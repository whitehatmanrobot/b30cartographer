turn fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample6Kto11K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev = lpPcm->pcm16Prev;
	short nCounter = lpPcm->nCounter;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		if (++nCounter == 6)
			nCounter = 0;

		switch(nCounter)
		{
			case 0:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(5, (pcm16Src - pcm16Prev), 11);
				*lppcm16Dst++ = pcm16Src;
				break;

			case 1:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(6, (pcm16Src - pcm16Prev), 11);
				break;

			case 2:
			{
				PCM16 pcm16Delta = pcm16Src - pcm16Prev;
				*lppcm16Dst++ = pcm16Prev +
					(pcm16Delta) / 11;
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(7, (pcm16Delta), 11);
			}
				break;

			case 3:
			{
				PCM16 pcm16Delta = pcm16Src - pcm16Prev;
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(2, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(8, (pcm16Delta), 11);
			}
				break;

			case 4:
			{
				PCM16 pcm16Delta = pcm16Src - pcm16Prev;
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(3, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(9, (pcm16Delta), 11);
			}
				break;

			case 5:
			{
				PCM16 pcm16Delta = pcm16Src - pcm16Prev;
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(4, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(10, (pcm16Delta), 11);
			}
				break;
		}
		pcm16Prev = pcm16Src;
	}

	lpPcm->pcm16Prev = pcm16Prev;
	lpPcm->nCounter = nCounter;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample6Kto22K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev = lpPcm->pcm16Prev;
	short nCounter = lpPcm->nCounter;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		if (++nCounter == 3)
			nCounter = 0;

		switch(nCounter)
		{
			case 0:
			{
				PCM16 pcm16Delta = pcm16Src - pcm16Prev;
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(2, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(5, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(8, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Src;
			}
				break;

			case 1:
			{
				PCM16 pcm16Delta = pcm16Src - pcm16Prev;
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(3, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(6, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(9, (pcm16Delta), 11);
			}
				break;

			case 2:
			{
				PCM16 pcm16Delta = pcm16Src - pcm16Prev;
				*lppcm16Dst++ = pcm16Prev +
					(pcm16Delta) / 11;
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(4, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(7, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(10, (pcm16Delta), 11);
			}
				break;
		}
		pcm16Prev = pcm16Src;
	}

	lpPcm->pcm16Prev = pcm16Prev;
	lpPcm->nCounter = nCounter;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample6Kto44K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev = lpPcm->pcm16Prev;
	short nCounter = lpPcm->nCounter;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		if (++nCounter == 3)
			nCounter = 0;

		switch(nCounter)
		{
			case 0:
			{
				PCM16 pcm16Delta = pcm16Src - pcm16Prev;
				*lppcm16Dst++ = pcm16Prev +
					(pcm16Delta) / 22;
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(4, (pcm16Delta), 22);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(7, (pcm16Delta), 22);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(10, (pcm16Delta), 22);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(13, (pcm16Delta), 22);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(16, (pcm16Delta), 22);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(19, (pcm16Delta), 22);
				*lppcm16Dst++ = pcm16Src;
			}
				break;

			case 1:
			{
				PCM16 pcm16Delta = pcm16Src - pcm16Prev;
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(3, (pcm16Delta), 22);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(6, (pcm16Delta), 22);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(9, (pcm16Delta), 22);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(12, (pcm16Delta), 22);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(15, (pcm16Delta), 22);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(18, (pcm16Delta), 22);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(21, (pcm16Delta), 22);
			}
				break;

			case 2:
			{
				PCM16 pcm16Delta = pcm16Src - pcm16Prev;
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(2, (pcm16Delta), 22);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(5, (pcm16Delta), 22);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(8, (pcm16Delta), 22);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(11, (pcm16Delta), 22);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(14, (pcm16Delta), 22);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(17, (pcm16Delta), 22);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(20, (pcm16Delta), 22);
			}
				break;
		}
		pcm16Prev = pcm16Src;
	}

	lpPcm->pcm16Prev = pcm16Prev;
	lpPcm->nCounter = nCounter;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample8Kto6K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev = lpPcm->pcm16Prev;
	short nCounter = lpPcm->nCounter;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		if (++nCounter == 4)
			nCounter = 0;

		switch(nCounter)
		{
			case 0:
				*lppcm16Dst++ = pcm16Src;
				break;

			case 1:
				break;

			case 2:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(2, (pcm16Src - pcm16Prev), 6);
				break;

			case 3:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(4, (pcm16Src - pcm16Prev), 6);
				break;
		}
		pcm16Prev = pcm16Src;
	}

	lpPcm->pcm16Prev = pcm16Prev;
	lpPcm->nCounter = nCounter;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample8Kto11K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev = lpPcm->pcm16Prev;
	short nCounter = lpPcm->nCounter;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		if (++nCounter == 8)
			nCounter = 0;

		switch(nCounter)
		{
			case 0:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(3, (pcm16Src - pcm16Prev), 11);
				*lppcm16Dst++ = pcm16Src;
				break;

			case 1:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(8, (pcm16Src - pcm16Prev), 11);
				break;

			case 2:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(5, (pcm16Src - pcm16Prev), 11);
				break;

			case 3:
			{
				PCM16 pcm16Delta = pcm16Src - pcm16Prev;
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(2, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(10, (pcm16Delta), 11);
			}
				break;

			case 4:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(7, (pcm16Src - pcm16Prev), 11);
				break;

			case 5:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(4, (pcm16Src - pcm16Prev), 11);
				break;

			case 6:
			{
				PCM16 pcm16Delta = pcm16Src - pcm16Prev;
				*lppcm16Dst++ = pcm16Prev +
					(pcm16Delta) / 11;
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(9, (pcm16Delta), 11);
			}
				break;

			case 7:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(6, (pcm16Src - pcm16Prev), 11);
				break;
		}
		pcm16Prev = pcm16Src;
	}

	lpPcm->pcm16Prev = pcm16Prev;
	lpPcm->nCounter = nCounter;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample8Kto22K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev = lpPcm->pcm16Prev;
	short nCounter = lpPcm->nCounter;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		if (++nCounter == 4)
			nCounter = 0;

		switch(nCounter)
		{
			case 0:
			{
				PCM16 pcm16Delta = pcm16Src - pcm16Prev;
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(3, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(7, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Src;
			}
				break;

			case 1:
			{
				PCM16 pcm16Delta = pcm16Src - pcm16Prev;
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(4, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(8, (pcm16Delta), 11);
			}
				break;

			case 2:
			{
				PCM16 pcm16Delta = pcm16Src - pcm16Prev;
				*lppcm16Dst++ = pcm16Prev +
					(pcm16Delta) / 11;
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(5, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(9, (pcm16Delta), 11);
			}
				break;

			case 3:
			{
				PCM16 pcm16Delta = pcm16Src - pcm16Prev;
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(2, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(6, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(10, (pcm16Delta), 11);
			}
				break;
		}
		pcm16Prev = pcm16Src;
	}

	lpPcm->pcm16Prev = pcm16Prev;
	lpPcm->nCounter = nCounter;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample8Kto44K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev = lpPcm->pcm16Prev;
	short nCounter = lpPcm->nCounter;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		if (++nCounter == 2)
			nCounter = 0;

		switch(nCounter)
		{
			case 0:
			{
				PCM16 pcm16Delta = pcm16Src - pcm16Prev;
				*lppcm16Dst++ = pcm16Prev +
					(pcm16Delta) / 11;
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(3, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(5, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(7, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(9, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Src;
			}
				break;

			case 1:
			{
				PCM16 pcm16Delta = pcm16Src - pcm16Prev;
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(2, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(4, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(6, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(8, (pcm16Delta), 11);
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(10, (pcm16Delta), 11);
			}
				break;
		}
		pcm16Prev = pcm16Src;
	}

	lpPcm->pcm16Prev = pcm16Prev;
	lpPcm->nCounter = nCounter;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample11Kto6K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev = lpPcm->pcm16Prev;
	short nCounter = lpPcm->nCounter;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		if (++nCounter == 11)
			nCounter = 0;

		switch(nCounter)
		{
			case 0:
				*lppcm16Dst++ = pcm16Src;
				break;

			case 1:
				break;

			case 2:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(5, (pcm16Src - pcm16Prev), 6);
				break;

			case 3:
				break;

			case 4:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(4, (pcm16Src - pcm16Prev), 6);
				break;

			case 5:
				break;

			case 6:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(3, (pcm16Src - pcm16Prev), 6);
				break;

			case 7:
				break;

			case 8:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(2, (pcm16Src - pcm16Prev), 6);
				break;

			case 9:
				break;

			case 10:
				*lppcm16Dst++ = pcm16Prev +
					(pcm16Src - pcm16Prev) / 6;
				break;
		}
		pcm16Prev = pcm16Src;
	}

	lpPcm->pcm16Prev = pcm16Prev;
	lpPcm->nCounter = nCounter;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample11Kto8K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev = lpPcm->pcm16Prev;
	short nCounter = lpPcm->nCounter;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		if (++nCounter == 11)
			nCounter = 0;

		switch(nCounter)
		{
			case 0:
				*lppcm16Dst++ = pcm16Src;
				break;

			case 1:
				break;

			case 2:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(3, (pcm16Src - pcm16Prev), 8);
				break;

			case 3:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(6, (pcm16Src - pcm16Prev), 8);
				break;

			case 4:
				break;

			case 5:
				*lppcm16Dst++ = pcm16Prev +
					(pcm16Src - pcm16Prev) / 8;
				break;

			case 6:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(4, (pcm16Src - pcm16Prev), 8);
				break;

			case 7:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(7, (pcm16Src - pcm16Prev), 8);
				break;

			case 8:
				break;

			case 9:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(2, (pcm16Src - pcm16Prev), 8);
				break;

			case 10:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(5, (pcm16Src - pcm16Prev), 8);
				break;
		}
		pcm16Prev = pcm16Src;
	}

	lpPcm->pcm16Prev = pcm16Prev;
	lpPcm->nCounter = nCounter;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample11Kto22K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev = lpPcm->pcm16Prev;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		*lppcm16Dst++ = pcm16Prev +
			(pcm16Src - pcm16Prev) / 2;
		*lppcm16Dst++ = pcm16Src;
		pcm16Prev = pcm16Src;
	}

	lpPcm->pcm16Prev = pcm16Prev;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample11Kto44K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev = lpPcm->pcm16Prev;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		*lppcm16Dst++ = pcm16Prev +
			(pcm16Src - pcm16Prev) / 4;
		*lppcm16Dst++ = pcm16Prev +
			MULDIV16(2, (pcm16Src - pcm16Prev), 4);
		*lppcm16Dst++ = pcm16Prev +
			MULDIV16(3, (pcm16Src - pcm16Prev), 4);
		*lppcm16Dst++ = pcm16Src;
		pcm16Prev = pcm16Src;
	}

	lpPcm->pcm16Prev = pcm16Prev;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample22Kto6K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev = lpPcm->pcm16Prev;
	short nCounter = lpPcm->nCounter;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		if (++nCounter == 11)
			nCounter = 0;

		switch(nCounter)
		{
			case 0:
				*lppcm16Dst++ = pcm16Src;
				break;

			case 1:
				break;

			case 2:
				break;

			case 3:
				break;

			case 4:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(2, (pcm16Src - pcm16Prev), 3);
				break;

			case 5:
				break;

			case 6:
				break;

			case 7:
				break;

			case 8:
				*lppcm16Dst++ = pcm16Prev +
					(pcm16Src - pcm16Prev) / 3;
				break;

			case 9:
				break;

			case 10:
				break;
		}
		pcm16Prev = pcm16Src;
	}

	lpPcm->pcm16Prev = pcm16Prev;
	lpPcm->nCounter = nCounter;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample22Kto8K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev = lpPcm->pcm16Prev;
	short nCounter = lpPcm->nCounter;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		if (++nCounter == 11)
			nCounter = 0;

		switch(nCounter)
		{
			case 0:
				*lppcm16Dst++ = pcm16Src;
				break;

			case 1:
				break;

			case 2:
				break;

			case 3:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(3, (pcm16Src - pcm16Prev), 4);
				break;

			case 4:
				break;

			case 5:
				break;

			case 6:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(2, (pcm16Src - pcm16Prev), 4);
				break;

			case 7:
				break;

			case 8:
				break;

			case 9:
				*lppcm16Dst++ = pcm16Prev +
					(pcm16Src - pcm16Prev) / 4;
				break;

			case 10:
				break;
		}
		pcm16Prev = pcm16Src;
	}

	lpPcm->pcm16Prev = pcm16Prev;
	lpPcm->nCounter = nCounter;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample22Kto11K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev = lpPcm->pcm16Prev;
	short nCounter = lpPcm->nCounter;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		if (++nCounter == 2)
			nCounter = 0;

		switch(nCounter)
		{
			case 0:
				break;

			case 1:
				*lppcm16Dst++ = pcm16Prev +
					(pcm16Src - pcm16Prev) / 2;
				break;
		}
		pcm16Prev = pcm16Src;
	}

	lpPcm->pcm16Prev = pcm16Prev;
	lpPcm->nCounter = nCounter;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample22Kto44K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev = lpPcm->pcm16Prev;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		*lppcm16Dst++ = pcm16Prev +
			(pcm16Src - pcm16Prev) / 2;
		*lppcm16Dst++ = pcm16Src;
		pcm16Prev = pcm16Src;
	}

	lpPcm->pcm16Prev = pcm16Prev;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample44Kto6K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev = lpPcm->pcm16Prev;
	short nCounter = lpPcm->nCounter;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		if (++nCounter == 22)
			nCounter = 0;

		switch(nCounter)
		{
			case 0:
				*lppcm16Dst++ = pcm16Src;
				break;

			case 1:
				break;

			case 2:
				break;

			case 3:
				break;

			case 4:
				break;

			case 5:
				break;

			case 6:
				break;

			case 7:
				break;

			case 8:
				*lppcm16Dst++ = pcm16Prev +
					(pcm16Src - pcm16Prev) / 3;
				break;

			case 9:
				break;

			case 10:
				break;

			case 11:
				break;

			case 12:
				break;

			case 13:
				break;

			case 14:
				break;

			case 15:
				*lppcm16Dst++ = pcm16Prev +
					MULDIV16(2, (pcm16Src - pcm16Prev), 3);
				break;

			case 16:
				break;

			case 17:
				break;

			case 18:
				break;

			case 19:
				break;

			case 20:
				break;

			case 21:
				break;
		}
		pcm16Prev = pcm16Src;
	}

	lpPcm->pcm16Prev = pcm16Prev;
	lpPcm->nCounter = nCounter;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample44Kto8K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev = lpPcm->pcm16Prev;
	short nCounter = lpPcm->nCounter;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		if (++nCounter == 11)
			nCounter = 0;

		switch(nCounter)
		{
			case 0:
				*lppcm16Dst++ = pcm16Src;
				break;

			case 1:
				break;

			case 2:
				break;

			case 3:
				break;

			case 4:
				break;

			case 5:
				break;

			case 6:
				*lppcm16Dst++ = pcm16Prev +
					(pcm16Src - pcm16Prev) / 2;
				break;

			case 7:
				break;

			case 8:
				break;

			case 9:
				break;

			case 10:
				break;
		}
		pcm16Prev = pcm16Src;
	}

	lpPcm->pcm16Prev = pcm16Prev;
	lpPcm->nCounter = nCounter;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample44Kto11K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev0 = lpPcm->pcm16Prev0;
	PCM16 pcm16Prev1 = lpPcm->pcm16Prev1;
	PCM16 pcm16Prev2 = lpPcm->pcm16Prev2;
	short nCounter = lpPcm->nCounter;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		if (++nCounter == 4)
			nCounter = 0;

		switch(nCounter)
		{
			case 0:
				pcm16Prev0 = pcm16Src;
				break;

			case 1:
				pcm16Prev1 = pcm16Src;
				break;

			case 2:
				pcm16Prev2 = pcm16Src;
				break;

			case 3:
				*lppcm16Dst++ = (PCM16) ((__int32) pcm16Prev0 +
					(__int32) pcm16Prev1 + (__int32) pcm16Prev2 +
					(__int32) pcm16Src) / 4;
				break;
		}
	}

	lpPcm->pcm16Prev0 = pcm16Prev0;
	lpPcm->pcm16Prev1 = pcm16Prev1;
	lpPcm->pcm16Prev2 = pcm16Prev2;
	lpPcm->nCounter = nCounter;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

static UINT PcmResample44Kto22K(LPPCM lpPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPPCM16 lppcm16DstSave = lppcm16Dst;
	PCM16 pcm16Prev = lpPcm->pcm16Prev;
	short nCounter = lpPcm->nCounter;

	while (uSamples-- > 0)
	{
		PCM16 pcm16Src = *lppcm16Src++;

		if (++nCounter == 2)
			nCounter = 0;

		switch(nCounter)
		{
			case 0:
				break;

			case 1:
				*lppcm16Dst++ = pcm16Prev +
					(pcm16Src - pcm16Prev) / 2;
				break;
		}
		pcm16Prev = pcm16Src;
	}

	lpPcm->pcm16Prev = pcm16Prev;
	lpPcm->nCounter = nCounter;

	return fSuccess ? (UINT) (lppcm16Dst - lppcm16DstSave) : 0;
}

// PcmGetPtr - verify that pcm handle is valid,
//		<hPcm>		(i) handle returned from PcmInit
// return corresponding pcm pointer (NULL if error)
//
static LPPCM PcmGetPtr(HPCM hPcm)
{
	BOOL fSuccess = TRUE;
	LPPCM lpPcm;

	if ((lpPcm = (LPPCM) hPcm) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpPcm, sizeof(PCM)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the pcm handle
	//
	else if (lpPcm->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpPcm : NULL;
}

// PcmGetHandle - verify that pcm pointer is valid,
//		<lpPcm>		(i) pointer to PCM struct
// return corresponding pcm handle (NULL if error)
//
static HPCM PcmGetHandle(LPPCM lpPcm)
{
	BOOL fSuccess = TRUE;
	HPCM hPcm;

	if ((hPcm = (HPCM) lpPcm) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hPcm : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\avwav\pcm.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// pcm.h - interface to pcm functions in pcm.c
////

#ifndef __PCM_H__
#define __PCM_H__

#include "winlocal.h"

#include "wavfmt.h"

#define PCM_VERSION 0x00000100

// handle to pcm engine
//
DECLARE_HANDLE32(HPCM);

// <dwFlags> param in PcmFilter and PcmConvert
//
#define PCMFILTER_LOWPASS		0x00000001

#ifdef __cplusplus
extern "C" {
#endif

// PcmInit - initialize pcm engine
//		<dwVersion>			(i) must be PCM_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<dwFlags>			(i) reserved; must be 0
// return handle (NULL if error)
//
HPCM DLLEXPORT WINAPI PcmInit(DWORD dwVersion, HINSTANCE hInst, DWORD dwFlags);

// PcmTerm - shut down pcm engine
//		<hPcm>				(i) handle returned from PcmInit
// return 0 if success
//
int DLLEXPORT WINAPI PcmTerm(HPCM hPcm);

// PcmReset - reset pcm engine
//		<hPcm>				(i) handle returned from PcmInit
// return 0 if success
//
int DLLEXPORT WINAPI PcmReset(HPCM hPcm);

// PcmCalcSizBufSrc - calculate source buffer size
//		<hPcm>				(i) handle returned from PcmInit
//		<sizBufDst>			(i) size of destination buffer in bytes
//		<lpwfxSrc>			(i) source wav format
//		<lpwfxDst>			(i) destination wav format
// return source buffer size, -1 if error
//
long DLLEXPORT WINAPI PcmCalcSizBufSrc(HPCM hPcm, long sizBufDst,
	LPWAVEFORMATEX lpwfxSrc, LPWAVEFORMATEX lpwfxDst);

// PcmCalcSizBufDst - calculate destination buffer size
//		<hPcm>				(i) handle returned from PcmInit
//		<sizBufSrc>			(i) size of source buffer in bytes
//		<lpwfxSrc>			(i) source wav format
//		<lpwfxDst>			(i) destination wav format
// return destination buffer size, -1 if error
//
long DLLEXPORT WINAPI PcmCalcSizBufDst(HPCM hPcm, long sizBufSrc,
	LPWAVEFORMATEX lpwfxSrc, LPWAVEFORMATEX lpwfxDst);

// PcmConvert - convert pcm data from one format to another
//		<hPcm>				(i) handle returned from PcmInit
//		<hpBufSrc> 			(i) buffer containing bytes to reformat
//		<sizBufSrc>			(i) size of buffer in bytes
//		<lpwfxSrc>			(i) source wav format
//		<hpBufDst> 			(o) buffer to contain new format
//		<sizBufDst>			(i) size of buffer in bytes
//		<lpwfxDst>			(i) destination wav format
//		<dwFlags>			(i) control flags
//			PCMFILTER_LOWPASS	perform lowpass filter
// return count of bytes in destination buffer (-1 if error)
//
// NOTE: the destination buffer must be large enough to hold the result
//
long DLLEXPORT WINAPI PcmConvert(HPCM hPcm,
	void _huge *hpBufSrc, long sizBufSrc, LPWAVEFORMATEX lpwfxSrc,
	void _huge *hpBufDst, long sizBufDst, LPWAVEFORMATEX lpwfxDst,
	DWORD dwFlags);

// Pcm16To8 - convert 16-bit samples to 8-bit samples
//		<hPcm>				(i) handle returned from PcmInit
//		<lppcm16Src>		(i) buffer of source samples
//		<lppcm8Dst>			(o) buffer to hold destination samples
//		<uSamples>			(i) count of source samples to convert
// return 0 if success
//
int DLLEXPORT WINAPI Pcm16To8(HPCM hPcm,
	LPPCM16 lppcm16Src, LPPCM8 lppcm8Dst, UINT uSamples);

// Pcm8To16 - convert 8-bit samples to 16-bit samples
//		<hPcm>				(i) handle returned from PcmInit
//		<lppcm8Src>			(i) buffer of source samples
//		<lppcm16Dst>		(o) buffer to hold destination samples
//		<uSamples>			(i) count of source samples to convert
// return 0 if success
//
int DLLEXPORT WINAPI Pcm8To16(HPCM hPcm,
	LPPCM8 lppcm8Src, LPPCM16 lppcm16Dst, UINT uSamples);

// PcmFilter - filter pcm samples
//		<hPcm>				(i) handle returned from PcmInit
//		<lppcm16Src>		(i) buffer of source samples
//		<lppcm16Dst>		(o) buffer to hold destination samples
//		<uSamples>			(i) count of source samples to filter
//		<dwFlags>			(i) control flags
//			PCMFILTER_LOWPASS	perform a low pass filter
// return 0 if success
//
// NOTE: <lppcm16Src> and <lppcm16Dst> can point to the same buffer
//
int DLLEXPORT WINAPI PcmFilter(HPCM hPcm,
	LPPCM16 lppcm16Src, LPPCM16 lppcm16Dst, UINT uSamples, DWORD dwFlags);

// PcmResample - resample pcm samples
//		<hPcm>				(i) handle returned from PcmInit
//		<lppcm16Src>		(i) buffer of source samples
//		<nSamplesPerSecSrc>	(i) sample rate of source samples
//		<lppcm16Dst>		(o) buffer to hold destination samples
//		<nSamplesPerSecDst>	(i) sample rate of destination samples
//		<uSamples>			(i) count of source samples to resample
//		<dwFlags>			(i) control flags
//			0					reserved, must be zero
// return count of samples in destination buffer (0 if error)
//
// NOTE: the destination buffer must be large enough to hold the result.
// Call PcmResampleCalcDstMax() to calculate max destination samples
//
UINT DLLEXPORT WINAPI PcmResample(HPCM hPcm,
	LPPCM16 lppcm16Src, long nSamplesPerSecSrc,
	LPPCM16 lppcm16Dst, long nSamplesPerSecDst,
	UINT uSamples, DWORD dwFlags);

#ifdef __cplusplus
}
#endif

#endif // __PCM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\avwav\propio.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	propio.cpp - property i/o functions
////

#include "winlocal.h"

#include <mmsystem.h>

#include <mapi.h>
#include <mapidefs.h>

#include "propio.h"
#include "trace.h"
#include "str.h"

////
//	private definitions
////

// helper functions
//
static LRESULT PropIOOpen(LPMMIOINFO lpmmioinfo, LPTSTR lpszFileName);
static LRESULT PropIOClose(LPMMIOINFO lpmmioinfo, UINT uFlags);
static LRESULT PropIORead(LPMMIOINFO lpmmioinfo, HPSTR pch, LONG cch);
static LRESULT PropIOWrite(LPMMIOINFO lpmmioinfo, const HPSTR pch, LONG cch, BOOL fFlush);
static LRESULT PropIOSeek(LPMMIOINFO lpmmioinfo, LONG lOffset, int iOrigin);
static LRESULT PropIORename(LPMMIOINFO lpmmioinfo, LPCTSTR lpszFileName, LPCTSTR lpszNewFileName);

////
//	public functions
////

// PropIOProc - i/o procedure for property data
//		<lpmmioinfo>		(i/o) information about open file
//		<uMessage>			(i) message indicating the requested I/O operation
//		<lParam1>			(i) message specific parameter
//		<lParam2>			(i) message specific parameter
// returns 0 if message not recognized, otherwise message specific value
//
// NOTE: the address of this function should be passed to the WavOpen()
// or mmioInstallIOProc() functions for accessing property data.
//
LRESULT DLLEXPORT CALLBACK PropIOProc(LPSTR lpmmioinfo,
	UINT uMessage, LPARAM lParam1, LPARAM lParam2)
{
	BOOL fSuccess = TRUE;
	LRESULT lResult = 0;

	if (lpmmioinfo == NULL)
		fSuccess = TraceFALSE(NULL);

	else switch (uMessage)
	{
		case MMIOM_OPEN:
			lResult = PropIOOpen((LPMMIOINFO) lpmmioinfo,
				(LPTSTR) lParam1);
			break;

		case MMIOM_CLOSE:
			lResult = PropIOClose((LPMMIOINFO) lpmmioinfo,
				(UINT) lParam1);
			break;

		case MMIOM_READ:
			lResult = PropIORead((LPMMIOINFO) lpmmioinfo,
				(HPSTR) lParam1, (LONG) lParam2);
			break;

		case MMIOM_WRITE:
			lResult = PropIOWrite((LPMMIOINFO) lpmmioinfo,
				(const HPSTR) lParam1, (LONG) lParam2, FALSE);
			break;

		case MMIOM_WRITEFLUSH:
			lResult = PropIOWrite((LPMMIOINFO) lpmmioinfo,
				(const HPSTR) lParam1, (LONG) lParam2, TRUE);
			break;

		case MMIOM_SEEK:
			lResult = PropIOSeek((LPMMIOINFO) lpmmioinfo,
				(LONG) lParam1, (int) lParam2);
			break;

		case MMIOM_RENAME:
			lResult = PropIORename((LPMMIOINFO) lpmmioinfo,
				(LPCTSTR) lParam1, (LPCTSTR) lParam2);
			break;

		default:
			lResult = 0;
			break;
	}

	return lResult;
}

////
//	installable file i/o procedures
////

static LRESULT PropIOOpen(LPMMIOINFO lpmmioinfo, LPTSTR lpszFileName)
{
	BOOL fSuccess = TRUE;
	LPMESSAGE lpmsg;
	ULONG ulPropTag;
	ULONG ulFlags = 0L;
	HRESULT hr;
	IID IID_IStream;
	LPSTREAM lpStream;

 	TracePrintf_0(NULL, 5,
 		TEXT("PropIOOpen\n"));

	// convert MMIOINFO flags to equivalent OpenProperty flags
	//
	if (lpmmioinfo->dwFlags & MMIO_CREATE)
		ulFlags |= MAPI_CREATE | MAPI_MODIFY;
	if (lpmmioinfo->dwFlags & MMIO_READWRITE)
		ulFlags |= MAPI_MODIFY;

	// message pointer is within first element of info array
	//
	if ((lpmsg = (LPMESSAGE) lpmmioinfo->adwInfo[0]) == NULL)
		fSuccess = TraceFALSE(NULL);

	// property id is within second element of info array
	//
	else if ((ulPropTag = (ULONG) lpmmioinfo->adwInfo[1]) == (ULONG) 0)
		fSuccess = TraceFALSE(NULL);

	// open the property
	//
	else if ((hr = lpmsg->OpenProperty(ulPropTag, (LPCIID) &IID_IStream, 0,
		ulFlags, (LPUNKNOWN *) &lpStream)) != S_OK)
	{
		fSuccess = TraceFALSE(NULL);
	 	TracePrintf_1(NULL, 5,
	 		TEXT("OpenProperty failed (%ld)\n"),
	 		(long) hr);
	}

	else
	{
		// save stream pointer for use in other i/o routines
		//
		lpmmioinfo->adwInfo[0] = (DWORD) (LPVOID) lpStream;
	}

	// return the same error code given by mmioOpen
	//
	return fSuccess ? lpmmioinfo->wErrorRet = 0 : MMIOERR_CANNOTOPEN;
}

static LRESULT PropIOClose(LPMMIOINFO lpmmioinfo, UINT uFlags)
{
	BOOL fSuccess = TRUE;
	LPSTREAM lpStream = (LPSTREAM) lpmmioinfo->adwInfo[0];
	UINT uRet = MMIOERR_CANNOTCLOSE;

 	TracePrintf_0(NULL, 5,
 		TEXT("PropIOClose\n"));

	// close the stream
	//
	if (lpStream->Release() < 0)
	{
		fSuccess = TraceFALSE(NULL);
	 	TracePrintf_0(NULL, 5,
	 		TEXT("Stream:Close failed\n"));
	}

	else
	{
		lpmmioinfo->adwInfo[0] = (DWORD) NULL;
	}

	return fSuccess ? 0 : uRet;
}

static LRESULT PropIORead(LPMMIOINFO lpmmioinfo, HPSTR pch, LONG cch)
{
	BOOL fSuccess = TRUE;
	LPSTREAM lpStream = (LPSTREAM) lpmmioinfo->adwInfo[0];
	HRESULT hr;
	LONG lBytesRead = 0L;

 	TracePrintf_1(NULL, 5,
 		TEXT("PropIORead (%ld)\n"),
		(long) cch);

	if (cch <= 0)
		lBytesRead = 0; // nothing to do

	// read
	//
	else if ((hr = lpStream->Read((LPVOID) pch,
		(ULONG) cch, (ULONG FAR *) &lBytesRead)) != S_OK)
	{
		fSuccess = TraceFALSE(NULL);
	 	TracePrintf_2(NULL, 5,
	 		TEXT("IStream:Read failed (%ld, %ld)\n"),
	 		(long) hr,
			(long) lBytesRead);
	}

	// update simulated file position
	//
	else
		lpmmioinfo->lDiskOffset += (LONG) lBytesRead;

 	TracePrintf_2(NULL, 5,
 		TEXT("PropIO: lpmmioinfo->lDiskOffset=%ld, lBytesRead=%ld\n"),
		(long) lpmmioinfo->lDiskOffset,
		(long) lBytesRead);

	// return number of bytes read
	//
	return fSuccess ? lBytesRead : -1;
}

static LRESULT PropIOWrite(LPMMIOINFO lpmmioinfo, const HPSTR pch, LONG cch, BOOL fFlush)
{
	BOOL fSuccess = TRUE;
	LPSTREAM lpStream = (LPSTREAM) lpmmioinfo->adwInfo[0];
	HRESULT hr;
	LONG lBytesWritten;

 	TracePrintf_1(NULL, 5,
 		TEXT("PropIOWrite (%ld)\n"),
		(long) cch);

	if (cch <= 0)
		lBytesWritten = 0; // nothing to do

	// write
	//
	else if ((hr = lpStream->Write((LPVOID) pch,
		(ULONG) cch, (ULONG FAR *) &lBytesWritten)) != S_OK)
	{
		fSuccess = TraceFALSE(NULL);
	 	TracePrintf_2(NULL, 5,
	 		TEXT("IStream:Write failed (%ld, %ld)\n"),
	 		(long) hr,
			(long) lBytesWritten);
	}

	// update file position
	//
	else
		lpmmioinfo->lDiskOffset += lBytesWritten;

 	TracePrintf_2(NULL, 5,
 		TEXT("PropIO: lpmmioinfo->lDiskOffset=%ld, lBytesWritten=%ld\n"),
		(long) lpmmioinfo->lDiskOffset,
		(long) lBytesWritten);

	// return number of bytes written
	//
	return fSuccess ? lBytesWritten : -1;
}

static LRESULT PropIOSeek(LPMMIOINFO lpmmioinfo, LONG lOffset, int iOrigin)
{
	BOOL fSuccess = TRUE;
	LPSTREAM lpStream = (LPSTREAM) lpmmioinfo->adwInfo[0];
	HRESULT hr;
	LARGE_INTEGER largeOffset;
	ULARGE_INTEGER ulargePosNew;

	largeOffset.LowPart = (DWORD) lOffset;
	largeOffset.HighPart = (DWORD) 0L;

 	TracePrintf_2(NULL, 5,
 		TEXT("PropIOSeek (%ld, %d)\n"),
		(long) lOffset,
		(int) iOrigin);

	// seek
	//
	if ((hr = lpStream->Seek(largeOffset,
		(DWORD) iOrigin, &ulargePosNew)) != S_OK)
	{
		fSuccess = TraceFALSE(NULL);
	 	TracePrintf_1(NULL, 5,
	 		TEXT("IStream:Seek failed (%ld)\n"),
	 		(long) hr);
	}

	// update file position
	//
	else
		lpmmioinfo->lDiskOffset = (long) ulargePosNew.LowPart;

 	TracePrintf_1(NULL, 5,
 		TEXT("PropIO: lpmmioinfo->lDiskOffset=%ld\n"),
		(long) lpmmioinfo->lDiskOffset);

	return fSuccess ? lpmmioinfo->lDiskOffset : -1;
}

static LRESULT PropIORename(LPMMIOINFO lpmmioinfo, LPCTSTR lpszFileName, LPCTSTR lpszNewFileName)
{
	BOOL fSuccess = TRUE;
	UINT uRet = MMIOERR_FILENOTFOUND;

 	TracePrintf_2(NULL, 5,
 		TEXT("PropIORename (%s, %s)\n"),
		(LPTSTR) lpszFileName,
		(LPTSTR) lpszNewFileName);

	// rename is not supported by this i/o procedure
	//
	if (TRUE)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : uRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\avwav\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by avwav.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\avwav\propio.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// propio.h - interface to property i/o functions in propio.c
////

#ifndef __PROPIO_H__
#define __PROPIO_H__

#include "winlocal.h"

#ifdef __cplusplus
extern "C" {
#endif

// PropIOProc - i/o procedure for property data
//		<lpmmioinfo>		(i/o) information about open file
//		<uMessage>			(i) message indicating the requested I/O operation
//		<lParam1>			(i) message specific parameter
//		<lParam2>			(i) message specific parameter
// returns 0 if message not recognized, otherwise message specific value
//
// NOTE: the address of this function should be passed to the WavOpen()
// or mmioInstallIOProc() functions for accessing property data.
//
LRESULT DLLEXPORT CALLBACK PropIOProc(LPSTR lpmmioinfo,
	UINT uMessage, LPARAM lParam1, LPARAM lParam2);

#ifdef __cplusplus
}
#endif

#endif // __PROPIO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\avwav\sockio.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	sockio.c - winsock i/o functions
////

#include "winlocal.h"

#include <mmsystem.h>
#include <winsock.h>

#include "sockio.h"
#include "trace.h"
#include "str.h"

////
//	private definitions
////

// sock control struct
//
typedef struct SOCK
{
	WSADATA wsaData;
	LPTSTR lpszServerName;
	unsigned short uPort;
	SOCKADDR_IN sin;
	SOCKET iSocket;
} SOCK, FAR *LPSOCK;

#define PORT_DEFAULT 1024

// helper functions
//
static LRESULT SockIOOpen(LPMMIOINFO lpmmioinfo, LPTSTR lpszFileName);
static LRESULT SockIOClose(LPMMIOINFO lpmmioinfo, UINT uFlags);
static LRESULT SockIORead(LPMMIOINFO lpmmioinfo, HPSTR pch, LONG cch);
static LRESULT SockIOWrite(LPMMIOINFO lpmmioinfo, const HPSTR pch, LONG cch, BOOL fFlush);
static LRESULT SockIOSeek(LPMMIOINFO lpmmioinfo, LONG lOffset, int iOrigin);
static LRESULT SockIORename(LPMMIOINFO lpmmioinfo, LPCTSTR lpszFileName, LPCTSTR lpszNewFileName);

////
//	public functions
////

// SockIOProc - i/o procedure for winsock data
//		<lpmmioinfo>		(i/o) information about open file
//		<uMessage>			(i) message indicating the requested I/O operation
//		<lParam1>			(i) message specific parameter
//		<lParam2>			(i) message specific parameter
// returns 0 if message not recognized, otherwise message specific value
//
// NOTE: the address of this function should be passed to the WavOpen()
// or mmioInstallIOProc() functions for accessing property data.
//
LRESULT DLLEXPORT CALLBACK SockIOProc(LPSTR lpmmioinfo,
	UINT uMessage, LPARAM lParam1, LPARAM lParam2)
{
	BOOL fSuccess = TRUE;
	LRESULT lResult = 0;

	if (lpmmioinfo == NULL)
		fSuccess = TraceFALSE(NULL);

	else switch (uMessage)
	{
		case MMIOM_OPEN:
			lResult = SockIOOpen((LPMMIOINFO) lpmmioinfo,
				(LPTSTR) lParam1);
			break;

		case MMIOM_CLOSE:
			lResult = SockIOClose((LPMMIOINFO) lpmmioinfo,
				(UINT) lParam1);
			break;

		case MMIOM_READ:
			lResult = SockIORead((LPMMIOINFO) lpmmioinfo,
				(HPSTR) lParam1, (LONG) lParam2);
			break;

		case MMIOM_WRITE:
			lResult = SockIOWrite((LPMMIOINFO) lpmmioinfo,
				(const HPSTR) lParam1, (LONG) lParam2, FALSE);
			break;

		case MMIOM_WRITEFLUSH:
			lResult = SockIOWrite((LPMMIOINFO) lpmmioinfo,
				(const HPSTR) lParam1, (LONG) lParam2, TRUE);
			break;

		case MMIOM_SEEK:
			lResult = SockIOSeek((LPMMIOINFO) lpmmioinfo,
				(LONG) lParam1, (int) lParam2);
			break;

		case MMIOM_RENAME:
			lResult = SockIORename((LPMMIOINFO) lpmmioinfo,
				(LPCTSTR) lParam1, (LPCTSTR) lParam2);
			break;

		default:
			lResult = 0;
			break;
	}

	return lResult;
}

////
//	installable file i/o procedures
////

static LRESULT SockIOOpen(LPMMIOINFO lpmmioinfo, LPTSTR lpszFileName)
{
	BOOL fSuccess = TRUE;
	int nRet;
	LPSOCK lpSock = NULL;
	LPTSTR lpsz;

 	TracePrintf_0(NULL, 5,
 		TEXT("SockIOOpen\n"));

	// convert MMIOINFO flags to equivalent socket flags
	//
	if (lpmmioinfo->dwFlags & MMIO_CREATE)
		;
	if (lpmmioinfo->dwFlags & MMIO_READWRITE)
		;

	// server name pointer is first element of info array
	//
	if ((LPTSTR) lpmmioinfo->adwInfo[0] == NULL)
		fSuccess = TraceFALSE(NULL);

	// allocate control struct
	//
	else if ((lpSock = (LPSOCK) GlobalAllocPtr(GMEM_MOVEABLE |
		GMEM_ZEROINIT, sizeof(SOCK))) == NULL)
	{
		fSuccess = TraceFALSE(NULL);
	}

	// initialize Windows Sockets DLL, requesting v1.1 compatibility
	//
	else if ((nRet = WSAStartup(0x0101, &lpSock->wsaData)) != 0)
	{
		fSuccess = TraceFALSE(NULL);
	 	TracePrintf_1(NULL, 5,
	 		TEXT("WSAStartup failed (%d)\n"),
	 		(int) nRet);
	}

	// Confirm that the Windows Sockets DLL supports winsock v1.1
	//
	else if (LOBYTE(lpSock->wsaData.wVersion) != 1 ||
			HIBYTE(lpSock->wsaData.wVersion) != 1)
	{
		fSuccess = TraceFALSE(NULL);
	 	TracePrintf_0(NULL, 5,
	 		TEXT("Winsock is not v1.1 compatible\n"));
	}

	// save copy of server name
	//
	else if ((lpSock->lpszServerName =
		(LPTSTR) StrDup((LPTSTR) lpmmioinfo->adwInfo[0])) == NULL)
		fSuccess = TraceFALSE(NULL);

	// parse out port number if present (servername:port)
	//
	else if ((lpsz = StrRChr(lpSock->lpszServerName, ':')) != NULL)
	{
		*lpsz = '\0';
		lpSock->uPort = (unsigned int) StrAtoI(lpsz + 1);
	}

	// otherwise assume default port
	//
	else
		lpSock->uPort = PORT_DEFAULT;

	// construct server's socket address struct
	//
	if (fSuccess)
	{
		LPHOSTENT lpHostEnt = NULL;

		// address family must be internetwork: UDP, TCP, etc.
		//
		lpSock->sin.sin_family = AF_INET;

		// convert port from host byte order to network byte order
		//
		lpSock->sin.sin_port = htons(lpSock->uPort);

		// if servername contains anything other than digits and periods
		//
		if (StrSpn(lpSock->lpszServerName, TEXT(".0123456789")) !=
			StrLen(lpSock->lpszServerName))
		{
			// try to resolve with DNS
			//
			if ((lpHostEnt = gethostbyname(lpSock->lpszServerName)) == NULL)
			{
			 	TracePrintf_2(NULL, 5,
		 			TEXT("gethostbyname(%s) failed (%d)\n"),
					(LPTSTR) lpSock->lpszServerName,
					(int) WSAGetLastError());
			}

		 	// store resolved address
		 	//
			else
			{
				lpSock->sin.sin_addr.s_addr =
					*((LPDWORD) lpHostEnt->h_addr);
			}		
		}

		// if servername contains only digits and periods,
		// or if gethostbyname() failed, convert address string to binary
		//
		if (lpHostEnt == NULL)
		{
		    if ((lpSock->sin.sin_addr.s_addr =
				inet_addr(lpSock->lpszServerName)) == INADDR_NONE)
			{
				fSuccess = TraceFALSE(NULL);
			 	TracePrintf_1(NULL, 5,
		 			TEXT("inet_addr(%s) failed\n"),
					(LPTSTR) lpSock->lpszServerName);
			}
		}
	}

	if (fSuccess)
	{
		LINGER l;

		l.l_onoff = 1;
		l.l_linger = 0;

		// create a socket
		//
		if ((lpSock->iSocket = socket(PF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
		 		TEXT("socket() failed (%d)\n"),
				(int) WSAGetLastError());
		}

		// establish a socket connection to server
		//
		else if (connect(lpSock->iSocket, (LPSOCKADDR) &lpSock->sin,
			sizeof(lpSock->sin)) == SOCKET_ERROR)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
		 		TEXT("connect() failed (%d)\n"),
				(int) WSAGetLastError());
		}

		// enable SO_LINGER option so that closesocket() will discard
		// unsent data rather than block until queued data is sent
		//
		else if (setsockopt(lpSock->iSocket, SOL_SOCKET, SO_LINGER,
			(LPVOID) &l, sizeof(l)) == SOCKET_ERROR)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
		 		TEXT("setsockopt(SO_LINGER) failed (%d)\n"),
				(int) WSAGetLastError());
		}
	}

	if (fSuccess)
	{
		// save socket control struct pointer for use in other i/o routines
		//
		lpmmioinfo->adwInfo[0] = (DWORD) (LPVOID) lpSock;
	}

	// return the same error code given by mmioOpen
	//
	return fSuccess ? lpmmioinfo->wErrorRet = 0 : MMIOERR_CANNOTOPEN;
}

static LRESULT SockIOClose(LPMMIOINFO lpmmioinfo, UINT uFlags)
{
	BOOL fSuccess = TRUE;
	LPSOCK lpSock = (LPSOCK) lpmmioinfo->adwInfo[0];
	UINT uRet = MMIOERR_CANNOTCLOSE;

 	TracePrintf_0(NULL, 5,
 		TEXT("SockIOClose\n"));

	// cancel any blocking call if necessary
	//
	if (WSAIsBlocking() && WSACancelBlockingCall() == SOCKET_ERROR)
	{
		fSuccess = TraceFALSE(NULL);
		TracePrintf_1(NULL, 5,
	 		TEXT("WSACancelBlockingCall() failed (%d)\n"),
			(int) WSAGetLastError());
	}

	// close the socket
	//
	else if (lpSock->iSocket != INVALID_SOCKET &&
		closesocket(lpSock->iSocket) == SOCKET_ERROR)
	{
		fSuccess = TraceFALSE(NULL);
		TracePrintf_1(NULL, 5,
	 		TEXT("closesocket() failed (%d)\n"),
			(int) WSAGetLastError());
	}

	else
		lpSock->iSocket = INVALID_SOCKET;

	if (fSuccess)
	{
		// free server name buffer
		//
		if (lpSock->lpszServerName != NULL &&
			StrDupFree(lpSock->lpszServerName) != 0)
		{
			fSuccess = TraceFALSE(NULL);
		}

		else
			lpSock->lpszServerName = NULL;
	}

	if (fSuccess)
	{
		lpmmioinfo->adwInfo[0] = (DWORD) NULL;
	}

	return fSuccess ? 0 : uRet;
}

static LRESULT SockIORead(LPMMIOINFO lpmmioinfo, HPSTR pch, LONG cch)
{
	BOOL fSuccess = TRUE;
	LPSOCK lpSock = (LPSOCK) lpmmioinfo->adwInfo[0];
	int nBytesRead;

 	TracePrintf_1(NULL, 5,
 		TEXT("SockIORead (%ld)\n"),
		(long) cch);

	if (cch <= 0)
		nBytesRead = 0; // nothing to do

	// read
	//
	else if ((nBytesRead = recv(lpSock->iSocket,
		(LPVOID) pch, (int) cch, 0)) == SOCKET_ERROR)
	{
		fSuccess = TraceFALSE(NULL);
		TracePrintf_1(NULL, 5,
	 		TEXT("recv() failed (%d)\n"),
			(int) WSAGetLastError());
	}

	// update simulated file position
	//
	else
		lpmmioinfo->lDiskOffset += (LONG) nBytesRead;

 	TracePrintf_2(NULL, 5,
 		TEXT("SockIO: lpmmioinfo->lDiskOffset=%ld, lBytesRead=%ld\n"),
		(long) lpmmioinfo->lDiskOffset,
		(long) nBytesRead);

	// return number of bytes read
	//
	return fSuccess ? (LRESULT) nBytesRead : -1;
}

static LRESULT SockIOWrite(LPMMIOINFO lpmmioinfo, const HPSTR pch, LONG cch, BOOL fFlush)
{
	BOOL fSuccess = TRUE;
	LPSOCK lpSock = (LPSOCK) lpmmioinfo->adwInfo[0];
	int nBytesWritten;

 	TracePrintf_1(NULL, 5,
 		TEXT("SockIOWrite (%ld)\n"),
		(long) cch);

	if (cch <= 0)
		nBytesWritten = 0; // nothing to do

	// write
	//
	else if ((nBytesWritten = send(lpSock->iSocket,
		(LPVOID) pch, (int) cch, 0)) == SOCKET_ERROR)
	{
		fSuccess = TraceFALSE(NULL);
		TracePrintf_1(NULL, 5,
	 		TEXT("send() failed (%d)\n"),
			(int) WSAGetLastError());
	}

	// update file position
	//
	else
		lpmmioinfo->lDiskOffset += (LONG) nBytesWritten;

 	TracePrintf_2(NULL, 5,
 		TEXT("SockIO: lpmmioinfo->lDiskOffset=%ld, lBytesWritten=%ld\n"),
		(long) lpmmioinfo->lDiskOffset,
		(long) nBytesWritten);

	// return number of bytes written
	//
	return fSuccess ? (LRESULT) nBytesWritten : -1;
}

static LRESULT SockIOSeek(LPMMIOINFO lpmmioinfo, LONG lOffset, int iOrigin)
{
	BOOL fSuccess = TRUE;
	LPSOCK lpSock = (LPSOCK) lpmmioinfo->adwInfo[0];

 	TracePrintf_2(NULL, 5,
 		TEXT("SockIOSeek (%ld, %d)\n"),
		(long) lOffset,
		(int) iOrigin);

	// seek is not supported by this i/o procedure
	//
	if (TRUE)
		fSuccess = TraceFALSE(NULL);

 	TracePrintf_1(NULL, 5,
 		TEXT("SockIO: lpmmioinfo->lDiskOffset=%ld\n"),
		(long) lpmmioinfo->lDiskOffset);

	return fSuccess ? lpmmioinfo->lDiskOffset : -1;
}

static LRESULT SockIORename(LPMMIOINFO lpmmioinfo, LPCTSTR lpszFileName, LPCTSTR lpszNewFileName)
{
	BOOL fSuccess = TRUE;
	UINT uRet = MMIOERR_FILENOTFOUND;

 	TracePrintf_2(NULL, 5,
 		TEXT("SockIORename (%s, %s)\n"),
		(LPTSTR) lpszFileName,
		(LPTSTR) lpszNewFileName);

	// rename is not supported by this i/o procedure
	//
	if (TRUE)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : uRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\avwav\telthunk.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// telthunk.h - interface for tel thunk functions in telthunk.c
////

#ifndef __TELTHUNK_H__
#define __TELTHUNK_H__

#include "winlocal.h"

#define TELTHUNK_VERSION 0x00000107

// handle to telthunk engine
//
DECLARE_HANDLE32(HTELTHUNK);

#ifdef __cplusplus
extern "C" {
#endif

// TelThunkInit - initialize telthunk engine
//		<dwVersion>			(i) must be TELTHUNK_VERSION
// 		<hInst>				(i) instance handle of calling module
// return handle (NULL if error)
//
HTELTHUNK DLLEXPORT WINAPI TelThunkInit(DWORD dwVersion, HINSTANCE hInst);

// TelThunkTerm - shut down telthunk engine
//		<hTelThunk>				(i) handle returned from TelThunkInit
// return 0 if success
//
int DLLEXPORT WINAPI TelThunkTerm(HTELTHUNK hTelThunk);

#ifdef __cplusplus
}
#endif

#endif // __TELTHUNK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\avwav\strmio.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// strmio.h - interface to property i/o functions in strmio.cpp
////

#ifndef __STRMIO_H__
#define __STRMIO_H__

#include "winlocal.h"

#ifdef __cplusplus
extern "C" {
#endif

// StreamIOProc - i/o procedure for property data
//		<lpmmioinfo>		(i/o) information about open file
//		<uMessage>			(i) message indicating the requested I/O operation
//		<lParam1>			(i) message specific parameter
//		<lParam2>			(i) message specific parameter
// returns 0 if message not recognized, otherwise message specific value
//
// NOTE: the address of this function should be passed to the WavOpen()
// or mmioInstallIOProc() functions for accessing property data.
//
LRESULT DLLEXPORT CALLBACK StreamIOProc(LPSTR lpmmioinfo,
	UINT uMessage, LPARAM lParam1, LPARAM lParam2);

#ifdef __cplusplus
}
#endif

#endif // __STRMIO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\avwav\telthunk.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	telthunk.c - tel thunk functions
////

// This is a thunk layer to the telephone functions in tel.dll.
// It's purpose is to allow an application to use tel.dll functions
// only if they are available.
//
// To use this module, link TELTHUNK.OBJ with your application
// rather than with TEL.LIB.  Before calling any Tel or TelOut
// functions, call TelThunkInit.  Before exiting your application,
// call TelThunkTerm.
//

#include "winlocal.h"

#include <stdlib.h>

#include "telthunk.h"
#include "tel.h"
#include "telcfg.h"
#include "telwav.h"
#include "telout.h"
#include "telin.h"
#include "file.h"
#include "loadlib.h"
#include "mem.h"
#include "str.h"
#include "trace.h"

extern HINSTANCE g_hInstLib;

////
//	private definitions
////

#ifdef _WIN32
#define TELTHUNK_LIBNAME		"tel32.dll"
#define TELTHUNK_LIBNAME_TIU	"tel32nt.dll"
#else
#define TELTHUNK_LIBNAME		"tel.dll"
#endif

#ifdef TELTHUNK
#undef TELTHUNK
#endif

extern HINSTANCE g_hInstLib;

// telthunk control struct
//
typedef struct TELTHUNK
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	HINSTANCE hInstLib;
} TELTHUNK, FAR *LPTELTHUNK;

// telthunk function struct
//
typedef struct TELTHUNKFN
{
	int index;
	LPSTR lpszName;
	FARPROC lpfn;
} TELTHUNKFN, FAR *LPTELTHUNKFN;

enum
{
	iTelInitDLL = 0,
	iTelTermDLL,
	iTelInit,
	iTelTerm,
	iTelIsConnected,
	iTelConnect,
	iTelDisconnect,
	iTelTransfer,
	iTelConnectIdleTimeoutReset,

	iTelOutGetDeviceCount,
	iTelOutDeviceIsOpen,
	iTelOutOpen,
	iTelOutClose,
	iTelOutPlay,
	iTelOutStop,
	iTelOutPause,
	iTelOutResume,
	iTelOutGetState,
	iTelOutGetPosition,
	iTelOutGetId,
	iTelOutGetName,
	iTelOutSupportsFormat,
	iTelOutFormatSuggest,
	iTelOutIsSynchronous,
	iTelOutSupportsVolume,
	iTelOutSupportsSpeed,
	iTelOutSupportsPitch,
	iTelOutGetVolume,
	iTelOutSetVolume,
	iTelOutGetSpeed,
	iTelOutSetSpeed,
	iTelOutGetPitch,
	iTelOutSetPitch,
	iTelOutTerm,

	iTelInGetDeviceCount,
	iTelInDeviceIsOpen,
	iTelInOpen,
	iTelInClose,
	iTelInRecord,
	iTelInStop,
	iTelInGetState,
	iTelInGetPosition,
	iTelInGetId,
	iTelInGetName,
	iTelInSupportsFormat,
	iTelInFormatSuggest,
	iTelInTerm,

	iTelCfgRead,
	iTelCfgWrite,
	iTelCfgDoDialog,

	iTelWavOpenEx,

	TELTHUNK_MAXFUNCTIONS
};

static TELTHUNKFN aTelThunkFn[] =
{
	iTelInitDLL, "TelInitDLL", NULL,
	iTelTermDLL, "TelTermDLL", NULL,

	iTelInit, "TelInit", NULL,
	iTelTerm, "TelTerm", NULL,
	iTelIsConnected, "TelIsConnected", NULL,
	iTelConnect, "TelConnect", NULL,
	iTelDisconnect, "TelDisconnect", NULL,
	iTelTransfer, "TelTransfer", NULL,
	iTelConnectIdleTimeoutReset, "TelConnectIdleTimeoutReset", NULL,

	iTelOutGetDeviceCount, "TelOutGetDeviceCount", NULL,
	iTelOutDeviceIsOpen, "TelOutDeviceIsOpen", NULL,
	iTelOutOpen, "TelOutOpen", NULL,
	iTelOutClose, "TelOutClose", NULL,
	iTelOutPlay, "TelOutPlay", NULL,
	iTelOutStop, "TelOutStop", NULL,
	iTelOutPause, "TelOutPause", NULL,
	iTelOutResume, "TelOutResume", NULL,
	iTelOutGetState, "TelOutGetState", NULL,
	iTelOutGetPosition, "TelOutGetPosition", NULL,
	iTelOutGetId, "TelOutGetId", NULL,
	iTelOutGetName, "TelOutGetName", NULL,
	iTelOutSupportsFormat, "TelOutSupportsFormat", NULL,
	iTelOutFormatSuggest, "TelOutFormatSuggest", NULL,
	iTelOutIsSynchronous, "TelOutIsSynchronous", NULL,
	iTelOutSupportsVolume, "TelOutSupportsVolume", NULL,
	iTelOutSupportsSpeed, "TelOutSupportsSpeed", NULL,
	iTelOutSupportsPitch, "TelOutSupportsPitch", NULL,
	iTelOutGetVolume, "TelOutGetVolume", NULL,
	iTelOutSetVolume, "TelOutSetVolume", NULL,
	iTelOutGetSpeed, "TelOutGetSpeed", NULL,
	iTelOutSetSpeed, "TelOutSetSpeed", NULL,
	iTelOutGetPitch, "TelOutGetPitch", NULL,
	iTelOutSetPitch, "TelOutSetPitch", NULL,
	iTelOutTerm, "TelOutTerm", NULL,

	iTelInGetDeviceCount, "TelInGetDeviceCount", NULL,
	iTelInDeviceIsOpen, "TelInDeviceIsOpen", NULL,
	iTelInOpen, "TelInOpen", NULL,
	iTelInClose, "TelInClose", NULL,
	iTelInRecord, "TelInRecord", NULL,
	iTelInStop, "TelInStop", NULL,
	iTelInGetState, "TelInGetState", NULL,
	iTelInGetPosition, "TelInGetPosition", NULL,
	iTelInGetId, "TelInGetId", NULL,
	iTelInGetName, "TelInGetName", NULL,
	iTelInSupportsFormat, "TelInSupportsFormat", NULL,
	iTelInFormatSuggest, "TelInFormatSuggest", NULL,
	iTelInTerm, "TelInTerm", NULL,

	iTelCfgRead, "TelCfgRead", NULL,
	iTelCfgWrite, "TelCfgWrite", NULL,
	iTelCfgDoDialog, "TelCfgDoDialog", NULL,

	iTelWavOpenEx, "TelWavOpenEx", NULL
};

// helper functions
//
static LPTELTHUNK TelThunkGetPtr(HTELTHUNK hTelThunk);
static HTELTHUNK TelThunkGetHandle(LPTELTHUNK lpTelThunk);

////
//	public functions
////

// TelThunkInit - initialize telthunk engine
//		<dwVersion>			(i) must be TELTHUNK_VERSION
// 		<hInst>				(i) instance handle of calling module
// return handle (NULL if error)
//
HTELTHUNK DLLEXPORT WINAPI TelThunkInit(DWORD dwVersion, HINSTANCE hInst)
{
	BOOL fSuccess = TRUE;
	LPTELTHUNK lpTelThunk = NULL;

	if (dwVersion != TELTHUNK_VERSION)
		fSuccess = TraceFALSE(NULL);
	
	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);
                        
	else if ((lpTelThunk = (LPTELTHUNK) MemAlloc(NULL, sizeof(TELTHUNK), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		int i;
		TCHAR szLibName[_MAX_PATH];
		LPTSTR lpszBackSlash = NULL;
		
		lpTelThunk->dwVersion = dwVersion;
		lpTelThunk->hInst = hInst;
		lpTelThunk->hTask = GetCurrentTask();
		lpTelThunk->hInstLib = NULL;

		// Determine which DLL to use
		//
#ifdef _WIN32
		MemSet(szLibName, 0, sizeof(szLibName));
		GetModuleFileName(g_hInstLib, szLibName, SIZEOFARRAY(szLibName));
		if ((lpszBackSlash = StrRChr(szLibName, '\\')) != NULL)
			StrCpy(lpszBackSlash + 1, TEXT("TiuClient.dll"));

		if (FileExists(szLibName))
			StrNCpy(szLibName, TELTHUNK_LIBNAME_TIU, SIZEOFARRAY(szLibName));
		else
#endif
			StrNCpy(szLibName, TELTHUNK_LIBNAME, SIZEOFARRAY(szLibName));
			
		TracePrintf_1(NULL, 5,
			TEXT("TelThunkInit: Loading DLL=%s\n"),
			(LPTSTR) szLibName);

		// load the library if possible
		//
		if ((lpTelThunk->hInstLib = LoadLibraryPath(szLibName, g_hInstLib, 0)) == NULL)
			fSuccess = TraceFALSE(NULL);

		// get the address of each function in library
		//
		else for (i = 0; i < MAG(aTelThunkFn); ++i)
		{
			if (aTelThunkFn[i].index != i)
				fSuccess = TraceFALSE(NULL);

			else if ((aTelThunkFn[i].lpfn = GetProcAddress(lpTelThunk->hInstLib,
				aTelThunkFn[i].lpszName)) == NULL)
			{
				TracePrintf_1(NULL, 6,
					TEXT("GetProcAddress failed\n   fn=%s\n"),
					(LPTSTR) aTelThunkFn[i].lpszName);
				fSuccess = TraceFALSE(NULL);
			}
		}
	}

	if (!fSuccess)
	{
		TelThunkTerm(TelThunkGetHandle(lpTelThunk));
		lpTelThunk = NULL;
	}
	else
	{
		__int16 (WINAPI *lpfnTelInitDLL)(void);

		if (((FARPROC) lpfnTelInitDLL = aTelThunkFn[iTelInitDLL].lpfn) != NULL)
			(*lpfnTelInitDLL)();
	}

	return fSuccess ? TelThunkGetHandle(lpTelThunk) : NULL;
}


// TelThunkTerm - shut down telthunk engine
//		<hTelThunk>				(i) handle returned from TelThunkInit
// return 0 if success
//
int DLLEXPORT WINAPI TelThunkTerm(HTELTHUNK hTelThunk)
{
	BOOL fSuccess = TRUE;
	LPTELTHUNK lpTelThunk;

	if ((lpTelThunk = TelThunkGetPtr(hTelThunk)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		__int16 (WINAPI *lpfnTelTermDLL)(void);

		if (((FARPROC) lpfnTelTermDLL = aTelThunkFn[iTelTermDLL].lpfn) != NULL)
			(*lpfnTelTermDLL)();

		// library no longer needed
		//
		FreeLibrary(lpTelThunk->hInstLib);

		if ((lpTelThunk = MemFree(NULL, lpTelThunk)) != NULL)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// Tel thunk functions
//

HTEL DLLEXPORT WINAPI TelInit(DWORD dwVersion, HINSTANCE hInst,
	LPCTSTR lpszServerParams, HWND hwndNotify, WORD wFlags)
{
	BOOL fSuccess = TRUE;
	HTEL (WINAPI *lpfnTelInit)(DWORD dwVersion, HINSTANCE hInst,
		LPCTSTR lpszServerParams, HWND hwndNotify, WORD wFlags);
	HTEL hTel;

	if (aTelThunkFn[iTelInit].index != iTelInit)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelInit = aTelThunkFn[iTelInit].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		hTel = (*lpfnTelInit)(dwVersion, hInst,
			lpszServerParams, hwndNotify, wFlags);
	}

	return fSuccess ? hTel : NULL;
}

int DLLEXPORT WINAPI TelTerm(HTEL hTel)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelTerm)(HTEL hTel);
	int iRet;

	if (aTelThunkFn[iTelTerm].index != iTelTerm)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelTerm = aTelThunkFn[iTelTerm].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelTerm)(hTel);
	}

	return fSuccess ? iRet : -1;
}

DWORD DLLEXPORT WINAPI TelIsConnected(HTEL hTel)
{
	BOOL fSuccess = TRUE;
	DWORD (WINAPI *lpfnTelIsConnected)(HTEL hTel);
	DWORD dwRet;

	if (aTelThunkFn[iTelIsConnected].index != iTelIsConnected)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelIsConnected = aTelThunkFn[iTelIsConnected].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		dwRet = (*lpfnTelIsConnected)(hTel);
	}

	return fSuccess ? dwRet : 0;
}

int DLLEXPORT WINAPI TelConnect(HTEL hTel, LPCTSTR lpszPhoneConnect,
	HNBOX hNBoxConnect, DWORD dwTimeoutConnect, DWORD dwTimeoutIdle,
	HNBOX hNBoxDisconnect, DWORD dwTimeoutDisconnect, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelConnect)(HTEL hTel, LPCTSTR lpszPhoneConnect,
		HNBOX hNBoxConnect, DWORD dwTimeoutConnect, DWORD dwTimeoutIdle,
		HNBOX hNBoxDisconnect, DWORD dwTimeoutDisconnect, DWORD dwFlags);
	int iRet;

	if (aTelThunkFn[iTelConnect].index != iTelConnect)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelConnect = aTelThunkFn[iTelConnect].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelConnect)(hTel, lpszPhoneConnect,
			hNBoxConnect, dwTimeoutConnect, dwTimeoutIdle,
			hNBoxDisconnect, dwTimeoutDisconnect, dwFlags);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelDisconnect(HTEL hTel, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelDisconnect)(HTEL hTel, DWORD dwFlags);
	int iRet;

	if (aTelThunkFn[iTelDisconnect].index != iTelDisconnect)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelDisconnect = aTelThunkFn[iTelDisconnect].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelDisconnect)(hTel, dwFlags);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelTransfer(HTEL hTel, LPCTSTR lpszPhoneTransfer,
	HNBOX hNBoxTransfer, DWORD dwTimeoutTransfer, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelTransfer)(HTEL hTel, LPCTSTR lpszPhoneTransfer,
		HNBOX hNBoxTransfer, DWORD dwTimeoutTransfer, DWORD dwFlags);
	int iRet;

	if (aTelThunkFn[iTelTransfer].index != iTelTransfer)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelTransfer = aTelThunkFn[iTelTransfer].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelTransfer)(hTel, lpszPhoneTransfer,
			hNBoxTransfer, dwTimeoutTransfer, dwFlags);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelConnectIdleTimeoutReset(HTEL hTel, BOOL fReset)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelConnectIdleTimeoutReset)(HTEL hTel, BOOL fReset);
	int iRet;

	if (aTelThunkFn[iTelConnectIdleTimeoutReset].index != iTelConnectIdleTimeoutReset)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelConnectIdleTimeoutReset = aTelThunkFn[iTelConnectIdleTimeoutReset].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelConnectIdleTimeoutReset)(hTel, fReset);
	}

	return fSuccess ? iRet : -1;
}

// TelOut thunk functions
//

int DLLEXPORT WINAPI TelOutGetDeviceCount(void)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelOutGetDeviceCount)(void);
	int iRet;

	if (aTelThunkFn[iTelOutGetDeviceCount].index != iTelOutGetDeviceCount)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutGetDeviceCount = aTelThunkFn[iTelOutGetDeviceCount].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelOutGetDeviceCount)();
	}

	return fSuccess ? iRet : -1;
}

BOOL DLLEXPORT WINAPI TelOutDeviceIsOpen(int idDev)
{
	BOOL fSuccess = TRUE;
	BOOL (WINAPI *lpfnTelOutDeviceIsOpen)(int idDev);
	BOOL fRet;

	if (aTelThunkFn[iTelOutDeviceIsOpen].index != iTelOutDeviceIsOpen)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutDeviceIsOpen = aTelThunkFn[iTelOutDeviceIsOpen].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		fRet = (*lpfnTelOutDeviceIsOpen)(idDev);
	}

	return fSuccess ? fRet : -1;
}

HTELOUT DLLEXPORT WINAPI TelOutOpen(DWORD dwVersion, HINSTANCE hInst,
	int idDev, LPWAVEFORMATEX lpwfx, HWND hwndNotify,
	DWORD msTimeoutOpen, DWORD msTimeoutRetry, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	HTELOUT (WINAPI *lpfnTelOutOpen)(DWORD dwVersion, HINSTANCE hInst,
	int idDev, LPWAVEFORMATEX lpwfx, HWND hwndNotify,
	DWORD msTimeoutOpen, DWORD msTimeoutRetry, DWORD dwFlags);
	HTELOUT hTelOut;

	if (aTelThunkFn[iTelOutOpen].index != iTelOutOpen)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutOpen = aTelThunkFn[iTelOutOpen].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		hTelOut = (*lpfnTelOutOpen)(dwVersion, hInst, idDev, lpwfx,
			hwndNotify, msTimeoutOpen, msTimeoutRetry, dwFlags);
	}

	return fSuccess ? hTelOut : NULL;
}

int DLLEXPORT WINAPI TelOutClose(HTELOUT hTelOut, DWORD msTimeoutClose)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelOutClose)(HTELOUT hTelOut, DWORD msTimeoutClose);
	int iRet;

	if (aTelThunkFn[iTelOutClose].index != iTelOutClose)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutClose = aTelThunkFn[iTelOutClose].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelOutClose)(hTelOut, msTimeoutClose);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelOutPlay(HTELOUT hTelOut, LPVOID lpBuf, long sizBuf, long hrfile)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelOutPlay)(HTELOUT hTelOut, LPVOID lpBuf, long sizBuf, long hrfile);
	int iRet;

	if (aTelThunkFn[iTelOutPlay].index != iTelOutPlay)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutPlay = aTelThunkFn[iTelOutPlay].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelOutPlay)(hTelOut, lpBuf, sizBuf, hrfile);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelOutStop(HTELOUT hTelOut, DWORD msTimeoutStop)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelOutStop)(HTELOUT hTelOut, DWORD msTimeoutStop);
	int iRet;

	if (aTelThunkFn[iTelOutStop].index != iTelOutStop)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutStop = aTelThunkFn[iTelOutStop].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelOutStop)(hTelOut, msTimeoutStop);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelOutPause(HTELOUT hTelOut)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelOutPause)(HTELOUT hTelOut);
	int iRet;

	if (aTelThunkFn[iTelOutPause].index != iTelOutPause)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutPause = aTelThunkFn[iTelOutPause].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelOutPause)(hTelOut);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelOutResume(HTELOUT hTelOut)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelOutResume)(HTELOUT hTelOut);
	int iRet;

	if (aTelThunkFn[iTelOutResume].index != iTelOutResume)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutResume = aTelThunkFn[iTelOutResume].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelOutResume)(hTelOut);
	}

	return fSuccess ? iRet : -1;
}

WORD DLLEXPORT WINAPI TelOutGetState(HTELOUT hTelOut)
{
	BOOL fSuccess = TRUE;
	WORD (WINAPI *lpfnTelOutGetState)(HTELOUT hTelOut);
	WORD wRet;

	if (aTelThunkFn[iTelOutGetState].index != iTelOutGetState)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutGetState = aTelThunkFn[iTelOutGetState].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		wRet = (*lpfnTelOutGetState)(hTelOut);
	}

	return fSuccess ? wRet : 0;
}

long DLLEXPORT WINAPI TelOutGetPosition(HTELOUT hTelOut)
{
	BOOL fSuccess = TRUE;
	long (WINAPI *lpfnTelOutGetPosition)(HTELOUT hTelOut);
	long lRet;

	if (aTelThunkFn[iTelOutGetPosition].index != iTelOutGetPosition)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutGetPosition = aTelThunkFn[iTelOutGetPosition].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lRet = (*lpfnTelOutGetPosition)(hTelOut);
	}

	return fSuccess ? lRet : -1;
}

int DLLEXPORT WINAPI TelOutGetId(HTELOUT hTelOut)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelOutGetId)(HTELOUT hTelOut);
	int iRet;

	if (aTelThunkFn[iTelOutGetId].index != iTelOutGetId)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutGetId = aTelThunkFn[iTelOutGetId].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelOutGetId)(hTelOut);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelOutGetName(HTELOUT hTelOut, int idDev, LPTSTR lpszName, int sizName)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelOutGetName)(HTELOUT hTelOut, int idDev, LPTSTR lpszName, int sizName);
	int iRet;

	if (aTelThunkFn[iTelOutGetName].index != iTelOutGetName)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutGetName = aTelThunkFn[iTelOutGetName].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelOutGetName)(hTelOut, idDev, lpszName, sizName);
	}

	return fSuccess ? iRet : -1;
}

BOOL DLLEXPORT WINAPI TelOutSupportsFormat(HTELOUT hTelOut, int idDev,
	LPWAVEFORMATEX lpwfx)
{
	BOOL fSuccess = TRUE;
	BOOL (WINAPI *lpfnTelOutSupportsFormat)(HTELOUT hTelOut, int idDev,
		LPWAVEFORMATEX lpwfx);
	BOOL fRet;

	if (aTelThunkFn[iTelOutSupportsFormat].index != iTelOutSupportsFormat)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutSupportsFormat = aTelThunkFn[iTelOutSupportsFormat].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		fRet = (*lpfnTelOutSupportsFormat)(hTelOut, idDev, lpwfx);
	}

	return fSuccess ? fRet : FALSE;
}

LPWAVEFORMATEX DLLEXPORT WINAPI TelOutFormatSuggest(HTELOUT hTelOut,
	int idDev, LPWAVEFORMATEX lpwfxSrc, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAVEFORMATEX (WINAPI *lpfnTelOutFormatSuggest)(HTELOUT hTelOut,
		int idDev,	LPWAVEFORMATEX lpwfxSrc, DWORD dwFlags);
	LPWAVEFORMATEX lpwfx;

	if (aTelThunkFn[iTelOutFormatSuggest].index != iTelOutFormatSuggest)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutFormatSuggest = aTelThunkFn[iTelOutFormatSuggest].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lpwfx = (*lpfnTelOutFormatSuggest)(hTelOut, idDev, lpwfxSrc, dwFlags);
	}

	return fSuccess ? lpwfx : NULL;
}

BOOL DLLEXPORT WINAPI TelOutIsSynchronous(HTELOUT hTelOut, int idDev)
{
	BOOL fSuccess = TRUE;
	BOOL (WINAPI *lpfnTelOutIsSynchronous)(HTELOUT hTelOut, int idDev);
	BOOL fRet;

	if (aTelThunkFn[iTelOutIsSynchronous].index != iTelOutIsSynchronous)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutIsSynchronous = aTelThunkFn[iTelOutIsSynchronous].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		fRet = (*lpfnTelOutIsSynchronous)(hTelOut, idDev);
	}

	return fSuccess ? fRet : FALSE;
}

BOOL DLLEXPORT WINAPI TelOutSupportsVolume(HTELOUT hTelOut, int idDev)
{
	BOOL fSuccess = TRUE;
	BOOL (WINAPI *lpfnTelOutSupportsVolume)(HTELOUT hTelOut, int idDev);
	BOOL fRet;

	if (aTelThunkFn[iTelOutSupportsVolume].index != iTelOutSupportsVolume)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutSupportsVolume = aTelThunkFn[iTelOutSupportsVolume].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		fRet = (*lpfnTelOutSupportsVolume)(hTelOut, idDev);
	}

	return fSuccess ? fRet : FALSE;
}

BOOL DLLEXPORT WINAPI TelOutSupportsSpeed(HTELOUT hTelOut, int idDev)
{
	BOOL fSuccess = TRUE;
	BOOL (WINAPI *lpfnTelOutSupportsSpeed)(HTELOUT hTelOut, int idDev);
	BOOL fRet;

	if (aTelThunkFn[iTelOutSupportsSpeed].index != iTelOutSupportsSpeed)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutSupportsSpeed = aTelThunkFn[iTelOutSupportsSpeed].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		fRet = (*lpfnTelOutSupportsSpeed)(hTelOut, idDev);
	}

	return fSuccess ? fRet : FALSE;
}

BOOL DLLEXPORT WINAPI TelOutSupportsPitch(HTELOUT hTelOut, int idDev)
{
	BOOL fSuccess = TRUE;
	BOOL (WINAPI *lpfnTelOutSupportsPitch)(HTELOUT hTelOut, int idDev);
	BOOL fRet;

	if (aTelThunkFn[iTelOutSupportsPitch].index != iTelOutSupportsPitch)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutSupportsPitch = aTelThunkFn[iTelOutSupportsPitch].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		fRet = (*lpfnTelOutSupportsPitch)(hTelOut, idDev);
	}

	return fSuccess ? fRet : FALSE;
}

int DLLEXPORT WINAPI TelOutGetVolume(HTELOUT hTelOut)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelOutGetVolume)(HTELOUT hTelOut);
	int iRet;

	if (aTelThunkFn[iTelOutGetVolume].index != iTelOutGetVolume)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutGetVolume = aTelThunkFn[iTelOutGetVolume].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelOutGetVolume)(hTelOut);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelOutSetVolume(HTELOUT hTelOut, int nLevel)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelOutSetVolume)(HTELOUT hTelOut, int nLevel);
	int iRet;

	if (aTelThunkFn[iTelOutSetVolume].index != iTelOutSetVolume)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutSetVolume = aTelThunkFn[iTelOutSetVolume].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelOutSetVolume)(hTelOut, nLevel);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelOutGetSpeed(HTELOUT hTelOut)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelOutGetSpeed)(HTELOUT hTelOut);
	int iRet;

	if (aTelThunkFn[iTelOutGetSpeed].index != iTelOutGetSpeed)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutGetSpeed = aTelThunkFn[iTelOutGetSpeed].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelOutGetSpeed)(hTelOut);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelOutSetSpeed(HTELOUT hTelOut, int nLevel)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelOutSetSpeed)(HTELOUT hTelOut, int nLevel);
	int iRet;

	if (aTelThunkFn[iTelOutSetSpeed].index != iTelOutSetSpeed)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutSetSpeed = aTelThunkFn[iTelOutSetSpeed].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelOutSetSpeed)(hTelOut, nLevel);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelOutGetPitch(HTELOUT hTelOut)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelOutGetPitch)(HTELOUT hTelOut);
	int iRet;

	if (aTelThunkFn[iTelOutGetPitch].index != iTelOutGetPitch)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutGetPitch = aTelThunkFn[iTelOutGetPitch].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelOutGetPitch)(hTelOut);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelOutSetPitch(HTELOUT hTelOut, int nLevel)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelOutSetPitch)(HTELOUT hTelOut, int nLevel);
	int iRet;

	if (aTelThunkFn[iTelOutSetPitch].index != iTelOutSetPitch)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutSetPitch = aTelThunkFn[iTelOutSetPitch].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelOutSetPitch)(hTelOut, nLevel);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelOutTerm(HINSTANCE hInst, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelOutTerm)(HINSTANCE hInst, DWORD dwFlags);
	int iRet;

	if (aTelThunkFn[iTelOutTerm].index != iTelOutTerm)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelOutTerm = aTelThunkFn[iTelOutTerm].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelOutTerm)(hInst, dwFlags);
	}

	return fSuccess ? iRet : -1;
}

// TelIn thunk functions
//

int DLLEXPORT WINAPI TelInGetDeviceCount(void)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelInGetDeviceCount)(void);
	int iRet;

	if (aTelThunkFn[iTelInGetDeviceCount].index != iTelInGetDeviceCount)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelInGetDeviceCount = aTelThunkFn[iTelInGetDeviceCount].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelInGetDeviceCount)();
	}

	return fSuccess ? iRet : -1;
}

BOOL DLLEXPORT WINAPI TelInDeviceIsOpen(int idDev)
{
	BOOL fSuccess = TRUE;
	BOOL (WINAPI *lpfnTelInDeviceIsOpen)(int idDev);
	BOOL fRet;

	if (aTelThunkFn[iTelInDeviceIsOpen].index != iTelInDeviceIsOpen)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelInDeviceIsOpen = aTelThunkFn[iTelInDeviceIsOpen].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		fRet = (*lpfnTelInDeviceIsOpen)(idDev);
	}

	return fSuccess ? fRet : -1;
}

HTELIN DLLEXPORT WINAPI TelInOpen(DWORD dwVersion, HINSTANCE hInst,
	int idDev, LPWAVEFORMATEX lpwfx, HWND hwndNotify,
	DWORD msTimeoutOpen, DWORD msTimeoutRetry, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	HTELIN (WINAPI *lpfnTelInOpen)(DWORD dwVersion, HINSTANCE hInst,
	int idDev, LPWAVEFORMATEX lpwfx, HWND hwndNotify,
	DWORD msTimeoutOpen, DWORD msTimeoutRetry, DWORD dwFlags);
	HTELIN hTelIn;

	if (aTelThunkFn[iTelInOpen].index != iTelInOpen)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelInOpen = aTelThunkFn[iTelInOpen].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		hTelIn = (*lpfnTelInOpen)(dwVersion, hInst, idDev, lpwfx,
			hwndNotify, msTimeoutOpen, msTimeoutRetry, dwFlags);
	}

	return fSuccess ? hTelIn : NULL;
}

int DLLEXPORT WINAPI TelInClose(HTELIN hTelIn, DWORD msTimeoutClose)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelInClose)(HTELIN hTelIn, DWORD msTimeoutClose);
	int iRet;

	if (aTelThunkFn[iTelInClose].index != iTelInClose)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelInClose = aTelThunkFn[iTelInClose].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelInClose)(hTelIn, msTimeoutClose);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelInRecord(HTELIN hTelIn, LPVOID lpBuf, long sizBuf, long hrfile)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelInRecord)(HTELIN hTelIn, LPVOID lpBuf, long sizBuf, long hrfile);
	int iRet;

	if (aTelThunkFn[iTelInRecord].index != iTelInRecord)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelInRecord = aTelThunkFn[iTelInRecord].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelInRecord)(hTelIn, lpBuf, sizBuf, hrfile);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelInStop(HTELIN hTelIn, DWORD msTimeoutStop)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelInStop)(HTELIN hTelIn, DWORD msTimeoutStop);
	int iRet;

	if (aTelThunkFn[iTelInStop].index != iTelInStop)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelInStop = aTelThunkFn[iTelInStop].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelInStop)(hTelIn, msTimeoutStop);
	}

	return fSuccess ? iRet : -1;
}

WORD DLLEXPORT WINAPI TelInGetState(HTELIN hTelIn)
{
	BOOL fSuccess = TRUE;
	WORD (WINAPI *lpfnTelInGetState)(HTELIN hTelIn);
	WORD wRet;

	if (aTelThunkFn[iTelInGetState].index != iTelInGetState)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelInGetState = aTelThunkFn[iTelInGetState].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		wRet = (*lpfnTelInGetState)(hTelIn);
	}

	return fSuccess ? wRet : 0;
}

long DLLEXPORT WINAPI TelInGetPosition(HTELIN hTelIn)
{
	BOOL fSuccess = TRUE;
	long (WINAPI *lpfnTelInGetPosition)(HTELIN hTelIn);
	long lRet;

	if (aTelThunkFn[iTelInGetPosition].index != iTelInGetPosition)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelInGetPosition = aTelThunkFn[iTelInGetPosition].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lRet = (*lpfnTelInGetPosition)(hTelIn);
	}

	return fSuccess ? lRet : -1;
}

int DLLEXPORT WINAPI TelInGetId(HTELIN hTelIn)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelInGetId)(HTELIN hTelIn);
	int iRet;

	if (aTelThunkFn[iTelInGetId].index != iTelInGetId)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelInGetId = aTelThunkFn[iTelInGetId].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelInGetId)(hTelIn);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelInGetName(HTELIN hTelIn, int idDev, LPTSTR lpszName, int sizName)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelInGetName)(HTELIN hTelIn, int idDev, LPTSTR lpszName, int sizName);
	int iRet;

	if (aTelThunkFn[iTelInGetName].index != iTelInGetName)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelInGetName = aTelThunkFn[iTelInGetName].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelInGetName)(hTelIn, idDev, lpszName, sizName);
	}

	return fSuccess ? iRet : -1;
}

BOOL DLLEXPORT WINAPI TelInSupportsFormat(HTELIN hTelIn, int idDev,
	LPWAVEFORMATEX lpwfx)
{
	BOOL fSuccess = TRUE;
	BOOL (WINAPI *lpfnTelInSupportsFormat)(HTELIN hTelIn, int idDev,
		LPWAVEFORMATEX lpwfx);
	BOOL fRet;

	if (aTelThunkFn[iTelInSupportsFormat].index != iTelInSupportsFormat)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelInSupportsFormat = aTelThunkFn[iTelInSupportsFormat].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		fRet = (*lpfnTelInSupportsFormat)(hTelIn, idDev, lpwfx);
	}

	return fSuccess ? fRet : FALSE;
}

LPWAVEFORMATEX DLLEXPORT WINAPI TelInFormatSuggest(HTELIN hTelIn,
	int idDev, LPWAVEFORMATEX lpwfxSrc, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAVEFORMATEX (WINAPI *lpfnTelInFormatSuggest)(HTELIN hTelIn,
		int idDev,	LPWAVEFORMATEX lpwfxSrc, DWORD dwFlags);
	LPWAVEFORMATEX lpwfx;

	if (aTelThunkFn[iTelInFormatSuggest].index != iTelInFormatSuggest)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelInFormatSuggest = aTelThunkFn[iTelInFormatSuggest].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lpwfx = (*lpfnTelInFormatSuggest)(hTelIn, idDev, lpwfxSrc, dwFlags);
	}

	return fSuccess ? lpwfx : NULL;
}

int DLLEXPORT WINAPI TelInTerm(HINSTANCE hInst, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelInTerm)(HINSTANCE hInst, DWORD dwFlags);
	int iRet;

	if (aTelThunkFn[iTelInTerm].index != iTelInTerm)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelInTerm = aTelThunkFn[iTelInTerm].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelInTerm)(hInst, dwFlags);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelCfgRead(DWORD dwVersion, HINSTANCE hInst,
	LPTELCFG lpTelCfg, LPARAM lParam, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelCfgRead)(DWORD dwVersion, HINSTANCE hInst,
		LPTELCFG lpTelCfg, LPARAM lParam, DWORD dwFlags);
	int iRet;

	if (aTelThunkFn[iTelCfgRead].index != iTelCfgRead)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelCfgRead = aTelThunkFn[iTelCfgRead].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelCfgRead)(dwVersion, hInst, lpTelCfg, lParam, dwFlags);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TelCfgWrite(DWORD dwVersion, HINSTANCE hInst,
	LPTELCFG lpTelCfg, LPARAM lParam, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelCfgWrite)(DWORD dwVersion, HINSTANCE hInst,
		LPTELCFG lpTelCfg, LPARAM lParam, DWORD dwFlags);
	int iRet;

	if (aTelThunkFn[iTelCfgWrite].index != iTelCfgWrite)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelCfgWrite = aTelThunkFn[iTelCfgWrite].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelCfgWrite)(dwVersion, hInst, lpTelCfg, lParam, dwFlags);
	}

	return fSuccess ? iRet : -1;
}


int DLLEXPORT WINAPI TelCfgDoDialog(HINSTANCE hInst,
	HWND hwndOwner, LPARAM lParam)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTelCfgDoDialog)(HINSTANCE hInst,
		HWND hwndOwner, LPARAM lParam);
	int iRet;

	if (aTelThunkFn[iTelCfgDoDialog].index != iTelCfgDoDialog)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelCfgDoDialog = aTelThunkFn[iTelCfgDoDialog].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTelCfgDoDialog)(hInst, hwndOwner, lParam);
	}

	return fSuccess ? iRet : -1;
}

HWAV DLLEXPORT WINAPI TelWavOpenEx(DWORD dwVersion, HINSTANCE hInst,
	LPTSTR lpszFileName, DWORD dwReserved, DWORD dwFlagsOpen, DWORD dwFlagsEx)
{
	BOOL fSuccess = TRUE;
	HWAV (WINAPI *lpfnTelWavOpenEx)(DWORD dwVersion, HINSTANCE hInst,
		LPTSTR lpszFileName, DWORD dwReserved, DWORD dwFlagsOpen, DWORD dwFlagsEx);
	HWAV hWav;

	if (aTelThunkFn[iTelWavOpenEx].index != iTelWavOpenEx)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTelWavOpenEx = aTelThunkFn[iTelWavOpenEx].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		hWav = (*lpfnTelWavOpenEx)(dwVersion, hInst,
			lpszFileName, dwReserved, dwFlagsOpen, dwFlagsEx);
	}

	return fSuccess ? hWav : NULL;
}

////
//	helper functions
////

// TelThunkGetPtr - verify that telthunk handle is valid,
//		<hTelThunk>				(i) handle returned from TelThunkInit
// return corresponding telthunk pointer (NULL if error)
//
static LPTELTHUNK TelThunkGetPtr(HTELTHUNK hTelThunk)
{
	BOOL fSuccess = TRUE;
	LPTELTHUNK lpTelThunk;

	if ((lpTelThunk = (LPTELTHUNK) hTelThunk) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpTelThunk, sizeof(TELTHUNK)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the telthunk handle
	//
	else if (lpTelThunk->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpTelThunk : NULL;
}

// TelThunkGetHandle - verify that telthunk pointer is valid,
//		<lpTelThunk>				(i) pointer to TELTHUNK struct
// return corresponding telthunk handle (NULL if error)
//
static HTELTHUNK TelThunkGetHandle(LPTELTHUNK lpTelThunk)
{
	BOOL fSuccess = TRUE;
	HTELTHUNK hTelThunk;

	if ((hTelThunk = (HTELTHUNK) lpTelThunk) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hTelThunk : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\avwav\sockio.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// sockio.h - interface to property i/o functions in sockio.c
////

#ifndef __SOCKIO_H__
#define __SOCKIO_H__

#include "winlocal.h"

#ifdef __cplusplus
extern "C" {
#endif

// SockIOProc - i/o procedure for winsock data
//		<lpmmioinfo>		(i/o) information about open file
//		<uMessage>			(i) message indicating the requested I/O operation
//		<lParam1>			(i) message specific parameter
//		<lParam2>			(i) message specific parameter
// returns 0 if message not recognized, otherwise message specific value
//
// NOTE: the address of this function should be passed to the WavOpen()
// or mmioInstallIOProc() functions for accessing winsock data.
//
LRESULT DLLEXPORT CALLBACK SockIOProc(LPSTR lpmmioinfo,
	UINT uMessage, LPARAM lParam1, LPARAM lParam2);

#ifdef __cplusplus
}
#endif

#endif // __SOCKIO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\avwav\strmio.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	strmio.cpp - IStream i/o functions
////

#include "winlocal.h"

#include <mmsystem.h>

#include <mapi.h>
#include <mapidefs.h>

#include "strmio.h"
#include "trace.h"

////
//	private definitions
////

// helper functions
//
static LRESULT StreamIoOpen(LPMMIOINFO lpmmioinfo, LPTSTR lpszFileName);
static LRESULT StreamIoClose(LPMMIOINFO lpmmioinfo, UINT uFlags);
static LRESULT StreamIoRead(LPMMIOINFO lpmmioinfo, HPSTR pch, LONG cch);
static LRESULT StreamIoWrite(LPMMIOINFO lpmmioinfo, const HPSTR pch, LONG cch, BOOL fFlush);
static LRESULT StreamIoSeek(LPMMIOINFO lpmmioinfo, LONG lOffset, int iOrigin);
static LRESULT StreamIoRename(LPMMIOINFO lpmmioinfo, LPCTSTR lpszFileName, LPCTSTR lpszNewFileName);

////
//	public functions
////

// StreamIoProc - i/o procedure for IStream data
//		<lpmmioinfo>		(i/o) information about open file
//		<uMessage>			(i) message indicating the requested I/O operation
//		<lParam1>			(i) message specific parameter
//		<lParam2>			(i) message specific parameter
// returns 0 if message not recognized, otherwise message specific value
//
// NOTE: the address of this function should be passed to the WavOpen()
// or mmioInstallIOProc() functions for accessing IStream data.
//
LRESULT DLLEXPORT CALLBACK StreamIOProc(LPSTR lpmmioinfo,
	UINT uMessage, LPARAM lParam1, LPARAM lParam2)
{
	BOOL fSuccess = TRUE;
	LRESULT lResult = 0;

	if (lpmmioinfo == NULL)
		fSuccess = TraceFALSE(NULL);

	else switch (uMessage)
	{
		case MMIOM_OPEN:
			lResult = StreamIoOpen((LPMMIOINFO) lpmmioinfo,
				(LPTSTR) lParam1);
			break;

		case MMIOM_CLOSE:
			lResult = StreamIoClose((LPMMIOINFO) lpmmioinfo,
				(UINT) lParam1);
			break;

		case MMIOM_READ:
			lResult = StreamIoRead((LPMMIOINFO) lpmmioinfo,
				(HPSTR) lParam1, (LONG) lParam2);
			break;

		case MMIOM_WRITE:
			lResult = StreamIoWrite((LPMMIOINFO) lpmmioinfo,
				(const HPSTR) lParam1, (LONG) lParam2, FALSE);
			break;

		case MMIOM_WRITEFLUSH:
			lResult = StreamIoWrite((LPMMIOINFO) lpmmioinfo,
				(const HPSTR) lParam1, (LONG) lParam2, TRUE);
			break;

		case MMIOM_SEEK:
			lResult = StreamIoSeek((LPMMIOINFO) lpmmioinfo,
				(LONG) lParam1, (int) lParam2);
			break;

		case MMIOM_RENAME:
			lResult = StreamIoRename((LPMMIOINFO) lpmmioinfo,
				(LPCTSTR) lParam1, (LPCTSTR) lParam2);
			break;

		default:
			lResult = 0;
			break;
	}

	return lResult;
}

////
//	installable file i/o procedures
////

static LRESULT StreamIoOpen(LPMMIOINFO lpmmioinfo, LPTSTR lpszFileName)
{
	BOOL fSuccess = TRUE;
	LPSTREAM lpStream;

 	TracePrintf_0(NULL, 5,
 		TEXT("StreamIoOpen\n"));

	// stream pointer is within first element of info array
	//
	if ((lpStream = (LPSTREAM)(DWORD_PTR)lpmmioinfo->adwInfo[0]) == NULL)
		fSuccess = TraceFALSE(NULL);

	// seek to the beginning of the stream
	//
	else if (StreamIoSeek(lpmmioinfo, 0, 0) != 0)
		fSuccess = TraceFALSE(NULL);

	else
		lpStream->AddRef();

	// return the same error code given by mmioOpen
	//
	return fSuccess ? lpmmioinfo->wErrorRet = 0 : MMIOERR_CANNOTOPEN;
}

static LRESULT StreamIoClose(LPMMIOINFO lpmmioinfo, UINT uFlags)
{
	BOOL fSuccess = TRUE;
	LPSTREAM lpStream = (LPSTREAM)(DWORD_PTR)lpmmioinfo->adwInfo[0];
	UINT uRet = MMIOERR_CANNOTCLOSE;

 	TracePrintf_0(NULL, 5,
 		TEXT("StreamIoClose\n"));

	// close the stream
	//
	lpStream->Release();
    lpmmioinfo->adwInfo[0] = (DWORD) NULL;

	return fSuccess ? 0 : uRet;
}

static LRESULT StreamIoRead(LPMMIOINFO lpmmioinfo, HPSTR pch, LONG cch)
{
	BOOL fSuccess = TRUE;
	LPSTREAM lpStream = (LPSTREAM)(DWORD_PTR)lpmmioinfo->adwInfo[0];
	HRESULT hr;
	LONG lBytesRead = 0L;

 	TracePrintf_1(NULL, 5,
 		TEXT("StreamIoRead (%ld)\n"),
		(long) cch);

	if (cch <= 0)
		lBytesRead = 0; // nothing to do

	// read
	//
	else if ((hr = lpStream->Read((LPVOID) pch,
		(ULONG) cch, (ULONG FAR *) &lBytesRead)) != S_OK)
	{
		fSuccess = TraceFALSE(NULL);
	 	TracePrintf_2(NULL, 5,
	 		TEXT("IStream:Read failed (%ld, %ld)\n"),
	 		(long) hr,
			(long) lBytesRead);
	}

	// update simulated file position
	//
	else
		lpmmioinfo->lDiskOffset += (LONG) lBytesRead;

 	TracePrintf_2(NULL, 5,
 		TEXT("StreamIo: lpmmioinfo->lDiskOffset=%ld, lBytesRead=%ld\n"),
		(long) lpmmioinfo->lDiskOffset,
		(long) lBytesRead);

	// return number of bytes read
	//
	return fSuccess ? lBytesRead : -1;
}

static LRESULT StreamIoWrite(LPMMIOINFO lpmmioinfo, const HPSTR pch, LONG cch, BOOL fFlush)
{
	BOOL fSuccess = TRUE;
	LPSTREAM lpStream = (LPSTREAM)(DWORD_PTR)lpmmioinfo->adwInfo[0];
	HRESULT hr;
	LONG lBytesWritten;

 	TracePrintf_1(NULL, 5,
 		TEXT("StreamIoWrite (%ld)\n"),
		(long) cch);

	if (cch <= 0)
		lBytesWritten = 0; // nothing to do

	// write
	//
	else if ((hr = lpStream->Write((LPVOID) pch,
		(ULONG) cch, (ULONG FAR *) &lBytesWritten)) != S_OK)
	{
		fSuccess = TraceFALSE(NULL);
	 	TracePrintf_2(NULL, 5,
	 		TEXT("IStream:Write failed (%ld, %ld)\n"),
	 		(long) hr,
			(long) lBytesWritten);
	}

	// update file position
	//
	else
		lpmmioinfo->lDiskOffset += lBytesWritten;

 	TracePrintf_2(NULL, 5,
 		TEXT("StreamIo: lpmmioinfo->lDiskOffset=%ld, lBytesWritten=%ld\n"),
		(long) lpmmioinfo->lDiskOffset,
		(long) lBytesWritten);

	// return number of bytes written
	//
	return fSuccess ? lBytesWritten : -1;
}

static LRESULT StreamIoSeek(LPMMIOINFO lpmmioinfo, LONG lOffset, int iOrigin)
{
	BOOL fSuccess = TRUE;
	LPSTREAM lpStream = (LPSTREAM)(DWORD_PTR)lpmmioinfo->adwInfo[0];
	HRESULT hr;
	LARGE_INTEGER largeOffset;
	ULARGE_INTEGER ulargePosNew;

	largeOffset.LowPart = (DWORD) lOffset;
	largeOffset.HighPart = (DWORD) 0L;

 	TracePrintf_2(NULL, 5,
 		TEXT("StreamIoSeek (%ld, %d)\n"),
		(long) lOffset,
		(int) iOrigin);

	// seek
	//
	if ((hr = lpStream->Seek(largeOffset,
		(DWORD) iOrigin, &ulargePosNew)) != S_OK)
	{
		fSuccess = TraceFALSE(NULL);
	 	TracePrintf_1(NULL, 5,
	 		TEXT("IStream:Seek failed (%ld)\n"),
	 		(long) hr);
	}

	// update file position
	//
	else
		lpmmioinfo->lDiskOffset = (long) ulargePosNew.LowPart;

 	TracePrintf_1(NULL, 5,
 		TEXT("StreamIo: lpmmioinfo->lDiskOffset=%ld\n"),
		(long) lpmmioinfo->lDiskOffset);

	return fSuccess ? lpmmioinfo->lDiskOffset : -1;
}

static LRESULT StreamIoRename(LPMMIOINFO lpmmioinfo, LPCTSTR lpszFileName, LPCTSTR lpszNewFileName)
{
	BOOL fSuccess = TRUE;
	UINT uRet = MMIOERR_FILENOTFOUND;

 	TracePrintf_2(NULL, 5,
 		TEXT("StreamIoRename (%s, %s)\n"),
		(LPTSTR) lpszFileName,
		(LPTSTR) lpszNewFileName);

	// rename is not supported by this i/o procedure
	//
	if (TRUE)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : uRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\avwav\tsmthunk.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	tsmthunk.c - tsm thunk functions
////

// This is a thunk layer to the telephone functions in avtsm.dll.
// It's purpose is to allow an application to use avtsm.dll functions
// only if they are available.
//
// To use this module, link TSMTHUNK.OBJ with your application
// rather than with AVTSM.LIB.  Before calling any Tsm
// functions, call TsmThunkInit.  Before exiting your application,
// call TsmThunkTerm.
//

#include "winlocal.h"

#include <stdlib.h>

#include "avtsm.h"
#include "tsmthunk.h"
#include "loadlib.h"
#include "mem.h"
#include "trace.h"

extern HINSTANCE g_hInstLib;

////
//	private definitions
////

#define TSMTHUNK_LIBNAME		"avtsm.dll"

#ifdef TSMTHUNK
#undef TSMTHUNK
#endif

extern HINSTANCE g_hInstLib;

// tsmthunk control struct
//
typedef struct TSMTHUNK
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	HINSTANCE hInstLib;
} TSMTHUNK, FAR *LPTSMTHUNK;

// tsmthunk function struct
//
typedef struct TSMTHUNKFN
{
	int index;
	LPSTR lpszName;
	FARPROC lpfn;
} TSMTHUNKFN, FAR *LPTSMTHUNKFN;

enum
{
	iTsmInit = 0,
	iTsmTerm,
	iTsmSetSpeed,
	iTsmConvert,
	iTsmSupportsSpeed,

	TSMTHUNK_MAXFUNCTIONS
};

static TSMTHUNKFN aTsmThunkFn[] =
{
	iTsmInit, "TsmInit", NULL,
	iTsmTerm, "TsmTerm", NULL,
	iTsmSetSpeed, "TsmSetSpeed", NULL,
	iTsmConvert, "TsmConvert", NULL,
	iTsmSupportsSpeed, "TsmSupportsSpeed", NULL
};

// helper functions
//
static LPTSMTHUNK TsmThunkGetPtr(HTSMTHUNK hTsmThunk);
static HTSMTHUNK TsmThunkGetHandle(LPTSMTHUNK lpTsmThunk);

////
//	public functions
////

// TsmThunkInit - initialize tsmthunk engine
//		<dwVersion>			(i) must be TSMTHUNK_VERSION
// 		<hInst>				(i) instance handle of calling module
// return handle (NULL if error)
//
HTSMTHUNK DLLEXPORT WINAPI TsmThunkInit(DWORD dwVersion, HINSTANCE hInst)
{
	BOOL fSuccess = TRUE;
	LPTSMTHUNK lpTsmThunk = NULL;

	if (dwVersion != TSMTHUNK_VERSION)
		fSuccess = TraceFALSE(NULL);
	
	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);
                        
	else if ((lpTsmThunk = (LPTSMTHUNK) MemAlloc(NULL, sizeof(TSMTHUNK), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		int i;
		
		lpTsmThunk->dwVersion = dwVersion;
		lpTsmThunk->hInst = hInst;
		lpTsmThunk->hTask = GetCurrentTask();
		lpTsmThunk->hInstLib = NULL;

		// load the library if possible
		//
		if ((lpTsmThunk->hInstLib = LoadLibraryPath(TSMTHUNK_LIBNAME, g_hInstLib, 0)) == NULL)
			fSuccess = TraceFALSE(NULL);

		// get the address of each function in library
		//
		else for (i = 0; i < SIZEOFARRAY(aTsmThunkFn); ++i)
		{
			if (aTsmThunkFn[i].index != i)
				fSuccess = TraceFALSE(NULL);

			else if ((aTsmThunkFn[i].lpfn = GetProcAddress(lpTsmThunk->hInstLib,
				aTsmThunkFn[i].lpszName)) == NULL)
			{
				TracePrintf_1(NULL, 6,
					TEXT("GetProcAddress failed\n   fn=%s\n"),
					(LPTSTR) aTsmThunkFn[i].lpszName);
				fSuccess = TraceFALSE(NULL);
			}
		}
	}

	if (!fSuccess)
	{
		TsmThunkTerm(TsmThunkGetHandle(lpTsmThunk));
		lpTsmThunk = NULL;
	}

	return fSuccess ? TsmThunkGetHandle(lpTsmThunk) : NULL;
}


// TsmThunkTerm - shut down tsmthunk engine
//		<hTsmThunk>				(i) handle returned from TsmThunkInit
// return 0 if success
//
int DLLEXPORT WINAPI TsmThunkTerm(HTSMTHUNK hTsmThunk)
{
	BOOL fSuccess = TRUE;
	LPTSMTHUNK lpTsmThunk;

	if ((lpTsmThunk = TsmThunkGetPtr(hTsmThunk)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		// library no longer needed
		//
		FreeLibrary(lpTsmThunk->hInstLib);

		if ((lpTsmThunk = MemFree(NULL, lpTsmThunk)) != NULL)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// Tsm thunk functions
//

HTSM DLLEXPORT WINAPI TsmInit(DWORD dwVersion, HINSTANCE hInst,
	LPWAVEFORMATEX lpwfx, int nScaleEfficiency, long sizBufSrcMax,
	DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	HTSM (WINAPI *lpfnTsmInit)(DWORD dwVersion, HINSTANCE hInst,
		LPWAVEFORMATEX lpwfx, int nScaleEfficiency, long sizBufSrcMax,
		DWORD dwFlags);
	HTSM hTsm;

	if (aTsmThunkFn[iTsmInit].index != iTsmInit)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTsmInit = aTsmThunkFn[iTsmInit].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		hTsm = (*lpfnTsmInit)(dwVersion, hInst,
			lpwfx, nScaleEfficiency, sizBufSrcMax, dwFlags);
	}

	return fSuccess ? hTsm : NULL;
}

int DLLEXPORT WINAPI TsmTerm(HTSM hTsm)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTsmTerm)(HTSM hTsm);
	int iRet;

	if (aTsmThunkFn[iTsmTerm].index != iTsmTerm)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTsmTerm = aTsmThunkFn[iTsmTerm].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTsmTerm)(hTsm);
	}

	return fSuccess ? iRet : -1;
}

int DLLEXPORT WINAPI TsmSetSpeed(HTSM hTsm, int nLevel, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	int (WINAPI *lpfnTsmSetSpeed)(HTSM hTsm, int nLevel, DWORD dwFlags);
	int iRet;

	if (aTsmThunkFn[iTsmSetSpeed].index != iTsmSetSpeed)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTsmSetSpeed = aTsmThunkFn[iTsmSetSpeed].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		iRet = (*lpfnTsmSetSpeed)(hTsm, nLevel, dwFlags);
	}

	return fSuccess ? iRet : -1;
}

long DLLEXPORT WINAPI TsmConvert(HTSM hTsm,
	void _huge *hpBufSrc, long sizBufSrc,
	void _huge *hpBufDst, long sizBufDst,
	DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	long (WINAPI *lpfnTsmConvert)(HTSM hTsm,
		void _huge *hpBufSrc, long sizBufSrc,
		void _huge *hpBufDst, long sizBufDst,
		DWORD dwFlags);
	long lRet;

	if (aTsmThunkFn[iTsmConvert].index != iTsmConvert)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTsmConvert = aTsmThunkFn[iTsmConvert].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lRet = (*lpfnTsmConvert)(hTsm,
			hpBufSrc, sizBufSrc, hpBufDst, sizBufDst, dwFlags);
	}

	return fSuccess ? lRet : -1;
}

BOOL DLLEXPORT WINAPI TsmSupportsSpeed(int nLevel, LPWAVEFORMATEX lpwfx, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	BOOL (WINAPI *lpfnTsmSupportsSpeed)(int nLevel, LPWAVEFORMATEX lpwfx, DWORD dwFlags);
	BOOL fRet;

	if (aTsmThunkFn[iTsmSupportsSpeed].index != iTsmSupportsSpeed)
		fSuccess = TraceFALSE(NULL);

	else if (((FARPROC) lpfnTsmSupportsSpeed = aTsmThunkFn[iTsmSupportsSpeed].lpfn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		fRet = (*lpfnTsmSupportsSpeed)(nLevel, lpwfx, dwFlags);
	}

	return fSuccess ? fRet : FALSE;
}

////
//	helper functions
////

// TsmThunkGetPtr - verify that tsmthunk handle is valid,
//		<hTsmThunk>				(i) handle returned from TsmThunkInit
// return corresponding tsmthunk pointer (NULL if error)
//
static LPTSMTHUNK TsmThunkGetPtr(HTSMTHUNK hTsmThunk)
{
	BOOL fSuccess = TRUE;
	LPTSMTHUNK lpTsmThunk;

	if ((lpTsmThunk = (LPTSMTHUNK) hTsmThunk) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpTsmThunk, sizeof(TSMTHUNK)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the tsmthunk handle
	//
	else if (lpTsmThunk->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpTsmThunk : NULL;
}

// TsmThunkGetHandle - verify that tsmthunk pointer is valid,
//		<lpTsmThunk>				(i) pointer to TSMTHUNK struct
// return corresponding tsmthunk handle (NULL if error)
//
static HTSMTHUNK TsmThunkGetHandle(LPTSMTHUNK lpTsmThunk)
{
	BOOL fSuccess = TRUE;
	HTSMTHUNK hTsmThunk;

	if ((hTsmThunk = (HTSMTHUNK) lpTsmThunk) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hTsmThunk : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\avwav\vox.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// vox.h - interface to vox file functions in vox.c
////

#ifndef __VOX_H__
#define __VOX_H__

#include "winlocal.h"

#include "wavfmt.h"

#define VOX_VERSION 0x00000106

// handle to a vox engine instance
//
DECLARE_HANDLE32(HVOX);

#ifdef __cplusplus
extern "C" {
#endif

// these macros for compatibility with old code
//
#define VoxFormat(lpwfx, nSamplesPerSec) \
	WavFormatVoxadpcm(lpwfx, nSamplesPerSec)
#define VoxFormatPcm(lpwfx) \
	WavFormatPcm(6000, 16, 1, lpwfx)

// VoxInit - initialize vox engine
//		<dwVersion>			(i) must be VOX_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<dwFlags>			(i) reserved; must be 0
// return handle (NULL if error)
//
HVOX DLLEXPORT WINAPI VoxInit(DWORD dwVersion, HINSTANCE hInst, DWORD dwFlags);

// VoxTerm - shut down vox engine
//		<hVox>				(i) handle returned from VoxInit
// return 0 if success
//
int DLLEXPORT WINAPI VoxTerm(HVOX hVox);

// VoxReset - reset vox engine
//		<hVox>				(i) handle returned from VoxInit
// return 0 if success
//
int DLLEXPORT WINAPI VoxReset(HVOX hVox);

// VoxDecode_16BitMono - decode vox samples
//		<hVox>				(i) handle returned from VoxInit
//		<lpabVox>			(i) array of encoded samples
//		<lpaiPcm>			(o) array of decoded samples
//		<uSamples>			(i) number of samples to decode
// return 0 if success
//
// NOTE: each BYTE in <lpabVox> contains 2 12-bit encoded samples
// in OKI ADPCM Vox format, as described by Dialogic
// Each PCM16 in <lpaiPcm> contains 1 16-bit decoded sample
// in standard PCM format.
//
int DLLEXPORT WINAPI VoxDecode_16BitMono(HVOX hVox, LPBYTE lpabVox, LPPCM16 lpaiPcm, UINT uSamples);

// VoxEncode_16BitMono - encode vox samples
//		<hVox>				(i) handle returned from VoxInit
//		<lpaiPcm>			(i) array of decoded samples
//		<lpabVox>			(o) array of encoded samples
//		<uSamples>			(i) number of samples to encode
// return 0 if success
//
// NOTE: each BYTE in <lpabVox> contains 2 12-bit encoded samples
// in OKI ADPCM Vox format, as described by Dialogic
// Each PCM16 in <lpaiPcm> contains 1 16-bit decoded sample
// in standard PCM format.
//
int DLLEXPORT WINAPI VoxEncode_16BitMono(HVOX hVox, LPPCM16 lpaiPcm, LPBYTE lpabVox, UINT uSamples);

// VoxDecode_8BitMono - decode vox samples
//		<hVox>				(i) handle returned from VoxInit
//		<lpabVox>			(i) array of encoded samples
//		<lpabPcm>			(o) array of decoded samples
//		<uSamples>			(i) number of samples to decode
// return 0 if success
//
// NOTE: each BYTE in <lpabVox> contains 2 12-bit encoded samples
// in OKI ADPCM Vox format, as described by Dialogic
// Each PCM8 in <lpabPcm> contains 1 8-bit decoded sample
// in standard PCM format.
//
int DLLEXPORT WINAPI VoxDecode_8BitMono(HVOX hVox, LPBYTE lpabVox, LPPCM8 lpabPcm, UINT uSamples);

// VoxEncode_8BitMono - encode vox samples
//		<hVox>				(i) handle returned from VoxInit
//		<lpabPcm>			(i) array of decoded samples
//		<lpabVox>			(o) array of encoded samples
//		<uSamples>			(i) number of samples to encode
// return 0 if success
//
// NOTE: each BYTE in <lpabVox> contains 2 12-bit encoded samples
// in OKI ADPCM Vox format, as described by Dialogic
// Each PCM8 in <lpabPcm> contains 1 8-bit decoded sample
// in standard PCM format.
//
int DLLEXPORT WINAPI VoxEncode_8BitMono(HVOX hVox, LPPCM8 lpabPcm, LPBYTE lpabVox, UINT uSamples);

// VoxIOProc - i/o procedure for vox format file data
//		<lpmmioinfo>		(i/o) information about open file
//		<uMessage>			(i) message indicating the requested I/O operation
//		<lParam1>			(i) message specific parameter
//		<lParam2>			(i) message specific parameter
// returns 0 if message not recognized, otherwise message specific value
//
// NOTE: the address of this function should be passed to the WavOpen()
// or mmioInstallIOProc() functions for accessing vox format file data.
//
LRESULT DLLEXPORT CALLBACK VoxIOProc(LPTSTR lpmmioinfo,
	UINT uMessage, LPARAM lParam1, LPARAM lParam2);

#ifdef __cplusplus
}
#endif

#endif // __VOX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\avwav\tsmthunk.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// tsmthunk.h - interface for tsm thunk functions in tsmthunk.c
////

#ifndef __TSMTHUNK_H__
#define __TSMTHUNK_H__

#include "winlocal.h"

#define TSMTHUNK_VERSION 0x00000107

// handle to tsmthunk engine
//
DECLARE_HANDLE32(HTSMTHUNK);

#ifdef __cplusplus
extern "C" {
#endif

// TsmThunkInit - initialize tsmthunk engine
//		<dwVersion>			(i) must be TSMTHUNK_VERSION
// 		<hInst>				(i) instance handle of calling module
// return handle (NULL if error)
//
HTSMTHUNK DLLEXPORT WINAPI TsmThunkInit(DWORD dwVersion, HINSTANCE hInst);

// TsmThunkTerm - shut down tsmthunk engine
//		<hTsmThunk>				(i) handle returned from TsmThunkInit
// return 0 if success
//
int DLLEXPORT WINAPI TsmThunkTerm(HTSMTHUNK hTsmThunk);

#ifdef __cplusplus
}
#endif

#endif // __TSMTHUNK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\avwav\wav.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// wav.h - interface for wav functions in wav.c
////

#ifndef __WAV_H__
#define __WAV_H__

#ifdef _WIN32
#define MULTITHREAD 1
#endif

#include "winlocal.h"

#include "wavfmt.h"
#include "wavout.h"
#include "wavin.h"

#define WAV_VERSION 0x00000108

// <dwFlags> values in WavInit
//
#define WAV_TELTHUNK		0x00004000
#define WAV_NOTSMTHUNK		0x00008000
#define WAV_VOXADPCM		0x00000001

// <dwFlags> values in WavOpen
//
#define WAV_READ			0x00000000
#define WAV_WRITE			0x00000001
#define WAV_READWRITE		0x00000002
#define WAV_CREATE			0x00000004
#define WAV_NORIFF			0x00000008
#define WAV_MEMORY			0x00000010
#define WAV_RESOURCE		0x00000020
#define WAV_DENYNONE		0x00000040
#define WAV_DENYREAD		0x00000080
#define WAV_DENYWRITE		0x00000100
#define WAV_EXCLUSIVE		0x00000200
#define WAV_NOACM			0x00000400
#define WAV_DELETE			0x00000800
#define WAV_EXIST			0x00001000
#define WAV_GETTEMP			0x00002000
#define WAV_TELRFILE		0x00008000
#ifdef MULTITHREAD
#define WAV_MULTITHREAD		0x00010000
#define WAV_SINGLETHREAD	0x00020000
#define WAV_COINITIALIZE	0x00040000
#endif

// <dwFlags> values in WavPlay
//
#define WAV_PLAYASYNC		0x00000000
#define WAV_PLAYSYNC		0x00001000
#define WAV_AUTOSTOP		0x00002000
#define WAV_NOAUTOSTOP		0x00004000
#define WAV_AUTOCLOSE		0x00008000

// <dwFlags> values in WavRecord
//
#define WAV_RECORDASYNC		0x00000000
#define WAV_RECORDSYNC		0x00010000

// <dwFlags> values in WavPlaySound
//
#define WAV_ASYNC			0x00000000
#define WAV_SYNC			0x00100000
#define WAV_FILENAME		0x00200000
#define WAV_NODEFAULT		0x00400000
#define WAV_LOOP			0x00800000
#define WAV_NOSTOP			0x01000000
#define WAV_OPENRETRY		0x10000000

// control flags for WavSetSpeed and WavSupportsSpeed
//
#define WAVSPEED_NOPLAYBACKRATE	0x00000001
#define WAVSPEED_NOFORMATADJUST	0x00000002
#define WAVSPEED_NOTSM			0x00000004
#define WAVSPEED_NOACM			0x00000400

// return values from WavGetState
//
#define WAV_STOPPED			0x0001
#define WAV_PLAYING			0x0002
#define WAV_RECORDING		0x0004
#define WAV_STOPPING		0x0008

// <dwFlags> values in WavGetFormat and WavSetFormat
//
#define WAV_FORMATFILE		0x0001
#define WAV_FORMATPLAY		0x0002
#define WAV_FORMATRECORD	0x0004
#define WAV_FORMATALL		(WAV_FORMATFILE | WAV_FORMATPLAY | WAV_FORMATRECORD)

// <dwFlags> values in WavSetVolume and WavSupportsVolume
//
#define WAVVOLUME_MIXER		0x0001

#ifdef TELTHUNK
// control flags for WavOpenEx
//
#define WOX_LOCAL			0x00000001
#define WOX_REMOTE			0x00000002
#define WOX_WAVFMT			0x00000010
#define WOX_VOXFMT			0x00000020
#define WOX_WAVDEV			0x00000100
#define WOX_TELDEV			0x00000200
#endif

// handle returned from WavInit
//
DECLARE_HANDLE32(HWAVINIT);

// handle returned from WavOpen // (NOT the same as Windows HWAVE)
//
DECLARE_HANDLE32(HWAV);

// prototype for <lpfnUserAbort> in WavCopy
//
typedef BOOL (CALLBACK* USERABORTPROC)(DWORD dwUser, int nPctComplete);

// prototype for <lpfnPlayStopped> in WavPlay
//
typedef BOOL (CALLBACK* PLAYSTOPPEDPROC)(HWAV hWav, HANDLE hUser, DWORD dwReserved);

// prototype for <lpfnRecordStopped> in WavRecord
//
typedef BOOL (CALLBACK* RECORDSTOPPEDPROC)(HWAV hWav, DWORD dwUser, DWORD dwReserved);

#ifdef __cplusplus
extern "C" {
#endif

// WavInit - initialize wav engine
//		<dwVersion>			(i) must be WAV_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<dwFlags>			(i) control flags
#ifdef TELTHUNK
//			WAV_TELTHUNK		initialize telephone thunking layer
#endif
//			WAV_NOACM			do not use audio compression manager
//			WAV_VOXADPCM		load acm driver for Dialogic OKI ADPCM
// return handle (NULL if error)
//
HWAVINIT WINAPI WavInit(DWORD dwVersion, HINSTANCE hInst, DWORD dwFlags);

// WavTerm - shut down wav engine
//		<hWavInit>			(i) handle returned from WavInit
// return 0 if success
//
int WINAPI WavTerm(HWAVINIT hWavInit);

// WavOpen - open or create wav file
//		<dwVersion>			(i) must be WAV_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<lpszFileName>		(i) name of file to open or create
//		<lpwfx>				(i) wave format
//			NULL				use format from header or default
//		<lpIOProc>			(i) address of i/o procedure to use
//			NULL				use default i/o procedure
//		<lpadwInfo>			(i) data to pass to i/o procedure during open
//			NULL				no data to pass
//		<dwFlags>			(i) control flags
//			WAV_READ			open file for reading (default)
//			WAV_WRITE			open file for writing
//			WAV_READWRITE		open file for reading and writing
//			WAV_DENYNONE		allow other programs read and write access
//			WAV_DENYREAD		prevent other programs from read access
//			WAV_DENYWRITE		prevent other programs from write access
//			WAV_EXCLUSIVE		prevent other programs from read or write
//			WAV_CREATE			create new file or truncate existing file
//			WAV_NORIFF			file has no RIFF/WAV header
//			WAV_MEMORY			<lpszFileName> points to memory block
//			WAV_RESOURCE		<lpszFileName> points to wave resource
//			WAV_NOACM			do not use audio compression manager
//			WAV_DELETE			delete specified file, return TRUE if success
//			WAV_EXIST			return TRUE if specified file exists
//			WAV_GETTEMP			fill lpszFileName with temp name, return TRUE
//			WAV_TELRFILE		telephone will play audio from file on server
#ifdef MULTITHREAD
//			WAV_MULTITHREAD		support multiple threads (default)
//			WAV_SINGLETHREAD	do not support multiple threads
//			WAV_COINITIALIZE	call CoInitialize in all secondary threads
#endif
// return handle (NULL if error)
//
// NOTE: if WAV_CREATE or WAV_NORIFF are used in <dwFlags>, then the
// <lpwfx> parameter must be specified.  If <lpwfx> is NULL, the
// current default format is assumed.
// WavSetFormat() can be used to set or override the defaults.
//
// NOTE: if WAV_RESOURCE is specified in <dwFlags>, then <lpszFileName>
// must point to a WAVE resource in the module specified by <hInst>.
// If the first character of the string is a pound sign (#), the remaining
// characters represent a decimal number that specifies the resource id.
//
// NOTE: if WAV_MEMORY is specified in <dwFlags>, then <lpszFileName>
// must be a pointer to a memory block obtained by calling MemAlloc().
//
// NOTE: if <lpIOProc> is not NULL, this i/o procedure will be called
// for opening, closing, reading, writing, and seeking the wav file.
// If <lpadwInfo> is not NULL, this array of three (3) DWORDs will be
// passed to the i/o procedure when the wav file is opened.
// See the Windows mmioOpen() and mmioInstallIOProc() function for details
// on these parameters.  Also, the WAV_MEMORY and WAV_RESOURCE flags may
// only be used when <lpIOProc> is NULL.
//
HWAV WINAPI WavOpen(DWORD dwVersion, HINSTANCE hInst,
	LPCTSTR lpszFileName, LPWAVEFORMATEX lpwfx,
	LPMMIOPROC lpIOProc, DWORD FAR *lpadwInfo, DWORD dwFlags);

// WavClose - close wav file
//		<hWav>				(i) handle returned from WavOpen
// return 0 if success
//
int WINAPI WavClose(HWAV hWav);

// WavPlayEx - play data from wav file
//		<hWav>				(i) handle returned from WavOpen
//		<idDev>				(i) wav output device id
//			-1					use any suitable output device
//		<lpfnPlayStopped>	(i) function to call when play is stopped
//			NULL				do not notify
//		<hUserPlayStopped>	(i) param to pass to lpfnPlayStopped
//		<dwReserved>		(i) reserved; must be zero
//		<dwFlags>			(i) control flags
//			WAV_PLAYASYNC		return when playback starts (default)
//			WAV_PLAYSYNC		return after playback completes
//			WAV_NOSTOP			if device already playing, don't stop it
//			WAV_AUTOSTOP		stop playback when eof reached (default)
//			WAV_NOAUTOSTOP		continue playback until WavStop called
//			WAV_AUTOCLOSE		close wav file after playback stops
//			WAV_OPENRETRY		if output device busy, retry for up to 2 sec
// return 0 if success
//
// NOTE: data from the wav file is sent to the output device in chunks.
// Chunks are submitted to an output device queue, so that when one
// chunk is finished playing, another is ready to start playing. By
// default, each chunk is large enough to hold approximately 666 ms
// of sound, and 3 chunks are maintained in the output device queue.
// WavSetChunks() can be used to override the defaults.
//
// NOTE: if WAV_NOSTOP is specified in <dwFlags>, and the device specified
// by <idDev> is already in use, this function returns without playing.
// Unless this flag is specified, the specified device will be stopped
// so that the new sound can be played.
//
// NOTE: if WAV_AUTOSTOP is specified in <dwFlags>, WavStop() will be
// called automatically when end of file is reached.  This is the
// default behavior, but can be overridden by using the WAV_NOAUTOSTOP
// flag.  WAV_NOAUTOSTOP is useful if you are playing a file that
// is growing dynamically as another program writes to it. If this is
// the case, also use the WAV_DENYNONE flag when calling WavOpen().
//
// NOTE: if WAV_AUTOCLOSE is specified in <dwFlags>, WavClose() will
// be called automatically when playback completes.  This will happen
// when WavStop() is called explicitly, or when WavPlay() reaches end
// of file and WAV_NOAUTOSTOP was not specified.  WAV_AUTOCLOSE is useful
// when used with WAV_PLAYASYNC, since cleanup occurs automatically.
// The <hWav> handle is thereafter invalid, and should not be used again.
//
int WINAPI WavPlay(HWAV hWav, int idDev, DWORD dwFlags);
int DLLEXPORT WINAPI WavPlayEx(HWAV hWav, int idDev,
	PLAYSTOPPEDPROC lpfnPlayStopped, HANDLE hUserPlayStopped,
	DWORD dwReserved, DWORD dwFlags);

// WavRecordEx - record data to wav file
//		<hWav>				(i) handle returned from WavOpen
//		<idDev>				(i) wav input device id
//			-1					use any suitable input device
//		<lpfnRecordStopped>	(i) function to call when record is stopped
//			NULL				do not notify
//		<dwUserRecordStopped>	(i) param to pass to lpfnRecordStopped
//		<msMaxSize>			(i) stop recording if file reaches this size
//			0					no maximum size
//		<dwFlags>			(i) control flags
//			WAV_RECORDASYNC		return when recording starts (default)
//			WAV_RECORDSYNC		return after recording completes
//			WAV_NOSTOP			if device already recording, don't stop it
//			WAV_OPENRETRY		if input device busy, retry for up to 2 sec
// return 0 if success
//
// NOTE: data from the input device is written to the wav file in chunks.
// Chunks are submitted to an input device queue, so that when one
// chunk is finished recording, another is ready to start recording.
// By default, each chunk is large enough to hold approximately 666 ms
// of sound, and 3 chunks are maintained in the input device queue.
// WavSetChunks() can be used to override the defaults.
//
// NOTE: if WAV_NOSTOP is specified in <dwFlags>, and the device specified
// by <idDev> is already in use, this function returns without recording.
// Unless this flag is specified, the specified device will be stopped
// so that the new sound can be recorded.
//
int WINAPI WavRecord(HWAV hWav, int idDev, DWORD dwFlags);
int DLLEXPORT WINAPI WavRecordEx(HWAV hWav, int idDev,
	RECORDSTOPPEDPROC lpfnRecordStopped, DWORD dwUserRecordStopped,
 	long msMaxSize, DWORD dwFlags);

// WavStop - stop playing and/or recording
//		<hWav>				(i) handle returned from WavOpen
// return 0 if success
//
int WINAPI WavStop(HWAV hWav);

// WavRead - read data from wav file
//		<hWav>				(i) handle returned from WavOpen
//		<hpBuf>				(o) buffer to contain bytes read
//		<sizBuf>			(i) size of buffer in bytes
// return bytes read (-1 if error)
//
// NOTE : Even if the read operation does not reach the end of file,
// the number of bytes returned could be less than <sizBuf> if data
// decompression is performed by the wav file's I/O procedure. See the
// <lpIOProc> parameter in WavOpen.  It is safest to keep calling
// WavRead() until 0 bytes are read.
//
long DLLEXPORT WINAPI WavRead(HWAV hWav, void _huge *hpBuf, long sizBuf);

// WavWrite - write data to wav file
//		<hWav>				(i) handle returned from WavOpen
//		<hpBuf>				(i) buffer containing bytes to write
//		<sizBuf>			(i) size of buffer in bytes
// return bytes written (-1 if error)
//
// NOTE : Even if the write operation successfully completes,
// the number of bytes returned could be less than <sizBuf> if data
// compression is performed by the wav file's I/O procedure. See the
// <lpIOProc> parameter in WavOpen.  It is safest to assume no error
// in WavWrite() occurred if the return value is greater than 0.
//
long DLLEXPORT WINAPI WavWrite(HWAV hWav, void _huge *hpBuf, long sizBuf);

// WavSeek - seek within wav file data
//		<hWav>				(i) handle returned from WavOpen
//		<lOffset>			(i) bytes to move pointer
//		<nOrigin>			(i) position to move from
//			0					move pointer relative to start of data chunk
//			1					move pointer relative to current position
//			2					move pointer relative to end of data chunk
// return new file position (-1 if error)
//
long DLLEXPORT WINAPI WavSeek(HWAV hWav, long lOffset, int nOrigin);

// WavGetState - return current wav state
//		<hWav>				(i) handle returned from WavOpen
// return WAV_STOPPED, WAV_PLAYING, WAV_RECORDING, or 0 if error
//
WORD DLLEXPORT WINAPI WavGetState(HWAV hWav);

// WavGetLength - get current wav data length in milleseconds
//		<hWav>				(i) handle returned from WavOpen
// return milleseconds if success, otherwise -1
//
long DLLEXPORT WINAPI WavGetLength(HWAV hWav);

// WavSetLength - set current wav data length in milleseconds
//		<hWav>				(i) handle returned from WavOpen
//		<msLength>			(i) length in milleseconds
// return new length in milleseconds if success, otherwise -1
//
// NOTE: afterwards, the current wav data position is set to either
// the previous wav data position or <msLength>, whichever is smaller.
//
long DLLEXPORT WINAPI WavSetLength(HWAV hWav, long msLength);

// WavGetPosition - get current wav data position in milleseconds
//		<hWav>				(i) handle returned from WavOpen
// return milleseconds if success, otherwise -1
//
long DLLEXPORT WINAPI WavGetPosition(HWAV hWav);

// WavSetPosition - set current wav data position in milleseconds
//		<hWav>				(i) handle returned from WavOpen
//		<msPosition>		(i) position in milleseconds
// return new position in milleseconds if success, otherwise -1
//
long DLLEXPORT WINAPI WavSetPosition(HWAV hWav, long msPosition);

// WavGetFormat - get wav format
//		<hWav>				(i) handle returned from WavOpen
//		<dwFlags>			(i) control flags
//			WAV_FORMATFILE		get format of data in file
//			WAV_FORMATPLAY		get format of output device
//			WAV_FORMATRECORD	get format of input device
// return pointer to specified format, NULL if error
//
// NOTE: the format structure returned is dynamically allocated.
// Use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI WavGetFormat(HWAV hWav, DWORD dwFlags);

// WavSetFormat - set wav format
//		<hWav>				(i) handle returned from WavOpen
//		<lpwfx>				(i) wav format
//		<dwFlags>			(i) control flags
//			WAV_FORMATFILE		set format of data in file
//			WAV_FORMATPLAY		set format of output device
//			WAV_FORMATRECORD	set format of input device
//			WAV_FORMATALL		set all formats
// return 0 if success
//
int DLLEXPORT WINAPI WavSetFormat(HWAV hWav,
	LPWAVEFORMATEX lpwfx, DWORD dwFlags);

// WavChooseFormat - choose and set audio format from dialog box
//		<hWav>				(i) handle returned from WavOpen
//		<hwndOwner>			(i) owner of dialog box
//			NULL				no owner
//		<lpszTitle>			(i) title of the dialog box
//			NULL				use default title ("Sound Selection")
//		<dwFlags>			(i)	control flags
//			WAV_FORMATFILE		set format of data in file
//			WAV_FORMATPLAY		set format of output device
//			WAV_FORMATRECORD	set format of input device
//			WAV_FORMATALL		set all formats
// return 0 if success
//
int DLLEXPORT WINAPI WavChooseFormat(HWAV hWav, HWND hwndOwner, LPCTSTR lpszTitle, DWORD dwFlags);

// WavGetVolume - get current volume level
//		<hWav>				(i) handle returned from WavOpen
//		<idDev>				(i) wav output device id
//			-1					use any suitable output device
//		<dwFlags>			(i) reserved; must be zero
// return volume level (0 minimum through 100 maximum, -1 if error)
//
int DLLEXPORT WINAPI WavGetVolume(HWAV hWav, int idDev, DWORD dwFlags);

// WavSetVolume - set current volume level
//		<hWav>				(i) handle returned from WavOpen
//		<idDev>				(i) wav output device id
//			-1					use any suitable output device
//		<nLevel>			(i) volume level
//			0					minimum volume
//			100					maximum volume
//		<dwFlags>			(i) control flags
//			WAVVOLUME_MIXER		set volume through mixer device
// return 0 if success
//
int DLLEXPORT WINAPI WavSetVolume(HWAV hWav, int idDev, int nLevel, DWORD dwFlags);

// WavSupportsVolume - check if audio can be played at specified volume
//		<hWav>				(i) handle returned from WavOpen
//		<idDev>				(i) wav output device id
//			-1					any suitable output device
//		<nLevel>			(i) volume level
//			0					minimum volume
//			100					maximum volume
//		<dwFlags>			(i) control flags
//			WAVVOLUME_MIXER		check volume support through mixer device
// return TRUE if supported
//
BOOL DLLEXPORT WINAPI WavSupportsVolume(HWAV hWav, int idDev, int nLevel, DWORD dwFlags);

// WavGetSpeed - get current speed level
//		<hWav>				(i) handle returned from WavOpen
//		<idDev>				(i) wav output device id
//			-1					use any suitable output device
//		<dwFlags>			(i) reserved; must be zero
// return speed level (100 is normal, 50 is half, 200 is double, -1 if error)
//
int DLLEXPORT WINAPI WavGetSpeed(HWAV hWav, int idDev, DWORD dwFlags);

// WavSetSpeed - set current speed level
//		<hWav>				(i) handle returned from WavOpen
//		<idDev>				(i) wav output device id
//			-1					use any suitable output device
//		<nLevel>			(i) speed level
//			50					half speed
//			100					normal speed
//			200					double speed, etc.
//		<dwFlags>			(i) control flags
#ifdef AVTSM
//			WAVSPEED_NOTSM			do not use time scale modification engine
#endif
//			WAVSPEED_NOPLAYBACKRATE	do not use device driver playback rate
//			WAVSPEED_NOFORMATADJUST	do not use adjusted format to open device
//			WAVSPEED_NOACM			do not use audio compression manager
// return 0 if success
//
// NOTE: In order to accomodate the specified speed change, it is _possible_
// that this function will in turn call WavSetFormat(hWav, ..., WAV_FORMATPLAY)
// to change the playback format of the specified file. You can prevent this
// side-effect by specifying the WAVSPEED_NOACM flag, but this reduces the
// likelihood that WavSetSpeed will succeed.
//
int DLLEXPORT WINAPI WavSetSpeed(HWAV hWav, int idDev, int nLevel, DWORD dwFlags);

// WavSupportsSpeed - check if audio can be played at specified speed
//		<hWav>				(i) handle returned from WavOpen
//		<idDev>				(i) wav output device id
//			-1					any suitable output device
//		<nLevel>			(i) speed level
//			50					half speed
//			100					normal speed
//			200					double speed, etc.
//		<dwFlags>			(i) control flags
#ifdef AVTSM
//			WAVSPEED_NOTSM			do not use time scale modification engine
#endif
//			WAVSPEED_NOPLAYBACKRATE	do not use device driver playback rate
//			WAVSPEED_NOFORMATADJUST	do not use adjusted format to open device
//			WAVSPEED_NOACM			do not use audio compression manager
// return TRUE if supported
//
BOOL DLLEXPORT WINAPI WavSupportsSpeed(HWAV hWav, int idDev, int nLevel, DWORD dwFlags);

// WavGetChunks - get chunk count and size
//		<hWav>				(i) handle returned from WavOpen
//			NULL				get default chunk count and size
//		<lpcChunks>			(o) buffer to hold chunk count
//			NULL				do not get chunk count
//		<lpmsChunkSize>		(o) buffer to hold chunk size
//			NULL				do not get chunk size
//		<fWavOut>			(i) TRUE for playback, FALSE for recording
// return 0 if success
//
int DLLEXPORT WINAPI WavGetChunks(HWAV hWav,
	int FAR *lpcChunks, long FAR *lpmsChunkSize, BOOL fWavOut);

// WavSetChunks - set chunk count and size
//		<hWav>				(i) handle returned from WavOpen
//			NULL				set default chunk count and size
//		<cChunks>			(i) number of chunks in device queue
//			-1					do not set chunk count
//		<msChunkSize>		(i) chunk size in milleseconds
//			-1					do not set chunk size
//		<fWavOut>			(i) TRUE for playback, FALSE for recording
// return 0 if success
//
int DLLEXPORT WINAPI WavSetChunks(HWAV hWav, int cChunks, long msChunkSize, BOOL fWavOut);

// WavCalcChunkSize - calculate chunk size in bytes
//		<lpwfx>				(i) wav format
//		<msPlayChunkSize>	(i) chunk size in milleseconds
//			-1					default chunk size
//		<fWavOut>			(i) TRUE for playback, FALSE for recording
// return chunk size in bytes (-1 if success)
//
long DLLEXPORT WINAPI WavCalcChunkSize(LPWAVEFORMATEX lpwfx,
	long msChunkSize, BOOL fWavOut);

// WavCopy - copy data from one open wav file to another
//		<hWavSrc>			(i) source handle returned from WavOpen
//		<hWavDst>			(i) destination handle returned from WavOpen
//		<hpBuf>				(o) pointer to copy buffer
//			NULL				allocate buffer internally
//		<sizBuf>			(i) size of copy buffer
//			-1					default buffer size (16K)
//		<lpfnUserAbort>		(i) function that returns TRUE if user aborts
//			NULL				don't check for user abort
//		<dwUser>			(i) parameter passed to <lpfnUserAbort>
//		<dwFlags>			(i) control flags
//			WAV_NOACM			do not use audio compression manager
// return 0 if success (-1 if error, +1 if user abort)
//
int DLLEXPORT WINAPI WavCopy(HWAV hWavSrc, HWAV hWavDst,
	void _huge *hpBuf, long sizBuf, USERABORTPROC lpfnUserAbort, DWORD dwUser, DWORD dwFlags);

#ifdef AVTSM
// WavReadFormatSpeed - read data from wav file, then format it for speed
//		<hWav>				(i) handle returned from WavOpen
//		<hpBufSpeed>		(o) buffer to contain bytes read
//		<sizBufSpeed>		(i) size of buffer in bytes
// return bytes formatted for speed in <hpBuf> (-1 if error)
//
// NOTE: this function reads a block of data, and then converts it
// from the file format to the speed format, unless those formats
// are identical.
//
long DLLEXPORT WINAPI WavReadFormatSpeed(HWAV hWav, void _huge *hpBufSpeed, long sizBufSpeed);
#endif

// WavReadFormatPlay - read data from wav file, then format it for playback
//		<hWav>				(i) handle returned from WavOpen
//		<hpBufPlay>			(o) buffer to contain bytes read
//		<sizBufPlay>		(i) size of buffer in bytes
// return bytes formatted for playback in <hpBuf> (-1 if error)
//
// NOTE: this function reads a block of data, and then converts it
// from the file format to the playback format, unless those formats
// are identical.
//
long DLLEXPORT WINAPI WavReadFormatPlay(HWAV hWav, void _huge *hpBufPlay, long sizBufPlay);

// WavWriteFormatRecord - write data to file after formatting it for file
//		<hWav>				(i) handle returned from WavOpen
//		<hpBufRecord>		(i) buffer containing bytes in record format
//		<sizBufRecord>		(i) size of buffer in bytes
// return bytes written (-1 if error)
//
// NOTE: this function converts a block of data from the record
// format to the file format (unless those formats are identical),
// and then writes the data to disk.
//
long DLLEXPORT WINAPI WavWriteFormatRecord(HWAV hWav, void _huge *hpBufRecord, long sizBufRecord);

// WavGetOutputDevice - get handle to open wav output device
//		<hWav>				(i) handle returned from WavOpen
// return handle to wav output device (NULL if device not open or error)
//
// NOTE: this function is useful only during playback (after calling
// WavPlay() and before calling WavStop()).  The returned device handle
// can then be used when calling the WavOut functions in wavout.h
//
HWAVOUT DLLEXPORT WINAPI WavGetOutputDevice(HWAV hWav);

// WavGetInputDevice - get handle to open wav input device
//		<hWav>				(i) handle returned from WavOpen
// return handle to wav input device (NULL if device not open or error)
//
// NOTE: this function is useful only during recording (after calling
// WavRecord() and before calling WavStop()).  The returned device handle
// can then be used when calling the WavIn functions in wavin.h
//
HWAVIN DLLEXPORT WINAPI WavGetInputDevice(HWAV hWav);

// WavPlaySound - play wav file
//		<dwVersion>			(i) must be WAV_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<idDev>				(i) wav output device id
//			-1					use any suitable output device
//		<lpszFileName>		(i) name of file to play
//			NULL				stop playing current sound, if any
//		<lpwfx>				(i) wave format
//			NULL				use format from header or default
//		<lpIOProc>			(i) address of i/o procedure to use
//			NULL				use default i/o procedure
//		<lpadwInfo>			(i) data to pass to i/o procedure during open
//			NULL				no data to pass
//		<dwFlags>			(i) control flags
//			WAV_ASYNC			return when playback starts (default)
//			WAV_SYNC			return after playback completes
//			WAV_FILENAME		<lpszFileName> points to a filename
//			WAV_RESOURCE		<lpszFileName> points to a resource
//			WAV_MEMORY			<lpszFileName> points to memory block
//			WAV_NODEFAULT		if sound not found, do not play default
//			WAV_LOOP			loop sound until WavPlaySound called again
//			WAV_NOSTOP			if device already playing, don't stop it
//			WAV_NORIFF			file has no RIFF/WAV header
//			WAV_NOACM			do not use audio compression manager
//			WAV_OPENRETRY		if output device busy, retry for up to 2 sec
#ifdef MULTITHREAD
//			WAV_MULTITHREAD		support multiple threads (default)
//			WAV_SINGLETHREAD	do not support multiple threads
//			WAV_COINITIALIZE	call CoInitialize in all secondary threads
#endif
// return 0 if success
//
// NOTE: if WAV_NORIFF is specified in <dwFlags>, then the
// <lpwfx> parameter must be specified.  If <lpwfx> is NULL, the
// current default format is assumed.
// WavSetFormat() can be used to set or override the defaults.
//
// NOTE: if WAV_FILENAME is specified in <dwFlags>, then <lpszFileName>
// must point to a file name.
//
// NOTE: if WAV_RESOURCE is specified in <dwFlags>, then <lpszFileName>
// must point to a WAVE resource in the module specified by <hInst>.
// If the first character of the string is a pound sign (#), the remaining
// characters represent a decimal number that specifies the resource id.
//
// NOTE: if WAV_MEMORY is specified in <dwFlags>, then <lpszFileName>
// must be a pointer to a memory block containing a wav file image.
// The pointer must be obtained by calling MemAlloc().
//
// NOTE: if neither WAV_FILENAME, WAV_RESOURCE, or WAV_MEMORY is specified
// in <dwFlags>, the [sounds] section of win.ini or the registry is
// searched for an entry matching <lpszFileName>.  If no matching entry
// is found, <lpszFileName> is assumed to be a file name.
//
// NOTE: if WAV_NODEFAULT is specified in <dwFlags>, no default sound
// will be played.  Unless this flag is specified, the default system
// event sound entry will be played if the sound specified in
// <lpszFileName> is not found.
//
// NOTE: if WAV_LOOP is specified in <dwFlags>, the sound specified in
// <lpszFileName> will be played repeatedly, until WavPlaySound() is
// called again.  The WAV_ASYNC flag must be specified when using this flag.
//
// NOTE: if WAV_NOSTOP is specified in <dwFlags>, and the device specified
// by <idDev> is already in use, this function returns without playing.
// Unless this flag is specified, the specified device will be stopped
// so that the new sound can be played.
//
// NOTE: if <lpIOProc> is not NULL, this i/o procedure will be called
// for opening, closing, reading, writing, and seeking the wav file.
// If <lpadwInfo> is not NULL, this array of three (3) DWORDs will be
// passed to the i/o procedure when the wav file is opened.
// See the Windows mmioOpen() and mmioInstallIOProc() function for details
// on these parameters.  Also, the WAV_MEMORY and WAV_RESOURCE flags may
// only be used when <lpIOProc> is NULL.
//
int DLLEXPORT WINAPI WavPlaySound(DWORD dwVersion, HINSTANCE hInst,
	int idDev, LPCTSTR lpszFileName, LPWAVEFORMATEX lpwfx,
	LPMMIOPROC lpIOProc, DWORD FAR *lpadwInfo, DWORD dwFlags);

// WavSendMessage - send a user-defined message to the i/o procedure
//		<hWav>				(i) handle returned from WavOpen
//		<wMsg>				(i) user-defined message id
//		<lParam1>			(i) parameter for the message
//		<lParam2>			(i) parameter for the message
// return value from the i/o procedure (0 if error or unrecognized message)
//
LRESULT DLLEXPORT WINAPI WavSendMessage(HWAV hWav,
	UINT wMsg, LPARAM lParam1, LPARAM lParam2);

#ifdef TELTHUNK
// WavOpenEx - open an audio file, extra special version
//		<dwVersion>			(i) must be WAV_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<lpszFileName>		(i) name of file to open
//		<dwReserved>		(i) reserved; must be zero
//		<dwFlagsOpen>		(i) control flags to pass to WavOpen
//		<dwFlagsEx>			(i) control flags
//			WOX_LOCAL			file is on local client
//			WOX_REMOTE			file is on remote server
//			WOX_WAVFMT			file is in Microsoft RIFF/WAV format
//			WOX_VOXFMT			file is in Dialogic OKI ADPCM (vox) format
//			WOX_WAVDEV			file will be played on wav output device
//			WOX_TELDEV			file will be played on telephone device
// return handle (NULL if error)
//
HWAV DLLEXPORT WINAPI WavOpenEx(DWORD dwVersion, HINSTANCE hInst,
	LPTSTR lpszFileName, DWORD dwReserved, DWORD dwFlagsOpen, DWORD dwFlagsEx);
#endif

#ifdef __cplusplus
}
#endif

#endif // __WAV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\avwav\wav.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	wav.c - wave file format functions
////

#include "winlocal.h"

#include <stdlib.h>

#include "wav.h"

#ifdef MULTITHREAD
#include <objbase.h>
#endif

#include "wavin.h"
#include "wavout.h"
#include "wavmixer.h"
#include "acm.h"
#include "mem.h"
#include "str.h"
#include "trace.h"
#include "mmio.h"

#ifdef AVTSM
#include "avtsm.h"
#define TSMTHUNK
#ifdef TSMTHUNK
#include "tsmthunk.h"
#endif
#define TSM_OUTBUF_SIZE_FACT 4
#endif

// allow telephone output functions if defined
//
#ifdef TELOUT
#include "telout.h"
#endif

// allow telephone input functions if defined
//
#ifdef TELIN
#include "telin.h"
#endif

// use telephone thunk layer if defined
//
#ifdef TELTHUNK
#include "telthunk.h"
#endif

#if defined(TELOUT) || defined(TELIN)
#include "telwav.h"
#include "vox.h"
#endif

////
//	private definitions
////

#define WAVCLASS TEXT("WavClass")

#define PLAYCHUNKCOUNT_DEFAULT 3
#define PLAYCHUNKCOUNT_MIN 1
#define PLAYCHUNKCOUNT_MAX 16

#define PLAYCHUNKSIZE_DEFAULT 666
#define PLAYCHUNKSIZE_MIN 111
#define PLAYCHUNKSIZE_MAX 9999999

#define RECORDCHUNKCOUNT_DEFAULT 3
#define RECORDCHUNKCOUNT_MIN 1
#define RECORDCHUNKCOUNT_MAX 16

#define RECORDCHUNKSIZE_DEFAULT 666
#define RECORDCHUNKSIZE_MIN 111
#define RECORDCHUNKSIZE_MAX 9999999

// index into format arrays
//
#define FORMATFILE		0
#define FORMATPLAY		1
#define FORMATRECORD	2

// internal state flags
//
#define WAVSTATE_STOPPLAY				0x00000010
#define WAVSTATE_STOPRECORD				0x00000020
#define WAVSTATE_AUTOSTOP				0x00000040
#define WAVSTATE_AUTOCLOSE				0x00000080

// internal array of current handles
//
#define HWAVOUT_MAX 100
#define HWAVIN_MAX 100

#ifdef TELOUT
#define HWAVOUT_MIN -2
#define HWAVOUT_OFFSET 2
#else
#define HWAVOUT_MIN -1
#define HWAVOUT_OFFSET 1
#endif
static HWAV ahWavOutCurr[HWAVOUT_MAX + HWAVOUT_OFFSET] = { 0 };

#ifdef TELIN
#define HWAVIN_MIN -2
#define HWAVIN_OFFSET 2
#else
#define HWAVIN_MIN -1
#define HWAVIN_OFFSET 1
#endif
static HWAV ahWavInCurr[HWAVIN_MAX + HWAVIN_OFFSET] = { 0 };

// internal storage of defaults
//
static int cPlayChunksDefault = PLAYCHUNKCOUNT_DEFAULT;
static long msPlayChunkSizeDefault = PLAYCHUNKSIZE_DEFAULT;
static int cRecordChunksDefault = RECORDCHUNKCOUNT_DEFAULT;
static long msRecordChunkSizeDefault = RECORDCHUNKSIZE_DEFAULT;

// wavinit control struct
//
typedef struct WAVINIT
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	DWORD dwFlags;
	UINT nLastError;
	HACM hAcm;
	HACMDRV hAcmDrv;
#ifdef TELTHUNK
	HTELTHUNK hTelThunk;
#endif
#ifdef TSMTHUNK
	HTSMTHUNK hTsmThunk;
#endif
} WAVINIT, FAR *LPWAVINIT;

// wav control struct
//
typedef struct WAV
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	DWORD dwFlags;
	LPWAVEFORMATEX lpwfx[3];
	LPMMIOPROC lpIOProc;
	int cPlayChunks;
	long msPlayChunkSize;
	int cRecordChunks;
	long msRecordChunkSize;
	HWND hwndNotify;
#ifdef MULTITHREAD
	HANDLE hThreadCallback;
	DWORD dwThreadId;
	HANDLE hEventThreadCallbackStarted;
	HANDLE hEventStopped;
#endif
	UINT nLastError;
	HMMIO hmmio;
	MMCKINFO ckRIFF;
	MMCKINFO ckfmt;
	MMCKINFO ckdata;
	long cbData;
	long lDataOffset;
	long lDataPos;
	long msPositionStop;
	HWAVIN hWavIn;
	HWAVOUT hWavOut;
	HACM hAcm;
	DWORD dwState;
	HGLOBAL hResource;
	long lPosFmt;
	DWORD dwFlagsPlay;
	DWORD dwFlagsRecord;
	int nVolumeLevel;
	int dwFlagsVolume;
	int nSpeedLevel;
	DWORD dwFlagsSpeed;
	PLAYSTOPPEDPROC lpfnPlayStopped;
	HANDLE hUserPlayStopped;
	RECORDSTOPPEDPROC lpfnRecordStopped;
	DWORD dwUserRecordStopped;
#ifdef MULTITHREAD
	HRESULT hrCoInitialize;
#endif
#ifdef AVTSM
	HTSM hTsm;
#endif
	LPTSTR lpszFileName;
	long msMaxSize;
} WAV, FAR *LPWAV;

// helper functions
//
static int WavStopPlay(HWAV hWav);
static int WavStopRecord(HWAV hWav);
static int WavStopOutputDevice(int idDev, DWORD dwFlags);
static int WavStopInputDevice(int idDev, DWORD dwFlags);
static HWAV WavGetOutputHandle(int idDev);
static HWAV WavGetInputHandle(int idDev);
static int WavPlayNextChunk(HWAV hWav);
static int WavRecordNextChunk(HWAV hWav);
static int WavNotifyCreate(LPWAV lpWav);
static int WavNotifyDestroy(LPWAV lpWav);
#ifdef MULTITHREAD
DWORD WINAPI WavCallbackThread(LPVOID lpvThreadParameter);
#endif
LRESULT DLLEXPORT CALLBACK WavNotify(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
static int WavCalcPositionStop(HWAV hWav, long cbPosition);
static int WavSeekTraceBefore(LPWAV lpWav, long lOffset, int nOrigin);
static int WavSeekTraceAfter(LPWAV lpWav, long lPos, long lOffset, int nOrigin);
static LPWAV WavGetPtr(HWAV hWav);
static HWAV WavGetHandle(LPWAV lpWav);
static LPWAVINIT WavInitGetPtr(HWAVINIT hWavInit);
static HWAVINIT WavInitGetHandle(LPWAVINIT lpWavInit);
#ifdef MULTITHREAD
static int SetEventMessageProcessed(LPWAV lpWav, HANDLE hEventMessageProcessed);
#endif
static int WavTempStop(HWAV hWav, LPWORD lpwStatePrev, LPINT lpidDevPrev);
static int WavTempResume(HWAV hWav, WORD wStatePrev, int idDevPrev);

////
//	public functions
////

// WavInit - initialize wav engine
//		<dwVersion>			(i) must be WAV_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<dwFlags>			(i) control flags
//			WAV_TELTHUNK		initialize telephone thunking layer
//			WAV_NOTSMTHUNK		do not initialize tsm thunking layer
//			WAV_NOACM			do not use audio compression manager
//			WAV_VOXADPCM		load acm driver for Dialogic OKI ADPCM
// return handle (NULL if error)
//
HWAVINIT WINAPI WavInit(DWORD dwVersion, HINSTANCE hInst, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAVINIT lpWavInit = NULL;

	if (dwVersion != WAV_VERSION)
		fSuccess = TraceFALSE(NULL);
	
	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpWavInit = (LPWAVINIT) MemAlloc(NULL, sizeof(WAVINIT), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lpWavInit->dwVersion = dwVersion;
		lpWavInit->hInst = hInst;
		lpWavInit->hTask = GetCurrentTask();
		lpWavInit->dwFlags = dwFlags;
		lpWavInit->hAcm = NULL;
		lpWavInit->hAcmDrv = NULL;
#ifdef TELTHUNK
		lpWavInit->hTelThunk = NULL;
#endif
#ifdef TSMTHUNK
		lpWavInit->hTsmThunk = NULL;
#endif

		// start the acm engine before any other Wav or Acm functions called
		//
		if ((lpWavInit->hAcm = AcmInit(ACM_VERSION,	lpWavInit->hInst,
			(lpWavInit->dwFlags & WAV_NOACM) ? ACM_NOACM : 0)) == NULL)
			fSuccess = TraceFALSE(NULL);

		// load voxadpcm driver if specified
		//
		else if ((dwFlags & WAV_VOXADPCM) && (!(dwFlags & WAV_NOACM)) &&
			(lpWavInit->hAcmDrv = AcmDriverLoad(lpWavInit->hAcm,
			MM_ACTIVEVOICE, MM_ACTIVEVOICE_ACM_VOXADPCM,
#ifdef _WIN32
			TEXT("avvox.acm"),
#else
			TEXT("voxadpcm.acm"),
#endif
			"DriverProc", 0)) == NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}

#ifdef TELTHUNK
		// initialize telephone thunking layer if specified
		//
		else if ((dwFlags & WAV_TELTHUNK) &&
			(lpWavInit->hTelThunk = TelThunkInit(TELTHUNK_VERSION,
			lpWavInit->hInst)) == NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}
#endif

#ifdef TSMTHUNK
		// initialize tsm thunking layer if specified
		//
		else if (!(dwFlags & WAV_NOTSMTHUNK) &&
			(lpWavInit->hTsmThunk = TsmThunkInit(TSMTHUNK_VERSION,
			lpWavInit->hInst)) == NULL)
		{
			fSuccess = TraceTRUE(NULL); // not a fatal error
		}
#endif

	}

	if (!fSuccess)
	{
		WavTerm(WavInitGetHandle(lpWavInit));
		lpWavInit = NULL;
	}

	return fSuccess ? WavInitGetHandle(lpWavInit) : NULL;
}

// WavTerm - shut down wav engine
//		<hWavInit>			(i) handle returned from WavInit
// return 0 if success
//
int WINAPI WavTerm(HWAVINIT hWavInit)
{
	BOOL fSuccess = TRUE;
	LPWAVINIT lpWavInit;

	if ((lpWavInit = WavInitGetPtr(hWavInit)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (WavOutTerm(lpWavInit->hInst, lpWavInit->dwFlags) != 0)
		fSuccess = TraceFALSE(NULL);

	else if (WavInTerm(lpWavInit->hInst, lpWavInit->dwFlags) != 0)
		fSuccess = TraceFALSE(NULL);

	else
	{
#ifdef TELTHUNK
		// shut down telephone thunking layer if necessary
		//
		if (lpWavInit->hTelThunk != NULL &&
			TelThunkTerm(lpWavInit->hTelThunk) != 0)
			fSuccess = TraceFALSE(NULL);

		else
			lpWavInit->hTelThunk = NULL;
#endif

#ifdef TSMTHUNK
		// shut down tsm thunking layer if necessary
		//
		if (lpWavInit->hTsmThunk != NULL &&
			TsmThunkTerm(lpWavInit->hTsmThunk) != 0)
			fSuccess = TraceFALSE(NULL);

		else
			lpWavInit->hTsmThunk = NULL;
#endif

		// unload voxadpcm driver if necessary
		//
		if (lpWavInit->hAcmDrv != NULL &&
			AcmDriverUnload(lpWavInit->hAcm, lpWavInit->hAcmDrv) != 0)
			fSuccess = TraceFALSE(NULL);

		else
			lpWavInit->hAcmDrv = NULL;

		// shut down acm engine
		//
		if (lpWavInit->hAcm != NULL && AcmTerm(lpWavInit->hAcm) != 0)
			fSuccess = TraceFALSE(NULL);

		else
			lpWavInit->hAcm = NULL;

		if (fSuccess && (lpWavInit = MemFree(NULL, lpWavInit)) != NULL)
			fSuccess = TraceFALSE(NULL);

	}

	return fSuccess ? 0 : -1;
}

// WavOpen - open or create wav file
//		<dwVersion>			(i) must be WAV_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<lpszFileName>		(i) name of file to open or create
//		<lpwfx>				(i) wave format
//			NULL				use format from header or default
//		<lpIOProc>			(i) address of i/o procedure to use
//			NULL				use default i/o procedure
//		<lpadwInfo>			(i) data to pass to i/o procedure during open
//			NULL				no data to pass
//		<dwFlags>			(i) control flags
//			WAV_READ			open file for reading (default)
//			WAV_WRITE			open file for writing
//			WAV_READWRITE		open file for reading and writing
//			WAV_DENYNONE		allow other programs read and write access
//			WAV_DENYREAD		prevent other programs from read access
//			WAV_DENYWRITE		prevent other programs from write access
//			WAV_EXCLUSIVE		prevent other programs from read or write
//			WAV_CREATE			create new file or truncate existing file
//			WAV_NORIFF			file has no RIFF/WAV header
//			WAV_MEMORY			<lpszFileName> points to memory block
//			WAV_RESOURCE		<lpszFileName> points to wave resource
//			WAV_NOACM			do not use audio compression manager
//			WAV_DELETE			delete specified file, return TRUE if success
//			WAV_EXIST			return TRUE if specified file exists
//			WAV_GETTEMP			create temp file, return TRUE if success
//			WAV_TELRFILE		telephone will play audio from file on server
#ifdef MULTITHREAD
//			WAV_MULTITHREAD		support multiple threads (default)
//			WAV_SINGLETHREAD	do not support multiple threads
//			WAV_COINITIALIZE	call CoInitialize in all secondary threads
#endif
// return handle (NULL if error)
//
// NOTE: if WAV_CREATE or WAV_NORIFF are used in <dwFlags>, then the
// <lpwfx> parameter must be specified.  If <lpwfx> is NULL, the
// current default format is assumed.
// WavSetFormat() can be used to set or override the defaults.
//
// NOTE: if WAV_RESOURCE is specified in <dwFlags>, then <lpszFileName>
// must point to a WAVE resource in the module specified by <hInst>.
// If the first character of the string is a pound sign (#), the remaining
// characters represent a decimal number that specifies the resource id.
//
// NOTE: if WAV_MEMORY is specified in <dwFlags>, then <lpszFileName>
// must be a pointer to a memory block obtained by calling MemAlloc().
//
// NOTE: if <lpIOProc> is not NULL, this i/o procedure will be called
// for opening, closing, reading, writing, and seeking the wav file.
// If <lpadwInfo> is not NULL, this array of three (3) DWORDs will be
// passed to the i/o procedure when the wav file is opened.
// See the Windows mmioOpen() and mmioInstallIOProc() function for details
// on these parameters.  Also, the WAV_MEMORY and WAV_RESOURCE flags may
// only be used when <lpIOProc> is NULL.
//
HWAV WINAPI WavOpen(DWORD dwVersion, HINSTANCE hInst,
	LPCTSTR lpszFileName, LPWAVEFORMATEX lpwfx,
	LPMMIOPROC lpIOProc, DWORD FAR *lpadwInfo, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav = NULL;

#ifdef MULTITHREAD
	// assume WAV_MULTITHREAD unless WAV_SINGLETHREAD specified
	//
	if (!(dwFlags & WAV_SINGLETHREAD))
		dwFlags |= WAV_MULTITHREAD;
#endif

	if (dwVersion != WAV_VERSION)
		fSuccess = TraceFALSE(NULL);
	
	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);

	// special case flags that don't actually open a file
	// return TRUE if success, ignore all other flags
	//
	else if ((dwFlags & WAV_EXIST) ||
		(dwFlags & WAV_DELETE) ||
		(dwFlags & WAV_GETTEMP))
	{
		DWORD dwOpenFlags = 0;
		HMMIO hmmio;

		if (dwFlags & WAV_EXIST)
			dwOpenFlags |= MMIO_EXIST;
		else if (dwFlags & WAV_DELETE)
			dwOpenFlags |= MMIO_DELETE;
		else if (dwFlags & WAV_GETTEMP)
			dwOpenFlags |= MMIO_GETTEMP;

		// use specified i/o procedure
		//
		if (lpIOProc != NULL)
		{
			MMIOINFO mmioinfo;

			MemSet(&mmioinfo, 0, sizeof(mmioinfo));

			mmioinfo.pIOProc = lpIOProc;

			// pass data to the i/o procedure
			//
			if (lpadwInfo != NULL)
				MemCpy(mmioinfo.adwInfo, lpadwInfo, sizeof(mmioinfo.adwInfo));

			hmmio = mmioOpen((LPTSTR) lpszFileName, &mmioinfo, dwOpenFlags);
		}

		// default i/o procedure
		//
		else
		{
			hmmio = mmioOpen((LPTSTR) lpszFileName, NULL, dwOpenFlags);
		}

		if ((dwFlags & WAV_EXIST) && hmmio == (HMMIO) FALSE)
			fSuccess = FALSE; // no trace
		else if ((dwFlags & WAV_DELETE) && hmmio == (HMMIO) FALSE)
			fSuccess = TraceFALSE(NULL);
		else if ((dwFlags & WAV_GETTEMP) && hmmio == (HMMIO) FALSE)
			fSuccess = TraceFALSE(NULL);

		return (HWAV)IntToPtr(fSuccess);
	}

	else if ((lpWav = (LPWAV) MemAlloc(NULL, sizeof(WAV), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lpWav->dwVersion = dwVersion;
		lpWav->hInst = hInst;
		lpWav->hTask = GetCurrentTask();
		lpWav->dwFlags = dwFlags;
		lpWav->lpwfx[FORMATFILE] = NULL;
		lpWav->lpwfx[FORMATPLAY] = NULL;
		lpWav->lpwfx[FORMATRECORD] = NULL;
		lpWav->lpIOProc = lpIOProc;
		lpWav->cPlayChunks = cPlayChunksDefault;
		lpWav->msPlayChunkSize = msPlayChunkSizeDefault;
		lpWav->cRecordChunks = cRecordChunksDefault;
		lpWav->msRecordChunkSize = msRecordChunkSizeDefault;
		lpWav->hwndNotify = NULL;
#ifdef MULTITHREAD
		lpWav->hThreadCallback = NULL;
		lpWav->dwThreadId = 0;
		lpWav->hEventThreadCallbackStarted = NULL;
		lpWav->hEventStopped = NULL;
#endif
		lpWav->nLastError = 0;
		lpWav->hmmio = NULL;
		lpWav->cbData = 0;
		lpWav->lDataOffset = 0;
		lpWav->lDataPos = 0;
		lpWav->hWavIn = NULL;
		lpWav->hWavOut = NULL;
		lpWav->hAcm = NULL;
		lpWav->msPositionStop = 0L;
		lpWav->dwState = 0L;
		lpWav->hResource = NULL;
		lpWav->lPosFmt = -1;
		lpWav->dwFlagsPlay = 0;
		lpWav->dwFlagsRecord = 0;
		lpWav->nVolumeLevel = 50;
		lpWav->dwFlagsVolume = 0;
		lpWav->nSpeedLevel = 100;
		lpWav->dwFlagsSpeed = 0;
		lpWav->lpfnPlayStopped = NULL;
		lpWav->hUserPlayStopped = 0;
		lpWav->lpfnRecordStopped = NULL;
		lpWav->dwUserRecordStopped = 0;
#ifdef MULTITHREAD
		lpWav->hrCoInitialize = E_UNEXPECTED;
#endif
#ifdef AVTSM
		lpWav->hTsm = NULL;
#endif
		lpWav->lpszFileName = NULL;
		lpWav->msMaxSize = 0;

		// start the acm engine before any other Wav or Acm functions called
		//
		if ((lpWav->hAcm = AcmInit(ACM_VERSION,	lpWav->hInst,
			(lpWav->dwFlags & WAV_NOACM) ? ACM_NOACM : 0)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else
		{
			// assume default wave format if none specified
			//
			if (lpwfx == NULL)
			{
				WAVEFORMATEX wfx;

				if (WavSetFormat(WavGetHandle(lpWav),
					WavFormatPcm(-1, -1, -1, &wfx), WAV_FORMATALL) != 0)
					fSuccess = TraceFALSE(NULL);
			}

			// set specified wave format
			//
			else if (WavSetFormat(WavGetHandle(lpWav), lpwfx, WAV_FORMATALL) != 0)
				fSuccess = TraceFALSE(NULL);
		}
	}

	// load WAVE resource if specified
	//
	if (fSuccess && (dwFlags & WAV_RESOURCE))
	{
		HRSRC hResInfo;
		LPVOID lpResource;

		if ((hResInfo = FindResource(hInst, lpszFileName, TEXT("WAVE"))) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if ((lpWav->hResource = LoadResource(hInst, hResInfo)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if ((lpResource = LockResource(lpWav->hResource)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else
		{
			// <lpszFileName> now points to a memory block
			//
			lpszFileName = lpResource;
			dwFlags |= WAV_MEMORY;
		}
	}

	if (fSuccess && (dwFlags & WAV_MEMORY))
	{
		// i/o procedure can not be specified with memory block
		//
		lpIOProc = NULL;
		lpadwInfo = NULL;
	}

	if (fSuccess)
	{
		DWORD dwOpenFlags = 0;

		if (lpWav->dwFlags & WAV_READ)
			dwOpenFlags |= MMIO_READ;
		if (lpWav->dwFlags & WAV_WRITE)
			dwOpenFlags |= MMIO_WRITE;
		if (lpWav->dwFlags & WAV_READWRITE)
			dwOpenFlags |= MMIO_READWRITE;
		if (lpWav->dwFlags & WAV_CREATE)
			dwOpenFlags |= MMIO_CREATE;
		if (lpWav->dwFlags & WAV_DENYNONE)
			dwOpenFlags |= MMIO_DENYNONE;
		if (lpWav->dwFlags & WAV_DENYREAD)
			dwOpenFlags |= MMIO_DENYREAD;
		if (lpWav->dwFlags & WAV_DENYWRITE)
			dwOpenFlags |= MMIO_DENYWRITE;
		if (lpWav->dwFlags & WAV_EXCLUSIVE)
			dwOpenFlags |= MMIO_EXCLUSIVE;

		// open/create disk wav file with specified i/o procedure
		//
		if (lpIOProc != NULL)
		{
			MMIOINFO mmioinfo;

			MemSet(&mmioinfo, 0, sizeof(mmioinfo));

			mmioinfo.pIOProc = lpIOProc;

			// pass data to the i/o procedure
			//
			if (lpadwInfo != NULL)
				MemCpy(mmioinfo.adwInfo, lpadwInfo, sizeof(mmioinfo.adwInfo));

			if ((lpWav->hmmio = mmioOpen((LPTSTR) lpszFileName,
				&mmioinfo, dwOpenFlags)) == NULL)
			{
				fSuccess = TraceFALSE(NULL);
			}
		}

		// open/create a memory wav file if WAV_MEMORY specified
		//
		else if (lpWav->dwFlags & WAV_MEMORY)
		{
			MMIOINFO mmioinfo;

			MemSet(&mmioinfo, 0, sizeof(mmioinfo));

			mmioinfo.fccIOProc = FOURCC_MEM;
			mmioinfo.pchBuffer = (HPSTR) lpszFileName;

			if (lpszFileName == NULL)
			{
				// expandable memory file
				//
				mmioinfo.cchBuffer = 0;
				mmioinfo.adwInfo[0] = (DWORD) (16 * 1024);
			}
			else
			{
				// expandable memory file
				//
				mmioinfo.cchBuffer = (long) MemSize(NULL, (LPVOID) lpszFileName);
				mmioinfo.adwInfo[0] = (DWORD) 16384;
			}

			if ((lpWav->hmmio = mmioOpen(NULL,
				&mmioinfo, dwOpenFlags)) == NULL)
			{
				fSuccess = TraceFALSE(NULL);
			}
		}

		// otherwise open/create disk wav file
		//
		else
		{
			if ((lpWav->lpszFileName = StrDup(lpszFileName)) == NULL)
				fSuccess = TraceFALSE(NULL);

			else if ((lpWav->hmmio = mmioOpen((LPTSTR) lpszFileName,
				NULL, dwOpenFlags)) == NULL)
			{
				fSuccess = TraceFALSE(NULL);
			}
		}
	}

	// handle reading of RIFF file chunks if necessary
	//
	if (fSuccess && !(lpWav->dwFlags & WAV_CREATE) &&
		!(lpWav->dwFlags & WAV_NORIFF))
	{
		MMCKINFO ck;

		// search for RIFF chunk with form type WAV
		//
		if ((lpWav->nLastError = mmioDescend(lpWav->hmmio,
			&lpWav->ckRIFF, NULL, MMIO_FINDRIFF)) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("mmioDescend failed (%u)\n"),
				(unsigned) lpWav->nLastError);
		}

		// search for "fmt " subchunk
		//
		ck.ckid = mmioFOURCC('f', 'm', 't', ' ');

		if (fSuccess &&	(lpWav->nLastError = mmioDescend(lpWav->hmmio,
			&ck, &lpWav->ckRIFF, MMIO_FINDCHUNK)) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("mmioDescend failed (%u)\n"),
				(unsigned) lpWav->nLastError);
		}

		// save position of "fmt " chunk data so we can seek there later
		//
		else if (fSuccess && (lpWav->lPosFmt = mmioSeek(lpWav->hmmio,
			0, SEEK_CUR)) == -1)
		{
			fSuccess = TraceFALSE(NULL);
		}

		// check for file corruption
		//
		if (fSuccess && (ck.dwDataOffset + ck.cksize) >
			(lpWav->ckRIFF.dwDataOffset + lpWav->ckRIFF.cksize))
		{
			fSuccess = TraceFALSE(NULL);
		}

		if (fSuccess)
		{
			LPWAVEFORMATEX lpwfx = NULL;
			DWORD cksize;

			// save fmt chunk info
			//
			lpWav->ckfmt = ck;

			// fmt chunk must be no smaller than WAVEFORMAT struct
			//
			if ((cksize = max(ck.cksize, sizeof(WAVEFORMAT)))
				< sizeof(WAVEFORMAT))
				fSuccess = TraceFALSE(NULL);

			// allocate space for WAVEFORMATEX struct
			//
			else if ((lpwfx = (LPWAVEFORMATEX) MemAlloc(NULL,
				max(sizeof(WAVEFORMATEX), cksize), 0)) == NULL)
				fSuccess = TraceFALSE(NULL);

			// read the fmt chunk
			//
			else if (mmioRead(lpWav->hmmio,
				(HPSTR) lpwfx, (LONG) cksize) != (LONG) cksize)
				fSuccess = TraceFALSE(NULL);

			// seek to beginning of next chunk if necessary
			//
			else if (ck.cksize > cksize &&
				mmioSeek(lpWav->hmmio, ck.cksize - cksize, SEEK_CUR) == -1)
				fSuccess = TraceFALSE(NULL);

			// calculate bits per sample if necessary
			//
			else if (lpwfx->wFormatTag == WAVE_FORMAT_PCM &&
				lpwfx->wBitsPerSample == 0)
			{
				// NOTE: this only works for PCM data with
				// sample size that is a multiple of 8 bits
				//
				lpwfx->wBitsPerSample =
					(lpwfx->nBlockAlign * 8) / lpwfx->nChannels;
			}

			// save format for later
			//
			if (fSuccess && WavSetFormat(WavGetHandle(lpWav),
				lpwfx, WAV_FORMATALL) != 0)
				fSuccess = TraceFALSE(NULL);

			// clean up
			//
			if (lpwfx != NULL &&
				(lpwfx = MemFree(NULL, lpwfx)) != NULL)
				fSuccess = TraceFALSE(NULL);
		}

		// search for "data" subchunk
		//
		ck.ckid = mmioFOURCC('d', 'a', 't', 'a');

		if (fSuccess &&	(lpWav->nLastError = mmioDescend(lpWav->hmmio,
			&ck, &lpWav->ckRIFF, MMIO_FINDCHUNK)) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("mmioDescend failed (%u)\n"),
				(unsigned) lpWav->nLastError);
		}

		// check for file corruption
		//
		if (fSuccess && (ck.dwDataOffset + ck.cksize) >
			(lpWav->ckRIFF.dwDataOffset + lpWav->ckRIFF.cksize))
		{
			fSuccess = TraceFALSE(NULL);
		}

		if (fSuccess)
		{
			// save data chunk info
			//
			lpWav->ckdata = ck;

			// save data size and offset for later
			//
			lpWav->cbData = (long) ck.cksize;
			lpWav->lDataOffset = (long) ck.dwDataOffset;
		}
	}

	// handle creation of RIFF file chunks if necessary
	//
	else if (fSuccess && (lpWav->dwFlags & WAV_CREATE) &&
		!(lpWav->dwFlags & WAV_NORIFF))
	{
		lpWav->ckRIFF.ckid = mmioFOURCC('R', 'I', 'F', 'F');
		lpWav->ckRIFF.cksize = 0; // unknown
		lpWav->ckRIFF.fccType = mmioFOURCC('W', 'A', 'V', 'E');
		lpWav->ckfmt.ckid = mmioFOURCC('f', 'm', 't', ' ');
		lpWav->ckfmt.cksize = WavFormatGetSize(lpWav->lpwfx[FORMATFILE]);
		lpWav->ckdata.ckid = mmioFOURCC('d', 'a', 't', 'a');
		lpWav->ckdata.cksize = 0; // unknown

		// create RIFF chunk with form type WAV
		//
		if ((lpWav->nLastError = mmioCreateChunk(lpWav->hmmio,
			&lpWav->ckRIFF, MMIO_CREATERIFF)) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("mmioCreateChunk failed (%u)\n"),
				(unsigned) lpWav->nLastError);
		}

		// create 'fmt ' chunk
		//
		else if ((lpWav->nLastError = mmioCreateChunk(lpWav->hmmio,
			&lpWav->ckfmt, 0)) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("mmioCreateChunk failed (%u)\n"),
				(unsigned) lpWav->nLastError);
		}

		// save position of "fmt " chunk data so we can seek there later
		//
		else if ((lpWav->lPosFmt = mmioSeek(lpWav->hmmio,
			0, SEEK_CUR)) == -1)
		{
			fSuccess = TraceFALSE(NULL);
		}

		// write 'fmt ' chunk data
		//
		else if (mmioWrite(lpWav->hmmio, (HPSTR) lpWav->lpwfx[FORMATFILE],
			WavFormatGetSize(lpWav->lpwfx[FORMATFILE])) !=
			WavFormatGetSize(lpWav->lpwfx[FORMATFILE]))
		{
			fSuccess = TraceFALSE(NULL);
		}

		// ascend out of 'fmt ' chunk
		//
		else if ((lpWav->nLastError = mmioAscend(lpWav->hmmio,
			&lpWav->ckfmt, 0)) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("mmioAscend failed (%u)\n"),
				(unsigned) lpWav->nLastError);
		}

		// create the 'data' chunk which holds the waveform samples
		//
		else if ((lpWav->nLastError = mmioCreateChunk(lpWav->hmmio,
			&lpWav->ckdata, 0)) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("mmioCreateChunk failed (%u)\n"),
				(unsigned) lpWav->nLastError);
		}

		// calculate beginning offset of data chunk
		//
		else if ((lpWav->lDataOffset = mmioSeek(lpWav->hmmio, 0, SEEK_CUR)) == -1)
			fSuccess = TraceFALSE(NULL);
	}

	// calculate size of data chunk (file size) for non-RIFF files
	//
	else if (fSuccess && !(lpWav->dwFlags & WAV_CREATE) &&
		(lpWav->dwFlags & WAV_NORIFF))
	{
		// RFileIOProc already knows the file size
		//
		if (lpWav->lpIOProc != NULL &&
			(lpWav->dwFlags & WAV_TELRFILE))
		{
			long lSize;

			// retrieve size of remote file from i/o procedure
			//
			if ((lSize = (long)
				WavSendMessage(WavGetHandle(lpWav), MMIOM_GETINFO, 1, 0)) == (long) -1)
				fSuccess = TraceFALSE(NULL);
			else
				lpWav->cbData = (long) lSize;
		}
		else
		{
			LONG lPosCurr;
			LONG lPosEnd;

			// save current position
			//
			if ((lPosCurr = mmioSeek(lpWav->hmmio, 0, SEEK_CUR)) == -1)
				fSuccess = TraceFALSE(NULL);

			// seek to end of file
			//
			else if ((lPosEnd = mmioSeek(lpWav->hmmio, 0, SEEK_END)) == -1)
				fSuccess = TraceFALSE(NULL);

			// restore current position
			//
			else if (mmioSeek(lpWav->hmmio, lPosCurr, SEEK_SET) == -1)
				fSuccess = TraceFALSE(NULL);

			else
				lpWav->cbData = (long) lPosEnd; // + 1;
		}
	}

	if (fSuccess)
	{
		TracePrintf_4(NULL, 6,
			TEXT("After WavOpen: lpWav->lDataOffset=%ld, lpWav->lDataPos=%ld, lpWav->cbData=%ld, lpWav->msPositionStop=%ld\n"),
			(long) lpWav->lDataOffset,
			(long) lpWav->lDataPos,
			(long) lpWav->cbData,
			(long) lpWav->msPositionStop);
	}

	if (!fSuccess)
	{
		WavClose(WavGetHandle(lpWav));
		lpWav = NULL;
	}

	return fSuccess ? WavGetHandle(lpWav) : NULL;
}

// WavClose - close wav file
//		<hWav>				(i) handle returned from WavOpen
// return 0 if success
//
int WINAPI WavClose(HWAV hWav)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
#ifdef _WIN32
	long lPosTruncate = -1;
#endif

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// stop playback or record if necessary
	//
	else if (WavStop(hWav) != 0)
		fSuccess = TraceFALSE(NULL);

	// update the RIFF header chunks if dirty flag set
	//
	else if (lpWav->hmmio != NULL &&
		!(lpWav->dwFlags & WAV_NORIFF) &&
		((lpWav->ckdata.dwFlags & MMIO_DIRTY) ||
		(lpWav->ckRIFF.dwFlags & MMIO_DIRTY)))
	{
#if 0
		// seek to end of file
		//
		if (mmioSeek(lpWav->hmmio, 0, SEEK_END) == -1)
		{
			fSuccess = TraceFALSE(NULL);
		}
#else
		// seek to end of the data
		//
		if (mmioSeek(lpWav->hmmio, lpWav->lDataOffset + lpWav->cbData, SEEK_SET) == -1)
		{
			fSuccess = TraceFALSE(NULL);
		}
#endif

		// ascend out of the 'data' chunk; chunk size will be written
		//
		else if ((lpWav->nLastError = mmioAscend(lpWav->hmmio,
			&lpWav->ckdata, 0)) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("mmioAscend failed (%u)\n"),
				(unsigned) lpWav->nLastError);
		}

		// ascend out of the 'RIFF' chunk; chunk size will be written
		//
		else if ((lpWav->nLastError = mmioAscend(lpWav->hmmio,
			&lpWav->ckRIFF, 0)) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("mmioAscend failed (%u)\n"),
				(unsigned) lpWav->nLastError);
		}
#if 0
		// seek to beginning of file
		//
		else if (mmioSeek(lpWav->hmmio, 0, SEEK_SET) == -1)
		{
			fSuccess = TraceFALSE(NULL);
		}

		// search for RIFF chunk with form type WAV
		//
		else if ((lpWav->nLastError = mmioDescend(lpWav->hmmio,
			&lpWav->ckRIFF, NULL, MMIO_FINDRIFF)) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("mmioDescend failed (%u)\n"),
				(unsigned) lpWav->nLastError);
		}

		// search for 'fmt ' chunk
		//
		else if ((lpWav->nLastError = mmioDescend(lpWav->hmmio,
			&lpWav->ckfmt, &lpWav->ckRIFF, MMIO_FINDCHUNK)) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("mmioDescend failed (%u)\n"),
				(unsigned) lpWav->nLastError);
		}
#else
		// seek to beginning of "fmt " chunk data
		//
		else if (mmioSeek(lpWav->hmmio, lpWav->lPosFmt, SEEK_SET) == -1)
		{
			fSuccess = TraceFALSE(NULL);
		}
#endif
		// write 'fmt ' chunk data
		// $FIXUP - what happens if current file format struct size
		// is larger than the original format?
		//
		else if (mmioWrite(lpWav->hmmio, (HPSTR) lpWav->lpwfx[FORMATFILE],
			WavFormatGetSize(lpWav->lpwfx[FORMATFILE])) !=
			WavFormatGetSize(lpWav->lpwfx[FORMATFILE]))
		{
			fSuccess = TraceFALSE(NULL);
		}
#ifdef _WIN32
		// see if we need to truncate file
		//
		else if (lpWav->lpIOProc == NULL && !(lpWav->dwFlags & WAV_MEMORY) &&
			!(lpWav->dwFlags & WAV_RESOURCE))
		{
			if (mmioSeek(lpWav->hmmio, 0, SEEK_END) >
				lpWav->lDataOffset + lpWav->cbData)
			{
				lPosTruncate = lpWav->lDataOffset + lpWav->cbData;
			}
		}
#endif
	}

	if (fSuccess)
	{
		// close the file
		//
		if (lpWav->hmmio != NULL && mmioClose(lpWav->hmmio, 0) != 0)
				fSuccess = TraceFALSE(NULL);
		else
			lpWav->hmmio = NULL;

		// close acm engine
		//
		if (lpWav->hAcm != NULL && AcmTerm(lpWav->hAcm) != 0)
			fSuccess = TraceFALSE(NULL);

		else
			lpWav->hAcm = NULL;

		// free wave resource
		//
		if (lpWav->hResource != NULL)
		{
			UnlockResource(lpWav->hResource);

			if (!FreeResource(lpWav->hResource))
				fSuccess = TraceFALSE(NULL);
			else
				lpWav->hResource = NULL;
		}

#ifdef _WIN32
		// truncate file if necessary
		//
		if (lPosTruncate != -1 && lpWav->lpszFileName != NULL)
		{
			HANDLE hFile = INVALID_HANDLE_VALUE;

			// open file
			//
			if ((hFile = CreateFile(lpWav->lpszFileName,
				GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
				FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE)
			{
				fSuccess = TraceFALSE(NULL);
			}

			// seek to truncate position
			//
			else if (SetFilePointer(hFile, lPosTruncate,
				NULL, (DWORD) FILE_BEGIN) == 0xFFFFFFFF)
			{
				fSuccess = TraceFALSE(NULL);
			}

			// truncate file
			//
			else if (!SetEndOfFile(hFile))
				fSuccess = TraceFALSE(NULL);

			// close file
			//
			if (hFile != INVALID_HANDLE_VALUE && !CloseHandle(hFile))
				fSuccess = TraceFALSE(NULL);
		}
#endif
		// free formats
		//
		if (1)
		{
			int iType;

			for (iType = FORMATFILE; fSuccess && iType <= FORMATRECORD; ++iType)
			{
				if (lpWav->lpwfx[iType] != NULL &&
					WavFormatFree(lpWav->lpwfx[iType]) != 0)
					fSuccess = TraceFALSE(NULL);
			}
		}

		// free file name string
		//
		if (lpWav->lpszFileName != NULL)
		{
			StrDupFree(lpWav->lpszFileName);
			lpWav->lpszFileName = NULL;
		}

		if ((lpWav = MemFree(NULL, lpWav)) != NULL)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// WavPlayEx - play data from wav file
//		<hWav>				(i) handle returned from WavOpen
//		<idDev>				(i) wav output device id
//			-1					use any suitable output device
//		<lpfnPlayStopped>	(i) function to call when play is stopped
//			NULL				do not notify
//		<hUserPlayStopped>	(i) param to pass to lpfnPlayStopped
//		<dwReserved>		(i) reserved; must be zero
//		<dwFlags>			(i) control flags
//			WAV_PLAYASYNC		return when playback starts (default)
//			WAV_PLAYSYNC		return after playback completes
//			WAV_NOSTOP			if device already playing, don't stop it
//			WAV_AUTOSTOP		stop playback when eof reached (default)
//			WAV_NOAUTOSTOP		continue playback until WavStop called
//			WAV_AUTOCLOSE		close wav file after playback stops
//			WAV_OPENRETRY		if output device busy, retry for up to 2 sec
// return 0 if success
//
// NOTE: data from the wav file is sent to the output device in chunks.
// Chunks are submitted to an output device queue, so that when one
// chunk is finished playing, another is ready to start playing. By
// default, each chunk is large enough to hold approximately 666 ms
// of sound, and 3 chunks are maintained in the output device queue.
// WavSetChunks() can be used to override the defaults.
//
// NOTE: if WAV_NOSTOP is specified in <dwFlags>, and the device specified
// by <idDev> is already in use, this function returns without playing.
// Unless this flag is specified, the specified device will be stopped
// so that the new sound can be played.
//
// NOTE: if WAV_AUTOSTOP is specified in <dwFlags>, WavStop() will be
// called automatically when end of file is reached.  This is the
// default behavior, but can be overridden by using the WAV_NOAUTOSTOP
// flag.  WAV_NOAUTOSTOP is useful if you are playing a file that
// is growing dynamically as another program writes to it. If this is
// the case, also use the WAV_DENYNONE flag when calling WavOpen().
//
// NOTE: if WAV_AUTOCLOSE is specified in <dwFlags>, WavClose() will
// be called automatically when playback completes.  This will happen
// when WavStop() is called explicitly, or when WavPlay() reaches end
// of file and WAV_NOAUTOSTOP was not specified.  WAV_AUTOCLOSE is useful
// when used with WAV_PLAYASYNC, since cleanup occurs automatically.
// The <hWav> handle is thereafter invalid, and should not be used again.
//
int WINAPI WavPlay(HWAV hWav, int idDev, DWORD dwFlags)
{
	return WavPlayEx(hWav, idDev, NULL, NULL, 0, dwFlags);
}

int DLLEXPORT WINAPI WavPlayEx(HWAV hWav, int idDev,
	PLAYSTOPPEDPROC lpfnPlayStopped, HANDLE hUserPlayStopped,
	DWORD dwReserved, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	int i;
	LPWAVEFORMATEX lpwfxWavOutOpen = NULL;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// make sure output device is not already open for this file
	//
	else if (lpWav->hWavOut != NULL)
		fSuccess = TraceFALSE(NULL);
		
#ifdef MULTITHREAD
	// we need to know when we can exit
	//
	else if ((lpWav->dwFlags & WAV_MULTITHREAD) &&
		(dwFlags & WAV_PLAYSYNC) &&
		(lpWav->hEventStopped = CreateEvent(
		NULL, FALSE, FALSE, NULL)) == NULL)
	{
		fSuccess = TraceFALSE(NULL);
	}
#endif

	// make sure output device is not playing
	//
	else if (WavStopOutputDevice(idDev, dwFlags) != 0)
		fSuccess = TraceFALSE(NULL);

	// set new playback format if device cannot handle the current format
	//
	else if (!WavOutSupportsFormat(NULL, idDev, lpWav->lpwfx[FORMATPLAY]))
	{
		LPWAVEFORMATEX lpwfxPlay = NULL;

		if ((lpwfxPlay = WavOutFormatSuggest(NULL,
			idDev, lpWav->lpwfx[FORMATPLAY],
			(lpWav->dwFlags & WAV_NOACM) ? WAVOUT_NOACM : 0)) != NULL &&
			WavSetFormat(hWav, lpwfxPlay, WAV_FORMATPLAY) != 0)
		{
			fSuccess = TraceFALSE(NULL);
		}

		if (lpwfxPlay != NULL && WavFormatFree(lpwfxPlay) != 0)
			fSuccess = TraceFALSE(NULL);
		else
			lpwfxPlay = NULL;
	}

	if (!fSuccess)
		;

	// create the notification callback window
	//
	else if (WavNotifyCreate(lpWav) != 0)
		fSuccess = TraceFALSE(NULL);

	// non-standard playback speed must be handled here
	//
	else if (lpWav->nSpeedLevel != 100)
	{
#ifdef AVTSM
		// use time scale modification engine
		//
		if (!(lpWav->dwFlagsSpeed & WAVSPEED_NOTSM))
		{
			long sizBufPlay;

			// calculate the size of output chunk
			//
			if ((sizBufPlay = WavCalcChunkSize(lpWav->lpwfx[FORMATPLAY],
				lpWav->msPlayChunkSize, TRUE)) <= 0)
			{
				fSuccess = TraceFALSE(NULL);
			}

			// initialize time scale modification engine
			//
			else if ((lpWav->hTsm = TsmInit(TSM_VERSION, lpWav->hInst,
				lpWav->lpwfx[FORMATPLAY],
				2, sizBufPlay * TSM_OUTBUF_SIZE_FACT, 0)) == NULL)
			{
				fSuccess = TraceFALSE(NULL);
			}

			// set the speed
			//
			else if (TsmSetSpeed(lpWav->hTsm, lpWav->nSpeedLevel, 0) != 0)
				fSuccess = TraceFALSE(NULL);
		}
		else
#endif
		// device supports playback rate directly
		//
		if (!(lpWav->dwFlagsSpeed & WAVSPEED_NOPLAYBACKRATE))
		{
			// we must wait until device has been opened
			//
			;
		}

		// device supports adjusted format
		//
		else if (!(lpWav->dwFlagsSpeed & WAVSPEED_NOFORMATADJUST))
		{
			// device supports adjusted format with acm
			//
			if (!(lpWav->dwFlagsSpeed & WAVSPEED_NOACM))
			{
#if 0
				LPWAVEFORMATEX lpwfxPlay = NULL;

				if ((lpwfxPlay = WavFormatDup(lpWav->lpwfx[FORMATPLAY])) == NULL)
					fSuccess = TraceFALSE(NULL);

				// we must double sample rate so that adjusted format works
				//
				else if (lpWav->nSpeedLevel < 100 &&
					WavFormatSpeedAdjust(lpwfxPlay, 200, 0) != 0)
				{
					fSuccess = TraceFALSE(NULL);
				}

				// we must halve sample rate so that adjusted format works
				//
				else if (lpWav->nSpeedLevel > 100 &&
					WavFormatSpeedAdjust(lpwfxPlay, 50, 0) != 0)
				{
					fSuccess = TraceFALSE(NULL);
				}

				else if (WavSetFormat(hWav, lpwfxPlay, WAV_FORMATPLAY) != 0)
					fSuccess = TraceFALSE(NULL);

				if (lpwfxPlay != NULL && WavFormatFree(lpwfxPlay) != 0)
					fSuccess = TraceFALSE(NULL);
				else
					lpwfxPlay = NULL;
#endif
			}

			if (fSuccess)
			{
				if ((lpwfxWavOutOpen = WavFormatDup(lpWav->lpwfx[FORMATPLAY])) == NULL)
					fSuccess = TraceFALSE(NULL);

				// adjust output device format to reflect current speed
				//
				else if (WavFormatSpeedAdjust(lpwfxWavOutOpen, lpWav->nSpeedLevel, 0) != 0)
					fSuccess = TraceFALSE(NULL);
			}
		}
	}

	if (!fSuccess)
		;

	// open output device
	//
	else if ((lpWav->hWavOut = WavOutOpen(WAVOUT_VERSION, lpWav->hInst, idDev,
		lpwfxWavOutOpen == NULL ? lpWav->lpwfx[FORMATPLAY] : lpwfxWavOutOpen,
#ifdef MULTITHREAD
		lpWav->dwFlags & WAV_MULTITHREAD ? (HWND)(DWORD_PTR)lpWav->dwThreadId :
#endif
		lpWav->hwndNotify, 0, 0,
#ifdef TELOUT
		((lpWav->dwFlags & WAV_TELRFILE) ? WAVOUT_TELRFILE : 0) |
#endif
#ifdef MULTITHREAD
		((lpWav->dwFlags & WAV_MULTITHREAD) ? WAVOUT_MULTITHREAD : 0) |
#endif
		((dwFlags & WAV_OPENRETRY) ? WAVOUT_OPENRETRY : 0) |
		((lpWav->dwFlags & WAV_NOACM) ? WAVOUT_NOACM : 0))) == NULL)
		fSuccess = TraceFALSE(NULL);

	// save PlayStopped params for later
	//
	else if (lpWav->lpfnPlayStopped = lpfnPlayStopped, FALSE)
		;
	else if (lpWav->hUserPlayStopped = hUserPlayStopped, FALSE)
		;

	// set the device volume if necessary
	//
	else if (lpWav->nVolumeLevel != 50 &&
		WavOutSetVolume(lpWav->hWavOut, -1, lpWav->nVolumeLevel) != 0)
		fSuccess = TraceFALSE(NULL);

	// set the device playback rate if necessary
	//
	else if (lpWav->nSpeedLevel != 100 &&
		!(lpWav->dwFlagsSpeed & WAVSPEED_NOPLAYBACKRATE) &&
		WavOutSetSpeed(lpWav->hWavOut, lpWav->nSpeedLevel) != 0)
		fSuccess = TraceFALSE(NULL);

	// setup acm conversion if play format different than file format
	//
	else if (WavFormatCmp(lpWav->lpwfx[FORMATFILE],
		lpWav->lpwfx[FORMATPLAY]) != 0 &&
		AcmConvertInit(lpWav->hAcm,
		lpWav->lpwfx[FORMATFILE], lpWav->lpwfx[FORMATPLAY], NULL, 0) != 0)
	{
		fSuccess = TraceFALSE(NULL);
	}

#if 0
	// pause output device before sending chunks to play
	//
	else if (WavOutPause(lpWav->hWavOut) != 0)
		fSuccess = TraceFALSE(NULL);
#endif

	// associate wav handle with device id
	//
	if (fSuccess)
	{
		int idDev;

		if ((idDev = WavOutGetId(lpWav->hWavOut)) < HWAVOUT_MIN ||
			idDev >= HWAVOUT_MAX)
			fSuccess = TraceFALSE(NULL);

		else
			ahWavOutCurr[idDev + HWAVOUT_OFFSET] = WavGetHandle(lpWav);
	}

	// remember the flags used in case we need them later
	//
	if (fSuccess)
		lpWav->dwFlagsPlay = dwFlags;

	// set the WAVSTATE_AUTOSTOP flag for later if necessary
	//
	if (fSuccess && !(dwFlags & WAV_NOAUTOSTOP))
		lpWav->dwState |= WAVSTATE_AUTOSTOP;

	// set the WAVSTATE_AUTOCLOSE flag for later if necessary
	//
	if (fSuccess && (dwFlags & WAV_AUTOCLOSE))
		lpWav->dwState |= WAVSTATE_AUTOCLOSE;

	// load output device queue with chunks to play
	//
	for (i = 0; fSuccess && i < lpWav->cPlayChunks; ++i)
	{
		if (WavPlayNextChunk(hWav) != 0)
			fSuccess = TraceFALSE(NULL);
	}

#if 0
	// start playback
	//
	if (fSuccess && WavOutResume(lpWav->hWavOut) != 0)
		fSuccess = TraceFALSE(NULL);
#endif

	// loop until playback complete if WAV_PLAYSYNC flag specified
	//
	if (fSuccess && (dwFlags & WAV_PLAYSYNC))
	{
#ifdef MULTITHREAD
		// handle WAV_MULTITHREAD flag
		//
		if (fSuccess && (lpWav->dwFlags & WAV_MULTITHREAD))
		{
			// wait for the play to end
			//
			if (WaitForSingleObject(lpWav->hEventStopped, INFINITE) != WAIT_OBJECT_0)
			{
				fSuccess = TraceFALSE(NULL);
			}

			// clean up
			//
			else if (lpWav->hEventStopped != NULL)
			{
				if (!CloseHandle(lpWav->hEventStopped))
					fSuccess = TraceFALSE(NULL);
				else
					lpWav->hEventStopped = NULL;
			}
		}
		else
#endif
		// check for valid pointer because WAV_AUTOCLOSE flag
		// could cause hWav to be invalidated during this loop
		//
		while (WavGetPtr(hWav) != NULL &&
			WavGetState(hWav) != WAV_STOPPED)
		{
			MSG msg;

			if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
			{
	 			TranslateMessage(&msg);
	 			DispatchMessage(&msg);
			}
			else
				WaitMessage();
		}
	}

	// close output device only if error or playback complete
	//
	if (!fSuccess || (dwFlags & WAV_PLAYSYNC))
	{
		if (WavGetPtr(hWav) != NULL && WavStopPlay(hWav) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	// clean up
	//
	if (lpwfxWavOutOpen != NULL && WavFormatFree(lpwfxWavOutOpen) != 0)
		fSuccess = TraceFALSE(NULL);
	else
		lpwfxWavOutOpen = NULL;

	return fSuccess ? 0 : -1;
}

// WavRecordEx - record data to wav file
//		<hWav>				(i) handle returned from WavOpen
//		<idDev>				(i) wav input device id
//			-1					use any suitable input device
//		<lpfnRecordStopped>	(i) function to call when record is stopped
//			NULL				do not notify
//		<dwUserRecordStopped>	(i) param to pass to lpfnRecordStopped
//		<msMaxSize>			(i) stop recording if file reaches this size
//			0					no maximum size
//		<dwFlags>			(i) control flags
//			WAV_RECORDASYNC		return when recording starts (default)
//			WAV_RECORDSYNC		return after recording completes
//			WAV_NOSTOP			if device already recording, don't stop it
//			WAV_OPENRETRY		if input device busy, retry for up to 2 sec
// return 0 if success
//
// NOTE: data from the input device is written to the wav file in chunks.
// Chunks are submitted to an input device queue, so that when one
// chunk is finished recording, another is ready to start recording.
// By default, each chunk is large enough to hold approximately 666 ms
// of sound, and 3 chunks are maintained in the input device queue.
// WavSetChunks() can be used to override the defaults.
//
// NOTE: if WAV_NOSTOP is specified in <dwFlags>, and the device specified
// by <idDev> is already in use, this function returns without recording.
// Unless this flag is specified, the specified device will be stopped
// so that the new sound can be recorded.
//
int WINAPI WavRecord(HWAV hWav, int idDev, DWORD dwFlags)
{
	return WavRecordEx(hWav, idDev, NULL, 0, 0, dwFlags);
}

int DLLEXPORT WINAPI WavRecordEx(HWAV hWav, int idDev,
	RECORDSTOPPEDPROC lpfnRecordStopped, DWORD dwUserRecordStopped,
	long msMaxSize, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	int i;
	LPWAVEFORMATEX lpwfxRecord = NULL;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// make sure input device is not already open for this file
	//
	else if (lpWav->hWavIn != NULL)
		fSuccess = TraceFALSE(NULL);

#ifdef MULTITHREAD
	// we need to know when we can exit
	//
	else if ((lpWav->dwFlags & WAV_MULTITHREAD) &&
		(dwFlags & WAV_RECORDSYNC) &&
		(lpWav->hEventStopped = CreateEvent(
		NULL, FALSE, FALSE, NULL)) == NULL)
	{
		fSuccess = TraceFALSE(NULL);
	}
#endif

	// make sure input device is not recording
	//
	else if (WavStopInputDevice(idDev, dwFlags) != 0)
		fSuccess = TraceFALSE(NULL);

	// set new recording format if device cannot handle the current format
	//
	else if (!WavInSupportsFormat(NULL, idDev, lpWav->lpwfx[FORMATRECORD]) &&
		(lpwfxRecord = WavInFormatSuggest(NULL,
		idDev, lpWav->lpwfx[FORMATRECORD],
		(lpWav->dwFlags & WAV_NOACM) ? WAVIN_NOACM : 0)) != NULL &&
		WavSetFormat(hWav, lpwfxRecord, WAV_FORMATRECORD) != 0)
	{
		fSuccess = TraceFALSE(NULL);
	}

	// create the notification callback window
	//
	else if (WavNotifyCreate(lpWav) != 0)
		fSuccess = TraceFALSE(NULL);

	// open input device
	//
	else if ((lpWav->hWavIn = WavInOpen(WAVIN_VERSION, lpWav->hInst,
		idDev, lpWav->lpwfx[FORMATRECORD],
#ifdef MULTITHREAD
		lpWav->dwFlags & WAV_MULTITHREAD ? (HWND)(DWORD_PTR)lpWav->dwThreadId :
#endif
		lpWav->hwndNotify, 0, 0,
#ifdef TELIN
		((lpWav->dwFlags & WAV_TELRFILE) ? WAVIN_TELRFILE : 0) |
#endif
#ifdef MULTITHREAD
		((lpWav->dwFlags & WAV_MULTITHREAD) ? WAVOUT_MULTITHREAD : 0) |
#endif
		((dwFlags & WAV_OPENRETRY) ? WAVIN_OPENRETRY : 0) |
		((lpWav->dwFlags & WAV_NOACM) ? WAVIN_NOACM : 0))) == NULL)
		fSuccess = TraceFALSE(NULL);

	// save params for later
	//
	else if (lpWav->lpfnRecordStopped = lpfnRecordStopped, FALSE)
		;
	else if (lpWav->dwUserRecordStopped = dwUserRecordStopped, FALSE)
		;
	else if (lpWav->msMaxSize = msMaxSize, FALSE)
		;

	// setup acm conversion if file format different than record format
	//
	else if (WavFormatCmp(lpWav->lpwfx[FORMATRECORD],
		lpWav->lpwfx[FORMATFILE]) != 0 &&
		AcmConvertInit(lpWav->hAcm,
		lpWav->lpwfx[FORMATRECORD], lpWav->lpwfx[FORMATFILE], NULL, 0) != 0)
	{
		fSuccess = TraceFALSE(NULL);
	}

	// associate wav handle with device id
	//
	if (fSuccess)
	{
		int idDev;

		if ((idDev = WavInGetId(lpWav->hWavIn)) < HWAVIN_MIN ||
			idDev >= HWAVIN_MAX)
			TraceFALSE(NULL);

		else
			ahWavInCurr[idDev + HWAVIN_OFFSET] = WavGetHandle(lpWav);
	}

	// remember the flags used in case we need them later
	//
	if (fSuccess)
		lpWav->dwFlagsRecord = dwFlags;

	// load input device queue with chunks to play
	//
	for (i = 0; fSuccess && i < lpWav->cRecordChunks; ++i)
	{
		if (WavRecordNextChunk(hWav) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	// set the WAVSTATE_AUTOSTOP flag for later if necessary
	//
	if (fSuccess && (dwFlags & WAV_AUTOSTOP))
		lpWav->dwState |= WAVSTATE_AUTOSTOP;

	// set the WAVSTATE_AUTOCLOSE flag for later if necessary
	//
	if (fSuccess && (dwFlags & WAV_AUTOCLOSE))
		lpWav->dwState |= WAVSTATE_AUTOCLOSE;

	// loop until recording complete if WAV_RECORDSYNC flag specified
	//
	if (fSuccess && (dwFlags & WAV_RECORDSYNC))
	{
#ifdef MULTITHREAD
		// handle WAV_MULTITHREAD flag
		//
		if (fSuccess && (lpWav->dwFlags & WAV_MULTITHREAD))
		{
			// wait for the record to end
			//
			if (WaitForSingleObject(lpWav->hEventStopped, INFINITE) != WAIT_OBJECT_0)
			{
				fSuccess = TraceFALSE(NULL);
			}

			// clean up
			//
			else if (lpWav->hEventStopped != NULL)
			{
				if (!CloseHandle(lpWav->hEventStopped))
					fSuccess = TraceFALSE(NULL);
				else
					lpWav->hEventStopped = NULL;
			}
		}
		else
#endif
		while (WavGetState(hWav) != WAV_STOPPED)
		{
			MSG msg;

			if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
			{
	 			TranslateMessage(&msg);
	 			DispatchMessage(&msg);
			}
			else
				WaitMessage();
		}
	}

	// close input device only if error or recording complete
	//
	if (!fSuccess || (dwFlags & WAV_RECORDSYNC))
	{
		if (WavGetPtr(hWav) != NULL && WavStopRecord(hWav) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	if (lpwfxRecord != NULL && WavFormatFree(lpwfxRecord) != 0)
		fSuccess = TraceFALSE(NULL);
	else
		lpwfxRecord = NULL;

	return fSuccess ? 0 : -1;
}

// WavStop - stop playing and/or recording
//		<hWav>				(i) handle returned from WavOpen
// return 0 if success
//
int WINAPI WavStop(HWAV hWav)
{
	BOOL fSuccess = TRUE;

	// stop playing
	//
	if (WavStopPlay(hWav) != 0)
		fSuccess = TraceFALSE(NULL);

	// stop recording
	//
	if (WavStopRecord(hWav) != 0)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

// WavRead - read data from wav file
//		<hWav>				(i) handle returned from WavOpen
//		<hpBuf>				(o) buffer to contain bytes read
//		<sizBuf>			(i) size of buffer in bytes
// return bytes read (-1 if error)
//
// NOTE : Even if the read operation does not reach the end of file,
// the number of bytes returned could be less than <sizBuf> if data
// decompression is performed by the wav file's I/O procedure. See the
// <lpIOProc> parameter in WavOpen.  It is safest to keep calling
// WavRead() until 0 bytes are read.
//
long DLLEXPORT WINAPI WavRead(HWAV hWav, void _huge *hpBuf, long sizBuf)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	long lBytesRead;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (hpBuf == NULL)
		fSuccess = TraceFALSE(NULL);

	// make sure we don't read beyond the end of the data
	// NOTE: cbData might not be accurate if file is growing dynamically,
	// so it is ok to read beyond eof if sharing flags are set
	//
	else if (!(lpWav->dwFlags & WAV_DENYNONE) &&
		!(lpWav->dwFlags & WAV_DENYREAD) &&
		(sizBuf = min(sizBuf, lpWav->cbData - lpWav->lDataPos)) < 0)
		fSuccess = TraceFALSE(NULL);

	// do the read
	//
	else if ((lBytesRead = mmioRead(lpWav->hmmio, hpBuf, sizBuf)) < 0)
		fSuccess = TraceFALSE(NULL);

 	else if (TracePrintf_1(NULL, 5,
 		TEXT("WavRead (%ld)\n"),
		(long) lBytesRead), FALSE)
		fSuccess = TraceFALSE(NULL);

	// adjust current data position
	// (and total data bytes, if file has grown)
	//
	else if ((lpWav->lDataPos += lBytesRead) > lpWav->cbData)
	{
		if ((lpWav->dwFlags & WAV_DENYNONE) ||
			(lpWav->dwFlags & WAV_DENYREAD))
			lpWav->cbData = lpWav->lDataPos;
		else
			fSuccess = TraceFALSE(NULL);
	}

	// calculate new stop position if stopped
	//
	if (fSuccess && WavCalcPositionStop(hWav, lpWav->lDataPos) != 0)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lBytesRead : -1;
}

// WavWrite - write data to wav file
//		<hWav>				(i) handle returned from WavOpen
//		<hpBuf>				(i) buffer containing bytes to write
//		<sizBuf>			(i) size of buffer in bytes
// return bytes written (-1 if error)
//
// NOTE : Even if the write operation successfully completes,
// the number of bytes returned could be less than <sizBuf> if data
// compression is performed by the wav file's I/O procedure. See the
// <lpIOProc> parameter in WavOpen.  It is safest to assume no error
// in WavWrite() occurred if the return value is greater than 0.
//
long DLLEXPORT WINAPI WavWrite(HWAV hWav, void _huge *hpBuf, long sizBuf)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	long lBytesWritten;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// special case: truncate file at current position
	//
	else if (hpBuf == NULL && sizBuf == 0)
	{
		if (WavSetLength(hWav, WavGetPosition(hWav)) < 0)
			return -1;
		else
			return 0;
	}

	else if (hpBuf == NULL)
		fSuccess = TraceFALSE(NULL);

	// do the write
	//
	else if ((lBytesWritten = mmioWrite(lpWav->hmmio, hpBuf, sizBuf)) < 0)
		fSuccess = TraceFALSE(NULL);

	// set dirty flags
	//
	else if (lpWav->ckdata.dwFlags |= MMIO_DIRTY,
		lpWav->ckRIFF.dwFlags |= MMIO_DIRTY, FALSE)
		;

 	else if (TracePrintf_1(NULL, 5,
 		TEXT("WavWrite (%ld)\n"),
		(long) lBytesWritten), FALSE)
		fSuccess = TraceFALSE(NULL);

	// adjust current data position
	// (and total data bytes, if file has grown)
	//
	else if ((lpWav->lDataPos += lBytesWritten) > lpWav->cbData)
		lpWav->cbData = lpWav->lDataPos;

	// calculate new stop position if stopped
	//
	if (fSuccess && WavCalcPositionStop(hWav, lpWav->lDataPos) != 0)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lBytesWritten : -1;
}

// WavSeek - seek within wav file data
//		<hWav>				(i) handle returned from WavOpen
//		<lOffset>			(i) bytes to move pointer
//		<nOrigin>			(i) position to move from
//			0					move pointer relative to start of data chunk
//			1					move pointer relative to current position
//			2					move pointer relative to end of data chunk
// return new file position (-1 if error)
//
long DLLEXPORT WINAPI WavSeek(HWAV hWav, long lOffset, int nOrigin)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	long lPos;
	BOOL fWavTell;
	BOOL fWavSeekTrace;

	// WavSeek(..., 0, 1) is same as WavTell(); i.e. no position change
	//
	fWavTell = (BOOL) (lOffset == 0L && nOrigin == 1);

	// traces only if position change with high trace level
	//
	fWavSeekTrace = (BOOL) (!fWavTell && TraceGetLevel(NULL) >= 6);

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// debug trace output before the seek
	//
	else if (fWavSeekTrace && WavSeekTraceBefore(lpWav, lOffset, nOrigin) != 0)
		fSuccess = TraceFALSE(NULL);

	// SEEK_SET: adjust offset relative to beginning of file
	//
	else if (nOrigin == 0 && (lOffset += lpWav->lDataOffset, FALSE))
		fSuccess = TraceFALSE(NULL);

	// SEEK_CUR: adjust offset relative to beginning of file
	//
	else if (nOrigin == 1 && (lOffset += lpWav->lDataOffset + lpWav->lDataPos, FALSE))
		fSuccess = TraceFALSE(NULL);

	// SEEK_END: adjust offset relative to beginning of file
	//
	else if (nOrigin == 2 && (lOffset += lpWav->lDataOffset + lpWav->cbData, FALSE))
		fSuccess = TraceFALSE(NULL);

	// seek is always relative to the beginning of file
	//
	else if (nOrigin = 0, FALSE)
		;

	// do the seek
	//
	else if ((lPos = mmioSeek(lpWav->hmmio, lOffset, nOrigin)) < 0)
		fSuccess = TraceFALSE(NULL);

	// adjust current data position
	//
	else if ((lpWav->lDataPos = lPos - lpWav->lDataOffset) < 0)
		fSuccess = TraceFALSE(NULL);

	// adjust total data bytes, if file has grown
	//
	else if (lpWav->lDataPos > lpWav->cbData)
	{
		if ((lpWav->dwFlags & WAV_DENYNONE) ||
			(lpWav->dwFlags & WAV_DENYREAD))
			lpWav->cbData = lpWav->lDataPos;
		else
			fSuccess = TraceFALSE(NULL);
	}

	// calculate new stop position if stopped
	// NOTE: we skip this if position unchanged
	//
	if (fSuccess && !fWavTell &&
		WavCalcPositionStop(hWav, lpWav->lDataPos) != 0)
		fSuccess = TraceFALSE(NULL);

	// debug trace output after the seek
	//
	if (fSuccess && fWavSeekTrace &&
		WavSeekTraceAfter(lpWav, lPos, lOffset, nOrigin) != 0)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lpWav->lDataPos : -1;
}

// WavGetState - return current wav state
//		<hWav>				(i) handle returned from WavOpen
// return WAV_STOPPED, WAV_PLAYING, WAV_RECORDING, or 0 if error
//
WORD DLLEXPORT WINAPI WavGetState(HWAV hWav)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	WORD wState = WAV_STOPPED;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpWav->hWavOut != NULL)
	{
		switch (WavOutGetState(lpWav->hWavOut))
		{
			case WAVOUT_PLAYING:
				wState = WAV_PLAYING;
				break;

			case WAVOUT_STOPPING:
				wState = WAV_STOPPING;
				break;

			case WAVOUT_STOPPED:
			case WAVOUT_PAUSED:
				wState = WAV_STOPPED;
				break;

			case 0:
			default:
				fSuccess = TraceFALSE(NULL);
				break;

		}
	}

	else if (lpWav->hWavIn != NULL)
	{
		switch (WavInGetState(lpWav->hWavIn))
		{
			case WAVIN_RECORDING:
				wState = WAV_RECORDING;
				break;

			case WAVIN_STOPPING:
				wState = WAV_STOPPING;
				break;

			case WAVIN_STOPPED:
				wState = WAV_STOPPED;
				break;

			case 0:
			default:
				fSuccess = TraceFALSE(NULL);
				break;

		}
	}

	// if we are in the middle of WavStopPlay() or WavStopRecord()
	// then set state to WAV_STOPPING, regardless of device state
	//
	if (fSuccess && ((lpWav->dwState & WAVSTATE_STOPPLAY) ||
		(lpWav->dwState & WAVSTATE_STOPRECORD)))
	{
		wState = WAV_STOPPING;
	}

	return fSuccess ? wState : 0;
}

// WavGetLength - get current wav data length in milleseconds
//		<hWav>				(i) handle returned from WavOpen
// return milleseconds if success, otherwise -1
//
long DLLEXPORT WINAPI WavGetLength(HWAV hWav)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	long msLength;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		msLength = WavFormatBytesToMilleseconds(
			lpWav->lpwfx[FORMATFILE], (DWORD) lpWav->cbData);
	}

	return fSuccess ? msLength : -1;
}

// WavSetLength - set current wav data length in milleseconds
//		<hWav>				(i) handle returned from WavOpen
//		<msLength>			(i) length in milleseconds
// return new length in milleseconds if success, otherwise -1
//
// NOTE: afterwards, the current wav data position is set to either
// the previous wav data position or <msLength>, whichever is smaller.
//
long DLLEXPORT WINAPI WavSetLength(HWAV hWav, long msLength)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;

	TracePrintf_1(NULL, 6,
		TEXT("WavSetLength(%ld)\n"),
		(long) msLength);

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// new length must be reasonable
	//
	else if (msLength < 0 || msLength > WavGetLength(hWav))
		fSuccess = TraceFALSE(NULL);

	else
	{
		long lBlockAlign;

		// convert <msLength> to byte offset in file
		//
		lpWav->cbData = WavFormatMillesecondsToBytes(
			lpWav->lpwfx[FORMATFILE], (DWORD) msLength);

		// $FIXUP - add <nRound> parameter to
		// WavFormatMillesecondsToBytes() and WavFormatBytesToMilleseconds()
		//
		if ((lBlockAlign = (long) lpWav->lpwfx[FORMATFILE]->nBlockAlign) > 0)
		{
			// round down to nearest block boundary
			//
			lpWav->cbData = lBlockAlign * (lpWav->cbData / lBlockAlign);
		}

		// set dirty flags
		//
		lpWav->ckdata.dwFlags |= MMIO_DIRTY;
		lpWav->ckRIFF.dwFlags |= MMIO_DIRTY;

		// adjust current data position if necessary
		//
		if (lpWav->lDataPos > lpWav->cbData)
		{
			lpWav->lDataPos = lpWav->cbData;

			// calculate new stop position if stopped
			//
			if (fSuccess && WavCalcPositionStop(hWav, lpWav->lDataPos) != 0)
				fSuccess = TraceFALSE(NULL);
		}
	}

	return fSuccess ? WavGetLength(hWav) : -1;
}

// WavGetPosition - get current wav data position in milleseconds
//		<hWav>				(i) handle returned from WavOpen
// return milleseconds if success, otherwise -1
//
long DLLEXPORT WINAPI WavGetPosition(HWAV hWav)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	long msPosition;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else switch (WavGetState(hWav))
	{
		case WAV_PLAYING:
		{
			long msPositionPlay = 0L;

			// get position relative to start of playback
			//
			if ((msPositionPlay = WavOutGetPosition(lpWav->hWavOut)) == -1)
				fSuccess = TraceFALSE(NULL);

			else
			{
				// if necessary, adjust position to compensate for non-standard speed
				//
				if (lpWav->nSpeedLevel != 100 && (
#ifdef AVTSM
					!(lpWav->dwFlagsSpeed & WAVSPEED_NOTSM) ||
#endif
					!(lpWav->dwFlagsSpeed & WAVSPEED_NOFORMATADJUST)))
				{
					msPositionPlay = msPositionPlay * lpWav->nSpeedLevel / 100;
				}

				// calc position relative to start of file
				//
				msPosition = lpWav->msPositionStop + msPositionPlay;
			}
		}
			break;

		case WAV_RECORDING:
		{
			long msPositionRecord = 0L;

			// get position relative to start of recording
			//
			if ((msPositionRecord = WavInGetPosition(lpWav->hWavIn)) == -1)
				fSuccess = TraceFALSE(NULL);

			else
			{
				// calc position relative to start of file
				//
				msPosition = lpWav->msPositionStop + msPositionRecord;
			}
		}
			break;

		default:
		{
			long cbPosition;

			// get current file position
			//
			if ((cbPosition = WavSeek(hWav, 0, 1)) == -1)
				fSuccess = TraceFALSE(NULL);

			// convert file position to milleseconds
			//
			else
			{
				msPosition = WavFormatBytesToMilleseconds(
					lpWav->lpwfx[FORMATFILE], (DWORD) cbPosition);
			}
		}
			break;
	}

	return fSuccess ? msPosition : -1;
}

// WavSetPosition - set current wav data position in milleseconds
//		<hWav>				(i) handle returned from WavOpen
//		<msPosition>		(i) position in milleseconds
// return new position in milleseconds if success, otherwise -1
//
long DLLEXPORT WINAPI WavSetPosition(HWAV hWav, long msPosition)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	WORD wStatePrev;
	int idDevPrev;
	long cbPosition;
	long cbPositionNew;
	long msPositionNew;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (WavTempStop(hWav, &wStatePrev, &idDevPrev) != 0)
		fSuccess = TraceFALSE(NULL);

	else
	{
		long lBlockAlign;

		TracePrintf_1(NULL, 6,
			TEXT("WavSetPosition(%ld)\n"),
			(long) msPosition);

		// convert <msPosition> to byte offset in file
		//
		cbPosition = WavFormatMillesecondsToBytes(
			lpWav->lpwfx[FORMATFILE], (DWORD) msPosition);

		if ((lBlockAlign = (long) lpWav->lpwfx[FORMATFILE]->nBlockAlign) > 0)
		{
			// round down to nearest block boundary
			//
			cbPosition = lBlockAlign * (cbPosition / lBlockAlign);
		}

		// seek to new position
		//
		if ((cbPositionNew = WavSeek(hWav, cbPosition, 0)) == -1)
			fSuccess = TraceFALSE(NULL);

		// convert the new position to milleseconds
		//
		if (fSuccess)
		{
			msPositionNew = WavFormatBytesToMilleseconds(
				lpWav->lpwfx[FORMATFILE], (DWORD) cbPositionNew);
		}

		if (WavTempResume(hWav, wStatePrev, idDevPrev) != 0)
			fSuccess = TraceFALSE(NULL);

	}

	return fSuccess ? msPositionNew : -1;
}

// WavGetFormat - get wav format
//		<hWav>				(i) handle returned from WavOpen
//		<dwFlags>			(i) control flags
//			WAV_FORMATFILE		get format of data in file
//			WAV_FORMATPLAY		get format of output device
//			WAV_FORMATRECORD	get format of input device
// return pointer to specified format, NULL if error
//
// NOTE: the format structure returned is dynamically allocated.
// Use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI WavGetFormat(HWAV hWav, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	int iType = 0;
	LPWAVEFORMATEX lpwfx;

	if (dwFlags & WAV_FORMATFILE)
		iType = FORMATFILE;
	if (dwFlags & WAV_FORMATPLAY)
		iType = FORMATPLAY;
	if (dwFlags & WAV_FORMATRECORD)
		iType = FORMATRECORD;

    //
    // We need to take care if hWav is NULL
    //
    if( NULL != hWav )
    {
	    if ((lpWav = WavGetPtr(hWav)) == NULL)
		    fSuccess = TraceFALSE(NULL);

	    else if ((lpwfx = WavFormatDup(lpWav->lpwfx[iType])) == NULL)
		    fSuccess = TraceFALSE(NULL);
    }
    else
        fSuccess = TraceFALSE(NULL);

	return fSuccess ? lpwfx : NULL;
}

// WavSetFormat - set wav format
//		<hWav>				(i) handle returned from WavOpen
//		<lpwfx>				(i) wav format
//		<dwFlags>			(i) control flags
//			WAV_FORMATFILE		set format of data in file
//			WAV_FORMATPLAY		set format of output device
//			WAV_FORMATRECORD	set format of input device
//			WAV_FORMATALL		set all formats
// return 0 if success
//
int DLLEXPORT WINAPI WavSetFormat(HWAV hWav,
	LPWAVEFORMATEX lpwfx, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	WORD wStatePrev;
	int idDevPrev;

	if (hWav != NULL && (lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (!WavFormatIsValid(lpwfx) != 0)
		fSuccess = TraceFALSE(NULL);

	else if (WavTempStop(hWav, &wStatePrev, &idDevPrev) != 0)
		fSuccess = TraceFALSE(NULL);

	else
	{
		int iType;

		for (iType = FORMATFILE; fSuccess && iType <= FORMATRECORD; ++iType)
		{
			if (iType == FORMATFILE && !(dwFlags & WAV_FORMATFILE))
				continue;
			if (iType == FORMATPLAY && !(dwFlags & WAV_FORMATPLAY))
				continue;
			if (iType == FORMATRECORD && !(dwFlags & WAV_FORMATRECORD))
				continue;

			// free previous format
			//
			if (lpWav->lpwfx[iType] != NULL &&
				WavFormatFree(lpWav->lpwfx[iType]) != 0)
				fSuccess = TraceFALSE(NULL);

			// save new format
			//
			else if ((lpWav->lpwfx[iType] = WavFormatDup(lpwfx)) == NULL)
				fSuccess = TraceFALSE(NULL);

			// trace format text
			//
			else if (TraceGetLevel(NULL) >= 5)
			{
				TCHAR szText[512];

				switch (iType)
				{
					case FORMATFILE:
						TraceOutput(NULL, 5, TEXT("FORMATFILE:\t"));
						break;

					case FORMATPLAY:
						TraceOutput(NULL, 5, TEXT("FORMATPLAY:\t"));
						break;

					case FORMATRECORD:
						TraceOutput(NULL, 5, TEXT("FORMATRECORD:\t"));
						break;

					default:
						break;
				}

				if (AcmFormatGetText(lpWav->hAcm,
					lpWav->lpwfx[iType], szText, SIZEOFARRAY(szText), 0) != 0)
					; // fSuccess = TraceFALSE(NULL);

				else
				{
					TracePrintf_1(NULL, 5,
						TEXT("%s\n"),
						(LPTSTR) szText);
#if 0
					WavFormatDump(lpWav->lpwfx[iType]);
#endif
				}
			}
		}

		if (WavTempResume(hWav, wStatePrev, idDevPrev) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// WavChooseFormat - choose and set audio format from dialog box
//		<hWav>				(i) handle returned from WavOpen
//		<hwndOwner>			(i) owner of dialog box
//			NULL				no owner
//		<lpszTitle>			(i) title of the dialog box
//			NULL				use default title ("Sound Selection")
//		<dwFlags>			(i)	control flags
//			WAV_FORMATFILE		set format of data in file
//			WAV_FORMATPLAY		set format of output device
//			WAV_FORMATRECORD	set format of input device
//			WAV_FORMATALL		set all formats
// return 0 if success
//
int DLLEXPORT WINAPI WavChooseFormat(HWAV hWav, HWND hwndOwner, LPCTSTR lpszTitle, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		LPWAVEFORMATEX lpwfx = NULL;
		LPWAVEFORMATEX lpwfxNew = NULL;
		DWORD dwFlagsChoose = 0;

		// see which format we are choosing
		//
		if (dwFlags & WAV_FORMATFILE)
			lpwfx = lpWav->lpwfx[FORMATFILE];
		else if (dwFlags & WAV_FORMATPLAY)
			lpwfx = lpWav->lpwfx[FORMATPLAY];
		else if (dwFlags & WAV_FORMATRECORD)
			lpwfx = lpWav->lpwfx[FORMATRECORD];
#if 0
		// restrict choices if necessary
		//
		if (dwFlags == WAV_FORMATPLAY)
			dwFlagsChoose |= ACM_FORMATPLAY;
		if (dwFlags == WAV_FORMATRECORD)
			dwFlagsChoose |= ACM_FORMATRECORD;
#endif
		// get chosen format
		//
		if ((lpwfxNew = AcmFormatChoose(lpWav->hAcm,
			hwndOwner, lpszTitle, lpwfx, dwFlagsChoose)) == NULL)
			; // no format chosen

		// set chosen format
		//
		else if (WavSetFormat(hWav, lpwfxNew, dwFlags) != 0)
			fSuccess = TraceFALSE(NULL);

		// free chosen format struct
		//
		if (lpwfxNew != NULL && WavFormatFree(lpwfxNew) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// WavGetVolume - get current volume level
//		<hWav>				(i) handle returned from WavOpen
//		<idDev>				(i) wav output device id
//			-1					use any suitable output device
//		<dwFlags>			(i) reserved; must be zero
// return volume level (0 minimum through 100 maximum, -1 if error)
//
int DLLEXPORT WINAPI WavGetVolume(HWAV hWav, int idDev, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	int nLevel;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
		nLevel = lpWav->nVolumeLevel;

	return fSuccess ? nLevel : -1;
}

// WavSetVolume - set current volume level
//		<hWav>				(i) handle returned from WavOpen
//		<idDev>				(i) wav output device id
//			-1					use any suitable output device
//		<nLevel>			(i) volume level
//			0					minimum volume
//			100					maximum volume
//		<dwFlags>			(i) control flags
//			WAVVOLUME_MIXER		set volume through mixer device
// return 0 if success
//
int DLLEXPORT WINAPI WavSetVolume(HWAV hWav, int idDev, int nLevel, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;

	TracePrintf_4(NULL, 6,
		TEXT("WavSetVolume(hWav=%p, idDev=%d, nLevel=%d, dwFlags=%08X)\n"),
		hWav,
		idDev,
		nLevel,
		dwFlags);

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (nLevel == lpWav->nVolumeLevel)
		; // nothing to be done

	else if (dwFlags & WAVVOLUME_MIXER)
	{
		HWAVMIXER hWavMixer = NULL;

		if ((hWavMixer = WavMixerInit(WAVMIXER_VERSION, lpWav->hInst,
			(LPARAM) idDev, 0, 0, WAVMIXER_WAVEOUT)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if (WavMixerSetVolume(hWavMixer, nLevel, 0) < 0)
			fSuccess = TraceFALSE(NULL);

		if (hWavMixer != NULL && WavMixerTerm(hWavMixer) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	else if (!(dwFlags & WAVVOLUME_MIXER))
	{
		if (!WavOutSupportsVolume(lpWav->hWavOut, idDev))
			fSuccess = TraceFALSE(NULL);

		// set the device volume if we are currently playing
		//
		else if (WavGetState(hWav) == WAV_PLAYING &&
			WavOutSetVolume(lpWav->hWavOut, idDev, nLevel) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	if (fSuccess)
		lpWav->nVolumeLevel = nLevel;

	return fSuccess ? 0 : -1;
}

// WavSupportsVolume - check if audio can be played at specified volume
//		<hWav>				(i) handle returned from WavOpen
//		<idDev>				(i) wav output device id
//			-1					any suitable output device
//		<nLevel>			(i) volume level
//			0					minimum volume
//			100					maximum volume
//		<dwFlags>			(i) control flags
//			WAVVOLUME_MIXER		check volume support through mixer device
// return TRUE if supported
//
BOOL DLLEXPORT WINAPI WavSupportsVolume(HWAV hWav, int idDev, int nLevel, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	BOOL fSupportsVolume = FALSE;
	LPWAV lpWav;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (dwFlags & WAVVOLUME_MIXER)
	{
		HWAVMIXER hWavMixer = NULL;

		if ((hWavMixer = WavMixerInit(WAVMIXER_VERSION, lpWav->hInst,
			(LPARAM) idDev, 0, 0, WAVMIXER_WAVEOUT)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if (WavMixerSupportsVolume(hWavMixer, 0))
			fSupportsVolume = TRUE;

		if (hWavMixer != NULL && WavMixerTerm(hWavMixer) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	else if (!(dwFlags & WAVVOLUME_MIXER))
	{
		// see if the device driver supports volume directly
		//
		if (WavOutSupportsVolume(NULL, idDev))
			fSupportsVolume = TRUE;
	}

	return fSuccess ? fSupportsVolume : FALSE;
}

// WavGetSpeed - get current speed level
//		<hWav>				(i) handle returned from WavOpen
//		<idDev>				(i) wav output device id
//			-1					use any suitable output device
//		<dwFlags>			(i) reserved; must be zero
// return speed level (100 is normal, 50 is half, 200 is double, -1 if error)
//
int DLLEXPORT WINAPI WavGetSpeed(HWAV hWav, int idDev, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	int nLevel;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
		nLevel = lpWav->nSpeedLevel;

	return fSuccess ? nLevel : -1;
}

// WavSetSpeed - set current speed level
//		<hWav>				(i) handle returned from WavOpen
//		<idDev>				(i) wav output device id
//			-1					use any suitable output device
//		<nLevel>			(i) speed level
//			50					half speed
//			100					normal speed
//			200					double speed, etc.
//		<dwFlags>			(i) control flags
#ifdef AVTSM
//			WAVSPEED_NOTSM			do not use time scale modification engine
#endif
//			WAVSPEED_NOPLAYBACKRATE	do not use device driver playback rate
//			WAVSPEED_NOFORMATADJUST	do not use adjusted format to open device
//			WAVSPEED_NOACM			do not use audio compression manager
// return 0 if success
//
// NOTE: In order to accomodate the specified speed change, it is _possible_
// that this function will in turn call WavSetFormat(hWav, ..., WAV_FORMATPLAY)
// to change the playback format of the specified file. You can prevent this
// side-effect by specifying the WAVSPEED_NOACM flag, but this reduces the likelihood
// that WavSetSpeed will succeed.
//
int DLLEXPORT WINAPI WavSetSpeed(HWAV hWav, int idDev, int nLevel, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	WORD wStatePrev;
	int idDevPrev;

	TracePrintf_4(NULL, 6,
		TEXT("WavSetSpeed(hWav=%p, idDev=%d, nLevel=%d, dwFlags=%08X)\n"),
		hWav,
		idDev,
		nLevel,
		dwFlags);

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (nLevel == lpWav->nSpeedLevel)
		; // nothing to be done

	else if (WavTempStop(hWav, &wStatePrev, &idDevPrev) != 0)
		fSuccess = TraceFALSE(NULL);

	else
	{
		if (nLevel == 100)
		{
			// normal speed is a special case
			//
			lpWav->nSpeedLevel = 100;
			lpWav->dwFlagsSpeed = 0;
		}
#ifdef AVTSM
		else if (!(dwFlags & WAVSPEED_NOTSM) &&
			WavSupportsSpeed(hWav, idDev, nLevel,
			WAVSPEED_NOACM | WAVSPEED_NOFORMATADJUST | WAVSPEED_NOPLAYBACKRATE))
		{
			// use time scale modification engine
			//
			lpWav->nSpeedLevel = nLevel;
			lpWav->dwFlagsSpeed = WAVSPEED_NOACM | WAVSPEED_NOFORMATADJUST | WAVSPEED_NOPLAYBACKRATE;
		}

		else if (!(dwFlags & WAVSPEED_NOTSM) &&
			WavSupportsSpeed(hWav, idDev, nLevel,
			WAVSPEED_NOFORMATADJUST | WAVSPEED_NOPLAYBACKRATE))
		{
#if 1
			WAVEFORMATEX wfxTsm;

			// try a format that the tsm engine will handle
			//
			if (WavSetFormat(hWav, WavFormatPcm(
				lpWav->lpwfx[FORMATPLAY]->nSamplesPerSec, 16, 1, &wfxTsm),
				WAV_FORMATPLAY) != 0)
				fSuccess = TraceFALSE(NULL);
#endif
			// use time scale modification engine with adjusted format
			//
			lpWav->nSpeedLevel = nLevel;
			lpWav->dwFlagsSpeed = WAVSPEED_NOFORMATADJUST | WAVSPEED_NOPLAYBACKRATE;
		}
#endif
		else if (!(dwFlags & WAVSPEED_NOPLAYBACKRATE) &&
			WavSupportsSpeed(hWav, idDev, nLevel,
			WAVSPEED_NOACM | WAVSPEED_NOFORMATADJUST | WAVSPEED_NOTSM))
		{
			// device supports playback rate directly
			//
			lpWav->nSpeedLevel = nLevel;
			lpWav->dwFlagsSpeed = WAVSPEED_NOACM | WAVSPEED_NOFORMATADJUST | WAVSPEED_NOTSM;
		}

		else if (!(dwFlags & WAVSPEED_NOFORMATADJUST) &&
			WavSupportsSpeed(hWav, idDev, nLevel,
			WAVSPEED_NOACM | WAVSPEED_NOPLAYBACKRATE | WAVSPEED_NOTSM))
		{
			// device supports adjusted format without acm
			//
			lpWav->nSpeedLevel = nLevel;
			lpWav->dwFlagsSpeed = WAVSPEED_NOACM | WAVSPEED_NOPLAYBACKRATE | WAVSPEED_NOTSM;
		}

		else if (!(dwFlags & WAVSPEED_NOFORMATADJUST) && !(dwFlags & WAVSPEED_NOACM) &&
			WavSupportsSpeed(hWav, idDev, nLevel,
			WAVSPEED_NOPLAYBACKRATE | WAVSPEED_NOTSM))
		{
#if 1
			LPWAVEFORMATEX lpwfxPlay = NULL;

			if ((lpwfxPlay = WavFormatDup(lpWav->lpwfx[FORMATPLAY])) == NULL)
				fSuccess = TraceFALSE(NULL);

			// we must double sample rate so that adjusted format works
			//
			else if (nLevel < 100 &&
				WavFormatSpeedAdjust(lpwfxPlay, 200, 0) != 0)
			{
				fSuccess = TraceFALSE(NULL);
			}

			// we must halve sample rate so that adjusted format works
			//
			else if (nLevel > 100 &&
				WavFormatSpeedAdjust(lpwfxPlay, 50, 0) != 0)
			{
				fSuccess = TraceFALSE(NULL);
			}

			else if (WavSetFormat(hWav, lpwfxPlay, WAV_FORMATPLAY) != 0)
				fSuccess = TraceFALSE(NULL);

			if (lpwfxPlay != NULL && WavFormatFree(lpwfxPlay) != 0)
				fSuccess = TraceFALSE(NULL);
			else
				lpwfxPlay = NULL;
#endif
			// device supports adjusted format with acm
			//
			lpWav->nSpeedLevel = nLevel;
			lpWav->dwFlagsSpeed = WAVSPEED_NOPLAYBACKRATE | WAVSPEED_NOTSM;
		}

			else
				fSuccess = TraceFALSE(NULL);

		if (WavTempResume(hWav, wStatePrev, idDevPrev) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// WavSupportsSpeed - check if audio can be played at specified speed
//		<hWav>				(i) handle returned from WavOpen
//		<idDev>				(i) wav output device id
//			-1					any suitable output device
//		<nLevel>			(i) speed level
//			50					half speed
//			100					normal speed
//			200					double speed, etc.
//		<dwFlags>			(i) control flags
#ifdef AVTSM
//			WAVSPEED_NOTSM			do not use time scale modification engine
#endif
//			WAVSPEED_NOPLAYBACKRATE	do not use device driver playback rate
//			WAVSPEED_NOFORMATADJUST	do not use adjusted format to open device
//			WAVSPEED_NOACM			do not use audio compression manager
// return TRUE if supported
//
BOOL DLLEXPORT WINAPI WavSupportsSpeed(HWAV hWav, int idDev, int nLevel, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	BOOL fSupportsSpeed = FALSE;
	LPWAV lpWav;
#ifdef AVTSM
	WAVEFORMATEX wfxTsm;
#endif

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// normal speed is a special case
	//
	else if (nLevel == 100 &&
		WavOutSupportsFormat(NULL, idDev, lpWav->lpwfx[FORMATPLAY]))
	{
		fSupportsSpeed = TRUE;
	}
#ifdef AVTSM
	// see if time scale modification will work
	//
	else if (!(dwFlags & WAVSPEED_NOTSM) &&
		TsmSupportsSpeed(nLevel, lpWav->lpwfx[FORMATPLAY], 0))
	{
		fSupportsSpeed = TRUE;
	}

	// see if time scale modification will work with PCM 16-bit mono
	//
	else if (!(dwFlags & WAVSPEED_NOTSM) && !(dwFlags & WAVSPEED_NOACM) &&
		TsmSupportsSpeed(nLevel, WavFormatPcm(
		lpWav->lpwfx[FORMATPLAY]->nSamplesPerSec, 16, 1, &wfxTsm), 0))
	{
		fSupportsSpeed = TRUE;
	}
#endif
	// see if the device driver supports playback rate directly
	//
	else if (!(dwFlags & WAVSPEED_NOPLAYBACKRATE) &&
		WavOutSupportsSpeed(NULL, idDev))
	{
		fSupportsSpeed = TRUE;
	}

	else if (!(dwFlags & WAVSPEED_NOFORMATADJUST))
	{
		LPWAVEFORMATEX lpwfx = NULL;

		if ((lpwfx = WavFormatDup(lpWav->lpwfx[FORMATPLAY])) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if (WavFormatSpeedAdjust(lpwfx, nLevel, 0) != 0)
			fSuccess = TraceTRUE(NULL);

		// see if device supports playback using adjusted format
		//
		else if (WavOutSupportsFormat(NULL, idDev, lpwfx))
		{
			fSupportsSpeed = TRUE;
		}

		if (lpwfx != NULL && WavFormatFree(lpwfx) != 0)
			fSuccess = TraceFALSE(NULL);
		else
			lpwfx = NULL;

		// as a last resort, see if doubling or halving the sample rate
		// would allow us to use a wave format that has been adjusted
		//
		if (!fSupportsSpeed && !(dwFlags & WAVSPEED_NOACM))
		{
			LPWAVEFORMATEX lpwfx = NULL;

			if (nLevel < 100)
				nLevel = nLevel * 100 / 50;
			else if (nLevel > 100)
				nLevel = nLevel * 100 / 200;

			if ((lpwfx = WavFormatDup(lpWav->lpwfx[FORMATPLAY])) == NULL)
				fSuccess = TraceFALSE(NULL);

			else if (WavFormatSpeedAdjust(lpwfx, nLevel, 0) != 0)
				fSuccess = TraceTRUE(NULL);

			// see if device supports playback using adjusted format
			//
			else if (WavOutSupportsFormat(NULL, idDev, lpwfx))
			{
				fSupportsSpeed = TRUE;
			}

			if (lpwfx != NULL && WavFormatFree(lpwfx) != 0)
				fSuccess = TraceFALSE(NULL);
			else
				lpwfx = NULL;
		}
	}

	return fSuccess ? fSupportsSpeed : FALSE;
}

// WavGetChunks - get chunk count and size
//		<hWav>				(i) handle returned from WavOpen
//			NULL				get default chunk count and size
//		<lpcChunks>			(o) buffer to hold chunk count
//			NULL				do not get chunk count
//		<lpmsChunkSize>		(o) buffer to hold chunk size
//			NULL				do not get chunk size
//		<fWavOut>			(i) TRUE for playback, FALSE for recording
// return 0 if success
//
int DLLEXPORT WINAPI WavGetChunks(HWAV hWav,
	int FAR *lpcChunks, long FAR *lpmsChunkSize, BOOL fWavOut)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;

	if (hWav != NULL && (lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		if (lpcChunks != NULL)
		{
			if (hWav == NULL)
			{
				*lpcChunks = fWavOut ?
					cPlayChunksDefault : cRecordChunksDefault;
			}
			else
			{
				*lpcChunks = fWavOut ?
					lpWav->cPlayChunks : lpWav->cRecordChunks;
			}
		}

		if (lpmsChunkSize != NULL)
		{
			if (hWav == NULL)
			{
				*lpmsChunkSize = fWavOut ?
					msPlayChunkSizeDefault : msRecordChunkSizeDefault;
			}
			else
			{
				*lpmsChunkSize = fWavOut ?
					lpWav->msPlayChunkSize : lpWav->msRecordChunkSize;
			}
		}
	}

	return fSuccess ? 0 : -1;
}

// WavSetChunks - set chunk count and size
//		<hWav>				(i) handle returned from WavOpen
//			NULL				set default chunk count and size
//		<cChunks>			(i) number of chunks in device queue
//			-1					do not set chunk count
//		<msChunkSize>		(i) chunk size in milleseconds
//			-1					do not set chunk size
//		<fWavOut>			(i) TRUE for playback, FALSE for recording
// return 0 if success
//
int DLLEXPORT WINAPI WavSetChunks(HWAV hWav, int cChunks, long msChunkSize, BOOL fWavOut)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;

	if (hWav != NULL && (lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (fWavOut && cChunks != -1 &&
		(cChunks < PLAYCHUNKCOUNT_MIN ||
		cChunks > PLAYCHUNKCOUNT_MAX))
		fSuccess = TraceFALSE(NULL);

	else if (fWavOut && msChunkSize != -1 &&
		(msChunkSize < PLAYCHUNKSIZE_MIN ||
		msChunkSize > PLAYCHUNKSIZE_MAX))
		fSuccess = TraceFALSE(NULL);

	else if (!fWavOut && cChunks != -1 &&
		(cChunks < RECORDCHUNKCOUNT_MIN ||
		cChunks > RECORDCHUNKCOUNT_MAX))
		fSuccess = TraceFALSE(NULL);

	else if (!fWavOut && msChunkSize != -1 &&
		(msChunkSize < RECORDCHUNKSIZE_MIN ||
		msChunkSize > RECORDCHUNKSIZE_MAX))
		fSuccess = TraceFALSE(NULL);

	else
	{
		if (fWavOut && cChunks != -1)
		{
			if (hWav == NULL)
				cPlayChunksDefault = cChunks;
			else
				lpWav->cPlayChunks = cChunks;
		}
		
		if (fWavOut && msChunkSize != -1)
		{
			if (hWav == NULL)
				msPlayChunkSizeDefault = msChunkSize;
			else
				lpWav->msPlayChunkSize = msChunkSize;
		}

		if (!fWavOut && cChunks != -1)
		{
			if (hWav == NULL)
				cRecordChunksDefault = cChunks;
			else
				lpWav->cRecordChunks = cChunks;
		}
		
		if (!fWavOut && msChunkSize != -1)
		{
			if (hWav == NULL)
				msRecordChunkSizeDefault = msChunkSize;
			else
				lpWav->msRecordChunkSize = msChunkSize;
		}
	}

	return fSuccess ? 0 : -1;
}

// WavCalcChunkSize - calculate chunk size in bytes
//		<lpwfx>				(i) wav format
//		<msPlayChunkSize>	(i) chunk size in milleseconds
//			-1					default chunk size
//		<fWavOut>			(i) TRUE for playback, FALSE for recording
// return chunk size in bytes (-1 if success)
//
long DLLEXPORT WINAPI WavCalcChunkSize(LPWAVEFORMATEX lpwfx,
	long msChunkSize, BOOL fWavOut)
{
	BOOL fSuccess = TRUE;
	long cbChunkSize;

	if (msChunkSize == -1)
	{
		msChunkSize = fWavOut ?
			PLAYCHUNKSIZE_DEFAULT : RECORDCHUNKSIZE_DEFAULT;
	}

	if (!WavFormatIsValid(lpwfx) != 0)
		fSuccess = TraceFALSE(NULL);

	else if (fWavOut &&
		(msChunkSize < PLAYCHUNKSIZE_MIN ||
		msChunkSize > PLAYCHUNKSIZE_MAX))
		fSuccess = TraceFALSE(NULL);

	else if (!fWavOut &&
		(msChunkSize < RECORDCHUNKSIZE_MIN ||
		msChunkSize > RECORDCHUNKSIZE_MAX))
		fSuccess = TraceFALSE(NULL);

#if 0 // this only works for PCM
	else
	{
		int nBytesPerSample;

		// calculate bytes per sample
		//
		nBytesPerSample = lpwfx->nChannels *
			(((lpwfx->wBitsPerSample - 1) / 8) + 1);

		// calculate chunk size in bytes
		//
		cbChunkSize = msChunkSize *
			lpwfx->nSamplesPerSec * nBytesPerSample / 1000L;

		// round up to nearest 1K bytes
		//
		cbChunkSize = 1024L * ((cbChunkSize + 1023L) / 1024L);
	}
#else
	else
	{
		long lBlockAlign;

		// calculate chunk size in bytes
		//
		cbChunkSize = msChunkSize * lpwfx->nAvgBytesPerSec / 1000L;

		// round up to nearest block boundary
		//
		if ((lBlockAlign = (long) lpwfx->nBlockAlign) > 0)
		{
			cbChunkSize = lBlockAlign *
				((cbChunkSize + lBlockAlign - 1) / lBlockAlign);
		}
	}
#endif

	return fSuccess ? cbChunkSize : -1;
}

// WavCopy - copy data from one open wav file to another
//		<hWavSrc>			(i) source handle returned from WavOpen
//		<hWavDst>			(i) destination handle returned from WavOpen
//		<hpBuf>				(o) pointer to copy buffer
//			NULL				allocate buffer internally
//		<sizBuf>			(i) size of copy buffer
//			-1					default buffer size (16K)
//		<lpfnUserAbort>		(i) function that returns TRUE if user aborts
//			NULL				don't check for user abort
//		<dwUser>			(i) parameter passed to <lpfnUserAbort>
//		<dwFlags>			(i) control flags
//			WAV_NOACM			do not use audio compression manager
// return 0 if success (-1 if error, +1 if user abort)
//
int DLLEXPORT WINAPI WavCopy(HWAV hWavSrc, HWAV hWavDst,
	void _huge *hpBuf, long sizBuf, USERABORTPROC lpfnUserAbort, DWORD dwUser, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWavSrc;
	LPWAV lpWavDst;
	LPWAVEFORMATEX lpwfxSrc;
	LPWAVEFORMATEX lpwfxDst;
	BOOL fFreeBuf = (BOOL) (hpBuf == NULL);
	BOOL fUserAbort = FALSE;

	// calc buffer size if none supplied
	//
	if (sizBuf <= 0)
		sizBuf = 16 * 1024;

	if ((lpWavSrc = WavGetPtr(hWavSrc)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpWavDst = WavGetPtr(hWavDst)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// get source file format
	//
	else if ((lpwfxSrc = WavGetFormat(hWavSrc, WAV_FORMATFILE)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// get destination file format
	//
	else if ((lpwfxDst = WavGetFormat(hWavDst, WAV_FORMATFILE)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// allocate buffer if none supplied
	//
	else if (hpBuf == NULL && (hpBuf = MemAlloc(NULL, sizBuf, 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// do simple copy if no conversion is required
	//
	else if (WavFormatCmp(lpwfxSrc, lpwfxDst) == 0)
	{
		long lBytesReadTotal = 0;
		long lBytesTotal = max(1, lpWavSrc->cbData - lpWavSrc->lDataPos);

		while (fSuccess)
		{
			long lBytesRead;
			long lBytesWritten;

			// check for user abort, notify of percent complete
			//
			if (lpfnUserAbort != NULL &&
				(*lpfnUserAbort)(dwUser, (int) (lBytesReadTotal / lBytesTotal)))
			{
				fUserAbort = TRUE;
				break;
			}

			// fill copy buffer
			//
			else if ((lBytesRead = WavRead(hWavSrc, hpBuf, sizBuf)) < 0)
				fSuccess = TraceFALSE(NULL);

			// keep running total
			//
			else if ((lBytesReadTotal += lBytesRead) < 0)
				fSuccess = TraceFALSE(NULL);

			// check for end of file
			//
			else if (lBytesRead == 0)
				break; // eof

			// write the buffer
			//
			else if ((lBytesWritten = WavWrite(hWavDst, hpBuf, lBytesRead)) < 0)
				fSuccess = TraceFALSE(NULL);
		}

		// notify of 100% complete
		//
		if (fSuccess && lpfnUserAbort != NULL)
			(*lpfnUserAbort)(dwUser, 100);
	}

	// different formats require conversion during copy
	//
	else
	{
		long lBytesReadTotal = 0;
		long lBytesTotal = max(1, lpWavSrc->cbData - lpWavSrc->lDataPos);
		HACM hAcm = NULL;
		long sizBufRead;
		void _huge *hpBufRead = NULL;

		// turn on WAV_NOACM flag if either file was opened with it
		//
		if ((lpWavSrc->dwFlags & WAV_NOACM) ||
			(lpWavDst->dwFlags & WAV_NOACM))
			dwFlags |= WAV_NOACM;

		// start acm engine
		//
		if ((hAcm = AcmInit(ACM_VERSION, lpWavSrc->hInst,
			(dwFlags & WAV_NOACM) ? ACM_NOACM : 0)) == NULL)
			fSuccess = TraceFALSE(NULL);

		// start conversion engine
		//
		else if (AcmConvertInit(hAcm, lpwfxSrc, lpwfxDst, NULL, 0) != 0)
			fSuccess = TraceFALSE(NULL);

		// calc how many bytes required for read buffer
		//
		else if ((sizBufRead = AcmConvertGetSizeSrc(hAcm, sizBuf)) <= 0)
			fSuccess = TraceFALSE(NULL);
		
		// allocate read buffer
		//
		else if ((hpBufRead = (void _huge *) MemAlloc(NULL,
			sizBufRead, 0)) == NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}

		// do the conversion during the copy
		//
		else while (fSuccess)
		{
			long lBytesRead;
			long lBytesConverted;
			long lBytesWritten;

			// check for user abort, notify of percent complete
			//
			if (lpfnUserAbort != NULL &&
				(*lpfnUserAbort)(dwUser, (int) (lBytesReadTotal / lBytesTotal)))
			{
				fUserAbort = TRUE;
				break;
			}

			// fill read buffer
			//
			else if ((lBytesRead = WavRead(hWavSrc, hpBufRead, sizBufRead)) < 0)
				fSuccess = TraceFALSE(NULL);

			// keep running total
			//
			else if ((lBytesReadTotal += lBytesRead) < 0)
				fSuccess = TraceFALSE(NULL);

			// check for end of file
			//
			else if (lBytesRead == 0)
				break; // eof

			// convert the data
			//
			else if ((lBytesConverted = AcmConvert(hAcm,
				hpBufRead, lBytesRead, hpBuf, sizBuf, 0)) < 0)
			{
				fSuccess = TraceFALSE(NULL);
			}

			// write the buffer
			//
			else if ((lBytesWritten = WavWrite(hWavDst,
				hpBuf, lBytesConverted)) < 0)
			{
				fSuccess = TraceFALSE(NULL);
			}
		}

		// notify of 100% complete
		//
		if (fSuccess && lpfnUserAbort != NULL)
			(*lpfnUserAbort)(dwUser, 100);

		// clean up
		//

		if (hpBufRead != NULL &&
			(hpBufRead = MemFree(NULL, hpBufRead)) != NULL)
			fSuccess = TraceFALSE(NULL);

		// NOTE: AcmConvertTerm() is called from AcmTerm()
		//
		if (hAcm != NULL && AcmTerm(hAcm) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	// clean up
	//
	if (hpBuf != NULL && fFreeBuf &&
		(hpBuf = MemFree(NULL, hpBuf)) != NULL)
		fSuccess = TraceFALSE(NULL);

	if (!fSuccess)
		return -1;
	else if (fUserAbort)
		return +1;
	else
		return 0;
}

#ifdef AVTSM
// WavReadFormatSpeed - read data from wav file, then format it for speed
//		<hWav>				(i) handle returned from WavOpen
//		<hpBufSpeed>		(o) buffer to contain bytes read
//		<sizBufSpeed>		(i) size of buffer in bytes
// return bytes formatted for speed in <hpBuf> (-1 if error)
//
// NOTE: this function reads a block of data, and then converts it
// from the file format to the speed format, unless those formats
// are identical.
//
long DLLEXPORT WINAPI WavReadFormatSpeed(HWAV hWav, void _huge *hpBufSpeed, long sizBufSpeed)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	long sizBufPlay;
	void _huge *hpBufPlay = NULL;
	long lBytesPlay;
	long lBytesSpeed = 0;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// see if speed conversion required
	//
	else if (lpWav->nSpeedLevel == 100 ||
		(lpWav->dwFlagsSpeed & WAVSPEED_NOTSM))
	{
		// no, so just convert file format to play format
		//
		if ((lBytesSpeed = WavReadFormatPlay(hWav, hpBufSpeed, sizBufSpeed)) < 0)
			fSuccess = TraceFALSE(NULL);
	}

	// calc how many bytes required for play buffer
	//
	else if ((sizBufPlay = sizBufSpeed * (lpWav->nSpeedLevel - 2) / 100) <= 0)
		fSuccess = TraceFALSE(NULL);

	// round down to nearest block boundary
	//
	else if (lpWav->lpwfx[FORMATPLAY]->nBlockAlign > 0 &&
		(sizBufPlay = lpWav->lpwfx[FORMATPLAY]->nBlockAlign *
		(sizBufPlay / lpWav->lpwfx[FORMATPLAY]->nBlockAlign)) <= 0)
	{
		fSuccess = TraceFALSE(NULL);
	}

	// allocate play buffer
	//
	else if ((hpBufPlay = (void _huge *) MemAlloc(NULL,
		sizBufPlay, 0)) == NULL)
	{
		fSuccess = TraceFALSE(NULL);
	}

	// fill play buffer
	//
	else if ((lBytesPlay = WavReadFormatPlay(hWav, hpBufPlay, sizBufPlay)) < 0)
		fSuccess = TraceFALSE(NULL);

	// convert the data from playback format to speed format
	//
	else if (lBytesPlay > 0 &&
		(lBytesSpeed = TsmConvert(lpWav->hTsm,
		hpBufPlay, lBytesPlay, hpBufSpeed, sizBufSpeed, 0)) < 0)
	{
		fSuccess = TraceFALSE(NULL);
	}

	// clean up
	//
	if (hpBufPlay != NULL &&
		(hpBufPlay = MemFree(NULL, hpBufPlay)) != NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lBytesSpeed : -1;
}
#endif

// WavReadFormatPlay - read data from wav file, then format it for playback
//		<hWav>				(i) handle returned from WavOpen
//		<hpBufPlay>			(o) buffer to contain bytes read
//		<sizBufPlay>		(i) size of buffer in bytes
// return bytes formatted for playback in <hpBuf> (-1 if error)
//
// NOTE: this function reads a block of data, and then converts it
// from the file format to the playback format, unless those formats
// are identical.
//
long DLLEXPORT WINAPI WavReadFormatPlay(HWAV hWav, void _huge *hpBufPlay, long sizBufPlay)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	long sizBufRead;
	void _huge *hpBufRead = NULL;
	long lBytesRead;
	long lBytesPlay = 0;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// see if format conversion required
	//
	else if (WavFormatCmp(lpWav->lpwfx[FORMATFILE],
		lpWav->lpwfx[FORMATPLAY]) == 0)
	{
		// no, so just read block directly into the play buffer
		//
		if ((lBytesPlay = WavRead(hWav, hpBufPlay, sizBufPlay)) < 0)
			fSuccess = TraceFALSE(NULL);
	}

	// calc how many bytes required for read buffer
	//
	else if ((sizBufRead = AcmConvertGetSizeSrc(lpWav->hAcm,
		sizBufPlay)) <= 0)
		fSuccess = TraceFALSE(NULL);
		
	// allocate read buffer
	//
	else if ((hpBufRead = (void _huge *) MemAlloc(NULL,
		sizBufRead, 0)) == NULL)
	{
		fSuccess = TraceFALSE(NULL);
	}

	// fill read buffer
	//
	else if ((lBytesRead = WavRead(hWav, hpBufRead, sizBufRead)) < 0)
		fSuccess = TraceFALSE(NULL);

	// convert the data from file format to playback format
	//
	else if (lBytesRead > 0 &&
		(lBytesPlay = AcmConvert(lpWav->hAcm,
		hpBufRead, lBytesRead, hpBufPlay, sizBufPlay, 0)) < 0)
	{
		fSuccess = TraceFALSE(NULL);
	}

	// clean up
	//
	if (hpBufRead != NULL &&
		(hpBufRead = MemFree(NULL, hpBufRead)) != NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lBytesPlay : -1;
}

// WavWriteFormatRecord - write data to file after formatting it for file
//		<hWav>				(i) handle returned from WavOpen
//		<hpBufRecord>		(i) buffer containing bytes in record format
//		<sizBufRecord>		(i) size of buffer in bytes
// return bytes written (-1 if error)
//
// NOTE: this function converts a block of data from the record
// format to the file format (unless those formats are identical),
// and then writes the data to disk.
//
long DLLEXPORT WINAPI WavWriteFormatRecord(HWAV hWav, void _huge *hpBufRecord, long sizBufRecord)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	long sizBufWrite;
	void _huge *hpBufWrite = NULL;
	long lBytesWrite;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// see if format conversion required
	//
	else if (WavFormatCmp(lpWav->lpwfx[FORMATRECORD],
		lpWav->lpwfx[FORMATFILE]) == 0)
	{
		// no, so just write record buffer directly to the file
		//
		if ((lBytesWrite = WavWrite(hWav, hpBufRecord, sizBufRecord)) < 0)
			fSuccess = TraceFALSE(NULL);
	}

	// calc how many bytes required for write buffer
	//
	else if ((sizBufWrite = AcmConvertGetSizeDst(lpWav->hAcm,
		sizBufRecord)) <= 0)
		fSuccess = TraceFALSE(NULL);

	// allocate write buffer
	//
	else if ((hpBufWrite = (void _huge *) MemAlloc(NULL,
		sizBufWrite, 0)) == NULL)
	{
		fSuccess = TraceFALSE(NULL);
	}

	// convert the data from record format to file format
	//
	else if ((lBytesWrite = AcmConvert(lpWav->hAcm,
		hpBufRecord, sizBufRecord, hpBufWrite, sizBufWrite, 0)) < 0)
	{
		fSuccess = TraceFALSE(NULL);
	}

	// write buffer to disk
	//
	else if ((lBytesWrite = WavWrite(hWav, hpBufWrite, lBytesWrite)) < 0)
		fSuccess = TraceFALSE(NULL);

	// clean up
	//
	if (hpBufWrite != NULL &&
		(hpBufWrite = MemFree(NULL, hpBufWrite)) != NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lBytesWrite : -1;
}

// WavGetOutputDevice - get handle to open wav output device
//		<hWav>				(i) handle returned from WavOpen
// return handle to wav output device (NULL if device not open or error)
//
// NOTE: this function is useful only during playback (after calling
// WavPlay() and before calling WavStop()).  The returned device handle
// can then be used when calling the WavOut functions in wavout.h
//
HWAVOUT DLLEXPORT WINAPI WavGetOutputDevice(HWAV hWav)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lpWav->hWavOut : NULL;
}

// WavGetInputDevice - get handle to open wav input device
//		<hWav>				(i) handle returned from WavOpen
// return handle to wav input device (NULL if device not open or error)
//
// NOTE: this function is useful only during recording (after calling
// WavRecord() and before calling WavStop()).  The returned device handle
// can then be used when calling the WavIn functions in wavin.h
//
HWAVIN DLLEXPORT WINAPI WavGetInputDevice(HWAV hWav)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lpWav->hWavIn : NULL;
}

// WavPlaySound - play wav file
//		<dwVersion>			(i) must be WAV_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<idDev>				(i) wav output device id
//			-1					use any suitable output device
//		<lpszFileName>		(i) name of file to play
//			NULL				stop playing current sound, if any
//		<lpwfx>				(i) wave format
//			NULL				use format from header or default
//		<lpIOProc>			(i) address of i/o procedure to use
//			NULL				use default i/o procedure
//		<lpadwInfo>			(i) data to pass to i/o procedure during open
//			NULL				no data to pass
//		<dwFlags>			(i) control flags
//			WAV_ASYNC			return when playback starts (default)
//			WAV_SYNC			return after playback completes
//			WAV_FILENAME		<lpszFileName> points to a filename
//			WAV_RESOURCE		<lpszFileName> points to a resource
//			WAV_MEMORY			<lpszFileName> points to memory block
//			WAV_NODEFAULT		if sound not found, do not play default
//			WAV_LOOP			loop sound until WavPlaySound called again
//			WAV_NOSTOP			if device already playing, don't stop it
//			WAV_NORIFF			file has no RIFF/WAV header
//			WAV_NOACM			do not use audio compression manager
//			WAV_OPENRETRY		if output device busy, retry for up to 2 sec
#ifdef MULTITHREAD
//			WAV_MULTITHREAD		support multiple threads (default)
//			WAV_SINGLETHREAD	do not support multiple threads
//			WAV_COINITIALIZE	call CoInitialize in all secondary threads
#endif
// return 0 if success
//
// NOTE: if WAV_NORIFF is specified in <dwFlags>, then the
// <lpwfx> parameter must be specified.  If <lpwfx> is NULL, the
// current default format is assumed.
// WavSetFormat() can be used to set or override the defaults.
//
// NOTE: if WAV_FILENAME is specified in <dwFlags>, then <lpszFileName>
// must point to a file name.
//
// NOTE: if WAV_RESOURCE is specified in <dwFlags>, then <lpszFileName>
// must point to a WAVE resource in the module specified by <hInst>.
// If the first character of the string is a pound sign (#), the remaining
// characters represent a decimal number that specifies the resource id.
//
// NOTE: if WAV_MEMORY is specified in <dwFlags>, then <lpszFileName>
// must be a pointer to a memory block containing a wav file image.
// The pointer must be obtained by calling MemAlloc().
//
// NOTE: if neither WAV_FILENAME, WAV_RESOURCE, or WAV_MEMORY is specified
// in <dwFlags>, the [sounds] section of win.ini or the registry is
// searched for an entry matching <lpszFileName>.  If no matching entry
// is found, <lpszFileName> is assumed to be a file name.
//
// NOTE: if WAV_NODEFAULT is specified in <dwFlags>, no default sound
// will be played.  Unless this flag is specified, the default system
// event sound entry will be played if the sound specified in
// <lpszFileName> is not found.
//
// NOTE: if WAV_LOOP is specified in <dwFlags>, the sound specified in
// <lpszFileName> will be played repeatedly, until WavPlaySound() is
// called again.  The WAV_ASYNC flag must be specified when using this flag.
//
// NOTE: if WAV_NOSTOP is specified in <dwFlags>, and the device specified
// by <idDev> is already in use, this function returns without playing.
// Unless this flag is specified, the specified device will be stopped
// so that the new sound can be played.
//
// NOTE: if <lpIOProc> is not NULL, this i/o procedure will be called
// for opening, closing, reading, writing, and seeking the wav file.
// If <lpadwInfo> is not NULL, this array of three (3) DWORDs will be
// passed to the i/o procedure when the wav file is opened.
// See the Windows mmioOpen() and mmioInstallIOProc() function for details
// on these parameters.  Also, the WAV_MEMORY and WAV_RESOURCE flags may
// only be used when <lpIOProc> is NULL.
//
int DLLEXPORT WINAPI WavPlaySound(DWORD dwVersion, HINSTANCE hInst,
	int idDev, LPCTSTR lpszFileName, LPWAVEFORMATEX lpwfx,
	LPMMIOPROC lpIOProc, DWORD FAR *lpadwInfo, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	HWAV hWav = NULL;
	LPCTSTR lpszSound = lpszFileName;
	TCHAR szSound[_MAX_PATH];

	// stop current sound if necessary
	//
	if (lpszFileName == NULL && WavStopOutputDevice(idDev, dwFlags) != 0)
		fSuccess = TraceFALSE(NULL);

	if (lpszSound != NULL)
	{
		// search win.ini or registry if necessary
		//
		if (!(dwFlags & WAV_FILENAME) &&
			!(dwFlags & WAV_RESOURCE) &&
			!(dwFlags & WAV_MEMORY))
		{
			if (GetProfileString(TEXT("Sounds"), lpszFileName, TEXT(""),
				szSound, SIZEOFARRAY(szSound)) > 0)
			{
				LPTSTR lpszComma;

				// ignore text description starting with comma
				//
				if ((lpszComma = StrChr(szSound, ',')) != NULL)
					*lpszComma = '\0';

				if (*szSound != '\0')
					lpszSound = szSound;
			}
		}

		// open sound
		//
		if ((hWav = WavOpen(WAV_VERSION, hInst, lpszSound, lpwfx,
			lpIOProc, lpadwInfo, dwFlags | WAV_READ)) == NULL)
		{
			// play default sound unless WAV_NODEFAULT flag set
			//
			if (!(dwFlags & WAV_NODEFAULT))
			{
				// find system default sound
				//
				if (GetProfileString(TEXT("Sounds"), TEXT("SystemDefault"), TEXT(""),
					szSound, SIZEOFARRAY(szSound)) > 0)
				{
					LPTSTR lpszComma;

					// ignore text description starting with comma
					//
					if ((lpszComma = StrChr(szSound, ',')) != NULL)
						*lpszComma = '\0';

					// open system default sound
					//
					if (*szSound != '\0' &&
						(hWav = WavOpen(WAV_VERSION, hInst, szSound,
						NULL, NULL, NULL, WAV_READ)) == NULL)
						fSuccess = TraceFALSE(NULL);
				}
			}
		}

		// play the sound
		//
		if (fSuccess && hWav != NULL)
		{
			if (dwFlags & WAV_ASYNC)
				dwFlags |= WAV_PLAYASYNC;
			if (dwFlags & WAV_SYNC)
				dwFlags |= WAV_PLAYSYNC;

			if (WavPlay(hWav, idDev, dwFlags | WAV_AUTOCLOSE) != 0)
				fSuccess = TraceFALSE(NULL);
		}

		// clean up
		//
		if (!fSuccess && hWav != NULL && WavClose(hWav) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// WavSendMessage - send a user-defined message to the i/o procedure
//		<hWav>				(i) handle returned from WavOpen
//		<wMsg>				(i) user-defined message id
//		<lParam1>			(i) parameter for the message
//		<lParam2>			(i) parameter for the message
// return value from the i/o procedure (0 if error or unrecognized message)
//
LRESULT DLLEXPORT WINAPI WavSendMessage(HWAV hWav,
	UINT wMsg, LPARAM lParam1, LPARAM lParam2)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	LRESULT lResult;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpWav->hmmio == NULL)
		fSuccess = TraceFALSE(NULL);

	else
		lResult = mmioSendMessage(lpWav->hmmio, wMsg, lParam1, lParam2);

	return fSuccess ? lResult : 0;
}

#ifdef TELTHUNK
// WavOpenEx - open an audio file, extra special version
//		<dwVersion>			(i) must be WAV_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<lpszFileName>		(i) name of file to open
//		<dwReserved>		(i) reserved; must be zero
//		<dwFlagsOpen>		(i) control flags to pass to WavOpen
//		<dwFlagsEx>			(i) control flags
//			WOX_LOCAL			file is on local client
//			WOX_REMOTE			file is on remote server
//			WOX_WAVFMT			file is in Microsoft RIFF/WAV format
//			WOX_VOXFMT			file is in Dialogic OKI ADPCM (vox) format
//			WOX_WAVDEV			file will be played on wav output device
//			WOX_TELDEV			file will be played on telephone device
// return handle (NULL if error)
//
HWAV DLLEXPORT WINAPI WavOpenEx(DWORD dwVersion, HINSTANCE hInst,
	LPTSTR lpszFileName, DWORD dwReserved, DWORD dwFlagsOpen, DWORD dwFlagsEx)
{
	BOOL fSuccess = TRUE;
	HWAV hWav = NULL;

	if ((dwFlagsEx & WOX_TELDEV) || (dwFlagsEx & WOX_REMOTE))
	{
	 	hWav = TelWavOpenEx(TELWAV_VERSION, hInst,
			lpszFileName, 0, dwFlagsOpen, dwFlagsEx);
	}
	else
	{
		WAVEFORMATEX wfx;
		LPWAVEFORMATEX lpwfx = NULL;

		if (dwFlagsEx & WOX_VOXFMT)
		{
			dwFlagsOpen |= WAV_NORIFF;
			lpwfx = VoxFormat(&wfx, -1);
		}

		hWav = WavOpen(WAV_VERSION, hInst,
			lpszFileName, lpwfx, NULL, 0, dwFlagsOpen);
	}

	return fSuccess ? hWav : NULL;
}
#endif

////
//	helper functions
////

// WavStopPlay - stop playing
//		<hWav>				(i) handle returned from WavOpen
// return 0 if success
//
static int WavStopPlay(HWAV hWav)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
		lpWav->dwState |= WAVSTATE_AUTOSTOP;

	// close output device if necessary
	//
	if (fSuccess &&
		!(lpWav->dwState & WAVSTATE_STOPPLAY) &&
		lpWav->hWavOut != NULL)
	{
		long msPositionPlay = 0L;

		// set a state flag so we never execute this code recursively
		//
		lpWav->dwState |= WAVSTATE_STOPPLAY;

		// get current playback position
		//
		if ((msPositionPlay = WavOutGetPosition(lpWav->hWavOut)) == -1)
		{
			// let's ignore errors here and assume play position is 0;
			//
			msPositionPlay = 0L;
			fSuccess = TraceTRUE(NULL);
		}

		else
		{
			// if necessary, adjust position to compensate for non-standard speed
			//
			if (lpWav->nSpeedLevel != 100 && (
#ifdef AVTSM
				!(lpWav->dwFlagsSpeed & WAVSPEED_NOTSM) ||
#endif
				!(lpWav->dwFlagsSpeed & WAVSPEED_NOFORMATADJUST)))
			{
				msPositionPlay = msPositionPlay * lpWav->nSpeedLevel / 100;
			}
		}
#if 1
		TracePrintf_2(NULL, 6,
			TEXT("lpWav->msPositionStop=%ld, msPositionPlay=%ld\n"),
			(long) lpWav->msPositionStop,
			(long) msPositionPlay);
#endif
		// clear wav handle array entry
		//
		if (fSuccess)
		{
			int idDev;

			if ((idDev = WavOutGetId(lpWav->hWavOut)) < HWAVOUT_MIN ||
				idDev >= HWAVOUT_MAX)
				fSuccess = TraceFALSE(NULL);

			else
				ahWavOutCurr[idDev + HWAVOUT_OFFSET] = NULL;
		}

		// close output device
		//
		if (WavOutClose(lpWav->hWavOut, 0) != 0)
			fSuccess = TraceFALSE(NULL);

		else if ((lpWav->hWavOut = NULL), FALSE)
			fSuccess = TraceFALSE(NULL);

		// destroy the notification callback window
		//
		else if (WavNotifyDestroy(lpWav) != 0)
			fSuccess = TraceFALSE(NULL);

		// move read/write pointer (back) to new stop position
		//
		else if (WavSetPosition(hWav, min(WavGetLength(hWav),
			lpWav->msPositionStop + msPositionPlay)) == -1)
			fSuccess = TraceFALSE(NULL);

		// close acm conversion engine
		//
		else if (AcmConvertTerm(lpWav->hAcm) != 0)
			fSuccess = TraceFALSE(NULL);

		// notify user that play is stopped if necessary
		//
		if (lpWav->lpfnPlayStopped != NULL)
		{
			(*lpWav->lpfnPlayStopped)(hWav, lpWav->hUserPlayStopped, 0);
			lpWav->lpfnPlayStopped = NULL;
			lpWav->hUserPlayStopped = NULL;
		}

		// clear state flags
		//
		lpWav->dwState &= ~WAVSTATE_STOPPLAY;

		// close wav file if specified
		//
		if (lpWav->dwState & WAVSTATE_AUTOCLOSE)
		{
			lpWav->dwState &= ~WAVSTATE_AUTOCLOSE;

			if (WavClose(hWav) != 0)
				fSuccess = TraceFALSE(NULL);
			else
				hWav = NULL; // handle no longer valid
		}
	}

#ifdef AVTSM
	// shut down time scale modification engine if necessary
	//
	if (fSuccess && lpWav->hTsm != NULL)
	{
		if (TsmTerm(lpWav->hTsm) != 0)
			fSuccess = TraceFALSE(NULL);
		else
			lpWav->hTsm = NULL;
	}
#endif

	return fSuccess ? 0 : -1;
}

// WavStopRecord - stop recording
//		<hWav>				(i) handle returned from WavOpen
// return 0 if success
//
static int WavStopRecord(HWAV hWav)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
		lpWav->dwState |= WAVSTATE_AUTOSTOP;

	// close input device if necessary
	//
	if (fSuccess &&
		!(lpWav->dwState & WAVSTATE_STOPRECORD) &&
		lpWav->hWavIn != NULL)
	{
		long msPositionRecord = 0L;

		// set a state flag so we never execute this code recursively
		//
		lpWav->dwState |= WAVSTATE_STOPRECORD;

		// get current record position
		//
		if ((msPositionRecord = WavInGetPosition(lpWav->hWavIn)) == -1)
		{
			// let's ignore errors here and assume record position is 0;
			//
			msPositionRecord = 0L;
			fSuccess = TraceTRUE(NULL);
		}
#if 1
		TracePrintf_2(NULL, 6,
			TEXT("lpWav->msPositionStop=%ld, msPositionRecord=%ld\n"),
			(long) lpWav->msPositionStop,
			(long) msPositionRecord);
#endif
		// clear wav handle array entry
		//
		if (fSuccess)
		{
			int idDev;

			if ((idDev = WavInGetId(lpWav->hWavIn)) < HWAVIN_MIN ||
				idDev >= HWAVIN_MAX)
				TraceFALSE(NULL);

			else
				ahWavInCurr[idDev + HWAVIN_OFFSET] = NULL;
		}

		// close input device
		//
		if (WavInClose(lpWav->hWavIn, 0) != 0)
			fSuccess = TraceFALSE(NULL);

		else if ((lpWav->hWavIn = NULL), FALSE)
			fSuccess = TraceFALSE(NULL);

		// destroy the notification callback window
		//
		else if (WavNotifyDestroy(lpWav) != 0)
			fSuccess = TraceFALSE(NULL);

		// move read/write pointer to new stop position
		//
		else if (WavSetPosition(hWav, min(WavGetLength(hWav),
			lpWav->msPositionStop + msPositionRecord)) == -1)
			fSuccess = TraceFALSE(NULL);

		// close acm conversion engine
		//
		else if (AcmConvertTerm(lpWav->hAcm) != 0)
			fSuccess = TraceFALSE(NULL);

		// truncate file if max file size exceeded
		//
		else if (lpWav->msMaxSize > 0 &&
			WavGetLength(hWav) > lpWav->msMaxSize &&
			WavSetLength(hWav, lpWav->msMaxSize) < 0)
			fSuccess = TraceFALSE(NULL);

		// clear state flags
		//
		lpWav->dwState &= ~WAVSTATE_STOPRECORD;

		// notify user that record is stopped if necessary
		//
		if (lpWav->lpfnRecordStopped != NULL)
		{
			(*lpWav->lpfnRecordStopped)(hWav, lpWav->dwUserRecordStopped, 0);
			lpWav->lpfnRecordStopped = NULL;
			lpWav->dwUserRecordStopped = 0;
		}

		// close wav file if specified
		//
		if (lpWav->dwState & WAVSTATE_AUTOCLOSE)
		{
			lpWav->dwState &= ~WAVSTATE_AUTOCLOSE;

			if (WavClose(hWav) != 0)
				fSuccess = TraceFALSE(NULL);
			else
				hWav = NULL; // handle no longer valid
		}
	}

	return fSuccess ? 0 : -1;
}

// WavStopOutputDevice - stop specified output device
//		<idDev>				(i) wav output device id
//			-1					use any suitable output device
//		<dwFlags>			(i) control flags
//			WAV_NOSTOP			if device already playing, don't stop it
// return 0 if success
//
static int WavStopOutputDevice(int idDev, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;

	// stop output device (unless WAV_NOSTOP flag set or device not open)
	//
	if (!(dwFlags & WAV_NOSTOP) && WavOutDeviceIsOpen(idDev))
	{
		HWAV hWavCurr;

		// stop device using WavStopPlay if WavPlay was used
		//
		if ((hWavCurr = WavGetOutputHandle(idDev)) != NULL &&
			WavStopPlay(hWavCurr) != 0)
			fSuccess = TraceFALSE(NULL);
		
		// otherwise stop device using sndPlaySound
		//
		else if (!sndPlaySound(NULL, 0))
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// WavStopInputDevice - stop specified input device
//		<idDev>				(i) wav input device id
//			-1					use any suitable input device
//		<dwFlags>			(i) control flags
//			WAV_NOSTOP			if device already recording, don't stop it
// return 0 if success
//
static int WavStopInputDevice(int idDev, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;

	// stop input device (unless WAV_NOSTOP flag set or device not open)
	//
	if (!(dwFlags & WAV_NOSTOP) && WavInDeviceIsOpen(idDev))
	{
		HWAV hWavCurr;

		// stop device using WavStopRecord if WavRecord was used
		//
		if ((hWavCurr = WavGetInputHandle(idDev)) != NULL &&
			WavStopRecord(hWavCurr) != 0)
			fSuccess = TraceFALSE(NULL);
		
		// otherwise stop device using sndPlaySound
		//
		else if (!sndPlaySound(NULL, 0))
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// WavGetOutputHandle - get wav handle being played on specified device 
//		<idDev>				(i) wav output device id
// return wav handle (NULL if error or if output device not in use)
//
static HWAV WavGetOutputHandle(int idDev)
{
	BOOL fSuccess = TRUE;
	HWAV hWav;

	if (idDev < HWAVOUT_MIN || idDev >= HWAVOUT_MAX)
		fSuccess = TraceFALSE(NULL);

	else
		hWav = ahWavOutCurr[idDev + HWAVOUT_OFFSET];

	return fSuccess ? hWav : NULL;
}

// WavGetInputHandle - get wav handle being recorded on specified device 
//		<idDev>				(i) wav input device id
// return wav handle (NULL if error or if input device not in use)
//
static HWAV WavGetInputHandle(int idDev)
{
	BOOL fSuccess = TRUE;
	HWAV hWav;

	if (idDev < HWAVIN_MIN || idDev >= HWAVIN_MAX)
		fSuccess = TraceFALSE(NULL);

	else
		hWav = ahWavInCurr[idDev + HWAVIN_OFFSET];

	return fSuccess ? hWav : NULL;
}

// WavPlayNextChunk - fill next chunk and submit it to the output device
//		<hWav>				(i) handle returned from WavOpen
// return 0 if success
//
static int WavPlayNextChunk(HWAV hWav)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	LPVOID lpBuf = NULL;
	long sizBuf;
	long lBytesRead = 0;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// calculate the size of output chunk
	//

    //
    // we have to verify if lpWav is a valid pointer
    //

    else if ((sizBuf = WavCalcChunkSize(lpWav->lpwfx[FORMATPLAY],
		lpWav->msPlayChunkSize, TRUE)) <= 0)
	{
		fSuccess = TraceFALSE(NULL);
	}

#ifdef TELOUT // $FIXUP - need to work on this
	// special case - if we are using the telephone to play audio
	// from a file that already resides on the server, just pass
	// the file handle to TelOutPlay rather than a buffer
	//
	else if (WavOutGetId(lpWav->hWavOut) == TELOUT_DEVICEID &&
		(lpWav->dwFlags & WAV_TELRFILE))
	{
		long hrfile;
		long lSize;
		long lPos;
		
		// retrieve handle to remote file from i/o procedure
		//
		if ((hrfile = (long)
			WavSendMessage(hWav, MMIOM_GETINFO, 0, 0)) == (long) -1)
			fSuccess = TraceFALSE(NULL);

		// retrieve size of remote file from i/o procedure
		//
		else if ((lSize = (long)
			WavSendMessage(hWav, MMIOM_GETINFO, 1, 0)) == (long) -1)
			fSuccess = TraceFALSE(NULL);

		// get current file position
		//
		else if ((lPos = mmioSeek(lpWav->hmmio, 0, SEEK_CUR)) == -1)
			fSuccess = TraceFALSE(NULL);

		// force the remote file pointer to be at that position
		//
		else if (WavOutGetState(lpWav->hWavOut) == WAVOUT_STOPPED)
		{
			long lPosActual;
			
			if ((lPosActual = mmioSendMessage(lpWav->hmmio,
				MMIOM_SEEK, lPos, SEEK_SET)) != lPos)
			{
				fSuccess = TraceTRUE(NULL); // not an error
			}
		}

		// loop until we read some data or we know we are finished
		//
		while (fSuccess && lBytesRead == 0)
		{
			// calculate how many bytes would be read
			//
			lBytesRead = max(0, min(sizBuf, lSize - lPos));

			TracePrintf_4(NULL, 5,
				TEXT("lBytesRead(%ld) = max(0, min(sizBuf(%ld), lSize(%ld) - lPos(%ld)));\n"),
				(long) lBytesRead,
				(long) sizBuf,
				(long) lSize,
				(long) lPos);

			// advance the file position, skipping over the (virtual) chunk
			//
			if (lBytesRead > 0 &&
				mmioSeek(lpWav->hmmio, lBytesRead, SEEK_CUR) == -1)
				fSuccess = TraceFALSE(NULL);

			// submit the (virtual) chunk to the output device for playback
			//
			else if (lBytesRead > 0 &&
				TelOutPlay((HTELOUT) lpWav->hWavOut,
				lpBuf, lBytesRead, hrfile) != 0)
				fSuccess = TraceFALSE(NULL);

			// if no more wav data to play,
			//
			else if (lBytesRead == 0)
			{
				// if WAV_AUTOSTOP flag set, we are finished
				//
				if (lpWav->dwState & WAVSTATE_AUTOSTOP)
				{
					// if output device is idle, then close output device
					//
					if (lpWav->hWavOut != NULL &&
						WavOutGetState(lpWav->hWavOut) == WAVOUT_STOPPED &&
						WavStopPlay(hWav) != 0)
					{
						fSuccess = TraceFALSE(NULL);
					}

					break;
				}

				// if not finished, yield and then try to read again
				//
				else
				{
					MSG msg;

					if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
					{
		 				TranslateMessage(&msg);
		 				DispatchMessage(&msg);
					}
					else
						WaitMessage();
				}
			}
		}

		return fSuccess ? 0 : -1;
	}
#endif

	else if ((lpBuf = (LPVOID) MemAlloc(NULL, sizBuf, 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// loop until we read some data or we know we are finished
	//
	while (fSuccess && lBytesRead == 0)
	{
		// fill chunk with wav data
		//
#ifdef AVTSM
		if ((lBytesRead = WavReadFormatSpeed(hWav, lpBuf, sizBuf)) < 0)
#else
		if ((lBytesRead = WavReadFormatPlay(hWav, lpBuf, sizBuf)) < 0)
#endif
			fSuccess = TraceFALSE(NULL);

		// submit the chunk to the output device for playback
		//
		else if (lBytesRead > 0 &&
			WavOutPlay(lpWav->hWavOut, lpBuf, lBytesRead) != 0)
		{
			fSuccess = TraceFALSE(NULL);
		}

		// if no more wav data to play,
		//
		else if (lBytesRead == 0)
		{
			// if WAV_AUTOSTOP flag set, we are finished
			//
			if (lpWav->dwState & WAVSTATE_AUTOSTOP)
			{
				// if output device is idle, then close output device
				//
				if (lpWav->hWavOut != NULL &&
					WavOutGetState(lpWav->hWavOut) == WAVOUT_STOPPED &&
					WavStopPlay(hWav) != 0)
				{
					fSuccess = TraceFALSE(NULL);
				}

				break;
			}

			// if not finished, yield and then try to read again
			//
			else
			{
				MSG msg;

				if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
				{
		 			TranslateMessage(&msg);
		 			DispatchMessage(&msg);
				}
				else
					WaitMessage();
			}
		}
	}
	
	// free buffer if it was not sent to output device
	//
	if (!fSuccess || lBytesRead == 0)
	{
		if (lpBuf != NULL && (lpBuf = MemFree(NULL, lpBuf)) != NULL)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// WavRecordNextChunk - submit next chunk to the input device
//		<hWav>				(i) handle returned from WavOpen
// return 0 if success
//
static int WavRecordNextChunk(HWAV hWav)
{
	BOOL fSuccess = TRUE;
    //
    // We have to initialize local variable
    //
	LPWAV lpWav = NULL;
	LPVOID lpBuf = NULL;
	long sizBuf;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);
    else
    {
        //
        // we should make sure lpWas is not NULL
        //

	// calculate the size of input chunk
	//
	if ((sizBuf = WavCalcChunkSize(lpWav->lpwfx[FORMATRECORD],
		lpWav->msRecordChunkSize, FALSE)) <= 0)
	{
		fSuccess = TraceFALSE(NULL);
	}

#ifdef TELOUT // $FIXUP - need to work on this
	// special case - if we are using the telephone to record audio
	// to a file that already resides on the server, just pass
	// the file handle to TelOutRecord rather than a buffer
	//
	else if (WavInGetId(lpWav->hWavIn) == TELIN_DEVICEID &&
		(lpWav->dwFlags & WAV_TELRFILE))
	{
		long hrfile;
		
		// retrieve handle to remote file from i/o procedure
		//
		if ((hrfile = (long)
			WavSendMessage(hWav, MMIOM_GETINFO, 0, 0)) == (long) -1)
			fSuccess = TraceFALSE(NULL);

		// submit the (virtual) chunk to the output device for playback
		//
		else if (TelInRecord((HTELIN) lpWav->hWavIn,
			lpBuf, sizBuf, hrfile) != 0)
			fSuccess = TraceFALSE(NULL);

		return fSuccess ? 0 : -1;
	}
#endif

	else if ((lpBuf = (LPVOID) MemAlloc(NULL, sizBuf, 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// submit the chunk to the input device for recording
	//
	else if (WavInRecord(lpWav->hWavIn, lpBuf, sizBuf) != 0)
	{
		fSuccess = TraceFALSE(NULL);
	}

    }

	// free buffer if it was not sent to input device
	//
	if (!fSuccess)
	{
		if (lpBuf != NULL && (lpBuf = MemFree(NULL, lpBuf)) != NULL)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

static int WavNotifyCreate(LPWAV lpWav)
{
	BOOL fSuccess = TRUE;
	WNDCLASS wc;

#ifdef MULTITHREAD
	// handle WAV_MULTITHREAD flag
	//
	if (fSuccess && (lpWav->dwFlags & WAV_MULTITHREAD))
	{
		DWORD dwRet;

		// we need to know when callback thread begins execution
		//
		if ((lpWav->hEventThreadCallbackStarted = CreateEvent(
			NULL, FALSE, FALSE, NULL)) == NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}

		// create the callback thread
		//
		else if ((lpWav->hThreadCallback = CreateThread(
			NULL,
			0,
			WavCallbackThread,
			(LPVOID) lpWav,
			0,
			&lpWav->dwThreadId)) == NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}

		// wait for the callback thread to begin execution
		//
		else if ((dwRet = WaitForSingleObject(
			lpWav->hEventThreadCallbackStarted, 10000)) != WAIT_OBJECT_0)
		{
			fSuccess = TraceFALSE(NULL);
		}

		// clean up
		//
		if (lpWav->hEventThreadCallbackStarted != NULL)
		{
			if (!CloseHandle(lpWav->hEventThreadCallbackStarted))
				fSuccess = TraceFALSE(NULL);
			else
				lpWav->hEventThreadCallbackStarted = NULL;
		}
	}
	else
#endif
	{
		// register notify class unless it has been already
		//
		if (GetClassInfo(lpWav->hInst, WAVCLASS, &wc) == 0)
		{
			wc.hCursor =		NULL;
			wc.hIcon =			NULL;
			wc.lpszMenuName =	NULL;
			wc.hInstance =		lpWav->hInst;
			wc.lpszClassName =	WAVCLASS;
			wc.hbrBackground =	NULL;
			wc.lpfnWndProc =	WavNotify;
			wc.style =			0L;
			wc.cbWndExtra =		sizeof(lpWav);
			wc.cbClsExtra =		0;

			if (!RegisterClass(&wc))
				fSuccess = TraceFALSE(NULL);
		}

		// create the notify window
		//
		if (fSuccess && lpWav->hwndNotify == NULL &&
			(lpWav->hwndNotify = CreateWindowEx(
			0L,
			WAVCLASS,
			NULL,
			0L,
			0, 0, 0, 0,
			NULL,
			NULL,
			lpWav->hInst,
			lpWav)) == NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}
	}

	return fSuccess ? 0 : -1;
}

static int WavNotifyDestroy(LPWAV lpWav)
{
	BOOL fSuccess = TRUE;

	// destroy notify window
	//
	if (lpWav->hwndNotify != NULL &&
		!DestroyWindow(lpWav->hwndNotify))
	{	
		fSuccess = TraceFALSE(NULL);
	}

	else
		lpWav->hwndNotify = NULL;

#ifdef MULTITHREAD
	if (lpWav->hThreadCallback != NULL)
	{
		if (!CloseHandle(lpWav->hThreadCallback))
			fSuccess = TraceFALSE(NULL);
		else
			lpWav->hThreadCallback = NULL;
	}
#endif

	return fSuccess ? 0 : -1;
}

#ifdef MULTITHREAD
DWORD WINAPI WavCallbackThread(LPVOID lpvThreadParameter)
{
	BOOL fSuccess = TRUE;
	MSG msg;
	LPWAV lpWav = (LPWAV) lpvThreadParameter;

	// initialize COM
	//
	if (lpWav->dwFlags & WAV_COINITIALIZE)
	{
		if ((lpWav->hrCoInitialize = CoInitialize(NULL)) != S_OK &&
			lpWav->hrCoInitialize != S_FALSE)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("CoInitialize failed (%08X)\n"),
				(unsigned long) lpWav->hrCoInitialize);
		}
	}

	// make sure message queue is created before calling SetEvent
	//
	PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);

	// notify main thread that callback thread has begun execution
	//
	if (!SetEvent(lpWav->hEventThreadCallbackStarted))
	{
		fSuccess = TraceFALSE(NULL);
	}

	while (fSuccess && GetMessage(&msg, NULL, 0, 0))
	{
		WavNotify((HWND) lpWav, msg.message, msg.wParam, msg.lParam);

		// exit thread when when have processed last expected message
		//
		if (msg.message == WM_WAVOUT_CLOSE || msg.message == WM_WAVIN_CLOSE)
		{
			// notify main thread that we are terminating
			//
			if (lpWav->hEventStopped != NULL &&
				!SetEvent(lpWav->hEventStopped))
			{
				fSuccess = TraceFALSE(NULL);
			}

			break;
		}
	}

	// uninitialize COM
	//
	if (lpWav->dwFlags & WAV_COINITIALIZE)
	{
		if (lpWav->hrCoInitialize == S_OK || lpWav->hrCoInitialize == S_FALSE)
		{
			CoUninitialize();
			lpWav->hrCoInitialize = E_UNEXPECTED;
		}
	}

	return 0;
}
#endif

// WavNotify - window procedure for wav notify
//
LRESULT DLLEXPORT CALLBACK WavNotify(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	BOOL fSuccess = TRUE;
	LRESULT lResult;
	LPWAV lpWav;
	
#ifdef MULTITHREAD
	if (!IsWindow(hwnd))
		lpWav = (LPWAV) hwnd;
	else
#endif
	// retrieve lpWav from window extra bytes
	//
	lpWav = (LPWAV) GetWindowLongPtr(hwnd, 0);

	switch (msg)
	{
		case WM_NCCREATE:
		{
			LPCREATESTRUCT lpcs = (LPCREATESTRUCT) lParam;
			LPWAV lpWav = (LPWAV) lpcs->lpCreateParams;

			// store lpWav in window extra bytes
			//
			SetWindowLongPtr(hwnd, 0, (LONG_PTR) lpWav);

			lResult = DefWindowProc(hwnd, msg, wParam, lParam);
		}
			break;

		case WM_WAVOUT_OPEN:
		{
		 	TracePrintf_0(NULL, 5,
		 		TEXT("WM_WAVOUT_OPEN\n"));

			lResult = 0L;

#ifdef MULTITHREAD
			if ((HANDLE) wParam != NULL)
				SetEventMessageProcessed(lpWav, (HANDLE) wParam);
#endif
		}
			break;

		case WM_WAVOUT_CLOSE:
		{
		 	TracePrintf_0(NULL, 5,
		 		TEXT("WM_WAVOUT_CLOSE\n"));

			// handle no longer valid
			//
			lpWav->hWavOut = NULL;

			lResult = 0L;

#ifdef MULTITHREAD
			if ((HANDLE) wParam != NULL)
				SetEventMessageProcessed(lpWav, (HANDLE) wParam);
#endif
		}
			break;

		case WM_WAVOUT_PLAYDONE:
		{
			LPPLAYDONE lpplaydone = (LPPLAYDONE) lParam;

		 	TracePrintf_0(NULL, 5,
		 		TEXT("WM_WAVOUT_PLAYDONE\n"));

			if (lpplaydone == NULL)
				fSuccess = TraceFALSE(NULL);

			else if (lpplaydone->lpBuf != NULL &&
				(lpplaydone->lpBuf = MemFree(NULL, lpplaydone->lpBuf)) != NULL)
				fSuccess = TraceFALSE(NULL);

			else switch (WavOutGetState(lpWav->hWavOut))
			{
				case WAVOUT_STOPPED:
					// make sure to close output device when play complete
					//
					if (lpWav->dwState & WAVSTATE_AUTOSTOP)
					{
#ifdef MULTITHREAD
						if (lpWav->dwFlags & WAV_MULTITHREAD)
							PostThreadMessage(lpWav->dwThreadId, WM_WAVOUT_STOPPLAY, 0, 0);
						else
#endif
							PostMessage(lpWav->hwndNotify, WM_WAVOUT_STOPPLAY, 0, 0);
						break;
					}
					// else fall through

				case WAVOUT_PLAYING:
					// load output device queue with next chunk to play
					//
					if (WavPlayNextChunk(WavGetHandle(lpWav)) != 0)
						fSuccess = TraceFALSE(NULL);
					break;

				default:
					break;
			}

			lResult = 0L;

#ifdef MULTITHREAD
			if ((HANDLE) wParam != NULL)
				SetEventMessageProcessed(lpWav, (HANDLE) wParam);
#endif
		}
			break;

		case WM_WAVOUT_STOPPLAY:
		{
		 	TracePrintf_0(NULL, 5,
		 		TEXT("WM_WAVOUT_STOPPLAY\n"));

			if (WavStopPlay(WavGetHandle(lpWav)) != 0)
				fSuccess = TraceFALSE(NULL);

			lResult = 0L;
		}
			break;

		case WM_WAVIN_OPEN:
		{
		 	TracePrintf_0(NULL, 5,
		 		TEXT("WM_WAVIN_OPEN\n"));

			lResult = 0L;

#ifdef MULTITHREAD
			if ((HANDLE) wParam != NULL)
				SetEventMessageProcessed(lpWav, (HANDLE) wParam);
#endif
		}
			break;

		case WM_WAVIN_CLOSE:
		{
		 	TracePrintf_0(NULL, 5,
		 		TEXT("WM_WAVIN_CLOSE\n"));

			// handle no longer valid
			//
			lpWav->hWavIn = NULL;

			lResult = 0L;

#ifdef MULTITHREAD
			if ((HANDLE) wParam != NULL)
				SetEventMessageProcessed(lpWav, (HANDLE) wParam);
#endif
		}
			break;

		case WM_WAVIN_RECORDDONE:
		{
			LPRECORDDONE lprecorddone = (LPRECORDDONE) lParam;
			long lBytesWritten;

		 	TracePrintf_0(NULL, 5,
		 		TEXT("WM_WAVIN_RECORDDONE\n"));

			if (lprecorddone == NULL)
				fSuccess = TraceFALSE(NULL);

			// write wav data from chunk to file
			//
			else if (lprecorddone->lpBuf != NULL &&
				lprecorddone->lBytesRecorded > 0 &&
				(lBytesWritten = WavWriteFormatRecord(WavGetHandle(lpWav),
				lprecorddone->lpBuf, lprecorddone->lBytesRecorded)) < 0)
			{
				fSuccess = TraceFALSE(NULL);
			}

			// free the record buffer, allocated in WavRecordNextChunk()
			//

            //
            // we have to verify if lprecorddone is a valid pointer
            //

			if (lprecorddone != NULL && lprecorddone->lpBuf != NULL &&
				(lprecorddone->lpBuf = MemFree(NULL,
				lprecorddone->lpBuf)) != NULL)
			{
				fSuccess = TraceFALSE(NULL);
			}

			// stop recording if max size exceeded
			//
			else if (lpWav->msMaxSize > 0 &&
				WavGetLength(WavGetHandle(lpWav)) > lpWav->msMaxSize)
			{
#ifdef MULTITHREAD
				if (lpWav->dwFlags & WAV_MULTITHREAD)
					PostThreadMessage(lpWav->dwThreadId, WM_WAVIN_STOPRECORD, 0, 0);
				else
#endif
					PostMessage(lpWav->hwndNotify, WM_WAVIN_STOPRECORD, 0, 0);
			}

			else switch (WavInGetState(lpWav->hWavIn))
			{
				case WAVIN_STOPPED:
					// make sure to close input device when record complete
					//
					if (lpWav->dwState & WAVSTATE_AUTOSTOP)
					{
#ifdef MULTITHREAD
						if (lpWav->dwFlags & WAV_MULTITHREAD)
							PostThreadMessage(lpWav->dwThreadId, WM_WAVIN_STOPRECORD, 0, 0);
						else
#endif
							PostMessage(lpWav->hwndNotify, WM_WAVIN_STOPRECORD, 0, 0);
						break;
					}
					// else fall through

				case WAVIN_RECORDING:
					// load input device queue with next chunk to record
					//
					if (WavRecordNextChunk(WavGetHandle(lpWav)) != 0)
						fSuccess = TraceFALSE(NULL);
					break;

				default:
					break;
			}

			lResult = 0L;

#ifdef MULTITHREAD
			if ((HANDLE) wParam != NULL)
				SetEventMessageProcessed(lpWav, (HANDLE) wParam);
#endif
		}
			break;

		case WM_WAVIN_STOPRECORD:
		{
		 	TracePrintf_0(NULL, 5,
		 		TEXT("WM_WAVIN_STOPRECORD\n"));

			if (WavStopRecord(WavGetHandle(lpWav)) != 0)
				fSuccess = TraceFALSE(NULL);

			lResult = 0L;
		}
			break;

		default:
			lResult = DefWindowProc(hwnd, msg, wParam, lParam);
			break;
	}
	
	return lResult;
}

// WavCalcPositionStop - calculate new stop position if stopped
//		<hWav>				(i) handle returned from WavOpen
//		<cbPosition>		(i) new stop position, in bytes
// return 0 if success
//
static int WavCalcPositionStop(HWAV hWav, long cbPosition)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// recalculate stop position only if currently stopped
	// (if playing or recording, defer recalc until stop occurs)
	//
#if 0
	else if (WavGetState(hWav) == WAV_STOPPED)
#else
	else if (lpWav->hWavOut == NULL && lpWav->hWavIn == NULL)
#endif
	{
		// convert byte position to milleseconds
		// save the new stop position
		//
		lpWav->msPositionStop = WavFormatBytesToMilleseconds(
			lpWav->lpwfx[FORMATFILE], (DWORD) cbPosition);
#if 1
		TracePrintf_2(NULL, 6,
			TEXT("lpWav->msPositionStop=%ld, cbPosition=%ld\n"),
			(long) lpWav->msPositionStop,
			(long) cbPosition);
#endif
	}

	return fSuccess ? 0 : -1;
}

// WavSeekTraceBefore - debug trace output before the seek
//		<lpWav>				(i) pointer to WAV struct
//		<lOffset>			(i) bytes to move pointer
//		<nOrigin>			(i) position to move from
// return 0 if success
//
static int WavSeekTraceBefore(LPWAV lpWav, long lOffset, int nOrigin)
{
	BOOL fSuccess = TRUE;

	TracePrintf_2(NULL, 6,
		TEXT("WavSeek(..., lOffset=%ld, nOrigin=%d)\n"),
		(long) lOffset,
		(int) nOrigin);

	TracePrintf_4(NULL, 6,
		TEXT("Before: lpWav->lDataOffset=%ld, lpWav->lDataPos=%ld, lpWav->cbData=%ld, lpWav->msPositionStop=%ld\n"),
		(long) lpWav->lDataOffset,
		(long) lpWav->lDataPos,
		(long) lpWav->cbData,
		(long) lpWav->msPositionStop);

	return fSuccess ? 0 : -1;
}

// WavSeekTraceAfter - debug trace output after the seek
//		<lpWav>				(i) pointer to WAV struct
//		<lPos>				(i) position returned from mmioSeek
//		<lOffset>			(i) bytes to move pointer
//		<nOrigin>			(i) position to move from
// return 0 if success
//
static int WavSeekTraceAfter(LPWAV lpWav, long lPos, long lOffset, int nOrigin)
{
	BOOL fSuccess = TRUE;

	TracePrintf_3(NULL, 6,
		TEXT("%ld = mmioSeek(..., lOffset=%ld, nOrigin=%d)\n"),
		(long) lPos,
		(long) lOffset,
		(int) nOrigin);

	TracePrintf_4(NULL, 6,
		TEXT("After: lpWav->lDataOffset=%ld, lpWav->lDataPos=%ld, lpWav->cbData=%ld, lpWav->msPositionStop=%ld\n"),
		(long) lpWav->lDataOffset,
		(long) lpWav->lDataPos,
		(long) lpWav->cbData,
		(long) lpWav->msPositionStop);

	return fSuccess ? 0 : -1;
}

// WavGetPtr - verify that wav handle is valid,
//		<hWav>				(i) handle returned from WavInit
// return corresponding wav pointer (NULL if error)
//
static LPWAV WavGetPtr(HWAV hWav)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;

	if ((lpWav = (LPWAV) hWav) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpWav, sizeof(WAV)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the wav handle
	//
	else if (lpWav->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpWav : NULL;
}

// WavGetHandle - verify that wav pointer is valid,
//		<lpWav>				(i) pointer to WAV struct
// return corresponding wav handle (NULL if error)
//
static HWAV WavGetHandle(LPWAV lpWav)
{
	BOOL fSuccess = TRUE;
	HWAV hWav;

	if ((hWav = (HWAV) lpWav) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hWav : NULL;
}

// WavInitGetPtr - verify that wavinit handle is valid,
//		<hWavInit>				(i) handle returned from WavInitInit
// return corresponding wavinit pointer (NULL if error)
//
static LPWAVINIT WavInitGetPtr(HWAVINIT hWavInit)
{
	BOOL fSuccess = TRUE;
	LPWAVINIT lpWavInit;

	if ((lpWavInit = (LPWAVINIT) hWavInit) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpWavInit, sizeof(WAVINIT)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the wavinit handle
	//
	else if (lpWavInit->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpWavInit : NULL;
}

// WavInitGetHandle - verify that wavinit pointer is valid,
//		<lpWavInit>				(i) pointer to WAVINIT struct
// return corresponding wavinit handle (NULL if error)
//
static HWAVINIT WavInitGetHandle(LPWAVINIT lpWavInit)
{
	BOOL fSuccess = TRUE;
	HWAVINIT hWavInit;

	if ((hWavInit = (HWAVINIT) lpWavInit) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hWavInit : NULL;
}

#ifdef MULTITHREAD
static int SetEventMessageProcessed(LPWAV lpWav, HANDLE hEventMessageProcessed)
{
	BOOL fSuccess = TRUE;

	if (lpWav == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (!(lpWav->dwFlags & WAV_MULTITHREAD))
		; // nothing to do

	else if (hEventMessageProcessed == NULL)
		fSuccess = TraceFALSE(NULL);

	// notify SendMessageEx that message has been processed
	//
	else if (!SetEvent(hEventMessageProcessed))
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}
#endif


// WavTempStop - stop playback or recording if necessary, save prev state
//		<hWav>				(i) handle returned from WavInit
//		<lpwStatePrev>		(o) return previous state here
//		<lpidDevPrev>		(o) return device id here
// return 0 if success
//
static int WavTempStop(HWAV hWav, LPWORD lpwStatePrev, LPINT lpidDevPrev)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;
	WORD wStatePrev;

    //
    // We have to initialize the local variable
    //
	int idDevPrev = 0;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// make sure we not playing or recording
	// $FIXUP - we need to make sure that WAV_PLAYSYNC and
	// WAV_AUTOCLOSE flags are ignored during this stop
	//
	else switch ((wStatePrev = WavGetState(hWav)))
	{
		case WAV_PLAYING:
			if ((idDevPrev = WavOutGetId(lpWav->hWavOut)) < -1)
				fSuccess = TraceFALSE(NULL);

			else if (WavStop(hWav) != 0)
				fSuccess = TraceFALSE(NULL);

			break;

		case WAV_RECORDING:
			if ((idDevPrev = WavInGetId(lpWav->hWavIn)) < -1)
				fSuccess = TraceFALSE(NULL);

			else if (WavStop(hWav) != 0)
				fSuccess = TraceFALSE(NULL);
			break;

		default:
			break;
	}

	if (fSuccess)
	{
		*lpwStatePrev = wStatePrev;
		*lpidDevPrev = idDevPrev;
	}

	return fSuccess ? 0 : -1;
}

// WavTempResume - resume playback or recording if necessary, using prev state
//		<hWav>				(i) handle returned from WavInit
//		<wStatePrev>		(i) previous state returned from WavTempStop
//		<idDevPrev>			(i) device id returned from WavTempStop
// return 0 if success
//
static int WavTempResume(HWAV hWav, WORD wStatePrev, int idDevPrev)
{
	BOOL fSuccess = TRUE;
	LPWAV lpWav;

	if ((lpWav = WavGetPtr(hWav)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// resume playback or recording if necessary
	//
	else switch (wStatePrev)
	{
		case WAV_PLAYING:
			if (WavPlay(hWav, idDevPrev, lpWav->dwFlagsPlay) != 0)
				fSuccess = TraceFALSE(NULL);
			break;

		case WAV_RECORDING:
			if (WavRecord(hWav, idDevPrev, lpWav->dwFlagsRecord) != 0)
				fSuccess = TraceFALSE(NULL);
			break;

		default:
			break;
	}

	return fSuccess ? 0 : -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\avwav\vox.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	vox.c - vox file format (OKI ADPCM) functions
////

#include "winlocal.h"

#include "vox.h"
#include "wav.h"
#include "mem.h"
#include "mmio.h"
#include "sys.h"
#include "trace.h"

////
//	private definitions
////

// step size type
//
typedef __int16 ss_type;

// vox engine control structure
//
typedef struct VOX
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	DWORD dwFlags;
	ss_type ssDecoder;		// decoder step size
	ss_type ssEncoder;		// encoder step size
	PCM16 iVoxDecode;		// previous decoded sample
} VOX, FAR *LPVOX;

// macros to convert vox 12 bit samples to/from other size samples
//
#define _Vox12To16(intx) ((PCM16) ((PCM16) (intx) << 4))
#define _Vox12To8(intx) ((BYTE) (((PCM16) (intx) >> 4) + 128))
#define _Vox8To12(bytex) (((PCM16) (bytex) - 128) << 4)
#define _Vox16To12(intx) ((PCM16) (intx) >> 4)

// helper functions
//
static LPVOX VoxGetPtr(HVOX hVox);
static HVOX VoxGetHandle(LPVOX lpVox);
static void ReverseIndexTableInit(void);
static PCM16 DecodeSample(BYTE bVoxEncode, ss_type FAR *lpss, PCM16 iVoxDecodePrev);
static BYTE EncodeSample(__int16 iDelta, ss_type FAR *lpss);

static LRESULT VoxIOOpen(LPMMIOINFO lpmmioinfo, LPTSTR lpszFileName);
static LRESULT VoxIOClose(LPMMIOINFO lpmmioinfo, UINT uFlags);
static LRESULT VoxIORead(LPMMIOINFO lpmmioinfo, HPSTR pch, LONG cch);
static LRESULT VoxIOWrite(LPMMIOINFO lpmmioinfo, const HPSTR pch, LONG cch, BOOL fFlush);
static LRESULT VoxIOSeek(LPMMIOINFO lpmmioinfo, LONG lOffset, int iOrigin);
static LRESULT VoxIORename(LPMMIOINFO lpmmioinfo, LPCTSTR lpszFileName, LPCTSTR lpszNewFileName);
static LRESULT VoxIOGetInfo(LPMMIOINFO lpmmioinfo, int iInfo);
static LRESULT VoxIOChSize(LPMMIOINFO lpmmioinfo, long lSize);

////
//	public functions
////

// VoxInit - initialize vox engine
//		<dwVersion>			(i) must be VOX_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<dwFlags>			(i) reserved; must be 0
// return handle (NULL if error)
//
HVOX DLLEXPORT WINAPI VoxInit(DWORD dwVersion, HINSTANCE hInst, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPVOX lpVox = NULL;

	if (dwVersion != VOX_VERSION)
		fSuccess = TraceFALSE(NULL);

	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpVox = (LPVOX) MemAlloc(NULL, sizeof(VOX), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		// initialize engine structure
		//
		lpVox->dwVersion = dwVersion;
		lpVox->hInst = hInst;
		lpVox->hTask = GetCurrentTask();
		lpVox->dwFlags = dwFlags;

		ReverseIndexTableInit();

		if (VoxReset(VoxGetHandle(lpVox)) != 0)
			fSuccess = TraceFALSE(NULL);
	}

	if (!fSuccess)
	{
		VoxTerm(VoxGetHandle(lpVox));
		lpVox = NULL;
	}

	return fSuccess ? VoxGetHandle(lpVox) : NULL;
}

// VoxTerm - shut down vox engine
//		<hVox>				(i) handle returned from VoxInit
// return 0 if success
//
int DLLEXPORT WINAPI VoxTerm(HVOX hVox)
{
	BOOL fSuccess = TRUE;
	LPVOX lpVox;
	
	if ((lpVox = VoxGetPtr(hVox)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpVox = MemFree(NULL, lpVox)) != NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

// VoxReset - reset vox engine
//		<hVox>				(i) handle returned from VoxInit
// return 0 if success
//
int DLLEXPORT WINAPI VoxReset(HVOX hVox)
{
	BOOL fSuccess = TRUE;
	LPVOX lpVox;
	
	if ((lpVox = VoxGetPtr(hVox)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lpVox->ssDecoder = 16;
		lpVox->ssEncoder = 16;
		lpVox->iVoxDecode = 0;
	}

	return fSuccess ? 0 : -1;
}

// VoxDecode_16BitMono - decode vox samples
//		<hVox>				(i) handle returned from VoxInit
//		<lpabVox>			(i) array of encoded samples
//		<lpaiPcm>			(o) array of decoded samples
//		<uSamples>			(i) number of samples to decode
// return 0 if success
//
// NOTE: each BYTE in <lpabVox> contains 2 12-bit encoded samples
// in OKI ADPCM Vox format, as described by Dialogic
// Each PCM16 in <lpaiPcm> contains 1 16-bit decoded sample
// in standard PCM format.
//
int DLLEXPORT WINAPI VoxDecode_16BitMono(HVOX hVox, LPBYTE lpabVox, LPPCM16 lpaiPcm, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPVOX lpVox;

	if ((lpVox = VoxGetPtr(hVox)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpaiPcm == NULL || lpabVox == NULL)
		fSuccess = TraceFALSE(NULL);

	// since there are two samples per Vox data byte,
	// we will decode two samples each time through the loop
	//
	else while (uSamples > 1)
	{
		BYTE bData;

		bData = *lpabVox++;

		lpVox->iVoxDecode = DecodeSample((BYTE)
			(0xFF & ((BYTE) (bData >> 4) & (BYTE) 0x0F)),
			&lpVox->ssDecoder, lpVox->iVoxDecode);

		*lpaiPcm++ = _Vox12To16(lpVox->iVoxDecode);

		lpVox->iVoxDecode = DecodeSample((BYTE)
			(0xFF & (bData & (BYTE) 0x0F)),
			&lpVox->ssDecoder, lpVox->iVoxDecode);

		*lpaiPcm++ = _Vox12To16(lpVox->iVoxDecode);

		uSamples -= 2;
	}

	return fSuccess ? 0 : -1;
}

// VoxEncode_16BitMono - encode vox samples
//		<hVox>				(i) handle returned from VoxInit
//		<lpaiPcm>			(i) array of decoded samples
//		<lpabVox>			(o) array of encoded samples
//		<uSamples>			(i) number of samples to encode
// return 0 if success
//
// NOTE: each BYTE in <lpabVox> contains 2 12-bit encoded samples
// in OKI ADPCM Vox format, as described by Dialogic
// Each PCM16 in <lpaiPcm> contains 1 16-bit decoded sample
// in standard PCM format.
//
int DLLEXPORT WINAPI VoxEncode_16BitMono(HVOX hVox, LPPCM16 lpaiPcm, LPBYTE lpabVox, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPVOX lpVox;

	if ((lpVox = VoxGetPtr(hVox)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpaiPcm == NULL || lpabVox == NULL)
		fSuccess = TraceFALSE(NULL);

	// since there are two samples per Vox data byte,
	// we will encode two samples each time through the loop
	//
	else while (uSamples > 1)
	{
		__int16 iDelta;
		PCM16 iVoxDecode;
		BYTE bVoxEncode1;
		BYTE bVoxEncode2;

		iVoxDecode = _Vox16To12(*lpaiPcm++);

		iDelta = iVoxDecode - lpVox->iVoxDecode;
		bVoxEncode1 = EncodeSample(iDelta, &lpVox->ssEncoder);
		lpVox->iVoxDecode = DecodeSample(bVoxEncode1, &lpVox->ssDecoder, lpVox->iVoxDecode);

		iVoxDecode = _Vox16To12(*lpaiPcm++);

		iDelta = iVoxDecode - lpVox->iVoxDecode;
		bVoxEncode2 = EncodeSample(iDelta, &lpVox->ssEncoder);
		lpVox->iVoxDecode = DecodeSample(bVoxEncode2, &lpVox->ssDecoder, lpVox->iVoxDecode);

		*lpabVox++ = (BYTE) (((BYTE) (bVoxEncode1 << 4) & (BYTE) 0xF0) | bVoxEncode2);

		uSamples -= 2;
	}

	return fSuccess ? 0 : -1;
}

// VoxDecode_8BitMono - decode vox samples
//		<hVox>				(i) handle returned from VoxInit
//		<lpabVox>			(i) array of encoded samples
//		<lpabPcm>			(o) array of decoded samples
//		<uSamples>			(i) number of samples to decode
// return 0 if success
//
// NOTE: each BYTE in <lpabVox> contains 2 12-bit encoded samples
// in OKI ADPCM Vox format, as described by Dialogic
// Each PCM8 in <lpabPcm> contains 1 8-bit decoded sample
// in standard PCM format.
//
int DLLEXPORT WINAPI VoxDecode_8BitMono(HVOX hVox, LPBYTE lpabVox, LPPCM8 lpabPcm, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPVOX lpVox;

	if ((lpVox = VoxGetPtr(hVox)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpabPcm == NULL || lpabVox == NULL)
		fSuccess = TraceFALSE(NULL);

	// since there are two samples per Vox data byte,
	// we will decode two samples each time through the loop
	//
	else while (uSamples > 1)
	{
		BYTE bData;

		bData = *lpabVox++;

		lpVox->iVoxDecode = DecodeSample((BYTE)
			(0xFF & ((BYTE) (bData >> 4) & (BYTE) 0x0F)),
			&lpVox->ssDecoder, lpVox->iVoxDecode);

		*lpabPcm++ = _Vox12To8(lpVox->iVoxDecode);

		lpVox->iVoxDecode = DecodeSample((BYTE)
			(0xFF & (bData & (BYTE) 0x0F)),
			&lpVox->ssDecoder, lpVox->iVoxDecode);

		*lpabPcm++ = _Vox12To8(lpVox->iVoxDecode);

		uSamples -= 2;
	}

	return fSuccess ? 0 : -1;
}

// VoxEncode_8BitMono - encode vox samples
//		<hVox>				(i) handle returned from VoxInit
//		<lpabPcm>			(i) array of decoded samples
//		<lpabVox>			(o) array of encoded samples
//		<uSamples>			(i) number of samples to encode
// return 0 if success
//
// NOTE: each BYTE in <lpabVox> contains 2 12-bit encoded samples
// in OKI ADPCM Vox format, as described by Dialogic
// Each PCM8 in <lpabPcm> contains 1 8-bit decoded sample
// in standard PCM format.
//
int DLLEXPORT WINAPI VoxEncode_8BitMono(HVOX hVox, LPPCM8 lpabPcm, LPBYTE lpabVox, UINT uSamples)
{
	BOOL fSuccess = TRUE;
	LPVOX lpVox;

	if ((lpVox = VoxGetPtr(hVox)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpabPcm == NULL || lpabVox == NULL)
		fSuccess = TraceFALSE(NULL);

	// since there are two samples per Vox data byte,
	// we will encode two samples each time through the loop
	//
	else while (uSamples > 1)
	{
		__int16 iDelta;
		PCM16 iVoxDecode;
		BYTE bVoxEncode1;
		BYTE bVoxEncode2;

		iVoxDecode = _Vox8To12(*lpabPcm++);

		iDelta = iVoxDecode - lpVox->iVoxDecode;
		bVoxEncode1 = EncodeSample(iDelta, &lpVox->ssEncoder);
		lpVox->iVoxDecode = DecodeSample(bVoxEncode1, &lpVox->ssDecoder, lpVox->iVoxDecode);

		iVoxDecode = _Vox8To12(*lpabPcm++);

		iDelta = iVoxDecode - lpVox->iVoxDecode;
		bVoxEncode2 = EncodeSample(iDelta, &lpVox->ssEncoder);
		lpVox->iVoxDecode = DecodeSample(bVoxEncode2, &lpVox->ssDecoder, lpVox->iVoxDecode);

		*lpabVox++ = (BYTE) (((BYTE) (bVoxEncode1 << 4) & (BYTE) 0xF0) | bVoxEncode2);

		uSamples -= 2;
	}

	return fSuccess ? 0 : -1;
}

// VoxIOProc - i/o procedure for vox format file data
//		<lpmmioinfo>		(i/o) information about open file
//		<uMessage>			(i) message indicating the requested I/O operation
//		<lParam1>			(i) message specific parameter
//		<lParam2>			(i) message specific parameter
// returns 0 if message not recognized, otherwise message specific value
//
// NOTE: the address of this function should be passed to the WavOpen()
// or mmioInstallIOProc() functions for accessing vox format file data.
//
LRESULT DLLEXPORT CALLBACK VoxIOProc(LPTSTR lpmmioinfo,
	UINT uMessage, LPARAM lParam1, LPARAM lParam2)
{
	BOOL fSuccess = TRUE;
	LRESULT lResult = 0;

	if (lpmmioinfo == NULL)
		fSuccess = TraceFALSE(NULL);

	else switch (uMessage)
	{
		case MMIOM_OPEN:
			lResult = VoxIOOpen((LPMMIOINFO) lpmmioinfo,
				(LPTSTR) lParam1);
			break;

		case MMIOM_CLOSE:
			lResult = VoxIOClose((LPMMIOINFO) lpmmioinfo,
				(UINT) lParam1);
			break;

		case MMIOM_READ:
			lResult = VoxIORead((LPMMIOINFO) lpmmioinfo,
				(HPSTR) lParam1, (LONG) lParam2);
			break;

		case MMIOM_WRITE:
			lResult = VoxIOWrite((LPMMIOINFO) lpmmioinfo,
				(const HPSTR) lParam1, (LONG) lParam2, FALSE);
			break;

		case MMIOM_WRITEFLUSH:
			lResult = VoxIOWrite((LPMMIOINFO) lpmmioinfo,
				(const HPSTR) lParam1, (LONG) lParam2, TRUE);
			break;

		case MMIOM_SEEK:
			lResult = VoxIOSeek((LPMMIOINFO) lpmmioinfo,
				(LONG) lParam1, (int) lParam2);
			break;

		case MMIOM_RENAME:
			lResult = VoxIORename((LPMMIOINFO) lpmmioinfo,
				(LPCTSTR) lParam1, (LPCTSTR) lParam2);
			break;

		case MMIOM_GETINFO:
			lResult = VoxIOGetInfo((LPMMIOINFO) lpmmioinfo,
				(int) lParam1);
			break;

		case MMIOM_CHSIZE:
			lResult = VoxIOChSize((LPMMIOINFO) lpmmioinfo,
				(long) lParam1);
			break;

		default:
			lResult = 0;
			break;
	}

	return lResult;
}

////
//	private functions
////

// VoxGetPtr - verify that vox handle is valid,
//		<hVox>				(i) handle returned from VoxInit
// return corresponding vox pointer (NULL if error)
//
static LPVOX VoxGetPtr(HVOX hVox)
{
	BOOL fSuccess = TRUE;
	LPVOX lpVox;

	if ((lpVox = (LPVOX) hVox) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpVox, sizeof(VOX)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the vox engine handle
	//
	else if (lpVox->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpVox : NULL;
}

// VoxGetHandle - verify that vox pointer is valid,
//		<lpVox>				(i) pointer to VOX structure
// return corresponding vox handle (NULL if error)
//
static HVOX VoxGetHandle(LPVOX lpVox)
{
	BOOL fSuccess = TRUE;
	HVOX hVox;

	if ((hVox = (HVOX) lpVox) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hVox : NULL;
}

////
//	low-level ADPCM stuff
////

static ss_type const ss_table[] =
	{
	16, 17, 19, 21, 23, 25, 28, 31, 34, 37,
	41, 45, 50, 55, 60, 66, 73, 80, 88, 97,
	107, 118, 130, 143, 157, 173, 190, 209, 230, 253,
	279, 307, 337, 371, 408, 449, 494, 544, 598, 658,
	724, 796, 876, 963, 1060, 1166, 1282, 1411, 1552
	};

static __int16 delta_index_table[] =
	{
	-1, -1, -1, -1, +2, +4, +6, +8, -1, -1, -1, -1, +2, +4, +6, +8
	};

////
//	The reverse index table is designed so that given a step size, we
//	can get back out the index that generated it.
////
static BYTE reverse_index_table[1553];

// initialize reverse index table
//
static void ReverseIndexTableInit(void)
{
 	__int16 i;

 	for (i = 0; i < 49; ++i)
 		reverse_index_table[ss_table[i]] = (BYTE) i;
}

#if 0
static ss_type new_ss(ss_type ss, BYTE bVoxEncode);
static ss_type new_ss(ss_type ss, BYTE bVoxEncode)
{
	__int16 index;

	// find out what our old index into the step size table was
	//
	index = reverse_index_table[ss];

	// modify our index based on the present value of the ADPCM nibble
	//
	index += delta_index_table[bVoxEncode];

	// limit ourselves to the maximum size of the table in case of overflow
	//
	index = max(0, min(48, index));

	// and return our new step size out of the table
	//
	return ss_table[index];
}
#else
#define new_ss(ss, bVoxEncode) ss_table[max(0, min(48, \
	reverse_index_table[ss] + delta_index_table[bVoxEncode]))]
#endif

// DECODE - ADPCM to linear
//
static PCM16 DecodeSample(BYTE bVoxEncode, ss_type FAR *lpss, PCM16 iVoxDecodePrev)
{
	__int16 iDelta;
	PCM16 iVoxDecode;
	ss_type ss;

	ss = *lpss;

	// iDelta = (((nibble * 2) + 1) / 8 ) * ss;
	//
	iDelta = ((((bVoxEncode & 0x07) << 1) + 1) * ss ) >> 3;

	if ((bVoxEncode & 0x08) == 0x08)
		iDelta = -iDelta;

	*lpss = new_ss(ss, bVoxEncode);
	iVoxDecode = iVoxDecodePrev + iDelta;

	// limit ourselves to 12 bits of resolution
	//
	if (iVoxDecode > 2047)
		return 2047;
	else if (iVoxDecode < -2048)
		return -2048;
	else
		return iVoxDecode;
}

// ENCODE - linear to ADPCM
//
static BYTE EncodeSample(__int16 iDelta, ss_type FAR *lpss)
{
	BYTE bVoxEncode;
	ss_type ss;
	__int16 iDeltaTmp;

	ss = *lpss;
	iDeltaTmp = iDelta;

	if (iDeltaTmp < 0)
	{
		iDeltaTmp = -iDeltaTmp;
		bVoxEncode = 0x08;
	}
	else
		bVoxEncode = 0;

	if (iDeltaTmp >= ss)
	{
		bVoxEncode |= 0x04;
		iDeltaTmp -= ss;
	}

	if (iDeltaTmp >= (ss >> 1))
	{
		bVoxEncode |= 0x02;
		iDeltaTmp -= (ss >> 1);
	}

	if (iDeltaTmp >= (ss >> 2))
	{
		bVoxEncode |= 0x01;
	}

	*lpss = new_ss(ss, bVoxEncode);

	return (BYTE) (bVoxEncode & (BYTE) 0x0F);

	// format of return nibble is
	//	S W F F
	//	| | | |
	//	| | | +--- 1/4 of delta/step
	//	| | +----- 1/2 of delta/step
	//	| +------- whole part of delta/step
	//	+--------- sign bit
}


////
//	installable file i/o procedures
////

static LRESULT VoxIOOpen(LPMMIOINFO lpmmioinfo, LPTSTR lpszFileName)
{
	BOOL fSuccess = TRUE;
	HMMIO hmmio = NULL;
	MMIOINFO mmioinfo;
	HVOX hVox = NULL;
	HINSTANCE hInst;

 	TracePrintf_1(NULL, 5,
 		TEXT("VoxIOOpen (%s)\n"),
		(LPTSTR) lpszFileName);

	MemSet(&mmioinfo, 0, sizeof(mmioinfo));

	// interpret first value passed as pointer to next i/o procedure in chain
	//
	mmioinfo.pIOProc = (LPMMIOPROC) lpmmioinfo->adwInfo[0];

	// pass along second and third values to next i/o procedure
	//
	mmioinfo.adwInfo[0] = lpmmioinfo->adwInfo[1];
	mmioinfo.adwInfo[1] = lpmmioinfo->adwInfo[2];
	mmioinfo.adwInfo[2] = 0L;

	// get instance handle of current task
	//
	if ((hInst = SysGetTaskInstance(NULL)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((hVox = VoxInit(VOX_VERSION, hInst, 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((hmmio = mmioOpen(lpszFileName, &mmioinfo, lpmmioinfo->dwFlags)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		// save stuff for use in other i/o routines
		//
		lpmmioinfo->adwInfo[0] = (DWORD) (LPVOID) hmmio;
		lpmmioinfo->adwInfo[1] = (DWORD) (LPVOID) hVox;
	}

	// clean up after error
	//
	if (!fSuccess && hVox != NULL && VoxTerm(hVox) != 0)
		fSuccess = TraceFALSE(NULL);

	if (!fSuccess && hmmio != NULL && mmioClose(hmmio, 0) != 0)
		fSuccess = TraceFALSE(NULL);

	// return the same error code given by mmioOpen
	//
	return fSuccess ? lpmmioinfo->wErrorRet = mmioinfo.wErrorRet : MMIOERR_CANNOTOPEN;
}

static LRESULT VoxIOClose(LPMMIOINFO lpmmioinfo, UINT uFlags)
{
	BOOL fSuccess = TRUE;
	HMMIO hmmio = (HMMIO) lpmmioinfo->adwInfo[0];
	HVOX hVox = (HVOX) lpmmioinfo->adwInfo[1];
	UINT uRet = MMIOERR_CANNOTCLOSE;

 	TracePrintf_0(NULL, 5,
 		TEXT("VoxIOClose\n"));

	if (VoxTerm(hVox) != 0)
		fSuccess = TraceFALSE(NULL);

	else if ((uRet = mmioClose(hmmio, uFlags)) != 0)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lpmmioinfo->adwInfo[0] = (DWORD) NULL;
		lpmmioinfo->adwInfo[1] = (DWORD) NULL;
	}

	return fSuccess ? 0 : uRet;
}

static LRESULT VoxIORead(LPMMIOINFO lpmmioinfo, HPSTR pch, LONG cch)
{
	BOOL fSuccess = TRUE;
	HMMIO hmmio = (HMMIO) lpmmioinfo->adwInfo[0];
	HVOX hVox = (HVOX) lpmmioinfo->adwInfo[1];
	LONG cchVox;
	LONG lBytesRead;
	HPSTR pchVox = NULL;

 	TracePrintf_1(NULL, 5,
 		TEXT("VoxIORead (%ld)\n"),
		(long) cch);

	// vox format files contain 4 bit samples,
	// but we must simulate access to 16 bit samples.
	//
	cchVox = cch / 4L;
	
	if (cchVox <= 0)
		lBytesRead = 0; // nothing to do

	// allocate temporary buffer to hold the vox format samples
	//
	if ((pchVox = (HPSTR) MemAlloc(NULL, cchVox, 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// read vox format samples
	//
	else if ((lBytesRead = mmioRead(hmmio, pchVox, cchVox)) == -1)
		fSuccess = TraceFALSE(NULL);

	// decode vox format samples into pcm format samples
	// (there are 2 samples encoded in each vox byte)
	//
	else if (VoxDecode_16BitMono(hVox, (LPBYTE) pchVox, (LPPCM16) pch, (UINT) (lBytesRead * 2L)) != 0)
		fSuccess = TraceFALSE(NULL);

	// update simulated file position
	//
	if (fSuccess)
		lpmmioinfo->lDiskOffset += lBytesRead * 4L;

 	TracePrintf_2(NULL, 5,
 		TEXT("VoxIO: lpmmioinfo->lDiskOffset=%ld, lBytesRead=%ld\n"),
		(long) lpmmioinfo->lDiskOffset,
		(long) lBytesRead);

	// clean up
	//
	if (pchVox != NULL &&
		(pchVox = MemFree(NULL, pchVox)) != NULL)
		fSuccess = TraceFALSE(NULL);

	// return number of bytes read/decoded into pch
	//
	return fSuccess ? lBytesRead * 4L : -1;
}

static LRESULT VoxIOWrite(LPMMIOINFO lpmmioinfo, const HPSTR pch, LONG cch, BOOL fFlush)
{
	BOOL fSuccess = TRUE;
	HMMIO hmmio = (HMMIO) lpmmioinfo->adwInfo[0];
	HVOX hVox = (HVOX) lpmmioinfo->adwInfo[1];
	HPSTR pchVox = NULL;
	LONG cchVox;
	LONG lBytesWritten;

 	TracePrintf_1(NULL, 5,
 		TEXT("VoxIOWrite (%ld)\n"),
		(long) cch);

	// vox format files contain 4 bit samples,
	// but we must simulate access to 16 bit samples.
	//
	cchVox = cch / 4L;
	
	if (cchVox <= 0)
		lBytesWritten = 0; // nothing to do

	// allocate temporary buffer to hold the vox format samples
	//
	else if ((pchVox = (HPSTR) MemAlloc(NULL, cchVox, 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// encode pcm format samples into vox format samples
	// (there are 2 bytes required for each pcm sample)
	//
	else if (VoxEncode_16BitMono(hVox, (LPPCM16) pch, (LPBYTE) pchVox, (UINT) (cch / 2L)) != 0)
		fSuccess = TraceFALSE(NULL);

	// write vox format samples
	//
	else if ((lBytesWritten = mmioWrite(hmmio, pchVox, cchVox)) == -1)
		fSuccess = TraceFALSE(NULL);

	// update simulated file position
	//
	else
		lpmmioinfo->lDiskOffset += lBytesWritten * 4L;

	// clean up
	//
	if (pchVox != NULL &&
		(pchVox = MemFree(NULL, pchVox)) != NULL)
		fSuccess = TraceFALSE(NULL);

 	TracePrintf_2(NULL, 5,
 		TEXT("VoxIO: lpmmioinfo->lDiskOffset=%ld, lBytesWritten=%ld\n"),
		(long) lpmmioinfo->lDiskOffset,
		(long) lBytesWritten);

	// return number of bytes encoded/written from pch
	//
	return fSuccess ? lBytesWritten * 4L : -1;
}

static LRESULT VoxIOSeek(LPMMIOINFO lpmmioinfo, LONG lOffset, int iOrigin)
{
	BOOL fSuccess = TRUE;
	HMMIO hmmio = (HMMIO) lpmmioinfo->adwInfo[0];
	LONG lPosNew;

 	TracePrintf_2(NULL, 5,
 		TEXT("VoxIOSeek (%ld, %d)\n"),
		(long) lOffset,
		(int) iOrigin);

	// vox format files contain 4 bit samples,
	// but we must simulate access to 16 bit samples.
	//
	if ((lPosNew = mmioSeek(hmmio, lOffset / 4L, iOrigin)) == -1)
		fSuccess = TraceFALSE(NULL);

	// update simulated file position
	//
	else
		lpmmioinfo->lDiskOffset = lPosNew * 4L;

 	TracePrintf_1(NULL, 5,
 		TEXT("VoxIO: lpmmioinfo->lDiskOffset=%ld\n"),
		(long) lpmmioinfo->lDiskOffset);

	return fSuccess ? lpmmioinfo->lDiskOffset : -1;
}

static LRESULT VoxIORename(LPMMIOINFO lpmmioinfo, LPCTSTR lpszFileName, LPCTSTR lpszNewFileName)
{
	BOOL fSuccess = TRUE;
	UINT uRet = MMIOERR_FILENOTFOUND;

 	TracePrintf_2(NULL, 5,
 		TEXT("VoxIORename (%s, %s)\n"),
		(LPTSTR) lpszFileName,
		(LPTSTR) lpszNewFileName);

	if ((uRet = mmioRename(lpszFileName, lpszNewFileName, lpmmioinfo, 0)) != 0)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : uRet;
}

static LRESULT VoxIOGetInfo(LPMMIOINFO lpmmioinfo, int iInfo)
{
	BOOL fSuccess = TRUE;
	HMMIO hmmio = (HMMIO) lpmmioinfo->adwInfo[0];
	LRESULT lResult;

 	TracePrintf_1(NULL, 5,
 		TEXT("VoxIOGetInfo (%d)\n"),
		(int) iInfo);

	lResult = mmioSendMessage(hmmio, MMIOM_GETINFO, iInfo, 0);
#if 1
	if (iInfo == 1)
	{
		// vox format files contain 4 bit samples,
		// but we must simulate access to 16 bit samples.
		//
		lResult *= 4;
	}
#endif
	return fSuccess ? lResult : 0;
}

static LRESULT VoxIOChSize(LPMMIOINFO lpmmioinfo, long lSize)
{
	BOOL fSuccess = TRUE;
	HMMIO hmmio = (HMMIO) lpmmioinfo->adwInfo[0];
	LRESULT lResult;

 	TracePrintf_1(NULL, 5,
 		TEXT("VoxIOChSize (%ld)\n"),
		(long) lSize);

	lResult = mmioSendMessage(hmmio, MMIOM_CHSIZE, lSize, 0);

	return fSuccess ? lResult : -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\avwav\wavfmt.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	wavfmt.c - wave format functions
////

#include "winlocal.h"

#include <stdlib.h>
#include <stddef.h>

#include "wavfmt.h"
#include "calc.h"
#include "mem.h"
#include "trace.h"

////
//	private definitions
////

#define SAMPLERATE_DEFAULT			11025
#define SAMPLERATE_MAX				64000
#define SAMPLERATE_MIN				1000

#define SAMPLESIZE_DEFAULT 			8
#define SAMPLESIZE_MAX				32
#define SAMPLESIZE_MIN				0

#define CHANNELS_DEFAULT			1
#define CHANNELS_MAX				2
#define CHANNELS_MIN				1

////
//	public functions
////

// WavFormatPcm - fill WAVEFORMATEX struct based on PCM characteristics
//		<nSamplesPerSec>	(i) sample rate
//			-1					default sample rate (11025)
//		<nBitsPerSample>	(i) sample size
//			-1					default sample size (8)
//		<nChannels>			(i) number of channels (1=mono, 2=stereo)
//			-1					default (mono)
//		<lpwfx>				(o) pointer to output buffer
//			NULL				allocate new buffer to hold result
// return pointer to WAVEFORMATEX struct, NULL if error
//
// NOTE: if <lpwfx> points to a WAVEFORMATEX struct, this struct
// is filled in, and this function returns <lpwfx>.
// If <lpwfx> is NULL, space is dynamically allocated for the output
// buffer, and this function returns a pointer to the output buffer.
// Use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI WavFormatPcm(long nSamplesPerSec,
	WORD nBitsPerSample, WORD nChannels, LPWAVEFORMATEX lpwfx)
{
	BOOL fSuccess = TRUE;
	LPWAVEFORMATEX lpwfxNew = lpwfx;

	if (nSamplesPerSec == -1)
		nSamplesPerSec = SAMPLERATE_DEFAULT;
		
	if (nBitsPerSample == -1)
		nBitsPerSample = SAMPLESIZE_DEFAULT;

	if (nChannels == -1)
		nChannels = CHANNELS_DEFAULT;

	// user passed struct to fill
	//
	if (lpwfx != NULL && IsBadReadPtr(lpwfx, sizeof(WAVEFORMATEX)))
		fSuccess = TraceFALSE(NULL);

	// we allocate struct to fill
	//
	else if (lpwfx == NULL
		&& (lpwfxNew = WavFormatAlloc(sizeof(WAVEFORMATEX))) == NULL)
		fSuccess = TraceFALSE(NULL);

	// fill the struct
	//
	else
	{
		lpwfxNew->wFormatTag = WAVE_FORMAT_PCM;
		lpwfxNew->nChannels = nChannels;
		lpwfxNew->nSamplesPerSec = nSamplesPerSec;
		lpwfxNew->nBlockAlign = nChannels * (((nBitsPerSample - 1) / 8) + 1);
		lpwfxNew->nAvgBytesPerSec = lpwfxNew->nBlockAlign * nSamplesPerSec;
		lpwfxNew->wBitsPerSample = nBitsPerSample;
		lpwfxNew->cbSize = 0;
	}

	return fSuccess ? lpwfxNew : NULL;
}

// WavFormatAlloc - allocate WAVEFORMATEX struct buffer
//		<cbSize>			(i) size of struct, including extra bytes
// return pointer to WAVEFORMATEX struct, NULL if error
//
// NOTE: use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI WavFormatAlloc(WORD cbSize)
{
	BOOL fSuccess = TRUE;
	LPWAVEFORMATEX lpwfx;

	if (cbSize < sizeof(WAVEFORMATEX))
		fSuccess = TraceFALSE(NULL);

	// memory is allocated such that the client owns it
	//
	else if ((lpwfx = (LPWAVEFORMATEX) MemAlloc(NULL, cbSize, 0)) == NULL)
		fSuccess = TraceFALSE(NULL);
	else
		lpwfx->cbSize = cbSize - sizeof(WAVEFORMATEX);

	return fSuccess ? lpwfx : NULL;
}

// WavFormatDup - duplicate WAVEFORMATEX structure
//		<lpwfx>				(i) pointer to WAVEFORMATEX struct
// return pointer to new WAVEFORMATEX struct, NULL if error
//
// NOTE: use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI WavFormatDup(LPWAVEFORMATEX lpwfx)
{
	BOOL fSuccess = TRUE;
	LPWAVEFORMATEX lpwfxNew;

	if (lpwfx == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadReadPtr(lpwfx, WavFormatGetSize(lpwfx)))
		fSuccess = TraceFALSE(NULL);

	else if ((lpwfxNew = WavFormatAlloc((WORD)
		WavFormatGetSize(lpwfx))) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
		MemCpy(lpwfxNew, lpwfx, WavFormatGetSize(lpwfx));

	return fSuccess ? lpwfxNew : NULL;
}

// WavFormatFree - free WAVEFORMATEX struct
//		<lpwfx>				(i) pointer returned from WavFormatAlloc/Dup/Pcm
// return 0 if success
//
int DLLEXPORT WINAPI WavFormatFree(LPWAVEFORMATEX lpwfx)
{
	BOOL fSuccess = TRUE;

	if (lpwfx == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpwfx = MemFree(NULL, lpwfx)) != NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? 0 : -1;
}

// WavFormatIsValid - check format for validity
//		<lpwfx>				(i) pointer to WAVEFORMATEX struct
// return TRUE if valid format
//
BOOL DLLEXPORT WINAPI WavFormatIsValid(LPWAVEFORMATEX lpwfx)
{
	BOOL fSuccess = TRUE;

	if (lpwfx == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadReadPtr(lpwfx, sizeof(WAVEFORMATEX)))
		fSuccess = TraceFALSE(NULL);

	else if (IsBadReadPtr(lpwfx, WavFormatGetSize(lpwfx)))
		fSuccess = TraceFALSE(NULL);

	else if (lpwfx->nSamplesPerSec < SAMPLERATE_MIN ||
		lpwfx->nSamplesPerSec > SAMPLERATE_MAX)
		fSuccess = TraceFALSE(NULL);

	else if (lpwfx->wBitsPerSample < SAMPLESIZE_MIN ||
		lpwfx->wBitsPerSample > SAMPLESIZE_MAX)
		fSuccess = TraceFALSE(NULL);

	else if (lpwfx->nChannels < CHANNELS_MIN ||
		lpwfx->nChannels > CHANNELS_MAX)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? TRUE : FALSE;
}

// WavFormatCmp - compare one format with another
//		<lpwfx1>			(i) pointer to WAVEFORMATEX struct
//		<lpwfx2>			(i) pointer to WAVEFORMATEX struct
// return 0 if identical
//
#if 0
// NOTE: this function does NOT compare the cbSize field or the extra bytes
#else
// NOTE: this function does NOT compare the extra bytes beyond the cbSize field
#endif
//
int DLLEXPORT WINAPI WavFormatCmp(LPWAVEFORMATEX lpwfx1, LPWAVEFORMATEX lpwfx2)
{
	BOOL fSuccess = TRUE;
	int nCmp = 0; // assume identical

	if (!WavFormatIsValid(lpwfx1))
		fSuccess = TraceFALSE(NULL);

	else if (!WavFormatIsValid(lpwfx2))
		fSuccess = TraceFALSE(NULL);

	else
	{
#if 0
		// compare up to (but not including) the cbSize field
		//
		nCmp = MemCmp(lpwfx1, lpwfx2,
			offsetof(WAVEFORMATEX, cbSize));
#else
		// compare up to and including the cbSize field
		//
		nCmp = MemCmp(lpwfx1, lpwfx2, sizeof(WAVEFORMATEX));
#endif
	}

	return fSuccess ? nCmp : -1;
}

// WavFormatCopy - copy one format to another
//		<lpwfxDst>			(i) pointer to destination WAVEFORMATEX struct
//		<lpwfxSrc>			(i) pointer to source WAVEFORMATEX struct
// return 0 if success
//
#if 0
// NOTE: this function does NOT copy the cbSize field or the extra bytes
#else
// NOTE: make sure lpwfxDst points to enough memory to contain the entire
// WAVEFORMATEX struct plus any extra bytes beyond it
#endif
//
int DLLEXPORT WINAPI WavFormatCopy(LPWAVEFORMATEX lpwfxDst, LPWAVEFORMATEX lpwfxSrc)
{
	BOOL fSuccess = TRUE;

	if (!WavFormatIsValid(lpwfxSrc))
		fSuccess = TraceFALSE(NULL);

	else if (lpwfxDst == NULL)
		fSuccess = TraceFALSE(NULL);

#if 0
	// make sure destination is at least as big as WAVEFORMATEX struct
	//
	else if (IsBadReadPtr(lpwfxDst, sizeof(WAVEFORMATEX))
		fSuccess = TraceFALSE(NULL);

	else
	{
		// copy up to (but not including) the cbSize field
		//
		MemCpy(lpwfxDst, lpwfxSrc,
			offsetof(WAVEFORMATEX, cbSize));
	}
#else
	// make sure destination is at least as big as source
	//
	else if (IsBadReadPtr(lpwfxDst, WavFormatGetSize(lpwfxSrc)))
		fSuccess = TraceFALSE(NULL);

	else
	{
		// copy entire structure, including any extra bytes
		//
		MemCpy(lpwfxDst, lpwfxSrc, WavFormatGetSize(lpwfxSrc));
	}
#endif

	return fSuccess ? 0 : -1;
}

// WavFormatGetSize - check size of format structure
//		<lpwfx>				(i) pointer to WAVEFORMATEX struct
// return size of structure, 0 if error
//
int DLLEXPORT WINAPI WavFormatGetSize(LPWAVEFORMATEX lpwfx)
{
	BOOL fSuccess = TRUE;
	int sizwfx = 0;

	if (lpwfx == NULL)
		fSuccess = TraceFALSE(NULL);

	// ignore cbSize value if pcm format
	//
	else if (lpwfx->wFormatTag == WAVE_FORMAT_PCM)
		sizwfx = sizeof(WAVEFORMATEX);

	else
		sizwfx = sizeof(WAVEFORMATEX) + lpwfx->cbSize;

	return fSuccess ? sizwfx : 0;
}

// WavFormatDump - dump WAVEFORMATEX struct to debug
//		<lpwfx>				(i) pointer to WAVEFORMATEX struct
// return 0 if success
//
int DLLEXPORT WINAPI WavFormatDump(LPWAVEFORMATEX lpwfx)
{
	BOOL fSuccess = TRUE;

	if (lpwfx == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadReadPtr(lpwfx, sizeof(WAVEFORMATEX)))
		fSuccess = TraceFALSE(NULL);

	else
	{
		TracePrintf_7(NULL, 1,
			TEXT("struct tWAVEFORMATEX\n")
			TEXT("{\n")
				TEXT("\tWORD\twFormatTag = %u;\n")
				TEXT("\tWORD\tnChannels = %u;\n")
				TEXT("\tDWORD\tnSamplesPerSec = %lu;\n")
				TEXT("\tDWORD\tnAvgBytesPerSec = %lu;\n")
				TEXT("\tWORD\tnBlockAlign = %u;\n")
				TEXT("\tWORD\twBitsPerSample = %u;\n")
				TEXT("\tWORD\tcbSize = %u;\n")
			TEXT("} WAVEFORMATEX\n"),
			(unsigned int) lpwfx->wFormatTag,
			(unsigned int) lpwfx->nChannels,
			(unsigned long) lpwfx->nSamplesPerSec,
			(unsigned long) lpwfx->nAvgBytesPerSec,
			(unsigned int) lpwfx->nBlockAlign,
			(unsigned int) lpwfx->wBitsPerSample,
			(unsigned int) lpwfx->cbSize);
	}

	return fSuccess ? 0 : -1;
}

// WavFormatBytesToMilleseconds - convert bytes to milleseconds
//		<lpwfx>				(i) pointer to WAVEFORMATEX struct
//		<dwBytes>			(i) bytes
// return milleseconds
//
DWORD DLLEXPORT WINAPI WavFormatBytesToMilleseconds(LPWAVEFORMATEX lpwfx, DWORD dwBytes)
{
	if (lpwfx == NULL || lpwfx->nAvgBytesPerSec == 0)
		return 0;
	else
		return MULDIVU32(dwBytes, 1000, (DWORD) lpwfx->nAvgBytesPerSec);
}

// WavFormatMillesecondsToBytes - convert milleseconds to bytes
//		<lpwfx>				(i) pointer to WAVEFORMATEX struct
//		<dwMilleseconds>	(i) milleseconds
// return milleseconds
//
DWORD DLLEXPORT WINAPI WavFormatMillesecondsToBytes(LPWAVEFORMATEX lpwfx, DWORD dwMilleseconds)
{
	if (lpwfx == NULL || lpwfx->nAvgBytesPerSec == 0)
		return 0;
	else
		return MULDIVU32(dwMilleseconds, (DWORD) lpwfx->nAvgBytesPerSec, 1000);
}

// WavFormatSpeedAdjust - adjust format to reflect specified speed
//		<lpwfx>				(i/o) pointer to WAVEFORMATEX struct
//		<nLevel>			(i) speed level
//			50					half speed
//			100					normal speed
//			200					double speed, etc.
//		<dwFlags>			(i) reserved; must be zero
// return 0 if success
//
int DLLEXPORT WINAPI WavFormatSpeedAdjust(LPWAVEFORMATEX lpwfx, int nLevel, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;

	if (lpwfx == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (nLevel != 100)
	{
		lpwfx->nSamplesPerSec = lpwfx->nSamplesPerSec * nLevel / 100;
		lpwfx->nAvgBytesPerSec = lpwfx->nBlockAlign * lpwfx->nSamplesPerSec;
	}

	return fSuccess ? 0 : -1;
}

// WavFormatVoxadpcm - fill WAVEFORMATEX struct for Dialogic OKI ADPCM
//		<lpwfx>				(o) pointer to output buffer
//			NULL				allocate new buffer to hold result
//		<nSamplesPerSec>	(i) sample rate
//			-1					default sample rate (6000)
// return pointer to WAVEFORMATEX struct, NULL if error
//
// NOTE: if <lpwfx> points to a WAVEFORMATEX struct, this struct
// is filled in, and this function returns <lpwfx>.
// If <lpwfx> is NULL, space is dynamically allocated for the output
// buffer, and this function returns a pointer to the output buffer.
// Use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI WavFormatVoxadpcm(LPWAVEFORMATEX lpwfx, long nSamplesPerSec)
{
	BOOL fSuccess = TRUE;
	LPWAVEFORMATEX lpwfxNew = lpwfx;
	WORD nBitsPerSample = 4;
	WORD nChannels = 1;
#if 0
	// nBlockAlign is 4 so that chunk size of 5188 is returned from
	// WavCalcChunkSize(VoxFormat(NULL, 6000), 1962, TRUE);
	// 5188 is optimal for Dialogic buffer logic (((12 * 1024) - 512) / 2)
	//
	WORD nBlockAlign = 4;
#else
	WORD nBlockAlign = 1;
#endif

	if (nSamplesPerSec == -1)
		nSamplesPerSec = 6000;
		
	// user passed struct to fill
	//
	if (lpwfx != NULL && IsBadReadPtr(lpwfx, sizeof(WAVEFORMATEX)))
		fSuccess = TraceFALSE(NULL);

	// we allocate struct to fill
	//
	else if (lpwfx == NULL
		&& (lpwfxNew = WavFormatAlloc(sizeof(WAVEFORMATEX))) == NULL)
		fSuccess = TraceFALSE(NULL);

	// fill the struct
	//
	else
	{
		lpwfxNew->wFormatTag = WAVE_FORMAT_DIALOGIC_OKI_ADPCM;
		lpwfxNew->nChannels = nChannels;
		lpwfxNew->nSamplesPerSec = nSamplesPerSec;
		lpwfxNew->nBlockAlign = nBlockAlign;
		lpwfxNew->nAvgBytesPerSec = nSamplesPerSec / 2;
		lpwfxNew->wBitsPerSample = nBitsPerSample;
		lpwfxNew->cbSize = 0;
	}

	return fSuccess ? lpwfxNew : NULL;
}

// WavFormatMulaw - fill WAVEFORMATEX struct for CCITT u-law format
//		<lpwfx>				(o) pointer to output buffer
//			NULL				allocate new buffer to hold result
//		<nSamplesPerSec>	(i) sample rate
//			-1					default sample rate (8000)
// return pointer to WAVEFORMATEX struct, NULL if error
//
// NOTE: if <lpwfx> points to a WAVEFORMATEX struct, this struct
// is filled in, and this function returns <lpwfx>.
// If <lpwfx> is NULL, space is dynamically allocated for the output
// buffer, and this function returns a pointer to the output buffer.
// Use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI WavFormatMulaw(LPWAVEFORMATEX lpwfx, long nSamplesPerSec)
{
	BOOL fSuccess = TRUE;
	LPWAVEFORMATEX lpwfxNew = lpwfx;
	WORD nBitsPerSample = 8;
	WORD nChannels = 1;
	WORD nBlockAlign = 1;

	if (nSamplesPerSec == -1)
		nSamplesPerSec = 8000;
		
	// user passed struct to fill
	//
	if (lpwfx != NULL && IsBadReadPtr(lpwfx, sizeof(WAVEFORMATEX)))
		fSuccess = TraceFALSE(NULL);

	// we allocate struct to fill
	//
	else if (lpwfx == NULL
		&& (lpwfxNew = WavFormatAlloc(sizeof(WAVEFORMATEX))) == NULL)
		fSuccess = TraceFALSE(NULL);

	// fill the struct
	//
	else
	{
		lpwfxNew->wFormatTag = WAVE_FORMAT_MULAW;
		lpwfxNew->nChannels = nChannels;
		lpwfxNew->nSamplesPerSec = nSamplesPerSec;
		lpwfxNew->nBlockAlign = nBlockAlign;
		lpwfxNew->nAvgBytesPerSec = lpwfxNew->nBlockAlign * nSamplesPerSec;
		lpwfxNew->wBitsPerSample = nBitsPerSample;
		lpwfxNew->cbSize = 0;
	}

	return fSuccess ? lpwfxNew : NULL;
}

// WavFormatAlaw - fill WAVEFORMATEX struct for CCITT a-law format
//		<lpwfx>				(o) pointer to output buffer
//			NULL				allocate new buffer to hold result
//		<nSamplesPerSec>	(i) sample rate
//			-1					default sample rate (8000)
// return pointer to WAVEFORMATEX struct, NULL if error
//
// NOTE: if <lpwfx> points to a WAVEFORMATEX struct, this struct
// is filled in, and this function returns <lpwfx>.
// If <lpwfx> is NULL, space is dynamically allocated for the output
// buffer, and this function returns a pointer to the output buffer.
// Use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI WavFormatAlaw(LPWAVEFORMATEX lpwfx, long nSamplesPerSec)
{
	BOOL fSuccess = TRUE;
	LPWAVEFORMATEX lpwfxNew = lpwfx;
	WORD nBitsPerSample = 8;
	WORD nChannels = 1;
	WORD nBlockAlign = 1;

	if (nSamplesPerSec == -1)
		nSamplesPerSec = 8000;
		
	// user passed struct to fill
	//
	if (lpwfx != NULL && IsBadReadPtr(lpwfx, sizeof(WAVEFORMATEX)))
		fSuccess = TraceFALSE(NULL);

	// we allocate struct to fill
	//
	else if (lpwfx == NULL
		&& (lpwfxNew = WavFormatAlloc(sizeof(WAVEFORMATEX))) == NULL)
		fSuccess = TraceFALSE(NULL);

	// fill the struct
	//
	else
	{
		lpwfxNew->wFormatTag = WAVE_FORMAT_ALAW;
		lpwfxNew->nChannels = nChannels;
		lpwfxNew->nSamplesPerSec = nSamplesPerSec;
		lpwfxNew->nBlockAlign = nBlockAlign;
		lpwfxNew->nAvgBytesPerSec = lpwfxNew->nBlockAlign * nSamplesPerSec;
		lpwfxNew->wBitsPerSample = nBitsPerSample;
		lpwfxNew->cbSize = 0;
	}

	return fSuccess ? lpwfxNew : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\avwav\wavfmt.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// wavfmt.h - interface for wav format functions in wavfmt.c
////

#ifndef __WAVFMT_H__
#define __WAVFMT_H__

#include "winlocal.h"

// 16-bit pcm sample
//
typedef __int16 PCM16;
typedef PCM16 _huge *LPPCM16;

// 8-bit pcm sample
//
typedef BYTE PCM8;
typedef PCM8 _huge *LPPCM8;

#include <mmsystem.h>

#ifdef _WIN32
#include <mmreg.h>
#else
#if 0 // this requires either the VFWDK or MDRK
#include <mmreg.h>
#else // this is copied from the WIN32 version of mmreg.h

#ifndef _WAVEFORMATEX_
#define _WAVEFORMATEX_
typedef struct tWAVEFORMATEX
{
    WORD    wFormatTag;        /* format type */
    WORD    nChannels;         /* number of channels (i.e. mono, stereo...) */
    DWORD   nSamplesPerSec;    /* sample rate */
    DWORD   nAvgBytesPerSec;   /* for buffer estimation */
    WORD    nBlockAlign;       /* block size of data */
    WORD    wBitsPerSample;    /* Number of bits per sample of mono data */
    WORD    cbSize;            /* The count in bytes of the size of
                                    extra information (after cbSize) */
} WAVEFORMATEX;

typedef WAVEFORMATEX       *PWAVEFORMATEX;
typedef WAVEFORMATEX NEAR *NPWAVEFORMATEX;
typedef WAVEFORMATEX FAR  *LPWAVEFORMATEX;
#endif /* _WAVEFORMATEX_ */

#ifndef _ACM_WAVEFILTER
#define _ACM_WAVEFILTER

#define WAVE_FILTER_UNKNOWN         0x0000
#define WAVE_FILTER_DEVELOPMENT    (0xFFFF)

typedef struct wavefilter_tag {
    DWORD   cbStruct;           /* Size of the filter in bytes */
    DWORD   dwFilterTag;        /* filter type */
    DWORD   fdwFilter;          /* Flags for the filter (Universal Dfns) */
    DWORD   dwReserved[5];      /* Reserved for system use */
} WAVEFILTER;
typedef WAVEFILTER       *PWAVEFILTER;
typedef WAVEFILTER NEAR *NPWAVEFILTER;
typedef WAVEFILTER FAR  *LPWAVEFILTER;

#endif  /* _ACM_WAVEFILTER */

#ifndef WAVE_FORMAT_DIALOGIC_OKI_ADPCM
#define  WAVE_FORMAT_DIALOGIC_OKI_ADPCM 0x0017  /*  Dialogic Corporation  */
#endif

#ifndef MM_DIALOGIC
#define   MM_DIALOGIC                   93         /*  Dialogic Corporation  */
#endif

#ifndef WAVE_FORMAT_MULAW
#define  WAVE_FORMAT_MULAW      0x0007  /*  Microsoft Corporation  */
#endif

#endif
#endif

// issued 5/11/98 by Terri Hendry thendry@microsoft.com
//
#ifndef MM_ACTIVEVOICE
#define MM_ACTIVEVOICE 225
#endif

// issued 5/11/98 by Terri Hendry thendry@microsoft.com
//
#ifndef MM_ACTIVEVOICE_ACM_VOXADPCM
#define MM_ACTIVEVOICE_ACM_VOXADPCM 1
#endif

// $FIXUP - we need to register with Microsoft to get product id
//
#ifndef MM_ACTIVEVOICE_AVPHONE_WAVEOUT
#define MM_ACTIVEVOICE_AVPHONE_WAVEOUT 2
#endif

// $FIXUP - we need to register with Microsoft to get product id
//
#ifndef MM_ACTIVEVOICE_AVPHONE_WAVEIN
#define MM_ACTIVEVOICE_AVPHONE_WAVEIN 3
#endif

#define WAVFMT_VERSION 0x00000105

#ifdef __cplusplus
extern "C" {
#endif

// WavFormatPcm - fill WAVEFORMATEX struct based on PCM characteristics
//		<nSamplesPerSec>	(i) sample rate
//			-1					default sample rate (11025)
//		<nBitsPerSample>	(i) sample size
//			-1					default sample size (8)
//		<nChannels>			(i) number of channels (1=mono, 2=stereo)
//			-1					default (mono)
//		<lpwfx>				(o) pointer to output buffer
//			NULL				allocate new buffer to hold result
// return pointer to WAVEFORMATEX struct, NULL if error
//
// NOTE: if <lpwfx> points to a WAVEFORMATEX struct, this struct
// is filled in, and this function returns <lpwfx>.
// If <lpwfx> is NULL, space is dynamically allocated for the output
// buffer, and this function returns a pointer to the output buffer.
// Use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI WavFormatPcm(long nSamplesPerSec,
	WORD nBitsPerSample, WORD nChannels, LPWAVEFORMATEX lpwfx);

// WavFormatAlloc - allocate WAVEFORMATEX struct buffer
//		<cbSize>			(i) size of struct, including extra bytes
// return pointer to WAVEFORMATEX struct, NULL if error
//
// NOTE: use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI WavFormatAlloc(WORD cbSize);

// WavFormatDup - duplicate WAVEFORMATEX structure
//		<lpwfx>				(i) pointer to WAVEFORMATEX struct
// return pointer to new WAVEFORMATEX struct, NULL if error
//
// NOTE: use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI WavFormatDup(LPWAVEFORMATEX lpwfx);

// WavFormatFree - free WAVEFORMATEX struct
//		<lpwfx>				(i) pointer returned from WavFormatAlloc/Dup/Pcm
// return 0 if success
//
int DLLEXPORT WINAPI WavFormatFree(LPWAVEFORMATEX lpwfx);

// WavFormatIsValid - check format for validity
//		<lpwfx>				(i) pointer to WAVEFORMATEX struct
// return TRUE if valid format
//
BOOL DLLEXPORT WINAPI WavFormatIsValid(LPWAVEFORMATEX lpwfx);

// WavFormatCmp - compare one format with another
//		<lpwfx1>			(i) pointer to WAVEFORMATEX struct
//		<lpwfx2>			(i) pointer to WAVEFORMATEX struct
// return 0 if identical
//
// NOTE: this function does NOT compare the cbSize field or the extra bytes
//
int DLLEXPORT WINAPI WavFormatCmp(LPWAVEFORMATEX lpwfx1, LPWAVEFORMATEX lpwfx2);

// WavFormatCopy - copy one format to another
//		<lpwfxDst>			(i) pointer to destination WAVEFORMATEX struct
//		<lpwfxSrc>			(i) pointer to source WAVEFORMATEX struct
// return 0 if success
//
// NOTE: this function does NOT copy the cbSize field or the extra bytes
//
int DLLEXPORT WINAPI WavFormatCopy(LPWAVEFORMATEX lpwfxDst, LPWAVEFORMATEX lpwfxSrc);

// WavFormatGetSize - check size of format structure
//		<lpwfx>				(i) pointer to WAVEFORMATEX struct
// return size of structure, 0 if error
//
int DLLEXPORT WINAPI WavFormatGetSize(LPWAVEFORMATEX lpwfx);

// WavFormatDump - dump WAVEFORMATEX struct to debug
//		<lpwfx>				(i) pointer to WAVEFORMATEX struct
// return 0 if success
//
int DLLEXPORT WINAPI WavFormatDump(LPWAVEFORMATEX lpwfx);

// WavFormatBytesToMilleseconds - convert bytes to milleseconds
//		<lpwfx>				(i) pointer to WAVEFORMATEX struct
//		<dwBytes>			(i) bytes
// return milleseconds
//
DWORD DLLEXPORT WINAPI WavFormatBytesToMilleseconds(LPWAVEFORMATEX lpwfx, DWORD dwBytes);

// WavFormatMillesecondsToBytes - convert milleseconds to bytes
//		<lpwfx>				(i) pointer to WAVEFORMATEX struct
//		<dwMilleseconds>	(i) milleseconds
// return milleseconds
//
DWORD DLLEXPORT WINAPI WavFormatMillesecondsToBytes(LPWAVEFORMATEX lpwfx, DWORD dwMilleseconds);

// WavFormatSpeedAdjust - adjust format to reflect specified speed
//		<lpwfx>				(i/o) pointer to WAVEFORMATEX struct
//		<nLevel>			(i) speed level
//			50					half speed
//			100					normal speed
//			200					double speed, etc.
//		<dwFlags>			(i) reserved; must be zero
// return 0 if success
//
int DLLEXPORT WINAPI WavFormatSpeedAdjust(LPWAVEFORMATEX lpwfx, int nLevel, DWORD dwFlags);

// WavFormatVoxadpcm - fill WAVEFORMATEX struct for Dialogic OKI ADPCM
//		<lpwfx>				(o) pointer to output buffer
//			NULL				allocate new buffer to hold result
//		<nSamplesPerSec>	(i) sample rate
//			-1					default sample rate (6000)
// return pointer to WAVEFORMATEX struct, NULL if error
//
// NOTE: if <lpwfx> points to a WAVEFORMATEX struct, this struct
// is filled in, and this function returns <lpwfx>.
// If <lpwfx> is NULL, space is dynamically allocated for the output
// buffer, and this function returns a pointer to the output buffer.
// Use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI WavFormatVoxadpcm(LPWAVEFORMATEX lpwfx, long nSamplesPerSec);

// WavFormatMulaw - fill WAVEFORMATEX struct for CCITT u-law format
//		<lpwfx>				(o) pointer to output buffer
//			NULL				allocate new buffer to hold result
//		<nSamplesPerSec>	(i) sample rate
//			-1					default sample rate (8000)
// return pointer to WAVEFORMATEX struct, NULL if error
//
// NOTE: if <lpwfx> points to a WAVEFORMATEX struct, this struct
// is filled in, and this function returns <lpwfx>.
// If <lpwfx> is NULL, space is dynamically allocated for the output
// buffer, and this function returns a pointer to the output buffer.
// Use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI WavFormatMulaw(LPWAVEFORMATEX lpwfx, long nSamplesPerSec);

// WavFormatAlaw - fill WAVEFORMATEX struct for CCITT a-law format
//		<lpwfx>				(o) pointer to output buffer
//			NULL				allocate new buffer to hold result
//		<nSamplesPerSec>	(i) sample rate
//			-1					default sample rate (8000)
// return pointer to WAVEFORMATEX struct, NULL if error
//
// NOTE: if <lpwfx> points to a WAVEFORMATEX struct, this struct
// is filled in, and this function returns <lpwfx>.
// If <lpwfx> is NULL, space is dynamically allocated for the output
// buffer, and this function returns a pointer to the output buffer.
// Use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI WavFormatAlaw(LPWAVEFORMATEX lpwfx, long nSamplesPerSec);

#ifdef __cplusplus
}
#endif

#endif // __WAV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\avwav\wavmixer.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	wavmixer.c - wav mixer functions
////

#include "winlocal.h"

#include <mmsystem.h>

#include "wavmixer.h"
#include "calc.h"
#include "mem.h"
#include "trace.h"

////
//	private definitions
////

// wavmixer control struct
//
typedef struct WAVMIXER
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	HMIXER hMixer;
	UINT nLastError;
	DWORD dwFlags;
} WAVMIXER, FAR *LPWAVMIXER;

#define VOLUME_MINLEVEL 0
#define VOLUME_MAXLEVEL 100
#define VOLUME_POSITIONS (VOLUME_MAXLEVEL - VOLUME_MINLEVEL)

#define WAVMIXER_SUPPORTSVOLUME		0x00000001
#define WAVMIXER_GETVOLUME			0x00000002
#define WAVMIXER_SETVOLUME			0x00000004

#define LEVEL_MINLEVEL 0
#define LEVEL_MAXLEVEL 100
#define LEVEL_POSITIONS (LEVEL_MAXLEVEL - LEVEL_MINLEVEL)

#define WAVMIXER_SUPPORTSLEVEL		0x00000001
#define WAVMIXER_GETLEVEL			0x00000002

// helper functions
//
static int WINAPI WavMixerVolume(HWAVMIXER hWavMixer, LPINT lpnLevel, DWORD dwFlags);
static int WINAPI WavMixerLevel(HWAVMIXER hWavMixer, LPINT lpnLevel, DWORD dwFlags);
static LPWAVMIXER WavMixerGetPtr(HWAVMIXER hWavMixer);
static HWAVMIXER WavMixerGetHandle(LPWAVMIXER lpWavMixer);

////
//	public functions
////

// WavMixerInit - initialize wav mixer device
//		<dwVersion>			(i) must be WAVMIXER_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<lParam>			(i) device id or handle, as specified by <dwFlags>
//		<dwReserved1>		(i) reserved; must be 0;
//		<dwReserved2>		(i) reserved; must be 0;
//		<dwFlags>			(i) control flags
//			WAVMIXER_HWAVEIN	<lParam> contains an HWAVEIN
//			WAVMIXER_HWAVEOUT	<lParam> contains an HWAVEOUT
//			WAVMIXER_WAVEIN		<lParam> contains a wav input device id
//			WAVMIXER_WAVEOUT	<lParam> contains a wav output device id
// return handle (NULL if error)
//
HWAVMIXER WINAPI WavMixerInit(DWORD dwVersion, HINSTANCE hInst,
	LPARAM lParam, DWORD dwReserved1, DWORD dwReserved2, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAVMIXER lpWavMixer = NULL;

	if (dwVersion != WAVMIXER_VERSION)
		fSuccess = TraceFALSE(NULL);
	
	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);
                        
	else if ((lpWavMixer = (LPWAVMIXER) MemAlloc(NULL, sizeof(WAVMIXER), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		UINT uMxId = (UINT) lParam; 
		DWORD fdwOpen = 0;
		UINT nLastError;

		lpWavMixer->dwVersion = dwVersion;
		lpWavMixer->hInst = hInst;
		lpWavMixer->hTask = GetCurrentTask();
		lpWavMixer->hMixer = NULL;
		lpWavMixer->nLastError = 0;
		lpWavMixer->dwFlags = dwFlags;

		if (dwFlags & WAVMIXER_HWAVEIN)
			fdwOpen |= MIXER_OBJECTF_HWAVEIN;
		if (dwFlags & WAVMIXER_HWAVEOUT)
			fdwOpen |= MIXER_OBJECTF_HWAVEOUT;
		if (dwFlags & WAVMIXER_WAVEIN)
			fdwOpen |= MIXER_OBJECTF_WAVEIN;
		if (dwFlags & WAVMIXER_WAVEOUT)
			fdwOpen |= MIXER_OBJECTF_WAVEOUT;

		// open the mixer device
		//
		if ((nLastError = mixerOpen(&lpWavMixer->hMixer, uMxId, 0L, 0L, fdwOpen)) != MMSYSERR_NOERROR)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("mixerOpen failed (%u)\n"),
				(unsigned) nLastError);
		}
	}

	if (!fSuccess)
	{
		WavMixerTerm(WavMixerGetHandle(lpWavMixer));
		lpWavMixer = NULL;
	}

	return fSuccess ? WavMixerGetHandle(lpWavMixer) : NULL;
}

// WavMixerTerm - shut down wave mixer device
//		<hWavMixer>				(i) handle returned from WavMixerInit
// return 0 if success
//
int WINAPI WavMixerTerm(HWAVMIXER hWavMixer)
{
	BOOL fSuccess = TRUE;
	LPWAVMIXER lpWavMixer;

	if ((lpWavMixer = WavMixerGetPtr(hWavMixer)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		if (lpWavMixer->hMixer != NULL)
		{
			UINT nLastError;

			if ((nLastError = mixerClose(lpWavMixer->hMixer)) != MMSYSERR_NOERROR)
			{
				fSuccess = TraceFALSE(NULL);
				TracePrintf_1(NULL, 5,
					TEXT("mixerClose failed (%u)\n"),
					(unsigned) nLastError);
			}
			else
				lpWavMixer->hMixer = NULL;
		}

		if ((lpWavMixer = MemFree(NULL, lpWavMixer)) != NULL)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// WavMixerSupportsVolume - return TRUE if device supports volume control
//		<hWavMixer>				(i) handle returned from WavMixerInit
//		<dwFlags>				(i) control flags
//			0						reserved; must be zero
// return TRUE if device supports volume control
//
BOOL WINAPI WavMixerSupportsVolume(HWAVMIXER hWavMixer, DWORD dwFlags)
{
	if (WavMixerVolume(hWavMixer, NULL, WAVMIXER_SUPPORTSVOLUME) != 0)
		return FALSE;
	else
		return TRUE;
}

// WavMixerGetVolume - get current volume level
//		<hWavMixer>				(i) handle returned from WavMixerInit
//		<dwFlags>				(i) control flags
//			0						reserved; must be zero
// return volume level (0 minimum through 100 maximum, -1 if error)
//
int WINAPI WavMixerGetVolume(HWAVMIXER hWavMixer, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	int nLevel;

	if (WavMixerVolume(hWavMixer, &nLevel, WAVMIXER_GETVOLUME) != 0)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? nLevel : -1;
}

// WavMixerSetVolume - set current volume level
//		<hWavMixer>				(i) handle returned from WavMixerInit
//		<nLevel>				(i) volume level
//			0						minimum volume
//			100						maximum volume
//		<dwFlags>				(i) control flags
//			0						reserved; must be zero
// return new volume level (0 minimum through 100 maximum, -1 if error)
//
int WINAPI WavMixerSetVolume(HWAVMIXER hWavMixer, int nLevel, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;

	if (WavMixerVolume(hWavMixer, &nLevel, WAVMIXER_SETVOLUME) != 0)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? nLevel : -1;
}

static int WINAPI WavMixerVolume(HWAVMIXER hWavMixer, LPINT lpnLevel, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAVMIXER lpWavMixer;
	LPMIXERCONTROL lpmxc = NULL;

    //
    // We have to initialize local variable
    //
	UINT nLastError;
	MIXERLINE mxlDst;
	MIXERLINE mxlSrc;
	BOOL fWaveIn = FALSE;

	if ((lpWavMixer = WavMixerGetPtr(hWavMixer)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpmxc = (LPMIXERCONTROL) MemAlloc(NULL, sizeof(MIXERCONTROL), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// get info for the destination line
	//
	if (fSuccess)
	{
		if ((lpWavMixer->dwFlags & WAVMIXER_WAVEIN) ||
			(lpWavMixer->dwFlags & WAVMIXER_HWAVEIN))
			fWaveIn = TRUE;

		mxlDst.cbStruct = sizeof(mxlDst);
		mxlDst.dwComponentType = fWaveIn ?
			MIXERLINE_COMPONENTTYPE_DST_WAVEIN :
			MIXERLINE_COMPONENTTYPE_DST_SPEAKERS;

		if ((nLastError = mixerGetLineInfo((HMIXEROBJ) lpWavMixer->hMixer, &mxlDst,
			MIXER_OBJECTF_HMIXER | MIXER_GETLINEINFOF_COMPONENTTYPE)) != MMSYSERR_NOERROR)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("mixerGetLineInfo failed (%u)\n"),
				(unsigned) nLastError);
		}
	}

	// find appropriate source line connected to this destination line
	//
	if (fSuccess)
	{
		DWORD dwSource;

		for (dwSource = 0; fSuccess && dwSource < mxlDst.cConnections; ++dwSource)
		{
			mxlSrc.cbStruct = sizeof(mxlSrc);
			mxlSrc.dwSource = dwSource;
			mxlSrc.dwDestination = mxlDst.dwDestination;

			if ((nLastError = mixerGetLineInfo((HMIXEROBJ) lpWavMixer->hMixer, &mxlSrc,
				MIXER_OBJECTF_HMIXER | MIXER_GETLINEINFOF_SOURCE)) != MMSYSERR_NOERROR)
			{
				fSuccess = TraceFALSE(NULL);
				TracePrintf_1(NULL, 5,
					TEXT("mixerGetLineInfo failed (%u)\n"),
					(unsigned) nLastError);
			}

			else if (mxlSrc.dwComponentType == (DWORD) (fWaveIn ?
				MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE :
				MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT))
			{
				// source line found
				//
				break;
			}
		}

		if (dwSource == mxlDst.cConnections)
		{
			// unable to find source line
			//
			fSuccess = TraceFALSE(NULL);
		}
	}

	// find volume control, if any, of the appropriate line
	//
	if (fSuccess)
	{
		MIXERLINECONTROLS mxlc;

		mxlc.cbStruct = sizeof(mxlc);
		mxlc.dwLineID = (fWaveIn ? mxlSrc.dwLineID : mxlDst.dwLineID);
		mxlc.dwControlType = MIXERCONTROL_CONTROLTYPE_VOLUME;
		mxlc.cControls = 1;
		mxlc.cbmxctrl = sizeof(MIXERCONTROL);
		mxlc.pamxctrl = lpmxc;

		if ((nLastError = mixerGetLineControls((HMIXEROBJ) lpWavMixer->hMixer, &mxlc,
			MIXER_OBJECTF_HMIXER | MIXER_GETLINECONTROLSF_ONEBYTYPE)) != MMSYSERR_NOERROR)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("mixerGetLineControls failed (%u)\n"),
				(unsigned) nLastError);
		}
	}

	// get and/or set current volume level
	//
	if (fSuccess &&
		((dwFlags & WAVMIXER_GETVOLUME) || (dwFlags & WAVMIXER_SETVOLUME)))
	{
		LPMIXERCONTROLDETAILS_UNSIGNED lpmxcdu = NULL;
		MIXERCONTROLDETAILS mxcd;
		DWORD cChannels = mxlSrc.cChannels;
		DWORD dwVolume;
		int nLevel;

		if (lpmxc->fdwControl & MIXERCONTROL_CONTROLF_UNIFORM)
			cChannels = 1;
		
		if ((lpmxcdu = (LPMIXERCONTROLDETAILS_UNSIGNED) MemAlloc(NULL,
			cChannels * sizeof(MIXERCONTROLDETAILS_UNSIGNED), 0)) == NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}

		else
		{
			mxcd.cbStruct = sizeof(mxcd);
			mxcd.dwControlID = lpmxc->dwControlID;
			mxcd.cChannels = cChannels;
			mxcd.hwndOwner = (HWND) NULL;
			mxcd.cbDetails = sizeof(MIXERCONTROLDETAILS_UNSIGNED);
			mxcd.paDetails = (LPVOID) lpmxcdu;

			if ((nLastError = mixerGetControlDetails((HMIXEROBJ) lpWavMixer->hMixer, &mxcd,
				MIXER_OBJECTF_HMIXER | MIXER_GETCONTROLDETAILSF_VALUE)) != MMSYSERR_NOERROR)
			{
				fSuccess = TraceFALSE(NULL);
				TracePrintf_1(NULL, 5,
					TEXT("mixerGetControlDetails failed (%u)\n"),
					(unsigned) nLastError);
			}
			else
				dwVolume = lpmxcdu[0].dwValue;
		}

		if (fSuccess && (dwFlags & WAVMIXER_SETVOLUME))
		{
			if (lpnLevel != NULL)
				nLevel = *lpnLevel;

			// convert signed level (0 - 100) to unsigned volume (0 - 65535)
			//
			dwVolume = nLevel * (0xFFFF / VOLUME_POSITIONS);

			lpmxcdu[0].dwValue = lpmxcdu[cChannels - 1].dwValue = dwVolume;

			TracePrintf_2(NULL, 5,
				TEXT("WavMixerSetVolume() = %d, 0x%08lX\n"),
				(int) nLevel,
				(unsigned long) dwVolume);

			if ((nLastError = mixerSetControlDetails((HMIXEROBJ) lpWavMixer->hMixer, &mxcd,
				MIXER_OBJECTF_HMIXER | MIXER_SETCONTROLDETAILSF_VALUE)) != MMSYSERR_NOERROR)
			{
				fSuccess = TraceFALSE(NULL);
				TracePrintf_1(NULL, 5,
					TEXT("mixerSetControlDetails failed (%u)\n"),
					(unsigned) nLastError);
			}
#if 1
			// save new volume to pass back
			//
			else if ((nLastError = mixerGetControlDetails((HMIXEROBJ) lpWavMixer->hMixer, &mxcd,
				MIXER_OBJECTF_HMIXER | MIXER_GETCONTROLDETAILSF_VALUE)) != MMSYSERR_NOERROR)
			{
				fSuccess = TraceFALSE(NULL);
				TracePrintf_1(NULL, 5,
					TEXT("mixerGetControlDetails failed (%u)\n"),
					(unsigned) nLastError);
			}
			else
				dwVolume = lpmxcdu[0].dwValue;
#endif
		}

		if (fSuccess &&
#if 1
			((dwFlags & WAVMIXER_GETVOLUME) || (dwFlags & WAVMIXER_SETVOLUME)))
#else
			(dwFlags & WAVMIXER_GETVOLUME))
#endif
		{
			// convert unsigned volume (0 - 65535) to signed level (0 - 100)
			//
			nLevel = LOWORD(dwVolume) / (0xFFFF / VOLUME_POSITIONS);

			if (lpnLevel != NULL)
				*lpnLevel = nLevel;

			TracePrintf_2(NULL, 5,
				TEXT("WavMixerGetVolume() = %d, 0x%08lX\n"),
				(int) nLevel,
				(unsigned long) dwVolume);
		}

		if (lpmxcdu != NULL && (lpmxcdu = MemFree(NULL, lpmxcdu)) != NULL)
			fSuccess = TraceFALSE(NULL);
	}

	// clean up
	//
	if (lpmxc != NULL && (lpmxc = MemFree(NULL, lpmxc)) != NULL)
		fSuccess = TraceFALSE(NULL);

	if (hWavMixer != NULL && lpWavMixer != NULL)
		lpWavMixer->nLastError = nLastError;

	return fSuccess ? 0 : -1;
}

// WavMixerSupportsLevel - return TRUE if device supports peak meter level
//		<hWavMixer>				(i) handle returned from WavMixerInit
//		<dwFlags>				(i) control flags
//			0						reserved; must be zero
// return TRUE if device supports peak meter level
//
BOOL WINAPI WavMixerSupportsLevel(HWAVMIXER hWavMixer, DWORD dwFlags)
{
	if (WavMixerLevel(hWavMixer, NULL, WAVMIXER_SUPPORTSLEVEL) != 0)
		return FALSE;
	else
		return TRUE;
}

// WavMixerGetLevel - get current peak meter level
//		<hWavMixer>			(i) handle returned from WavMixerInit
//		<dwFlags>				(i) control flags
//			0						reserved; must be zero
// return peak meter level (0 minimum through 100 maximum, -1 if error)
//
int WINAPI WavMixerGetLevel(HWAVMIXER hWavMixer, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	int nLevel;

	if (WavMixerLevel(hWavMixer, &nLevel, WAVMIXER_GETLEVEL) != 0)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? nLevel : -1;
}

static int WINAPI WavMixerLevel(HWAVMIXER hWavMixer, LPINT lpnLevel, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAVMIXER lpWavMixer;
	LPMIXERCONTROL lpmxc = NULL;

    //
    // Initialize local variable
    //

	UINT nLastError = 0;
	MIXERLINE mxlDst;
	MIXERLINE mxlSrc;
	BOOL fWaveIn = FALSE;

	if ((lpWavMixer = WavMixerGetPtr(hWavMixer)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpmxc = (LPMIXERCONTROL) MemAlloc(NULL, sizeof(MIXERCONTROL), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// get info for the destination line
	//
	if (fSuccess)
	{
		if ((lpWavMixer->dwFlags & WAVMIXER_WAVEIN) ||
			(lpWavMixer->dwFlags & WAVMIXER_HWAVEIN))
			fWaveIn = TRUE;

		mxlDst.cbStruct = sizeof(mxlDst);
		mxlDst.dwComponentType = fWaveIn ?
			MIXERLINE_COMPONENTTYPE_DST_WAVEIN :
			MIXERLINE_COMPONENTTYPE_DST_SPEAKERS;

		if ((nLastError = mixerGetLineInfo((HMIXEROBJ) lpWavMixer->hMixer, &mxlDst,
			MIXER_OBJECTF_HMIXER | MIXER_GETLINEINFOF_COMPONENTTYPE)) != MMSYSERR_NOERROR)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("mixerGetLineInfo failed (%u)\n"),
				(unsigned) nLastError);
		}
	}

	// find appropriate source line connected to this destination line
	//
	if (fSuccess)
	{
		DWORD dwSource;

		for (dwSource = 0; fSuccess && dwSource < mxlDst.cConnections; ++dwSource)
		{
			mxlSrc.cbStruct = sizeof(mxlSrc);
			mxlSrc.dwSource = dwSource;
			mxlSrc.dwDestination = mxlDst.dwDestination;

			if ((nLastError = mixerGetLineInfo((HMIXEROBJ) lpWavMixer->hMixer, &mxlSrc,
				MIXER_OBJECTF_HMIXER | MIXER_GETLINEINFOF_SOURCE)) != MMSYSERR_NOERROR)
			{
				fSuccess = TraceFALSE(NULL);
				TracePrintf_1(NULL, 5,
					TEXT("mixerGetLineInfo failed (%u)\n"),
					(unsigned) nLastError);
			}

			else if (mxlSrc.dwComponentType == (DWORD) (fWaveIn ?
				MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE :
				MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT))
			{
				// source line found
				//
				break;
			}
		}

		if (dwSource == mxlDst.cConnections)
		{
			// unable to find source line
			//
			fSuccess = TraceFALSE(NULL);
		}
	}

	// find peak meter control, if any, of the appropriate line
	//
	if (fSuccess)
	{
		MIXERLINECONTROLS mxlc;

		mxlc.cbStruct = sizeof(mxlc);
		mxlc.dwLineID = (fWaveIn ? mxlDst.dwLineID : mxlSrc.dwLineID);
		mxlc.dwControlType = MIXERCONTROL_CONTROLTYPE_PEAKMETER;
		mxlc.cControls = 1;
		mxlc.cbmxctrl = sizeof(MIXERCONTROL);
		mxlc.pamxctrl = lpmxc;

		if ((nLastError = mixerGetLineControls((HMIXEROBJ) lpWavMixer->hMixer, &mxlc,
			MIXER_OBJECTF_HMIXER | MIXER_GETLINECONTROLSF_ONEBYTYPE)) != MMSYSERR_NOERROR)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("mixerGetLineControls failed (%u)\n"),
				(unsigned) nLastError);
		}
	}

	// get current peak meter level
	//
	if (fSuccess && (dwFlags & WAVMIXER_GETLEVEL))
	{
		LPMIXERCONTROLDETAILS_SIGNED lpmxcds = NULL;
		MIXERCONTROLDETAILS mxcd;
		DWORD cChannels = mxlDst.cChannels;
		DWORD dwLevel;
		int nLevel;

		if (lpmxc->fdwControl & MIXERCONTROL_CONTROLF_UNIFORM)
			cChannels = 1;
		
		if ((lpmxcds = (LPMIXERCONTROLDETAILS_SIGNED) MemAlloc(NULL,
			cChannels * sizeof(MIXERCONTROLDETAILS_SIGNED), 0)) == NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}

		else
		{
			mxcd.cbStruct = sizeof(mxcd);
			mxcd.dwControlID = lpmxc->dwControlID;
			mxcd.cChannels = cChannels;
			mxcd.hwndOwner = (HWND) NULL;
			mxcd.cbDetails = sizeof(MIXERCONTROLDETAILS_SIGNED);
			mxcd.paDetails = (LPVOID) lpmxcds;

			if ((nLastError = mixerGetControlDetails((HMIXEROBJ) lpWavMixer->hMixer, &mxcd,
				MIXER_OBJECTF_HMIXER | MIXER_GETCONTROLDETAILSF_VALUE)) != MMSYSERR_NOERROR)
			{
				fSuccess = TraceFALSE(NULL);
				TracePrintf_1(NULL, 5,
					TEXT("mixerGetControlDetails failed (%u)\n"),
					(unsigned) nLastError);
			}
			else
			{
				// convert signed level to unsigned level
				//
				dwLevel = lpmxcds[0].lValue - 0; // lpmxc->Bounds.lMinimum;
				dwLevel *= 2;
			}
		}

		// convert unsigned level (0 - 65535) to signed level (0 - 100)
		//
		nLevel = LOWORD(dwLevel) / (0xFFFF / LEVEL_POSITIONS);

		if (lpnLevel != NULL)
			*lpnLevel = nLevel;

        //
        // We have to verify lpmxcds pointer
        //
		TracePrintf_3(NULL, 5,
			TEXT("WavMixerGetLevel() = %d, %ld, 0x%08lX\n"),
			(int) nLevel,
            lpmxcds ? lpmxcds[0].lValue : 0,
			(unsigned long) dwLevel);

		if (lpmxcds != NULL && (lpmxcds = MemFree(NULL, lpmxcds)) != NULL)
			fSuccess = TraceFALSE(NULL);
	}

	// clean up
	//
	if (lpmxc != NULL && (lpmxc = MemFree(NULL, lpmxc)) != NULL)
		fSuccess = TraceFALSE(NULL);

	if (hWavMixer != NULL && lpWavMixer != NULL)
		lpWavMixer->nLastError = nLastError;

	return fSuccess ? 0 : -1;
}

////
//	helper functions
////

// WavMixerGetPtr - verify that wavmixer handle is valid,
//		<hWavMixer>				(i) handle returned from WavMixerInit
// return corresponding wavmixer pointer (NULL if error)
//
static LPWAVMIXER WavMixerGetPtr(HWAVMIXER hWavMixer)
{
	BOOL fSuccess = TRUE;
	LPWAVMIXER lpWavMixer;

	if ((lpWavMixer = (LPWAVMIXER) hWavMixer) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpWavMixer, sizeof(WAVMIXER)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the wavmixer handle
	//
	else if (lpWavMixer->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpWavMixer : NULL;
}

// WavMixerGetHandle - verify that wavmixer pointer is valid,
//		<lpWavMixer>				(i) pointer to WAVMIXER struct
// return corresponding wavmixer handle (NULL if error)
//
static HWAVMIXER WavMixerGetHandle(LPWAVMIXER lpWavMixer)
{
	BOOL fSuccess = TRUE;

    //
    // we have to initialize local variable
    //

	HWAVMIXER hWavMixer = NULL;

	if ((hWavMixer = (HWAVMIXER) lpWavMixer) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hWavMixer : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\avwav\wavout.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	wavout.c - wav output device functions
////

#include "winlocal.h"

#include "wavout.h"
#include "wav.h"
#include "acm.h"
#include "calc.h"
#include "mem.h"
#include "str.h"
#include "sys.h"
#include "trace.h"
#include <mmddk.h>

// allow telephone output functions if defined
//
#ifdef TELOUT
#include "telout.h"
static HTELOUT hTelOut = NULL;
#endif

////
//	private definitions
////

#define WAVOUTCLASS TEXT("WavOutClass")

// wavout control struct
//
typedef struct WAVOUT
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	UINT idDev;
	LPWAVEFORMATEX lpwfx;
	HWND hwndNotify;
	DWORD dwFlags;
	BOOL fIsOpen;
	HWAVEOUT hWaveOut;
	WORD wState;
	HWND hwndCallback;
#ifdef MULTITHREAD
	HANDLE hThreadCallback;
	DWORD dwThreadId;
	HANDLE hEventThreadCallbackStarted;
	HANDLE hEventDeviceOpened;
	HANDLE hEventDeviceClosed;
	HANDLE hEventDeviceStopped;
	CRITICAL_SECTION critSectionStop;
#endif
	UINT nLastError;
	int cBufsPending;
} WAVOUT, FAR *LPWAVOUT;

#define VOLUME_MINLEVEL 0
#define VOLUME_MAXLEVEL 100
#define VOLUME_POSITIONS (VOLUME_MAXLEVEL - VOLUME_MINLEVEL)

// helper functions
//
LRESULT DLLEXPORT CALLBACK WavOutCallback(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
#ifdef MULTITHREAD
DWORD WINAPI WavOutCallbackThread(LPVOID lpvThreadParameter);
#endif
static LPWAVOUT WavOutGetPtr(HWAVOUT hWavOut);
static HWAVOUT WavOutGetHandle(LPWAVOUT lpWavOut);
#ifdef MULTITHREAD
static LRESULT SendThreadMessage(DWORD dwThreadId, UINT Msg, LPARAM lParam);
#endif

////
//	public functions
////

// WavOutGetDeviceCount - return number of wav output devices found
//		<void>				this function takes no arguments
// return number of wav output devices found (0 if none)
//
int DLLEXPORT WINAPI WavOutGetDeviceCount(void)
{
	return waveOutGetNumDevs();
}

// WavOutDeviceIsOpen - check if output device is open
//		<idDev>				(i) device id
//			-1					open any suitable output device
// return TRUE if open
//
BOOL DLLEXPORT WINAPI WavOutDeviceIsOpen(int idDev)
{
	BOOL fSuccess = TRUE;
	BOOL fIsOpen = FALSE;
	WAVEFORMATEX wfx;
	HWAVEOUT hWaveOut;
	int nLastError;

#ifdef TELOUT
	if (idDev == TELOUT_DEVICEID)
		return TelOutDeviceIsOpen(idDev);
#endif

	// try to open device
	//
	if ((nLastError = waveOutOpen(&hWaveOut, idDev, 
#ifndef _WIN32
			(LPWAVEFORMAT)
#endif
		WavFormatPcm(-1, -1, -1, &wfx),
		0, 0, WAVE_ALLOWSYNC)) != 0)
	{
		if (nLastError == MMSYSERR_ALLOCATED)
			fIsOpen = TRUE; // device in use

		else
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("waveOutOpen failed (%u)\n"),
				(unsigned) nLastError);
		}
	}

	// close device
	//
	else if (waveOutClose(hWaveOut) != 0)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? fIsOpen : FALSE;
}

// WavOutOpen - open wav output device
//		<dwVersion>			(i) must be WAVOUT_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<idDev>				(i) device id
//			-1					open any suitable output device
//		<lpwfx>				(i) wave format
//		<hwndNotify>		(i) notify this window of device events
//			NULL				do not notify
//		<msTimeoutOpen>		(i) device open timeout in milleseconds
//			0					default timeout (30000)
//		<msTimeoutRetry>	(i) device retry timeout in milleseconds
//			0					default timeout (2000)
//		<dwFlags>			(i) control flags
//			WAVOUT_NOSYNC		do not open synchronous devices
//			WAVOUT_AUTOFREE		free each buffer after playback
//			WAVOUT_OPENRETRY	retry if device busy
//			WAVOUT_OPENASYNC	return before notification of device open
//			WAVOUT_CLOSEASYNC	return before notification of device close
//			WAVOUT_NOACM		do not use audio compression manager
//			WAVOUT_TELRFILE		telephone will play/record audio on server
#ifdef MULTITHREAD
//			WAVOUT_MULTITHREAD	support multiple threads
#endif
// return handle (NULL if error)
//
// NOTE: if <hwndNotify> is specified in WavOutOpen,
// WM_WAVOUT_OPEN will be sent to <hwndNotify>,
// when output device has been opened.
//
// NOTE: if WAVOUT_MULTITHREAD is specified in <dwFlags>,
// it is assumed that <hwndNotify> is not a window handle,
// but rather the id of the thread to receive notifications
//
HWAVOUT DLLEXPORT WINAPI WavOutOpen(DWORD dwVersion, HINSTANCE hInst,
	int idDev, LPWAVEFORMATEX lpwfx, HWND hwndNotify,
	DWORD msTimeoutOpen, DWORD msTimeoutRetry, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut = NULL;
	WNDCLASS wc;

#ifdef TELOUT
	if (idDev == TELOUT_DEVICEID)
	{
		hTelOut = TelOutOpen(TELOUT_VERSION, hInst, idDev, lpwfx,
			hwndNotify, msTimeoutOpen, msTimeoutRetry, dwFlags);
		return (HWAVOUT) hTelOut;
	}
#endif

	if (dwVersion != WAVOUT_VERSION)
		fSuccess = TraceFALSE(NULL);
	
	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpWavOut = (LPWAVOUT) MemAlloc(NULL, sizeof(WAVOUT), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lpWavOut->dwVersion = dwVersion;
		lpWavOut->hInst = hInst;
		lpWavOut->hTask = GetCurrentTask();
		lpWavOut->idDev = (UINT) idDev;
		lpWavOut->lpwfx = NULL;
		lpWavOut->hwndNotify = hwndNotify;
		lpWavOut->dwFlags = dwFlags;
		lpWavOut->fIsOpen = FALSE;
		lpWavOut->hWaveOut = NULL;
		lpWavOut->wState = WAVOUT_STOPPED;
		lpWavOut->hwndCallback = NULL;
#ifdef MULTITHREAD
		lpWavOut->hThreadCallback = NULL;
		lpWavOut->dwThreadId = 0;
		lpWavOut->hEventThreadCallbackStarted = NULL;
		lpWavOut->hEventDeviceOpened = NULL;
		lpWavOut->hEventDeviceClosed = NULL;
		lpWavOut->hEventDeviceStopped = NULL;
#endif
		lpWavOut->nLastError = 0;
		lpWavOut->cBufsPending = 0;

		// memory is allocated such that the client app owns it
		//
		if ((lpWavOut->lpwfx = WavFormatDup(lpwfx)) == NULL)
			fSuccess = TraceFALSE(NULL);
	}

#ifdef MULTITHREAD
	// handle WAVOUT_MULTITHREAD flag
	//
	if (fSuccess && (lpWavOut->dwFlags & WAVOUT_MULTITHREAD))
	{
		DWORD dwRet;

		InitializeCriticalSection(&(lpWavOut->critSectionStop));

		// we need to know when device has been opened
		//
		if ((lpWavOut->hEventDeviceOpened = CreateEvent(
			NULL, FALSE, FALSE, NULL)) == NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}

		// we need to know when callback thread begins execution
		//
		else if ((lpWavOut->hEventThreadCallbackStarted = CreateEvent(
			NULL, FALSE, FALSE, NULL)) == NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}

		// create the callback thread
		//
		else if ((lpWavOut->hThreadCallback = CreateThread(
			NULL,
			0,
			WavOutCallbackThread,
			(LPVOID) lpWavOut,
			0,
			&lpWavOut->dwThreadId)) == NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}

		// wait for the callback thread to begin execution
		//
		else if ((dwRet = WaitForSingleObject(
			lpWavOut->hEventThreadCallbackStarted, 10000)) != WAIT_OBJECT_0)
		{
			fSuccess = TraceFALSE(NULL);
		}

		// clean up
		//
		if (lpWavOut->hEventThreadCallbackStarted != NULL)
		{
			if (!CloseHandle(lpWavOut->hEventThreadCallbackStarted))
				fSuccess = TraceFALSE(NULL);
			else
				lpWavOut->hEventThreadCallbackStarted = NULL;
		}
	}
	else
#endif
	{
		// register callback class unless it has been already
		//
		if (fSuccess && GetClassInfo(lpWavOut->hInst, WAVOUTCLASS, &wc) == 0)
		{
			wc.hCursor =		NULL;
			wc.hIcon =			NULL;
			wc.lpszMenuName =	NULL;
			wc.hInstance =		lpWavOut->hInst;
			wc.lpszClassName =	WAVOUTCLASS;
			wc.hbrBackground =	NULL;
			wc.lpfnWndProc =	WavOutCallback;
			wc.style =			0L;
			wc.cbWndExtra =		sizeof(lpWavOut);
			wc.cbClsExtra =		0;

			if (!RegisterClass(&wc))
				fSuccess = TraceFALSE(NULL);
		}

		// create the callback window
		//
		if (fSuccess && (lpWavOut->hwndCallback = CreateWindowEx(
			0L,
			WAVOUTCLASS,
			NULL,
			0L,
			0, 0, 0, 0,
			NULL,
			NULL,
			lpWavOut->hInst,
			lpWavOut)) == NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}
	}

	if (fSuccess)
	{
		DWORD dwTimeout = SysGetTimerCount() +
			(msTimeoutRetry == 0 ? 2000L : msTimeoutRetry);
		DWORD dwCallback;
		DWORD dwFlags;

#ifdef MULTITHREAD
		if (lpWavOut->dwFlags & WAVOUT_MULTITHREAD)
		{
			dwCallback = lpWavOut->dwThreadId;
			dwFlags = CALLBACK_THREAD;
		}
		else
#endif
		{
			dwCallback = HandleToUlong(lpWavOut->hwndCallback);
			dwFlags = CALLBACK_WINDOW;
		}

		// allow synchronous device drivers unless WAVOUT_NOSYNC specified
		//
		if (!(lpWavOut->dwFlags & WAVOUT_NOSYNC))
			dwFlags |= WAVE_ALLOWSYNC;

		// open the device
		//
		while (fSuccess && (lpWavOut->nLastError = waveOutOpen(&lpWavOut->hWaveOut,
			(UINT) lpWavOut->idDev,
#ifndef _WIN32
			(LPWAVEFORMAT)
#endif
			lpWavOut->lpwfx, dwCallback, 0, dwFlags)) != 0)
		{
			// no need to retry unless the device is busy
			//
			if (lpWavOut->nLastError != MMSYSERR_ALLOCATED)
			{
				fSuccess = TraceFALSE(NULL);
				TracePrintf_1(NULL, 5,
					TEXT("waveOutOpen failed (%u)\n"),
					(unsigned) lpWavOut->nLastError);
			}

			// no need to retry if flag not set
			//
			else if (!(lpWavOut->dwFlags & WAVOUT_OPENRETRY))
				fSuccess = TraceFALSE(NULL);

			// no more retries if timeout occurred
			//
			else if (SysGetTimerCount() >= dwTimeout)
				fSuccess = TraceFALSE(NULL);

			else
			{
				MSG msg;

				if (PeekMessage(&msg, lpWavOut->hwndCallback, 0, 0, PM_REMOVE))
				{
				 	TranslateMessage(&msg);
				 	DispatchMessage(&msg);
				}

				else
#ifdef _WIN32
					Sleep(100);
#else
        		    WaitMessage();
#endif
			}
		}
	}

	// make sure a handle was returned
	//
	if (fSuccess && lpWavOut->hWaveOut == NULL)
		fSuccess = TraceFALSE(NULL);

	// wait for device open notification or timeout
	//
	if (fSuccess && !(lpWavOut->dwFlags & WAVOUT_OPENASYNC))
	{
		DWORD dwTimeout = SysGetTimerCount() +
			(msTimeoutOpen == 0 ? 2000L : msTimeoutOpen);

#ifdef MULTITHREAD
		if (lpWavOut->dwFlags & WAVOUT_MULTITHREAD)
		{
			DWORD dwRet;

			// wait for the device to be opened
			//
			if ((dwRet = WaitForSingleObject(
				lpWavOut->hEventDeviceOpened,
				(msTimeoutOpen == 0 ? 30000L : msTimeoutOpen))) != WAIT_OBJECT_0)
			{
				fSuccess = TraceFALSE(NULL);
			}
		}
		else
#endif
		while (fSuccess && !lpWavOut->fIsOpen)
		{
			MSG msg;

			if (SysGetTimerCount() >= dwTimeout)
				fSuccess = TraceFALSE(NULL);

			else if (PeekMessage(&msg, lpWavOut->hwndCallback, 0, 0, PM_REMOVE))
			{
			 	TranslateMessage(&msg);
			 	DispatchMessage(&msg);
			}

			else
        	    WaitMessage();
		}
	}

#ifdef MULTITHREAD
	// clean up
	//
	if (lpWavOut != NULL && lpWavOut->hEventDeviceOpened != NULL)
	{
		if (!CloseHandle(lpWavOut->hEventDeviceOpened))
			fSuccess = TraceFALSE(NULL);
		else
			lpWavOut->hEventDeviceOpened = NULL;
	}
#endif

	if (fSuccess)
	{
		if ((lpWavOut->nLastError = waveOutGetID(lpWavOut->hWaveOut,
			&lpWavOut->idDev)) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("waveOutGetID failed (%u)\n"),
				(unsigned) lpWavOut->nLastError);
		}
	}

	if (!fSuccess)
	{
		WavOutClose(WavOutGetHandle(lpWavOut), 0);
		lpWavOut = NULL;
	}

	return fSuccess ? WavOutGetHandle(lpWavOut) : NULL;
}

// WavOutClose - close wav output device
//		<hWavOut>			(i) handle returned from WavOutOpen
//		<msTimeoutClose>	(i) device close timeout in milleseconds
//			0					default timeout (30000)
// return 0 if success
//
// NOTE: if <hwndNotify> was specified in WavOutOpen,
// WM_WAVOUT_CLOSE will be sent to <hwndNotify>,
// when output device has been closed.
//
int DLLEXPORT WINAPI WavOutClose(HWAVOUT hWavOut, DWORD msTimeoutClose)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;

#ifdef TELOUT
	if (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut)
	{
		int iRet = TelOutClose((HTELOUT) hWavOut, msTimeoutClose);
		hTelOut = NULL;
		return iRet;
	}
#endif

	if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// stop the device
	//
	else if (WavOutStop(hWavOut, 0) != 0)
		fSuccess = TraceFALSE(NULL);

#ifdef MULTITHREAD
	// we need to know when device has been closed
	//
	else if ((lpWavOut->dwFlags & WAVOUT_MULTITHREAD) &&
		(lpWavOut->hEventDeviceClosed = CreateEvent(
		NULL, FALSE, FALSE, NULL)) == NULL)
	{
		fSuccess = TraceFALSE(NULL);
	}
#endif

	// close the device
	//
	else if (lpWavOut->hWaveOut != NULL &&
		(lpWavOut->nLastError = waveOutClose(lpWavOut->hWaveOut)) != 0)
	{
		fSuccess = TraceFALSE(NULL);
	 	TracePrintf_1(NULL, 5,
	 		TEXT("wavOutClose failed (%u)\n"),
	 		(unsigned) lpWavOut->nLastError);
	}

	// wait for device close notification or timeout
	//
	if (fSuccess && !(lpWavOut->dwFlags & WAVOUT_CLOSEASYNC))
	{
		DWORD dwTimeout = SysGetTimerCount() +
			(msTimeoutClose == 0 ? 30000L : msTimeoutClose);

#ifdef MULTITHREAD
		if (lpWavOut->dwFlags & WAVOUT_MULTITHREAD)
		{
			DWORD dwRet;

			// wait for the device to be closed
			//
			if ((dwRet = WaitForSingleObject(
				lpWavOut->hEventDeviceClosed,
				(msTimeoutClose == 0 ? 30000L : msTimeoutClose))) != WAIT_OBJECT_0)
			{
				fSuccess = TraceFALSE(NULL);
			}
		}
		else
#endif
		while (fSuccess && lpWavOut->fIsOpen)
		{
			MSG msg;

			if (SysGetTimerCount() >= dwTimeout)
				fSuccess = TraceFALSE(NULL);

			else if (PeekMessage(&msg, lpWavOut->hwndCallback, 0, 0, PM_REMOVE))
			{
			 	TranslateMessage(&msg);
			 	DispatchMessage(&msg);
			}

			else
        	    WaitMessage();
		}
	}

#ifdef MULTITHREAD
	// clean up
	//
	if (lpWavOut != NULL && lpWavOut->hEventDeviceClosed != NULL)
	{
		if (!CloseHandle(lpWavOut->hEventDeviceClosed))
			fSuccess = TraceFALSE(NULL);
		else
			lpWavOut->hEventDeviceClosed = NULL;
	}

	if (lpWavOut != NULL && lpWavOut->hThreadCallback != NULL)
	{
		if (!CloseHandle(lpWavOut->hThreadCallback))
			fSuccess = TraceFALSE(NULL);
		else
			lpWavOut->hThreadCallback = NULL;
	}
#endif

	if (fSuccess)
	{
#ifdef MULTITHREAD
	   	if (lpWavOut->dwFlags & WAVOUT_MULTITHREAD)
		{
			while (lpWavOut->critSectionStop.OwningThread != NULL)
				Sleep(100L);

			DeleteCriticalSection(&(lpWavOut->critSectionStop));
		}
#endif
		// device handle is no longer valid
		//
		lpWavOut->hWaveOut = NULL;

		// destroy callback window
		//
		if (lpWavOut->hwndCallback != NULL &&
			!DestroyWindow(lpWavOut->hwndCallback))
			fSuccess = TraceFALSE(NULL);

		else if (lpWavOut->hwndCallback = NULL, FALSE)
			fSuccess = TraceFALSE(NULL);

		else if (lpWavOut->lpwfx != NULL &&
			WavFormatFree(lpWavOut->lpwfx) != 0)
			fSuccess = TraceFALSE(NULL);

		else if (lpWavOut->lpwfx = NULL, FALSE)
			fSuccess = TraceFALSE(NULL);

		else if ((lpWavOut = MemFree(NULL, lpWavOut)) != NULL)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// WavOutPlay - submit buffer of samples to wav output device for playback
//		<hWavOut>			(i) handle returned from WavOutOpen
//		<lpBuf>				(i) pointer to buffer containing samples
//		<sizBuf>			(i) size of buffer in bytes
// return 0 if success
//
// NOTE: the buffer pointed to by <lpBuf> must have been allocated
// using MemAlloc().
//
// NOTE: if <hwndNotify> is specified in WavOutOpen(), a WM_WAVOUT_PLAYDONE
// message will be sent to <hwndNotify>, with <lParam> set to a pointer to
// a PLAYDONE structure, when <lpBuf> has been played.
//
// NOTE: if WAVOUT_AUTOFREE flag is specified in WavOutOpen,
// GlobalFreePtr(lpBuf) will be called when <lpBuf> has been played.
//
int DLLEXPORT WINAPI WavOutPlay(HWAVOUT hWavOut, LPVOID lpBuf, long sizBuf)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;
	LPWAVEHDR lpWaveHdr = NULL;

#ifdef TELOUT
	if (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut)
		return TelOutPlay((HTELOUT) hWavOut, lpBuf, sizBuf, -1);
#endif

	if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpBuf == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpWaveHdr = (LPWAVEHDR) MemAlloc(NULL,
		sizeof(WAVEHDR), 0)) == NULL)
	{
		fSuccess = TraceFALSE(NULL);
	}

	else
	{
		lpWaveHdr->lpData = (LPSTR) lpBuf;
		lpWaveHdr->dwBufferLength = (DWORD) sizBuf;

		if ((lpWavOut->nLastError = waveOutPrepareHeader(lpWavOut->hWaveOut,
			lpWaveHdr, sizeof(WAVEHDR))) != 0)
		{
			fSuccess = TraceFALSE(NULL);
		 	TracePrintf_1(NULL, 5,
		 		TEXT("waveOutPrepareHeader failed (%u)\n"),
	 			(unsigned) lpWavOut->nLastError);
		}

		else if ((lpWavOut->nLastError = waveOutWrite(lpWavOut->hWaveOut,
			lpWaveHdr, sizeof(WAVEHDR))) != 0)
		{
			fSuccess = TraceFALSE(NULL);
		 	TracePrintf_1(NULL, 5,
		 		TEXT("waveOutWrite failed (%u)\n"),
	 			(unsigned) lpWavOut->nLastError);
		}

		else
		{
			++lpWavOut->cBufsPending;
			lpWavOut->wState = WAVOUT_PLAYING;
		}
	}

	return fSuccess ? 0 : -1;
}

// WavOutStop - stop playback of buffer(s) sent to wav output device
//		<hWavOut>			(i) handle returned from WavOutOpen
//		<msTimeoutStop>		(i) device stop timeout in milleseconds
//			0					default timeout (2000)
// return 0 if success
//
int DLLEXPORT WINAPI WavOutStop(HWAVOUT hWavOut, DWORD msTimeoutStop)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;

#ifdef TELOUT
	if (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut)
		return TelOutStop((HTELOUT) hWavOut, msTimeoutStop);
#endif

	if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
		fSuccess = TraceFALSE(NULL);

#ifdef MULTITHREAD
	else if ((lpWavOut->dwFlags & WAVOUT_MULTITHREAD) &&
		(EnterCriticalSection(&(lpWavOut->critSectionStop)), FALSE))
		;
#endif

	// make sure device is playing or paused
	//
	else if (WavOutGetState(hWavOut) == WAVOUT_STOPPED ||
		WavOutGetState(hWavOut) == WAVOUT_STOPPING)
		; // not an error to call this function when stopped or stopping

	else if (lpWavOut->wState = WAVOUT_STOPPING, FALSE)
		;

#ifdef MULTITHREAD
	// we need to know when device has been stopped
	//
	else if ((lpWavOut->dwFlags & WAVOUT_MULTITHREAD) &&
		(lpWavOut->hEventDeviceStopped = CreateEvent(
			NULL, FALSE, FALSE, NULL)) == NULL)
	{
		fSuccess = TraceFALSE(NULL);
	}
#endif

	// stop the device
	//
	else if ((lpWavOut->nLastError = waveOutReset(lpWavOut->hWaveOut)) != 0)
	{	
		fSuccess = TraceFALSE(NULL);
 		TracePrintf_1(NULL, 5,
 			TEXT("waveOutReset failed (%u)\n"),
			(unsigned) lpWavOut->nLastError);
	}

	// wait for device to be stopped
	//
#ifdef MULTITHREAD
	else if (lpWavOut->dwFlags & WAVOUT_MULTITHREAD)
	{
		DWORD dwRet;

		LeaveCriticalSection(&(lpWavOut->critSectionStop));

		// wait for the device to be stopped
		//
		if ((dwRet = WaitForSingleObject(
			lpWavOut->hEventDeviceStopped,
			(msTimeoutStop == 0 ? 10000L : msTimeoutStop))) != WAIT_OBJECT_0)
		{
			fSuccess = TraceFALSE(NULL);
		}

		EnterCriticalSection(&(lpWavOut->critSectionStop));
	}
#endif
	else
	{
		DWORD dwTimeout = SysGetTimerCount() +
			(msTimeoutStop == 0 ? 2000L : msTimeoutStop);

		while (fSuccess && WavOutGetState(hWavOut) != WAVOUT_STOPPED)
		{
			MSG msg;

			// check for timeout
			//
			if (SysGetTimerCount() >= dwTimeout)
				fSuccess = TraceFALSE(NULL);

#if 0 // this version doesn't seem to work with TCP/IP protocol
			else if (PeekMessage(&msg, lpWavOut->hwndCallback, 0, 0, PM_REMOVE))
#else
			else if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
#endif
			{
		 		TranslateMessage(&msg);
		 		DispatchMessage(&msg);
			}

			else
       			WaitMessage();
		}
	}

#ifdef MULTITHREAD
	// clean up
	//
	if (lpWavOut != NULL && lpWavOut->hEventDeviceStopped != NULL)
	{
		if (!CloseHandle(lpWavOut->hEventDeviceStopped))
			fSuccess = TraceFALSE(NULL);
		else
			lpWavOut->hEventDeviceStopped = NULL;
	}

	if (lpWavOut != NULL && (lpWavOut->dwFlags & WAVOUT_MULTITHREAD))
		LeaveCriticalSection(&(lpWavOut->critSectionStop));
#endif

	return fSuccess ? 0 : -1;
}

// WavOutPause - pause wav output device playback
//		<hWavOut>			(i) handle returned from WavOutOpen
// return 0 if success
//
int DLLEXPORT WINAPI WavOutPause(HWAVOUT hWavOut)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;

#ifdef TELOUT
	if (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut)
		return TelOutPause((HTELOUT) hWavOut);
#endif

	if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// make sure device is playing or stopped
	//
	else if (WavOutGetState(hWavOut) == WAVOUT_PAUSED)
		; // not an error to call this function when already paused

	// pause the device
	//
	else if ((lpWavOut->nLastError = waveOutPause(lpWavOut->hWaveOut)) != 0)
	{
		fSuccess = TraceFALSE(NULL);
	 	TracePrintf_1(NULL, 5,
	 		TEXT("waveOutPause failed (%u)\n"),
 			(unsigned) lpWavOut->nLastError);
	}

	else
		lpWavOut->wState = WAVOUT_PAUSED;

	return fSuccess ? 0 : -1;
}

// WavOutResume - resume wav output device playback
//		<hWavOut>			(i) handle returned from WavOutOpen
// return 0 if success
//
int DLLEXPORT WINAPI WavOutResume(HWAVOUT hWavOut)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;

#ifdef TELOUT
	if (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut)
		return TelOutResume((HTELOUT) hWavOut);
#endif

	if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// make sure the device is paused
	//
	else if (WavOutGetState(hWavOut) != WAVOUT_PAUSED)
		; // not an error to call this function when already playing

	// restart the device
	//
	else if ((lpWavOut->nLastError = waveOutRestart(lpWavOut->hWaveOut)) != 0)
	{
		fSuccess = TraceFALSE(NULL);
	  	TracePrintf_1(NULL, 5,
	  		TEXT("waveOutRestart failed (%u)\n"),
	 		(unsigned) lpWavOut->nLastError);
	}

	else
		lpWavOut->wState = WAVOUT_PLAYING;

	return fSuccess ? 0 : -1;
}

// WavOutGetState - return current wav output device state
//		<hWavOut>			(i) handle returned from WavOutOpen
// return WAVOUT_STOPPED, WAVOUT_PLAYING, WAVOUT_PAUSED, or 0 if error
//
WORD DLLEXPORT WINAPI WavOutGetState(HWAVOUT hWavOut)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;

#ifdef TELOUT
	if (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut)
		return TelOutGetState((HTELOUT) hWavOut);
#endif

	if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lpWavOut->wState : 0;
}

// WavOutGetPosition - get milleseconds of elapsed playback
//		<hWavOut>			(i) handle returned from WavOutOpen
// return 0 if success
//
long DLLEXPORT WINAPI WavOutGetPosition(HWAVOUT hWavOut)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;
	MMTIME mmtime;
	long msPosition;

#ifdef TELOUT
	if (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut)
		return TelOutGetPosition((HTELOUT) hWavOut);
#endif

	MemSet(&mmtime, 0, sizeof(mmtime));

	// we will be requesting position in milleseconds
	//
	mmtime.wType = TIME_MS;

	if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// get device position
	//
	else if ((lpWavOut->nLastError = waveOutGetPosition(
		lpWavOut->hWaveOut, &mmtime, sizeof(MMTIME))) != 0)
	{
		fSuccess = TraceFALSE(NULL);
	 	TracePrintf_1(NULL, 5,
	 		TEXT("waveOutGetPosition failed (%u)\n"),
 			(unsigned) lpWavOut->nLastError);
	}

	// see what type of position was returned
	//
	else switch (mmtime.wType)
	{
		case TIME_MS:
		{
			// we got milleseconds; no conversion required
			//
			msPosition = (long) mmtime.u.ms;
		}
			break;

		case TIME_SAMPLES:
		{
			// convert samples to millesconds
			//
			msPosition = (long) MULDIVU32(mmtime.u.sample,
				1000L, lpWavOut->lpwfx->nSamplesPerSec);
		}
			break;

		case TIME_BYTES:
		{
			// convert bytes to millesconds
			//
			msPosition = (long) MULDIVU32(mmtime.u.cb,
				1000L, lpWavOut->lpwfx->nAvgBytesPerSec);
		}
			break;

		case TIME_SMPTE:
		case TIME_MIDI:
		default:
			fSuccess = TraceFALSE(NULL);
			break;
	}

	return fSuccess ? msPosition : -1;
}

// WavOutGetId - return id of wav output device
//		<hWavOut>			(i) handle returned from WavOutOpen
// return device id (-1 if error)
//
int DLLEXPORT WINAPI WavOutGetId(HWAVOUT hWavOut)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;

#ifdef TELOUT
	if (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut)
		return TelOutGetId((HTELOUT) hWavOut);
#endif

	if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lpWavOut->idDev : -1;
}

// WavOutGetName - get name of wav output device
//		<hWavOut>			(i) handle returned from WavOutOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavOut> is not NULL)
//			-1					any suitable output device
//		<lpszName>			(o) buffer to hold device name
//		<sizName>			(i) size of buffer
// return 0 if success
//
int DLLEXPORT WINAPI WavOutGetName(HWAVOUT hWavOut, int idDev, LPTSTR lpszName, int sizName)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;

#ifdef TELOUT
	if (idDev == TELOUT_DEVICEID || (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut))
		return TelOutGetName((HTELOUT) hWavOut, idDev, lpszName, sizName);
#endif

	if (hWavOut != NULL)
	{
		if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
			fSuccess = TraceFALSE(NULL);
		else
			idDev = lpWavOut->idDev;
	}

	if (fSuccess)
	{
		WAVEOUTCAPS woc;
		UINT nLastError;

		if ((nLastError = waveOutGetDevCaps(idDev, &woc, sizeof(WAVEOUTCAPS))) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("waveOutGetDevCaps failed (%u)\n"),
				(unsigned) nLastError);
		}

		else if (lpszName != NULL)
			StrNCpy(lpszName, woc.szPname, sizName);

		if (hWavOut != NULL && lpWavOut != NULL)
			lpWavOut->nLastError = nLastError;
	}

	return fSuccess ? 0 : -1;
}

// WavOutGetIdByName - get id of wav output device, lookup by name
//		<lpszName>			(i) device name
#ifdef _WIN32
//			NULL or TEXT("")	get preferred device id
#endif
//		<dwFlags>			(i) reserved; must be zero
// return device id (-1 if error)
//
int WINAPI WavOutGetIdByName(LPCTSTR lpszName, DWORD dwFlags)
{
	UINT idDev;
	UINT cDev = (UINT) WavInGetDeviceCount();

	// If no device specified, get the preferred device
	if ( !lpszName || (_tcslen(lpszName) <= 0) )
	{
		DWORD dwTemp;
		DWORD dwRet = waveOutMessage( (HWAVEOUT)(DWORD_PTR)WAVE_MAPPER, DRVM_MAPPER_PREFERRED_GET, (DWORD_PTR) &idDev, (DWORD_PTR) &dwTemp );
		if ( dwRet == MMSYSERR_NOERROR )
			return idDev;
	}
	else
	{
		// Device specified, search by name
		for ( idDev = 0; idDev < cDev; ++idDev )
		{
			TCHAR szName[256];
			if ( WavOutGetName(NULL, idDev, szName, SIZEOFARRAY(szName)) == 0 )
			{
				if ( _tcsicmp(lpszName, szName) == 0 )
					return idDev;
			}
		}
	}

	// No match for device name
	TraceFALSE(NULL);
	return -1;
}

// WavOutSupportsFormat - return TRUE if device supports specified format
//		<hWavOut>			(i) handle returned from WavOutOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavOut> is not NULL)
//			-1					any suitable output device
//		<lpwfx>				(i) wave format
// return TRUE if device supports specified format
//
BOOL DLLEXPORT WINAPI WavOutSupportsFormat(HWAVOUT hWavOut, int idDev,
	LPWAVEFORMATEX lpwfx)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;
	BOOL fSupportsFormat;

#ifdef TELOUT
	if (idDev == TELOUT_DEVICEID || (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut))
		return TelOutSupportsFormat((HTELOUT) hWavOut, idDev, lpwfx);
#endif

	if (hWavOut != NULL)
	{
		if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
			fSuccess = TraceFALSE(NULL);
		else
			idDev = lpWavOut->idDev;
	}

	if (fSuccess)
	{
		UINT nLastError;

		// query the device
		//
		if ((nLastError = waveOutOpen(NULL, (UINT) idDev,
#ifndef _WIN32
			(LPWAVEFORMAT)
#endif
			lpwfx, 0, 0,
			WAVE_FORMAT_QUERY | WAVE_ALLOWSYNC)) != 0)
		{
			fSupportsFormat = FALSE;
#if 1
			if (TraceGetLevel(NULL) >= 9)
			{
				TracePrintf_0(NULL, 9,
					TEXT("unsupported format:\n"));
				WavFormatDump(lpwfx);
			}
#endif
			if (nLastError != WAVERR_BADFORMAT)
			{
				fSuccess = TraceFALSE(NULL);
				TracePrintf_1(NULL, 5,
					TEXT("waveOutOpen/FormatQuery failed (%u)\n"),
					(unsigned) nLastError);
			}
		}

		else
			fSupportsFormat = TRUE;

		if (hWavOut != NULL && lpWavOut != NULL)
			lpWavOut->nLastError = nLastError;
	}

	return fSuccess ? fSupportsFormat : FALSE;
}

// WavOutFormatSuggest - suggest a new format which the device supports
//		<hWavOut>			(i) handle returned from WavOutOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavOut> is not NULL)
//			-1					any suitable output device
//		<lpwfxSrc>			(i) source format
//		<dwFlags>			(i)	control flags
//			WAVOUT_NOACM		do not use audio compression manager
// return pointer to suggested format, NULL if error
//
// NOTE: the format structure returned is dynamically allocated.
// Use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI WavOutFormatSuggest(
	HWAVOUT hWavOut, int idDev,	LPWAVEFORMATEX lpwfxSrc, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;
	LPWAVEFORMATEX lpwfxSuggest = NULL;
	LPWAVEFORMATEX lpwfxTemp = NULL;
	HACM hAcm = NULL;

#ifdef TELOUT
	if (idDev == TELOUT_DEVICEID || (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut))
		return TelOutFormatSuggest((HTELOUT) hWavOut, idDev, lpwfxSrc, dwFlags);
#endif

	if (hWavOut != NULL)
	{
		if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
			fSuccess = TraceFALSE(NULL);
		else
		{
			idDev = lpWavOut->idDev;
			if (lpWavOut->dwFlags & WAVOUT_NOACM)
				dwFlags |= WAVOUT_NOACM;
		}
	}

	if ((hAcm = AcmInit(ACM_VERSION, SysGetTaskInstance(NULL),
		(dwFlags & WAVOUT_NOACM) ? ACM_NOACM : 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (!WavFormatIsValid(lpwfxSrc))
		fSuccess = TraceFALSE(NULL);

	else if ((lpwfxTemp = WavFormatDup(lpwfxSrc)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// get suggested format, see if it is supported
	//
	if (fSuccess && lpwfxSuggest == NULL)
	{
		if ((lpwfxSuggest = AcmFormatSuggest(hAcm, lpwfxTemp,
			-1, -1, -1, -1, 0)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if (WavFormatFree(lpwfxTemp) != 0)
			fSuccess = TraceFALSE(NULL);

		else if (!WavOutSupportsFormat(NULL, idDev, lpwfxSuggest))
		{
			lpwfxTemp = lpwfxSuggest;
			lpwfxSuggest = NULL;
		}
	}

	// get suggested PCM format, see if it is supported
	//
	if (fSuccess && lpwfxSuggest == NULL &&
		lpwfxTemp->wFormatTag != WAVE_FORMAT_PCM)
	{
		if ((lpwfxSuggest = AcmFormatSuggest(hAcm, lpwfxTemp,
			WAVE_FORMAT_PCM, -1, -1, -1, 0)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if (WavFormatFree(lpwfxTemp) != 0)
			fSuccess = TraceFALSE(NULL);

		else if (!WavOutSupportsFormat(NULL, idDev, lpwfxSuggest))
		{
			lpwfxTemp = lpwfxSuggest;
			lpwfxSuggest = NULL;
		}
	}

	// get suggested PCM mono format, see if it is supported
	//
	if (fSuccess && lpwfxSuggest == NULL &&
		lpwfxTemp->nChannels != 1)
	{
		if ((lpwfxSuggest = AcmFormatSuggest(hAcm, lpwfxTemp,
			WAVE_FORMAT_PCM, -1, -1, 1, 0)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if (WavFormatFree(lpwfxTemp) != 0)
			fSuccess = TraceFALSE(NULL);

		else if (!WavOutSupportsFormat(NULL, idDev, lpwfxSuggest))
		{
			lpwfxTemp = lpwfxSuggest;
			lpwfxSuggest = NULL;
		}
	}

	// get suggested PCM 8-bit mono format, see if it is supported
	//
	if (fSuccess && lpwfxSuggest == NULL &&
		lpwfxTemp->wBitsPerSample != 8)
	{
		if ((lpwfxSuggest = AcmFormatSuggest(hAcm, lpwfxTemp,
			WAVE_FORMAT_PCM, -1, 8, 1, 0)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if (WavFormatFree(lpwfxTemp) != 0)
			fSuccess = TraceFALSE(NULL);

		else if (!WavOutSupportsFormat(NULL, idDev, lpwfxSuggest))
		{
			lpwfxTemp = lpwfxSuggest;
			lpwfxSuggest = NULL;
		}
	}

	// get suggested PCM 11025Hz 8-bit mono format, see if it is supported
	//
	if (fSuccess && lpwfxSuggest == NULL &&
		lpwfxTemp->nSamplesPerSec != 11025)
	{
		if ((lpwfxSuggest = AcmFormatSuggest(hAcm, lpwfxTemp,
			WAVE_FORMAT_PCM, 11025, 8, 1, 0)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if (WavFormatFree(lpwfxTemp) != 0)
			fSuccess = TraceFALSE(NULL);

		else if (!WavOutSupportsFormat(NULL, idDev, lpwfxSuggest))
		{
			lpwfxTemp = lpwfxSuggest;
			lpwfxSuggest = NULL;
		}
	}

	// last resort; see if MULAW 8000Hz 8-bit mono format is supported
	//
	if (fSuccess && lpwfxSuggest == NULL)
	{
#if 0
		if ((lpwfxSuggest = AcmFormatSuggest(hAcm, lpwfxTemp,
			WAVE_FORMAT_MULAW, 8000, 8, 1, 0)) == NULL)
#else
		if ((lpwfxSuggest = WavFormatMulaw(NULL, 8000)) == NULL)
#endif
			fSuccess = TraceFALSE(NULL);

		else if (WavFormatFree(lpwfxTemp) != 0)
			fSuccess = TraceFALSE(NULL);

		else if (!WavOutSupportsFormat(NULL, idDev, lpwfxSuggest))
		{
			// no more chances for success
			//
			fSuccess = TraceFALSE(NULL);
			if (WavFormatFree(lpwfxSuggest) != 0)
				fSuccess = TraceFALSE(NULL);
		}
	}

	// clean up
	//
	if (hAcm != NULL && AcmTerm(hAcm) != 0)
		fSuccess = TraceFALSE(NULL);
	else
		hAcm = NULL;

	return fSuccess ? lpwfxSuggest : NULL;
}

// WavOutIsSynchronous - return TRUE if wav output device is synchronous
//		<hWavOut>			(i) handle returned from WavOutOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavOut> is not NULL)
//			-1					any suitable output device
// return TRUE if wav output device is synchronous
//
BOOL DLLEXPORT WINAPI WavOutIsSynchronous(HWAVOUT hWavOut, int idDev)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;
	BOOL fIsSynchronous;

#ifdef TELOUT
	if (idDev == TELOUT_DEVICEID || (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut))
		return TelOutIsSynchronous((HTELOUT) hWavOut, idDev);
#endif

	if (hWavOut != NULL)
	{
		if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
			fSuccess = TraceFALSE(NULL);
		else
			idDev = lpWavOut->idDev;
	}

	if (fSuccess)
	{
		WAVEOUTCAPS woc;
		UINT nLastError;

		if ((nLastError = waveOutGetDevCaps(idDev, &woc, sizeof(WAVEOUTCAPS))) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("waveOutGetDevCaps failed (%u)\n"),
				(unsigned) nLastError);
		}

		else
			fIsSynchronous = (BOOL) (woc.dwSupport & WAVECAPS_SYNC);

		if (hWavOut != NULL && lpWavOut != NULL)
			lpWavOut->nLastError = nLastError;
	}

	return fSuccess ? fIsSynchronous : FALSE;
}

// WavOutSupportsVolume - return TRUE if device supports volume control
//		<hWavOut>			(i) handle returned from WavOutOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavOut> is not NULL)
// return TRUE if device supports volume control
//
BOOL DLLEXPORT WINAPI WavOutSupportsVolume(HWAVOUT hWavOut, int idDev)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;
	BOOL fSupportsVolume;

#ifdef TELOUT
	if (idDev == TELOUT_DEVICEID || (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut))
		return TelOutSupportsVolume((HTELOUT) hWavOut, idDev);
#endif

	if (hWavOut != NULL)
	{
		if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
			fSuccess = TraceFALSE(NULL);
		else
			idDev = lpWavOut->idDev;
	}

	if (fSuccess)
	{
		WAVEOUTCAPS woc;
		UINT nLastError;

		if ((nLastError = waveOutGetDevCaps(idDev, &woc, sizeof(WAVEOUTCAPS))) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("waveOutGetDevCaps failed (%u)\n"),
				(unsigned) nLastError);
		}

		else
			fSupportsVolume = (BOOL) (woc.dwSupport & WAVECAPS_VOLUME);

		if (hWavOut != NULL && lpWavOut != NULL)
			lpWavOut->nLastError = nLastError;
	}

	return fSuccess ? fSupportsVolume : FALSE;
}

// WavOutSupportsSpeed - return TRUE if device supports speed control
//		<hWavOut>			(i) handle returned from WavOutOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavOut> is not NULL)
// return TRUE if device supports speed control
//
BOOL DLLEXPORT WINAPI WavOutSupportsSpeed(HWAVOUT hWavOut, int idDev)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;
	BOOL fSupportsSpeed;

#ifdef TELOUT
	if (idDev == TELOUT_DEVICEID || (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut))
		return TelOutSupportsSpeed((HTELOUT) hWavOut, idDev);
#endif

	if (hWavOut != NULL)
	{
		if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
			fSuccess = TraceFALSE(NULL);
		else
			idDev = lpWavOut->idDev;
	}

	if (fSuccess)
	{
		WAVEOUTCAPS woc;
		UINT nLastError;

		if ((nLastError = waveOutGetDevCaps(idDev, &woc, sizeof(WAVEOUTCAPS))) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("waveOutGetDevCaps failed (%u)\n"),
				(unsigned) nLastError);
		}

		else
			fSupportsSpeed = (BOOL) (woc.dwSupport & WAVECAPS_PLAYBACKRATE);

		if (hWavOut != NULL && lpWavOut != NULL)
			lpWavOut->nLastError = nLastError;
	}

	return fSuccess ? fSupportsSpeed : FALSE;
}

// WavOutSupportsPitch - return TRUE if device supports pitch control
//		<hWavOut>			(i) handle returned from WavOutOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavOut> is not NULL)
// return TRUE if device supports pitch control
//
BOOL DLLEXPORT WINAPI WavOutSupportsPitch(HWAVOUT hWavOut, int idDev)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;
	BOOL fSupportsPitch;

#ifdef TELOUT
	if (idDev == TELOUT_DEVICEID || (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut))
		return TelOutSupportsPitch((HTELOUT) hWavOut, idDev);
#endif

	if (hWavOut != NULL)
	{
		if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
			fSuccess = TraceFALSE(NULL);
		else
			idDev = lpWavOut->idDev;
	}

	if (fSuccess)
	{
		WAVEOUTCAPS woc;
		UINT nLastError;

		if ((nLastError = waveOutGetDevCaps(idDev, &woc, sizeof(WAVEOUTCAPS))) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("waveOutGetDevCaps failed (%u)\n"),
				(unsigned) nLastError);
		}

		else
			fSupportsPitch = (BOOL) (woc.dwSupport & WAVECAPS_PITCH);

		if (hWavOut != NULL && lpWavOut != NULL)
			lpWavOut->nLastError = nLastError;
	}

	return fSuccess ? fSupportsPitch : FALSE;
}

// WavOutGetVolume - get current volume level
//		<hWavOut>			(i) handle returned from WavOutOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavOut> is not NULL)
// return volume level (0 minimum through 100 maximum, -1 if error)
//
int DLLEXPORT WINAPI WavOutGetVolume(HWAVOUT hWavOut, int idDev)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;
	UINT nLastError;
	DWORD dwVolume;
	int nLevel;

#ifdef TELOUT
	if (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut)
		return TelOutGetVolume((HTELOUT) hWavOut);
#endif

	if (hWavOut != NULL && (lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((nLastError = waveOutGetVolume(
#ifdef _WIN32
#if (WINVER < 0x0400)
		(UINT)
#endif
		(hWavOut == NULL ? (HWAVEOUT)IntToPtr(idDev) : lpWavOut->hWaveOut),
#else
		(hWavOut == NULL ? (HWAVEOUT)IntToPtr(idDev) : (HWAVEOUT)IntToPtr(lpWavOut->idDev)),
#endif
		&dwVolume)) != 0)
	{
		fSuccess = TraceFALSE(NULL);
		TracePrintf_1(NULL, 5,
			TEXT("waveOutGetVolume failed (%u)\n"),
			(unsigned) nLastError);
	}

	else
	{
		nLevel = LOWORD(dwVolume) / (0xFFFF / VOLUME_POSITIONS);

		TracePrintf_2(NULL, 5,
			TEXT("WavOutGetVolume() = %d, 0x%08lX\n"),
			(int) nLevel,
			(unsigned long) dwVolume);
	}

	if (hWavOut != NULL && lpWavOut != NULL)
		lpWavOut->nLastError = nLastError;

	return fSuccess ? nLevel : -1;
}

// WavOutSetVolume - set current volume level
//		<hWavOut>			(i) handle returned from WavOutOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavOut> is not NULL)
//		<nLevel>			(i) volume level
//			0					minimum volume
//			100					maximum volume
// return 0 if success
//
int DLLEXPORT WINAPI WavOutSetVolume(HWAVOUT hWavOut, int idDev, int nLevel)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;
	DWORD dwVolume = MAKELONG(nLevel * (0xFFFF / VOLUME_POSITIONS),
		nLevel * (0xFFFF / VOLUME_POSITIONS));
	UINT nLastError;

#ifdef TELOUT
	if (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut)
		return TelOutSetVolume((HTELOUT) hWavOut, nLevel);
#endif

	if (hWavOut != NULL && (lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (nLevel < VOLUME_MINLEVEL || nLevel > VOLUME_MAXLEVEL)
		fSuccess = TraceFALSE(NULL);

	else if ((nLastError = waveOutSetVolume(
#ifdef _WIN32
#if (WINVER < 0x0400)
		(UINT)
#endif
		(hWavOut == NULL ? (HWAVEOUT)IntToPtr(idDev) : lpWavOut->hWaveOut),
#else
		(hWavOut == NULL ? idDev : lpWavOut->idDev),
#endif
		dwVolume)) != 0)
	{
		fSuccess = TraceFALSE(NULL);
		TracePrintf_1(NULL, 5,
			TEXT("waveOutSetVolume failed (%u)\n"),
			(unsigned) nLastError);
	}
	else
	{
		TracePrintf_2(NULL, 5,
			TEXT("WavOutSetVolume(%d) = 0x%08lX\n"),
			(int) nLevel,
			(unsigned long) dwVolume);
	}

	if (hWavOut != NULL && lpWavOut != NULL)
		lpWavOut->nLastError = nLastError;

	return fSuccess ? 0 : -1;
}

// WavOutGetSpeed - get current speed level
//		<hWavOut>			(i) handle returned from WavOutOpen
// return speed level (100 is normal, 50 is half, 200 is double, -1 if error)
//
int DLLEXPORT WINAPI WavOutGetSpeed(HWAVOUT hWavOut)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;
	DWORD dwSpeed;
	int nLevel;

#ifdef TELOUT
	if (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut)
		return TelOutGetSpeed((HTELOUT) hWavOut);
#endif

	if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpWavOut->nLastError = waveOutGetPlaybackRate(lpWavOut->hWaveOut,
		&dwSpeed)) != 0)
	{
		fSuccess = TraceFALSE(NULL);
		TracePrintf_1(NULL, 5,
			TEXT("waveOutGetPlaybackRate failed (%u)\n"),
			(unsigned) lpWavOut->nLastError);
	}

	else
	{
		WORD wSpeedInteger = HIWORD(dwSpeed);
		WORD wSpeedFraction = LOWORD(dwSpeed);

		nLevel = (int) (100 * wSpeedInteger) +
			(int) ((DWORD) wSpeedFraction * (DWORD) 100 / 0x10000);

		TracePrintf_2(NULL, 5,
			TEXT("WavOutGetSpeed() = %d, 0x%08lX\n"),
			(int) nLevel,
			(unsigned long) dwSpeed);
	}

	return fSuccess ? nLevel : -1;
}

// WavOutSetSpeed - set current speed level
//		<hWavOut>			(i) handle returned from WavOutOpen
//		<nLevel>			(i) speed level
//			50					half speed
//			100					normal speed
//			200					double speed, etc.
// return 0 if success
//
int DLLEXPORT WINAPI WavOutSetSpeed(HWAVOUT hWavOut, int nLevel)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;
	WORD wSpeedInteger = nLevel / 100;
	WORD wSpeedFraction = (WORD) (0x10000 * (DWORD) (nLevel % 100L) / 100L);
	DWORD dwSpeed = MAKELONG(wSpeedFraction, wSpeedInteger);

#ifdef TELOUT
	if (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut)
		return TelOutSetSpeed((HTELOUT) hWavOut, nLevel);
#endif

	if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpWavOut->nLastError = waveOutSetPlaybackRate(lpWavOut->hWaveOut,
		dwSpeed)) != 0)
	{
		fSuccess = TraceFALSE(NULL);
		TracePrintf_1(NULL, 5,
			TEXT("waveOutSetPlaybackRate failed (%u)\n"),
			(unsigned) lpWavOut->nLastError);
	}

	else
	{
		TracePrintf_2(NULL, 5,
			TEXT("WavOutSetSpeed(%d) = 0x%08lX\n"),
			(int) nLevel,
			(unsigned long) dwSpeed);
	}

	return fSuccess ? 0 : -1;
}

// WavOutGetPitch - get current pitch level
//		<hWavOut>			(i) handle returned from WavOutOpen
// return pitch level (100 is normal, 50 is half, 200 is double, -1 if error)
//
int DLLEXPORT WINAPI WavOutGetPitch(HWAVOUT hWavOut)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;
	DWORD dwPitch;
	int nLevel;

#ifdef TELOUT
	if (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut)
		return TelOutGetPitch((HTELOUT) hWavOut);
#endif

	if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpWavOut->nLastError = waveOutGetPitch(lpWavOut->hWaveOut,
		&dwPitch)) != 0)
	{
		fSuccess = TraceFALSE(NULL);
		TracePrintf_1(NULL, 5,
			TEXT("waveOutGetPitch failed (%u)\n"),
			(unsigned) lpWavOut->nLastError);
	}

	else
	{
		WORD wPitchInteger = HIWORD(dwPitch);
		WORD wPitchFraction = LOWORD(dwPitch);

		nLevel = (int) (100 * wPitchInteger) +
			(int) ((DWORD) wPitchFraction * (DWORD) 100 / 0x10000);

		TracePrintf_2(NULL, 5,
			TEXT("WavOutGetPitch() = %d, 0x%08lX\n"),
			(int) nLevel,
			(unsigned long) dwPitch);
	}

	return fSuccess ? nLevel : -1;
}

// WavOutSetPitch - set current pitch level
//		<hWavOut>			(i) handle returned from WavOutOpen
//		<nLevel>			(i) pitch level
//			50					half pitch
//			100					normal pitch
//			200					double pitch, etc.
// return 0 if success
//
int DLLEXPORT WINAPI WavOutSetPitch(HWAVOUT hWavOut, int nLevel)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;
	WORD wPitchInteger = nLevel / 100;
	WORD wPitchFraction = (WORD) (0x10000 * (DWORD) (nLevel % 100L) / 100L);
	DWORD dwPitch = MAKELONG(wPitchFraction, wPitchInteger);

#ifdef TELOUT
	if (hWavOut != NULL && hWavOut == (HWAVOUT) hTelOut)
		return TelOutSetPitch((HTELOUT) hWavOut, nLevel);
#endif

	if ((lpWavOut = WavOutGetPtr(hWavOut)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpWavOut->nLastError = waveOutSetPitch(lpWavOut->hWaveOut,
		dwPitch)) != 0)
	{
		fSuccess = TraceFALSE(NULL);
		TracePrintf_1(NULL, 5,
			TEXT("waveOutSetPitch failed (%u)\n"),
			(unsigned) lpWavOut->nLastError);
	}

	else
	{
		TracePrintf_2(NULL, 5,
			TEXT("WavOutSetPitch(%d) = 0x%08lX\n"),
			(int) nLevel,
			(unsigned long) dwPitch);
	}

	return fSuccess ? 0 : -1;
}

// WavOutTerm - shut down wav output residuals, if any
// 		<hInst>				(i) instance handle of calling module
//		<dwFlags>			(i) control flags
//			WAV_TELTHUNK		terminate telephone thunking layer
// return 0 if success
//
int DLLEXPORT WINAPI WavOutTerm(HINSTANCE hInst, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;

	if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);

#ifdef TELOUT
	else if ((dwFlags & WAV_TELTHUNK) &&
		TelOutTerm(hInst, dwFlags) != 0)
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? 0 : -1;
}

////
//	helper functions
////

#ifdef MULTITHREAD
DWORD WINAPI WavOutCallbackThread(LPVOID lpvThreadParameter)
{
	BOOL fSuccess = TRUE;
	MSG msg;
	LPWAVOUT lpWavOut = (LPWAVOUT) lpvThreadParameter;

	// make sure message queue is created before calling SetEvent
	//
	PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);

	// notify main thread that callback thread has begun execution
	//
	if (!SetEvent(lpWavOut->hEventThreadCallbackStarted))
	{
		fSuccess = TraceFALSE(NULL);
	}

	while (fSuccess && GetMessage(&msg, NULL, 0, 0))
	{
		WavOutCallback((HWND) lpWavOut, msg.message, msg.wParam, msg.lParam);

		// exit thread when when have processed last expected message
		//
		if (msg.message == MM_WOM_CLOSE)
			break;
	}

	return 0;
}
#endif

// WavOutCallback - window procedure for wavout callback
//
LRESULT DLLEXPORT CALLBACK WavOutCallback(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	BOOL fSuccess = TRUE;
	LRESULT lResult;
	LPWAVOUT lpWavOut;
	
#ifdef MULTITHREAD
	if (!IsWindow(hwnd))
		lpWavOut = (LPWAVOUT) hwnd;
	else
#endif
	// retrieve lpWavOut from window extra bytes
	//
	lpWavOut = (LPWAVOUT) GetWindowLongPtr(hwnd, 0);

	switch (msg)
	{
		case WM_NCCREATE:
		{
			LPCREATESTRUCT lpcs = (LPCREATESTRUCT) lParam;
			LPWAVOUT lpWavOut = (LPWAVOUT) lpcs->lpCreateParams;

			// store lpWavOut in window extra bytes
			//
			SetWindowLongPtr(hwnd, 0, (LONG_PTR) lpWavOut);

			lResult = DefWindowProc(hwnd, msg, wParam, lParam);
		}
			break;

		case MM_WOM_OPEN:
		{
			HWAVEOUT hWaveOut = (HWAVEOUT) wParam;

		 	TraceOutput(NULL, 5,
				TEXT("MM_WOM_OPEN\n"));

#ifdef MULTITHREAD
			if (!(lpWavOut->dwFlags & WAVOUT_MULTITHREAD) &&
				hWaveOut != lpWavOut->hWaveOut)
#else
			if (hWaveOut != lpWavOut->hWaveOut)
#endif
				fSuccess = TraceFALSE(NULL);

			else
			{
				lpWavOut->fIsOpen = TRUE;

#ifdef MULTITHREAD
				// notify main thread that device is open
				//
				if ((lpWavOut->dwFlags & WAVOUT_MULTITHREAD) &&
					!SetEvent(lpWavOut->hEventDeviceOpened))
				{
					fSuccess = TraceFALSE(NULL);
				}
#endif
				// send notification of device opening
				//
#ifdef MULTITHREAD
				if (lpWavOut->dwFlags & WAVOUT_MULTITHREAD)
				{
					if ( lpWavOut->hwndNotify )
						PostThreadMessage( HandleToUlong(lpWavOut->hwndNotify), WM_WAVOUT_OPEN, 0, 0);
				}
				else
#endif
				{
					if (lpWavOut->hwndNotify != NULL &&
						IsWindow(lpWavOut->hwndNotify))
					{
						SendMessage(lpWavOut->hwndNotify, WM_WAVOUT_OPEN, 0, 0);
					}
				}
			}

			lResult = 0L;
		}
			break;

		case MM_WOM_CLOSE:
		{
			HWAVEOUT hWaveOut = (HWAVEOUT) wParam;

		 	TraceOutput(NULL, 5,
				TEXT("MM_WOM_CLOSE\n"));

#ifdef MULTITHREAD
			if (!(lpWavOut->dwFlags & WAVOUT_MULTITHREAD) &&
				hWaveOut != lpWavOut->hWaveOut)
#else
			if (hWaveOut != lpWavOut->hWaveOut)
#endif
				fSuccess = TraceFALSE(NULL);

			else
			{
				lpWavOut->fIsOpen = FALSE;

				// send notification of device closing
				//
#ifdef MULTITHREAD
				if (lpWavOut->dwFlags & WAVOUT_MULTITHREAD)
				{
					if ( lpWavOut->hwndNotify )
						PostThreadMessage(HandleToUlong(lpWavOut->hwndNotify), WM_WAVOUT_CLOSE, 0, 0);
				}
				else
#endif
				{
					if (lpWavOut->hwndNotify != NULL &&
						IsWindow(lpWavOut->hwndNotify))
					{
						SendMessage(lpWavOut->hwndNotify, WM_WAVOUT_CLOSE, 0, 0);
					}
				}
#ifdef MULTITHREAD
				// notify main thread that device is closed
				//
				if ((lpWavOut->dwFlags & WAVOUT_MULTITHREAD) &&
					!SetEvent(lpWavOut->hEventDeviceClosed))
				{
					fSuccess = TraceFALSE(NULL);
				}
#endif
			}

			lResult = 0L;
		}
			break;

		case MM_WOM_DONE:
		{
			HWAVEOUT hWaveOut = (HWAVEOUT) wParam;
			LPWAVEHDR lpWaveHdr = (LPWAVEHDR) lParam;
			LPVOID lpBuf;
			long sizBuf;
			BOOL fAutoFree = (BOOL) (lpWavOut->dwFlags & WAVOUT_AUTOFREE);

		 	TracePrintf_1(NULL, 5,
		 		TEXT("MM_WOM_DONE (%lu)\n"),
	 			(unsigned long) lpWaveHdr->dwBufferLength);

#ifdef MULTITHREAD
			if (lpWavOut->dwFlags & WAVOUT_MULTITHREAD)
				EnterCriticalSection(&(lpWavOut->critSectionStop));
#endif

#ifdef MULTITHREAD
			if (!(lpWavOut->dwFlags & WAVOUT_MULTITHREAD) &&
				hWaveOut != lpWavOut->hWaveOut)
#else
			if (hWaveOut != lpWavOut->hWaveOut)
#endif
				fSuccess = TraceFALSE(NULL);

			else if (lpWaveHdr == NULL)
				fSuccess = TraceFALSE(NULL);

			// NULL buffer is possible with telephone, this is ok
			// 
			else if ((lpBuf = (LPVOID) lpWaveHdr->lpData) == NULL, FALSE)
				;

			else if (sizBuf = (long) lpWaveHdr->dwBufferLength, FALSE)
				fSuccess = TraceFALSE(NULL);

			else if (!(lpWaveHdr->dwFlags & WHDR_DONE))
				fSuccess = TraceFALSE(NULL);

			else if (!(lpWaveHdr->dwFlags & WHDR_PREPARED))
				fSuccess = TraceFALSE(NULL);

			else if ((lpWavOut->nLastError = waveOutUnprepareHeader(
				lpWavOut->hWaveOut, lpWaveHdr, sizeof(WAVEHDR))) != 0)
			{
				fSuccess = TraceFALSE(NULL);
			 	TracePrintf_1(NULL, 5,
			 		TEXT("waveOutUnprepareHeader failed (%u)\n"),
		 			(unsigned) lpWavOut->nLastError);
			}

			else if ((lpWaveHdr = MemFree(NULL, lpWaveHdr)) != NULL)
				fSuccess = TraceFALSE(NULL);

			else if (--lpWavOut->cBufsPending < 0)
				fSuccess = TraceFALSE(NULL);

			// device is no longer playing if no more buffers pending
			//
			else if (lpWavOut->cBufsPending == 0)
			{
				lpWavOut->wState = WAVOUT_STOPPED;

#ifdef MULTITHREAD
				// notify main thread that device is stopped
				//
				if ((lpWavOut->dwFlags & WAVOUT_MULTITHREAD) &&
					lpWavOut->hEventDeviceStopped != NULL &&
					!SetEvent(lpWavOut->hEventDeviceStopped))
				{
					fSuccess = TraceFALSE(NULL);
				}
#endif
			}

			if (fSuccess)
			{
				PLAYDONE playdone;

				playdone.lpBuf = lpBuf;
				playdone.sizBuf = sizBuf;

				// send notification of playback completion
				//
#ifdef MULTITHREAD
				if (lpWavOut->dwFlags & WAVOUT_MULTITHREAD)
				{
					if ( lpWavOut->hwndNotify )
					{
						SendThreadMessage( HandleToUlong(lpWavOut->hwndNotify),
							WM_WAVOUT_PLAYDONE, (LPARAM) (LPVOID) &playdone);
					}
				}
				else
#endif
				{
					if (lpWavOut->hwndNotify != NULL &&
						IsWindow(lpWavOut->hwndNotify))
					{
						SendMessage(lpWavOut->hwndNotify,
							WM_WAVOUT_PLAYDONE, 0, (LPARAM) (LPVOID) &playdone);
					}
				}
			}

			// free data buffer if WAVOUT_AUTOFREE specified
			//
			if (fSuccess && fAutoFree)
			{
				if (lpBuf != NULL && (lpBuf = MemFree(NULL, lpBuf)) != NULL)
					fSuccess = TraceFALSE(NULL);
			}

			lResult = 0L;
#ifdef MULTITHREAD
			if (lpWavOut->dwFlags & WAVOUT_MULTITHREAD)
				LeaveCriticalSection(&(lpWavOut->critSectionStop));
#endif
		}
			break;

		default:
			lResult = DefWindowProc(hwnd, msg, wParam, lParam);
			break;
	}
	
	return lResult;
}

// WavOutGetPtr - verify that wavout handle is valid,
//		<hWavOut>				(i) handle returned from WavOutInit
// return corresponding wavout pointer (NULL if error)
//
static LPWAVOUT WavOutGetPtr(HWAVOUT hWavOut)
{
	BOOL fSuccess = TRUE;
	LPWAVOUT lpWavOut;

	if ((lpWavOut = (LPWAVOUT) hWavOut) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpWavOut, sizeof(WAVOUT)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the wavout handle
	//
	else if (lpWavOut->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpWavOut : NULL;
}

// WavOutGetHandle - verify that wavout pointer is valid,
//		<lpWavOut>				(i) pointer to WAVOUT struct
// return corresponding wavout handle (NULL if error)
//
static HWAVOUT WavOutGetHandle(LPWAVOUT lpWavOut)
{
	BOOL fSuccess = TRUE;
	HWAVOUT hWavOut;

	if ((hWavOut = (HWAVOUT) lpWavOut) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hWavOut : NULL;
}

#ifdef MULTITHREAD

static LRESULT SendThreadMessage(DWORD dwThreadId, UINT Msg, LPARAM lParam)
{
	BOOL fSuccess = TRUE;
	HANDLE hEventMessageProcessed = NULL;
	DWORD dwRet;

	// we need to know when message has been processed
	//
	if ((hEventMessageProcessed = CreateEvent(
		NULL, FALSE, FALSE, NULL)) == NULL)
	{
		fSuccess = TraceFALSE(NULL);
	}

	// post message to thread, send event handle as wParam
	//
	else if (!PostThreadMessage(dwThreadId, Msg, (WPARAM) hEventMessageProcessed, lParam))
	{
		fSuccess = TraceFALSE(NULL);
	}

	// wait for the message to be processed
	//
	else if ((dwRet = WaitForSingleObject(
		hEventMessageProcessed, INFINITE)) != WAIT_OBJECT_0)
	{
		fSuccess = TraceFALSE(NULL);
	}

	// clean up
	//
	if (hEventMessageProcessed != NULL)
	{
		if (!CloseHandle(hEventMessageProcessed))
			fSuccess = TraceFALSE(NULL);
		else
			hEventMessageProcessed = NULL;
	}

	return 0L;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\avwav\wavin.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// wavin.h - interface for wav input device functions in wavin.c
////

#ifndef __WAVIN_H__
#define __WAVIN_H__

#ifdef _WIN32
#define MULTITHREAD 1
#endif

#include "winlocal.h"

#include "wavfmt.h"

#define WAVIN_VERSION 0x00000108

// handle to wav input device (NOT the same as Windows HWAVEIN)
//
DECLARE_HANDLE32(HWAVIN);

// <dwFlags> values in WavInOpen
//
#define WAVIN_NOSYNC		0x00000001
#define WAVIN_OPENRETRY		0x00000004
#define WAVIN_OPENASYNC		0x00000008
#define WAVIN_CLOSEASYNC	0x00000010
#define WAVIN_NOACM			0x00000020
#define WAVIN_TELRFILE		0x00000040
#ifdef MULTITHREAD
#define WAVIN_MULTITHREAD 	0x00000080
#endif

// notification messages sent to <hwndNotify>
//
#define WM_WAVIN_OPEN			(WM_USER + 200)
#define WM_WAVIN_CLOSE			(WM_USER + 201)
#define WM_WAVIN_RECORDDONE		(WM_USER + 202)
#define WM_WAVIN_STOPRECORD		(WM_USER + 203)

// structure passed as <lParam> in WM_WAVOUT_RECORDDONE message
//
typedef struct RECORDDONE
{
	LPVOID lpBuf;
	long sizBuf;
	long lBytesRecorded;
} RECORDDONE, FAR *LPRECORDDONE;

// return values from WavInGetState
//
#define WAVIN_STOPPED		0x0001
#define WAVIN_RECORDING		0x0002
#define WAVIN_STOPPING		0x0008

#ifdef __cplusplus
extern "C" {
#endif

// WavInGetDeviceCount - return number of wav input devices found
//		<void>				this function takes no arguments
// return number of wav input devices found (0 if none)
//
int DLLEXPORT WINAPI WavInGetDeviceCount(void);

// WavInDeviceIsOpen - check if input device is open
//		<idDev>				(i) device id
//			-1					open any suitable input device
// return TRUE if open
//
BOOL DLLEXPORT WINAPI WavInDeviceIsOpen(int idDev);

// WavInOpen - open wav input device
//		<dwVersion>			(i) must be WAVIN_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<idDev>				(i) device id
//			-1					open any suitable input device
//		<lpwfx>				(i) wave format
//		<hwndNotify>		(i) notify this window of device events
//			NULL				do not notify
//		<msTimeoutOpen>		(i) device open timeout in milleseconds
//			0					default timeout (30000)
//		<msTimeoutRetry>	(i) device retry timeout in milleseconds
//			0					default timeout (2000)
//		<dwFlags>			(i) control flags
//			WAVIN_NOSYNC		do not open synchronous devices
//			WAVIN_OPENRETRY		retry if device busy
//			WAVIN_OPENASYNC		return before notification of device open
//			WAVIN_CLOSEASYNC	return before notification of device close
//			WAVIN_NOACM			do not use audio compression manager
//			WAVIN_TELRFILE		telephone will record audio to file on server
#ifdef MULTITHREAD
//			WAVOUT_MULTITHREAD use callback thread rather than window
#endif
// return handle (NULL if error)
//
// NOTE: if <hwndNotify> is specified in WavInOpen,
// WM_WAVIN_OPEN will be sent to <hwndNotify>,
// when input device has been opened.
//
// NOTE: if WAVIN_MULTITHREAD is specified in <dwFlags>,
// it is assumed that <hwndNotify> is not a window handle,
// but rather the id of the thread to receive notifications
//
HWAVIN DLLEXPORT WINAPI WavInOpen(DWORD dwVersion, HINSTANCE hInst,
	int idDev, LPWAVEFORMATEX lpwfx, HWND hwndNotify,
	DWORD msTimeoutOpen, DWORD msTimeoutRetry, DWORD dwFlags);

// WavInClose - close wav input device
//		<hWavIn>			(i) handle returned from WavInOpen
//		<msTimeoutClose>	(i) device close timeout in milleseconds
//			0					default timeout (30000)
// return 0 if success
//
// NOTE: if <hwndNotify> was specified in WavInOpen,
// WM_WAVIN_CLOSE will be sent to <hwndNotify>,
// when input device has been closed.
//
int DLLEXPORT WINAPI WavInClose(HWAVIN hWavIn, DWORD msTimeoutClose);

// WavInRecord - submit buffer of samples to wav input device for recording
//		<hWavIn>			(i) handle returned from WavInOpen
//		<lpBuf>				(o) pointer to buffer to be filled with samples
//		<sizBuf>			(i) size of buffer in bytes
// return 0 if success
//
// NOTE: the buffer pointed to by <lpBuf> must have been allocated
// using MemAlloc().
//
// NOTE: if <hwndNotify> is specified in WavInOpen(), a WM_WAVIN_RECORDDONE
// message will be sent to <hwndNotify>, with <lParam> set to a pointer to
// a RECORDDONE structure, when <lpBuf> has been recorded.
//
int DLLEXPORT WINAPI WavInRecord(HWAVIN hWavIn, LPVOID lpBuf, long sizBuf);

// WavInStop - stop recording into buffer(s) sent to wav input device
//		<hWavIn>			(i) handle returned from WavInOpen
//		<msTimeoutStop>		(i) device stop timeout in milleseconds
//			0					default timeout (2000)
// return 0 if success
//
int DLLEXPORT WINAPI WavInStop(HWAVIN hWavIn, DWORD msTimeoutStop);

// WavInGetState - return current wav input device state
//		<hWavIn>			(i) handle returned from WavInOpen
// return WAVIN_STOPPED, WAVIN_RECORDING, or 0 if error
//
WORD DLLEXPORT WINAPI WavInGetState(HWAVIN hWavIn);

// WavInGetPosition - get milleseconds of elapsed recording
//		<hWavIn>			(i) handle returned from WavInOpen
// return 0 if success
//
long DLLEXPORT WINAPI WavInGetPosition(HWAVIN hWavIn);

// WavInGetId - return id of wav input device
//		<hWavIn>			(i) handle returned from WavInOpen
// return device id (-1 if error)
//
int DLLEXPORT WINAPI WavInGetId(HWAVIN hWavIn);

// WavInGetName - get name of wav input device
//		<hWavIn>			(i) handle returned from WavInOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavIn> is not NULL)
//			-1					any suitable input device
//		<lpszName>			(o) buffer to hold device name
//		<sizName>			(i) size of buffer
// return 0 if success
//
int DLLEXPORT WINAPI WavInGetName(HWAVIN hWavIn, int idDev, LPTSTR lpszName, int sizName);

// WavInGetIdByName - get id of wav input device, lookup by name
//		<lpszName>			(i) device name
#ifdef _WIN32
//			NULL or TEXT("")	get preferred device id
#endif
//		<dwFlags>			(i) reserved; must be zero
// return device id (-1 if error)
//
int WINAPI WavInGetIdByName(LPCTSTR lpszName, DWORD dwFlags);

// WavInSupportsFormat - return TRUE if device supports specified format
//		<hWavIn>			(i) handle returned from WavInOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavIn> is not NULL)
//			-1					any suitable input device
//		<lpwfx>				(i) wave format
// return TRUE if device supports specified format
//
BOOL DLLEXPORT WINAPI WavInSupportsFormat(HWAVIN hWavIn, int idDev,
	LPWAVEFORMATEX lpwfx);

// WavInFormatSuggest - suggest a new format which the device supports
//		<hWavIn>			(i) handle returned from WavInOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavIn> is not NULL)
//			-1					any suitable input device
//		<lpwfxSrc>			(i) source format
//		<dwFlags>			(i)	control flags
//			WAVIN_NOACM			do not use audio compression manager
// return pointer to suggested format, NULL if error
//
// NOTE: the format structure returned is dynamically allocated.
// Use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI WavInFormatSuggest(
	HWAVIN hWavIn, int idDev, LPWAVEFORMATEX lpwfxSrc, DWORD dwFlags);

// WavInTerm - shut down wav input residuals, if any
// 		<hInst>				(i) instance handle of calling module
//		<dwFlags>			(i) control flags
//			WAV_TELTHUNK		terminate telephone thunking layer
// return 0 if success
//
int DLLEXPORT WINAPI WavInTerm(HINSTANCE hInst, DWORD dwFlags);

#ifdef __cplusplus
}
#endif

#endif // __WAVIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\avwav\wavmixer.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	wavmixer.h - wav mixer functions
////

#ifndef __WAVMIXER_H__
#define __WAVMIXER_H__

#include "winlocal.h"

#define WAVMIXER_VERSION 0x00000100

// handle to wavmixer engine
//
DECLARE_HANDLE32(HWAVMIXER);

#define WAVMIXER_HWAVEIN		0x00000001
#define WAVMIXER_HWAVEOUT		0x00000002
#define WAVMIXER_WAVEIN			0x00000004
#define WAVMIXER_WAVEOUT		0x00000008

#ifdef __cplusplus
extern "C" {
#endif

// WavMixerInit - initialize wav mixer device
//		<dwVersion>			(i) must be WAVMIXER_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<lParam>			(i) device id or handle, as specified by <dwFlags>
//		<dwReserved1>		(i) reserved; must be 0;
//		<dwReserved2>		(i) reserved; must be 0;
//		<dwFlags>			(i) control flags
//			WAVMIXER_HWAVEIN	<lParam> contains an HWAVEIN
//			WAVMIXER_HWAVEOUT	<lParam> contains an HWAVEOUT
//			WAVMIXER_WAVEIN		<lParam> contains a wav input device id
//			WAVMIXER_WAVEOUT	<lParam> contains a wav output device id
// return handle (NULL if error)
//
HWAVMIXER WINAPI WavMixerInit(DWORD dwVersion, HINSTANCE hInst,
	LPARAM lParam, DWORD dwReserved1, DWORD dwReserved2, DWORD dwFlags);

// WavMixerTerm - shut down wave mixer device
//		<hWavMixer>				(i) handle returned from WavMixerInit
// return 0 if success
//
int WINAPI WavMixerTerm(HWAVMIXER hWavMixer);

// WavMixerSupportsVolume - return TRUE if device supports volume control
//		<hWavMixer>				(i) handle returned from WavMixerInit
//		<dwFlags>				(i) control flags
//			0						reserved; must be zero
// return TRUE if device supports volume control
//
BOOL WINAPI WavMixerSupportsVolume(HWAVMIXER hWavMixer, DWORD dwFlags);

// WavMixerGetVolume - get current volume level
//		<hWavMixer>				(i) handle returned from WavMixerInit
//		<dwFlags>				(i) control flags
//			0						reserved; must be zero
// return volume level (0 minimum through 100 maximum, -1 if error)
//
int WINAPI WavMixerGetVolume(HWAVMIXER hWavMixer, DWORD dwFlags);

// WavMixerSetVolume - set current volume level
//		<hWavMixer>				(i) handle returned from WavMixerInit
//		<nLevel>				(i) volume level
//			0						minimum volume
//			100						maximum volume
//		<dwFlags>				(i) control flags
//			0						reserved; must be zero
// return new volume level (0 minimum through 100 maximum, -1 if error)
//
int WINAPI WavMixerSetVolume(HWAVMIXER hWavMixer, int nLevel, DWORD dwFlags);

// WavMixerSupportsLevel - return TRUE if device supports peak meter level
//		<hWavMixer>				(i) handle returned from WavMixerInit
//		<dwFlags>				(i) control flags
//			0						reserved; must be zero
// return TRUE if device supports peak meter level
//
BOOL WINAPI WavMixerSupportsLevel(HWAVMIXER hWavMixer, DWORD dwFlags);

// WavMixerGetLevel - get current peak meter level
//		<hWavMixer>				(i) handle returned from WavMixerInit
//		<dwFlags>				(i) control flags
//			0						reserved; must be zero
// return peak meter level (0 minimum through 100 maximum, -1 if error)
//
int WINAPI WavMixerGetLevel(HWAVMIXER hWavMixer, DWORD dwFlags);

#ifdef __cplusplus
}
#endif

#endif // __WAVMIXER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\avwav\wavin.c ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//	wavin.c - wav input device functions
////

#include "winlocal.h"
#include "wavin.h"
#include "wav.h"
#include "acm.h"
#include "calc.h"
#include "mem.h"
#include "str.h"
#include "sys.h"
#include "trace.h"
#include <mmddk.h>

// allow telephone input functions if defined
//
#ifdef TELIN
#include "telin.h"
static HTELIN hTelIn = NULL;
#endif

////
//	private definitions
////

#define WAVINCLASS TEXT("WavInClass")

// wavin control struct
//
typedef struct WAVIN
{
	DWORD dwVersion;
	HINSTANCE hInst;
	HTASK hTask;
	UINT idDev;
	LPWAVEFORMATEX lpwfx;
	HWND hwndNotify;
	DWORD dwFlags;
	BOOL fIsOpen;
	HWAVEIN hWaveIn;
	WORD wState;
	HWND hwndCallback;
#ifdef MULTITHREAD
	HANDLE hThreadCallback;
	DWORD dwThreadId;
	HANDLE hEventThreadCallbackStarted;
	HANDLE hEventDeviceOpened;
	HANDLE hEventDeviceClosed;
	HANDLE hEventDeviceStopped;
	CRITICAL_SECTION critSectionStop;
#endif
	UINT nLastError;
	int cBufsPending;
} WAVIN, FAR *LPWAVIN;

// helper functions
//
LRESULT DLLEXPORT CALLBACK WavInCallback(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
#ifdef MULTITHREAD
DWORD WINAPI WavInCallbackThread(LPVOID lpvThreadParameter);
#endif
static LPWAVIN WavInGetPtr(HWAVIN hWavIn);
static HWAVIN WavInGetHandle(LPWAVIN lpWavIn);
#ifdef MULTITHREAD
static LRESULT SendThreadMessage(DWORD dwThreadId, UINT Msg, LPARAM lParam);
#endif

////
//	public functions
////

// WavInGetDeviceCount - return number of wav input devices found
//		<void>				this function takes no arguments
// return number of wav input devices found (0 if none)
//
int DLLEXPORT WINAPI WavInGetDeviceCount(void)
{
	return waveInGetNumDevs();
}

// WavInDeviceIsOpen - check if input device is open
//		<idDev>				(i) device id
//			-1					open any suitable input device
// return TRUE if open
//
BOOL DLLEXPORT WINAPI WavInDeviceIsOpen(int idDev)
{
	BOOL fSuccess = TRUE;
	BOOL fIsOpen = FALSE;
	WAVEFORMATEX wfx;
	HWAVEIN hWaveIn;
	int nLastError;

#ifdef TELIN
	if (idDev == TELIN_DEVICEID)
		return TelInDeviceIsOpen(idDev);
#endif

	// try to open device
	//
	if ((nLastError = waveInOpen(&hWaveIn, idDev, 
#ifndef _WIN32
			(LPWAVEFORMAT)
#endif
		WavFormatPcm(-1, -1, -1, &wfx),
		 0, 0, 0)) != 0)
	{
		if (nLastError == MMSYSERR_ALLOCATED)
			fIsOpen = TRUE; // device in use

		else
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("waveInOpen failed (%u)\n"),
				(unsigned) nLastError);
		}
	}

	// close device
	//
	else if (waveInClose(hWaveIn) != 0)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? fIsOpen : FALSE;
}

// WavInOpen - open wav input device
//		<dwVersion>			(i) must be WAVIN_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<idDev>				(i) device id
//			-1					open any suitable input device
//		<lpwfx>				(i) wave format
//		<hwndNotify>		(i) notify this window of device events
//			NULL				do not notify
//		<msTimeoutOpen>		(i) device open timeout in milleseconds
//			0					default timeout (30000)
//		<msTimeoutRetry>	(i) device retry timeout in milleseconds
//			0					default timeout (2000)
//		<dwFlags>			(i) control flags
//			WAVIN_NOSYNC		do not open synchronous devices
//			WAVIN_OPENRETRY		retry if device busy
//			WAVIN_OPENASYNC		return before notification of device open
//			WAVIN_CLOSEASYNC	return before notification of device close
//			WAVIN_NOACM			do not use audio compression manager
//			WAVIN_TELRFILE		telephone will record audio to file on server
#ifdef MULTITHREAD
//			WAVIN_MULTITHREAD	support multiple threads
#endif
// return handle (NULL if error)
//
// NOTE: if <hwndNotify> is specified in WavInOpen,
// WM_WAVIN_OPEN will be sent to <hwndNotify>,
// when input device has been opened.
//
// NOTE: if WAVIN_MULTITHREAD is specified in <dwFlags>,
// it is assumed that <hwndNotify> is not a window handle,
// but rather the id of the thread to receive notifications
//
HWAVIN DLLEXPORT WINAPI WavInOpen(DWORD dwVersion, HINSTANCE hInst,
	int idDev, LPWAVEFORMATEX lpwfx, HWND hwndNotify,
	DWORD msTimeoutOpen, DWORD msTimeoutRetry, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAVIN lpWavIn = NULL;
	WNDCLASS wc;

#ifdef TELIN
	if (idDev == TELIN_DEVICEID)
	{
		hTelIn = TelInOpen(TELIN_VERSION, hInst, idDev, lpwfx,
			hwndNotify, msTimeoutOpen, msTimeoutRetry, dwFlags);
		return (HWAVIN) hTelIn;
	}
#endif

	if (dwVersion != WAVIN_VERSION)
		fSuccess = TraceFALSE(NULL);
	
	else if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpWavIn = (LPWAVIN) MemAlloc(NULL, sizeof(WAVIN), 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else
	{
		lpWavIn->dwVersion = dwVersion;
		lpWavIn->hInst = hInst;
		lpWavIn->hTask = GetCurrentTask();
		lpWavIn->idDev = (UINT) idDev;
		lpWavIn->lpwfx = NULL;
		lpWavIn->hwndNotify = hwndNotify;
		lpWavIn->dwFlags = dwFlags;
		lpWavIn->fIsOpen = FALSE;
		lpWavIn->hWaveIn = NULL;
		lpWavIn->wState = WAVIN_STOPPED;
		lpWavIn->hwndCallback = NULL;
#ifdef MULTITHREAD
		lpWavIn->hThreadCallback = NULL;
		lpWavIn->dwThreadId = 0;
		lpWavIn->hEventThreadCallbackStarted = NULL;
		lpWavIn->hEventDeviceOpened = NULL;
		lpWavIn->hEventDeviceClosed = NULL;
		lpWavIn->hEventDeviceStopped = NULL;
#endif
		lpWavIn->nLastError = 0;
		lpWavIn->cBufsPending = 0;

		// memory is allocated such that the client app owns it
		//
		if ((lpWavIn->lpwfx = WavFormatDup(lpwfx)) == NULL)
			fSuccess = TraceFALSE(NULL);
	}

#ifdef MULTITHREAD
	// handle WAVIN_MULTITHREAD flag
	//
	if (fSuccess && (lpWavIn->dwFlags & WAVIN_MULTITHREAD))
	{
		DWORD dwRet;

		InitializeCriticalSection(&(lpWavIn->critSectionStop));

		// we need to know when device has been opened
		//
		if ((lpWavIn->hEventDeviceOpened = CreateEvent(
			NULL, FALSE, FALSE, NULL)) == NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}

		// we need to know when callback thread begins execution
		//
		else if ((lpWavIn->hEventThreadCallbackStarted = CreateEvent(
			NULL, FALSE, FALSE, NULL)) == NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}

		// create the callback thread
		//
		else if ((lpWavIn->hThreadCallback = CreateThread(
			NULL,
			0,
			WavInCallbackThread,
			(LPVOID) lpWavIn,
			0,
			&lpWavIn->dwThreadId)) == NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}

		// wait for the callback thread to begin execution
		//
		else if ((dwRet = WaitForSingleObject(
			lpWavIn->hEventThreadCallbackStarted, 10000)) != WAIT_OBJECT_0)
		{
			fSuccess = TraceFALSE(NULL);
		}

		// clean up
		//
		if (lpWavIn->hEventThreadCallbackStarted != NULL)
		{
			if (!CloseHandle(lpWavIn->hEventThreadCallbackStarted))
				fSuccess = TraceFALSE(NULL);
			else
				lpWavIn->hEventThreadCallbackStarted = NULL;
		}
	}
	else
#endif
	{
		// register callback class unless it has been already
		//
		if (fSuccess && GetClassInfo(lpWavIn->hInst, WAVINCLASS, &wc) == 0)
		{
			wc.hCursor =		NULL;
			wc.hIcon =			NULL;
			wc.lpszMenuName =	NULL;
			wc.hInstance =		lpWavIn->hInst;
			wc.lpszClassName =	WAVINCLASS;
			wc.hbrBackground =	NULL;
			wc.lpfnWndProc =	WavInCallback;
			wc.style =			0L;
			wc.cbWndExtra =		sizeof(lpWavIn);
			wc.cbClsExtra =		0;

			if (!RegisterClass(&wc))
				fSuccess = TraceFALSE(NULL);
		}

		// create the callback window
		//
		if (fSuccess && (lpWavIn->hwndCallback = CreateWindowEx(
			0L,
			WAVINCLASS,
			NULL,
			0L,
			0, 0, 0, 0,
			NULL,
			NULL,
			lpWavIn->hInst,
			lpWavIn)) == NULL)
		{
			fSuccess = TraceFALSE(NULL);
		}
	}

	if (fSuccess)
	{
		DWORD dwTimeout = SysGetTimerCount() +
			(msTimeoutRetry == 0 ? 2000L : msTimeoutRetry);
		DWORD dwCallback;
		DWORD dwFlags;

#ifdef MULTITHREAD
		if (lpWavIn->dwFlags & WAVIN_MULTITHREAD)
		{
			dwCallback = lpWavIn->dwThreadId;
			dwFlags = CALLBACK_THREAD;
		}
		else
#endif
		{
			dwCallback = HandleToUlong(lpWavIn->hwndCallback);
			dwFlags = CALLBACK_WINDOW;
		}

		// allow synchronous device drivers unless WAVIN_NOSYNC specified
		//
		if (!(lpWavIn->dwFlags & WAVIN_NOSYNC))
			dwFlags |= WAVE_ALLOWSYNC;

		// open the device
		//
		while (fSuccess && (lpWavIn->nLastError = waveInOpen(&lpWavIn->hWaveIn,
			(UINT) lpWavIn->idDev,
#ifndef _WIN32
			(LPWAVEFORMAT)
#endif
			lpWavIn->lpwfx, dwCallback, (DWORD) 0, dwFlags)) != 0)
		{
			// no need to retry unless the device is busy
			//
			if (lpWavIn->nLastError != MMSYSERR_ALLOCATED)
			{
				fSuccess = TraceFALSE(NULL);
				TracePrintf_1(NULL, 5,
					TEXT("waveInOpen failed (%u)\n"),
					(unsigned) lpWavIn->nLastError);
			}

			// no need to retry if flag not set
			//
			else if (!(lpWavIn->dwFlags & WAVIN_OPENRETRY))
				fSuccess = TraceFALSE(NULL);

			// no more retries if timeout occurred
			//
			else if (SysGetTimerCount() >= dwTimeout)
				fSuccess = TraceFALSE(NULL);

			else
			{
				MSG msg;

				if (PeekMessage(&msg, lpWavIn->hwndCallback, 0, 0, PM_REMOVE))
				{
				 	TranslateMessage(&msg);
				 	DispatchMessage(&msg);
				}

				else
#ifdef _WIN32
					Sleep(100);
#else
        		    WaitMessage();
#endif
			}
		}
	}

	// make sure a handle was returned
	//
	if (fSuccess && lpWavIn->hWaveIn == NULL)
		fSuccess = TraceFALSE(NULL);

	// wait for device open notification or timeout
	//
	if (fSuccess && !(lpWavIn->dwFlags & WAVIN_OPENASYNC))
	{
		DWORD dwTimeout = SysGetTimerCount() +
			(msTimeoutOpen == 0 ? 2000L : msTimeoutOpen);

#ifdef MULTITHREAD
		if (lpWavIn->dwFlags & WAVIN_MULTITHREAD)
		{
			DWORD dwRet;

			// wait for the device top be opened
			//
			if ((dwRet = WaitForSingleObject(
				lpWavIn->hEventDeviceOpened,
				(msTimeoutOpen == 0 ? 30000L : msTimeoutOpen))) != WAIT_OBJECT_0)
			{
				fSuccess = TraceFALSE(NULL);
			}
		}
		else
#endif
		while (fSuccess && !lpWavIn->fIsOpen)
		{
			MSG msg;

			if (SysGetTimerCount() >= dwTimeout)
				fSuccess = TraceFALSE(NULL);

			else if (PeekMessage(&msg, lpWavIn->hwndCallback, 0, 0, PM_REMOVE))
			{
			 	TranslateMessage(&msg);
			 	DispatchMessage(&msg);
			}

			else
        	    WaitMessage();
		}
	}

#ifdef MULTITHREAD
	// clean up
	//
	if (lpWavIn != NULL && lpWavIn->hEventDeviceOpened != NULL)
	{
		if (!CloseHandle(lpWavIn->hEventDeviceOpened))
			fSuccess = TraceFALSE(NULL);
		else
			lpWavIn->hEventDeviceOpened = NULL;
	}

	if (lpWavIn != NULL && lpWavIn->hThreadCallback != NULL)
	{
		if (!CloseHandle(lpWavIn->hThreadCallback))
			fSuccess = TraceFALSE(NULL);
		else
			lpWavIn->hThreadCallback = NULL;
	}
#endif

	if (fSuccess)
	{
		if ((lpWavIn->nLastError = waveInGetID(lpWavIn->hWaveIn,
			&lpWavIn->idDev)) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("waveInGetID failed (%u)\n"),
				(unsigned) lpWavIn->nLastError);
		}
	}

	if (!fSuccess)
	{
		WavInClose(WavInGetHandle(lpWavIn), 0);
		lpWavIn = NULL;
	}

	return fSuccess ? WavInGetHandle(lpWavIn) : NULL;
}

// WavInClose - close wav input device
//		<hWavIn>			(i) handle returned from WavInOpen
//		<msTimeoutClose>	(i) device close timeout in milleseconds
//			0					default timeout (30000)
// return 0 if success
//
// NOTE: if <hwndNotify> was specified in WavInOpen,
// WM_WAVIN_CLOSE will be sent to <hwndNotify>,
// when input device has been closed.
//
int DLLEXPORT WINAPI WavInClose(HWAVIN hWavIn, DWORD msTimeoutClose)
{
	BOOL fSuccess = TRUE;
	LPWAVIN lpWavIn;

#ifdef TELIN
	if (hWavIn != NULL && hWavIn == (HWAVIN) hTelIn)
	{
		int iRet = TelInClose((HTELIN) hWavIn, msTimeoutClose);
		hTelIn = NULL;
		return iRet;
	}
#endif

	if ((lpWavIn = WavInGetPtr(hWavIn)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// stop the device
	//
	else if (WavInStop(hWavIn, 0) != 0)
		fSuccess = TraceFALSE(NULL);

#ifdef MULTITHREAD
	// we need to know when device has been closed
	//
	else if ((lpWavIn->dwFlags & WAVIN_MULTITHREAD) &&
		(lpWavIn->hEventDeviceClosed = CreateEvent(
		NULL, FALSE, FALSE, NULL)) == NULL)
	{
		fSuccess = TraceFALSE(NULL);
	}
#endif

	// close the device
	//
	else if (lpWavIn->hWaveIn != NULL &&
		(lpWavIn->nLastError = waveInClose(lpWavIn->hWaveIn)) != 0)
	{
		fSuccess = TraceFALSE(NULL);
	 	TracePrintf_1(NULL, 5,
	 		TEXT("wavInClose failed (%u)\n"),
	 		(unsigned) lpWavIn->nLastError);
	}

	// wait for device close notification or timeout
	//
	if (fSuccess && !(lpWavIn->dwFlags & WAVIN_CLOSEASYNC))
	{
		DWORD dwTimeout = SysGetTimerCount() +
			(msTimeoutClose == 0 ? 30000L : msTimeoutClose);

#ifdef MULTITHREAD
		if (lpWavIn->dwFlags & WAVIN_MULTITHREAD)
		{
			DWORD dwRet;

			// wait for the device to be closed
			//
			if ((dwRet = WaitForSingleObject(
				lpWavIn->hEventDeviceClosed,
				(msTimeoutClose == 0 ? 30000L : msTimeoutClose))) != WAIT_OBJECT_0)
			{
				fSuccess = TraceFALSE(NULL);
			}
		}
		else
#endif
		while (fSuccess && lpWavIn->fIsOpen)
		{
			MSG msg;

			if (SysGetTimerCount() >= dwTimeout)
				fSuccess = TraceFALSE(NULL);

			else if (PeekMessage(&msg, lpWavIn->hwndCallback, 0, 0, PM_REMOVE))
			{
			 	TranslateMessage(&msg);
			 	DispatchMessage(&msg);
			}

			else
        	    WaitMessage();
		}
	}

#ifdef MULTITHREAD
	// clean up
	//
	if (lpWavIn != NULL && lpWavIn->hEventDeviceClosed != NULL)
	{
		if (!CloseHandle(lpWavIn->hEventDeviceClosed))
			fSuccess = TraceFALSE(NULL);
		else
			lpWavIn->hEventDeviceClosed = NULL;
	}
#endif

	if (fSuccess)
	{
#ifdef MULTITHREAD
	   	if (lpWavIn->dwFlags & WAVIN_MULTITHREAD)
		{
			while (lpWavIn->critSectionStop.OwningThread != NULL)
				Sleep(100L);

			DeleteCriticalSection(&(lpWavIn->critSectionStop));
		}
#endif
		// device handle is no longer valid
		//
		lpWavIn->hWaveIn = NULL;

		// destroy callback window
		//
		if (lpWavIn->hwndCallback != NULL &&
			!DestroyWindow(lpWavIn->hwndCallback))
			fSuccess = TraceFALSE(NULL);

		else if (lpWavIn->hwndCallback = NULL, FALSE)
			fSuccess = TraceFALSE(NULL);

		else if (lpWavIn->lpwfx != NULL &&
			WavFormatFree(lpWavIn->lpwfx) != 0)
			fSuccess = TraceFALSE(NULL);

		else if (lpWavIn->lpwfx = NULL, FALSE)
			fSuccess = TraceFALSE(NULL);

		else if ((lpWavIn = MemFree(NULL, lpWavIn)) != NULL)
			fSuccess = TraceFALSE(NULL);
	}

	return fSuccess ? 0 : -1;
}

// WavInRecord - submit buffer of samples to wav input device for recording
//		<hWavIn>			(i) handle returned from WavInOpen
//		<lpBuf>				(o) pointer to buffer to be filled with samples
//		<sizBuf>			(i) size of buffer in bytes
// return 0 if success
//
// NOTE: the buffer pointed to by <lpBuf> must have been allocated
// using MemAlloc().
//
// NOTE: if <hwndNotify> is specified in WavInOpen(), a WM_WAVIN_RECORDDONE
// message will be sent to <hwndNotify>, with <lParam> set to a pointer to
// a RECORDDONE structure, when <lpBuf> has been recorded.
//
int DLLEXPORT WINAPI WavInRecord(HWAVIN hWavIn, LPVOID lpBuf, long sizBuf)
{
	BOOL fSuccess = TRUE;
	LPWAVIN lpWavIn;
	LPWAVEHDR lpWaveHdr = NULL;

#ifdef TELIN
	if (hWavIn != NULL && hWavIn == (HWAVIN) hTelIn)
		return TelInRecord((HTELIN) hWavIn, lpBuf, sizBuf, -1);
#endif

	if ((lpWavIn = WavInGetPtr(hWavIn)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (lpBuf == NULL)
		fSuccess = TraceFALSE(NULL);

	else if ((lpWaveHdr = (LPWAVEHDR) MemAlloc(NULL,
		sizeof(WAVEHDR), 0)) == NULL)
	{
		fSuccess = TraceFALSE(NULL);
	}

	else
	{
		lpWaveHdr->lpData = (LPSTR) lpBuf;
		lpWaveHdr->dwBufferLength = (DWORD) sizBuf;

		if ((lpWavIn->nLastError = waveInPrepareHeader(lpWavIn->hWaveIn,
			lpWaveHdr, sizeof(WAVEHDR))) != 0)
		{
			fSuccess = TraceFALSE(NULL);
		 	TracePrintf_1(NULL, 5,
		 		TEXT("waveInPrepareHeader failed (%u)\n"),
	 			(unsigned) lpWavIn->nLastError);
		}

		else if ((lpWavIn->nLastError = waveInAddBuffer(lpWavIn->hWaveIn,
			lpWaveHdr, sizeof(WAVEHDR))) != 0)
		{
			fSuccess = TraceFALSE(NULL);
		 	TracePrintf_1(NULL, 5,
		 		TEXT("waveInAddBuffer failed (%u)\n"),
	 			(unsigned) lpWavIn->nLastError);
		}

		else if ((lpWavIn->nLastError = waveInStart(lpWavIn->hWaveIn)) != 0)
		{
			fSuccess = TraceFALSE(NULL);
		 	TracePrintf_1(NULL, 5,
		 		TEXT("waveInStart failed (%u)\n"),
		 		(unsigned) lpWavIn->nLastError);
		}

		else
		{
			++lpWavIn->cBufsPending;
			lpWavIn->wState = WAVIN_RECORDING;
		}
	}

	return fSuccess ? 0 : -1;
}

// WavInStop - stop recording into buffer(s) sent to wav input device
//		<hWavIn>			(i) handle returned from WavInOpen
//		<msTimeoutStop>		(i) device stop timeout in milleseconds
//			0					default timeout (2000)
// return 0 if success
//
int DLLEXPORT WINAPI WavInStop(HWAVIN hWavIn, DWORD msTimeoutStop)
{
	BOOL fSuccess = TRUE;
	LPWAVIN lpWavIn;

#ifdef TELIN
	if (hWavIn != NULL && hWavIn == (HWAVIN) hTelIn)
		return TelInStop((HTELIN) hWavIn, msTimeoutStop);
#endif

	if ((lpWavIn = WavInGetPtr(hWavIn)) == NULL)
		fSuccess = TraceFALSE(NULL);

#ifdef MULTITHREAD
	else if ((lpWavIn->dwFlags & WAVIN_MULTITHREAD) &&
		(EnterCriticalSection(&(lpWavIn->critSectionStop)), FALSE))
		;
#endif

	// make sure device is recording
	//
	else if (WavInGetState(hWavIn) == WAVIN_STOPPED)
		; // not an error to call this function when already stopped

	else if (lpWavIn->wState = WAVIN_STOPPING, FALSE)
		;

#ifdef MULTITHREAD
	// we need to know when device has been stopped
	//
	else if ((lpWavIn->dwFlags & WAVIN_MULTITHREAD) &&
		(lpWavIn->hEventDeviceStopped = CreateEvent(
			NULL, FALSE, FALSE, NULL)) == NULL)
	{
		fSuccess = TraceFALSE(NULL);
	}
#endif

	// stop the device
	//
	else if ((lpWavIn->nLastError = waveInReset(lpWavIn->hWaveIn)) != 0)
	{	
		fSuccess = TraceFALSE(NULL);
 		TracePrintf_1(NULL, 5,
 			TEXT("waveInReset failed (%u)\n"),
			(unsigned) lpWavIn->nLastError);
	}

	// wait for all pending buffers to complete
	//
#ifdef MULTITHREAD
	else if (lpWavIn->dwFlags & WAVIN_MULTITHREAD)
	{
		DWORD dwRet;

		LeaveCriticalSection(&(lpWavIn->critSectionStop));

		// wait for the device to be stopped
		//
		if ((dwRet = WaitForSingleObject(
			lpWavIn->hEventDeviceStopped,
			(msTimeoutStop == 0 ? 10000L : msTimeoutStop))) != WAIT_OBJECT_0)
		{
			fSuccess = TraceFALSE(NULL);
		}

		EnterCriticalSection(&(lpWavIn->critSectionStop));
	}
#endif
	else
	{
		DWORD dwTimeout = SysGetTimerCount() +
			(msTimeoutStop == 0 ? 2000L : msTimeoutStop);

		while (fSuccess && lpWavIn->cBufsPending > 0)
		{
			MSG msg;

			// check for timeout
			//
			if (SysGetTimerCount() >= dwTimeout)
				fSuccess = TraceFALSE(NULL);

			else if (PeekMessage(&msg, lpWavIn->hwndCallback, 0, 0, PM_REMOVE))
			{
		 		TranslateMessage(&msg);
		 		DispatchMessage(&msg);
			}

			else
       			WaitMessage();
		}
	}

#ifdef MULTITHREAD
	// clean up
	//
	if (lpWavIn != NULL && lpWavIn->hEventDeviceStopped != NULL)
	{
		if (!CloseHandle(lpWavIn->hEventDeviceStopped))
			fSuccess = TraceFALSE(NULL);
		else
			lpWavIn->hEventDeviceStopped = NULL;
	}

	if (lpWavIn != NULL && (lpWavIn->dwFlags & WAVIN_MULTITHREAD))
		LeaveCriticalSection(&(lpWavIn->critSectionStop));
#endif

	return fSuccess ? 0 : -1;
}

// WavInGetState - return current wav input device state
//		<hWavIn>			(i) handle returned from WavInOpen
// return WAVIN_STOPPED, WAVIN_RECORDING, or 0 if error
//
WORD DLLEXPORT WINAPI WavInGetState(HWAVIN hWavIn)
{
	BOOL fSuccess = TRUE;
	LPWAVIN lpWavIn;

#ifdef TELIN
	if (hWavIn != NULL && hWavIn == (HWAVIN) hTelIn)
		return TelInGetState((HTELIN) hWavIn);
#endif

	if ((lpWavIn = WavInGetPtr(hWavIn)) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lpWavIn->wState : 0;
}

// WavInGetPosition - get milleseconds of elapsed recording
//		<hWavIn>			(i) handle returned from WavInOpen
// return 0 if success
//
long DLLEXPORT WINAPI WavInGetPosition(HWAVIN hWavIn)
{
	BOOL fSuccess = TRUE;
	LPWAVIN lpWavIn;
	MMTIME mmtime;
	long msPosition;

#ifdef TELIN
	if (hWavIn != NULL && hWavIn == (HWAVIN) hTelIn)
		return TelInGetPosition((HTELIN) hWavIn);
#endif

	MemSet(&mmtime, 0, sizeof(mmtime));

	// we will be requesting position in millesconds
	//
	mmtime.wType = TIME_MS;

	if ((lpWavIn = WavInGetPtr(hWavIn)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// get device position
	//
	else if ((lpWavIn->nLastError = waveInGetPosition(
		lpWavIn->hWaveIn, &mmtime, sizeof(MMTIME))) != 0)
	{
		fSuccess = TraceFALSE(NULL);
	 	TracePrintf_1(NULL, 5,
	 		TEXT("waveInGetPosition failed (%u)\n"),
 			(unsigned) lpWavIn->nLastError);
	}

	// see what type of position was returned
	//
	else switch (mmtime.wType)
	{
		case TIME_MS:
		{
			// we got milleseconds; no conversion required
			//
			msPosition = (long) mmtime.u.ms;
		}
			break;

		case TIME_SAMPLES:
		{
			// convert samples to millesconds
			//
			msPosition = (long) MULDIVU32(mmtime.u.sample,
				1000L, lpWavIn->lpwfx->nSamplesPerSec);
		}
			break;

		case TIME_BYTES:
		{
			// convert bytes to millesconds
			//
			msPosition = (long) MULDIVU32(mmtime.u.cb,
				1000L, lpWavIn->lpwfx->nAvgBytesPerSec);
		}
			break;

		case TIME_SMPTE:
		case TIME_MIDI:
		default:
			fSuccess = TraceFALSE(NULL);
			break;
	}

	return fSuccess ? msPosition : -1;
}

// WavInGetId - return id of wav input device
//		<hWavIn>			(i) handle returned from WavInOpen
// return device id (-1 if error)
//
int DLLEXPORT WINAPI WavInGetId(HWAVIN hWavIn)
{
	BOOL fSuccess = TRUE;
	LPWAVIN lpWavIn;

#ifdef TELIN
	if (hWavIn != NULL && hWavIn == (HWAVIN) hTelIn)
		return TelInGetId((HTELIN) hWavIn);
#endif

	if ((lpWavIn = WavInGetPtr(hWavIn)) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? lpWavIn->idDev : -1;
}

// WavInGetName - get name of wav input device
//		<hWavIn>			(i) handle returned from WavInOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavIn> is not NULL)
//			-1					any suitable input device
//		<lpszName>			(o) buffer to hold device name
//		<sizName>			(i) size of buffer
// return 0 if success
//
int DLLEXPORT WINAPI WavInGetName(HWAVIN hWavIn, int idDev, LPTSTR lpszName, int sizName)
{
	BOOL fSuccess = TRUE;
	LPWAVIN lpWavIn;

#ifdef TELIN
	if (idDev == TELIN_DEVICEID || (hWavIn != NULL && hWavIn == (HWAVIN) hTelIn))
		return TelInGetName((HTELIN) hWavIn, idDev, lpszName, sizName);
#endif

	if (hWavIn != NULL)
	{
		if ((lpWavIn = WavInGetPtr(hWavIn)) == NULL)
			fSuccess = TraceFALSE(NULL);
		else
			idDev = lpWavIn->idDev;
	}

	if (fSuccess)
	{
		WAVEINCAPS wic;
		UINT nLastError;

		if ((nLastError = waveInGetDevCaps(idDev, &wic, sizeof(WAVEINCAPS))) != 0)
		{
			fSuccess = TraceFALSE(NULL);
			TracePrintf_1(NULL, 5,
				TEXT("waveInGetDevCaps failed (%u)\n"),
				(unsigned) nLastError);
		}

		else if (lpszName != NULL)
			StrNCpy(lpszName, wic.szPname, sizName);

		if (hWavIn != NULL && lpWavIn != NULL)
			lpWavIn->nLastError = nLastError;
	}

	return fSuccess ? 0 : -1;
}

// WavInGetIdByName - get id of wav input device, lookup by name
//		<lpszName>			(i) device name
#ifdef _WIN32
//			NULL or TEXT("")	get preferred device id
#endif
//		<dwFlags>			(i) reserved; must be zero
// return device id (-1 if error)
//
int WINAPI WavInGetIdByName(LPCTSTR lpszName, DWORD dwFlags)
{
	UINT idDev;
	UINT cDev = (UINT) WavInGetDeviceCount();

	// If no device specified, get the preferred device
	if ( !lpszName || (_tcslen(lpszName) <= 0) )
	{
		DWORD dwTemp;
		DWORD dwRet = waveInMessage( (HWAVEIN)(DWORD_PTR)WAVE_MAPPER, DRVM_MAPPER_PREFERRED_GET, (DWORD_PTR) &idDev, (DWORD_PTR) &dwTemp );
		if ( dwRet == MMSYSERR_NOERROR )
			return idDev;
	}
	else
	{
		// Device specified, search by name
		for ( idDev = 0; idDev < cDev; ++idDev )
		{
			TCHAR szName[256];
			if ( WavInGetName(NULL, idDev, szName, SIZEOFARRAY(szName)) == 0 )
			{
				if ( _tcsicmp(lpszName, szName) == 0 )
					return idDev;
			}
		}
	}

	// No match for device name
	TraceFALSE(NULL);
	return -1;
}

// WavInSupportsFormat - return TRUE if device supports specified format
//		<hWavIn>			(i) handle returned from WavInOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavIn> is not NULL)
//			-1					any suitable input device
//		<lpwfx>				(i) wave format
// return TRUE if device supports specified format
//
BOOL DLLEXPORT WINAPI WavInSupportsFormat(HWAVIN hWavIn, int idDev,
	LPWAVEFORMATEX lpwfx)
{
	BOOL fSuccess = TRUE;
	LPWAVIN lpWavIn;
	BOOL fSupportsFormat;

#ifdef TELIN
	if (idDev == TELIN_DEVICEID || (hWavIn != NULL && hWavIn == (HWAVIN) hTelIn))
		return TelInSupportsFormat((HTELIN) hWavIn, idDev, lpwfx);
#endif

	if (hWavIn != NULL)
	{
		if ((lpWavIn = WavInGetPtr(hWavIn)) == NULL)
			fSuccess = TraceFALSE(NULL);
		else
			idDev = lpWavIn->idDev;
	}

	if (fSuccess)
	{
		UINT nLastError;

		// query the device
		//
		if ((nLastError = waveInOpen(NULL, (UINT) idDev,
#ifndef _WIN32
			(LPWAVEFORMAT)
#endif
			lpwfx, 0,  0,
			WAVE_FORMAT_QUERY)) != 0)
		{
			fSupportsFormat = FALSE;
#if 1
			if (TraceGetLevel(NULL) >= 9)
			{
				TracePrintf_0(NULL, 9,
					TEXT("unsupported format:\n"));
				WavFormatDump(lpwfx);
			}
#endif
			if (nLastError != WAVERR_BADFORMAT)
			{
				fSuccess = TraceFALSE(NULL);
				TracePrintf_1(NULL, 5,
					TEXT("waveInOpen/FormatQuery failed (%u)\n"),
					(unsigned) nLastError);
			}
		}

		else
			fSupportsFormat = TRUE;

		if (hWavIn != NULL && lpWavIn != NULL)
			lpWavIn->nLastError = nLastError;
	}

	return fSuccess ? fSupportsFormat : FALSE;
}

// WavInFormatSuggest - suggest a new format which the device supports
//		<hWavIn>			(i) handle returned from WavInOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavIn> is not NULL)
//			-1					any suitable input device
//		<lpwfxSrc>			(i) source format
//		<dwFlags>			(i)	control flags
//			WAVIN_NOACM			do not use audio compression manager
// return pointer to suggested format, NULL if error
//
// NOTE: the format structure returned is dynamically allocated.
// Use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI WavInFormatSuggest(
	HWAVIN hWavIn, int idDev, LPWAVEFORMATEX lpwfxSrc, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;
	LPWAVIN lpWavIn;
	LPWAVEFORMATEX lpwfxSuggest = NULL;
	LPWAVEFORMATEX lpwfxTemp = NULL;
	HACM hAcm = NULL;

#ifdef TELIN
	if (idDev == TELIN_DEVICEID || (hWavIn != NULL && hWavIn == (HWAVIN) hTelIn))
		return TelInFormatSuggest((HTELIN) hWavIn, idDev, lpwfxSrc, dwFlags);
#endif

	if (hWavIn != NULL)
	{
		if ((lpWavIn = WavInGetPtr(hWavIn)) == NULL)
			fSuccess = TraceFALSE(NULL);
		else
		{
			idDev = lpWavIn->idDev;
			if (lpWavIn->dwFlags & WAVIN_NOACM)
				dwFlags |= WAVIN_NOACM;
		}
	}

	if ((hAcm = AcmInit(ACM_VERSION, SysGetTaskInstance(NULL),
		(dwFlags & WAVIN_NOACM) ? ACM_NOACM : 0)) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (!WavFormatIsValid(lpwfxSrc))
		fSuccess = TraceFALSE(NULL);

	else if ((lpwfxTemp = WavFormatDup(lpwfxSrc)) == NULL)
		fSuccess = TraceFALSE(NULL);

	// get suggested format, see if it is supported
	//
	if (fSuccess && lpwfxSuggest == NULL)
	{
		if ((lpwfxSuggest = AcmFormatSuggest(hAcm, lpwfxTemp,
			-1, -1, -1, -1, 0)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if (WavFormatFree(lpwfxTemp) != 0)
			fSuccess = TraceFALSE(NULL);

		else if (!WavInSupportsFormat(NULL, idDev, lpwfxSuggest))
		{
			lpwfxTemp = lpwfxSuggest;
			lpwfxSuggest = NULL;
		}
	}

	// get suggested PCM format, see if it is supported
	//
	if (fSuccess && lpwfxSuggest == NULL &&
		lpwfxTemp->wFormatTag != WAVE_FORMAT_PCM)
	{
		if ((lpwfxSuggest = AcmFormatSuggest(hAcm, lpwfxTemp,
			WAVE_FORMAT_PCM, -1, -1, -1, 0)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if (WavFormatFree(lpwfxTemp) != 0)
			fSuccess = TraceFALSE(NULL);

		else if (!WavInSupportsFormat(NULL, idDev, lpwfxSuggest))
		{
			lpwfxTemp = lpwfxSuggest;
			lpwfxSuggest = NULL;
		}
	}

	// get suggested PCM mono format, see if it is supported
	//
	if (fSuccess && lpwfxSuggest == NULL &&
		lpwfxTemp->nChannels != 1)
	{
		if ((lpwfxSuggest = AcmFormatSuggest(hAcm, lpwfxTemp,
			WAVE_FORMAT_PCM, -1, -1, 1, 0)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if (WavFormatFree(lpwfxTemp) != 0)
			fSuccess = TraceFALSE(NULL);

		else if (!WavInSupportsFormat(NULL, idDev, lpwfxSuggest))
		{
			lpwfxTemp = lpwfxSuggest;
			lpwfxSuggest = NULL;
		}
	}

	// get suggested PCM 8-bit mono format, see if it is supported
	//
	if (fSuccess && lpwfxSuggest == NULL &&
		lpwfxTemp->wBitsPerSample != 8)
	{
		if ((lpwfxSuggest = AcmFormatSuggest(hAcm, lpwfxTemp,
			WAVE_FORMAT_PCM, -1, 8, 1, 0)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if (WavFormatFree(lpwfxTemp) != 0)
			fSuccess = TraceFALSE(NULL);

		else if (!WavInSupportsFormat(NULL, idDev, lpwfxSuggest))
		{
			lpwfxTemp = lpwfxSuggest;
			lpwfxSuggest = NULL;
		}
	}

	// get suggested PCM 11025Hz 8-bit mono format, see if it is supported
	//
	if (fSuccess && lpwfxSuggest == NULL &&
		lpwfxTemp->nSamplesPerSec != 11025)
	{
		if ((lpwfxSuggest = AcmFormatSuggest(hAcm, lpwfxTemp,
			WAVE_FORMAT_PCM, 11025, 8, 1, 0)) == NULL)
			fSuccess = TraceFALSE(NULL);

		else if (WavFormatFree(lpwfxTemp) != 0)
			fSuccess = TraceFALSE(NULL);

		else if (!WavInSupportsFormat(NULL, idDev, lpwfxSuggest))
		{
			lpwfxTemp = lpwfxSuggest;
			lpwfxSuggest = NULL;
		}
	}

	// last resort; see if MULAW 8000Hz 8-bit mono format is supported
	//
	if (fSuccess && lpwfxSuggest == NULL)
	{
#if 0
		if ((lpwfxSuggest = AcmFormatSuggest(hAcm, lpwfxTemp,
			WAVE_FORMAT_MULAW, 8000, 8, 1, 0)) == NULL)
#else
		if ((lpwfxSuggest = WavFormatMulaw(NULL, 8000)) == NULL)
#endif
			fSuccess = TraceFALSE(NULL);

		else if (WavFormatFree(lpwfxTemp) != 0)
			fSuccess = TraceFALSE(NULL);

		else if (!WavInSupportsFormat(NULL, idDev, lpwfxSuggest))
		{
			// no more chances for success
			//
			fSuccess = TraceFALSE(NULL);
			if (WavFormatFree(lpwfxSuggest) != 0)
				fSuccess = TraceFALSE(NULL);
		}
	}

	// clean up
	//
	if (hAcm != NULL && AcmTerm(hAcm) != 0)
		fSuccess = TraceFALSE(NULL);
	else
		hAcm = NULL;

	return fSuccess ? lpwfxSuggest : NULL;
}

// WavInTerm - shut down wav input residuals, if any
// 		<hInst>				(i) instance handle of calling module
//		<dwFlags>			(i) control flags
//			WAV_TELTHUNK		terminate telephone thunking layer
// return 0 if success
//
int DLLEXPORT WINAPI WavInTerm(HINSTANCE hInst, DWORD dwFlags)
{
	BOOL fSuccess = TRUE;

	if (hInst == NULL)
		fSuccess = TraceFALSE(NULL);

#ifdef TELIN
	else if ((dwFlags & WAV_TELTHUNK) &&
		TelInTerm(hInst, dwFlags) != 0)
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? 0 : -1;
}

////
//	helper functions
////

#ifdef MULTITHREAD
DWORD WINAPI WavInCallbackThread(LPVOID lpvThreadParameter)
{
	BOOL fSuccess = TRUE;
	MSG msg;
	LPWAVIN lpWavIn = (LPWAVIN) lpvThreadParameter;

	// make sure message queue is created before calling SetEvent
	//
	PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);

	// notify main thread that callback thread has begun execution
	//
	if (!SetEvent(lpWavIn->hEventThreadCallbackStarted))
	{
		fSuccess = TraceFALSE(NULL);
	}

	while (fSuccess && GetMessage(&msg, NULL, 0, 0))
	{
		WavInCallback((HWND) lpWavIn, msg.message, msg.wParam, msg.lParam);

		// exit thread when when have processed last expected message
		//
		if (msg.message == MM_WIM_CLOSE)
			break;
	}

	return 0;
}
#endif

// WavInCallback - window procedure for wavin callback
//
LRESULT DLLEXPORT CALLBACK WavInCallback(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	BOOL fSuccess = TRUE;
	LRESULT lResult;
	LPWAVIN lpWavIn;

#ifdef MULTITHREAD
	if (!IsWindow(hwnd))
		lpWavIn = (LPWAVIN) hwnd;
	else
#endif
	// retrieve lpWavIn from window extra bytes
	//
	lpWavIn = (LPWAVIN) GetWindowLongPtr(hwnd, 0);

	switch (msg)
	{
		case WM_NCCREATE:
		{
			LPCREATESTRUCT lpcs = (LPCREATESTRUCT) lParam;
			LPWAVIN lpWavIn = (LPWAVIN) lpcs->lpCreateParams;

			// store lpWavIn in window extra bytes
			//
			SetWindowLongPtr(hwnd, 0, (LONG_PTR) lpWavIn);

			lResult = DefWindowProc(hwnd, msg, wParam, lParam);
		}
			break;

		case MM_WIM_OPEN:
		{
			HWAVEIN hWaveIn = (HWAVEIN) wParam;

		 	TraceOutput(NULL, 5,
				TEXT("MM_WIM_OPEN\n"));

#ifdef MULTITHREAD
			if (!(lpWavIn->dwFlags & WAVIN_MULTITHREAD) &&
				hWaveIn != lpWavIn->hWaveIn)
#else
			if (hWaveIn != lpWavIn->hWaveIn)
#endif
				fSuccess = TraceFALSE(NULL);

			else
			{
				lpWavIn->fIsOpen = TRUE;

#ifdef MULTITHREAD
				// notify main thread that device is open
				//
				if ((lpWavIn->dwFlags & WAVIN_MULTITHREAD) &&
					!SetEvent(lpWavIn->hEventDeviceOpened))
				{
					fSuccess = TraceFALSE(NULL);
				}
#endif
				// send notification of device opening
				//
#ifdef MULTITHREAD
				if (lpWavIn->dwFlags & WAVIN_MULTITHREAD)
				{
					if ( lpWavIn->hwndNotify )
						PostThreadMessage( HandleToUlong(lpWavIn->hwndNotify), WM_WAVIN_OPEN, 0, 0);
				}
				else
#endif
				{
					if (lpWavIn->hwndNotify != NULL &&
						IsWindow(lpWavIn->hwndNotify))
					{
						SendMessage(lpWavIn->hwndNotify, WM_WAVIN_OPEN, 0, 0);
					}
				}
			}

			lResult = 0L;
		}
			break;

		case MM_WIM_CLOSE:
		{
			HWAVEIN hWaveIn = (HWAVEIN) wParam;

		 	TraceOutput(NULL, 5,
				TEXT("MM_WIM_CLOSE\n"));

#ifdef MULTITHREAD
			if (!(lpWavIn->dwFlags & WAVIN_MULTITHREAD) &&
				hWaveIn != lpWavIn->hWaveIn)
#else
			if (hWaveIn != lpWavIn->hWaveIn)
#endif
				fSuccess = TraceFALSE(NULL);

			else
			{
				lpWavIn->fIsOpen = FALSE;

				// send notification of device closure
				//
#ifdef MULTITHREAD
				if (lpWavIn->dwFlags & WAVIN_MULTITHREAD)
				{
					if ( lpWavIn->hwndNotify )
						PostThreadMessage(HandleToUlong(lpWavIn->hwndNotify), WM_WAVIN_CLOSE, 0, 0);
				}
				else
#endif
				{
					if (lpWavIn->hwndNotify != NULL &&
						IsWindow(lpWavIn->hwndNotify))
					{
						SendMessage(lpWavIn->hwndNotify, WM_WAVIN_CLOSE, 0, 0);
					}
				}
#ifdef MULTITHREAD
				// notify main thread that device is closed
				//
				if ((lpWavIn->dwFlags & WAVIN_MULTITHREAD) &&
					!SetEvent(lpWavIn->hEventDeviceClosed))
				{
					fSuccess = TraceFALSE(NULL);
				}
#endif
			}

			lResult = 0L;
		}
			break;

		case MM_WIM_DATA:
		{
			HWAVEIN hWaveIn = (HWAVEIN) wParam;
			LPWAVEHDR lpWaveHdr = (LPWAVEHDR) lParam;
			LPVOID lpBuf;
			long sizBuf;
			long lBytesRecorded;

		 	TracePrintf_1(NULL, 5,
		 		TEXT("MM_WIM_DATA (%lu)\n"),
	 			(unsigned long) lpWaveHdr->dwBytesRecorded);

#ifdef MULTITHREAD
			if (lpWavIn->dwFlags & WAVIN_MULTITHREAD)
				EnterCriticalSection(&(lpWavIn->critSectionStop));
#endif
#ifdef MULTITHREAD
			if (!(lpWavIn->dwFlags & WAVIN_MULTITHREAD) &&
				hWaveIn != lpWavIn->hWaveIn)
#else
			if (hWaveIn != lpWavIn->hWaveIn)
#endif
				fSuccess = TraceFALSE(NULL);

			else if (lpWaveHdr == NULL)
				fSuccess = TraceFALSE(NULL);

			// NULL buffer is possible with telephone, this is ok
			// 
			else if ((lpBuf = (LPVOID) lpWaveHdr->lpData) == NULL, FALSE)
				;

			else if (sizBuf = (long) lpWaveHdr->dwBufferLength, FALSE)
				fSuccess = TraceFALSE(NULL);

			else if (lBytesRecorded = (long) lpWaveHdr->dwBytesRecorded, FALSE)
				fSuccess = TraceFALSE(NULL);

			else if (!(lpWaveHdr->dwFlags & WHDR_DONE))
				fSuccess = TraceFALSE(NULL);

			else if (!(lpWaveHdr->dwFlags & WHDR_PREPARED))
				fSuccess = TraceFALSE(NULL);

			else if ((lpWavIn->nLastError = waveInUnprepareHeader(
				lpWavIn->hWaveIn, lpWaveHdr, sizeof(WAVEHDR))) != 0)
			{
				fSuccess = TraceFALSE(NULL);
			 	TracePrintf_1(NULL, 5,
			 		TEXT("waveInUnprepareHeader failed (%u)\n"),
		 			(unsigned) lpWavIn->nLastError);
			}

			else if ((lpWaveHdr = MemFree(NULL, lpWaveHdr)) != NULL)
				fSuccess = TraceFALSE(NULL);

			else if (--lpWavIn->cBufsPending < 0)
				fSuccess = TraceFALSE(NULL);

			// device is no longer recording if no more buffers pending
			//
			else if (lpWavIn->cBufsPending == 0)
			{
				lpWavIn->wState = WAVIN_STOPPED;

#ifdef MULTITHREAD
				// notify main thread that device is stopped
				//
				if ((lpWavIn->dwFlags & WAVIN_MULTITHREAD) &&
					lpWavIn->hEventDeviceStopped != NULL &&
					!SetEvent(lpWavIn->hEventDeviceStopped))
				{
					fSuccess = TraceFALSE(NULL);
				}
#endif
			}

			if (fSuccess)
			{
				RECORDDONE recorddone;

				recorddone.lpBuf = lpBuf;
				recorddone.sizBuf = sizBuf;
				recorddone.lBytesRecorded = lBytesRecorded;

				// send notification of recording completion
				//
#ifdef MULTITHREAD
				if (lpWavIn->dwFlags & WAVIN_MULTITHREAD)
				{
					if ( lpWavIn->hwndNotify )
					{
						SendThreadMessage(HandleToUlong(lpWavIn->hwndNotify),
							WM_WAVIN_RECORDDONE, (LPARAM) (LPVOID) &recorddone);
					}
				}
				else
#endif
				{
					if (lpWavIn->hwndNotify != NULL &&
						IsWindow(lpWavIn->hwndNotify))
					{
						SendMessage(lpWavIn->hwndNotify,
							WM_WAVIN_RECORDDONE, 0, (LPARAM) (LPVOID) &recorddone);
					}
				}
			}

			lResult = 0L;
#ifdef MULTITHREAD
			if (lpWavIn->dwFlags & WAVIN_MULTITHREAD)
				LeaveCriticalSection(&(lpWavIn->critSectionStop));
#endif
		}
			break;

		default:
			lResult = DefWindowProc(hwnd, msg, wParam, lParam);
			break;
	}
	
	return lResult;
}

// WavInGetPtr - verify that wavin handle is valid,
//		<hWavIn>				(i) handle returned from WavInInit
// return corresponding wavin pointer (NULL if error)
//
static LPWAVIN WavInGetPtr(HWAVIN hWavIn)
{
	BOOL fSuccess = TRUE;
	LPWAVIN lpWavIn;

	if ((lpWavIn = (LPWAVIN) hWavIn) == NULL)
		fSuccess = TraceFALSE(NULL);

	else if (IsBadWritePtr(lpWavIn, sizeof(WAVIN)))
		fSuccess = TraceFALSE(NULL);

#ifdef CHECKTASK
	// make sure current task owns the wavin handle
	//
	else if (lpWavIn->hTask != GetCurrentTask())
		fSuccess = TraceFALSE(NULL);
#endif

	return fSuccess ? lpWavIn : NULL;
}

// WavInGetHandle - verify that wavin pointer is valid,
//		<lpWavIn>				(i) pointer to WAVIN struct
// return corresponding wavin handle (NULL if error)
//
static HWAVIN WavInGetHandle(LPWAVIN lpWavIn)
{
	BOOL fSuccess = TRUE;
	HWAVIN hWavIn;

	if ((hWavIn = (HWAVIN) lpWavIn) == NULL)
		fSuccess = TraceFALSE(NULL);

	return fSuccess ? hWavIn : NULL;
}

#ifdef MULTITHREAD

static LRESULT SendThreadMessage(DWORD dwThreadId, UINT Msg, LPARAM lParam)
{
	BOOL fSuccess = TRUE;
	HANDLE hEventMessageProcessed = NULL;
	DWORD dwRet;

	// we need to know when message has been processed
	//
	if ((hEventMessageProcessed = CreateEvent(
		NULL, FALSE, FALSE, NULL)) == NULL)
	{
		fSuccess = TraceFALSE(NULL);
	}

	// post message to thread, send event handle as wParam
	//
	else if (!PostThreadMessage(dwThreadId, Msg, (WPARAM) hEventMessageProcessed, lParam))
	{
		fSuccess = TraceFALSE(NULL);
	}

	// wait for the message to be processed
	//
	else if ((dwRet = WaitForSingleObject(
		hEventMessageProcessed, INFINITE)) != WAIT_OBJECT_0)
	{
		fSuccess = TraceFALSE(NULL);
	}

	// clean up
	//
	if (hEventMessageProcessed != NULL)
	{
		if (!CloseHandle(hEventMessageProcessed))
			fSuccess = TraceFALSE(NULL);
		else
			hEventMessageProcessed = NULL;
	}

	return 0L;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\avwav\wavout.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// wavout.h - interface for wav output device functions in wavout.c
////

#ifndef __WAVOUT_H__
#define __WAVOUT_H__

#ifdef _WIN32
#define MULTITHREAD 1
#endif

#include "winlocal.h"

#include "wavfmt.h"

#define WAVOUT_VERSION 0x00000108

// handle to wav output device (NOT the same as Windows HWAVEOUT)
//
DECLARE_HANDLE32(HWAVOUT);

// <dwFlags> values in WavOutOpen
//
#define WAVOUT_NOSYNC		0x00000001
#define WAVOUT_AUTOFREE		0x00000002
#define WAVOUT_OPENRETRY	0x00000004
#define WAVOUT_OPENASYNC	0x00000008
#define WAVOUT_CLOSEASYNC	0x00000010
#define WAVOUT_NOACM		0x00000020
#define WAVOUT_TELRFILE		0x00000040
#ifdef MULTITHREAD
#define WAVOUT_MULTITHREAD 0x00000080
#endif

// notification messages sent to <hwndNotify>
//
#define WM_WAVOUT_OPEN			(WM_USER + 100)
#define WM_WAVOUT_CLOSE			(WM_USER + 101)
#define WM_WAVOUT_PLAYDONE		(WM_USER + 102)
#define WM_WAVOUT_STOPPLAY		(WM_USER + 103)

// structure passed as <lParam> in WM_WAVOUT_PLAYDONE message
//
typedef struct PLAYDONE
{
	LPVOID lpBuf;
	long sizBuf;
} PLAYDONE, FAR *LPPLAYDONE;

// return values from WavOutGetState
//
#define WAVOUT_STOPPED		0x0001
#define WAVOUT_PLAYING		0x0002
#define WAVOUT_PAUSED		0x0004
#define WAVOUT_STOPPING		0x0008

#ifdef __cplusplus
extern "C" {
#endif

// WavOutGetDeviceCount - return number of wav output devices found
//		<void>				this function takes no arguments
// return number of wav output devices found (0 if none)
//
int DLLEXPORT WINAPI WavOutGetDeviceCount(void);

// WavOutDeviceIsOpen - check if output device is open
//		<idDev>				(i) device id
//			-1					open any suitable output device
// return TRUE if open
//
BOOL DLLEXPORT WINAPI WavOutDeviceIsOpen(int idDev);

// WavOutOpen - open wav output device
//		<dwVersion>			(i) must be WAVOUT_VERSION
// 		<hInst>				(i) instance handle of calling module
//		<idDev>				(i) device id
//			-1					open any suitable output device
//		<lpwfx>				(i) wave format
//		<hwndNotify>		(i) notify this window of device events
//			NULL				do not notify
//		<msTimeoutOpen>		(i) device open timeout in milleseconds
//			0					default timeout (30000)
//		<msTimeoutRetry>	(i) device retry timeout in milleseconds
//			0					default timeout (2000)
//		<dwFlags>			(i) control flags
//			WAVOUT_NOSYNC		do not open synchronous devices
//			WAVOUT_AUTOFREE		free each buffer after playback
//			WAVOUT_OPENRETRY	retry if device busy
//			WAVOUT_OPENASYNC	return before notification of device open
//			WAVOUT_CLOSEASYNC	return before notification of device close
//			WAVOUT_NOACM		do not use audio compression manager
//			WAVOUT_TELRFILE		telephone will play/record audio on server
#ifdef MULTITHREAD
//			WAVOUT_MULTITHREAD use callback thread rather than window
#endif
// return handle (NULL if error)
//
// NOTE: if <hwndNotify> is specified in WavOutOpen,
// WM_WAVOUT_OPEN will be sent to <hwndNotify>,
// when output device has been opened.
//
// NOTE: if WAVOUT_MULTITHREAD is specified in <dwFlags>,
// it is assumed that <hwndNotify> is not a window handle,
// but rather the id of the thread to receive notifications
//
HWAVOUT DLLEXPORT WINAPI WavOutOpen(DWORD dwVersion, HINSTANCE hInst,
	int idDev, LPWAVEFORMATEX lpwfx, HWND hwndNotify,
	DWORD msTimeoutOpen, DWORD msTimeoutRetry, DWORD dwFlags);

// WavOutClose - close wav output device
//		<hWavOut>			(i) handle returned from WavOutOpen
//		<msTimeoutClose>	(i) device close timeout in milleseconds
//			0					default timeout (30000)
// return 0 if success
//
// NOTE: if <hwndNotify> was specified in WavOutOpen,
// WM_WAVOUT_CLOSE will be sent to <hwndNotify>,
// when output device has been closed.
//
int DLLEXPORT WINAPI WavOutClose(HWAVOUT hWavOut, DWORD msTimeoutClose);

// WavOutPlay - submit buffer of samples to wav output device for playback
//		<hWavOut>			(i) handle returned from WavOutOpen
//		<lpBuf>				(i) pointer to buffer containing samples
//		<sizBuf>			(i) size of buffer in bytes
// return 0 if success
//
// NOTE: the buffer pointed to by <lpBuf> must have been allocated
// using MemAlloc().
//
// NOTE: if <hwndNotify> is specified in WavOutOpen(), a WM_WAVOUT_PLAYDONE
// message will be sent to <hwndNotify>, with <lParam> set to a pointer to
// a PLAYDONE structure, when <lpBuf> has been played.
//
// NOTE: if WAVOUT_AUTOFREE flag is specified in WavOutOpen,
// GlobalFreePtr(lpBuf) will be called when <lpBuf> has been played.
//
int DLLEXPORT WINAPI WavOutPlay(HWAVOUT hWavOut, LPVOID lpBuf, long sizBuf);

// WavOutStop - stop playback of buffer(s) sent to wav output device
//		<hWavOut>			(i) handle returned from WavOutOpen
//		<msTimeoutStop>		(i) device stop timeout in milleseconds
//			0					default timeout (2000)
// return 0 if success
//
int DLLEXPORT WINAPI WavOutStop(HWAVOUT hWavOut, DWORD msTimeoutStop);

// WavOutPause - pause wav output device playback
//		<hWavOut>			(i) handle returned from WavOutOpen
// return 0 if success
//
int DLLEXPORT WINAPI WavOutPause(HWAVOUT hWavOut);

// WavOutResume - resume wav output device playback
//		<hWavOut>			(i) handle returned from WavOutOpen
// return 0 if success
//
int DLLEXPORT WINAPI WavOutResume(HWAVOUT hWavOut);

// WavOutGetState - return current wav output device state
//		<hWavOut>			(i) handle returned from WavOutOpen
// return WAVOUT_STOPPED, WAVOUT_PLAYING, WAVOUT_PAUSED, or 0 if error
//
WORD DLLEXPORT WINAPI WavOutGetState(HWAVOUT hWavOut);

// WavOutGetPosition - get milleseconds of elapsed playback
//		<hWavOut>			(i) handle returned from WavOutOpen
// return 0 if success
//
long DLLEXPORT WINAPI WavOutGetPosition(HWAVOUT hWavOut);

// WavOutGetId - return id of wav output device
//		<hWavOut>			(i) handle returned from WavOutOpen
// return device id (-1 if error)
//
int DLLEXPORT WINAPI WavOutGetId(HWAVOUT hWavOut);

// WavOutGetName - get name of wav output device
//		<hWavOut>			(i) handle returned from WavOutOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavOut> is not NULL)
//			-1					any suitable output device
//		<lpszName>			(o) buffer to hold device name
//		<sizName>			(i) size of buffer
// return 0 if success
//
int DLLEXPORT WINAPI WavOutGetName(HWAVOUT hWavOut, int idDev, LPTSTR lpszName, int sizName);

// WavOutGetIdByName - get id of wav output device, lookup by name
//		<lpszName>			(i) device name
#ifdef _WIN32
//			NULL or TEXT("")	get preferred device id
#endif
//		<dwFlags>			(i) reserved; must be zero
// return device id (-1 if error)
//
int WINAPI WavOutGetIdByName(LPCTSTR lpszName, DWORD dwFlags);

// WavOutSupportsFormat - return TRUE if device supports specified format
//		<hWavOut>			(i) handle returned from WavOutOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavOut> is not NULL)
//			-1					any suitable output device
//		<lpwfx>				(i) wave format
// return TRUE if device supports specified format
//
BOOL DLLEXPORT WINAPI WavOutSupportsFormat(HWAVOUT hWavOut, int idDev,
	LPWAVEFORMATEX lpwfx);

// WavOutFormatSuggest - suggest a new format which the device supports
//		<hWavOut>			(i) handle returned from WavOutOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavOut> is not NULL)
//			-1					any suitable output device
//		<lpwfxSrc>			(i) source format
//		<dwFlags>			(i)	control flags
//			WAVOUT_NOACM		do not use audio compression manager
// return pointer to suggested format, NULL if error
//
// NOTE: the format structure returned is dynamically allocated.
// Use WavFormatFree() to free the buffer.
//
LPWAVEFORMATEX DLLEXPORT WINAPI WavOutFormatSuggest(
	HWAVOUT hWavOut, int idDev,	LPWAVEFORMATEX lpwfxSrc, DWORD dwFlags);

// WavOutIsSynchronous - return TRUE if wav output device is synchronous
//		<hWavOut>			(i) handle returned from WavOutOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavOut> is not NULL)
//			-1					any suitable output device
// return TRUE if wav output device is synchronous
//
BOOL DLLEXPORT WINAPI WavOutIsSynchronous(HWAVOUT hWavOut, int idDev);

// WavOutSupportsVolume - return TRUE if device supports volume control
//		<hWavOut>			(i) handle returned from WavOutOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavOut> is not NULL)
// return TRUE if device supports volume control
//
BOOL DLLEXPORT WINAPI WavOutSupportsVolume(HWAVOUT hWavOut, int idDev);

// WavOutSupportsSpeed - return TRUE if device supports speed control
//		<hWavOut>			(i) handle returned from WavOutOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavOut> is not NULL)
// return TRUE if device supports speed control
//
BOOL DLLEXPORT WINAPI WavOutSupportsSpeed(HWAVOUT hWavOut, int idDev);

// WavOutSupportsPitch - return TRUE if device supports pitch control
//		<hWavOut>			(i) handle returned from WavOutOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavOut> is not NULL)
// return TRUE if device supports pitch control
//
BOOL DLLEXPORT WINAPI WavOutSupportsPitch(HWAVOUT hWavOut, int idDev);

// WavOutGetVolume - get current volume level
//		<hWavOut>			(i) handle returned from WavOutOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavOut> is not NULL)
// return volume level (0 minimum through 100 maximum, -1 if error)
//
int DLLEXPORT WINAPI WavOutGetVolume(HWAVOUT hWavOut, int idDev);

// WavOutSetVolume - set current volume level
//		<hWavOut>			(i) handle returned from WavOutOpen
//			NULL				use unopened device specified in <idDev>
//		<idDev>				(i) device id (ignored if <hWavOut> is not NULL)
//		<nLevel>			(i) volume level
//			0					minimum volume
//			100					maximum volume
// return 0 if success
//
int DLLEXPORT WINAPI WavOutSetVolume(HWAVOUT hWavOut, int idDev, int nLevel);

// WavOutGetSpeed - get current speed level
//		<hWavOut>			(i) handle returned from WavOutOpen
// return speed level (100 is normal, 50 is half, 200 is double, -1 if error)
//
int DLLEXPORT WINAPI WavOutGetSpeed(HWAVOUT hWavOut);

// WavOutSetSpeed - set current speed level
//		<hWavOut>			(i) handle returned from WavOutOpen
//		<nLevel>			(i) speed level
//			50					half speed
//			100					normal speed
//			200					double speed, etc.
// return 0 if success
//
int DLLEXPORT WINAPI WavOutSetSpeed(HWAVOUT hWavOut, int nLevel);

// WavOutGetPitch - get current pitch level
//		<hWavOut>			(i) handle returned from WavOutOpen
// return pitch level (100 is normal, 50 is half, 200 is double, -1 if error)
//
int DLLEXPORT WINAPI WavOutGetPitch(HWAVOUT hWavOut);

// WavOutSetPitch - set current pitch level
//		<hWavOut>			(i) handle returned from WavOutOpen
//		<nLevel>			(i) pitch level
//			50					half pitch
//			100					normal pitch
//			200					double pitch, etc.
// return 0 if success
//
int DLLEXPORT WINAPI WavOutSetPitch(HWAVOUT hWavOut, int nLevel);

// WavOutTerm - shut down wav output residuals, if any
// 		<hInst>				(i) instance handle of calling module
//		<dwFlags>			(i) control flags
//			0					reserved; must be zero
// return 0 if success
//
int DLLEXPORT WINAPI WavOutTerm(HINSTANCE hInst, DWORD dwFlags);

#ifdef __cplusplus
}
#endif

#endif // __WAVOUT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\confprop\confinfo.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// TAPIDialer(tm) and ActiveDialer(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526; 5,488,650; 
// 5,434,906; 5,581,604; 5,533,102; 5,568,540, 5,625,676.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

/* $FILEHEADER
*
* FILE
*   ConfInfo.h
*
* CLASS
*	CConfInfo
*
*/

#if !defined(AFX_CONFINFO_H__CE5346F6_4AFC_11D1_84F1_00608CBAE3F4__INCLUDED_)
#define AFX_CONFINFO_H__CE5346F6_4AFC_11D1_84F1_00608CBAE3F4__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <atlbase.h>
#include <iads.h>
#include <rend.h>
#include <sdpblb.h>

typedef enum tagConfCommitError
{
   CONF_COMMIT_ERROR_NONE=0,
   CONF_COMMIT_ERROR_INVALIDDATETIME,
   CONF_COMMIT_ERROR_INVALIDNAME,
   CONF_COMMIT_ERROR_INVALIDOWNER,
   CONF_COMMIT_ERROR_INVALIDDESCRIPTION,
   CONF_COMMIT_ERROR_INVALIDSECURITYDESCRIPTOR,
   CONF_COMMIT_ERROR_MDHCPFAILED,
   CONF_COMMIT_ERROR_GENERALFAILURE,
}ConfCommitError;

class CConfInfo  
{
public:
	CConfInfo();
	virtual ~CConfInfo();

// Members
public:
	IADsSecurityDescriptor			*m_pSecDesc;
	ITDirectoryObjectConference		*m_pITConf;

	long							m_lScopeID;
	bool							m_bNewConference;
	bool							m_bDateTimeChange;

    // TRUE if user selects a row from the scopes list
    bool                            m_bUserSelected;

    // TRUE if has been showed the 'Start/Stop Change Date Message'
    bool                            m_bDateChangeMessage;

protected:
	ITRendezvous *m_pITRend;
	ITDirectoryObject **m_ppDirObject;
	BSTR m_bstrName;
	BSTR m_bstrDescription;
	BSTR m_bstrOwner;

	SYSTEMTIME	m_stStartTime;
	SYSTEMTIME	m_stStopTime;
	DATE		m_dateStart;
	DATE		m_dateStop;
	bool		m_bSecuritySet;

// Attributes
public:
	void get_Name(BSTR *pbstrName);
	void put_Name(BSTR bstrName);
	void get_Description(BSTR *pbstrDescription);
	void put_Description(BSTR bstrDescription);
	void get_Originator(BSTR *pbstrOwner);
	void put_Originator(BSTR bstrOwner);
	void GetStartTime(USHORT *nYear, BYTE *nMonth, BYTE *nDay, BYTE *nHour, BYTE *nMinute);
	void SetStartTime(USHORT nYear, BYTE nMonth, BYTE nDay, BYTE nHour, BYTE nMinute);
	void GetStopTime(USHORT *nYear, BYTE *nMonth, BYTE *nDay, BYTE *nHour, BYTE *nMinute);
	void SetStopTime(USHORT nYear, BYTE nMonth, BYTE nDay, BYTE nHour, BYTE nMinute);
	void GetPrimaryUser( BSTR *pbstrTrustee );
	bool IsNewConference()		{ return m_bNewConference; }
	bool WasSecuritySet()				{ return true; /*return m_bSecuritySet;*/ }
	void SetSecuritySet( bool bSet )	{ m_bSecuritySet = bSet; }


// Operations
public:
	static bool PopulateListWithMDHCPScopeDescriptions( HWND hWndList );
	static HRESULT CreateMDHCPAddress( ITSdp *pSdp, SYSTEMTIME *pStart, SYSTEMTIME *pStop, long lScopeID, bool bUserSelected );
	static HRESULT SetMDHCPAddress( ITMediaCollection *pMC, BSTR bstrAddress, long lCount, unsigned char nTTL );

	HRESULT Init(ITRendezvous *pITRend, ITDirectoryObjectConference *pITConf, ITDirectoryObject **ppDirObject, bool bNewConf );
	HRESULT CommitGeneral( DWORD& dwCommitError );
	HRESULT CommitSecurity( DWORD& dwCommitError, bool bCreate );
	HRESULT	AddDefaultACEs( bool bCreate );
};

#endif // !defined(AFX_CONFINFO_H__CE5346F6_4AFC_11D1_84F1_00608CBAE3F4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\confprop\confinfo.cpp ===
////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// TAPIDialer(tm) and ActiveDialer(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526; 5,488,650; 
// 5,434,906; 5,581,604; 5,533,102; 5,568,540, 5,625,676.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

/* $FILEHEADER
*
* FILE
*   ConfInfo.cpp
*
* CLASS
*	CConfInfo
*
* RESPONSIBILITIES
*	Creates / Gathers info about a conference
*
*/

#include "ConfInfo.h"
#include <limits.h>
#include <mdhcp.h>
#include "winlocal.h"
#include "objsec.h"
#include "rndsec.h"
#include "res.h"
#include "ThreadPub.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
//#define new DEBUG_NEW
#endif

CConfInfo::CConfInfo()
{
	// General properties
	m_pITRend = NULL;
	m_pITConf = NULL;
	m_ppDirObject = NULL;
	m_pSecDesc = NULL;
	m_bSecuritySet = false;
	m_bNewConference = false;
	m_bDateTimeChange = false;

	m_lScopeID = -1;		        // default is auto-select
    m_bUserSelected = false;        // the user doesn't select a scope
    m_bDateChangeMessage = false;   // wasn't show yet the message

	// Conference Info
	m_bstrName = NULL;
	m_bstrDescription = NULL;
	m_bstrOwner = NULL;

	// Default start time is immediately, default end time is +30m
	GetLocalTime( &m_stStartTime );
	GetLocalTime( &m_stStopTime );

	// Add 30 minutes to current time
	DATE dateNow;
	SystemTimeToVariantTime( &m_stStopTime, &dateNow );
	dateNow += (DATE) (.25 / 12);
	VariantTimeToSystemTime( dateNow, &m_stStopTime );
}

CConfInfo::~CConfInfo()
{
	SysFreeString(m_bstrName);
	SysFreeString(m_bstrDescription);
	SysFreeString(m_bstrOwner);

	if (m_pSecDesc)
		m_pSecDesc->Release();
}
 
/****************************************************************************
* Init
*	Stores the address of the ITRendezvous and ITDirectoryObjectConference interface
*	pointers.  When creating a new conference the calling function should set pITConf
*	to NULL.  When editing an existing conference, pITConf should point to the interface
*	of the conference COM object. 
*
* Return Value
*	Returns the HRESULT from the Rendezvous functions 
*
* Comments
*****************************************************************************/
HRESULT CConfInfo::Init(ITRendezvous *pITRend, ITDirectoryObjectConference *pITConf, ITDirectoryObject **ppDirObject, bool bNewConf )
{
	HRESULT hr = 0;
	m_pITRend = pITRend;
	m_pITConf = pITConf;
	m_bNewConference = (bool) (bNewConf || (m_pITConf == NULL));

	// store the pointer to the directory object
	m_ppDirObject = ppDirObject;

	// Create a conference, or edit an existing one?
	if ( m_pITConf )
	{
		// Start and stop time
		m_pITConf->get_StartTime( &m_dateStart );
		VariantTimeToSystemTime( m_dateStart, &m_stStartTime );

		m_pITConf->get_StopTime( &m_dateStop );
		VariantTimeToSystemTime( m_dateStop, &m_stStopTime );

		// get the ITSdp interface
		ITConferenceBlob *pITConferenceBlob;
		if ( SUCCEEDED(hr = m_pITConf->QueryInterface(IID_ITConferenceBlob, (void **) &pITConferenceBlob)) )
		{
			ITSdp *pITSdp;
			if ( SUCCEEDED(hr = pITConferenceBlob->QueryInterface(IID_ITSdp, (void **) &pITSdp)) )
			{
				pITSdp->get_Name( &m_bstrName );
				pITSdp->get_Originator( &m_bstrOwner );
				pITSdp->get_Description( &m_bstrDescription );
				pITSdp->Release();
			}

			pITConferenceBlob->Release();
		}

		if ( SUCCEEDED(hr) )
		{
			// get the security descriptor for the directory object
			if ( SUCCEEDED(hr = m_pITConf->QueryInterface(IID_ITDirectoryObject, (void **) m_ppDirObject)) )
			{
				hr = (*m_ppDirObject)->get_SecurityDescriptor( (IDispatch**) &m_pSecDesc );

				// Clean up
				(*m_ppDirObject)->Release();
				*m_ppDirObject = NULL;
			}
		}
	}
	else
	{
		// Setup defaults for the new conference
		SysFreeString( m_bstrOwner );
		m_bstrOwner = NULL;
		GetPrimaryUser( &m_bstrOwner );
	}

	return hr;
}

void CConfInfo::get_Name(BSTR *pbstrName)
{
	*pbstrName = SysAllocString( m_bstrName );
}

void CConfInfo::put_Name(BSTR bstrName)
{
	SysReAllocString(&m_bstrName, bstrName);
}

void CConfInfo::get_Description(BSTR *pbstrDescription)
{
	*pbstrDescription = SysAllocString( m_bstrDescription );
}

void CConfInfo::put_Description(BSTR bstrDescription)
{
	SysReAllocString(&m_bstrDescription, bstrDescription);
}

void CConfInfo::get_Originator(BSTR *pbstrOwner)
{
	*pbstrOwner = SysAllocString( m_bstrOwner );
}

void CConfInfo::put_Originator(BSTR bstrOwner)
{
	SysReAllocString(&m_bstrOwner, bstrOwner);
}

void CConfInfo::GetStartTime(USHORT *nYear, BYTE *nMonth, BYTE *nDay, BYTE *nHour, BYTE *nMinute)
{
	*nYear = m_stStartTime.wYear;
	*nMonth = (BYTE)m_stStartTime.wMonth;
	*nDay = (BYTE)m_stStartTime.wDay;
	*nHour = (BYTE)m_stStartTime.wHour;
	*nMinute = (BYTE)m_stStartTime.wMinute;
}

void CConfInfo::SetStartTime(USHORT nYear, BYTE nMonth, BYTE nDay, BYTE nHour, BYTE nMinute)
{
	m_stStartTime.wYear = nYear;
	m_stStartTime.wMonth = nMonth;
	m_stStartTime.wDay = nDay;
	m_stStartTime.wHour = nHour;
	m_stStartTime.wMinute = nMinute;
}

void CConfInfo::GetStopTime(USHORT *nYear, BYTE *nMonth, BYTE *nDay, BYTE *nHour, BYTE *nMinute)
{
	*nYear = m_stStopTime.wYear;
	*nMonth = (BYTE)m_stStopTime.wMonth;
	*nDay = (BYTE)m_stStopTime.wDay;
	*nHour = (BYTE)m_stStopTime.wHour;
	*nMinute = (BYTE)m_stStopTime.wMinute;
}

void CConfInfo::SetStopTime(USHORT nYear, BYTE nMonth, BYTE nDay, BYTE nHour, BYTE nMinute)
{
	m_stStopTime.wYear = nYear;
	m_stStopTime.wMonth = nMonth;
	m_stStopTime.wDay = nDay;
	m_stStopTime.wHour = nHour;
	m_stStopTime.wMinute = nMinute;
}

void CConfInfo::GetPrimaryUser(BSTR *pbstrTrustee)
{
	HRESULT		hr = S_OK;
    TOKEN_USER  *tokenUser = NULL;
    HANDLE      tokenHandle = NULL;
    DWORD       tokenSize = 0;
    DWORD       sidLength = 0;

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &tokenHandle))
	{
		ATLTRACE(_T("OpenProcessToken failed\n"));
        return;
	}

	// get the needed size for the tokenUser structure
	else 
    {
        GetTokenInformation(tokenHandle, TokenUser, tokenUser, 0, &tokenSize);
        if ( tokenSize == 0)
	    {
            CloseHandle( tokenHandle );
		    ATLTRACE(_T("GetTokenInformation failed"));
            return;
	    }
	    else
	    {
		    // allocate the tokenUser structure
            BYTE* pToken = new BYTE[tokenSize];
            if( pToken == NULL )
            {
			    ATLTRACE(_T("new tokenUser failed\n"));
                CloseHandle( tokenHandle );
                return;
            }

            // initialize the memory
            memset( pToken, 0, sizeof(BYTE)*tokenSize);

            // cast to the token user
            tokenUser = (TOKEN_USER *)pToken;

		    // get the tokenUser info for the current process
            if (!GetTokenInformation(tokenHandle, TokenUser, tokenUser, tokenSize, &tokenSize))
		    {
                CloseHandle( tokenHandle );
                delete [] pToken;
                pToken = NULL;
                tokenUser = NULL;

			    ATLTRACE(_T("GetTokenInformation failed\n"));
                return;
		    }
		    else
            {
			    TCHAR			domainName [256];
			    TCHAR			userName [256];
			    DWORD			nameLength;
			    SID_NAME_USE	snu;

 			    nameLength = 255;
                if (!LookupAccountSid(NULL,
											     tokenUser->User.Sid,
											     userName,
											     &nameLength,
											     domainName,
											     &nameLength,
											     &snu))
			    {
				    ATLTRACE(_T("LookupAccountSid failed (0x%08lx)\n"),hr);
			    }
			    else
			    {
				    USES_CONVERSION;
				    SysReAllocString(pbstrTrustee, T2OLE(userName));
			    }

		        CloseHandle (tokenHandle);
                delete [] pToken;
                pToken = NULL;
                tokenUser = NULL;
            }
        }
	}
}

/****************************************************************************
* Commit
*	Creates / Modifies the actual conference. 
*
* Return Value
*	Returns the HRESULT from the Rendezvous functions 
*
* Comments
*****************************************************************************/
HRESULT CConfInfo::CommitGeneral(DWORD& dwCommitError)
{
	HRESULT hr = E_FAIL;
	dwCommitError = CONF_COMMIT_ERROR_GENERALFAILURE;

	bool bNewMDHCP = true;
	bool bNewConf = IsNewConference();
	HCURSOR hCurOld = SetCursor( LoadCursor(NULL, IDC_WAIT) );

	// Are we creating a conference from scratch?
	if ( !m_pITConf )
	{
		// Need to create a conference
		if ( SUCCEEDED(hr = m_pITRend->CreateDirectoryObject(OT_CONFERENCE, m_bstrName, m_ppDirObject)) && *m_ppDirObject )
		{
			if ( FAILED(hr = (*m_ppDirObject)->QueryInterface(IID_ITDirectoryObjectConference, (void **) &m_pITConf)) )
				ATLTRACE(_T("(*m_ppDirObject)->QueryInterface(IID_ITDirectoryObjectConference... failed (0x%08lx)\n"),hr);

			(*m_ppDirObject)->Release();
			*m_ppDirObject = NULL;
		}
		else
		{
			ATLTRACE(_T("CreateDirectoryObject failed (0x%08lx)\n"),hr);
		}
	}

	// Should we create a new MDHCP IP address lease?
	DATE dateStart, dateStop;
	SystemTimeToVariantTime( &m_stStartTime, &dateStart );
	SystemTimeToVariantTime( &m_stStopTime, &dateStop );
	if ( !bNewConf && (dateStart == m_dateStart) && (dateStop == m_dateStop) )
	{
		ATLTRACE(_T("CConfInfo::CommitGeneral() -- not changing the MDHCP address for the conf.\n"));
		bNewMDHCP = false;
	}

	// set the conference attributes
	if (  m_pITConf )
	{
		ITConferenceBlob *pITConferenceBlob = NULL;
		ITSdp *pITSdp = NULL;
		DATE vtime;

		// Retrieve the owner for the conference
		if ( !m_bstrOwner )
			GetPrimaryUser( &m_bstrOwner );

		// set the conference start time
		if (FAILED(hr = SystemTimeToVariantTime(&m_stStartTime, &vtime)))
		{
			dwCommitError = CONF_COMMIT_ERROR_INVALIDDATETIME;
			ATLTRACE(_T("SystemTimeToVariantTime failed (0x%08lx)\n"),hr);
		}

		else if (FAILED(hr = m_pITConf->put_StartTime(vtime)))
		{
			dwCommitError = CONF_COMMIT_ERROR_INVALIDDATETIME;
			ATLTRACE(_T("put_StartTime failed (0x%08lx)\n"),hr);
		}

		// set the conference stop time
		else if (FAILED(hr = SystemTimeToVariantTime(&m_stStopTime, &vtime)))
		{
			dwCommitError = CONF_COMMIT_ERROR_INVALIDDATETIME;
			ATLTRACE(_T("SystemTimeToVariantTime failed (0x%08lx)\n"),hr);
		}

		else if (FAILED(hr = m_pITConf->put_StopTime(vtime)))
		{
	        dwCommitError = CONF_COMMIT_ERROR_INVALIDDATETIME;
			ATLTRACE(_T("put_StopTime failed (0x%08lx)\n"),hr);
		}

		// get the ITSdp interface
		else if ( SUCCEEDED(hr = m_pITConf->QueryInterface(IID_ITConferenceBlob, (void **) &pITConferenceBlob)) )
		{
			if ( SUCCEEDED(hr = pITConferenceBlob->QueryInterface(IID_ITSdp, (void **) &pITSdp)) )
			{
				// set the owner of the conference
				if (FAILED(hr = pITSdp->put_Originator(m_bstrOwner)))
				{
					dwCommitError = CONF_COMMIT_ERROR_INVALIDOWNER;
					ATLTRACE(_T("put_Originator failed (0x%08lx)\n"),hr);
				}

				// set the conference description
				else if (FAILED(hr = pITSdp->put_Description(m_bstrDescription)))
				{
					dwCommitError = CONF_COMMIT_ERROR_INVALIDDESCRIPTION;
					ATLTRACE(_T("put_Description failed (0x%08lx)\n"),hr);
				}

				else if ( bNewMDHCP && FAILED(hr = CreateMDHCPAddress(pITSdp, &m_stStartTime, &m_stStopTime, m_lScopeID, m_bUserSelected)) )
				{	
					dwCommitError = CONF_COMMIT_ERROR_MDHCPFAILED;
					ATLTRACE(_T("CreateMDHCPAddress failed (0x%08lx)\n"), hr );
				}

				// if this was an existing conference then allow for changing the name
				else if ( bNewConf )
				{
					if (FAILED(hr = pITSdp->put_Name(m_bstrName)))
					{
						dwCommitError = CONF_COMMIT_ERROR_INVALIDNAME;
						ATLTRACE(_T("put_Name failed (0x%08lx)\n"),hr);
					}
				}
				pITSdp->Release();
			}
			pITConferenceBlob->Release();
		}
		else
		{
			dwCommitError = CONF_COMMIT_ERROR_GENERALFAILURE;
			ATLTRACE(_T("m_pITConf->QueryInterface(IID_ITConferenceBlob... failed (0x%08lx)\n"),hr);
		}
	}

	SetCursor( hCurOld );
	return hr;
}

HRESULT CConfInfo::CommitSecurity(DWORD& dwCommitError, bool bCreate)
{
	HRESULT hr = E_FAIL;
	dwCommitError = CONF_COMMIT_ERROR_GENERALFAILURE;
	HCURSOR hCurOld = SetCursor( LoadCursor(NULL, IDC_WAIT) );

	if ( m_pITConf )
	{
		if (SUCCEEDED(hr = m_pITConf->QueryInterface(IID_ITDirectoryObject, (void **) m_ppDirObject)) && *m_ppDirObject)
		{
			// Setup the default conference security
			if ( !m_pSecDesc )
			{
				hr = CoCreateInstance( CLSID_SecurityDescriptor,
									   NULL,
									   CLSCTX_INPROC_SERVER,
									   IID_IADsSecurityDescriptor,
									   (void **) &m_pSecDesc );

				// Add default settings if successfully created the ACE
				if ( SUCCEEDED(hr) )
					hr = AddDefaultACEs( bCreate );
			}


			// if we created a new security descriptor for the conference, then save it
			if ( m_pSecDesc )
			{
				if (FAILED(hr = (*m_ppDirObject)->put_SecurityDescriptor((IDispatch *)m_pSecDesc)))
				{
					dwCommitError = CONF_COMMIT_ERROR_INVALIDSECURITYDESCRIPTOR;
					ATLTRACE(_T("put_SecurityDescriptor failed (0x%08lx)\n"),hr);
				}
			}
		}
		else
		{
			ATLTRACE(_T("m_pITConf->QueryInterface(IID_ITDirectoryObject... failed (0x%08lx)\n"),hr);
		}
	}

	SetCursor( hCurOld );
	return hr;
}



/////////////////////////////////////////////////////////////////////////////////
// MDHCP support
//
bool CConfInfo::PopulateListWithMDHCPScopeDescriptions( HWND hWndList )
{
	USES_CONVERSION;

	if ( !IsWindow(hWndList) ) return false;


	// First create the MDHCP wrapper object
	int nScopeCount = 0;
	IMcastAddressAllocation *pIMcastAddressAllocation;
	HRESULT hr = CoCreateInstance(  CLSID_McastAddressAllocation,
									NULL,
									CLSCTX_INPROC_SERVER,
									IID_IMcastAddressAllocation,
									(void **) &pIMcastAddressAllocation );
	
	if ( SUCCEEDED(hr) )
	{
		IEnumMcastScope *pEnum = NULL;
		if ( SUCCEEDED(hr = pIMcastAddressAllocation->EnumerateScopes(&pEnum)) )
		{
			// Clear out list
			SendMessage( hWndList, LB_RESETCONTENT, 0, 0 );

			IMcastScope *pScope = NULL;
			while ( SUCCEEDED(hr) && ((hr = pEnum->Next(1, &pScope, NULL)) == S_OK) && pScope )
			{
				if ( IsWindow(hWndList) )
				{
					// Retrieve scope information
					long lScopeID;
					BSTR bstrDescription = NULL;
					pScope->get_ScopeDescription( &bstrDescription );
					pScope->get_ScopeID( &lScopeID );
					ATLTRACE(_T(".1.CConfInfo::CreateMDHCPAddress() scope ID = %ld, description is %s.\n"), lScopeID, bstrDescription );

					// Add information to list box
					long nIndex = SendMessage(hWndList, LB_ADDSTRING, 0, (LPARAM) OLE2CT(bstrDescription));
					if ( nIndex >= 0 )
					{
						nScopeCount++;
						SendMessage(hWndList, LB_SETITEMDATA, nIndex, (LPARAM) lScopeID );
					}

					SysFreeString( bstrDescription );
				}
				else
				{
					hr = E_ABORT;
				}

				// Clean up
				pScope->Release();
				pScope = NULL;
			}
			pEnum->Release();
		}
		pIMcastAddressAllocation->Release();
	}

	// Select first item in the list
	if ( SUCCEEDED(hr) && (nScopeCount > 0) )
	{
		SendMessage( hWndList, LB_SETCURSEL, 0, 0 );
		EnableWindow( hWndList, TRUE );
	}
	else if ( IsWindow(hWndList) )
	{
		MessageBox(GetParent(hWndList), String(g_hInstLib, IDS_CONFPROP_SCOPEENUMFAILED), NULL, MB_OK | MB_ICONEXCLAMATION );
	}

	return (bool) (hr == S_OK);
}


HRESULT CConfInfo::CreateMDHCPAddress( ITSdp *pSdp, SYSTEMTIME *pStart, SYSTEMTIME *pStop, long lScopeID, bool bUserSelected )
{
	_ASSERT( pSdp && pStart && pStop );

	// First create the MDHCP wrapper object
	IMcastAddressAllocation *pIMcastAddressAllocation;
	HRESULT hr = CoCreateInstance(  CLSID_McastAddressAllocation,
									NULL,
									CLSCTX_INPROC_SERVER,
									IID_IMcastAddressAllocation,
									(void **) &pIMcastAddressAllocation );
	
	if ( SUCCEEDED(hr) )
	{
		ITMediaCollection *pMC = NULL;
		if ( SUCCEEDED(hr = pSdp->get_MediaCollection(&pMC)) && pMC )
		{
			long lMCCount = 0;
			pMC->get_Count( &lMCCount );

			IEnumMcastScope *pEnum = NULL;
			if ( SUCCEEDED(hr = pIMcastAddressAllocation->EnumerateScopes(&pEnum)) )
			{
				hr = E_FAIL;

				// Try scopes until you run out or succeed
				long lCount = 1;
				IMcastScope *pScope = NULL;
				while ( FAILED(hr) && ((hr = pEnum->Next(1, &pScope, NULL)) == S_OK) && pScope )
				{
					// If the scope ID has been specified, make sure that this scope matches
					if ( bUserSelected )
					{
						long lID;
						pScope->get_ScopeID(&lID);
						if ( lID != lScopeID )
						{
							hr = E_FAIL;
                            pScope->Release();
							continue;
						}
					}

					DATE dateStart, dateStop;
					SystemTimeToVariantTime( pStart, &dateStart );
					SystemTimeToVariantTime( pStop, &dateStop );

					// Need to assign addresses to all media collections for the conference
					while ( SUCCEEDED(hr) && (lCount <= lMCCount) )
					{
						IMcastLeaseInfo *pInfo = NULL;
						hr = pIMcastAddressAllocation->RequestAddress( pScope, dateStart, dateStop, 1, &pInfo );
						if ( SUCCEEDED(hr) && pInfo )
						{
							unsigned char nTTL = 15;
							long lTemp;
							if ( SUCCEEDED(pInfo->get_TTL(&lTemp)) && (lTemp >= 0) && (lTemp <= UCHAR_MAX) )
								nTTL = (unsigned char) nTTL;

							IEnumBstr *pEnumAddr = NULL;
							if ( SUCCEEDED(hr = pInfo->EnumerateAddresses(&pEnumAddr)) && pEnumAddr )
							{
								BSTR bstrAddress = NULL;

								// Must set addressess for all media types on the conference
								if ( SUCCEEDED((hr = pEnumAddr->Next(1, &bstrAddress, NULL))) && bstrAddress && SysStringLen(bstrAddress) )
								{
									hr = SetMDHCPAddress( pMC, bstrAddress, lCount, nTTL );	
									lCount++;
								}

								SysFreeString( bstrAddress );
								pEnumAddr->Release();
							}
						}
					}

					// Clean up
					pScope->Release();
					pScope = NULL;

                    // Try with just one scope
                    if( FAILED( hr ) && 
                        (bUserSelected == false) )
                        break;
				}

				// Convert to failure
				if ( hr == S_FALSE ) hr = E_FAIL;
				pEnum->Release();
			}
			pMC->Release();
		}
		pIMcastAddressAllocation->Release();
	}

	return hr;
}

HRESULT CConfInfo::SetMDHCPAddress( ITMediaCollection *pMC, BSTR bstrAddress, long lCount, unsigned char nTTL )
{
	_ASSERT( pMC && bstrAddress && (lCount > 0) );
	HRESULT hr;

	ITMedia *pMedia = NULL;
	if ( SUCCEEDED(hr = pMC->get_Item(lCount, &pMedia)) && pMedia )
	{
		ITConnection *pITConn = NULL;
		if ( SUCCEEDED(hr = pMedia->QueryInterface(IID_ITConnection, (void **) &pITConn)) && pITConn )
		{
			hr = pITConn->SetAddressInfo( bstrAddress, 1, nTTL );
			pITConn->Release();
		}
		pMedia->Release();
	}

	return hr;
}

HRESULT	CConfInfo::AddDefaultACEs( bool bCreate )
{
	HRESULT hr = S_OK;
	bool bOwner = false, bWorld = false;
	PACL pACL = NULL;
	PSID pSidWorld = NULL;
	DWORD dwAclSize = sizeof(ACL), dwTemp;
	BSTR bstrTemp = NULL;
	LPWSTR pszTemp = NULL;

    HANDLE hToken;
    UCHAR *pInfoBuffer = NULL;
    DWORD cbInfoBuffer = 512;

	// Only create owner ACL if requested
	if ( bCreate )
	{
		if( !OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken) )
		{
			if( GetLastError() == ERROR_NO_TOKEN )
			{
				// attempt to open the process token, since no thread token exists
				if( !OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken) )
					return E_FAIL;
			}
			else
			{
				// error trying to get thread token
				return E_FAIL;
			}
		}

		// Loop until we have a large enough structure
		while ( (pInfoBuffer = new UCHAR[cbInfoBuffer]) != NULL )
		{
			if ( !GetTokenInformation(hToken, TokenUser, pInfoBuffer, cbInfoBuffer, &cbInfoBuffer) )
			{
				delete pInfoBuffer;
				pInfoBuffer = NULL;

				if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
					return E_FAIL;
			}
			else
			{
				break;
			}
		}
		CloseHandle(hToken);

		// Did we get the owner ACL?
		if ( pInfoBuffer )
		{
			INC_ACCESS_ACL_SIZE( dwAclSize, ((PTOKEN_USER) pInfoBuffer)->User.Sid );
			bOwner = true;
		}
	}

	// Make SID for "Everyone"
	SysReAllocString( &bstrTemp, L"S-1-1-0" );
	hr = ConvertStringToSid( bstrTemp, &pSidWorld, &dwTemp, &pszTemp );
	if ( SUCCEEDED(hr) )
	{
		INC_ACCESS_ACL_SIZE( dwAclSize, pSidWorld );
		bWorld = true;
	}

	////////////////////////////////////
	// Create the ACL containing the Owner and World ACEs
	pACL = (PACL) new BYTE[dwAclSize];
	if ( pACL )
	{
		BAIL_ON_BOOLFAIL( InitializeAcl(pACL, dwAclSize, ACL_REVISION) );

		// Add World Rights
		if ( bWorld )
		{
			if ( bOwner )
			{
				BAIL_ON_BOOLFAIL( AddAccessAllowedAce(pACL, ACL_REVISION, ACCESS_READ, pSidWorld) );
			}
			else
			{
				BAIL_ON_BOOLFAIL( AddAccessAllowedAce(pACL, ACL_REVISION, ACCESS_ALL , pSidWorld) );
			}
		}

		// Add Creator rights
		if ( bOwner )
			BAIL_ON_BOOLFAIL( AddAccessAllowedAce(pACL, ACL_REVISION, ACCESS_ALL, ((PTOKEN_USER) pInfoBuffer)->User.Sid) );


		// Set the DACL onto our security descriptor
		VARIANT varDACL;
		VariantInit( &varDACL );
		if ( SUCCEEDED(hr = ConvertACLToVariant((PACL) pACL, &varDACL)) )
		{
			if ( SUCCEEDED(hr = m_pSecDesc->put_DaclDefaulted(FALSE)) )
				hr = m_pSecDesc->put_DiscretionaryAcl( V_DISPATCH(&varDACL) );
		}
		VariantClear( &varDACL );
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}

// Clean up
failed:
	SysFreeString( bstrTemp );
	if ( pACL ) delete pACL;
	if ( pSidWorld ) delete pSidWorld;
	if ( pInfoBuffer ) delete pInfoBuffer;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\confprop\res.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// res.h - resource functions
////

#ifndef __RES_H__
#define __RES_H__

#include "resource.h"

#define ARRAYSIZE(_AR_)		(sizeof(_AR_) / sizeof(_AR_[0]))

// Bug397418 Increase the szRes from 256 to 512 to make space
// for IDS_CONFPROP_MDHCP_FAILED string resource
static TCHAR szRes[512];
#define String(hInst, uID) \
	(*szRes = '\0', LoadString(hInst, uID, szRes, ARRAYSIZE(szRes)), szRes)
//	_lstrcpy((LPTCHAR) _alloca(256), szRes))

#endif // __RES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\confprop\objsec.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and29 product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

#ifndef _OBJSEC_H_
#define _OBJSEC_H_

#include "aclui.h"
#include "confprop.h"
#include "objsel.h"

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
//Class CObjSecurity
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

class CObjSecurity : public ISecurityInformation, IDsObjectPicker
{
public:
   CObjSecurity();
    virtual ~CObjSecurity();

protected:
    ULONG                   m_cRef;
    DWORD                   m_dwSIFlags;
    CONFPROP				*m_pConfProp;
	BSTR					m_bstrObject;
	BSTR					m_bstrPage;
    IDsObjectPicker			*m_pObjectPicker;

// Interface methods
public:
    STDMETHOD(InternalInitialize)(CONFPROP* pConfProp);

    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID, LPVOID *);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    
    // ISecurityInformation methods
    STDMETHOD(GetObjectInformation)(PSI_OBJECT_INFO pObjectInfo);
    STDMETHOD(GetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR *ppSD,
                           BOOL fDefault);
    STDMETHOD(SetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR pSD);
    STDMETHOD(GetAccessRights)(const GUID* pguidObjectType,
                               DWORD dwFlags,
                               PSI_ACCESS *ppAccess,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess);
    STDMETHOD(MapGeneric)(const GUID *pguidObjectType,
                          UCHAR *pAceFlags,
                          ACCESS_MASK *pmask);
    STDMETHOD(GetInheritTypes)(PSI_INHERIT_TYPE *ppInheritTypes,
                               ULONG *pcInheritTypes);
    STDMETHOD(PropertySheetPageCallback)(HWND hwnd,
                                         UINT uMsg,
                                         SI_PAGE_TYPE uPage);

    // IDsObjectPicker
    STDMETHOD(Initialize)(PDSOP_INIT_INFO pInitInfo);
    STDMETHOD(InvokeDialog)(HWND hwndParent, IDataObject **ppdoSelection);
};



/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
//Defines
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) { goto failed; }

#define BAIL_ON_BOOLFAIL(_FN_) \
		if ( !_FN_ )									\
		{												\
			hr = HRESULT_FROM_WIN32(GetLastError());	\
			goto failed;								\
		}

#define INC_ACCESS_ACL_SIZE(_SIZE_, _SID_)	\
		_SIZE_ += (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) + GetLengthSid(_SID_));


extern HINSTANCE g_hInstLib;

#define INHERIT_FULL            (CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE)

//
// DESCRIPTION OF ACCESS FLAG AFFECTS
//
// SI_ACCESS_GENERAL shows up on general properties page
// SI_ACCESS_SPECIFIC shows up on advanced page
// SI_ACCESS_CONTAINER shows on general page IF object is a container
//
// The following array defines the permission names for my objects.
//

// Access rights for our private objects
/*
#define ACCESS_READ		0x10
#define ACCESS_MODIFY   0x20
#define ACCESS_DELETE   (DELETE | WRITE_DAC | 0xf)
*/
#define ACCESS_READ		0x10
#define ACCESS_WRITE	0x20
#define ACCESS_MODIFY   (ACCESS_WRITE | WRITE_DAC)
#define ACCESS_DELETE   DELETE

#define ACCESS_ALL		(ACCESS_READ | ACCESS_MODIFY | ACCESS_DELETE)



#endif //_OBJSEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\confprop\confprop.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// confprop.h - conference properties dialog box
////

#ifndef _INC_CONFPROP_DLG
#define _INC_CONFPROP_DLG

//#ifdef __cplusplus
//extern "C" {
//#endif

#include "winlocal.h"

#include "tapi3if.h"
#include "rend.h"
#include "ConfInfo.h"

typedef struct CONFPROP
{
	DWORD dwFlags;
	CConfInfo	ConfInfo;
} CONFPROP, FAR *LPCONFPROP;

////
// public
////

INT64 ConfProp_DoModal( HWND hwndOwner, CONFPROP &confprop );

void ConfProp_Init( HINSTANCE hInst );

//#ifdef __cplusplus
//}
//#endif

#endif  // !_INC_DLG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\confprop\cpgen.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// cpgen.h - conference properties general dialog box
////

#ifndef _INC_CONFPROPGENERAL_DLG
#define _INC_CONFPROPGENERAL_DLG

#include "winlocal.h"
#include "oleauto.h"
#include "tapi3if.h"
#include "rend.h"

int DLLEXPORT WINAPI ConfPropGeneral_DoModal(HWND hwndOwner, DWORD dwUser);
INT_PTR DLLEXPORT CALLBACK ConfPropGeneral_DlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

#endif  // !_INC_DLG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\confprop\rndsec.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    rndsec.cpp

Abstract:

    Security utilities for Rendezvous Control.

Author:

    KrishnaG (from OLEDS team)

Environment:

    User Mode - Win32

Revision History:

    12-Dec-1997 DonRyan
        Munged KrishnaG's code to work with Rendezvous Control.

--*/


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SECURITY_WIN32

//#include <security.h>
#include "winlocal.h"
#include <objbase.h>
#include <initguid.h>
#include <iads.h>

#include <stdlib.h>
#include <limits.h>

#include <io.h>
#include <wchar.h>
#include <tchar.h>
//#include "ntseapi.h"
#include "rndsec.h"

///////////////////////////////////////////////////////////////////////////////
//Not defined, so I pulled it from ntseapi.h
///////////////////////////////////////////////////////////////////////////////

typedef struct _COMPOUND_ACCESS_ALLOWED_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    USHORT CompoundAceType;
    USHORT Reserved;
    ULONG SidStart;
} COMPOUND_ACCESS_ALLOWED_ACE;

typedef COMPOUND_ACCESS_ALLOWED_ACE *PCOMPOUND_ACCESS_ALLOWED_ACE;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private macros                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) { goto error; }

#define CONTINUE_ON_FAILURE(hr) \
        if (FAILED(hr)) { continue; }


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


LPWSTR
AllocADsStr(
    LPWSTR pStr
)
{
   LPWSTR pMem;

   if (!pStr)
      return NULL;

   if (pMem = new WCHAR[wcslen(pStr) + 1])
      wcscpy(pMem, pStr);

   return pMem;
}


HRESULT
ConvertSidToString(
    PSID pSid,
    LPWSTR   String
    )

/*++

Routine Description:


    This function generates a printable unicode string representation
    of a SID.

    The resulting string will take one of two forms.  If the
    IdentifierAuthority value is not greater than 2^32, then
    the SID will be in the form:


        S-1-281736-12-72-9-110
              ^    ^^ ^^ ^ ^^^
              |     |  | |  |
              +-----+--+-+--+---- Decimal



    Otherwise it will take the form:


        S-1-0x173495281736-12-72-9-110
            ^^^^^^^^^^^^^^ ^^ ^^ ^ ^^^
             Hexidecimal    |  | |  |
                            +--+-+--+---- Decimal


Arguments:

    pSid - opaque pointer that supplies the SID that is to be
    converted to Unicode.

Return Value:

    If the Sid is successfully converted to a Unicode string, a
    pointer to the Unicode string is returned, else NULL is
    returned.

--*/

{
    WCHAR Buffer[256];
    UCHAR   i;
    ULONG   Tmp;
    HRESULT hr = S_OK;

    SID_IDENTIFIER_AUTHORITY    *pSidIdentifierAuthority;
    PUCHAR                      pSidSubAuthorityCount;

    if (!IsValidSid( pSid )) {
        *String= L'\0';
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_SID);
        return(hr);
    }

    wsprintfW(Buffer, L"S-%u-", (USHORT)(((PISID)pSid)->Revision ));
    wcscpy(String, Buffer);

    pSidIdentifierAuthority = GetSidIdentifierAuthority(pSid);

    if (  (pSidIdentifierAuthority->Value[0] != 0)  ||
          (pSidIdentifierAuthority->Value[1] != 0)     ){
        wsprintfW(Buffer, L"0x%02hx%02hx%02hx%02hx%02hx%02hx",
                    (USHORT)pSidIdentifierAuthority->Value[0],
                    (USHORT)pSidIdentifierAuthority->Value[1],
                    (USHORT)pSidIdentifierAuthority->Value[2],
                    (USHORT)pSidIdentifierAuthority->Value[3],
                    (USHORT)pSidIdentifierAuthority->Value[4],
                    (USHORT)pSidIdentifierAuthority->Value[5] );
        wcscat(String, Buffer);

    } else {

        Tmp = (ULONG)pSidIdentifierAuthority->Value[5]          +
              (ULONG)(pSidIdentifierAuthority->Value[4] <<  8)  +
              (ULONG)(pSidIdentifierAuthority->Value[3] << 16)  +
              (ULONG)(pSidIdentifierAuthority->Value[2] << 24);
        wsprintfW(Buffer, L"%lu", Tmp);
        wcscat(String, Buffer);
    }

    pSidSubAuthorityCount = GetSidSubAuthorityCount(pSid);

    for (i=0;i< *(pSidSubAuthorityCount);i++ ) {
        wsprintfW(Buffer, L"-%lu", *(GetSidSubAuthority(pSid, i)));
        wcscat(String, Buffer);
    }

    return(S_OK);
}

HRESULT
ConvertSidToFriendlyName(
    PSID pSid,
    LPWSTR * ppszAccountName
    )
{
    HRESULT hr = S_OK;
    SID_NAME_USE eUse;
    WCHAR szAccountName[MAX_PATH];
    szAccountName[0] = L'\0';

    WCHAR szDomainName[MAX_PATH];
    szDomainName[0] = L'\0';

    DWORD dwLen = 0;
    DWORD dwRet = 0;

    LPWSTR pszAccountName = NULL;

    DWORD dwAcctLen = 0;
    DWORD dwDomainLen = 0;
    
    dwAcctLen = sizeof(szAccountName);
    dwDomainLen = sizeof(szDomainName);

    dwRet = LookupAccountSidW(
                NULL,
                pSid,
                szAccountName,
                &dwAcctLen,
                szDomainName,
                &dwDomainLen,
                (PSID_NAME_USE)&eUse
                );
    if (!dwRet) {

        hr = ConvertSidToString(
                    pSid,
                    szAccountName
                    );
        BAIL_ON_FAILURE(hr);

        pszAccountName = AllocADsStr(szAccountName);
        if (!pszAccountName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        *ppszAccountName = pszAccountName;

    }else {

        dwLen = wcslen(szAccountName) + wcslen(szDomainName) + 1 + 1;

        pszAccountName = new WCHAR [dwLen];
        if (!pszAccountName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        if (szDomainName[0] && szAccountName[0]) {
            wsprintfW(pszAccountName,L"%s\\%s",szDomainName, szAccountName);
        }else if (szAccountName[0]) {
            wsprintfW(pszAccountName,L"%s", szAccountName);
        }

        *ppszAccountName = pszAccountName;

    }

error:

    return(hr);
}


HRESULT
ConvertAceToVariant(
    PBYTE pAce,
    LPVARIANT pvarAce
    )
{
    IADsAccessControlEntry * pAccessControlEntry = NULL;
    IDispatch * pDispatch = NULL;

    DWORD dwAceType = 0;
    DWORD dwAceFlags = 0;
    DWORD dwAccessMask = 0;
    LPWSTR pszAccountName = NULL;
    PACE_HEADER pAceHeader = NULL;
    LPBYTE pSidAddress = NULL;
    LPBYTE pOffset = NULL;
    DWORD dwFlags = 0;

    GUID ObjectGUID;
    GUID InheritedObjectGUID;
    WCHAR szObjectGUID[MAX_PATH];
    WCHAR szInheritedObjectGUID[MAX_PATH];

    HRESULT hr = S_OK;

    szObjectGUID[0] = L'\0';
    szInheritedObjectGUID[0] = L'\0';


    VariantInit(pvarAce);

    hr = CoCreateInstance(
                CLSID_AccessControlEntry,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsAccessControlEntry,
                (void **)&pAccessControlEntry
                );
    BAIL_ON_FAILURE(hr);

    pAceHeader = (ACE_HEADER *)pAce;


    dwAceType = pAceHeader->AceType;
    dwAceFlags = pAceHeader->AceFlags;
    dwAccessMask = *(PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

    switch (dwAceType) {

    case ACCESS_ALLOWED_ACE_TYPE:
    case ACCESS_DENIED_ACE_TYPE:
    case SYSTEM_AUDIT_ACE_TYPE:
    case SYSTEM_ALARM_ACE_TYPE:
        pSidAddress =  (LPBYTE)pAceHeader + sizeof(ACE_HEADER) + sizeof(ACCESS_MASK);
        break;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
    case ACCESS_DENIED_OBJECT_ACE_TYPE:
    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
    case SYSTEM_ALARM_OBJECT_ACE_TYPE:
        pOffset = (LPBYTE)((LPBYTE)pAceHeader +  sizeof(ACE_HEADER) + sizeof(ACCESS_MASK));
        dwFlags = (DWORD)(*(PDWORD)pOffset);

        //
        // Now advance by the size of the flags
        //
        pOffset += sizeof(ULONG);

        if (dwFlags & ACE_OBJECT_TYPE_PRESENT) {

            memcpy(&ObjectGUID, pOffset, sizeof(GUID));

            StringFromGUID2(ObjectGUID, szObjectGUID, MAX_PATH);

            pOffset += sizeof (GUID);

        }

        if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT) {
            memcpy(&InheritedObjectGUID, pOffset, sizeof(GUID));

            StringFromGUID2(InheritedObjectGUID, szInheritedObjectGUID, MAX_PATH);

            pOffset += sizeof (GUID);

        }

        pSidAddress = pOffset;
        break;

    default:
        BAIL_ON_FAILURE(hr);
        break;

    }


    hr = ConvertSidToFriendlyName(
                pSidAddress,
                &pszAccountName
                );

    if (FAILED(hr)){
        pszAccountName = AllocADsStr(L"Unknown Trustee");
    }

    //
    // Now set all the information in the Access Control Entry
    //

    hr = pAccessControlEntry->put_AccessMask(dwAccessMask);
    hr = pAccessControlEntry->put_AceFlags(dwAceFlags);
    hr = pAccessControlEntry->put_AceType(dwAceType);

    //
    // Extended ACE information
    //
    hr = pAccessControlEntry->put_Flags(dwFlags);

    if (dwFlags & ACE_OBJECT_TYPE_PRESENT) {

        //
        // Add in the Object Type GUID
        //
        hr = pAccessControlEntry->put_ObjectType(szObjectGUID);

    }

    if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT) {

        //
        // Add in the Inherited Object Type GUID
        //

        hr = pAccessControlEntry->put_InheritedObjectType(szInheritedObjectGUID);

    }

    hr = pAccessControlEntry->put_Trustee(pszAccountName);

    hr = pAccessControlEntry->QueryInterface(
                IID_IDispatch,
                (void **)&pDispatch
                );
    BAIL_ON_FAILURE(hr);

    V_DISPATCH(pvarAce) =  pDispatch;
    V_VT(pvarAce) = VT_DISPATCH;

cleanup:

    if (pszAccountName) {

        delete (pszAccountName);
    }

    if (pAccessControlEntry) {

        pAccessControlEntry->Release();
    }

    return(hr);


error:

    if (pDispatch) {

        pDispatch->Release();

    }

    goto cleanup;
}


HRESULT
ConvertACLToVariant(
    PACL pACL,
    LPVARIANT pvarACL
    )
{
    IADsAccessControlList * pAccessControlList = NULL;
    IDispatch * pDispatch = NULL;

    VARIANT varAce;
    DWORD dwAclSize = 0;
    DWORD dwAclRevision = 0;
    DWORD dwAceCount = 0;

    ACL_SIZE_INFORMATION AclSize;
    ACL_REVISION_INFORMATION AclRevision;
    DWORD dwStatus = 0;

    DWORD i = 0;
    DWORD dwNewAceCount = 0;

    HRESULT hr = S_OK;
    LPBYTE pAceAddress = NULL;


    memset(&AclSize, 0, sizeof(ACL_SIZE_INFORMATION));
    memset(&AclRevision, 0, sizeof(ACL_REVISION_INFORMATION));


    dwStatus = GetAclInformation(
                        pACL,
                        &AclSize,
                        sizeof(ACL_SIZE_INFORMATION),
                        AclSizeInformation
                        );


    dwStatus = GetAclInformation(
                        pACL,
                        &AclRevision,
                        sizeof(ACL_REVISION_INFORMATION),
                        AclRevisionInformation
                        );

    dwAceCount = AclSize.AceCount;
    dwAclRevision = AclRevision.AclRevision;

    VariantInit(pvarACL);

    hr = CoCreateInstance(
                CLSID_AccessControlList,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsAccessControlList,
                (void **)&pAccessControlList
                );
    BAIL_ON_FAILURE(hr);

    for (i = 0; i < dwAceCount; i++) {

        dwStatus = GetAce(pACL, i, (void **)&pAceAddress);

        hr = ConvertAceToVariant(
                    pAceAddress,
                    (LPVARIANT)&varAce
                    );

        hr = pAccessControlList->AddAce(V_DISPATCH(&varAce));
        if (SUCCEEDED(hr)) {
           dwNewAceCount++;
        }

        VariantClear(&varAce);
    }

    pAccessControlList->put_AclRevision(dwAclRevision);

    pAccessControlList->put_AceCount(dwNewAceCount);


    hr = pAccessControlList->QueryInterface(
                        IID_IDispatch,
                        (void **)&pDispatch
                        );
    V_VT(pvarACL) = VT_DISPATCH;
    V_DISPATCH(pvarACL) = pDispatch;

error:

    if (pAccessControlList) {

        pAccessControlList->Release();
    }

    return(hr);
}


HRESULT
SecCreateSidFromArray (
    OUT PSID                        *PPSid,
    IN  PSID_IDENTIFIER_AUTHORITY   PSidAuthority,
    IN  UCHAR                       SubAuthorityCount,
    IN  ULONG                       SubAuthorities[],
    OUT PDWORD                      pdwSidSize
    )
/*++

Routine Description:

    Creates a SID with desired authority and sub authorities.

    NOTE:  This routine allocates memory for the SID.  When finished
           the caller should free memory using SEC_FREE (PSid).

Arguments:

    PPSid -- addr of ptr to SID to be created
        Note: if SID creation fails ptr set to NULL

    PSidAuthority -- desired value for SID authority

    SubAuthorityCount -- number of sub authorities desired

    SubAuthorities -- sub-authority values, MUST SPECIFY contain
        at least SubAuthorityCount number of values

Return Value:

    STATUS_SUCCESS if SID created.
    STATUS_UNSUCCESSFUL otherwise.

--*/
{
    USHORT  iSub;           /*  sub-authority index */
    DWORD dwSidSize = 0;
    HRESULT hr = S_OK;

    /*  allocate memory for SID */

    dwSidSize = GetSidLengthRequired(SubAuthorityCount);
    *PPSid = (PSID) new BYTE[dwSidSize];
    if (! *PPSid){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }


    *pdwSidSize = dwSidSize;


    /*  initialize SID with top level SID identifier authority */

    InitializeSid( *PPSid, PSidAuthority, SubAuthorityCount);

    /*  fill in sub authorities */
    for (iSub=0; iSub < SubAuthorityCount; iSub++)
        * GetSidSubAuthority( *PPSid, iSub) = SubAuthorities[iSub];

    /*  sanity check */

    if ( ! IsValidSid( *PPSid) ) {
        delete (*PPSid);
        *PPSid = NULL;
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_SID);
        BAIL_ON_FAILURE(hr);
    }

error:


    return(hr);
}


HRESULT
ConvertStringToSid(
    IN  PWSTR       string,
    OUT PSID       *sid,
    OUT PDWORD     pdwSidSize,
    OUT PWSTR      *end
    )
{
    HRESULT                     hr = S_OK;
    UCHAR                       revision;
    UCHAR                       sub_authority_count;
    SID_IDENTIFIER_AUTHORITY    authority;
    ULONG                       sub_authority[SID_MAX_SUB_AUTHORITIES];
    PWSTR                       end_list;
    PWSTR                       current;
    PWSTR                       next;
    ULONG                       x;

    *sid = NULL;

    if (((*string != L'S') && (*string != L's')) || (*(string + 1) != L'-'))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_SID);
        BAIL_ON_FAILURE(hr);
    }

    current = string + 2;

    revision = (UCHAR)wcstol(current, &end_list, 10);

    current = end_list + 1;

    //
    // Count the number of characters in the indentifer authority...
    //

    next = wcschr(current, L'-');

    if((next != NULL) &&
        (next - current == 6))
    {
        for(x = 0; x < 6; x++)
        {
            authority.Value[x] = (UCHAR)next[x];
        }

        current +=6;
    }
    else
    {
         ULONG Auto = wcstoul(current, &end_list, 10);
         authority.Value[0] = authority.Value[1] = 0;
         authority.Value[5] = (UCHAR)Auto & 0xF;
         authority.Value[4] = (UCHAR)((Auto >> 8) & 0xFF);
         authority.Value[3] = (UCHAR)((Auto >> 16) & 0xFF);
         authority.Value[2] = (UCHAR)((Auto >> 24) & 0xFF);
         current = end_list;
    }

    //
    // Now, count the number of sub auths
    //
    sub_authority_count = 0;
    next = current;

    //
    // We'll have to count our sub authoritys one character at a time,
    // since there are several deliminators that we can have...
    //
    while(next)
    {
        next++;

        if(*next == L'-')
        {
            //
            // We've found one!
            //
            sub_authority_count++;
        }
        else if(*next == L';' || *next  == L'\0')
        {
            *end = next;
            sub_authority_count++;
            break;
        }
    }

    if(sub_authority_count != 0)
    {
        current++;

        for(x = 0; x < sub_authority_count; x++)
        {
            sub_authority[x] = wcstoul(current, &end_list, 10);
            current = end_list + 1;
        }
    }

    //
    // Now, create the SID
    //

    hr = SecCreateSidFromArray(
                    sid,
                    &authority,
                    sub_authority_count,
                    sub_authority,
                    pdwSidSize
                    );

    if (SUCCEEDED(hr))
    {
        /* Set the revision to what was specified in the string, in case, our
           system creates one with newer revision */

        ((SID *)(*sid))->Revision = revision;
    }

error:

    return(hr);
}


HRESULT
ConvertTrusteeToSid(
    BSTR bstrTrustee,
    PSID * ppSid,
    PDWORD pdwSidSize
    )
{
    HRESULT hr = S_OK;
    BYTE Sid[MAX_PATH];
    DWORD dwSidSize = sizeof(Sid);
    DWORD dwRet = 0;
    WCHAR szDomainName[MAX_PATH];
    DWORD dwDomainSize = sizeof(szDomainName)/sizeof(WCHAR);
    SID_NAME_USE eUse;

    PSID pSid = NULL;
    LPWSTR pszEnd = NULL;
    BOOL fNTDSType = FALSE;

    
    dwSidSize = sizeof(Sid);

    dwRet = LookupAccountNameW(
                NULL,
                bstrTrustee,
                Sid,
                &dwSidSize,
                szDomainName,
                &dwDomainSize,
                (PSID_NAME_USE)&eUse
                );
    if (!dwRet) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // If neither the NTDS nor the U2 conversion
    // worked, then try a textual translation
    //

    if (FAILED(hr)) {

        hr = ConvertStringToSid(
                   bstrTrustee,
                    &pSid,
                    &dwSidSize,
                    &pszEnd
                    );
        BAIL_ON_FAILURE(hr);

        memcpy(Sid,pSid, dwSidSize);

        if (pSid) {
            delete pSid;
        }

    }

    pSid = (PSID) new BYTE[dwSidSize];
    if (!pSid) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    memcpy(pSid, Sid, dwSidSize);

    *pdwSidSize = dwSidSize;

    *ppSid = pSid;

error:

    return(hr);
}


HRESULT
GetOwnerSecurityIdentifier(
    IADsSecurityDescriptor FAR * pSecDes,
    PSID * ppSid,
    PBOOL pfOwnerDefaulted
    )
{
    BSTR bstrOwner = NULL;
    DWORD dwSidSize = 0;
    HRESULT hr = S_OK;
    VARIANT_BOOL varBool = VARIANT_FALSE;

    hr = pSecDes->get_Owner(
                    &bstrOwner
                    );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->get_OwnerDefaulted(
                      &varBool
                      );
    BAIL_ON_FAILURE(hr);

    if (varBool == VARIANT_FALSE) {

        if (bstrOwner && *bstrOwner) {

          hr = ConvertTrusteeToSid(
                    bstrOwner,
                    ppSid,
                    &dwSidSize
                    );
          BAIL_ON_FAILURE(hr);
          *pfOwnerDefaulted = FALSE;
        }else {

            *ppSid = NULL;
            *pfOwnerDefaulted = FALSE;
        }

    }else {
        *ppSid = NULL;
        dwSidSize = 0;
        *pfOwnerDefaulted = TRUE;
    }

error:

    if (bstrOwner) {
        SysFreeString(bstrOwner);
    }

    return(hr);
}


HRESULT
ComputeTotalAclSize(
    PACE_HEADER * ppAceHdr,
    DWORD dwAceCount,
    PDWORD pdwAclSize
    )
{
    DWORD i = 0;
    PACE_HEADER pAceHdr = NULL;
    DWORD dwAceSize = 0;
    DWORD dwAclSize = 0;

    for (i = 0; i < dwAceCount; i++) {

        pAceHdr = *(ppAceHdr + i);
        dwAceSize = pAceHdr->AceSize;
        dwAclSize += dwAceSize;
    }

    dwAclSize += sizeof(ACL);

    *pdwAclSize = dwAclSize;

    return(S_OK);

}


HRESULT
ConvertAccessControlEntryToAce(
    IADsAccessControlEntry * pAccessControlEntry,
    LPBYTE * ppAce
    )
{

    DWORD dwAceType = 0;
    HRESULT hr = S_OK;
    BSTR bstrTrustee = NULL;
    PSID pSid = NULL;
    DWORD dwSidSize = 0;

    DWORD dwAceFlags = 0;
    DWORD dwAccessMask = 0;
    DWORD dwAceSize = 0;
    LPBYTE pAce = NULL;
    PACCESS_MASK pAccessMask = NULL;
    PSID pSidAddress = NULL;

    PUSHORT pCompoundAceType = NULL;
    DWORD dwCompoundAceType = 0;

    PACE_HEADER pAceHeader = NULL;

    LPBYTE pOffset = NULL;

    BSTR bstrObjectTypeClsid = NULL;
    BSTR bstrInheritedObjectTypeClsid = NULL;

    GUID ObjectTypeGUID;
    GUID InheritedObjectTypeGUID;
    PULONG pFlags;
    DWORD dwFlags = 0;


    hr = pAccessControlEntry->get_AceType((LONG *)&dwAceType);
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->get_Trustee(&bstrTrustee);
    BAIL_ON_FAILURE(hr);

    hr = ConvertTrusteeToSid(
                bstrTrustee,
                &pSid,
                &dwSidSize
                );
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->get_AceFlags((long *)&dwAceFlags);
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->get_AccessMask((long *)&dwAccessMask);
    BAIL_ON_FAILURE(hr);


    //
    // we will compensateby adding the entire ACE size
    //

    dwAceSize = dwSidSize - sizeof(ULONG);

    switch (dwAceType) {

    case ACCESS_ALLOWED_ACE_TYPE:
        dwAceSize += sizeof(ACCESS_ALLOWED_ACE);
        pAce = new BYTE[dwAceSize];
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;

        pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;

        pSidAddress = (PSID)((LPBYTE)pAccessMask + sizeof(ACCESS_MASK));
        memcpy(pSidAddress, pSid, dwSidSize);
        break;


    case ACCESS_DENIED_ACE_TYPE:
        dwAceSize += sizeof(ACCESS_ALLOWED_ACE);
        pAce = new BYTE[dwAceSize];
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;


        pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;


        pSidAddress = (PSID)((LPBYTE)pAccessMask + sizeof(ACCESS_MASK));
        memcpy(pSidAddress, pSid, dwSidSize);
        break;


    case SYSTEM_AUDIT_ACE_TYPE:
        dwAceSize += sizeof(ACCESS_ALLOWED_ACE);
        pAce = new BYTE[dwAceSize];
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;


        pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;


        pSidAddress = (PSID)((LPBYTE)pAccessMask + sizeof(ACCESS_MASK));
        memcpy(pSidAddress, pSid, dwSidSize);
        break;

    case SYSTEM_ALARM_ACE_TYPE:
        dwAceSize += sizeof(ACCESS_ALLOWED_ACE);
        pAce = new BYTE[dwAceSize];
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;

        pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;

        pSidAddress = (PSID)((LPBYTE)pAccessMask + sizeof(ACCESS_MASK));
        memcpy(pSidAddress, pSid, dwSidSize);
        break;

    case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        dwAceSize += sizeof(COMPOUND_ACCESS_ALLOWED_ACE);
        pAce = new BYTE[dwAceSize];
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;

         pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;

        pCompoundAceType = (PUSHORT)(pAccessMask + sizeof(ACCESS_MASK));
        *pCompoundAceType = (USHORT)dwCompoundAceType;

        //
        // Fill in the reserved field here.
        //

        pSidAddress = (PSID)((LPBYTE)pCompoundAceType + sizeof(DWORD));
        memcpy(pSidAddress, pSid, dwSidSize);
        break;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:

    case ACCESS_DENIED_OBJECT_ACE_TYPE:

    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:

    case SYSTEM_ALARM_OBJECT_ACE_TYPE:


        hr = pAccessControlEntry->get_AceFlags((LONG *)&dwAceFlags);
        BAIL_ON_FAILURE(hr);

        hr = pAccessControlEntry->get_Flags((LONG *)&dwFlags);
        BAIL_ON_FAILURE(hr);

        if (dwFlags & ACE_OBJECT_TYPE_PRESENT) {
            dwAceSize += sizeof(GUID);
        }

        if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT) {
            dwAceSize += sizeof(GUID);
        }

        hr = pAccessControlEntry->get_ObjectType(&bstrObjectTypeClsid);
        BAIL_ON_FAILURE(hr);

        hr = CLSIDFromString(bstrObjectTypeClsid, &ObjectTypeGUID);
        BAIL_ON_FAILURE(hr);

        hr = pAccessControlEntry->get_InheritedObjectType(&bstrInheritedObjectTypeClsid);
        BAIL_ON_FAILURE(hr);

        hr = CLSIDFromString(bstrInheritedObjectTypeClsid, &InheritedObjectTypeGUID);
        BAIL_ON_FAILURE(hr);



        dwAceSize += sizeof(ACCESS_ALLOWED_OBJECT_ACE);
        pAce = new BYTE[dwAceSize];
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;

        pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;

        //
        // Fill in Flags
        //

        pOffset = (LPBYTE)((LPBYTE)pAceHeader +  sizeof(ACE_HEADER) + sizeof(ACCESS_MASK));

        pFlags = (PULONG)(pOffset);

        *pFlags = dwFlags;

        pOffset += sizeof(ULONG);

        if (dwFlags & ACE_OBJECT_TYPE_PRESENT) {

            memcpy(pOffset, &ObjectTypeGUID, sizeof(GUID));

            pOffset += sizeof(GUID);

        }


        if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT) {

            memcpy(pOffset, &InheritedObjectTypeGUID, sizeof(GUID));

            pOffset += sizeof(GUID);
        }

        pSidAddress = (PSID)((LPBYTE)pOffset);
        memcpy(pSidAddress, pSid, dwSidSize);
        break;

    }

    *ppAce = pAce;

error:

    if (bstrTrustee) {
        SysFreeString(bstrTrustee);
    }

    if (pSid) {
        delete (pSid);
    }

    return(hr);
}


HRESULT
ConvertAccessControlListToAcl(
    IADsAccessControlList FAR * pAccessList,
    PACL * ppAcl
    )
{
    IUnknown * pUnknown = NULL;
    IEnumVARIANT * pEnumerator  = NULL;
    HRESULT hr = S_OK;
    DWORD i = 0;
    DWORD cReturned = 0;
    VARIANT varAce;

    DWORD dwAceCount = 0;

    IADsAccessControlEntry FAR * pAccessControlEntry = NULL;

    LPBYTE pTempAce = NULL;
    DWORD dwCount = 0;

    PACL pAcl = NULL;
    DWORD dwAclSize = 0;
    PACE_HEADER * ppAceHdr = NULL;

    DWORD dwRet = 0;
    DWORD dwAclRevision = 0;
    DWORD dwStatus = 0;
    DWORD dwError = 0;


    hr = pAccessList->get_AceCount((long *)&dwAceCount);
    BAIL_ON_FAILURE(hr);


    hr = pAccessList->get__NewEnum(
                    &pUnknown
                    );
    BAIL_ON_FAILURE(hr);

    hr = pUnknown->QueryInterface(
                        IID_IEnumVARIANT,
                        (void FAR * FAR *)&pEnumerator
                        );
    BAIL_ON_FAILURE(hr);



    ppAceHdr = new PACE_HEADER [dwAceCount];
    if (!ppAceHdr) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = 0; i < dwAceCount; i++) {

        VariantInit(&varAce);

        hr = pEnumerator->Next(
                    1,
                    &varAce,
                    &cReturned
                    );

        CONTINUE_ON_FAILURE(hr);


        hr = (V_DISPATCH(&varAce))->QueryInterface(
                    IID_IADsAccessControlEntry,
                    (void **)&pAccessControlEntry
                    );
        CONTINUE_ON_FAILURE(hr);


        hr = ConvertAccessControlEntryToAce(
                    pAccessControlEntry,
                    &(pTempAce)
                    );

        // ZoltanS: Rather than CONTINUE_ON_FAILURE, let's bail so that we
        // know if the Ace we set is invalid.
        BAIL_ON_FAILURE(hr);



        *(ppAceHdr + dwCount) = (PACE_HEADER)pTempAce;

        VariantClear(&varAce);
        if (pAccessControlEntry) {
            pAccessControlEntry->Release();
            pAccessControlEntry = NULL;
        }

        dwCount++;
    }

    hr = ComputeTotalAclSize(ppAceHdr, dwCount, &dwAclSize);
    BAIL_ON_FAILURE(hr);

    pAcl = (PACL)new BYTE[dwAclSize];
    if (!pAcl) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = pAccessList->get_AclRevision((long *)&dwAclRevision);
    BAIL_ON_FAILURE(hr);


    dwRet  = InitializeAcl(
                    pAcl,
                    dwAclSize,
                    dwAclRevision
                    );
    if (!dwRet) {
        hr  = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }



    for (i = 0; i < dwCount; i++) {

        dwStatus = AddAce(
                        pAcl,
                        dwAclRevision,
                        i,
                        (LPBYTE)*(ppAceHdr + i),
                        (*(ppAceHdr + i))->AceSize
                        );
        if (!dwStatus) {

            dwError = GetLastError();
        }
    }

    *ppAcl = pAcl;



error:

    if (ppAceHdr) {
        for (i = 0; i < dwCount; i++) {
            if (*(ppAceHdr + i)) {

                delete (*(ppAceHdr + i));
            }
        }

        delete (ppAceHdr);
    }

    if (pUnknown) {
        pUnknown->Release();
    }

    if (pEnumerator) {
        pEnumerator->Release();
    }


    return(hr);
}


HRESULT
GetGroupSecurityIdentifier(
    IADsSecurityDescriptor FAR * pSecDes,
    PSID * ppSid,
    PBOOL pfGroupDefaulted
    )
{
    BSTR bstrGroup = NULL;
    DWORD dwSidSize = 0;
    HRESULT hr = S_OK;
    VARIANT_BOOL varBool = VARIANT_FALSE;

    hr = pSecDes->get_Group(
                    &bstrGroup
                    );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->get_GroupDefaulted(
                      &varBool
                      );
    BAIL_ON_FAILURE(hr);

    if (varBool == VARIANT_FALSE) {

        if (bstrGroup && *bstrGroup) {

            hr = ConvertTrusteeToSid(
                    bstrGroup,
                    ppSid,
                    &dwSidSize
                    );
            BAIL_ON_FAILURE(hr);
            *pfGroupDefaulted = FALSE;
        }else {
            *ppSid = NULL;
            *pfGroupDefaulted = FALSE;
        }

    }else {
        *ppSid = NULL;
        dwSidSize = 0;
        *pfGroupDefaulted = TRUE;
    }

error:

    if (bstrGroup) {
        SysFreeString(bstrGroup);
    }

    return(hr);

}


HRESULT
GetDacl(
    IADsSecurityDescriptor FAR * pSecDes,
    PACL * ppDacl,
    PBOOL pfDaclDefaulted
    )
{
    IADsAccessControlList FAR * pDiscAcl = NULL;
    IDispatch FAR * pDispatch = NULL;
    HRESULT hr = S_OK;
    VARIANT_BOOL varBool = VARIANT_FALSE;

    hr = pSecDes->get_DaclDefaulted(
                        &varBool
                        );
    BAIL_ON_FAILURE(hr);

    if (varBool == VARIANT_FALSE) {
        *pfDaclDefaulted = FALSE;
    }else {
        *pfDaclDefaulted = TRUE;
    }

    hr = pSecDes->get_DiscretionaryAcl(
                    &pDispatch
                    );
    BAIL_ON_FAILURE(hr);

    if (!pDispatch) {
        *ppDacl = NULL;
        goto error;
    }

    hr = pDispatch->QueryInterface(
                    IID_IADsAccessControlList,
                    (void **)&pDiscAcl
                    );
    BAIL_ON_FAILURE(hr);


    hr = ConvertAccessControlListToAcl(
                pDiscAcl,
                ppDacl
                );
    BAIL_ON_FAILURE(hr);

error:

    if (pDispatch) {
        pDispatch->Release();
    }

    if (pDiscAcl) {
        pDiscAcl->Release();
    }

    return(hr);
}


HRESULT
GetSacl(
    IADsSecurityDescriptor FAR * pSecDes,
    PACL * ppSacl,
    PBOOL pfSaclDefaulted
    )
{
    IADsAccessControlList FAR * pSystemAcl = NULL;
    IDispatch FAR * pDispatch = NULL;
    HRESULT hr = S_OK;
    VARIANT_BOOL varBool = VARIANT_FALSE;

    hr = pSecDes->get_SaclDefaulted(
                        &varBool
                        );
    BAIL_ON_FAILURE(hr);

    if (varBool == VARIANT_FALSE) {
        *pfSaclDefaulted = FALSE;
    }else {
        *pfSaclDefaulted = TRUE;
    }

    hr = pSecDes->get_SystemAcl(
                    &pDispatch
                    );
    BAIL_ON_FAILURE(hr);

    if (!pDispatch) {
        *ppSacl = NULL;
        goto error;
    }

    hr = pDispatch->QueryInterface(
                    IID_IADsAccessControlList,
                    (void **)&pSystemAcl
                    );
    BAIL_ON_FAILURE(hr);


    hr = ConvertAccessControlListToAcl(
                pSystemAcl,
                ppSacl
                );
    BAIL_ON_FAILURE(hr);

error:

    if (pDispatch) {
        pDispatch->Release();
    }

    if (pSystemAcl) {
        pSystemAcl->Release();
    }

    return(hr);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT
ConvertSDToIDispatch(
    IN  PSECURITY_DESCRIPTOR pSecurityDescriptor,
    OUT IDispatch ** ppIDispatch
    )
{
    IADsSecurityDescriptor * pSecDes = NULL;
    IDispatch * pDispatch = NULL;
    LPWSTR pszGroup = NULL;
    LPWSTR pszOwner = NULL;

    BOOL fOwnerDefaulted = 0;
    BOOL fGroupDefaulted = 0;
    BOOL fDaclDefaulted = 0;
    BOOL fSaclDefaulted = 0;

    BOOL fSaclPresent = 0;
    BOOL fDaclPresent = 0;

    LPBYTE pOwnerSidAddress = NULL;
    LPBYTE pGroupSidAddress = NULL;
    LPBYTE pDACLAddress = NULL;
    LPBYTE pSACLAddress = NULL;

    DWORD dwRet = 0;

    VARIANT varDACL;
    VARIANT varSACL;

    HRESULT hr = S_OK;

    DWORD dwRevision = 0;
    WORD  wControl = 0;

    memset(&varSACL, 0, sizeof(VARIANT));
    memset(&varDACL, 0, sizeof(VARIANT));

    if (!pSecurityDescriptor) {
        return(E_FAIL);
    }


    dwRet = GetSecurityDescriptorControl(
                        pSecurityDescriptor,
                        &wControl,
                        &dwRevision
                        );
    if (!dwRet){
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    dwRet = GetSecurityDescriptorOwner(
                        pSecurityDescriptor,
                        (PSID *)&pOwnerSidAddress,
                        &fOwnerDefaulted
                        );

    if (!dwRet){
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    hr = ConvertSidToFriendlyName(
                pOwnerSidAddress,
                &pszOwner
                );
    BAIL_ON_FAILURE(hr);


    dwRet = GetSecurityDescriptorGroup(
                        pSecurityDescriptor,
                        (PSID *)&pGroupSidAddress,
                        &fOwnerDefaulted
                        );
    if (!dwRet){
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    hr = ConvertSidToFriendlyName(
                pGroupSidAddress,
                &pszGroup
                );
    BAIL_ON_FAILURE(hr);


    dwRet = GetSecurityDescriptorDacl(
                        pSecurityDescriptor,
                        &fDaclPresent,
                        (PACL*)&pDACLAddress,
                        &fDaclDefaulted
                        );
    if (pDACLAddress) {

        hr = ConvertACLToVariant(
                (PACL)pDACLAddress,
                &varDACL
                );
        BAIL_ON_FAILURE(hr);
    }



    dwRet = GetSecurityDescriptorSacl(
                        pSecurityDescriptor,
                        &fSaclPresent,
                        (PACL *)&pSACLAddress,
                        &fSaclDefaulted
                        );

    if (!dwRet){
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    if (pSACLAddress) {

        hr = ConvertACLToVariant(
                (PACL)pSACLAddress,
                &varSACL
                );
        BAIL_ON_FAILURE(hr);
    }

    hr = CoCreateInstance(
                CLSID_SecurityDescriptor,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsSecurityDescriptor,
                (void **)&pSecDes
                );
    BAIL_ON_FAILURE(hr);

	if ( pszOwner )
		hr = pSecDes->put_Owner(pszOwner);
    BAIL_ON_FAILURE(hr);

	if ( pszGroup )
		hr = pSecDes->put_Group(pszGroup);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_Revision(dwRevision);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_Control((DWORD)wControl);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_DiscretionaryAcl(V_DISPATCH(&varDACL));
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_SystemAcl(V_DISPATCH(&varSACL));
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    *ppIDispatch = pDispatch;

error:
    VariantClear(&varSACL);
    VariantClear(&varDACL);

    if (pszOwner) {
        delete (pszOwner);
    }

    if (pszGroup) {
        delete (pszGroup);
    }


    if (pSecDes) {
        pSecDes->Release();
    }

    return(hr);
}

HRESULT
ConvertSDToVariant(
    IN  PSECURITY_DESCRIPTOR pSecurityDescriptor,
    OUT VARIANT * pVarSec
    )
{
    IDispatch *pIDispatch;

    HRESULT hr = ConvertSDToIDispatch(pSecurityDescriptor, &pIDispatch);

    if (FAILED(hr))
    {
        return hr;
    }

    VariantInit(pVarSec);
    V_VT(pVarSec)       = VT_DISPATCH;
    V_DISPATCH(pVarSec) = pIDispatch;

    return S_OK;
}


HRESULT
ConvertObjectToSD(
    IN  IADsSecurityDescriptor FAR * pSecDes,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor,
    OUT PDWORD pdwSDLength
    )
{
    HRESULT hr = S_OK;

    SECURITY_DESCRIPTOR AbsoluteSD;
    PSECURITY_DESCRIPTOR pRelative = NULL;
    BOOL Defaulted = FALSE;
    BOOL DaclPresent = FALSE;
    BOOL SaclPresent = FALSE;

    BOOL fDaclDefaulted = FALSE;
    BOOL fSaclDefaulted = FALSE;
    BOOL fOwnerDefaulted = FALSE;
    BOOL fGroupDefaulted = FALSE;

    PSID pOwnerSid = NULL;
    PSID pGroupSid = NULL;
    PACL pDacl = NULL;
    PACL pSacl = NULL;
    DWORD   dwSDLength = 0;
    DWORD dwRet = 0;
    BOOL dwStatus = 0;


    //
    // Initialize *pSizeSD = 0;
    //

    dwRet = InitializeSecurityDescriptor (
                &AbsoluteSD,
                SECURITY_DESCRIPTOR_REVISION1
                );
    if (!dwRet) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


    hr = GetOwnerSecurityIdentifier(
                pSecDes,
                &pOwnerSid,
                &fOwnerDefaulted
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = SetSecurityDescriptorOwner(
                    &AbsoluteSD,
                    pOwnerSid,
                    fOwnerDefaulted
                    );
    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    hr = GetGroupSecurityIdentifier(
                pSecDes,
                &pGroupSid,
                &fGroupDefaulted
                );
    BAIL_ON_FAILURE(hr);


    dwStatus = SetSecurityDescriptorGroup(
                    &AbsoluteSD,
                    pGroupSid,
                    fGroupDefaulted
                    );

    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    hr = GetDacl(
            pSecDes,
            &pDacl,
            &fDaclDefaulted
            );
    BAIL_ON_FAILURE(hr);


    if (pDacl || fDaclDefaulted) {
        DaclPresent = TRUE;
    }

    dwStatus = SetSecurityDescriptorDacl(
                    &AbsoluteSD,
                    DaclPresent,
                    pDacl,
                    fDaclDefaulted
                    );
    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }



    hr = GetSacl(
            pSecDes,
            &pSacl,
            &fSaclDefaulted
            );
    BAIL_ON_FAILURE(hr);


    if (pSacl || fSaclDefaulted) {
        SaclPresent = TRUE;
    }

    dwStatus = SetSecurityDescriptorSacl(
                    &AbsoluteSD,
                    SaclPresent,
                    pSacl,
                    fSaclDefaulted
                    );

    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    dwSDLength = GetSecurityDescriptorLength(
                        &AbsoluteSD
                        );

    pRelative = LocalAlloc(LPTR, dwSDLength);
    if (!pRelative) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    if (!MakeSelfRelativeSD (&AbsoluteSD, pRelative, &dwSDLength)) {
        delete (pRelative);

        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    *ppSecurityDescriptor = pRelative;
    *pdwSDLength = dwSDLength;

cleanup:

    if (pDacl) {
        delete (pDacl);
    }

    if (pSacl) {
        delete (pSacl);
    }

    if (pOwnerSid) {
        delete (pOwnerSid);
    }

    if (pGroupSid) {
        delete (pGroupSid);
    }

    return(hr);

error:
    if (pRelative) {
        LocalFree( pRelative );
    }

    *ppSecurityDescriptor = NULL;
    *pdwSDLength = 0;

    goto cleanup;

}

HRESULT
ConvertObjectToSDDispatch(
    IN  IDispatch * pDisp,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor,
    OUT PDWORD pdwSDLength
    )
{
    HRESULT hr;
    IADsSecurityDescriptor * pSecDes;

    hr = pDisp->QueryInterface(
        IID_IADsSecurityDescriptor,
        (VOID **)&pSecDes
        );

    if (FAILED(hr))
    {
        return hr;
    }

    hr = ConvertObjectToSD(pSecDes, ppSecurityDescriptor, pdwSDLength);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\confprop\confprop.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// confprop.c - conference properties dialog box
////

#include "winlocal.h"
#include <commctrl.h>
#include "confprop.h"
#include "cpgen.h"
#include "res.h"
#include "confinfo.h"
#include "DlgBase.h"
#include "objsec.h"

int CALLBACK ConfProp_PropSheetProc(HWND hwndDlg, UINT uMsg, LPARAM lParam);

// global to keep track of DLL's instance/module handle;
//
HINSTANCE g_hInstLib;

///////////////////////////////////////////////////////////////
// ConfProp_Init
//
void ConfProp_Init( HINSTANCE hInst )
{
	g_hInstLib = hInst;
}


///////////////////////////////////////////////////////////////
// ConfProp_DoModal
//
INT64 ConfProp_DoModal( HWND hWndOwner,	CONFPROP& confprop )
{
	INT64 nRet;
    HPROPSHEETPAGE hpsp[2];
	PROPSHEETPAGE psp;
	PROPSHEETHEADER psh;

	do
	{
		// fill out the PROPSHEETPAGE struct for the General sheet
		//
		psp.dwSize		= sizeof(PROPSHEETPAGE);
		psp.dwFlags		= PSP_USETITLE | PSP_HASHELP;
		psp.hInstance	= g_hInstLib;
		psp.pszTemplate	= MAKEINTRESOURCE(IDD_CONFPROP_GENERAL);
		psp.pszIcon		= NULL;
		psp.pszTitle	= MAKEINTRESOURCE(IDS_GENERAL);
		psp.pfnDlgProc	= ConfPropGeneral_DlgProc;
		psp.lParam		= (LPARAM) &confprop;
		psp.pfnCallback	= NULL;
		psp.pcRefParent	= NULL;
		hpsp[0] = CreatePropertySheetPage(&psp);

		CObjSecurity* pObjSecurity = new CObjSecurity;
		HRESULT hr = pObjSecurity->InternalInitialize( &confprop );
		hpsp[1] = CreateSecurityPage(pObjSecurity);

		// fill out the PROPSHEETHEADER
		//
		psh.dwSize			= sizeof(PROPSHEETHEADER);
		psh.dwFlags			= PSH_HASHELP | PSH_NOAPPLYNOW | PSH_USECALLBACK;
		psh.hwndParent		= hWndOwner;
		psh.hInstance		= g_hInstLib;
		psh.pszIcon			= NULL;
		psh.pszCaption		= MAKEINTRESOURCE(IDS_CONFPROP);
		psh.nPages			= sizeof(hpsp) / sizeof(HPROPSHEETPAGE);
		psh.nStartPage		= 0;
		psh.phpage			= (HPROPSHEETPAGE*)&hpsp[0];
		psh.pfnCallback		= ConfProp_PropSheetProc;

		// This is a loop so because the user has the option to cancel things from
		// the security property page.  The program uses a flag (confprop.ConfInfo.WasSecuritySet())
		// to determine when the user has agreed to the security settings to continue.

		// display the modal property sheet
		nRet = PropertySheet( &psh );

        // Clean-up
        if( pObjSecurity )
        {
            pObjSecurity->Release();
            pObjSecurity = NULL;
        }

		if ( nRet == IDOK )
		{
			if ( confprop.ConfInfo.WasSecuritySet() )
			{
				// Repaint window before commit
				UpdateWindow( hWndOwner );
				DWORD dwError;
				if ( confprop.ConfInfo.CommitSecurity(dwError, confprop.ConfInfo.IsNewConference()) )
				{
					//get proper message
					UINT uId = IDS_CONFPROP_INVALIDTIME + dwError - 1;
					MessageBox(hWndOwner, String(g_hInstLib, uId), NULL, MB_OK | MB_ICONEXCLAMATION );
				}
			}
			else
			{
				nRet = IDRETRY;
			}
		}
	} while ( nRet == IDRETRY );

	return nRet;
}

////
//	private
////

int CALLBACK ConfProp_PropSheetProc(HWND hwndDlg, UINT uMsg, LPARAM lParam)
{
	switch (uMsg)
	{
		case PSCB_PRECREATE:
			break;

		case PSCB_INITIALIZED:
			ConvertPropSheetHelp( hwndDlg );
			break;
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\confprop\cpgen.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and29 product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// cpgen.c - conference properties general dialog box
////

#include "winlocal.h"
#include "res.h"
#include "wnd.h"
#include "DlgBase.h"
#include "confprop.h"
#include "cpgen.h"
#include "confinfo.h"
#include "ThreadPub.h"

////
//	private
////

extern HINSTANCE g_hInstLib;

#define NAME_MAXLEN 64
#define DESCRIPTION_MAXLEN 256
#define OWNER_MAXLEN 64

static LRESULT ConfPropGeneral_DlgProcEx(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
static BOOL ConfPropGeneral_OnInitDialog(HWND hwndDlg, HWND hwndFocus, LPARAM lParam);
static BOOL ConfPropGeneral_OnCommand(HWND hwndDlg, UINT id, HWND hwndCtl, UINT code);
static int ConfPropGeneral_OnNotify(HWND hwndDlg, UINT idFrom, LPNMHDR lpnmhdr);
#define ConfPropGeneral_DefProc(hwnd, msg, wParam, lParam) \
	DefDlgProcEx(hwnd, msg, wParam, lParam, &g_bDefDlgEx)
static BOOL ConfPropGeneral_UpdateData(HWND hwndDlg, BOOL bSaveAndValidate);
static void ConfPropGeneral_SetDateTimeFormats( HWND hwndDlg );

DWORD WINAPI ThreadMDHCPScopeEnum( LPVOID pParam );
void ShowScopeInfo( HWND hwndDlg, int nShow, bool bInit );

static BOOL g_bDefDlgEx = FALSE;


////
//	public
////

int DLLEXPORT WINAPI ConfPropGeneral_DoModal(HWND hwndOwner, DWORD dwUser)
{
	return DialogBoxParam(g_hInstLib, MAKEINTRESOURCE(IDD_CONFPROP_GENERAL),
		hwndOwner, ConfPropGeneral_DlgProc, (LPARAM) dwUser);
}

INT_PTR DLLEXPORT CALLBACK ConfPropGeneral_DlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	CheckDefDlgRecursion(&g_bDefDlgEx);
	return SetDlgMsgResult(hwndDlg, uMsg, ConfPropGeneral_DlgProcEx(hwndDlg, uMsg, wParam, lParam));
}


////
//	private
////

void EnableOkBtn( HWND hWnd, bool bEnable )
{
	while ( hWnd )
	{
		HWND hWndOk = GetDlgItem( hWnd, IDOK );
		if ( hWndOk )
		{
			EnableWindow( hWndOk, bEnable );
			break;
		}

		hWnd = GetParent( hWnd );
	}
}

static LRESULT ConfPropGeneral_DlgProcEx(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LRESULT lRet = 0;

	switch (uMsg)
	{
		HANDLE_MSG(hwndDlg, WM_INITDIALOG, ConfPropGeneral_OnInitDialog);

		case WM_COMMAND:
			if ( (lRet = HANDLE_WM_COMMAND(hwndDlg, wParam, lParam, ConfPropGeneral_OnCommand)) != 0 )
				return lRet;
			break;

		case WM_NOTIFY:
			if ( (lRet = HANDLE_WM_NOTIFY(hwndDlg, wParam, lParam, ConfPropGeneral_OnNotify)) != 0 )
				return lRet;
			break;

		case WM_HELP:			return GeneralOnHelp( hwndDlg, wParam, lParam );
		case WM_CONTEXTMENU:	return GeneralOnContextMenu( hwndDlg, wParam, lParam );

		case WM_SETTINGCHANGE:
			ConfPropGeneral_SetDateTimeFormats( hwndDlg );
			// do default processing as well
			break;
	}

	return ConfPropGeneral_DefProc(hwndDlg, uMsg, wParam, lParam);
}

static BOOL ConfPropGeneral_OnInitDialog(HWND hwndDlg, HWND hwndFocus, LPARAM lParam)
{
	//_ASSERT( lParam  && ((LPPROPSHEETPAGE) lParam)->lParam );
    //
    // We have to verify the arguments
    //

    if( NULL == ((LPPROPSHEETPAGE)lParam) )
    {
        return TRUE;
    }

	LPCONFPROP lpConfProp = (LPCONFPROP) ((LPPROPSHEETPAGE) lParam)->lParam;

    //
    // Validates lpConfProp
    //

    if( IsBadReadPtr( lpConfProp, sizeof( CONFPROP) ) )
    {
        return TRUE;
    }

	SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR) lpConfProp );

	// Reset content of listbox if necessary
	ConfPropGeneral_UpdateData( hwndDlg, FALSE );
	if  ( lpConfProp->ConfInfo.IsNewConference() )
		ShowScopeInfo( hwndDlg, SW_SHOW, true );

	//WndCenterWindow( GetParent(hwndDlg), NULL, 0, 0 );

	return TRUE; // let Windows decide who gets focus
}

static BOOL ConfPropGeneral_OnCommand(HWND hwndDlg, UINT id, HWND hwndCtl, UINT code)
{
	BOOL bRet = false;

	HWND hwndName = GetDlgItem(hwndDlg, IDC_EDIT_NAME);

	switch (id)
	{
		case IDC_EDIT_NAME:
			if (code == EN_CHANGE)
				EnableOkBtn( hwndDlg, (bool) (Edit_GetTextLength(hwndName) != 0) );

			break;

		default:
			break;
	}

	return bRet;
}

static int ConfPropGeneral_OnNotify(HWND hwndDlg, UINT idFrom, LPNMHDR lpnmhdr)
{
	switch (lpnmhdr->code)
	{
		// page about to be activated and made visible, so initialize page
		//
		case PSN_SETACTIVE:
			return 0; // ok
			// return -1; // activate previous or next page
			// return MAKEINTRESOURCE(id); // activate specific page
			break;

		// page about to lose activation, so validate page
		//
		case PSN_KILLACTIVE:
			return FALSE; // ok
			// return TRUE; // not ok
			break;

		// ok or apply button pushed, so apply properties to object
		//
		case PSN_APPLY:
			return ConfPropGeneral_UpdateData( hwndDlg, TRUE );
			break;

		// cancel button pushed
		//
		case PSN_QUERYCANCEL:
			return FALSE; // ok
			// return TRUE; // not ok
			break;

		// page about to be destroyed after cancel button pushed
		//
		case PSN_RESET:
			return FALSE; // return value ignored
			break;

		// help button pushed
		//
		case PSN_HELP:
			// WinHelp(...); // $FIXUP - need to handle this
			return FALSE; // return value ignored
			break;

		case DTN_DATETIMECHANGE:
			// If this is not a new conference, post a message explaining that
			// the scope information will need to be re-selected
			if ( IsWindow(hwndDlg) )
			{
				LPCONFPROP lpConfProp = (LPCONFPROP) GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
				
                //
                // We have to verify the lpConfProp
                //

                if( NULL == lpConfProp )
                {
                    break;
                }

				if ( !lpConfProp->ConfInfo.m_bDateTimeChange )
				{
					lpConfProp->ConfInfo.m_bDateTimeChange = true;
					if ( !lpConfProp->ConfInfo.m_bNewConference )
					{

                        // We send the notification again even if the source is the combo
                        // and show MessageBox at that time
					    //MessageBox(hwndDlg, String(g_hInstLib, IDS_CONFPROP_DATECHANGE_MDHCP), NULL, MB_OK | MB_ICONINFORMATION );
						ShowScopeInfo( hwndDlg, SW_SHOW, true );
                        PostMessage(hwndDlg, WM_NOTIFY, idFrom, (LPARAM)lpnmhdr);
					}
				}
                else
                {
                    //Here is the second notification
                    //I show here the Error message
					if ( !lpConfProp->ConfInfo.m_bNewConference )
					{
                        if(!lpConfProp->ConfInfo.m_bDateChangeMessage)
                        {
                            lpConfProp->ConfInfo.m_bDateChangeMessage = true;
                            MessageBox(hwndDlg, String(g_hInstLib, IDS_CONFPROP_DATECHANGE_MDHCP), NULL, MB_OK | MB_ICONINFORMATION );
                        }
                    }
                }
			}
			break;

		default:
			break;
	}

	return FALSE;
}

static void ConfPropGeneral_SetDateTimeFormats( HWND hwndDlg )
{
	HWND hwndDTPStartDate = GetDlgItem(hwndDlg, IDC_DTP_STARTDATE);
	HWND hwndDTPStartTime = GetDlgItem(hwndDlg, IDC_DTP_STARTTIME);
	HWND hwndDTPStopDate = GetDlgItem(hwndDlg, IDC_DTP_STOPDATE);
	HWND hwndDTPStopTime = GetDlgItem(hwndDlg, IDC_DTP_STOPTIME);

	// conference start time
	TCHAR szFormat[255];
	GetLocaleInfo( LOCALE_USER_DEFAULT,
				   LOCALE_SSHORTDATE,
				   szFormat,
				   ARRAYSIZE(szFormat)  );

	DateTime_SetFormat(hwndDTPStartDate, szFormat );
	DateTime_SetFormat( hwndDTPStopDate,	szFormat );

	// conference stop time
	GetLocaleInfo( LOCALE_USER_DEFAULT,
				   LOCALE_STIMEFORMAT,
				   szFormat,
				   ARRAYSIZE(szFormat)  );
	

	DateTime_SetFormat( hwndDTPStopTime,	szFormat );
	DateTime_SetFormat(hwndDTPStartTime, szFormat );
}

static int ConfPropGeneral_UpdateData(HWND hwndDlg, BOOL bSaveAndValidate)
{
	HRESULT hr = S_OK;
	LPCONFPROP lpConfProp;

	HWND hwndName = GetDlgItem(hwndDlg, IDC_EDIT_NAME);
	HWND hwndDescription = GetDlgItem(hwndDlg, IDC_EDIT_DESCRIPTION);
	HWND hwndOwner = GetDlgItem(hwndDlg, IDC_EDIT_OWNER);
	HWND hwndDTPStartDate = GetDlgItem(hwndDlg, IDC_DTP_STARTDATE);
	HWND hwndDTPStartTime = GetDlgItem(hwndDlg, IDC_DTP_STARTTIME);
	HWND hwndDTPStopDate = GetDlgItem(hwndDlg, IDC_DTP_STOPDATE);
	HWND hwndDTPStopTime = GetDlgItem(hwndDlg, IDC_DTP_STOPTIME);

	BSTR bstrName = NULL;
	BSTR bstrDescription = NULL;
	BSTR bstrOwner = NULL;
	TCHAR szName[NAME_MAXLEN + 1];
	TCHAR szDescription[DESCRIPTION_MAXLEN + 1] = _T("");
	TCHAR szOwner[OWNER_MAXLEN + 1] = _T("");
	SYSTEMTIME st;
	USHORT nYear;
	BYTE nMonth, nDay, nHour, nMinute;

	USES_CONVERSION;

    _ASSERT( IsWindow(hwndDlg) );

	lpConfProp = (LPCONFPROP) GetWindowLongPtr( hwndDlg, GWLP_USERDATA );

	//
    // We have to verify lpConfProp
    //

    if( NULL == lpConfProp )
    {
        return PSNRET_INVALID_NOCHANGEPAGE;
    }
	
	if (!bSaveAndValidate) // initialization
	{
		// conference name
		//
		Edit_LimitText(hwndName, NAME_MAXLEN);

		lpConfProp->ConfInfo.get_Name(&bstrName);
		if (bstrName == NULL)
		{
			// Make up a default name for the conference
			CComBSTR bstrTemp(L"");
            if( bstrTemp.m_str == NULL )
            {
                // E_OUTOFMEMORY
    			_tcsncpy( szName, _T(""), NAME_MAXLEN );
            }
            else
            {
			    lpConfProp->ConfInfo.GetPrimaryUser( &bstrTemp );
			    bstrTemp.Append( String(g_hInstLib, IDS_CONFPROP_UNTITLED_DEFAULT_APPEND) );
			    _tcsncpy( szName, OLE2CT(bstrTemp), NAME_MAXLEN );
            }
		}
		else
		{
			_tcsncpy( szName, OLE2CT(bstrName), NAME_MAXLEN );
		}
		Edit_SetText(hwndName, szName);

		// Don't allow name to be editted if this is an existing conference
		if ( !lpConfProp->ConfInfo.IsNewConference() )
			EnableWindow( hwndName, false );

		// conference description
		//
		Edit_LimitText(hwndDescription, DESCRIPTION_MAXLEN);
		lpConfProp->ConfInfo.get_Description(&bstrDescription);
		if (bstrDescription )
			_tcsncpy(szDescription, OLE2CT(bstrDescription), DESCRIPTION_MAXLEN);

		Edit_SetText(hwndDescription, szDescription);

		// conference owner
		//
		Edit_LimitText(hwndOwner, OWNER_MAXLEN);
		lpConfProp->ConfInfo.get_Originator(&bstrOwner);
		if (bstrOwner )
			_tcsncpy(szOwner, OLE2CT(bstrOwner), OWNER_MAXLEN);

		Edit_SetText(hwndOwner, szOwner);
		
		ConfPropGeneral_SetDateTimeFormats( hwndDlg );

		lpConfProp->ConfInfo.GetStartTime(&nYear, &nMonth, &nDay, &nHour, &nMinute);
		st.wYear = nYear;
		st.wMonth = nMonth;
		st.wDayOfWeek = 0;
		st.wDay = nDay;
		st.wHour = nHour;
		st.wMinute = nMinute;
		st.wSecond = 0;
		st.wMilliseconds = 0;

		DateTime_SetSystemtime( hwndDTPStartDate, GDT_VALID, &st );
		DateTime_SetSystemtime( hwndDTPStartTime, GDT_VALID, &st );

		lpConfProp->ConfInfo.GetStopTime(&nYear, &nMonth, &nDay, &nHour, &nMinute);
		st.wYear = nYear;
		st.wMonth = nMonth;
		st.wDayOfWeek = 0;
		st.wDay = nDay;
		st.wHour = nHour;
		st.wMinute = nMinute;
		st.wSecond = 0;
		st.wMilliseconds = 0;

		DateTime_SetSystemtime( hwndDTPStopDate, GDT_VALID, &st );
		DateTime_SetSystemtime( hwndDTPStopTime, GDT_VALID, &st );
	}

	else // if (bSaveAndValidate)
	{
		// conference name
		//

        //
        // We have to initialize szName
        //

        szName[0] = (TCHAR)0;

		Edit_GetText(hwndName, szName, NAME_MAXLEN+1);
        bstrName = SysAllocString(T2COLE(szName));

        //
        // We have to verify the allocation and
        // initialize the szName
        //

        if( IsBadStringPtr( bstrName, (UINT)-1) )
        {
            return PSNRET_INVALID_NOCHANGEPAGE;
        }

		if ( !*szName )
		{
			// improper name
		    MessageBox(hwndDlg, String(g_hInstLib, IDS_CONFPROP_NONAME), NULL, MB_OK | MB_ICONEXCLAMATION);
		}
		else 
		{
			lpConfProp->ConfInfo.put_Name(bstrName);
		}

		// conference description
		//
		Edit_GetText(hwndDescription, szDescription, DESCRIPTION_MAXLEN);
		bstrDescription = SysAllocString(T2COLE(szDescription));

        //
        // We have to validate the allocation
        //

        if( IsBadStringPtr( bstrDescription, (UINT)-1) )
        {
	        SysFreeString(bstrName);
            return PSNRET_INVALID_NOCHANGEPAGE;
        }

		lpConfProp->ConfInfo.put_Description(bstrDescription);

		// conference start time
		//
		if ( DateTime_GetSystemtime(hwndDTPStartDate, &st) == GDT_VALID )
		{
			nYear = (UINT) st.wYear;
			nMonth = (BYTE) st.wMonth;
			nDay = (BYTE) st.wDay;

			if ( DateTime_GetSystemtime(hwndDTPStartTime, &st) == GDT_VALID )
			{
				nHour = (BYTE) st.wHour;
				nMinute = (BYTE) st.wMinute;

				lpConfProp->ConfInfo.SetStartTime(nYear, nMonth, nDay, nHour, nMinute);
			}
		}

		// conference stop time
		//
		if ( DateTime_GetSystemtime(hwndDTPStopDate, &st) == GDT_VALID )
		{
			nYear = (UINT) st.wYear;
			nMonth = (BYTE) st.wMonth;
			nDay = (BYTE) st.wDay;

			if ( DateTime_GetSystemtime(hwndDTPStopTime, &st) == GDT_VALID )
			{
				nHour = (BYTE) st.wHour;
				nMinute = (BYTE) st.wMinute;

				lpConfProp->ConfInfo.SetStopTime(nYear, nMonth, nDay, nHour, nMinute);
			}
		}

		// MDHCP info
		HWND hWndLst = GetDlgItem(hwndDlg, IDC_LST_SCOPE );
		if ( hWndLst )
		{
            int nSel = SendMessage(hWndLst, LB_GETCURSEL, 0, 0);
            lpConfProp->ConfInfo.m_bUserSelected = (nSel != LB_ERR);
            lpConfProp->ConfInfo.m_lScopeID = SendMessage( hWndLst, LB_GETITEMDATA, nSel, 0 );
		}

		DWORD dwError;
		hr = lpConfProp->ConfInfo.CommitGeneral( dwError );
		if ( hr != S_OK )
		{
			//get proper message
			UINT uId = IDS_CONFPROP_INVALIDTIME + dwError - 1;
			MessageBox(hwndDlg, String(g_hInstLib, uId), NULL, MB_OK | MB_ICONEXCLAMATION );
		}
	}

	SysFreeString(bstrName);
	SysFreeString(bstrDescription);
	SysFreeString(bstrOwner);

	return (hr == S_OK) ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
}


//////////////////////////////////////////////////////////////////
// This is the thread that goes out and enumerates the scopes
//
DWORD WINAPI ThreadMDHCPScopeEnum( LPVOID pParam )
{
	ATLTRACE(_T(".enter.ThreadMDHCPScopeEnum().\n"));
	HWND hWndDlg = (HWND) pParam;
	if ( !IsWindow(hWndDlg) ) return E_ABORT;
	
	HRESULT hr = CoInitializeEx( NULL, COINIT_MULTITHREADED | COINIT_SPEED_OVER_MEMORY );
	if ( SUCCEEDED(hr) )
	{
		HWND hWndList = GetDlgItem(hWndDlg, IDC_LST_SCOPE );

		CConfInfo::PopulateListWithMDHCPScopeDescriptions( hWndList );
		CoUninitialize();
	}

	ATLTRACE(_T(".exit.ThreadMDHCPScopeEnum(%ld).\n"), hr);
	return hr;
}

void ShowScopeInfo( HWND hwndDlg, int nShow, bool bInit )
{
	HWND hWndFrm = GetDlgItem( hwndDlg, IDC_FRM_SCOPE );
	HWND hWndLbl = GetDlgItem( hwndDlg, IDC_LBL_SCOPE );
	HWND hWndLst = GetDlgItem( hwndDlg, IDC_LST_SCOPE );

	if ( hWndFrm ) ShowWindow( hWndFrm, nShow );
	if ( hWndLbl ) ShowWindow( hWndLbl, nShow );
	if ( hWndLst )
	{
		ShowWindow( hWndLst, nShow );
		if ( bInit )
		{
			EnableWindow( hWndLst, FALSE );
			SendMessage( hWndLst, LB_RESETCONTENT, 0, 0 );
			SendMessage( hWndLst, LB_ADDSTRING, 0, (LPARAM) String(g_hInstLib, IDS_CONFPROP_ENUMERATING_SCOPES) );

			DWORD dwID;
			HANDLE hThread = CreateThread( NULL, 0, ThreadMDHCPScopeEnum, (void *) hwndDlg, NULL, &dwID );
			if ( hThread ) CloseHandle( hThread );
		}
	}    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\confprop\objsec.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and29 product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <winnt.h>
#include "res.h"
#include "objsec.h"
#include "rndsec.h"


#define DSOP_FILTER_COMMON ( DSOP_FILTER_USERS |					\
							 DSOP_FILTER_UNIVERSAL_GROUPS_SE |		\
							 DSOP_FILTER_GLOBAL_GROUPS_SE )

#define DSOP_FILTER_DL_COMMON1      ( DSOP_DOWNLEVEL_FILTER_USERS           \
                                    | DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS   \
                                    | DSOP_DOWNLEVEL_FILTER_COMPUTERS       \
                                    )

#define DSOP_FILTER_DL_COMMON2      ( DSOP_FILTER_DL_COMMON1                    \
                                    | DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS  \
                                    )

#define DSOP_FILTER_DL_COMMON3      ( DSOP_FILTER_DL_COMMON2                \
                                    | DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS    \
                                    )


#define DECLARE_SCOPE(t,f,b,m,n,d)  \
{ sizeof(DSOP_SCOPE_INIT_INFO), (t), (f), { { (b), (m), (n) }, (d) }, NULL, NULL, S_OK }

static const DSOP_SCOPE_INIT_INFO g_aDSOPScopes[] =
{
    // The domain to which the target computer is joined.
    DECLARE_SCOPE(DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN,                  \
                  DSOP_SCOPE_FLAG_STARTING_SCOPE,                         \
                  0,                                                      \
                  DSOP_FILTER_COMMON & ~DSOP_FILTER_UNIVERSAL_GROUPS_SE, \
                  DSOP_FILTER_COMMON,                                    \
                  0),

    DECLARE_SCOPE(DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN,0,0,0,0,DSOP_FILTER_DL_COMMON2),

    // The Global Catalog
    DECLARE_SCOPE(DSOP_SCOPE_TYPE_GLOBAL_CATALOG,0,DSOP_FILTER_COMMON|DSOP_FILTER_WELL_KNOWN_PRINCIPALS,0,0,0),

    // The domains in the same forest (enterprise) as the domain to which
    // the target machine is joined.  Note these can only be DS-aware
    DECLARE_SCOPE(DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN,0,DSOP_FILTER_COMMON,0,0,0),

    // Domains external to the enterprise but trusted directly by the
    // domain to which the target machine is joined.
    DECLARE_SCOPE(DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN, \
                  0,                        \
                  DSOP_FILTER_COMMON,      \
                  0,                        \
                  0,                        \
                  DSOP_DOWNLEVEL_FILTER_USERS | DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS),

    // Target computer scope.  Computer scopes are always treated as
    // downlevel (i.e., they use the WinNT provider).
    
    DECLARE_SCOPE(DSOP_SCOPE_TYPE_TARGET_COMPUTER,0,0,0,0,DSOP_FILTER_DL_COMMON3),
};


GENERIC_MAPPING ObjMap =
{
    ACCESS_READ,
    ACCESS_MODIFY,
    ACCESS_DELETE,
};

SI_ACCESS g_siObjAccesses[] = 
{
    { &GUID_NULL, ACCESS_READ,      MAKEINTRESOURCEW(IDS_PRIV_READ),      SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
    { &GUID_NULL, ACCESS_MODIFY,    MAKEINTRESOURCEW(IDS_PRIV_MODIFY),    SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
    { &GUID_NULL, ACCESS_DELETE,    MAKEINTRESOURCEW(IDS_PRIV_DELETE),    SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
};

#define g_iObjDefAccess    GENERIC_READ


// The following array defines the inheritance types for my containers.
SI_INHERIT_TYPE g_siObjInheritTypes[] =
{
    &GUID_NULL, 0, L"This container/object only",
};

/////////////////////////////////////////////////////////////////////////////////////////
CObjSecurity::CObjSecurity() : m_cRef(1)
{
	USES_CONVERSION;
	m_dwSIFlags = NULL;
	m_pConfProp = NULL;

    //
    // Let's have a properly constructor
    //

    m_bstrObject = NULL;
    m_bstrPage = NULL;

	m_pObjectPicker = NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////
CObjSecurity::~CObjSecurity()
{
    //
    // Properly deallocation
    //

    if( m_bstrObject )
	    SysFreeString( m_bstrObject );

    if( m_bstrPage )
    	SysFreeString( m_bstrPage );

	if ( m_pObjectPicker )
		m_pObjectPicker->Release();
}

/////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CObjSecurity::InternalInitialize( CONFPROP* pConfProp )
{
    HRESULT hr = S_OK;
    //
    // we can initialize BSTRs here
    //

	m_bstrObject = SysAllocString( T2COLE(String(g_hInstLib, IDS_CONFPROP_PERMISSIONS_OBJECT )) );
    if( IsBadStringPtr( m_bstrObject, (UINT)-1) )
        return E_OUTOFMEMORY;

	m_bstrPage = SysAllocString( T2COLE(String(g_hInstLib, IDS_CONFPROP_PERMISSIONS_PAGE )) );
    if( IsBadStringPtr( m_bstrPage, (UINT)-1) )
    {
        SysFreeString( m_bstrObject);
        return E_OUTOFMEMORY;
    }

    m_pConfProp = pConfProp;

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
//IUnknown Methods
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CObjSecurity::AddRef()
{
    return ++m_cRef;
}

/////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CObjSecurity::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

/////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CObjSecurity::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ISecurityInformation))
    {
        *ppv = (LPSECURITYINFO)this;
    }
    else if ( IsEqualIID(riid, IID_IDsObjectPicker) )
	{
        *ppv = static_cast<IDsObjectPicker*> (this);
	}
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

	m_cRef++;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
// IDsObjectPicker
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CObjSecurity::Initialize( PDSOP_INIT_INFO pInitInfo )
{
    HRESULT hr = S_OK;
    DSOP_INIT_INFO InitInfo;
    PDSOP_SCOPE_INIT_INFO pDSOPScopes = NULL;

	_ASSERT( pInitInfo->cbSize >= FIELD_OFFSET(DSOP_INIT_INFO, cAttributesToFetch) );

	// Create an instance of the object
    if (!m_pObjectPicker)
    {
        hr = CoCreateInstance(CLSID_DsObjectPicker,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDsObjectPicker,
                              (LPVOID*)&m_pObjectPicker);
    }

	if ( SUCCEEDED(hr) )
	{
		// Make a local copy of the InitInfo so we can modify it safely
		CopyMemory(&InitInfo, pInitInfo, min(pInitInfo->cbSize, sizeof(InitInfo)));

		// Make a local copy of g_aDSOPScopes so we can modify it safely.
		// Note also that m_pObjectPicker->Initialize returns HRESULTs
		// in this buffer.
		pDSOPScopes = (PDSOP_SCOPE_INIT_INFO)LocalAlloc(LPTR, sizeof(g_aDSOPScopes));
		if (pDSOPScopes)
		{
			CopyMemory(pDSOPScopes, g_aDSOPScopes, sizeof(g_aDSOPScopes));

			// Override the ACLUI default scopes, but don't touch
			// the other stuff.
//			pDSOPScopes->pwzDcName = m_strServerName;
			InitInfo.cDsScopeInfos = ARRAYSIZE(g_aDSOPScopes);
			InitInfo.aDsScopeInfos = pDSOPScopes;

			hr = m_pObjectPicker->Initialize(&InitInfo);

			LocalFree(pDSOPScopes);
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}

	return hr;
}

STDMETHODIMP CObjSecurity::InvokeDialog( HWND hwndParent, IDataObject **ppdoSelection )
{
    HRESULT hr = E_UNEXPECTED;
    _ASSERT( ppdoSelection );

    if (m_pObjectPicker)
        hr = m_pObjectPicker->InvokeDialog(hwndParent, ppdoSelection);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
// ISecurityInformation methods
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CObjSecurity::GetObjectInformation(PSI_OBJECT_INFO pObjectInfo)
{
    m_dwSIFlags = SI_EDIT_OWNER	| SI_EDIT_PERMS | SI_NO_ACL_PROTECT	|	\
				  SI_PAGE_TITLE;

    pObjectInfo->dwFlags = m_dwSIFlags;
    pObjectInfo->hInstance = g_hInstLib;
    pObjectInfo->pszServerName = NULL;          //use local computer
    pObjectInfo->pszObjectName = m_bstrObject;
	pObjectInfo->pszPageTitle = m_bstrPage;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CObjSecurity::GetSecurity(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR *ppSD,
                           BOOL fDefault)
{
	HRESULT hr = S_OK;

	// Make the default if necessary...
	if ( !m_pConfProp->ConfInfo.m_pSecDesc )
	{
		hr = CoCreateInstance( CLSID_SecurityDescriptor,
							   NULL,
							   CLSCTX_INPROC_SERVER,
							   IID_IADsSecurityDescriptor,
							   (void **) &m_pConfProp->ConfInfo.m_pSecDesc );

		// Add default settings if successfully created the ACE
		if ( SUCCEEDED(hr) )
			hr = m_pConfProp->ConfInfo.AddDefaultACEs( m_pConfProp->ConfInfo.IsNewConference() );
	}

	// If we failed to get the defaults, just use whatever you can...
	if ( !m_pConfProp->ConfInfo.m_pSecDesc )
	{
		PSECURITY_DESCRIPTOR psdNewSD = LocalAlloc(LPTR,SECURITY_DESCRIPTOR_MIN_LENGTH);

        //
        // Validate the allocation
        //
        if( psdNewSD == NULL )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            //
            // Allocation succeeded
            //
		    if( !InitializeSecurityDescriptor(psdNewSD,SECURITY_DESCRIPTOR_REVISION) )
		    {
			    hr = GetLastError();
		    }
        }

		*ppSD = psdNewSD;
	}
	else
	{
		DWORD dwSDLen = 0;
		ATLTRACE(_T(".1.CObjSecurity::GetSecurity() pre->Convert ticks = %ld.\n"), GetTickCount() );
		hr = ConvertObjectToSD( m_pConfProp->ConfInfo.m_pSecDesc, ppSD, &dwSDLen );
		ATLTRACE(_T(".1.CObjSecurity::GetSecurity() post Convert ticks = %ld.\n"), GetTickCount() );
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CObjSecurity::SetSecurity( SECURITY_INFORMATION si, PSECURITY_DESCRIPTOR pSD)
{
	if ( !m_pConfProp ) return E_UNEXPECTED;

	HRESULT hr = S_OK;
	m_pConfProp->ConfInfo.SetSecuritySet( true );
	
	
	///////////////////////////////////////////////////////////
	// If we don't have an existing SD, create one
	//
	if ( !m_pConfProp->ConfInfo.m_pSecDesc )
	{
		hr = CoCreateInstance( CLSID_SecurityDescriptor,
							   NULL,
							   CLSCTX_INPROC_SERVER,
							   IID_IADsSecurityDescriptor,
							   (void **) &m_pConfProp->ConfInfo.m_pSecDesc );

		// Failed te create the security descriptor object
		if ( FAILED(hr) ) return hr;
	}


	/////////////////////////////////////////////////////////////////////////////////
	// Set properties on the Security Descriptor
	//

	// Get control and revision information from SD
    DWORD dwRevision = 0;
    WORD  wControl = 0;
	DWORD dwRet = GetSecurityDescriptorControl( pSD, &wControl, &dwRevision );
    if ( !dwRet ) return HRESULT_FROM_WIN32(GetLastError());

	hr = m_pConfProp->ConfInfo.m_pSecDesc->put_Control( wControl );
	BAIL_ON_FAILURE(hr);

	hr = m_pConfProp->ConfInfo.m_pSecDesc->put_Revision( dwRevision );
	BAIL_ON_FAILURE(hr);

	////////////////////////////////////////////////
	// What was modified on the SD?
	if ( si & OWNER_SECURITY_INFORMATION )
	{
		BOOL bOwnerDefaulted = FALSE;
		LPBYTE pOwnerSidAddress = NULL;

		dwRet = GetSecurityDescriptorOwner( pSD, (PSID *) &pOwnerSidAddress, &bOwnerDefaulted );
		if ( dwRet )
		{
			LPWSTR pszOwner = NULL;
			if ( SUCCEEDED(hr = ConvertSidToFriendlyName(pOwnerSidAddress, &pszOwner)) )
			{
				if ( SUCCEEDED(hr = m_pConfProp->ConfInfo.m_pSecDesc->put_OwnerDefaulted((VARIANT_BOOL) bOwnerDefaulted)) )
					hr = m_pConfProp->ConfInfo.m_pSecDesc->put_Owner( pszOwner );
			}

			// Clean - up
			if ( pszOwner )	delete pszOwner;
		}
		else
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
		}
	}

	///////////////////////////////////////////////////////
	// Group security information changing...
	if ( si & GROUP_SECURITY_INFORMATION )
	{
		BOOL bGroupDefaulted = FALSE;
		LPBYTE pGroupSidAddress = NULL;

		dwRet = GetSecurityDescriptorGroup( pSD,
											(PSID *)&pGroupSidAddress,
											&bGroupDefaulted	);
		if ( dwRet )
		{
			LPWSTR pszGroup = NULL;
			if ( SUCCEEDED(hr = ConvertSidToFriendlyName(pGroupSidAddress, &pszGroup)) )
			{
				if ( SUCCEEDED(hr = m_pConfProp->ConfInfo.m_pSecDesc->put_GroupDefaulted((VARIANT_BOOL) bGroupDefaulted)) )
					hr = m_pConfProp->ConfInfo.m_pSecDesc->put_Group( pszGroup );
			}

			// Clean - up
			if ( pszGroup ) delete pszGroup;
		}
		else
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
		}
	} 

	///////////////////////////////////////////////
	// DACL list changing
	if ( si & DACL_SECURITY_INFORMATION )
	{
		LPBYTE pDACLAddress = NULL;
		BOOL bDaclPresent = FALSE, bDaclDefaulted = FALSE;
		VARIANT varDACL;
		VariantInit( &varDACL );

		// Extract DACL
		GetSecurityDescriptorDacl( pSD,
								   &bDaclPresent,
								   (PACL*) &pDACLAddress,
								   &bDaclDefaulted );

		if ( bDaclPresent && pDACLAddress && SUCCEEDED(hr = ConvertACLToVariant((PACL) pDACLAddress, &varDACL)) )
		{
			if ( SUCCEEDED(hr = m_pConfProp->ConfInfo.m_pSecDesc->put_DaclDefaulted((VARIANT_BOOL) bDaclDefaulted)) )
				hr = m_pConfProp->ConfInfo.m_pSecDesc->put_DiscretionaryAcl( V_DISPATCH(&varDACL) );
		}

		// Clean - up
		VariantClear( &varDACL );
	}

failed:
	return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CObjSecurity::GetAccessRights(const GUID* /*pguidObjectType*/,
                               DWORD dwFlags,
                               PSI_ACCESS *ppAccesses,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess)
{
    *ppAccesses = g_siObjAccesses;
    *pcAccesses = sizeof(g_siObjAccesses)/sizeof(g_siObjAccesses[0]);
    *piDefaultAccess = g_iObjDefAccess;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CObjSecurity::MapGeneric(const GUID* /*pguidObjectType*/,
                          UCHAR *pAceFlags,
                          ACCESS_MASK *pmask)
{
    MapGenericMask(pmask, &ObjMap);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CObjSecurity::GetInheritTypes(PSI_INHERIT_TYPE *ppInheritTypes,
                               ULONG *pcInheritTypes)
{
    *ppInheritTypes = g_siObjInheritTypes;
    *pcInheritTypes = sizeof(g_siObjInheritTypes)/sizeof(g_siObjInheritTypes[0]);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CObjSecurity::PropertySheetPageCallback(HWND hwnd,
                                         UINT uMsg,
                                         SI_PAGE_TYPE uPage)
{
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\synchros\atomics.h ===
////////////////////////////////////////////////
// Atomics.h

#ifndef __ATOMICS_H__
#define __ATOMICS_H__

void AtomicInit();
void AtomicTerm();

// Returns true if val at zero and siezed
bool AtomicSeizeToken( long &lVal );
// Returns true if val at non-zero and released
bool AtomicReleaseToken( long &lVal );


class CAtomicList
{
public:
	typedef enum tag_ListAccess_t
	{
		LIST_READ,
		LIST_WRITE,
	} ListAccess;

// Construction
public:
	CAtomicList();
	~CAtomicList();

// Members
protected:
	long				m_lCount;
	DWORD				m_dwThreadID;
	CRITICAL_SECTION	m_crit;
	HANDLE				m_hEvent;

// Implemetation
public:
	bool Lock( short nType, DWORD dwTimeOut = INFINITE );
	void Unlock( short nType );

};


#endif // __ATOMICS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\transbmp\transbmp.h ===
/////////////////////////////////////////////////////////////////
// TRANSBMP.H
//
// Transparent bitmap header
//

#ifndef __TRANSBMP_H__
#define __TRANSBMP_H__

extern "C" 
{
	void DrawTrans( HDC hDC, HBITMAP hBmp, int x, int y, int dx = -1, int dy = -1 );
	void Draw( HDC hDC, HBITMAP hBmp, int x, int y, int dx = -1, int dy = -1, bool bStretch = false );

	void Draw3dBox(HDC hDC, RECT& rect, bool bUp);
	void Erase3dBox(HDC hDC, RECT& rect, HBRUSH hbr );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\confprop\rndsec.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    rndsec.h

Abstract:

    Security utilities for Rendezvous Control.

Author:

    KrishnaG (from OLEDS team)

Environment:

    User Mode - Win32

Revision History:

    12-Dec-1997 DonRyan
        Munged KrishnaG's code to work with Rendezvous Control.

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
#include <iads.h>

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT
ConvertSDToVariant(
    IN  PSECURITY_DESCRIPTOR pSecurityDescriptor,
    OUT VARIANT * pVarSec
    );

HRESULT
ConvertSDToIDispatch(
    IN  PSECURITY_DESCRIPTOR pSecurityDescriptor,
    OUT IDispatch ** ppIDispatch
    );

HRESULT
ConvertObjectToSD(
    IN  IADsSecurityDescriptor FAR * pSecDes,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor,
    OUT PDWORD pdwSDLength
    );

HRESULT
ConvertObjectToSDDispatch(
    IN  IDispatch * pDisp,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor,
    OUT PDWORD pdwSDLength
    );

HRESULT
ConvertACLToVariant(
    PACL pACL,
    LPVARIANT pvarACL
    );

HRESULT
ConvertSidToFriendlyName(
    PSID pSid,
    LPWSTR * ppszAccountName
    );

HRESULT
ConvertTrusteeToSid(
    BSTR bstrTrustee,
    PSID * ppSid,
    PDWORD pdwSidSize
    );

HRESULT
ConvertStringToSid(
    IN  PWSTR       string,
    OUT PSID       *sid,
    OUT PDWORD     pdwSidSize,
    OUT PWSTR      *end
	 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\confprop\winlocal.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
//  winlocal.h - local windows include umbrella
////

#ifndef __WINLOCAL_H__
#define __WINLOCAL_H__

#ifndef STRICT
#define STRICT
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif 

#include <windows.h>
#include <windowsx.h>
#include <winnt.h>
#include <commctrl.h>
#include <atlbase.h>

#define DLLEXPORT __declspec(dllexport)
#define DECLARE_HANDLE32    DECLARE_HANDLE


#endif // __WINLOCAL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\synchros\atomics.cpp ===
/////////////////////////////////////////////////////////////////////
// atomics.cpp
//

#ifndef _WIN32_WINNT
#define _WIN32_WINNT	0x0500
#endif

#include <atlbase.h>
#include "atomics.h"



CComCriticalSection	g_critInc;

void AtomicInit()
{
	g_critInc.Init();
}

void AtomicTerm()
{
	g_critInc.Term();
}

bool AtomicSeizeToken( long &lVal )
{
	bool bRet = false;
	g_critInc.Lock();
	if ( !lVal )
	{
		lVal++;
		bRet = true;
	}
	g_critInc.Unlock();
	return bRet;
}

bool AtomicReleaseToken( long &lVal )
{
	bool bRet = false;
	g_critInc.Lock();
	if ( lVal == 1 )
	{
		lVal--;
		bRet = true;
	}
	g_critInc.Unlock();
	return bRet;
}


///////////////////////////////////////////////////////////////////////////
// class CAtomicList
//

CAtomicList::CAtomicList()
{
	m_dwThreadID = 0;
	m_lCount = 0;
	m_hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
	InitializeCriticalSection( &m_crit );
}

CAtomicList::~CAtomicList()
{
	_ASSERT( m_lCount == 0 );		// don't want to destroy object with outstanding ref's
	CloseHandle( m_hEvent );
	DeleteCriticalSection( &m_crit );
}


bool CAtomicList::Lock( short nType, DWORD dwTimeOut /*= INFINITE*/)
{
	switch ( nType )
	{
		case LIST_READ:
			if ( dwTimeOut == INFINITE )
			{
				EnterCriticalSection( &m_crit );
				m_lCount++;
				LeaveCriticalSection( &m_crit );
			}
			else
			{
				while ( dwTimeOut )
				{
					if ( TryEnterCriticalSection(&m_crit) )
					{
						m_lCount++;
						LeaveCriticalSection(&m_crit);
						break;
					}
					else
					{
						// Sleep for a while
						if ( dwTimeOut > 50 )
						{
							dwTimeOut -= 50;
							Sleep( 50 );
						}
						else
						{
							return false;
						}
					}
				}
			}
			break;

		case LIST_WRITE:
			for ( ;; )
			{
				EnterCriticalSection( &m_crit );
				if ( (GetCurrentThreadId() != m_dwThreadID) && (m_lCount > 0) )
				{	
					LeaveCriticalSection( &m_crit );
					WaitForSingleObject( m_hEvent, INFINITE );
				}
				else
				{
					m_dwThreadID = GetCurrentThreadId();
					m_lCount++;
					break;
				}
			};
			break;
	}

	// Success!
	return true;
}

void CAtomicList::Unlock( short nType )
{
	EnterCriticalSection( &m_crit );
	_ASSERT( m_lCount > 0 );
	m_lCount--;
	if ( nType == LIST_WRITE )
	{
		if ( !m_lCount ) m_dwThreadID = 0;
		LeaveCriticalSection( &m_crit );
	}
	LeaveCriticalSection( &m_crit );

	PulseEvent( m_hEvent );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\transbmp\transbmp.cpp ===
#include <windows.h>
#include <assert.h>
#include "transbmp.h"

void GetMetrics( HBITMAP hBmp, int &nWidth, int &nHeight )
{
	// Get width & height
	BITMAP bm;
	if ( GetObject(hBmp, sizeof(bm), &bm) > 0)
	{
		nWidth = bm.bmWidth;
		nHeight = bm.bmHeight;
	}
	assert( nWidth && nHeight );
}

void CreateMask( HDC hDC, HBITMAP hBmp, HBITMAP& hBmpMask, int nWidth, int nHeight )
{
    //
    // We have to verify if hDC is a valid handler
    //
    
    hBmpMask = NULL;
    if( (NULL == hDC) || (NULL == hBmp) )
    {
        hBmpMask = NULL;
        return;
    }

	// Create memory DCs to work with
	HDC hdcMask = CreateCompatibleDC( hDC );

    //
    // We have to verify if hdcMask is a valid handler
    //
    
    if( NULL == hdcMask )
    {
        return;
    }

	HDC hdcImage = CreateCompatibleDC( hDC );

    //
    // We have to verify if hdcMask is a valid handler
    //

    if( NULL == hdcImage )
    {
        DeleteDC( hdcMask );
        return;
    }

	// Create a monochrome bitmap for the mask
	hBmpMask = CreateBitmap( nWidth, nHeight, 1, 1, NULL );

    //
    // We have to verify if hdcMask is a valid handler
    //

    if( NULL == hBmpMask )
    {
        DeleteDC( hdcImage );
        DeleteDC( hdcMask );
        return;
    }

	// Select the mono bitmap into its DC
	HBITMAP hbmOldMask = (HBITMAP) SelectObject( hdcMask, hBmpMask );

    //
    // We have to verify if hdcMask is a valid handler
    //

    if( NULL == hbmOldMask )
    {
        DeleteObject( hBmpMask );
        hBmpMask = NULL;

        DeleteDC( hdcImage );
        DeleteDC( hdcMask );
        return;
    }

	// Select the image bitmap into its DC
	HBITMAP hbmOldImage = (HBITMAP) SelectObject( hdcImage, hBmp );

    //
    // We have to verify if hdcMask is a valid handler
    //

    if( NULL == hbmOldImage )
    {
        SelectObject( hdcMask, hbmOldMask);

        DeleteObject( hBmpMask );
        hBmpMask = NULL;

        DeleteDC( hdcImage );
        DeleteDC( hdcMask );
        return;
    }

	// Set the transparency color to be the top-left pixel
	SetBkColor( hdcImage, GetPixel(hdcImage, 0, 0) );
	
	// Make the mask
	BitBlt( hdcMask, 0, 0, nWidth, nHeight, hdcImage, 0, 0, SRCCOPY );

	// Clean up
	SelectObject( hdcImage, hbmOldImage );
	SelectObject( hdcMask, hbmOldMask );

	DeleteDC( hdcMask );
	DeleteDC( hdcImage );
}

void Draw( HDC hDC, HBITMAP hBmp, int x, int y, int dx /*= -1*/, int dy /*= -1*/, bool bStretch /* = false*/ )
{
	assert( hDC && hBmp );
	int nWidth, nHeight;
	GetMetrics( hBmp, nWidth, nHeight );

	// Create a memory DC
	HDC hDCMem = CreateCompatibleDC( hDC );		  	

	if ( hDCMem )
	{
		// Make sure we have valid values for width & height
		if ( dx == -1 )	dx = nWidth;
		if ( dy == -1 )	dy = nHeight;

		if ( !bStretch )
		{
			dx = min( dx, nWidth );
			dy = min( dy, nHeight );
		}

		HBITMAP hbmOld = (HBITMAP) SelectObject( hDCMem, hBmp );

		// Blt the bits
		if ( !bStretch )
		{
			BitBlt( hDC, x, y, dx, dy, hDCMem, 0, 0, SRCCOPY );
		}
		else
		{
			SetStretchBltMode((HDC) hDC, COLORONCOLOR);
			StretchBlt( hDC, x, y, dx, dy,
						hDCMem, 0, 0, nWidth, nHeight, SRCCOPY );
		}
			
		SelectObject( hDCMem, hbmOld );
		DeleteDC( hDCMem );
	}
}


void DrawTrans( HDC hDC, HBITMAP hBmp, int x, int y, int dx /*= -1*/, int dy /*= -1*/ )
{
    //
    // We should initialize local variables
    //
    if( (NULL == hDC) || (NULL == hBmp))
    {
        return;
    }

	int nWidth = 0, nHeight = 0;
	GetMetrics( hBmp, nWidth, nHeight );

	// Create transparent bitmap mask
	HBITMAP hBmpMask = NULL;
	CreateMask( hDC, hBmp, hBmpMask, nWidth, nHeight );

    //
    //

    if( NULL == hBmpMask )
    {
        return;
    }

	// Make sure we have valid values for width & height
	if ( dx == -1 )	dx = nWidth;
	if ( dy == -1 )	dy = nHeight;
	dx = min( dx, nWidth );
	dy = min( dy, nHeight );


	// Create a memory DC in which to draw
	HDC hdcOffScr = CreateCompatibleDC( hDC );

    //
    // We have to verify hdcOffScr is valid
    //

    if( NULL == hdcOffScr )
    {
	    DeleteObject( hBmpMask );
        return;
    }
	
	// Create a bitmap for the off-screen DC that is really color-compatible with the
	// destination DC
	HBITMAP hbmOffScr = CreateBitmap( dx, dy, (BYTE) GetDeviceCaps(hDC, PLANES),
						  					  (BYTE) GetDeviceCaps(hDC, BITSPIXEL),
											  NULL );

    //
    //

    if( NULL == hbmOffScr )
    {
        DeleteDC( hdcOffScr );
	    DeleteObject( hBmpMask );
        return;
    }

	// Select the buffer bitmap into the off-screen DC
	HBITMAP hbmOldOffScr = (HBITMAP) SelectObject( hdcOffScr, hbmOffScr );

    //
    //

    if( NULL == hbmOldOffScr )
    {
        DeleteObject( hbmOffScr );
        DeleteDC( hdcOffScr );
	    DeleteObject( hBmpMask );
        return;
    }


	// Copy the image of the destination rectangle to the off-screen buffer DC so
	// we can manipulate it
	BitBlt( hdcOffScr, 0, 0, dx, dy, hDC, x, y, SRCCOPY);

	// Create a memory DC for the source image
	HDC hdcImage = CreateCompatibleDC( hDC );

    //
    // We have to verify the hdcImage
    //

    if( NULL == hdcImage )
    {
        // Restore
    	SelectObject( hdcOffScr, hbmOldOffScr );
        DeleteObject( hbmOffScr );
        DeleteDC( hdcOffScr );
	    DeleteObject( hBmpMask );

        return;
    }

	HBITMAP hbmOldImage = (HBITMAP) SelectObject( hdcImage, hBmp );

    //
    // We have to verify the hbmOldImage
    //

    if( NULL == hbmOldImage )
    {
        // Restore
        DeleteDC( hdcImage );
    	SelectObject( hdcOffScr, hbmOldOffScr );
        DeleteObject( hbmOffScr );
        DeleteDC( hdcOffScr );
	    DeleteObject( hBmpMask );

        return;
    }


	// Create a memory DC for the mask
	HDC hdcMask = CreateCompatibleDC( hDC );

    //
    //

    if( NULL == hdcMask )
    {
        // Restore
        SelectObject( hdcImage, hbmOldImage );
        DeleteDC( hdcImage );
    	SelectObject( hdcOffScr, hbmOldOffScr );
        DeleteObject( hbmOffScr );
        DeleteDC( hdcOffScr );
	    DeleteObject( hBmpMask );

        return;
    }

	HBITMAP hbmOldMask = (HBITMAP) SelectObject( hdcMask, hBmpMask );

    //
    // We have to verify the hbmOldMask
    //

    if( NULL == hbmOldMask )
    {
        // Restore
        DeleteDC( hdcMask );
        SelectObject( hdcImage, hbmOldImage );
        DeleteDC( hdcImage );
    	SelectObject( hdcOffScr, hbmOldOffScr );
        DeleteObject( hbmOffScr );
        DeleteDC( hdcOffScr );
	    DeleteObject( hBmpMask );

        return;
    }


	// XOR the image with the destination
	SetBkColor( hdcOffScr, RGB(255, 255, 255) );
	BitBlt( hdcOffScr, 0, 0, dx, dy, hdcImage, 0, 0, SRCINVERT );
	// AND the destination with the mask
	BitBlt( hdcOffScr, 0, 0, dx, dy, hdcMask, 0, 0, SRCAND );
	// XOR the destination with the image again
	BitBlt( hdcOffScr, 0, 0, dx, dy, hdcImage, 0, 0, SRCINVERT);

	// Copy the resultant image back to the screen DC
	BitBlt( hDC, x, y, dx, dy, hdcOffScr, 0, 0, SRCCOPY );

	// Clean up
    //
    // We have to clean up corectly
    //
    SelectObject( hdcMask, hbmOldMask);
    DeleteDC( hdcMask );
    SelectObject( hdcImage, hbmOldImage );
    DeleteDC( hdcImage );
    SelectObject( hdcOffScr, hbmOldOffScr );
    DeleteObject( hbmOffScr );
    DeleteDC( hdcOffScr );
	DeleteObject( hBmpMask );
}

void Draw3dBox(HDC hDC, RECT& rect, bool bUp)
{
	assert ( hDC );

	HBRUSH hbrOld = (HBRUSH) SelectObject( hDC, GetSysColorBrush((bUp) ? COLOR_BTNHIGHLIGHT : COLOR_BTNSHADOW) );

	// Draw left and top sides of indent.		
	PatBlt( hDC, rect.left, rect.top, (rect.right - rect.left), 1, PATCOPY );
	PatBlt( hDC, rect.left, rect.top, 1, (rect.bottom - rect.top), PATCOPY );
    
	// Draw bottom and right sides of indent.
	SelectObject( hDC, GetSysColorBrush((!bUp) ? COLOR_BTNHIGHLIGHT : COLOR_BTNSHADOW) );
	PatBlt( hDC, rect.right - 1, rect.top, 1, (rect.bottom - rect.top), PATCOPY );
	PatBlt( hDC, rect.left, rect.bottom - 1, (rect.right - rect.left), 1, PATCOPY );

	if ( hbrOld )
		SelectObject( hDC, hbrOld );
}

void Erase3dBox(HDC hDC, RECT& rect, HBRUSH hbr )
{
	assert ( hDC );

	HBRUSH hbrOld = (HBRUSH) SelectObject( hDC, (hbr) ? hbr : GetSysColorBrush(GetBkColor(hDC)) );

	// Draw left and top sides of indent.		
	PatBlt( hDC, rect.left, rect.top, (rect.right - rect.left), 1, PATCOPY );
	PatBlt( hDC, rect.left, rect.top, 1, (rect.bottom - rect.top), PATCOPY );
    
	// Draw bottom and right sides of indent.
	PatBlt( hDC, rect.right - 1, rect.top, 1, (rect.bottom - rect.top), PATCOPY );
	PatBlt( hDC, rect.left, rect.bottom - 1, (rect.right - rect.left), 1, PATCOPY );

	if ( hbrOld )
		SelectObject( hDC, hbrOld );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\confprop\wnd.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// wnd.h - window functions
////

// WndCenterWindow - center one window on top of another
//		<hwnd1>				(i) window to be centered
//		<hwnd2>				(i) window to be centered upon
//			NULL				center on parent or owner
//		<xOffCenter>		(i) offset from horizontal center
//			0					center window exactly
//		<yOffCenter>		(i) offset from vertical center
//			0					center window exactly
// return 0 if success
//
int DLLEXPORT WINAPI WndCenterWindow(HWND hwnd1, HWND hwnd2, int xOffCenter, int yOffCenter);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\avdialer\confprop\wnd.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////
// wnd.c - window functions
////

#include "winlocal.h"

// WndCenterWindow - center one window on top of another
//		<hwnd1>				(i) window to be centered
//		<hwnd2>				(i) window to be centered upon
//			NULL				center on parent or owner
//		<xOffCenter>		(i) offset from horizontal center
//			0					center window exactly
//		<yOffCenter>		(i) offset from vertical center
//			0					center window exactly
// return 0 if success
//
int DLLEXPORT WINAPI WndCenterWindow(HWND hwnd1, HWND hwnd2, int xOffCenter, int yOffCenter)
{
	POINT pt;
	RECT rc1;
	RECT rc2;
	int nWidth;
	int nHeight;

	if ( hwnd1 )
	{
		// use parent or owner window if no other specified
		//
		if (hwnd2 == NULL)
			hwnd2 = GetParent(hwnd1);

		// use desktop window if no parent or owner
		// or if parent or owner is iconic or invisible
		//
		if (hwnd2 == NULL || IsIconic(hwnd2) || !IsWindowVisible(hwnd2))
			hwnd2 = GetDesktopWindow();

		// get the rectangles for both windows
		//
		GetWindowRect(hwnd1, &rc1);
		GetClientRect(hwnd2, &rc2);

		// calculate the height and width for MoveWindow
		//
		nWidth = rc1.right - rc1.left;
		nHeight = rc1.bottom - rc1.top;

		// find the center point and convert to screen coordinates
		//
		pt.x = (rc2.right - rc2.left) / 2;
		pt.y = (rc2.bottom - rc2.top) / 2;
		ClientToScreen(hwnd2, &pt);

		// calculate the new x, y starting point
		//
		pt.x -= (nWidth / 2);
		pt.y -= (nHeight / 2);

		// adjust the window position off center, if necessary
		//
		pt.x = max(0, pt.x + xOffCenter);
		pt.y = max(0, pt.y + yOffCenter);
	
		// center the window
		//
		MoveWindow( hwnd1, pt.x, pt.y, nWidth, nHeight, FALSE );
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\samples\ansmach\callnot.h ===
////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1998-1999  Microsoft Corporation
//
//
// TAPIEventNotification.h : Declaration of the CTAPIEventNotification object
//
////////////////////////////////////////////////////////////////////////////
#ifndef __TAPIEventNotification_H__
#define __TAPIEventNotification_H__


#define WM_PRIVATETAPIEVENT   WM_USER+101

HRESULT
OnTapiEvent(
            TAPI_EVENT TapiEvent,
            IDispatch * pEvent
           );

/////////////////////////////////////////////////////////////////////////////
// CTAPIEventNotification
class CTAPIEventNotification : public ITTAPIEventNotification
{
private:

    LONG       m_dwRefCount;

public:

    // CTAPIEventNotification implements ITTAPIEventNotification
    //  Declare ITTAPIEventNotification methods here
    HRESULT STDMETHODCALLTYPE Event(
                                    TAPI_EVENT TapiEvent,
                                    IDispatch * pEvent
                                   );
    
// other COM stuff:
public:

    // constructor
    CTAPIEventNotification() { m_dwRefCount = 1;}

    // destructor
    ~CTAPIEventNotification(){}

    // initialization function
    // this stuff could also be done in the
    // constructor
    HRESULT Initialize( )
    {
        m_dwRefCount = 1;
 
        return S_OK;
    }

    void Shutdown()
    {
    }

    // IUnknown implementation
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void **ppvObject)
    {
        if (iid == IID_ITTAPIEventNotification)
        {
            AddRef();
            *ppvObject = (void *)this;
            return S_OK;
        }

        if (iid == IID_IUnknown)
        {
            AddRef();
            *ppvObject = (void *)this;
            return S_OK;
        }

        return E_NOINTERFACE;
    }

    //
    // reference counting needs to be thread safe
    //

    ULONG STDMETHODCALLTYPE AddRef()
    {
        ULONG l = InterlockedIncrement(&m_dwRefCount);
        return l;
    }
    
	ULONG STDMETHODCALLTYPE Release()
    {
        ULONG l = InterlockedDecrement(&m_dwRefCount);

        if ( 0 == l)
        {
            delete this;
        }
        
        return l;
    }


};

#endif //__TAPIEventNotification_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\samples\ansmach\callnot.cpp ===
//////////////////////////////////////////////////////////////////////
//
//
//  Copyright (c) 1998-1999  Microsoft Corporation
//
//
// callnot.cpp
//
// Implementation of the ITTAPIEventNotification interface.
//
// This is an outgoing interface that is defined by TAPI 3.0.  This
// is basically a callback function that TAPI 3.0 calls to inform
// the application of events related to calls (on a specific address)
//
// Please refer to COM documentation for information on outgoing
// interfaces.
// 
// An application must implement and register this interface in order
// to receive calls and events related to calls
//
//////////////////////////////////////////////////////////////////////


#include <windows.h>
#include <tapi3.h>
#include <control.h>
#include <strmif.h>

#include "callnot.h"
#include "resource.h"
#include "term.h"

extern ITBasicCallControl * gpCall;
extern HWND ghDlg;
extern BSTR gbstrAudio;

extern bool g_fPlay;
extern bool g_fRecord;

extern ITTerminal *g_pPlayMedStrmTerm, *g_pRecordMedStrmTerm;
extern ITStream *g_pRecordStream;

CWorkerThread gWorkerThread;

void
DoMessage(
          LPTSTR pszMessage
         );

void
SetStatusMessage(
                 LPTSTR pszMessage
                );


HRESULT GetTerminalFromStreamEvent( ITCallMediaEvent * pCallMediaEvent,
                                    ITTerminal ** ppTerminal )
{
    HRESULT hr;

    //
    // Get the stream for this event.
    //

    ITStream * pStream;
    hr = pCallMediaEvent->get_Stream( &pStream );
    if ( FAILED(hr) || (pStream == NULL) ) return E_FAIL;

    //
    // Enumerate the terminals on this stream.
    //

    IEnumTerminal * pEnumTerminal;
    hr = pStream->EnumerateTerminals( &pEnumTerminal );
    pStream->Release();
    if ( FAILED(hr) ) return hr;

    //
    // Get the first terminal -- if there aren't any, return E_FAIL so that
    // we skip this event (this happens when the terminal is on the other
    // stream).
    //

    hr = pEnumTerminal->Next(1, ppTerminal, NULL);
    if ( hr != S_OK )
    {
        pEnumTerminal->Release();
        return E_FAIL;
    }

    //
    // Sanity check: see if there's more than one terminal. That shouldn't
    // happen since we only ever select one terminal on each stream.
    //

    ITTerminal * pExtraTerminal;
    hr = pEnumTerminal->Next(1, &pExtraTerminal, NULL);
    pEnumTerminal->Release();

    if ( hr == S_OK ) // more than one terminal -- impossible!
    {
        pExtraTerminal->Release();
        (*ppTerminal)->Release();
        *ppTerminal = NULL;
        return E_UNEXPECTED;
    }

    return S_OK;
}

///////////////////////////////////////////////////////////////////
// PlayAndRecordMessage
//
// Plays a recorded message and records the incoming message.
//
///////////////////////////////////////////////////////////////////
HRESULT PlayAndRecordMessage(ITTerminal *pPlayStreamTerm, ITTerminal *pRecordStreamTerm)
{
    CStreamMessageWI *pwi = new CStreamMessageWI();

    if (NULL == pwi)
    {
        return E_OUTOFMEMORY;
    }

    
    BOOL InitStatus = pwi->Init(pPlayStreamTerm, pRecordStreamTerm);
    
    if (!InitStatus) 
    {
        delete pwi;
        return E_FAIL;
    }

    
    HRESULT hr = gWorkerThread.AsyncWorkItem(pwi);

    if (FAILED(hr))
    {
        //
        // the message was not queued and will not be processed and freed.
        // delete it here
        //

        delete pwi;

        return hr;
    }

    return S_OK;
}

///////////////////////////////////////////////////////////////////
// CallEventNotification
//
// The only method in the ITCallEventNotification interface.  This gets
// called by TAPI 3.0 when there is a call event to report. This just
// posts the message to our UI thread, so that we do as little as
// possible on TAPI's callback thread.
//
///////////////////////////////////////////////////////////////////

HRESULT
STDMETHODCALLTYPE
CTAPIEventNotification::Event(
                              TAPI_EVENT TapiEvent,
                              IDispatch * pEvent
                             )
{
    //
    // Addref the event so it doesn't go away.
    //

    pEvent->AddRef();

    //
    // Post a message to our own UI thread.
    //

    PostMessage(
                ghDlg,
                WM_PRIVATETAPIEVENT,
                (WPARAM) TapiEvent,
                (LPARAM) pEvent
               );

    return S_OK;
}

///////////////////////////////////////////////////////////////////
// OnTapiEvent
//
// This is the real event handler, called on our UI thread when
// the WM_PRIVATETAPIEVENT message is received
//
///////////////////////////////////////////////////////////////////

HRESULT
OnTapiEvent(
            TAPI_EVENT TapiEvent,
            IDispatch * pEvent
           )
{
    HRESULT hr;

    switch ( TapiEvent )
    {
        case TE_CALLNOTIFICATION:
        {
            // CET_CALLNOTIFICATION means that the application is being notified
            // of a new call.
            //
            // Note that we don't answer to call at this point.  The application
            // should wait for a CS_OFFERING CallState message before answering
            // the call.

            ITCallNotificationEvent         * pNotify;
            

            hr = pEvent->QueryInterface( IID_ITCallNotificationEvent, (void **)&pNotify );

            if (S_OK != hr)
            {
                DoMessage( TEXT("Incoming call, but failed to get the interface"));
            }
            else
            {
                CALL_PRIVILEGE          cp;
                ITCallInfo *            pCall;

                //
                // get the call
                //

                hr = pNotify->get_Call( &pCall );
                
                //
                // release the event object
                //

                pNotify->Release();

                //
                // check to see if we own the call
                //

                hr = pCall->get_Privilege( &cp );

                if ( CP_OWNER != cp )
                {
                    // just ignore it if we don't own it
                    pCall->Release();

                    pEvent->Release(); // we addrefed it CTAPIEventNotification::Event()

                    return S_OK;
                }

                hr = pCall->QueryInterface( IID_ITBasicCallControl, (void**)&gpCall );

                pCall->Release();

                //
                // update UI
                //
                SetStatusMessage(TEXT("Incoming Owner Call"));
            }
            
            break;
        }
        
        case TE_CALLSTATE:
        {
            // TE_CALLSTATE is a call state event.  pEvent is
            // an ITCallStateEvent

            CALL_STATE         cs;
            ITCallStateEvent * pCallStateEvent;

            // Get the interface
            pEvent->QueryInterface( IID_ITCallStateEvent, (void **)&pCallStateEvent );

            // get the CallState that we are being notified of.
            pCallStateEvent->get_State( &cs );

            pCallStateEvent->Release();

            // if it's offering, update our UI
            if (CS_OFFERING == cs)
            {
                PostMessage(ghDlg, WM_COMMAND, IDC_ANSWER, 0);
            }
            else if (CS_DISCONNECTED == cs)
            {
                PostMessage(ghDlg, WM_COMMAND, IDC_DISCONNECTED, 0);
            }
            else if (CS_CONNECTED == cs)
            {
                PostMessage(ghDlg, WM_COMMAND, IDC_CONNECTED, 0);
            }

            break;
        }


        case TE_CALLMEDIA:
        {
            // TE_CALLMEDIA is a media event.  pEvent is
            // an ITCallMediaEvent

            CALL_MEDIA_EVENT    cme;
            ITCallMediaEvent  * pCallMediaEvent;

            // Get the interface
            pEvent->QueryInterface( IID_ITCallMediaEvent, (void **)&pCallMediaEvent );

            // get the CALL_MEDIA_EVENT that we are being notified of.
            pCallMediaEvent->get_Event( &cme );

            switch ( cme ) 
            {
                case CME_STREAM_INACTIVE:    
                {       
                //
                // CME_STREAM_INACTIVE tells us that the playback MST finished
                // playing. Since only one terminal, either play or record, has
                // to be selected at a time, the play terminal is first unselected 
                // and then the record terminal is selected. 
                // This event is only invoked in the play or the both case, since the call 
                // is disconnected after the reocrding is done.
                //

                    if ( ( g_pRecordMedStrmTerm != NULL ) && ( g_pPlayMedStrmTerm != NULL ) ) 
                    {
                        ITStream *pStream;

                        if ( SUCCEEDED( hr = pCallMediaEvent->get_Stream(&pStream) ) )
                        {
                            pStream->UnselectTerminal(g_pPlayMedStrmTerm);
                            pStream->Release();
                            g_pPlayMedStrmTerm->Release();
                            g_pPlayMedStrmTerm = NULL;
                        }
                        else
                        {
                            ::MessageBox(NULL, "UnSelect for Play Terminal Failed", "Call Media Event", MB_OK);
                        }
                        if ( SUCCEEDED( hr = g_pRecordStream->SelectTerminal(g_pRecordMedStrmTerm) ) ) 
                        {
                            g_pRecordMedStrmTerm->Release();
                            g_pRecordStream->Release();
                            g_pRecordMedStrmTerm= NULL;
                        }
                        else 
                        {
                            ::MessageBox(NULL, "Select Terminal for Record Failed", "Call Media Event", MB_OK);
                        }
                    }

                    // Once the recording is done, we disconnect but when only play
                    // is selected we need to post a disconnect message
                    else if (!g_fRecord) 
                    {
                        PostMessage(ghDlg, WM_COMMAND, IDC_DISCONNECT, 0);
                    }

                    break;
                }

                case CME_STREAM_NOT_USED:
                case CME_NEW_STREAM:
                    break;

                case CME_STREAM_FAIL:
                    ::MessageBox(NULL, "Stream failed", "Call media event", MB_OK);
                    break;
    
                case CME_TERMINAL_FAIL:
                    ::MessageBox(NULL, "Terminal failed", "Call media event", MB_OK);
                    break;

                case CME_STREAM_ACTIVE:    
                {
                
                    ITTerminal *pPlayStreamTerm    = NULL;
                    ITTerminal *pRecordStreamTerm  = NULL;

                    //
                    // Get the terminal that's now active. 
                    //    

                    ITTerminal * pTerminal;
                    hr = GetTerminalFromStreamEvent(pCallMediaEvent, &pTerminal);

                    if ( FAILED(hr) )  break; 
    
                    //
                    // Remember this terminal based on the direction.
                    //

                    TERMINAL_DIRECTION td;
                    hr = pTerminal->get_Direction( &td);

                    if ( FAILED(hr) ) 
                    { 
                        pTerminal->Release(); 
                        break; 
                    }
                   
                    if ( TD_CAPTURE == td ) 
                    {
                        pPlayStreamTerm = pTerminal;
                    }
                    else if ( TD_RENDER == td ) 
                    {
                        pRecordStreamTerm = pTerminal;
                    }
                    else 
                    {
                        // this is not supposed to happen
                        pTerminal->Release();
                        break;
                    }

                    //
                    // Now do the actual streaming...
                    //

                    PlayAndRecordMessage(pPlayStreamTerm, pRecordStreamTerm);
                
                    if (NULL != pPlayStreamTerm)   pPlayStreamTerm->Release();
                    if (NULL != pRecordStreamTerm) pRecordStreamTerm->Release();
               
            
                    //
                    // Start over for the next call.
                    //

                    pPlayStreamTerm = NULL;
                    pRecordStreamTerm = NULL;
                
                    break;
                }
            
                default:
                    break;
            }

            // We no longer need this interface.
            pCallMediaEvent->Release();
            break;    
        }    
    }    

   
    pEvent->Release(); // we addrefed it CTAPIEventNotification::Event()

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\samples\incoming\callnot.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.

Module Name:
    callnot.cpp

Abstract:

    Implementation of the ITTAPIEventNotification interface.

    This is an outgoing interface that is defined by TAPI 3.0.  This
    is basically a callback function that TAPI 3.0 calls to inform
    the application of events related to calls (on a specific address)

    Please refer to COM documentation for information on outgoing
    interfaces.

    An application must implement and register this interface in order
    to receive calls and events related to calls

--*/


#include <windows.h>
#include <tapi3.h>
#include <control.h>
#include <strmif.h>

#include "callnot.h"
#include "resource.h"

extern ITBasicCallControl * gpCall;
extern HWND ghDlg;
extern BSTR gbstrVideo;
extern BOOL gfAutoAnswer;

void
DoMessage(
          LPWSTR pszMessage
         );

void
SetStatusMessage(
                 LPWSTR pszMessage
                );

void
EnableButton(
             int ID
            );
void
DisableButton(
              int ID
             );

enum {
    VWP_LEFT = 20,
    VWP_TOP = 100
};

///////////////////////////////////////////////////////////////////
// HostWindow
//
// This method takes a pVideoWindow interface pointer and puts
//  the window in our dialog.
//
// The location depends on the iWhere parameter.
//
///////////////////////////////////////////////////////////////////

void
HostWindow(
           IVideoWindow *pVideoWindow,
           int iWhere
          )
{

    pVideoWindow->put_Owner( (LONG_PTR)ghDlg );
    pVideoWindow->put_WindowStyle( WS_CHILDWINDOW | WS_BORDER );

    long lWidth, lHeight;
    pVideoWindow->get_Width( &lWidth );
    pVideoWindow->get_Height( &lHeight );

    pVideoWindow->SetWindowPosition( VWP_LEFT + (iWhere * (VWP_LEFT + lWidth)),
                                     VWP_TOP,
                                     lWidth,
                                     lHeight );

    pVideoWindow->put_Visible( VARIANT_TRUE );
}

///////////////////////////////////////////////////////////////////
// GetVideoRenderTerminalFromStreamEvent
//
// Find out if this stream has a video render terminal. If not,
// we don't need to do anything with this stream. Also note
// if this is the video capture stream or the video render
// stream.
//
///////////////////////////////////////////////////////////////////

HRESULT
GetVideoRenderTerminalFromStreamEvent(
                                      ITCallMediaEvent  * pCallMediaEvent,
                                      ITTerminal       ** ppTerminal,
                                      BOOL              * pfRenderStream
                                     )
{
    HRESULT hr;

    //
    // Get the stream for this event.
    //

    ITStream * pStream;

    hr = pCallMediaEvent->get_Stream( &pStream );

    if ( FAILED(hr) || (pStream == NULL) )
    {
        return E_FAIL;
    }

    //
    // Find out if this is a video stream. If not, fail --
    // we don't care about this stream.
    //

    long lMediaType;

    hr = pStream->get_MediaType(&lMediaType);

    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( lMediaType != TAPIMEDIATYPE_VIDEO )
    {
        return E_FAIL;
    }

    //
    // Find out the direction of this stream. We will return this info to the
    // caller.
    //

    TERMINAL_DIRECTION td;

    hr = pStream->get_Direction(&td);

    if ( FAILED(hr) )
    {
        return hr;
    }

    *pfRenderStream = (td == TD_RENDER);

    //
    // Enumerate the terminals on this stream.
    //

    IEnumTerminal * pEnumTerminal;

    hr = pStream->EnumerateTerminals( &pEnumTerminal );

    pStream->Release();

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // Search for the first video render terminal and return it. If there are
    // none, fail -- we don't care about this stream.
    //

    while ( S_OK == pEnumTerminal->Next(1, ppTerminal, NULL) )
    {
        if ( SUCCEEDED( (*ppTerminal)->get_Direction(&td) ) )
        {
            if ( td == TD_RENDER )
            {
                // found it; done with enum, but keep ref on terminal
                pEnumTerminal->Release();

                return S_OK;
            }
        }

        // this is not the right one
        (*ppTerminal)->Release();
    }

    pEnumTerminal->Release();

    return E_FAIL; // no terminal found
}

///////////////////////////////////////////////////////////////////
// CallEventNotification
//
// The only method in the ITCallEventNotification interface.  This gets
// called by TAPI 3.0 when there is a call event to report. This just
// posts the message to our UI thread, so that we do as little as
// possible on TAPI's callback thread.
//
///////////////////////////////////////////////////////////////////

HRESULT
STDMETHODCALLTYPE
CTAPIEventNotification::Event(
                              TAPI_EVENT TapiEvent,
                              IDispatch * pEvent
                             )
{
    //
    // Addref the event so it doesn't go away.
    //

    pEvent->AddRef();

    //
    // Post a message to our own UI thread.
    //

    PostMessage(
                ghDlg,
                WM_PRIVATETAPIEVENT,
                (WPARAM) TapiEvent,
                (LPARAM) pEvent
               );

    return S_OK;
}

///////////////////////////////////////////////////////////////////
// OnTapiEvent
//
// This is the real event handler, called on our UI thread when
// the WM_PRIVATETAPIEVENT message is received
//
///////////////////////////////////////////////////////////////////

HRESULT
OnTapiEvent(
            TAPI_EVENT TapiEvent,
            IDispatch * pEvent
           )
{
    HRESULT hr;

    switch ( TapiEvent )
    {
        case TE_CALLNOTIFICATION:
        {
            //
            // TE_CALLNOTIFICATION means that the application is being notified
            // of a new call.
            //
            // Note that we don't answer to call at this point.  The application
            // should wait for a CS_OFFERING CallState message before answering
            // the call.
            //

            ITCallNotificationEvent         * pNotify;

            hr = pEvent->QueryInterface( IID_ITCallNotificationEvent, (void **)&pNotify );

            if (S_OK != hr)
            {
                DoMessage( L"Incoming call, but failed to get the interface");
            }
            else
            {
                CALL_PRIVILEGE          cp;
                ITCallInfo *            pCall;

                //
                // get the call
                //

                hr = pNotify->get_Call( &pCall );

                pNotify->Release();

                if ( SUCCEEDED(hr) )
                {
                    //
                    // check to see if we own the call
                    //

                    hr = pCall->get_Privilege( &cp );

                    if ( FAILED(hr) || (CP_OWNER != cp) )
                    {
                        //
                        // just ignore it if we don't own it
                        //

                        pCall->Release();

                        pEvent->Release(); // we addrefed it CTAPIEventNotification::Event()

                        return S_OK;
                    }

                    //
                    // Get the ITBasicCallControl interface and save it in our
                    // global variable.
                    //

                    hr = pCall->QueryInterface( IID_ITBasicCallControl,
                                                (void**)&gpCall );

                    pCall->Release();

                    if ( SUCCEEDED(hr) )
                    {
                        //
                        // update UI
                        //

                        EnableButton( IDC_ANSWER );
                        DisableButton( IDC_DISCONNECT );
                        SetStatusMessage(L"Incoming Owner Call");
                    }
                }
            }

            break;
        }

        case TE_CALLSTATE:
        {
            // TE_CALLSTATE is a call state event.  pEvent is
            // an ITCallStateEvent

            CALL_STATE         cs;
            ITCallStateEvent * pCallStateEvent;

            // Get the interface
            hr = pEvent->QueryInterface( IID_ITCallStateEvent, (void **)&pCallStateEvent );

            if ( FAILED(hr) )
            {
                break;
            }

            // get the CallState that we are being notified of.
            hr = pCallStateEvent->get_State( &cs );

            // Release the interface
            pCallStateEvent->Release();

            if ( FAILED(hr) )
            {
                break;
            }

            // if it's offering, update our UI
            if (CS_OFFERING == cs)
            {
                if (gfAutoAnswer)
                {
                    PostMessage(ghDlg, WM_COMMAND, IDC_ANSWER, 0);
                }
                else
                {
                    SetStatusMessage(L"Click the Answer button");
                }
            }
            else if (CS_DISCONNECTED == cs)
            {
                PostMessage(ghDlg, WM_COMMAND, IDC_DISCONNECTED, 0);
            }
            else if (CS_CONNECTED == cs)
            {
                // nothing to do -- we handle connection synchronously
            }

            break;
        }

        case TE_CALLMEDIA:
        {
            // TE_CALLMEDIA is a media event.  pEvent is
            // an ITCallMediaEvent

            CALL_MEDIA_EVENT    cme;
            ITCallMediaEvent  * pCallMediaEvent;

            // Get the interface
            hr = pEvent->QueryInterface( IID_ITCallMediaEvent, (void **)&pCallMediaEvent );

            if ( FAILED(hr) )
            {
                break;
            }

            // get the CALL_MEDIA_EVENT that we are being notified of.
            hr = pCallMediaEvent->get_Event( &cme );

            if ( SUCCEEDED(hr) )
            {
                switch ( cme )
                {
                case CME_STREAM_NOT_USED:
                case CME_STREAM_INACTIVE:
                case CME_NEW_STREAM:
                    break;

                case CME_STREAM_FAIL:
                    DoMessage( L"Call media event: stream failed");
                    break;

                case CME_TERMINAL_FAIL:
                    DoMessage( L"Call media event: terminal failed");
                    break;

                case CME_STREAM_ACTIVE:
                {
                    //
                    // Find out if this stream has a video render terminal. If not,
                    // we don't need to do anything with this stream. Also note
                    // if this is the video capture stream or the video render
                    // stream.
                    //

                    ITTerminal * pTerminal;
                    BOOL         fRenderStream;

                    hr = GetVideoRenderTerminalFromStreamEvent(
                                                               pCallMediaEvent,
                                                               &pTerminal,
                                                               &fRenderStream
                                                              );

                    if ( SUCCEEDED(hr) )
                    {
                        // Get the video window interface for the terminal
                        IVideoWindow *pVideoWindow = NULL;

                        hr = pTerminal->QueryInterface( IID_IVideoWindow, (void**)&pVideoWindow );

                        pTerminal->Release();

                        if ( SUCCEEDED(hr) )
                        {
                            // Put this window in our dialog
                            HostWindow(pVideoWindow, fRenderStream);

                            pVideoWindow->Release();
                        }
                    }

                    break;
                }

                default:
                    break;
                }
            }

            // We no longer need this interface.
            pCallMediaEvent->Release();

            break;
        }

        default:
            break;
    }

    pEvent->Release(); // we addrefed it CTAPIEventNotification::Event()

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\samples\ansmach\term.cpp ===
/*

    Copyright (c) 1998-1999  Microsoft Corporation

*/

#include <windows.h>
#include <tapi3.h>
#include <uuids.h>
#include <mmsystem.h>
#include <amstream.h>
#include <strmif.h>
#include <stdio.h>
#include <assert.h>
#include "term.h"
#include "resource.h"

// these flags determine whether we play, record or both
extern bool g_fPlay;
extern bool g_fRecord;

// pointer to the current call
extern ITBasicCallControl * gpCall;

// contains the waveformat thats used
extern WAVEFORMATEX gwfx;

extern HWND ghDlg;

#define RELEASE(x) if (x) { (x)->Release(); (x) = NULL; };

#define CHECK_ERROR(x)     \
   if (FAILED(hr = (x))) { \
       printf(#x "  failed with HRESULT(0x%8.8X)\n", hr); \
       goto Exit;          \
   }

// we read and write from the files below
// these should be present in the directory of execution
const WCHAR g_wszReadFileName[] = L"op1_16.avi";
const WCHAR g_wszWriteFileName[] = L"rec.avi";

void
SetStatusMessage(
                 LPTSTR pszMessage
                );



class CStreamSampleQueue;

// contains an IStreamSample ptr and is doubly-linked in
// a CStreamSampleQueue
class CQueueElem
{
public:

    friend CStreamSampleQueue;

    CQueueElem(
        IN IStreamSample    *pStreamSample,
        IN CQueueElem        *pPrev,
        IN CQueueElem        *pNext
        )
        : m_pStreamSample(pStreamSample),
          m_pPrev(pPrev),
          m_pNext(pNext)
    {
    }

protected:

    IStreamSample *m_pStreamSample;
    CQueueElem *m_pPrev;
    CQueueElem *m_pNext;
};

// queues CQueueElem instances (FIFO)
// keeps the instances in a doubly-linked list
class CStreamSampleQueue
{
public:

    CStreamSampleQueue()
        : m_Head(NULL, &m_Head, &m_Head)
    {}

    IStreamSample *Dequeue()
    {
        if (m_Head.m_pNext == &m_Head)    return NULL;

        CQueueElem *TargetQueueElem = m_Head.m_pNext;
        m_Head.m_pNext = m_Head.m_pNext->m_pNext;
        m_Head.m_pNext->m_pNext->m_pPrev = &m_Head;

        IStreamSample *ToReturn = TargetQueueElem->m_pStreamSample;
        delete TargetQueueElem;

        return ToReturn;
    }

    BOOL Enqueue(
        IN IStreamSample *pStreamSample
        )
    {
        CQueueElem *TargetQueueElem =
            new CQueueElem(pStreamSample, m_Head.m_pPrev, &m_Head);
        if (NULL == TargetQueueElem)    return FALSE;

        m_Head.m_pPrev->m_pNext = TargetQueueElem;
        m_Head.m_pPrev = TargetQueueElem;

        return TRUE;
    }


protected:

    CQueueElem    m_Head;
};

CStreamMessageWI::~CStreamMessageWI()
{
    if (NULL != m_pPlayStreamTerm)
    {
        m_pPlayStreamTerm->Release();
    }

    if (NULL != m_pRecordStreamTerm)
    {
        m_pRecordStreamTerm->Release();
    }
}

//////////////////////////////////////////////////////////////////////
// FreeMediaType
//
// Implementation of the functions using the media streaming terminal.
//
//////////////////////////////////////////////////////////////////////
void FreeMediaType(AM_MEDIA_TYPE& mt)
{
    if (mt.cbFormat != 0) {
        CoTaskMemFree((PVOID)mt.pbFormat);

        // Strictly unnecessary but tidier
        mt.cbFormat = 0;
        mt.pbFormat = NULL;
    }
    if (mt.pUnk != NULL) {
        mt.pUnk->Release();
        mt.pUnk = NULL;
    }
}

void DeleteMediaType(AM_MEDIA_TYPE *pmt)
{
    // allow NULL pointers for coding simplicity

    if (pmt == NULL) {
        return;
    }

    FreeMediaType(*pmt);
    CoTaskMemFree((PVOID)pmt);
}


//////////////////////////////////////////////////////////////////////
// CreateAudioStreamWithFormat
//
// This procedure creates and adds an audio stream to the passed in
// multimedia stream. It also sets the created audio stream's format
// to the passed in wave format.
//
//////////////////////////////////////////////////////////////////////
HRESULT CreateAudioStreamWithFormat(IAMMultiMediaStream *pAMStream,
                                    WAVEFORMATEX *pWaveFormat,
                                   IMediaStream **ppNewMediaStream)
{
    HRESULT hr;
    MSPID PurposeId = MSPID_PrimaryAudio;
    IAudioMediaStream   *pAudioMediaStream = NULL;

    CHECK_ERROR(pAMStream->AddMediaStream(NULL, &PurposeId, 0, ppNewMediaStream));

    // set the audio stream's format
    CHECK_ERROR((*ppNewMediaStream)->QueryInterface(IID_IAudioMediaStream, (void **)&pAudioMediaStream));
    CHECK_ERROR(pAudioMediaStream->SetFormat(pWaveFormat));

Exit:

    RELEASE(pAudioMediaStream);
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CreateWriterStream
//
// This procedure creates a multimedia stream with an audio stream that
// writes to the output file passed in.
//
//////////////////////////////////////////////////////////////////////
HRESULT CreateWriterStream(const WCHAR * pszOutputFileName,
                           WAVEFORMATEX *pWaveFormat,
                           IMultiMediaStream **ppMMStream)
{
    *ppMMStream = NULL;
    IAMMultiMediaStream *pAMStream = NULL;
    IMediaStream *pAudioStream = NULL;
    ICaptureGraphBuilder *pBuilder = NULL;
    IGraphBuilder *pFilterGraph = NULL;
    IFileSinkFilter *pFileSinkWriter = NULL;
    IBaseFilter *pMuxFilter = NULL;
    IConfigInterleaving *pConfigInterleaving = NULL;
    InterleavingMode MuxMode;

    HRESULT hr;

    CHECK_ERROR(CoCreateInstance(CLSID_AMMultiMediaStream, NULL, CLSCTX_INPROC_SERVER,
                 IID_IAMMultiMediaStream, (void **)&pAMStream));
    CHECK_ERROR(pAMStream->Initialize(STREAMTYPE_WRITE, 0, NULL));

    CHECK_ERROR(CreateAudioStreamWithFormat(pAMStream, pWaveFormat, &pAudioStream));

    CHECK_ERROR(CoCreateInstance(CLSID_CaptureGraphBuilder, NULL, CLSCTX_INPROC_SERVER,
                                 IID_ICaptureGraphBuilder, (void **)&pBuilder));

    CHECK_ERROR(pAMStream->GetFilterGraph(&pFilterGraph));
    CHECK_ERROR(pBuilder->SetFiltergraph(pFilterGraph));

    CHECK_ERROR(pBuilder->SetOutputFileName(&MEDIASUBTYPE_Avi, pszOutputFileName, &pMuxFilter, &pFileSinkWriter));

    CHECK_ERROR(pMuxFilter->QueryInterface(IID_IConfigInterleaving, (void **)&pConfigInterleaving));
    CHECK_ERROR(pConfigInterleaving->get_Mode(&MuxMode));

    CHECK_ERROR(pConfigInterleaving->put_Mode(INTERLEAVE_FULL));
    CHECK_ERROR(pBuilder->RenderStream(NULL, pAudioStream, NULL, pMuxFilter));

    *ppMMStream = pAMStream;
    pAMStream->AddRef();

Exit:
    if (pAMStream == NULL) {
    printf("Could not create a CLSID_MultiMediaStream object\n"
           "Check you have run regsvr32 amstream.dll\n");
    }
    RELEASE(pAMStream);
    RELEASE(pBuilder);
    RELEASE(pFilterGraph);
    RELEASE(pFileSinkWriter);
    RELEASE(pMuxFilter);
    RELEASE(pConfigInterleaving);
    RELEASE(pAudioStream);

    return hr;
}


//////////////////////////////////////////////////////////////////////
// RenderAudioStreamToStream
//
// This procedure reads from the source media stream (file) and writes the
// samples to the destination media stream (media streaming terminal - MST).
//
//////////////////////////////////////////////////////////////////////
HRESULT RenderAudioStreamToStream(IMediaStream *pMediaStreamSrc, IMediaStream *pMediaStreamDest)
{
    const DWORD DATA_SIZE = 4800;
    HRESULT hr;

    CStreamSampleQueue DestSampleQ;
    IStreamSample *pStreamSample = NULL; // this need not be released

    IStreamSample *pSampSrc = NULL;
    IStreamSample *pSampDest = NULL;
    IAudioData  *pAudioDataSrc = NULL;
    IAudioStreamSample *pAudioStreamSampleSrc = NULL;
    IMemoryData *pMemoryDataDest = NULL;

    ITAllocatorProperties *pAllocPropDest = NULL;

    HANDLE hDestEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (NULL == hDestEvent)    return E_FAIL;

    // when we allocate destination samples,
    // they will be of size DATA_SIZE
    CHECK_ERROR(pMediaStreamDest->QueryInterface(IID_ITAllocatorProperties, (void**)&pAllocPropDest));
    CHECK_ERROR(pAllocPropDest->SetBufferSize(DATA_SIZE));

    // Create a source sample - we only need one to read
    CHECK_ERROR(pMediaStreamSrc->AllocateSample(0, &pSampSrc));
    CHECK_ERROR(pSampSrc->QueryInterface(IID_IAudioStreamSample, (void**)&pAudioStreamSampleSrc));
    CHECK_ERROR(pAudioStreamSampleSrc->GetAudioData(&pAudioDataSrc));

    SetThreadPriority(
        GetCurrentThread(),
        THREAD_PRIORITY_TIME_CRITICAL
        );

    for (;;)
    {
        // Create a destination sample
        CHECK_ERROR(pMediaStreamDest->AllocateSample(0, &pSampDest));
        CHECK_ERROR(pSampDest->QueryInterface(IID_IMemoryData, (void**)&pMemoryDataDest));

        BYTE *pbDestData;
        CHECK_ERROR(pMemoryDataDest->GetInfo(NULL, &pbDestData, NULL));

        // point the source sample to the destination buffer
        CHECK_ERROR(pAudioDataSrc->SetBuffer(DATA_SIZE, pbDestData, 0));

        // Read the sample from the source stream synchronously
        hr = pSampSrc->Update(0, NULL, NULL, 0);
        if (hr != S_OK) { break; }

        DWORD   cbSrcActualData;
        CHECK_ERROR(pAudioDataSrc->GetInfo(NULL, NULL, &cbSrcActualData));
#if DBG
        char temp[255];
        wsprintf(temp, "%d bytes in buffer\n", cbSrcActualData);
        OutputDebugString(temp);
#endif

        if (0 == cbSrcActualData)  break;

        // set the size of data read on the destination sample
        CHECK_ERROR(pMemoryDataDest->SetActual(cbSrcActualData));

        // Write to the destination stream
        // we don't wait for the event to be signaled now
        // should have some check in between to reuse destination samples
        // as using one sample per update is costly
        hr = pSampDest->Update(0, hDestEvent, NULL, 0);
        if ((hr != S_OK) && (hr != MS_S_PENDING)) { break; }

        // release our references to the destination sample
        // except pSampDest
        RELEASE(pMemoryDataDest);

        // enqueue destination sample, so that we can wait on its
        // status later
        if (!DestSampleQ.Enqueue(pSampDest)) { break; }
    }

    // wait for each of the samples to complete
    // this ensures that we are done only when all the samples are done
    pStreamSample = DestSampleQ.Dequeue();
    while (NULL != pStreamSample)
    {
        // ignore any error values
        hr = pStreamSample->CompletionStatus(COMPSTAT_WAIT, INFINITE);
        pStreamSample->Release();

        pStreamSample = DestSampleQ.Dequeue();
    }

    // tell the stream that there is no more data
    pMediaStreamDest->SendEndOfStream(0);


Exit:

    RELEASE(pAudioDataSrc);
    RELEASE(pAudioStreamSampleSrc);
    RELEASE(pMemoryDataDest);
    RELEASE(pSampSrc);
    RELEASE(pSampDest);
    RELEASE(pAllocPropDest);
    CloseHandle(hDestEvent);

    return hr;
}


//////////////////////////////////////////////////////////////////////
// RenderStreamToAudioStream
//
// This procedure reads from the source media stream
// (media streaming terminal - MST) and writes the
// samples to the destination media stream (file).
//
//////////////////////////////////////////////////////////////////////
HRESULT
RenderStreamToAudioStream(
    IMediaStream *pMediaStreamSrc,
    IMediaStream *pMediaStreamDest
    )
{
    HRESULT         hr = E_FAIL;

    // only read the first MAX_SAMPLES samples
    const DWORD MAX_SAMPLES = 500;
    DWORD SamplesWritten = 0;

    DWORD           NumSamplesSrc = 0;
    HANDLE          *pEventsSrc = NULL;
    IStreamSample   **ppStreamSampleSrc = NULL;
    IMemoryData     **ppMemoryDataSrc = NULL;

    ITAllocatorProperties *pAllocPropsSrc = NULL;
    ALLOCATOR_PROPERTIES AllocProps;

    IStreamSample *pSampDest = NULL;
    IAudioData  *pAudioDataDest = NULL;
    IAudioStreamSample *pAudioStreamSampleDest = NULL;

    // Create a destination sample
    CHECK_ERROR(pMediaStreamDest->AllocateSample(0, &pSampDest));
    CHECK_ERROR(pSampDest->QueryInterface(IID_IAudioStreamSample, (void**)&pAudioStreamSampleDest));
    CHECK_ERROR(pAudioStreamSampleDest->GetAudioData(&pAudioDataDest));

    // get allocator properties
    hr = pMediaStreamSrc->QueryInterface(
        IID_ITAllocatorProperties, (void **)&pAllocPropsSrc
        );
    CHECK_ERROR(pAllocPropsSrc->GetAllocatorProperties(&AllocProps));
    NumSamplesSrc = AllocProps.cBuffers;

    // create event and source sample array
    pEventsSrc = new HANDLE[NumSamplesSrc];
    if (NULL == pEventsSrc) goto Exit;

    typedef IStreamSample *P_ISTREAM_SAMPLE;
    ppStreamSampleSrc = new P_ISTREAM_SAMPLE[NumSamplesSrc];
    if (NULL == ppStreamSampleSrc) goto Exit;

    typedef IMemoryData *P_IMEMORY_DATA;
    ppMemoryDataSrc = new P_IMEMORY_DATA[NumSamplesSrc];
    if (NULL == ppMemoryDataSrc) goto Exit;

    // create events for reading
    DWORD i;
    for (i=0; i < NumSamplesSrc; i++)
    {
        pEventsSrc[i] = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (NULL == pEventsSrc[i])  goto Exit;
    }

    // allocate src samples, put them in an array
    for (i=0; i < NumSamplesSrc; i++)
    {
        CHECK_ERROR(pMediaStreamSrc->AllocateSample(0, &ppStreamSampleSrc[i]));
        CHECK_ERROR(ppStreamSampleSrc[i]->QueryInterface(IID_IMemoryData, (void **)&ppMemoryDataSrc[i]));
    }

    // update samples
    for (i=0; i < NumSamplesSrc; i++)
    {
        CHECK_ERROR(ppStreamSampleSrc[i]->Update(0, pEventsSrc[i], NULL, 0));
    }

    // while an event is signaled,
    while(1)
    {
        DWORD WaitCode = WaitForMultipleObjects(
                            NumSamplesSrc, pEventsSrc, FALSE, INFINITE
                            );
        if ((WAIT_FAILED == WaitCode) || (WAIT_TIMEOUT == WaitCode))
            goto Exit;
        if ((WAIT_ABANDONED <= WaitCode) && (WaitCode < (WAIT_ABANDONED+NumSamplesSrc)))
            goto Exit;

        //  determine signaled sample,
        DWORD SampId =  WaitCode - WAIT_OBJECT_0;

        //  check sample status
        hr = ppStreamSampleSrc[SampId]->CompletionStatus(COMPSTAT_WAIT, 0);
        if (S_OK != hr) goto Exit;

        //  get buffer info
        DWORD   dwLength;
        BYTE    *pbData;
        DWORD   cbActualData;
        CHECK_ERROR(ppMemoryDataSrc[SampId]->GetInfo(&dwLength, &pbData, &cbActualData));

        //  point the file sample to completed buffer
        //  complete synchronous write (Update)
        CHECK_ERROR(pAudioDataDest->SetBuffer(dwLength, pbData, 0));
        CHECK_ERROR(pAudioDataDest->SetActual(cbActualData));
        hr = pSampDest->Update(0, NULL, NULL, 0);
        if (hr != S_OK) { break; }

        SamplesWritten++;
        // break out when the maximum number of samples have been read
        if (MAX_SAMPLES <= SamplesWritten)   break;

        //  update src sample for a read operation
        CHECK_ERROR(ppStreamSampleSrc[SampId]->Update(0, pEventsSrc[SampId], NULL, 0));
    }

Exit:

    // abort each sample, release IStreamSample i/fs and delete array
    if (NULL != ppStreamSampleSrc)
    {
        for(i=0; i < NumSamplesSrc; i++)
        {
            if (NULL == ppStreamSampleSrc[i])   break;
            ppStreamSampleSrc[i]->CompletionStatus(
                COMPSTAT_WAIT | COMPSTAT_ABORT, INFINITE
                );
            ppStreamSampleSrc[i]->Release();
        }

        delete ppStreamSampleSrc;
    }

    // release src IMemoryData i/fs
    if (NULL != ppMemoryDataSrc)
    {
        for(i=0; i < NumSamplesSrc; i++)
        {
            if (NULL == ppMemoryDataSrc[i])   break;
            ppMemoryDataSrc[i]->Release();
        }

        delete ppMemoryDataSrc;
    }

    // destroy events
    if (NULL != pEventsSrc)
    {
        for(i=0; i < NumSamplesSrc; i++)
        {
            if (NULL == pEventsSrc[i])   break;
            CloseHandle(pEventsSrc[i]);
        }

        delete pEventsSrc;
    }

    // release destination sample i/fs
    RELEASE(pAudioDataDest);
    RELEASE(pAudioStreamSampleDest);
    RELEASE(pSampDest);

    // release allocator properties i/f
    RELEASE(pAllocPropsSrc);

    return hr;
}


//////////////////////////////////////////////////////////////////////
// RenderFileToMMStream
//
// This procedure initializes the multimedia stream to read from a file.
//
//////////////////////////////////////////////////////////////////////
HRESULT RenderFileToMMStream(const WCHAR * pszFileName, IMultiMediaStream **ppMMStream)
{
    IAMMultiMediaStream *pAMStream;
    HRESULT hr = CoCreateInstance(CLSID_AMMultiMediaStream, NULL, CLSCTX_INPROC_SERVER,
                     IID_IAMMultiMediaStream, (void **)&pAMStream);
    if (FAILED(hr))
    {
        return hr;
    }

    pAMStream->Initialize(STREAMTYPE_READ, AMMSF_NOGRAPHTHREAD, NULL);
    pAMStream->AddMediaStream(NULL, &MSPID_PrimaryAudio, 0, NULL);
    pAMStream->OpenFile((WCHAR *)pszFileName, AMMSF_RUN);
    *ppMMStream = pAMStream;
    return S_OK;
}


//////////////////////////////////////////////////////////////////////
// RecordStreamToFile
//
// This procedure opens a file for writing audio samples (encapsulated
// within a multimedia stream). It initializes the writer audio stream
// with the Media Stream Terminal (MST) wave format.
//
//////////////////////////////////////////////////////////////////////
HRESULT RecordStreamToFile(IMediaStream *pMediaStreamTerm)
{
    HRESULT hr;
    IMultiMediaStream   *pWriteMMStream = NULL;
    IMediaStream        *pWriteAudioStream = NULL;
    AM_MEDIA_TYPE       *pAudioFormat = NULL;
    ITAMMediaFormat     *pITAMMediaFormat = NULL;

    // get the media stream terminal's format
    CHECK_ERROR(pMediaStreamTerm->QueryInterface(IID_ITAMMediaFormat, (void **)&pITAMMediaFormat));
    CHECK_ERROR(pITAMMediaFormat->get_MediaFormat(&pAudioFormat));

    CHECK_ERROR(CreateWriterStream(g_wszWriteFileName, (WAVEFORMATEX *)pAudioFormat->pbFormat, &pWriteMMStream));

    {
        MSPID PurposeId = MSPID_PrimaryAudio;
        CHECK_ERROR(pWriteMMStream->GetMediaStream(PurposeId, &pWriteAudioStream));
    }
    // run the stream
    CHECK_ERROR(pWriteMMStream->SetState(STREAMSTATE_RUN));

    // read samples form the terminal and write them to the file
    hr = RenderStreamToAudioStream(pMediaStreamTerm, pWriteAudioStream);

Exit:

    DeleteMediaType(pAudioFormat);
    RELEASE(pITAMMediaFormat);
    RELEASE(pWriteMMStream);
    RELEASE(pWriteAudioStream);

    return hr;
}


//////////////////////////////////////////////////////////////////////
// CStreamMessageWI::Init
//
// This procedure initializes the work item with the play and record
// terminals.
//
//////////////////////////////////////////////////////////////////////
BOOL CStreamMessageWI::Init(ITTerminal *pPlayStreamTerm, ITTerminal *pRecordStreamTerm)
{

    m_pPlayStreamTerm = NULL;
    m_pRecordStreamTerm = NULL;

    assert( ( (pPlayStreamTerm !=NULL) && (pRecordStreamTerm == NULL))
            || ( (pRecordStreamTerm != NULL) && (pPlayStreamTerm == NULL) ) );

    if ( (pPlayStreamTerm !=NULL) && (pRecordStreamTerm == NULL) )
    {

        m_pPlayStreamTerm = pPlayStreamTerm;
        m_pPlayStreamTerm->AddRef();
    }
    else if ( (pRecordStreamTerm != NULL) && (pPlayStreamTerm == NULL) )
    {
        m_pRecordStreamTerm = pRecordStreamTerm;
        m_pRecordStreamTerm->AddRef();
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////
// CStreamMessageWI::DoTask
//
// It plays out the greeting message and records the caller's message.
// It also updates the UI to indicate to the user when it has started
// and finished playing/recording.
//
//////////////////////////////////////////////////////////////////////
void CStreamMessageWI::DoTask()
{
    //
    // Update the UI
    //
    HRESULT hr;

    if (m_pPlayStreamTerm != NULL)
    {
        //
        // Update the UI
        //
        SetStatusMessage(TEXT("Playing Outgoing Message"));

        IMultiMediaStream *pMMStream;

        HRESULT hr = RenderFileToMMStream(g_wszReadFileName, &pMMStream);

        if (FAILED(hr))
        {
            SetStatusMessage(TEXT("failed to play outgoing message"));

            return;
        }

        IMediaStream *pMediaStreamFile;
        pMMStream->GetMediaStream(MSPID_PrimaryAudio, &pMediaStreamFile);

        // Not shown: we can also QI for IAudioMediaStream from pMediaStreamFile.

        IMediaStream *pPlayMediaStreamTerm;
        m_pPlayStreamTerm->QueryInterface(IID_IMediaStream, (void**)&pPlayMediaStreamTerm);

        hr = RenderAudioStreamToStream(pMediaStreamFile, pPlayMediaStreamTerm);

        pMediaStreamFile->Release();
        pPlayMediaStreamTerm->Release();
        pMMStream->Release();

        //
        // Update the UI, but be careful not to overwrite the "Waiting for a call..."
        // message if the call was disconnected and released in the meantime.
        //

        if ( gpCall != NULL )
        {
            SetStatusMessage(TEXT("Outbound Message Played"));
        }
    }
    else if (m_pRecordStreamTerm != NULL)
    {
        //
        // Update the UI
        //

        SetStatusMessage(TEXT("Recording Inbound Message"));

        IMediaStream *pRecordMediaStreamTerm;
        hr = m_pRecordStreamTerm->QueryInterface(
                IID_IMediaStream, (void**)&pRecordMediaStreamTerm);

        hr = RecordStreamToFile(pRecordMediaStreamTerm);
        pRecordMediaStreamTerm->Release();

        //
        // Update the UI, but be careful not to overwrite the "Waiting for a call..."
        // message if the call was disconnected and released in the meantime.
        //

        if ( gpCall != NULL )
        {
            SetStatusMessage(TEXT("Inbound Message Recorded"));

            //
            // We are finished recording, so drop the call. For
            // the playback case we don't do this, because playback
            // is asynchronous and we just drop the call when it's
            // complete (CME_STREAM_INACTIVE -- see callnot.cpp).
            //
            // Note that PostMessage also checks if gpCall == NULL
            // and does nothing in that case.
            //

            PostMessage(ghDlg, WM_COMMAND, IDC_DISCONNECT, 0);
        }
    }

}


//
// This thread is used to perform random tasks in a thread that requires a
//  message pump.
DWORD WINAPI
CWorkerThread::WorkerThreadProc(
    LPVOID pv
    )
{
    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (FAILED(hr))
    {
        SetStatusMessage(TEXT("worker thread failed to start "));

        return 1;
    }

    CWorkerThread *pThis = (CWorkerThread *)pv;

    while(true)
    {
        DWORD dwRet;
        MSG msg;

        dwRet = MsgWaitForMultipleObjects(1, &pThis->m_hSemStart,
                    FALSE, INFINITE, QS_ALLINPUT);

        // There is a window message available. Dispatch it.
        while(PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

        if (dwRet == WAIT_OBJECT_0)
        {
            if (pThis->m_fShutDown) { break; }

            pThis->m_pItem->DoTask();
            delete pThis->m_pItem; // Clean up async task
        }
    }

    CoUninitialize();

    //
    // Release the done semaphore to allow caller to continue.
    //
    ReleaseSemaphore(pThis->m_hSemDone , 1L, NULL);

    return 0;
}

//
// Schedule a synchronize work item in the background thread.
//
HRESULT
CWorkerThread::AsyncWorkItem(
    CWorkItem *pItem
    )
{
    //
    // Synchronize access to internal data.  Note that this lock is
    //  retained throughout the processing in the thread proc.  The
    //  semaphores provide syncronization between this procedure
    //  and the thread proc.
    //
    CAutoLock l(m_hCritSec);

    //
    // Check to see if our thread is active if not start it.
    //
    if (m_hThread == NULL)
    {
        m_hThread = CreateThread(NULL, 0, WorkerThreadProc, (LPVOID)this,
            0, &m_dwThreadID);
        if (m_hThread == NULL)
        {
            DWORD dwErr = ::GetLastError();
            return HRESULT_FROM_WIN32(dwErr);
        }
    }

    //
    // Set up the data members that will be used to execute work item.
    //
    m_pItem     = pItem;

    //
    // Start the task
    //
    ::ReleaseSemaphore(m_hSemStart, 1L, NULL);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\samples\ansmach\resource.h ===
/*

    Copyright (c) 1998-1999  Microsoft Corporation

*/

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Script1.rc
//
#define IDD_MAINDLG                     101
#define IDC_STATUS                      1000
#define IDC_ANSWER                      1001
#define IDC_DISCONNECTED                1002
#define IDC_CONNECTED                   1003
#define IDC_DISCONNECT                  1004
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1005
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\samples\ansmach\term.h ===
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Copyright (c) 1998-1999  Microsoft Corporation
//
// CWorkerThread & CWorkItem classes                                       //
//                                                                         //
// utilities for scheduling work in a separate thread                      //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class CWorkItem
{
public:
    virtual void DoTask() = 0;

    virtual ~CWorkItem(){}
};

class CWorkerThread
{
    //
    // Helper class
    //
    class CAutoLock
    {
    public:
        CAutoLock(CRITICAL_SECTION &hCritSec) : m_hCritSec(hCritSec)
            { ::EnterCriticalSection(&m_hCritSec); }
        ~CAutoLock()                            
            { ::LeaveCriticalSection(&m_hCritSec); }
        CRITICAL_SECTION &m_hCritSec;
    };

public:
    CWorkerThread() : m_fShutDown(false), m_hThread(NULL)
    {
        InitializeCriticalSection(&m_hCritSec);
        m_hSemStart = CreateSemaphore(NULL, 0, 1, NULL);
        m_hSemDone  = CreateSemaphore(NULL, 0, 1, NULL);
    }

    virtual ~CWorkerThread()
    {
        CAutoLock l(m_hCritSec);

        if (m_hThread != NULL)
        {
            //
            // Shut down the worker thread.  Using the control
            //  signaling mechanism.
            //
            m_fShutDown = true;
            ::ReleaseSemaphore(m_hSemStart, 1L, NULL);

            //
            // Now wait for the thread to terminate.
            //
            WaitForSingleObject(m_hThread, INFINITE);
        }
        CloseHandle(m_hSemDone);
        CloseHandle(m_hSemStart);
    }

    //
    // Operations
    //
    HRESULT AsyncWorkItem(CWorkItem *pItem);
private:
    //
    // Syncronization
    //
    CRITICAL_SECTION    m_hCritSec;
    HANDLE              m_hSemStart;
    HANDLE              m_hSemDone;

    //
    // Normal thread data
    //
    HANDLE              m_hThread;
    DWORD               m_dwThreadID;

    //
    // Control
    //
    bool                m_fShutDown;
    CWorkItem*          m_pItem;

    //
    // Thread Proceduce
    //
    static DWORD WINAPI WorkerThreadProc( LPVOID pv );
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Work items from above go here

// plays 
class CStreamMessageWI : public CWorkItem
{
public:
    CStreamMessageWI() 
        : m_pPlayStreamTerm(NULL),
          m_pRecordStreamTerm(NULL)
    {}

    BOOL Init(ITTerminal *pPlayStreamTerm, ITTerminal *pRecordStreamTerm);

    virtual void DoTask();

    virtual ~CStreamMessageWI();

protected:
    ITTerminal *m_pPlayStreamTerm;
    ITTerminal *m_pRecordStreamTerm;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\samples\ansmach\incoming.cpp ===
/*

    Copyright (c) 1998-1999  Microsoft Corporation

*/

#include <windows.h>
#include <tapi3.h>
#include <strmif.h>
#include <mmsystem.h>
#include <uuids.h>

#include "callnot.h"
#include "resource.h"

//////////////////////////////////////////////////////////
// ANSMACH.EXE
//
// Sample application that handles incoming TAPI calls
// and uses the media streaming terminal to preform the
// functions of a simple answering machine.
//
// This sample was adapted from the T3IN sample.
//
// In order to receive incoming calls, the application must
// implement and register the outgoing ITCallNotification
// interface.
//
// This application will register to receive calls on
// all addresses that support at least the audio media type.
//
// NOTES:
// 1. This application is limited to working with one
//    call at a time, and will not work correctly if
//    multiple calls are present at the same time.
// 2. Some voice boards may have problems with small sample sizes
//    (see SetAllocatorProperties below)
// 4. This works for half-duplex modems and voice boards with the
//    wave MSP, as well as IP telephony with the H.323 MSP.
//////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////
// constants
//////////////////////////////////////////////////////////

const DWORD MAXTERMINALS    = 5;

//////////////////////////////////////////////////////////
// GLOBALS
//////////////////////////////////////////////////////////

bool g_fPlay;
bool g_fRecord;


HINSTANCE               ghInst;
ITTAPI *                gpTapi;
ITBasicCallControl *    gpCall = NULL;
HWND                    ghDlg = NULL;
ITStream                *g_pRecordStream = NULL;
ITTerminal              *g_pPlayMedStrmTerm = NULL, *g_pRecordMedStrmTerm = NULL;

TCHAR gszTapi30[] = TEXT("TAPI 3.0 Answering Machine Sample");


CTAPIEventNotification      * gpTAPIEventNotification;
ULONG                         gulAdvise;

//////////////////////////////////////////////////////////
// PROTOTYPES
//////////////////////////////////////////////////////////
INT_PTR
CALLBACK
MainDialogProc(
               HWND hDlg,
               UINT uMsg,
               WPARAM wParam,
               LPARAM lParam
              );

HRESULT
GetTerminal(
            ITAddress *,
            BSTR bstrMedia,
            ITTerminal ** ppTerminal
           );
HRESULT
RegisterTapiEventInterface();

HRESULT
ListenOnAddresses();

HRESULT
ListenOnThisAddress(
                    ITAddress * pAddress
                   );

HRESULT
AnswerTheCall();

HRESULT
DisconnectTheCall();

void
ReleaseTheCall();

void
DoMessage(
          LPTSTR pszMessage
         );

void
SetStatusMessage(
                 LPTSTR pszMessage
                );

HRESULT
InitializeTapi();

void
ShutdownTapi();

//
// Telephone quality audio.
//
WAVEFORMATEX gwfx = {WAVE_FORMAT_PCM, 1,  8000, 16000, 2, 16, 0};

//////////////////////////////////////////////////////////
//
//              FUNCTIONS
//
//////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////
// WinMain
//////////////////////////////////////////////////////////
int
WINAPI
WinMain(
        HINSTANCE hInst,
        HINSTANCE hPrevInst,
        LPSTR lpCmdLine,
        int nCmdShow
       )
{
    if (__argc != 2)
    {
        MessageBox(NULL, "Usage: ansmach play|record|both", "ansmach", MB_OK);
        return 0;
    }

    switch(__argv[1][0])
    {
    case 'p':
    case 'P':
        g_fPlay   = true;
        g_fRecord = false;
        break;

    case 'r':
    case 'R':
        g_fPlay   = false;
        g_fRecord = true;
        break;

    case 'b':
    case 'B':
        g_fPlay   = true;
        g_fRecord = true;
        break;

    default:
        MessageBox(NULL, "Usage: ansmach play|record|both", "ansmach", MB_OK);
        return 0;
        break;
    }

    ghInst = hInst;

    // need to coinit
    if (!SUCCEEDED(CoInitializeEx(NULL, COINIT_MULTITHREADED)))
    {
        return 0;
    }

    // do all tapi initialization
    if (S_OK != InitializeTapi())
    {
        return 0;
    }

    // everything is initialized, so
    // start the main dialog box
    DialogBox(
              ghInst,
              MAKEINTRESOURCE(IDD_MAINDLG),
              NULL,
              MainDialogProc
             );

    //
    // When EndDialog is called, we get here; clean up and exit.
    //

    ShutdownTapi();

    CoUninitialize();

    return 1;
}


//////////////////////////////////////////////////////////////
// InitializeTapi
//
// Various initializations
///////////////////////////////////////////////////////////////
HRESULT
InitializeTapi()
{
    HRESULT         hr;

    // cocreate the TAPI object
    hr = CoCreateInstance(
                          CLSID_TAPI,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_ITTAPI,
                          (LPVOID *)&gpTapi
                         );

    if (hr != S_OK)
    {
        DoMessage(TEXT("CoCreateInstance on TAPI failed"));
        return hr;
    }

    // call initialize.  this must be called before
    // any other tapi functions are called.
    hr = gpTapi->Initialize();

    if (S_OK != hr)
    {
        DoMessage(TEXT("TAPI failed to initialize"));

        gpTapi->Release();
        gpTapi = NULL;

        return hr;
    }

    gpTAPIEventNotification = new CTAPIEventNotification;

    hr = RegisterTapiEventInterface();

    // Set the Event filter to only give us only the events we process
    gpTapi->put_EventFilter(TE_CALLNOTIFICATION | TE_CALLSTATE | TE_CALLMEDIA);

    // find all address objects that
    // we will use to listen for calls on
    hr = ListenOnAddresses();

    if (S_OK != hr)
    {
        DoMessage(TEXT("Could not find any addresses to listen on"));

        gpTapi->Release();
        gpTapi = NULL;

        return hr;
    }

    return S_OK;

}


///////////////////////////////////////////////////////////////
// ShutdownTapi
///////////////////////////////////////////////////////////////
void
ShutdownTapi()
{
    //
    // if there is still a call, disconnect and release it
    //

    DisconnectTheCall();

    ReleaseTheCall();

    //
    // Sleep for a little while to give tapi a chance to finish
    // disconnecting the call. Note that our dialog box has
    // disappeared by now so the user has no idea that our process
    // is still around. This step would not be necessary if the
    // call were disconnected interactively as a separate operation
    // from shutting down TAPI. The argument to Sleep is in
    // milliseconds.
    //

    Sleep(5000);

    //
    // release main object.
    //

    if (NULL != gpTapi)
    {
        gpTapi->Shutdown();
        gpTapi->Release();
    }
}


///////////////////////////////////////////////////////////////////////////
// MainDlgProc
///////////////////////////////////////////////////////////////////////////
INT_PTR
CALLBACK
MainDialogProc(
               HWND hDlg,
               UINT uMsg,
               WPARAM wParam,
               LPARAM lParam
              )
{
    switch (uMsg)
    {
        case WM_PRIVATETAPIEVENT:
        {
            OnTapiEvent(
                        (TAPI_EVENT) wParam,
                        (IDispatch *) lParam
                       );

            return 0;
        }

        case WM_INITDIALOG:
        {
            // set up dialog
            ghDlg = hDlg;

            SetStatusMessage( TEXT("Waiting for a call..."));

            return 0;
        }

        case WM_COMMAND:
        {
            if ( LOWORD(wParam) == IDCANCEL )
            {
                //
                // quit
                //

                EndDialog( hDlg, 0 );

                return 1;
            }

            switch ( LOWORD(wParam) )
            {
                // dial request
                case IDC_ANSWER:
                {
                    SetStatusMessage(TEXT("Answering..."));
                    // answer the call
                    if ( S_OK == AnswerTheCall() )
                    {
                        SetStatusMessage(TEXT("Connected"));
                    }
                    else
                    {
                        DoMessage(TEXT("Answer failed"));
                        SetStatusMessage(TEXT("Waiting for a call..."));
                    }

                    return 1;
                }

                // disconnect request
                case IDC_DISCONNECT:
                {
                    // If the remote party disconnected first, then the call was
                    // already disconnected and released, so do not disconnect
                    // it again.

                    if ( gpCall != NULL )
                    {
                        SetStatusMessage(TEXT("Disconnecting..."));

                        // disconnect the call
                        if (S_OK != DisconnectTheCall())
                        {
                            DoMessage(TEXT("Disconnect failed"));
                        }
                    }

                    return 1;
                }

                // connect notification
                case IDC_CONNECTED:
                {
                    SetStatusMessage(TEXT("Connected; waiting for media streams to run..."));

                    return 1;
                }

                // disconnected notification
                case IDC_DISCONNECTED:
                {
                    // release
                    ReleaseTheCall();

                    SetStatusMessage(TEXT("Waiting for a call..."));

                    return 1;
                }
                default:

                    return 0;
            }
        }
        default:

            return 0;
    }
}


HRESULT
RegisterTapiEventInterface()
{
    HRESULT                       hr = S_OK;
    IConnectionPointContainer   * pCPC;
    IConnectionPoint            * pCP;


    hr = gpTapi->QueryInterface(
                                IID_IConnectionPointContainer,
                                (void **)&pCPC
                               );

    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    hr = pCPC->FindConnectionPoint(
                                   IID_ITTAPIEventNotification,
                                   &pCP
                                  );
    pCPC->Release();

    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    hr = pCP->Advise(
                      gpTAPIEventNotification,
                      &gulAdvise
                     );

    pCP->Release();


    return hr;

}


////////////////////////////////////////////////////////////////////////
// ListenOnAddresses
//
// This procedure will find all addresses that support audioin and audioout
// and will call ListenOnThisAddress to start listening on it.
////////////////////////////////////////////////////////////////////////

HRESULT
ListenOnAddresses()
{
    HRESULT             hr = S_OK;
    IEnumAddress *      pEnumAddress;
    ITAddress *         pAddress;
    ITMediaSupport *    pMediaSupport;
    VARIANT_BOOL        bSupport;

    // enumerate the addresses
    hr = gpTapi->EnumerateAddresses( &pEnumAddress );

    if (S_OK != hr)
    {
        return hr;
    }

    while ( TRUE )
    {
        // get the next address
        hr = pEnumAddress->Next( 1, &pAddress, NULL );

        if (S_OK != hr)
        {
            break;
        }

        pAddress->QueryInterface( IID_ITMediaSupport, (void **)&pMediaSupport );

        // does it support Audio
        pMediaSupport->QueryMediaType(
                                      TAPIMEDIATYPE_AUDIO,
                                      &bSupport
                                     );

        if (bSupport)
        {
            // If it does then we'll listen.
            hr = ListenOnThisAddress( pAddress );
            if (S_OK != hr)
            {
                DoMessage(TEXT("Listen failed on an address"));
            }
        }

        pMediaSupport->Release();
        pAddress->Release();
    }

    pEnumAddress->Release();

    return S_OK;
}


///////////////////////////////////////////////////////////////////
// ListenOnThisAddress
//
// We call RegisterCallNotifications to inform TAPI that we want
// notifications of calls on this address. We already resistered
// our notification interface with TAPI, so now we are just telling
// TAPI that we want calls from this address to trigger events on
// our existing notification interface.
//
///////////////////////////////////////////////////////////////////

HRESULT
ListenOnThisAddress(
                    ITAddress * pAddress
                   )
{

    //
    // RegisterCallNotifications takes a media type bitmap indicating
    // the set of media types we are interested in. We know the
    // address supports audio.
    //

    long lMediaTypes = TAPIMEDIATYPE_AUDIO;

    HRESULT  hr;
    long     lRegister;

    hr = gpTapi->RegisterCallNotifications(
                                           pAddress,
                                           VARIANT_TRUE,
                                           VARIANT_TRUE,
                                           lMediaTypes,
                                           0,
                                           &lRegister
                                          );

    return hr;
}


/////////////////////////////////////////////////////////
// GetMediaStreamTerminal
//
// Create a media streaming terminal for the given
// direction.
//
/////////////////////////////////////////////////////////

HRESULT
GetMediaStreamTerminal(
                 ITAddress * pAddress,
                 TERMINAL_DIRECTION dir,
                 ITTerminal ** ppTerminal
                )
{
    HRESULT             hr = S_OK;
    ITTerminalSupport * pTerminalSupport;
    BSTR                bstrTerminalClass;
    LPOLESTR            lpTerminalClass;
    AM_MEDIA_TYPE       mt;

    // get the terminal support interface
    pAddress->QueryInterface( IID_ITTerminalSupport, (void **)&pTerminalSupport );

    StringFromIID(
                  CLSID_MediaStreamTerminal,
                  &lpTerminalClass
                 );
    bstrTerminalClass = SysAllocString ( lpTerminalClass );
    CoTaskMemFree( lpTerminalClass );

    hr = pTerminalSupport->CreateTerminal(
                                          bstrTerminalClass,
                                          TAPIMEDIATYPE_AUDIO,
                                          dir,
                                          ppTerminal
                                         );

    SysFreeString( bstrTerminalClass );
    pTerminalSupport->Release();

    if (FAILED(hr)) { return hr; }

    if (TD_CAPTURE == dir)
    {
        //
        // Now set the media format for the terminal.
        //
        // On addresses where a variety of formats are supported (such as
        // Wave MSP addresses, which are used on most modems and voice boards),
        // this call is mandatory or the terminal will not be able to connect.
        //
        // For other addresses, such as those implemented over IP, the format
        // may be fixed / predetermined. In that case, this call will fail
        // if the format is not the same as the predetermined format. To
        // retrieve such a predetermined format, an application can use
        // ITAMMediaFormat::get_MediaFormat.
        //
        // For the purposes of this example, we just set our preferred format
        // and ignore any failure code. This is fine for both Wave MSP
        // addresses and for addresses implemented over IP (which happens to
        // use the same format the one we are setting here).
        //

        ITAMMediaFormat *pITFormat;
        hr = (*ppTerminal)->QueryInterface(IID_ITAMMediaFormat, (void **)&pITFormat);
        if (FAILED(hr)) { (*ppTerminal)->Release(); *ppTerminal = NULL; return hr; }

        mt.majortype            = MEDIATYPE_Audio;
        mt.subtype              = MEDIASUBTYPE_PCM;
        mt.bFixedSizeSamples    = TRUE;
        mt.bTemporalCompression = FALSE;
        mt.lSampleSize          = 0;
        mt.formattype           = FORMAT_WaveFormatEx;
        mt.pUnk                 = NULL;
        mt.cbFormat             = sizeof(WAVEFORMATEX);
        mt.pbFormat             = (BYTE*)&gwfx;

        pITFormat->put_MediaFormat(&mt);
        pITFormat->Release();


        //
        // optional - set the buffer size of fragments negotiated with rest of the graph
        // this is only needed for applications that are not happy with the default fragment size
        // (which depends on the MSP -- for the Wave MSP (used on most modems and voice boards)
        // the default is 20 ms.
        //

        ITAllocatorProperties *pITAllocatorProperties;
        hr = (*ppTerminal)->QueryInterface(IID_ITAllocatorProperties, (void **)&pITAllocatorProperties);
        if (FAILED(hr)) { (*ppTerminal)->Release(); *ppTerminal = NULL; return hr; }

        // Call to SetAllocatorProperties below illustrates how
        // an app can control the number and size of buffers.
        // A 30 ms sample size is most appropriate for IP (especailly G.723.1)
        // (that's 480 bytes at 16-bit 8 KHz PCM); in fact you may get very
        // poor audio quality with other settings.
        // However, 30ms can cause poor audio quality on some voice boards --
        // voice boards generally work best with large buffers.
        // If this method is not called, the allocator properties
        // suggested by the connecting filter may be used.

        ALLOCATOR_PROPERTIES AllocProps;
        AllocProps.cbBuffer   = 480;
        AllocProps.cBuffers   = 5;
        AllocProps.cbAlign    = 1;
        AllocProps.cbPrefix   = 0;

        hr = pITAllocatorProperties->SetAllocatorProperties(&AllocProps);
        hr = pITAllocatorProperties->SetAllocateBuffers(TRUE);

        BOOL bAllocateBuffer;
        hr = pITAllocatorProperties->GetAllocateBuffers(&bAllocateBuffer);

        pITAllocatorProperties->Release();
    }

    return hr;

}



/////////////////////////////////////////////////////////////////
// ReleaseTerminals
//
/////////////////////////////////////////////////////////////////

void
ReleaseTerminals(
                      ITTerminal ** ppTerminals,
                      LONG nNumTerminals
                     )
{
    for (long i = 0; i < nNumTerminals; i ++)
    {
        if (ppTerminals[i])
        {
            ppTerminals[i]->Release();
        }
    }
}

/////////////////////////////////////////////////////////////////////
// Answer the call
/////////////////////////////////////////////////////////////////////

HRESULT
AnswerTheCall()
{
    HRESULT                 hr;
    ITCallInfo *            pCallInfo;
    ITAddress *             pAddress;


    g_pRecordStream = NULL;
    g_pPlayMedStrmTerm = NULL;
    g_pRecordMedStrmTerm = NULL;

    if (NULL == gpCall)
    {
        return E_UNEXPECTED;
    }

    // get the address object of this call
    gpCall->QueryInterface( IID_ITCallInfo, (void**)&pCallInfo );
    pCallInfo->get_Address( &pAddress );
    pCallInfo->Release();

    ITStreamControl * pStreamControl;

    // get the ITStreamControl interface for this call
    hr = gpCall->QueryInterface(IID_ITStreamControl,
                                (void **) &pStreamControl);

    // enumerate the streams

    IEnumStream * pEnumStreams;
    hr = pStreamControl->EnumerateStreams(&pEnumStreams);
    pStreamControl->Release();

    if (FAILED(hr))
    {
        pAddress->Release();
        gpCall->Release();
        gpCall = NULL;
        return hr;
    }

    // for each stream
    ITStream * pStream;


    // Since we are interested in the audio capture and render streams only,
    // the while loop terminates when either all the streams are done or
    // when terminals for both the streams i.e. render and capture are created
    // We will also make sure that even though terminals are created on the
    // streams only one terminal will be selected to support half duplex lines
    while ( ( S_OK == pEnumStreams->Next(1, &pStream, NULL) )  &&
        ( (g_pPlayMedStrmTerm == NULL) || (g_pRecordMedStrmTerm==NULL) ) )
    {
        TERMINAL_DIRECTION td;
        hr = pStream->get_Direction(&td);

        if ( SUCCEEDED(hr) )
        {
            //
            // create the media terminals for this call
            //

            //  Only one capture terminal will be created even if they are multiple capture streams
            //
            if ( (td == TD_CAPTURE) && g_fPlay && (g_pPlayMedStrmTerm == NULL))
            {
                GetMediaStreamTerminal(
                    pAddress,
                    TD_CAPTURE,
                    &g_pPlayMedStrmTerm
                    );

                // the created terminal is selected on the stream if the user
                // wishes to play or play and record. The play terminal has to be
                // selected in any case before the record since the message will always
                // be played before the record

                hr = pStream->SelectTerminal(g_pPlayMedStrmTerm);

                if ( FAILED (hr) )
                {
                    ::MessageBox(NULL,"Select Terminal for Play Failed", "Answer the call", MB_OK);
                    return hr;
                }
            }

            // Create terminal for Render stream
            // Note that we only create the terminal.. we do not select it on the stream
            if ( (td == TD_RENDER) && g_fRecord && (g_pRecordMedStrmTerm == NULL))
            {
                GetMediaStreamTerminal(
                    pAddress,
                    TD_RENDER,
                    &g_pRecordMedStrmTerm
                    );
                g_pRecordStream = pStream;
                g_pRecordStream->AddRef();
            }
        }
        pStream->Release();
    }


    // the record terminal is selected on the stream only if the play terminal is not already
    // selected. This will happen only in the case when the user selects only record and no play
    // Only one terminal is selected at a time inorder to support half-duplex lines
    if (!g_fPlay)
    {
        hr = g_pRecordStream->SelectTerminal(g_pRecordMedStrmTerm);

        if ( FAILED (hr) )
        {
            ::MessageBox(NULL,"Select Terminal for Record Failed", "Answer the call", MB_OK);
            return hr;
        }

        g_pRecordMedStrmTerm->Release();
        g_pRecordStream->Release();
    }


    pEnumStreams->Release();

    // release the address
    pAddress->Release();

    // answer the call
    hr = gpCall->Answer();

    if (S_OK != hr)
    {
        gpCall->Release();
        gpCall = NULL;
        return hr;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// DisconnectTheCall
//
// Disconnects the call
//////////////////////////////////////////////////////////////////////

HRESULT
DisconnectTheCall()
{
    HRESULT         hr = S_OK;

    if (NULL != gpCall)
    {
        hr = gpCall->Disconnect( DC_NORMAL );

        // Do not release the call yet, as that would prevent
        // us from receiving the disconnected notification.

        return hr;
    }

    return S_FALSE;
}

//////////////////////////////////////////////////////////////////////
// ReleaseTheCall
//
// Releases the call
//////////////////////////////////////////////////////////////////////

void
ReleaseTheCall()
{
    if (NULL != gpCall)
    {
        gpCall->Release();
        gpCall = NULL;
    }
}


///////////////////////////////////////////////////////////////////
//
// HELPER FUNCTIONS
//
///////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////
// DoMessage
///////////////////////////////////////////////////////////////////

void
DoMessage(
          LPTSTR pszMessage
         )
{
    MessageBox(
               ghDlg,
               pszMessage,
               gszTapi30,
               MB_OK
              );
}


//////////////////////////////////////////////////////////////////
// SetStatusMessage
//////////////////////////////////////////////////////////////////

void
SetStatusMessage(
                 LPTSTR pszMessage
                )
{
    SetDlgItemText(
                   ghDlg,
                   IDC_STATUS,
                   pszMessage
                  );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\samples\incoming\callnot.h ===
/*++

Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.

Module Name:
    callnot.h

Abstract:
    
    Declaration of the CTAPIEventNotification object

--*/

#ifndef __TAPIEventNotification_H__
#define __TAPIEventNotification_H__

#define WM_PRIVATETAPIEVENT   WM_USER+101

HRESULT
OnTapiEvent(
            TAPI_EVENT TapiEvent,
            IDispatch * pEvent
           );

/////////////////////////////////////////////////////////////////////////////
// CTAPIEventNotification
class CTAPIEventNotification : public ITTAPIEventNotification
{
private:

    LONG       m_dwRefCount;

public:

    // CTAPIEventNotification implements ITTAPIEventNotification
    //  Declare ITTAPIEventNotification methods here
    HRESULT STDMETHODCALLTYPE Event(
                                    TAPI_EVENT TapiEvent,
                                    IDispatch * pEvent
                                   );
    
// other COM stuff:
public:

    //
    // constructor
    //

    CTAPIEventNotification()
    {
        m_dwRefCount = 1;
    }


    //
    // destructor
    //

    ~CTAPIEventNotification()
    {
    }

    // IUnknown implementation
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void **ppvObject)
    {
        if (iid == IID_ITTAPIEventNotification)
        {
            AddRef();
            *ppvObject = (void *)this;
            return S_OK;
        }

        if (iid == IID_IUnknown)
        {
            AddRef();
            *ppvObject = (void *)this;
            return S_OK;
        }

        return E_NOINTERFACE;
    }

    //
    // reference counting needs to be thread safe
    //
    
    ULONG STDMETHODCALLTYPE AddRef()
    {
        ULONG l = InterlockedIncrement(&m_dwRefCount);
        return l;
    }
    
	ULONG STDMETHODCALLTYPE Release()
    {
        ULONG l = InterlockedDecrement(&m_dwRefCount);

        if ( 0 == l)
        {
            delete this;
        }
        
        return l;
    }


};

#endif //__TAPIEventNotification_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\samples\incoming\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Script1.rc
//
#define IDD_MAINDLG                     101
#define IDC_STATUS                      1000
#define IDC_ANSWER                      1001
#define IDC_DISCONNECT                  1002
#define IDC_DISCONNECTED                1003
#define IDC_AUTOANSWER                  1004
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\samples\mstsample\tapirecv\avifilewriter.cpp ===
/*

Copyright (c) 1999  Microsoft Corporation

Module Name:

    AVIFileWriter.cpp

Abstract:

    Implementation of CAVIFileWriter class
 
*/


#include "common.h"
#include "AVIFileWriter.h"


///////////////////////////////////////////////////////////////////////////////
//
// CAVIFileWriter::CAVIFileWriter
//
///////////////////////////////////////////////////////////////////////////////

CAVIFileWriter::CAVIFileWriter()
    :m_pAVIFile(NULL),
    m_pAudioStream(NULL),
    m_nSampleSize(0)
{

    LogMessage("CAVIFileWriter::CAVIFileWriter");

}


///////////////////////////////////////////////////////////////////////////////
//
// CAVIFileWriter::Initialize
//
// initialize avi library. attempt to create a file with the given name and 
// format.
//
// if file creation fails, subsequent calls to write will fail.
//
///////////////////////////////////////////////////////////////////////////////

HRESULT CAVIFileWriter::Initialize(IN const CHAR *pszFileName, 
                                   IN const WAVEFORMATEX &WaveFormat)
{

    HRESULT hr = S_OK;

    
    //
    // if initialization fails, the object's stream and file will be NULL, so 
    // subsequent Write() calls will fail
    //


    //
    // would do a better argument checking in a real-life application
    //

    _ASSERTE(pszFileName);


    //
    // log file name and requested wave format
    //


    LogMessage("CAVIFileWriter::Initialize started.");

    LogMessage("    file [%s] ", pszFileName);
    
    LogFormat(&WaveFormat);
 

    //
    // initialize avi file library.
    // when done with it, call AVIFileExit should be called on the same thread
    //
    
    AVIFileInit();

        
    //
    // create file
    //

    hr = AVIFileOpen(&m_pAVIFile,
                     pszFileName,
                     OF_WRITE | OF_CREATE | OF_SHARE_DENY_WRITE,
                     NULL);

    if (FAILED(hr))
    {
        LogError("CAVIFileWriter::Initialize Failed to create file %s",
                 pszFileName);

        m_pAVIFile = NULL;

        return hr;
    }


    //
    // fill in stream information
    //

    AVISTREAMINFO StreamInfo;

    memset(&StreamInfo, 0, sizeof(StreamInfo));

    StreamInfo.fccType = streamtypeAUDIO;
    StreamInfo.dwQuality = -1;
    m_nSampleSize = StreamInfo.dwSampleSize = WaveFormat.nBlockAlign;
    strcpy(&StreamInfo.szName[0], "test audio stream");


    //
    // add an audio stream to the file
    //

    hr = AVIFileCreateStream(m_pAVIFile, &m_pAudioStream, &StreamInfo);

    if (FAILED(hr))
    {
        LogError("CAVIFileWriter::CAVIFileWriter "
                 "failed to create audio stream");

        AVIFileRelease(m_pAVIFile);
        m_pAVIFile = NULL;

        return hr;
    }


    //
    // set format for the stream
    //

    hr = AVIStreamSetFormat(m_pAudioStream,
                            0,
                            (void*)&WaveFormat,
                            sizeof(WaveFormat) + WaveFormat.cbSize);

    if ( FAILED(hr))
    {
        LogError("Failed to set stream format");

        AVIFileRelease(m_pAVIFile);
        m_pAVIFile = NULL;

        AVIStreamRelease(m_pAudioStream);
        m_pAudioStream = NULL;

        return hr;
    }

    LogMessage("CAVIFileWriter::Initialize succeeded");

    return S_OK;

}


///////////////////////////////////////////////////////////////////////////////
//
// CAVIFileWriter::~CAVIFileWriter
//
// if the file and stream were open, close them.
//
// uninitialize AVI library
//
///////////////////////////////////////////////////////////////////////////////

CAVIFileWriter::~CAVIFileWriter()
{

    LogMessage("CAVIFileWriter::~CAVIFileWriter started");


    if (NULL != m_pAudioStream)
    {
        AVIStreamRelease(m_pAudioStream);
        m_pAudioStream = NULL;
    }


    if (NULL != m_pAVIFile)
    {
        AVIFileRelease(m_pAVIFile);
        m_pAVIFile = NULL;
    }

    
    //
    // uninitialize avi file libraries
    //

    AVIFileExit();

    LogMessage("CAVIFileWriter::~CAVIFileWriter finished");

}


///////////////////////////////////////////////////////////////////////////////
//
// CAVIFileWriter::Write
// 
// write the buffer into the open stream. return the number of bytes recorded.
//
// return S_OK on success, error code on failure
//
///////////////////////////////////////////////////////////////////////////////

HRESULT CAVIFileWriter::Write(IN BYTE *pBuffer,
                              IN ULONG nBytesToWrite,
                              IN OUT ULONG *pnBytesWritten)
{

    if ( (NULL == m_pAudioStream) || (NULL == m_pAVIFile))
    {
        LogError("CAVIFileWriter::Write file or stream is not open");
       
        return E_UNEXPECTED;
    }


    //
    // AVIStreamWrite wants the number of samples we are recording
    //

    LONG nSamples2Write = nBytesToWrite / m_nSampleSize;


    //
    // write to file until dumped the whole buffer of until failure
    //
    
    HRESULT hr = S_OK;

    ULONG nTotalBytesWritten = 0;


    while ((hr == S_OK) && (nTotalBytesWritten < nBytesToWrite))
    {

        //
        // bytes and samples written with the call
        //

        LONG nBytesWritten = 0;

        LONG nSamplesWritten = 0;

        hr = AVIStreamWrite(m_pAudioStream,
                            -1,              // append at the end of the stream
                            nSamples2Write,  // how many samples to write
                            pBuffer,         // where the data is
                            nBytesToWrite,   // how much data do we have
                            AVIIF_KEYFRAME,  // self-sufficient data 
                            &nSamplesWritten,// how many samples were written
                            &nBytesWritten); // how many bytes were written


        //
        // keep track of how many bytes made it into the file
        //

        nTotalBytesWritten += nBytesWritten;
        
    }


    //
    // will return the number of bytes written
    //

    if (NULL != pnBytesWritten) 
    {
        *pnBytesWritten = nTotalBytesWritten;
    }


    //
    // either dumped the whole buffer or failed.
    //

    if (FAILED(hr))
    {

        LogError("CAVIFileWriter::Write Failed to write buffer hr = 0x%lx, "
                 "wrote %ld bytes", hr, nTotalBytesWritten);
    }
    else
    {

        LogMessage("CAVIFileWriter::Write Succeeded. Wrote %ld bytes",
                    nTotalBytesWritten);
    }

    return hr;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\samples\mstsample\tapirecv\avifilewriter.h ===
/*

Copyright (c) 1999  Microsoft Corporation

Module Name:

    AVIFileWriter.h

Abstract:

    Declaration for the AVIFileWriter class. 

*/

#if !defined(AFX_AVIFILEWRITER_H__75ED6641_F059_4EC1_AAB2_867109AA7695__INCLUDED_)
#define AFX_AVIFILEWRITER_H__75ED6641_F059_4EC1_AAB2_867109AA7695__INCLUDED_


//
// an abstraction for a media file open for reading
//

class CAVIFileWriter  
{

public:


    //
    // initialization (including opening file)
    //
    
    HRESULT Initialize(IN const CHAR *psFileName, 
                       IN const WAVEFORMATEX &WaveFormat);


    //
    // zero data members
    //
    
    CAVIFileWriter();


    //
    // close file
    //

	virtual ~CAVIFileWriter();


    //
    // write data
    //

    HRESULT Write(IN BYTE *pBuffer,
                  IN ULONG nBytesToWrite,
                  IN OUT ULONG *pnBytesWritten);

private:

    //
    // file handle
    //

    PAVIFILE m_pAVIFile;

    
    //
    // audio stream
    //
    
    PAVISTREAM  m_pAudioStream;

    
    //
    // size of one sample
    //
    
    LONG m_nSampleSize;


};

#endif // !defined(AFX_AVIFILEWRITER_H__75ED6641_F059_4EC1_AAB2_867109AA7695__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\samples\incoming\incoming.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.

--*/

#define UNICODE
#include <list>
#include <windows.h>
#include <tapi3.h>
#include <control.h>
#include "callnot.h"
#include "resource.h"

//////////////////////////////////////////////////////////
// T3IN.EXE
//
// Sample application that handles incoming TAPI calls.
// In order to receive incoming calls, the application must
// implement and register the outgoing ITCallNotification
// interface.
//
// This application will register to receive calls on
// all addresses that support at least the audio media type.
//
// NOTE:  This application is limited to working with one
// call at at time, and will not work correctly if multiple
// calls are present at the same time.
//////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////
// constants
//////////////////////////////////////////////////////////

const DWORD MAXTERMINALS    = 5;

//////////////////////////////////////////////////////////
// GLOBALS
//////////////////////////////////////////////////////////

HINSTANCE               ghInst;
ITTAPI *                gpTapi;
ITBasicCallControl *    gpCall;
HWND                    ghDlg = NULL;

BOOL                    gfAutoAnswer = FALSE;

WCHAR gszTapi30[] = L"TAPI 3.0 Incoming Call Sample";


ULONG                         gulAdvise;

//////////////////////////////////////////////////////////
// PROTOTYPES
//////////////////////////////////////////////////////////

INT_PTR
CALLBACK
MainDialogProc(
               HWND hDlg,
               UINT uMsg,
               WPARAM wParam,
               LPARAM lParam
              );

HRESULT
RegisterTapiEventInterface(CTAPIEventNotification *pTAPIEventNotification);

HRESULT
ListenOnAddresses();

HRESULT
ListenOnThisAddress(
                    ITAddress * pAddress
                   );

HRESULT
AnswerTheCall();

HRESULT
DisconnectTheCall();

void
ReleaseTheCall();

void
DoMessage(
          LPWSTR pszMessage
         );

void
SetStatusMessage(
                 LPWSTR pszMessage
                );

HRESULT
InitializeTapi();

void
ShutdownTapi();

void
EnableButton(
             int ID
            );
void
DisableButton(
              int ID
             );

BOOL
AddressSupportsMediaType(
                         ITAddress * pAddress,
                         long        lMediaType
                        );

//////////////////////////////////////////////////////////
//
//              FUNCTIONS
//
//////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////
// WinMain
//////////////////////////////////////////////////////////
int
WINAPI
WinMain(
        HINSTANCE hInst,
        HINSTANCE hPrevInst,
        LPSTR lpCmdLine,
        int nCmdShow
       )
{
    ghInst = hInst;

    //
    // Initialize COM.
    //

    if (!SUCCEEDED(CoInitializeEx(NULL, COINIT_MULTITHREADED)))
    {
        return 0;
    }

    //
    // do all tapi initialization
    //

    if (S_OK != InitializeTapi())
    {
        return 0;
    }

    //
    // everything is initialized, so
    // start the main dialog box
    //

    DialogBox(
              ghInst,
              MAKEINTRESOURCE(IDD_MAINDLG),
              NULL,
              MainDialogProc
             );


    //
    // clean up tapi
    //

    ShutdownTapi();

    //
    // Shut down COM.
    //

    CoUninitialize();

    return 1;
}


//////////////////////////////////////////////////////////////
// InitializeTapi
//
// Various tapi initializations
///////////////////////////////////////////////////////////////

HRESULT
InitializeTapi()
{
    HRESULT         hr;

    //
    // cocreate the TAPI object
    //

    hr = CoCreateInstance(
                          CLSID_TAPI,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_ITTAPI,
                          (LPVOID *)&gpTapi
                         );

    if ( FAILED(hr) )
    {
        DoMessage(L"CoCreateInstance on TAPI failed");
        return hr;
    }

    //
    // call initialize.  this must be called before
    // any other tapi functions are called.
    //

    hr = gpTapi->Initialize();

    if ( FAILED(hr) )
    {
        DoMessage(L"TAPI failed to initialize");

        gpTapi->Release();
        gpTapi = NULL;

        return hr;
    }

    //
    // Create our own event notification object and register it
    // see callnot.h and callnot.cpp
    //

    CTAPIEventNotification *pTAPIEventNotification = new CTAPIEventNotification;

    hr = RegisterTapiEventInterface(pTAPIEventNotification);


    //
    // no longer need a reference to the callback object. tapi will keep a 
    // reference to it for as long as it is using it.
    //

    pTAPIEventNotification->Release();



    // Set the Event filter to only give us only the events we process
    gpTapi->put_EventFilter(TE_CALLNOTIFICATION | TE_CALLSTATE | TE_CALLMEDIA);


    //
    // find all address objects that
    // we will use to listen for calls on
    //

    hr = ListenOnAddresses();

    if ( FAILED(hr) )
    {
        DoMessage(L"Could not find any addresses to listen on");

        gpTapi->Release();
        gpTapi = NULL;

        return hr;
    }

    return S_OK;
}


///////////////////////////////////////////////////////////////
// ShutdownTapi
///////////////////////////////////////////////////////////////

void
ShutdownTapi()
{
    //
    // if there is still a call, release it
    //

    if (NULL != gpCall)
    {
        gpCall->Release();
        gpCall = NULL;
    }

    //
    // release main object.
    //

    if (NULL != gpTapi)
    {
        gpTapi->Shutdown();
        gpTapi->Release();
    }

}


///////////////////////////////////////////////////////////////////////////
// MainDlgProc
///////////////////////////////////////////////////////////////////////////

INT_PTR
CALLBACK
MainDialogProc(
               HWND hDlg,
               UINT uMsg,
               WPARAM wParam,
               LPARAM lParam
              )
{
    switch (uMsg)
    {
        case WM_PRIVATETAPIEVENT:
        {
            OnTapiEvent(
                        (TAPI_EVENT) wParam,
                        (IDispatch *) lParam
                       );

            return 0;
        }

        case WM_INITDIALOG:
        {
            //
            // set up dialog
            //

            ghDlg = hDlg;

            DisableButton( IDC_ANSWER );
            DisableButton( IDC_DISCONNECT );

            SetStatusMessage( L"Waiting for a call..." );

            return 0;
        }

        case WM_COMMAND:
        {
            if ( LOWORD(wParam) == IDCANCEL )
            {
                //
                // quit
                //

                EndDialog( hDlg, 0 );

                return 1;
            }

            switch ( LOWORD(wParam) )
            {
                case IDC_AUTOANSWER:
                {
                    //
                    // auto answer check box was fiddled around with
                    //

                    gfAutoAnswer = !gfAutoAnswer;
                    return 1;
                }

                case IDC_ANSWER:
                {
                    //
                    // answer the call
                    //

                    SetStatusMessage(L"Answering...");

                    if ( S_OK == AnswerTheCall() )
                    {
                        SetStatusMessage(L"Connected");

                        EnableButton( IDC_DISCONNECT );
                        DisableButton( IDC_ANSWER );
                    }
                    else
                    {
                        DisableButton( IDC_ANSWER );
                        DoMessage(L"Answer failed");
                        SetStatusMessage(L"Waiting for a call...");
                    }

                    return 1;
                }

                case IDC_DISCONNECT:
                {
                    //
                    // disconnect request
                    //

                    SetStatusMessage(L"Disconnecting...");
                    if (S_OK != DisconnectTheCall())
                    {
                        DoMessage(L"Disconnect failed");
                    }

                    return 1;
                }

                case IDC_DISCONNECTED:
                {
                    //
                    // disconnected notification -- release the call
                    //

                    ReleaseTheCall();

                    EnableButton( IDOK );
                    DisableButton( IDC_DISCONNECT );

                    SetStatusMessage(L"Waiting for a call...");

                    return 1;
                }
                default:

                    return 0;
            }
        }
        default:

            return 0;
    }
}


///////////////////////////////////////////////////////////////////////////
// RegisterTapiEventInterface(CTAPIEventNotification *pTAPIEventNotification)
///////////////////////////////////////////////////////////////////////////

HRESULT
RegisterTapiEventInterface(CTAPIEventNotification *pTAPIEventNotification)
{
    HRESULT                       hr = S_OK;
    IConnectionPointContainer   * pCPC;
    IConnectionPoint            * pCP;


    hr = gpTapi->QueryInterface(
                                IID_IConnectionPointContainer,
                                (void **)&pCPC
                               );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pCPC->FindConnectionPoint(
                                   IID_ITTAPIEventNotification,
                                   &pCP
                                  );

    pCPC->Release();

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pCP->Advise(
                      pTAPIEventNotification,
                      &gulAdvise
                     );

    pCP->Release();


    return hr;

}


////////////////////////////////////////////////////////////////////////
// ListenOnAddresses
//
// This procedure will find all addresses that support audioin and audioout
// and will call ListenOnThisAddress to start listening on it.
////////////////////////////////////////////////////////////////////////

HRESULT
ListenOnAddresses()
{
    HRESULT             hr = S_OK;
    IEnumAddress *      pEnumAddress;
    ITAddress *         pAddress;

    //
    // enumerate the addresses
    //

    hr = gpTapi->EnumerateAddresses( &pEnumAddress );

    if ( FAILED(hr) )
    {
        return hr;
    }

    while ( TRUE )
    {
        //
        // get the next address
        //

        hr = pEnumAddress->Next( 1, &pAddress, NULL );

        if (S_OK != hr)
        {
            break;
        }

        //
        // does the address support audio?
        //

        if ( AddressSupportsMediaType(pAddress, TAPIMEDIATYPE_AUDIO) )
        {
            //
            // If it does then we'll listen.
            //

            hr = ListenOnThisAddress( pAddress );

            if ( FAILED(hr) )
            {
                DoMessage(L"Listen failed on an address");
            }
        }

        pAddress->Release();
    }

    pEnumAddress->Release();

    return S_OK;
}


///////////////////////////////////////////////////////////////////
// ListenOnThisAddress
//
// We call RegisterCallNotifications to inform TAPI that we want
// notifications of calls on this address. We already resistered
// our notification interface with TAPI, so now we are just telling
// TAPI that we want calls from this address to trigger events on
// our existing notification interface.
//
///////////////////////////////////////////////////////////////////

HRESULT
ListenOnThisAddress(
                    ITAddress * pAddress
                   )
{

    //
    // RegisterCallNotifications takes a media type bitmap indicating
    // the set of media types we are interested in. We know the
    // address supports audio, but let's add in video as well
    // if the address supports it.
    //

    long lMediaTypes = TAPIMEDIATYPE_AUDIO;

    if ( AddressSupportsMediaType(pAddress, TAPIMEDIATYPE_VIDEO) )
    {
        lMediaTypes |= TAPIMEDIATYPE_VIDEO;
    }


    HRESULT  hr;
    long     lRegister;

    hr = gpTapi->RegisterCallNotifications(
                                           pAddress,
                                           VARIANT_TRUE,
                                           VARIANT_TRUE,
                                           lMediaTypes,
                                           0,
                                           &lRegister
                                          );

    return hr;
}

/////////////////////////////////////////////////////////////////
// IsVideoCaptureStream
//
// Returns true if the stream is for video capture
/////////////////////////////////////////////////////////////////

BOOL
IsVideoCaptureStream(
                     ITStream * pStream
                    )
{
    TERMINAL_DIRECTION tdStreamDirection;
    long               lStreamMediaType;

    if ( FAILED( pStream  ->get_Direction(&tdStreamDirection)   ) ) { return FALSE; }
    if ( FAILED( pStream  ->get_MediaType(&lStreamMediaType)    ) ) { return FALSE; }

    return (tdStreamDirection == TD_CAPTURE) &&
           (lStreamMediaType  == TAPIMEDIATYPE_VIDEO);
}

/////////////////////////////////////////////////////////
// GetVideoRenderTerminal
//
// Creates a dynamic terminal for the Video Render mediatype / direction
//
/////////////////////////////////////////////////////////
HRESULT
GetVideoRenderTerminal(
                   ITAddress   * pAddress,
                   ITTerminal ** ppTerminal
                  )
{
    //
    // Construct a BSTR for the correct IID.
    //

    LPOLESTR            lpTerminalClass;

    HRESULT             hr;

    hr = StringFromIID(CLSID_VideoWindowTerm,
                       &lpTerminalClass);

    if ( SUCCEEDED(hr) )
    {
        BSTR                bstrTerminalClass;

        bstrTerminalClass = SysAllocString ( lpTerminalClass );

        CoTaskMemFree( lpTerminalClass );

        if ( bstrTerminalClass == NULL )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {

            //
            // Get the terminal support interface
            //

            ITTerminalSupport * pTerminalSupport;

            hr = pAddress->QueryInterface(IID_ITTerminalSupport,
                                          (void **)&pTerminalSupport);

            if ( SUCCEEDED(hr) )
            {
                //
                // Create the video render terminal.
                //

                hr = pTerminalSupport->CreateTerminal(bstrTerminalClass,
                                                      TAPIMEDIATYPE_VIDEO,
                                                      TD_RENDER,
                                                      ppTerminal);

                pTerminalSupport->Release();

                //
                // We do not make the window visible now -- we will do that
                // when the CME_STREAM_ACTIVE event is received for the stream
                // (and we have placed the window within our frame).
                //
            }

            SysFreeString( bstrTerminalClass );
        }
    }

    return hr;
}


/////////////////////////////////////////////////////////////////
// EnablePreview
//
// Selects a video render terminal on a video capture stream,
// thereby enabling video preview.
/////////////////////////////////////////////////////////////////

HRESULT
EnablePreview(
              ITAddress * pAddress,
              ITStream * pStream
             )
{
    ITTerminal * pTerminal;

    HRESULT hr = GetVideoRenderTerminal(pAddress, &pTerminal);

    if ( SUCCEEDED(hr) )
    {
        hr = pStream->SelectTerminal(pTerminal);

        pTerminal->Release();
    }

    return hr;
}


/////////////////////////////////////////////////////////
// GetTerminal
//
// Creates the default terminal for the passed-in stream.
//
/////////////////////////////////////////////////////////
HRESULT
GetTerminal(
            ITAddress   * pAddress,
            ITStream    * pStream,
            ITTerminal ** ppTerminal
           )
{
    //
    // Determine the media type and direction of this stream.
    //

    HRESULT            hr;
    long               lMediaType;
    TERMINAL_DIRECTION dir;

    hr = pStream->get_MediaType( &lMediaType );
    if ( FAILED(hr) ) return hr;

    hr = pStream->get_Direction( &dir );
    if ( FAILED(hr) ) return hr;

    //
    // Since video render is a dynamic terminal, the procedure for creating
    // it is different.
    //

    if ( ( lMediaType == TAPIMEDIATYPE_VIDEO ) &&
         ( dir        == TD_RENDER ) )
    {
        return GetVideoRenderTerminal(pAddress, ppTerminal);
    }

    //
    // For all other terminals we use GetDefaultStaticTerminal.
    // First, get the terminal support interface.
    //

    ITTerminalSupport * pTerminalSupport;

    hr = pAddress->QueryInterface( IID_ITTerminalSupport,
                                   (void **)&pTerminalSupport);

    if ( SUCCEEDED(hr) )
    {
        //
        // get the default terminal for this MediaType and direction
        //

        hr = pTerminalSupport->GetDefaultStaticTerminal(lMediaType,
                                                        dir,
                                                        ppTerminal);

        pTerminalSupport->Release();
    }

    return hr;

}

/////////////////////////////////////////////////////////////////
// SelectTerminalOnCall
//
// Selects a given terminal on the first compatible stream that
// exists on the given call.
/////////////////////////////////////////////////////////////////

HRESULT
SelectTerminalsOnCall(
                     ITAddress * pAddress,
                     ITBasicCallControl * pCall
                     )
{
    HRESULT hr;

    //
    // get the ITStreamControl interface for this call
    //

    ITStreamControl * pStreamControl;

    hr = pCall->QueryInterface(IID_ITStreamControl,
                               (void **) &pStreamControl);

    if ( SUCCEEDED(hr) )
    {
        //
        // enumerate the streams
        //

        IEnumStream * pEnumStreams;

        hr = pStreamControl->EnumerateStreams(&pEnumStreams);

        pStreamControl->Release();

        if ( SUCCEEDED(hr) )
        {
            //
            // for each stream
            //

            ITStream * pStream;

            while ( S_OK == pEnumStreams->Next(1, &pStream, NULL) )
            {
                ITTerminal * pTerminal;

                //
                // Find out the media type and direction of this stream,
                // and create the default terminal for this media type and
                // direction.
                //

                hr = GetTerminal(pAddress,
                                 pStream,
                                 &pTerminal);

                if ( SUCCEEDED(hr) )
                {
                    //
                    // Select the terminal on the stream.
                    //

                    hr = pStream->SelectTerminal(pTerminal);

                    if ( SUCCEEDED(hr) )
                    {
                        //
                        // Also enable preview on the video capture stream.
                        //

                        if ( IsVideoCaptureStream( pStream ) )
                        {
                            EnablePreview( pAddress, pStream );
                        }
                    }

                    pTerminal->Release();
                }

                pStream->Release();
            }

            pEnumStreams->Release();
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
// Answer the call
/////////////////////////////////////////////////////////////////////

HRESULT
AnswerTheCall()
{
    HRESULT                 hr;
    ITCallInfo *            pCallInfo;
    ITAddress *             pAddress;



    if (NULL == gpCall)
    {
        return E_UNEXPECTED;
    }


    //
    // get the address object of this call
    //

    hr = gpCall->QueryInterface( IID_ITCallInfo, (void**)&pCallInfo );

    if ( FAILED(hr) )
    {
        gpCall->Release();
        gpCall = NULL;

        return hr;
    }

    hr = pCallInfo->get_Address( &pAddress );

    pCallInfo->Release();

    if ( FAILED(hr) )
    {
        gpCall->Release();
        gpCall = NULL;

        return hr;
    }

    //
    // Select our terminals on the call; if any of the selections fail
    // we proceed without that terminal
    //

    hr = SelectTerminalsOnCall( pAddress, gpCall );

    pAddress->Release();

    //
    // Now we can actually answer the call
    //

    hr = gpCall->Answer();

    return hr;
}

//////////////////////////////////////////////////////////////////////
// DisconnectTheCall
//
// Disconnects the call
//////////////////////////////////////////////////////////////////////

HRESULT
DisconnectTheCall()
{
    HRESULT         hr = S_OK;

    if (NULL != gpCall)
    {
        hr = gpCall->Disconnect( DC_NORMAL );

        // Do not release the call yet, as that would prevent
        // us from receiving the disconnected notification.

        return hr;
    }

    return S_FALSE;
}

//////////////////////////////////////////////////////////////////////
// ReleaseTheCall
//
// Releases the call
//////////////////////////////////////////////////////////////////////
void
ReleaseTheCall()
{
    if (NULL != gpCall)
    {
        gpCall->Release();
        gpCall = NULL;
    }
}


///////////////////////////////////////////////////////////////////
//
// HELPER FUNCTIONS
//
///////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////
// DoMessage
///////////////////////////////////////////////////////////////////

void
DoMessage(
          LPWSTR pszMessage
         )
{
    MessageBox(
               ghDlg,
               pszMessage,
               gszTapi30,
               MB_OK
              );
}


//////////////////////////////////////////////////////////////////
// SetStatusMessage
//////////////////////////////////////////////////////////////////

void
SetStatusMessage(
                 LPWSTR pszMessage
                )
{
    SetDlgItemText(
                   ghDlg,
                   IDC_STATUS,
                   pszMessage
                  );
}

///////////////////////////////////////////////////////////////
// EnableButton
//
// Enable, make default, and setfocus to a button
///////////////////////////////////////////////////////////////

void
EnableButton(
             int ID
            )
{
    SendDlgItemMessage(
                       ghDlg,
                       ID,
                       BM_SETSTYLE,
                       BS_DEFPUSHBUTTON,
                       0
                      );
    EnableWindow(
                 GetDlgItem( ghDlg, ID ),
                 TRUE
                );
    SetFocus(
             GetDlgItem( ghDlg, ID )
            );
}

//////////////////////////////////////////////////////////////
// DisableButton
//
// Disable a button
//////////////////////////////////////////////////////////////

void
DisableButton(
              int ID
             )
{
    SendDlgItemMessage(
                       ghDlg,
                       ID,
                       BM_SETSTYLE,
                       BS_PUSHBUTTON,
                       0
                      );
    EnableWindow(
                 GetDlgItem( ghDlg, ID ),
                 FALSE
                );
}

//////////////////////////////////////////////////////////////
// AddressSupportsMediaType
//
// Finds out if the given address supports the given media
// type, and returns TRUE if it does.
//////////////////////////////////////////////////////////////

BOOL
AddressSupportsMediaType(
                         ITAddress * pAddress,
                         long        lMediaType
                        )
{
    VARIANT_BOOL     bSupport = VARIANT_FALSE;
    ITMediaSupport * pMediaSupport;

    if ( SUCCEEDED( pAddress->QueryInterface( IID_ITMediaSupport,
                                              (void **)&pMediaSupport ) ) )
    {
        //
        // does it support this media type?
        //

        pMediaSupport->QueryMediaType(
                                      lMediaType,
                                      &bSupport
                                     );

        pMediaSupport->Release();
    }

    return (bSupport == VARIANT_TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\samples\mstsample\tapirecv\processing.cpp ===
/*


Copyright (c) 1999  Microsoft Corporation


Module Name:

    Processing.cpp

Abstract:

    Implementation of the ITTAPIEventNotification interface. An application 
    must implement and register this interface in order to receive calls and 
    events related to calls. See TAPI documentation for more information on 
    this interface.
 
    This file also contains a collection of functions related to event 
    processing

*/


#include "common.h"

#include "Processing.h"

#include "WorkerThread.h"

#include "AVIFileWriter.h"


//
// the name of the file we will save the incoming audio to
//

#define SZ_OUTPUTFILENAME "recording.wav"


//
// the worker thread for asycnhronous message processing
//

CWorkerThread g_WorkerThread;


///////////////////////////////////////////////////////////////////////////////
//
// ITTAPIEventNotification::Event
//
// the method on the tapi callback object that will be called 
// when tapi notifies the application of an event 
//
// this method should return as soon as possible, so we are not 
// going to actually process the events here. Instead, we will post
// events to a worker thread for asynchronous processing.
//
// in a real life application that could be another thread, the
// application's main thread, or we could post events to a window.
//
///////////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CTAPIEventNotification::Event(IN TAPI_EVENT TapiEvent,
                                                        IN IDispatch *pEvent)
{
    
    LogMessage("CTAPIEventNotification::Event "
               "posting message for asynchronous processing");

    
    //
    // AddRef the event so it doesn't go away after we return
    //

    pEvent->AddRef();


    //
    // Post a message to our own worker thread to be processed asynchronously
    //

    g_WorkerThread.PostMessage(WM_PRIVATETAPIEVENT,
                              (WPARAM) TapiEvent,
                              (LPARAM) pEvent);

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//
// GetTerminalFromStreamEvent
//
//
// given pCallMediaEvent, find the one and only terminal selected on its stream
//
// return the terminal and S_OK if success, error otherwise
//
///////////////////////////////////////////////////////////////////////////////

HRESULT GetTerminalFromStreamEvent(IN ITCallMediaEvent *pCallMediaEvent,
                                   OUT ITTerminal **ppTerminal)
{

    HRESULT hr = E_FAIL;

    
    //
    // don't return garbage
    //

    *ppTerminal = NULL;


    //
    // Get the stream for this event.
    //

    ITStream *pStream = NULL;
    
    hr = pCallMediaEvent->get_Stream(&pStream);

    if ( FAILED(hr) )
    {
        
        LogMessage("GetTerminalFromStreamEvent: "
                   "Failed to get stream from pCallMediaEvent hr = 0x%lx", hr);

        return hr;
    }


    //
    // Enumerate terminals on this stream.
    //

    IEnumTerminal *pEnumTerminal = NULL;

    hr = pStream->EnumerateTerminals(&pEnumTerminal);

    pStream->Release();
    pStream = NULL;

    if ( FAILED(hr) ) 
    {
        LogMessage("GetTerminalFromStreamEvent: "
                   "Failed to enumerate terminals hr = 0x%lx", hr);
        return hr;
    }

    
    //
    // we should have at most one terminal selected on the stream, so 
    // get the first terminal
    //

    ITTerminal *pTerminal = NULL;

    hr = pEnumTerminal->Next(1, &pTerminal, NULL);

    if ( hr != S_OK )
    {
        LogMessage("GetTerminalFromStreamEvent: "
                   "Failed to get a terminal from enumeration hr = 0x%lx", hr);

        pEnumTerminal->Release();
        pEnumTerminal = NULL;

        return E_FAIL;
    }

    *ppTerminal = pTerminal;

    pTerminal = NULL;

    
    //
    // we should not have any more terminals on this stream, 
    // double-check this.
    //

    hr = pEnumTerminal->Next(1, &pTerminal, NULL);

    if (hr == S_OK)
    {
        LogError("GetTerminalFromStreamEvent: "
                 "more than one terminal on the stream!");

        _ASSERTE(FALSE);

        pTerminal->Release();
        pTerminal = NULL;

    }

    pEnumTerminal->Release();
    pEnumTerminal = NULL;


    return S_OK;
}





///////////////////////////////////////////////////////////////////////////////
//
// IsMessageForActiveCall
//
// return TRUE if the event received is for the currently active call
//
///////////////////////////////////////////////////////////////////////////////

BOOL IsMessageForActiveCall(IN ITCallStateEvent *pCallStateEvent)
{
    
    EnterCriticalSection(&g_CurrentCallCritSection);
    
    //
    // if we don't have an active call we have not received call notification
    // for a call that we own, so return FALSE
    //

    if (NULL == g_pCurrentCall)
    {
        LogMessage("IsMessageForActiveCall: no active call. return FALSE");
    
        LeaveCriticalSection(&g_CurrentCallCritSection);


        return FALSE;
    }


    //
    // get the call corresponding to the event
    //
    
    ITCallInfo *pCallInfo = NULL;
    
    HRESULT hr = pCallStateEvent->get_Call(&pCallInfo);

    if (FAILED(hr))
    {
        LogError("IsMessageForActiveCall: failed to get call. "
                 "returning FALSE");
        
        LeaveCriticalSection(&g_CurrentCallCritSection);

        return FALSE;
    }


    //
    // get IUnknown of the call from the event
    //

    IUnknown *pIncomingCallUnk = NULL;

    hr = pCallInfo->QueryInterface(IID_IUnknown, (void**)&pIncomingCallUnk);

    pCallInfo->Release();
    pCallInfo = NULL;

    if (FAILED(hr))
    {
        LogError("IsMessageForActiveCall: "
                 "failed to qi incoming call for IUnknown. returning FALSE");

        LeaveCriticalSection(&g_CurrentCallCritSection);
        
        return FALSE;
    }


    //
    // get IUnknown of the call from the event
    //

    IUnknown *pCurrentCallUnk = NULL;

    hr = g_pCurrentCall->QueryInterface(IID_IUnknown, (void**)&pCurrentCallUnk);

    LeaveCriticalSection(&g_CurrentCallCritSection);

    if (FAILED(hr))
    {
        LogError("IsMessageForActiveCall: "
                 "Failed to QI current call for IUnknown. returning FALSE.");

        pIncomingCallUnk->Release();
        pIncomingCallUnk = NULL;


        return FALSE;
    }


    //
    // compare IUnknowns of the current call and the event call
    // if they are the same, this is the same call
    //

    BOOL bSameCall = FALSE;

    if (pCurrentCallUnk == pIncomingCallUnk)
    {
        bSameCall = TRUE;
    }
    else
    {
        LogMessage("IsMessageForActiveCall: "
                    "current and event calls are different. returning FALSE.");

        bSameCall = FALSE;
    }

    pCurrentCallUnk->Release();
    pCurrentCallUnk = NULL;
        
    pIncomingCallUnk->Release();
    pIncomingCallUnk = NULL;

    return bSameCall;
}


///////////////////////////////////////////////////////////////////////////////
//
// GetAddressFromCall
//
//
// return ITAddress of the address corresponding to the supplied 
// ITBasicCallControl
//
///////////////////////////////////////////////////////////////////////////////

HRESULT GetAddressFromCall(IN ITBasicCallControl *pCallControl, 
                           OUT ITAddress **ppAddress)
{

    HRESULT hr = E_FAIL;


    //
    // don't return garbage
    //

    *ppAddress = NULL;

    
    //
    // get ITCallInfo so we can get the call's address
    //
    
    ITCallInfo *pCallInfo = NULL;

    hr = pCallControl->QueryInterface(IID_ITCallInfo, (void**)&pCallInfo);

    if (FAILED(hr))
    {
        LogError("GetAddressFromCall: "
                 "Failed to QI call for ITCallInfo");

        return hr;
    }


    //
    // get the call's address
    //

    ITAddress *pAddress = NULL;

    hr = pCallInfo->get_Address(&pAddress);
    
    
    pCallInfo->Release();
    pCallInfo = NULL;


    if (FAILED(hr))
    {
        LogError("GetAddressFromCall: failed to get address");

    }
    else 
    {
        *ppAddress = pAddress;
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
// CreateRenderMediaStreamingTerminal
//
// create rendering media streaming terminal. 
//
// if success, return the pointer to the terminal
// if failed, return NULL
//
///////////////////////////////////////////////////////////////////////////////

ITTerminal *CreateRenderMediaStreamingTerminal(IN ITBasicCallControl *pCallControl)
{
    
    HRESULT hr = E_FAIL;


    //
    // get address from call
    //

    ITAddress *pAddress = NULL;

    hr = GetAddressFromCall(pCallControl, &pAddress);

    if (FAILED(hr))
    {
        LogError("CreateRenderMediaStreamingTerminal: failed to get address from call");

        return NULL;
    }

    
    //
    // get the terminal support interface from the address
    //

    ITTerminalSupport *pTerminalSupport = NULL;

    hr = pAddress->QueryInterface( IID_ITTerminalSupport,
                                   (void **)&pTerminalSupport );

    pAddress->Release();
    pAddress = NULL;

    if (FAILED(hr))
    {
        LogError("CreateRenderMediaStreamingTerminal: "
                 "failed to QI pAddress for ITTerminalSupport");

        return NULL;
    }

    
    //
    // get string for the terminal's class id
    //

    WCHAR *pszTerminalClass = NULL;

    hr = StringFromIID(CLSID_MediaStreamTerminal, &pszTerminalClass);

    if (FAILED(hr))
    {
        LogError("CreateRenderMediaStreamingTerminal: "
                 "Failed to generate string from terminal's class id");

        pTerminalSupport->Release();
        pTerminalSupport = NULL;

        return NULL;
    }


    //
    // make bstr out of the class id
    //

    BSTR bstrTerminalClass = SysAllocString (pszTerminalClass);

    
    //
    // free the string returned by StringFromIID
    //

    CoTaskMemFree(pszTerminalClass);
    pszTerminalClass = NULL;


    //
    // create media streaming terminal for rendering
    //
    
    ITTerminal *pTerminal = NULL;

    hr = pTerminalSupport->CreateTerminal(bstrTerminalClass,
                                          TAPIMEDIATYPE_AUDIO,
                                          TD_RENDER,
                                          &pTerminal);

    
    //
    // release resources no longer needed
    //

    SysFreeString(bstrTerminalClass);
    bstrTerminalClass = NULL;

    pTerminalSupport->Release();
    pTerminalSupport = NULL;


    if (FAILED(hr))
    {
        LogError("CreateRenderMediaStreamingTerminal: "
                 "failed to create media streaming terminal hr = 0x%lx", hr);

        return NULL;
    }


    //
    // successfully created media streaming terminal. return.
    //

    LogMessage("CreateRenderMediaStreamingTerminal: "
               "Terminal created successfully");

    return pTerminal;

}


///////////////////////////////////////////////////////////////////////////////
//
// SetAudioFormat
// 
// tell media streaming terminal the audio format we would like
// to receive
//
///////////////////////////////////////////////////////////////////////////////

HRESULT SetAudioFormat(IN ITTerminal *pTerminal)
{

    HRESULT hr = E_FAIL;
    
    
    //
    // get ITAMMediaFormat interface on the terminal
    //

    ITAMMediaFormat *pITMediaFormat = NULL;

    hr = pTerminal->QueryInterface(IID_ITAMMediaFormat, 
                                   (void **)&pITMediaFormat);

    if (FAILED(hr))
    {
        LogError("SetAudioFormat: failed to QI terminal for ITAMMediaFormat");
     
        return hr;
    }

    //
    // will ask media streaming terminal for audio in this format
    //

    WAVEFORMATEX WaveFormat;

    ZeroMemory(&WaveFormat, sizeof(WAVEFORMATEX));
    
    WaveFormat.wFormatTag = WAVE_FORMAT_PCM; // pcm
    WaveFormat.nChannels = 1;                // mono
    WaveFormat.nSamplesPerSec = 8000;        // 8 khz
    WaveFormat.nAvgBytesPerSec = 16000;      // 16000 bytes per sec
    WaveFormat.nBlockAlign = 2;              // 2 bytes per block 
    WaveFormat.wBitsPerSample = 16;          // 16 bits per sample
    WaveFormat.cbSize = 0;                   // no extra format-specific data

    //
    // configure the wave format we want
    //

    AM_MEDIA_TYPE MediaType;

    MediaType.majortype            = MEDIATYPE_Audio;
    MediaType.subtype              = MEDIASUBTYPE_PCM;
    MediaType.bFixedSizeSamples    = TRUE;
    MediaType.bTemporalCompression = FALSE;
    MediaType.lSampleSize          = 0;
    MediaType.formattype           = FORMAT_WaveFormatEx;
    MediaType.pUnk                 = NULL;
    MediaType.cbFormat             = sizeof(WAVEFORMATEX);
    MediaType.pbFormat             = (BYTE*)&WaveFormat;


    //
    // log the wave format we are setting on the terminal
    //

    LogMessage("SetAudioFormat: setting wave format on terminal. ");
    LogFormat(&WaveFormat);


    //
    // set the format
    //

    hr = pITMediaFormat->put_MediaFormat(&MediaType);


    if (FAILED(hr))
    {

        //
        // try to see what format the terminal wanted
        //

        LogError("SetAudioFormat: failed to set format");

        AM_MEDIA_TYPE *pMediaFormat = NULL;

        HRESULT hr2 = pITMediaFormat->get_MediaFormat(&pMediaFormat);


        if (SUCCEEDED(hr2))
        {

            if (pMediaFormat->formattype == FORMAT_WaveFormatEx)
            {

                //
                // log the terminal's format
                //

                LogError("SetAudioFormat: terminal's format is");
                LogFormat((WAVEFORMATEX*) pMediaFormat->pbFormat);

            }
            else 
            {

                LogError("SetAudioFormat: "
                         "terminal's format is not WAVEFORMATEX");
            }


            //
            // note: we are responsible for deallocating the format returned by 
            // get_MediaFormat
            //

            DeleteMediaType(pMediaFormat);

        } //  succeeded getting terminal's format
        else
        {

            LogError("SetAudioFormat: failed to get terminal's format");

        }

    }

    pITMediaFormat->Release();
    pITMediaFormat = NULL;


    LogError("SetAudioFormat: completed");

 
    return hr;

}


///////////////////////////////////////////////////////////////////////////////
//
// SetAllocatorProperties
//
// suggest allocator properties to the terminal
//
///////////////////////////////////////////////////////////////////////////////

HRESULT SetAllocatorProperties(IN ITTerminal *pTerminal)
{


    //
    // different buffer sizes may produce different sound quality, depending
    // on the underlying transport that is being used.
    // 
    // this function illustrates how an app can control the number and size of
    // buffers. A multiple of 30 ms (480 bytes at 16-bit 8 KHz PCM) is the most
    // appropriate sample size for IP (especailly G.723.1).
    //
    // However, small buffers can cause poor audio quality on some voice boards.
    //
    // If this method is not called, the allocator properties suggested by the 
    // connecting filter will be used.
    //


    HRESULT hr = E_FAIL;

    
    //
    // get ITAllocator properties interface on the terminal
    //

    ITAllocatorProperties *pITAllocatorProperties = NULL;


    hr = pTerminal->QueryInterface(IID_ITAllocatorProperties,
                                   (void **)&pITAllocatorProperties);


    if (FAILED(hr))
    {
        LogError("SetAllocatorProperties: "
                 "failed to QI terminal for ITAllocatorProperties");

        return hr;
    }

    
    //
    // configure allocator properties
    //
    // suggest the size and number of the samples for MST to pre-allocate. 
    //
    
    ALLOCATOR_PROPERTIES AllocProps;
    
    AllocProps.cBuffers   = 5;    // ask MST to allocate 5 buffers
    AllocProps.cbBuffer   = 4800; // 4800 bytes each
    AllocProps.cbAlign    = 1;    // no need to align buffers
    AllocProps.cbPrefix   = 0;    // no extra memory preceeding the actual data
    
    
    hr = pITAllocatorProperties->SetAllocatorProperties(&AllocProps);

    if (FAILED(hr))
    {
        LogError("SetAllocatorProperties: "
                 "failed to set allocator properties. hr = 0x%lx", hr);

        pITAllocatorProperties->Release();
        pITAllocatorProperties = NULL;

        return hr;
    }

    
    //
    // ask media streaming terminal to allocate buffers for us. 
    // TRUE is the default, so strictly speaking, we didn't have to call 
    // this method.
    //

    hr = pITAllocatorProperties->SetAllocateBuffers(TRUE);


    pITAllocatorProperties->Release();
    pITAllocatorProperties = NULL;

    
    if (FAILED(hr))
    {
        LogError("SetAllocatorProperties: "
                 "failed to SetAllocateBuffers, hr = 0x%lx", hr);

        return hr;
    }


    //
    // succeeded setting allocator properties
    //

    LogMessage("SetAllocatorProperties: succeeded.");


    return S_OK;

}


///////////////////////////////////////////////////////////////////////////////
//
// SelectAndInitializeTerminal
//
//
// Set audio format and allocator properties on the terminal and
// select the terminal on the stream
//
///////////////////////////////////////////////////////////////////////////////

HRESULT SelectAndInitializeTerminal(IN ITTerminal *pRecordTerminal,
                                    IN ITStream *pStream)
{
    
    HRESULT hr = E_FAIL;


    //
    // set audio format on the created terminal
    //

    hr = SetAudioFormat(pRecordTerminal);

    if (FAILED(hr))
    {
     
        //
        // the terminal does not support the wave format we wanted.
        // no big deal for the receiver, we'll just have to create the 
        // file in the format requested by MST.
        //

        LogMessage("CreateAndSelectMST: "
                   "Failed to set audio format on recording terminal. "
                   "Continuing");

    }


    //
    // set allocator properties for this terminal
    //

    hr = SetAllocatorProperties(pRecordTerminal);

    if (FAILED(hr))
    {
     
        //
        // not a fatal error. our allocator props were rejected, 
        // but this does not necessarily mean streaming will fail.
        //

        LogError("CreateAndSelectMST: Failed to set "
                 "allocator properties on recording terminal");
    }


    //
    // select terminal on the stream
    //

    hr = pStream->SelectTerminal(pRecordTerminal);

    if (FAILED(hr))
    {

        LogError("CreateAndSelectMST: Failed to select "
                 "terminal on the stream");
    }

    return hr;

}


///////////////////////////////////////////////////////////////////////////////
//
// IsRenderingStream
//
// returns TRUE if the stream's direction is TD_RENDER
//
///////////////////////////////////////////////////////////////////////////////

BOOL IsRenderingStream(ITStream *pStream)
{

    //
    // check the stream's direction
    //

    TERMINAL_DIRECTION TerminalDirection;

    HRESULT hr = pStream->get_Direction(&TerminalDirection);

    if (FAILED(hr))
    {
        LogError("IsRenderingStream: Failed to get stream direction");
        
        return FALSE;
    }


    if (TD_RENDER == TerminalDirection)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


///////////////////////////////////////////////////////////////////////////////
//
// IsAudioStream
//
// returns TRUE if the stream's type is TAPIMEDIATYPE_AUDIO 
//
///////////////////////////////////////////////////////////////////////////////

BOOL IsAudioStream(ITStream *pStream)
{
    
    //
    // check the stream's media type 
    //
    
    long nMediaType = 0;

    HRESULT hr = pStream->get_MediaType(&nMediaType);

    if (FAILED(hr))
    {
        LogError("IsAudioStream: Failed to get media type");

        return FALSE;
    }


    //
    // return true if the stream is audio
    //

    if (TAPIMEDIATYPE_AUDIO == nMediaType)
    {
        
        return TRUE;
    }
    else
    {
    
        return FALSE;
    }

}


///////////////////////////////////////////////////////////////////////////////
// 
// CreateAndSelectMST
// 
// check the call's streams. create media streaming terminal on the first
// incoming audio stream
//
// returns:
//
// S_OK if a terminal was created and selected
// S_FALSE if no appropriate stream was found
// error if failed
//
///////////////////////////////////////////////////////////////////////////////

HRESULT CreateAndSelectMST()
{

    LogMessage("CreateAndSelectMST: started");


    //
    // we should already have the call
    //

    if (NULL == g_pCurrentCall) 
    {
        LogError("CreateAndSelectMST: g_pCurrentCall is NULL");

        return E_UNEXPECTED;
    }


    HRESULT hr = E_FAIL;


    //
    // get the ITStreamControl interface for this call
    //

    ITStreamControl *pStreamControl = NULL;

    hr = g_pCurrentCall->QueryInterface(IID_ITStreamControl,
                                        (void**)&pStreamControl);

    if (FAILED(hr))
    {
        LogError("CreateAndSelectMST: failed to QI call for ITStreamControl");

        return hr;
    }


    //
    // enumerate the streams on the call
    //

    IEnumStream *pEnumStreams = NULL;
    
    hr = pStreamControl->EnumerateStreams(&pEnumStreams);
    
    pStreamControl->Release();
    pStreamControl = NULL;

    if (FAILED(hr))
    {
        LogError("CreateAndSelectMST: failed to enumerate streams on call");
        
        return hr;
    }

    
    //
    // walk through the list of streams on the call
    // for the first incoming audio stream, create a media streaming terminal
    // and select it on the stream
    //
  
    BOOL bTerminalCreatedAndSelected = FALSE;

    while (!bTerminalCreatedAndSelected)
    {
        
        ITStream *pStream = NULL;

        hr = pEnumStreams->Next(1, &pStream, NULL);

        if (S_OK != hr)
        {
            //
            // no more streams or error
            //

            LogError("CreateAndSelectMST: didn't find an incoming audio stream."
                     " terminal not selected.");

            break;
        }


        //
        // create and select media streaming terminal on the first incoming
        // audio stream
        //

        if ( IsRenderingStream(pStream) && IsAudioStream(pStream))
        {

            LogMessage("CreateAndSelectMST: creating mst");

            //
            // create media streaming terminal and select it on the stream
            //
            
            ITTerminal *pRecordTerminal = NULL;

            pRecordTerminal = CreateRenderMediaStreamingTerminal(g_pCurrentCall);

            if (NULL != pRecordTerminal)
            {

                hr = SelectAndInitializeTerminal(pRecordTerminal, pStream);

                pRecordTerminal->Release();
                pRecordTerminal = NULL;


                if (SUCCEEDED(hr))
                {
                    //
                    // set the flag, so we can break out of the loop
                    //

                    bTerminalCreatedAndSelected = TRUE;
                }

            } // media streaming terminal created successfully

        } // stream is rendering and audio
        else
        {
            // 
            // the stream is of wrong direction, or type
            //

        }

        pStream->Release();
        pStream = NULL;

    } // while (enumerating streams on the call)


    //
    // done with the stream enumeration. release
    //

    pEnumStreams->Release();
    pEnumStreams = NULL;

    
    if (bTerminalCreatedAndSelected)
    {
        LogMessage("CreateAndSelectMST: terminal selected");

        return S_OK;
    }
    else
    {
        LogMessage("CreateAndSelectMST: no terminal selected");

        return S_FALSE;
    }

}


///////////////////////////////////////////////////////////////////////////////
//
// GetTerminalFromMediaEvent
//
//
// get the terminal selected on the event's stream
//
///////////////////////////////////////////////////////////////////////////////

HRESULT GetTerminalFromMediaEvent(IN ITCallMediaEvent *pCallMediaEvent,
                                  OUT ITTerminal **ppTerminal)
{

    HRESULT hr = E_FAIL;


    //
    // don't return garbage if we fail
    //

    *ppTerminal = NULL;


    //
    // get the stream corresponding to this event
    //

    ITStream *pStream = NULL;

    hr = pCallMediaEvent->get_Stream(&pStream);

    if ( FAILED(hr) )
    {
        LogError("GetTerminalFromMediaEvent: "
                 "failed to get stream hr = 0x%lx", hr);

        return hr;
    }


    //
    // find the terminal on this stream 
    //

    //
    // get terminal enumeration on the stream
    //
    
    IEnumTerminal *pEnumTerminal = NULL;

    hr = pStream->EnumerateTerminals(&pEnumTerminal);

    pStream->Release();
    pStream = NULL;


    if ( FAILED(hr) )
    {
        LogError("GetTerminalFromMediaEvent: failed to enumerate terminals, "
            "hr = 0x%lx", hr);
        
        return hr;

    }

    
    //
    // walk through terminal enumeration
    //

    ULONG nTerminalsFetched = 0;
    
    ITTerminal *pStreamTerminal = NULL;


    //
    // assuming there is at most one terminal selected on the stream
    //

    hr = pEnumTerminal->Next(1, &pStreamTerminal, &nTerminalsFetched);

    pEnumTerminal->Release();
    pEnumTerminal = NULL;

    if (S_OK != hr)
    {
        LogError("GetTerminalFromMediaEvent: enumeration returned no "
                 "terminals, hr = 0x%lx", hr);
        
        return hr;

    }

    *ppTerminal = pStreamTerminal;

    
    LogMessage("GetTerminalFromMediaEvent: succeeded");
    
    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//
// GetNumberOfSamplesOnStream
//
// read the terminal's allocator properties to return the number of samples
// the terminal provides
//
///////////////////////////////////////////////////////////////////////////////

HRESULT GetNumberOfSamplesOnStream(IN IMediaStream *pTerminalMediaStream,
                                   IN OUT DWORD *pnNumberOfSamples)
{

    HRESULT hr = S_OK;


    //
    // don't return garbage
    //
       
    *pnNumberOfSamples = 0;


    //
    // get allocator properties
    //

    ITAllocatorProperties *pAllocProperites = NULL;

    hr = pTerminalMediaStream->QueryInterface(IID_ITAllocatorProperties,
                                        (void **)&pAllocProperites);

    if (FAILED(hr))
    {
        LogError("GetNumberOfSamplesOnStream: "
                 "Failed to QI terminal for ITAllocatorProperties");

        return hr;
    }

    
    //
    // we want to know the number of samples we will be getting
    //

    ALLOCATOR_PROPERTIES AllocProperties;

    hr = pAllocProperites->GetAllocatorProperties(&AllocProperties);

    pAllocProperites->Release();
    pAllocProperites = NULL;


    if (FAILED(hr))
    {
        LogError("GetNumberOfSamplesOnStream: "
                 "Failed to get terminal's allocator properties");
        
        return hr;
    }


    *pnNumberOfSamples = AllocProperties.cBuffers;


    //
    // log the number of buffers and their sizes
    //

    LogMessage("GetNumberOfSamplesOnStream: [%ld] samples, [%ld] bytes each",
               *pnNumberOfSamples, AllocProperties.cbBuffer);


    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//
// ReleaseEvents
//
//
// close the handles passed into the function and release the array of handles
//
///////////////////////////////////////////////////////////////////////////////

void ReleaseEvents(IN OUT HANDLE *pEvents,   // array of events to be freed
                   IN DWORD nNumberOfEvents  // number of events in the array
                   )
{

    //
    // close all the handles in the array
    //

    for (DWORD i = 0; i < nNumberOfEvents; i++)
    {
        CloseHandle(pEvents[i]);
        pEvents[i] = NULL;
    }

    
    //
    // free the array itself
    //

    FreeMemory(pEvents);
    pEvents = NULL;
}


///////////////////////////////////////////////////////////////////////////////
//
// AllocateEvents
//
// allocate the array of events of size nNumberOfSamples
//
// return pointer to the allocated and initialized array if success
// or NULL if failed
//
///////////////////////////////////////////////////////////////////////////////

HANDLE *AllocateEvents(IN DWORD nNumberOfEvents)
{

    //
    // pointer to an array of event handles
    //

    HANDLE *pSampleReadyEvents = NULL;

    pSampleReadyEvents = 
        (HANDLE*)AllocateMemory(sizeof(HANDLE) * nNumberOfEvents);

    if (NULL == pSampleReadyEvents)
    {
        LogError("AllocateEvents: Failed to allocate sample ready events.");
        
        return NULL;
    }


    //
    // create an event for every allocated handle
    //

    
    for (DWORD i = 0; i < nNumberOfEvents; i++)
    {

        pSampleReadyEvents[i] = CreateEvent(NULL, FALSE, FALSE, NULL);
        
        if (NULL == pSampleReadyEvents[i])
        {

            LogError("AllocateEvents: "
                     "Failed to create event for sample %d", i);


            //
            // close handles we have created already
            //

            for (DWORD j = 0; j< i; j++)
            {
                CloseHandle(pSampleReadyEvents[j]);

                pSampleReadyEvents[j] = NULL;
            }


            FreeMemory(pSampleReadyEvents);
            pSampleReadyEvents = NULL;

            return NULL;

        }

    } // creating events for each sample

    
    //
    // succeded creating events. return the pointer to the array
    //

    return pSampleReadyEvents;

}


///////////////////////////////////////////////////////////////////////////////
//
// ReleaseSamples
//
// aborts and releases every sample in the array of samples of size 
// nNumberOfSamples and deallocates the array itself
//
// ppStreamSamples becomes invalid when the function returns
//
///////////////////////////////////////////////////////////////////////////////

void ReleaseSamples(IN OUT IStreamSample **ppStreamSamples,
                    IN DWORD nNumberOfSamples)
{

    for (DWORD i = 0; i < nNumberOfSamples; i++)
    {
        ppStreamSamples[i]->CompletionStatus(COMPSTAT_WAIT |
                                             COMPSTAT_ABORT,
                                             INFINITE);

        
        //
        // regardless of the error code, release the sample
        //

        ppStreamSamples[i]->Release();
        ppStreamSamples[i] = NULL;
    }

    FreeMemory(ppStreamSamples);
    ppStreamSamples = NULL;
}


///////////////////////////////////////////////////////////////////////////////
//
// AllocateStreamSamples
//
// allocate the array of nNumberOfSamples samples, and initialize each sample 
// pointer in the array with samples from the supplied stream.
//
// return pointer to the allocated and initialized array if success
// or NULL if failed
//
///////////////////////////////////////////////////////////////////////////////

IStreamSample **AllocateStreamSamples(IN IMediaStream *pMediaStream,
                                      IN DWORD nNumberOfSamples)
{

    //
    // allocate stream sample array
    //

    IStreamSample **ppStreamSamples = (IStreamSample **)
        AllocateMemory( sizeof(IStreamSample*) * nNumberOfSamples );


    if (NULL == ppStreamSamples)
    {
        LogError("AllocateStreamSamples: Failed to allocate stream sample array");

        return NULL;
    }


    //
    // allocate samples from the stream and put them into the array
    // 

    for (DWORD i = 0; i < nNumberOfSamples; i++)
    {

        HRESULT hr = pMediaStream->AllocateSample(0, &ppStreamSamples[i]);

        if (FAILED(hr))
        {

            LogError("AllocateStreamSamples: Failed to allocateSample. "
                     "Sample #%d", i);

            for (DWORD j = 0; j < i; j++)
            {
                ppStreamSamples[j]->Release();
                ppStreamSamples[j] = NULL;
            }

            FreeMemory(ppStreamSamples);
            ppStreamSamples = NULL;

            return NULL;
            
        } // failed AllocateSample()

    } // allocating samples on the stream



    //
    // succeeded allocating samples
    //

    return ppStreamSamples;

}


///////////////////////////////////////////////////////////////////////////////
//
// AssociateEventsWithSamples
//
// call Update() on every sample of the array of stream samples to associate it
// with an event from the array of events. The events will be signaled when the
// corresponding sample has data and is ready to be written to a file
//
///////////////////////////////////////////////////////////////////////////////

HRESULT AssociateEventsWithSamples(IN HANDLE *pSampleReadyEvents,
                                   IN IStreamSample **ppStreamSamples,
                                   IN DWORD nNumberOfSamples)
{


    for (DWORD i = 0; i < nNumberOfSamples; i++)
    {

        //
        // the event passed to Update will be signaled when the sample is 
        // filled with data
        //

        HRESULT hr = 
            ppStreamSamples[i]->Update(0, pSampleReadyEvents[i], NULL, 0);


        if (FAILED(hr))
        {
            
            LogError("AssociateEventsWithSamples: "
                     "Failed to call update on sample #%d", i);


            //
            // abort the samples we have Update()'d
            //

            for (DWORD j = 0; j < i; j++)
            {
      
                //
                // no need to check the return code here -- best effort attempt
                // if failed -- too bad
                //

                ppStreamSamples[j]->CompletionStatus(COMPSTAT_WAIT |
                                                     COMPSTAT_ABORT,
                                                     INFINITE);
            }

            return hr;

        } // Update() failed

    } // Update()'ing all samples


    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//
// GetAudioFormat
//
// return a pointer to wave format structure for the audio data produced by 
// the stream. the caller is responsible for deallocating returned stucture
//
// returns NULL if failed
// 
//////////////////////////////////////////////////////////////////////////////

WAVEFORMATEX *GetAudioFormat(IMediaStream *pTerminalMediaStream)
{


    //
    // get ITAMMediaFormat interface on the terminal, so we can query for
    // audio format
    //

    ITAMMediaFormat *pITMediaFormat = NULL;

    HRESULT hr = pTerminalMediaStream->QueryInterface(IID_ITAMMediaFormat,
                                                     (void **)&pITMediaFormat);

    if (FAILED(hr))
    {
        LogError("GetAudioFormat: "
                 "failed to QI terminal for ITAMMediaFormat");
 
        return NULL;
    }


    //
    // use ITAMMediaFormat to get terminal's media format
    //

    AM_MEDIA_TYPE *pMediaType = NULL;

    hr = pITMediaFormat->get_MediaFormat(&pMediaType);

    pITMediaFormat->Release();
    pITMediaFormat = NULL;


    if (FAILED(hr))
    {
        LogError("GetAudioFormat: failed to get_MediaFormat hr = 0x%lx", hr);

        return NULL;
    }


    //
    // did we get back a format that we can use?
    //

    if ((pMediaType->pbFormat == NULL) ||
        pMediaType->formattype != FORMAT_WaveFormatEx)
    {

        LogError("GetAudioFormat: invalid format");

        DeleteMediaType(pMediaType);
        pMediaType = NULL;

        return NULL;
    }

    // 
    // allocate and return wave format
    //

    WAVEFORMATEX *pFormat = 
        (WAVEFORMATEX *)AllocateMemory(pMediaType->cbFormat);

    if (NULL != pFormat)
    {
        CopyMemory(pFormat, pMediaType->pbFormat, pMediaType->cbFormat);
    }
    else
    {
        LogError("GetAudioFormat: Failed to allocate memory for audio format");
    }


    //
    // remember to release AM_MEDIA_TYPE that we no longer need
    //

    DeleteMediaType(pMediaType);
    pMediaType = NULL;

    return pFormat;

}


///////////////////////////////////////////////////////////////////////////////
//
// WriteSampleToFile
//
// This function writes the data portion of the sample into the file
//
///////////////////////////////////////////////////////////////////////////////

HRESULT WriteSampleToFile(IN IStreamSample *pStreamSample, // sample to record
                          IN CAVIFileWriter *pFileWriter)  // file to record to
{

    //
    // get the sample's IMemoryData interface so we can get to the 
    // sample's data
    //

    IMemoryData *pSampleMemoryData = NULL;

    HRESULT hr = pStreamSample->QueryInterface(IID_IMemoryData,
                                               (void **)&pSampleMemoryData);

    if (FAILED(hr))
    {

        LogError("WriteSampleToFile: "
                 "Failed to qi sample for IMemoryData");

        return hr;
    }


    //
    // get to the sample's data buffer
    //

    DWORD nBufferSize = 0;

    BYTE *pnDataBuffer = NULL;

    DWORD nActualDataSize = 0;


    hr = pSampleMemoryData->GetInfo(&nBufferSize,
                                    &pnDataBuffer,
                                    &nActualDataSize);


    pSampleMemoryData->Release();
    pSampleMemoryData = NULL;


    if (FAILED(hr))
    {
        LogError("WriteSampleToFile: "
                 "Failed to get to the sample's data");

        return hr;
    }


    //
    // write the data buffer to the avi file
    //

    LogMessage("WriteSampleToFile: received a sample of size %ld bytes",
                nActualDataSize);


    ULONG nBytesWritten = 0;

    hr = pFileWriter->Write(pnDataBuffer,
                            nActualDataSize,
                            &nBytesWritten);

    if (FAILED(hr) || (0 == nBytesWritten))
    {
        LogError("WriteSampleToFile: FileWriter.Write() wrote no data.");

        return E_FAIL;
    }


    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
// GetSampleID
//
// given the return code fom WaitForMultipleObjects, this function determines
// which sample was signal and returns S_OK and the id of the signaled sample
// or E_FAIL if WaitForMultipleEvents returned an error
//
///////////////////////////////////////////////////////////////////////////////

HRESULT GetSampleID(IN DWORD nWaitCode,         // code from WaitForMultiple...
                    IN DWORD nNumberOfSamples,  // the total number of samples
                    IN OUT DWORD *pnSampleID)   // the calculated id of the 
                                                //          signaled sample
{


    //
    // event abandoned?
    //

    if ( (nWaitCode >= WAIT_ABANDONED_0) && 
         (nWaitCode < WAIT_ABANDONED_0 + nNumberOfSamples) )
    {

        LogError("GetSampleID: event for sample #%lu abandoned.", 
                 nWaitCode - WAIT_ABANDONED_0);

        return E_FAIL;
    }


    //
    // any other error?
    //

    if ( (WAIT_OBJECT_0 > nWaitCode) || 
         (WAIT_OBJECT_0 + nNumberOfSamples <= nWaitCode) )
    {
        LogMessage("GetSampleID: "
                   "waiting for samples failed or timed out. "
                   "WaitForMultipleObjects returned %lu", nWaitCode);

        return E_FAIL;
    }


    //
    // which sample was signaled?
    //

    *pnSampleID = nWaitCode - WAIT_OBJECT_0;

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//
// WriteStreamToFile
//
// extract samples from the terminal's media stream and write them into a file
//
// returns when the call is disconnected (call disconnect causes media streaming
// terminal to abort the samples
//
///////////////////////////////////////////////////////////////////////////////

HRESULT WriteStreamToFile(IN IMediaStream *pTerminalMediaStream)
{

    LogMessage("WriteStreamToFile: started");


    HRESULT hr = E_FAIL;


    //
    // get the number of stream samples we will be using
    //

    DWORD nNumberOfSamples = 0;

    hr = GetNumberOfSamplesOnStream(pTerminalMediaStream, &nNumberOfSamples);

    if (FAILED(hr))
    {
        LogError("WriteStreamToFile: failed to get the number of samples");

        return hr;
    }


    //
    // the number of samples directly corresponds the number of events we will 
    // be waiting on later. WaitForMultipleObjects has a limit of 
    // MAXIMUM_WAIT_OBJECTS events.
    //

    if (nNumberOfSamples > MAXIMUM_WAIT_OBJECTS)
    {

        LogError("WriteStreamToFile: the number of samples [%ld] "
                 "exceeds the number allowed by the design of this "
                 "application [%ld]", 
                 nNumberOfSamples, MAXIMUM_WAIT_OBJECTS);

        return E_FAIL;

    }

   
    //
    // allocate events that will be signaled when each sample is ready to be 
    // saved to a file
    //

    HANDLE *pSampleReadyEvents = NULL;

    pSampleReadyEvents = AllocateEvents(nNumberOfSamples);

    if (NULL == pSampleReadyEvents)
    {
        LogError("WriteStreamToFile: Failed to allocate sample ready events.");
        
        return E_OUTOFMEMORY;
    }


    //
    // allocate array of stream samples
    //
   
    IStreamSample **ppStreamSamples = NULL;

    ppStreamSamples = AllocateStreamSamples(pTerminalMediaStream, 
                                            nNumberOfSamples);

    if (NULL == ppStreamSamples)
    {

        LogError("WriteStreamToFile: Failed to allocate stream sample array");


        //
        // release events we have allocated
        //

        ReleaseEvents(pSampleReadyEvents, nNumberOfSamples);
        pSampleReadyEvents = NULL;

        return E_FAIL;
    }


    //
    // we have the samples, we have the events. 
    // associate events with samples so events get signaled when the 
    // corresponding samples are ready to be written to a file
    // 

    hr = AssociateEventsWithSamples(pSampleReadyEvents,
                                    ppStreamSamples,
                                    nNumberOfSamples);

    if (FAILED(hr))
    {
        LogError("WriteStreamToFile: Failed to associate events with samples");


        //
        // release events and samples we have allocated
        //

        ReleaseEvents(pSampleReadyEvents, nNumberOfSamples);
        pSampleReadyEvents = NULL;

        ReleaseSamples(ppStreamSamples, nNumberOfSamples);
        ppStreamSamples = NULL;

        return E_FAIL;
    }

    
    //
    // get the format of the data delivered by media streaming terminal
    //

    WAVEFORMATEX *pAudioFormat = NULL;

    pAudioFormat = GetAudioFormat(pTerminalMediaStream);

    if (NULL == pAudioFormat)
    {
        LogError("WriteStreamToFile: Failed to get audio format");


        //
        // release events and samples we have allocated
        //

        ReleaseEvents(pSampleReadyEvents, nNumberOfSamples);
        pSampleReadyEvents = NULL;

        ReleaseSamples(ppStreamSamples, nNumberOfSamples);
        ppStreamSamples = NULL;

        return E_FAIL;

    }


    //
    // create a file with the required name and format.
    //
   
    CAVIFileWriter FileWriter;

    hr = FileWriter.Initialize(SZ_OUTPUTFILENAME, *pAudioFormat);


    //
    // no longer need audio format
    //

    FreeMemory(pAudioFormat);
    pAudioFormat = NULL;


    if (FAILED(hr))
    {
        LogError("WriteStreamToFile: open file");


        //
        // release events and samples we have allocated
        //

        ReleaseEvents(pSampleReadyEvents, nNumberOfSamples);
        pSampleReadyEvents = NULL;

        ReleaseSamples(ppStreamSamples, nNumberOfSamples);
        ppStreamSamples = NULL;

        return hr;

    }


    //
    // just for logging, count the number of samples we have recorded
    //

    ULONG nStreamSamplesRecorded = 0;


    while(TRUE)
    {

        //
        // wait for the events associated with the samples
        // when a samples has data, the corresponding event will be 
        // signaled
        //
    
        DWORD nWaitCode = WaitForMultipleObjects(nNumberOfSamples,
                                                 pSampleReadyEvents,
                                                 FALSE,
                                                 INFINITE);

        
        //
        // get the id of the sample that was signaled. fail if Wait returned
        // error
        // 

        DWORD nSampleID = 0;

        hr = GetSampleID(nWaitCode, nNumberOfSamples, &nSampleID);

        if (FAILED(hr))
        {
            LogError("WriteStreamToFile: wait failed");

            break;
        }


        //
        // we filtered out all invalid error codes. so nSampleID has no 
        // choice but be a valid sample index.
        //

        _ASSERTE(nSampleID < nNumberOfSamples);


        //
        // make sure the sample is ready to be read
        //

        hr = ppStreamSamples[nSampleID]->CompletionStatus(COMPSTAT_WAIT, 0);

    
        //
        // check against S_OK explicitly -- not all success codes mean the
        // sample is ready to be used (MS_S_ENDOFSTREAM, etc)
        //

        if (S_OK != hr)
        {

            if (E_ABORT == hr)
            {
        
                //
                // recording was aborted, probably because 
                // the call was disconnected
                //

                LogMessage("WriteStreamToFile: recording aborted");
            }
            else
            {

                LogMessage("WriteStreamToFile: sample is not completed. "
                            "hr = 0x%lx", hr);
            }

            break;
        }

        
        //
        // we have the sample that was signaled and which is now ready to be
        // saved to a file. Record the sample.
        //

        hr = WriteSampleToFile(ppStreamSamples[nSampleID], &FileWriter);

        if (FAILED(hr))
        {
            LogError("WriteStreamToFile: failed to write sample to file");

            break;
        }


        //
        // one more sample was recorded. update the count.
        //

        nStreamSamplesRecorded++;


        //
        // we are done with this sample. return it to the source stream
        // to be refilled with data
        //

        hr = ppStreamSamples[nSampleID]->Update(0,
                                               pSampleReadyEvents[nSampleID],
                                               NULL,
                                               0);

        if (FAILED(hr))
        {
            LogError("WriteStreamToFile: "
                     "Failed to Update the sample recorded. "
                     "hr = 0x%lx", hr);

            break;
        }

    } // sample-writing loop
 

    LogMessage("WriteStreamToFile: wrote the total of %lu samples", 
                nStreamSamplesRecorded);


    //
    // release samples and events
    //

    ReleaseSamples(ppStreamSamples, nNumberOfSamples);
    ppStreamSamples = NULL;

    ReleaseEvents(pSampleReadyEvents, nNumberOfSamples);
    pSampleReadyEvents = NULL;


    //
    // deallocated samples and events. safe to exit.
    //

    LogMessage("WriteStreamToFile: completed, hr = 0x%lx", hr);

 
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
// RecordMessage
//
// record the terminal's stream into a file
//
///////////////////////////////////////////////////////////////////////////////

HRESULT RecordMessage(IN ITTerminal *pRecordTerm)
{

    LogMessage("RecordMessage: started");

    HRESULT hr = E_FAIL;


    //
    // get IMediaStream interface on the terminal
    //
    
    IMediaStream *pTerminalMediaStream = NULL;

    hr = pRecordTerm->QueryInterface(IID_IMediaStream, 
                                     (void**)&pTerminalMediaStream);

    if (FAILED(hr))
    {
        LogError("RecordMessage: Failed to qi terminal for IMediaStream.");

        return hr;
    }

    
    //
    // write terminal stream data to a file
    //
    
    hr = WriteStreamToFile(pTerminalMediaStream);

    
    //
    // done with the terminal stream, release.
    //

    pTerminalMediaStream->Release();
    pTerminalMediaStream = NULL;


    LogMessage("RecordMessage: finished");

    return hr;

}


///////////////////////////////////////////////////////////////////////////////
//
// ProcessCallNotificationEvent
//
// processing for TE_CALLNOTIFICATION event
//
///////////////////////////////////////////////////////////////////////////////

HRESULT ProcessCallNotificationEvent(IDispatch *pEvent)
{

    HRESULT hr = E_FAIL;


    //
    // we are being notified of a new call
    //
    // if we own the call and there is not other active call
    // consider this to be the active call
    //
    // wait for CS_OFFERING message before answering the call
    //

    ITCallNotificationEvent *pCallNotificationEvent = NULL;

    hr = pEvent->QueryInterface( IID_ITCallNotificationEvent, 
                                (void **)&pCallNotificationEvent);

    if (FAILED(hr))
    {
        LogError("ProcessCallNotificationEvent: "
                 "Failed to QI event for ITCallNotificationEvent");

        return hr;
    }
   

    //
    // get the call from notification event
    //

    ITCallInfo *pCall = NULL;

    hr = pCallNotificationEvent->get_Call(&pCall);

    //
    // release the ITCallNotificationEvent interface
    //

    pCallNotificationEvent->Release();
    pCallNotificationEvent = NULL;


    if (FAILED(hr))
    {
        LogError("ProcessCallNotificationEvent: "
                 "Failed to get call from Call notification event");


        return hr;
    }

    
    //
    // if we already have an active call, reject the new incoming call
    //

    EnterCriticalSection(&g_CurrentCallCritSection);

    if (NULL != g_pCurrentCall)
    {

        LeaveCriticalSection(&g_CurrentCallCritSection);

        LogMessage("ProcessCallNotificationEvent: "
                   "incoming call while another call in progress");

        
        ITBasicCallControl *pSecondCall = NULL;

        hr = pCall->QueryInterface(IID_ITBasicCallControl, 
                                   (void**)&pSecondCall);

        pCall->Release();
        pCall = NULL;


        if (FAILED(hr))
        {
            LogError("ProcessCallNotificationEvent: failed to qi incoming call "
                     "for ITBasicCallConrtrol");

            return hr;
        }


        //
        // reject the incoming call
        //

        LogMessage("ProcessCallNotificationEvent: rejecting the incoming call");
        

        hr = pSecondCall->Disconnect(DC_REJECTED);

        pSecondCall->Release();
        pSecondCall = NULL;

        return E_FAIL;
    }


    //
    // check to see if we own the call
    //

    CALL_PRIVILEGE cp;
   
    hr = pCall->get_Privilege( &cp );


    if ( FAILED(hr) )
    {
        LogError("ProcessCallNotificationEvent: Failed to get call owner info");

        pCall->Release();
        pCall = NULL;

        LeaveCriticalSection(&g_CurrentCallCritSection);

        return hr;
    }

    if ( CP_OWNER != cp )
    {

        //
        // we don't own the call. ignore it.
        //

        LogMessage("ProcessCallNotificationEvent: We don't own the call.");

        pCall->Release();
        pCall = NULL;

        LeaveCriticalSection(&g_CurrentCallCritSection);

        return E_FAIL;
    }
    else
    {
        LogMessage("ProcessCallNotificationEvent: Incoming call.");
    }


    //
    // keep the call for future use
    // 

    hr = pCall->QueryInterface(IID_ITBasicCallControl, 
                               (void**)&g_pCurrentCall);


    if (FAILED(hr))
    {
        LogError("ProcessCallNotificationEvent: failed to qi incoming call for"
                  "ITBasicCallControl.");
        
        g_pCurrentCall = NULL;
    }
    
    LeaveCriticalSection(&g_CurrentCallCritSection);

    pCall->Release();
    pCall = NULL;


    return hr;

} // ProcessCallNotificationEvent


///////////////////////////////////////////////////////////////////////////////
//
// ProcessCallMediaEvent
//
// processing for TE_CALLMEDIA event. if stream is active, record the 
// incoming data
//
///////////////////////////////////////////////////////////////////////////////

HRESULT ProcessCallMediaEvent(IDispatch *pEvent)
{

    //
    // Get ITCallMediaEvent interface from the event
    //

    ITCallMediaEvent *pCallMediaEvent = NULL;

    HRESULT hr = pEvent->QueryInterface( IID_ITCallMediaEvent, 
                                 (void **)&pCallMediaEvent );

    if (FAILED(hr))
    {
    
        //
        // the event does not have the interface we want
        //

        LogError("ProcessCallMediaEvent: TE_CALLMEDIA. "
                 "Failed to QI event for ITCallMediaEvent");

        return hr;
    }


    //
    // get the CALL_MEDIA_EVENT that we are being notified of.
    //

    CALL_MEDIA_EVENT CallMediaEvent;

    hr = pCallMediaEvent->get_Event(&CallMediaEvent);

    if ( FAILED(hr) )
    {

        //
        // failed to get call media event 
        //
        
        LogError("ProcessCallMediaEvent: TE_CALLMEDIA. "
                 "Failed to get call media event hr = 0x%lx", hr);
        
        pCallMediaEvent->Release();
        pCallMediaEvent = NULL;

        return hr;
    }



    switch (CallMediaEvent) 
    {

        LogMessage("ProcessCallMediaEvent: processing call media event");

        case CME_STREAM_INACTIVE:
        {

            LogMessage("ProcessCallMediaEvent: CME_STREAM_INACTIVE");

            break;
        }

        case CME_STREAM_NOT_USED:
            
            LogMessage("ProcessCallMediaEvent: CME_STREAM_NOT_USED");
            
            break;

        case CME_NEW_STREAM:

            LogMessage("ProcessCallMediaEvent: CME_NEW_STREAM received");

            break;

        case CME_STREAM_FAIL:

            LogError("ProcessCallMediaEvent: CME_STREAM_FAIL received");
            
            break;

        case CME_TERMINAL_FAIL:
            
            LogError("ProcessCallMediaEvent: CME_STREAM_FAIL received");

            break;

        case CME_STREAM_ACTIVE:
        {

            LogError("ProcessCallMediaEvent: CME_STREAM_ACTIVE received");


            //
            // Get the terminal on the active stream
            //    

            ITTerminal *pRecordStreamTerminal = NULL;

            hr = GetTerminalFromMediaEvent(pCallMediaEvent, 
                                           &pRecordStreamTerminal);

            if ( FAILED(hr) )
            {
                // 
                // the stream has no terminals associated with it
                //

                LogError("ProcessCallMediaEvent: "
                         "failed to get terminal on the active stream");

                break; 
            }

          
            //
            // make sure the direction is right -- we are recording, so the 
            // terminal should be TD_RENDER
            //

            TERMINAL_DIRECTION td;

            hr = pRecordStreamTerminal->get_Direction( &td);

            if ( FAILED(hr) ) 
            {

                LogError("ProcessCallMediaEvent: "
                         "failed to get record terminal's direction.");

                pRecordStreamTerminal->Release();
                pRecordStreamTerminal = NULL;

                break; 
            }
            
            
            //
            // double check that the terminal is rendering terminal
            // since we are the recording side
            //

            if ( TD_RENDER != td ) 
            {

                //
                // this should never ever happen
                //

                LogError("ProcessCallMediaEvent: bad terminal direction");

                pRecordStreamTerminal->Release();
                pRecordStreamTerminal = NULL;

                hr = E_FAIL;

                break;

            }

            //
            // Now do the actual streaming.
            //

            //
            // this will block until:
            //
            // the call is disconnected, or
            // the user chooses to close the app, or
            // there is an error
            //
            // Since we are in the message processing thread,
            // the application will not be able to process messages
            // (the messages will still be queued) until this call
            // returns.
            //
            // If it is important that messages are processed while
            // file is being recorded, recording should be done on 
            // a different thread.
            // 

            RecordMessage(pRecordStreamTerminal);
        
            pRecordStreamTerminal->Release();
            pRecordStreamTerminal = NULL;
    
            break;
        }
    
        default:

            break;
    
    } // switch (call media event)


    //
    // We no longer need the event interface.
    //

    pCallMediaEvent->Release();
    pCallMediaEvent = NULL;

    
    return S_OK;    

}


///////////////////////////////////////////////////////////////////////////////
//
// ProcessCallStateEvent
//
// processing for TE_CALLSTATE. if CS_OFFERING, creates and selects MST, 
// answers the call . Release call if disconnected. 
//
// also verifies that the event is for the current call
//
///////////////////////////////////////////////////////////////////////////////

HRESULT ProcessCallStateEvent(IDispatch *pEvent)
{

    HRESULT hr = S_OK;


    //
    // TE_CALLSTATE is a call state event.  
    // pEvent is an ITCallStateEvent
    // 

    ITCallStateEvent *pCallStateEvent = NULL;


    //
    // Get the interface
    //

    hr = pEvent->QueryInterface(IID_ITCallStateEvent, 
                                (void **)&pCallStateEvent);

    if ( FAILED(hr) )
    {

        LogError("ProcessCallStateEvent: "
                 "Failed to QI event for ITCallStateEvent");

        return hr;
    }


    //
    // make sure the message is for the active call!
    //

    EnterCriticalSection(&g_CurrentCallCritSection);

    if (!IsMessageForActiveCall(pCallStateEvent))
    {
        LogMessage("ProcessCallStateEvent: received TE_CALLSTATE message "
                   "for a different call. ignoring.");

        pCallStateEvent->Release();
        pCallStateEvent = NULL;

        LeaveCriticalSection(&g_CurrentCallCritSection);

        return E_FAIL;
    }


    //
    // get the CallState that we are being notified of.
    //

    CALL_STATE CallState;

    hr = pCallStateEvent->get_State(&CallState);


    //
    // no longer need the event
    //

    pCallStateEvent->Release();
    pCallStateEvent = NULL;


    if (FAILED(hr))
    {
         LogError("ProcessCallStateEvent: "
                  "failed to get state from call state event.");

         LeaveCriticalSection(&g_CurrentCallCritSection);

         return hr;
    }



    //
    // log the new call state
    //

    if (CS_OFFERING == CallState)
    {
        
        LogMessage("ProcessCallStateEvent: call state is CS_OFFERING");


        //
        // try to create and select media streaming terminal on one of
        // the call's incoming audio streams
        //

        hr = CreateAndSelectMST();

        if (S_OK == hr)
        {
        
            //
            // we have selected a terminal on one of the streams
            // answer the call
            //

            LogMessage("ProcessCallStateEvent: answering the call");

            hr = g_pCurrentCall->Answer();

            if (FAILED(hr))
            {
                LogError("ProcessCallStateEvent: Failed to answer the call");
            }

        }
        else
        {
            
            //
            // we could not create mst on any of the streams of 
            // the incoming call. reject the call.
            //

            LogMessage("ProcessCallStateEvent: rejecting the call");

            HRESULT hr2 = g_pCurrentCall->Disconnect(DC_REJECTED);

            if (FAILED(hr2))
            {
                LogError("ProcessCallStateEvent: Failed to reject the call");
            }

        }


        
    } // CS_OFFERING
    else if (CS_DISCONNECTED == CallState)
    {

        LogMessage("ProcessCallStateEvent: call state is CS_DISCONNECTED. "
                   "Releasing the call.");


        //
        // release the call -- no longer need it!
        //

        g_pCurrentCall->Release();
        g_pCurrentCall = NULL;


        //
        // signal the main thread that it can exit if it is time to exit
        //

        LogMessage("ProcessCallStateEvent: signaling main thread.");

        SetEvent(g_hExitEvent);

    } // CS_DISCONNECTED
    else if (CS_CONNECTED == CallState)
    {
        
        LogMessage("ProcessCallStateEvent: call state is CS_CONNECTED");

    } // CS_CONNECTED


    //
    // no longer need to protect current call
    //

    LeaveCriticalSection(&g_CurrentCallCritSection);

    return hr;

}



/////////////////////////////////////////////////////////////////////////////
//
// OnTapiEvent
//
// handler for tapi events. called on a thread that provides asychronous
// processing of tapi messages
//
/////////////////////////////////////////////////////////////////////////////

HRESULT OnTapiEvent(TAPI_EVENT TapiEvent, IDispatch *pEvent)
{
    
    LogMessage("OnTapiEvent: message received");


    HRESULT hr = S_OK;


    switch ( TapiEvent )
    {
    
        case TE_CALLNOTIFICATION:
        {

            LogMessage("OnTapiEvent: received TE_CALLNOTIFICATION");

            hr = ProcessCallNotificationEvent(pEvent);

            break;

        } // TE_CALLNOTIFICATION
        

        case TE_CALLSTATE:
        {
            LogMessage("OnTapiEvent: received TE_CALLSTATE");

            hr = ProcessCallStateEvent(pEvent);

            break;

        } // TE_CALLSTATE


        case TE_CALLMEDIA:
        {

            LogMessage("OnTapiEvent: received TE_CALLMEDIA");

            hr = ProcessCallMediaEvent(pEvent);

            break;    
        
        } // case TE_CALLMEDIA


    default:

        LogMessage("OnTapiEvent: received message %d. not handled.", TapiEvent);

        break;

    }


    //
    // the event was AddRef()'ed when it was posted for asynchronous processing
    // no longer need the event, release it.
    //

    pEvent->Release(); 
    pEvent = NULL;

    LogMessage("OnTapiEvent: exiting.");

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\samples\mstsample\tapirecv\common.h ===
/*

Copyright (c) 1999  Microsoft Corporation


Module Name:

    common.h


Abstract:

    include files, definitions and declarations used in the app

*/


#define _WIN32_DCOM

#define WM_PRIVATETAPIEVENT   WM_USER+101

#include <stdio.h>
#include <windows.h>
#include <tapi3.h>
#include <crtdbg.h>

#include <control.h>
#include <strmif.h>

#include <uuids.h>
#include <mmsystem.h>
#include <amstream.h>

#include <vfw.h>
#include <Mtype.h>

#include "WorkerThread.h"


//
// the event to signal when it's time to exit
//

extern HANDLE g_hExitEvent;


//
// the tapi object
//

extern ITTAPI *g_pTapi;


//
// The current call. We only process one call at a time
//

extern ITBasicCallControl *g_pCurrentCall;


//
// critical section for protecting the global current call
//

extern  CRITICAL_SECTION g_CurrentCallCritSection;


//
// thread for asynchronous message processing
//

extern CWorkerThread g_WorkerThread;


//
// logging functions
//

void LogMessage(CHAR *pszFormat, ... );

#define LogError LogMessage

void LogFormat(const WAVEFORMATEX *pWaveFormat);


//
// tapi event handler
//

HRESULT OnTapiEvent(TAPI_EVENT TapiEvent, IDispatch *pEvent);


//
// memory allocation routines
//

void *AllocateMemory(SIZE_T nMemorySize);

void FreeMemory(void* pMemory);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\samples\mstsample\tapirecv\processing.h ===
/*
 
Copyright (c) 1999  Microsoft Corporation


Module Name:

    Processing.h 


Abstract: 
    
    Declaration of the CTAPIEventNotification object

*/


#ifndef __TAPIEventNotification_H__
#define __TAPIEventNotification_H__


//
// declaration of implementation of the interface that is registered
// with TAPI to receive notification messages
//

class CTAPIEventNotification : public ITTAPIEventNotification
{

private:

    //
    // reference counting
    //

    LONG       m_dwRefCount;

public:


    //
    // ITTAPIEventNotification
    //

    //
    // the method called by TAPI when there is an event
    //

    HRESULT STDMETHODCALLTYPE Event(IN TAPI_EVENT TapiEvent,
                                    IN IDispatch *pEvent);
    

    //
    // IUnknown
    //

    HRESULT STDMETHODCALLTYPE QueryInterface(IN REFIID iid,
                                             OUT void **ppvObject)
    {
        if (iid == IID_ITTAPIEventNotification)
        {
            AddRef();
            *ppvObject = (void *)this;
            return S_OK;
        }

        if (iid == IID_IUnknown)
        {
            AddRef();
            *ppvObject = (void *)this;
            return S_OK;
        }

        return E_NOINTERFACE;
    }

    
    //
    // reference counting needs to be thread safe
    //

    ULONG STDMETHODCALLTYPE AddRef()
    {
        ULONG l = InterlockedIncrement(&m_dwRefCount);

        return l;
    }
    
	ULONG STDMETHODCALLTYPE Release()
    {
        ULONG l = InterlockedDecrement(&m_dwRefCount);

        if ( 0 == l)
        {
            delete this;
        }
        
        return l;
    }



public:


    CTAPIEventNotification() 
    { 

        //
        // freshly created object has an outstanding reference count
        // 

        m_dwRefCount = 1;
    }



    //
    // the object should only be destroyed from Release().
    // destructor is private to enforce this.
    //

private:

    ~CTAPIEventNotification()
    {

        //
        // reference count here must be 0, otherwise we have a bug in the app
        //

        _ASSERTE(m_dwRefCount == 0);
    }

};

#endif //__TAPIEventNotification_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\samples\mstsample\tapirecv\workerthread.h ===
/*

Copyright (c) 1999  Microsoft Corporation


Module Name:

    WorkerThread.h

Abstract:

    interface for the CWorkerThread class.

*/


#if !defined(AFX_WORKERTHREAD_H__45467AAB_C5AB_43D6_B518_B81B971A859C__INCLUDED_)
#define AFX_WORKERTHREAD_H__45467AAB_C5AB_43D6_B518_B81B971A859C__INCLUDED_


//
// worker whose purpose is to asynchronously process messages received 
// from TAPI
// 

class CWorkerThread
{

public:

    //
    // post an message to be processed asyncronously
    //

    BOOL PostMessage(UINT Msg,       // message to post
                     WPARAM wParam,  // first message parameter
                     LPARAM lParam   // second message parameter
                     );

public:

    //
    // create thread
    //

    HRESULT Initialize();

    //
    // shutdown thread
    //

    HRESULT Shutdown();



    CWorkerThread()
        :m_hThreadHandle(NULL),
        m_nThreadID(0)
    {}


    virtual ~CWorkerThread();

protected:
    
    //
    // the actual thread function
    //

    static unsigned long _stdcall ThreadFunction(void *);


private:

    //
    // thread handle and thread id
    //

    HANDLE m_hThreadHandle;

    unsigned long m_nThreadID;

};

#endif // !defined(AFX_WORKERTHREAD_H__45467AAB_C5AB_43D6_B518_B81B971A859C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\samples\mstsample\tapirecv\tapirecv.cpp ===
/*

Copyright (c) 1999  Microsoft Corporation

Module Name:

    TAPIRecv.cpp

Abstract:

    This sample illustrates the use of Media Streaming Terminal for receiving 
    audio.

    The application listens on addresses that support audio, accepts an 
    incoming call and uses Media Streaming Terminal to get the incoming 
    data, which is written into a wav file.
 
*/


#include "common.h"

#include "Processing.h"


//
// main thread will wait on this event before exiting
//

HANDLE g_hExitEvent = NULL;


//
// the tapi object
//

ITTAPI *g_pTapi = NULL;


//
// the current call
//

ITBasicCallControl *g_pCurrentCall = NULL;


//
// critical section for protecting the global current call
//

CRITICAL_SECTION g_CurrentCallCritSection;

//
// the cookie from registering tapi event notification
//

ULONG g_nTAPINotificationCookie = 0;


///////////////////////////////////////////////////////////////////////////////
// 
// LogMessage
//
//
// logs a message using printf
//
///////////////////////////////////////////////////////////////////////////////

void LogMessage(CHAR *pszFormat, ... )
{
    
    //
    // output buffer -- note: hardcoded limit
    //

    char szBuffer[1280]; 


    //
    // get current time
    //

    SYSTEMTIME SystemTime;

    GetLocalTime(&SystemTime);

    
    //
    // format thread id and time
    //

    sprintf( szBuffer, "[%lx]:[%02u:%02u:%02u.%03u]::",
             GetCurrentThreadId(),
             SystemTime.wHour,
             SystemTime.wMinute,
             SystemTime.wSecond,
             SystemTime.wMilliseconds);


    //
    // get the actual message
    //

    va_list vaArguments;

    va_start(vaArguments, pszFormat);
    vsprintf(&(szBuffer[strlen(szBuffer)]), pszFormat, vaArguments);
    va_end(vaArguments);


    //
    // log the buffer with the terminating carriage return
    //

    strcat(szBuffer, "\n");

    printf(szBuffer);
}


///////////////////////////////////////////////////////////////////////////////
// 
// LogFormat
//
// use LogMessage to log wave format
//
///////////////////////////////////////////////////////////////////////////////

void LogFormat(const WAVEFORMATEX *pWaveFormat)
{
    LogMessage("    Format: ");
    LogMessage("        tag: %u", pWaveFormat->wFormatTag);
    LogMessage("        channels: %u", pWaveFormat->nChannels);
    LogMessage("        samples/sec: %lu", pWaveFormat->nSamplesPerSec);
    LogMessage("        align: %u", pWaveFormat->nBlockAlign);
    LogMessage("        bits/sample: %u", pWaveFormat->wBitsPerSample);

}



///////////////////////////////////////////////////////////////////////////////
//
// AllocateMemory
//
// use win32 heap api to allocate memory on the application's heap
// and zero the allocated memory
//
///////////////////////////////////////////////////////////////////////////////

void *AllocateMemory(SIZE_T nMemorySize)
{
    

    //
    // use HeapAlloc to allocate and clear memory
    //

    return HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, nMemorySize);
}


///////////////////////////////////////////////////////////////////////////////
//
// FreeMemory
//
// use win32 heap api to free memory previously allocated on the application's
// heap
//
///////////////////////////////////////////////////////////////////////////////


void FreeMemory(void *pMemory)
{
    
    //
    // get size of the allocated memory
    //

    DWORD nMemorySize = HeapSize(GetProcessHeap(), 0, pMemory);

    if (-1 == nMemorySize)
    {
        LogError("FreeMemory: failed to get size of the memory block %p",
                 pMemory);

        //
        // don't exit -- try freeing anyway
        //

    }
    else
    {
        //
        // fill memory with 0xdd's before freeing, so it is easier to debug 
        // failures caused by using pointer to deallocated memory
        //
        
        if (NULL != pMemory)
        {
            FillMemory(pMemory, nMemorySize, 0xdd);
        }

    }


    //
    // use HeapFree to free memory. use return code to log the result, but
    // do not return it to the caller
    //
    
    BOOL bFreeSuccess = HeapFree(GetProcessHeap(), 0, pMemory);

    if (FALSE == bFreeSuccess)
    {
        LogError("FreeMemory: HeapFree failed");

        //
        // if this assertion fires, it is likely there is a problem with the 
        // memory we are trying to deallocate. Was it allocated using heapalloc
        // and on the same heap? Is this a valid pointer?
        //

        _ASSERTE(FALSE);
    }

}


///////////////////////////////////////////////////////////////////////////////
//
// RegisterCallBack
//
//
// instantiate the callback object and register it with TAPI
//
///////////////////////////////////////////////////////////////////////////////

HRESULT RegisterCallback()
{
    LogMessage("RegisterCallback: started");

    HRESULT hr = S_OK;


    //
    // get connection point container on the tapi object
    // 
    
    IConnectionPointContainer *pCPContainer = NULL;

    hr = g_pTapi->QueryInterface(
                                IID_IConnectionPointContainer,
                                (void **)&pCPContainer
                               );

    if (FAILED(hr))
    {
        LogError("RegisterCallback: "
                 "Failed to get IConnectionPointContainer on TAPI");

        return hr;
    }


    //
    // find connection point for our interface
    //

    IConnectionPoint *pCP = NULL;

    hr = pCPContainer->FindConnectionPoint(IID_ITTAPIEventNotification, &pCP);

    pCPContainer->Release();
    pCPContainer = NULL;

    if (FAILED(hr))
    {
        LogError("RegisterCallback: "
                 "Failed to get a connecion point for ITTAPIEventNotification");

        return hr;
    }


    //
    // create the callback object and register it with TAPI.
    // for simplicity, the callback in this sample is not a 
    // full-fledged COM object. So create is with new.
    //

    ITTAPIEventNotification *pTAPIEventNotification = 
                                                new CTAPIEventNotification;

    if (NULL == pTAPIEventNotification)
    {

        LogError("RegisterCallback: Failed to create a tapi event notification object.");

        pCP->Release();
        pCP = NULL;
        
        return E_OUTOFMEMORY;
    }


    //
    // will use the cookie later to register for events from addresses
    // and to unregister the callback when we no longer needs the events
    //
    
    hr = pCP->Advise(pTAPIEventNotification,
                     &g_nTAPINotificationCookie);

    pCP->Release();
    pCP = NULL;


    //
    // whether Advise failed or succeeded, we no longer need a reference to 
    // the callback
    //

    pTAPIEventNotification->Release();
    pTAPIEventNotification = NULL;

    if (FAILED(hr))
    {
        g_nTAPINotificationCookie = 0;

        LogError("RegisterCallback: Failed to Advise");
    }


    LogMessage("RegisterCallback: completed");

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
// UnRegisterCallBack
//
//
// unregister call notification object
//
///////////////////////////////////////////////////////////////////////////////

HRESULT UnRegisterCallBack()
{
    LogMessage("UnRegisterCallBack: started");

    HRESULT hr = S_OK;


    //
    // get connection point container on the tapi object
    // 
    
    IConnectionPointContainer *pCPContainer = NULL;

    hr = g_pTapi->QueryInterface(IID_IConnectionPointContainer,
                                (void **)&pCPContainer);

    if (FAILED(hr))
    {
        LogError("UnRegisterCallBack: "
                 "Failed to get IConnectionPointContainer on TAPI");

        return hr;
    }


    //
    // find connection point for our interface
    //

    IConnectionPoint *pConnectionPoint = NULL;

    hr = pCPContainer->FindConnectionPoint(IID_ITTAPIEventNotification,
                                           &pConnectionPoint);

    pCPContainer->Release();
    pCPContainer = NULL;

    if (FAILED(hr))
    {
        LogError("RegisterCallback: Failed to get a connection point for "
                 "ITTAPIEventNotification");

        return hr;
    }


    // 
    // unregister the callback
    //
    
    hr = pConnectionPoint->Unadvise(g_nTAPINotificationCookie);

    pConnectionPoint->Release();
    pConnectionPoint = NULL;

    g_nTAPINotificationCookie = 0;

    if (FAILED(hr))
    {
        LogError("UnRegisterCallBack: Unadvise failed");
    }
    else
    {
        LogMessage("UnRegisterCallBack: succeeded");
    }


    return hr;
}


///////////////////////////////////////////////////////////////////////////////
// 
// AddressSupportsAudio
//
// return TRUE if the address supports audio
//
///////////////////////////////////////////////////////////////////////////////

BOOL AddressSupportsAudio(IN ITAddress *pAddress)
{

    //
    // get the address's ITMediaSupport so we can check 
    // the media type it supports
    //

    ITMediaSupport *pMediaSupport = NULL;

    HRESULT hr = pAddress->QueryInterface(IID_ITMediaSupport, 
                                          (void**)&pMediaSupport);

    if (FAILED(hr))
    {
        LogError("AddressSupportsAudio: "
                 "Failed to QI address for ITMediaSupport");

        return FALSE;
    }


    //
    // does the address support audio?
    //

    VARIANT_BOOL bAudioSupported = VARIANT_FALSE;

    hr = pMediaSupport->QueryMediaType(TAPIMEDIATYPE_AUDIO, &bAudioSupported);
    
    pMediaSupport->Release();
    pMediaSupport = NULL;

    if (FAILED(hr))
    {
        LogError("AddressSupportsAudio: Failed to QueryMediaType");

        return FALSE;
    }



    if (VARIANT_TRUE == bAudioSupported)
    {
        LogMessage("AddressSupportsAudio: audio supported on this address");

        return TRUE;

    }
    else
    {
        LogMessage("AddressSupportsAudio: "
                   "audio NOT supported on this address");

        return FALSE;

    }
}


///////////////////////////////////////////////////////////////////////////////
// 
// AddressSupportsMST
//
// return TRUE if the address supports media streaming terminal
//
///////////////////////////////////////////////////////////////////////////////

BOOL AddressSupportsMST(IN ITAddress *pAddress)
{

    //
    // get the address's ITTerminalSupport so we can check
    // the terminals it supports
    //

    ITTerminalSupport *pTerminalSupport = NULL;

    HRESULT hr = pAddress->QueryInterface( IID_ITTerminalSupport,
                                           (void **)&pTerminalSupport );

    if (FAILED(hr))
    {
        LogError("AddressSupportsMST: Failed to QI address for ITTerminalSupport");

        return FALSE;
    }


    //
    // get enumeration of dynamic terminal classes this address supports
    //

    IEnumTerminalClass *pTerminalClassEnumerator = NULL;

    hr = pTerminalSupport->EnumerateDynamicTerminalClasses(&pTerminalClassEnumerator);

    pTerminalSupport->Release();
    pTerminalSupport = NULL;

    if (FAILED(hr))
    {

        LogError("AddressSupportsMST: Failed to get dynamic terminal classes");

        return FALSE;

    }


    //
    // walk through terminal class enumeration and see if the 
    // media streaming terminal is in it
    //

    while (TRUE)
    {
        
        GUID guid;
        
        hr = pTerminalClassEnumerator->Next(1, &guid, NULL);

        if (S_OK != hr)
        {
            LogMessage("AddressSupportsMST: no more terminal classes. "
                       "MST not supported on this address");

            break;
        }

        if ( IsEqualGUID(guid, CLSID_MediaStreamTerminal))
        {
            LogMessage("AddressSupportsMST: media streaming terminal supported");

            break;
        }
    }

    
    //
    // no longer need the enumeration
    //

    pTerminalClassEnumerator->Release();
    pTerminalClassEnumerator = NULL;

  
    //
    // if we did not break out of the loop because the enumeration ended,
    // media streaming terminal was not in the list of supported terminals
    //

    if (S_OK == hr)
    {
        return TRUE;
    }
    else 
    {
        return FALSE;
    }

}


///////////////////////////////////////////////////////////////////////////////
//
// ListenOnAddress
// 
// register to receieve notifications of calls on this addres.
// calls on this address will trigger events on the callback object
// we have registered with TAPI earlier.
//
///////////////////////////////////////////////////////////////////////////////

HRESULT ListenOnAddress(ITAddress *pAddress)
{
    
    long ulCallNotificationCookie = 0;


    //
    // we want to be notified of the status of this address
    //
    // the app can keep the cookies to later unregister from events
    // from specific addresses (by calling ITTAPI::UnregisterNotifications)
    // when it no longer wants to receive events for this specific address.
    // this sample does not do this for simplicity.
    //

    HRESULT  hr= g_pTapi->RegisterCallNotifications(pAddress,
                                                   VARIANT_TRUE,
                                                   VARIANT_TRUE,
                                                   TAPIMEDIATYPE_AUDIO,
                                                   g_nTAPINotificationCookie,
                                                   &ulCallNotificationCookie
                                                   );

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
// StartListening
//
// find all addresses that support audio and start listening on them
//
///////////////////////////////////////////////////////////////////////////////

HRESULT StartListening()
{

    HRESULT hr = S_OK;

    LogMessage("StartListening: started");
    

    //
    // enumerate available addresses
    // 
    
    IEnumAddress *pEnumAddress = NULL;

    hr = g_pTapi->EnumerateAddresses( &pEnumAddress );

    if (FAILED(hr))
    {
        LogError("StartListening: Failed to enumerate addresses");

        return hr;
    }


    //
    // this flag remains false until we succeded starting listening on at 
    // least one address
    //

    BOOL bListenStarted = FALSE;


    //
    // walk through all the addresses and start listening on the ones that
    // support audio
    //
    
    while (TRUE)
    {
        //
        // check the next address
        //

        ITAddress *pAddress = NULL;

        hr = pEnumAddress->Next(1, &pAddress, NULL);

        if (S_OK != hr)
        {

            //
            // no more addresses or error
            //

            break;
        }


        //
        // log the name of the address
        //

        BSTR bstrAddressName;
        hr = pAddress->get_AddressName(&bstrAddressName);

        if (SUCCEEDED(hr))
        {

            LogMessage("StartListening: -> found address [%S]",
                        bstrAddressName);

            SysFreeString(bstrAddressName);
        }
        else
        {
            LogError("StartListening: failed to get address name");
        }


        //
        // if the address supports audio and media streaming terminal, 
        // start listening
        //

        if ( AddressSupportsAudio(pAddress) && AddressSupportsMST(pAddress) )
        {

            //
            // start listening on this address
            // 

            LogMessage("StartListening: Starting listening.");

            hr = ListenOnAddress(pAddress);

            if (SUCCEEDED(hr))
            {

                //
                // we are listening on at least one address
                //

                bListenStarted = TRUE;

                LogMessage("StartListening: "
                           "-> started listening on this address");

            }
            else
            {
                //
                // log an error and continue
                //

                LogError("StartListening: -> failed starting listening on this address, "
                         "hr = 0x%lx", hr);
            }
        }
        else
        {
            LogMessage("StartListening: -> no audio or MST support on this address.");
        }


        pAddress->Release();
        pAddress = NULL;

    }


    pEnumAddress->Release();
    pEnumAddress = NULL;


    //
    // depending on whether we started listening or not, log a message and
    // return the appropriate error code.
    //

    if (bListenStarted)
    {
        LogMessage("StartListening: completed. "
                   "Listening on one or more addresses");

        return S_OK;
    }
    else
    {
        LogMessage("StartListening: completed. Not listening on any address.");

        return E_FAIL;
    }
}


///////////////////////////////////////////////////////////////////////////////
//
// InitializeTAPI
//
// create and initialize the tapi object
//
///////////////////////////////////////////////////////////////////////////////

HRESULT InitializeTAPI()
{
    
    LogMessage("InitializeTAPI: started");

    HRESULT hr = E_FAIL;
        

    //
    // cocreate the TAPI object
    //

    hr = CoCreateInstance(
                          CLSID_TAPI,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_ITTAPI,
                          (LPVOID *)&g_pTapi
                         );

    if (FAILED(hr))
    {
        LogError("InitializeTAPI: failed to CoCreateInstance TAPI");

        return hr;
    }


    //
    // cannot use tapi until it's initialized
    //

    hr = g_pTapi->Initialize();

    if (FAILED(hr))
    {
        LogError("InitializeTAPI: TAPI failed to initialize");

        g_pTapi->Release();
        g_pTapi = NULL;
        
        return hr;
    }


    //
    // register the callback object that will receive tapi notifications
    //

    hr = RegisterCallback();

    if (FAILED(hr))
    {
        LogError("InitializeTAPI: failed to register callback");

        g_pTapi->Shutdown();
        g_pTapi->Release();
        g_pTapi = NULL;
        
        return hr;
    }


    //
    // we want to be notified of these events:
    //
   
    hr = g_pTapi->put_EventFilter(TE_CALLNOTIFICATION |
                                  TE_CALLSTATE |
                                  TE_CALLMEDIA);

    if (FAILED(hr))
    {
        LogError("InitializeTAPI: Failed to put_EventFilter");

        //
        // unregister callback
        //

        UnRegisterCallBack();

        //
        // shutdown and release TAPI
        //

        g_pTapi->Shutdown();
        g_pTapi->Release();
        g_pTapi = NULL;

        return hr;
    }


    //
    // start listening on the addresses that support audio
    //

    hr = StartListening();

    if (S_OK != hr)
    {
        LogError("InitializeTAPI: Failed to start listening");

        //
        // unregister callback
        //

        UnRegisterCallBack();

        //
        // shutdown and release TAPI
        //

        g_pTapi->Shutdown();
        g_pTapi->Release();
        g_pTapi = NULL;

        return hr;
    }

    LogMessage("InitializeTAPI: succeeded");

    return S_OK;
}



///////////////////////////////////////////////////////////////////////////////
//
// DisconnectAndReleaseCall
// 
// disconnect and release the current call, if we have one
//
///////////////////////////////////////////////////////////////////////////////

void DisconnectAndReleaseCall()
{

    //
    // g_pCurrentCall can be accessed from event-processing thread and
    // needs to be protected
    //

    EnterCriticalSection(&g_CurrentCallCritSection);

    if (NULL != g_pCurrentCall)
    {

        //
        // if the call exists, attempt to disconnect it
        //

        LogMessage("DisconnectAndReleaseCall: disconnecting the call");

        g_pCurrentCall->Disconnect(DC_NORMAL);


        //
        // succeded or failed, release the call
        //

        g_pCurrentCall->Release();
        g_pCurrentCall = NULL;
    }

    
    LeaveCriticalSection(&g_CurrentCallCritSection);
}


///////////////////////////////////////////////////////////////////////////////
//
// ShutdownTapi
//
// - unregister callback object
// - shutdown and release TAPI object
//
///////////////////////////////////////////////////////////////////////////////

void ShutdownTapi()
{

    LogMessage("ShutdownTapi: started");

    
    // 
    // if there is still a call, disconnect it
    //

    HRESULT hr = E_FAIL;


    //
    // by now, the call is released and disconnected.
    // shutdown tapi
    //

    if (NULL != g_pTapi)
    {
        //
        // unregister callback
        //

        UnRegisterCallBack();


        //
        // shutdown and release the TAPI object
        //

        g_pTapi->Shutdown();
        g_pTapi->Release();
        g_pTapi = NULL;

    }

    
    //
    // in the unlikely case another call was received after we released the 
    // call that we had, release the new call.
    //
    
    EnterCriticalSection(&g_CurrentCallCritSection);

    if (NULL != g_pCurrentCall)
    {
        
        g_pCurrentCall->Release();
        g_pCurrentCall = NULL;

    }

    LeaveCriticalSection(&g_CurrentCallCritSection);

    LogMessage("ShutdownTapi: succeeded");
}


///////////////////////////////////////////////////////////////////////////////
//
// CtrlHandler
//
// set shutdown flag when the user requests exit by pressing
// ctrl+break, attempting to log off, close the window, or
// shutdown windows. this will give use a chance to exit gracefully.
//
///////////////////////////////////////////////////////////////////////////////

BOOL CtrlHandler(DWORD nEventType) 
{

    static BOOL bShutdownInProgress = FALSE;

    
    //
    // are we in the middle of shutting down?
    //

    if (TRUE == bShutdownInProgress)
    {
        LogMessage("CtrlHandler: Shutdown already in progress");

        return TRUE;
    }


    //
    // any exit event (close, ctrl+break/C, logoff, shutdown)
    // is a signal for the application to exit.
    //

    switch (nEventType)
    { 
 
        case CTRL_C_EVENT: 
        case CTRL_CLOSE_EVENT: 
        case CTRL_BREAK_EVENT: 
        case CTRL_LOGOFF_EVENT: 
        case CTRL_SHUTDOWN_EVENT:

            LogMessage("CtrlHandler: Initiating shutdown.");
            
            //
            // ignore subsequent shutdown requests...
            //

            bShutdownInProgress = TRUE;
            
            //
            // signal shutdown
            //

            SetEvent(g_hExitEvent);


            return TRUE; 
  

        default: 

             return FALSE; 
    } 

    return TRUE;
}
 

///////////////////////////////////////////////////////////////////////////////
//
// main
// 
///////////////////////////////////////////////////////////////////////////////

int __cdecl main(int argc, char* argv[])
{

    LogMessage("main: started");


    //
    // this event be signalled when it's time to exit
    //

    g_hExitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (NULL == g_hExitEvent)
    {
        LogError("main: Failed to create exit event");

        return 1;
    }

   

    //
    // we want to handle ctrl+c and ctrl+break events so we can cleanup on exit
    // proceed even in case of failure
    //

    SetConsoleCtrlHandler( (PHANDLER_ROUTINE)CtrlHandler, TRUE);


    //
    // initialize COM
    //

    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if ( FAILED(hr))
    {
        LogError("main: Failed to CoInitialize");

        CloseHandle(g_hExitEvent);
        g_hExitEvent = NULL;

        return 1;
    }


    //
    // start worker thread for tapi message processing
    //

    hr = g_WorkerThread.Initialize();

    if (FAILED(hr))
    {
        LogError("main: Failed to initialize worker thread");
        
        CoUninitialize();

        CloseHandle(g_hExitEvent);
        g_hExitEvent = NULL;

        return 1;
    }


    //
    // initialize critical section used to serialize access to global
    // current call
    //
    // note: InitializeCriticalSection can raise STATUS_NO_MEMORY exception
    //

    InitializeCriticalSection(&g_CurrentCallCritSection);

    //
    // create and initialize tapi object, register the callback object 
    // and start listening
    //
    
    hr = InitializeTAPI();

    if (FAILED(hr))
    {
        
        g_WorkerThread.Shutdown();


        CloseHandle(g_hExitEvent);
        g_hExitEvent = NULL;

        DeleteCriticalSection(&g_CurrentCallCritSection);

        CoUninitialize();
        return 1;
    }

    
    //
    // wait until ctrl+break handler or CS_DISCONNECT handler signal exit event
    //

    LogMessage("main: waiting for exit event");

    DWORD nWaitResult = WaitForSingleObject(g_hExitEvent, INFINITE);
    
    LogMessage("main: exit event signaled");


    //
    // disconnect and release call, if it exists
    //

    DisconnectAndReleaseCall();


    //
    // cleanup tapi
    //

    ShutdownTapi();


    //
    // stop the worker thread
    //

    g_WorkerThread.Shutdown();


    //
    // no longer need the critical section
    //

    DeleteCriticalSection(&g_CurrentCallCritSection);


    //
    // release com
    //
    
    CoUninitialize();


    //
    // no longer need the event
    //

    CloseHandle(g_hExitEvent);
    g_hExitEvent = NULL;


    //
    // exiting... we no longer want to handle ctrl+c and ctrl+break
    //
    
    SetConsoleCtrlHandler( (PHANDLER_ROUTINE) CtrlHandler, FALSE);


    //
    // was the event signaled, or wait failed?
    //

    if (WAIT_OBJECT_0 != nWaitResult)
    {
        LogError("main: Failed to wait for exit event");
        return 1;
    }


    LogMessage("main: exiting");

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\samples\mstsample\tapirecv\workerthread.cpp ===
/*

Copyright (c) 1999  Microsoft Corporation

Module Name:

    WorkerThread.cpp

Abstract:

    Implementation of CWorkerThread class
 
*/


#include "common.h"
#include "WorkerThread.h"



///////////////////////////////////////////////////////////////////////////////
//
// CWorkerThread::Initialize
//
// create the thread
//
///////////////////////////////////////////////////////////////////////////////

HRESULT CWorkerThread::Initialize()
{

    //
    // if the thread is already initialized 
    //

    if ( (NULL != m_hThreadHandle) && (0 != m_nThreadID) )
    {

        LogError("CWorkerThread::Initialize() thread is already running");

        return E_UNEXPECTED;
    }


    //
    // start the thread
    //
    
    m_hThreadHandle = CreateThread(NULL,        // security
                                   0,           // stack
                                   ThreadFunction,    // thread function
                                   0,           // thread parameter
                                   0,           // flags
                                   &m_nThreadID);

    //
    // thread creation failed. log a message and return an error
    // 

    if (NULL == m_hThreadHandle)
    {
        LogError("CWorkerThread::Initialize() "
                 "failed to start the worker thread");

        return E_FAIL;
    }


    //
    // thread created. log thread id.
    //
    
    LogMessage("CWorkerThread::Initialize() succeeded. thread id [0x%lx]",
                m_nThreadID);

    return S_OK;

}


///////////////////////////////////////////////////////////////////////////////
//
// CWorkerThread::Shutdown
//
// exit the thread and close thread handle
//
///////////////////////////////////////////////////////////////////////////////

HRESULT CWorkerThread::Shutdown()
{

     LogError("CWorkerThread::Shutdown() entered");

    //
    // if the thread is running, post quit message and wait for thread to exit
    //

    if (NULL != m_hThreadHandle)
    {
        
        //
        // let the thread know it's time to go home
        //

        PostMessage(WM_QUIT, NULL, NULL);
    

        //
        // wait for the thread to disappear
        //

        DWORD rc = WaitForSingleObject(m_hThreadHandle, INFINITE);
        
        //
        // close thread handle
        //

        CloseHandle(m_hThreadHandle);
        m_hThreadHandle = NULL;

        m_nThreadID = 0;


        if (rc != WAIT_OBJECT_0)
        {
            LogError("CWorkerThread::Shutdown() "
                     "Failed waiting for thread to shutdown");

            return E_FAIL;
        }
        else
        {

            LogMessage("CWorkerThread::Shutdown() finished");

            return S_OK;

        }

    }
    else
    {
        //
        // thread was not running
        //

        LogError("CWorkerThread::Shutdown() thread is not running");

        return E_FAIL;
    }

}


///////////////////////////////////////////////////////////////////////////////
//
// CWorkerThread::~CWorkerThread
//
// log a message and fire assert in the thread is still running
//
///////////////////////////////////////////////////////////////////////////////

CWorkerThread::~CWorkerThread()
{
    LogError("CWorkerThread::~CWorkerThread() entered");

    
    //
    // the thread should not be running at this point -- the app should have 
    // called Shutdown()
    // 
    
    if (NULL != m_hThreadHandle)
    {
        LogError("CWorkerThread::~CWorkerThread thread [%ld] is still running",
                  m_nThreadID);
    }

    _ASSERTE(NULL == m_hThreadHandle);
    

    LogError("CWorkerThread::~CWorkerThread() finished");
}


///////////////////////////////////////////////////////////////////////////////
//
// CWorkerThread::PostMessage
//
// posts a message to the thread
//
///////////////////////////////////////////////////////////////////////////////

BOOL CWorkerThread::PostMessage( UINT Msg,       // message to post
                                 WPARAM wParam,  // first message parameter
                                 LPARAM lParam   // second message parameter
                                 )
{
    
    BOOL bReturn = FALSE;


    if (NULL != m_hThreadHandle)
    {

        //
        // the thread is running, post the message
        //

        bReturn = PostThreadMessage(m_nThreadID, Msg, wParam, lParam);

    }


    return bReturn;
}


///////////////////////////////////////////////////////////////////////////////
//
// CWorkerThread::ThreadFunction
//
//
// thread function. receives messages posted to the thread. Forwards TAPI
// messages to TAPI event handler. Exits on WM_QUIT.
//
///////////////////////////////////////////////////////////////////////////////

unsigned long _stdcall CWorkerThread::ThreadFunction(void *)
{

    LogMessage("CWorkerThread::ThreadFunction() starting");


    CoInitializeEx(NULL, COINIT_MULTITHREADED);

    //
    // force creation of message queue
    // 

    MSG msg;


    //
    // keep retrieving messages until we fail or get WM_QUIT
    //
    
    while (GetMessage(&msg, NULL, 0, 0))
    {

        switch (msg.message)
        {
        
        case WM_PRIVATETAPIEVENT:
            {

                //
                // get event from the message
                //

                TAPI_EVENT TapiEvent = (TAPI_EVENT)msg.wParam;
                IDispatch *pEvent = (IDispatch*)msg.lParam;


                //
                // pass event to the event handler
                //
                
                OnTapiEvent(TapiEvent, pEvent);

                pEvent = NULL;


                //
                // do not check the error code from event handler - 
                // there is not much we can do here anyway.
                //
                
                //
                // Note: pEvent is released by OnTapiEvent, so we should not
                // use it after OnTapiEvent returns
                //


            }

            break;

        default:

            //
            // we are not interested in any other messages
            //

            break;
        }


    } // while (GetMessage())


    CoUninitialize();

    LogMessage("CWorkerThread::ThreadFunction() exiting");

    return 0;

} // CWorkerThread::ThreadFunction
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\samples\mstsample\tapisend\common.h ===
/*

Copyright (c) 1999  Microsoft Corporation


Module Name:

    common.h


Abstract:

    include files and declarations used throughout the application

*/



#define _WIN32_DCOM


#include <stdio.h>
#include <windows.h>
#include <tapi3.h>

#include <vfw.h>
#include <crtdbg.h>

#include <uuids.h>
#include <Mtype.h>

#include <amstream.h>

#include <vfwmsgs.h>

#include <deque>



//
// logging functions
//

void LogMessage(CHAR *pszFormat, ... );

#define LogError LogMessage

void LogFormat(WAVEFORMATEX *pWaveFormat);


//
// memory allocation routines
//

void *AllocateMemory(SIZE_T nMemorySize);

void FreeMemory(void* pMemory);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\samples\mstsample\tapisend\avifilereader.cpp ===
/*

Copyright (c) 1999  Microsoft Corporation


Module Name:

    AVIFileReader.cpp


Abstract:

    Implementation of CAVIFileReader class
 
*/

#include "common.h"
#include "AVIFileReader.h"


///////////////////////////////////////////////////////////////////////////////
//
// CAVIFileReader::CAVIFileReader
//
///////////////////////////////////////////////////////////////////////////////

CAVIFileReader::CAVIFileReader()
    :m_pAudioStream(NULL),
    m_pWaveFormat(NULL),
    m_nSamplesReadSoFar(0)
{
    LogMessage("CAVIFileReader::CAVIFileReader");
}



///////////////////////////////////////////////////////////////////////////////
//
// CAVIFileReader::Initialize
//
// open the first audio stream contained in file pszFileName. 
// if successful, also get the stream's format
//
// if the file does not exist, is not valid, or does not contain
// any audio streams, subsequent calls to Read() will fail
//
///////////////////////////////////////////////////////////////////////////////

HRESULT CAVIFileReader::Initialize(IN char *pszFileName)
{

    HRESULT hr = S_OK;

    
    //
    // would do better argument checking in a real-life application
    //

    _ASSERTE(pszFileName);


    //
    // log file name and requested wave format
    //

    LogMessage("CAVIFileReader::Initialize started. file [%s]", 
                pszFileName);


    //
    // initialize avi file library. AVIFileExit should be called on the same 
    // thread when AVI library is no longer needed
    //
    // AVIFileExit is called in the destructor. 
    //
    // Assuption: instances of CAVIFileReader are initialized and destroyed on 
    // the same thread
    //
    
    AVIFileInit();

    
    //
    // open the first audio stream in the file
    //

    hr = AVIStreamOpenFromFile(&m_pAudioStream,
                               pszFileName,
                               streamtypeAUDIO,
                               0,
                               OF_READ | OF_SHARE_DENY_WRITE,
                               NULL);

    if (FAILED(hr))
    {
        LogError("CAVIFileReader::Initialize "
                 "Failed to open stream from the file");

        m_pAudioStream = NULL;

        return hr;
    }


    //
    // read the size of the stream's format
    //

    LONG nFormatSize = 0;

    hr = AVIStreamReadFormat(m_pAudioStream, 0, NULL, &nFormatSize);

    if ( FAILED(hr) || (0 == nFormatSize) )
    {
        LogError("CAVIFileReader::Initialize"
                 "Failed to get stream format's size");

        m_pAudioStream->Release();
        m_pAudioStream = NULL;

        return E_FAIL;
    }


    //
    // allocate memory for audio format. keep it in a waveformatex structure. 
    // if the structure returned is waveformat, still allocate waveformatex
    //

    nFormatSize = max(sizeof(WAVEFORMATEX), nFormatSize);
       
    m_pWaveFormat = (WAVEFORMATEX*)AllocateMemory(nFormatSize);

    if (NULL == m_pWaveFormat)
    {
        LogError("CAVIFileReader::Initialize "
                 "Failed to allocate memory for wave format, size %ld", 
                 nFormatSize);

        m_pAudioStream->Release();
        m_pAudioStream = NULL;

        return E_OUTOFMEMORY;

    }


    //
    // read stream format into allocated structure
    //

    hr = AVIStreamReadFormat(m_pAudioStream, 0, m_pWaveFormat, &nFormatSize);

    if (FAILED(hr))
    {
        LogError("CAVIFileReader::Initialize "
                 "Failed to read stream format");

        m_pAudioStream->Release();
        m_pAudioStream = NULL;

        FreeMemory(m_pWaveFormat);
        m_pWaveFormat = NULL;

        return hr;
    }


    //
    // log stream's format
    //

    LogMessage("CAVIFileReader::CAVIFileReader stream opened");
    LogFormat(m_pWaveFormat);


    LogMessage("CAVIFileReader::CAVIFileReader finished");

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//
// CAVIFileReader::~CAVIFileReader
//
// if we succeeded opening the stream, close it now.
//
///////////////////////////////////////////////////////////////////////////////

CAVIFileReader::~CAVIFileReader()
{
    LogMessage("CAVIFileReader::~CAVIFileReader started");

    if (NULL != m_pAudioStream)
    {
        AVIStreamRelease(m_pAudioStream);
        m_pAudioStream = NULL;
    }

    if (NULL != m_pWaveFormat)
    {
        FreeMemory(m_pWaveFormat);
        m_pWaveFormat = NULL;
    }


    //
    // AVIFileExit must be called on the same thread as AVIFileInit.
    // therefore this object must be created and deleted on the same thread
    //

    AVIFileExit();

    LogMessage("CAVIFileReader::~CAVIFileReader completed");
}


///////////////////////////////////////////////////////////////////////////////
//
// CAVIFileReader::Read
//
// read the open stream, at the current stream position, 
// into the supplied buffer of specified length. 
// return the number of bytes read
//
// returns: S_OK if succeded, S_FALSE if no more data, failure if failed.
// 
///////////////////////////////////////////////////////////////////////////////

HRESULT CAVIFileReader::Read( IN     BYTE *pBuffer,
                              IN     LONG nBufferSize, 
                              IN OUT LONG *pBytesRead)
{
    
    
    //
    // don't return garbage
    //

    *pBytesRead = 0;


    //
    // fail if the file is not open
    //

    if (NULL == m_pWaveFormat)
    {

        //
        // file is not open
        //

        LogError("CAVIFileReader::Read file is not open");

        return E_FAIL;
    }



    HRESULT hr = E_FAIL;


    //
    // read data into the user-supplied buffer, starting with the current 
    // stream position
    //
    
    LONG nSamplesRead = 0;
    
    hr = AVIStreamRead(m_pAudioStream, 
                        m_nSamplesReadSoFar, 
                        AVISTREAMREAD_CONVENIENT, 
                        pBuffer,
                        nBufferSize,
                        pBytesRead,
                        &nSamplesRead);

    if (FAILED(hr))
    {
        LogError("CAVIFileReader::Read AVIStreamRead failed");

        *pBytesRead = 0;

        return hr;
    }

    
    //
    // keep track of how many samples we have read, so we know where 
    // to start next time
    //

    m_nSamplesReadSoFar += nSamplesRead;

    if (*pBytesRead == 0)
    {
        LogMessage("CAVIFileReader::Read no more data in the file");

        return S_FALSE;
    }


    LogMessage("CAVIFileReader::Read read %ld bytes (%ld samples)", 
                *pBytesRead, nSamplesRead);

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//
// CAVIFileReader::GetFormat
//
// returns the wave format structure. the caller is responsible for 
// freeing the structure by calling FreeMemory()
// 
// returns S_OK if success or E_FAIL if the file failed to open
//
///////////////////////////////////////////////////////////////////////////////

HRESULT CAVIFileReader::GetFormat(OUT WAVEFORMATEX **ppWaveFormat)
{

    HRESULT hr = E_FAIL;


    //
    // don't return garbage
    //

    *ppWaveFormat = NULL;


    //
    // fail if the file is not open
    //

    if (NULL == m_pWaveFormat)
    {

        //
        // file is not open
        //

        LogError("CAVIFileReader::GetFormat file is not open");

        return E_FAIL;
    }


    //
    // allocate memory for wave format structure
    //

    WAVEFORMATEX *pWaveFormat = 
        (WAVEFORMATEX *)AllocateMemory( sizeof(WAVEFORMATEX) + 
                                m_pWaveFormat->cbSize);

    if (NULL == pWaveFormat)
    {

        LogError("CAVIFileReader::GetFormat "
                 "failed to allocate memory for wave format structure");

        return E_OUTOFMEMORY;
    }

    
    //
    // copy wave format structure into allocated memory
    //

    CopyMemory(pWaveFormat,
               m_pWaveFormat,
               sizeof(WAVEFORMATEX) + m_pWaveFormat->cbSize);

    *ppWaveFormat = pWaveFormat;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\samples\mstsample\tapisend\avifilereader.h ===
/*

Copyright (c) 1999  Microsoft Corporation


Module Name:

    AVIFileReader.h


Abstract:

    Declaration for the AVIFileReader class. 

*/

#if !defined(AFX_AVIFILEREADER_H__6AC8BC7B_287D_452A_98BF_1C2B69277AB3__INCLUDED_)
#define AFX_AVIFILEREADER_H__6AC8BC7B_287D_452A_98BF_1C2B69277AB3__INCLUDED_


//
// an abstraction for a media file open for reading
//

class CAVIFileReader  
{

public:

    
    //
    // open stream
    //

    HRESULT Initialize(char *pszFileName);


    //
    // constructor
    //

    CAVIFileReader();


    //
    // close stream
    //

	virtual ~CAVIFileReader();

    
    //
    // read stream data into buffer
    //

    HRESULT Read(BYTE *pBuffer, LONG nBufferSize, LONG *pBytesWritten);

    
    //
    // returns waveformat for the open file. the caller must free 
    // returned memory
    //
    
    HRESULT GetFormat(WAVEFORMATEX **ppWaveFormat);


    //
    // return TRUE if the file was opened and is a valid wave file containing 
    // an audio stream
    //

    BOOL IsValidAudioFile()
    {

        //
        // if we know stream's format, chances are this is a valid audio file
        //

        if (NULL == m_pWaveFormat)
        {
            return FALSE;
        }
        else
        {
            return TRUE;
        }
    }


private:

    
    //
    // audio stream
    //
    
    PAVISTREAM  m_pAudioStream;

    
    //
    // format of the audio stream
    //

    WAVEFORMATEX *m_pWaveFormat;


    //
    // number of samples read so far. we use it to determine the current
    // position in the stream
    //

    LONG m_nSamplesReadSoFar;

};


#endif // !defined(AFX_AVIFILEREADER_H__6AC8BC7B_287D_452A_98BF_1C2B69277AB3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\samples\mstsample\tapisend\tapisend.cpp ===
/*

Copyright (c) 1999  Microsoft Corporation


Module Name:

    TAPISend.cpp


Abstract:

    This sample illustrates use of Media Streaming Terminal for sending audio.

    The application makes a TAPI call to the address specified in the command 
    line and uses Media Streaming Terminal to send the media content of a wav 
    file, also specified in the command line, to the remote machibe.
 
*/


#include "common.h"
#include "avifilereader.h"


//
// global TAPI object
//

ITTAPI *g_pTapi = NULL;


//
// a global flag, set true to request stop streaming
//

BOOL g_bExitRequested = FALSE;


//
// possible address types strings and corresponding LINEADDRESSTYPE_ constants
//

char *g_szAddressTypes[] = 
            {"PHONENUMBER", "CONFERENCE", "EMAIL", "MACHINE", "IP"};


long g_nAddressTypeConstants[] = 
            { LINEADDRESSTYPE_PHONENUMBER,
              LINEADDRESSTYPE_SDP,
              LINEADDRESSTYPE_EMAILNAME,
              LINEADDRESSTYPE_DOMAINNAME,
              LINEADDRESSTYPE_IPADDRESS };

//
// number of different address types
//

const UINT g_nNumberOfAddressTypes = 
                    sizeof(g_szAddressTypes)/sizeof(g_szAddressTypes[0]);


///////////////////////////////////////////////////////////////////////////////
// 
// LogMessage
//
//
// log a message using printf
//
///////////////////////////////////////////////////////////////////////////////

void LogMessage(IN CHAR *pszFormat, ... )
{
    
    //
    // output buffer -- note: hardcoded limit
    //

    char szBuffer[1280]; 


    //
    // get current time
    //

    SYSTEMTIME SystemTime;

    GetLocalTime(&SystemTime);

    
    //
    // format thread id and time
    //

    sprintf( szBuffer, "[%lx]:[%02u:%02u:%02u.%03u]::",
             GetCurrentThreadId(),
             SystemTime.wHour,
             SystemTime.wMinute,
             SystemTime.wSecond,
             SystemTime.wMilliseconds);


    //
    // get the actual message
    //

    va_list vaArguments;

    va_start(vaArguments, pszFormat);
    vsprintf(&(szBuffer[strlen(szBuffer)]), pszFormat, vaArguments);
    va_end(vaArguments);


    //
    // log the buffer with the terminating carriage return
    //

    strcat(szBuffer, "\n");

    printf(szBuffer);
}


#define LogError LogMessage


///////////////////////////////////////////////////////////////////////////////
// 
// LogFormat
//
// use LogMessage to log wave format
//
///////////////////////////////////////////////////////////////////////////////

void LogFormat(IN WAVEFORMATEX *pWaveFormat)
{
    LogMessage("    Format: ");
    LogMessage("        tag: %u", pWaveFormat->wFormatTag);
    LogMessage("        channels: %u", pWaveFormat->nChannels);
    LogMessage("        samples/sec: %lu", pWaveFormat->nSamplesPerSec);
    LogMessage("        align: %u", pWaveFormat->nBlockAlign);
    LogMessage("        bits/sample: %u", pWaveFormat->wBitsPerSample);

}


///////////////////////////////////////////////////////////////////////////////
//
// AllocateMemory
//
// use win32 heap api to allocate memory on the application's heap
// and zero the allocated memory
//
///////////////////////////////////////////////////////////////////////////////

void *AllocateMemory(SIZE_T nMemorySize)
{
    

    //
    // use HeapAlloc to allocate and clear memory
    //

    return HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, nMemorySize);
}


///////////////////////////////////////////////////////////////////////////////
//
// FreeMemory
//
// use win32 heap api to free memory previously allocated on the application's
// heap
//
///////////////////////////////////////////////////////////////////////////////

void FreeMemory(void *pMemory)
{
    
    //
    // get size of the allocated memory
    //

    DWORD nMemorySize = HeapSize(GetProcessHeap(), 0, pMemory);

    if (-1 == nMemorySize)
    {
        LogError("FreeMemory: failed to get size of the memory block %p",
                 pMemory);

        //
        // don't exit -- try freeing anyway
        //

    }
    else
    {
        //
        // fill memory with 0xdd's before freeing, so it is easier to debug 
        // failures caused by using pointer to deallocated memory
        //
        
        if (0 != pMemory)
        {
            FillMemory(pMemory, nMemorySize, 0xdd);
        }

    }


    //
    // use HeapFree to free memory. use return code to log the result, but
    // do not return it to the caller
    //
    
    BOOL bFreeSuccess = HeapFree(GetProcessHeap(), 0, pMemory);

    if (FALSE == bFreeSuccess)
    {
        LogError("FreeMemory: HeapFree failed");

        //
        // if this assertion fires, it is likely there is a problem with the 
        // memory we are trying to deallocate. Was it allocated using heapalloc
        // and on the same heap? Is this a valid pointer?
        //

        _ASSERTE(FALSE);
    }

}


///////////////////////////////////////////////////////////////////////////////
// 
// InitializeTAPI()
//
// create and initialize the TAPI object
//
///////////////////////////////////////////////////////////////////////////////

HRESULT InitializeTAPI()
{
    
    HRESULT hr = E_FAIL;

    LogMessage("InitializeTAPI: started");
    
    
    //
    // create the TAPI object
    //

    hr = CoCreateInstance(
                          CLSID_TAPI,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_ITTAPI,
                          (LPVOID *)&g_pTapi
                         );

    if (FAILED(hr))
    {
        LogError("InitializeTAPI: CoCreateInstance on TAPI failed");

        return hr;
    }

    
    //
    // must initialize tapi object before using it
    //
    
    LogMessage("InitializeTAPI: calling ITTAPI::Initialize()");

    hr = g_pTapi->Initialize();

    if (FAILED(hr))
    {
        LogError("InitializeTAPI: TAPI failed to initialize");

        g_pTapi->Release();
        g_pTapi = NULL;
        
        return hr;
    }

    
    //
    // setting event filtering -- this is required for synchronous 
    // ITBasicCallControl->Connect to work
    //
    
    LogMessage("InitializeTAPI: calling ITTAPI::put_EventFilter()");

    hr = g_pTapi->put_EventFilter(TE_CALLSTATE);

    if (FAILED(hr))
    {
        LogError("InitializeTAPI: TAPI failed to put event filtering");

        g_pTapi->Shutdown();

        g_pTapi->Release();
        g_pTapi = NULL;
        
        return hr;
    }


    
    LogMessage("InitializeTAPI: succeeded");
    
    return S_OK;
}



///////////////////////////////////////////////////////////////////////////////
// 
// ShutdownTAPI
//
// shutdown and release the tapi object
// 
///////////////////////////////////////////////////////////////////////////////

void ShutdownTAPI()
{
    
    LogMessage("ShutdownTAPI: started");


    if (NULL != g_pTapi)
    {
        
        g_pTapi->Shutdown();
        
        g_pTapi->Release();
        g_pTapi = NULL;
    }

    
    LogMessage("ShutdownTAPI: completed");

}


///////////////////////////////////////////////////////////////////////////////
//
//  IsValidAudioFile
//
// returns TRUE if the file specified by pszFileName 
// exists and is a valid audio file
//
///////////////////////////////////////////////////////////////////////////////

BOOL IsValidAudioFile(IN char *pszFileName)
{

    //
    // open the file
    //
    
    CAVIFileReader FileReader;

    HRESULT hr = FileReader.Initialize(pszFileName);


    //
    // see if it is a valid audio file
    //

    if ((FAILED(hr)) || !FileReader.IsValidAudioFile())
    {
        LogError("IsValidAudioFile: file [%s] does not exist or is not "
                 "a valid wav file", pszFileName);

        return FALSE;
    }
    else
    {
        LogMessage("IsValidAudioFile: file [%s] is a valid audio file", 
                    pszFileName);

        return TRUE;
    }

}


///////////////////////////////////////////////////////////////////////////////
//
// FindAddress
//
// find an address of the requested type that supports audio. returns S_OK 
// if address found, failure otherwise
//
///////////////////////////////////////////////////////////////////////////////

HRESULT FindAddress(IN  long nAddressType,
                    OUT ITAddress **ppAddress)
{

    HRESULT hr = E_FAIL;


    //
    // don't return garbage even if we fail
    //
    
    *ppAddress = NULL;


    //
    // enumerate all available addresses
    //

    IEnumAddress *pEnumAddress = NULL;
    
    hr = g_pTapi->EnumerateAddresses(&pEnumAddress);
    
    if (FAILED(hr))
    {
        LogError("FindAddress: Failed to enumerate addresses");

        return hr;
    }


    //
    // walk through the enumeration of addresses and look for those which are
    // of requested type and supports audio 
    //

    while (TRUE)
    {
        //        
        // get the next address from the enumeration
        // 

        ITAddress *pAddress = NULL;

        hr = pEnumAddress->Next( 1, &pAddress, NULL );

        if (S_OK != hr)
        {

            //
            // no more addresses
            //

            LogMessage("FindAddress: no more addresses");

            break;
        }
        

        //
        // we got an address. check its capabilities
        //
        
        ITAddressCapabilities *pAddressCaps = NULL;

        hr = pAddress->QueryInterface( IID_ITAddressCapabilities, 
                                       (void**)&pAddressCaps );

        if (FAILED(hr))
        {

            LogError("FindAddress: "
                     "Failed to QI address for address capabilities");

            //
            // just continue to the next address
            // 

            pAddress->Release();
            pAddress = NULL;

            continue;
        }


        //
        // is this the right address type?
        //
    
        long nType = 0;

        hr = pAddressCaps->get_AddressCapability(AC_ADDRESSTYPES, &nType);
 

        pAddressCaps->Release();
        pAddressCaps = NULL;


        if (FAILED(hr))
        {
            LogError("FindAddress: Failed to get_AddressCapability");

            pAddress->Release();
            pAddress = NULL;

            continue;
        }


        if (nType & nAddressType)
        {
            
            //
            // this address is of the right type. does it support audio?
            //

            ITMediaSupport *pMediaSupport = NULL;

            hr = pAddress->QueryInterface(IID_ITMediaSupport,
                                           (void **)&pMediaSupport);

            if (FAILED(hr))
            {

                //
                // continue to the next address
                //

                LogError("FindAddress: "
                         "failed to qi address for ITMediaSupport");

                pAddress->Release();
                pAddress = NULL;

                continue;
            }

            
            VARIANT_BOOL bAudioSupported = VARIANT_FALSE;

            hr = pMediaSupport->QueryMediaType(TAPIMEDIATYPE_AUDIO, 
                                               &bAudioSupported);

            pMediaSupport->Release();
            pMediaSupport = NULL;
            
            if (SUCCEEDED(hr) && (VARIANT_TRUE == bAudioSupported))
            {

                LogMessage("FindAddress: address found");


                //
                // log the name of this address
                //
                
                BSTR bstrAddressName = NULL;
                
                hr = pAddress->get_AddressName(&bstrAddressName);

                if (FAILED(hr))
                {
                    LogError("FindAddress: failed to get address name");
                }
                else
                {
                    LogMessage("   %S\n", bstrAddressName);
                }

                SysFreeString(bstrAddressName);


                //
                // will use this address
                //

                *ppAddress = pAddress;

                break;;
            }
        }


        //
        // can't use this address. release it
        //

        pAddress->Release();
        pAddress = NULL;

    }

    
    //
    // done with the enumeration. release.
    //

    pEnumAddress->Release();
    pEnumAddress = NULL;


    //
    // log a message if no address was found
    //

    if (NULL == *ppAddress)
    {
        LogError("FindAddress: no address found");

        return E_FAIL;

    }


    LogMessage("FindAddress: completed");

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//
// GetAddressType
//
// convert a address type specified by pszRequestedAddressType
// to tapi LINEADDRESSTYPE_ constants (LINEADDRESSTYPE_PHONENUMBER,
// LINEADDRESSTYPE_IPADDRESS, etc).
//
// returns E_FAIL if the string does not correspond to a valid address type
//
///////////////////////////////////////////////////////////////////////////////

HRESULT GetAddressType(IN char *pszRequestedAddressType, 
                       IN OUT long *pnAddressType)
{
    
    //
    // match address type specified by the user to one of the known
    // address types
    //

    *pnAddressType = 0;


    for (int i = 0; i < g_nNumberOfAddressTypes; i++)
    {

        if (0 == _stricmp(g_szAddressTypes[i], pszRequestedAddressType))
        {
            
            //
            // get the address type constant corresponding to the string
            //

            *pnAddressType =  g_nAddressTypeConstants[i];

            LogMessage("GetAddressType: "
                       "matched address type [%s] to address type [%d]", 
                       pszRequestedAddressType, *pnAddressType);

            return S_OK;
        }


    }

    LogError("GetAddressType: unrecognized address type [%s]", 
              pszRequestedAddressType);

    return E_FAIL;
}



///////////////////////////////////////////////////////////////////////////////
//
// CreateBSTRfromString
// 
// create a bstr from a string supplied. the caller is responsible for
// freeng the returned string by calling SysFreeString. 
//
// returns the allocated string or NULL if failed.
//
///////////////////////////////////////////////////////////////////////////////

BSTR CreateBSTRfromString(IN char *pszString)
{

    //
    // convert to wchar so we can create bstr
    //
    // allocate buffer for resulting string of wchars
    //
    
    size_t nStringLength = strlen(pszString) + 1;

    WCHAR *pwsString = (WCHAR *)AllocateMemory(sizeof(WCHAR) *  nStringLength);

    if (NULL == pwsString)
    {
        LogError("CreateBSTRfromString: "
                 "failed to allocate memory for address string.");

        return NULL;
    }


    //
    // convert to wchar
    //

    int rc = MultiByteToWideChar(CP_ACP, 
                                 0, 
                                 pszString, 
                                 -1, 
                                 pwsString, 
                                 nStringLength);

    if (0 == rc)
    {
        LogError("CreateBSTRfromString: Failed to convert char to wchar");

        FreeMemory(pwsString);
        pwsString = NULL;

        return NULL;
    }


    //
    // create bstr
    //

    BSTR bstr = SysAllocString(pwsString);


    //
    // no longer needed, deallocate
    //

    FreeMemory(pwsString);
    pwsString = NULL;

    return bstr;

}


///////////////////////////////////////////////////////////////////////////////
//
// CreateAndConnectCall
//
// make a call using the address object specified, to the address specified
//
// if successful, returns S_OK and connected call, error otherwise
//
///////////////////////////////////////////////////////////////////////////////

HRESULT CreateAndConnectCall(IN  ITAddress *pAddress,
                             IN  char *pszDestinationAddress,
                             IN  long nAddressType,
                             OUT ITBasicCallControl **ppCall)
{

    HRESULT hr = E_FAIL;

    
    //
    // don't return garbage
    //

    *ppCall = NULL;


    //
    // create a call on the address
    //

    BSTR bstrDestinationAddress = CreateBSTRfromString(pszDestinationAddress);
    
    ITBasicCallControl *pCall = NULL;

    hr = pAddress->CreateCall(bstrDestinationAddress,
                              nAddressType,
                              TAPIMEDIATYPE_AUDIO,
                              &pCall);

    SysFreeString (bstrDestinationAddress);


    if (FAILED(hr))
    {
        LogError("CreateAndConnectCall: Failed to create a call");

        return hr;
    }


    //
    // call created. attempt to connect synchronously
    //

    LogMessage("CreateAndConnectCall: attempting a synchronous connect");

    hr = pCall->Connect(VARIANT_TRUE);

    if (S_OK != hr)
    {

        LogError("CreateAndConnectCall: failed to connect, hr = 0x%lx", hr);


        pCall->Disconnect(DC_NORMAL);


        //
        // we don't need the call object if it failed to connect
        //

        pCall->Release();
        pCall = NULL;

        hr = E_FAIL;

    }
    else
    {
        //
        // call is successful. return the call object
        //

        LogMessage("CreateAndConnectCall: call connected successfully");

        *ppCall = pCall;
    }


    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
// Call
//
// make a call to the specified address on the first address object
// of the requested type that supports audio
//
// if successful, returns S_OK and connected call, error otherwise
// 
///////////////////////////////////////////////////////////////////////////////

HRESULT Call(IN char *szDestinationAddress,
             IN char *szAddressType,
             OUT ITBasicCallControl **ppCall)
{
    HRESULT hr = E_FAIL;

    
    //
    // we don't want to return garbage even if we fail
    //

    *ppCall = NULL;


    //
    // find address type
    //

    long nAddressType = 0;
    
    hr = GetAddressType(szAddressType, &nAddressType);

    if (FAILED(hr))
    {
        LogError("Call: failed to recognize address type %s", szAddressType);

        return hr;
    }

    
    //
    // find an address for this address type that supports audio
    //
    
    ITAddress *pAddress = NULL;

    hr = FindAddress(nAddressType, &pAddress);

    if (FAILED(hr))
    {
        LogError("Call: failed to find an address with audio for type %s", 
                 szAddressType);

        return hr;
    }


    //
    // have the address. create and connect call
    //

    ITBasicCallControl *pCall = NULL;

    hr = CreateAndConnectCall(pAddress,
                              szDestinationAddress,
                              nAddressType,
                              &pCall);

    pAddress->Release();
    pAddress = NULL;
    
    if (FAILED(hr))
    {
        LogError("Call: Failed to create and connect call");

        return hr;
    }


    //
    // we have a connected call. return it.
    //

    *ppCall = pCall;

    LogMessage("Call: succeeded.");

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//
// FindAudioStream
// 
// given a call, return the first outgoing audio stream.
//
// returns S_OK if successful, error otherwise
//
///////////////////////////////////////////////////////////////////////////////

HRESULT FindAudioStream( IN  ITBasicCallControl *pCall, 
                         OUT ITStream **ppStream)
{
    
    HRESULT hr = E_FAIL;
    
    LogMessage("FindAudioStream: started");


    //
    // don't return garbage
    //

    *ppStream = NULL;


    //
    // enumerate streams on the call
    //



    //
    // get the ITStreamControl interface for this call
    //

    ITStreamControl *pStreamControl = NULL;

    hr = pCall->QueryInterface(IID_ITStreamControl,
                                (void **) &pStreamControl);

    if (FAILED(hr))
    {
        LogError("FindAudioStream: failed to QI call for ITStreamControl");

        return hr;
    }


    //
    // enumerate the streams
    //

    IEnumStream *pEnumStreams = NULL;
    
    hr = pStreamControl->EnumerateStreams(&pEnumStreams);
    
    pStreamControl->Release();
    pStreamControl = NULL;

    if (FAILED(hr))
    {
        LogError("CreateAndSelectMST: failed to enumerate streams on call");
        
        return hr;
    }

    
    //
    // walk through the streams on the call
    // return the first outgoing audio stream
    //
  
    while (TRUE)
    {
        ITStream *pStream = NULL;

        hr = pEnumStreams->Next(1, &pStream, NULL);

        if (S_OK != hr)
        {
            //
            // no more streams
            //

            break;
        }


        //
        // check the stream's direction
        //

        TERMINAL_DIRECTION td;

        hr = pStream->get_Direction(&td);

        if (FAILED(hr))
        {
            LogError("CreateAndSelectMST: Failed to get stream direction");
            
            pStream->Release();
            pStream = NULL;
            

            //
            // proceed to the next stream, if any
            //

            continue;
        }


        //
        // is the stream of the right direction?
        //

        if (TD_CAPTURE != td)
        {

            //
            // incoming stream. we need outgoing. 
            // release the stream and continue
            // 

            pStream->Release();
            pStream = NULL;

            continue;
        }


        //
        // check the stream's media type
        //

        long lMediaType = 0;

        hr = pStream->get_MediaType(&lMediaType);

        if (FAILED(hr))
        {
            LogError("CreateAndSelectMST: Failed to get media type");

            pStream->Release();
            pStream = NULL;
            
            continue;
        }

        //
        // Does this stream have the right media type?
        // Streams are defined as having exactly one media type
        // (not a bitmask).
        //

        if ( lMediaType == TAPIMEDIATYPE_AUDIO )
        {

            LogMessage("FindAudioStream: stream found");


            //
            // this is what we need, so stop looking
            //

            *ppStream = pStream;

            break;
        }


        pStream->Release();
        pStream = NULL;

    } // while (walking through the call's streams)



    //
    // release stream enumeration
    //

    pEnumStreams->Release();
    pEnumStreams = NULL;


    //
    // return the error code, depending on whether we found a stream or not
    //

    if (NULL == *ppStream)
    {
        LogMessage("FindAudioStream: didn't find an audio stream");

        return E_FAIL;
    }

    LogMessage("FindAudioStream: succeded");

    return S_OK;

}


///////////////////////////////////////////////////////////////////////////////
//
// CreateCaptureMediaStreamingTerminal
//
// create media streaming terminal for outgoing data
//
// returns the created terminal or NULL if failed
//
///////////////////////////////////////////////////////////////////////////////

ITTerminal *CreateCaptureMediaStreamingTerminal(IN ITBasicCallControl *pCall)
{
    
    HRESULT hr = E_FAIL;


    //
    // get the call's call info so we can get the call's address 
    //

    ITCallInfo *pCallInfo = NULL;

    hr = pCall->QueryInterface(IID_ITCallInfo, (void**)&pCallInfo);

    if (FAILED(hr))
    {
        LogError("CreateCaptureMediaStreamingTerminal: "
                 "failed to qi call for ITCallInfo");

        return NULL;
    }


    //
    // now we can get the address
    //

    ITAddress *pAddress = NULL;

    hr = pCallInfo->get_Address(&pAddress);
    
    pCallInfo->Release();
    pCallInfo = NULL;

    if (FAILED(hr))
    {
        LogError("CreateCaptureMediaStreamingTerminal: "
                 "failed to get call's address");
        return NULL;
    }

    
    //
    // get the terminal support interface
    //

    ITTerminalSupport *pTerminalSupport = NULL;

    hr = pAddress->QueryInterface( IID_ITTerminalSupport, 
                                   (void **)&pTerminalSupport );

    
    pAddress->Release();
    pAddress = NULL;


    if (FAILED(hr))
    {
        LogError("CreateCaptureMediaStreamingTerminal: "
                 "failed to QI pAddress for ITTerminalSupport");

        return NULL;
    }

    
    //
    // get string for the terminal's class id
    //

    LPOLESTR psTerminalClass = NULL;

    hr = StringFromIID(CLSID_MediaStreamTerminal, &psTerminalClass);

    if (FAILED(hr))
    {
        LogError("CreateCaptureMediaStreamingTerminal: "
                 "Failed to generate string from terminal's class id");

        pTerminalSupport->Release();
        pTerminalSupport = NULL;

        return NULL;
    }


    //
    // make bstr out of the class id
    //

    BSTR bstrTerminalClass = SysAllocString (psTerminalClass);


    //
    // free the string returned by StringFromIID
    //

    CoTaskMemFree(psTerminalClass);
    psTerminalClass = NULL;


    if (NULL == bstrTerminalClass)
    {

        LogError("CreateCaptureMediaStreamingTerminal: "
                 "Failed to allocate BSTR for terminal class");

        pTerminalSupport->Release();
        pTerminalSupport = NULL;

        return NULL;
    }

    

    //
    // create media streaming terminal
    //
    
    ITTerminal *pTerminal = NULL;

    hr = pTerminalSupport->CreateTerminal(bstrTerminalClass,
                                          TAPIMEDIATYPE_AUDIO,
                                          TD_CAPTURE,
                                          &pTerminal);

    
    //
    // release resources no longer needed
    //

    SysFreeString(bstrTerminalClass);

    pTerminalSupport->Release();
    pTerminalSupport = NULL;


    if (FAILED(hr))
    {
        LogError("CreateCaptureMediaStreamingTerminal: "
                 "failed to create media streaming terminal hr = 0x%lx", hr);

        return NULL;
    }


    //
    // successfully created media streaming terminal. return.
    //

    LogMessage("CreateCaptureMediaStreamingTerminal: "
               "Terminal created successfully");

    return pTerminal;

}



///////////////////////////////////////////////////////////////////////////////
//
// SetTerminalFormat
//
// tell media streaming terminal the format of the data we are going to provide
//
///////////////////////////////////////////////////////////////////////////////

HRESULT SetTerminalFormat(IN ITTerminal *pTerminal, 
                          IN WAVEFORMATEX *pWaveFormat)
{

    HRESULT hr = E_FAIL;


    //
    // log format requested
    //

    LogMessage("SetTerminalFormat: starting.");
    LogFormat(pWaveFormat);

    
    ITAMMediaFormat *pIMediaFormat = NULL;
    
    hr = pTerminal->QueryInterface(IID_ITAMMediaFormat, 
                                   (void **)&pIMediaFormat);

    if (FAILED(hr)) 
    { 
    
        LogError("SetTerminalFormat: Failed to set terminal format");

        return hr; 
    }


    //
    // fill the media format structure 
    //

    AM_MEDIA_TYPE MediaType;

    ZeroMemory(&MediaType, sizeof(AM_MEDIA_TYPE));

    MediaType.majortype            = MEDIATYPE_Audio;
    MediaType.subtype              = MEDIASUBTYPE_PCM;
    MediaType.bFixedSizeSamples    = TRUE;
    MediaType.bTemporalCompression = FALSE;
    MediaType.lSampleSize          = pWaveFormat->nBlockAlign;
    MediaType.formattype           = FORMAT_WaveFormatEx;
    MediaType.pUnk                 = NULL;

    MediaType.cbFormat             = sizeof(WAVEFORMATEX) + 
                                     pWaveFormat->cbSize;

    MediaType.pbFormat             = (BYTE*)pWaveFormat;

    
    //
    // set the requested format 
    //

    hr = pIMediaFormat->put_MediaFormat(&MediaType);
    
    if (FAILED(hr))
    {

        //
        // try to see what format the terminal wanted
        //

        LogError("SetTerminalFormat: failed to set format");

        AM_MEDIA_TYPE *pMediaFormat = NULL;

        HRESULT hr2 = pIMediaFormat->get_MediaFormat(&pMediaFormat);


        if (SUCCEEDED(hr2))
        {

            if (pMediaFormat->formattype == FORMAT_WaveFormatEx)
            {

                //
                // log the terminal's format
                //

                LogError("SetTerminalFormat: terminal's format is");
                LogFormat((WAVEFORMATEX*) pMediaFormat->pbFormat);

            }
            else 
            {

                LogError("SetTerminalFormat: "
                         "terminal's format is not WAVEFORMATEX");
            }


            //
            // note: we are responsible for deallocating the format returned by
            // get_MediaFormat
            //

            DeleteMediaType(pMediaFormat);

        } //  succeeded to get terminal's format
        else
        {

            LogError("SetTerminalFormat: failed to get terminal's format");

        }

    } // failed to set format


    pIMediaFormat->Release();
    pIMediaFormat = NULL;

    LogMessage("SetTerminalFormat: completed");
    
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
// SetAllocatorProperties
//
// sets allocator properties to the terminal
//
///////////////////////////////////////////////////////////////////////////////

HRESULT SetAllocatorProperties(IN ITTerminal *pTerminal)
{

    //
    // different buffer sizes may produce different sound quality, depending
    // on the underlying transport that is being used.
    // 
    // this function illustrates how an app can control the number and size of
    // buffers. A multiple of 30 ms (480 bytes at 16-bit 8 KHz PCM) is the most
    // appropriate sample size for IP (especailly G.723.1).
    //
    // However, small buffers can cause poor audio quality on some voice boards.
    //
    // If this method is not called, the allocator properties suggested by the 
    // connecting filter will be used.
    //
    // Note: do not set allocator properties in the applications unless you are
    // sure that sound quality will not degrade as a result. Some MSPs can have
    // their own preferred allocator properties, and will not be able to 
    // provide the best quality if the app sets its own properties, different 
    // from what is preferred by the msp.
    //
    // Also note that ITAllocatorProperties::SetBufferSize allows the app to
    // specify preferred size of the buffer allocated to the application 
    // without affecting terminal's allocator properties.
    //
    
    LogMessage("SetAllocatorProperties: starting.");


    HRESULT hr = E_FAIL;


    //
    // get ITAllocator properties interface on the terminal
    //

    ITAllocatorProperties *pITAllocatorProperties = NULL;


    hr = pTerminal->QueryInterface(IID_ITAllocatorProperties, 
                                   (void **)&pITAllocatorProperties);


    if (FAILED(hr))
    {
        LogError("SetAllocatorProperties: "
                 "failed to QI terminal for ITAllocatorProperties");

        return hr;
    }

    
    //
    // configure allocator properties
    //

    ALLOCATOR_PROPERTIES AllocProps;
    
    AllocProps.cbBuffer   = 4800;
    AllocProps.cBuffers   = 5;
    AllocProps.cbAlign    = 1;
    AllocProps.cbPrefix   = 0;

    
    hr = pITAllocatorProperties->SetAllocatorProperties(&AllocProps);

    if (FAILED(hr))
    {
        LogError("SetAllocatorProperties: failed to set allocator properties. "
                 "hr = 0x%lx", hr);

        pITAllocatorProperties->Release();
        pITAllocatorProperties = NULL;

        return hr;
    }

    
    //
    // ask media streaming terminal to allocate buffers for us. 
    // TRUE is the default, so strictly speaking, we didn't have to call 
    // this method.
    //

    hr = pITAllocatorProperties->SetAllocateBuffers(TRUE);


    pITAllocatorProperties->Release();
    pITAllocatorProperties = NULL;

    
    if (FAILED(hr))
    {
        LogError("SetAllocatorProperties: failed to SetAllocateBuffers, "
                 "hr = 0x%lx", hr);

        return hr;
    }


    //
    // succeeded setting allocator properties
    //

    LogMessage("SetAllocatorProperties: completed");

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//
// ReadFileIntoTerminal
//
// read data from the file and submit it to media streaming terminal
// 
// exit when finished reading the file, user requested exit by pressing 
// ctrl+break, or the connection broke
//
// returns S_FALSE when finished streaming the file, S_OK if user requested 
// exit, failure otherwise
//
///////////////////////////////////////////////////////////////////////////////

HRESULT ReadFileIntoTerminal(IN CAVIFileReader *pFileReader, 
                             IN ITTerminal *pPlaybackTerminal)
{

    HRESULT hr = E_FAIL;

    LogMessage("ReadFileIntoTerminal: started.");


    Sleep(20000);


    //
    // get terminal's IMediaStream interface
    //

    IMediaStream *pTerminalMediaStream = NULL;

    hr = pPlaybackTerminal->QueryInterface(IID_IMediaStream, 
                                           (void**)&pTerminalMediaStream);

    if (FAILED(hr))
    {
        LogError("ReadFileIntoTerminal: "
                 "failed to QI terminal for IMediaStream");

        return hr;
    }

    
    //
    // create a queue (STL deque) that will hold all the samples that we ever 
    // submitted to media streaming terminal
    //
    // we need this so when we are finished reading the file, we can go through 
    // the list of all the samples that we have submitted and make sure mst 
    // is finished processing them
    //
    // note that samples get reused, the same samples will be put in the queue 
    // more than once. so the size of the queue will be proportional to the 
    // size of the file being played. this might cause problems if
    // the file is big or the source of the samples is unlimited (live audio
    // feed). In this case, the logic can be modified to only enqueue each
    // sample once, by comparing against existing queue entries.
    // 
    
    std::deque<IStreamSample*> SampleQ;


    //
    // count the number of samples that have been submitted
    //

    ULONG nSampleCount = 0;

    
    //
    // keep reading samples from file and sending them.
    // (until user requests exit, there is no more data, or failure)
    //

    while (!g_bExitRequested)
    {
       
        //
        // allocate a sample on the terminal's media stream
        //
        // Note: the call to AllocateSample() will block if we filled all the 
        // samples with data, and there are no more samples for us to fill 
        // (waiting for media streaming terminal to process samples we have
        // submitted). When MST is is done with at least one sample, the call 
        // will return. This logic will ensure that MST always has work and is
        // never starved for samples.
        //

        IStreamSample *pStreamSample = NULL;

        hr = pTerminalMediaStream->AllocateSample(0, &pStreamSample);

        if (FAILED(hr))
        {
            LogError("ReadFileIntoTerminal: "
                     "failed to allocate a sample on terminal's stream");

            break;
        }


        //
        // get IMemoryData on the sample so we can get to the sample's memory 
        // data
        //

        IMemoryData *pSampleMemoryData = NULL;

        hr = pStreamSample->QueryInterface(IID_IMemoryData, 
                                           (void**)&pSampleMemoryData);

        if (FAILED(hr))
        {
            LogError("ReadFileIntoTerminal: failed to qi sample for IMemoryData");

            pStreamSample->Release();
            pStreamSample = NULL;

            break;

        }


        //
        // get to the sample's memory buffer
        //

        DWORD nBufferSize = 0;

        BYTE *pBuffer = NULL;

        hr = pSampleMemoryData->GetInfo(&nBufferSize, &pBuffer, NULL);

        if (FAILED(hr))
        {

            LogError("ReadFileIntoTerminal: "
                     "failed to get info on sample's memory");

            pStreamSample->Release();
            pStreamSample = NULL;

            pSampleMemoryData->Release();
            pSampleMemoryData = NULL;

            break;

        }


        //
        // read file into memory buffer provided by the sample
        //

        LONG nBytesRead = 0;
        
        hr = pFileReader->Read(pBuffer, nBufferSize, &nBytesRead);

        if (FAILED(hr))
        {
            LogError("ReadFileIntoTerminal: failed to read data from file");

            pStreamSample->Release();
            pStreamSample = NULL;

            pSampleMemoryData->Release();
            pSampleMemoryData = NULL;

            break;

        }
        else if (S_FALSE == hr)
        {
            //
            // no more data
            //

            LogMessage("ReadFileIntoTerminal: finished reading file");

            pStreamSample->Release();
            pStreamSample = NULL;

            pSampleMemoryData->Release();
            pSampleMemoryData = NULL;

            break;
        }


        
        //
        // tell the sample how many useful bytes are in the sample's buffer
        //
        
        hr = pSampleMemoryData->SetActual(nBytesRead);

        pSampleMemoryData->Release();
        pSampleMemoryData = NULL;

        if (FAILED(hr))
        {

            LogError("ReadFileIntoTerminal: failed to SetActual (%ld bytes) "
                     "on the sample.", nBytesRead);

            pStreamSample->Release();
            pStreamSample = NULL;

            break;

        }

        
        //
        // we are done with the sample. now let media streaming terminal 
        // process it asynchronously. when the terminal is finished with 
        // the sample, this sample will be returned to us from the call 
        // to AllocateSample()
        //

        hr = pStreamSample->Update(SSUPDATE_ASYNC, NULL, NULL, 0);


        //
        // with some MSPs, starting the stream can be done asynchronously, so
        // there may be a delay between the time when terminal is selected
        // (or call connected) and the time when the stream becomes usable.
        //
        // attempting to use the stream before the stream is active would
        // result in the Update() returning error VFW_E_NOT_COMMITTED.
        //
        // Usually an application would not start using the stream until 
        // it gets media event CME_STREAM_ACTIVE. This requires the app
        // to register a callback interface by calling 
        // ITTAPI::RegisterCallNotifications. Refer to documentation and other 
        // samples for more details on how this is done.
        //
        // To keep things simple, this sample doesn't do event processing.
        // To deal with the problem of using the stream before it becomes 
        // active, we retry Update() until we succeed.
        //
        // Note that there is still a danger that the stream becomes 
        // disconnected before we process the first sample, in which case
        // we will be stuck in a loop, which can be exited when the user
        // presses ctrl+break
        //

        while ( (hr == VFW_E_NOT_COMMITTED)
                && (0 == nSampleCount) 
                && !g_bExitRequested )
        {
            LogMessage("ReadFileIntoTerminal: "
                       "Update returned VFW_E_NOT_COMMITTED. "
                       "Likely cause: stream not yet started. Retrying.");

            Sleep( 1000 );

            hr = pStreamSample->Update(SSUPDATE_ASYNC, NULL, NULL, 0);
        }

        if (FAILED(hr))
        {
            LogError("ReadFileIntoTerminal: failed to Update the sample");

            pStreamSample->Release();
            pStreamSample = NULL;

            break;

        }

        
        //
        // the sample was submitted successfully. update count
        //

        nSampleCount++;

        if (nSampleCount == 300)
        {
            
            LogError("ReadFileIntoTerminal: sleeping 10 seconds");

            Sleep(30000);

            LogError("ReadFileIntoTerminal: woke up");
        }

        //
        // keep the sample we have just submitted. on exit, we will wait 
        // for it to be processed by mst
        //

        SampleQ.push_back(pStreamSample);

    } // file reading/sample-filling loop


    LogMessage("ReadFileIntoTerminal: processed %lu samples", nSampleCount);

    
    //
    // walk through the list of all the samples we have submitted and wait for 
    // each sample to be done
    //
    
    while (!SampleQ.empty())
    {

        //
        // get and remove a sample from the queue 
        //

        IStreamSample *pStreamSample = SampleQ.front();

        SampleQ.pop_front();


        //
        // wait for the Media Streaming Terminal to finish 
        // processing the sample
        //

        pStreamSample->CompletionStatus(COMPSTAT_WAIT, INFINITE);


        //
        // ignore the error code -- release the sample in any case
        //

        pStreamSample->Release();
        pStreamSample = NULL;

    }


    LogMessage("ReadFileIntoTerminal: released all submitted samples");

    
    //
    // tell media streaming terminal's stream that there is no more data
    //

    pTerminalMediaStream->SendEndOfStream(0);


    //
    // ignore the error code
    //

    pTerminalMediaStream->Release();
    pTerminalMediaStream = NULL;


    //
    // if we disconnect the call right away, the call may be dropped before
    // receiver gets all the samples. An application should wait for 
    // STREAM_INACTIVE media event before disconnecting the call.
    //
    // Since, for simplicity, we are not processing events in this sample,
    // wait several seconds to give the receiver a little time to complete
    // processing.
    //

    LogMessage("ReadFileIntoTerminal: Sleeping to give the receiver time "
               "to process everything we have sent.");

    Sleep(7500);


    LogMessage("ReadFileIntoTerminal: completed");
   
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
// CreateAndSelectTerminal
//
// creates a media streaming terminal for capture, sets requested format,
// sets allocator properties, and selects the terminal on the call's first 
// outgoing audio stream.
//
// returns S_OK and terminal if success
// error if failure
//
///////////////////////////////////////////////////////////////////////////////

HRESULT CreateAndSelectTerminal(IN ITBasicCallControl *pCall,
                                IN WAVEFORMATEX *pWaveFormat,
                                OUT ITTerminal **ppTerminal)
{

    HRESULT hr = E_FAIL;

    
    //
    // don't return garbage
    //

    *ppTerminal = NULL;



    //
    // find an outgoing audio stream on the call
    //

    ITStream *pStream = NULL;

    hr = FindAudioStream(pCall, &pStream);

    if (FAILED(hr))
    {
        LogError("CreateAndSelectTerminal: failed to find an outgoing audio stream");

        return hr;
    }


    //
    // create media streaming terminal
    //
    
    ITTerminal *pTerminal = NULL;

    pTerminal = CreateCaptureMediaStreamingTerminal(pCall);


    if (NULL == pTerminal)
    {

        LogError("CreateAndSelectTerminal: Failed to create media streaming terminal");

        pStream->Release();
        pStream = NULL;

        return hr;

    }


    //
    // tell media streaming terminal format of the data 
    // we are going to send. If the terminal cannot handle this format
    // return an error
    //

    hr = SetTerminalFormat(pTerminal, pWaveFormat);

    if (FAILED(hr))
    {
        LogMessage("CreateAndSelectTerminal: "
                   "terminal does not support requested format");
    
        pStream->Release();
        pStream = NULL;

        pTerminal->Release();
        pTerminal = NULL;

        return hr;
    }


    //
    // set allocator properties. 
    //
    // calling ITAllocatorProperties::SetAllocatorProperties with the 
    // properties that are not optimal for the MSP in use can result
    // in loss of sound quality.
    //
    // So make sure that you only call this function if you know you
    // need it.
    // 
    // Do not use ITAllocatorProperties::SetAllocatorProperties to set
    // the size of the buffer you want to get when you fill samples, 
    // ITAllocatorProperties::SetBufferSize will accomplish that without
    // affecting terminal's allocator properties.
    //

    // hr = SetAllocatorProperties(pTerminal);

    if (FAILED(hr))
    {

        //
        // not fatal -- we are still likely to successfully stream data
        //

        LogMessage("CreateAndSelectTerminal: "
                   "failed to set allocator properties. continuing.");
    }


    //
    // select the terminal on the stream
    //

    hr = pStream->SelectTerminal(pTerminal);


    //
    // don't need the stream anymore
    //

    pStream->Release();
    pStream = NULL;
    

    if (FAILED(hr))
    {
        LogError("CreateAndSelectTerminal: Failed to select terminal on the stream");

        pTerminal->Release();
        pTerminal = NULL;

    }

    
    //
    // if everything went smoothly pTerminal has a pointer to configured 
    // and selected terminal. otherwise pTerminal is null and all resources 
    // have been released
    //

    *ppTerminal = pTerminal;

    
    return hr;

}


///////////////////////////////////////////////////////////////////////////////
//
// StreamFile
//
// use TAPI to connect to the remote machine to stream file
//
///////////////////////////////////////////////////////////////////////////////

HRESULT StreamFile(IN char *szFileName, 
                   IN char *szAddressString, 
                   IN char *szAddressType)
{

    HRESULT hr = E_FAIL;


    LogMessage("StreamFile: file [%s] address [%s] address type [%s]", 
                szFileName, szAddressString, szAddressType);


    //
    // check if the file is valid
    //

    if (!IsValidAudioFile(szFileName))
    {

        LogError("StreamFile: file not valid [%s]", szFileName);

        return E_FAIL;
    }


    //
    // initialize COM libraries -- used by TAPI
    //

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if ( FAILED(hr))
    {
        LogError("StreamFile: Failed to CoInitialize");

        return hr;
    }


    //
    // create and initialize TAPI
    //

    hr = InitializeTAPI();

    if (SUCCEEDED(hr))
    {

        //
        // try to make a call
        //

        ITBasicCallControl *pCall = NULL;

        hr = Call(szAddressString, szAddressType, &pCall);

        if (SUCCEEDED(hr))
        {

            //
            // construct the file reader object
            // to be used to read file's data
            //
            // note: If you want to play more than one file in one call, reuse 
            // the same terminal for the duration of the call. Under 
            // Windows 2000, all data submitted via the Media Streaming Terminal
            // during the call must have the same format. Changing a Media 
            // Streaming Terminal's format after it is initially configured will 
            // always return an error code, regardless of the OS version. 
            // Unselecting a Media Streaming Terminal and creating and selecting
            // a new terminal on the same stream from the same call with a 
            // different format is not supported on Windows 2000. This may, 
            // however, be supported on other versions of Windows. For the latest 
            // information on which versions of Windows support this, please 
            // refer to the latest Platform SDK documentation.
            //

            CAVIFileReader FileReader;

            hr =  FileReader.Initialize(szFileName);


            //
            // get the file's format. remember to deallocate when done.
            //

            WAVEFORMATEX *pWaveFormat = NULL;

            if (SUCCEEDED(hr) && 
                SUCCEEDED(hr = FileReader.GetFormat(&pWaveFormat)))
            {

                //
                // create and configure a media streaming terminal and select it on this call
                //
                //

                ITTerminal *pPlaybackTerminal = NULL;

                hr = CreateAndSelectTerminal(pCall, pWaveFormat, &pPlaybackTerminal);


                if (SUCCEEDED(hr))
                {

                    //
                    // use the terminal to send the file
                    //

                    hr = ReadFileIntoTerminal(&FileReader, pPlaybackTerminal);

                    if (FAILED(hr))
                    {
                        LogError("StreamFile: failed to ReadFileIntoTerminal");
                    }
                    else
                    {
                        LogError("StreamFile: succeeded");
                    }



                    //
                    // release the terminal, we no longer need it
                    //

                    pPlaybackTerminal->Release();
                    pPlaybackTerminal = NULL;

                }
                else
                {
                    LogError("StreamFile: failed to create and select terminal");

                }


                //
                // no longer need wave format. free memory.
                //

                FreeMemory(pWaveFormat);
                pWaveFormat = NULL;

            }  // got file format
            else
            {
                LogError("StreamFile: failed to get file's format");

            }


            //
            // there is not much we can do if disconnect fails, 
            // so ignore its return code
            //

            pCall->Disconnect(DC_NORMAL);

            pCall->Release();
            pCall = NULL;

        }   // call connected
        else
        {
        
            LogError("StreamFile: failed to connect to %s", szAddressString);

        }


        //
        // tapi has been initialized. shutdown now.
        //

        ShutdownTAPI();

    } // initialized tapi
    else
    {

        LogError("StreamFile: Failed to initialize TAPI");

    }


    CoUninitialize();
        
    return hr;
}



///////////////////////////////////////////////////////////////////////////////
//
// HelpScreen
//
// this function displays usage information
//
///////////////////////////////////////////////////////////////////////////////

void HelpScreen()
{

    printf("Usage:\n\n"
               "  TAPISend filename address addresstype\n\n"
               "  where addresstype is [ ");


    for (int i = 0; i < g_nNumberOfAddressTypes - 1; ++i)
    {
        printf("%s | ", g_szAddressTypes[i]);
    }

    printf("%s ]\n", g_szAddressTypes[i]);

}


///////////////////////////////////////////////////////////////////////////////
// 
// CtrlHandler
//
// handler for ctrl+break, close, logoff and shutdown. 
//
// sets g_bExitRequested flag signaling shutdown. this ensures graceful exit
// 
///////////////////////////////////////////////////////////////////////////////

BOOL CtrlHandler(DWORD nEventType) 
{

    //
    // are we in the middle of shutting down?
    //

    if (TRUE == g_bExitRequested)
    {
        LogMessage("CtrlHandler: shutdown is already in progress");

        return TRUE;
    }


    //
    // any exit event (close, ctrl+break/C, logoff, shutdown)
    // is a signal for the application to exit.
    //

    switch (nEventType) 
    { 
 
        case CTRL_C_EVENT: 
        case CTRL_CLOSE_EVENT:
        case CTRL_BREAK_EVENT:
        case CTRL_LOGOFF_EVENT:
        case CTRL_SHUTDOWN_EVENT:

            LogMessage("CtrlHandler: Initiating shutdown.");


            //
            // signal shutdown
            //

            g_bExitRequested = TRUE;


    }

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
//
// main 
//
// usage: TAPISend filename address addresstype
// 
// returns 0 if success, 1 if failure
//
///////////////////////////////////////////////////////////////////////////////

int __cdecl main(int argc, char* argv[])
{

    LogMessage("main: started");


    //
    // validate arguments
    //

    if (argc != 4)
    {
        HelpScreen();

        LogMessage("main: invalid arguments, exiting.");

        return 1;
    }


    //
    // we want to handle ctrl+c and ctrl+break events so we can cleanup on exit
    // proceed even in case of failure
    //

    SetConsoleCtrlHandler( (PHANDLER_ROUTINE)CtrlHandler, TRUE);


    //
    // open the file, connect to the remote machine and stream the file over
    //

    HRESULT hr = StreamFile(argv[1], argv[2], argv[3]);


    //
    // exiting... we no longer want to handle ctrl+c and ctrl+break
    //
    
    SetConsoleCtrlHandler( (PHANDLER_ROUTINE) CtrlHandler, FALSE);


    //
    // was file streaming successful?
    //

    if (FAILED(hr))
    {
        LogError("main: Failed to stream file");

        return 1;
    }


    LogMessage("main: completed");

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\samples\outgoing\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Script1.rc
//
#define IDD_MAINDLG                     102
#define IDC_ADDRESSTYPE                 1002
#define IDC_ADDRESS                     1009
#define IDC_DISCONNECT                  1001
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1010
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3test\adds.cpp ===
#include "stdafx.h"
#include "t3test.h"
#include "t3testD.h"
#include "calldlg.h"
#include "callnot.h"
#include "externs.h"

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddListen
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::AddListen( long lMediaType )
{
    WCHAR                   szName[256];
    TV_INSERTSTRUCT         tvi;

    //
    // map the mediatype bstr to
    // a string name (like "audio in")
    //
    GetMediaTypeName(
                     lMediaType,
                     szName
                    );

    //
    // insert that string into the
    // listen window
    //
    tvi.hParent = ghListenRoot;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_TEXT | TVIF_PARAM;
    tvi.item.pszText = szName;
    tvi.item.lParam = (LPARAM) lMediaType;
    
    TreeView_InsertItem(
                        ghListenWnd,
                        &tvi
                       );


    //
    // select the first item
    //
    SelectFirstItem(
                    ghListenWnd,
                    ghListenRoot
                   );
}
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddAddressToTree
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::AddAddressToTree( ITAddress * pAddress )
{
    BSTR                bstrName;
    TV_INSERTSTRUCT     tvi;

    //
    // get the name of the address
    //
    pAddress->get_AddressName( &bstrName );


    //
    // set up struct
    //
    tvi.hParent = ghAddressesRoot;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_TEXT | TVIF_PARAM;
    tvi.item.pszText = bstrName;
    tvi.item.lParam = (LPARAM) pAddress;


    //
    // addref
    //
    pAddress->AddRef();

    
    //
    // insert it
    //
    TreeView_InsertItem(
                        ghAddressesWnd,
                        &tvi
                       );

    //
    // free name
    //
    SysFreeString( bstrName );
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddMediaType
//
// Add a mediatype to the mediatype tree
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::AddMediaType( long lMediaType )
{
    WCHAR szString[256];
    TV_INSERTSTRUCT tvi;

    //
    // get the displayable name
    //
    GetMediaTypeName(
                     lMediaType,
                     szString
                    );

    //
    // set up struct
    //
    tvi.hParent = ghMediaTypesRoot;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_TEXT | TVIF_PARAM;
    tvi.item.pszText = szString;
    tvi.item.lParam = (LPARAM) lMediaType;

    //
    // add the item
    //
    TreeView_InsertItem(
                        ghMediaTypesWnd,
                        &tvi
                       );

    //
    // select the first item
    //
    SelectFirstItem(
                    ghMediaTypesWnd,
                    ghMediaTypesRoot
                   );
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddCall
//
// Add a call to the call tree
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::AddCall( ITCallInfo * pCall )
{
    TV_INSERTSTRUCT             tvi;
    HTREEITEM                   hItem;
    CALL_PRIVILEGE              cp;
    CALL_STATE                  cs;
    WCHAR                       pszName[16];

    //
    // for the name of the call, use
    // the pointer!
    //
    wsprintf(
             pszName,
             L"0x%lx",
             pCall
            );


    //
    // set up struct
    //
    tvi.hParent = ghCallsRoot;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_TEXT | TVIF_PARAM;
    tvi.item.pszText = pszName;
    tvi.item.lParam = (LPARAM) pCall;

    //
    // save a reference
    //
    pCall->AddRef();

    
    //
    // insert the item
    //
    hItem = TreeView_InsertItem(
                                ghCallsWnd,
                                &tvi
                               );

    if (NULL != hItem)
    {
        //
        // select the item
        //
        TreeView_SelectItem(
                            ghCallsWnd,
                            hItem
                           );
    }

}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::AddTerminal( ITTerminal * pTerminal )
{
    BSTR                    bstrName;
    BSTR                    bstrClass;
    TV_INSERTSTRUCT         tvi;
    TERMINAL_DIRECTION      td;
    WCHAR                   szName[256];

    //
    // get the name of the terminal
    //
    pTerminal->get_Name( &bstrName );

    pTerminal->get_Direction( &td );

    if (td == TD_RENDER)
    {
        wsprintfW(szName, L"%s [Playback]", bstrName);
    }
    else if (td == TD_CAPTURE)
    {
        wsprintfW(szName, L"%s [Record]", bstrName);
    }
    else //if (TD == TD_BOTH)
    {
        lstrcpyW(szName, bstrName);
    }
    
    //
    // set up the structure
    //
    tvi.hParent = ghTerminalsRoot;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_TEXT | TVIF_PARAM;
    tvi.item.pszText = szName;
    tvi.item.lParam = (LPARAM) pTerminal;


    //
    // keep a refence to the terminal
    //
    pTerminal->AddRef();

    //
    // add it
    //
    TreeView_InsertItem(
                        ghTerminalsWnd,
                        &tvi
                       );

    //
    // free the name
    //
    SysFreeString( bstrName );


    //
    // select
    //
    SelectFirstItem(
                    ghTerminalsWnd,
                    ghTerminalsRoot
                   );
    
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddTerminalClass
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::AddTerminalClass( GUID * pguid )
{
    TV_INSERTSTRUCT tvi;
    
    //
    // get the name
    //
    tvi.item.pszText = GetTerminalClassName( pguid );

    //
    // set up the struct
    //
    tvi.hParent = ghClassesRoot;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_TEXT | TVIF_PARAM;
    tvi.item.lParam = (LPARAM) pguid;

    //
    // insert the item
    //
    TreeView_InsertItem(
                        ghClassesWnd,
                        &tvi
                       );

    SysFreeString( tvi.item.pszText );

    //
    // select item
    //
    SelectFirstItem(
                    ghClassesWnd,
                    ghClassesRoot
                   );

}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddCreatedTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::AddCreatedTerminal( ITTerminal * pTerminal )
{
    BSTR                    bstrName;
    TV_INSERTSTRUCT         tvi;


    //
    // get the name
    //
    pTerminal->get_Name( &bstrName );

    //
    // set up the structure
    //
    tvi.hParent = ghCreatedRoot;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_TEXT | TVIF_PARAM;

    if ( ( NULL == bstrName ) || (NULL == bstrName[0] ))
    {
        tvi.item.pszText = L"<No Name Given>";
    }
    else
    {
        tvi.item.pszText = bstrName;
    }

    tvi.item.lParam = (LPARAM) pTerminal;


    //
    // keep reference
    //
    pTerminal->AddRef();

    //
    // insert
    //
    TreeView_InsertItem(
                        ghCreatedWnd,
                        &tvi
                       );

    SysFreeString( bstrName );

    //
    // select
    //
    SelectFirstItem(
                    ghCreatedWnd,
                    ghCreatedRoot
                   );
    
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddSelectedTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::AddSelectedTerminal(
                                     ITTerminal * pTerminal
                                    )
{
    BSTR bstrName;
    BSTR pMediaType;
    TV_INSERTSTRUCT tvi;
    TERMINAL_DIRECTION td;
    WCHAR szName[256];
    

    //
    // get the name
    //
    pTerminal->get_Name( &bstrName );

    pTerminal->get_Direction( &td );

    if (td == TD_RENDER)
    {
        wsprintfW(szName, L"%s [Playback]", bstrName);
    }
    else if (td == TD_CAPTURE)
    {
        wsprintfW(szName, L"%s [Record]", bstrName);
    }
    else //if (TD == TD_BOTH)
    {
        lstrcpyW(szName, bstrName);
    }
    

    //
    // set up the struct
    //
    tvi.hParent = ghSelectedRoot;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_TEXT | TVIF_PARAM;
    tvi.item.pszText = szName;
    tvi.item.lParam = (LPARAM) pTerminal;

    //
    // keep reference
    //
    pTerminal->AddRef();

    //
    // insert item
    //
    TreeView_InsertItem(
                        ghSelectedWnd,
                        &tvi
                       );

    //
    // free name
    //
    SysFreeString( bstrName );


    //
    // select
    //
    SelectFirstItem(
                    ghSelectedWnd,
                    ghSelectedRoot
                   );
    
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\samples\outgoing\outgoing.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.

--*/

#define UNICODE
#include <windows.h>
#include <tapi3.h>
#include <strmif.h>
#include <control.h>
#include "resource.h"

//////////////////////////////////////////////////////////
// T3OUT.EXE
//
// Example of making an outgoing call with TAPI 3.0
//
// This application will allow a user to make a call
// by using TAPI 3.0.  The application will simply look
// for the first TAPI line that support Audio, and can
// dial a phone number.  It will then use that line to
// make calls.
//
// This application does not handle incoming calls, and
// does not process incoming messages.
//
//////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////
// Constants
//////////////////////////////////////////////////////////

const DWORD ADDRESSLENGTH   = 128;
const DWORD MAXTERMINALS    = 5;

const WCHAR * const gszTapi30           = L"TAPI 3.0 Outgoing Call Sample";

const WCHAR * const gszConferenceName   = L"Conference Name";
const WCHAR * const gszEmailName        = L"Email Name";
const WCHAR * const gszMachineName      = L"Machine Name";
const WCHAR * const gszPhoneNumber      = L"Phone Number";
const WCHAR * const gszIPAddress        = L"IP Address";

//////////////////////////////////////////////////////////
// GLOBALS
//////////////////////////////////////////////////////////
HINSTANCE               ghInst;
HWND                    ghDlg = NULL;
ITTAPI *                gpTapi;
ITAddress *             gpAddress = NULL;
ITBasicCallControl *    gpCall;

//////////////////////////////////////////////////////////
// PROTOTYPES
//////////////////////////////////////////////////////////
INT_PTR
CALLBACK
MainDialogProc(
               HWND hDlg,
               UINT uMsg,
               WPARAM wParam,
               LPARAM lParam
              );

HRESULT
FindAnAddress(
              DWORD dwAddressType,
              BSTR  * ppName
             );

HRESULT
GetTerminal(
            ITStream * pStream,
            ITTerminal ** ppTerminal
           );

HRESULT
GetVideoRenderTerminal(
                   ITTerminal ** ppTerminal
                  );

HRESULT
MakeTheCall(
            DWORD dwAddressType,
            PWCHAR szAddressToCall
           );

HRESULT
DisconnectTheCall();

void
DoMessage(
          LPWSTR pszMessage
         );

HRESULT
InitializeTapi();

void
ShutdownTapi();

void
EnableButton(
             HWND hDlg,
             int ID
            );
void
DisableButton(
              HWND hDlg,
              int ID
             );

BOOL
AddressSupportsMediaType(
                         ITAddress * pAddress,
                         long        lMediaType
                        );

//////////////////////////////////////////////////////////
// WinMain
//////////////////////////////////////////////////////////
int
WINAPI
WinMain(
        HINSTANCE hInst,
        HINSTANCE hPrevInst,
        LPSTR lpCmdLine,
        int nCmdShow
       )
{
    ghInst = hInst;


    // need to coinit
    if ( FAILED( CoInitialize(NULL) ) )
    {
        return 0;
    }

    if ( FAILED( InitializeTapi() ) )
    {
        return 0;
    }

    // everything is initialized, so
    // start the main dialog box
    DialogBox(
              ghInst,
              MAKEINTRESOURCE(IDD_MAINDLG),
              NULL,
              MainDialogProc
             );


    ShutdownTapi();

    CoUninitialize();

    return 1;
}


//////////////////////////////////////////////////////////////
// InitializeTapi
//
// Various initializations
///////////////////////////////////////////////////////////////
HRESULT
InitializeTapi()
{
    HRESULT         hr;


    // cocreate the TAPI object
    hr = CoCreateInstance(
                          CLSID_TAPI,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_ITTAPI,
                          (LPVOID *)&gpTapi
                         );

    if ( FAILED(hr) )
    {
        DoMessage(L"CoCreateInstance on TAPI failed");
        return hr;
    }

    // call initialize.  this must be called before
    // any other tapi functions are called.
    hr = gpTapi->Initialize();

    if (S_OK != hr)
    {
        DoMessage(L"TAPI failed to initialize");

        gpTapi->Release();
        gpTapi = NULL;

        return hr;
    }

    return S_OK;
}


///////////////////////////////////////////////////////////////
// ShutdownTapi
///////////////////////////////////////////////////////////////
void
ShutdownTapi()
{
    // if there is still a call,
    // release it
    if (NULL != gpCall)
    {
        gpCall->Release();
        gpCall = NULL;
    }

    // if we have an address object
    // release it
    if (NULL != gpAddress)
    {
        gpAddress->Release();
        gpAddress = NULL;
    }

    // release main object.
    if (NULL != gpTapi)
    {
        gpTapi->Shutdown();
        gpTapi->Release();
        gpTapi = NULL;
    }

}

///////////////////////////////////////////////////////////////////////////
// InitAddressTypeComboBox
//
// Put address type string in the combo box
// and save the addresstype with the string
//
///////////////////////////////////////////////////////////////////////////
void
InitAddressTypeComboBox(
    HWND hComboBox
    )
{
    int i;

    i = (int)SendMessage( hComboBox, CB_ADDSTRING, 0, (LONG_PTR)gszConferenceName );

    SendMessage(
                hComboBox,
                CB_SETITEMDATA ,
                i,
                (LONG_PTR)LINEADDRESSTYPE_SDP
               );


    i = (int)SendMessage( hComboBox, CB_ADDSTRING, 0, (LONG_PTR)gszEmailName );

    SendMessage(
                hComboBox,
                CB_SETITEMDATA ,
                i,
                (LONG_PTR)LINEADDRESSTYPE_EMAILNAME
               );


    i = (int)SendMessage( hComboBox, CB_ADDSTRING, 0, (LONG_PTR)gszMachineName );

    SendMessage(
                hComboBox,
                CB_SETITEMDATA ,
                i,
                (LONG_PTR)LINEADDRESSTYPE_DOMAINNAME
               );


    i = (int)SendMessage( hComboBox, CB_ADDSTRING, 0, (LONG_PTR)gszPhoneNumber );

    SendMessage(
                hComboBox,
                CB_SETITEMDATA ,
                i,
                (LONG_PTR)LINEADDRESSTYPE_PHONENUMBER
               );


    SendMessage( hComboBox, CB_SETCURSEL, i, 0 );

    i = (int)SendMessage( hComboBox, CB_ADDSTRING, 0, (LONG_PTR)gszIPAddress );

    SendMessage(
                hComboBox,
                CB_SETITEMDATA ,
                i,
                (LONG_PTR)LINEADDRESSTYPE_IPADDRESS
               );

}

///////////////////////////////////////////////////////////////////////////
// MainDlgProc
///////////////////////////////////////////////////////////////////////////
INT_PTR
CALLBACK
MainDialogProc(
               HWND hDlg,
               UINT uMsg,
               WPARAM wParam,
               LPARAM lParam
              )
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            HWND hComboBox;


            // set up dialog
            ghDlg = hDlg;

            EnableButton( hDlg, IDOK );
            DisableButton( hDlg, IDC_DISCONNECT );

            hComboBox = GetDlgItem( hDlg, IDC_ADDRESSTYPE );

            InitAddressTypeComboBox(hComboBox);

            SetFocus( hComboBox );

            return 0;
        }

        case WM_COMMAND:
        {
            if ( LOWORD(wParam) == IDCANCEL )
            {
                // quit
                EndDialog( hDlg, 0 );

                return 1;
            }

            // dial request
            if ( LOWORD(wParam) == IDOK )
            {
                HWND hComboBox;
                DWORD dwIndex;
                DWORD dwAddressType;
                WCHAR szAddressToCall[ADDRESSLENGTH];


                // get the address type the user selected.
                hComboBox = GetDlgItem( hDlg, IDC_ADDRESSTYPE );
                dwIndex = (DWORD)SendMessage( hComboBox, CB_GETCURSEL, 0, 0 );

                dwAddressType = (DWORD)SendMessage(
                                             hComboBox,
                                             CB_GETITEMDATA,
                                             dwIndex,
                                             0
                                           );

                // get the address the user wants to call
                GetDlgItemText(
                               hDlg,
                               IDC_ADDRESS,
                               szAddressToCall,
                               ADDRESSLENGTH
                              );

                // make the call
                if ( S_OK == MakeTheCall(dwAddressType, szAddressToCall) )
                {
                    EnableButton( hDlg, IDC_DISCONNECT );
                    DisableButton( hDlg, IDOK );
                }
                else
                {
                    DoMessage(L"The call failed to connect");
                }

                return 1;
            }

            // disconnect request
            if ( LOWORD( wParam ) == IDC_DISCONNECT )
            {
                // disconnect
                if (S_OK == DisconnectTheCall())
                {
                    EnableButton( hDlg, IDOK );
                    DisableButton( hDlg, IDC_DISCONNECT );
                }
                else
                {
                    DoMessage(L"The call failed to disconnect");
                }

                return 1;
            }

            return 0;
        }
        default:

            return 0;
    }
}


////////////////////////////////////////////////////////////////////////
// FindAnAddress
//
// Finds an address object that this application will use to make calls on.
//
// This function finds an address that supports the addresstype passed
// in, as well as the audioin and audioout media types.
//
// Return Value
//          S_OK if it finds an address
//          E_FAIL if it does not find an address
////////////////////////////////////////////////////////////////////////
HRESULT
FindAnAddress(
              DWORD dwAddressType,
              BSTR  * ppName
             )
{
    HRESULT                 hr = S_OK;
    BOOL                    bFoundAddress = FALSE;
    IEnumAddress          * pEnumAddress;
    ITAddress             * pAddress;
    ITAddressCapabilities * pAddressCaps;
    long                    lType = 0;

    // if we have an address object
    // release it
    if (NULL != gpAddress)
    {
        gpAddress->Release();
        gpAddress = NULL;
    }

    // enumerate the addresses
    hr = gpTapi->EnumerateAddresses( &pEnumAddress );

    if ( FAILED(hr) )
    {
        return hr;
    }

    while ( !bFoundAddress )
    {
        // get the next address
        hr = pEnumAddress->Next( 1, &pAddress, NULL );

        if (S_OK != hr)
        {
            break;
        }


        hr = pAddress->QueryInterface(IID_ITAddressCapabilities, (void**)&pAddressCaps);

        if ( SUCCEEDED(hr) )
        {

            hr = pAddressCaps->get_AddressCapability( AC_ADDRESSTYPES, &lType );

            pAddressCaps->Release();

            if ( SUCCEEDED(hr) )
            {
                // is the type we are looking for?
                if ( dwAddressType & lType )
                {
                    // does it support audio?
                    if ( AddressSupportsMediaType(pAddress, TAPIMEDIATYPE_AUDIO) )
                    {
                        // does it have a name?
                        if ( SUCCEEDED( pAddress->get_AddressName(ppName) ) )
                        {
                            // save it in the global variable
                            // since we break out of the loop, this one won't
                            // get released

                            gpAddress = pAddress;

                            bFoundAddress = TRUE;

                            break;
                        }
                    }
                }
            }
        }

        pAddress->Release();

    } // end while loop

    pEnumAddress->Release();

    if (!bFoundAddress)
    {
        return E_FAIL;
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////
// IsVideoCaptureStream
//
// Returns true if the stream is for video capture
/////////////////////////////////////////////////////////////////

BOOL
IsVideoCaptureStream(
                     ITStream * pStream
                    )
{
    TERMINAL_DIRECTION tdStreamDirection;
    long               lStreamMediaType;

    if ( FAILED( pStream  ->get_Direction(&tdStreamDirection)   ) ) { return FALSE; }
    if ( FAILED( pStream  ->get_MediaType(&lStreamMediaType)    ) ) { return FALSE; }

    return (tdStreamDirection == TD_CAPTURE) &&
           (lStreamMediaType  == TAPIMEDIATYPE_VIDEO);
}

/////////////////////////////////////////////////////////////////
// EnablePreview
//
// Selects a video render terminal on a video capture stream,
// thereby enabling video preview.
/////////////////////////////////////////////////////////////////

HRESULT
EnablePreview(
              ITStream * pStream
             )
{
    ITTerminal * pTerminal;

    HRESULT hr = GetVideoRenderTerminal(&pTerminal);

    if ( SUCCEEDED(hr) )
    {
        hr = pStream->SelectTerminal(pTerminal);

        pTerminal->Release();
    }

    return hr;
}

/////////////////////////////////////////////////////////////////
// SelectTerminalsOnCall
//
// Creates and selects terminals for all streams on the given
// call.
/////////////////////////////////////////////////////////////////

HRESULT
SelectTerminalsOnCall(
                     ITBasicCallControl * pCall
                     )
{
    HRESULT hr;

    //
    // get the ITStreamControl interface for this call
    //

    ITStreamControl * pStreamControl;

    hr = pCall->QueryInterface(IID_ITStreamControl,
                               (void **) &pStreamControl);

    if ( SUCCEEDED(hr) )
    {
        //
        // enumerate the streams
        //

        IEnumStream * pEnumStreams;

        hr = pStreamControl->EnumerateStreams(&pEnumStreams);

        pStreamControl->Release();

        if ( SUCCEEDED(hr) )
        {
            //
            // for each stream
            //

            ITStream * pStream;

            while ( S_OK == pEnumStreams->Next(1, &pStream, NULL) )
            {
                ITTerminal * pTerminal;

                //
                // Find out the media type and direction of this stream,
                // and create the default terminal for this media type and
                // direction.
                //

                hr = GetTerminal(pStream,
                                 &pTerminal);

                if ( SUCCEEDED(hr) )
                {
                    //
                    // Select the terminal on the stream.
                    //

                    hr = pStream->SelectTerminal(pTerminal);

                    if ( SUCCEEDED(hr) )
                    {
                        //
                        // Also enable preview on the video capture stream.
                        //

                        if ( IsVideoCaptureStream( pStream ) )
                        {
                            EnablePreview( pStream );
                        }
                    }

                    pTerminal->Release();
                }

                pStream->Release();

            }

            pEnumStreams->Release();
        }
    }

    return hr;
}


/////////////////////////////////////////////////////////////////
// MakeTheCall
//
// Sets up and makes a call
/////////////////////////////////////////////////////////////////

HRESULT
MakeTheCall(
            DWORD dwAddressType,
            PWCHAR szAddressToCall
           )
{
    HRESULT                 hr = S_OK;
    BSTR                    bstrAddressToCall;
    BSTR                    pAddressName;


    // find an address object that
    // we will use to make calls on

    hr = FindAnAddress(dwAddressType, &pAddressName);

    if ( FAILED(hr) )
    {
        DoMessage(L"Could not find a TAPI address for making calls.");

        return hr;
    }

    WCHAR pText[200];

    wsprintf(pText, L"Using address: %s", pAddressName);

    SysFreeString(pAddressName);

    DoMessage(pText);

    //
    // find out which media types this address supports
    //

    long lMediaTypes = 0;

    if ( AddressSupportsMediaType(gpAddress, TAPIMEDIATYPE_AUDIO) )
    {
        lMediaTypes |= TAPIMEDIATYPE_AUDIO; // we will use audio
    }

    if ( AddressSupportsMediaType(gpAddress, TAPIMEDIATYPE_VIDEO) )
    {
        lMediaTypes |= TAPIMEDIATYPE_VIDEO; // we will use video
    }

    //
    // Create the call.
    //

    bstrAddressToCall = SysAllocString( szAddressToCall );

    hr = gpAddress->CreateCall( bstrAddressToCall,
                                dwAddressType,
                                lMediaTypes,
                                &gpCall);

    SysFreeString ( bstrAddressToCall );

    if ( FAILED(hr) )
    {
        DoMessage(L"Could not create a call.");

        return hr;
    }

    //
    // Select our terminals on the call; if any of the selections fail we
    // proceed without that terminal.
    //

    hr = SelectTerminalsOnCall( gpCall );

    //
    // We're now ready to call connect.
    //
    // the VARIANT_TRUE parameter indicates that this
    // call is sychronous - that is, it won't
    // return until the call is in the connected
    // state (or fails to connect)
    // Since this is called in the UI thread,
    // this means that the app will appear
    // to hang until this function returns.
    // Some TAPI service providers may take a long
    // time for a call to reach the connected state.
    //

    hr = gpCall->Connect( VARIANT_TRUE );

    if ( FAILED(hr) )
    {
        gpCall->Release();
        gpCall = NULL;

        DoMessage(L"Could not connect the call.");

        return hr;
    }

    return S_OK;
}


/////////////////////////////////////////////////////////
// GetTerminal
//
// Creates the default terminal for the passed-in stream.
//
/////////////////////////////////////////////////////////
HRESULT
GetTerminal(
            ITStream * pStream,
            ITTerminal ** ppTerminal
           )
{
    //
    // Determine the media type and direction of this stream.
    //

    HRESULT            hr;
    long               lMediaType;
    TERMINAL_DIRECTION dir;

    hr = pStream->get_MediaType( &lMediaType );
    if ( FAILED(hr) ) return hr;

    hr = pStream->get_Direction( &dir );
    if ( FAILED(hr) ) return hr;

    //
    // Since video render is a dynamic terminal, the procedure for creating
    // it is different.
    //

    if ( ( lMediaType == TAPIMEDIATYPE_VIDEO ) &&
         ( dir        == TD_RENDER ) )
    {
        return GetVideoRenderTerminal(ppTerminal);
    }

    //
    // For all other terminals we use GetDefaultStaticTerminal.
    // First, get the terminal support interface.
    //

    ITTerminalSupport * pTerminalSupport;

    hr = gpAddress->QueryInterface( IID_ITTerminalSupport,
                                    (void **)&pTerminalSupport);

    if ( SUCCEEDED(hr) )
    {
        //
        // get the default terminal for this MediaType and direction
        //

        hr = pTerminalSupport->GetDefaultStaticTerminal(lMediaType,
                                                        dir,
                                                        ppTerminal);

        pTerminalSupport->Release();
    }

    return hr;

}

/////////////////////////////////////////////////////////
// GetVideoRenderTerminal
//
// Creates a dynamic terminal for the Video Render mediatype / direction
//
/////////////////////////////////////////////////////////
HRESULT
GetVideoRenderTerminal(
                   ITTerminal ** ppTerminal
                  )
{
    //
    // Construct a BSTR for the correct IID.
    //

    LPOLESTR            lpTerminalClass;

    HRESULT             hr;

    hr = StringFromIID(CLSID_VideoWindowTerm,
                       &lpTerminalClass);

    if ( SUCCEEDED(hr) )
    {
        BSTR                bstrTerminalClass;

        bstrTerminalClass = SysAllocString ( lpTerminalClass );

        CoTaskMemFree( lpTerminalClass );

        if ( bstrTerminalClass == NULL )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {

            //
            // Get the terminal support interface
            //

            ITTerminalSupport * pTerminalSupport;

            hr = gpAddress->QueryInterface(IID_ITTerminalSupport,
                                           (void **)&pTerminalSupport);

            if ( SUCCEEDED(hr) )
            {
                //
                // Create the video render terminal.
                //

                hr = pTerminalSupport->CreateTerminal(bstrTerminalClass,
                                                      TAPIMEDIATYPE_VIDEO,
                                                      TD_RENDER,
                                                      ppTerminal);

                pTerminalSupport->Release();

                if ( SUCCEEDED(hr) )
                {
                    // Get the video window interface for the terminal
                    IVideoWindow *pVideoWindow = NULL;

                    hr = (*ppTerminal)->QueryInterface(IID_IVideoWindow,
                                                       (void**)&pVideoWindow);

                    if ( SUCCEEDED(hr) )
                    {
                        //
                        // Set the AutoShow member to true
                        //
                        // Note that the AutoShow property is the only one
                        // we can use on this terminal's IVideoWindow and
                        // IBasicVideo interfaces before the CME_STREAM_ACTIVE
                        // event is received for the stream. All other methods
                        // will fail until CME_STREAM_ACTIVE has been sent.
                        // Applications that need to control more about a video
                        // window than just its visibility must listen for the
                        // CME_STREAM_ACTIVE event. See the "t3in.exe" sample
                        // for how to do this.
                        //

                        hr = pVideoWindow->put_AutoShow( VARIANT_TRUE );

                        pVideoWindow->Release();
                    }
                }
            }

            SysFreeString( bstrTerminalClass );
        }
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////
// DisconnectTheCall
//
// Disconnects the call
//////////////////////////////////////////////////////////////////////
HRESULT
DisconnectTheCall()
{
    HRESULT         hr = S_OK;

    if (NULL != gpCall)
    {
        hr = gpCall->Disconnect( DC_NORMAL );

        gpCall->Release();
        gpCall = NULL;

        return hr;
    }

    return S_FALSE;
}



///////////////////////////////////////////////////////////////////
//
// HELPER FUNCTIONS
//
///////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////
// DoMessage
///////////////////////////////////////////////////////////////////
void
DoMessage(
          LPWSTR pszMessage
         )
{
    MessageBox(
               ghDlg,
               pszMessage,
               gszTapi30,
               MB_OK
              );
}

///////////////////////////////////////////////////////////////
// EnableButton
//
// Enable, make default, and setfocus to a button
///////////////////////////////////////////////////////////////
void
EnableButton(
             HWND hDlg,
             int ID
            )
{
    SendDlgItemMessage(
                       hDlg,
                       ID,
                       BM_SETSTYLE,
                       BS_DEFPUSHBUTTON,
                       0
                      );
    EnableWindow(
                 GetDlgItem( hDlg, ID ),
                 TRUE
                );
    SetFocus(
             GetDlgItem( hDlg, ID )
            );
}

//////////////////////////////////////////////////////////////
// DisableButton
//
// Disable a button
//////////////////////////////////////////////////////////////
void
DisableButton(
              HWND hDlg,
              int ID
             )
{
    SendDlgItemMessage(
                       hDlg,
                       ID,
                       BM_SETSTYLE,
                       BS_PUSHBUTTON,
                       0
                      );
    EnableWindow(
                 GetDlgItem( hDlg, ID ),
                 FALSE
                );
}

//////////////////////////////////////////////////////////////
// AddressSupportsMediaType
//
// Finds out if the given address supports the given media
// type, and returns TRUE if it does.
//////////////////////////////////////////////////////////////

BOOL
AddressSupportsMediaType(
                         ITAddress * pAddress,
                         long        lMediaType
                        )
{
    VARIANT_BOOL     bSupport = VARIANT_FALSE;
    ITMediaSupport * pMediaSupport;

    if ( SUCCEEDED( pAddress->QueryInterface( IID_ITMediaSupport,
                                              (void **)&pMediaSupport ) ) )
    {
        // does it support this media type?
        pMediaSupport->QueryMediaType(
                                      lMediaType,
                                      &bSupport
                                     );

        pMediaSupport->Release();
    }

    return (bSupport == VARIANT_TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3test\autoans.h ===
#if !defined(AFX_AUTOANS_H__2BFE6626_7758_11D1_8F5C_00C04FB6809F__INCLUDED_)
#define AFX_AUTOANS_H__2BFE6626_7758_11D1_8F5C_00C04FB6809F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// autoans.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// autoans dialog

class autoans : public CDialog
{
// Construction
public:
	autoans(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(autoans)
	enum { IDD = IDD_AUTOANSWER };
    TerminalPtrList m_TerminalPtrList;
    ITAddress * m_pAddress;
    
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(autoans)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(autoans)
	virtual BOOL OnInitDialog();
	afx_msg void OnTerminalAdd();
	afx_msg void OnTerminalRemove();
	virtual void OnOK();
    virtual void OnCancel();
    afx_msg void OnClose() ;
    void PopulateListBox();
    void AddTerminalToListBox( ITTerminal * pTerminal, BOOL bSelected );
    void AddDynamicTerminalToListBox( BOOL bSelected );
    void AddTerminalToAAList( ITTerminal * pTerminal );
//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_AUTOANS_H__2BFE6626_7758_11D1_8F5C_00C04FB6809F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3test\calldlg.h ===
#if !defined(AFX_CREATECALLDLG_H__2584F283_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_)
#define AFX_CREATECALLDLG_H__2584F283_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// CreateCallDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCreateCallDlg dialog

class CCreateCallDlg : public CDialog
{
// Construction
public:
	CCreateCallDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CCreateCallDlg)
	enum { IDD = IDD_CREATECALL };
	CString	m_pszDestAddress;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCreateCallDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CCreateCallDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CREATECALLDLG_H__2584F283_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3test\calldlg.cpp ===
// CreateCallDlg.cpp : implementation file
//

#include "stdafx.h"
#include "t3test.h"
#include "CallDlg.h"

#ifdef _DEBUG

#ifndef _WIN64 // mfc 4.2's heap debugging features generate warnings on win64
#define new DEBUG_NEW
#endif

#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCreateCallDlg dialog


CCreateCallDlg::CCreateCallDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CCreateCallDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CCreateCallDlg)
	m_pszDestAddress = _T("");
	//}}AFX_DATA_INIT
}


void CCreateCallDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCreateCallDlg)
	DDX_Text(pDX, IDC_DESTADDRESS, m_pszDestAddress);
	DDV_MaxChars(pDX, m_pszDestAddress, 256);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCreateCallDlg, CDialog)
	//{{AFX_MSG_MAP(CCreateCallDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCreateCallDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3test\autoans.cpp ===
// autoans.cpp : implementation file
//

#include "stdafx.h"
#include "t3test.h"
#include "t3testd.h"
#include "autoans.h"

#ifdef _DEBUG

#ifndef _WIN64 // mfc 4.2's heap debugging features generate warnings on win64
#define new DEBUG_NEW
#endif

#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
extern DataPtrList       gDataPtrList;
/////////////////////////////////////////////////////////////////////////////
// autoans dialog


autoans::autoans(CWnd* pParent /*=NULL*/)
	: CDialog(autoans::IDD, pParent)
{
        CT3testDlg::GetAddress( &m_pAddress );

}


void autoans::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(autoans)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BOOL autoans::OnInitDialog()
{
    CDialog::OnInitDialog();
    PopulateListBox();

    return TRUE;
}


BEGIN_MESSAGE_MAP(autoans, CDialog)
	//{{AFX_MSG_MAP(autoans)
	ON_BN_CLICKED(IDC_TERMINALADD, OnTerminalAdd)
	ON_BN_CLICKED(IDC_TERMINALREMOVE, OnTerminalRemove)
    ON_WM_CLOSE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// autoans message handlers

void autoans::OnTerminalAdd() 
{
    LONG            i;
    ITTerminal *    pTerminal;
    
    i = SendDlgItemMessage(
                           IDC_NOTSELECTED,
                           LB_GETCURSEL,
                           0,
                           0
                          );

    if ( i == LB_ERR )
    {
        return;
    }
    
    pTerminal = (ITTerminal *) SendDlgItemMessage(
        IDC_NOTSELECTED,
        LB_GETITEMDATA,
        i,
        0
        );

    if ( NULL != pTerminal )
    {
        SendDlgItemMessage(
                           IDC_NOTSELECTED,
                           LB_DELETESTRING,
                           i,
                           0
                          );

        AddTerminalToListBox( pTerminal, TRUE );
    }
    else
    {
        AddDynamicTerminalToListBox( TRUE );
    }

	
}

void autoans::OnTerminalRemove() 
{
    LONG        i;
    ITTerminal * pTerminal;
    
    i = SendDlgItemMessage(
                           IDC_SELECTED,
                           LB_GETCURSEL,
                           0,
                           0
                          );

    if ( i == LB_ERR )
    {
        return;
    }
    
    pTerminal = (ITTerminal *) SendDlgItemMessage(
        IDC_SELECTED,
        LB_GETITEMDATA,
        i,
        0
        );

    SendDlgItemMessage(
                       IDC_SELECTED,
                       LB_DELETESTRING,
                       i,
                       0
                      );
    
    if ( NULL != pTerminal )
    {
        AddTerminalToListBox( pTerminal, FALSE );
    }
	
}

void autoans::OnOK() 
{
    LONG        i, count;

    
    i = 0;

    count = SendDlgItemMessage(
                               IDC_SELECTED,
                               LB_GETCOUNT,
                               0,
                               0
                              );


    for( i = 0; i < count; i++ )
    {
        ITTerminal * pTerminal;

        
        pTerminal = (ITTerminal *)SendDlgItemMessage(
            IDC_SELECTED,
            LB_GETITEMDATA,
            i,
            0
            );

        AddTerminalToAAList( pTerminal );

        if ( NULL != pTerminal )
        {
            pTerminal->Release();
        }
    }

    count = SendDlgItemMessage(
                               IDC_NOTSELECTED,
                               LB_GETCOUNT,
                               0,
                               0
                              );

    for ( i = 0; i < count; i++ )
    {
        ITTerminal * pTerminal;

        pTerminal = (ITTerminal *)SendDlgItemMessage(
            IDC_NOTSELECTED,
            LB_GETITEMDATA,
            i,
            0
            );

        if ( NULL != pTerminal )
        {
            pTerminal->Release();
        }
    }
    

	CDialog::OnOK();
}
void autoans::OnCancel()
{
    LONG        i, count;

    
    i = 0;

    count = SendDlgItemMessage(
                               IDC_SELECTED,
                               LB_GETCOUNT,
                               0,
                               0
                              );


    for( i = 0; i < count; i++ )
    {
        ITTerminal * pTerminal;

        
        pTerminal = (ITTerminal *)SendDlgItemMessage(
            IDC_SELECTED,
            LB_GETITEMDATA,
            i,
            0
            );

        if ( NULL != pTerminal )
        {
            pTerminal->Release();
        }
    }


    count = SendDlgItemMessage(
                               IDC_NOTSELECTED,
                               LB_GETCOUNT,
                               0,
                               0
                              );

    for ( i = 0; i < count; i++ )
    {
        ITTerminal * pTerminal;

        pTerminal = (ITTerminal *)SendDlgItemMessage(
            IDC_NOTSELECTED,
            LB_GETITEMDATA,
            i,
            0
            );

        if ( NULL != pTerminal )
        {
            pTerminal->Release();
        }
    }
    
    CDialog::OnCancel();
}

void autoans::PopulateListBox()
{
    ITTerminalSupport * pTerminalSupport;
    IEnumTerminal *     pEnumTerminal;
    IEnumTerminalClass * pEnumClasses;
    HRESULT             hr;
    
    if ( NULL == m_pAddress )
    {
        return;
    }

    m_pAddress->QueryInterface(
                               IID_ITTerminalSupport,
                               (void **) &pTerminalSupport
                              );

    pTerminalSupport->EnumerateStaticTerminals( &pEnumTerminal );

    while (TRUE)
    {
        ITTerminal * pTerminal;
        
        hr = pEnumTerminal->Next(
                                 1,
                                 &pTerminal,
                                 NULL
                                );

        if ( S_OK != hr )
        {
            break;
        }

        AddTerminalToListBox( pTerminal, FALSE );

//        pTerminal->Release();
    }

    pEnumTerminal->Release();

    pTerminalSupport->EnumerateDynamicTerminalClasses( &pEnumClasses );

    while (TRUE)
    {
        GUID        guid;
        
        hr = pEnumClasses->Next(
                                1,
                                &guid,
                                NULL
                               );

        if ( S_OK != hr )
        {
            break;
        }

        if ( guid == CLSID_VideoWindowTerm )
        {
            AddDynamicTerminalToListBox( FALSE );
        }

    }

    pEnumClasses->Release();
    
    pTerminalSupport->Release();
}

void
autoans::AddTerminalToListBox( ITTerminal * pTerminal, BOOL bSelected )
{
    HRESULT         hr;
    LONG            i;
    DWORD           dwLB;
    BSTR            bstrName;
    WCHAR		szBuffer[256];
	TERMINAL_DIRECTION td;

    dwLB = (bSelected ? IDC_SELECTED : IDC_NOTSELECTED);

    hr = pTerminal->get_Name( &bstrName );
    pTerminal->get_Direction( &td );

	if ( td == TD_RENDER )
	{
		wsprintfW(szBuffer, L"%s [Playback]", bstrName);
	}
	else
	{
		wsprintfW(szBuffer, L"%s [Record]", bstrName);	
	}

    i = SendDlgItemMessage(
                           dwLB,
                           LB_ADDSTRING,
                           0,
                           (LPARAM)szBuffer
                          );

    SysFreeString( bstrName );

    SendDlgItemMessage(
                       dwLB,
                       LB_SETITEMDATA,
                       (WPARAM) i,
                       (LPARAM) pTerminal
                      );

}

void
autoans::AddDynamicTerminalToListBox( BOOL bSelected )
{
    LONG            i;
    DWORD           dwLB;

    dwLB = (bSelected ? IDC_SELECTED : IDC_NOTSELECTED);


    i = SendDlgItemMessage(
                           dwLB,
                           LB_ADDSTRING,
                           0,
                           (LPARAM)L"Video Window"
                          );

    SendDlgItemMessage(
                       dwLB,
                       LB_SETITEMDATA,
                       (WPARAM) i,
                       (LPARAM) 0
                      );


    return;
}

void autoans::AddTerminalToAAList( ITTerminal * pTerminal )
{
    if ( NULL != pTerminal )
    {
        pTerminal->AddRef();
    }
    
    m_TerminalPtrList.push_back( pTerminal );
}


void autoans::OnClose()
{
    LONG        i, count;

    
    i = 0;

    count = SendDlgItemMessage(
                               IDC_SELECTED,
                               LB_GETCOUNT,
                               0,
                               0
                              );


    for( i = 0; i < count; i++ )
    {
        ITTerminal * pTerminal;

        
        pTerminal = (ITTerminal *)SendDlgItemMessage(
            IDC_SELECTED,
            LB_GETITEMDATA,
            i,
            0
            );

        if ( NULL != pTerminal )
        {
            pTerminal->Release();
        }
    }


    count = SendDlgItemMessage(
                               IDC_NOTSELECTED,
                               LB_GETCOUNT,
                               0,
                               0
                              );

    for ( i = 0; i < count; i++ )
    {
        ITTerminal * pTerminal;

        pTerminal = (ITTerminal *)SendDlgItemMessage(
            IDC_NOTSELECTED,
            LB_GETITEMDATA,
            i,
            0
            );

        if ( NULL != pTerminal )
        {
            pTerminal->Release();
        }
    }
    
	CDialog::OnClose();
    
}

void
CT3testDlg::DoAutoAnswer(
                         ITCallInfo * pCall
                        )
{
    ITAddress * pAddress;
    ITBasicCallControl * pBCC;
    HRESULT     hr;
    DataPtrList::iterator iter,end;
    TerminalPtrList::iterator terminaliter, terminalend;
    DWORD       dwSize;
    ITTerminalSupport * pTerminalSupport;
    BSTR        bstrTerminalClass;
    PWSTR       pwstr;
    

    StringFromIID(CLSID_VideoWindowTerm,&pwstr);
    bstrTerminalClass = SysAllocString( pwstr );
    CoTaskMemFree( pwstr );

    hr = pCall->get_Address( &pAddress );

    if ( !SUCCEEDED(hr) )
    {
        return;
    }

    hr = pAddress->QueryInterface(
                                  IID_ITTerminalSupport,
                                  (void **) &pTerminalSupport
                                 );

    if ( !SUCCEEDED(hr) )
    {
        pAddress->Release();
        return;
    }
    
    hr = pCall->QueryInterface(
                               IID_ITBasicCallControl,
                               (void **)&pBCC
                              );

    if ( !SUCCEEDED(hr) )
    {
        pTerminalSupport->Release();
        pAddress->Release();
        return;
    }

    iter = gDataPtrList.begin();
    end  = gDataPtrList.end();

    for ( ; iter != end ; iter++ )
    {
        if ( (*iter)->pAddress == pAddress )
        {
            break;
        }
    }

    pAddress->Release();

    if ( iter == end )
    {
        pBCC->Release();
        pTerminalSupport->Release();
        return;
    }

    dwSize = (*iter)->pTerminalPtrList->size();
    
    if ( 0 == dwSize )
    {
        pTerminalSupport->Release();
        pBCC->Release();
        return ;
    }

    terminaliter = (*iter)->pTerminalPtrList->begin();
    terminalend  = (*iter)->pTerminalPtrList->end();

    for( ; terminaliter != terminalend ; terminaliter++ )
    {
        ITTerminal * pTerminal;
        
        if ( NULL == (*terminaliter) )
        {
            hr = pTerminalSupport->CreateTerminal(
                bstrTerminalClass,
                (long)LINEMEDIAMODE_VIDEO,
                TD_RENDER,
                &pTerminal
                );
        }
        else
        {
            pTerminal = *terminaliter;
        }

//        hr = pBCC->SelectTerminal( pTerminal );

//        if ( !SUCCEEDED(hr) )
//        {
//        }

    }
    
    hr = pBCC->Answer();

    if ( !SUCCEEDED(hr) )
    {
    }
    
    pBCC->Release();
    pTerminalSupport->Release();
    SysFreeString( bstrTerminalClass );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3test\callnot.cpp ===
//

#include "stdafx.h"
#include "t3test.h"
#include "t3testd.h"
#include "callnot.h"
#include "control.h"

#ifdef _DEBUG

#ifndef _WIN64 // mfc 4.2's heap debugging features generate warnings on win64
#define new DEBUG_NEW
#endif

#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


extern CWnd * gpmainwnd;

HandleVideoWindowCrap(
                      ITCallInfo * pCallInfo
                     );

HRESULT
STDMETHODCALLTYPE
CTAPIEventNotification::Event(
                              TAPI_EVENT TapiEvent,
                              IDispatch * pEvent
                             )
{
    HRESULT hr;


    pEvent->AddRef();
    
    hr = PostMessage( gpmainwnd->m_hWnd, WM_USER+101, (WPARAM)TapiEvent, (LPARAM)pEvent );

    return hr;
    
}

afx_msg LONG CT3testDlg::OnTapiEvent(UINT u, LONG_PTR l)
{
    HRESULT         hr;
    TAPI_EVENT      TapiEvent;
    IDispatch *     pEvent;

    TapiEvent = (TAPI_EVENT)u;
    pEvent = (IDispatch *)l;
    
    switch (TapiEvent)
    {
        case TE_CALLNOTIFICATION:
        {
            ITAddress *                 pAddress;
            ITAddress *                 pCallAddress;
            ITCallInfo *                pCallInfo;
            ITCallNotificationEvent *   pCallNotify;


            //
            // get the currently selected address
            //
            if (CT3testDlg::GetAddress( &pAddress ))
            {
                //
                // get the event
                //
                pEvent->QueryInterface(IID_ITCallNotificationEvent, (void **)&pCallNotify );
                //
                // get the call
                //
                pCallNotify->get_Call( &pCallInfo );
                //
                // get the call's event
                //
                pCallInfo->get_Address( &pCallAddress );

                //
                // if this call is supposed to be on this
                // address, add it to the UI
                //
                if (pAddress == pCallAddress)
                {
                    // need to add a second reference for
                    // the tree view
                    CT3testDlg::AddCall( pCallInfo );
                }

                CALL_PRIVILEGE      cp;
                CALL_STATE          cs;
                
                pCallInfo->get_Privilege( &cp );

                if ( CP_OWNER == cp )
                {
                    DoAutoAnswer( pCallInfo );
                }

                pCallInfo->get_CallState(&cs);
                
                //
                // release our references
                // keep refernce to the call or it will
                // be destroyed
                //
                pCallAddress->Release();
                pCallNotify->Release();
            }
        }
        
        break;
        
        case TE_CALLSTATE:
        {
            ITCallStateEvent        * pCallStateEvent;
            ITCallInfo              * pCallInfo;
            CALL_STATE                cs;


            hr = pEvent->QueryInterface(IID_ITCallStateEvent, (void **)&pCallStateEvent);

            pCallStateEvent->get_Call( &pCallInfo );

            CT3testDlg::UpdateCall( pCallInfo );

            pCallStateEvent->get_State(
                                       &cs
                                      );

            if (CS_CONNECTED == cs)
            {
//                HandleVideoWindowCrap( pCallInfo );
            }

            pCallInfo->Release();
            pCallStateEvent->Release();

            break;
        }

        case TE_CALLHUB:
        {
            CT3testDlg::HandleCallHubEvent( pEvent );

            break;
        }

        case TE_TAPIOBJECT:
        {
            CT3testDlg::HandleTapiObjectMessage( pEvent );
            break;
        }
        
        break;

        case TE_CALLMEDIA:
        {
            WCHAR * pwstrEvent;
            WCHAR * pwstrCause;

            ITCallMediaEvent  * pCallMediaEvent;
            hr = pEvent->QueryInterface( IID_ITCallMediaEvent,
                                         (void **)&pCallMediaEvent );

            if (FAILED(hr))
            {
                pwstrEvent = pwstrCause = L"can't get event interface";
            }
            else
            {
                CALL_MEDIA_EVENT    cme;
                hr = pCallMediaEvent->get_Event( &cme );

                if (FAILED(hr))
                {
                    pwstrEvent = L"can't get event type";
                }
                else
                {
                    switch ( cme )
                    {
                    case CME_NEW_STREAM:
                        pwstrEvent = L"CME_NEW_STREAM";
                        break;

                    case CME_STREAM_FAIL:
                        pwstrEvent = L"CME_STREAM_FAIL";
                        break;
            
                    case CME_TERMINAL_FAIL:
                        pwstrEvent = L"CME_TERMINAL_FAIL";
                        break;

                    case CME_STREAM_NOT_USED:
                        pwstrEvent = L"CME_STREAM_NOT_USED";
                        break;

                    case CME_STREAM_ACTIVE:
                        pwstrEvent = L"CME_STREAM_ACTIVE";
                        break;

                    case CME_STREAM_INACTIVE:
                        pwstrEvent = L"CME_STREAM_INACTIVE";
                        break;

                    default:
                        pwstrEvent = L"type undefined";
                        break;
                    }
                }
            }

            CALL_MEDIA_EVENT_CAUSE    cmec;

            hr = pCallMediaEvent->get_Cause( &cmec );

            pCallMediaEvent->Release();

            if (FAILED(hr))
            {
                pwstrCause = L"can't get event cause";
            }
            else
            {
                switch ( cmec )
                {
                case CMC_UNKNOWN:
                    pwstrCause = L"CMC_UNKNOWN";
                    break;

                case CMC_BAD_DEVICE:
                    pwstrCause = L"CMC_BAD_DEVICE";
                    break;
            
                case CMC_CONNECT_FAIL:
                    pwstrCause = L"CMC_CONNECT_FAIL";
                    break;
            
                case CMC_LOCAL_REQUEST:
                    pwstrCause = L"CMC_LOCAL_REQUEST";
                    break;

                case CMC_REMOTE_REQUEST:
                    pwstrCause = L"CMC_REMOTE_REQUEST";
                    break;

                case CMC_MEDIA_TIMEOUT:
                    pwstrCause = L"CMC_MEDIA_TIMEOUT";
                    break;

                case CMC_MEDIA_RECOVERED:
                    pwstrCause = L"CMC_MEDIA_RECOVERED";
                    break;

                default:
                    pwstrCause = L"cause undefined";
                    break;
                }
            }

            ::MessageBox(NULL, pwstrEvent, pwstrCause, MB_OK);

            break;
        }
       
        case TE_ADDRESS:
        {
            ITAddressEvent      * pAddressEvent;
            ITTerminal          * pTerminal;
            ITAddress           * pAddress;
            LONG                lMediaType;
            LONG                lSelectedMediaType;
            BSTR                bstrName = NULL;
            ADDRESS_EVENT       ae;

            hr = pEvent->QueryInterface(IID_ITAddressEvent, (void **)&pAddressEvent);

            if (SUCCEEDED(hr))
            {
                hr = pAddressEvent->get_Event( &ae );
            
                if (SUCCEEDED(hr))
                {
                    hr = pAddressEvent->get_Terminal( &pTerminal );

                    if (SUCCEEDED(hr))
                    {
                        hr = pTerminal->get_Name( &bstrName );

                        if (SUCCEEDED(hr))
                        {
                            switch(ae)
                            {
                            case AE_NEWTERMINAL:
                                ::MessageBox(NULL, bstrName, L"AE_NEWTERMINAL", MB_OK);
                                break;
                    
                            case AE_REMOVETERMINAL:
                                ::MessageBox(NULL, bstrName, L"AE_REMOVETERMINAL", MB_OK);
                                break;
                    
                            }

                            SysFreeString( bstrName );

                            hr = pAddressEvent->get_Address( &pAddress );

                            if (SUCCEEDED(hr))
                            {
                                hr = pTerminal->get_MediaType( &lMediaType );

                                if (SUCCEEDED(hr))
                                {
                                    if (CT3testDlg::GetMediaType( &lSelectedMediaType ) && ( lSelectedMediaType == lMediaType))
                                    {
                                        CT3testDlg::ReleaseTerminals();
                                        CT3testDlg::UpdateTerminals( pAddress, lMediaType );
                                    }
                                }

                                pAddress->Release();
                            }
                        }
                        pTerminal->Release();
                    }
                }
                pAddressEvent->Release();
            }

            break;
        }

        default:

            break;
    }

    pEvent->Release();
    
    return S_OK;
}


#ifdef ENABLE_DIGIT_DETECTION_STUFF

HRESULT
STDMETHODCALLTYPE
CDigitDetectionNotification::DigitDetected(
                                           unsigned char ucDigit,
                                           TAPI_DIGITMODE DigitMode,
                                           long ulTickCount
                                          )
{
    return S_OK;
}
    
#endif // ENABLE_DIGIT_DETECTION_STUFF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3test\callnot.h ===
// CallNotification.h : Declaration of the CCallNotification

#ifndef __CALLNOTIFICATION_H_
#define __CALLNOTIFICATION_H_

/////////////////////////////////////////////////////////////////////////////
//
// CTAPIEventNotification
//
/////////////////////////////////////////////////////////////////////////////
class CTAPIEventNotification :
	public ITTAPIEventNotification
{

private:

    LONG m_lRefCount;


public:

    CTAPIEventNotification()
    { 
        m_lRefCount = 0;
    }

	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void **ppvObject)
    {
        if (iid == IID_ITTAPIEventNotification)
        {
            *ppvObject = (void *)this;
            AddRef();
            return S_OK;
        }

        if (iid == IID_IUnknown)
        {
            *ppvObject = (void *)this;
            AddRef();
            return S_OK;
        }

        return E_NOINTERFACE;
    }
	ULONG STDMETHODCALLTYPE AddRef()
    {
        ULONG l = InterlockedIncrement(&m_lRefCount);
        return l;
    }
    
	ULONG STDMETHODCALLTYPE Release()
    {
        ULONG l = InterlockedDecrement(&m_lRefCount);

        if ( 0 == l)
        {
            delete this;
        }

        return l;
    }


// ICallNotification
public:

	    HRESULT STDMETHODCALLTYPE Event(
            TAPI_EVENT TapiEvent,
            IDispatch * pEvent
            );

};


#ifdef ENABLE_DIGIT_DETECTION_STUFF

/////////////////////////////////////////////////////////////////////////////
//
// CDigitDetectionNotification
//
/////////////////////////////////////////////////////////////////////////////
class CDigitDetectionNotification :
	public ITDigitDetectionNotification
{

private:

    LONG m_lRefCount;


public:
    
    CDigitDetectionNotification()
    { 
        m_lRefCount = 0;
    }

	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void **ppvObject)
    {
        if (iid == IID_ITDigitDetectionNotification)
        {
            *ppvObject = (void *)this;
            AddRef();
            return S_OK;
        }

        if (iid == IID_IUnknown)
        {
            *ppvObject = (void *)this;
            AddRef();
            return S_OK;
        }

        if (iid == IID_IDispatch)
        {
            *ppvObject = (void *)this;
            AddRef();
            return S_OK;
        }
        return E_NOINTERFACE;
    }

	ULONG STDMETHODCALLTYPE AddRef()
    {
        ULONG l = InterlockedIncrement(&m_lRefCount);

        return l;
    }
    
	ULONG STDMETHODCALLTYPE Release()
    {
        ULONG l = InterlockedDecrement(&m_lRefCount);

        if ( 0 == l)
        {
            delete this;
        }

        return l;
    }


// ICallNotification
public:

    HRESULT STDMETHODCALLTYPE DigitDetected(
            unsigned char ucDigit,
            TAPI_DIGITMODE DigitMode,
            long ulTickCount
            );
    
};

#endif // ENABLE_DIGIT_DETECTION_STUFF

#endif //__CALLNOTIFICATION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3test\confdlg.h ===
#if !defined(AFX_CONFDLG_H)
#define AFX_CONFDLG_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "rend.h"

/////////////////////////////////////////////////////////////////////////////
// CConfDlg dialog

class CConfDlg : public CDialog
{
// Construction
public:
	CConfDlg(CWnd* pParent = NULL);
	enum { IDD = IDD_CONFDLG };
    BSTR       m_bstrDestAddress;
    ITDirectory * m_pDirectory;
    
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    void PopulateConferences();
    void ListObjects( ITDirectory * );
    BOOL CConfDlg::OnInitDialog();
    virtual void OnOK();
    afx_msg void OnDestroy();
    DECLARE_MESSAGE_MAP()
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3test\externs.h ===
#include "stdafx.h"
#include "t3test.h"

extern ITTAPI * gpTapi;
extern HWND ghAddressesWnd;
extern HWND ghTerminalsWnd;
extern HWND ghMediaTypesWnd;
extern HWND ghCallsWnd;
extern HWND ghSelectedWnd;
extern HWND ghCreatedWnd;
extern HWND ghClassesWnd;
extern HWND ghListenWnd;
extern HTREEITEM ghAddressesRoot;
extern HTREEITEM ghTerminalsRoot;
extern HTREEITEM ghMediaTypesRoot;
extern HTREEITEM ghCallsRoot;
extern HTREEITEM ghSelectedRoot;
extern HTREEITEM ghCreatedRoot;
extern HTREEITEM ghClassesRoot;
extern HTREEITEM ghListenRoot;

extern long       gulAdvise;
extern BOOL gbUpdatingStuff;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3test\event.cpp ===
#include "stdafx.h"
#include "t3test.h"
#include "t3testD.h"
#include "externs.h"

void
CT3testDlg::HandleCallHubEvent( IDispatch * pEvent )
{
    HRESULT             hr;
    ITCallHubEvent *    pCallHubEvent;
    CALLHUB_EVENT       che;
    

    hr = pEvent->QueryInterface(
                                IID_ITCallHubEvent,
                                (void **)&pCallHubEvent
                               );

    if (!SUCCEEDED(hr))
    {
        return;
    }

    hr = pCallHubEvent->get_Event( &che );

    if (!SUCCEEDED(hr))
    {
        return;
    }

    switch ( che )
    {
        case CHE_CALLHUBNEW:

            break;
            
        case CHE_CALLHUBIDLE:

            break;
            
        default:
            break;
    }

    pCallHubEvent->Release();

}


void
CT3testDlg::HandleTapiObjectMessage( IDispatch * pEvent )
{
    ITTAPIObjectEvent * pte;
    HRESULT             hr;
    TAPIOBJECT_EVENT    te;

    hr = pEvent->QueryInterface(
                                IID_ITTAPIObjectEvent,
                                (void**)&pte
                               );

    if ( !SUCCEEDED(hr) )
    {
        return;
    }

    pte->get_Event( &te );

    switch (te)
    {
        case TE_ADDRESSCREATE:
        case TE_ADDRESSREMOVE:

            ReleaseMediaTypes();
            ReleaseTerminals();
            ReleaseCalls();
            ReleaseSelectedTerminals();
            ReleaseCreatedTerminals();
            ReleaseTerminalClasses();
            ReleaseListen();
            ReleaseAddresses();
            InitializeAddressTree();

            break;
            
        default:
            break;
    }

    pte->Release();
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3test\ilsdlg.cpp ===
// autoans.cpp : implementation file
//
#include "stdafx.h"
#include "t3test.h"
#include "t3testd.h"
#include "ilsdlg.h"
#include "servname.h"
#include "resource.h"
#include "strings.h"


#ifdef _DEBUG

#ifndef _WIN64 // mfc 4.2's heap debugging features generate warnings on win64
#define new DEBUG_NEW
#endif

#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CILSDlg::CILSDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CILSDlg::IDD, pParent)
{
}


void CILSDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
}

BOOL CILSDlg::OnInitDialog()
{
    CDialog::OnInitDialog();
    ListServers();
    return TRUE;
}


void CILSDlg::OnOK()
{
    SaveServers();
    
	CDialog::OnOK();
}


void CILSDlg::OnDestroy() 
{
    CleanUp();
    CDialog::OnDestroy();
}


void CILSDlg::ListServers()
{
    HRESULT         hr;
    LPWSTR        * ppServers;
    DWORD           dw;
    
    hr = ListILSServers(
                        &ppServers,
                        &dw
                       );

    if ( !SUCCEEDED(hr) )
    {
        return;
    }

    while (dw)
    {
        dw--;

        SendDlgItemMessage(
                           IDC_ILSLIST,
                           LB_ADDSTRING,
                           0,
                           (LPARAM) ppServers[dw]
                          );

        CoTaskMemFree( ppServers[dw] );
        
    }

    CoTaskMemFree( ppServers );
    
}

void CILSDlg::SaveServers()
{
    HKEY        hKey, hAppKey;
    DWORD       dw;

    
    if ( RegOpenKeyEx(
                      HKEY_LOCAL_MACHINE,
                      PARENTKEY,
                      0,
                      KEY_WRITE,
                      &hKey
                     ) != ERROR_SUCCESS )
    {
    }

    if ( RegCreateKeyEx(
                        hKey,
                        APPKEY,
                        0,
                        L"",
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hAppKey,
                        &dw
                       ) != ERROR_SUCCESS )
    {
    }

    RegCloseKey( hKey );

        
    RegDeleteKey(
                 hAppKey,
                 SERVERKEY
                );
    
    if ( RegCreateKeyEx(
                        hAppKey,
                        SERVERKEY,
                        0,
                        L"",
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hKey,
                        &dw
                       ) != ERROR_SUCCESS )
    {
    }

    RegCloseKey (hAppKey );
    
    dw = SendDlgItemMessage(
                            IDC_ILSLIST,
                            LB_GETCOUNT,
                            0,
                            0
                           );

    while ( 0 != dw )
    {
        WCHAR szServer[256];
        WCHAR szBuffer[256];
        
        dw--;

        wsprintf(szServer, L"server%d", dw);
                 
        SendDlgItemMessage(
                           IDC_ILSLIST,
                           LB_GETTEXT,
                           dw,
                           (LPARAM)szBuffer
                          );

        RegSetValueEx(
                      hKey,
                      szServer,
                      0,
                      REG_SZ,
                      (BYTE *)szBuffer,
                      lstrlenW(szBuffer) * sizeof(WCHAR)
                     );
    }
}

void CILSDlg::CleanUp()
{
}

void CILSDlg::OnAdd()
{
    CServNameDlg dlg;
    
    if (IDOK == dlg.DoModal())
    {
        SendDlgItemMessage(
                           IDC_ILSLIST,
                           LB_ADDSTRING,
                           0,
                           (LPARAM)(LPCTSTR)(dlg.m_pszServerName)
                          );
    }   
}

void CILSDlg::OnRemove()
{
    DWORD       dw;

    dw = SendDlgItemMessage(
                            IDC_ILSLIST,
                            LB_GETCURSEL,
                            0,
                            0
                           );

    if ( dw != LB_ERR )
    {
        SendDlgItemMessage(
                           IDC_ILSLIST,
                           LB_DELETESTRING,
                           dw,
                           0
                          );
    }
}


BEGIN_MESSAGE_MAP(CILSDlg, CDialog)
	ON_WM_DESTROY()
    ON_BN_CLICKED(IDC_ADD, OnAdd)
    ON_BN_CLICKED(IDC_REMOVE, OnRemove)
END_MESSAGE_MAP()

            
HRESULT ListILSServers(
                    LPWSTR ** pppServers,
                    DWORD * pdwNumServers
                   )
{
    HKEY        hKey, hAppKey;
    DWORD       dw, dwSize;

    //
    // look in the directory for the
    //
    if ( RegOpenKeyEx(
                      HKEY_LOCAL_MACHINE,
                      PARENTKEY,
                      0,
                      KEY_WRITE,
                      &hKey
                     ) != ERROR_SUCCESS )
    {
    }

    if ( RegOpenKeyEx(
                      hKey,
                      APPKEY,
                      0,
                      KEY_ALL_ACCESS,
                      &hAppKey
                     ) != ERROR_SUCCESS )
    {
        RegCloseKey( hKey );
        return E_FAIL;
    }

    RegCloseKey( hKey );
    
    if ( RegOpenKeyEx(
                      hAppKey,
                      SERVERKEY,
                      0,
                      KEY_ALL_ACCESS,
                      &hKey
                     ) != ERROR_SUCCESS )
    {
        RegCloseKey(hAppKey);
        return E_FAIL;
    }

    RegCloseKey (hAppKey );
    
    dw = 0;
    
    while (TRUE)
    {
        WCHAR       szBuffer[256];
        WCHAR       szServer[256];
        DWORD       dwType;
        
        wsprintf(szBuffer, L"server%d", dw);

        if ( RegQueryValueEx(
                             hKey,
                             szBuffer,
                             NULL,
                             NULL,
                             NULL,
                             &dwSize
                            ) != ERROR_SUCCESS )
        {
            break;
        }

        dw++;
    }

    *pppServers = (LPWSTR *)CoTaskMemAlloc( dw * sizeof (LPWSTR) );

    if ( NULL == *pppServers )
    {
        return E_OUTOFMEMORY;
    }

    dw = 0;
    
    while (TRUE)
    {
        WCHAR       szBuffer[256];
        WCHAR       szServer[256];
        DWORD       dwType;
        
        wsprintf(szBuffer, L"server%d", dw);

        dwSize = 256;
        
        if ( RegQueryValueEx(
                             hKey,
                             szBuffer,
                             NULL,
                             NULL,
                             (LPBYTE)szServer,
                             &dwSize
                            ) != ERROR_SUCCESS )
        {
            break;
        }

        (*pppServers)[dw] = (LPWSTR) CoTaskMemAlloc( (lstrlenW(szServer) + 1) * sizeof(WCHAR));
        
        lstrcpy(
                (*pppServers)[dw],
                szServer
               );
        dw++;
    }

    *pdwNumServers = dw;

    RegCloseKey( hKey );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3test\gets.cpp ===
#include "stdafx.h"
#include "t3test.h"
#include "t3testD.h"
#include "calldlg.h"
#include "callnot.h"
#include "externs.h"


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetMediaTypeName
//
// Convert the mediatype bstr to a string, like
// "audio in"
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::GetMediaTypeName(
                                  long lMediaType,
                                  LPWSTR szString
                                 )
{
    if (lMediaType == (long)LINEMEDIAMODE_AUTOMATEDVOICE)
    {
        lstrcpyW(
                 szString,
                 L"Audio"
                );

    }
    else if (lMediaType == (long)LINEMEDIAMODE_VIDEO)
    {
        lstrcpyW(
                 szString,
                 L"Video"
                );

    }
    else if (lMediaType == (long)LINEMEDIAMODE_DATAMODEM)
    {
        lstrcpyW(
                 szString,
                 L"DataModem"
                );

    }
    else if (lMediaType == (long)LINEMEDIAMODE_G3FAX)
    {
        lstrcpyW(
                 szString,
                 L"G3Fax"
                );

    }
    else
    {
        lstrcpyW(
                 szString,
                 L"Unknown MediaType - "
                );
    }

    
}

LPWSTR CT3testDlg::GetCallPrivilegeName(
                                        ITCallInfo * pCall
                                       )
{
    CALL_PRIVILEGE      cp;

    
    pCall->get_Privilege( &cp );

    if (CP_OWNER == cp)
    {
        return SysAllocString(L"OWNER");
        
    }
    else
    {
        return SysAllocString(L"MONITOR");
    }

    return NULL;
}


LPWSTR CT3testDlg::GetCallStateName(
                                    ITCallInfo * pCall
                                   )
{
    CALL_STATE          cs;
    
    //
    // get the current call state
    //
    pCall->get_CallState( &cs );

    //
    // make the name
    //
    switch( cs )
    {
        case CS_INPROGRESS:

            return SysAllocString( L"INPROGRESS" );
            break;

        case CS_CONNECTED:

            return SysAllocString ( L"CONNECTED" );
            break;

        case CS_DISCONNECTED:

            return SysAllocString ( L"DISCONNECTED" );
            break;

        case CS_OFFERING:

            return SysAllocString ( L"OFFERING" );
            break;

        case CS_IDLE:

            return SysAllocString( L"IDLE" );
            break;

        default:

            return SysAllocString( L"<Unknown Call State>" );
            break;
    }


    return NULL;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetAddress
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL CT3testDlg::GetAddress( ITAddress ** ppAddress )
{
    HTREEITEM           hItem;
    TV_ITEM             item;

    hItem = TreeView_GetSelection(
                                  ghAddressesWnd
                                 );

    if (NULL == hItem)
    {
        return FALSE;
    }

    item.mask = TVIF_HANDLE | TVIF_PARAM;
    item.hItem = hItem;

    TreeView_GetItem(
                     ghAddressesWnd,
                     &item
                    );

    *ppAddress = (ITAddress *)item.lParam;

    if (NULL == *ppAddress)
    {
//        ::MessageBox(NULL, L"Select an Address", NULL, MB_OK);
        return FALSE;
    }

    return TRUE;
    
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL CT3testDlg::GetTerminal( ITTerminal ** ppTerminal )
{
    HTREEITEM           hItem;
    TV_ITEM             item;

    hItem = TreeView_GetSelection(
                                  ghTerminalsWnd
                                 );

    if (NULL == hItem)
    {
        return FALSE;
    }

    item.mask = TVIF_HANDLE | TVIF_PARAM;
    item.hItem = hItem;

    TreeView_GetItem(
                     ghTerminalsWnd,
                     &item
                    );

    *ppTerminal = (ITTerminal *)item.lParam;

    if (NULL == *ppTerminal)
    {
        ::MessageBox(NULL, L"Select a Terminal", NULL, MB_OK);
        return FALSE;
    }

    return TRUE;
    
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetCall
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL CT3testDlg::GetCall( ITCallInfo ** ppCallInfo )
{
    HTREEITEM           hItem;
    TV_ITEM             item;

    hItem = TreeView_GetSelection(
                                  ghCallsWnd
                                 );

    if (NULL == hItem)
    {
        return FALSE;
    }

    item.mask = TVIF_HANDLE | TVIF_PARAM;
    item.hItem = hItem;

    TreeView_GetItem(
                     ghCallsWnd,
                     &item
                    );

    *ppCallInfo = (ITCallInfo *)item.lParam;

    if (NULL == *ppCallInfo)
    {
        //::MessageBox(NULL, L"Select a Call", NULL, MB_OK);
        return FALSE;
    }

    return TRUE;
    
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetMediaType
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL CT3testDlg::GetMediaType( long * plMediaType )
{
    HTREEITEM           hItem;
    TV_ITEM             item;

    hItem = TreeView_GetSelection(
                                  ghMediaTypesWnd
                                 );

    if (NULL == hItem)
    {
        return FALSE;
    }

    item.mask = TVIF_HANDLE | TVIF_PARAM;
    item.hItem = hItem;

    TreeView_GetItem(
                     ghMediaTypesWnd,
                     &item
                    );

    *plMediaType = (long)(item.lParam);

    if (0 == *plMediaType)
    {
        return FALSE;
    }

    return TRUE;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetTerminalClass
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL CT3testDlg::GetTerminalClass( BSTR * pbstrClass )
{
    HTREEITEM       hItem;
    TV_ITEM         item;
    GUID *          pguid;

    hItem = TreeView_GetSelection(
                                  ghClassesWnd
                                 );

    if (NULL == hItem)
    {
        return FALSE;
    }

    item.mask = TVIF_HANDLE | TVIF_PARAM;
    item.hItem = hItem;

    TreeView_GetItem(
                     ghClassesWnd,
                     &item
                    );

    pguid = (GUID *)item.lParam;

    if (NULL == pguid)
    {
        return FALSE;
    }

    LPWSTR      lphold;

    
    StringFromIID(
                  *pguid,
                  &lphold
                 );

    *pbstrClass = SysAllocString(lphold);

    CoTaskMemFree(lphold);
    
    return TRUE;
}




//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetCreatedTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL CT3testDlg::GetCreatedTerminal( ITTerminal ** ppTerminal )
{
    HTREEITEM       hItem;
    TV_ITEM         item;

    hItem = TreeView_GetSelection(
                                  ghCreatedWnd
                                 );

    if (NULL == hItem)
    {
        return FALSE;
    }

    item.mask = TVIF_HANDLE | TVIF_PARAM;
    item.hItem = hItem;

    TreeView_GetItem(
                     ghCreatedWnd,
                     &item
                    );

    *ppTerminal = (ITTerminal *)item.lParam;

    if (NULL == *ppTerminal)
    {
        return FALSE;
    }

    return TRUE;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetSelectedTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL CT3testDlg::GetSelectedTerminal( ITTerminal ** ppTerminal )
{
    HTREEITEM       hItem;
    TV_ITEM         item;

    hItem = TreeView_GetSelection(
                                  ghSelectedWnd
                                 );

    if (NULL == hItem)
    {
        return FALSE;
    }

    item.mask = TVIF_HANDLE | TVIF_PARAM;
    item.hItem = hItem;

    TreeView_GetItem(
                     ghSelectedWnd,
                     &item
                    );

    *ppTerminal = (ITTerminal *)item.lParam;

    if (NULL == *ppTerminal)
    {
        return FALSE;
    }

    return TRUE;
}


BSTR CT3testDlg::GetTerminalClassName( GUID * pguid )
{
    if (IsEqualIID( *pguid, CLSID_VideoWindowTerm ))
    {
        return SysAllocString( L"Video" );
    }

#ifdef ENABLE_DIGIT_DETECTION_STUFF
    else if (IsEqualIID( *pguid, CLSID_DigitTerminal ))
    {
        return SysAllocString( L"Digit Terminal" );
    }
    else if (IsEqualIID( *pguid, CLSID_DataTerminal ))
    {
        return SysAllocString( L"Data Terminal" );
    }
#endif // ENABLE_DIGIT_DETECTION_STUFF

    else
    {
        return SysAllocString( L"Unknown Dynamic Type" );
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3test\confdlg.cpp ===
// autoans.cpp : implementation file
//
#include "stdafx.h"

#include "t3test.h"
#include "t3testd.h"
#include "confdlg.h"
#include "strings.h"
#include "resource.h"


#ifdef _DEBUG

#ifndef _WIN64 // mfc 4.2's heap debugging features generate warnings on win64
#define new DEBUG_NEW
#endif

#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CConfDlg::CConfDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CConfDlg::IDD, pParent)
{
        m_bstrDestAddress = NULL;
}


void CConfDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
}

BOOL CConfDlg::OnInitDialog()
{
    CDialog::OnInitDialog();
    PopulateConferences();
    return TRUE;
}

void CConfDlg::PopulateConferences()
{
    ITRendezvous *      pRend;
    IEnumDirectory *    pEnumDirectory;
    HRESULT             hr;
    ITDirectory *       pDirectory;
    LPWSTR *            ppServers;
    DWORD               dw;
    
    //
    // create the rendezvous control.
    //
    hr = ::CoCreateInstance(
                            CLSID_Rendezvous,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_ITRendezvous,
                            (void **)&pRend
                           );
    
    if (FAILED(hr))
    {
        return;
    }


    hr = pRend->EnumerateDefaultDirectories(
        &pEnumDirectory
        );

    if (FAILED(hr))
    {
        pRend->Release();
    
        return;
    }

    while (TRUE)
    {

        DWORD dwFetched = 0;

        hr = pEnumDirectory->Next(
                                  1,
                                  &pDirectory,
                                  &dwFetched
                                 );

        if ( S_OK != hr )
        {
            break;
        }

        DIRECTORY_TYPE type;
        // print out the names of the conference found.
        hr = pDirectory->get_DirectoryType(&type);
        if ( FAILED(hr) )
        {
            pDirectory->Release();
            continue;
        }

        if (type == DT_ILS)
        {
            break;
        }

        pDirectory->Release();

    }

    pEnumDirectory->Release();

    //
    // if hr is s_false, we went through the enumerate
    // without finding an ils server
    //
    if ( S_OK == hr )
    {
        hr = pDirectory->Connect(FALSE);

        if ( SUCCEEDED(hr))
        {
            ListObjects( pDirectory );
        }

        pDirectory->Release();
    }

    hr = ListILSServers(
                        &ppServers,
                        &dw
                       );

    if ( !SUCCEEDED(hr) )
    {
        return;
    }
    
    while ( dw )
    {
        dw--;

        hr = pRend->CreateDirectory(
                                    DT_ILS,
                                    ppServers[dw],
                                    &pDirectory
                                   );

        if ( SUCCEEDED(hr) )
        {
            hr = pDirectory->Connect(FALSE);

            if ( SUCCEEDED(hr) )
            {
                ListObjects( pDirectory );
            }

            pDirectory->Release();
        }

        CoTaskMemFree( ppServers[dw] );
    }

    CoTaskMemFree( ppServers );

}

void
CConfDlg::ListObjects( ITDirectory * pDirectory )
{
    BSTR            bstrNameToSearch;
    BSTR            bstrDirName;
    HRESULT         hr;
    int             i;
    
    
    bstrNameToSearch = SysAllocString(L"*");

    if (bstrNameToSearch == NULL)
    {
        return;
    }

    IEnumDirectoryObject * pEnum;
    
    hr = pDirectory->EnumerateDirectoryObjects(
        OT_CONFERENCE,
        bstrNameToSearch,
        &pEnum
        );

    SysFreeString( bstrNameToSearch );

    if (FAILED(hr))
    {
        return;
    }

    pDirectory->get_DisplayName( &bstrDirName );

    // print out the names of all the users found.
    while (TRUE)
    {
        ITDirectoryObject *     pObject;
        BSTR                    bstrObjectName;
        WCHAR                   szBuffer[256];

        hr = pEnum->Next(
                         1,
                         &pObject,
                         NULL
                        );
        
        if ( S_OK != hr )
        {
            break;
        }

        hr = pObject->get_Name(&bstrObjectName);
        
        if (FAILED(hr))
        {
            continue;
        }

        wsprintf(szBuffer, L"%s: %s", bstrDirName, bstrObjectName );
        
        i = SendDlgItemMessage(
                               IDC_CONFLIST,
                               LB_ADDSTRING,
                               0,
                               (LPARAM)szBuffer
                              );

        SysFreeString(bstrObjectName);

        SendDlgItemMessage(
                           IDC_CONFLIST,
                           LB_SETITEMDATA,
                           i,
                           (LPARAM) pObject
                          );
    }

    SysFreeString( bstrDirName );
    
    pEnum->Release();
}

void CConfDlg::OnOK()
{
    DWORD       i;
    HRESULT     hr;
    
    i = SendDlgItemMessage(
                           IDC_CONFLIST,
                           LB_GETCURSEL,
                           0,
                           0
                          );

    if (LB_ERR != i)
    {
        ITDirectoryObject *     pObject;
        IEnumDialableAddrs *    pEnumAddress;

        
        pObject = (ITDirectoryObject *)SendDlgItemMessage(
            IDC_CONFLIST,
            LB_GETITEMDATA,
            i,
            0
            );

        hr = pObject->EnumerateDialableAddrs(
                                             LINEADDRESSTYPE_SDP,
                                             &pEnumAddress
                                            );

        if ( !SUCCEEDED(hr) )
        {
        }

        hr = pEnumAddress->Next(
                                1,
                                &m_bstrDestAddress,
                                NULL
                               );

        if ( S_OK != hr )
        {
        }

        pEnumAddress->Release();
    }

    
	CDialog::OnOK();
}


void CConfDlg::OnDestroy() 
{
    DWORD       count;

    CDialog::OnDestroy();

    count = SendDlgItemMessage(
                               IDC_CONFLIST,
                               LB_GETCOUNT,
                               0,
                               0
                              );

    while ( 0 != count )
    {
        ITDirectoryObject * pObject;

        count--;
        
        pObject = (ITDirectoryObject *)SendDlgItemMessage(
            IDC_CONFLIST,
            LB_GETITEMDATA,
            count,
            0
            );

        pObject->Release();
    }
}


BEGIN_MESSAGE_MAP(CConfDlg, CDialog)
	ON_WM_DESTROY()
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3test\ilsdlg.h ===
#if !defined(AFX_ILSDlg_H)
#define AFX_ILSDlg_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "rend.h"

/////////////////////////////////////////////////////////////////////////////
// CILSDlg dialog

class CILSDlg : public CDialog
{
// Construction
public:
	CILSDlg(CWnd* pParent = NULL);
	enum { IDD = IDD_ILSSERVERS };
    
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    BOOL CILSDlg::OnInitDialog();
    virtual void OnOK();
    afx_msg void OnDestroy();
    afx_msg void OnAdd();
    afx_msg void OnRemove();
    void ListServers();
    void SaveServers();
    void CleanUp();
    DECLARE_MESSAGE_MAP()
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3test\rate.cpp ===
// RateDlg.cpp : implementation file
//

#include "stdafx.h"
#include "t3test.h"
#include "rate.h"

#ifdef _DEBUG

#ifndef _WIN64 // mfc 4.2's heap debugging features generate warnings on win64
#define new DEBUG_NEW
#endif

#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRateDlg dialog


CRateDlg::CRateDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CRateDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CRateDlg)
	m_dwMinRate = 0;
    m_dwMaxRate = 0;

	//}}AFX_DATA_INIT
}


void CRateDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRateDlg)
	DDX_Text(pDX, IDC_MINRATE, m_dwMinRate);
    DDX_Text(pDX, IDC_MAXRATE, m_dwMaxRate);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRateDlg, CDialog)
	//{{AFX_MSG_MAP(CRateDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRateDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3test\rate.h ===
#if !defined(AFX_RATEDLG_H__2584F283_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_)
#define AFX_RATEDLG_H__2584F283_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// RateDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CRateDlg dialog

class CRateDlg : public CDialog
{
// Construction
public:
	CRateDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CRateDlg)
	enum { IDD = IDD_RATE };
    DWORD m_dwMinRate;
    DWORD m_dwMaxRate;
    
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRateDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CRateDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_RATEDLG_H__2584F283_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3test\menus.cpp ===
#include "stdafx.h"
#include "t3test.h"
#include "t3testD.h"
#include "calldlg.h"
#include "callnot.h"
#include "externs.h"
#include "control.h"

void
CT3testDlg::CreateSelectedTerminalMenu(
                                       POINT pt,
                                       HWND hWnd
                                      )
{
    ITTerminal *                    pTerminal;

#ifdef ENABLE_DIGIT_DETECTION_STUFF
    ITDigitGenerationTerminal *     pDigitGeneration;
    ITDigitDetectionTerminal *         pDigitDetect;
#endif // ENABLE_DIGIT_DETECTION_STUFF


    HRESULT                         hr;
    ITBasicAudioTerminal *          pBasicAudio;
    long                            lval;
    
    //
    // get the terminal in question
    //
    if (!GetSelectedTerminal( &pTerminal ))
    {
        return;
    }

    hr = pTerminal->QueryInterface(
                                   IID_ITBasicAudioTerminal,
                                   (void **) &pBasicAudio
                                  );

    if ( SUCCEEDED(hr) )
    {
        pBasicAudio->get_Volume( &lval );
        pBasicAudio->put_Volume( lval );
        pBasicAudio->get_Balance( &lval );
        pBasicAudio->put_Balance( lval );
        pBasicAudio->Release();
    }

#ifdef ENABLE_DIGIT_DETECTION_STUFF
    hr = pTerminal->QueryInterface(
                                   IID_ITDigitGenerationTerminal,
                                   (void **) &pDigitGeneration
                                  );

    if (SUCCEEDED(hr))
    {
        DoDigitGenerationTerminalMenu(hWnd, &pt);

        pDigitGeneration->Release();
        
        return;
    }
    
    hr = pTerminal->QueryInterface(
                                   IID_ITDigitDetectionTerminal,
                                   (void **) &pDigitDetect
                                  );

    if (SUCCEEDED(hr))
    {
        DoDigitDetectTerminalMenu(hWnd,&pt);

        pDigitDetect->Release();
        
        return;
    }
#endif // ENABLE_DIGIT_DETECTION_STUFF


}

void CT3testDlg::DoDigitGenerationTerminalMenu(
                                               HWND hWnd,
                                               POINT * pPt
                                              )
{
    //
    // create the menu
    //
    HMENU                   hMenu;

    hMenu = CreatePopupMenu();

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_MODESUPPORTED,
               L"Modes Supported"
              );

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_GENERATE,
               L"Generate"
              );

    // actually show menu
    TrackPopupMenu(
                   hMenu,
                   TPM_LEFTALIGN | TPM_TOPALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                   pPt->x,
                   pPt->y,
                   0,
                   hWnd,
                   NULL
                  );
}
    
void CT3testDlg::DoDigitDetectTerminalMenu(
                                           HWND hWnd,
                                           POINT * pPt
                                          )
{
    //
    // create the menu
    //
    HMENU                   hMenu;

    hMenu = CreatePopupMenu();

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_MODESUPPORTED2,
               L"Modes Supported"
              );

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_STARTDETECT,
               L"Start Detection"
              );

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_STOPDETECT,
               L"Stop Detection"
              );

    // actually show menu
    TrackPopupMenu(
                   hMenu,
                   TPM_LEFTALIGN | TPM_TOPALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                   pPt->x,
                   pPt->y,
                   0,
                   hWnd,
                   NULL
                  );
}

void
CT3testDlg::CreateCallMenu(
                           POINT pt,
                           HWND hWnd
                          )
{
    ITCallInfo              * pCall;
    HMENU                   hMenu;

    //
    // get the call in question
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    //
    // create the menu
    //
    hMenu = CreatePopupMenu();

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_HANDOFF1,
               L"Handoff1"
              );

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_HANDOFF2,
               L"Handoff2"
              );

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_PARK1,
               L"Park1"
              );

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_PARK2,
               L"Park2"
              );

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_UNPARK,
               L"Unpark"
              );

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_PICKUP1,
               L"Pickup1"
              );

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_PICKUP2,
               L"Pickup2"
              );

    

    

    //
    // actually show menu
    //
    TrackPopupMenu(
                   hMenu,
                   TPM_LEFTALIGN | TPM_TOPALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                   pt.x,
                   pt.y,
                   0,
                   hWnd,
                   NULL
                  );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3test\servname.h ===
#if !defined(AFX_ServNameDLG_H__2584F283_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_)
#define AFX_ServNameDLG_H__2584F283_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ServNameDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CServNameDlg dialog

class CServNameDlg : public CDialog
{
// Construction
public:
	CServNameDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CServNameDlg)
	enum { IDD = IDD_ILSSERVERNAME };
	CString	m_pszServerName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CServNameDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CServNameDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ServNameDLG_H__2584F283_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3test\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by t3test.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_T3TEST_DIALOG               102
#define IDR_MAINFRAME                   128
#define IDD_CREATECALL                  129
#define IDR_DIGITPOPUP                  130
#define IDD_AUTOANSWER                  131
#define IDD_CONFDLG                     132
#define IDD_ILSSERVERS                  133
#define IDD_ILSSERVERNAME               134
#define IDD_RATE                        135
#define IDC_ADDRESSES                   1000
#define IDC_MEDIATYPES                  1001
#define IDC_TERMINALS                   1002
#define IDC_CALLS                       1003
#define IDC_CREATECALL                  1004
#define IDC_CONNECT                     1005
#define IDC_ANSWER                      1006
#define IDC_DROP                        1007
#define IDC_ADDTERMINAL                 1008
#define IDC_REMOVETERMINAL              1009
#define IDC_DESTADDRESS                 1010
#define IDC_SELECTEDTERMINALS           1011
#define IDC_LISTEN                      1012
#define IDC_RELEASE                     1013
#define IDC_CREATE                      1014
#define IDC_RELEASETERMINAL             1015
#define IDC_CREATEDTERMINALS            1017
#define IDC_DYNAMICCLASSES              1018
#define IDC_ADDCREATED                  1019
#define IDC_ADDNULL                     1020
#define IDC_LISTENMEDIAMODES            1021
#define IDC_ADDTOLISTEN                 1022
#define IDC_LISTENALL                   1023
#define IDC_CONFIGAUTOANSWER            1024
#define IDC_SELECTED                    1025
#define IDC_NOTSELECTED                 1026
#define IDC_TERMINALADD                 1027
#define IDC_TERMINALREMOVE              1028
#define IDC_CONFLIST                    1029
#define IDC_ILS                         1029
#define IDC_ILSLIST                     1030
#define IDC_ADD                         1031
#define IDC_REMOVE                      1032
#define IDC_SERVERNAME                  1033
#define IDC_RATE                        1034
#define IDC_MINRATE                     1035
#define IDC_MAXRATE                     1036
#define ID_MODESUPPORTED                32771
#define ID_GENERATE                     32772
#define ID_MODESUPPORTED2               32773
#define ID_STARTDETECT                  32774
#define ID_STOPDETECT                   32775
#define ID_NOTHING                      32776
#define ID_PARK1                        32778
#define ID_PARK2                        32779
#define ID_HANDOFF1                     32780
#define ID_HANDOFF2                     32781
#define ID_UNPARK                       32782
#define ID_PICKUP1                      32783
#define ID_PICKUP2                      32784


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        136
#define _APS_NEXT_COMMAND_VALUE         32773
#define _APS_NEXT_CONTROL_VALUE         1037
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3test\servname.cpp ===
// ServNameDlg.cpp : implementation file
//

#include "stdafx.h"
#include "t3test.h"
#include "servname.h"

#ifdef _DEBUG

#ifndef _WIN64 // mfc 4.2's heap debugging features generate warnings on win64
#define new DEBUG_NEW
#endif

#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CServNameDlg dialog


CServNameDlg::CServNameDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CServNameDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CServNameDlg)
	m_pszServerName = _T("");
	//}}AFX_DATA_INIT
}


void CServNameDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CServNameDlg)
	DDX_Text(pDX, IDC_SERVERNAME, m_pszServerName);
	DDV_MaxChars(pDX, m_pszServerName, 256);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CServNameDlg, CDialog)
	//{{AFX_MSG_MAP(CServNameDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CServNameDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3test\release.cpp ===
#include "stdafx.h"
#include "t3test.h"
#include "t3testD.h"
#include "calldlg.h"
#include "callnot.h"
#include "externs.h"


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleaseAddresses
//
// Release all the address objects in the address tree
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::ReleaseAddresses()
{
    HTREEITEM           hItem;
    TV_ITEM             item;

    item.mask = TVIF_HANDLE | TVIF_PARAM;

    //
    // get the first address
    //
    hItem = TreeView_GetChild(
                              ghAddressesWnd,
                              ghAddressesRoot
                             );

    //
    // go through all the addresses
    // and release
    while (NULL != hItem)
    {
        HTREEITEM   hNewItem;
        ITAddress * pAddress;
        
        item.hItem = hItem;
        
        TreeView_GetItem(
                         ghAddressesWnd,
                         &item
                        );

        pAddress = (ITAddress *)item.lParam;

        if (NULL != pAddress)
        {
            pAddress->Release();
        }
        

        hNewItem = TreeView_GetNextSibling(
                                        ghAddressesWnd,
                                        hItem
                                       );
        //
        // delete the item
        //
//        TreeView_DeleteItem(
//                            ghAddressesWnd,
//                            hItem
//                           );

        hItem = hNewItem;
    }

    TreeView_DeleteAllItems(ghAddressesWnd);
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleaseMediaTypes
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::ReleaseMediaTypes()
{
    HTREEITEM           hItem;
    TV_ITEM             item;
    BSTR                pMediaType;

    gbUpdatingStuff = TRUE;
    
    item.mask = TVIF_HANDLE | TVIF_PARAM;


    //
    // go through all the mediatypes
    // and free the associated strings
    // and delete the item from the
    // tree
    //
    hItem = TreeView_GetChild(
                              ghMediaTypesWnd,
                              ghMediaTypesRoot
                             );

    while (NULL != hItem)
    {
        HTREEITEM   hNewItem;
        
        hNewItem = TreeView_GetNextSibling(
                                           ghMediaTypesWnd,
                                           hItem
                                          );


        //
        // delete the item
        //
        TreeView_DeleteItem(
                            ghMediaTypesWnd,
                            hItem
                           );

        hItem = hNewItem;
    }

    gbUpdatingStuff = FALSE;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleaseListen
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::ReleaseListen()
{
    HTREEITEM       hItem;
    TV_ITEM         item;

    item.mask = TVIF_HANDLE | TVIF_PARAM;


    //
    // delete all the leave on the listen
    // tree
    // there are no resources associated with
    // this, so nothing to free
    //
    hItem = TreeView_GetChild(
                              ghListenWnd,
                              ghListenRoot
                             );

    while (NULL != hItem)
    {
        HTREEITEM   hNewItem;
        
        hNewItem = TreeView_GetNextSibling(
                                        ghListenWnd,
                                        hItem
                                       );

        TreeView_DeleteItem(
                            ghListenWnd,
                            hItem
                           );

        hItem = hNewItem;
    }

}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleaseTerminalClasses
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::ReleaseTerminalClasses()
{
    HTREEITEM       hItem;
    TV_ITEM         item;

    item.mask = TVIF_HANDLE | TVIF_PARAM;


    //
    // go through all the terminal classes
    // free the memory allocated for the
    // guid, and delete the item
    //
    hItem = TreeView_GetChild(
                              ghClassesWnd,
                              ghClassesRoot
                             );

    while (NULL != hItem)
    {
        HTREEITEM   hNewItem;
        GUID *      pGuid;
        
        item.hItem = hItem;
        
        TreeView_GetItem(
                         ghClassesWnd,
                         &item
                        );

        pGuid = (GUID *)item.lParam;
        delete pGuid;

        hNewItem = TreeView_GetNextSibling(
                                           ghClassesWnd,
                                           hItem
                                          );

        TreeView_DeleteItem(
                            ghClassesWnd,
                            hItem
                           );

        hItem = hNewItem;
    }

}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleaseTerminalClasses
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::ReleaseTerminals()
{
    HTREEITEM           hItem;
    TV_ITEM             item;

    item.mask = TVIF_HANDLE | TVIF_PARAM;


    //
    // go though all the terminals, and
    // free the terminals, and delete the
    // item
    //
    hItem = TreeView_GetChild(
                              ghTerminalsWnd,
                              ghTerminalsRoot
                             );

    while (NULL != hItem)
    {
        HTREEITEM           hNewItem;
        ITTerminal *        pTerminal;
        
        item.hItem = hItem;
        
        TreeView_GetItem(
                         ghTerminalsWnd,
                         &item
                        );

        pTerminal = (ITTerminal *)item.lParam;

        pTerminal->Release();

        hNewItem = TreeView_GetNextSibling(
                                        ghTerminalsWnd,
                                        hItem
                                       );
    

        TreeView_DeleteItem(
                            ghTerminalsWnd,
                            hItem
                           );

        hItem = hNewItem;
    }
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleaseSelectedTerminals
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::ReleaseSelectedTerminals()
{
    HTREEITEM               hItem;
    TV_ITEM                 item;

    
    item.mask = TVIF_HANDLE | TVIF_PARAM;


    //
    // go through all the selected terminals
    // and free and delete
    //
    hItem = TreeView_GetChild(
                              ghSelectedWnd,
                              ghSelectedRoot
                             );

    while (NULL != hItem)
    {
        HTREEITEM           hNewItem;
        ITTerminal *        pTerminal;
        
        item.hItem = hItem;
        
        TreeView_GetItem(
                         ghSelectedWnd,
                         &item
                        );

        pTerminal = (ITTerminal *)item.lParam;

        pTerminal->Release();

        hNewItem = TreeView_GetNextSibling(
                                           ghSelectedWnd,
                                           hItem
                                          );


        TreeView_DeleteItem(
                            ghSelectedWnd,
                            hItem
                           );

        hItem = hNewItem;
    }
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleaseCalls
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::ReleaseCalls()
{
    HTREEITEM           hItem;
    TV_ITEM             item;

    item.mask = TVIF_HANDLE | TVIF_PARAM;


    //
    // go through all the calls, and
    // release and delete
    //
    hItem = TreeView_GetChild(
                              ghCallsWnd,
                              ghCallsRoot
                             );

    while (NULL != hItem)
    {
        HTREEITEM           hNewItem;
        ITCallInfo *        pCallInfo;

        
        item.hItem = hItem;
        
        TreeView_GetItem(
                         ghCallsWnd,
                         &item
                        );

        pCallInfo = (ITCallInfo *)item.lParam;

        pCallInfo->Release();

        hNewItem = TreeView_GetNextSibling(
                                           ghCallsWnd,
                                           hItem
                                          );
    

        TreeView_DeleteItem(
                            ghCallsWnd,
                            hItem
                           );

        hItem = hNewItem;
    }
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleaseCalls
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::ReleaseCreatedTerminals()
{
    HTREEITEM hItem;
    TV_ITEM item;

    item.mask = TVIF_HANDLE | TVIF_PARAM;
    

    //
    // go through all the created terminals
    // and release and delete
    //
    hItem = TreeView_GetChild(
                              ghCreatedWnd,
                              ghCreatedRoot
                             );

    while (NULL != hItem)
    {
        HTREEITEM hNewItem;
        ITTerminal * pTerminal;

        
        item.hItem = hItem;
        
        TreeView_GetItem(
                         ghCreatedWnd,
                         &item
                        );

        pTerminal = (ITTerminal *)item.lParam;

        pTerminal->Release();

        hNewItem = TreeView_GetNextSibling(
                                           ghCreatedWnd,
                                           hItem
                                          );
    

        TreeView_DeleteItem(
                            ghCreatedWnd,
                            hItem
                           );

        hItem = hNewItem;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3test\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	t3test.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3test\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#ifndef UNICODE
#define UNICODE
#endif

#if !defined(AFX_STDAFX_H__47F9FE88_D2F9_11D0_8ECA_00C04FB6809F__INCLUDED_)
#define AFX_STDAFX_H__47F9FE88_D2F9_11D0_8ECA_00C04FB6809F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#include "tapi3.h"
//#include "tapi.h"

#include <list>
using namespace std;

typedef list<ITTerminal *>      TerminalPtrList;
typedef struct
{
    ITAddress * pAddress;
    TerminalPtrList * pTerminalPtrList;
    
} AADATA;

typedef list<AADATA *> DataPtrList;
   


#endif // !defined(AFX_STDAFX_H__47F9FE88_D2F9_11D0_8ECA_00C04FB6809F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3test\t3test.cpp ===
// t3test.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "t3test.h"
#include "t3testD.h"

#ifdef _DEBUG

#ifndef _WIN64 // mfc 4.2's heap debugging features generate warnings on win64
#define new DEBUG_NEW
#endif

#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CWnd * gpmainwnd;

/////////////////////////////////////////////////////////////////////////////
// CT3testApp

BEGIN_MESSAGE_MAP(CT3testApp, CWinApp)
	//{{AFX_MSG_MAP(CT3testApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CT3testApp construction

CT3testApp::CT3testApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CT3testApp object

CT3testApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CT3testApp initialization

BOOL CT3testApp::InitInstance()
{
	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CT3testDlg dlg;
	m_pMainWnd = &dlg;
    gpmainwnd = &dlg;
    
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3test\t3test.h ===
// t3test.h : main header file for the T3TEST application
//

#if !defined(AFX_T3TEST_H__47F9FE84_D2F9_11D0_8ECA_00C04FB6809F__INCLUDED_)
#define AFX_T3TEST_H__47F9FE84_D2F9_11D0_8ECA_00C04FB6809F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CT3testApp:
// See t3test.cpp for the implementation of this class
//

class CT3testApp : public CWinApp
{
public:
	CT3testApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CT3testApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CT3testApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_T3TEST_H__47F9FE84_D2F9_11D0_8ECA_00C04FB6809F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3test\strings.h ===
#define PARENTKEY L"Software\\Microsoft"
#define APPKEY L"t3test"
#define SERVERKEY L"Servers"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3testph\autoans.h ===
#if !defined(AFX_AUTOANS_H__2BFE6626_7758_11D1_8F5C_00C04FB6809F__INCLUDED_)
#define AFX_AUTOANS_H__2BFE6626_7758_11D1_8F5C_00C04FB6809F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// autoans.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// autoans dialog

class autoans : public CDialog
{
// Construction
public:
	autoans(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(autoans)
	enum { IDD = IDD_AUTOANSWER };
    TerminalPtrList m_TerminalPtrList;
    ITAddress * m_pAddress;
    
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(autoans)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(autoans)
	virtual BOOL OnInitDialog();
	afx_msg void OnTerminalAdd();
	afx_msg void OnTerminalRemove();
	virtual void OnOK();
    virtual void OnCancel();
    afx_msg void OnClose() ;
    void PopulateListBox();
    void AddTerminalToListBox( ITTerminal * pTerminal, BOOL bSelected );
    void AddDynamicTerminalToListBox( BOOL bSelected );
    void AddTerminalToAAList( ITTerminal * pTerminal );
//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_AUTOANS_H__2BFE6626_7758_11D1_8F5C_00C04FB6809F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3testph\calldlg.cpp ===
// CreateCallDlg.cpp : implementation file
//

#include "stdafx.h"
#include "t3test.h"
#include "CallDlg.h"

#ifdef _DEBUG

#ifndef _WIN64 // mfc 4.2's heap debugging features generate warnings on win64
#define new DEBUG_NEW
#endif

#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCreateCallDlg dialog


CCreateCallDlg::CCreateCallDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CCreateCallDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CCreateCallDlg)
	m_pszDestAddress = _T("");
	//}}AFX_DATA_INIT
}


void CCreateCallDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCreateCallDlg)
	DDX_Text(pDX, IDC_DESTADDRESS, m_pszDestAddress);
	DDV_MaxChars(pDX, m_pszDestAddress, 256);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCreateCallDlg, CDialog)
	//{{AFX_MSG_MAP(CCreateCallDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCreateCallDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3testph\calldlg.h ===
#if !defined(AFX_CREATECALLDLG_H__2584F283_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_)
#define AFX_CREATECALLDLG_H__2584F283_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// CreateCallDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCreateCallDlg dialog

class CCreateCallDlg : public CDialog
{
// Construction
public:
	CCreateCallDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CCreateCallDlg)
	enum { IDD = IDD_CREATECALL };
	CString	m_pszDestAddress;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCreateCallDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CCreateCallDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CREATECALLDLG_H__2584F283_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3testph\adds.cpp ===
#include "stdafx.h"
#include "t3test.h"
#include "t3testD.h"
#include "calldlg.h"
#include "callnot.h"
#include "externs.h"

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddListen
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::AddListen( long lMediaType )
{
    WCHAR                   szName[256];
    TV_INSERTSTRUCT         tvi;

    //
    // map the mediatype bstr to
    // a string name (like "audio in")
    //
    GetMediaTypeName(
                     lMediaType,
                     szName
                    );

    //
    // insert that string into the
    // listen window
    //
    tvi.hParent = ghListenRoot;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_TEXT | TVIF_PARAM;
    tvi.item.pszText = szName;
    tvi.item.lParam = (LPARAM) lMediaType;
    
    TreeView_InsertItem(
                        ghListenWnd,
                        &tvi
                       );


    //
    // select the first item
    //
    SelectFirstItem(
                    ghListenWnd,
                    ghListenRoot
                   );
}
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddAddressToTree
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::AddAddressToTree( ITAddress * pAddress )
{
    BSTR                bstrName;
    TV_INSERTSTRUCT     tvi;

    //
    // get the name of the address
    //
    pAddress->get_AddressName( &bstrName );


    //
    // set up struct
    //
    tvi.hParent = ghAddressesRoot;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_TEXT | TVIF_PARAM;
    tvi.item.pszText = bstrName;
    tvi.item.lParam = (LPARAM) pAddress;


    //
    // addref
    //
    pAddress->AddRef();

    
    //
    // insert it
    //
    TreeView_InsertItem(
                        ghAddressesWnd,
                        &tvi
                       );

    //
    // free name
    //
    SysFreeString( bstrName );
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddMediaType
//
// Add a mediatype to the mediatype tree
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::AddMediaType( long lMediaType )
{
    WCHAR szString[256];
    TV_INSERTSTRUCT tvi;

    //
    // get the displayable name
    //
    GetMediaTypeName(
                     lMediaType,
                     szString
                    );

    //
    // set up struct
    //
    tvi.hParent = ghMediaTypesRoot;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_TEXT | TVIF_PARAM;
    tvi.item.pszText = szString;
    tvi.item.lParam = (LPARAM) lMediaType;

    //
    // add the item
    //
    TreeView_InsertItem(
                        ghMediaTypesWnd,
                        &tvi
                       );

    //
    // select the first item
    //
    SelectFirstItem(
                    ghMediaTypesWnd,
                    ghMediaTypesRoot
                   );
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddCall
//
// Add a call to the call tree
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::AddCall( ITCallInfo * pCall )
{
    TV_INSERTSTRUCT             tvi;
    HTREEITEM                   hItem;
    CALL_PRIVILEGE              cp;
    CALL_STATE                  cs;
    WCHAR                       pszName[16];

    //
    // for the name of the call, use
    // the pointer!
    //
    wsprintf(
             pszName,
             L"0x%lx",
             pCall
            );


    //
    // set up struct
    //
    tvi.hParent = ghCallsRoot;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_TEXT | TVIF_PARAM;
    tvi.item.pszText = pszName;
    tvi.item.lParam = (LPARAM) pCall;

    //
    // save a reference
    //
    pCall->AddRef();

    
    //
    // insert the item
    //
    hItem = TreeView_InsertItem(
                                ghCallsWnd,
                                &tvi
                               );

    if (NULL != hItem)
    {
        //
        // select the item
        //
        TreeView_SelectItem(
                            ghCallsWnd,
                            hItem
                           );
    }

}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::AddTerminal( ITTerminal * pTerminal )
{
    BSTR                    bstrName;
    BSTR                    bstrClass;
    TV_INSERTSTRUCT         tvi;
    TERMINAL_DIRECTION      td;
    WCHAR                   szName[256];

    //
    // get the name of the terminal
    //
    pTerminal->get_Name( &bstrName );

    pTerminal->get_Direction( &td );

    if (td == TD_RENDER)
    {
        wsprintfW(szName, L"%s [Playback]", bstrName);
    }
    else if (td == TD_CAPTURE)
    {
        wsprintfW(szName, L"%s [Record]", bstrName);
    }
    else //if (TD == TD_BOTH)
    {
        lstrcpyW(szName, bstrName);
    }
    
    //
    // set up the structure
    //
    tvi.hParent = ghTerminalsRoot;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_TEXT | TVIF_PARAM;
    tvi.item.pszText = szName;
    tvi.item.lParam = (LPARAM) pTerminal;


    //
    // keep a refence to the terminal
    //
    pTerminal->AddRef();

    //
    // add it
    //
    TreeView_InsertItem(
                        ghTerminalsWnd,
                        &tvi
                       );

    //
    // free the name
    //
    SysFreeString( bstrName );


    //
    // select
    //
    SelectFirstItem(
                    ghTerminalsWnd,
                    ghTerminalsRoot
                   );
    
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddPhone
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::AddPhone( ITPhone * pPhone )
{
    BSTR                    bstrName;
    TV_INSERTSTRUCT         tvi;
    TERMINAL_DIRECTION      td;
    WCHAR                   szName[256];

    //
    // get the name of the phone
    //
    pPhone->get_PhoneCapsString ( PCS_PHONENAME, &bstrName );

    lstrcpyW(szName, bstrName);

    //
    // set up the structure
    //
    tvi.hParent = ghPhonesRoot;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_TEXT | TVIF_PARAM;
    tvi.item.pszText = szName;
    tvi.item.lParam = (LPARAM) pPhone;


    //
    // keep a refence to the phone
    //
    pPhone->AddRef();

    //
    // add it
    //
    TreeView_InsertItem(
                        ghPhonesWnd,
                        &tvi
                       );

    //
    // free the name
    //
    SysFreeString( bstrName );


    //
    // select
    //
    SelectFirstItem(
                    ghPhonesWnd,
                    ghPhonesRoot
                   );
    
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddTerminalClass
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::AddTerminalClass( GUID * pguid )
{
    TV_INSERTSTRUCT tvi;
    
    //
    // get the name
    //
    tvi.item.pszText = GetTerminalClassName( pguid );

    //
    // set up the struct
    //
    tvi.hParent = ghClassesRoot;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_TEXT | TVIF_PARAM;
    tvi.item.lParam = (LPARAM) pguid;

    //
    // insert the item
    //
    TreeView_InsertItem(
                        ghClassesWnd,
                        &tvi
                       );

    SysFreeString( tvi.item.pszText );

    //
    // select item
    //
    SelectFirstItem(
                    ghClassesWnd,
                    ghClassesRoot
                   );

}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddCreatedTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::AddCreatedTerminal( ITTerminal * pTerminal )
{
    BSTR                    bstrName;
    TV_INSERTSTRUCT         tvi;


    //
    // get the name
    //
    pTerminal->get_Name( &bstrName );

    //
    // set up the structure
    //
    tvi.hParent = ghCreatedRoot;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_TEXT | TVIF_PARAM;

    if ( ( NULL == bstrName ) || (NULL == bstrName[0] ))
    {
        tvi.item.pszText = L"<No Name Given>";
    }
    else
    {
        tvi.item.pszText = bstrName;
    }

    tvi.item.lParam = (LPARAM) pTerminal;


    //
    // keep reference
    //
    pTerminal->AddRef();

    //
    // insert
    //
    TreeView_InsertItem(
                        ghCreatedWnd,
                        &tvi
                       );

    SysFreeString( bstrName );

    //
    // select
    //
    SelectFirstItem(
                    ghCreatedWnd,
                    ghCreatedRoot
                   );
    
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddSelectedTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::AddSelectedTerminal(
                                     ITTerminal * pTerminal
                                    )
{
    BSTR bstrName;
    BSTR pMediaType;
    TV_INSERTSTRUCT tvi;
    TERMINAL_DIRECTION td;
    WCHAR szName[256];
    

    //
    // get the name
    //
    pTerminal->get_Name( &bstrName );

    pTerminal->get_Direction( &td );

    if (td == TD_RENDER)
    {
        wsprintfW(szName, L"%s [Playback]", bstrName);
    }
    else if (td == TD_CAPTURE)
    {
        wsprintfW(szName, L"%s [Record]", bstrName);
    }
    else //if (TD == TD_BOTH)
    {
        lstrcpyW(szName, bstrName);
    }
    

    //
    // set up the struct
    //
    tvi.hParent = ghSelectedRoot;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_TEXT | TVIF_PARAM;
    tvi.item.pszText = szName;
    tvi.item.lParam = (LPARAM) pTerminal;

    //
    // keep reference
    //
    pTerminal->AddRef();

    //
    // insert item
    //
    TreeView_InsertItem(
                        ghSelectedWnd,
                        &tvi
                       );

    //
    // free name
    //
    SysFreeString( bstrName );


    //
    // select
    //
    SelectFirstItem(
                    ghSelectedWnd,
                    ghSelectedRoot
                   );
    
    
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddSelectedCall
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::AddSelectedCall(
                                     ITCallInfo * pCall
                                    )
{
    TV_INSERTSTRUCT tvi;
    WCHAR pszName[16];
    
    //
    // for the name of the call, use
    // the pointer!
    //
    wsprintf(
             pszName,
             L"0x%lx",
             pCall
            );

    //
    // set up the struct
    //
    tvi.hParent = ghSelectedCallsRoot;
    tvi.hInsertAfter = TVI_LAST;
    tvi.item.mask = TVIF_TEXT | TVIF_PARAM;
    tvi.item.pszText = pszName;
    tvi.item.lParam = (LPARAM) pCall;

    //
    // keep reference
    //
    pCall->AddRef();

    //
    // insert item
    //
    TreeView_InsertItem(
                        ghSelectedCallsWnd,
                        &tvi
                       );


    //
    // select
    //
    SelectFirstItem(
                    ghSelectedCallsWnd,
                    ghSelectedCallsRoot
                   );
    
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3test\updates.cpp ===
#include "stdafx.h"
#include "t3test.h"
#include "t3testD.h"
#include "calldlg.h"
#include "callnot.h"
#include "externs.h"


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// UpdateMediaTypes
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::UpdateMediaTypes(
                                  ITAddress * pAddress
                                 )
{
    long                    lMediaType;
    ITMediaSupport *        pMediaSupport;
    HRESULT                 hr;
    

    //
    // get the media support interface
    //
    pAddress->QueryInterface(
                             IID_ITMediaSupport,
                             (void **)&pMediaSupport
                            );

    //
    // get the mediatype enumerator
    //
    pMediaSupport->get_MediaTypes(&lMediaType);


    //
    // release the interface
    //
    pMediaSupport->Release();


    gbUpdatingStuff = TRUE;

    
    //
    // go through the supported mediatypes
    //
    DWORD       dwMediaType = 1;
    DWORD       dwHold = (DWORD)lMediaType;

    while (dwMediaType)
    {
        if ( dwMediaType & dwHold )
        {
            AddMediaType( (long) dwMediaType );
        }

        dwMediaType <<=1;
    }


    gbUpdatingStuff = FALSE;

    //
    // select the first
    // media type
    //
    SelectFirstItem(
                    ghMediaTypesWnd,
                    ghMediaTypesRoot
                   );


    //
    // release and redo terminals
    //
    ReleaseTerminals();
    ReleaseTerminalClasses();

    if ( GetMediaType( &lMediaType ) )
    {
        UpdateTerminals( pAddress, lMediaType );
        UpdateTerminalClasses( pAddress, lMediaType );
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// UpdateCalls
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::UpdateCalls(
                             ITAddress * pAddress
                            )
{
    IEnumCall *             pEnumCall;
    HRESULT                 hr;
    ITCallInfo *            pCallInfo;

    //
    // enumerate the current calls
    //
    pAddress->EnumerateCalls( &pEnumCall );


    //
    // go through the list
    // and add the calls to the tree
    //
    while (TRUE)
    {
        hr = pEnumCall->Next( 1, &pCallInfo, NULL);

        if (S_OK != hr)
        {
            break;
        }

        AddCall(pCallInfo);

        UpdateCall( pCallInfo );

        //
        // release this reference
        //
        pCallInfo->Release();
    }

    pEnumCall->Release();
    
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// UpdateCall
//
// check the call's state and privelege, and update the call
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::UpdateCall( ITCallInfo * pCall )
{
    HTREEITEM               hItem, hParent;
    TV_ITEM                 item;
    CALL_PRIVILEGE          cp;
    CALL_STATE              cs;
    TV_INSERTSTRUCT         tvi;
    

    //
    // get the first call
    //
    item.mask = TVIF_HANDLE | TVIF_PARAM;
    
    
    hItem = TreeView_GetChild(
                              ghCallsWnd,
                              ghCallsRoot
                             );

    //
    // go through all the calls
    // and look for the one that matches
    // the one passed in
    //
    while (NULL != hItem)
    {
        item.hItem = hItem;
        
        TreeView_GetItem(
                         ghCallsWnd,
                         &item
                        );

        if ( item.lParam == (LPARAM)pCall )
        {
            break;
        }

        hItem = TreeView_GetNextSibling(
                                        ghCallsWnd,
                                        hItem
                                       );
    }

    //
    // did we find it?
    //
    if (NULL == hItem)
    {
        return;
    }

    
    hParent = hItem;

    //
    // delete the current children of the call
    // node (these are the old privelege and state
    //
    hItem = TreeView_GetChild(
                              ghCallsWnd,
                              hItem
                             );

    
    while (NULL != hItem)
    {
        HTREEITEM   hNewItem;
        
        hNewItem = TreeView_GetNextSibling(
                                           ghCallsWnd,
                                           hItem
                                          );

        TreeView_DeleteItem(
                            ghCallsWnd,
                            hItem
                           );

        hItem = hNewItem;
    }

    tvi.hInsertAfter = TVI_LAST;

    //
    // get the current privilege
    //
    tvi.item.pszText = GetCallPrivilegeName( pCall );

    //
    // add it as a child of the
    // call node
    //
    tvi.hParent = hParent;
    tvi.item.mask = TVIF_TEXT;

    TreeView_InsertItem(
                        ghCallsWnd,
                        &tvi
                       );

    SysFreeString( tvi.item.pszText );
    
    //
    // get the current callstate
    //
    tvi.item.pszText = GetCallStateName( pCall );
    
    //
    // add it as a child of the call
    // node
    //
    tvi.hParent = hParent;
    tvi.item.mask = TVIF_TEXT;

    TreeView_InsertItem(
                        ghCallsWnd,
                        &tvi
                       );

    SysFreeString( tvi.item.pszText );

    
}


void CT3testDlg::UpdateTerminals(
                                 ITAddress * pAddress,
                                 long lMediaType
                                )
{
    ITTerminalSupport *     pTerminalSupport;
    IEnumTerminal *         pEnumTerminals;
    HRESULT                 hr;
    ITTerminal *            pTerminal;
    
    
    //
    // get the terminalsupport interface
    //
    hr = pAddress->QueryInterface(
                             IID_ITTerminalSupport,
                             (void **) &pTerminalSupport
                            );

    if ( !SUCCEEDED(hr) )
    {
        return;
    }

    //
    // enumerate the terminals
    //
    pTerminalSupport->EnumerateStaticTerminals( &pEnumTerminals );

    //
    // go through the terminals
    //
    while (TRUE)
    {
        VARIANT_BOOL        bSupport;
        BSTR                bstr;
        long                l;

        
        hr = pEnumTerminals->Next( 1, &pTerminal, NULL);

        if (S_OK != hr)
        {
            break;
        }

        //
        // get the name
        //
        hr = pTerminal->get_Name( &bstr );

        //
        // if it's a unimodem or a direct sound
        // device don't show it, cause they bother
        // me
        //
        if (wcsstr( bstr, L"Voice Modem" ) || wcsstr( bstr, L"ds:" ) )
        {
            pTerminal->Release();
            SysFreeString( bstr );
            
            continue;
        }

        //
        // free the name
        //
        SysFreeString( bstr );

        //
        // get the mediatype of the terminal
        //
        pTerminal->get_MediaType( &l );

        //
        // if it's the same as the selected mediatype
        // show it
        //
        if ( l == lMediaType )
        {
            AddTerminal(pTerminal);
        }

        //
        // release
        //
        pTerminal->Release();
    }

    //
    // release enumerator
    //
    pEnumTerminals->Release();

    //
    // release
    //
    pTerminalSupport->Release();

    //
    // select
    //
    SelectFirstItem(
                    ghTerminalsWnd,
                    ghTerminalsRoot
                   );

}


void CT3testDlg::UpdateTerminalClasses(
                                       ITAddress * pAddress,
                                       long lMediaType
                                      )
{
    IEnumTerminalClass *        pEnumTerminalClasses;
    HRESULT                     hr;
    ITTerminalSupport *         pTerminalSupport;

    hr = pAddress->QueryInterface(
                             IID_ITTerminalSupport,
                             (void **)&pTerminalSupport
                            );


    if (!SUCCEEDED(hr))
    {
        return;
    }
    
    //
    // now enum dymnamic
    //
    hr = pTerminalSupport->EnumerateDynamicTerminalClasses( &pEnumTerminalClasses );

    if (S_OK == hr)
    {
        
        //
        // go through all the classes
        //
        while (TRUE)
        {
            GUID *                  pDynTerminalClass = new GUID;

            hr = pEnumTerminalClasses->Next(
                                            1,
                                            pDynTerminalClass,
                                            NULL
                                           );

            if (S_OK != hr)
            {
                delete pDynTerminalClass;
                break;
            }

            //
            // manually match up mediatype and
            // class
            //
            if ( (lMediaType == (long)LINEMEDIAMODE_VIDEO) &&
                 (*pDynTerminalClass == CLSID_VideoWindowTerm) )
            {

                AddTerminalClass(
                                 pDynTerminalClass
                                );
            }

#ifdef ENABLE_DIGIT_DETECTION_STUFF
            else if ( (lMediaType == (long)LINEMEDIAMODE_AUTOMATEDVOICE) &&
                      ( *pDynTerminalClass == CLSID_DigitTerminal ) )
            {
                AddTerminalClass(
                                 pDynTerminalClass
                                );
            }
            else if ( ((lMediaType == (long)LINEMEDIAMODE_DATAMODEM) ||
                       (lMediaType == (long)LINEMEDIAMODE_G3FAX)) &&
                      (*pDynTerminalClass == CLSID_DataTerminal) )
            {
                AddTerminalClass( pDynTerminalClass );
            }
#endif // ENABLE_DIGIT_DETECTION_STUFF


            else
            {
                delete pDynTerminalClass;
            }

        }

        //
        // release enumerator
        //
        pEnumTerminalClasses->Release();

    }
    
    //
    // release this interface
    //
    pTerminalSupport->Release();
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3testph\confdlg.cpp ===
// autoans.cpp : implementation file
//
#include "stdafx.h"

#include "t3test.h"
#include "t3testd.h"
#include "confdlg.h"
#include "strings.h"
#include "resource.h"


#ifdef _DEBUG

#ifndef _WIN64 // mfc 4.2's heap debugging features generate warnings on win64
#define new DEBUG_NEW
#endif

#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CConfDlg::CConfDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CConfDlg::IDD, pParent)
{
        m_bstrDestAddress = NULL;
}


void CConfDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
}

BOOL CConfDlg::OnInitDialog()
{
    CDialog::OnInitDialog();
    PopulateConferences();
    return TRUE;
}

void CConfDlg::PopulateConferences()
{
    ITRendezvous *      pRend;
    IEnumDirectory *    pEnumDirectory;
    HRESULT             hr;
    ITDirectory *       pDirectory;
    LPWSTR *            ppServers;
    DWORD               dw;
    
    //
    // create the rendezvous control.
    //
    hr = ::CoCreateInstance(
                            CLSID_Rendezvous,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_ITRendezvous,
                            (void **)&pRend
                           );
    
    if (FAILED(hr))
    {
        return;
    }


    hr = pRend->EnumerateDefaultDirectories(
        &pEnumDirectory
        );

    if (FAILED(hr))
    {
        pRend->Release();
    
        return;
    }

    while (TRUE)
    {

        DWORD dwFetched = 0;

        hr = pEnumDirectory->Next(
                                  1,
                                  &pDirectory,
                                  &dwFetched
                                 );

        if ( S_OK != hr )
        {
            break;
        }

        DIRECTORY_TYPE type;
        // print out the names of the conference found.
        hr = pDirectory->get_DirectoryType(&type);
        if ( FAILED(hr) )
        {
            pDirectory->Release();
            continue;
        }

        if (type == DT_ILS)
        {
            break;
        }

        pDirectory->Release();

    }

    pEnumDirectory->Release();

    //
    // if hr is s_false, we went through the enumerate
    // without finding an ils server
    //
    if ( S_OK == hr )
    {
        hr = pDirectory->Connect(FALSE);

        if ( SUCCEEDED(hr))
        {
            ListObjects( pDirectory );
        }

        pDirectory->Release();
    }

    hr = ListILSServers(
                        &ppServers,
                        &dw
                       );

    if ( !SUCCEEDED(hr) )
    {
        return;
    }
    
    while ( dw )
    {
        dw--;

        hr = pRend->CreateDirectory(
                                    DT_ILS,
                                    ppServers[dw],
                                    &pDirectory
                                   );

        if ( SUCCEEDED(hr) )
        {
            hr = pDirectory->Connect(FALSE);

            if ( SUCCEEDED(hr) )
            {
                ListObjects( pDirectory );
            }

            pDirectory->Release();
        }

        CoTaskMemFree( ppServers[dw] );
    }

    CoTaskMemFree( ppServers );

}

void
CConfDlg::ListObjects( ITDirectory * pDirectory )
{
    BSTR            bstrNameToSearch;
    BSTR            bstrDirName;
    HRESULT         hr;
    int             i;
    
    
    bstrNameToSearch = SysAllocString(L"*");

    if (bstrNameToSearch == NULL)
    {
        return;
    }

    IEnumDirectoryObject * pEnum;
    
    hr = pDirectory->EnumerateDirectoryObjects(
        OT_CONFERENCE,
        bstrNameToSearch,
        &pEnum
        );

    SysFreeString( bstrNameToSearch );

    if (FAILED(hr))
    {
        return;
    }

    pDirectory->get_DisplayName( &bstrDirName );

    // print out the names of all the users found.
    while (TRUE)
    {
        ITDirectoryObject *     pObject;
        BSTR                    bstrObjectName;
        WCHAR                   szBuffer[256];

        hr = pEnum->Next(
                         1,
                         &pObject,
                         NULL
                        );
        
        if ( S_OK != hr )
        {
            break;
        }

        hr = pObject->get_Name(&bstrObjectName);
        
        if (FAILED(hr))
        {
            continue;
        }

        wsprintf(szBuffer, L"%s: %s", bstrDirName, bstrObjectName );
        
        i = SendDlgItemMessage(
                               IDC_CONFLIST,
                               LB_ADDSTRING,
                               0,
                               (LPARAM)szBuffer
                              );

        SysFreeString(bstrObjectName);

        SendDlgItemMessage(
                           IDC_CONFLIST,
                           LB_SETITEMDATA,
                           i,
                           (LPARAM) pObject
                          );
    }

    SysFreeString( bstrDirName );
    
    pEnum->Release();
}

void CConfDlg::OnOK()
{
    DWORD       i;
    HRESULT     hr;
    
    i = SendDlgItemMessage(
                           IDC_CONFLIST,
                           LB_GETCURSEL,
                           0,
                           0
                          );

    if (LB_ERR != i)
    {
        ITDirectoryObject *     pObject;
        IEnumDialableAddrs *    pEnumAddress;

        
        pObject = (ITDirectoryObject *)SendDlgItemMessage(
            IDC_CONFLIST,
            LB_GETITEMDATA,
            i,
            0
            );

        hr = pObject->EnumerateDialableAddrs(
                                             LINEADDRESSTYPE_SDP,
                                             &pEnumAddress
                                            );

        if ( !SUCCEEDED(hr) )
        {
        }

        hr = pEnumAddress->Next(
                                1,
                                &m_bstrDestAddress,
                                NULL
                               );

        if ( S_OK != hr )
        {
        }

        pEnumAddress->Release();
    }

    
	CDialog::OnOK();
}


void CConfDlg::OnDestroy() 
{
    DWORD       count;

    CDialog::OnDestroy();

    count = SendDlgItemMessage(
                               IDC_CONFLIST,
                               LB_GETCOUNT,
                               0,
                               0
                              );

    while ( 0 != count )
    {
        ITDirectoryObject * pObject;

        count--;
        
        pObject = (ITDirectoryObject *)SendDlgItemMessage(
            IDC_CONFLIST,
            LB_GETITEMDATA,
            count,
            0
            );

        pObject->Release();
    }
}


BEGIN_MESSAGE_MAP(CConfDlg, CDialog)
	ON_WM_DESTROY()
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3testph\confdlg.h ===
#if !defined(AFX_CONFDLG_H)
#define AFX_CONFDLG_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "rend.h"

/////////////////////////////////////////////////////////////////////////////
// CConfDlg dialog

class CConfDlg : public CDialog
{
// Construction
public:
	CConfDlg(CWnd* pParent = NULL);
	enum { IDD = IDD_CONFDLG };
    BSTR       m_bstrDestAddress;
    ITDirectory * m_pDirectory;
    
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    void PopulateConferences();
    void ListObjects( ITDirectory * );
    BOOL CConfDlg::OnInitDialog();
    virtual void OnOK();
    afx_msg void OnDestroy();
    DECLARE_MESSAGE_MAP()
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3test\t3testd.cpp ===
// t3testDlg.cpp : implementation file
//

#include "stdafx.h"

#include <control.h> // for IVideoWindow

#include "t3test.h"
#include "t3testD.h"
#include "calldlg.h"
#include "callnot.h"
#include "uuids.h"
#include "autoans.h"
#include "confdlg.h"
#include "ilsdlg.h"
#include "rate.h"

#ifdef _DEBUG

#ifndef _WIN64 // mfc 4.2's heap debugging features generate warnings on win64
#define new DEBUG_NEW
#endif

#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

ITTAPI * gpTapi;
IConnectionPoint * gpCP;
HWND ghAddressesWnd;
HWND ghTerminalsWnd;
HWND ghMediaTypesWnd;
HWND ghCallsWnd;
HWND ghSelectedWnd;
HWND ghCreatedWnd;
HWND ghClassesWnd;
HWND ghListenWnd;
HTREEITEM ghAddressesRoot;
HTREEITEM ghTerminalsRoot;
HTREEITEM ghMediaTypesRoot;
HTREEITEM ghCallsRoot;
HTREEITEM ghSelectedRoot;
HTREEITEM ghCreatedRoot;
HTREEITEM ghClassesRoot;
HTREEITEM ghListenRoot;

#ifdef ENABLE_DIGIT_DETECTION_STUFF
CDigitDetectionNotification *   gpDigitNotification;
#endif // ENABLE_DIGIT_DETECTION_STUFF

long       gulAdvise;
BOOL gbUpdatingStuff = FALSE;
BOOL gfShuttingDown = FALSE;

DataPtrList       gDataPtrList;
extern CT3testApp theApp;

const BSTR TAPIMEDIATYPE_String_Audio = L"{028ED8C2-DC7A-11D0-8ED3-00C04FB6809F}";
const BSTR TAPIMEDIATYPE_String_Video = L"{028ED8C4-DC7A-11D0-8ED3-00C04FB6809F}";

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CT3testDlg dialog

CT3testDlg::CT3testDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CT3testDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CT3testDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CT3testDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CT3testDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CT3testDlg, CDialog)
	//{{AFX_MSG_MAP(CT3testDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_WM_DESTROY()
	ON_NOTIFY(TVN_SELCHANGED, IDC_ADDRESSES, OnSelchangedAddresses)
	ON_BN_CLICKED(IDC_ADDTERMINAL, OnAddterminal)
	ON_BN_CLICKED(IDC_REMOVETERMINAL, OnRemoveterminal)
	ON_BN_CLICKED(IDC_CREATECALL, OnCreatecall)
	ON_BN_CLICKED(IDC_CONNECT, OnConnect)
	ON_BN_CLICKED(IDC_DROP, OnDrop)
	ON_BN_CLICKED(IDC_ANSWER, OnAnswer)
	ON_BN_CLICKED(IDC_LISTEN, OnListen)
	ON_NOTIFY(TVN_SELCHANGED, IDC_CALLS, OnSelchangedCalls)
	ON_BN_CLICKED(IDC_RELEASE, OnRelease)
	ON_BN_CLICKED(IDC_CREATE, OnCreateTerminal)
	ON_BN_CLICKED(IDC_RELEASETERMINAL, OnReleaseterminal)
	ON_BN_CLICKED(IDC_ADDCREATED, OnAddcreated)
	ON_BN_CLICKED(IDC_ADDNULL, OnAddnull)
	ON_BN_CLICKED(IDC_ADDTOLISTEN, OnAddtolisten)
	ON_BN_CLICKED(IDC_LISTENALL, OnListenall)
    ON_BN_CLICKED(IDC_CONFIGAUTOANSWER, OnConfigAutoAnswer)
    ON_BN_CLICKED(IDC_ILS, OnILS)
    ON_BN_CLICKED(IDC_RATE, OnRate)
	ON_NOTIFY(TVN_SELCHANGED, IDC_MEDIATYPES, OnSelchangedMediatypes)
	ON_NOTIFY(NM_RCLICK, IDC_SELECTEDTERMINALS, OnRclickSelectedterminals)

#ifdef ENABLE_DIGIT_DETECTION_STUFF
    ON_COMMAND(ID_GENERATE, OnGenerate)
    ON_COMMAND(ID_MODESUPPORTED, OnModesSupported)
    ON_COMMAND(ID_MODESUPPORTED2, OnModesSupported2)
    ON_COMMAND(ID_STARTDETECT, OnStartDetect)
    ON_COMMAND(ID_STOPDETECT, OnStopDetect)
#endif // ENABLE_DIGIT_DETECTION_STUFF
    
    ON_COMMAND(ID_PARK1, OnPark1)
    ON_COMMAND(ID_PARK2, OnPark2)
    ON_COMMAND(ID_HANDOFF1, OnHandoff1)
    ON_COMMAND(ID_HANDOFF2, OnHandoff2)
    ON_COMMAND(ID_UNPARK, OnUnpark)
    ON_COMMAND(ID_PICKUP1, OnPickup1)
    ON_COMMAND(ID_PICKUP2, OnPickup2)

    ON_WM_CLOSE()
    ON_MESSAGE(WM_USER+101, OnTapiEvent)
	ON_NOTIFY(NM_RCLICK, IDC_CALLS, OnRclickCalls)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CT3testDlg message handlers

BOOL CT3testDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon

    HRESULT     hr;


    //
    // coinit
    //
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    //hr = CoInitialize(NULL);

    if (hr != S_OK)
    {
        MessageBox(L"CoInitialize failed", MB_OK);

        return FALSE;
    }


    //
    // create the tapi object
    //
    hr = CoCreateInstance(
        CLSID_TAPI,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_ITTAPI,
        (LPVOID *)&gpTapi
        );

    if (hr != S_OK)
    {
        ::MessageBox(NULL, L"CoCreateInstance on TAPI failed", NULL, MB_OK);
        return TRUE;
    }

    //
    // initialize tapi
    //
    hr = gpTapi->Initialize();

    if (hr != S_OK)
    {
        ::MessageBox(NULL, L"TAPI initialize failed", NULL, MB_OK);
        gpTapi->Release();
        return TRUE;
    }


    // Set the Event filter to only give us only the events we process
    gpTapi->put_EventFilter(TE_CALLNOTIFICATION | \
                            TE_CALLSTATE        | \
                            TE_CALLHUB          | \
                            TE_CALLMEDIA        | \
                            TE_TAPIOBJECT       | \
                            TE_ADDRESS);

    //
    // intialize the tree controls
    //
    InitializeTrees();

    //
    // intialize the address tree control
    //
    InitializeAddressTree();

    //
    // register the main event interface
    //
    RegisterEventInterface();

    //
    // register for call notification for
    // all addresses for outgoing calls
    //
    RegisterForCallNotifications();
    
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CT3testDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CT3testDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CT3testDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

void CT3testDlg::OnFinalRelease() 
{
	// TODO: Add your specialized code here and/or call the base class

	CDialog::OnFinalRelease();
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// SelectFirstItem
//
// selects the first item under the hroot node in hwnd.
// this is used to make sure that something is selected
// in the window at all times.
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::SelectFirstItem(
                                 HWND        hWnd,
                                 HTREEITEM   hRoot
                                )
{
    HTREEITEM           hChild;


    //
    // get the first item
    //
    hChild = TreeView_GetChild(
                               hWnd,
                               hRoot
                              );

    //
    // select it
    //
    TreeView_SelectItem(
                        hWnd,
                        hChild
                       );

}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// DeleteSelectedItem
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::DeleteSelectedItem(
                                    HWND hWnd
                                   )
{
    HTREEITEM           hItem;

    //
    // get current selections
    // 
    hItem = TreeView_GetSelection( hWnd );


    //
    // delete it
    //
    TreeView_DeleteItem(
                        hWnd,
                        hItem
                       );
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//  InitializeAddressTree
//      initialize the address tree control with
//      the address objects
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::InitializeAddressTree()
{
    IEnumAddress *      pEnumAddress;
    ITAddress *         pAddress;
    HTREEITEM           hChild;
    HRESULT             hr;
    long                l;
    DWORD               dwCount = 0;
    
    //
    // get the address enumerator
    //
    
    hr = gpTapi->EnumerateAddresses( &pEnumAddress );

    if (S_OK != hr)
    {
        gpTapi->Release();
        gpTapi = NULL;

        return;
    }

    //
    // go through all the address objects
    // and add them to the address treecontrol
    //

    while (TRUE)
    {
        AADATA * pData;
        
        hr = pEnumAddress->Next( 1, &pAddress, NULL );

        if (S_OK != hr)
        {
            break;
        }

        AddAddressToTree( pAddress );

        pAddress->Release();

        pData = (AADATA *)CoTaskMemAlloc( sizeof ( AADATA ) );
        pData->pAddress = pAddress;
        pData->pTerminalPtrList = new TerminalPtrList;
        
        gDataPtrList.push_back( pData );

        dwCount++;
    }

    //
    // release the enumerator
    //
    pEnumAddress->Release();

    //
    // select the first item
    //
    if (dwCount > 0)
    {
        SelectFirstItem(
                        ghAddressesWnd,
                        ghAddressesRoot
                       );
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// RegisterEventInterface
//
// registers the ITTAPIEventNotification interface
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CT3testDlg::RegisterEventInterface()
{
    CTAPIEventNotification *        pTAPIEventNotification;
    IConnectionPointContainer *     pCPC;
    IConnectionPoint *              pCP;
    IUnknown *                      pUnk;
    
    //
    // create the object
    //
    pTAPIEventNotification = new CTAPIEventNotification;


    //
    // get the connectionpointcontainer interface
    // from the tapi object
    //
    gpTapi->QueryInterface(
                           IID_IConnectionPointContainer,
                           (void **) &pCPC
                          );


    //
    // get the connectionpoint we are
    // looking for
    //
    pCPC->FindConnectionPoint(
                              IID_ITTAPIEventNotification,
                              &gpCP
                             );

    pCPC->Release();

    pTAPIEventNotification->QueryInterface(
                                           IID_IUnknown,
                                           (void **)&pUnk
                                          );

    //
    // call the advise method to tell tapi
    // about the interface
    //
    gpCP->Advise(
                 pUnk,
                 (ULONG *)&gulAdvise
                );


    //
    // release our reference to
    // it
    //
    pUnk->Release();
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// RegisterForCallNotifications
//
// registers for call state notifications for all
// addresses for outgoing calls
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::RegisterForCallNotifications()
{
    VARIANT                 var;

    var.vt = VT_ARRAY;
    var.parray = NULL;
    
    gpTapi->SetCallHubTracking(var, VARIANT_TRUE);
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// InitializeTrees
//
// Create and labels the tree controls
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::InitializeTrees()
{
    TV_INSERTSTRUCT tvi;

    tvi.hParent = TVI_ROOT;
    tvi.hInsertAfter = TVI_FIRST;
    tvi.item.mask = TVIF_TEXT;

    //
    // address tree
    //
    tvi.item.pszText = L"Addresses";

    ghAddressesWnd = GetDlgItem( IDC_ADDRESSES )->m_hWnd;
    ghAddressesRoot = TreeView_InsertItem(
                                          ghAddressesWnd,
                                          &tvi
                                         );

    //
    // mediatypes tree
    //
    tvi.item.pszText = L"MediaTypes";

    ghMediaTypesWnd = GetDlgItem( IDC_MEDIATYPES )->m_hWnd;
    ghMediaTypesRoot = TreeView_InsertItem(
                                          ghMediaTypesWnd,
                                          &tvi
                                         );

    //
    // terminals tree
    //
    tvi.item.pszText = L"Terminals";

    ghTerminalsWnd = GetDlgItem( IDC_TERMINALS )->m_hWnd;
    ghTerminalsRoot = TreeView_InsertItem(
                                          ghTerminalsWnd,
                                          &tvi
                                         );

    //
    // calls tree
    //
    tvi.item.pszText = L"Calls";
    
    ghCallsWnd = GetDlgItem( IDC_CALLS )->m_hWnd;
    ghCallsRoot = TreeView_InsertItem(
                                      ghCallsWnd,
                                      &tvi
                                     );

    //
    // selected media terminals tree
    //
    tvi.item.pszText = L"Selected Media Terminals";
    
    ghSelectedWnd = GetDlgItem( IDC_SELECTEDTERMINALS )->m_hWnd;
    ghSelectedRoot = TreeView_InsertItem(
                                        ghSelectedWnd,
                                        &tvi
                                       );

    //
    // dynamic terminal classes tree
    //
    tvi.item.pszText = L"Dynamic Terminal Classes";
    
    ghClassesWnd = GetDlgItem( IDC_DYNAMICCLASSES )->m_hWnd;
    ghClassesRoot = TreeView_InsertItem(
                                        ghClassesWnd,
                                        &tvi
                                       );

    //
    // created terminals tree
    //
    tvi.item.pszText = L"Created Terminals";
    
    ghCreatedWnd = GetDlgItem( IDC_CREATEDTERMINALS )->m_hWnd;
    ghCreatedRoot = TreeView_InsertItem(
                                        ghCreatedWnd,
                                        &tvi
                                       );

    //
    // listen mediatypes tree
    //
    tvi.item.pszText = L"Listen MediaTypes";
    
    ghListenWnd = GetDlgItem( IDC_LISTENMEDIAMODES )->m_hWnd;
    ghListenRoot = TreeView_InsertItem(
                                       ghListenWnd,
                                       &tvi
                                      );
    
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnDestroy
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnDestroy() 
{
	CDialog::OnDestroy();

    gfShuttingDown = TRUE;

    //
    // Release everything
    //
    ReleaseMediaTypes();
    ReleaseTerminals();
    ReleaseCalls();
    ReleaseSelectedTerminals();
    ReleaseCreatedTerminals();
    ReleaseTerminalClasses();
    ReleaseListen();
    ReleaseAddresses();

    DataPtrList::iterator       iter, end;

    iter = gDataPtrList.begin();
    end  = gDataPtrList.end();
    
    for( ; iter != end; iter++ )
    {
        FreeData( *iter );

        delete (*iter)->pTerminalPtrList;
        
        CoTaskMemFree( *iter );
    }

    gDataPtrList.clear();
    

    if (NULL != gpCP)
    {
        gpCP->Unadvise(gulAdvise);
        gpCP->Release();
    }
    
    //
    // shutdown TAPI
    //
    if (NULL != gpTapi)
    {
        gpTapi->Shutdown();
        gpTapi->Release();
    }

}

void
DoAddressCapStuff(ITTAPI * pTapi);
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnSelChangedAddresses
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnSelchangedAddresses(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_TREEVIEW*            pNMTreeView = (NM_TREEVIEW*)pNMHDR;
    ITAddress *             pAddress;


	*pResult = 0;


    //
    // free all the stuff related to
    // the address selected.  this stuff
    // will all be refilled in
    //
    ReleaseMediaTypes();
    ReleaseListen();
    ReleaseCalls();
    ReleaseSelectedTerminals();
    ReleaseCreatedTerminals();
    

    //
    // get the currently selected address
    //
    if (!GetAddress( &pAddress ))
    {
        return;
    }

    //
    // update these trees
    //
    if ( !gfShuttingDown )
    {
        UpdateMediaTypes( pAddress );
        UpdateCalls( pAddress );
    }
}

/////////////////////////////////////////////////////////////////
// IsVideoCaptureStream
//
// Returns true if the stream is for video capture
/////////////////////////////////////////////////////////////////

BOOL
CT3testDlg::IsVideoCaptureStream(
                     ITStream * pStream
                    )
{
    TERMINAL_DIRECTION tdStreamDirection;
    long               lStreamMediaType;

    if ( FAILED( pStream  ->get_Direction(&tdStreamDirection)   ) ) { return FALSE; }
    if ( FAILED( pStream  ->get_MediaType(&lStreamMediaType)    ) ) { return FALSE; }

    return (tdStreamDirection == TD_CAPTURE) &&
           (lStreamMediaType  == TAPIMEDIATYPE_VIDEO);
}

/////////////////////////////////////////////////////////////////
// EnablePreview
//
// Selects a video render terminal on a video capture stream,
// thereby enabling video preview.
/////////////////////////////////////////////////////////////////

HRESULT
CT3testDlg::EnablePreview(
              ITStream * pStream
             )
{
    ITTerminal * pTerminal;

    HRESULT hr = GetVideoRenderTerminal(&pTerminal);

    if ( SUCCEEDED(hr) )
    {
        hr = pStream->SelectTerminal(pTerminal);

        pTerminal->Release();
    }

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// SelectTerminalOnCall
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

HRESULT
CT3testDlg::SelectTerminalOnCall(
                ITTerminal * pTerminal,
                ITCallInfo * pCall
               )
{
    ITStreamControl *       pStreamControl;
    TERMINAL_DIRECTION      termtd;
    long                    lTermMediaType;
    HRESULT hr;

    pTerminal->get_Direction( &termtd );
    pTerminal->get_MediaType( &lTermMediaType );
    
    hr = pCall->QueryInterface(
                               IID_ITStreamControl,
                               (void**) &pStreamControl
                              );

    if ( SUCCEEDED(hr) )
    {
        IEnumStream * pEnumStreams;
        
        hr = pStreamControl->EnumerateStreams( &pEnumStreams );

        if ( SUCCEEDED(hr) )
        {
            while (TRUE)
            {
                ITStream              * pStream;
                long                    lMediaType;
                TERMINAL_DIRECTION      td;
                
                hr = pEnumStreams->Next( 1, &pStream, NULL );

                if ( S_OK != hr )
                {
                    hr = E_FAIL; // didn't select it anywhere
                    break;
                }

                pStream->get_MediaType( &lMediaType );
                pStream->get_Direction( &td );

                if ( ( lMediaType == lTermMediaType ) &&
                     ( td == termtd) )
                {
                    hr = pStream->SelectTerminal( pTerminal );

                    if ( FAILED(hr) )
                    {
                        ::MessageBox(NULL, L"SelectTerminals failed", NULL, MB_OK);
                    }
                    else
                    {
                        //
                        // Also enable preview on the video capture stream.
                        //

                        if ( IsVideoCaptureStream( pStream ) )
                        {
                            EnablePreview( pStream );
                        }

                        pStream->Release();
                        
                        break;
                    }
                }
                
                pStream->Release();
            }

            pEnumStreams->Release();
        }

        pStreamControl->Release();
    }

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnAddTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

void CT3testDlg::OnAddterminal() 
{
    ITCallInfo *            pCall;
    ITTerminal *            pTerminal;
    HRESULT                 hr = S_OK;

    //
    // get the selected call
    //
    if (!(GetCall( &pCall )))
    {
        return;
    }


    //
    // get the selected terminal
    //
    if (!(GetTerminal( &pTerminal )))
    {
        return;
    }

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"SelectTerminals failed", NULL, MB_OK);
        return;
    }
        
    hr = SelectTerminalOnCall(pTerminal, pCall);

    if ( FAILED(hr) )
    {
        return;
    }

    //
    // put the terminal in the
    // tree
    //
    AddSelectedTerminal(
                        pTerminal
                       );
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// RemovePreview
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

void CT3testDlg::RemovePreview( ITStream * pStream )
{
    //
    // This is a video capture stream and we've unselected the
    // video capture terminal. If there is a video render
    // terminal on the stream, then unselect it now.
    //

    IEnumTerminal * pEnum;

    if ( FAILED( pStream->EnumerateTerminals( &pEnum ) ) )
    {
        return;
    }

    ITTerminal * pTerminal;

    if ( S_OK == pEnum->Next(1, &pTerminal, NULL) )
    {
        pStream->UnselectTerminal( pTerminal );
        pTerminal->Release();
    }

    pEnum->Release();
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnRemoveTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnRemoveterminal() 
{
    ITTerminal *                pTerminal;
    ITCallInfo *                pCall;
    HTREEITEM                   hItem;
    HRESULT                     hr;
    ITBasicCallControl *        pBCC;

    

    //
    // get current call
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    //
    // get current terminal
    //
    if (!GetSelectedTerminal(&pTerminal))
    {
        return;
    }

    TERMINAL_DIRECTION termtd;
    long               lTermMediaType;

    pTerminal->get_Direction( &termtd );
    pTerminal->get_MediaType( &lTermMediaType );

    ITStreamControl * pStreamControl;
    
    hr = pCall->QueryInterface(
                               IID_ITStreamControl,
                               (void**) &pStreamControl
                              );

    BOOL bFound = FALSE;

    if ( SUCCEEDED(hr) )
    {
        IEnumStream * pEnumStreams;
        
        hr = pStreamControl->EnumerateStreams( &pEnumStreams );

        if ( SUCCEEDED(hr) )
        {
            while ( ! bFound )
            {
                ITStream              * pStream;
                long                    lMediaType;
                TERMINAL_DIRECTION      td;
                
                hr = pEnumStreams->Next( 1, &pStream, NULL );

                if ( S_OK != hr )
                {
                    break;
                }

                pStream->get_MediaType( &lMediaType );
                pStream->get_Direction( &td );

                if ( ( lMediaType == lTermMediaType ) &&
                     ( td == termtd) )
                {
                    hr = pStream->UnselectTerminal( pTerminal );

                    if ( !SUCCEEDED(hr) )
                    {
                        ::MessageBox(NULL, L"UnselectTerminals failed", NULL, MB_OK);
                    }
                    else
                    {
                        if ( IsVideoCaptureStream( pStream ) )
                        {
                            RemovePreview( pStream );
                        }

                        bFound = TRUE;
                    }

                }
                
                pStream->Release();
            }

            pEnumStreams->Release();
        }

        pStreamControl->Release();
    }


    if ( !bFound )
    {
        return;
    }

    //
    // remove it from tree
    //
    hItem = TreeView_GetSelection( ghSelectedWnd );
    TreeView_DeleteItem(
                        ghSelectedWnd,
                        hItem
                       );


    //
    // release tree's reference to
    // the terminal
    //
    pTerminal->Release();

	
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnCreateCall
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnCreatecall() 
{
    ITAddress *             pAddress;
    HRESULT                 hr;
    ITBasicCallControl *    pCall;
    ITCallInfo *            pCallInfo;
    BOOL                    bConference      = FALSE;
    BOOL                    lAddressType     = LINEADDRESSTYPE_PHONENUMBER;
    BSTR                    bstrDestAddress;
    ITAddressCapabilities * pAddressCaps;
    long                    lType = 0;
    ITMediaSupport *        pMediaSupport;
    long                    lSupportedMediaTypes, lMediaTypes = 0;
    
    //
    // get the current address
    //
    if (!GetAddress( &pAddress ))
    {
        return;
    }


    hr = pAddress->QueryInterface(IID_ITAddressCapabilities, (void**)&pAddressCaps);

    hr = pAddressCaps->get_AddressCapability( AC_ADDRESSTYPES, &lType );

    if ( SUCCEEDED(hr) && (LINEADDRESSTYPE_SDP & lType) )
    {
        bConference = TRUE;
        lAddressType = LINEADDRESSTYPE_SDP;
    }

    if ( SUCCEEDED(hr) && (LINEADDRESSTYPE_DOMAINNAME & lType) )
    {
        lAddressType = LINEADDRESSTYPE_DOMAINNAME;
    }

    pAddressCaps->Release();
    
    if ( !bConference )
    {
        //
        // create the dialog to get the
        // dial string
        //
        CCreateCallDlg Dlg( this );


        if (IDOK == Dlg.DoModal())
        {
            //
            // create a call with the
            // string input in the dialog
            //
            bstrDestAddress = SysAllocString( Dlg.m_pszDestAddress );
        }
        else
        {
            return;
        }
    }
    else
    {
        CConfDlg    Dlg;

        if ( IDOK == Dlg.DoModal() )
        {
            bstrDestAddress = Dlg.m_bstrDestAddress;
        }
        else
        {
            return;
        }
    }

    //
    // Find out if the address supports audio, video, or both.
    //

    pAddress->QueryInterface(
                             IID_ITMediaSupport,
                             (void**)&pMediaSupport
                            );

    pMediaSupport->get_MediaTypes( &lSupportedMediaTypes );
                                  
    pMediaSupport->Release();


    if ( lSupportedMediaTypes & TAPIMEDIATYPE_AUDIO )
    {
        lMediaTypes |= TAPIMEDIATYPE_AUDIO;
    }

    if ( lSupportedMediaTypes & TAPIMEDIATYPE_VIDEO )
    {
        lMediaTypes |= TAPIMEDIATYPE_VIDEO;
    }

    if ( lMediaTypes == 0 )
    {
        if ( lSupportedMediaTypes & TAPIMEDIATYPE_DATAMODEM )
        {
            lMediaTypes |= TAPIMEDIATYPE_DATAMODEM;
        }
    }

    //
    // Create the call.
    //

    hr = pAddress->CreateCall(
                              bstrDestAddress,
                              lAddressType,
                              lMediaTypes,
                              &pCall
                             );

    SysFreeString( bstrDestAddress );


    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"CreateCall failed", NULL, MB_OK);
        return;
    }

    //
    // get the callinfo interface
    //
    pCall->QueryInterface( IID_ITCallInfo, (void **)&pCallInfo );


    //
    // add the call to the tree
    //
    AddCall(pCallInfo);

    //
    // update the callinfo
    //
    UpdateCall( pCallInfo );


    //
    // release this inteface
    //
    pCallInfo->Release();

    //
    // note that we keep a global reference to the call
    // (CreateCall returns with a reference count of 1)
    // so the call does not get destroyed.  When we want
    // the call to actually be destroyed, then we
    // release twice.
    //
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnConnect
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnConnect() 
{
    ITBasicCallControl *            pCall;
    ITCallInfo *                    pCallInfo;
    HRESULT                         hr = S_OK;


    //
    // get the current call
    //
    if (!GetCall( &pCallInfo))
    {
        return;
    }

    //
    // get the call control interface
    //
    hr = pCallInfo->QueryInterface(IID_ITBasicCallControl, (void **)&pCall);
    
    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"Connect failed", NULL, MB_OK);
        return;
    }


    //
    // call connect
    //
    hr = pCall->Connect( FALSE );


    //
    // release this interface
    //
    pCall->Release();

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"Connect failed", NULL, MB_OK);
        return;
    }
	
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnDrop
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnDrop() 
{
    ITBasicCallControl *        pCall;
    ITCallInfo *                pCallInfo;
    HRESULT                     hr =    S_OK;


    //
    // get the current call
    //
    if (!GetCall( &pCallInfo ))
    {
        return;
    }

    //
    // get the bcc interface
    //
    hr = pCallInfo->QueryInterface(
                                   IID_ITBasicCallControl,
                                   (void **)&pCall
                                  );

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"Disconnect failed", NULL, MB_OK);
        return;
    }


    //
    // call disconnect
    //
    hr = pCall->Disconnect( DC_NORMAL );

    //
    // release this reference
    //
    pCall->Release();

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"Disconnect failed", NULL, MB_OK);
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnDrop
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnAnswer() 
{
    ITCallInfo *                pCallInfo;
    ITBasicCallControl *        pCall;
    HRESULT                     hr = S_OK;


    //
    // get the current call
    //
    if (!GetCall( &pCallInfo))
    {
        return;
    }

    //
    // get the bcc interface
    //
    hr = pCallInfo->QueryInterface(IID_ITBasicCallControl, (void **)&pCall);
    
    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"Answer failed", NULL, MB_OK);
        return;
    }

    //
    // answer it
    //
    hr = pCall->Answer( );

    //
    // release this interface
    //
    pCall->Release();

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"Answer failed", NULL, MB_OK);
    }
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnListen
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnListen() 
{
    ITAddress *             pAddress;
    HRESULT                 hr = S_OK;
    DWORD                   dwCookie;
    HTREEITEM               hItem;
    long                    ulRegister;
    DWORD                   dwMediaMode = 0;


    //
    // get the current address
    //
    if (!GetAddress( &pAddress ))
    {
        return;
    }


    hItem = TreeView_GetChild(
                              ghListenWnd,
                              ghListenRoot
                             );

    while (NULL != hItem)
    {
        TV_ITEM item;

        item.mask = TVIF_HANDLE | TVIF_PARAM;
        item.hItem = hItem;

        //
        // get it
        //
        TreeView_GetItem(
                         ghListenWnd,
                         &item
                        );

        dwMediaMode |= (DWORD)(item.lParam);

        hItem = TreeView_GetNextSibling(
                                        ghAddressesWnd,
                                        hItem
                                       );

    }

    hr = gpTapi->RegisterCallNotifications(
                                           pAddress,
                                           VARIANT_TRUE,
                                           VARIANT_TRUE,
                                           (long)dwMediaMode,
                                           gulAdvise,
                                           &ulRegister
                                          );

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"RegisterCallNotifications failed", NULL, MB_OK);
    }

    //
    // release all the mediatypes
    // in the listen tree
    //
    ReleaseListen();
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnSelChangedCalls
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnSelchangedCalls(NMHDR* pNMHDR, LRESULT* pResult) 
{
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnRelease()
//
// this is called to release all references to a call
//
// if a call is selected it has two references - once for
// the tree control, and once for our global reference.
// release both here.
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnRelease() 
{
    ITCallInfo *        pCallInfo;


    //
    // get the call
    //
    if (!GetCall( &pCallInfo ))
    {
        return;
    }

    //
    // these depend on the call,
    // so release them
    //
    ReleaseSelectedTerminals();
    ReleaseCreatedTerminals();

    //
    // delete it from the tree
    //
    DeleteSelectedItem(
                       ghCallsWnd
                      );

    //
    // release once for the tree view
    //
    pCallInfo->Release();

    //
    // release a second time for our global reference
    //
    pCallInfo->Release();

}

void
CT3testDlg::HelpCreateTerminal(
                               ITTerminalSupport * pTerminalSupport,
                               BSTR bstrClass,
                               long lMediaType,
                               TERMINAL_DIRECTION dir
                              )
{
    ITTerminal * pTerminal;
    HRESULT         hr;
    
    //
    // create it
    //
    hr = pTerminalSupport->CreateTerminal(
                                          bstrClass,
                                          lMediaType,
                                          dir,
                                          &pTerminal
                                         );

    if (S_OK != hr)
    {
        return;
    }

    // 
    // ZoltanS:
    // We do nothing special with our video windows. Just make them visible
    // all the time. If this isn't a video window we just skip this step.
    //

    IVideoWindow * pWindow;

    if ( SUCCEEDED( pTerminal->QueryInterface(IID_IVideoWindow,
                                              (void **) &pWindow) ) )
    {
        pWindow->put_AutoShow( VARIANT_TRUE );

        pWindow->Release();
    }


    //
    // add the terminal
    //
    AddCreatedTerminal(
                       pTerminal
                      );


    //
    // release our reference
    //
    pTerminal->Release();    
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetVideoRenderTerminal
//
// this is used to create a video render terminal for preview
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

HRESULT CT3testDlg::GetVideoRenderTerminal(ITTerminal ** ppTerminal) 
{
    //
    // Get the current address
    //

    ITAddress * pAddress;

    if (!GetAddress( &pAddress ))
    {
        return E_FAIL;
    }

    //
    // get the terminal support interface
    //

    ITTerminalSupport * pTerminalSupport;
    HRESULT hr;

    hr = pAddress->QueryInterface(
                                  IID_ITTerminalSupport,
                                  (void **) &pTerminalSupport
                                 );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // Construct a BSTR for the correct IID.
    //

    LPOLESTR            lpTerminalClass;

    hr = StringFromIID(CLSID_VideoWindowTerm,
                       &lpTerminalClass);

    BSTR                bstrTerminalClass;

    if ( FAILED(hr) )
    {
        pTerminalSupport->Release();
        return hr;
    }

    bstrTerminalClass = SysAllocString ( lpTerminalClass );

    CoTaskMemFree( lpTerminalClass );

    if ( bstrTerminalClass == NULL )
    {
        pTerminalSupport->Release();
        return E_OUTOFMEMORY;
    }
    
    //
    // create it
    //

    hr = pTerminalSupport->CreateTerminal(
                                          bstrTerminalClass,
                                          TAPIMEDIATYPE_VIDEO,
                                          TD_RENDER,
                                          ppTerminal
                                         );

    pTerminalSupport->Release();

    if ( FAILED(hr) )
    {
        *ppTerminal = NULL;
        return hr;
    }

    // 
    // We do nothing special with our video windows. Just make them visible
    // all the time.
    //

    IVideoWindow * pWindow;

    if ( FAILED( (*ppTerminal)->QueryInterface(IID_IVideoWindow,
                                               (void **) &pWindow) ) )
    {
        (*ppTerminal)->Release();
        *ppTerminal = NULL;

        return hr;
    }

    pWindow->put_AutoShow( VARIANT_TRUE );

    pWindow->Release();

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnCreateTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnCreateTerminal() 
{
    //
    // Get the selected media type.
    //

    long lMediaType;

    if (!GetMediaType( &lMediaType ))
    {
        return;
    }

    //
    // Get the current address
    //

    ITAddress * pAddress;

    if (!GetAddress( &pAddress ))
    {
        return;
    }

    //
    // Get the selected terminal class.
    //

    BSTR bstrClass;

    if (!GetTerminalClass( &bstrClass ))
    {
        return;
    }

    //
    // get the terminal support interface
    //

    ITTerminalSupport * pTerminalSupport;
    HRESULT hr;

    hr = pAddress->QueryInterface(
                                  IID_ITTerminalSupport,
                                  (void **) &pTerminalSupport
                                 );

    if ( FAILED(hr) )
    {
        SysFreeString( bstrClass );
        return;
    }

    //
    // Convert the terminal class from a BSTR to an IID.
    //

    IID iidTerminalClass;

    IIDFromString(
                bstrClass,
                &iidTerminalClass
               );

    //
    // Create and add the terminal.
    //

    if ( CLSID_VideoWindowTerm == iidTerminalClass )
    {
        HelpCreateTerminal(
                           pTerminalSupport,
                           bstrClass,
                           lMediaType,
                           TD_RENDER
                          );
    }

    //
    // Release references.
    //

    pTerminalSupport->Release();

    SysFreeString(bstrClass);
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnReleaseTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnReleaseterminal() 
{
    ITTerminal * pTerminal;

    //
    // get the terminal
    //
    if (GetCreatedTerminal( &pTerminal ))
    {
        //
        // and release it!
        //
        pTerminal->Release();

        //
        // delete it from the tree
        //
        DeleteSelectedItem(
                           ghCreatedWnd
                          );
    }
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnAddCreated
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnAddcreated() 
{
    ITTerminal *            pTerminal;
    ITCallInfo *            pCall;
    HRESULT                 hr = S_OK;
    ITBasicCallControl *    pBCC;
    

    //
    // get the current call
    //

    if (!(GetCall( &pCall )))
    {
        return;
    }

    //
    // GetCreatedTerminal
    //

    if (!GetCreatedTerminal( &pTerminal ))
    {
        return;
    }

    //
    // Select the terminal on the call.
    //

    hr = SelectTerminalOnCall(pTerminal, pCall);

    if ( FAILED(hr) )
    {
        ::MessageBox(NULL, L"SelectTerminals failed", NULL, MB_OK);
        return;
    }

    //
    // add to the selected window
    //

    AddSelectedTerminal(
                        pTerminal
                       );

    //
    // delete from the created window
    //

    DeleteSelectedItem(
                       ghCreatedWnd
                      );

    //
    // release because there was a reference to
    // this terminal in the created wnd
    //

    pTerminal->Release();
    return;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnAddNull
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

void CT3testDlg::OnAddnull() 
{
    return;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnAddToListen
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

void CT3testDlg::OnAddtolisten() 
{
    long lMediaType;

    //
    // get the current mediatype
    //
    if (!GetMediaType( &lMediaType ))
    {
        return;
    }

    //
    // add it
    //
    AddListen( lMediaType );
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnListenAll
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnListenall() 
{
    ITAddress *             pAddress;
    HRESULT                 hr = S_OK;
    long                    ulRegister;
    long                    lMediaType;
    ITMediaSupport        * pMediaSupport;
    
    //
    // get the currently selected address
    //
    if (!GetAddress( &pAddress ))
    {
        return;
    }

    pAddress->QueryInterface(
                             IID_ITMediaSupport,
                             (void **)&pMediaSupport
                            );
    
    pMediaSupport->get_MediaTypes( &lMediaType );
    
    //
    // register
    //
    gpTapi->RegisterCallNotifications(
                                      pAddress,
                                      TRUE,
                                      TRUE,
                                      lMediaType,
                                      gulAdvise,
                                      &ulRegister
                                     );

    
    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"RegisterCallTypes failed", NULL, MB_OK);
    }

	
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnSelChangedMedia
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnSelchangedMediatypes(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_TREEVIEW*            pNMTreeView = (NM_TREEVIEW*)pNMHDR;
    long                    lMediaType;
    ITAddress *             pAddress;
    HRESULT                 hr;

	*pResult = 0;

    if (gbUpdatingStuff)
        return;

    //
    // get the current mediatype
    //
    if (!GetMediaType( &lMediaType ))
    {
        return;
    }

    //
    // get the current address
    //
    if (!GetAddress( &pAddress ))
    {
        return;
    }

    //
    // we only show terminals that relate
    // to the selected mediatype
    // so get rid of the old ones
    //
    ReleaseTerminals();
    ReleaseTerminalClasses();

    UpdateTerminals( pAddress, lMediaType );
    UpdateTerminalClasses( pAddress, lMediaType );
    
}

void CT3testDlg::OnRclickSelectedterminals(NMHDR* pNMHDR, LRESULT* pResult) 
{
    POINT                   pt;
    HTREEITEM               hItem;
    TV_HITTESTINFO          hittestinfo;
    RECT                    rc;

    
    *pResult = 0;

    //
    // get the location of the cursor
    //
    GetCursorPos( &pt );

    //
    // get the control's window
    //
    ::GetWindowRect(
                    ghSelectedWnd,
                    &rc
                   );

    //
    // adjust the point to
    // the child's coords
    //
    hittestinfo.pt.x = pt.x - rc.left;
    hittestinfo.pt.y = pt.y - rc.top;


    //
    // hittest to get the tree view item
    //
    hItem = TreeView_HitTest(
                             ghSelectedWnd,
                             &hittestinfo
                            );


    //
    // only display a menu if the mouse is actually
    // over the item (TVHT_ONITEM)
    //
    if (hItem == NULL || (!(hittestinfo.flags & TVHT_ONITEM)) )
    {
        return;
    }


    //
    // select that item (right clicking will not select
    // by default
    //
    TreeView_Select(
                    ghSelectedWnd,
                    hItem,
                    TVGN_CARET
                   );

    CreateSelectedTerminalMenu(
                               pt,
                               m_hWnd
                              );
}


#ifdef ENABLE_DIGIT_DETECTION_STUFF

void CT3testDlg::OnModesSupported()
{
	ITTerminal *                    pTerminal;
    ITDigitGenerationTerminal *     pDigitGeneration;
    HRESULT                         hr = S_OK;
    LONG                            lDigits;

    
    if (!GetSelectedTerminal(&pTerminal))
    {
        return;
    }

    hr = pTerminal->QueryInterface(
                                   IID_ITDigitGenerationTerminal,
                                   (void **) &pDigitGeneration
                                  );

    if (!SUCCEEDED(hr))
    {
        return;
    }

    pDigitGeneration->get_ModesSupported( &lDigits );

    pDigitGeneration->Release();
}


void CT3testDlg::OnGenerate()
{
	ITTerminal *                    pTerminal;
    ITDigitGenerationTerminal *     pDigitGeneration;
    HRESULT                         hr = S_OK;


    
    if (!GetSelectedTerminal(&pTerminal))
    {
        return;
    }

    hr = pTerminal->QueryInterface(
                                   IID_ITDigitGenerationTerminal,
                                   (void **) &pDigitGeneration
                                  );

    if (!SUCCEEDED(hr))
    {
        return;
    }

    hr = pDigitGeneration->Generate(
                                    L"12345",
                                    LINEDIGITMODE_DTMF
                                   );

    pDigitGeneration->Release();
}

void CT3testDlg::OnModesSupported2()
{
	ITTerminal *                    pTerminal;
    ITDigitDetectionTerminal *      pDigitDetection;
    HRESULT                         hr = S_OK;
    LONG                            lDigits;

    
    if (!GetSelectedTerminal(&pTerminal))
    {
        return;
    }

    hr = pTerminal->QueryInterface(
                                   IID_ITDigitDetectionTerminal,
                                   (void **) &pDigitDetection
                                  );

    if (!SUCCEEDED(hr))
    {
        return;
    }

    pDigitDetection->get_ModesSupported( &lDigits );

    pDigitDetection->Release();
}

void CT3testDlg::OnStartDetect()
{
	ITTerminal *                    pTerminal;
    ITDigitDetectionTerminal *      pDigitDetection;
    HRESULT                         hr = S_OK;
    LONG                            lDigits;
    ULONG                           ulAdvise;
    IConnectionPointContainer *     pCPC;
    IConnectionPoint *              pCP;
    
    if (!GetSelectedTerminal(&pTerminal))
    {
        return;
    }

    hr = pTerminal->QueryInterface(
                                   IID_ITDigitDetectionTerminal,
                                   (void **) &pDigitDetection
                                  );

    if (!SUCCEEDED(hr))
    {
        return;
    }


    hr = pTerminal->QueryInterface(
                                   IID_IConnectionPointContainer,
                                   (void **)&pCPC
                                  );

    if (!SUCCEEDED(hr))
    {
        pDigitDetection->Release();
        return;
    }

    gpDigitNotification = new CDigitDetectionNotification;
    
    hr = pCPC->FindConnectionPoint(
                                   IID_ITDigitDetectionNotification,
                                   &pCP
                                  );

    pCPC->Release();

    IUnknown * pUnk;
    
    gpDigitNotification->QueryInterface(
                                        IID_IUnknown,
                                        (void**)&pUnk
                                       );
    
    hr = pCP->Advise(
                     pUnk,
                     &ulAdvise
                    );

    pUnk->Release();
    
    pCP->Release();
    
    pDigitDetection->StartDetect(LINEDIGITMODE_DTMF);

    pDigitDetection->Release();
}

void CT3testDlg::OnStopDetect()
{
	ITTerminal *                    pTerminal;
    ITDigitDetectionTerminal *      pDigitDetection;
    HRESULT                         hr = S_OK;
    LONG                            lDigits;

    
    if (!GetSelectedTerminal(&pTerminal))
    {
        return;
    }

    hr = pTerminal->QueryInterface(
                                   IID_ITDigitDetectionTerminal,
                                   (void **) &pDigitDetection
                                  );

    if (!SUCCEEDED(hr))
    {
        return;
    }

    pDigitDetection->StopDetect();

    pDigitDetection->Release();
}

#endif // ENABLE_DIGIT_DETECTION_STUFF



void CT3testDlg::OnRclickCalls(NMHDR* pNMHDR, LRESULT* pResult) 
{
    POINT                   pt;
    HTREEITEM               hItem;
    TV_HITTESTINFO          hittestinfo;
    RECT                    rc;

    
    *pResult = 0;

    //
    // get the location of the cursor
    //
    GetCursorPos( &pt );

    //
    // get the control's window
    //
    ::GetWindowRect(
                    ghCallsWnd,
                    &rc
                   );

    //
    // adjust the point to
    // the child's coords
    //
    hittestinfo.pt.x = pt.x - rc.left;
    hittestinfo.pt.y = pt.y - rc.top;


    //
    // hittest to get the tree view item
    //
    hItem = TreeView_HitTest(
                             ghCallsWnd,
                             &hittestinfo
                            );


    //
    // only display a menu if the mouse is actually
    // over the item (TVHT_ONITEM)
    //
    if (hItem == NULL || (!(hittestinfo.flags & TVHT_ONITEM)) )
    {
        return;
    }


    //
    // select that item (right clicking will not select
    // by default
    //
    TreeView_Select(
                    ghCallsWnd,
                    hItem,
                    TVGN_CARET
                   );

}

void CT3testDlg::OnConfigAutoAnswer()
{
    ITAddress * pAddress;
    autoans dlg;
    DataPtrList::iterator   dataiter, dataend;
    
    if (!GetAddress( &pAddress ) )
    {
        return;
    }

    dataiter = gDataPtrList.begin();
    dataend  = gDataPtrList.end();

    for ( ; dataiter != dataend; dataiter++ )
    {
        if ( pAddress == (*dataiter)->pAddress )
        {
            break;
        }
    }

    if ( dataiter == dataend )
    {
        return;
    }

    FreeData( (*dataiter) );
    
    if (IDOK == dlg.DoModal())
    {
        TerminalPtrList::iterator       iter, end;
        DWORD                           dwCount;
        long                            lRegister;
        HRESULT                         hr;
        long                            lMediaType = 0;
        
        dwCount = dlg.m_TerminalPtrList.size();

        if ( 0 == dwCount )
        {
            return;
        }
        
        iter = dlg.m_TerminalPtrList.begin();
        end  = dlg.m_TerminalPtrList.end();
        
        for ( ; iter != end ; iter++ )
        {
            long        l;
            
            (*dataiter)->pTerminalPtrList->push_back( *iter );

            if ( NULL != (*iter) )
            {
                (*iter)->get_MediaType( &l );
                lMediaType |= l;
            }
            else
            {
                lMediaType |= (long)LINEMEDIAMODE_VIDEO;
            }

        }

        //
        // call register call types
        //
        hr = gpTapi->RegisterCallNotifications(
                                               pAddress,
                                               VARIANT_FALSE,
                                               VARIANT_TRUE,
                                               lMediaType,
                                               0,
                                               &lRegister
                                              );

    }

}
void CT3testDlg::FreeData( AADATA * pData )
{
    TerminalPtrList::iterator       iter, end;

    iter = pData->pTerminalPtrList->begin();
    end  = pData->pTerminalPtrList->end();

    for ( ; iter != end; iter++ )
    {
        if ( NULL != (*iter) )
        {
            (*iter)->Release();
        }
    }

    pData->pTerminalPtrList->clear();
}

void CT3testDlg::OnClose() 
{
	CDialog::OnClose();
}


void CT3testDlg::OnILS()
{
    CILSDlg dlg;

    if (IDOK == dlg.DoModal())
    {
    }
    
}

void CT3testDlg::OnRate()
{
    CRateDlg dlg;
    ITCallInfo * pCallInfo;

    if ( !GetCall( &pCallInfo ) )
    {
        return;
    }

    if (IDOK == dlg.DoModal() )
    {
        pCallInfo->put_CallInfoLong(CIL_MINRATE, dlg.m_dwMinRate );
        pCallInfo->put_CallInfoLong(CIL_MAXRATE, dlg.m_dwMaxRate );
    }
}

void CT3testDlg::OnPark1()
{
    ITCallInfo              * pCall;
    ITBasicCallControl      * pBCC;
    HRESULT                 hr;
    
    //
    // get the call in question
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    pCall->QueryInterface(
                          IID_ITBasicCallControl,
                          (void**)&pBCC
                         );
    
    hr = pBCC->ParkDirect( L"101");
    
    pBCC->Release();

}
void CT3testDlg::OnPark2()
{
    ITCallInfo              * pCall;
    ITBasicCallControl      * pBCC;
    HRESULT                 hr;
    BSTR                    pAddress;

    
    //
    // get the call in question
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    pCall->QueryInterface(
                          IID_ITBasicCallControl,
                          (void **)&pBCC
                         );

    hr = pBCC->ParkIndirect( &pAddress );

    SysFreeString( pAddress );

    pBCC->Release();
    

}
void CT3testDlg::OnHandoff1()
{
    ITCallInfo              * pCall;
    ITBasicCallControl      * pBCC;
    HRESULT                 hr;

    //
    // get the call in question
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    pCall->QueryInterface(
                          IID_ITBasicCallControl,
                          (void **)&pBCC
                         );

    pBCC->HandoffDirect( L"tb20.exe" );

    pBCC->Release();
    
}
void CT3testDlg::OnHandoff2()
{
    ITCallInfo              * pCall;
    ITBasicCallControl      * pBCC;
    HRESULT                 hr;


    //
    // get the call in question
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    pCall->QueryInterface(
                          IID_ITBasicCallControl,
                          (void **)&pBCC
                         );

    pBCC->HandoffIndirect( TAPIMEDIATYPE_AUDIO );

    pBCC->Release();

}
void CT3testDlg::OnUnpark()
{
    ITCallInfo              * pCall;
    ITBasicCallControl      * pBCC;
    HRESULT                 hr;

    //
    // get the call in question
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    pCall->QueryInterface(
                          IID_ITBasicCallControl,
                          (void **)&pBCC
                         );


    pBCC->Unpark();

    pBCC->Release();
    
}
void CT3testDlg::OnPickup1()
{
    ITCallInfo              * pCall;
    ITBasicCallControl      * pBCC;
    HRESULT                 hr;

    //
    // get the call in question
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    pCall->QueryInterface(
                          IID_ITBasicCallControl,
                          (void **)&pBCC
                         );


    pBCC->Pickup( NULL );

    pBCC->Release();
}
void CT3testDlg::OnPickup2()
{
    ITCallInfo              * pCall;
    ITBasicCallControl      * pBCC;
    HRESULT                 hr;

    //
    // get the call in question
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    pCall->QueryInterface(
                          IID_ITBasicCallControl,
                          (void **)&pBCC
                         );


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3test\t3testd.h ===
// t3testDlg.h : header file
//

#if !defined(AFX_T3TESTDLG_H__2584F27A_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_)
#define AFX_T3TESTDLG_H__2584F27A_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CT3testDlg dialog
#include "autoans.h"
class CT3testDlg : public CDialog
{
// Construction
public:
	CT3testDlg(CWnd* pParent = NULL);	// standard constructor
    void InitializeTrees();
    static void AddAddressToTree( ITAddress * pAddress );
    static void ReleaseAddresses( );
    static void SelectFirstItem(HWND hWnd,HTREEITEM hRoot);
    static void DeleteSelectedItem(HWND hWnd);
    static void UpdateMediaTypes(ITAddress * pAddress);
    static void UpdateCalls(ITAddress * pAddress);
    static void UpdateTerminalClasses(ITAddress * pAddress,long lMediaType);
    static void UpdateTerminals(ITAddress * pAddress,long lMediaType);
    static void CreateSelectedTerminalMenu(POINT pt, HWND);
    static void DoDigitGenerationTerminalMenu(HWND hWnd,POINT *);
    static void DoDigitDetectTerminalMenu(HWND hWnd, POINT *);
    static void CreateCallMenu(POINT pt, HWND hWnd);
    static void PutCaptions();
    static void HandleCallHubEvent( IDispatch * );
    static void HandleTapiObjectMessage( IDispatch * pEvent );
    static LPWSTR GetCallPrivilegeName(ITCallInfo * pCall);
    static LPWSTR GetCallStateName(ITCallInfo * pCall);
    static BSTR GetTerminalClassName( GUID * pguid );
    static void InitializeAddressTree();
    static void RegisterEventInterface();
    static void RegisterForCallNotifications();
    static void AddMediaType( long lMediaType );
    static void AddTerminal( ITTerminal * pTerminal );
    static void AddCreatedTerminal( ITTerminal * pTerminal );    
    static void AddCall( ITCallInfo * pCall );
    static void UpdateCall( ITCallInfo * pCall );
    static void AddSelectedTerminal( ITTerminal * pTerminal);
    static void AddTerminalClass( GUID * );
    static void AddListen( long );
    static void ReleaseMediaTypes( );
    static void ReleaseTerminals();
    static void ReleaseCalls();
    static void ReleaseTerminalClasses();
    static void ReleaseCreatedTerminals();
    static void ReleaseDynamicClasses();
    static void ReleaseSelectedTerminals();
    static void ReleaseListen();
    static void GetMediaTypeName( long, LPWSTR );
    static BOOL GetMediaType( long * plMediaType );
    static BOOL GetCall( ITCallInfo ** ppCall );
    static BOOL GetAddress( ITAddress ** ppAddress );
    static BOOL GetTerminal( ITTerminal ** ppTerminal );
    static BOOL GetTerminalClass( BSTR * pbstrClass );
    static BOOL GetCreatedTerminal( ITTerminal ** ppTerminal );
    static BOOL GetSelectedTerminal( ITTerminal ** ppTerminal );
    void FreeData( AADATA * pData );
    static void HelpCreateTerminal(
                               ITTerminalSupport * pTerminalSupport,
                               BSTR bstrClass,
                               long lMediaType,
                               TERMINAL_DIRECTION dir
                              );
    BOOL IsVideoCaptureStream(ITStream * pStream);
    HRESULT GetVideoRenderTerminal(ITTerminal ** ppTerminal) ;
    HRESULT SelectTerminalOnCall(ITTerminal * pTerminal, ITCallInfo * pCall);
    HRESULT EnablePreview(ITStream * pStream);
    void RemovePreview( ITStream * pStream );

    void DoAutoAnswer(ITCallInfo * pCall);
    afx_msg void OnClose() ;
// Dialog Data
	//{{AFX_DATA(CT3testDlg)
	enum { IDD = IDD_T3TEST_DIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CT3testDlg)
	public:
	virtual void OnFinalRelease();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CT3testDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnDestroy();
	afx_msg void OnSelchangedAddresses(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnAddterminal();
	afx_msg void OnRemoveterminal();
	afx_msg void OnCreatecall();
	afx_msg void OnConnect();
	afx_msg void OnDrop();
	afx_msg void OnAnswer();
	afx_msg void OnListen();
	afx_msg void OnSelchangedCalls(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnRelease();
	afx_msg void OnCreateTerminal();
	afx_msg void OnReleaseterminal();
	afx_msg void OnAddcreated();
	afx_msg void OnAddnull();
	afx_msg void OnAddtolisten();
	afx_msg void OnListenall();
	afx_msg void OnSelchangedMediatypes(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnRclickSelectedterminals(NMHDR* pNMHDR, LRESULT* pResult);

#ifdef ENABLE_DIGIT_DETECTION_STUFF
	afx_msg void OnGenerate();
    afx_msg void OnModesSupported();
    afx_msg void OnModesSupported2();
    afx_msg void OnStartDetect();
    afx_msg void OnStopDetect();
#endif // ENABLE_DIGIT_DETECTION_STUFF

    afx_msg void OnConfigAutoAnswer();
    afx_msg void OnILS();
    afx_msg void OnRate();
    afx_msg void OnPark1();
    afx_msg void OnPark2();
    afx_msg void OnHandoff1();
    afx_msg void OnHandoff2();
    afx_msg void OnUnpark();
    afx_msg void OnPickup1();
    afx_msg void OnPickup2();

    
	afx_msg void OnRclickCalls(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg LONG CT3testDlg::OnTapiEvent(UINT u, LONG_PTR l);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

HRESULT ListILSServers(
                       LPWSTR ** ppServers,
                       DWORD * pdwNumServers
                      );

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_T3TESTDLG_H__2584F27A_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3testph\ilsdlg.cpp ===
// autoans.cpp : implementation file
//
#include "stdafx.h"
#include "t3test.h"
#include "t3testd.h"
#include "ilsdlg.h"
#include "servname.h"
#include "resource.h"
#include "strings.h"


#ifdef _DEBUG

#ifndef _WIN64 // mfc 4.2's heap debugging features generate warnings on win64
#define new DEBUG_NEW
#endif

#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CILSDlg::CILSDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CILSDlg::IDD, pParent)
{
}


void CILSDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
}

BOOL CILSDlg::OnInitDialog()
{
    CDialog::OnInitDialog();
    ListServers();
    return TRUE;
}


void CILSDlg::OnOK()
{
    SaveServers();
    
	CDialog::OnOK();
}


void CILSDlg::OnDestroy() 
{
    CleanUp();
    CDialog::OnDestroy();
}


void CILSDlg::ListServers()
{
    HRESULT         hr;
    LPWSTR        * ppServers;
    DWORD           dw;
    
    hr = ListILSServers(
                        &ppServers,
                        &dw
                       );

    if ( !SUCCEEDED(hr) )
    {
        return;
    }

    while (dw)
    {
        dw--;

        SendDlgItemMessage(
                           IDC_ILSLIST,
                           LB_ADDSTRING,
                           0,
                           (LPARAM) ppServers[dw]
                          );

        CoTaskMemFree( ppServers[dw] );
        
    }

    CoTaskMemFree( ppServers );
    
}

void CILSDlg::SaveServers()
{
    HKEY        hKey, hAppKey;
    DWORD       dw;

    
    if ( RegOpenKeyEx(
                      HKEY_LOCAL_MACHINE,
                      PARENTKEY,
                      0,
                      KEY_WRITE,
                      &hKey
                     ) != ERROR_SUCCESS )
    {
    }

    if ( RegCreateKeyEx(
                        hKey,
                        APPKEY,
                        0,
                        L"",
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hAppKey,
                        &dw
                       ) != ERROR_SUCCESS )
    {
    }

    RegCloseKey( hKey );

        
    RegDeleteKey(
                 hAppKey,
                 SERVERKEY
                );
    
    if ( RegCreateKeyEx(
                        hAppKey,
                        SERVERKEY,
                        0,
                        L"",
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hKey,
                        &dw
                       ) != ERROR_SUCCESS )
    {
    }

    RegCloseKey (hAppKey );
    
    dw = SendDlgItemMessage(
                            IDC_ILSLIST,
                            LB_GETCOUNT,
                            0,
                            0
                           );

    while ( 0 != dw )
    {
        WCHAR szServer[256];
        WCHAR szBuffer[256];
        
        dw--;

        wsprintf(szServer, L"server%d", dw);
                 
        SendDlgItemMessage(
                           IDC_ILSLIST,
                           LB_GETTEXT,
                           dw,
                           (LPARAM)szBuffer
                          );

        RegSetValueEx(
                      hKey,
                      szServer,
                      0,
                      REG_SZ,
                      (BYTE *)szBuffer,
                      lstrlenW(szBuffer) * sizeof(WCHAR)
                     );
    }
}

void CILSDlg::CleanUp()
{
}

void CILSDlg::OnAdd()
{
    CServNameDlg dlg;
    
    if (IDOK == dlg.DoModal())
    {
        SendDlgItemMessage(
                           IDC_ILSLIST,
                           LB_ADDSTRING,
                           0,
                           (LPARAM)(LPCTSTR)(dlg.m_pszServerName)
                          );
    }   
}

void CILSDlg::OnRemove()
{
    DWORD       dw;

    dw = SendDlgItemMessage(
                            IDC_ILSLIST,
                            LB_GETCURSEL,
                            0,
                            0
                           );

    if ( dw != LB_ERR )
    {
        SendDlgItemMessage(
                           IDC_ILSLIST,
                           LB_DELETESTRING,
                           dw,
                           0
                          );
    }
}


BEGIN_MESSAGE_MAP(CILSDlg, CDialog)
	ON_WM_DESTROY()
    ON_BN_CLICKED(IDC_ADD, OnAdd)
    ON_BN_CLICKED(IDC_REMOVE, OnRemove)
END_MESSAGE_MAP()

            
HRESULT ListILSServers(
                    LPWSTR ** pppServers,
                    DWORD * pdwNumServers
                   )
{
    HKEY        hKey, hAppKey;
    DWORD       dw, dwSize;

    //
    // look in the directory for the
    //
    if ( RegOpenKeyEx(
                      HKEY_LOCAL_MACHINE,
                      PARENTKEY,
                      0,
                      KEY_WRITE,
                      &hKey
                     ) != ERROR_SUCCESS )
    {
    }

    if ( RegOpenKeyEx(
                      hKey,
                      APPKEY,
                      0,
                      KEY_ALL_ACCESS,
                      &hAppKey
                     ) != ERROR_SUCCESS )
    {
        RegCloseKey( hKey );
        return E_FAIL;
    }

    RegCloseKey( hKey );
    
    if ( RegOpenKeyEx(
                      hAppKey,
                      SERVERKEY,
                      0,
                      KEY_ALL_ACCESS,
                      &hKey
                     ) != ERROR_SUCCESS )
    {
        RegCloseKey(hAppKey);
        return E_FAIL;
    }

    RegCloseKey (hAppKey );
    
    dw = 0;
    
    while (TRUE)
    {
        WCHAR       szBuffer[256];
        WCHAR       szServer[256];
        DWORD       dwType;
        
        wsprintf(szBuffer, L"server%d", dw);

        if ( RegQueryValueEx(
                             hKey,
                             szBuffer,
                             NULL,
                             NULL,
                             NULL,
                             &dwSize
                            ) != ERROR_SUCCESS )
        {
            break;
        }

        dw++;
    }

    *pppServers = (LPWSTR *)CoTaskMemAlloc( dw * sizeof (LPWSTR) );

    if ( NULL == *pppServers )
    {
        return E_OUTOFMEMORY;
    }

    dw = 0;
    
    while (TRUE)
    {
        WCHAR       szBuffer[256];
        WCHAR       szServer[256];
        DWORD       dwType;
        
        wsprintf(szBuffer, L"server%d", dw);

        dwSize = 256;
        
        if ( RegQueryValueEx(
                             hKey,
                             szBuffer,
                             NULL,
                             NULL,
                             (LPBYTE)szServer,
                             &dwSize
                            ) != ERROR_SUCCESS )
        {
            break;
        }

        (*pppServers)[dw] = (LPWSTR) CoTaskMemAlloc( (lstrlenW(szServer) + 1) * sizeof(WCHAR));
        
        lstrcpy(
                (*pppServers)[dw],
                szServer
               );
        dw++;
    }

    *pdwNumServers = dw;

    RegCloseKey( hKey );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3testph\callnot.cpp ===
//

#include "stdafx.h"
#include "t3test.h"
#include "t3testd.h"
#include "callnot.h"
#include "control.h"

#ifdef _DEBUG

#ifndef _WIN64 // mfc 4.2's heap debugging features generate warnings on win64
#define new DEBUG_NEW
#endif

#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


extern CWnd * gpmainwnd;

HandleVideoWindowCrap(
                      ITCallInfo * pCallInfo
                     );

HRESULT
STDMETHODCALLTYPE
CTAPIEventNotification::Event(
                              TAPI_EVENT TapiEvent,
                              IDispatch * pEvent
                             )
{
    HRESULT hr;


    pEvent->AddRef();
    
    hr = PostMessage( gpmainwnd->m_hWnd, WM_USER+101, (WPARAM)TapiEvent, (LPARAM)pEvent );

    return hr;
    
}

afx_msg LONG CT3testDlg::OnTapiEvent(UINT u, LONG_PTR l)
{
    HRESULT         hr;
    TAPI_EVENT      TapiEvent;
    IDispatch *     pEvent;

    TapiEvent = (TAPI_EVENT)u;
    pEvent = (IDispatch *)l;
    
    switch (TapiEvent)
    {
        case TE_CALLNOTIFICATION:
        {
            ITAddress *                 pAddress;
            ITAddress *                 pCallAddress;
            ITCallInfo *                pCallInfo;
            ITCallNotificationEvent *   pCallNotify;


            //
            // get the currently selected address
            //
            if (CT3testDlg::GetAddress( &pAddress ))
            {
                //
                // get the event
                //
                pEvent->QueryInterface(IID_ITCallNotificationEvent, (void **)&pCallNotify );
                //
                // get the call
                //
                pCallNotify->get_Call( &pCallInfo );
                //
                // get the call's event
                //
                pCallInfo->get_Address( &pCallAddress );

                //
                // if this call is supposed to be on this
                // address, add it to the UI
                //
                if (pAddress == pCallAddress)
                {
                    // need to add a second reference for
                    // the tree view
                    CT3testDlg::AddCall( pCallInfo );
                }

                CALL_PRIVILEGE      cp;
                CALL_STATE          cs;
                
                pCallInfo->get_Privilege( &cp );

                if ( CP_OWNER == cp )
                {
                    DoAutoAnswer( pCallInfo );
                }

                pCallInfo->get_CallState(&cs);
                
                //
                // release our references
                // keep refernce to the call or it will
                // be destroyed
                //
                pCallAddress->Release();
                pCallNotify->Release();
            }
        }
        
        break;
        
        case TE_CALLSTATE:
        {
            ITCallStateEvent        * pCallStateEvent;
            ITCallInfo              * pCallInfo;
            CALL_STATE                cs;


            hr = pEvent->QueryInterface(IID_ITCallStateEvent, (void **)&pCallStateEvent);

            pCallStateEvent->get_Call( &pCallInfo );

            CT3testDlg::UpdateCall( pCallInfo );

            pCallStateEvent->get_State(
                                       &cs
                                      );

            if (CS_CONNECTED == cs)
            {
//                HandleVideoWindowCrap( pCallInfo );
            }

            pCallInfo->Release();
            pCallStateEvent->Release();

            break;
        }

        case TE_CALLHUB:
        {
            CT3testDlg::HandleCallHubEvent( pEvent );

            break;
        }

        case TE_TAPIOBJECT:
        {
            CT3testDlg::HandleTapiObjectMessage( pEvent );
            break;
        }

        case TE_ADDRESS:
        {
            CT3testDlg::HandleAddressEvent( pEvent );
            break;
        }

        case TE_PHONEEVENT:
        {
            CT3testDlg::HandlePhoneEvent( pEvent );
            break;
        }

        break;

        case TE_CALLMEDIA:
        {
            WCHAR * pwstrEvent;
            WCHAR * pwstrCause;

            ITCallMediaEvent  * pCallMediaEvent;
            hr = pEvent->QueryInterface( IID_ITCallMediaEvent,
                                         (void **)&pCallMediaEvent );

            if (FAILED(hr))
            {
                pwstrEvent = pwstrCause = L"can't get event interface";
            }
            else
            {
                CALL_MEDIA_EVENT    cme;
                hr = pCallMediaEvent->get_Event( &cme );

                if (FAILED(hr))
                {
                    pwstrEvent = L"can't get event type";
                }
                else
                {
                    switch ( cme )
                    {
                    case CME_NEW_STREAM:
                        pwstrEvent = L"CME_NEW_STREAM";
                        break;

                    case CME_STREAM_FAIL:
                        pwstrEvent = L"CME_STREAM_FAIL";
                        break;
            
                    case CME_TERMINAL_FAIL:
                        pwstrEvent = L"CME_TERMINAL_FAIL";
                        break;

                    case CME_STREAM_NOT_USED:
                        pwstrEvent = L"CME_STREAM_NOT_USED";
                        break;

                    case CME_STREAM_ACTIVE:
                        pwstrEvent = L"CME_STREAM_ACTIVE";
                        break;

                    case CME_STREAM_INACTIVE:
                        pwstrEvent = L"CME_STREAM_INACTIVE";
                        break;

                    default:
                        pwstrEvent = L"type undefined";
                        break;
                    }
                }
            }

            CALL_MEDIA_EVENT_CAUSE    cmec;

            hr = pCallMediaEvent->get_Cause( &cmec );

            pCallMediaEvent->Release();

            if (FAILED(hr))
            {
                pwstrCause = L"can't get event cause";
            }
            else
            {
                switch ( cmec )
                {
                case CMC_UNKNOWN:
                    pwstrCause = L"CMC_UNKNOWN";
                    break;

                case CMC_BAD_DEVICE:
                    pwstrCause = L"CMC_BAD_DEVICE";
                    break;
            
                case CMC_CONNECT_FAIL:
                    pwstrCause = L"CMC_CONNECT_FAIL";
                    break;
            
                case CMC_LOCAL_REQUEST:
                    pwstrCause = L"CMC_LOCAL_REQUEST";
                    break;

                case CMC_REMOTE_REQUEST:
                    pwstrCause = L"CMC_REMOTE_REQUEST";
                    break;

                case CMC_MEDIA_TIMEOUT:
                    pwstrCause = L"CMC_MEDIA_TIMEOUT";
                    break;

                case CMC_MEDIA_RECOVERED:
                    pwstrCause = L"CMC_MEDIA_RECOVERED";
                    break;

                default:
                    pwstrCause = L"cause undefined";
                    break;
                }
            }

            ::MessageBox(NULL, pwstrEvent, pwstrCause, MB_OK);

            break;
        }      

        default:

            break;
    }

    pEvent->Release();
    
    return S_OK;
}


#ifdef ENABLE_DIGIT_DETECTION_STUFF

HRESULT
STDMETHODCALLTYPE
CDigitDetectionNotification::DigitDetected(
                                           unsigned char ucDigit,
                                           TAPI_DIGITMODE DigitMode,
                                           long ulTickCount
                                          )
{
    return S_OK;
}
    
#endif // ENABLE_DIGIT_DETECTION_STUFF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3testph\callnot.h ===
// CallNotification.h : Declaration of the CCallNotification

#ifndef __CALLNOTIFICATION_H_
#define __CALLNOTIFICATION_H_

/////////////////////////////////////////////////////////////////////////////
//
// CTAPIEventNotification
//
/////////////////////////////////////////////////////////////////////////////
class CTAPIEventNotification :
	public ITTAPIEventNotification
{
public:
    DWORD m_dwRefCount;
    CTAPIEventNotification(){ m_dwRefCount = 0;}

	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void **ppvObject)
    {
        if (iid == IID_ITTAPIEventNotification)
        {
            *ppvObject = (void *)this;
            AddRef();
            return S_OK;
        }

        if (iid == IID_IUnknown)
        {
            *ppvObject = (void *)this;
            AddRef();
            return S_OK;
        }

        return E_NOINTERFACE;
    }
	ULONG STDMETHODCALLTYPE AddRef()
    {
        m_dwRefCount++;
        return m_dwRefCount;
    }
    
	ULONG STDMETHODCALLTYPE Release()
    {
        m_dwRefCount--;

        if ( 0 == m_dwRefCount)
        {
            delete this;
        }

        return 1;
    }


// ICallNotification
public:

	    HRESULT STDMETHODCALLTYPE Event(
            TAPI_EVENT TapiEvent,
            IDispatch * pEvent
            );

};


#ifdef ENABLE_DIGIT_DETECTION_STUFF

/////////////////////////////////////////////////////////////////////////////
//
// CDigitDetectionNotification
//
/////////////////////////////////////////////////////////////////////////////
class CDigitDetectionNotification :
	public ITDigitDetectionNotification
{
public:
    DWORD m_dwRefCount;
    CDigitDetectionNotification(){ m_dwRefCount = 0;}

	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void **ppvObject)
    {
        if (iid == IID_ITDigitDetectionNotification)
        {
            *ppvObject = (void *)this;
            AddRef();
            return S_OK;
        }

        if (iid == IID_IUnknown)
        {
            *ppvObject = (void *)this;
            AddRef();
            return S_OK;
        }

        if (iid == IID_IDispatch)
        {
            *ppvObject = (void *)this;
            AddRef();
            return S_OK;
        }
        return E_NOINTERFACE;
    }
	ULONG STDMETHODCALLTYPE AddRef()
    {
        m_dwRefCount++;
        return m_dwRefCount;
    }
    
	ULONG STDMETHODCALLTYPE Release()
    {
        m_dwRefCount--;

        if ( 0 == m_dwRefCount)
        {
            delete this;
        }
        return 1;
    }


// ICallNotification
public:

    HRESULT STDMETHODCALLTYPE DigitDetected(
            unsigned char ucDigit,
            TAPI_DIGITMODE DigitMode,
            long ulTickCount
            );
    
};

#endif // ENABLE_DIGIT_DETECTION_STUFF

#endif //__CALLNOTIFICATION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3testph\ilsdlg.h ===
#if !defined(AFX_ILSDlg_H)
#define AFX_ILSDlg_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "rend.h"

/////////////////////////////////////////////////////////////////////////////
// CILSDlg dialog

class CILSDlg : public CDialog
{
// Construction
public:
	CILSDlg(CWnd* pParent = NULL);
	enum { IDD = IDD_ILSSERVERS };
    
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    BOOL CILSDlg::OnInitDialog();
    virtual void OnOK();
    afx_msg void OnDestroy();
    afx_msg void OnAdd();
    afx_msg void OnRemove();
    void ListServers();
    void SaveServers();
    void CleanUp();
    DECLARE_MESSAGE_MAP()
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3testph\menus.cpp ===
#include "stdafx.h"
#include "t3test.h"
#include "t3testD.h"
#include "calldlg.h"
#include "callnot.h"
#include "externs.h"
#include "control.h"

void
CT3testDlg::CreateSelectedTerminalMenu(
                                       POINT pt,
                                       HWND hWnd
                                      )
{
    ITTerminal *                    pTerminal;

#ifdef ENABLE_DIGIT_DETECTION_STUFF
    ITDigitGenerationTerminal *     pDigitGeneration;
    ITDigitDetectionTerminal *         pDigitDetect;
#endif // ENABLE_DIGIT_DETECTION_STUFF


    HRESULT                         hr;
    ITBasicAudioTerminal *          pBasicAudio;
    long                            lval;
    
    //
    // get the terminal in question
    //
    if (!GetSelectedTerminal( &pTerminal ))
    {
        return;
    }

    hr = pTerminal->QueryInterface(
                                   IID_ITBasicAudioTerminal,
                                   (void **) &pBasicAudio
                                  );

    if ( SUCCEEDED(hr) )
    {
        pBasicAudio->get_Volume( &lval );
        pBasicAudio->put_Volume( lval );
        pBasicAudio->get_Balance( &lval );
        pBasicAudio->put_Balance( lval );
        pBasicAudio->Release();
    }

#ifdef ENABLE_DIGIT_DETECTION_STUFF
    hr = pTerminal->QueryInterface(
                                   IID_ITDigitGenerationTerminal,
                                   (void **) &pDigitGeneration
                                  );

    if (SUCCEEDED(hr))
    {
        DoDigitGenerationTerminalMenu(hWnd, &pt);

        pDigitGeneration->Release();
        
        return;
    }
    
    hr = pTerminal->QueryInterface(
                                   IID_ITDigitDetectionTerminal,
                                   (void **) &pDigitDetect
                                  );

    if (SUCCEEDED(hr))
    {
        DoDigitDetectTerminalMenu(hWnd,&pt);

        pDigitDetect->Release();
        
        return;
    }
#endif // ENABLE_DIGIT_DETECTION_STUFF


}

void CT3testDlg::DoDigitGenerationTerminalMenu(
                                               HWND hWnd,
                                               POINT * pPt
                                              )
{
    //
    // create the menu
    //
    HMENU                   hMenu;

    hMenu = CreatePopupMenu();

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_MODESUPPORTED,
               L"Modes Supported"
              );

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_GENERATE,
               L"Generate"
              );

    // actually show menu
    TrackPopupMenu(
                   hMenu,
                   TPM_LEFTALIGN | TPM_TOPALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                   pPt->x,
                   pPt->y,
                   0,
                   hWnd,
                   NULL
                  );
}
    
void CT3testDlg::DoDigitDetectTerminalMenu(
                                           HWND hWnd,
                                           POINT * pPt
                                          )
{
    //
    // create the menu
    //
    HMENU                   hMenu;

    hMenu = CreatePopupMenu();

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_MODESUPPORTED2,
               L"Modes Supported"
              );

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_STARTDETECT,
               L"Start Detection"
              );

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_STOPDETECT,
               L"Stop Detection"
              );

    // actually show menu
    TrackPopupMenu(
                   hMenu,
                   TPM_LEFTALIGN | TPM_TOPALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                   pPt->x,
                   pPt->y,
                   0,
                   hWnd,
                   NULL
                  );
}

void
CT3testDlg::CreateCallMenu(
                           POINT pt,
                           HWND hWnd
                          )
{
    ITCallInfo              * pCall;
    HMENU                   hMenu;

    //
    // get the call in question
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    //
    // create the menu
    //
    hMenu = CreatePopupMenu();

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_HANDOFF1,
               L"Handoff1"
              );

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_HANDOFF2,
               L"Handoff2"
              );

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_PARK1,
               L"Park1"
              );

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_PARK2,
               L"Park2"
              );

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_UNPARK,
               L"Unpark"
              );

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_PICKUP1,
               L"Pickup1"
              );

    AppendMenu(
               hMenu,
               MF_ENABLED | MF_STRING,
               ID_PICKUP2,
               L"Pickup2"
              );

    

    

    //
    // actually show menu
    //
    TrackPopupMenu(
                   hMenu,
                   TPM_LEFTALIGN | TPM_TOPALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                   pt.x,
                   pt.y,
                   0,
                   hWnd,
                   NULL
                  );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3testph\rate.h ===
#if !defined(AFX_RATEDLG_H__2584F283_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_)
#define AFX_RATEDLG_H__2584F283_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// RateDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CRateDlg dialog

class CRateDlg : public CDialog
{
// Construction
public:
	CRateDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CRateDlg)
	enum { IDD = IDD_RATE };
    DWORD m_dwMinRate;
    DWORD m_dwMaxRate;
    
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRateDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CRateDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_RATEDLG_H__2584F283_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3testph\rate.cpp ===
// RateDlg.cpp : implementation file
//

#include "stdafx.h"
#include "t3test.h"
#include "rate.h"

#ifdef _DEBUG

#ifndef _WIN64 // mfc 4.2's heap debugging features generate warnings on win64
#define new DEBUG_NEW
#endif

#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRateDlg dialog


CRateDlg::CRateDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CRateDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CRateDlg)
	m_dwMinRate = 0;
    m_dwMaxRate = 0;

	//}}AFX_DATA_INIT
}


void CRateDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRateDlg)
	DDX_Text(pDX, IDC_MINRATE, m_dwMinRate);
    DDX_Text(pDX, IDC_MAXRATE, m_dwMaxRate);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRateDlg, CDialog)
	//{{AFX_MSG_MAP(CRateDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRateDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3testph\autoans.cpp ===
// autoans.cpp : implementation file
//

#include "stdafx.h"
#include "t3test.h"
#include "t3testd.h"
#include "autoans.h"

#ifdef _DEBUG

#ifndef _WIN64 // mfc 4.2's heap debugging features generate warnings on win64
#define new DEBUG_NEW
#endif

#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
extern DataPtrList       gDataPtrList;
/////////////////////////////////////////////////////////////////////////////
// autoans dialog


autoans::autoans(CWnd* pParent /*=NULL*/)
	: CDialog(autoans::IDD, pParent)
{
        CT3testDlg::GetAddress( &m_pAddress );

}


void autoans::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(autoans)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BOOL autoans::OnInitDialog()
{
    CDialog::OnInitDialog();
    PopulateListBox();

    return TRUE;
}


BEGIN_MESSAGE_MAP(autoans, CDialog)
	//{{AFX_MSG_MAP(autoans)
	ON_BN_CLICKED(IDC_TERMINALADD, OnTerminalAdd)
	ON_BN_CLICKED(IDC_TERMINALREMOVE, OnTerminalRemove)
    ON_WM_CLOSE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// autoans message handlers

void autoans::OnTerminalAdd() 
{
    LONG            i;
    ITTerminal *    pTerminal;
    
    i = SendDlgItemMessage(
                           IDC_NOTSELECTED,
                           LB_GETCURSEL,
                           0,
                           0
                          );

    if ( i == LB_ERR )
    {
        return;
    }
    
    pTerminal = (ITTerminal *) SendDlgItemMessage(
        IDC_NOTSELECTED,
        LB_GETITEMDATA,
        i,
        0
        );

    if ( NULL != pTerminal )
    {
        SendDlgItemMessage(
                           IDC_NOTSELECTED,
                           LB_DELETESTRING,
                           i,
                           0
                          );

        AddTerminalToListBox( pTerminal, TRUE );
    }
    else
    {
        AddDynamicTerminalToListBox( TRUE );
    }

	
}

void autoans::OnTerminalRemove() 
{
    LONG        i;
    ITTerminal * pTerminal;
    
    i = SendDlgItemMessage(
                           IDC_SELECTED,
                           LB_GETCURSEL,
                           0,
                           0
                          );

    if ( i == LB_ERR )
    {
        return;
    }
    
    pTerminal = (ITTerminal *) SendDlgItemMessage(
        IDC_SELECTED,
        LB_GETITEMDATA,
        i,
        0
        );

    SendDlgItemMessage(
                       IDC_SELECTED,
                       LB_DELETESTRING,
                       i,
                       0
                      );
    
    if ( NULL != pTerminal )
    {
        AddTerminalToListBox( pTerminal, FALSE );
    }
	
}

void autoans::OnOK() 
{
    LONG        i, count;

    
    i = 0;

    count = SendDlgItemMessage(
                               IDC_SELECTED,
                               LB_GETCOUNT,
                               0,
                               0
                              );


    for( i = 0; i < count; i++ )
    {
        ITTerminal * pTerminal;

        
        pTerminal = (ITTerminal *)SendDlgItemMessage(
            IDC_SELECTED,
            LB_GETITEMDATA,
            i,
            0
            );

        AddTerminalToAAList( pTerminal );

        if ( NULL != pTerminal )
        {
            pTerminal->Release();
        }
    }

    count = SendDlgItemMessage(
                               IDC_NOTSELECTED,
                               LB_GETCOUNT,
                               0,
                               0
                              );

    for ( i = 0; i < count; i++ )
    {
        ITTerminal * pTerminal;

        pTerminal = (ITTerminal *)SendDlgItemMessage(
            IDC_NOTSELECTED,
            LB_GETITEMDATA,
            i,
            0
            );

        if ( NULL != pTerminal )
        {
            pTerminal->Release();
        }
    }
    

	CDialog::OnOK();
}
void autoans::OnCancel()
{
    LONG        i, count;

    
    i = 0;

    count = SendDlgItemMessage(
                               IDC_SELECTED,
                               LB_GETCOUNT,
                               0,
                               0
                              );


    for( i = 0; i < count; i++ )
    {
        ITTerminal * pTerminal;

        
        pTerminal = (ITTerminal *)SendDlgItemMessage(
            IDC_SELECTED,
            LB_GETITEMDATA,
            i,
            0
            );

        if ( NULL != pTerminal )
        {
            pTerminal->Release();
        }
    }


    count = SendDlgItemMessage(
                               IDC_NOTSELECTED,
                               LB_GETCOUNT,
                               0,
                               0
                              );

    for ( i = 0; i < count; i++ )
    {
        ITTerminal * pTerminal;

        pTerminal = (ITTerminal *)SendDlgItemMessage(
            IDC_NOTSELECTED,
            LB_GETITEMDATA,
            i,
            0
            );

        if ( NULL != pTerminal )
        {
            pTerminal->Release();
        }
    }
    
    CDialog::OnCancel();
}

void autoans::PopulateListBox()
{
    ITTerminalSupport * pTerminalSupport;
    IEnumTerminal *     pEnumTerminal;
    IEnumTerminalClass * pEnumClasses;
    HRESULT             hr;
    
    if ( NULL == m_pAddress )
    {
        return;
    }

    m_pAddress->QueryInterface(
                               IID_ITTerminalSupport,
                               (void **) &pTerminalSupport
                              );

    pTerminalSupport->EnumerateStaticTerminals( &pEnumTerminal );

    while (TRUE)
    {
        ITTerminal * pTerminal;
        
        hr = pEnumTerminal->Next(
                                 1,
                                 &pTerminal,
                                 NULL
                                );

        if ( S_OK != hr )
        {
            break;
        }

        AddTerminalToListBox( pTerminal, FALSE );

//        pTerminal->Release();
    }

    pEnumTerminal->Release();

    pTerminalSupport->EnumerateDynamicTerminalClasses( &pEnumClasses );

    while (TRUE)
    {
        GUID        guid;
        
        hr = pEnumClasses->Next(
                                1,
                                &guid,
                                NULL
                               );

        if ( S_OK != hr )
        {
            break;
        }

        if ( guid == CLSID_VideoWindowTerm )
        {
            AddDynamicTerminalToListBox( FALSE );
        }

    }

    pEnumClasses->Release();
    
    pTerminalSupport->Release();
}

void
autoans::AddTerminalToListBox( ITTerminal * pTerminal, BOOL bSelected )
{
    HRESULT         hr;
    LONG            i;
    DWORD           dwLB;
    BSTR            bstrName;
    WCHAR		szBuffer[256];
	TERMINAL_DIRECTION td;

    dwLB = (bSelected ? IDC_SELECTED : IDC_NOTSELECTED);

    hr = pTerminal->get_Name( &bstrName );
    pTerminal->get_Direction( &td );

	if ( td == TD_RENDER )
	{
		wsprintfW(szBuffer, L"%s [Playback]", bstrName);
	}
	else
	{
		wsprintfW(szBuffer, L"%s [Record]", bstrName);	
	}

    i = SendDlgItemMessage(
                           dwLB,
                           LB_ADDSTRING,
                           0,
                           (LPARAM)szBuffer
                          );

    SysFreeString( bstrName );

    SendDlgItemMessage(
                       dwLB,
                       LB_SETITEMDATA,
                       (WPARAM) i,
                       (LPARAM) pTerminal
                      );

}

void
autoans::AddDynamicTerminalToListBox( BOOL bSelected )
{
    LONG            i;
    DWORD           dwLB;

    dwLB = (bSelected ? IDC_SELECTED : IDC_NOTSELECTED);


    i = SendDlgItemMessage(
                           dwLB,
                           LB_ADDSTRING,
                           0,
                           (LPARAM)L"Video Window"
                          );

    SendDlgItemMessage(
                       dwLB,
                       LB_SETITEMDATA,
                       (WPARAM) i,
                       (LPARAM) 0
                      );


    return;
}

void autoans::AddTerminalToAAList( ITTerminal * pTerminal )
{
    if ( NULL != pTerminal )
    {
        pTerminal->AddRef();
    }
    
    m_TerminalPtrList.push_back( pTerminal );
}


void autoans::OnClose()
{
    LONG        i, count;

    
    i = 0;

    count = SendDlgItemMessage(
                               IDC_SELECTED,
                               LB_GETCOUNT,
                               0,
                               0
                              );


    for( i = 0; i < count; i++ )
    {
        ITTerminal * pTerminal;

        
        pTerminal = (ITTerminal *)SendDlgItemMessage(
            IDC_SELECTED,
            LB_GETITEMDATA,
            i,
            0
            );

        if ( NULL != pTerminal )
        {
            pTerminal->Release();
        }
    }


    count = SendDlgItemMessage(
                               IDC_NOTSELECTED,
                               LB_GETCOUNT,
                               0,
                               0
                              );

    for ( i = 0; i < count; i++ )
    {
        ITTerminal * pTerminal;

        pTerminal = (ITTerminal *)SendDlgItemMessage(
            IDC_NOTSELECTED,
            LB_GETITEMDATA,
            i,
            0
            );

        if ( NULL != pTerminal )
        {
            pTerminal->Release();
        }
    }
    
	CDialog::OnClose();
    
}

void
CT3testDlg::DoAutoAnswer(
                         ITCallInfo * pCall
                        )
{
    ITAddress * pAddress;
    ITBasicCallControl * pBCC;
    HRESULT     hr;
    DataPtrList::iterator iter,end;
    TerminalPtrList::iterator terminaliter, terminalend;
    DWORD       dwSize;
    ITTerminalSupport * pTerminalSupport;
    BSTR        bstrTerminalClass;
    PWSTR       pwstr;
    

    StringFromIID(CLSID_VideoWindowTerm,&pwstr);
    bstrTerminalClass = SysAllocString( pwstr );
    CoTaskMemFree( pwstr );

    hr = pCall->get_Address( &pAddress );

    if ( !SUCCEEDED(hr) )
    {
        return;
    }

    hr = pAddress->QueryInterface(
                                  IID_ITTerminalSupport,
                                  (void **) &pTerminalSupport
                                 );

    if ( !SUCCEEDED(hr) )
    {
        pAddress->Release();
        return;
    }
    
    hr = pCall->QueryInterface(
                               IID_ITBasicCallControl,
                               (void **)&pBCC
                              );

    if ( !SUCCEEDED(hr) )
    {
        pTerminalSupport->Release();
        pAddress->Release();
        return;
    }

    iter = gDataPtrList.begin();
    end  = gDataPtrList.end();

    for ( ; iter != end ; iter++ )
    {
        if ( (*iter)->pAddress == pAddress )
        {
            break;
        }
    }

    pAddress->Release();

    if ( iter == end )
    {
        pBCC->Release();
        pTerminalSupport->Release();
        return;
    }

    dwSize = (*iter)->pTerminalPtrList->size();
    
    if ( 0 == dwSize )
    {
        pTerminalSupport->Release();
        pBCC->Release();
        return ;
    }

    terminaliter = (*iter)->pTerminalPtrList->begin();
    terminalend  = (*iter)->pTerminalPtrList->end();

    for( ; terminaliter != terminalend ; terminaliter++ )
    {
        ITTerminal * pTerminal;
        
        if ( NULL == (*terminaliter) )
        {
            hr = pTerminalSupport->CreateTerminal(
                bstrTerminalClass,
                (long)LINEMEDIAMODE_VIDEO,
                TD_RENDER,
                &pTerminal
                );
        }
        else
        {
            pTerminal = *terminaliter;
        }

//        hr = pBCC->SelectTerminal( pTerminal );

//        if ( !SUCCEEDED(hr) )
//        {
//        }

    }
    
    hr = pBCC->Answer();

    if ( !SUCCEEDED(hr) )
    {
    }
    
    pBCC->Release();
    pTerminalSupport->Release();
    SysFreeString( bstrTerminalClass );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3testph\servname.cpp ===
// ServNameDlg.cpp : implementation file
//

#include "stdafx.h"
#include "t3test.h"
#include "servname.h"

#ifdef _DEBUG

#ifndef _WIN64 // mfc 4.2's heap debugging features generate warnings on win64
#define new DEBUG_NEW
#endif

#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CServNameDlg dialog


CServNameDlg::CServNameDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CServNameDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CServNameDlg)
	m_pszServerName = _T("");
	//}}AFX_DATA_INIT
}


void CServNameDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CServNameDlg)
	DDX_Text(pDX, IDC_SERVERNAME, m_pszServerName);
	DDV_MaxChars(pDX, m_pszServerName, 256);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CServNameDlg, CDialog)
	//{{AFX_MSG_MAP(CServNameDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CServNameDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3testph\servname.h ===
#if !defined(AFX_ServNameDLG_H__2584F283_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_)
#define AFX_ServNameDLG_H__2584F283_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ServNameDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CServNameDlg dialog

class CServNameDlg : public CDialog
{
// Construction
public:
	CServNameDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CServNameDlg)
	enum { IDD = IDD_ILSSERVERNAME };
	CString	m_pszServerName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CServNameDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CServNameDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ServNameDLG_H__2584F283_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3testph\event.cpp ===
#include "stdafx.h"
#include "t3test.h"
#include "t3testD.h"
#include "externs.h"

void
CT3testDlg::HandleCallHubEvent( IDispatch * pEvent )
{
    HRESULT             hr;
    ITCallHubEvent *    pCallHubEvent;
    CALLHUB_EVENT       che;
    

    hr = pEvent->QueryInterface(
                                IID_ITCallHubEvent,
                                (void **)&pCallHubEvent
                               );

    if (!SUCCEEDED(hr))
    {
        return;
    }

    hr = pCallHubEvent->get_Event( &che );

    if (!SUCCEEDED(hr))
    {
        return;
    }

    switch ( che )
    {
        case CHE_CALLHUBNEW:

            break;
            
        case CHE_CALLHUBIDLE:

            break;
            
        default:
            break;
    }

    pCallHubEvent->Release();

}


void
CT3testDlg::HandleTapiObjectMessage( IDispatch * pEvent )
{
    ITTAPIObjectEvent * pte;
    HRESULT             hr;
    TAPIOBJECT_EVENT    te;

    hr = pEvent->QueryInterface(
                                IID_ITTAPIObjectEvent,
                                (void**)&pte
                               );

    if ( !SUCCEEDED(hr) )
    {
        return;
    }

    pte->get_Event( &te );

    switch (te)
    {
        case TE_ADDRESSCREATE:
        case TE_ADDRESSREMOVE:

            ReleaseMediaTypes();
            ReleaseTerminals();
            ReleaseCalls();
            ReleasePhones();
            ReleaseSelectedTerminals();
            ReleaseCreatedTerminals();
            ReleaseTerminalClasses();
            ReleaseListen();
            ReleaseAddresses();
            InitializeAddressTree();

            break;

        case TE_PHONECREATE:
        case TE_PHONEREMOVE:
            {
                ITAddress           * pSelectedAddress;
                ITTAPIObjectEvent2  * pTAPIObjectEvent2;
                ITPhone             * pPhone;
                BSTR                bstrName = NULL;

                hr = pte->QueryInterface(IID_ITTAPIObjectEvent2, (void **)&pTAPIObjectEvent2);

                if (SUCCEEDED(hr))
                {
                    hr = pTAPIObjectEvent2->get_Phone( &pPhone );

                    if (SUCCEEDED(hr))
                    {
                        hr = pPhone->get_PhoneCapsString( PCS_PHONENAME, &bstrName );

                        if (SUCCEEDED(hr))
                        {     
                            switch(te)
                                    {
                                    case TE_PHONECREATE:
                                        ::MessageBox(NULL, bstrName, L"TE_PHONECREATE", MB_OK);
                                        break;
        
                                    case TE_PHONEREMOVE:
                                        ::MessageBox(NULL, bstrName, L"TE_PHONEREMOVE", MB_OK);
                                        break;
        
                                    }

                            SysFreeString( bstrName );
                        }
                        pPhone->Release();
                    }
                    pTAPIObjectEvent2->Release();
                }

                if ( GetAddress( &pSelectedAddress ) )
                {
                    ReleasePhones();
                
                    UpdatePhones( pSelectedAddress );    
                }
            }

            break;
            
        default:
            break;
    }

    pte->Release();
    
}

void
CT3testDlg::HandleAddressEvent( IDispatch * pEvent )
{
    ITAddressEvent      * pAddressEvent;
    ITTerminal          * pTerminal;
    ITAddress           * pAddress;   
    ITAddress           * pSelectedAddress;
    LONG                lMediaType;
    LONG                lSelectedMediaType;
    BSTR                bstrName = NULL;
    ADDRESS_EVENT       ae;
    HRESULT             hr;

    hr = pEvent->QueryInterface(IID_ITAddressEvent, (void **)&pAddressEvent);

    if (SUCCEEDED(hr))
    {
        hr = pAddressEvent->get_Event( &ae );

        if (SUCCEEDED(hr))
        {
            if ( (ae == AE_NEWTERMINAL) || (ae == AE_REMOVETERMINAL) )
            {
                hr = pAddressEvent->get_Terminal( &pTerminal );

                if (SUCCEEDED(hr))
                {
                    hr = pTerminal->get_Name( &bstrName );

                    if (SUCCEEDED(hr))
                    {                                                               
                        hr = pAddressEvent->get_Address( &pAddress );

                        if (SUCCEEDED(hr))
                        {
                            hr = pTerminal->get_MediaType( &lMediaType );

                            if (SUCCEEDED(hr))
                            {
                                if (CT3testDlg::GetMediaType( &lSelectedMediaType ) && ( lSelectedMediaType == lMediaType) &&
                                    CT3testDlg::GetAddress( &pSelectedAddress ) && ( pSelectedAddress == pAddress) )
                                {
                                    switch(ae)
                                    {
                                    case AE_NEWTERMINAL:
                                        ::MessageBox(NULL, bstrName, L"AE_NEWTERMINAL", MB_OK);
                                        break;
        
                                    case AE_REMOVETERMINAL:
                                        ::MessageBox(NULL, bstrName, L"AE_REMOVETERMINAL", MB_OK);
                                        break;
        
                                    }

                                    CT3testDlg::ReleaseTerminals();
                                    CT3testDlg::UpdateTerminals( pAddress, lMediaType );
                                }
                            }
                            pAddress->Release();
                        }
                        SysFreeString( bstrName );
                    }
                    pTerminal->Release();
                }
            }           
        }
        pAddressEvent->Release();
    }
}

void
CT3testDlg::HandlePhoneEvent( IDispatch * pEvent )
{
    ITPhoneEvent      * pPhoneEvent;
    ITPhone           * pPhone;
    PHONE_EVENT       pe;
    HRESULT           hr;

    hr = pEvent->QueryInterface(IID_ITPhoneEvent, (void **)&pPhoneEvent);

    if (SUCCEEDED(hr))
    {
        hr = pPhoneEvent->get_Event( &pe );

        if (SUCCEEDED(hr))
        {
            hr = pPhoneEvent->get_Phone( &pPhone );

            if ( SUCCEEDED(hr) )
            {
                switch( pe )
                {
                case PE_DISPLAY:
                    ::MessageBox(NULL, L"", L"PE_DISPLAY", MB_OK);
                    break;
                case PE_LAMPMODE:
                    ::MessageBox(NULL, L"", L"PE_LAMPMODE", MB_OK);
                    break;
                case PE_RINGMODE:
                    ::MessageBox(NULL, L"", L"PE_RINGMODE", MB_OK);
                    break;          
                case PE_RINGVOLUME:
                    ::MessageBox(NULL, L"", L"PE_RINGVOLUME", MB_OK);
                    break;            
                case PE_HOOKSWITCH:
                    {
                        PHONE_HOOK_SWITCH_DEVICE HookSwitchDevice;
                        PHONE_HOOK_SWITCH_STATE HookSwitchState;
                        WCHAR szText[256];

                        hr = pPhoneEvent->get_HookSwitchDevice( &HookSwitchDevice );

                        if ( SUCCEEDED(hr) )
                        {
                            hr = pPhoneEvent->get_HookSwitchState( &HookSwitchState );
                            
                            if ( SUCCEEDED(hr) )
                            {
                                switch( HookSwitchDevice )
                                {
                                case PHSD_HANDSET:
                                    lstrcpyW(szText, L"PHSD_HANDSET");
                                    break;
                                case PHSD_SPEAKERPHONE:
                                    lstrcpyW(szText, L"PHSD_SPEAKERPHONE");
                                    break;
                                case PHSD_HEADSET:
                                    lstrcpyW(szText, L"PHSD_HEADSET");
                                    break;
                                }

                                switch( HookSwitchState )
                                {
                                case PHSS_ONHOOK:
                                    lstrcatW(szText, L" PHSS_ONHOOK");
                                    break;
                                case PHSS_OFFHOOK:
                                    lstrcatW(szText, L" PHSS_OFFHOOK");
                                    break;
                                }

                                //::MessageBox(NULL, szText, L"PE_HOOKSWITCH", MB_OK);
                            }
                        }
                    }
                    break;            
                case PE_CAPSCHANGE:
                    ::MessageBox(NULL, L"", L"PE_CAPSCHANGE", MB_OK);
                    break;            
                case PE_BUTTON:
                    {
                        long lButtonId;
                        BSTR pButtonText;
                        WCHAR szText[256];
                        PHONE_BUTTON_STATE ButtonState;

                        hr = pPhoneEvent->get_ButtonLampId( &lButtonId );

                        if ( SUCCEEDED(hr) )
                        {
                            hr = pPhone->get_ButtonText( lButtonId, &pButtonText );
                            
                            if ( SUCCEEDED( hr ) )
                            {
                                lstrcpyW(szText, pButtonText);
                                //wsprintf(szText, L"%d", lButtonId);

                                hr = pPhoneEvent->get_ButtonState( &ButtonState );

                                if ( SUCCEEDED( hr ) )
                                {
                                    switch( ButtonState )
                                    {
                                    case PBS_UP:
                                        lstrcatW(szText, L" PBS_UP");

                                        /*
                                        if ((lButtonId >= PT_KEYPADZERO) && (lButtonId <= PT_KEYPADPOUND))
                                        {
                                            ITAutomatedPhoneControl * pPhoneControl;

                                            //
                                            // get the automated phone control interface
                                            //
                                            hr = pPhone->QueryInterface(IID_ITAutomatedPhoneControl, (void **)&pPhoneControl);

                                            if (S_OK != hr)
                                            {
                                                ::MessageBox(NULL, L"QueryInterface failed", NULL, MB_OK);
                                                return;
                                            }
                                            
                                            PHONE_TONE Tone;
                                            pPhoneControl->get_Tone(&Tone);

                                            if ((long)Tone == lButtonId)
                                            {
                                                hr = pPhoneControl->StopTone();
                                            }
                                            
                                            pPhoneControl->Release();
                                        }
                                        */
                                        break;
                                    case PBS_DOWN:
                                        lstrcatW(szText, L" PBS_DOWN");

                                        /*
                                        if ((lButtonId >= PT_KEYPADZERO) && (lButtonId <= PT_KEYPADPOUND))
                                        {
                                            ITAutomatedPhoneControl * pPhoneControl;

                                            //
                                            // get the automated phone control interface
                                            //
                                            hr = pPhone->QueryInterface(IID_ITAutomatedPhoneControl, (void **)&pPhoneControl);

                                            if (S_OK != hr)
                                            {
                                                ::MessageBox(NULL, L"QueryInterface failed", NULL, MB_OK);
                                                return;
                                            }

                                            hr = pPhoneControl->StartTone((PHONE_TONE)lButtonId, 0);

                                            pPhoneControl->Release();
                                        }
                                        */
                                        break;
                                    case PBS_UNKNOWN:
                                        lstrcatW(szText, L" PBS_UNKNOWN");
                                        break;
                                    case PBS_UNAVAIL:
                                        lstrcatW(szText, L" PBS_UNAVAIL");
                                        break;
                                    }

                                    //::MessageBox(NULL, szText, L"PE_BUTTON", MB_OK);
                                }

                                //SysFreeString( pButtonText );
                            }
                        }
                    }
                    break;            
                case PE_CLOSE:
                    ::MessageBox(NULL, L"", L"PE_CLOSE", MB_OK);
                    break;           
                case PE_NUMBERGATHERED:
                    {
                        BSTR pNumberGathered;

                        hr = pPhoneEvent->get_NumberGathered( &pNumberGathered );

                        if ( SUCCEEDED(hr) && (pNumberGathered != NULL) )
                        {
                            ::MessageBox(NULL, pNumberGathered, L"PE_NUMBERGATHERED", MB_OK);
                        }
                    }
                    break; 
                }

                pPhone->Release();
            }
        }

        pPhoneEvent->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3testph\externs.h ===
#include "stdafx.h"
#include "t3test.h"

extern ITTAPI * gpTapi;
extern HWND ghAddressesWnd;
extern HWND ghTerminalsWnd;
extern HWND ghMediaTypesWnd;
extern HWND ghCallsWnd;
extern HWND ghSelectedCallsWnd;
extern HWND ghPhonesWnd;
extern HWND ghSelectedWnd;
extern HWND ghCreatedWnd;
extern HWND ghClassesWnd;
extern HWND ghListenWnd;
extern HTREEITEM ghAddressesRoot;
extern HTREEITEM ghTerminalsRoot;
extern HTREEITEM ghMediaTypesRoot;
extern HTREEITEM ghCallsRoot;
extern HTREEITEM ghSelectedCallsRoot;
extern HTREEITEM ghPhonesRoot;
extern HTREEITEM ghSelectedRoot;
extern HTREEITEM ghCreatedRoot;
extern HTREEITEM ghClassesRoot;
extern HTREEITEM ghListenRoot;

extern long       gulAdvise;
extern BOOL gbUpdatingStuff;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3testph\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	t3test.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3testph\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#ifndef UNICODE
#define UNICODE
#endif

#if !defined(AFX_STDAFX_H__47F9FE88_D2F9_11D0_8ECA_00C04FB6809F__INCLUDED_)
#define AFX_STDAFX_H__47F9FE88_D2F9_11D0_8ECA_00C04FB6809F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#include "tapi3.h"
//#include "tapi.h"

#include <list>
using namespace std;

typedef list<ITTerminal *>      TerminalPtrList;
typedef struct
{
    ITAddress * pAddress;
    TerminalPtrList * pTerminalPtrList;
    
} AADATA;

typedef list<AADATA *> DataPtrList;
   


#endif // !defined(AFX_STDAFX_H__47F9FE88_D2F9_11D0_8ECA_00C04FB6809F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3testph\strings.h ===
#define PARENTKEY L"Software\\Microsoft"
#define APPKEY L"t3test"
#define SERVERKEY L"Servers"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3testph\t3test.cpp ===
// t3test.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "t3test.h"
#include "t3testD.h"

#ifdef _DEBUG

#ifndef _WIN64 // mfc 4.2's heap debugging features generate warnings on win64
#define new DEBUG_NEW
#endif

#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CWnd * gpmainwnd;

/////////////////////////////////////////////////////////////////////////////
// CT3testApp

BEGIN_MESSAGE_MAP(CT3testApp, CWinApp)
	//{{AFX_MSG_MAP(CT3testApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CT3testApp construction

CT3testApp::CT3testApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CT3testApp object

CT3testApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CT3testApp initialization

BOOL CT3testApp::InitInstance()
{
	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CT3testDlg dlg;
	m_pMainWnd = &dlg;
    gpmainwnd = &dlg;
    
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3testph\gets.cpp ===
#include "stdafx.h"
#include "t3test.h"
#include "t3testD.h"
#include "calldlg.h"
#include "callnot.h"
#include "externs.h"


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetMediaTypeName
//
// Convert the mediatype bstr to a string, like
// "audio in"
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::GetMediaTypeName(
                                  long lMediaType,
                                  LPWSTR szString
                                 )
{
    if (lMediaType == (long)LINEMEDIAMODE_AUTOMATEDVOICE)
    {
        lstrcpyW(
                 szString,
                 L"Audio"
                );

    }
    else if (lMediaType == (long)LINEMEDIAMODE_VIDEO)
    {
        lstrcpyW(
                 szString,
                 L"Video"
                );

    }
    else if (lMediaType == (long)LINEMEDIAMODE_DATAMODEM)
    {
        lstrcpyW(
                 szString,
                 L"DataModem"
                );

    }
    else if (lMediaType == (long)LINEMEDIAMODE_G3FAX)
    {
        lstrcpyW(
                 szString,
                 L"G3Fax"
                );

    }
    else
    {
        lstrcpyW(
                 szString,
                 L"Unknown MediaType - "
                );
    }

    
}

LPWSTR CT3testDlg::GetCallPrivilegeName(
                                        ITCallInfo * pCall
                                       )
{
    CALL_PRIVILEGE      cp;
    HRESULT             hr;
   
    hr = pCall->get_Privilege( &cp );

    if ( SUCCEEDED(hr) )
    {
        if (CP_OWNER == cp)
        {
            return SysAllocString(L"OWNER");
        
        }
        else
        {
            return SysAllocString(L"MONITOR");
        }
    }

    return NULL;
}

LPWSTR CT3testDlg::GetPhonePrivilegeName(
                                        ITPhone * pPhone
                                       )
{
    PHONE_PRIVILEGE      pp;
    HRESULT              hr;
    
    hr = pPhone->get_Privilege( &pp );

    if ( SUCCEEDED(hr) )
    {
        if (PP_OWNER == pp)
        {
            return SysAllocString(L"OWNER");
        
        }
        else
        {
            return SysAllocString(L"MONITOR");
        }
    }

    return NULL;
}


LPWSTR CT3testDlg::GetCallStateName(
                                    ITCallInfo * pCall
                                   )
{
    CALL_STATE          cs;
    
    //
    // get the current call state
    //
    pCall->get_CallState( &cs );

    //
    // make the name
    //
    switch( cs )
    {
        case CS_INPROGRESS:

            return SysAllocString( L"INPROGRESS" );
            break;

        case CS_CONNECTED:

            return SysAllocString ( L"CONNECTED" );
            break;

        case CS_DISCONNECTED:

            return SysAllocString ( L"DISCONNECTED" );
            break;

        case CS_OFFERING:

            return SysAllocString ( L"OFFERING" );
            break;

        case CS_IDLE:

            return SysAllocString( L"IDLE" );
            break;

        default:

            return SysAllocString( L"<Unknown Call State>" );
            break;
    }


    return NULL;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetAddress
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL CT3testDlg::GetAddress( ITAddress ** ppAddress )
{
    HTREEITEM           hItem;
    TV_ITEM             item;

    hItem = TreeView_GetSelection(
                                  ghAddressesWnd
                                 );

    if (NULL == hItem)
    {
        return FALSE;
    }

    item.mask = TVIF_HANDLE | TVIF_PARAM;
    item.hItem = hItem;

    TreeView_GetItem(
                     ghAddressesWnd,
                     &item
                    );

    *ppAddress = (ITAddress *)item.lParam;

    if (NULL == *ppAddress)
    {
//        ::MessageBox(NULL, L"Select an Address", NULL, MB_OK);
        return FALSE;
    }

    return TRUE;
    
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL CT3testDlg::GetTerminal( ITTerminal ** ppTerminal )
{
    HTREEITEM           hItem;
    TV_ITEM             item;

    hItem = TreeView_GetSelection(
                                  ghTerminalsWnd
                                 );

    if (NULL == hItem)
    {
        return FALSE;
    }

    item.mask = TVIF_HANDLE | TVIF_PARAM;
    item.hItem = hItem;

    TreeView_GetItem(
                     ghTerminalsWnd,
                     &item
                    );

    *ppTerminal = (ITTerminal *)item.lParam;

    if (NULL == *ppTerminal)
    {
        ::MessageBox(NULL, L"Select a Terminal", NULL, MB_OK);
        return FALSE;
    }

    return TRUE;
    
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetPhone
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL CT3testDlg::GetPhone( ITPhone ** ppPhone )
{
    HTREEITEM           hItem;
    TV_ITEM             item;

    hItem = TreeView_GetSelection(
                                  ghPhonesWnd
                                 );

    if (NULL == hItem)
    {
        return FALSE;
    }

    item.mask = TVIF_HANDLE | TVIF_PARAM;
    item.hItem = hItem;

    TreeView_GetItem(
                     ghPhonesWnd,
                     &item
                    );

    *ppPhone = (ITPhone *)item.lParam;

    if (NULL == *ppPhone)
    {
        //::MessageBox(NULL, L"Select a Phone", NULL, MB_OK);
        return FALSE;
    }

    return TRUE;
    
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetCall
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL CT3testDlg::GetCall( ITCallInfo ** ppCallInfo )
{
    HTREEITEM           hItem;
    TV_ITEM             item;

    hItem = TreeView_GetSelection(
                                  ghCallsWnd
                                 );

    if (NULL == hItem)
    {
        return FALSE;
    }

    item.mask = TVIF_HANDLE | TVIF_PARAM;
    item.hItem = hItem;

    TreeView_GetItem(
                     ghCallsWnd,
                     &item
                    );

    *ppCallInfo = (ITCallInfo *)item.lParam;

    if (NULL == *ppCallInfo)
    {
        //::MessageBox(NULL, L"Select a Call", NULL, MB_OK);
        return FALSE;
    }

    return TRUE;
    
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetMediaType
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL CT3testDlg::GetMediaType( long * plMediaType )
{
    HTREEITEM           hItem;
    TV_ITEM             item;

    hItem = TreeView_GetSelection(
                                  ghMediaTypesWnd
                                 );

    if (NULL == hItem)
    {
        return FALSE;
    }

    item.mask = TVIF_HANDLE | TVIF_PARAM;
    item.hItem = hItem;

    TreeView_GetItem(
                     ghMediaTypesWnd,
                     &item
                    );

    *plMediaType = (long)(item.lParam);

    if (0 == *plMediaType)
    {
        return FALSE;
    }

    return TRUE;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetTerminalClass
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL CT3testDlg::GetTerminalClass( BSTR * pbstrClass )
{
    HTREEITEM       hItem;
    TV_ITEM         item;
    GUID *          pguid;

    hItem = TreeView_GetSelection(
                                  ghClassesWnd
                                 );

    if (NULL == hItem)
    {
        return FALSE;
    }

    item.mask = TVIF_HANDLE | TVIF_PARAM;
    item.hItem = hItem;

    TreeView_GetItem(
                     ghClassesWnd,
                     &item
                    );

    pguid = (GUID *)item.lParam;

    if (NULL == pguid)
    {
        return FALSE;
    }

    LPWSTR      lphold;

    
    StringFromIID(
                  *pguid,
                  &lphold
                 );

    *pbstrClass = SysAllocString(lphold);

    CoTaskMemFree(lphold);
    
    return TRUE;
}




//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetCreatedTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL CT3testDlg::GetCreatedTerminal( ITTerminal ** ppTerminal )
{
    HTREEITEM       hItem;
    TV_ITEM         item;

    hItem = TreeView_GetSelection(
                                  ghCreatedWnd
                                 );

    if (NULL == hItem)
    {
        return FALSE;
    }

    item.mask = TVIF_HANDLE | TVIF_PARAM;
    item.hItem = hItem;

    TreeView_GetItem(
                     ghCreatedWnd,
                     &item
                    );

    *ppTerminal = (ITTerminal *)item.lParam;

    if (NULL == *ppTerminal)
    {
        return FALSE;
    }

    return TRUE;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetSelectedTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL CT3testDlg::GetSelectedTerminal( ITTerminal ** ppTerminal )
{
    HTREEITEM       hItem;
    TV_ITEM         item;

    hItem = TreeView_GetSelection(
                                  ghSelectedWnd
                                 );

    if (NULL == hItem)
    {
        return FALSE;
    }

    item.mask = TVIF_HANDLE | TVIF_PARAM;
    item.hItem = hItem;

    TreeView_GetItem(
                     ghSelectedWnd,
                     &item
                    );

    *ppTerminal = (ITTerminal *)item.lParam;

    if (NULL == *ppTerminal)
    {
        return FALSE;
    }

    return TRUE;
}


BSTR CT3testDlg::GetTerminalClassName( GUID * pguid )
{
    if (IsEqualIID( *pguid, CLSID_VideoWindowTerm ))
    {
        return SysAllocString( L"Video" );
    }

#ifdef ENABLE_DIGIT_DETECTION_STUFF
    else if (IsEqualIID( *pguid, CLSID_DigitTerminal ))
    {
        return SysAllocString( L"Digit Terminal" );
    }
    else if (IsEqualIID( *pguid, CLSID_DataTerminal ))
    {
        return SysAllocString( L"Data Terminal" );
    }
#endif // ENABLE_DIGIT_DETECTION_STUFF

    else
    {
        return SysAllocString( L"Unknown Dynamic Type" );
    }

    return NULL;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetSelectedCall
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
BOOL CT3testDlg::GetSelectedCall( ITCallInfo ** ppCall )
{
    HTREEITEM           hItem;
    TV_ITEM             item;

    hItem = TreeView_GetSelection(
                                  ghSelectedCallsWnd
                                 );

    if (NULL == hItem)
    {
        return FALSE;
    }

    item.mask = TVIF_HANDLE | TVIF_PARAM;
    item.hItem = hItem;

    TreeView_GetItem(
                     ghSelectedCallsWnd,
                     &item
                    );

    *ppCall = (ITCallInfo *)item.lParam;

    if (NULL == *ppCall)
    {
        //::MessageBox(NULL, L"Select a Call", NULL, MB_OK);
        return FALSE;
    }

    return TRUE;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3testph\t3test.h ===
// t3test.h : main header file for the T3TEST application
//

#if !defined(AFX_T3TEST_H__47F9FE84_D2F9_11D0_8ECA_00C04FB6809F__INCLUDED_)
#define AFX_T3TEST_H__47F9FE84_D2F9_11D0_8ECA_00C04FB6809F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CT3testApp:
// See t3test.cpp for the implementation of this class
//

class CT3testApp : public CWinApp
{
public:
	CT3testApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CT3testApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CT3testApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_T3TEST_H__47F9FE84_D2F9_11D0_8ECA_00C04FB6809F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3testph\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by t3test.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_T3TEST_DIALOG               102
#define IDR_MAINFRAME                   128
#define IDD_CREATECALL                  129
#define IDR_DIGITPOPUP                  130
#define IDD_AUTOANSWER                  131
#define IDD_CONFDLG                     132
#define IDD_ILSSERVERS                  133
#define IDD_ILSSERVERNAME               134
#define IDD_RATE                        135
#define IDC_ADDRESSES                   1000
#define IDC_MEDIATYPES                  1001
#define IDC_TERMINALS                   1002
#define IDC_CALLS                       1003
#define IDC_CREATECALL                  1004
#define IDC_CONNECT                     1005
#define IDC_ANSWER                      1006
#define IDC_DROP                        1007
#define IDC_ADDTERMINAL                 1008
#define IDC_REMOVETERMINAL              1009
#define IDC_DESTADDRESS                 1010
#define IDC_PHONES                      1010
#define IDC_SELECTEDTERMINALS           1011
#define IDC_LISTEN                      1012
#define IDC_RELEASE                     1013
#define IDC_CREATE                      1014
#define IDC_RELEASETERMINAL             1015
#define IDC_SELECTEDCALLS               1016
#define IDC_CREATEDTERMINALS            1017
#define IDC_DYNAMICCLASSES              1018
#define IDC_ADDCREATED                  1019
#define IDC_ADDNULL                     1020
#define IDC_LISTENMEDIAMODES            1021
#define IDC_ADDTOLISTEN                 1022
#define IDC_LISTENALL                   1023
#define IDC_CONFIGAUTOANSWER            1024
#define IDC_SELECTED                    1025
#define IDC_NOTSELECTED                 1026
#define IDC_TERMINALADD                 1027
#define IDC_TERMINALREMOVE              1028
#define IDC_CONFLIST                    1029
#define IDC_ILS                         1029
#define IDC_ILSLIST                     1030
#define IDC_ADD                         1031
#define IDC_REMOVE                      1032
#define IDC_SERVERNAME                  1033
#define IDC_RATE                        1034
#define IDC_MINRATE                     1035
#define IDC_MAXRATE                     1036
#define IDC_OPENPHONE                   1037
#define IDC_CLOSEPHONE                  1038
#define IDC_STARTTONE                   1039
#define IDC_STOPTONE                    1040
#define IDC_STARTRING                   1041
#define IDC_STOPRING                    1042
#define IDC_BUSYTONE                    1043
#define IDC_RINGBACKTONE                1044
#define IDC_ERRORTONE                   1045
#define IDC_PHONEAUTOON                 1046
#define IDC_PHONEAUTOOFF                1047
#define IDC_SELECTCALL                  1048
#define IDC_UNSELECTCALL                1049
#define IDC_PHONESPEAKERONHOOK          1050
#define IDC_PHONESPEAKEROFFHOOK         1051
#define ID_MODESUPPORTED                32771
#define ID_GENERATE                     32772
#define ID_MODESUPPORTED2               32773
#define ID_STARTDETECT                  32774
#define ID_STOPDETECT                   32775
#define ID_NOTHING                      32776
#define ID_PARK1                        32778
#define ID_PARK2                        32779
#define ID_HANDOFF1                     32780
#define ID_HANDOFF2                     32781
#define ID_UNPARK                       32782
#define ID_PICKUP1                      32783
#define ID_PICKUP2                      32784

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        136
#define _APS_NEXT_COMMAND_VALUE         32773
#define _APS_NEXT_CONTROL_VALUE         1051
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3testph\release.cpp ===
#include "stdafx.h"
#include "t3test.h"
#include "t3testD.h"
#include "calldlg.h"
#include "callnot.h"
#include "externs.h"


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleaseAddresses
//
// Release all the address objects in the address tree
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::ReleaseAddresses()
{
    HTREEITEM           hItem;
    TV_ITEM             item;

    item.mask = TVIF_HANDLE | TVIF_PARAM;

    //
    // get the first address
    //
    hItem = TreeView_GetChild(
                              ghAddressesWnd,
                              ghAddressesRoot
                             );

    //
    // go through all the addresses
    // and release
    while (NULL != hItem)
    {
        HTREEITEM   hNewItem;
        ITAddress * pAddress;
        
        item.hItem = hItem;
        
        TreeView_GetItem(
                         ghAddressesWnd,
                         &item
                        );

        pAddress = (ITAddress *)item.lParam;

        if (NULL != pAddress)
        {
            pAddress->Release();
        }
        

        hNewItem = TreeView_GetNextSibling(
                                        ghAddressesWnd,
                                        hItem
                                       );
        //
        // delete the item
        //
        TreeView_DeleteItem(
                            ghAddressesWnd,
                            hItem
                           );

        hItem = hNewItem;
    }

    //TreeView_DeleteAllItems(ghAddressesWnd);
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleaseMediaTypes
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::ReleaseMediaTypes()
{
    HTREEITEM           hItem;
    TV_ITEM             item;
    BSTR                pMediaType;

    gbUpdatingStuff = TRUE;
    
    item.mask = TVIF_HANDLE | TVIF_PARAM;


    //
    // go through all the mediatypes
    // and free the associated strings
    // and delete the item from the
    // tree
    //
    hItem = TreeView_GetChild(
                              ghMediaTypesWnd,
                              ghMediaTypesRoot
                             );

    while (NULL != hItem)
    {
        HTREEITEM   hNewItem;
        
        hNewItem = TreeView_GetNextSibling(
                                           ghMediaTypesWnd,
                                           hItem
                                          );


        //
        // delete the item
        //
        TreeView_DeleteItem(
                            ghMediaTypesWnd,
                            hItem
                           );

        hItem = hNewItem;
    }

    gbUpdatingStuff = FALSE;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleaseListen
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::ReleaseListen()
{
    HTREEITEM       hItem;
    TV_ITEM         item;

    item.mask = TVIF_HANDLE | TVIF_PARAM;


    //
    // delete all the leave on the listen
    // tree
    // there are no resources associated with
    // this, so nothing to free
    //
    hItem = TreeView_GetChild(
                              ghListenWnd,
                              ghListenRoot
                             );

    while (NULL != hItem)
    {
        HTREEITEM   hNewItem;
        
        hNewItem = TreeView_GetNextSibling(
                                        ghListenWnd,
                                        hItem
                                       );

        TreeView_DeleteItem(
                            ghListenWnd,
                            hItem
                           );

        hItem = hNewItem;
    }

}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleaseTerminalClasses
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::ReleaseTerminalClasses()
{
    HTREEITEM       hItem;
    TV_ITEM         item;

    item.mask = TVIF_HANDLE | TVIF_PARAM;


    //
    // go through all the terminal classes
    // free the memory allocated for the
    // guid, and delete the item
    //
    hItem = TreeView_GetChild(
                              ghClassesWnd,
                              ghClassesRoot
                             );

    while (NULL != hItem)
    {
        HTREEITEM   hNewItem;
        GUID *      pGuid;
        
        item.hItem = hItem;
        
        TreeView_GetItem(
                         ghClassesWnd,
                         &item
                        );

        pGuid = (GUID *)item.lParam;
        delete pGuid;

        hNewItem = TreeView_GetNextSibling(
                                           ghClassesWnd,
                                           hItem
                                          );

        TreeView_DeleteItem(
                            ghClassesWnd,
                            hItem
                           );

        hItem = hNewItem;
    }

}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleaseTerminalClasses
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::ReleaseTerminals()
{
    HTREEITEM           hItem;
    TV_ITEM             item;

    item.mask = TVIF_HANDLE | TVIF_PARAM;


    //
    // go though all the terminals, and
    // free the terminals, and delete the
    // item
    //
    hItem = TreeView_GetChild(
                              ghTerminalsWnd,
                              ghTerminalsRoot
                             );

    while (NULL != hItem)
    {
        HTREEITEM           hNewItem;
        ITTerminal *        pTerminal;
        
        item.hItem = hItem;
        
        TreeView_GetItem(
                         ghTerminalsWnd,
                         &item
                        );

        pTerminal = (ITTerminal *)item.lParam;

        pTerminal->Release();

        hNewItem = TreeView_GetNextSibling(
                                        ghTerminalsWnd,
                                        hItem
                                       );
    

        TreeView_DeleteItem(
                            ghTerminalsWnd,
                            hItem
                           );

        hItem = hNewItem;
    }
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleasePhones
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::ReleasePhones()
{
    HTREEITEM           hItem;
    TV_ITEM             item;

    item.mask = TVIF_HANDLE | TVIF_PARAM;


    //
    // go though all the phones, and
    // free the phones, and delete the
    // item
    //
    hItem = TreeView_GetChild(
                              ghPhonesWnd,
                              ghPhonesRoot
                             );

    while (NULL != hItem)
    {
        HTREEITEM           hNewItem;
        ITPhone *           pPhone;
        
        item.hItem = hItem;
        
        TreeView_GetItem(
                         ghPhonesWnd,
                         &item
                        );

        pPhone = (ITPhone *)item.lParam;

        pPhone->Release();

        hNewItem = TreeView_GetNextSibling(
                                        ghPhonesWnd,
                                        hItem
                                       );
    

        TreeView_DeleteItem(
                            ghPhonesWnd,
                            hItem
                           );

        hItem = hNewItem;
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleaseSelectedTerminals
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::ReleaseSelectedTerminals()
{
    HTREEITEM               hItem;
    TV_ITEM                 item;

    
    item.mask = TVIF_HANDLE | TVIF_PARAM;


    //
    // go through all the selected terminals
    // and free and delete
    //
    hItem = TreeView_GetChild(
                              ghSelectedWnd,
                              ghSelectedRoot
                             );

    while (NULL != hItem)
    {
        HTREEITEM           hNewItem;
        ITTerminal *        pTerminal;
        
        item.hItem = hItem;
        
        TreeView_GetItem(
                         ghSelectedWnd,
                         &item
                        );

        pTerminal = (ITTerminal *)item.lParam;

        pTerminal->Release();

        hNewItem = TreeView_GetNextSibling(
                                           ghSelectedWnd,
                                           hItem
                                          );


        TreeView_DeleteItem(
                            ghSelectedWnd,
                            hItem
                           );

        hItem = hNewItem;
    }
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleaseCalls
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::ReleaseCalls()
{
    HTREEITEM           hItem;
    TV_ITEM             item;

    item.mask = TVIF_HANDLE | TVIF_PARAM;


    //
    // go through all the calls, and
    // release and delete
    //
    hItem = TreeView_GetChild(
                              ghCallsWnd,
                              ghCallsRoot
                             );

    while (NULL != hItem)
    {
        HTREEITEM           hNewItem;
        ITCallInfo *        pCallInfo;

        
        item.hItem = hItem;
        
        TreeView_GetItem(
                         ghCallsWnd,
                         &item
                        );

        pCallInfo = (ITCallInfo *)item.lParam;

        pCallInfo->Release();

        hNewItem = TreeView_GetNextSibling(
                                           ghCallsWnd,
                                           hItem
                                          );
    

        TreeView_DeleteItem(
                            ghCallsWnd,
                            hItem
                           );

        hItem = hNewItem;
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleaseSelectedCalls
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::ReleaseSelectedCalls()
{
    HTREEITEM           hItem;
    TV_ITEM             item;

    item.mask = TVIF_HANDLE | TVIF_PARAM;


    //
    // go through all the calls, and
    // release and delete
    //
    hItem = TreeView_GetChild(
                              ghSelectedCallsWnd,
                              ghSelectedCallsRoot
                             );

    while (NULL != hItem)
    {
        HTREEITEM           hNewItem;
        ITCallInfo *        pCallInfo;

        
        item.hItem = hItem;
        
        TreeView_GetItem(
                         ghSelectedCallsWnd,
                         &item
                        );

        pCallInfo = (ITCallInfo *)item.lParam;

        pCallInfo->Release();

        hNewItem = TreeView_GetNextSibling(
                                           ghSelectedCallsWnd,
                                           hItem
                                          );
    

        TreeView_DeleteItem(
                            ghSelectedCallsWnd,
                            hItem
                           );

        hItem = hNewItem;
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleaseCreatedTerminals
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::ReleaseCreatedTerminals()
{
    HTREEITEM hItem;
    TV_ITEM item;

    item.mask = TVIF_HANDLE | TVIF_PARAM;
    

    //
    // go through all the created terminals
    // and release and delete
    //
    hItem = TreeView_GetChild(
                              ghCreatedWnd,
                              ghCreatedRoot
                             );

    while (NULL != hItem)
    {
        HTREEITEM hNewItem;
        ITTerminal * pTerminal;

        
        item.hItem = hItem;
        
        TreeView_GetItem(
                         ghCreatedWnd,
                         &item
                        );

        pTerminal = (ITTerminal *)item.lParam;

        pTerminal->Release();

        hNewItem = TreeView_GetNextSibling(
                                           ghCreatedWnd,
                                           hItem
                                          );
    

        TreeView_DeleteItem(
                            ghCreatedWnd,
                            hItem
                           );

        hItem = hNewItem;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3testph\updates.cpp ===
#include "stdafx.h"
#include "t3test.h"
#include "t3testD.h"
#include "calldlg.h"
#include "callnot.h"
#include "externs.h"


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// UpdateMediaTypes
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::UpdateMediaTypes(
                                  ITAddress * pAddress
                                 )
{
    long                    lMediaType;
    ITMediaSupport *        pMediaSupport;
    HRESULT                 hr;
    

    //
    // get the media support interface
    //
    pAddress->QueryInterface(
                             IID_ITMediaSupport,
                             (void **)&pMediaSupport
                            );

    //
    // get the mediatype enumerator
    //
    pMediaSupport->get_MediaTypes(&lMediaType);


    //
    // release the interface
    //
    pMediaSupport->Release();


    gbUpdatingStuff = TRUE;

    
    //
    // go through the supported mediatypes
    //
    DWORD       dwMediaType = 1;
    DWORD       dwHold = (DWORD)lMediaType;

    while (dwMediaType)
    {
        if ( dwMediaType & dwHold )
        {
            AddMediaType( (long) dwMediaType );
        }

        dwMediaType <<=1;
    }


    gbUpdatingStuff = FALSE;

    //
    // select the first
    // media type
    //
    SelectFirstItem(
                    ghMediaTypesWnd,
                    ghMediaTypesRoot
                   );


    //
    // release and redo terminals
    //
    ReleaseTerminals();
    ReleaseTerminalClasses();

    if ( GetMediaType( &lMediaType ) )
    {
        UpdateTerminals( pAddress, lMediaType );
        UpdateTerminalClasses( pAddress, lMediaType );
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// UpdateCalls
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::UpdateCalls(
                             ITAddress * pAddress
                            )
{
    IEnumCall *             pEnumCall;
    HRESULT                 hr;
    ITCallInfo *            pCallInfo;

    //
    // enumerate the current calls
    //
    pAddress->EnumerateCalls( &pEnumCall );


    //
    // go through the list
    // and add the calls to the tree
    //
    while (TRUE)
    {
        hr = pEnumCall->Next( 1, &pCallInfo, NULL);

        if (S_OK != hr)
        {
            break;
        }

        AddCall(pCallInfo);

        UpdateCall( pCallInfo );

        //
        // release this reference
        //
        pCallInfo->Release();
    }

    pEnumCall->Release();
    
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// UpdateSelectedCalls
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::UpdateSelectedCalls(
                             ITPhone * pPhone
                            )
{
    IEnumCall *             pEnumCall;
    HRESULT                 hr;
    ITCallInfo *            pCallInfo;
    ITAutomatedPhoneControl * pPhoneControl;

    //
    // get the automated phone control interface
    //
    hr = pPhone->QueryInterface(IID_ITAutomatedPhoneControl, (void **)&pPhoneControl);

    if (S_OK != hr)
    {
        return;
    }
    //
    // enumerate the current calls
    //
    pPhoneControl->EnumerateSelectedCalls( &pEnumCall );

    pPhoneControl->Release();

    //
    // go through the list
    // and add the calls to the tree
    //
    while (TRUE)
    {
        hr = pEnumCall->Next( 1, &pCallInfo, NULL);

        if (S_OK != hr)
        {
            break;
        }

        AddSelectedCall(pCallInfo);

        //
        // release this reference
        //
        pCallInfo->Release();
    }

    pEnumCall->Release();
    
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// UpdateCall
//
// check the call's state and privelege, and update the call
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::UpdateCall( ITCallInfo * pCall )
{
    HTREEITEM               hItem, hParent;
    TV_ITEM                 item;
    CALL_PRIVILEGE          cp;
    CALL_STATE              cs;
    TV_INSERTSTRUCT         tvi;
    

    //
    // get the first call
    //
    item.mask = TVIF_HANDLE | TVIF_PARAM;
    
    
    hItem = TreeView_GetChild(
                              ghCallsWnd,
                              ghCallsRoot
                             );

    //
    // go through all the calls
    // and look for the one that matches
    // the one passed in
    //
    while (NULL != hItem)
    {
        item.hItem = hItem;
        
        TreeView_GetItem(
                         ghCallsWnd,
                         &item
                        );

        if ( item.lParam == (LPARAM)pCall )
        {
            break;
        }

        hItem = TreeView_GetNextSibling(
                                        ghCallsWnd,
                                        hItem
                                       );
    }

    //
    // did we find it?
    //
    if (NULL == hItem)
    {
        return;
    }

    
    hParent = hItem;

    //
    // delete the current children of the call
    // node (these are the old privelege and state
    //
    hItem = TreeView_GetChild(
                              ghCallsWnd,
                              hItem
                             );

    
    while (NULL != hItem)
    {
        HTREEITEM   hNewItem;
        
        hNewItem = TreeView_GetNextSibling(
                                           ghCallsWnd,
                                           hItem
                                          );

        TreeView_DeleteItem(
                            ghCallsWnd,
                            hItem
                           );

        hItem = hNewItem;
    }

    tvi.hInsertAfter = TVI_LAST;

    //
    // get the current privilege
    //
    tvi.item.pszText = GetCallPrivilegeName( pCall );

    //
    // add it as a child of the
    // call node
    //
    tvi.hParent = hParent;
    tvi.item.mask = TVIF_TEXT;

    TreeView_InsertItem(
                        ghCallsWnd,
                        &tvi
                       );

    SysFreeString( tvi.item.pszText );
    
    //
    // get the current callstate
    //
    tvi.item.pszText = GetCallStateName( pCall );
    
    //
    // add it as a child of the call
    // node
    //
    tvi.hParent = hParent;
    tvi.item.mask = TVIF_TEXT;

    TreeView_InsertItem(
                        ghCallsWnd,
                        &tvi
                       );

    SysFreeString( tvi.item.pszText );

    
}

void CT3testDlg::UpdatePhones(
                                 ITAddress * pAddress
                                )
{
    ITAddress2 *            pAddress2;
    IEnumPhone *            pEnumPhones;
    HRESULT                 hr;
    ITPhone *               pPhone;
    
    
    //
    // get the address2 interface
    //
    hr = pAddress->QueryInterface(
                             IID_ITAddress2,
                             (void **) &pAddress2
                            );

    if ( !SUCCEEDED(hr) )
    {
        return;
    }

    //
    // enumerate the phones
    //
    pAddress2->EnumeratePhones( &pEnumPhones );

    //
    // go through the phones
    //
    while (TRUE)
    {      
        hr = pEnumPhones->Next( 1, &pPhone, NULL);

        if (S_OK != hr)
        {
            break;
        }

        AddPhone(pPhone);

        UpdatePhone(pPhone);

        //
        // release
        //
        pPhone->Release();
    }

    //
    // release enumerator
    //
    pEnumPhones->Release();

    //
    // release
    //
    pAddress2->Release();

    //
    // select
    //
    SelectFirstItem(
                    ghPhonesWnd,
                    ghPhonesRoot
                   );

}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// UpdatePhone
//
// check the call's state and privelege, and update the call
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::UpdatePhone( ITPhone * pPhone )
{
    HTREEITEM               hItem, hParent;
    TV_ITEM                 item;
    PHONE_PRIVILEGE         pp;
    TV_INSERTSTRUCT         tvi;
    
    //
    // get the first phone
    //
    item.mask = TVIF_HANDLE | TVIF_PARAM;
    
    
    hItem = TreeView_GetChild(
                              ghPhonesWnd,
                              ghPhonesRoot
                             );

    //
    // go through all the phones
    // and look for the one that matches
    // the one passed in
    //
    while (NULL != hItem)
    {
        item.hItem = hItem;
        
        TreeView_GetItem(
                         ghPhonesWnd,
                         &item
                        );

        if ( item.lParam == (LPARAM)pPhone )
        {
            break;
        }

        hItem = TreeView_GetNextSibling(
                                        ghPhonesWnd,
                                        hItem
                                       );
    }

    //
    // did we find it?
    //
    if (NULL == hItem)
    {
        return;
    }

    
    hParent = hItem;

    //
    // delete the current children of the phone
    // node (these are the old privelege)
    //
    hItem = TreeView_GetChild(
                              ghPhonesWnd,
                              hItem
                             );

    
    while (NULL != hItem)
    {
        HTREEITEM   hNewItem;
        
        hNewItem = TreeView_GetNextSibling(
                                           ghPhonesWnd,
                                           hItem
                                          );

        TreeView_DeleteItem(
                            ghPhonesWnd,
                            hItem
                           );

        hItem = hNewItem;
    }

    tvi.hInsertAfter = TVI_LAST;

    //
    // get the current privilege
    //
    if (tvi.item.pszText = GetPhonePrivilegeName( pPhone ))
    {
        //
        // add it as a child of the
        // call node
        //
        tvi.hParent = hParent;
        tvi.item.mask = TVIF_TEXT;

        TreeView_InsertItem(
                            ghPhonesWnd,
                            &tvi
                           );

        SysFreeString( tvi.item.pszText );
    }      
}

void CT3testDlg::UpdateTerminals(
                                 ITAddress * pAddress,
                                 long lMediaType
                                )
{
    ITTerminalSupport *     pTerminalSupport;
    IEnumTerminal *         pEnumTerminals;
    HRESULT                 hr;
    ITTerminal *            pTerminal;
    
    
    //
    // get the terminalsupport interface
    //
    hr = pAddress->QueryInterface(
                             IID_ITTerminalSupport,
                             (void **) &pTerminalSupport
                            );

    if ( !SUCCEEDED(hr) )
    {
        return;
    }

    //
    // enumerate the terminals
    //
    pTerminalSupport->EnumerateStaticTerminals( &pEnumTerminals );

    //
    // go through the terminals
    //
    while (TRUE)
    {
        VARIANT_BOOL        bSupport;
        BSTR                bstr;
        long                l;

        
        hr = pEnumTerminals->Next( 1, &pTerminal, NULL);

        if (S_OK != hr)
        {
            break;
        }

        //
        // get the name
        //
        hr = pTerminal->get_Name( &bstr );

        //
        // if it's a unimodem or a direct sound
        // device don't show it, cause they bother
        // me
        //
        if (wcsstr( bstr, L"Voice Modem" ) || wcsstr( bstr, L"ds:" ) )
        {
            pTerminal->Release();
            SysFreeString( bstr );
            
            continue;
        }

        //
        // free the name
        //
        SysFreeString( bstr );

        //
        // get the mediatype of the terminal
        //
        pTerminal->get_MediaType( &l );

        //
        // if it's the same as the selected mediatype
        // show it
        //
        if ( l == lMediaType )
        {
            AddTerminal(pTerminal);
        }

        //
        // release
        //
        pTerminal->Release();
    }

    //
    // release enumerator
    //
    pEnumTerminals->Release();

    //
    // release
    //
    pTerminalSupport->Release();

    //
    // select
    //
    SelectFirstItem(
                    ghTerminalsWnd,
                    ghTerminalsRoot
                   );

}


void CT3testDlg::UpdateTerminalClasses(
                                       ITAddress * pAddress,
                                       long lMediaType
                                      )
{
    IEnumTerminalClass *        pEnumTerminalClasses;
    HRESULT                     hr;
    ITTerminalSupport *         pTerminalSupport;

    hr = pAddress->QueryInterface(
                             IID_ITTerminalSupport,
                             (void **)&pTerminalSupport
                            );


    if (!SUCCEEDED(hr))
    {
        return;
    }
    
    //
    // now enum dymnamic
    //
    hr = pTerminalSupport->EnumerateDynamicTerminalClasses( &pEnumTerminalClasses );

    if (S_OK == hr)
    {
        
        //
        // go through all the classes
        //
        while (TRUE)
        {
            GUID *                  pDynTerminalClass = new GUID;

            hr = pEnumTerminalClasses->Next(
                                            1,
                                            pDynTerminalClass,
                                            NULL
                                           );

            if (S_OK != hr)
            {
                delete pDynTerminalClass;
                break;
            }

            //
            // manually match up mediatype and
            // class
            //
            if ( (lMediaType == (long)LINEMEDIAMODE_VIDEO) &&
                 (*pDynTerminalClass == CLSID_VideoWindowTerm) )
            {

                AddTerminalClass(
                                 pDynTerminalClass
                                );
            }

#ifdef ENABLE_DIGIT_DETECTION_STUFF
            else if ( (lMediaType == (long)LINEMEDIAMODE_AUTOMATEDVOICE) &&
                      ( *pDynTerminalClass == CLSID_DigitTerminal ) )
            {
                AddTerminalClass(
                                 pDynTerminalClass
                                );
            }
            else if ( ((lMediaType == (long)LINEMEDIAMODE_DATAMODEM) ||
                       (lMediaType == (long)LINEMEDIAMODE_G3FAX)) &&
                      (*pDynTerminalClass == CLSID_DataTerminal) )
            {
                AddTerminalClass( pDynTerminalClass );
            }
#endif // ENABLE_DIGIT_DETECTION_STUFF


            else
            {
                delete pDynTerminalClass;
            }

        }

        //
        // release enumerator
        //
        pEnumTerminalClasses->Release();

    }
    
    //
    // release this interface
    //
    pTerminalSupport->Release();
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\callcont\callman.c ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/callman.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.69.1.1  $
 *	$Date:   23 Jun 1997 15:58:00  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#pragma warning ( disable: 4115 4201 4214)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#pragma warning ( default: 4115 4201 4214)
#include "incommon.h"
#include "callcont.h"
#include "q931.h"
#include "ccmain.h"
#include "h245man.h"
#include "confman.h"
#include "callman.h"
#include "ccutils.h"
#include "callman2.h"


static BOOL		bCallInited = FALSE;

#define HASH_TABLE_SIZE	11

static struct {
	PCALL				pHead[HASH_TABLE_SIZE];
	LOCK				Lock;
} CallTable;

static struct {
	CC_HCALL			hCall;
	LOCK				Lock;
} CallHandle;

HRESULT _LockCallAndConferenceMarkedForDeletion(
									CC_HCALL				hCall,
									PPCALL					ppCall,
									PPCONFERENCE			ppConference);

HRESULT InitCallManager()
{
int		i;

	ASSERT(bCallInited == FALSE);

	for (i = 0; i < HASH_TABLE_SIZE; i++)
		CallTable.pHead[i] = NULL;
	InitializeLock(&CallTable.Lock);

	CallHandle.hCall = CC_INVALID_HANDLE + 1;
	InitializeLock(&CallHandle.Lock);

	bCallInited = TRUE;
	return CC_OK;
}



HRESULT DeInitCallManager()
{
HRESULT		status;
HRESULT		SaveStatus;
int			i;
PCALL		pCall;
PCALL		pNextCall;
H245_INST_T	H245Instance;

	if (bCallInited == FALSE)
		return CC_OK;

	SaveStatus = CC_OK;
	for (i = 0; i < HASH_TABLE_SIZE; i++) {
		pCall = CallTable.pHead[i];
		while (pCall != NULL) {
			AcquireLock(&pCall->Lock);
			pNextCall = pCall->pNextInTable;
			H245Instance = pCall->H245Instance;
			FreeCall(pCall);
			if (H245Instance != H245_INVALID_ID) {
				status = H245ShutDown(H245Instance);
				if (status != H245_ERROR_OK)
					SaveStatus = status;
			}
			pCall = pNextCall;
		}
	}

	DeleteLock(&CallHandle.Lock);
	DeleteLock(&CallTable.Lock);
	bCallInited = FALSE;
	return SaveStatus;
}



#define _Hash(hCall) ((hCall) % HASH_TABLE_SIZE)



HRESULT _AddCallToTable(			PCALL					pCall)
{
int	index;

	ASSERT(pCall != NULL);
	ASSERT(pCall->hCall != CC_INVALID_HANDLE);
	ASSERT(pCall->bInTable == FALSE);

	AcquireLock(&CallTable.Lock);

	index = _Hash(pCall->hCall);
	pCall->pNextInTable = CallTable.pHead[index];
	pCall->pPrevInTable = NULL;
	if (CallTable.pHead[index] != NULL)
		CallTable.pHead[index]->pPrevInTable = pCall;
	CallTable.pHead[index] = pCall;

	pCall->bInTable = TRUE;

	RelinquishLock(&CallTable.Lock);
	return CC_OK;
}



HRESULT _RemoveCallFromTable(		PCALL					pCall)
{
CC_HCALL	hCall;
int			index;
BOOL		bTimedOut;

	ASSERT(pCall != NULL);
	ASSERT(pCall->bInTable == TRUE);

	// Caller must have a lock on the call object;
	// in order to avoid deadlock, we must:
	//   1. unlock the Call object,
	//   2. lock the CallTable,
	//   3. locate the call object in the CallTable (note that
	//      after step 2, the call object may be deleted from the
	//      CallTable by another thread),
	//   4. lock the Call object (someone else may have the lock)
	//   5. remove the call object from the CallTable,
	//   6. unlock the CallTable
	//
	// The caller can now safely unlock and destroy the call object,
	// since no other thread will be able to find the object (its been
	// removed from the CallTable), and therefore no other thread will
	// be able to lock it.

	// Save the call handle; its the only way to look up
	// the call object in the CallTable. Note that we
	// can't use pCall to find the call object, since
	// pCall may be free'd up, and another call object
	// allocated at the same address
	hCall = pCall->hCall;

	// step 1
	RelinquishLock(&pCall->Lock);

step2:
	// step 2
	AcquireLock(&CallTable.Lock);

	index = _Hash(hCall);

	// step 3
	pCall = CallTable.pHead[index];
	while ((pCall != NULL) && (pCall->hCall != hCall))
		pCall = pCall->pNextInTable;

	if (pCall != NULL) {
		// step 4
		AcquireTimedLock(&pCall->Lock,10,&bTimedOut);
		if (bTimedOut) {
			RelinquishLock(&CallTable.Lock);
			Sleep(0);
			goto step2;
		}

		// step 5
		if (pCall->pPrevInTable == NULL)
			CallTable.pHead[index] = pCall->pNextInTable;
		else
			pCall->pPrevInTable->pNextInTable = pCall->pNextInTable;

		if (pCall->pNextInTable != NULL)
			pCall->pNextInTable->pPrevInTable = pCall->pPrevInTable;

		pCall->pNextInTable = NULL;
		pCall->pPrevInTable = NULL;
		pCall->bInTable = FALSE;
	}

	// step 6
	RelinquishLock(&CallTable.Lock);

	if (pCall == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT _MakeCallHandle(			PCC_HCALL				phCall)
{
	AcquireLock(&CallHandle.Lock);
	*phCall = CallHandle.hCall++;
	RelinquishLock(&CallHandle.Lock);
	return CC_OK;
}



HRESULT AllocAndLockCall(			PCC_HCALL				phCall,
									CC_HCONFERENCE			hConference,
									HQ931CALL				hQ931Call,
									HQ931CALL				hQ931CallInvitor,
									PCC_ALIASNAMES			pLocalAliasNames,
									PCC_ALIASNAMES			pPeerAliasNames,
									PCC_ALIASNAMES			pPeerExtraAliasNames,
									PCC_ALIASITEM			pPeerExtension,
									PCC_NONSTANDARDDATA		pLocalNonStandardData,
									PCC_NONSTANDARDDATA		pPeerNonStandardData,
									PWSTR					pszLocalDisplay,
									PWSTR					pszPeerDisplay,
									PCC_VENDORINFO			pPeerVendorInfo,
									PCC_ADDR				pQ931LocalConnectAddr,
									PCC_ADDR				pQ931PeerConnectAddr,
									PCC_ADDR				pQ931DestinationAddr,
									PCC_ADDR				pSourceCallSignalAddr,
									CALLTYPE				CallType,
									BOOL					bCallerIsMC,
									DWORD					dwUserToken,
									CALLSTATE				InitialCallState,
									DWORD					dwBandwidth,
									PCC_CONFERENCEID		pConferenceID,
									PPCALL					ppCall)
{
HRESULT		status;
	
	ASSERT(bCallInited == TRUE);

	// all parameters should have been validated by the caller
	ASSERT(phCall != NULL);
	ASSERT(ppCall != NULL);
	ASSERT(pConferenceID != NULL);

	// set phCall now, in case we encounter an error
	*phCall = CC_INVALID_HANDLE;

	*ppCall = (PCALL)Malloc(sizeof(CALL));
	if (*ppCall == NULL)
		return CC_NO_MEMORY;

   memset(*ppCall, 0, sizeof(CALL));
	(*ppCall)->bInTable = FALSE;
	(*ppCall)->hConference = hConference;
	(*ppCall)->hQ931Call = hQ931Call;
	(*ppCall)->hQ931CallInvitor = hQ931CallInvitor;
	(*ppCall)->pPeerParticipantInfo = NULL;
	(*ppCall)->bMarkedForDeletion = FALSE;
	(*ppCall)->H245Instance = H245_INVALID_ID;
	(*ppCall)->dwH245PhysicalID = 0;
	(*ppCall)->dwUserToken = dwUserToken;
	(*ppCall)->pLocalNonStandardData = NULL;
	(*ppCall)->pPeerNonStandardData = NULL;
	(*ppCall)->pQ931LocalConnectAddr = NULL;
	(*ppCall)->pQ931PeerConnectAddr = NULL;
	(*ppCall)->pQ931DestinationAddr = NULL;
	(*ppCall)->pszLocalDisplay = NULL;
	(*ppCall)->pszPeerDisplay = NULL;
	(*ppCall)->pPeerVendorInfo = NULL;
	(*ppCall)->pLocalAliasNames = NULL;
	(*ppCall)->pPeerAliasNames = NULL;
	(*ppCall)->pPeerExtraAliasNames = NULL;
	(*ppCall)->pPeerExtension = NULL;
	(*ppCall)->OutgoingTermCapState = NEED_TO_SEND_TERMCAP;
	(*ppCall)->IncomingTermCapState = AWAITING_TERMCAP;
	(*ppCall)->MasterSlaveState = MASTER_SLAVE_NOT_STARTED;
	(*ppCall)->pPeerH245TermCapList = NULL;
	(*ppCall)->pPeerH245H2250MuxCapability = NULL;
	(*ppCall)->pPeerH245TermCapDescriptors = NULL;
	(*ppCall)->CallState = InitialCallState;
	(*ppCall)->dwBandwidth = dwBandwidth;
	(*ppCall)->ConferenceID = *pConferenceID;
	(*ppCall)->CallType = CallType;
	(*ppCall)->bCallerIsMC = bCallerIsMC;
	(*ppCall)->bLinkEstablished = FALSE;
	(*ppCall)->pNext = NULL;
	(*ppCall)->pPrev = NULL;
	(*ppCall)->pNextInTable = NULL;
	(*ppCall)->pPrevInTable = NULL;

	InitializeLock(&(*ppCall)->Lock);
	AcquireLock(&(*ppCall)->Lock);

	status = _MakeCallHandle(&(*ppCall)->hCall);
	if (status != CC_OK) {
		FreeCall(*ppCall);
		return status;
	}
	
	// make a local copy of the local non-standard data, if supplied
	status = CopyNonStandardData(&(*ppCall)->pLocalNonStandardData,
		                         pLocalNonStandardData);
	if (status != CC_OK) {
		FreeCall(*ppCall);
		return status;
	}
	
	// make a local copy of the peer's non-standard data, if supplied
	status = CopyNonStandardData(&(*ppCall)->pPeerNonStandardData,
		                         pPeerNonStandardData);
	if (status != CC_OK) {
		FreeCall(*ppCall);
		return status;
	}
	
	// make a copy of the local connect address, if supplied
	if (pQ931LocalConnectAddr != NULL) {
		(*ppCall)->pQ931LocalConnectAddr = (PCC_ADDR)Malloc(sizeof(CC_ADDR));
		if ((*ppCall)->pQ931LocalConnectAddr == NULL) {
			FreeCall(*ppCall);
			return CC_NO_MEMORY;
		}
		*(*ppCall)->pQ931LocalConnectAddr = *pQ931LocalConnectAddr;
	}

	// make a copy of the peer's connect address, if supplied
	if (pQ931PeerConnectAddr != NULL) {
		(*ppCall)->pQ931PeerConnectAddr = (PCC_ADDR)Malloc(sizeof(CC_ADDR));
		if ((*ppCall)->pQ931PeerConnectAddr == NULL) {
			FreeCall(*ppCall);
			return CC_NO_MEMORY;
		}
		*(*ppCall)->pQ931PeerConnectAddr = *pQ931PeerConnectAddr;
	}

	// make a copy of the destination address, if supplied
	if (pQ931DestinationAddr != NULL) {
		(*ppCall)->pQ931DestinationAddr = (PCC_ADDR)Malloc(sizeof(CC_ADDR));
		if ((*ppCall)->pQ931DestinationAddr == NULL) {
			FreeCall(*ppCall);
			return CC_NO_MEMORY;
		}
		*(*ppCall)->pQ931DestinationAddr = *pQ931DestinationAddr;
	}

	// make a copy of the source call signal address, if supplied
	if (pSourceCallSignalAddr != NULL) {
		(*ppCall)->pSourceCallSignalAddr = (PCC_ADDR)Malloc(sizeof(CC_ADDR));
		if ((*ppCall)->pSourceCallSignalAddr == NULL) {
			FreeCall(*ppCall);
			return CC_NO_MEMORY;
		}
		*(*ppCall)->pSourceCallSignalAddr = *pSourceCallSignalAddr;
	}

	// make a local copy of the local alias names
	status = Q931CopyAliasNames(&((*ppCall)->pLocalAliasNames), pLocalAliasNames);
	if (status != CS_OK) {
		FreeCall(*ppCall);
		return status;
	}

	// make a local copy of the peer alias names
	status = Q931CopyAliasNames(&((*ppCall)->pPeerAliasNames), pPeerAliasNames);
	if (status != CS_OK) {
		FreeCall(*ppCall);
		return status;
	}

	// make a local copy of the peer extra alias names
	status = Q931CopyAliasNames(&((*ppCall)->pPeerExtraAliasNames),
								pPeerExtraAliasNames);
	if (status != CS_OK) {
		FreeCall(*ppCall);
		return status;
	}

	// make a local copy of the peer extension
	status = Q931CopyAliasItem(&((*ppCall)->pPeerExtension),
							   pPeerExtension);
	if (status != CS_OK) {
		FreeCall(*ppCall);
		return status;
	}

	status = CopyDisplay(&(*ppCall)->pszLocalDisplay, pszLocalDisplay);
	if (status != CC_OK) {
		FreeCall(*ppCall);
		return status;
	}

	status = CopyDisplay(&(*ppCall)->pszPeerDisplay, pszPeerDisplay);
	if (status != CC_OK) {
		FreeCall(*ppCall);
		return status;
	}

	status = CopyVendorInfo(&(*ppCall)->pPeerVendorInfo, pPeerVendorInfo);
	if (status != CC_OK) {
		FreeCall(*ppCall);
		return status;
	}

	*phCall = (*ppCall)->hCall;

	// add the Call to the Call table
	status = _AddCallToTable(*ppCall);
	if (status != CC_OK)
		FreeCall(*ppCall);
	
	return status;
}



// Caller must have a lock on the Call object
HRESULT FreeCall(					PCALL					pCall)
{
HRESULT		status;
CC_HCALL	hCall;
PCONFERENCE	pConference;

	ASSERT(pCall != NULL);

#ifdef    GATEKEEPER
	if (pCall->GkiCall.uGkiCallState != 0)
		GkiCloseCall(&pCall->GkiCall);
#endif // GATEKEEPER

	// caller must have a lock on the Call object,
	// so there's no need to re-lock it
	
	hCall = pCall->hCall;
	if (pCall->hConference != CC_INVALID_HANDLE) {
		UnlockCall(pCall);
		status = _LockCallAndConferenceMarkedForDeletion(hCall, &pCall, &pConference);
		if (status != CC_OK)
			return status;
	}

	if (pCall->bInTable == TRUE)
		if (_RemoveCallFromTable(pCall) == CC_BAD_PARAM)
			// the Call object was deleted by another thread,
			// so just return CC_OK
			return CC_OK;

	if (pCall->pPeerParticipantInfo != NULL) {
		if (pCall->CallType == VIRTUAL_CALL)
			FreePeerParticipantInfo(NULL, pCall->pPeerParticipantInfo);
		else
			FreePeerParticipantInfo(pConference, pCall->pPeerParticipantInfo);
	}

	// If the call object is associated with a conference object, deassociate it.
	if (pCall->hConference != CC_INVALID_HANDLE) {
		RemoveCallFromConference(pCall, pConference);
		UnlockConference(pConference);
	}

	if (pCall->pLocalNonStandardData != NULL)
		FreeNonStandardData(pCall->pLocalNonStandardData);

	if (pCall->pPeerNonStandardData != NULL)
		FreeNonStandardData(pCall->pPeerNonStandardData);

	if (pCall->pQ931LocalConnectAddr != NULL)
		Free(pCall->pQ931LocalConnectAddr);

	if (pCall->pQ931PeerConnectAddr != NULL)
		Free(pCall->pQ931PeerConnectAddr);

	if (pCall->pQ931DestinationAddr != NULL)
		Free(pCall->pQ931DestinationAddr);

	if (pCall->pSourceCallSignalAddr != NULL)
		Free(pCall->pSourceCallSignalAddr);

	if (pCall->pPeerH245TermCapList != NULL)
		DestroyH245TermCapList(&(pCall->pPeerH245TermCapList));

	if (pCall->pPeerH245H2250MuxCapability != NULL)
		DestroyH245TermCap(&(pCall->pPeerH245H2250MuxCapability));

	if (pCall->pPeerH245TermCapDescriptors != NULL)
		DestroyH245TermCapDescriptors(&(pCall->pPeerH245TermCapDescriptors));

	if (pCall->pLocalAliasNames != NULL)
		Q931FreeAliasNames(pCall->pLocalAliasNames);

	if (pCall->pPeerAliasNames != NULL)
		Q931FreeAliasNames(pCall->pPeerAliasNames);

	if (pCall->pPeerExtraAliasNames != NULL)
		Q931FreeAliasNames(pCall->pPeerExtraAliasNames);
	
	if (pCall->pPeerExtension != NULL)
		Q931FreeAliasItem(pCall->pPeerExtension);

	if (pCall->pszLocalDisplay != NULL)
		FreeDisplay(pCall->pszLocalDisplay);

	if (pCall->pszPeerDisplay != NULL)
		FreeDisplay(pCall->pszPeerDisplay);

	if (pCall->pPeerVendorInfo != NULL)
		FreeVendorInfo(pCall->pPeerVendorInfo);

#ifdef    GATEKEEPER
	if (pCall->GkiCall.uGkiCallState != 0)
		GkiFreeCall(&pCall->GkiCall);
#endif // GATEKEEPER

	// Since the call object has been removed from the CallTable,
	// no other thread will be able to find the call object and obtain
	// a lock, so its safe to unlock the call object and delete it here
	RelinquishLock(&pCall->Lock);
	DeleteLock(&pCall->Lock);
	Free(pCall);
	return CC_OK;
}



HRESULT _LockQ931CallMarkedForDeletion(
									CC_HCALL				hCall,
									HQ931CALL				hQ931Call,
									PPCALL					ppCall)
{
int		index;
BOOL	bTimedOut;

	// If hCall != CC_INVALID_HANDLE, the search is based on hCall;
	// otherwise, the search is based on hQ931Call

	ASSERT(ppCall != NULL);

step1:
	AcquireLock(&CallTable.Lock);

	if (hCall != CC_INVALID_HANDLE) {
		index = _Hash(hCall);

		*ppCall = CallTable.pHead[index];
		while ((*ppCall != NULL) && ((*ppCall)->hCall != hCall))
			*ppCall = (*ppCall)->pNextInTable;
	} else {
		// Perform an exhaustive search based on hQ931Call
		for (index = 0; index < HASH_TABLE_SIZE; index++) {
			*ppCall = CallTable.pHead[index];
			while ((*ppCall != NULL) && ((*ppCall)->hQ931Call != hQ931Call))
				*ppCall = (*ppCall)->pNextInTable;
			if (*ppCall != NULL)
				break;
		}
	}

	if (*ppCall != NULL) {
		AcquireTimedLock(&(*ppCall)->Lock,10,&bTimedOut);
		if (bTimedOut) {
			RelinquishLock(&CallTable.Lock);
			Sleep(0);
			goto step1;
		}
	}

	RelinquishLock(&CallTable.Lock);

	if (*ppCall == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT LockQ931Call(				CC_HCALL				hCall,
									HQ931CALL				hQ931Call,
									PPCALL					ppCall)
{
HRESULT	status;

	status = _LockQ931CallMarkedForDeletion(hCall, hQ931Call, ppCall);
	if (status != CC_OK)
		return status;
	if ((*ppCall)->bMarkedForDeletion) {
		UnlockCall(*ppCall);
		return CC_BAD_PARAM;
	}
	return CC_OK;
}



HRESULT LockCall(					CC_HCALL				hCall,
									PPCALL					ppCall)
{
	ASSERT(hCall != CC_INVALID_HANDLE);
	ASSERT(ppCall != NULL);

	return LockQ931Call(hCall,	// Call Control call handle (used in this call)
		                0,		// Q931 call handle (ignored in this call)
						ppCall);
}



HRESULT _LockCallMarkedForDeletion(	CC_HCALL				hCall,
									PPCALL					ppCall)
{
	ASSERT(hCall != CC_INVALID_HANDLE);
	ASSERT(ppCall != NULL);

	return _LockQ931CallMarkedForDeletion(hCall,	// Call Control call handle (used in this call)
										  0,		// Q931 call handle (ignored in this call)
										  ppCall);
}



HRESULT LockCallAndConference(		CC_HCALL				hCall,
									PPCALL					ppCall,
									PPCONFERENCE			ppConference)
{
HRESULT			status;
CC_HCONFERENCE	hConference;

	ASSERT(hCall != CC_INVALID_HANDLE);
	ASSERT(ppCall != NULL);
	ASSERT(ppConference != NULL);

	status = LockCall(hCall, ppCall);
	if (status != CC_OK)
		return status;
	
	if ((*ppCall)->hConference == CC_INVALID_HANDLE) {
		UnlockCall(*ppCall);
		return CC_BAD_PARAM;
	}

	hConference = (*ppCall)->hConference;
	UnlockCall(*ppCall);

	status = LockConference(hConference, ppConference);
	if (status != CC_OK)
		return status;

	status = LockCall(hCall, ppCall);
	if (status != CC_OK) {
		UnlockConference(*ppConference);
		return status;
	}
	
	return CC_OK;
}



HRESULT _LockCallAndConferenceMarkedForDeletion(
									CC_HCALL				hCall,
									PPCALL					ppCall,
									PPCONFERENCE			ppConference)
{
HRESULT			status;
CC_HCONFERENCE	hConference;

	ASSERT(hCall != CC_INVALID_HANDLE);
	ASSERT(ppCall != NULL);
	ASSERT(ppConference != NULL);

	status = _LockCallMarkedForDeletion(hCall, ppCall);
	if (status != CC_OK)
		return status;
	
	if ((*ppCall)->hConference == CC_INVALID_HANDLE) {
		UnlockCall(*ppCall);
		return CC_BAD_PARAM;
	}

	hConference = (*ppCall)->hConference;
	UnlockCall(*ppCall);

	status = LockConference(hConference, ppConference);
	if (status != CC_OK)
		return status;

	status = _LockCallMarkedForDeletion(hCall, ppCall);
	if (status != CC_OK) {
		UnlockConference(*ppConference);
		return status;
	}
	
	return CC_OK;
}



HRESULT MarkCallForDeletion(		PCALL					pCall)
{
	ASSERT(pCall != NULL);
	ASSERT(pCall->bMarkedForDeletion == FALSE);

	pCall->bMarkedForDeletion = TRUE;
	return CC_OK;
}



HRESULT ValidateCall(				CC_HCALL				hCall)
{
PCALL	pCall;
int		index;

	ASSERT(hCall != CC_INVALID_HANDLE);

	AcquireLock(&CallTable.Lock);

	index = _Hash(hCall);

	pCall = CallTable.pHead[index];
	while ((pCall != NULL) && (pCall->hCall != hCall))
		pCall = pCall->pNextInTable;

	if (pCall != NULL)
		if (pCall->bMarkedForDeletion == TRUE)
			pCall = NULL;

	RelinquishLock(&CallTable.Lock);

	if (pCall == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT ValidateCallMarkedForDeletion(
									CC_HCALL				hCall)
{
PCALL	pCall;
int		index;

	ASSERT(hCall != CC_INVALID_HANDLE);

	AcquireLock(&CallTable.Lock);

	index = _Hash(hCall);

	pCall = CallTable.pHead[index];
	while ((pCall != NULL) && (pCall->hCall != hCall))
		pCall = pCall->pNextInTable;

	RelinquishLock(&CallTable.Lock);

	if (pCall == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT UnlockCall(					PCALL					pCall)
{
	ASSERT(pCall != NULL);

	RelinquishLock(&pCall->Lock);
	return CC_OK;
}



HRESULT AddLocalNonStandardDataToCall(
									PCALL					pCall,
									PCC_NONSTANDARDDATA		pLocalNonStandardData)
{
HRESULT	status;

	ASSERT(pCall != NULL);

	if (pCall->pLocalNonStandardData != NULL)
		FreeNonStandardData(pCall->pLocalNonStandardData);
	status = CopyNonStandardData(&pCall->pLocalNonStandardData, pLocalNonStandardData);
	return status;
}



HRESULT AddLocalDisplayToCall(		PCALL					pCall,
									PWSTR					pszLocalDisplay)
{
HRESULT	status;

	ASSERT(pCall != NULL);

	if (pCall->pszLocalDisplay != NULL)
		FreeDisplay(pCall->pszLocalDisplay);
	status = CopyDisplay(&pCall->pszLocalDisplay, pszLocalDisplay);
	return status;
}



HRESULT AllocatePeerParticipantInfo(PCONFERENCE				pConference,
									PPARTICIPANTINFO		*ppPeerParticipantInfo)
{
HRESULT					status;
H245_TERMINAL_LABEL_T	H245TerminalLabel;

	ASSERT(ppPeerParticipantInfo != NULL);

	if (pConference == NULL) {
		H245TerminalLabel.mcuNumber = 0;
		H245TerminalLabel.terminalNumber = 0;
	} else {
		status = AllocateTerminalNumber(pConference, &H245TerminalLabel);
		if (status != CC_OK) {
			*ppPeerParticipantInfo = NULL;
			return status;
		}
	}

	*ppPeerParticipantInfo = (PPARTICIPANTINFO)Malloc(sizeof(PARTICIPANTINFO));
	if (*ppPeerParticipantInfo == NULL)
		return CC_NO_MEMORY;

	(*ppPeerParticipantInfo)->TerminalIDState = TERMINAL_ID_INVALID;
	(*ppPeerParticipantInfo)->ParticipantInfo.TerminalLabel.bMCUNumber = (BYTE)H245TerminalLabel.mcuNumber;
	(*ppPeerParticipantInfo)->ParticipantInfo.TerminalLabel.bTerminalNumber = (BYTE)H245TerminalLabel.terminalNumber;
	(*ppPeerParticipantInfo)->ParticipantInfo.TerminalID.pOctetString = NULL;
	(*ppPeerParticipantInfo)->ParticipantInfo.TerminalID.wOctetStringLength = 0;
	(*ppPeerParticipantInfo)->pEnqueuedRequestsForTerminalID = NULL;

	return CC_OK;
}



HRESULT FreePeerParticipantInfo(	PCONFERENCE				pConference,
									PPARTICIPANTINFO		pPeerParticipantInfo)
{
HRESULT				status = CC_OK;

	ASSERT(pPeerParticipantInfo != NULL);

	if (pConference != NULL)
		status = FreeTerminalNumber(pConference,
							        pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber);

	while (DequeueRequest(&pPeerParticipantInfo->pEnqueuedRequestsForTerminalID, NULL) == CC_OK);

	if (pPeerParticipantInfo->ParticipantInfo.TerminalID.pOctetString != NULL)
		Free(pPeerParticipantInfo->ParticipantInfo.TerminalID.pOctetString);
	Free(pPeerParticipantInfo);
	return status;
}



#ifdef GATEKEEPER

HRESULT LockGkiCallAndConference(	HANDLE					hGkiCall,
									PGKICALL *				ppGkiCall,
									void * *				ppConference,
									DWORD *					phCall,
									DWORD *					phConference)
{
unsigned int	uIndex;
PCALL			pCall;
PCONFERENCE		pConference;
CC_HCONFERENCE	hConference;
BOOL			bTimedOut;
				
	ASSERT(hGkiCall     != 0);
	ASSERT(ppGkiCall    != NULL);
	ASSERT(ppConference != NULL);
	ASSERT(phCall       != NULL);
	ASSERT(phConference != NULL);

step1:
	AcquireLock(&CallTable.Lock);

	// Perform an exhaustive search based on hGkiCall
	for (uIndex = 0; uIndex < HASH_TABLE_SIZE; ++uIndex)
	{
		pCall = CallTable.pHead[uIndex];
		while (pCall)
		{
			if (pCall->GkiCall.hGkiCall == hGkiCall)
			{
				AcquireTimedLock(&pCall->Lock,10,&bTimedOut);
				if (bTimedOut) {
					RelinquishLock(&CallTable.Lock);
					Sleep(0);
					goto step1;
				}
				hConference = pCall->hConference;
				if (pCall->bMarkedForDeletion || hConference == CC_INVALID_HANDLE)
				{
					RelinquishLock(&pCall->Lock);
					RelinquishLock(&CallTable.Lock);
					return CC_BAD_PARAM;
				}
				RelinquishLock(&pCall->Lock);
				if (LockConference(hConference, &pConference) != CC_OK)
				{
					RelinquishLock(&CallTable.Lock);
					return CC_BAD_PARAM;
				}
				AcquireLock(&pCall->Lock);
				*ppGkiCall    = &pCall->GkiCall;
				*ppConference = (void *)pConference;
				*phCall		  = pCall->hCall;
				*phConference = pCall->hConference;
				RelinquishLock(&CallTable.Lock);
				return NOERROR;
			}
			pCall = pCall->pNextInTable;
		} // while
	}

	RelinquishLock(&CallTable.Lock);
	return CC_BAD_PARAM;
} // LockGkiCallAndConference()



HRESULT UnlockGkiCallAndConference(	PGKICALL				pGkiCall,
									void *					pConference,
									DWORD					hCall,
									DWORD					hConference)
{
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference((PCONFERENCE)pConference);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pGkiCall->pCall);
	return NOERROR;
} // UnlockGkiCallAndConference()



HRESULT LockGkiCall(HANDLE hGkiCall, PPGKICALL ppGkiCall)
{
unsigned int	uIndex;
PCALL			pCall;
BOOL			bTimedOut;

	ASSERT(hGkiCall != 0);
	ASSERT(ppGkiCall != NULL);

step1:
	AcquireLock(&CallTable.Lock);

	// Perform an exhaustive search based on hGkiCall
	for (uIndex = 0; uIndex < HASH_TABLE_SIZE; ++uIndex)
	{
		pCall = CallTable.pHead[uIndex];
		while (pCall)
		{
			if (pCall->GkiCall.hGkiCall == hGkiCall)
			{
				AcquireTimedLock(&pCall->Lock,10,&bTimedOut);
				if (bTimedOut) {
					RelinquishLock(&CallTable.Lock);
					Sleep(0);
					goto step1;
				}
				if (pCall->bMarkedForDeletion)
				{
					RelinquishLock(&pCall->Lock);
					*ppGkiCall = NULL;
					RelinquishLock(&CallTable.Lock);
					return CC_BAD_PARAM;
				}
				*ppGkiCall = &pCall->GkiCall;
				RelinquishLock(&CallTable.Lock);
				return NOERROR;
			}
			pCall = pCall->pNextInTable;
		} // while
	}

	*ppGkiCall = NULL;
	RelinquishLock(&CallTable.Lock);
	return CC_BAD_PARAM;
} // LockGkiCall()



HRESULT UnlockGkiCall(PGKICALL pGkiCall)
{
	return UnlockCall(pGkiCall->pCall);
} // UnlockGkiCall()



HRESULT ApplyToAllCalls(PGKICALLFUN pGkiCallFun)
{
unsigned	uIndex;
PCALL		pCall;
DWORD		hCall;
PCONFERENCE	pConference;
DWORD		hConference;
HRESULT     status;
BOOL		bTimedOut;

step1:
	AcquireLock(&CallTable.Lock);

	// Apply pGkiCallFun to all calls in table
	for (uIndex = 0; uIndex < HASH_TABLE_SIZE; ++uIndex)
	{
		pCall = CallTable.pHead[uIndex];
		while (pCall)
		{
			AcquireTimedLock(&pCall->Lock,10,&bTimedOut);
			if (bTimedOut) {
				RelinquishLock(&CallTable.Lock);
				Sleep(0);
				goto step1;
			}
			hConference = pCall->hConference;
			if (pCall->bMarkedForDeletion || hConference == CC_INVALID_HANDLE)
			{
				RelinquishLock(&pCall->Lock);
			}
			else
			{
				RelinquishLock(&pCall->Lock);
				if (LockConference(hConference, &pConference) == CC_OK)
				{
					AcquireLock(&pCall->Lock);
					hCall = pCall->hCall;
					status = pGkiCallFun(&pCall->GkiCall, pConference);
					if (ValidateConference(hConference) == NOERROR)
						UnlockConference(pConference);
					if (ValidateCall(hCall) != NOERROR)
					{
						// Call was deleted
						RelinquishLock(&CallTable.Lock);
						if (status != NOERROR)
							return status;
						// Start all over again
						goto step1;
					}
					RelinquishLock(&pCall->Lock);
					if (status != NOERROR)
					{
						RelinquishLock(&CallTable.Lock);
						return status;
					}
				}
			}
			pCall = pCall->pNextInTable;
		} // while
	}

	RelinquishLock(&CallTable.Lock);
	return NOERROR;
} // ApplyToAllCalls()

#endif // GATEKEEPER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\callcont\callcon2.c ===
/****************************************************************************
 *
 * $Archive:   S:/STURGEON/SRC/CALLCONT/VCS/callcon2.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 * Copyright (c) 1996 Intel Corporation.
 *
 * $Revision:   1.35  $
 * $Date:   03 Mar 1997 09:08:16  $
 * $Author:   MANDREWS  $
 *
 * Deliverable:
 *
 * Abstract:
 *
 * Notes:
 *
 ***************************************************************************/
#ifdef GATEKEEPER

#pragma warning ( disable : 4057 4115 4201 4214 )
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#pragma warning ( default : 4115 4201 4214 )
#include "apierror.h"
#include "incommon.h"
#include "callcont.h"
#include "q931.h"
#include "ccmain.h"
#include "confman.h"
#include "listman.h"
#include "q931man.h"
#include "h245man.h"
#include "callman.h"
#include "userman.h"
#include "chanman.h"
#include "hangman.h"
#include "linkapi.h"
#include "h245api.h"
#include "ccutils.h"
#include "callman2.h"

#define HResultLeave(x) return x


extern CC_CONFERENCEID	InvalidConferenceID;


//
// Complete CC_xxx Operations
//

HRESULT ListenReject     (DWORD hListen, HRESULT Reason)
{
HRESULT						status;
PLISTEN						pListen;
CC_LISTEN_CALLBACK_PARAMS   ListenCallbackParams;

	status = LockListen(hListen, &pListen);
	if (status == CC_OK) {
		ListenCallbackParams.hCall = CC_INVALID_HANDLE;
		ListenCallbackParams.pCallerAliasNames = NULL;
		ListenCallbackParams.pCalleeAliasNames = NULL;
		ListenCallbackParams.pNonStandardData = NULL;
		ListenCallbackParams.pszDisplay = NULL;
		ListenCallbackParams.pVendorInfo = NULL;
		ListenCallbackParams.ConferenceID = InvalidConferenceID;
		ListenCallbackParams.pCallerAddr = NULL;
		ListenCallbackParams.pCalleeAddr = NULL;
		ListenCallbackParams.dwListenToken = pListen->dwListenToken;

	    // Invoke the user callback -- the listen object is locked during the callback,
	    // but the associated call object is unlocked (to prevent deadlock if
	    // CC_AcceptCall() or CC_RejectCall() is called during the callback from a
	    // different thread, and the callback thread blocks pending completion of 
	    // CC_AcceptCall() or CC_RejectCall())
	    InvokeUserListenCallback(pListen,
							     Reason,
							     &ListenCallbackParams);

	    // Need to validate the listen handle; the associated object may have been
	    // deleted during the user callback by this thread
	    if (ValidateListen(hListen) == CC_OK) {
	        HQ931LISTEN hQ931Listen = pListen->hQ931Listen;
		    UnlockListen(pListen);
	        status = Q931CancelListen(hQ931Listen);
	        if (LockListen(hListen, &pListen) == CC_OK) {
                FreeListen(pListen);
            }
        }
    }

    HResultLeave(status);
} // ListenReject()



HRESULT PlaceCallConfirm    (void *pCallVoid, void *pConferenceVoid)
{
    register PCALL          pCall = (PCALL) pCallVoid;
    HRESULT                 status;

    // Free Alias lists
    if (pCall->GkiCall.pCalleeAliasNames != NULL) {
        Q931FreeAliasNames(pCall->GkiCall.pCalleeAliasNames);
        pCall->GkiCall.pCalleeAliasNames = NULL;
    }
    if (pCall->GkiCall.pCalleeExtraAliasNames != NULL) {
        Q931FreeAliasNames(pCall->GkiCall.pCalleeExtraAliasNames);
        pCall->GkiCall.pCalleeExtraAliasNames = NULL;
    }

    if (pCall->pQ931PeerConnectAddr == NULL) {
        pCall->pQ931PeerConnectAddr = (PCC_ADDR)Malloc(sizeof(CC_ADDR));
        if (pCall->pQ931PeerConnectAddr == NULL)
            return PlaceCallReject(pCallVoid, pConferenceVoid, CC_NO_MEMORY);
    }

    pCall->pQ931PeerConnectAddr->nAddrType             = CC_IP_BINARY;
    pCall->pQ931PeerConnectAddr->bMulticast            = FALSE;
    pCall->pQ931PeerConnectAddr->Addr.IP_Binary.wPort  = pCall->GkiCall.wPort;
    pCall->pQ931PeerConnectAddr->Addr.IP_Binary.dwAddr = ntohl(pCall->GkiCall.dwIpAddress);

    status = PlaceCall(pCall, (PCONFERENCE)pConferenceVoid);
    if (status != CC_OK)
      PlaceCallReject(pCallVoid, pConferenceVoid, status);
    return status;
} // PlaceCallConfirm()



HRESULT PlaceCallReject     (void *pCallVoid, void *pConferenceVoid, HRESULT Reason)
{
register PCALL          pCall = (PCALL) pCallVoid;
register PCONFERENCE    pConference = (PCONFERENCE) pConferenceVoid;
CC_HCONFERENCE			hConference;
HRESULT                 status = CC_OK;
CC_CONNECT_CALLBACK_PARAMS ConnectCallbackParams = {0};
CC_HCALL                hCall;
PCALL                   pCall2;

	ASSERT(pCall != NULL);
	ASSERT(pConference != NULL);

    // Free Alias lists
    if (pCall->GkiCall.pCalleeAliasNames != NULL) {
        Q931FreeAliasNames(pCall->GkiCall.pCalleeAliasNames);
        pCall->GkiCall.pCalleeAliasNames = NULL;
    }
    if (pCall->GkiCall.pCalleeExtraAliasNames != NULL) {
        Q931FreeAliasNames(pCall->GkiCall.pCalleeExtraAliasNames);
        pCall->GkiCall.pCalleeExtraAliasNames = NULL;
    }

    // Inform Call Control client of failure
    ConnectCallbackParams.pNonStandardData     = pCall->pPeerNonStandardData;
    ConnectCallbackParams.pszPeerDisplay       = pCall->pszPeerDisplay;
    ConnectCallbackParams.bRejectReason        = 0;
    ConnectCallbackParams.pTermCapList         = pCall->pPeerH245TermCapList;
    ConnectCallbackParams.pH2250MuxCapability  = pCall->pPeerH245H2250MuxCapability;
    ConnectCallbackParams.pTermCapDescriptors  = pCall->pPeerH245TermCapDescriptors;
    ConnectCallbackParams.pLocalAddr           = pCall->pQ931LocalConnectAddr;
 	if (pCall->pQ931DestinationAddr == NULL)
		ConnectCallbackParams.pPeerAddr = pCall->pQ931PeerConnectAddr;
	else
		ConnectCallbackParams.pPeerAddr = pCall->pQ931DestinationAddr;
    ConnectCallbackParams.pVendorInfo          = pCall->pPeerVendorInfo;
    if (pConference->ConferenceMode == MULTIPOINT_MODE)
        ConnectCallbackParams.bMultipointConference = TRUE;
    else
        ConnectCallbackParams.bMultipointConference = FALSE;
    ConnectCallbackParams.pConferenceID        = &pConference->ConferenceID;
    ConnectCallbackParams.pMCAddress           = pConference->pMultipointControllerAddr;
	ConnectCallbackParams.pAlternateAddress	= NULL;
    ConnectCallbackParams.dwUserToken          = pCall->dwUserToken;
	hConference = pConference->hConference;
    InvokeUserConferenceCallback(pConference,
                                 CC_CONNECT_INDICATION,
                                 Reason,
                                 &ConnectCallbackParams);

    if (ValidateConference(hConference) == CC_OK) {
		// Start up an enqueued call, if one exists
		for ( ; ; ) {
			status = RemoveEnqueuedCallFromConference(pConference, &hCall);
			if ((status != CC_OK) || (hCall == CC_INVALID_HANDLE))
				break;

			status = LockCall(hCall, &pCall2);
			if (status == CC_OK) {
				pCall2->CallState = PLACED;

				status = PlaceCall(pCall2, pConference);
				UnlockCall(pCall2);
				if (status == CC_OK)
					break;
			}
		}
    }

    HResultLeave(status);
} // PlaceCallReject()



HRESULT AcceptCallConfirm   (void *pCallVoid, void *pConferenceVoid)
{
CC_HCALL        hCall       = ((PCALL)pCallVoid)->hCall;
CC_HCONFERENCE  hConference = ((PCONFERENCE)pConferenceVoid)->hConference;
HRESULT         status;

    status = AcceptCall((PCALL)pCallVoid, (PCONFERENCE)pConferenceVoid);
    LockConference(hConference, (PPCONFERENCE)&pConferenceVoid);
    LockCall(hCall, (PPCALL)&pCallVoid);
    if (status != CC_OK && pCallVoid != NULL && pConferenceVoid != NULL)
      AcceptCallReject(pCallVoid, pConferenceVoid, status);
    return status;
} // AcceptCallConfirm()



HRESULT AcceptCallReject    (void *pCallVoid, void *pConferenceVoid, HRESULT Reason)
{
register PCALL          pCall = (PCALL) pCallVoid;
register PCONFERENCE    pConference = (PCONFERENCE) pConferenceVoid;
HRESULT                 status = CC_OK;
CC_CONNECT_CALLBACK_PARAMS ConnectCallbackParams = {0};

    status = Q931RejectCall(pCall->hQ931Call,       // Q931 call handle
                            CC_REJECT_GATEKEEPER_RESOURCES,
                            &pCall->ConferenceID,   // Conference Identifier
                            NULL,                   // alternate address
                            pCall->pLocalNonStandardData);

    ConnectCallbackParams.pNonStandardData     = pCall->pPeerNonStandardData;
    ConnectCallbackParams.pszPeerDisplay       = pCall->pszPeerDisplay;
    ConnectCallbackParams.bRejectReason        = 0;
    ConnectCallbackParams.pTermCapList         = pCall->pPeerH245TermCapList;
    ConnectCallbackParams.pH2250MuxCapability  = pCall->pPeerH245H2250MuxCapability;
    ConnectCallbackParams.pTermCapDescriptors  = pCall->pPeerH245TermCapDescriptors;
    ConnectCallbackParams.pLocalAddr           = pCall->pQ931LocalConnectAddr;
 	if (pCall->pQ931DestinationAddr == NULL)
		ConnectCallbackParams.pPeerAddr = pCall->pQ931PeerConnectAddr;
	else
		ConnectCallbackParams.pPeerAddr = pCall->pQ931DestinationAddr;
    if (pConference->ConferenceMode == MULTIPOINT_MODE)
        ConnectCallbackParams.bMultipointConference = TRUE;
    else
        ConnectCallbackParams.bMultipointConference = FALSE;
    ConnectCallbackParams.pVendorInfo          = pCall->pPeerVendorInfo;
    ConnectCallbackParams.pConferenceID        = &pConference->ConferenceID;
    ConnectCallbackParams.pMCAddress           = pConference->pMultipointControllerAddr;
	ConnectCallbackParams.pAlternateAddress	= NULL;
    ConnectCallbackParams.dwUserToken          = pCall->dwUserToken;

    InvokeUserConferenceCallback(pConference,
                                 CC_CONNECT_INDICATION,
                                 Reason,
                                 &ConnectCallbackParams);

    HResultLeave(status);
} // AcceptCallReject()



#if 0

HRESULT CancelCallConfirm   (void *pCallVoid, void *pConferenceVoid)
{
PCALL               pCall = (PCALL) pCallVoid;
PCONFERENCE         pConference = (PCONFERENCE) pConferenceVoid;
HRESULT             status;
H245_INST_T         H245Instance;
HQ931CALL           hQ931Call;
CC_HCONFERENCE      hConference;
HRESULT             SaveStatus;
CC_HCALL            hCall;

    H245Instance = pCall->H245Instance;
    hQ931Call    = pCall->hQ931Call;
    hConference  = pCall->hConference;
    FreeCall(pCall);

    if (H245Instance != H245_INVALID_ID)
        SaveStatus = H245ShutDown(H245Instance);
    else
        SaveStatus = H245_ERROR_OK;

    if (SaveStatus == H245_ERROR_OK) {
        SaveStatus = Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
        // Q931Hangup may legitimately return CS_BAD_PARAM, because the Q.931 call object
        // may have been deleted at this point
        if (SaveStatus == CS_BAD_PARAM)
            SaveStatus = CC_OK;
    } else
        Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);

    // Start up an enqueued call, if one exists
    for ( ; ; ) {
        status = RemoveEnqueuedCallFromConference(pConference, &hCall);
        if ((status != CC_OK) || (hCall == CC_INVALID_HANDLE))
            break;

        status = LockCall(hCall, &pCall);
        if (status == CC_OK) {
            pCall->CallState = PLACED;

            status = PlaceCall(pCall, pConference);
            UnlockCall(pCall);
            if (status == CC_OK)
                break;
        }
    }
    UnlockConference(pConference);

    if (SaveStatus != CC_OK)
        status = SaveStatus;
    HResultLeave(status);
} // CancelCallConfirm()



HRESULT CancelCallReject    (void *pCallVoid, void *pConferenceVoid)
{
    // I don't care what the Gatekeeper says; I'm shutting down the call!
    return CancelCallConfirm(pCallVoid, pConferenceVoid);
} // CancelCallReject()

#endif



HRESULT OpenChannelConfirm  (DWORD hChannel)
{
HRESULT             status;
PCHANNEL            pChannel;
PCONFERENCE         pConference;
WORD                wNumCalls;
PCC_HCALL           CallList;
HRESULT             SaveStatus;
unsigned            i;
PCALL               pCall;

    status = LockChannelAndConference(hChannel, &pChannel, &pConference);
    if (status == CC_OK) {
        // Open a logical channel for each established call
        status = EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
        if (status == CC_OK) {
            SaveStatus = CC_OK;
            for (i = 0; i < wNumCalls; ++i) {
                if (LockCall(CallList[i], &pCall) == CC_OK) {
                    status = H245OpenChannel(pCall->H245Instance,       // H245 instance
                                             pChannel->hChannel,        // dwTransId
                                             pChannel->wLocalChannelNumber,
                                             pChannel->pTxH245TermCap,  // TxMode
                                             pChannel->pTxMuxTable,     // TxMux
                                             H245_INVALID_PORT_NUMBER,  // TxPort
                                             pChannel->pRxH245TermCap,  // RxMode
                                             pChannel->pRxMuxTable,     // RxMux
                                             pChannel->pSeparateStack);
                    if (status == H245_ERROR_OK)
                        (pChannel->wNumOutstandingRequests)++;
                    else
                        SaveStatus = status;
                    UnlockCall(pCall);
                }
            }

            if (CallList != NULL)
                Free(CallList);

            if (pChannel->wNumOutstandingRequests == 0) {
                // all open channel requests failed
                FreeChannel(pChannel);
            }
            else {
                UnlockChannel(pChannel);
            }

            if (SaveStatus != CC_OK)
                status = SaveStatus;
        }
        else {
            FreeChannel(pChannel);
        }
        UnlockConference(pConference);
    }


    HResultLeave(status);
} // OpenChannelConfirm()



HRESULT OpenChannelReject   (DWORD hChannel, HRESULT Reason)
{
PCHANNEL            pChannel;
PCONFERENCE         pConference;
CC_HCONFERENCE      hConference;
HRESULT             status;
CC_TX_CHANNEL_OPEN_CALLBACK_PARAMS Params = {0};

    status = LockChannelAndConference(hChannel, &pChannel, &pConference);
    if (status == CC_OK) {
        // Inform Call Control client of failure
        Params.hChannel         = hChannel;
        Params.pPeerRTPAddr     = pChannel->pPeerRTPAddr;
        Params.pPeerRTCPAddr    = pChannel->pPeerRTCPAddr;
        Params.dwRejectReason   = 0;
        Params.dwUserToken      = pChannel->dwUserToken;

        hConference = pConference->hConference;
        InvokeUserConferenceCallback(pConference,
                                     CC_TX_CHANNEL_OPEN_INDICATION,
                                     Reason,
                                     &Params);

        if (ValidateChannel(hChannel) == CC_OK)
            FreeChannel(pChannel);
        if (ValidateConference(hConference) == CC_OK)
            UnlockConference(pConference);
    }

    HResultLeave(status);
} // OpenChannelReject()



HRESULT AcceptChannelConfirm(DWORD hChannel)
{
HRESULT         status;
PCHANNEL        pChannel;
PCONFERENCE     pConference;
CC_HCONFERENCE  hConference;
PCALL           pCall;
unsigned        i;
H245_MUX_T      H245MuxTable;
CC_ACCEPT_CHANNEL_CALLBACK_PARAMS Params;

    status = LockChannelAndConference(hChannel, &pChannel, &pConference);
    if (status != CC_OK)
        HResultLeave(status);

    status = LockCall(pChannel->hCall, &pCall);
    if (status != CC_OK) {
        UnlockChannel(pChannel);
        UnlockConference(pConference);
        HResultLeave(status);
    }

    if (pChannel->wNumOutstandingRequests != 0) {
        PCC_ADDR pRTPAddr  = pChannel->pLocalRTPAddr;
        PCC_ADDR pRTCPAddr = pChannel->pLocalRTCPAddr;
        if ((pChannel->bMultipointChannel) &&
            (pConference->tsMultipointController == TS_TRUE)) {
            // Supply the RTP and RTCP addresses in the OpenLogicalChannelAck
            if (pConference->pSessionTable != NULL) {
                for (i = 0; i < pConference->pSessionTable->wLength; ++i) {
                    if (pConference->pSessionTable->SessionInfoArray[i].bSessionID ==
                        pChannel->bSessionID) {
                        pRTPAddr = pConference->pSessionTable->SessionInfoArray[i].pRTPAddr;
                        pRTCPAddr = pConference->pSessionTable->SessionInfoArray[i].pRTCPAddr;
                        break;
                    }
                }
            }
        }

        H245MuxTable.Kind = H245_H2250ACK;
        H245MuxTable.u.H2250ACK.nonStandardList = NULL;

        if (pRTPAddr != NULL) {
            if (pRTPAddr->bMulticast)
                H245MuxTable.u.H2250ACK.mediaChannel.type = H245_IP_MULTICAST;
            else
                H245MuxTable.u.H2250ACK.mediaChannel.type = H245_IP_UNICAST;
            H245MuxTable.u.H2250ACK.mediaChannel.u.ip.tsapIdentifier =
                pRTPAddr->Addr.IP_Binary.wPort;
            HostToH245IPNetwork(H245MuxTable.u.H2250ACK.mediaChannel.u.ip.network,
                                pRTPAddr->Addr.IP_Binary.dwAddr);
            H245MuxTable.u.H2250ACK.mediaChannelPresent = TRUE;
        } else
            H245MuxTable.u.H2250ACK.mediaChannelPresent = FALSE;

        if (pRTCPAddr != NULL) {
            if (pRTCPAddr->bMulticast)
                H245MuxTable.u.H2250ACK.mediaControlChannel.type = H245_IP_MULTICAST;
            else
                H245MuxTable.u.H2250ACK.mediaControlChannel.type = H245_IP_UNICAST;
            H245MuxTable.u.H2250ACK.mediaControlChannel.u.ip.tsapIdentifier =
                pRTCPAddr->Addr.IP_Binary.wPort;
            HostToH245IPNetwork(H245MuxTable.u.H2250ACK.mediaControlChannel.u.ip.network,
                                pRTCPAddr->Addr.IP_Binary.dwAddr);
            H245MuxTable.u.H2250ACK.mediaControlChannelPresent = TRUE;
        } else
            H245MuxTable.u.H2250ACK.mediaControlChannelPresent = FALSE;

        H245MuxTable.u.H2250ACK.dynamicRTPPayloadTypePresent = FALSE;
        H245MuxTable.u.H2250ACK.sessionIDPresent = TRUE;
        H245MuxTable.u.H2250ACK.sessionID = pChannel->bSessionID;

        status = H245OpenChannelAccept(pCall->H245Instance,
                                       0,                   // dwTransId
                                       pChannel->wRemoteChannelNumber, // Rx channel
                                       &H245MuxTable,
                                       0,                       // Tx channel
                                       NULL,                    // Tx mux
                                       H245_INVALID_PORT_NUMBER,// Port
                                       pChannel->pSeparateStack);
        if (status == CC_OK)
            pChannel->wNumOutstandingRequests = 0;
        else
            --(pChannel->wNumOutstandingRequests);
    }

    pChannel->tsAccepted = TS_TRUE;

    Params.hChannel = hChannel;
    if (status == CC_OK)
        UnlockChannel(pChannel);
    else
        FreeChannel(pChannel);
    UnlockCall(pCall);

    hConference = pConference->hConference;
    InvokeUserConferenceCallback(pConference,
                                 CC_ACCEPT_CHANNEL_INDICATION,
                                 status,
                                 &Params);
    if (ValidateConference(hConference) == CC_OK)
        UnlockConference(pConference);

    HResultLeave(status);
} // AcceptChannelConfirm(void()



HRESULT AcceptChannelReject (DWORD hChannel, HRESULT Reason)
{
HRESULT         status;
PCHANNEL        pChannel;
PCONFERENCE     pConference;
CC_HCONFERENCE  hConference;
CC_ACCEPT_CHANNEL_CALLBACK_PARAMS Params;

    status = LockChannelAndConference(hChannel, &pChannel, &pConference);
    if (status == CC_OK) {
        Params.hChannel = hChannel;
        FreeChannel(pChannel);

        hConference = pConference->hConference;
        InvokeUserConferenceCallback(pConference,
                                     CC_ACCEPT_CHANNEL_INDICATION,
                                     Reason,
                                     &Params);
        if (ValidateConference(hConference) == CC_OK)
            UnlockConference(pConference);
    }

    HResultLeave(status);
} // AcceptChannelReject()



//
// Handle gratuitous messages from Gatekeeper
//

// Note: pCall assumed locked when called!

HRESULT Disengage(void *pCallVoid)
{
CC_HCALL            hCall        = ((PCALL)pCallVoid)->hCall;
HRESULT             status;

    UnlockCall((PCALL)pCallVoid);
    status = ProcessRemoteHangup(hCall, CC_INVALID_HANDLE, CC_REJECT_GATEKEEPER_TERMINATED);
    HResultLeave(status);
} // Disengage()



// Note: pCall assumed locked when called!

HRESULT BandwidthShrunk(void *pCallVoid,
                        void *pConferenceVoid,
                        unsigned uBandwidthAllocated,
                        long lBandwidthChange)
{
PCALL               pCall       = (PCALL) pCallVoid;
PCONFERENCE         pConference = (PCONFERENCE)pConferenceVoid;
CC_BANDWIDTH_CALLBACK_PARAMS Params;

    Params.hCall = pCall->hCall;
    Params.dwBandwidthTotal  = uBandwidthAllocated;
    Params.lBandwidthChange  = lBandwidthChange;
    InvokeUserConferenceCallback(pConference,
                                 CC_BANDWIDTH_CHANGED_INDICATION,
                                 CC_OK,
                                 &Params);

    HResultLeave(CC_OK);
} // BandwidthShrunk()

#else  // GATEKEEPER
static char ch; // Kludge around warning C4206: nonstandard extension used : translation unit is empty
#endif // GATEKEEPER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3testph\t3testd.cpp ===
// t3testDlg.cpp : implementation file
//

#include "stdafx.h"

#include <control.h> // for IVideoWindow

#include "t3test.h"
#include "t3testD.h"
#include "calldlg.h"
#include "callnot.h"
#include "uuids.h"
#include "autoans.h"
#include "confdlg.h"
#include "ilsdlg.h"
#include "rate.h"

#ifdef _DEBUG

#ifndef _WIN64 // mfc 4.2's heap debugging features generate warnings on win64
#define new DEBUG_NEW
#endif

#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

ITTAPI * gpTapi;
IConnectionPoint * gpCP;
HWND ghAddressesWnd;
HWND ghTerminalsWnd;
HWND ghMediaTypesWnd;
HWND ghCallsWnd;
HWND ghPhonesWnd;
HWND ghSelectedCallsWnd;
HWND ghSelectedWnd;
HWND ghCreatedWnd;
HWND ghClassesWnd;
HWND ghListenWnd;
HTREEITEM ghAddressesRoot;
HTREEITEM ghTerminalsRoot;
HTREEITEM ghMediaTypesRoot;
HTREEITEM ghCallsRoot;
HTREEITEM ghPhonesRoot;
HTREEITEM ghSelectedCallsRoot;
HTREEITEM ghSelectedRoot;
HTREEITEM ghCreatedRoot;
HTREEITEM ghClassesRoot;
HTREEITEM ghListenRoot;

#ifdef ENABLE_DIGIT_DETECTION_STUFF
CDigitDetectionNotification *   gpDigitNotification;
#endif // ENABLE_DIGIT_DETECTION_STUFF

long       gulAdvise;
BOOL gbUpdatingStuff = FALSE;
BOOL gfShuttingDown = FALSE;

DataPtrList       gDataPtrList;
extern CT3testApp theApp;

const BSTR TAPIMEDIATYPE_String_Audio = L"{028ED8C2-DC7A-11D0-8ED3-00C04FB6809F}";
const BSTR TAPIMEDIATYPE_String_Video = L"{028ED8C4-DC7A-11D0-8ED3-00C04FB6809F}";

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CT3testDlg dialog

CT3testDlg::CT3testDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CT3testDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CT3testDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CT3testDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CT3testDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CT3testDlg, CDialog)
	//{{AFX_MSG_MAP(CT3testDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_WM_DESTROY()
	ON_NOTIFY(TVN_SELCHANGED, IDC_ADDRESSES, OnSelchangedAddresses)
	ON_BN_CLICKED(IDC_ADDTERMINAL, OnAddterminal)
	ON_BN_CLICKED(IDC_REMOVETERMINAL, OnRemoveterminal)
	ON_BN_CLICKED(IDC_CREATECALL, OnCreatecall)
	ON_BN_CLICKED(IDC_CONNECT, OnConnect)
	ON_BN_CLICKED(IDC_DROP, OnDrop)
	ON_BN_CLICKED(IDC_ANSWER, OnAnswer)
	ON_BN_CLICKED(IDC_LISTEN, OnListen)
	ON_NOTIFY(TVN_SELCHANGED, IDC_CALLS, OnSelchangedCalls)
    ON_NOTIFY(TVN_SELCHANGED, IDC_PHONES, OnSelchangedPhones)
	ON_BN_CLICKED(IDC_RELEASE, OnRelease)
	ON_BN_CLICKED(IDC_CREATE, OnCreateTerminal)
	ON_BN_CLICKED(IDC_RELEASETERMINAL, OnReleaseterminal)
	ON_BN_CLICKED(IDC_ADDCREATED, OnAddcreated)
	ON_BN_CLICKED(IDC_ADDNULL, OnAddnull)
	ON_BN_CLICKED(IDC_ADDTOLISTEN, OnAddtolisten)
	ON_BN_CLICKED(IDC_LISTENALL, OnListenall)
    ON_BN_CLICKED(IDC_CONFIGAUTOANSWER, OnConfigAutoAnswer)
    ON_BN_CLICKED(IDC_ILS, OnILS)
    ON_BN_CLICKED(IDC_RATE, OnRate)
    ON_BN_CLICKED(IDC_OPENPHONE, OnOpenPhone)
    ON_BN_CLICKED(IDC_CLOSEPHONE, OnClosePhone)
    ON_BN_CLICKED(IDC_STARTTONE, OnStartTone)
    ON_BN_CLICKED(IDC_STOPTONE, OnStopTone)
    ON_BN_CLICKED(IDC_STARTRING, OnStartRing)
    ON_BN_CLICKED(IDC_STOPRING, OnStopRing)
    ON_BN_CLICKED(IDC_BUSYTONE, OnBusyTone)
    ON_BN_CLICKED(IDC_RINGBACKTONE, OnRingBackTone)
    ON_BN_CLICKED(IDC_ERRORTONE, OnErrorTone)
    ON_BN_CLICKED(IDC_PHONEAUTOON, OnPhoneAutoOn)
    ON_BN_CLICKED(IDC_PHONEAUTOOFF, OnPhoneAutoOff)
    ON_BN_CLICKED(IDC_PHONESPEAKERONHOOK, OnPhoneSpeakerOnHook)
    ON_BN_CLICKED(IDC_PHONESPEAKEROFFHOOK, OnPhoneSpeakerOffHook)
    ON_BN_CLICKED(IDC_SELECTCALL, OnSelectCall)
    ON_BN_CLICKED(IDC_UNSELECTCALL, OnUnselectCall)
	ON_NOTIFY(TVN_SELCHANGED, IDC_MEDIATYPES, OnSelchangedMediatypes)
	ON_NOTIFY(NM_RCLICK, IDC_SELECTEDTERMINALS, OnRclickSelectedterminals)

#ifdef ENABLE_DIGIT_DETECTION_STUFF
    ON_COMMAND(ID_GENERATE, OnGenerate)
    ON_COMMAND(ID_MODESUPPORTED, OnModesSupported)
    ON_COMMAND(ID_MODESUPPORTED2, OnModesSupported2)
    ON_COMMAND(ID_STARTDETECT, OnStartDetect)
    ON_COMMAND(ID_STOPDETECT, OnStopDetect)
#endif // ENABLE_DIGIT_DETECTION_STUFF
    
    ON_COMMAND(ID_PARK1, OnPark1)
    ON_COMMAND(ID_PARK2, OnPark2)
    ON_COMMAND(ID_HANDOFF1, OnHandoff1)
    ON_COMMAND(ID_HANDOFF2, OnHandoff2)
    ON_COMMAND(ID_UNPARK, OnUnpark)
    ON_COMMAND(ID_PICKUP1, OnPickup1)
    ON_COMMAND(ID_PICKUP2, OnPickup2)

    ON_WM_CLOSE()
    ON_MESSAGE(WM_USER+101, OnTapiEvent)
	ON_NOTIFY(NM_RCLICK, IDC_CALLS, OnRclickCalls)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CT3testDlg message handlers

BOOL CT3testDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon

    HRESULT     hr;


    //
    // coinit
    //
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    //hr = CoInitialize(NULL);

    if (hr != S_OK)
    {
        MessageBox(L"CoInitialize failed", MB_OK);

        return FALSE;
    }


    //
    // create the tapi object
    //
    hr = CoCreateInstance(
        CLSID_TAPI,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_ITTAPI,
        (LPVOID *)&gpTapi
        );

    if (hr != S_OK)
    {
        ::MessageBox(NULL, L"CoCreateInstance on TAPI failed", NULL, MB_OK);
        return TRUE;
    }

    //
    // initialize tapi
    //
    hr = gpTapi->Initialize();

    if (hr != S_OK)
    {
        ::MessageBox(NULL, L"TAPI initialize failed", NULL, MB_OK);
        gpTapi->Release();
        return TRUE;
    }


    // Set the Event filter to only give us only the events we process
    gpTapi->put_EventFilter(TE_CALLNOTIFICATION | \
                            TE_CALLSTATE        | \
                            TE_CALLHUB          | \
                            TE_CALLMEDIA        | \
                            TE_TAPIOBJECT       | \
                            TE_ADDRESS          | \
                            TE_PHONEEVENT );

    //
    // intialize the tree controls
    //
    InitializeTrees();

    //
    // intialize the address tree control
    //
    InitializeAddressTree();

    //
    // register the main event interface
    //
    RegisterEventInterface();

    //
    // register for call notification for
    // all addresses for outgoing calls
    //
    RegisterForCallNotifications();
    
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CT3testDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CT3testDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CT3testDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

void CT3testDlg::OnFinalRelease() 
{
	// TODO: Add your specialized code here and/or call the base class

	CDialog::OnFinalRelease();
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// SelectFirstItem
//
// selects the first item under the hroot node in hwnd.
// this is used to make sure that something is selected
// in the window at all times.
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::SelectFirstItem(
                                 HWND        hWnd,
                                 HTREEITEM   hRoot
                                )
{
    HTREEITEM           hChild;


    //
    // get the first item
    //
    hChild = TreeView_GetChild(
                               hWnd,
                               hRoot
                              );

    //
    // select it
    //
    TreeView_SelectItem(
                        hWnd,
                        hChild
                       );

}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// DeleteSelectedItem
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::DeleteSelectedItem(
                                    HWND hWnd
                                   )
{
    HTREEITEM           hItem;

    //
    // get current selections
    // 
    hItem = TreeView_GetSelection( hWnd );


    //
    // delete it
    //
    TreeView_DeleteItem(
                        hWnd,
                        hItem
                       );
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//  InitializeAddressTree
//      initialize the address tree control with
//      the address objects
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::InitializeAddressTree()
{
    IEnumAddress *      pEnumAddress;
    ITAddress *         pAddress;
    HTREEITEM           hChild;
    HRESULT             hr;
    long                l;
    DWORD               dwCount = 0;
    
    //
    // get the address enumerator
    //
    
    hr = gpTapi->EnumerateAddresses( &pEnumAddress );

    if (S_OK != hr)
    {
        gpTapi->Release();
        gpTapi = NULL;

        return;
    }

    //
    // go through all the address objects
    // and add them to the address treecontrol
    //

    while (TRUE)
    {
        AADATA * pData;
        
        hr = pEnumAddress->Next( 1, &pAddress, NULL );

        if (S_OK != hr)
        {
            break;
        }

        AddAddressToTree( pAddress );

        pAddress->Release();

        pData = (AADATA *)CoTaskMemAlloc( sizeof ( AADATA ) );
        pData->pAddress = pAddress;
        pData->pTerminalPtrList = new TerminalPtrList;
        
        gDataPtrList.push_back( pData );

        dwCount++;
    }

    //
    // release the enumerator
    //
    pEnumAddress->Release();

    //
    // select the first item
    //
    if (dwCount > 0)
    {
        SelectFirstItem(
                        ghAddressesWnd,
                        ghAddressesRoot
                       );
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// RegisterEventInterface
//
// registers the ITTAPIEventNotification interface
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CT3testDlg::RegisterEventInterface()
{
    CTAPIEventNotification *        pTAPIEventNotification;
    IConnectionPointContainer *     pCPC;
    IConnectionPoint *              pCP;
    IUnknown *                      pUnk;
    
    //
    // create the object
    //
    pTAPIEventNotification = new CTAPIEventNotification;


    //
    // get the connectionpointcontainer interface
    // from the tapi object
    //
    gpTapi->QueryInterface(
                           IID_IConnectionPointContainer,
                           (void **) &pCPC
                          );


    //
    // get the connectionpoint we are
    // looking for
    //
    pCPC->FindConnectionPoint(
                              IID_ITTAPIEventNotification,
                              &gpCP
                             );

    pCPC->Release();

    pTAPIEventNotification->QueryInterface(
                                           IID_IUnknown,
                                           (void **)&pUnk
                                          );

    //
    // call the advise method to tell tapi
    // about the interface
    //
    gpCP->Advise(
                 pUnk,
                 (ULONG *)&gulAdvise
                );


    //
    // release our reference to
    // it
    //
    pUnk->Release();
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// RegisterForCallNotifications
//
// registers for call state notifications for all
// addresses for outgoing calls
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::RegisterForCallNotifications()
{
    VARIANT                 var;

    var.vt = VT_ARRAY;
    var.parray = NULL;
    
    gpTapi->SetCallHubTracking(var, VARIANT_TRUE);
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// InitializeTrees
//
// Create and labels the tree controls
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::InitializeTrees()
{
    TV_INSERTSTRUCT tvi;

    tvi.hParent = TVI_ROOT;
    tvi.hInsertAfter = TVI_FIRST;
    tvi.item.mask = TVIF_TEXT;

    //
    // address tree
    //
    tvi.item.pszText = L"Addresses";

    ghAddressesWnd = GetDlgItem( IDC_ADDRESSES )->m_hWnd;
    ghAddressesRoot = TreeView_InsertItem(
                                          ghAddressesWnd,
                                          &tvi
                                         );

    //
    // mediatypes tree
    //
    tvi.item.pszText = L"MediaTypes";

    ghMediaTypesWnd = GetDlgItem( IDC_MEDIATYPES )->m_hWnd;
    ghMediaTypesRoot = TreeView_InsertItem(
                                          ghMediaTypesWnd,
                                          &tvi
                                         );

    //
    // terminals tree
    //
    tvi.item.pszText = L"Terminals";

    ghTerminalsWnd = GetDlgItem( IDC_TERMINALS )->m_hWnd;
    ghTerminalsRoot = TreeView_InsertItem(
                                          ghTerminalsWnd,
                                          &tvi
                                         );

    //
    // calls tree
    //
    tvi.item.pszText = L"Calls";
    
    ghCallsWnd = GetDlgItem( IDC_CALLS )->m_hWnd;
    ghCallsRoot = TreeView_InsertItem(
                                      ghCallsWnd,
                                      &tvi
                                     );

    //
    // phones tree
    //
    tvi.item.pszText = L"Phones";

    ghPhonesWnd = GetDlgItem( IDC_PHONES )->m_hWnd;
    ghPhonesRoot = TreeView_InsertItem(
                                          ghPhonesWnd,
                                          &tvi
                                         );

    //
    // selected calls tree
    //
    tvi.item.pszText = L"Selected Calls";
    
    ghSelectedCallsWnd = GetDlgItem( IDC_SELECTEDCALLS )->m_hWnd;
    ghSelectedCallsRoot = TreeView_InsertItem(
                                        ghSelectedCallsWnd,
                                        &tvi
                                       );

    //
    // selected media terminals tree
    //
    tvi.item.pszText = L"Selected Media Terminals";
    
    ghSelectedWnd = GetDlgItem( IDC_SELECTEDTERMINALS )->m_hWnd;
    ghSelectedRoot = TreeView_InsertItem(
                                        ghSelectedWnd,
                                        &tvi
                                       );

    //
    // dynamic terminal classes tree
    //
    tvi.item.pszText = L"Dynamic Terminal Classes";
    
    ghClassesWnd = GetDlgItem( IDC_DYNAMICCLASSES )->m_hWnd;
    ghClassesRoot = TreeView_InsertItem(
                                        ghClassesWnd,
                                        &tvi
                                       );

    //
    // created terminals tree
    //
    tvi.item.pszText = L"Created Terminals";
    
    ghCreatedWnd = GetDlgItem( IDC_CREATEDTERMINALS )->m_hWnd;
    ghCreatedRoot = TreeView_InsertItem(
                                        ghCreatedWnd,
                                        &tvi
                                       );

    //
    // listen mediatypes tree
    //
    tvi.item.pszText = L"Listen MediaTypes";
    
    ghListenWnd = GetDlgItem( IDC_LISTENMEDIAMODES )->m_hWnd;
    ghListenRoot = TreeView_InsertItem(
                                       ghListenWnd,
                                       &tvi
                                      );
    
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnDestroy
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnDestroy() 
{
	CDialog::OnDestroy();

    gfShuttingDown = TRUE;

    //
    // Release everything
    //
    ReleaseMediaTypes();
    ReleaseTerminals();
    ReleaseCalls();
    ReleasePhones();
    ReleaseSelectedTerminals();
    ReleaseSelectedCalls();
    ReleaseCreatedTerminals();
    ReleaseTerminalClasses();
    ReleaseListen();
    ReleaseAddresses();

    DataPtrList::iterator       iter, end;

    iter = gDataPtrList.begin();
    end  = gDataPtrList.end();
    
    for( ; iter != end; iter++ )
    {
        FreeData( *iter );

        delete (*iter)->pTerminalPtrList;
        
        CoTaskMemFree( *iter );
    }

    gDataPtrList.clear();
    

    if (NULL != gpCP)
    {
        gpCP->Unadvise(gulAdvise);
        gpCP->Release();
    }
    
    //
    // shutdown TAPI
    //
    if (NULL != gpTapi)
    {
        gpTapi->Shutdown();
        gpTapi->Release();
    }

}

void
DoAddressCapStuff(ITTAPI * pTapi);
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnSelChangedAddresses
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnSelchangedAddresses(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_TREEVIEW*            pNMTreeView = (NM_TREEVIEW*)pNMHDR;
    ITAddress *             pAddress;


	*pResult = 0;


    //
    // free all the stuff related to
    // the address selected.  this stuff
    // will all be refilled in
    //
    ReleaseMediaTypes();
    ReleaseListen();
    ReleaseCalls();
    ReleasePhones();
    ReleaseSelectedCalls();
    ReleaseSelectedTerminals();
    ReleaseCreatedTerminals();
    

    //
    // get the currently selected address
    //
    if (!GetAddress( &pAddress ))
    {
        return;
    }

    //
    // update these trees
    //
    if ( !gfShuttingDown )
    {
        UpdateMediaTypes( pAddress );
        UpdateCalls( pAddress );
        UpdatePhones( pAddress );
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnSelChangedPhones
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnSelchangedPhones(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_TREEVIEW*            pNMTreeView = (NM_TREEVIEW*)pNMHDR;
    ITPhone *               pPhone;


	*pResult = 0;


    //
    // free all the stuff related to
    // the phone selected.  this stuff
    // will all be refilled in
    //
    ReleaseSelectedCalls();
    

    //
    // get the currently selected phone
    //
    if (!GetPhone( &pPhone ))
    {
        return;
    }


    //
    // update these trees
    //
    if ( !gfShuttingDown )
    {
        UpdateSelectedCalls( pPhone );

    }
}

/////////////////////////////////////////////////////////////////
// IsVideoCaptureStream
//
// Returns true if the stream is for video capture
/////////////////////////////////////////////////////////////////

BOOL
CT3testDlg::IsVideoCaptureStream(
                     ITStream * pStream
                    )
{
    TERMINAL_DIRECTION tdStreamDirection;
    long               lStreamMediaType;

    if ( FAILED( pStream  ->get_Direction(&tdStreamDirection)   ) ) { return FALSE; }
    if ( FAILED( pStream  ->get_MediaType(&lStreamMediaType)    ) ) { return FALSE; }

    return (tdStreamDirection == TD_CAPTURE) &&
           (lStreamMediaType  == TAPIMEDIATYPE_VIDEO);
}

/////////////////////////////////////////////////////////////////
// EnablePreview
//
// Selects a video render terminal on a video capture stream,
// thereby enabling video preview.
/////////////////////////////////////////////////////////////////

HRESULT
CT3testDlg::EnablePreview(
              ITStream * pStream
             )
{
    ITTerminal * pTerminal;

    HRESULT hr = GetVideoRenderTerminal(&pTerminal);

    if ( SUCCEEDED(hr) )
    {
        hr = pStream->SelectTerminal(pTerminal);

        pTerminal->Release();
    }

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// SelectTerminalOnCall
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

HRESULT
CT3testDlg::SelectTerminalOnCall(
                ITTerminal * pTerminal,
                ITCallInfo * pCall
               )
{
    ITStreamControl *       pStreamControl;
    TERMINAL_DIRECTION      termtd;
    long                    lTermMediaType;
    HRESULT hr;

    pTerminal->get_Direction( &termtd );
    pTerminal->get_MediaType( &lTermMediaType );
    
    hr = pCall->QueryInterface(
                               IID_ITStreamControl,
                               (void**) &pStreamControl
                              );

    if ( SUCCEEDED(hr) )
    {
        IEnumStream * pEnumStreams;
        
        hr = pStreamControl->EnumerateStreams( &pEnumStreams );

        if ( SUCCEEDED(hr) )
        {
            while (TRUE)
            {
                ITStream              * pStream;
                long                    lMediaType;
                TERMINAL_DIRECTION      td;
                
                hr = pEnumStreams->Next( 1, &pStream, NULL );

                if ( S_OK != hr )
                {
                    hr = E_FAIL; // didn't select it anywhere
                    break;
                }

                pStream->get_MediaType( &lMediaType );
                pStream->get_Direction( &td );

                if ( ( lMediaType == lTermMediaType ) &&
                     ( td == termtd) )
                {
                    hr = pStream->SelectTerminal( pTerminal );

                    if ( FAILED(hr) )
                    {
                        ::MessageBox(NULL, L"SelectTerminals failed", NULL, MB_OK);
                    }
                    else
                    {
                        //
                        // Also enable preview on the video capture stream.
                        //

                        if ( IsVideoCaptureStream( pStream ) )
                        {
                            EnablePreview( pStream );
                        }

                        pStream->Release();
                        
                        break;
                    }
                }
                
                pStream->Release();
            }

            pEnumStreams->Release();
        }

        pStreamControl->Release();
    }

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnAddTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

void CT3testDlg::OnAddterminal() 
{
    ITCallInfo *            pCall;
    ITTerminal *            pTerminal;
    HRESULT                 hr = S_OK;

    //
    // get the selected call
    //
    if (!(GetCall( &pCall )))
    {
        return;
    }


    //
    // get the selected terminal
    //
    if (!(GetTerminal( &pTerminal )))
    {
        return;
    }

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"SelectTerminals failed", NULL, MB_OK);
        return;
    }
        
    hr = SelectTerminalOnCall(pTerminal, pCall);

    if ( FAILED(hr) )
    {
        return;
    }

    //
    // put the terminal in the
    // tree
    //
    AddSelectedTerminal(
                        pTerminal
                       );
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// RemovePreview
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

void CT3testDlg::RemovePreview( ITStream * pStream )
{
    //
    // This is a video capture stream and we've unselected the
    // video capture terminal. If there is a video render
    // terminal on the stream, then unselect it now.
    //

    IEnumTerminal * pEnum;

    if ( FAILED( pStream->EnumerateTerminals( &pEnum ) ) )
    {
        return;
    }

    ITTerminal * pTerminal;

    if ( S_OK == pEnum->Next(1, &pTerminal, NULL) )
    {
        pStream->UnselectTerminal( pTerminal );
        pTerminal->Release();
    }

    pEnum->Release();
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnRemoveTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnRemoveterminal() 
{
    ITTerminal *                pTerminal;
    ITCallInfo *                pCall;
    HTREEITEM                   hItem;
    HRESULT                     hr;
    ITBasicCallControl *        pBCC;

    

    //
    // get current call
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    //
    // get current terminal
    //
    if (!GetSelectedTerminal(&pTerminal))
    {
        return;
    }

    TERMINAL_DIRECTION termtd;
    long               lTermMediaType;

    pTerminal->get_Direction( &termtd );
    pTerminal->get_MediaType( &lTermMediaType );

    ITStreamControl * pStreamControl;
    
    hr = pCall->QueryInterface(
                               IID_ITStreamControl,
                               (void**) &pStreamControl
                              );

    BOOL bFound = FALSE;

    if ( SUCCEEDED(hr) )
    {
        IEnumStream * pEnumStreams;
        
        hr = pStreamControl->EnumerateStreams( &pEnumStreams );

        if ( SUCCEEDED(hr) )
        {
            while ( ! bFound )
            {
                ITStream              * pStream;
                long                    lMediaType;
                TERMINAL_DIRECTION      td;
                
                hr = pEnumStreams->Next( 1, &pStream, NULL );

                if ( S_OK != hr )
                {
                    break;
                }

                pStream->get_MediaType( &lMediaType );
                pStream->get_Direction( &td );

                if ( ( lMediaType == lTermMediaType ) &&
                     ( td == termtd) )
                {
                    hr = pStream->UnselectTerminal( pTerminal );

                    if ( !SUCCEEDED(hr) )
                    {
                        ::MessageBox(NULL, L"UnselectTerminals failed", NULL, MB_OK);
                    }
                    else
                    {
                        if ( IsVideoCaptureStream( pStream ) )
                        {
                            RemovePreview( pStream );
                        }

                        bFound = TRUE;
                    }

                }
                
                pStream->Release();
            }

            pEnumStreams->Release();
        }

        pStreamControl->Release();
    }


    if ( !bFound )
    {
        return;
    }

    //
    // remove it from tree
    //
    hItem = TreeView_GetSelection( ghSelectedWnd );
    TreeView_DeleteItem(
                        ghSelectedWnd,
                        hItem
                       );


    //
    // release tree's reference to
    // the terminal
    //
    pTerminal->Release();

	
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnCreateCall
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnCreatecall() 
{
    ITAddress *             pAddress;
    HRESULT                 hr;
    ITBasicCallControl *    pCall;
    ITCallInfo *            pCallInfo;
    BOOL                    bConference      = FALSE;
    BOOL                    lAddressType     = LINEADDRESSTYPE_PHONENUMBER;
    BSTR                    bstrDestAddress;
    ITAddressCapabilities * pAddressCaps;
    long                    lType = 0;
    ITMediaSupport *        pMediaSupport;
    long                    lSupportedMediaTypes, lMediaTypes = 0;
    
    //
    // get the current address
    //
    if (!GetAddress( &pAddress ))
    {
        return;
    }


    hr = pAddress->QueryInterface(IID_ITAddressCapabilities, (void**)&pAddressCaps);

    hr = pAddressCaps->get_AddressCapability( AC_ADDRESSTYPES, &lType );

    if ( SUCCEEDED(hr) && (LINEADDRESSTYPE_SDP & lType) )
    {
        bConference = TRUE;
        lAddressType = LINEADDRESSTYPE_SDP;
    }

    if ( SUCCEEDED(hr) && (LINEADDRESSTYPE_DOMAINNAME & lType) )
    {
        lAddressType = LINEADDRESSTYPE_DOMAINNAME;
    }

    pAddressCaps->Release();
    
    if ( !bConference )
    {
        //
        // create the dialog to get the
        // dial string
        //
        CCreateCallDlg Dlg( this );


        if (IDOK == Dlg.DoModal())
        {
            //
            // create a call with the
            // string input in the dialog
            //
            bstrDestAddress = SysAllocString( Dlg.m_pszDestAddress );
        }
        else
        {
            return;
        }
    }
    else
    {
        CConfDlg    Dlg;

        if ( IDOK == Dlg.DoModal() )
        {
            bstrDestAddress = Dlg.m_bstrDestAddress;
        }
        else
        {
            return;
        }
    }

    //
    // Find out if the address supports audio, video, or both.
    //

    pAddress->QueryInterface(
                             IID_ITMediaSupport,
                             (void**)&pMediaSupport
                            );

    pMediaSupport->get_MediaTypes( &lSupportedMediaTypes );
                                  
    pMediaSupport->Release();


    if ( lSupportedMediaTypes & TAPIMEDIATYPE_AUDIO )
    {
        lMediaTypes |= TAPIMEDIATYPE_AUDIO;
    }

    if ( lSupportedMediaTypes & TAPIMEDIATYPE_VIDEO )
    {
        lMediaTypes |= TAPIMEDIATYPE_VIDEO;
    }

    if ( lMediaTypes == 0 )
    {
        if ( lSupportedMediaTypes & TAPIMEDIATYPE_DATAMODEM )
        {
            lMediaTypes |= TAPIMEDIATYPE_DATAMODEM;
        }
    }

    //
    // Create the call.
    //

    hr = pAddress->CreateCall(
                              bstrDestAddress,
                              lAddressType,
                              lMediaTypes,
                              &pCall
                             );

    SysFreeString( bstrDestAddress );


    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"CreateCall failed", NULL, MB_OK);
        return;
    }

    //
    // get the callinfo interface
    //
    pCall->QueryInterface( IID_ITCallInfo, (void **)&pCallInfo );


    //
    // add the call to the tree
    //
    AddCall(pCallInfo);

    //
    // update the callinfo
    //
    UpdateCall( pCallInfo );


    //
    // release this inteface
    //
    pCallInfo->Release();

    //
    // note that we keep a global reference to the call
    // (CreateCall returns with a reference count of 1)
    // so the call does not get destroyed.  When we want
    // the call to actually be destroyed, then we
    // release twice.
    //
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnOpenPhone
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnOpenPhone() 
{
    ITPhone *                       pPhone;
    HRESULT                         hr = S_OK;

    //
    // get the current phone
    //
    if (!GetPhone( &pPhone))
    {
        return;
    }

    //
    // call connect
    //
    hr = pPhone->Open( PP_OWNER );

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"Open failed", NULL, MB_OK);
        return;
    }

    UpdatePhone( pPhone );
	
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnClosePhone
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnClosePhone() 
{
    ITPhone *                       pPhone;
    HRESULT                         hr = S_OK;

    //
    // get the current phone
    //
    if (!GetPhone( &pPhone))
    {
        return;
    }

    //
    // call connect
    //
    hr = pPhone->Close();

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"Close failed", NULL, MB_OK);
        return;
    }
	
    UpdatePhone( pPhone );
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnStartTone
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnStartTone() 
{
    ITPhone *                       pPhone;
    ITAutomatedPhoneControl *       pPhoneControl;
    HRESULT                         hr = S_OK;

    //
    // get the current phone
    //
    if (!GetPhone( &pPhone))
    {
        return;
    }

    //
    // get the automated phone control interface
    //
    hr = pPhone->QueryInterface(IID_ITAutomatedPhoneControl, (void **)&pPhoneControl);

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"QueryInterface failed", NULL, MB_OK);
        return;
    }

    //
    // call connect
    //
    hr = pPhoneControl->StartTone(PT_NORMALDIALTONE, 5000);

    pPhoneControl->Release();

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"StartTone failed", NULL, MB_OK);
        return;
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnBusyTone
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnBusyTone() 
{
    ITPhone *                       pPhone;
    ITAutomatedPhoneControl *       pPhoneControl;
    HRESULT                         hr = S_OK;

    //
    // get the current phone
    //
    if (!GetPhone( &pPhone))
    {
        return;
    }

    //
    // get the automated phone control interface
    //
    hr = pPhone->QueryInterface(IID_ITAutomatedPhoneControl, (void **)&pPhoneControl);

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"QueryInterface failed", NULL, MB_OK);
        return;
    }

    //
    // call connect
    //
    hr = pPhoneControl->StartTone(PT_BUSY, 10000);

    pPhoneControl->Release();

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"StartTone failed", NULL, MB_OK);
        return;
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnRingBackTone
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnRingBackTone() 
{
    ITPhone *                       pPhone;
    ITAutomatedPhoneControl *       pPhoneControl;
    HRESULT                         hr = S_OK;

    //
    // get the current phone
    //
    if (!GetPhone( &pPhone))
    {
        return;
    }

    //
    // get the automated phone control interface
    //
    hr = pPhone->QueryInterface(IID_ITAutomatedPhoneControl, (void **)&pPhoneControl);

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"QueryInterface failed", NULL, MB_OK);
        return;
    }

    //
    // call connect
    //
    hr = pPhoneControl->StartTone(PT_RINGBACK, 10000);

    pPhoneControl->Release();

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"StartTone failed", NULL, MB_OK);
        return;
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnErrorTone
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnErrorTone() 
{
    ITPhone *                       pPhone;
    ITAutomatedPhoneControl *       pPhoneControl;
    HRESULT                         hr = S_OK;

    //
    // get the current phone
    //
    if (!GetPhone( &pPhone))
    {
        return;
    }

    //
    // get the automated phone control interface
    //
    hr = pPhone->QueryInterface(IID_ITAutomatedPhoneControl, (void **)&pPhoneControl);

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"QueryInterface failed", NULL, MB_OK);
        return;
    }

    //
    // call connect
    //
    hr = pPhoneControl->StartTone(PT_ERRORTONE, 10000);

    pPhoneControl->Release();

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"StartTone failed", NULL, MB_OK);
        return;
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnStopTone
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnStopTone() 
{
    ITPhone *                       pPhone;
    ITAutomatedPhoneControl *       pPhoneControl;
    HRESULT                         hr = S_OK;

    //
    // get the current phone
    //
    if (!GetPhone( &pPhone))
    {
        return;
    }

    //
    // get the automated phone control interface
    //
    hr = pPhone->QueryInterface(IID_ITAutomatedPhoneControl, (void **)&pPhoneControl);

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"QueryInterface failed", NULL, MB_OK);
        return;
    }

    //
    // call connect
    //
    hr = pPhoneControl->StopTone();

    pPhoneControl->Release();

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"StopTone failed", NULL, MB_OK);
        return;
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnSelectCall
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnSelectCall() 
{
    ITPhone *                       pPhone;
    ITAutomatedPhoneControl *       pPhoneControl;
    ITCallInfo *                    pCall;
    HRESULT                         hr = S_OK;

    //
    // get the current phone
    //
    if (!GetPhone( &pPhone))
    {
        return;
    }

    //
    // get the current call
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    //
    // get the automated phone control interface
    //
    hr = pPhone->QueryInterface(IID_ITAutomatedPhoneControl, (void **)&pPhoneControl);

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"QueryInterface failed", NULL, MB_OK);
        return;
    }

    hr = pPhoneControl->SelectCall( pCall, VARIANT_TRUE );

    pPhoneControl->Release();

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"OnSelectCall failed", NULL, MB_OK);
        return;
    }

    //
    // put the call in the
    // tree
    //
    AddSelectedCall(
                        pCall
                       );

    //
    // add the selected terminals to the tree
    //
    ITTerminal *    pTerminal;
    IEnumTerminal * pEnum;
    ITAddress *     pAddress;

    if (!GetAddress( &pAddress ))
    {
        return;
    }

    if ( FAILED( pPhone->EnumerateTerminals( pAddress, &pEnum ) ) )
    {
        return;
    }

    while ( S_OK == pEnum->Next(1, &pTerminal, NULL) )
    {
        AddSelectedTerminal( pTerminal );
        pTerminal->Release();
    }

    pEnum->Release();
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnUnselectCall
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnUnselectCall() 
{
    ITPhone *                       pPhone;
    ITAutomatedPhoneControl *       pPhoneControl;
    ITCallInfo *                    pCall;
    HRESULT                         hr = S_OK;
    HTREEITEM                       hItem;

    //
    // get the current phone
    //
    if (!GetPhone( &pPhone))
    {
        return;
    }

    //
    // get the selected call
    //
    if (!GetSelectedCall( &pCall ))
    {
        return;
    }

    //
    // get the automated phone control interface
    //
    hr = pPhone->QueryInterface(IID_ITAutomatedPhoneControl, (void **)&pPhoneControl);

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"QueryInterface failed", NULL, MB_OK);
        return;
    }

    hr = pPhoneControl->UnselectCall( pCall );

    pPhoneControl->Release();

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"OnUnselectCall failed", NULL, MB_OK);
        return;
    }

    //
    // remove it from tree
    //
    hItem = TreeView_GetSelection( ghSelectedCallsWnd );
    TreeView_DeleteItem(
                        ghSelectedCallsWnd,
                        hItem
                       );


    //
    // release tree's reference to
    // the terminal
    //
    pCall->Release();  
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnPhoneAutoOn
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnPhoneAutoOn() 
{
    ITPhone *                       pPhone;
    ITAutomatedPhoneControl *       pPhoneControl;
    HRESULT                         hr = S_OK;

    //
    // get the current phone
    //
    if (!GetPhone( &pPhone))
    {
        return;
    }

    //
    // get the automated phone control interface
    //
    hr = pPhone->QueryInterface(IID_ITAutomatedPhoneControl, (void **)&pPhoneControl);

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"QueryInterface failed", NULL, MB_OK);
        return;
    }

    hr = pPhoneControl->put_PhoneHandlingEnabled(VARIANT_TRUE);

    pPhoneControl->Release();

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"OnPhoneAutoOn failed", NULL, MB_OK);
        return;
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnPhoneAutoOff
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnPhoneAutoOff() 
{
    ITPhone *                       pPhone;
    ITAutomatedPhoneControl *       pPhoneControl;
    HRESULT                         hr = S_OK;

    //
    // get the current phone
    //
    if (!GetPhone( &pPhone))
    {
        return;
    }

    //
    // get the automated phone control interface
    //
    hr = pPhone->QueryInterface(IID_ITAutomatedPhoneControl, (void **)&pPhoneControl);

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"QueryInterface failed", NULL, MB_OK);
        return;
    }

    hr = pPhoneControl->put_PhoneHandlingEnabled(VARIANT_FALSE);

    pPhoneControl->Release();

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"OnPhoneAutoOff failed", NULL, MB_OK);
        return;
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnPhoneSpeakerOnHook
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnPhoneSpeakerOnHook() 
{
    ITPhone *                       pPhone;
    ITAutomatedPhoneControl *       pPhoneControl;
    HRESULT                         hr = S_OK;

    //
    // get the current phone
    //
    if (!GetPhone( &pPhone))
    {
        return;
    }

    hr = pPhone->put_HookSwitchState( PHSD_SPEAKERPHONE, PHSS_ONHOOK );

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"OnPhoneSpeakerOnHook failed", NULL, MB_OK);
        return;
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnPhoneSpeakerOffHook
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnPhoneSpeakerOffHook() 
{
    ITPhone *                       pPhone;
    ITAutomatedPhoneControl *       pPhoneControl;
    HRESULT                         hr = S_OK;

    //
    // get the current phone
    //
    if (!GetPhone( &pPhone))
    {
        return;
    }

    hr = pPhone->put_HookSwitchState( PHSD_SPEAKERPHONE, PHSS_OFFHOOK );

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"OnPhoneSpeakerOffHook failed", NULL, MB_OK);
        return;
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnStartRing
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnStartRing() 
{
    ITPhone *                       pPhone;
    ITAutomatedPhoneControl *       pPhoneControl;
    HRESULT                         hr = S_OK;

    //
    // get the current phone
    //
    if (!GetPhone( &pPhone))
    {
        return;
    }

    //
    // get the automated phone control interface
    //
    hr = pPhone->QueryInterface(IID_ITAutomatedPhoneControl, (void **)&pPhoneControl);

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"QueryInterface failed", NULL, MB_OK);
        return;
    }

    //
    // call connect
    //
    hr = pPhoneControl->StartRinger(0, 0);

    pPhoneControl->Release();

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"StartRing failed", NULL, MB_OK);
        return;
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnStopRing
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnStopRing() 
{
    ITPhone *                       pPhone;
    ITAutomatedPhoneControl *       pPhoneControl;
    HRESULT                         hr = S_OK;

    //
    // get the current phone
    //
    if (!GetPhone( &pPhone))
    {
        return;
    }

    //
    // get the automated phone control interface
    //
    hr = pPhone->QueryInterface(IID_ITAutomatedPhoneControl, (void **)&pPhoneControl);

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"QueryInterface failed", NULL, MB_OK);
        return;
    }

    //
    // call connect
    //
    hr = pPhoneControl->StopRinger();

    pPhoneControl->Release();

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"StopRing failed", NULL, MB_OK);
        return;
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnConnect
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnConnect() 
{
    ITBasicCallControl *            pCall;
    ITCallInfo *                    pCallInfo;
    HRESULT                         hr = S_OK;


    //
    // get the current call
    //
    if (!GetCall( &pCallInfo))
    {
        return;
    }

    //
    // get the call control interface
    //
    hr = pCallInfo->QueryInterface(IID_ITBasicCallControl, (void **)&pCall);
    
    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"Connect failed", NULL, MB_OK);
        return;
    }


    //
    // call connect
    //
    hr = pCall->Connect( FALSE );


    //
    // release this interface
    //
    pCall->Release();

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"Connect failed", NULL, MB_OK);
        return;
    }
	
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnDrop
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnDrop() 
{
    ITBasicCallControl *        pCall;
    ITCallInfo *                pCallInfo;
    HRESULT                     hr =    S_OK;


    //
    // get the current call
    //
    if (!GetCall( &pCallInfo ))
    {
        return;
    }

    //
    // get the bcc interface
    //
    hr = pCallInfo->QueryInterface(
                                   IID_ITBasicCallControl,
                                   (void **)&pCall
                                  );

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"Disconnect failed", NULL, MB_OK);
        return;
    }


    //
    // call disconnect
    //
    hr = pCall->Disconnect( DC_NORMAL );

    //
    // release this reference
    //
    pCall->Release();

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"Disconnect failed", NULL, MB_OK);
    }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnDrop
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnAnswer() 
{
    ITCallInfo *                pCallInfo;
    ITBasicCallControl *        pCall;
    HRESULT                     hr = S_OK;


    //
    // get the current call
    //
    if (!GetCall( &pCallInfo))
    {
        return;
    }

    //
    // get the bcc interface
    //
    hr = pCallInfo->QueryInterface(IID_ITBasicCallControl, (void **)&pCall);
    
    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"Answer failed", NULL, MB_OK);
        return;
    }

    //
    // answer it
    //
    hr = pCall->Answer( );

    //
    // release this interface
    //
    pCall->Release();

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"Answer failed", NULL, MB_OK);
    }
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnListen
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnListen() 
{
    ITAddress *             pAddress;
    HRESULT                 hr = S_OK;
    DWORD                   dwCookie;
    HTREEITEM               hItem;
    long                    ulRegister;
    DWORD                   dwMediaMode = 0;


    //
    // get the current address
    //
    if (!GetAddress( &pAddress ))
    {
        return;
    }


    hItem = TreeView_GetChild(
                              ghListenWnd,
                              ghListenRoot
                             );

    while (NULL != hItem)
    {
        TV_ITEM item;

        item.mask = TVIF_HANDLE | TVIF_PARAM;
        item.hItem = hItem;

        //
        // get it
        //
        TreeView_GetItem(
                         ghListenWnd,
                         &item
                        );

        dwMediaMode |= (DWORD)(item.lParam);

        hItem = TreeView_GetNextSibling(
                                        ghAddressesWnd,
                                        hItem
                                       );

    }

    hr = gpTapi->RegisterCallNotifications(
                                           pAddress,
                                           VARIANT_TRUE,
                                           VARIANT_TRUE,
                                           (long)dwMediaMode,
                                           gulAdvise,
                                           &ulRegister
                                          );

    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"RegisterCallNotifications failed", NULL, MB_OK);
    }

    //
    // release all the mediatypes
    // in the listen tree
    //
    ReleaseListen();
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnSelChangedCalls
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnSelchangedCalls(NMHDR* pNMHDR, LRESULT* pResult) 
{
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnRelease()
//
// this is called to release all references to a call
//
// if a call is selected it has two references - once for
// the tree control, and once for our global reference.
// release both here.
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnRelease() 
{
    ITCallInfo *        pCallInfo;


    //
    // get the call
    //
    if (!GetCall( &pCallInfo ))
    {
        return;
    }

    //
    // these depend on the call,
    // so release them
    //
    ReleaseSelectedTerminals();
    ReleaseCreatedTerminals();

    //
    // delete it from the tree
    //
    DeleteSelectedItem(
                       ghCallsWnd
                      );

    //
    // release once for the tree view
    //
    pCallInfo->Release();

    //
    // release a second time for our global reference
    //
    pCallInfo->Release();

}

void
CT3testDlg::HelpCreateTerminal(
                               ITTerminalSupport * pTerminalSupport,
                               BSTR bstrClass,
                               long lMediaType,
                               TERMINAL_DIRECTION dir
                              )
{
    ITTerminal * pTerminal;
    HRESULT         hr;
    
    //
    // create it
    //
    hr = pTerminalSupport->CreateTerminal(
                                          bstrClass,
                                          lMediaType,
                                          dir,
                                          &pTerminal
                                         );

    if (S_OK != hr)
    {
        return;
    }

    // 
    // ZoltanS:
    // We do nothing special with our video windows. Just make them visible
    // all the time. If this isn't a video window we just skip this step.
    //

    IVideoWindow * pWindow;

    if ( SUCCEEDED( pTerminal->QueryInterface(IID_IVideoWindow,
                                              (void **) &pWindow) ) )
    {
        pWindow->put_AutoShow( VARIANT_TRUE );

        pWindow->Release();
    }


    //
    // add the terminal
    //
    AddCreatedTerminal(
                       pTerminal
                      );


    //
    // release our reference
    //
    pTerminal->Release();    
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// GetVideoRenderTerminal
//
// this is used to create a video render terminal for preview
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

HRESULT CT3testDlg::GetVideoRenderTerminal(ITTerminal ** ppTerminal) 
{
    //
    // Get the current address
    //

    ITAddress * pAddress;

    if (!GetAddress( &pAddress ))
    {
        return E_FAIL;
    }

    //
    // get the terminal support interface
    //

    ITTerminalSupport * pTerminalSupport;
    HRESULT hr;

    hr = pAddress->QueryInterface(
                                  IID_ITTerminalSupport,
                                  (void **) &pTerminalSupport
                                 );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // Construct a BSTR for the correct IID.
    //

    LPOLESTR            lpTerminalClass;

    hr = StringFromIID(CLSID_VideoWindowTerm,
                       &lpTerminalClass);

    BSTR                bstrTerminalClass;

    if ( FAILED(hr) )
    {
        pTerminalSupport->Release();
        return hr;
    }

    bstrTerminalClass = SysAllocString ( lpTerminalClass );

    CoTaskMemFree( lpTerminalClass );

    if ( bstrTerminalClass == NULL )
    {
        pTerminalSupport->Release();
        return E_OUTOFMEMORY;
    }
    
    //
    // create it
    //

    hr = pTerminalSupport->CreateTerminal(
                                          bstrTerminalClass,
                                          TAPIMEDIATYPE_VIDEO,
                                          TD_RENDER,
                                          ppTerminal
                                         );

    pTerminalSupport->Release();

    if ( FAILED(hr) )
    {
        *ppTerminal = NULL;
        return hr;
    }

    // 
    // We do nothing special with our video windows. Just make them visible
    // all the time.
    //

    IVideoWindow * pWindow;

    if ( FAILED( (*ppTerminal)->QueryInterface(IID_IVideoWindow,
                                               (void **) &pWindow) ) )
    {
        (*ppTerminal)->Release();
        *ppTerminal = NULL;

        return hr;
    }

    pWindow->put_AutoShow( VARIANT_TRUE );

    pWindow->Release();

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnCreateTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnCreateTerminal() 
{
    //
    // Get the selected media type.
    //

    long lMediaType;

    if (!GetMediaType( &lMediaType ))
    {
        return;
    }

    //
    // Get the current address
    //

    ITAddress * pAddress;

    if (!GetAddress( &pAddress ))
    {
        return;
    }

    //
    // Get the selected terminal class.
    //

    BSTR bstrClass;

    if (!GetTerminalClass( &bstrClass ))
    {
        return;
    }

    //
    // get the terminal support interface
    //

    ITTerminalSupport * pTerminalSupport;
    HRESULT hr;

    hr = pAddress->QueryInterface(
                                  IID_ITTerminalSupport,
                                  (void **) &pTerminalSupport
                                 );

    if ( FAILED(hr) )
    {
        SysFreeString( bstrClass );
        return;
    }

    //
    // Convert the terminal class from a BSTR to an IID.
    //

    IID iidTerminalClass;

    IIDFromString(
                bstrClass,
                &iidTerminalClass
               );

    //
    // Create and add the terminal.
    //

    if ( CLSID_VideoWindowTerm == iidTerminalClass )
    {
        HelpCreateTerminal(
                           pTerminalSupport,
                           bstrClass,
                           lMediaType,
                           TD_RENDER
                          );
    }

    //
    // Release references.
    //

    pTerminalSupport->Release();

    SysFreeString(bstrClass);
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnReleaseTerminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnReleaseterminal() 
{
    ITTerminal * pTerminal;

    //
    // get the terminal
    //
    if (GetCreatedTerminal( &pTerminal ))
    {
        //
        // and release it!
        //
        pTerminal->Release();

        //
        // delete it from the tree
        //
        DeleteSelectedItem(
                           ghCreatedWnd
                          );
    }
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnAddCreated
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnAddcreated() 
{
    ITTerminal *            pTerminal;
    ITCallInfo *            pCall;
    HRESULT                 hr = S_OK;
    ITBasicCallControl *    pBCC;
    

    //
    // get the current call
    //

    if (!(GetCall( &pCall )))
    {
        return;
    }

    //
    // GetCreatedTerminal
    //

    if (!GetCreatedTerminal( &pTerminal ))
    {
        return;
    }

    //
    // Select the terminal on the call.
    //

    hr = SelectTerminalOnCall(pTerminal, pCall);

    if ( FAILED(hr) )
    {
        ::MessageBox(NULL, L"SelectTerminals failed", NULL, MB_OK);
        return;
    }

    //
    // add to the selected window
    //

    AddSelectedTerminal(
                        pTerminal
                       );

    //
    // delete from the created window
    //

    DeleteSelectedItem(
                       ghCreatedWnd
                      );

    //
    // release because there was a reference to
    // this terminal in the created wnd
    //

    pTerminal->Release();
    return;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnAddNull
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

void CT3testDlg::OnAddnull() 
{
    return;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnAddToListen
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

void CT3testDlg::OnAddtolisten() 
{
    long lMediaType;

    //
    // get the current mediatype
    //
    if (!GetMediaType( &lMediaType ))
    {
        return;
    }

    //
    // add it
    //
    AddListen( lMediaType );
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnListenAll
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnListenall() 
{
    ITAddress *             pAddress;
    HRESULT                 hr = S_OK;
    long                    ulRegister;
    long                    lMediaType;
    ITMediaSupport        * pMediaSupport;
    
    //
    // get the currently selected address
    //
    if (!GetAddress( &pAddress ))
    {
        return;
    }

    pAddress->QueryInterface(
                             IID_ITMediaSupport,
                             (void **)&pMediaSupport
                            );
    
    pMediaSupport->get_MediaTypes( &lMediaType );
    
    //
    // register
    //
    gpTapi->RegisterCallNotifications(
                                      pAddress,
                                      TRUE,
                                      TRUE,
                                      lMediaType,
                                      gulAdvise,
                                      &ulRegister
                                     );

    
    if (S_OK != hr)
    {
        ::MessageBox(NULL, L"RegisterCallTypes failed", NULL, MB_OK);
    }

	
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// OnSelChangedMedia
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void CT3testDlg::OnSelchangedMediatypes(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_TREEVIEW*            pNMTreeView = (NM_TREEVIEW*)pNMHDR;
    long                    lMediaType;
    ITAddress *             pAddress;
    HRESULT                 hr;

	*pResult = 0;

    if (gbUpdatingStuff)
        return;

    //
    // get the current mediatype
    //
    if (!GetMediaType( &lMediaType ))
    {
        return;
    }

    //
    // get the current address
    //
    if (!GetAddress( &pAddress ))
    {
        return;
    }

    //
    // we only show terminals that relate
    // to the selected mediatype
    // so get rid of the old ones
    //
    ReleaseTerminals();
    ReleaseTerminalClasses();

    UpdateTerminals( pAddress, lMediaType );
    UpdateTerminalClasses( pAddress, lMediaType );
    
}

void CT3testDlg::OnRclickSelectedterminals(NMHDR* pNMHDR, LRESULT* pResult) 
{
    POINT                   pt;
    HTREEITEM               hItem;
    TV_HITTESTINFO          hittestinfo;
    RECT                    rc;

    
    *pResult = 0;

    //
    // get the location of the cursor
    //
    GetCursorPos( &pt );

    //
    // get the control's window
    //
    ::GetWindowRect(
                    ghSelectedWnd,
                    &rc
                   );

    //
    // adjust the point to
    // the child's coords
    //
    hittestinfo.pt.x = pt.x - rc.left;
    hittestinfo.pt.y = pt.y - rc.top;


    //
    // hittest to get the tree view item
    //
    hItem = TreeView_HitTest(
                             ghSelectedWnd,
                             &hittestinfo
                            );


    //
    // only display a menu if the mouse is actually
    // over the item (TVHT_ONITEM)
    //
    if (hItem == NULL || (!(hittestinfo.flags & TVHT_ONITEM)) )
    {
        return;
    }


    //
    // select that item (right clicking will not select
    // by default
    //
    TreeView_Select(
                    ghSelectedWnd,
                    hItem,
                    TVGN_CARET
                   );

    CreateSelectedTerminalMenu(
                               pt,
                               m_hWnd
                              );
}


#ifdef ENABLE_DIGIT_DETECTION_STUFF

void CT3testDlg::OnModesSupported()
{
	ITTerminal *                    pTerminal;
    ITDigitGenerationTerminal *     pDigitGeneration;
    HRESULT                         hr = S_OK;
    LONG                            lDigits;

    
    if (!GetSelectedTerminal(&pTerminal))
    {
        return;
    }

    hr = pTerminal->QueryInterface(
                                   IID_ITDigitGenerationTerminal,
                                   (void **) &pDigitGeneration
                                  );

    if (!SUCCEEDED(hr))
    {
        return;
    }

    pDigitGeneration->get_ModesSupported( &lDigits );

    pDigitGeneration->Release();
}


void CT3testDlg::OnGenerate()
{
	ITTerminal *                    pTerminal;
    ITDigitGenerationTerminal *     pDigitGeneration;
    HRESULT                         hr = S_OK;


    
    if (!GetSelectedTerminal(&pTerminal))
    {
        return;
    }

    hr = pTerminal->QueryInterface(
                                   IID_ITDigitGenerationTerminal,
                                   (void **) &pDigitGeneration
                                  );

    if (!SUCCEEDED(hr))
    {
        return;
    }

    hr = pDigitGeneration->Generate(
                                    L"12345",
                                    LINEDIGITMODE_DTMF
                                   );

    pDigitGeneration->Release();
}

void CT3testDlg::OnModesSupported2()
{
	ITTerminal *                    pTerminal;
    ITDigitDetectionTerminal *      pDigitDetection;
    HRESULT                         hr = S_OK;
    LONG                            lDigits;

    
    if (!GetSelectedTerminal(&pTerminal))
    {
        return;
    }

    hr = pTerminal->QueryInterface(
                                   IID_ITDigitDetectionTerminal,
                                   (void **) &pDigitDetection
                                  );

    if (!SUCCEEDED(hr))
    {
        return;
    }

    pDigitDetection->get_ModesSupported( &lDigits );

    pDigitDetection->Release();
}

void CT3testDlg::OnStartDetect()
{
	ITTerminal *                    pTerminal;
    ITDigitDetectionTerminal *      pDigitDetection;
    HRESULT                         hr = S_OK;
    LONG                            lDigits;
    ULONG                           ulAdvise;
    IConnectionPointContainer *     pCPC;
    IConnectionPoint *              pCP;
    
    if (!GetSelectedTerminal(&pTerminal))
    {
        return;
    }

    hr = pTerminal->QueryInterface(
                                   IID_ITDigitDetectionTerminal,
                                   (void **) &pDigitDetection
                                  );

    if (!SUCCEEDED(hr))
    {
        return;
    }


    hr = pTerminal->QueryInterface(
                                   IID_IConnectionPointContainer,
                                   (void **)&pCPC
                                  );

    if (!SUCCEEDED(hr))
    {
        pDigitDetection->Release();
        return;
    }

    gpDigitNotification = new CDigitDetectionNotification;
    
    hr = pCPC->FindConnectionPoint(
                                   IID_ITDigitDetectionNotification,
                                   &pCP
                                  );

    pCPC->Release();

    IUnknown * pUnk;
    
    gpDigitNotification->QueryInterface(
                                        IID_IUnknown,
                                        (void**)&pUnk
                                       );
    
    hr = pCP->Advise(
                     pUnk,
                     &ulAdvise
                    );

    pUnk->Release();
    
    pCP->Release();
    
    pDigitDetection->StartDetect(LINEDIGITMODE_DTMF);

    pDigitDetection->Release();
}

void CT3testDlg::OnStopDetect()
{
	ITTerminal *                    pTerminal;
    ITDigitDetectionTerminal *      pDigitDetection;
    HRESULT                         hr = S_OK;
    LONG                            lDigits;

    
    if (!GetSelectedTerminal(&pTerminal))
    {
        return;
    }

    hr = pTerminal->QueryInterface(
                                   IID_ITDigitDetectionTerminal,
                                   (void **) &pDigitDetection
                                  );

    if (!SUCCEEDED(hr))
    {
        return;
    }

    pDigitDetection->StopDetect();

    pDigitDetection->Release();
}

#endif // ENABLE_DIGIT_DETECTION_STUFF



void CT3testDlg::OnRclickCalls(NMHDR* pNMHDR, LRESULT* pResult) 
{
    POINT                   pt;
    HTREEITEM               hItem;
    TV_HITTESTINFO          hittestinfo;
    RECT                    rc;

    
    *pResult = 0;

    //
    // get the location of the cursor
    //
    GetCursorPos( &pt );

    //
    // get the control's window
    //
    ::GetWindowRect(
                    ghCallsWnd,
                    &rc
                   );

    //
    // adjust the point to
    // the child's coords
    //
    hittestinfo.pt.x = pt.x - rc.left;
    hittestinfo.pt.y = pt.y - rc.top;


    //
    // hittest to get the tree view item
    //
    hItem = TreeView_HitTest(
                             ghCallsWnd,
                             &hittestinfo
                            );


    //
    // only display a menu if the mouse is actually
    // over the item (TVHT_ONITEM)
    //
    if (hItem == NULL || (!(hittestinfo.flags & TVHT_ONITEM)) )
    {
        return;
    }


    //
    // select that item (right clicking will not select
    // by default
    //
    TreeView_Select(
                    ghCallsWnd,
                    hItem,
                    TVGN_CARET
                   );

}

void CT3testDlg::OnConfigAutoAnswer()
{
    ITAddress * pAddress;
    autoans dlg;
    DataPtrList::iterator   dataiter, dataend;
    
    if (!GetAddress( &pAddress ) )
    {
        return;
    }

    dataiter = gDataPtrList.begin();
    dataend  = gDataPtrList.end();

    for ( ; dataiter != dataend; dataiter++ )
    {
        if ( pAddress == (*dataiter)->pAddress )
        {
            break;
        }
    }

    if ( dataiter == dataend )
    {
        return;
    }

    FreeData( (*dataiter) );
    
    if (IDOK == dlg.DoModal())
    {
        TerminalPtrList::iterator       iter, end;
        DWORD                           dwCount;
        long                            lRegister;
        HRESULT                         hr;
        long                            lMediaType = 0;
        
        dwCount = dlg.m_TerminalPtrList.size();

        if ( 0 == dwCount )
        {
            return;
        }
        
        iter = dlg.m_TerminalPtrList.begin();
        end  = dlg.m_TerminalPtrList.end();
        
        for ( ; iter != end ; iter++ )
        {
            long        l;
            
            (*dataiter)->pTerminalPtrList->push_back( *iter );

            if ( NULL != (*iter) )
            {
                (*iter)->get_MediaType( &l );
                lMediaType |= l;
            }
            else
            {
                lMediaType |= (long)LINEMEDIAMODE_VIDEO;
            }

        }

        //
        // call register call types
        //
        hr = gpTapi->RegisterCallNotifications(
                                               pAddress,
                                               VARIANT_FALSE,
                                               VARIANT_TRUE,
                                               lMediaType,
                                               0,
                                               &lRegister
                                              );

    }

}
void CT3testDlg::FreeData( AADATA * pData )
{
    TerminalPtrList::iterator       iter, end;

    iter = pData->pTerminalPtrList->begin();
    end  = pData->pTerminalPtrList->end();

    for ( ; iter != end; iter++ )
    {
        if ( NULL != (*iter) )
        {
            (*iter)->Release();
        }
    }

    pData->pTerminalPtrList->clear();
}

void CT3testDlg::OnClose() 
{
	CDialog::OnClose();
}


void CT3testDlg::OnILS()
{
    CILSDlg dlg;

    if (IDOK == dlg.DoModal())
    {
    }
    
}

void CT3testDlg::OnRate()
{
    CRateDlg dlg;
    ITCallInfo * pCallInfo;

    if ( !GetCall( &pCallInfo ) )
    {
        return;
    }

    if (IDOK == dlg.DoModal() )
    {
        pCallInfo->put_CallInfoLong(CIL_MINRATE, dlg.m_dwMinRate );
        pCallInfo->put_CallInfoLong(CIL_MAXRATE, dlg.m_dwMaxRate );
    }
}

void CT3testDlg::OnPark1()
{
    ITCallInfo              * pCall;
    ITBasicCallControl      * pBCC;
    HRESULT                 hr;
    
    //
    // get the call in question
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    pCall->QueryInterface(
                          IID_ITBasicCallControl,
                          (void**)&pBCC
                         );
    
    hr = pBCC->ParkDirect( L"101");
    
    pBCC->Release();

}
void CT3testDlg::OnPark2()
{
    ITCallInfo              * pCall;
    ITBasicCallControl      * pBCC;
    HRESULT                 hr;
    BSTR                    pAddress;

    
    //
    // get the call in question
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    pCall->QueryInterface(
                          IID_ITBasicCallControl,
                          (void **)&pBCC
                         );

    hr = pBCC->ParkIndirect( &pAddress );

    SysFreeString( pAddress );

    pBCC->Release();
    

}
void CT3testDlg::OnHandoff1()
{
    ITCallInfo              * pCall;
    ITBasicCallControl      * pBCC;
    HRESULT                 hr;

    //
    // get the call in question
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    pCall->QueryInterface(
                          IID_ITBasicCallControl,
                          (void **)&pBCC
                         );

    pBCC->HandoffDirect( L"tb20.exe" );

    pBCC->Release();
    
}
void CT3testDlg::OnHandoff2()
{
    ITCallInfo              * pCall;
    ITBasicCallControl      * pBCC;
    HRESULT                 hr;


    //
    // get the call in question
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    pCall->QueryInterface(
                          IID_ITBasicCallControl,
                          (void **)&pBCC
                         );

    pBCC->HandoffIndirect( TAPIMEDIATYPE_AUDIO );

    pBCC->Release();

}
void CT3testDlg::OnUnpark()
{
    ITCallInfo              * pCall;
    ITBasicCallControl      * pBCC;
    HRESULT                 hr;

    //
    // get the call in question
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    pCall->QueryInterface(
                          IID_ITBasicCallControl,
                          (void **)&pBCC
                         );


    pBCC->Unpark();

    pBCC->Release();
    
}
void CT3testDlg::OnPickup1()
{
    ITCallInfo              * pCall;
    ITBasicCallControl      * pBCC;
    HRESULT                 hr;

    //
    // get the call in question
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    pCall->QueryInterface(
                          IID_ITBasicCallControl,
                          (void **)&pBCC
                         );


    pBCC->Pickup( NULL );

    pBCC->Release();
}
void CT3testDlg::OnPickup2()
{
    ITCallInfo              * pCall;
    ITBasicCallControl      * pBCC;
    HRESULT                 hr;

    //
    // get the call in question
    //
    if (!GetCall( &pCall ))
    {
        return;
    }

    pCall->QueryInterface(
                          IID_ITBasicCallControl,
                          (void **)&pBCC
                         );


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\callcont\callcont.c ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/callcont.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.208.1.6  $
 *	$Date:   30 Jun 1997 18:21:36  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#define CALL_CONTROL_EXPORT

#pragma warning ( disable : 4057 4100 4115 4201 4214)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#pragma warning ( default : 4115 4201 4214)
#include "apierror.h"
#include "incommon.h"
#include "callcont.h"
#ifdef FORCE_SERIALIZE_CALL_CONTROL
#include "cclock.h"
#endif // FORCE_SERIALIZE_CALL_CONTROL
#include "q931.h"
#include "ccmain.h"
#include "confman.h"
#include "listman.h"
#include "q931man.h"
#include "h245man.h"
#include "callman.h"
#include "userman.h"
#include "chanman.h"
#include "hangman.h"
#include "linkapi.h"
#include "h245api.h"
#include "ccutils.h"

#ifdef    GATEKEEPER
HRESULT InitGkiManager(void);
void    DeInitGkiManager(void);
#define GKI_MAX_BANDWIDTH       (0xFFFFFFFF / 100)
#endif // GATEKEEPER

CALL_CONTROL_STATE		CallControlState = INITIALIZING_STATE;
BOOL					bISDMLoaded = FALSE;
static HRESULT			InitStatus;
// NumThreads counts the number of threads which are executing code within this DLL.
// NumThreads must be incremented at each DLL entry point (which includes each API
// call, the Q931 callback location and the H245 callback location).
// NumThreads must be decremented upon DLL exit.  The macro LeaveCallControlTop()
// is used to facilitate this operation.  Note that LeaveCallControlTop may accept
// a function call as a parameter; we must call the function first, save its return
// value, then decrement NumThreads, and finally return the saved value.
THREADCOUNT				ThreadCount;
HINSTANCE				ghCallControlInstance;
extern CC_CONFERENCEID	InvalidConferenceID;

#define _Unicode(x) L ## x
#define Unicode(x) _Unicode(x)

WORD  ADDRToInetPort(CC_ADDR *pAddr);
DWORD ADDRToInetAddr(CC_ADDR *pAddr);


BOOL WINAPI CCDllMain(                            HINSTANCE                               hInstDll,
									DWORD					fdwReason,
									LPVOID					lpvReserved)
{
	switch (fdwReason) {
		case DLL_PROCESS_ATTACH:
			// The DLL is being mapped into the process's address space

                        ASSERT(CallControlState == INITIALIZING_STATE);
			ASSERT(CC_OK == CS_OK);
			ASSERT(CC_OK == H245_ERROR_OK);

			InitializeLock(&ThreadCount.Lock);
			ThreadCount.wNumThreads = 0;
			ghCallControlInstance = hInstDll;

#ifdef    GATEKEEPER			
			InitStatus = InitGkiManager();
			if (InitStatus != CC_OK)
				break;
#endif // GATEKEEPER

                        // create Q.931 ASN.1 global structure
                        InitStatus = Q931InitPER();
                        if (InitStatus != CC_OK)
                            break;

                        // create H.245 ASN.1 global structure
                        if (H245_InitModule() != ASN1_SUCCESS) {
                            InitStatus = CC_NO_MEMORY;
                            break;
                        }

                        InitStatus = InitConferenceManager();
			if (InitStatus != CC_OK)
				break;

			InitStatus = InitCallManager();
			if (InitStatus != CC_OK)
				break;
			
			InitStatus = InitChannelManager();
			if (InitStatus != CC_OK)
				break;
			
			InitStatus = InitH245Manager();
			if (InitStatus != CC_OK)
				break;
			
			InitStatus = InitListenManager();
			if (InitStatus != CC_OK)
				break;
			
			InitStatus = InitQ931Manager();
			if (InitStatus != CC_OK)
				break;
			
			InitStatus = InitUserManager();
			if (InitStatus != CC_OK)
				break;

			InitStatus = InitHangupManager();
			if (InitStatus != CC_OK)
				break;

			InitStatus = Q931Init();
			if (InitStatus != CS_OK)
				break;

                        CallControlState = OPERATIONAL_STATE;
			break;

		case DLL_THREAD_ATTACH:
			// A thread is being created
			break;

		case DLL_THREAD_DETACH:
			// A thread is exiting cleanly
			break;

                case DLL_PROCESS_DETACH:
                        // The DLL is being unmapped from the process's address space
                        CC_Shutdown();

                        // destroy ASN.1 global structures
                        H245_TermModule();
                        Q931DeInitPER();

			DeleteLock(&ThreadCount.Lock);
			break;
	}

	return TRUE;
}



CC_API
HRESULT CC_AcceptCall(				CC_HCONFERENCE			hConference,
									PCC_NONSTANDARDDATA		pNonStandardData,
									PWSTR					pszDisplay,
									CC_HCALL				hCall,
                                    DWORD                   dwBandwidth,
									DWORD					dwUserToken)
{
HRESULT			status;
PCALL			pCall;
PCONFERENCE		pConference;
HQ931CALL		hQ931Call;
WORD			wNumCalls;
CC_ADDR			AlternateAddr;
PCC_ADDR		pAlternateAddr;
BOOL			bAccept = FALSE;
BYTE			bRejectReason = CC_REJECT_UNDEFINED_REASON;
CC_CONFERENCEID	ConferenceID;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (hConference == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = ValidateNonStandardData(pNonStandardData);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = LockCall(hCall, &pCall);
	if (status != CC_OK)
		// note that we can't even tell Q931 to reject the call
		LeaveCallControlTop(status);

	if (pCall->CallState != INCOMING) {
		UnlockCall(pCall);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	ASSERT(pCall->hConference == CC_INVALID_HANDLE);

	hQ931Call = pCall->hQ931Call;
	ConferenceID = pCall->ConferenceID;

	status = AddLocalNonStandardDataToCall(pCall, pNonStandardData);
	if (status != CC_OK) {
		FreeCall(pCall);
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &ConferenceID,
					   NULL,					// alternate address
					   pNonStandardData);		// non-standard data
		LeaveCallControlTop(status);
	}

	status = AddLocalDisplayToCall(pCall, pszDisplay);
	if (status != CC_OK) {
		FreeCall(pCall);
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &ConferenceID,
					   NULL,					// alternate address
					   pNonStandardData);		// non-standard data
		LeaveCallControlTop(status);
	}

	UnlockCall(pCall);
	status = LockConferenceEx(hConference,
							  &pConference,
							  TS_FALSE);	// bDeferredDelete
	if (status == CC_OK) {
		status = LockCall(hCall, &pCall);
		if (status != CC_OK) {
			UnlockConference(pConference);
			LeaveCallControlTop(status);
		}
	} else
		LeaveCallControlTop(status);

	if ((pCall->bCallerIsMC == TRUE) &&
		((pConference->tsMultipointController == TS_TRUE) ||
		 (pConference->bMultipointCapable == FALSE))) {
		FreeCall(pCall);
		UnlockConference(pConference);
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &ConferenceID,
					   NULL,					// alternate address
					   pNonStandardData);		// non-standard data
		if (pConference->bMultipointCapable == FALSE) {
			LeaveCallControlTop(CC_BAD_PARAM);
		} else {
			LeaveCallControlTop(CC_NOT_MULTIPOINT_CAPABLE);
		}
	}

	EnumerateCallsInConference(&wNumCalls, NULL, pConference, REAL_CALLS);

	if ((wNumCalls > 0) &&
		(pConference->bMultipointCapable == FALSE)) {
		FreeCall(pCall);
		UnlockConference(pConference);
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &ConferenceID,
					   NULL,					// alternate address
					   pNonStandardData);		// non-standard data
		LeaveCallControlTop(CC_NOT_MULTIPOINT_CAPABLE);
	}

	pAlternateAddr = NULL;

	if (EqualConferenceIDs(&pCall->ConferenceID, &pConference->ConferenceID)) {
		if (wNumCalls > 0) {
			if (pConference->tsMultipointController == TS_TRUE) {
				// Accept Call
				status = CC_OK;
				bAccept = TRUE;
			} else { // we're not the MC
				if (pConference->bMultipointCapable) {
					if (pConference->pMultipointControllerAddr != NULL) {
						// Reject Call - route to MC
						status = CC_OK;
						bAccept = FALSE;
						bRejectReason = CC_REJECT_ROUTE_TO_MC;
						AlternateAddr = *pConference->pMultipointControllerAddr;
						pAlternateAddr = &AlternateAddr;
					} else { // we don't have the MC's address
						// XXX -- we may eventually want to enqueue the request
						// and set an expiration timer
						// Error - no MC
						status = CC_NOT_MULTIPOINT_CAPABLE;
					}
				} else { // we're not multipoint capable
					// Error - bad param
					status = CC_BAD_PARAM;
				}
			}
		} else { // wNumCalls == 0
			// Accept Call
			status = CC_OK;
			bAccept = TRUE;
		}
	} else { // pCall->ConferenceID != pConference->ConferenceID
		if (EqualConferenceIDs(&pConference->ConferenceID, &InvalidConferenceID)) {
			// Accept Call
			status = CC_OK;
			bAccept = TRUE;
		} else { // pConferenceID != InvalidConferenceID
			if (pConference->tsMultipointController == TS_TRUE) {
				// Reject Call - route to MC
				status = CC_OK;
				bAccept = FALSE;
				bRejectReason = CC_REJECT_ROUTE_TO_MC;
				pAlternateAddr = &AlternateAddr;
				if (GetLastListenAddress(pAlternateAddr) != CC_OK) {
					pAlternateAddr = NULL;
					bRejectReason = CC_REJECT_UNDEFINED_REASON;
				}
			} else { // we're not the MC
				if (pConference->bMultipointCapable) {
					if (pConference->pMultipointControllerAddr) {
						// Reject Call - route to MC
						status = CC_OK;
						bAccept = FALSE;
						bRejectReason = CC_REJECT_ROUTE_TO_MC;
						AlternateAddr = *pConference->pMultipointControllerAddr;
						pAlternateAddr = &AlternateAddr;
					} else { // we don't have the MC's address
						// XXX -- we may eventually want to enqueue the request
						// and set an expiration timer
						// Error - no MC
						status = CC_NOT_MULTIPOINT_CAPABLE;
					}
				} else { // we're not multipoint capable
					// Error - bad param
					status = CC_BAD_PARAM;
				}
			}
		}
	}

	if (status != CC_OK) {
		FreeCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	if (bAccept) {
		pCall->dwUserToken = dwUserToken;

#ifdef    GATEKEEPER
		pCall->hConference = hConference;

		// Fill in Gatekeeper Call fields
		memset(&pCall->GkiCall, 0, sizeof(pCall->GkiCall));
		pCall->GkiCall.pCall            = pCall;
		pCall->GkiCall.hCall            = hCall;
        pCall->GkiCall.pConferenceId    = pCall->ConferenceID.buffer;
		pCall->GkiCall.bActiveMC        = pCall->bCallerIsMC;
		pCall->GkiCall.bAnswerCall      = TRUE;
		if (pCall->pSourceCallSignalAddr) {
			pCall->GkiCall.dwSrcCallSignalIpAddress = ADDRToInetAddr(pCall->pSourceCallSignalAddr);
			pCall->GkiCall.wSrcCallSignalPort = ADDRToInetPort(pCall->pSourceCallSignalAddr);
		} else {
			pCall->GkiCall.dwSrcCallSignalIpAddress = 0;
			pCall->GkiCall.wSrcCallSignalPort = 0;
		}
		pCall->GkiCall.wSrcCallSignalPort =
			(WORD)((pCall->GkiCall.wSrcCallSignalPort<<8)|(pCall->GkiCall.wSrcCallSignalPort>>8));

		pCall->GkiCall.dwIpAddress      = ADDRToInetAddr(pCall->pQ931PeerConnectAddr);
		pCall->GkiCall.wPort            = ADDRToInetPort(pCall->pQ931PeerConnectAddr);
		pCall->GkiCall.wPort = (WORD)((pCall->GkiCall.wPort<<8)|(pCall->GkiCall.wPort>>8));

		if (pConference->bMultipointCapable)
			pCall->GkiCall.CallType = MANY_TO_MANY; 
		else
			pCall->GkiCall.CallType = POINT_TO_POINT;
        pCall->GkiCall.uBandwidthRequested = dwBandwidth / 100;
		status = GkiOpenCall(&pCall->GkiCall, pConference);

        // GkiOpenCall may or may not have called AcceptCall, which unlocks
        // call and conference and may or may not free the call
	    if (ValidateCall(hCall) == CC_OK)
			if (status == CC_OK)
				UnlockCall(pCall);
			else
				FreeCall(pCall);
	    if (ValidateConference(hConference) == CC_OK)
		    UnlockConference(pConference);

        if (status != CC_OK)
        {
		    Q931RejectCall( hQ931Call,				        // Q931 call handle
		  			        CC_REJECT_GATEKEEPER_RESOURCES, // reject reason
		  			        &ConferenceID,
		    		        NULL,          			        // alternate address
		  			        pNonStandardData);		        // non-standard data
        }
#else  // GATEKEEPER
		status = AcceptCall(pCall, pConference);
#endif // GATEKEEPER

		LeaveCallControlTop(status);
	} else { // bAccept == FALSE
		FreeCall(pCall);
		if (bRejectReason == CC_REJECT_ROUTE_TO_MC) {
			ASSERT(pAlternateAddr != NULL);
			ConferenceID = pConference->ConferenceID;
		} else
			pAlternateAddr = NULL;

		UnlockConference(pConference);
		status = Q931RejectCall(hQ931Call,				// Q931 call handle
								bRejectReason,			// reject reason
								&ConferenceID,
				   				pAlternateAddr,			// alternate address
								pNonStandardData);		// non-standard data
		LeaveCallControlTop(status);
	}
}



CC_API
HRESULT CC_AcceptChannel(			CC_HCHANNEL				hChannel,
									PCC_ADDR				pRTPAddr,
									PCC_ADDR				pRTCPAddr,
									DWORD					dwBandwidth)
{
HRESULT			status;
PCHANNEL		pChannel;
PCONFERENCE		pConference;
CC_HCALL		hCall;
PCALL			pCall;
#ifndef    GATEKEEPER
H245_MUX_T		H245MuxTable;
WORD			i;
CC_ACCEPT_CHANNEL_CALLBACK_PARAMS Params;
CC_HCONFERENCE hConference;
#endif // !GATEKEEPER

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hChannel == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (pRTCPAddr != NULL)
		if ((pRTCPAddr->nAddrType != CC_IP_BINARY) ||
			(pRTCPAddr->bMulticast == TRUE))
			LeaveCallControlTop(CC_BAD_PARAM);

	status = LockChannelAndConference(hChannel, &pChannel, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);


	// Make sure that hChannel is a receive or proxy channel that
	// hasn't already been accepted
	if (((pChannel->bChannelType != RX_CHANNEL) &&
		 (pChannel->bChannelType != PROXY_CHANNEL)) ||
		 (pChannel->tsAccepted != TS_UNKNOWN)) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (pChannel->bMultipointChannel) {
		if ((pRTPAddr != NULL) || (pRTCPAddr != NULL)) {
			UnlockChannel(pChannel);
			UnlockConference(pConference);
			LeaveCallControlTop(CC_BAD_PARAM);
		}
	} else
		if ((pRTPAddr == NULL) || (pRTCPAddr == NULL)) {
			UnlockChannel(pChannel);
			UnlockConference(pConference);
			LeaveCallControlTop(CC_BAD_PARAM);
		}

	if (pConference->LocalEndpointAttached != ATTACHED) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	hCall = pChannel->hCall;
	status = LockCall(hCall, &pCall);
	if (status != CC_OK) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	if (pChannel->bMultipointChannel == FALSE) {
		status = AddLocalAddrPairToChannel(pRTPAddr, pRTCPAddr, pChannel);
		if (status != CC_OK) {
			UnlockCall(pCall);
			UnlockChannel(pChannel);
			UnlockConference(pConference);
			LeaveCallControlTop(status);
		}
	}

#ifdef    GATEKEEPER
	pChannel->dwBandwidth = dwBandwidth;
	UnlockChannel(pChannel);
	UnlockConference(pConference);
	status = GkiOpenChannel(&pCall->GkiCall, dwBandwidth, hChannel, RX);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
#else  // GATEKEEPER
	if (pChannel->wNumOutstandingRequests != 0) {
		if ((pChannel->bMultipointChannel) &&
			(pConference->tsMultipointController == TS_TRUE)) {
			// Supply the RTP and RTCP addresses in the OpenLogicalChannelAck
			if (pConference->pSessionTable != NULL) {
				for (i = 0; i < pConference->pSessionTable->wLength; i++) {
					if (pConference->pSessionTable->SessionInfoArray[i].bSessionID ==
						pChannel->bSessionID) {
						pRTPAddr = pConference->pSessionTable->SessionInfoArray[i].pRTPAddr;
						pRTCPAddr = pConference->pSessionTable->SessionInfoArray[i].pRTCPAddr;
						break;
					}
				}
			}
		}

		H245MuxTable.Kind = H245_H2250ACK;
		H245MuxTable.u.H2250ACK.nonStandardList = NULL;

		if (pRTPAddr != NULL) {
			if (pRTPAddr->bMulticast)
				H245MuxTable.u.H2250ACK.mediaChannel.type = H245_IP_MULTICAST;
			else
				H245MuxTable.u.H2250ACK.mediaChannel.type = H245_IP_UNICAST;
			H245MuxTable.u.H2250ACK.mediaChannel.u.ip.tsapIdentifier =
				pRTPAddr->Addr.IP_Binary.wPort;
			HostToH245IPNetwork(H245MuxTable.u.H2250ACK.mediaChannel.u.ip.network,
								pRTPAddr->Addr.IP_Binary.dwAddr);
			H245MuxTable.u.H2250ACK.mediaChannelPresent = TRUE;
		} else
			H245MuxTable.u.H2250ACK.mediaChannelPresent = FALSE;

		if (pRTCPAddr != NULL) {
			if (pRTCPAddr->bMulticast)
				H245MuxTable.u.H2250ACK.mediaControlChannel.type = H245_IP_MULTICAST;
			else
				H245MuxTable.u.H2250ACK.mediaControlChannel.type = H245_IP_UNICAST;
			H245MuxTable.u.H2250ACK.mediaControlChannel.u.ip.tsapIdentifier =
				pRTCPAddr->Addr.IP_Binary.wPort;
			HostToH245IPNetwork(H245MuxTable.u.H2250ACK.mediaControlChannel.u.ip.network,
								pRTCPAddr->Addr.IP_Binary.dwAddr);
			H245MuxTable.u.H2250ACK.mediaControlChannelPresent = TRUE;
		} else
			H245MuxTable.u.H2250ACK.mediaControlChannelPresent = FALSE;

		H245MuxTable.u.H2250ACK.dynamicRTPPayloadTypePresent = FALSE;
		H245MuxTable.u.H2250ACK.sessionIDPresent = TRUE;
		H245MuxTable.u.H2250ACK.sessionID = pChannel->bSessionID;
		
		status = H245OpenChannelAccept(pCall->H245Instance,
									   0,					// dwTransId
									   pChannel->wRemoteChannelNumber, // Rx channel
									   &H245MuxTable,
									   0,						// Tx channel
									   NULL,					// Tx mux
									   H245_INVALID_PORT_NUMBER,// Port
									   pChannel->pSeparateStack);
		if (status == CC_OK)
			pChannel->wNumOutstandingRequests = 0;
		else
			--(pChannel->wNumOutstandingRequests);
	}

	pChannel->tsAccepted = TS_TRUE;

    Params.hChannel = hChannel;
    if (status == CC_OK)
        UnlockChannel(pChannel);
    else
        FreeChannel(pChannel);
    UnlockCall(pCall);

    hConference = pConference->hConference;
    InvokeUserConferenceCallback(pConference,
                                 CC_ACCEPT_CHANNEL_INDICATION,
                                 status,
                                 &Params);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
#endif // GATEKEEPER

	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_AcceptT120Channel(		CC_HCHANNEL				hChannel,
									BOOL					bAssociateConference,
									PCC_OCTETSTRING			pExternalReference,
									PCC_ADDR				pAddr)
{
HRESULT			status;
PCHANNEL		pChannel;
PCALL			pCall;
PCONFERENCE		pConference;
H245_ACCESS_T	SeparateStack;
H245_ACCESS_T	*pSeparateStack;
H245_MUX_T		H245MuxTable;
WORD			i;
WORD			wNumCalls;
PCC_HCALL		CallList;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hChannel == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (pAddr != NULL)
		if ((pAddr->nAddrType != CC_IP_BINARY) ||
			(pAddr->bMulticast == TRUE))
			LeaveCallControlTop(CC_BAD_PARAM);

	status = LockChannelAndConference(hChannel, &pChannel, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	// Make sure that hChannel is a bidirectional channel that was
	// not opened locally and hasn't already been accepted or rejected
	if ((pChannel->bChannelType != TXRX_CHANNEL) ||
		(pChannel->tsAccepted != TS_UNKNOWN) ||
		(pChannel->bLocallyOpened == TRUE)) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	// If the remote endpoint specified a channel address, it will
	// be contained in the SeparateStack field, and we are not
	// allowed to specify another address in pAddr;
	// if the remote endpoint did not specify a channel address,
	// we must specify one now
	if (((pChannel->pSeparateStack == NULL) && (pAddr == NULL)) ||
	    ((pChannel->pSeparateStack != NULL) && (pAddr != NULL))) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (pConference->LocalEndpointAttached != ATTACHED) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	// Add the SeparateStack field to the channel, if necessary
	if (pAddr != NULL) {
		SeparateStack.bit_mask = distribution_present;
		SeparateStack.distribution.choice = unicast_chosen;
		if (pExternalReference != NULL)	{
			SeparateStack.bit_mask |= externalReference_present;
			SeparateStack.externalReference.length = pExternalReference->wOctetStringLength;
			memcpy(SeparateStack.externalReference.value,
				   pExternalReference->pOctetString,
				   pExternalReference->wOctetStringLength);
		}
		SeparateStack.networkAddress.choice = localAreaAddress_chosen;
		SeparateStack.networkAddress.u.localAreaAddress.choice = unicastAddress_chosen;
		SeparateStack.networkAddress.u.localAreaAddress.u.unicastAddress.choice = UnicastAddress_iPAddress_chosen;
		SeparateStack.networkAddress.u.localAreaAddress.u.unicastAddress.u.UnicastAddress_iPAddress.tsapIdentifier =
			pAddr->Addr.IP_Binary.wPort;
		SeparateStack.networkAddress.u.localAreaAddress.u.unicastAddress.u.UnicastAddress_iPAddress.network.length = 4;
		HostToH245IPNetwork(SeparateStack.networkAddress.u.localAreaAddress.u.unicastAddress.u.UnicastAddress_iPAddress.network.value,
							pAddr->Addr.IP_Binary.dwAddr);
		SeparateStack.associateConference = (char) bAssociateConference;
		pSeparateStack = &SeparateStack;
		AddSeparateStackToChannel(pSeparateStack, pChannel);
	} else
		pSeparateStack = NULL;

    // Send an ACK to the endpoint which requested the channel
	status = LockCall(pChannel->hCall, &pCall);
	if (status != CC_OK) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	H245MuxTable.Kind = H245_H2250ACK;
	H245MuxTable.u.H2250ACK.nonStandardList = NULL;
	H245MuxTable.u.H2250ACK.mediaChannelPresent = FALSE;
	H245MuxTable.u.H2250ACK.mediaControlChannelPresent = FALSE;
	H245MuxTable.u.H2250ACK.dynamicRTPPayloadTypePresent = FALSE;
	H245MuxTable.u.H2250ACK.sessionIDPresent = FALSE;

	status = H245OpenChannelAccept(pCall->H245Instance,	// dwInst
								   0,					// dwTransId
								   pChannel->wRemoteChannelNumber, // remote channel
								   &H245MuxTable,			// Rx Mux
								   pChannel->wLocalChannelNumber,	// local channel
								   NULL,					// Tx mux
								   H245_INVALID_PORT_NUMBER,// Port
								   pSeparateStack);
	if (status != CC_OK) {
 		FreeChannel(pChannel);
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}
	pChannel->tsAccepted = TS_TRUE;
	--(pChannel->wNumOutstandingRequests);
	UnlockCall(pCall);

	// If we're the MC in a multipoint conference, forward the
	// open T.120 channel request to all other endpoints in the conference
	if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
		(pConference->tsMultipointController == TS_TRUE)) {
		EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
		for (i = 0; i < wNumCalls; i++) {
			if (CallList[i] != pChannel->hCall) {
				if (LockCall(CallList[i], &pCall) == CC_OK) {
					status = H245OpenChannel(pCall->H245Instance,		// H245 instance
											 pChannel->hChannel,		// dwTransId
											 pChannel->wLocalChannelNumber,
											 pChannel->pTxH245TermCap,	// TxMode
											 pChannel->pTxMuxTable,		// TxMux
											 H245_INVALID_PORT_NUMBER,	// TxPort
											 pChannel->pRxH245TermCap,	// RxMode
											 pChannel->pRxMuxTable,		// RxMux
											 pChannel->pSeparateStack);
					UnlockCall(pCall);
				}
			}
		}
		Free(CallList);
	}

	UnlockChannel(pChannel);
	UnlockConference(pConference);
	LeaveCallControlTop(CC_OK);
}


				
CC_API
HRESULT CC_CallListen(				PCC_HLISTEN				phListen,
									PCC_ADDR				pListenAddr,
									PCC_ALIASNAMES			pLocalAliasNames,
									DWORD					dwListenToken,
									CC_LISTEN_CALLBACK		ListenCallback)
{
HRESULT		status;
PLISTEN		pListen;
HQ931LISTEN	hQ931Listen;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (phListen == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	// set phListen now, in case we encounter an error
	*phListen = CC_INVALID_HANDLE;

	if (pListenAddr == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = ValidateAddr(pListenAddr);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = Q931ValidateAliasNames(pLocalAliasNames);
	if (status != CS_OK)
		LeaveCallControlTop(status);

	if (ListenCallback == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = SetQ931Port(pListenAddr);
 	if (status != CS_OK)
		LeaveCallControlTop(status);

	status = AllocAndLockListen(phListen,
								pListenAddr,
								0,				// hQ931Listen
								pLocalAliasNames,
								dwListenToken,
								ListenCallback,
								&pListen);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	// Unlock the listen object to prevent deadlock when calling Q931
	UnlockListen(pListen);

	status = Q931Listen(&hQ931Listen, pListenAddr,
						(DWORD)*phListen, (Q931_CALLBACK)Q931Callback);
	if (status != CS_OK) {
		if (LockListen(*phListen, &pListen) == CC_OK)
			FreeListen(pListen);
		*phListen = CC_INVALID_HANDLE;
		LeaveCallControlTop(status);
	}

	status = LockListen(*phListen, &pListen);
	if (status != CC_OK) {
		Q931CancelListen(hQ931Listen);
		LeaveCallControlTop(status);
	}

	ASSERT(pListenAddr != NULL);
	ASSERT(pListenAddr->nAddrType == CC_IP_BINARY);

	pListen->hQ931Listen = hQ931Listen;
	// Copy the binary form of the listen address into the listen object
	pListen->ListenAddr = *pListenAddr;

#ifdef    GATEKEEPER
	status = GkiOpenListen(*phListen,
						   pLocalAliasNames,
						   pListenAddr->Addr.IP_Binary.dwAddr,
						   pListenAddr->Addr.IP_Binary.wPort);
    if (status != NOERROR) {
		Q931CancelListen(hQ931Listen);
        FreeListen(pListen);
    } else {
	    UnlockListen(pListen);
    }
#else
	status = UnlockListen(pListen);
#endif // GATEKEEPER

	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_CancelCall(				CC_HCALL				hCall)
{
HRESULT			status;
PCALL			pCall;
PCONFERENCE		pConference;
HRESULT			SaveStatus;
H245_INST_T		H245Instance;
HQ931CALL		hQ931Call;
WORD			wNumCalls;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pCall->CallState != ENQUEUED) &&
		(pCall->CallState != PLACED) &&
		(pCall->CallState != RINGING) &&
		(pCall->CallState != TERMCAP)) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

#ifdef    GATEKEEPER 
	if (pCall->GkiCall.uGkiCallState != 0)
	{
		GkiCloseCall(&pCall->GkiCall);
	}
#endif // GATEKEEPER

	H245Instance = pCall->H245Instance;
	hQ931Call = pCall->hQ931Call;
	FreeCall(pCall);

	if (H245Instance != H245_INVALID_ID)
		SaveStatus = H245ShutDown(H245Instance);
	else
		SaveStatus = H245_ERROR_OK;
	
	if (hQ931Call != 0) {
		if (SaveStatus == H245_ERROR_OK) {
			SaveStatus = Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
			// Q931Hangup may legitimately return CS_BAD_PARAM, because the Q.931 call object
			// may have been deleted at this point
			if (SaveStatus == CS_BAD_PARAM)
				SaveStatus = CC_OK;
		} else
			Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
	}

	for ( ; ; ) {
		// Start up an enqueued call, if one exists
		status = RemoveEnqueuedCallFromConference(pConference, &hCall);
		if ((status != CC_OK) || (hCall == CC_INVALID_HANDLE))
			break;

		status = LockCall(hCall, &pCall);
		if (status == CC_OK) {
			pCall->CallState = PLACED;

			status = PlaceCall(pCall, pConference);
			UnlockCall(pCall);
			if (status == CC_OK)
				break;
		}
	}

	EnumerateCallsInConference(&wNumCalls, NULL, pConference, REAL_CALLS);

	if (wNumCalls == 0) {
		if (pConference->bDeferredDelete) {
			ASSERT(pConference->LocalEndpointAttached == DETACHED);
			FreeConference(pConference);
		} else {
			if ((pConference->ConferenceMode != MULTIPOINT_MODE) ||
				(pConference->tsMultipointController != TS_TRUE))
				ReInitializeConference(pConference);
			UnlockConference(pConference);
		}
	} else {
		UnlockConference(pConference);
	}
	if (SaveStatus != CC_OK)
		status = SaveStatus;

	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_CancelListen(			CC_HLISTEN				hListen)
{
HRESULT		status;
PLISTEN		pListen;
HQ931LISTEN	hQ931Listen;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (hListen == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockListen(hListen, &pListen);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	hQ931Listen = pListen->hQ931Listen;

	// Unlock the listen object to prevent deadlock when calling Q931
	UnlockListen(pListen);

#ifdef    GATEKEEPER
	status = GkiCloseListen(hListen);
#endif // GATEKEEPER

	status = Q931CancelListen(hQ931Listen);
	if (status != CS_OK)
		LeaveCallControlTop(status);

	status = LockListen(hListen, &pListen);
	if (status == CC_OK) {
		LeaveCallControlTop(FreeListen(pListen));
	} else
		LeaveCallControlTop(status);
}



CC_API
HRESULT CC_CloseChannel(			CC_HCHANNEL				hChannel)
{
HRESULT		status;
HRESULT		SaveStatus = CC_OK;
PCHANNEL	pChannel;
PCONFERENCE	pConference;
PCALL		pCall;
WORD		wNumCalls;
PCC_HCALL	CallList;
WORD		i;
BOOL		bChannelCloseRequest;
CC_HCALL	hCall;
#ifdef    GATEKEEPER
unsigned    uBandwidth = 0;
#endif // GATEKEEPER 

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (hChannel == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockChannelAndConference(hChannel, &pChannel, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if (pChannel->tsAccepted != TS_TRUE) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (pConference->LocalEndpointAttached != ATTACHED) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	status = EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
	if (status != CC_OK) {
		UnlockConference(pConference);
		UnlockChannel(pChannel);
		LeaveCallControlTop(status);
	}

	if ((pChannel->bChannelType == RX_CHANNEL) ||
		(pChannel->bChannelType == PROXY_CHANNEL) ||
		((pChannel->bChannelType == TXRX_CHANNEL) &&
		 (pChannel->bLocallyOpened == FALSE))) {
		// Generate a channel close request
		bChannelCloseRequest = TRUE;
	} else {
		bChannelCloseRequest = FALSE;
		while (DequeueRequest(&pChannel->pCloseRequests, &hCall) == CC_OK) {
			if (LockCall(hCall, &pCall) == CC_OK) {
				H245CloseChannelReqResp(pCall->H245Instance,
										H245_ACC,
										pChannel->wLocalChannelNumber);
				UnlockCall(pCall);
			}
		}
#ifdef    GATEKEEPER
        if (pChannel->bChannelType != TXRX_CHANNEL) {
            if (pChannel->bMultipointChannel) {
                // Multicast channel bandwidth is assigned to arbitrary call
	            uBandwidth = pChannel->dwBandwidth / 100;
            } else {
                // Channel bandwidth is assigned to a specific call
                ASSERT(pChannel->hCall != CC_INVALID_HANDLE);
		        if (LockCall(pChannel->hCall, &pCall) == CC_OK) {
			        SaveStatus = GkiCloseChannel(&pCall->GkiCall, pChannel->dwBandwidth, hChannel);
			        UnlockCall(pCall);
                }
            }
        }
#endif // GATEKEEPER
	}

	for (i = 0; i < wNumCalls; i++) {
		if (LockCall(CallList[i], &pCall) == CC_OK) {
			if (bChannelCloseRequest) {
				if ((pChannel->bChannelType != PROXY_CHANNEL) ||
					(pChannel->hCall == pCall->hCall)) {
					// Note that dwTransID is set to the call handle of
					// the peer who initiated the close channel request.
					// When the close channel response is received,
					// the dwTransID gives us back the call handle to which
					// the response must be forwarded. In this case,
					// the local endpoint initiated the close channel request,
					// so we'll use CC_INVALID_HANDLE as the dwTransId
					// to note this fact.
					status = H245CloseChannelReq(pCall->H245Instance,	// H245 instance
												 CC_INVALID_HANDLE,		// dwTransId
												 pChannel->wRemoteChannelNumber);
				}
			} else {
				status = H245CloseChannel(pCall->H245Instance,	// H245 instance
										  0,					// dwTransId
										  pChannel->wLocalChannelNumber);
#ifdef    GATEKEEPER
                if (uBandwidth && uBandwidth <= pCall->GkiCall.uBandwidthUsed) {
                    // Since the bandwidth is multicast, only subtract it from
                    // a single call (does not really matter which one)
				    SaveStatus = GkiCloseChannel(&pCall->GkiCall, pChannel->dwBandwidth, hChannel);
				    if (SaveStatus == CC_OK)
				        uBandwidth = 0;
                }
#endif // GATEKEEPER
			}
			// Note that this channel may not have been accepted on all of the calls,
			// so we could get an H245_ERROR_INVALID_CHANNEL error
			if ((status != H245_ERROR_OK) && (status != H245_ERROR_INVALID_CHANNEL))
				SaveStatus = status;
			UnlockCall(pCall);
		}
	}

	if (CallList != NULL)
		Free(CallList);

	if (pChannel->bChannelType == PROXY_CHANNEL) {
		// If this is a PROXY channel, keep the channel object around
		// until the channel owner closes it
		pChannel->tsAccepted = TS_FALSE;
		UnlockChannel(pChannel);
	} else {
		FreeChannel(pChannel);
	}
	UnlockConference(pConference);
	LeaveCallControlTop(SaveStatus);
}



CC_API
HRESULT CC_CloseChannelResponse(	CC_HCHANNEL				hChannel,
									BOOL					bWillCloseChannel)
{
HRESULT			status;
PCHANNEL		pChannel;
PCONFERENCE		pConference;
CC_HCALL		hCall;
PCALL			pCall;
H245_ACC_REJ_T	AccRej;
WORD			wNumRequests;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hChannel == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockChannelAndConference(hChannel, &pChannel, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if (((pChannel->bChannelType != TX_CHANNEL) &&
		 (pChannel->bChannelType != TXRX_CHANNEL)) ||
	     (pChannel->bLocallyOpened == FALSE)) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (bWillCloseChannel)
		AccRej = H245_ACC;
	else
		AccRej = H245_REJ;

	wNumRequests = 0;
	while (DequeueRequest(&pChannel->pCloseRequests, &hCall) == CC_OK) {
		wNumRequests++;
		if (LockCall(hCall, &pCall) == CC_OK) {
			H245CloseChannelReqResp(pCall->H245Instance,
									AccRej,
									pChannel->wLocalChannelNumber);
			UnlockCall(pCall);
		}
	}

	UnlockChannel(pChannel);
	UnlockConference(pConference);

	if (wNumRequests == 0)
		status = CC_BAD_PARAM;
	else
		status = CC_OK;

	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_ChangeConferenceCapabilities(
									CC_HCONFERENCE			hConference,
									PCC_TERMCAPLIST			pTermCapList,
									PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors)
{
HRESULT		status;
PCONFERENCE	pConference;
PCALL		pCall;
PCC_HCALL	CallList;
WORD		wNumCalls;
WORD		i;
BOOL		bConferenceTermCapsChanged;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hConference == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (pTermCapList == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = ValidateTermCapList(pTermCapList);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = ValidateTermCapDescriptors(pTermCapDescriptors, pTermCapList);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = LockConference(hConference, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if (pConference->LocalEndpointAttached == DETACHED) {
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	status = UnregisterTermCapListFromH245(pConference,
										   pConference->pLocalH245TermCapList);
	if (status != CC_OK) {
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	DestroyH245TermCapList(&pConference->pLocalH245TermCapList);
	status = CopyH245TermCapList(&pConference->pLocalH245TermCapList,
								 pTermCapList);
	if (status != CC_OK) {
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	status = UnregisterTermCapDescriptorsFromH245(pConference,
												  pConference->pLocalH245TermCapDescriptors);
	if (status != CC_OK) {
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	DestroyH245TermCapDescriptors(&pConference->pLocalH245TermCapDescriptors);
	// create a new descriptor list if one was not supplied
	if (pTermCapDescriptors == NULL)
		status = CreateH245DefaultTermCapDescriptors(&pConference->pLocalH245TermCapDescriptors,
													 pConference->pLocalH245TermCapList);
	else
		// make a local copy of pTermCapDescriptors
		status = CopyH245TermCapDescriptors(&pConference->pLocalH245TermCapDescriptors,
											pTermCapDescriptors);
	if (status != CC_OK) {
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
		(pConference->tsMultipointController == TS_TRUE))
		CreateConferenceTermCaps(pConference, &bConferenceTermCapsChanged);
	else
		bConferenceTermCapsChanged = TRUE;

	if (bConferenceTermCapsChanged) {
		EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
		for (i = 0; i < wNumCalls; i++) {
			if (LockCall(CallList[i], &pCall) == CC_OK) {
				SendTermCaps(pCall, pConference);
				UnlockCall(pCall);
			}
		}
		if (CallList != NULL)
			Free(CallList);
	}

	UnlockConference(pConference);
	LeaveCallControlTop(CC_OK);
}



CC_API
HRESULT CC_CreateConference(		PCC_HCONFERENCE			phConference,
									PCC_CONFERENCEID		pConferenceID,
									DWORD					dwConferenceConfiguration,
									PCC_TERMCAPLIST			pTermCapList,
									PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors,
									PCC_VENDORINFO			pVendorInfo,
									PCC_OCTETSTRING			pTerminalID,
									DWORD					dwConferenceToken,
									CC_TERMCAP_CONSTRUCTOR	TermCapConstructor,
									CC_SESSIONTABLE_CONSTRUCTOR	SessionTableConstructor,
									CC_CONFERENCE_CALLBACK	ConferenceCallback)
{
PCONFERENCE				pConference;
HRESULT					status;
BOOL					bMultipointCapable;
BOOL					bForceMultipointController;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (phConference == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);
	
	// set phConference now, in case we encounter an error
	*phConference = CC_INVALID_HANDLE;

	bMultipointCapable = 
		(dwConferenceConfiguration & CC_CONFIGURE_MULTIPOINT_CAPABLE) != 0 ? TRUE : FALSE;
	bForceMultipointController = 
		(dwConferenceConfiguration & CC_CONFIGURE_FORCE_MC) != 0 ? TRUE : FALSE;

	if ((bMultipointCapable == FALSE) &&
		(bForceMultipointController == TRUE))
		LeaveCallControlTop(CC_BAD_PARAM);

	if (pTermCapList == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = ValidateTermCapList(pTermCapList);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = ValidateTermCapDescriptors(pTermCapDescriptors, pTermCapList);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if (pVendorInfo == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = ValidateVendorInfo(pVendorInfo);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = ValidateTerminalID(pTerminalID);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if (ConferenceCallback == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (SessionTableConstructor == NULL)
		SessionTableConstructor = DefaultSessionTableConstructor;

	if (TermCapConstructor == NULL)
		TermCapConstructor = DefaultTermCapConstructor;

	status = AllocAndLockConference(phConference,
									pConferenceID,
									bMultipointCapable,
									bForceMultipointController,
									pTermCapList,
									pTermCapDescriptors,
									pVendorInfo,
									pTerminalID,
									dwConferenceToken,
									SessionTableConstructor,
									TermCapConstructor,
									ConferenceCallback,
									&pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	LeaveCallControlTop(UnlockConference(pConference));
}



CC_API
HRESULT CC_DestroyConference(		CC_HCONFERENCE			hConference,
									BOOL					bAutoAccept)
{
HRESULT					status;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (hConference == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = AsynchronousDestroyConference(hConference, bAutoAccept);

	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_EnumerateConferences(	PWORD					pwNumConferences,
									CC_HCONFERENCE			ConferenceList[])
{
HRESULT	status;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if ((*pwNumConferences != 0) && (ConferenceList == NULL))
		LeaveCallControlTop(CC_BAD_PARAM);

	if ((*pwNumConferences == 0) && (ConferenceList != NULL))
		LeaveCallControlTop(CC_BAD_PARAM);

	status = EnumerateConferences(pwNumConferences, ConferenceList);

	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_FlowControl(				CC_HCHANNEL				hChannel,
									DWORD					dwRate)
{
HRESULT		status;
PCHANNEL	pChannel;
PCALL		pCall;
PCONFERENCE	pConference;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hChannel == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockChannelAndConference(hChannel, &pChannel, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pConference->LocalEndpointAttached != ATTACHED) ||
		((pChannel->bChannelType != RX_CHANNEL) && 
		 (pChannel->bChannelType != PROXY_CHANNEL)) ||
		(pChannel->tsAccepted != TS_TRUE)) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	status = LockCall(pChannel->hCall, &pCall);
	if (status != CC_OK) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	// H.245 expects flow rate in units of 100 bps
	if (dwRate != H245_NO_RESTRICTION)
		dwRate /= 100;

	status = H245FlowControl(pCall->H245Instance,
							 H245_SCOPE_CHANNEL_NUMBER,
							 pChannel->wRemoteChannelNumber,
							 0,			// wResourceID, not used here
							 dwRate);	// H245_NO_RESTRICTION if no restriction

	UnlockCall(pCall);
	UnlockChannel(pChannel);
	UnlockConference(pConference);
	LeaveCallControlTop(status);
}


CC_API
HRESULT CC_GetCallControlVersion(	WORD					wArraySize,
									PWSTR					pszVersion)
{
WCHAR	pszCCversion[256];
WCHAR	pszQ931version[256];

	EnterCallControlTop();

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (wArraySize == 0)
		LeaveCallControlTop(CC_BAD_PARAM);
	if (pszVersion == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	wcscpy(pszCCversion, L"Call Control ");
	wcscat(pszCCversion, Unicode(__DATE__));
	wcscat(pszCCversion, L" ");
	wcscat(pszCCversion, Unicode(__TIME__));
	wcscat(pszCCversion, L"\n");
	Q931GetVersion(sizeof(pszQ931version)/sizeof(WCHAR), pszQ931version);
	wcscat(pszCCversion, pszQ931version);

	if (wcslen(pszCCversion) >= wArraySize) {
		memcpy(pszVersion, pszCCversion, (wArraySize-1)*sizeof(WCHAR));
		pszVersion[wArraySize-1] = L'\0';
		LeaveCallControlTop(CC_BAD_SIZE);
	}

	wcscpy(pszVersion, pszCCversion);
	LeaveCallControlTop(CC_OK);
}



CC_API
HRESULT CC_GetConferenceAttributes(	CC_HCONFERENCE				hConference,
									PCC_CONFERENCEATTRIBUTES	pConferenceAttributes)
{
HRESULT		status;
PCONFERENCE	pConference;
WORD		wNumCalls;
BOOL		bLocallyAttached;
PCC_HCALL	CallList;
PCALL		pCall;
WORD		wLimit;
WORD		wIndex;
WORD		wOctetStringLength;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (hConference == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (pConferenceAttributes == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockConference(hConference, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	pConferenceAttributes->bMaster =
		(pConference->tsMaster == TS_TRUE ? TRUE : FALSE);
	pConferenceAttributes->bMultipointController =
		(pConference->tsMultipointController == TS_TRUE ? TRUE : FALSE);
	pConferenceAttributes->bMultipointConference =
		(pConference->ConferenceMode == MULTIPOINT_MODE ? TRUE : FALSE);
	pConferenceAttributes->ConferenceID = pConference->ConferenceID;
	pConferenceAttributes->LocalTerminalLabel = pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel;
	if (pConference->LocalEndpointAttached == ATTACHED)
		bLocallyAttached = TRUE;
	else
		bLocallyAttached = FALSE;
	if ((pConference->tsMultipointController == TS_TRUE) ||
		(pConference->ConferenceMode == POINT_TO_POINT_MODE))
		EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
	else
		EnumerateCallsInConference(&wNumCalls, &CallList, pConference, VIRTUAL_CALL);
	pConferenceAttributes->dwConferenceToken = pConference->dwConferenceToken;
	UnlockConference(pConference);
	if (bLocallyAttached)
		pConferenceAttributes->wNumCalls = (WORD)(wNumCalls + 1);
	else
		pConferenceAttributes->wNumCalls = wNumCalls;

#ifdef    GATEKEEPER
	pConferenceAttributes->dwBandwidthAllocated = 0;
	pConferenceAttributes->dwBandwidthUsed      = 0;
	for (wIndex = 0; wIndex < wNumCalls; ++wIndex) {
		if (LockCall(CallList[wIndex], &pCall) == CC_OK) {
			pConferenceAttributes->dwBandwidthAllocated += pCall->GkiCall.uBandwidthAllocated;
			if (pConferenceAttributes->dwBandwidthAllocated > GKI_MAX_BANDWIDTH)
				pConferenceAttributes->dwBandwidthAllocated = GKI_MAX_BANDWIDTH;
			pConferenceAttributes->dwBandwidthUsed += pCall->GkiCall.uBandwidthUsed;
			if (pConferenceAttributes->dwBandwidthUsed > GKI_MAX_BANDWIDTH)
				pConferenceAttributes->dwBandwidthUsed = GKI_MAX_BANDWIDTH;
			UnlockCall(pCall);
		}
	}
    pConferenceAttributes->dwBandwidthAllocated *= 100;
    pConferenceAttributes->dwBandwidthUsed      *= 100;
#endif // GATEKEEPER

	if (pConferenceAttributes->pParticipantList != NULL) {
		wLimit = pConferenceAttributes->pParticipantList->wLength;
		pConferenceAttributes->pParticipantList->wLength = 0;
		for (wIndex = 0; wIndex < wNumCalls; wIndex++) {
			if (LockCall(CallList[wIndex], &pCall) == CC_OK) {
				if (pCall->pPeerParticipantInfo != NULL) {
					if (pConferenceAttributes->pParticipantList->wLength < wLimit) {
						pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalLabel =
							pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
						if ((pCall->pPeerParticipantInfo->TerminalIDState == TERMINAL_ID_VALID) &&
							(pCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.wOctetStringLength != 0) &&
							(pCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.pOctetString != NULL) &&
							(pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.pOctetString != NULL)) {
							if (pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.wOctetStringLength <
							    pCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.wOctetStringLength) {
								wOctetStringLength = pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.wOctetStringLength;
							} else {
								wOctetStringLength = pCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.wOctetStringLength;
								pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.wOctetStringLength =	wOctetStringLength;
							}
							memcpy(pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.pOctetString,
								   pCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.pOctetString,
								   wOctetStringLength);
						} else {
							pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.wOctetStringLength = 0;
							pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.pOctetString = NULL;							
	
						}
					}
					pConferenceAttributes->pParticipantList->wLength++;
				}
				UnlockCall(pCall);
			}
		}
		if (bLocallyAttached) {
			if (LockConference(hConference, &pConference) == CC_OK) {
				if (pConferenceAttributes->pParticipantList->wLength < wLimit) {
					pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalLabel =
						pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel;
					if ((pConference->LocalParticipantInfo.TerminalIDState == TERMINAL_ID_VALID) &&
						(pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength != 0) &&
						(pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString != NULL) &&
						(pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.pOctetString != NULL)) {
						if (pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.wOctetStringLength <
							pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength) {
							wOctetStringLength = pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.wOctetStringLength;
						} else {
							wOctetStringLength = pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength;
							pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.wOctetStringLength =	wOctetStringLength;
						}
						memcpy(pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.pOctetString,
							   pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString,
							   wOctetStringLength);
					} else {
						pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.wOctetStringLength = 0;
						pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.pOctetString = NULL;								
					}
				}
				pConferenceAttributes->pParticipantList->wLength++;
				UnlockConference(pConference);
			}
		}
	}
	
	if (CallList != NULL)
		Free(CallList);

	LeaveCallControlTop(CC_OK);
}



CC_API
HRESULT CC_H245ConferenceRequest(	CC_HCALL				hCall,
									H245_CONFER_REQ_ENUM_T	RequestType,
									CC_TERMINAL_LABEL		TerminalLabel)
{
HRESULT		status;
PCALL		pCall;
PCONFERENCE	pConference;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if ((RequestType != H245_REQ_MAKE_ME_CHAIR) &&
		(RequestType != H245_REQ_CANCEL_MAKE_ME_CHAIR) &&
		(RequestType != H245_REQ_DROP_TERMINAL) &&
		(RequestType != H245_REQ_ENTER_H243_TERMINAL_ID) &&
		(RequestType != H245_REQ_ENTER_H243_CONFERENCE_ID))
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pConference->LocalEndpointAttached != ATTACHED) ||
		(pCall->CallState != CALL_COMPLETE) ||
		(pCall->CallType == VIRTUAL_CALL)) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	status = H245ConferenceRequest(pCall->H245Instance,
								   RequestType,
								   TerminalLabel.bMCUNumber,
								   TerminalLabel.bTerminalNumber);

	UnlockCall(pCall);
	UnlockConference(pConference);
	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_H245ConferenceResponse(	CC_HCALL				hCall,
									H245_CONFER_RSP_ENUM_T	ResponseType,
									CC_TERMINAL_LABEL		CC_TerminalLabel,
									PCC_OCTETSTRING			pOctetString,
									CC_TERMINAL_LABEL		*pCC_TerminalList,
									WORD					wTerminalListCount)
{
HRESULT			status;
PCALL			pCall;
PCONFERENCE		pConference;
WORD			i;
TerminalLabel	*pH245TerminalList;
BYTE			*pH245OctetString;
BYTE			bH245OctetStringLength;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if ((ResponseType != H245_RSP_CONFERENCE_ID) &&
		(ResponseType != H245_RSP_PASSWORD) &&
		(ResponseType != H245_RSP_VIDEO_COMMAND_REJECT) &&
		(ResponseType != H245_RSP_TERMINAL_DROP_REJECT) &&
		(ResponseType != H245_RSP_DENIED_CHAIR_TOKEN) &&
		(ResponseType != H245_RSP_GRANTED_CHAIR_TOKEN))
		LeaveCallControlTop(CC_BAD_PARAM);

	if (wTerminalListCount != 0)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (pCC_TerminalList == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = ValidateOctetString(pOctetString);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if (pOctetString != NULL)
		if (pOctetString->wOctetStringLength > 255)
			LeaveCallControlTop(CC_BAD_PARAM);

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pConference->LocalEndpointAttached != ATTACHED) ||
		(pCall->CallState != CALL_COMPLETE) ||
		(pCall->CallType == VIRTUAL_CALL)) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (wTerminalListCount == 0) {
		pH245TerminalList = NULL;
	} else {
		pH245TerminalList = (TerminalLabel *)Malloc(sizeof(TerminalLabel) * wTerminalListCount);
		if (pH245TerminalList == NULL) {
			UnlockCall(pCall);
			UnlockConference(pConference);
			LeaveCallControlTop(CC_NO_MEMORY);
		}

		for (i = 0; i < wTerminalListCount; i++) {
			pH245TerminalList[i].mcuNumber = pCC_TerminalList[i].bMCUNumber;
			pH245TerminalList[i].terminalNumber = pCC_TerminalList[i].bTerminalNumber;
		}
	}

	if (pOctetString == NULL) {
		pH245OctetString = NULL;
		bH245OctetStringLength = 0;
	} else {
		pH245OctetString = pOctetString->pOctetString;
		bH245OctetStringLength = (BYTE)pOctetString->wOctetStringLength;
	}

	status = H245ConferenceResponse(pCall->H245Instance,
									ResponseType,
									CC_TerminalLabel.bMCUNumber,
									CC_TerminalLabel.bTerminalNumber,
									pH245OctetString,
									bH245OctetStringLength,
									pH245TerminalList,
									wTerminalListCount);

	if (pH245TerminalList != NULL)
		Free(pH245TerminalList);
	UnlockCall(pCall);
	UnlockConference(pConference);
	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_H245ConferenceCommand(	CC_HCALL				hCall,
									CC_HCHANNEL				hChannel,
									H245_CONFER_CMD_ENUM_T	CommandType,
									CC_TERMINAL_LABEL		TerminalLabel)
{
HRESULT		status;
PCALL		pCall;
PCONFERENCE	pConference;
PCHANNEL	pChannel;
WORD		wChannelNumber;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if ((CommandType != H245_CMD_BROADCAST_CHANNEL) &&
		(CommandType != H245_CMD_CANCEL_BROADCAST_CHANNEL) &&
		(CommandType != H245_CMD_BROADCASTER) &&
		(CommandType != H245_CMD_CANCEL_BROADCASTER) &&
		(CommandType != H245_CMD_SEND_THIS_SOURCE) &&
		(CommandType != H245_CMD_CANCEL_SEND_THIS_SOURCE) &&
		(CommandType != H245_CMD_DROP_CONFERENCE))
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pConference->LocalEndpointAttached != ATTACHED) ||
		(pCall->CallState != CALL_COMPLETE) ||
		(pCall->CallType == VIRTUAL_CALL)) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (hChannel == CC_INVALID_HANDLE) {
		wChannelNumber = 1;
	} else {
		status = LockChannel(hChannel, &pChannel);
		if (status != CC_OK) {
			UnlockCall(pCall);
			UnlockConference(pConference);
			LeaveCallControlTop(status);
		}
		switch (pChannel->bChannelType) {
			case TX_CHANNEL:
				wChannelNumber = pChannel->wLocalChannelNumber;
				break;

			case RX_CHANNEL:
				wChannelNumber = pChannel->wRemoteChannelNumber;
				break;

			case TXRX_CHANNEL:
				wChannelNumber = pChannel->wRemoteChannelNumber;
				break;

			case PROXY_CHANNEL:
				if (pChannel->hCall == hCall)
					wChannelNumber = pChannel->wRemoteChannelNumber;
				else
					wChannelNumber = pChannel->wLocalChannelNumber;
				break;

			default:
				ASSERT(0);
				break;
		}
		UnlockChannel(pChannel);
	}

	status = H245ConferenceCommand(pCall->H245Instance,
								   CommandType,
								   wChannelNumber,
								   TerminalLabel.bMCUNumber,
								   TerminalLabel.bTerminalNumber);

	UnlockCall(pCall);
	UnlockConference(pConference);
	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_H245ConferenceIndication(CC_HCALL				hCall,
									H245_CONFER_IND_ENUM_T	IndicationType,
									BYTE					bSBENumber,
									CC_TERMINAL_LABEL		TerminalLabel)
{
HRESULT		status;
PCALL		pCall;
PCONFERENCE	pConference;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if ((IndicationType != H245_IND_SBE_NUMBER) &&
		(IndicationType != H245_IND_SEEN_BY_ONE_OTHER) &&
		(IndicationType != H245_IND_CANCEL_SEEN_BY_ONE_OTHER) &&
		(IndicationType != H245_IND_SEEN_BY_ALL) &&
		(IndicationType != H245_IND_CANCEL_SEEN_BY_ALL) &&
		(IndicationType != H245_IND_TERMINAL_YOU_ARE_SEEING) &&
		(IndicationType != H245_IND_REQUEST_FOR_FLOOR))
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pConference->LocalEndpointAttached != ATTACHED) ||
		(pCall->CallState != CALL_COMPLETE) ||
		(pCall->CallType == VIRTUAL_CALL)) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	status = H245ConferenceIndication(pCall->H245Instance,
									  IndicationType,
									  bSBENumber,
									  TerminalLabel.bMCUNumber,
									  TerminalLabel.bTerminalNumber);

	UnlockCall(pCall);
	UnlockConference(pConference);
	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_H245MiscellaneousCommand(CC_HCALL				hCall,
									CC_HCHANNEL				hChannel,
									MiscellaneousCommand	*pMiscellaneousCommand)
{
HRESULT		status;
PCALL		pCall;
PCONFERENCE	pConference;
PCHANNEL	pChannel;
WORD		wChannelNumber;
PDU_T		Pdu;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (pMiscellaneousCommand == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	if ((pMiscellaneousCommand->type.choice == multipointModeCommand_chosen) ||
		(pMiscellaneousCommand->type.choice == cnclMltpntMdCmmnd_chosen))
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pConference->LocalEndpointAttached != ATTACHED) ||
		(pCall->CallState != CALL_COMPLETE) ||
		(pCall->CallType == VIRTUAL_CALL)) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (hChannel == CC_INVALID_HANDLE) {
		wChannelNumber = 1;
	} else {
		status = LockChannel(hChannel, &pChannel);
		if (status != CC_OK) {
			UnlockCall(pCall);
			UnlockConference(pConference);
			LeaveCallControlTop(status);
		}
		switch (pChannel->bChannelType) {
			case TX_CHANNEL:
				wChannelNumber = pChannel->wLocalChannelNumber;
				break;

			case RX_CHANNEL:
				wChannelNumber = pChannel->wRemoteChannelNumber;
				break;

			case TXRX_CHANNEL:
				wChannelNumber = pChannel->wRemoteChannelNumber;
				break;

			case PROXY_CHANNEL:
				if (pChannel->hCall == hCall)
					wChannelNumber = pChannel->wRemoteChannelNumber;
				else
					wChannelNumber = pChannel->wLocalChannelNumber;
				break;

			default:
				ASSERT(0);
				break;
		}
		UnlockChannel(pChannel);
	}

	// Construct an H.245 PDU to hold a miscellaneous command
	Pdu.choice = MSCMg_cmmnd_chosen;
	Pdu.u.MSCMg_cmmnd.choice = miscellaneousCommand_chosen;
	Pdu.u.MSCMg_cmmnd.u.miscellaneousCommand = *pMiscellaneousCommand;
	Pdu.u.MSCMg_cmmnd.u.miscellaneousCommand.logicalChannelNumber = wChannelNumber;

	status = H245SendPDU(pCall->H245Instance,	// H245 instance
						 &Pdu);

	UnlockCall(pCall);
	UnlockConference(pConference);
	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_H245MiscellaneousIndication(
									CC_HCALL				hCall,
									CC_HCHANNEL				hChannel,
									MiscellaneousIndication	*pMiscellaneousIndication)
{
HRESULT		status;
PCALL		pCall;
PCONFERENCE	pConference;
PCHANNEL	pChannel;
WORD		wChannelNumber;
PDU_T		Pdu;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (pMiscellaneousIndication == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	if ((pMiscellaneousIndication->type.choice == logicalChannelActive_chosen) ||
		(pMiscellaneousIndication->type.choice == logicalChannelInactive_chosen))
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pConference->LocalEndpointAttached != ATTACHED) ||
		(pCall->CallState != CALL_COMPLETE) ||
		(pCall->CallType == VIRTUAL_CALL)) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (hChannel == CC_INVALID_HANDLE) {
		wChannelNumber = 1;
	} else {
		status = LockChannel(hChannel, &pChannel);
		if (status != CC_OK) {
			UnlockCall(pCall);
			UnlockConference(pConference);
			LeaveCallControlTop(status);
		}
		switch (pChannel->bChannelType) {
			case TX_CHANNEL:
				wChannelNumber = pChannel->wLocalChannelNumber;
				break;

			case RX_CHANNEL:
				wChannelNumber = pChannel->wRemoteChannelNumber;
				break;

			case TXRX_CHANNEL:
				wChannelNumber = pChannel->wRemoteChannelNumber;
				break;

			case PROXY_CHANNEL:
				if (pChannel->hCall == hCall)
					wChannelNumber = pChannel->wRemoteChannelNumber;
				else
					wChannelNumber = pChannel->wLocalChannelNumber;
				break;

			default:
				ASSERT(0);
				break;
		}
		UnlockChannel(pChannel);
	}

	// Construct an H.245 PDU to hold a miscellaneous indication
	Pdu.choice = indication_chosen;
	Pdu.u.indication.choice = miscellaneousIndication_chosen;
	Pdu.u.indication.u.miscellaneousIndication = *pMiscellaneousIndication;
	Pdu.u.indication.u.miscellaneousIndication.logicalChannelNumber = wChannelNumber;

	status = H245SendPDU(pCall->H245Instance,	// H245 instance
						 &Pdu);

	UnlockCall(pCall);
	UnlockConference(pConference);
	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_Hangup(					CC_HCONFERENCE			hConference,
									BOOL					bTerminateConference,
									DWORD					dwUserToken)
{
HRESULT						status;
HRESULT						SaveStatus;
HHANGUP						hHangup;
PHANGUP						pHangup;
PCHANNEL					pChannel;
PCALL						pCall;
PCONFERENCE					pConference;
CC_HANGUP_CALLBACK_PARAMS	HangupCallbackParams;
HQ931CALL					hQ931Call;
WORD						wNumChannels;
PCC_HCHANNEL				ChannelList;
WORD						wNumCalls;
PCC_HCALL					CallList;
WORD						i;
H245_INST_T					H245Instance;
CALLSTATE					CallState;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (hConference == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockConference(hConference, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	// If the local endpoint is not attached, we will only allow a hangup if
	// the local endpoint is the MC in a multipoint conference and
	// conference termination is being requested
	if ((pConference->LocalEndpointAttached != ATTACHED) &&
		((bTerminateConference == FALSE) ||
		 (pConference->ConferenceMode != MULTIPOINT_MODE) ||
		 (pConference->tsMultipointController != TS_TRUE))) {
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	HangupCallbackParams.dwUserToken = dwUserToken;

	if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
		(pConference->tsMultipointController == TS_TRUE) &&
		(bTerminateConference == FALSE)) {

		// Send TerminalLeftConference (this call) to all established calls
		EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
		for (i = 0; i < wNumCalls; i++) {
			if (LockCall(CallList[i], &pCall) == CC_OK) {
				H245ConferenceIndication(pCall->H245Instance,
										 H245_IND_TERMINAL_LEFT,	// Indication Type
										 0,							// SBE number; ignored here
										 pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber,		 // MCU number
										 pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber); // terminal number
				UnlockCall(pCall);
			}
		}
		if (CallList != NULL)
			Free(CallList);

		// Delete all TX, RX and bi-directional channels on this conference
		// Leave PROXY_CHANNELs intact
		EnumerateChannelsInConference(&wNumChannels,
									  &ChannelList,
									  pConference,
									  TX_CHANNEL | RX_CHANNEL | TXRX_CHANNEL);
		for (i = 0; i < wNumChannels; i++) {
			if (LockChannel(ChannelList[i], &pChannel) == CC_OK)
				// Notice that since we're going to hangup, we don't need to
				// close any channels
				FreeChannel(pChannel);	
		}
		if (ChannelList != NULL)
			Free(ChannelList);

		if (pConference->bDeferredDelete) {
			ASSERT(pConference->LocalEndpointAttached == DETACHED);
			FreeConference(pConference);
		} else {
			InvokeUserConferenceCallback(pConference,
										 CC_HANGUP_INDICATION,
										 CC_OK,
										 &HangupCallbackParams);
			if (ValidateConference(hConference) == CC_OK) {
				pConference->LocalEndpointAttached = DETACHED;
				UnlockConference(pConference);
			}
		}
		LeaveCallControlTop(CC_OK);
	}

	status = EnumerateChannelsInConference(&wNumChannels,
										   &ChannelList,
										   pConference,
										   ALL_CHANNELS);
	if (status != CC_OK) {
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	// free all the channels
	for (i = 0; i < wNumChannels; i++) {
		if (LockChannel(ChannelList[i], &pChannel) == CC_OK)
			// Notice that since we're going to hangup, we don't need to
			// close any channels
			FreeChannel(pChannel);	
	}
	if (ChannelList != NULL)
		Free(ChannelList);

	status = EnumerateCallsInConference(&wNumCalls, &CallList, pConference, REAL_CALLS);
	if (status != CC_OK) {
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
		(pConference->tsMultipointController == TS_FALSE) &&
		(bTerminateConference == TRUE)) {
		ASSERT(wNumCalls == 1);
		
		if (LockCall(CallList[0], &pCall) == CC_OK) {
			// Send DropConference command to MC
			H245ConferenceCommand   (
						 pCall->H245Instance,
						 H245_CMD_DROP_CONFERENCE, // Command type
						 1,			// Channel
						 0,			// byMcuNumber
						 0);		// byTerminalNumber
			UnlockCall(pCall);
		}
	}

	status = AllocAndLockHangup(&hHangup,
								hConference,
								dwUserToken,
								&pHangup);
	if (status != CC_OK) {
	    if (CallList != NULL)
		    Free(CallList);
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	// Now close all calls
	SaveStatus = H245_ERROR_OK;
	for (i = 0; i < wNumCalls; i++) {
		if (LockCall(CallList[i], &pCall) == CC_OK) {
			H245Instance = pCall->H245Instance;
			hQ931Call = pCall->hQ931Call;
			CallState = pCall->CallState;
			FreeCall(pCall);
			if (CallState != ENQUEUED) {
				if (H245Instance != H245_INVALID_ID) {
					status = H245ShutDown(H245Instance);
					if (status == H245_ERROR_OK)
						pHangup->wNumCalls++;
					else
						// The link may already be shut down; if so, don't return an error
						if (status != LINK_INVALID_STATE)
							SaveStatus = status;
				}
				if (SaveStatus == H245_ERROR_OK) {
					if ((CallState == PLACED) ||
						(CallState == RINGING))
						SaveStatus = Q931RejectCall(hQ931Call,
													CC_REJECT_UNDEFINED_REASON,
													&pConference->ConferenceID,
													NULL,	// alternate address
													NULL);	// pNonStandardData
					else
						SaveStatus = Q931Hangup(hQ931Call, CC_REJECT_NORMAL_CALL_CLEARING);
					// Q931Hangup may legitimately return CS_BAD_PARAM or LINK_INVALID_STATE,
					// because the Q.931 call object may have been deleted at this point
					if ((SaveStatus == CS_BAD_PARAM) ||
						(SaveStatus == LINK_INVALID_STATE))
						SaveStatus = CC_OK;
				} else
					if ((CallState == PLACED) ||
						(CallState == RINGING))
						Q931RejectCall(hQ931Call,
									   CC_REJECT_UNDEFINED_REASON,
									   &pConference->ConferenceID,
									   NULL,	// alternate address
									   NULL);	// pNonStandardData
					else
						Q931Hangup(hQ931Call, CC_REJECT_NORMAL_CALL_CLEARING);
			}
		}
	}

	if (CallList != NULL)
		Free(CallList);

	// Need to validate the conference object; H245ShutDown may cause us to re-enter
	// Call Control, which may result in deletion of the conference object
	if (ValidateConference(hConference) != CC_OK)
		LeaveCallControlTop(SaveStatus);

	// Delete the virtual calls (if any)
	EnumerateCallsInConference(&wNumCalls, &CallList, pConference, VIRTUAL_CALL);
	for (i = 0; i < wNumCalls; i++)
		if (LockCall(CallList[i], &pCall) == CC_OK) {
			FreeCall(pCall);
		}

	if (CallList != NULL)
		Free(CallList);

	// XXX -- for sync 2, H245ShutDown() is synchronous, so change wNumCalls
	// to cause the user callback and associated cleanup to occur synchronously
	pHangup->wNumCalls = 0;

	if (pHangup->wNumCalls == 0) {
		if (pConference->bDeferredDelete) {
			ASSERT(pConference->LocalEndpointAttached == DETACHED);
			FreeConference(pConference);
		} else {
			InvokeUserConferenceCallback(pConference,
										 CC_HANGUP_INDICATION,
										 SaveStatus,
										 &HangupCallbackParams);
			if (ValidateConference(hConference) == CC_OK) {
				ReInitializeConference(pConference);
				UnlockConference(pConference);
			}
		}
		if (ValidateHangup(hHangup) == CC_OK)
			FreeHangup(pHangup);
		LeaveCallControlTop(SaveStatus);
	} else {
		UnlockHangup(pHangup);
		LeaveCallControlTop(SaveStatus);
	}
}



CC_API
HRESULT CC_MaximumAudioVideoSkew(	CC_HCHANNEL				hChannelAudio,
									CC_HCHANNEL				hChannelVideo,
									WORD					wMaximumSkew)
{
HRESULT		status;
PCALL		pCall;
PCONFERENCE	pConference;
PCHANNEL	pChannelAudio;
PCHANNEL	pChannelVideo;
PCC_HCALL	CallList;
WORD		wNumCalls;
WORD		i;
WORD		wNumSuccesses;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if ((hChannelAudio == CC_INVALID_HANDLE) || (hChannelVideo == CC_INVALID_HANDLE))
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockChannelAndConference(hChannelAudio, &pChannelAudio, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = LockChannel(hChannelVideo, &pChannelVideo);
	if (status != CC_OK) {
		UnlockChannel(pChannelAudio);
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	if ((pChannelAudio->hConference != pChannelVideo->hConference) ||
		(pChannelAudio->bChannelType != TX_CHANNEL) ||
		(pChannelAudio->wNumOutstandingRequests != 0) ||
		(pChannelVideo->bChannelType != TX_CHANNEL) ||
		(pChannelVideo->wNumOutstandingRequests != 0)) {
		UnlockChannel(pChannelAudio);
		UnlockChannel(pChannelVideo);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);

	wNumSuccesses = 0;
	for (i = 0; i < wNumCalls; i++) {
		if (LockCall(CallList[i], &pCall) == CC_OK) {
			status = H245H2250MaximumSkewIndication(pCall->H245Instance,
											        pChannelAudio->wLocalChannelNumber,
											        pChannelVideo->wLocalChannelNumber,
											        wMaximumSkew);
			UnlockCall(pCall);
			if (status == H245_ERROR_OK)
				wNumSuccesses++;
		}
	}

	if (CallList != NULL)
		Free(CallList);

	UnlockChannel(pChannelAudio);
	UnlockChannel(pChannelVideo);
	UnlockConference(pConference);
	if (wNumSuccesses == 0) {
		LeaveCallControlTop(status);
	} else {
		LeaveCallControlTop(CC_OK);
	}
}



CC_API
HRESULT CC_Mute(					CC_HCHANNEL				hChannel)
{
HRESULT		status;
HRESULT		SaveStatus;
PCHANNEL	pChannel;
PCONFERENCE	pConference;
PCALL		pCall;
PDU_T		Pdu;
WORD		wNumCalls;
PCC_HCALL	CallList;
WORD		i;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hChannel == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockChannelAndConference(hChannel, &pChannel, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if (pChannel->bChannelType != TX_CHANNEL) {
		// can only mute transmit channels
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (pConference->LocalEndpointAttached != ATTACHED) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	status = EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
	if (status != CC_OK) {
		UnlockConference(pConference);
		UnlockChannel(pChannel);
		LeaveCallControlTop(status);
	}

	// Construct an H.245 PDU to hold a miscellaneous indication
	// of "logical channel inactive"
	Pdu.choice = indication_chosen;
	Pdu.u.indication.choice = miscellaneousIndication_chosen;
	Pdu.u.indication.u.miscellaneousIndication.logicalChannelNumber =
		pChannel->wLocalChannelNumber;
	Pdu.u.indication.u.miscellaneousIndication.type.choice = logicalChannelInactive_chosen;

	SaveStatus = CC_OK;
	for (i = 0; i < wNumCalls; i++) {
		if (LockCall(CallList[i], &pCall) == CC_OK) {
			status = H245SendPDU(pCall->H245Instance,	// H245 instance
								 &Pdu);
			// Note that this channel may not have been accepted on all of the calls,
			// so we could get an H245_ERROR_INVALID_CHANNEL error
			if ((status != H245_ERROR_OK) && (status != H245_ERROR_INVALID_CHANNEL))
				SaveStatus = status;
			UnlockCall(pCall);
		}
	}

	if (CallList != NULL)
		Free(CallList);

	UnlockConference(pConference);
	UnlockChannel(pChannel);
	LeaveCallControlTop(SaveStatus);
}



CC_API
HRESULT CC_OpenChannel(				CC_HCONFERENCE			hConference,
									PCC_HCHANNEL			phChannel,
									BYTE					bSessionID,
									BYTE					bAssociatedSessionID,
									BOOL					bSilenceSuppression,
									PCC_TERMCAP				pTermCap,
									PCC_ADDR				pLocalRTCPAddr,
									BYTE					bDynamicRTPPayloadType,
									DWORD					dwBandwidth,
									DWORD					dwUserToken)
{
HRESULT		status;
PCONFERENCE	pConference;
PCHANNEL	pChannel;
CC_HCALL	hCall;
PCALL		pCall;
H245_MUX_T	H245MuxTable;
WORD		i;
PCC_ADDR	pLocalRTPAddr;
PCC_ADDR	pPeerRTPAddr;
PCC_ADDR	pPeerRTCPAddr;
BOOL		bFoundSession;
WORD		wNumCalls;
PCC_HCALL	CallList;
#ifndef GATEKEEPER
HRESULT		SaveStatus;
#endif // !GATEKEEPER

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (phChannel == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	// set phChannel now, in case we encounter an error
	*phChannel = CC_INVALID_HANDLE;
	
	if (hConference == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (pLocalRTCPAddr != NULL)
		if (pLocalRTCPAddr->nAddrType != CC_IP_BINARY)
			LeaveCallControlTop(CC_BAD_PARAM);
	
	if (pTermCap == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	if ((bDynamicRTPPayloadType != 0) &&
		((bDynamicRTPPayloadType < 96) || (bDynamicRTPPayloadType > 127)))
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockConferenceEx(hConference,
							  &pConference,
							  TS_FALSE);	// bDeferredDelete
	if (status != CC_OK)
		LeaveCallControlTop(status);

	// XXX -- we may eventually want to support dynamic session generation
	if (bSessionID == 0)
		if ((pConference->tsMaster == TS_TRUE) ||
			(pConference->ConferenceMode == MULTIPOINT_MODE)) {
			UnlockConference(pConference);
			LeaveCallControlTop(CC_BAD_PARAM);
		}

	if (((pConference->ConferenceMode == MULTIPOINT_MODE) &&
		(pLocalRTCPAddr != NULL)) ||
		((pConference->ConferenceMode != MULTIPOINT_MODE) &&
		(pLocalRTCPAddr == NULL))) {
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (pConference->LocalEndpointAttached != ATTACHED) {
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (pConference->ConferenceMode == MULTIPOINT_MODE) {
		// XXX -- We should be able to dynamically create a new session if needed
		// Validate session ID
		pLocalRTPAddr = NULL;
		pLocalRTCPAddr = NULL;
		bFoundSession = FALSE;
		if (pConference->pSessionTable != NULL) {
			for (i = 0; i < pConference->pSessionTable->wLength; i++) {
				if (bSessionID == pConference->pSessionTable->SessionInfoArray[i].bSessionID) {
					bFoundSession = TRUE;
					if (pConference->tsMultipointController == TS_TRUE) {
						pLocalRTPAddr = pConference->pSessionTable->SessionInfoArray[i].pRTPAddr;
						pLocalRTCPAddr = pConference->pSessionTable->SessionInfoArray[i].pRTCPAddr;
					}
					break;
				}
			}
		}
		if (bFoundSession == FALSE) {
			UnlockConference(pConference);
			LeaveCallControlTop(CC_BAD_PARAM);
		}
		pPeerRTPAddr = pLocalRTPAddr;
		pPeerRTCPAddr = pLocalRTCPAddr;
	} else {
		pLocalRTPAddr = NULL;
		pPeerRTPAddr = NULL;
		pPeerRTCPAddr = NULL;
	}

	H245MuxTable.Kind = H245_H2250;
	H245MuxTable.u.H2250.nonStandardList = NULL;
	if (pLocalRTPAddr != NULL) {
		if (pLocalRTPAddr->bMulticast)
			H245MuxTable.u.H2250.mediaChannel.type = H245_IP_MULTICAST;
		else
			H245MuxTable.u.H2250.mediaChannel.type = H245_IP_UNICAST;
		H245MuxTable.u.H2250.mediaChannel.u.ip.tsapIdentifier =
			pLocalRTPAddr->Addr.IP_Binary.wPort;
		HostToH245IPNetwork(H245MuxTable.u.H2250.mediaChannel.u.ip.network,
							pLocalRTPAddr->Addr.IP_Binary.dwAddr);
		H245MuxTable.u.H2250.mediaChannelPresent = TRUE;
	} else
		H245MuxTable.u.H2250.mediaChannelPresent = FALSE;
	if (pLocalRTCPAddr != NULL) {
		if (pLocalRTCPAddr->bMulticast)
			H245MuxTable.u.H2250.mediaControlChannel.type = H245_IP_MULTICAST;
		else
			H245MuxTable.u.H2250.mediaControlChannel.type = H245_IP_UNICAST;
		H245MuxTable.u.H2250.mediaControlChannel.u.ip.tsapIdentifier =
			pLocalRTCPAddr->Addr.IP_Binary.wPort;
		HostToH245IPNetwork(H245MuxTable.u.H2250.mediaControlChannel.u.ip.network,
							pLocalRTCPAddr->Addr.IP_Binary.dwAddr);
		H245MuxTable.u.H2250.mediaControlChannelPresent = TRUE;
	} else
		H245MuxTable.u.H2250.mediaControlChannelPresent = FALSE;

	if (bDynamicRTPPayloadType == 0)
		H245MuxTable.u.H2250.dynamicRTPPayloadTypePresent = FALSE;
	else {
		H245MuxTable.u.H2250.dynamicRTPPayloadTypePresent = TRUE;
		H245MuxTable.u.H2250.dynamicRTPPayloadType = bDynamicRTPPayloadType;
	}
	H245MuxTable.u.H2250.sessionID = bSessionID;
	if (bAssociatedSessionID == 0)
		H245MuxTable.u.H2250.associatedSessionIDPresent = FALSE;
	else {
		H245MuxTable.u.H2250.associatedSessionIDPresent = TRUE;
		H245MuxTable.u.H2250.associatedSessionID = bAssociatedSessionID;
	}
	H245MuxTable.u.H2250.mediaGuaranteed = FALSE;
	H245MuxTable.u.H2250.mediaGuaranteedPresent = TRUE;
	H245MuxTable.u.H2250.mediaControlGuaranteed = FALSE;
	H245MuxTable.u.H2250.mediaControlGuaranteedPresent = TRUE;
	// The silence suppression field must be present if and only if
	// the channel is an audio channel
	if (pTermCap->DataType == H245_DATA_AUDIO) {
		H245MuxTable.u.H2250.silenceSuppressionPresent = TRUE;
		H245MuxTable.u.H2250.silenceSuppression = (char) bSilenceSuppression;
	} else
		H245MuxTable.u.H2250.silenceSuppressionPresent = FALSE;

	if (pConference->ConferenceMode == POINT_TO_POINT_MODE)
		H245MuxTable.u.H2250.destinationPresent = FALSE;
	else {
		H245MuxTable.u.H2250.destinationPresent = TRUE;
		H245MuxTable.u.H2250.destination.mcuNumber = pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber;
		H245MuxTable.u.H2250.destination.terminalNumber = pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber;
	}

	H245MuxTable.u.H2250.h261aVideoPacketization = FALSE;

	// Set hCall in the channel object to indicate which call object
	// the channel is being opened to; if we're in multipoint mode,
	// the channel may be opened to multiple calls, to set hCall
	// to CC_INVALID_HANDLE. If the channel is opened in point-to-point
	// mode, and we later switch to multipoint mode and this peer hangs
	// up, hCall will be used to determine whether this call object
	// should be deleted
	if (pConference->ConferenceMode == POINT_TO_POINT_MODE)	{
		EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
		ASSERT(wNumCalls == 1);
		hCall = CallList[0];
		Free(CallList);
	} else {
		hCall = CC_INVALID_HANDLE;
	}

	status = AllocAndLockChannel(phChannel,
								 pConference,
								 hCall,				// hCall
								 pTermCap,			// Tx term cap
								 NULL,				// Rx term cap
								 &H245MuxTable,		// Tx mux table
								 NULL,				// Rx mux table
								 NULL,				// separate stack
								 dwUserToken,
								 TX_CHANNEL,
								 bSessionID,
								 bAssociatedSessionID,
								 0,					// remote channel number
								 pLocalRTPAddr,
								 pLocalRTCPAddr,
								 pPeerRTPAddr,
								 pPeerRTCPAddr,
								 TRUE,				// locally opened
								 dwBandwidth,
								 &pChannel);
	if (status != CC_OK) {
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	status = AddChannelToConference(pChannel, pConference);
	if (status != CC_OK) {
		FreeChannel(pChannel);
		UnlockConference(pConference);
		*phChannel = CC_INVALID_HANDLE;
		LeaveCallControlTop(status);
	}

	status = EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
	if (status != CC_OK) {
		FreeChannel(pChannel);
		UnlockConference(pConference);
		*phChannel = CC_INVALID_HANDLE;
		LeaveCallControlTop(status);
	}

#ifdef    GATEKEEPER
	UnlockChannel(pChannel);
	UnlockConference(pConference);
    // If point-to-point mode, than wNumCalls == 1 and CallList[0] == hCall
    // If multipoint, choice of which channel to assign TX bandwidth to
    // is arbitrary. Either way, CallList[0] works.
	status = LockCall(CallList[0], &pCall);
	if (status == CC_OK) {
		status = GkiOpenChannel(&pCall->GkiCall, dwBandwidth, *phChannel, TX);
    	if (ValidateCall(CallList[0]) == CC_OK)
	    	UnlockCall(pCall);
	}
	Free(CallList);
	LeaveCallControlTop(status);
#else  // GATEKEEPER
	// Open a logical channel for each established call
	SaveStatus = CC_OK;
	for (i = 0; i < wNumCalls; i++) {
		if (LockCall(CallList[i], &pCall) == CC_OK) {
			status = H245OpenChannel(pCall->H245Instance,		// H245 instance
									 pChannel->hChannel,		// dwTransId
									 pChannel->wLocalChannelNumber,
									 pChannel->pTxH245TermCap,	// TxMode
									 pChannel->pTxMuxTable,		// TxMux
									 H245_INVALID_PORT_NUMBER,	// TxPort
									 pChannel->pRxH245TermCap,	// RxMode
									 pChannel->pRxMuxTable,		// RxMux
									 pChannel->pSeparateStack);
			if (status == H245_ERROR_OK)
				(pChannel->wNumOutstandingRequests)++;
			else
				SaveStatus = status;
			UnlockCall(pCall);
		}
	}

	if (CallList != NULL)
		Free(CallList);

	if (pChannel->wNumOutstandingRequests == 0) {
		// all open channel requests failed
		FreeChannel(pChannel);
		UnlockConference(pConference);
		*phChannel = CC_INVALID_HANDLE;
		LeaveCallControlTop(SaveStatus);
	}

	UnlockChannel(pChannel);
	UnlockConference(pConference);
	LeaveCallControlTop(CC_OK);
#endif // GATEKEEPER

}



HRESULT CC_OpenT120Channel(			CC_HCONFERENCE			hConference,
                           			PCC_HCHANNEL			phChannel,
									BOOL					bAssociateConference,
									PCC_OCTETSTRING			pExternalReference,
									PCC_ADDR				pAddr,
									DWORD					dwBandwidth,
									DWORD					dwUserToken)
{
HRESULT			status;
PCALL			pCall;
PCONFERENCE		pConference;
PCHANNEL		pChannel;
H245_MUX_T		H245MuxTable;
CC_TERMCAP		TermCap;
H245_ACCESS_T	SeparateStack;
H245_ACCESS_T	*pSeparateStack;
BYTE			bSessionID;
WORD			wNumCalls;
PCC_HCALL		CallList;
HRESULT			SaveStatus;
int				i;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (hConference == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);
	
	if (pAddr != NULL)
		if ((pAddr->nAddrType != CC_IP_BINARY) ||
            (pAddr->bMulticast == TRUE))
			LeaveCallControlTop(CC_BAD_PARAM);

	if (pExternalReference != NULL)
		if (pExternalReference->wOctetStringLength > 255)
			LeaveCallControlTop(CC_BAD_PARAM);

	status = LockConference(hConference, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if (pConference->LocalEndpointAttached != ATTACHED) {
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	// Assume that T.120 channels are always opened with a session ID of 0
	bSessionID = 0;

	H245MuxTable.Kind = H245_H2250;
	H245MuxTable.u.H2250.nonStandardList = NULL;
	H245MuxTable.u.H2250.mediaChannelPresent = FALSE;
	H245MuxTable.u.H2250.mediaControlChannelPresent = FALSE;
	H245MuxTable.u.H2250.dynamicRTPPayloadTypePresent = FALSE;
	H245MuxTable.u.H2250.sessionID = bSessionID;
	H245MuxTable.u.H2250.associatedSessionIDPresent = FALSE;
	H245MuxTable.u.H2250.mediaGuaranteedPresent = FALSE;
	H245MuxTable.u.H2250.mediaControlGuaranteedPresent = FALSE;
	H245MuxTable.u.H2250.silenceSuppressionPresent = FALSE;
	if (pConference->ConferenceMode == POINT_TO_POINT_MODE)
		H245MuxTable.u.H2250.destinationPresent = FALSE;
	else {
		H245MuxTable.u.H2250.destinationPresent = TRUE;
		H245MuxTable.u.H2250.destination.mcuNumber = pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber;
		H245MuxTable.u.H2250.destination.terminalNumber = pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber;
	}
	H245MuxTable.u.H2250.h261aVideoPacketization = FALSE;

	TermCap.Dir = H245_CAPDIR_LCLRXTX;
	TermCap.DataType = H245_DATA_DATA;
	TermCap.ClientType = H245_CLIENT_DAT_T120;
	TermCap.CapId = 0;
	TermCap.Cap.H245Dat_T120.maxBitRate = dwBandwidth;
	TermCap.Cap.H245Dat_T120.application.choice = DACy_applctn_t120_chosen;
	TermCap.Cap.H245Dat_T120.application.u.DACy_applctn_t120.choice = separateLANStack_chosen;

	if (pAddr != NULL) {
		SeparateStack.bit_mask = distribution_present;
		SeparateStack.distribution.choice = unicast_chosen;
		if (pExternalReference != NULL)	{
			SeparateStack.bit_mask |= externalReference_present;
			SeparateStack.externalReference.length = pExternalReference->wOctetStringLength;
			memcpy(SeparateStack.externalReference.value,
				   pExternalReference->pOctetString,
				   pExternalReference->wOctetStringLength);
		}
		SeparateStack.networkAddress.choice = localAreaAddress_chosen;
		SeparateStack.networkAddress.u.localAreaAddress.choice = unicastAddress_chosen;
		SeparateStack.networkAddress.u.localAreaAddress.u.unicastAddress.choice = UnicastAddress_iPAddress_chosen;
		SeparateStack.networkAddress.u.localAreaAddress.u.unicastAddress.u.UnicastAddress_iPAddress.tsapIdentifier =
			pAddr->Addr.IP_Binary.wPort;
		SeparateStack.networkAddress.u.localAreaAddress.u.unicastAddress.u.UnicastAddress_iPAddress.network.length = 4;
		HostToH245IPNetwork(SeparateStack.networkAddress.u.localAreaAddress.u.unicastAddress.u.UnicastAddress_iPAddress.network.value,
							pAddr->Addr.IP_Binary.dwAddr);
		SeparateStack.associateConference = (char) bAssociateConference;
		pSeparateStack = &SeparateStack;
	} else {
		pSeparateStack = NULL;
	}
	
    status = AllocAndLockChannel(phChannel,
						         pConference,
						         CC_INVALID_HANDLE,	// hCall
						         &TermCap,			// Tx term cap
						         &TermCap,			// Rx term cap
						         &H245MuxTable,		// Tx mux table
						         &H245MuxTable,		// Rx mux table
						         pSeparateStack,	// separate stack
						         dwUserToken,
						         TXRX_CHANNEL,
						         bSessionID,
						         0,					// associated session ID
						         0,					// remote channel
								 NULL,				// local RTP addr
						         NULL,				// local RTCP addr
						         NULL,				// peer RTP addr
						         NULL,				// peer RTCP addr
								 TRUE,				// locally opened
								 dwBandwidth,
						         &pChannel);
	if (status != CC_OK) {
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	pChannel->tsAccepted = TS_TRUE;

	status = AddChannelToConference(pChannel, pConference);
	if (status != CC_OK) {
		FreeChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);

	SaveStatus = CC_OK;
	for (i = 0; i < wNumCalls; i++) {
		if (LockCall(CallList[i], &pCall) == CC_OK) {
			status = H245OpenChannel(pCall->H245Instance,		// H245 instance
									 pChannel->hChannel,		// dwTransId
									 pChannel->wLocalChannelNumber,
									 pChannel->pTxH245TermCap,	// TxMode
									 pChannel->pTxMuxTable,		// TxMux
									 H245_INVALID_PORT_NUMBER,	// TxPort
									 pChannel->pRxH245TermCap,	// RxMode
									 pChannel->pRxMuxTable,		// RxMux
									 pChannel->pSeparateStack);
			if (status == H245_ERROR_OK)
				(pChannel->wNumOutstandingRequests)++;
			else
				SaveStatus = status;
			UnlockCall(pCall);
		}
	}
	Free(CallList);
	if (pChannel->wNumOutstandingRequests == 0) {
		// All open channel requests failed
		FreeChannel(pChannel);
		status = SaveStatus;
	} else {
		UnlockChannel(pChannel);
		status = CC_OK;
	}
	UnlockConference(pConference);

	LeaveCallControlTop(status);
}



HRESULT CC_Ping(					CC_HCALL				hCall,
									DWORD					dwTimeout)
{
PCALL			pCall;
HRESULT			status;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);
	
	status = LockCall(hCall, &pCall);
	if (status != CC_OK)
		LeaveCallControlTop(status);
	
	if ((pCall->CallState != CALL_COMPLETE) ||
		(pCall->CallType == VIRTUAL_CALL)) {
		UnlockCall(pCall);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	// Set the T105 timeout value as specified by the user;
	// note that the previous timeout value is returned in this parameter
	H245SystemControl(0, H245_SYSCON_SET_FSM_T105, &dwTimeout);

	status = H245RoundTripDelayRequest(pCall->H245Instance,
									   0); // dwTransId

	// Reset the T105 timeout value to its original setting
	H245SystemControl(0, H245_SYSCON_SET_FSM_T105, &dwTimeout);

	UnlockCall(pCall);
	LeaveCallControlTop(status);
}


	
CC_API
HRESULT CC_PlaceCall(				CC_HCONFERENCE			hConference,
									PCC_HCALL				phCall,
									PCC_ALIASNAMES			pLocalAliasNames,
									PCC_ALIASNAMES			pCalleeAliasNames,
									PCC_ALIASNAMES			pCalleeExtraAliasNames,
									PCC_ALIASITEM			pCalleeExtension,
									PCC_NONSTANDARDDATA		pNonStandardData,
									PWSTR					pszDisplay,
									PCC_ADDR				pDestinationAddr,
									PCC_ADDR				pConnectAddr,
                                    DWORD                   dwBandwidth,
									DWORD					dwUserToken)
{
PCALL				pCall;
CC_HCALL            hCall;
PCONFERENCE			pConference;
HRESULT				status;
CALLTYPE			CallType = CALLER;
CALLSTATE			CallState = PLACED;
WORD				wNumCalls;
BOOL				bCallerIsMC;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (phCall == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	// set hCall now, in case we encounter an error
	*phCall = CC_INVALID_HANDLE;

	if (hConference == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = Q931ValidateAliasNames(pLocalAliasNames);
	if (status != CS_OK)
		LeaveCallControlTop(status);

	status = Q931ValidateAliasNames(pCalleeAliasNames);
	if (status != CS_OK)
		LeaveCallControlTop(status);

	status = Q931ValidateAliasNames(pCalleeExtraAliasNames);
	if (status != CS_OK)
		LeaveCallControlTop(status);

	status = Q931ValidateAliasItem(pCalleeExtension);
	if (status != CS_OK)
		LeaveCallControlTop(status);

	status = ValidateNonStandardData(pNonStandardData);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = ValidateDisplay(pszDisplay);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pDestinationAddr == NULL) &&
		(pConnectAddr == NULL) &&
		(pCalleeAliasNames == NULL))
		LeaveCallControlTop(CC_BAD_PARAM);

	status = ValidateAddr(pDestinationAddr);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = ValidateAddr(pConnectAddr);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = SetQ931Port(pDestinationAddr);
 	if (status != CS_OK)
		LeaveCallControlTop(status);

	status = SetQ931Port(pConnectAddr);
 	if (status != CS_OK)
		LeaveCallControlTop(status);

	status = LockConferenceEx(hConference,
							  &pConference,
							  TS_FALSE);	// bDeferredDelete
	if (status != CC_OK)
		LeaveCallControlTop(status);

	EnumerateCallsInConference(&wNumCalls, NULL, pConference, REAL_CALLS);

	if (wNumCalls > 0) {
		if (pConference->tsMultipointController == TS_TRUE) {
			// Place Call directly to callee
			status = CC_OK;
			ASSERT(!EqualConferenceIDs(&pConference->ConferenceID, &InvalidConferenceID));
			CallType = CALLER;
			CallState = PLACED;
		} else { // we're not the MC
			if (pConference->bMultipointCapable) {
				if (pConference->pMultipointControllerAddr != NULL) {
					// Place Call to MC
					status = CC_OK;
					if (pDestinationAddr == NULL)
						pDestinationAddr = pConnectAddr;
					pConnectAddr = pConference->pMultipointControllerAddr;
					ASSERT(!EqualConferenceIDs(&pConference->ConferenceID, &InvalidConferenceID));
					CallType = THIRD_PARTY_INVITOR;
					CallState = PLACED;
				} else { // we don't have an MC address
					if (pConference->tsMaster == TS_UNKNOWN) {
						ASSERT(pConference->tsMultipointController == TS_UNKNOWN);
						status = CC_OK;
						CallType = CALLER;
						CallState = ENQUEUED;
					} else {
						ASSERT(pConference->tsMultipointController == TS_FALSE);
						// Error, no MC
						// XXX -- we may eventually want to enqueue the request
						// and set an expiration timer
						status = CC_NOT_MULTIPOINT_CAPABLE;
						CallType = THIRD_PARTY_INVITOR;
						CallState = ENQUEUED;
					}
				}
			} else { // we're not multipoint capable
				// Error - bad param
				ASSERT(wNumCalls == 1);
				status = CC_BAD_PARAM;
			}
		}
	} else { // wNumCalls == 0
		// Place Call directly to callee
		status = CC_OK;
		CallType = CALLER;
		CallState = PLACED;
	}
	
	if (status != CC_OK) {
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	if (pConference->tsMultipointController == TS_TRUE)
		bCallerIsMC = TRUE;
	else
		bCallerIsMC = FALSE;

	status = AllocAndLockCall(&hCall,
							  hConference,
							  CC_INVALID_HANDLE,	// hQ931Call
							  CC_INVALID_HANDLE,	// hQ931CallInvitor
							  pLocalAliasNames,     // local alias names
							  pCalleeAliasNames,	// remote alias names
							  pCalleeExtraAliasNames,// remote extra alias names
							  pCalleeExtension,		// remote extension
							  pNonStandardData,		// local non-standard data
							  NULL,					// remote non-standard data
							  pszDisplay,			// local display
							  NULL,					// remote display
							  NULL,					// remote vendor info
							  NULL,					// local connect address
							  pConnectAddr,			// peer connect address
							  pDestinationAddr,		// peer destination address
							  NULL,					// source call signal address
							  CallType,				// call type
							  bCallerIsMC,
							  dwUserToken,			// user token
							  CallState,			// call state
							  dwBandwidth,
							  &pConference->ConferenceID,
							  &pCall);
	if (status != CC_OK) {
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

#ifdef    GATEKEEPER
	// Fill in Gatekeeper Call fields
	memset(&pCall->GkiCall, 0, sizeof(pCall->GkiCall));

	if (pCalleeAliasNames != NULL) {
		// make a local copy of the peer alias names
		status = Q931CopyAliasNames(&pCall->GkiCall.pCalleeAliasNames, pCalleeAliasNames);
		if (status != CS_OK) {
			FreeCall(pCall);
			UnlockConference(pConference);
			LeaveCallControlTop(status);
		}
	}

	if (pCalleeExtraAliasNames != NULL) {
		// make a local copy of the peer alias names
		status = Q931CopyAliasNames(&pCall->GkiCall.pCalleeExtraAliasNames,
									pCalleeExtraAliasNames);
		if (status != CS_OK) {
			FreeCall(pCall);
			UnlockConference(pConference);
			LeaveCallControlTop(status);
		}
	}

	pCall->GkiCall.pCall            = pCall;
	pCall->GkiCall.hCall            = hCall;
    pCall->GkiCall.pConferenceId    = pCall->ConferenceID.buffer;
	pCall->GkiCall.bActiveMC        = pCall->bCallerIsMC;
	pCall->GkiCall.bAnswerCall      = FALSE;

    if (pCall->pQ931PeerConnectAddr) {
        pCall->GkiCall.dwIpAddress = ADDRToInetAddr(pCall->pQ931PeerConnectAddr);
        pCall->GkiCall.wPort       = ADDRToInetPort(pCall->pQ931PeerConnectAddr);
    } else if (pCall->pQ931DestinationAddr) {
        pCall->GkiCall.dwIpAddress = ADDRToInetAddr(pCall->pQ931DestinationAddr);
        pCall->GkiCall.wPort       = ADDRToInetPort(pCall->pQ931DestinationAddr);
    }
    
	pCall->GkiCall.wPort = (WORD)((pCall->GkiCall.wPort<<8)|(pCall->GkiCall.wPort>>8));

	if (pConference->bMultipointCapable)
		pCall->GkiCall.CallType = MANY_TO_MANY; 
	else
		pCall->GkiCall.CallType = POINT_TO_POINT;
    pCall->GkiCall.uBandwidthRequested = dwBandwidth / 100;

	status = GkiOpenCall(&pCall->GkiCall, pConference);
    if (ValidateCall(hCall) == CC_OK) {
        if (status == CC_OK) {
		    UnlockCall(pCall);
            *phCall = hCall;
        } else {
		    FreeCall(pCall);
        }
	}

	if (ValidateConference(hConference) == CC_OK)
	    UnlockConference(pConference);
#else  // GATEKEEPER
	status = PlaceCall(pCall, pConference);
	if (status == CC_OK) {
		UnlockCall(pCall);
        *phCall = hCall;
	} else {
		FreeCall(pCall);
	}

	UnlockConference(pConference);
#endif // GATEKEEPER

	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_RejectCall(				BYTE					bRejectReason,
									PCC_NONSTANDARDDATA		pNonStandardData,
									CC_HCALL				hCall)
{
HRESULT			status;
HRESULT			SaveStatus;
PCALL			pCall;
HQ931CALL		hQ931Call;
CC_CONFERENCEID	ConferenceID;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	SaveStatus = CC_OK;

	// validate parameters
	if ((bRejectReason != CC_REJECT_IN_CONF) &&
		(bRejectReason != CC_REJECT_UNDEFINED_REASON) &&
		(bRejectReason != CC_REJECT_DESTINATION_REJECTION) &&
		(bRejectReason != CC_REJECT_NO_ANSWER) &&
		(bRejectReason != CC_REJECT_NOT_IMPLEMENTED) &&
		(bRejectReason != CC_REJECT_USER_BUSY)) {
		bRejectReason = CC_REJECT_UNDEFINED_REASON;
		SaveStatus = CC_BAD_PARAM;
	}

	status = ValidateNonStandardData(pNonStandardData);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockCall(hCall, &pCall);
	if (status != CC_OK)
		// note that we can't even tell Q931 to reject the call
		LeaveCallControlTop(status);

	if (pCall->CallState != INCOMING) {
		UnlockCall(pCall);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	hQ931Call = pCall->hQ931Call;
	ConferenceID = pCall->ConferenceID;
	FreeCall(pCall);
	Q931RejectCall(hQ931Call,			// Q931 call handle
				   bRejectReason,		// reject reason
				   &ConferenceID,
				   NULL,				// alternate address
				   pNonStandardData);	// non-standard data
	LeaveCallControlTop(SaveStatus);
}



CC_API
HRESULT CC_RejectChannel(			CC_HCHANNEL				hChannel,
									DWORD					dwRejectReason)

{
HRESULT		status;
PCHANNEL	pChannel;
PCALL		pCall;
PCONFERENCE	pConference;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hChannel == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if ((dwRejectReason != H245_REJ) &&
		(dwRejectReason != H245_REJ_TYPE_NOTSUPPORT) &&
		(dwRejectReason != H245_REJ_TYPE_NOTAVAIL) &&
		(dwRejectReason != H245_REJ_TYPE_UNKNOWN) &&
		(dwRejectReason != H245_REJ_AL_COMB) &&
                (dwRejectReason != H245_REJ_MULTICAST) &&
                (dwRejectReason != H245_REJ_BANDWIDTH) &&
		(dwRejectReason != H245_REJ_SESSION_ID) &&
		(dwRejectReason != H245_REJ_MASTER_SLAVE_CONFLICT))
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockChannelAndConference(hChannel, &pChannel, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	// Make sure that hChannel is a receive, proxy or bi-directional
	// channel that hasn't already been accepted
	if (((pChannel->bChannelType != RX_CHANNEL) &&
		 (pChannel->bChannelType != PROXY_CHANNEL) &&
		 (pChannel->bChannelType != TXRX_CHANNEL)) ||
		 (pChannel->tsAccepted != TS_UNKNOWN)) {
		UnlockConference(pConference);
		UnlockChannel(pChannel);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (pConference->LocalEndpointAttached != ATTACHED) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	pChannel->tsAccepted = TS_FALSE;

	if (pChannel->wNumOutstandingRequests == 0) {
		ASSERT(pChannel->bMultipointChannel == TRUE);
		ASSERT(pChannel->bChannelType == PROXY_CHANNEL);
		ASSERT(pConference->ConferenceMode == MULTIPOINT_MODE);
		ASSERT(pConference->tsMultipointController == TS_TRUE);
		UnlockConference(pConference);
		UnlockChannel(pChannel);
		LeaveCallControlTop(CC_OK);
	}

	(pChannel->wNumOutstandingRequests)--;

	if (pChannel->wNumOutstandingRequests == 0) {
		status = LockCall(pChannel->hCall, &pCall);
		if (status != CC_OK) {
			UnlockConference(pConference);
			FreeChannel(pChannel);
			LeaveCallControlTop(status);
		}

		status = H245OpenChannelReject(pCall->H245Instance,
									   pChannel->wRemoteChannelNumber,	// Rx channel
									   (WORD)dwRejectReason);			// rejection reason
		UnlockCall(pCall);
		FreeChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	// Don't free the channel; it is a PROXY_CHANNEL and we're the MC,
	// so we need to keep the channel object around until the peer that
	// opened it closes it.
	ASSERT(pChannel->bMultipointChannel == TRUE);
	ASSERT(pChannel->bChannelType == PROXY_CHANNEL);
	ASSERT(pConference->ConferenceMode == MULTIPOINT_MODE);
	ASSERT(pConference->tsMultipointController == TS_TRUE);
	UnlockChannel(pChannel);
	UnlockConference(pConference);
	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_RequestMode(				CC_HCALL				hCall,
									WORD					wNumModeDescriptions,
									ModeDescription			ModeDescriptions[])
{
HRESULT		status;
PCALL		pCall;
PCONFERENCE	pConference;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (wNumModeDescriptions == 0)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (ModeDescriptions == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pConference->LocalEndpointAttached != ATTACHED) ||
		(pCall->CallState != CALL_COMPLETE) ||
		(pCall->CallType == VIRTUAL_CALL)) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	status = H245RequestMode(pCall->H245Instance,
							 pCall->H245Instance,	// trans ID
							 ModeDescriptions,
							 wNumModeDescriptions);

	UnlockCall(pCall);
	UnlockConference(pConference);

	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_RequestModeResponse(		CC_HCALL				hCall,
									CC_REQUEST_MODE_RESPONSE RequestModeResponse)
{
HRESULT		status;
PCALL		pCall;
PCONFERENCE	pConference;
BOOL		bAccept;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);
	
	switch (RequestModeResponse) {
		case CC_WILL_TRANSMIT_PREFERRED_MODE:
			RequestModeResponse = wllTrnsmtMstPrfrrdMd_chosen;
			bAccept = TRUE;
			break;
		case CC_WILL_TRANSMIT_LESS_PREFERRED_MODE:
			RequestModeResponse = wllTrnsmtLssPrfrrdMd_chosen;
			bAccept = TRUE;
			break;
		case CC_MODE_UNAVAILABLE:
			RequestModeResponse = H245_REJ_UNAVAILABLE;
			bAccept = FALSE;
			break;
		case CC_MULTIPOINT_CONSTRAINT:
			RequestModeResponse = H245_REJ_MULTIPOINT;
			bAccept = FALSE;
			break;
		case CC_REQUEST_DENIED:
			RequestModeResponse = H245_REJ_DENIED;
			bAccept = FALSE;
			break;
		default:
			LeaveCallControlTop(CC_BAD_PARAM);
	}

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = DequeueSpecificRequest(&pConference->pEnqueuedRequestModeCalls,
									hCall);
	if (status != CC_OK) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	if (bAccept == TRUE) {
		status = H245RequestModeAck(pCall->H245Instance,
									(WORD)RequestModeResponse);
	} else {
		status = H245RequestModeReject(pCall->H245Instance,
									   (WORD)RequestModeResponse);
	}

	UnlockCall(pCall);
	UnlockConference(pConference);
	
	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_SendNonStandardMessage(	CC_HCALL				hCall,
									BYTE					bH245MessageType,
									PCC_NONSTANDARDDATA		pNonStandardData)
{
HRESULT					status;
PCALL					pCall;
PCONFERENCE				pConference;
H245_MESSAGE_TYPE_T		H245MessageType;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	switch (bH245MessageType) {
		case CC_H245_MESSAGE_REQUEST:
			H245MessageType = H245_MESSAGE_REQUEST;
			break;
		case CC_H245_MESSAGE_RESPONSE:
			H245MessageType = H245_MESSAGE_RESPONSE;
			break;
		case CC_H245_MESSAGE_COMMAND:
			H245MessageType = H245_MESSAGE_COMMAND;
			break;
		case CC_H245_MESSAGE_INDICATION:
			H245MessageType = H245_MESSAGE_INDICATION;
			break;
		default:
			LeaveCallControlTop(CC_BAD_PARAM);
	}

	status = ValidateNonStandardData(pNonStandardData);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = LockCallAndConference(hCall,
								   &pCall,
								   &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pConference->LocalEndpointAttached != ATTACHED) ||
		(pCall->CallState != CALL_COMPLETE) ||
		(pCall->CallType == VIRTUAL_CALL)) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	status = H245NonStandardH221(pCall->H245Instance,
								 H245MessageType,
								 pNonStandardData->sData.pOctetString,
								 pNonStandardData->sData.wOctetStringLength,
								 pNonStandardData->bCountryCode,
								 pNonStandardData->bExtension,
								 pNonStandardData->wManufacturerCode);

	UnlockCall(pCall);
	UnlockConference(pConference);
	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_SendVendorID(			CC_HCALL				hCall,
									CC_NONSTANDARDDATA		NonStandardData,
									PCC_OCTETSTRING			pProductNumber,
									PCC_OCTETSTRING			pVersionNumber)
{
HRESULT					status;
PCALL					pCall;
PCONFERENCE				pConference;
BYTE					*pH245ProductNumber;
BYTE					bProductNumberLength;
BYTE					*pH245VersionNumber;
BYTE					bVersionNumberLength;
H245_NONSTANDID_T		H245Identifier;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = ValidateNonStandardData(&NonStandardData);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = ValidateOctetString(pProductNumber);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if (pProductNumber != NULL)
		if (pProductNumber->wOctetStringLength > 255)
			LeaveCallControlTop(CC_BAD_PARAM);

	status = ValidateOctetString(pVersionNumber);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if (pVersionNumber != NULL)
		if (pVersionNumber->wOctetStringLength > 255)
			LeaveCallControlTop(CC_BAD_PARAM);

	status = LockCallAndConference(hCall,
								   &pCall,
								   &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pConference->LocalEndpointAttached != ATTACHED) ||
		(pCall->CallState != CALL_COMPLETE) ||
		(pCall->CallType == VIRTUAL_CALL)) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	H245Identifier.choice = h221NonStandard_chosen;
	H245Identifier.u.h221NonStandard.t35CountryCode = NonStandardData.bCountryCode;
	H245Identifier.u.h221NonStandard.t35Extension = NonStandardData.bExtension;
	H245Identifier.u.h221NonStandard.manufacturerCode = NonStandardData.wManufacturerCode;

	if (pProductNumber == NULL) {
		pH245ProductNumber = NULL;
		bProductNumberLength = 0;
	} else {
		pH245ProductNumber = pProductNumber->pOctetString;
		bProductNumberLength = (BYTE)pProductNumber->wOctetStringLength;
	}

	if (pVersionNumber == NULL) {
		pH245VersionNumber = NULL;
		bVersionNumberLength = 0;
	} else {
		pH245VersionNumber = pVersionNumber->pOctetString;
		bVersionNumberLength = (BYTE)pVersionNumber->wOctetStringLength;
	}

	status = H245VendorIdentification(pCall->H245Instance,
									  &H245Identifier,
									  pH245ProductNumber,
									  bProductNumberLength,
									  pH245VersionNumber,
									  bVersionNumberLength);

	UnlockCall(pCall);
	UnlockConference(pConference);
	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_SetCallControlTimeout(	WORD					wType,
									DWORD					dwDuration)
{
HRESULT	status;
DWORD	dwRequest;
DWORD	dwSaveDuration;

	EnterCallControlTop();

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	status = CC_OK;

	switch (wType) {
		case CC_Q931_ALERTING_TIMEOUT:
			status = Q931SetAlertingTimeout(dwDuration);
			break;
		case CC_H245_RETRY_COUNT:
			status = H245SystemControl(0, H245_SYSCON_SET_FSM_N100, &dwDuration);
			break;
		case CC_H245_TIMEOUT:
			dwRequest = H245_SYSCON_SET_FSM_T101;
			dwSaveDuration = dwDuration;
			while ((dwRequest <= H245_SYSCON_SET_FSM_T109) && (status == CC_OK)) {
				dwDuration = dwSaveDuration;
				// Note -- the following call resets dwDuration
				status = H245SystemControl(0, dwRequest, &dwDuration);
				dwRequest += (H245_SYSCON_SET_FSM_T102 - H245_SYSCON_SET_FSM_T101);
			}
			break;
		default :
			LeaveCallControlTop(CC_BAD_PARAM);
			break;
	}

	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_SetTerminalID(			CC_HCONFERENCE			hConference,
									PCC_OCTETSTRING			pTerminalID)
{
HRESULT		status;
PCONFERENCE	pConference;
CC_HCALL	hCall;
PCALL		pCall;

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (hConference == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);
	
	status = ValidateTerminalID(pTerminalID);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = LockConference(hConference, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);
	
	if (pConference->LocalParticipantInfo.TerminalIDState == TERMINAL_ID_VALID) {
		pConference->LocalParticipantInfo.TerminalIDState = TERMINAL_ID_INVALID;
		Free(pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString);
		pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString = NULL;
		pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength = 0;
	}

	if ((pTerminalID == NULL) ||
		(pTerminalID->pOctetString == NULL) ||
		(pTerminalID->wOctetStringLength == 0)) {
		UnlockConference(pConference);
 		LeaveCallControlTop(CC_OK);
	}

	pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString =
		(BYTE *)Malloc(pTerminalID->wOctetStringLength);
	if (pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString == NULL) {
		UnlockConference(pConference);
 		LeaveCallControlTop(CC_NO_MEMORY);
	}

	memcpy(pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString,
		   pTerminalID->pOctetString,
		   pTerminalID->wOctetStringLength);
	pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength =
		pTerminalID->wOctetStringLength;
	pConference->LocalParticipantInfo.TerminalIDState = TERMINAL_ID_VALID;

	while (DequeueRequest(&pConference->LocalParticipantInfo.pEnqueuedRequestsForTerminalID,
						  &hCall) == CC_OK) {
		if (LockCall(hCall, &pCall) == CC_OK) {
   			H245ConferenceResponse(pCall->H245Instance,
								   H245_RSP_TERMINAL_ID,
								   pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber,
								   pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber,
								   pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString,
								   (BYTE)pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength,
								   NULL,					// terminal list
								   0);						// terminal list count
			UnlockCall(pCall);
		}
	}

	UnlockConference(pConference);
	LeaveCallControlTop(CC_OK);
}



CC_API
HRESULT CC_Shutdown()
{
	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

        if (CallControlState == SHUTDOWN_STATE)
                LeaveCallControlTop(CC_OK);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_BAD_PARAM);

#ifdef    GATEKEEPER
	DeInitGkiManager();
#endif // GATEKEEPER

	// Don't allow any additional threads to enter this DLL
	CallControlState = SHUTDOWN_STATE;

	Q931DeInit();
	DeInitHangupManager();
	DeInitUserManager();
	DeInitQ931Manager();
	DeInitListenManager();
	DeInitH245Manager();
	DeInitChannelManager();
	DeInitCallManager();
	DeInitConferenceManager();
	LeaveCallControlTop(CC_OK);
}



CC_API
HRESULT CC_UnMute(					CC_HCHANNEL				hChannel)
{
HRESULT		status;
HRESULT		SaveStatus;
PCHANNEL	pChannel;
PCONFERENCE	pConference;
PCALL		pCall;
PDU_T		Pdu;
WORD		wNumCalls;
PCC_HCALL	CallList;
WORD		i;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hChannel == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockChannelAndConference(hChannel, &pChannel, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if (pChannel->bChannelType != TX_CHANNEL) {
		// can only unmute transmit channels
		UnlockConference(pConference);
		UnlockChannel(pChannel);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (pConference->LocalEndpointAttached != ATTACHED) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	status = EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
	if (status != CC_OK) {
		UnlockConference(pConference);
		UnlockChannel(pChannel);
		LeaveCallControlTop(status);
	}

	// Construct an H.245 PDU to hold a miscellaneous indication
	// of "logical channel active"
	Pdu.choice = indication_chosen;
	Pdu.u.indication.choice = miscellaneousIndication_chosen;
	Pdu.u.indication.u.miscellaneousIndication.logicalChannelNumber =
		pChannel->wLocalChannelNumber;
	Pdu.u.indication.u.miscellaneousIndication.type.choice = logicalChannelActive_chosen;

	SaveStatus = CC_OK;
	for (i = 0; i < wNumCalls; i++) {
		if (LockCall(CallList[i], &pCall) == CC_OK) {
			status = H245SendPDU(pCall->H245Instance,	// H245 instance
								 &Pdu);
			// Note that this channel may not have been accepted on all of the calls,
			// so we could get an H245_ERROR_INVALID_CHANNEL error
			if ((status != H245_ERROR_OK) && (status != H245_ERROR_INVALID_CHANNEL))
				SaveStatus = status;
			UnlockCall(pCall);
		}
	}

	if (CallList != NULL)
		Free(CallList);

	UnlockConference(pConference);
	UnlockChannel(pChannel);
	LeaveCallControlTop(SaveStatus);
}


CC_API
HRESULT CC_UpdatePeerList(			CC_HCONFERENCE			hConference)
{
HRESULT						status;
PCONFERENCE					pConference;
PCALL						pCall;
WORD						wNumCalls;
WORD						i;
PCC_HCALL					CallList;
CC_PEER_ADD_CALLBACK_PARAMS	PeerAddCallbackParams;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hConference == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockConference(hConference, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pConference->ConferenceMode != MULTIPOINT_MODE) ||
		(pConference->LocalEndpointAttached != ATTACHED)) {
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (pConference->tsMultipointController == TS_TRUE) {
		EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
		for (i = 0; i < wNumCalls; i++) {
			if (LockCall(CallList[i], &pCall) == CC_OK) {
				if (pCall->pPeerParticipantInfo != NULL) {
					PeerAddCallbackParams.hCall = pCall->hCall;
					PeerAddCallbackParams.TerminalLabel =
						pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
					if (pCall->pPeerParticipantInfo->TerminalIDState == TERMINAL_ID_VALID)
						PeerAddCallbackParams.pPeerTerminalID =
							&pCall->pPeerParticipantInfo->ParticipantInfo.TerminalID;
					else
						PeerAddCallbackParams.pPeerTerminalID = NULL;
					InvokeUserConferenceCallback(pConference,
												 CC_PEER_ADD_INDICATION,
												 CC_OK,
												 &PeerAddCallbackParams);
					if (ValidateCall(CallList[i]) == CC_OK)
						UnlockCall(pCall);
					if (ValidateConference(hConference) != CC_OK) {
						Free(CallList);
						LeaveCallControlTop(CC_OK);
					}
				} else // pCall->pPeerParticipantInfo == NULL
					UnlockCall(pCall);
			}
		}
		status = CC_OK;
	} else { // pConference->tsMultipointController != TS_TRUE
		EnumerateCallsInConference(&wNumCalls, &CallList, pConference, VIRTUAL_CALL);
		for (i = 0; i < wNumCalls; i++) {
			if (LockCall(CallList[i], &pCall) == CC_OK) {
				FreeCall(pCall);
			}
		}
		if (CallList != NULL)
			Free(CallList);
		EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
		ASSERT((wNumCalls == 0) || (wNumCalls == 1));
		if (wNumCalls == 1) {
			if (LockCall(CallList[0], &pCall) == CC_OK) {
				// Send TerminalListRequest
				status = H245ConferenceRequest(pCall->H245Instance,
									  H245_REQ_TERMINAL_LIST,
									  pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber,
									  pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber);
				UnlockCall(pCall);
			}
		}
	}

	if (CallList != NULL)
		Free(CallList);
	UnlockConference(pConference);
	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_UserInput(				CC_HCALL				hCall,
									PWSTR					pszUserInput)
{
HRESULT		status;
PCALL		pCall;
PCONFERENCE	pConference;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (pszUserInput == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (wcslen(pszUserInput) == 0)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pConference->LocalEndpointAttached != ATTACHED) ||
		(pCall->CallState != CALL_COMPLETE) ||
		(pCall->CallType == VIRTUAL_CALL)) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	status = H245UserInput(pCall->H245Instance,
						   pszUserInput,
						   NULL);

	UnlockCall(pCall);
	UnlockConference(pConference);

	LeaveCallControlTop(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\apps\t3testph\t3testd.h ===
// t3testDlg.h : header file
//

#if !defined(AFX_T3TESTDLG_H__2584F27A_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_)
#define AFX_T3TESTDLG_H__2584F27A_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CT3testDlg dialog
#include "autoans.h"
class CT3testDlg : public CDialog
{
// Construction
public:
	CT3testDlg(CWnd* pParent = NULL);	// standard constructor
    void InitializeTrees();
    static void AddAddressToTree( ITAddress * pAddress );
    static void ReleaseAddresses( );
    static void SelectFirstItem(HWND hWnd,HTREEITEM hRoot);
    static void DeleteSelectedItem(HWND hWnd);
    static void UpdateMediaTypes(ITAddress * pAddress);
    static void UpdateCalls(ITAddress * pAddress);
    static void UpdateSelectedCalls(ITPhone * pPhone);
    static void UpdateTerminalClasses(ITAddress * pAddress,long lMediaType);
    static void UpdateTerminals(ITAddress * pAddress,long lMediaType);
    static void UpdatePhones(ITAddress * pAddress);
    static void CreateSelectedTerminalMenu(POINT pt, HWND);
    static void DoDigitGenerationTerminalMenu(HWND hWnd,POINT *);
    static void DoDigitDetectTerminalMenu(HWND hWnd, POINT *);
    static void CreateCallMenu(POINT pt, HWND hWnd);
    static void PutCaptions();
    static void HandleCallHubEvent( IDispatch * );
    static void HandleTapiObjectMessage( IDispatch * pEvent );
    static void HandleAddressEvent( IDispatch * pEvent );
    static void HandlePhoneEvent( IDispatch * pEvent );
    static LPWSTR GetCallPrivilegeName(ITCallInfo * pCall);
    static LPWSTR GetPhonePrivilegeName(ITPhone * pPhone);
    static LPWSTR GetCallStateName(ITCallInfo * pCall);
    static BSTR GetTerminalClassName( GUID * pguid );
    static void InitializeAddressTree();
    static void RegisterEventInterface();
    static void RegisterForCallNotifications();
    static void AddMediaType( long lMediaType );
    static void AddTerminal( ITTerminal * pTerminal );
    static void AddCreatedTerminal( ITTerminal * pTerminal );    
    static void AddCall( ITCallInfo * pCall );
    static void AddPhone( ITPhone * pPhone );
    static void UpdateCall( ITCallInfo * pCall );
    static void UpdatePhone( ITPhone * pPhone);
    static void AddSelectedTerminal( ITTerminal * pTerminal);
    static void AddSelectedCall( ITCallInfo *pCall);
    static void AddTerminalClass( GUID * );
    static void AddListen( long );
    static void ReleaseMediaTypes( );
    static void ReleaseTerminals();
    static void ReleaseCalls();
    static void ReleasePhones();
    static void ReleaseTerminalClasses();
    static void ReleaseCreatedTerminals();
    static void ReleaseDynamicClasses();
    static void ReleaseSelectedTerminals();
    static void ReleaseSelectedCalls();
    static void ReleaseListen();
    static void GetMediaTypeName( long, LPWSTR );
    static BOOL GetMediaType( long * plMediaType );
    static BOOL GetCall( ITCallInfo ** ppCall );
    static BOOL GetAddress( ITAddress ** ppAddress );
    static BOOL GetTerminal( ITTerminal ** ppTerminal );
    static BOOL GetPhone( ITPhone ** ppPhone );
    static BOOL GetTerminalClass( BSTR * pbstrClass );
    static BOOL GetCreatedTerminal( ITTerminal ** ppTerminal );
    static BOOL GetSelectedTerminal( ITTerminal ** ppTerminal );
    static BOOL GetSelectedCall( ITCallInfo ** ppCall );
    void FreeData( AADATA * pData );
    static void HelpCreateTerminal(
                               ITTerminalSupport * pTerminalSupport,
                               BSTR bstrClass,
                               long lMediaType,
                               TERMINAL_DIRECTION dir
                              );
    BOOL IsVideoCaptureStream(ITStream * pStream);
    HRESULT GetVideoRenderTerminal(ITTerminal ** ppTerminal) ;
    HRESULT SelectTerminalOnCall(ITTerminal * pTerminal, ITCallInfo * pCall);
    HRESULT EnablePreview(ITStream * pStream);
    void RemovePreview( ITStream * pStream );

    void DoAutoAnswer(ITCallInfo * pCall);
    afx_msg void OnClose() ;
// Dialog Data
	//{{AFX_DATA(CT3testDlg)
	enum { IDD = IDD_T3TEST_DIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CT3testDlg)
	public:
	virtual void OnFinalRelease();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CT3testDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnDestroy();
	afx_msg void OnSelchangedAddresses(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnAddterminal();
	afx_msg void OnRemoveterminal();
	afx_msg void OnCreatecall();
	afx_msg void OnConnect();
	afx_msg void OnDrop();
	afx_msg void OnAnswer();
	afx_msg void OnListen();
	afx_msg void OnSelchangedCalls(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSelchangedPhones(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnRelease();
	afx_msg void OnCreateTerminal();
	afx_msg void OnReleaseterminal();
	afx_msg void OnAddcreated();
	afx_msg void OnAddnull();
	afx_msg void OnAddtolisten();
	afx_msg void OnListenall();
    afx_msg void OnOpenPhone();
    afx_msg void OnClosePhone();
	afx_msg void OnSelchangedMediatypes(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnRclickSelectedterminals(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnStartTone();
    afx_msg void OnStopTone();
    afx_msg void OnBusyTone();
    afx_msg void OnRingBackTone();
    afx_msg void OnErrorTone();
    afx_msg void OnStartRing();
    afx_msg void OnStopRing();
    afx_msg void OnPhoneAutoOn();
    afx_msg void OnPhoneAutoOff();
    afx_msg void OnPhoneSpeakerOnHook();
    afx_msg void OnPhoneSpeakerOffHook();
    afx_msg void OnSelectCall();
    afx_msg void OnUnselectCall();

#ifdef ENABLE_DIGIT_DETECTION_STUFF
	afx_msg void OnGenerate();
    afx_msg void OnModesSupported();
    afx_msg void OnModesSupported2();
    afx_msg void OnStartDetect();
    afx_msg void OnStopDetect();
#endif // ENABLE_DIGIT_DETECTION_STUFF

    afx_msg void OnConfigAutoAnswer();
    afx_msg void OnILS();
    afx_msg void OnRate();
    afx_msg void OnPark1();
    afx_msg void OnPark2();
    afx_msg void OnHandoff1();
    afx_msg void OnHandoff2();
    afx_msg void OnUnpark();
    afx_msg void OnPickup1();
    afx_msg void OnPickup2();

    
	afx_msg void OnRclickCalls(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg LONG CT3testDlg::OnTapiEvent(UINT u, LONG_PTR l);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

HRESULT ListILSServers(
                       LPWSTR ** ppServers,
                       DWORD * pdwNumServers
                      );

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_T3TESTDLG_H__2584F27A_D15F_11D0_8ECA_00C04FB6809F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\callcont\callman.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/callman.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.27.2.1  $
 *	$Date:   23 Jun 1997 15:58:00  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/


HRESULT InitCallManager();

HRESULT DeInitCallManager();

HRESULT AllocAndLockCall(			PCC_HCALL				phCall,
									CC_HCONFERENCE			hConference,
									HQ931CALL				hQ931Call,
									HQ931CALL				hQ931CallInvitor,
									PCC_ALIASNAMES			pLocalAliasNames,
									PCC_ALIASNAMES			pPeerAliasNames,
									PCC_ALIASNAMES			pPeerExtraAliasNames,
									PCC_ALIASITEM			pPeerExtension,
									PCC_NONSTANDARDDATA		pLocalNonStandardData,
									PCC_NONSTANDARDDATA		pPeerNonStandardData,
									PWSTR					pszLocalDisplay,
									PWSTR					pszPeerDisplay,
									PCC_VENDORINFO			pPeerVendorInfo,
									PCC_ADDR				pQ931LocalConnectAddr,
									PCC_ADDR				pQ931PeerConnectAddr,
									PCC_ADDR				pQ931DestinationAddr,
									PCC_ADDR				pSourceCallSignalAddr,
									CALLTYPE				CallType,
									BOOL					bCallerIsMC,
									DWORD					dwUserToken,
									CALLSTATE				InitialCallState,
									DWORD					dwBandwidth,
									PCC_CONFERENCEID		pConferenceID,
									PPCALL					ppCall);

HRESULT FreeCall(					PCALL					pCall);

HRESULT LockQ931Call(				CC_HCALL				hCall,
									HQ931CALL				hQ931Call,
									PPCALL					ppCall);

HRESULT LockCall(					CC_HCALL				hCall,
									PPCALL					ppCall);

HRESULT LockCallAndConference(		CC_HCALL				hCall,
									PPCALL					ppCall,
									PPCONFERENCE			ppConference);

HRESULT MarkCallForDeletion(		PCALL					pCall);

HRESULT ValidateCall(				CC_HCALL				hCall);

HRESULT ValidateCallMarkedForDeletion(
									CC_HCALL				hCall);

HRESULT UnlockCall(					PCALL					pCall);

HRESULT AddLocalNonStandardDataToCall(
									PCALL					pCall,
									PCC_NONSTANDARDDATA		pLocalNonStandardData);

HRESULT AddLocalDisplayToCall(		PCALL					pCall,
									PWSTR					pszLocalDisplay);

HRESULT AllocatePeerParticipantInfo(PCONFERENCE				pConference,
									PPARTICIPANTINFO		*ppPeerParticipantInfo);

HRESULT FreePeerParticipantInfo(	PCONFERENCE				pConference,
									PPARTICIPANTINFO		pPeerParticipantInfo);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\callcont\callman2.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/callman2.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1996 Intel Corporation.
 *
 *	$Revision:   1.7  $
 *	$Date:   03 Jan 1997 16:28:04  $
 *	$Author:   EHOWARDX  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *
 *	Notes:
 *
 ***************************************************************************/

#ifdef GATEKEEPER

#ifndef CALLMAN2_H
#define CALLMAN2_H

#include "gkiman.h"

typedef HRESULT (*PGKICALLFUN)(PGKICALL pGkiCall, void *pConference);

// Additions to CALLMAN.C functionality
HRESULT LockGkiCallAndConference(	HANDLE					hGkiCall,
									PPGKICALL 				ppGkiCall,
									void * *				ppConference,
									DWORD *					phCall,
									DWORD *					phConference);
HRESULT UnlockGkiCallAndConference(	PGKICALL				pGkiCall,
									void *					pConference,
									DWORD					hCall,
									DWORD					hConference);
HRESULT LockGkiCall(HANDLE hGkiCall, PPGKICALL ppGkiCall);
HRESULT UnlockGkiCall(PGKICALL pGkiCall);

HRESULT ApplyToAllCalls(PGKICALLFUN pGkiCallFun);

// Complete CC_xxx Operations
HRESULT ListenReject        (DWORD hListen, HRESULT Reason);
HRESULT PlaceCallConfirm    (void *pCallVoid, void *pConferenceVoid);
HRESULT PlaceCallReject     (void *pCallVoid, void *pConferenceVoid, HRESULT Reason);
HRESULT AcceptCallConfirm   (void *pCallVoid, void *pConferenceVoid);
HRESULT AcceptCallReject    (void *pCallVoid, void *pConferenceVoid, HRESULT Reason);

HRESULT OpenChannelConfirm  (DWORD hChannel);
HRESULT OpenChannelReject   (DWORD hChannel, HRESULT Reason);
HRESULT AcceptChannelConfirm(DWORD hChannel);
HRESULT AcceptChannelReject (DWORD hChannel, HRESULT Reason);

// Handle gratuitous messages from Gatekeeper
HRESULT Disengage           (void *pCallVoid);
HRESULT BandwidthShrunk     (void *pCallVoid,
                             void *pConferenceVoid,
                             unsigned uBandwidthAllocated,
                             long lBandwidthChange);

#endif // CALLMAN2_H

#endif // GATEKEEPER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\callcont\ccutils.c ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/ccutils.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.107.1.0  $
 *	$Date:   20 Jun 1997 14:19:02  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#pragma warning ( disable : 4057 4100 4115 4201 4214 4244)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winreg.h>
#pragma warning ( default : 4115 4201 4214 )
#include "incommon.h"
#include "callcont.h"
#include "q931.h"
#include "apierror.h"
#include "ccmain.h"
#include "chanman.h"
#include "confman.h"
#include "callman.h"
#include "q931man.h"
#include "userman.h"
#include "ccutils.h"
#include "linkapi.h"
#include "h245man.h"
#include "provider.h"

extern CC_CONFERENCEID	InvalidConferenceID;



// The following two procedures are currently obsolete.  They're kept
// around in case we need them in the future
#if 0
void * MallocDbg(					DWORD					dwSize, 
									PSTR					pszFile, 
									int						nLine)
{
void	*pMem;

	ASSERT(dwSize != 0);

	pMem = GlobalAlloc(GMEM_FIXED, dwSize);

#ifdef MEM_TRACE
	printf("MALLOC %s %d %lu %08x\n",
		   pszFile, nLine, dwSize, pMem);
#endif // MEM_TRACE

	return pMem;
}



void FreeDbg(						void *					pMem,
									PSTR					pszFile, 
									int						nLine)
{
	ASSERT(pMem != NULL);

	GlobalFree(pMem);

#ifdef MEM_TRACE
	printf("FREE  %s %d %08x\n",
		   pszFile, nLine, pMem);
#endif // MEM_TRACE
}
#endif // 0



HRESULT InitializeLock(				PLOCK					pLock)
{
	ASSERT(pLock != NULL);

#ifdef DBG

    __try {

        // initialize lock (and allocate event immediately)
        InitializeCriticalSectionAndSpinCount(&pLock->LockInfoLock,H323_SPIN_COUNT);

    } __except ((GetExceptionCode() == STATUS_NO_MEMORY)
                ? EXCEPTION_EXECUTE_HANDLER
                : EXCEPTION_CONTINUE_SEARCH
                ) {

        // failure
        return CS_NO_MEMORY;
    }

        pLock->wLockCount = 0;
	pLock->wNumQueuedThreads = 0;
	pLock->hOwningThread = 0;
#endif

        pLock->Lock = CreateMutex(NULL, // security attributes
							  FALSE,	// initial owner
							  NULL);	// name

	if (pLock->Lock == NULL) {
#ifdef DBG
		DeleteCriticalSection(&pLock->LockInfoLock);
#endif
		return CC_INTERNAL_ERROR;
	} else
		return CC_OK;
}



HRESULT DeleteLock(					PLOCK					pLock)
{
	ASSERT(pLock != NULL);

#ifdef DBG
	DeleteCriticalSection(&pLock->LockInfoLock);
#endif

	if (CloseHandle(pLock->Lock) == TRUE)
		return CC_OK;
	else
		return CC_INTERNAL_ERROR;
}



HRESULT AcquireLock(				PLOCK					pLock)
{
HRESULT	status;

	ASSERT(pLock != NULL);
	
	status = AcquireTimedLock(pLock, INFINITE, NULL);
	return status;
}



HRESULT AcquireTimedLock(			PLOCK					pLock,
									DWORD					dwTimeout,
									BOOL					*pbTimedOut)
{
DWORD	dwStatus;

	ASSERT(pLock != NULL);

#ifdef DBG
	EnterCriticalSection(&pLock->LockInfoLock);
	(pLock->wNumQueuedThreads)++;
	LeaveCriticalSection(&pLock->LockInfoLock);
#endif

	dwStatus = WaitForSingleObject(pLock->Lock, dwTimeout);

#ifdef DBG
	EnterCriticalSection(&pLock->LockInfoLock);
	(pLock->wNumQueuedThreads)--;
	(pLock->wLockCount)++;
	pLock->hOwningThread = GetCurrentThread();
	LeaveCriticalSection(&pLock->LockInfoLock);
#endif

	if ((dwStatus != WAIT_OBJECT_0) && (dwStatus != WAIT_TIMEOUT))
		return CC_INTERNAL_ERROR;

	if (dwStatus == WAIT_TIMEOUT) {
		if (pbTimedOut != NULL) {
			*pbTimedOut = TRUE;
		}
	} else {
		if (pbTimedOut != NULL) {
			*pbTimedOut = FALSE;
		}
	}
	return CC_OK;
}



HRESULT RelinquishLock(				PLOCK					pLock)
{
	ASSERT(pLock != NULL);

#ifdef DBG
	EnterCriticalSection(&pLock->LockInfoLock);
	(pLock->wLockCount)--;
	if (pLock->wLockCount == 0)
		pLock->hOwningThread = 0;
	LeaveCriticalSection(&pLock->LockInfoLock);
#endif

	if (ReleaseMutex(pLock->Lock) == TRUE)
		return CC_OK;
	else
		return CC_INTERNAL_ERROR;
}



HRESULT ValidateOctetString(		PCC_OCTETSTRING			pOctetString)
{
	if (pOctetString == NULL)
		return CC_OK;
	if ((pOctetString->wOctetStringLength > 0) &&
		(pOctetString->pOctetString == NULL))
		return CC_BAD_PARAM;
	return CC_OK;
}



HRESULT CopyOctetString(			PCC_OCTETSTRING			*ppDest,
									PCC_OCTETSTRING			pSource)
{
	ASSERT(ppDest != NULL);
  
    if (pSource == NULL) {
        *ppDest = NULL;
        return CC_OK;
    }
    *ppDest = (PCC_OCTETSTRING)Malloc(sizeof(CC_OCTETSTRING));
    if (*ppDest == NULL)
        return CC_NO_MEMORY;
	(*ppDest)->wOctetStringLength = pSource->wOctetStringLength;
	if ((pSource->wOctetStringLength == 0) ||
		(pSource->pOctetString == NULL)) {
		pSource->wOctetStringLength = 0;
		(*ppDest)->pOctetString = NULL;
	} else {
		(*ppDest)->pOctetString = (BYTE *)Malloc(pSource->wOctetStringLength);
		if ((*ppDest)->pOctetString == NULL) {
			Free(*ppDest);
			*ppDest = NULL;
			return CC_NO_MEMORY;
		}
		memcpy((*ppDest)->pOctetString, pSource->pOctetString, pSource->wOctetStringLength);
	}
    return CC_OK;
}



HRESULT FreeOctetString(			PCC_OCTETSTRING			pOctetString)
{
	if (pOctetString == NULL)
		return CC_OK;
	if ((pOctetString->wOctetStringLength > 0) &&
		(pOctetString->pOctetString != NULL))
		Free(pOctetString->pOctetString);
	Free(pOctetString);
	return CC_OK;
}



HRESULT CopySeparateStack(			H245_ACCESS_T			**ppDest,
									H245_ACCESS_T			*pSource)
{
	ASSERT(ppDest != NULL);
  
    if (pSource == NULL) {
        *ppDest = NULL;
        return CC_OK;
    }

	// We currently can't handle IP source route addresses,
	// since this address format contains embedded pointers
	// that cannot simply be copied
	if ((pSource->networkAddress.choice == localAreaAddress_chosen) &&
		(pSource->networkAddress.u.localAreaAddress.choice == unicastAddress_chosen) &&
		(pSource->networkAddress.u.localAreaAddress.u.unicastAddress.choice == iPSourceRouteAddress_chosen))
		return CC_NOT_IMPLEMENTED;

    *ppDest = (H245_ACCESS_T *)Malloc(sizeof(H245_ACCESS_T));
    if (*ppDest == NULL)
        return CC_NO_MEMORY;

	**ppDest = *pSource;
    return CC_OK;
}



HRESULT FreeSeparateStack(			H245_ACCESS_T			*pSeparateStack)
{
	if (pSeparateStack == NULL)
		return CC_OK;
	Free(pSeparateStack);
	return CC_OK;
}



HRESULT ValidateNonStandardData(	PCC_NONSTANDARDDATA		pNonStandardData)
{
	if (pNonStandardData == NULL)
		return CC_OK;
	return ValidateOctetString(&pNonStandardData->sData);
}



HRESULT CopyNonStandardData(		PCC_NONSTANDARDDATA		*ppDest,
									PCC_NONSTANDARDDATA		pSource)
{
	ASSERT(ppDest != NULL);
  
    if (pSource == NULL) {
        *ppDest = NULL;
        return CC_OK;
    }
    *ppDest = (PCC_NONSTANDARDDATA)Malloc(sizeof(CC_NONSTANDARDDATA));
    if (*ppDest == NULL)
        return CC_NO_MEMORY;
	**ppDest = *pSource;
	if ((pSource->sData.wOctetStringLength == 0) ||
		(pSource->sData.pOctetString == NULL)) {
		(*ppDest)->sData.wOctetStringLength = 0;
		(*ppDest)->sData.pOctetString = NULL;
	} else {
		(*ppDest)->sData.pOctetString = (BYTE *)Malloc(pSource->sData.wOctetStringLength);
		if ((*ppDest)->sData.pOctetString == NULL) {
			Free(*ppDest);
			return CC_NO_MEMORY;
		}
		memcpy((*ppDest)->sData.pOctetString,
			   pSource->sData.pOctetString,
			   pSource->sData.wOctetStringLength);
	}
    return CC_OK;
}



HRESULT FreeNonStandardData(		PCC_NONSTANDARDDATA		pNonStandardData)
{
	if (pNonStandardData == NULL)
		return CC_OK;
	if ((pNonStandardData->sData.wOctetStringLength > 0) &&
		(pNonStandardData->sData.pOctetString != NULL))
		Free(pNonStandardData->sData.pOctetString);
	Free(pNonStandardData);
	return CC_OK;
}



HRESULT ValidateVendorInfo(			PCC_VENDORINFO			pVendorInfo)
{
HRESULT		status;

	if (pVendorInfo == NULL)
		return CC_OK;
	status = ValidateOctetString(pVendorInfo->pProductNumber);
	if (status != CC_OK)
		return status;
	status = ValidateOctetString(pVendorInfo->pVersionNumber);
	return status;
}



HRESULT CopyVendorInfo(				PCC_VENDORINFO			*ppDest,
									PCC_VENDORINFO			pSource)
{
HRESULT		status;

	ASSERT(ppDest != NULL);
  
    if (pSource == NULL) {
        *ppDest = NULL;
        return CC_OK;
    }
    *ppDest = (PCC_VENDORINFO)Malloc(sizeof(CC_VENDORINFO));
    if (*ppDest == NULL)
        return CC_NO_MEMORY;
	**ppDest = *pSource;
	status = CopyOctetString(&(*ppDest)->pProductNumber, pSource->pProductNumber);
	if (status != CC_OK) {
		Free(*ppDest);
		return status;
	}
	status = CopyOctetString(&(*ppDest)->pVersionNumber, pSource->pVersionNumber);
	if (status != CC_OK) {
		FreeOctetString((*ppDest)->pProductNumber);
		Free(*ppDest);
		return status;
	}
    return CC_OK;
}



HRESULT FreeVendorInfo(				PCC_VENDORINFO			pVendorInfo)
{
	if (pVendorInfo == NULL)
		return CC_OK;
	FreeOctetString(pVendorInfo->pProductNumber);
	FreeOctetString(pVendorInfo->pVersionNumber);
	Free(pVendorInfo);
	return CC_OK;
}



BOOL EqualConferenceIDs(			PCC_CONFERENCEID		pConferenceID1,
									PCC_CONFERENCEID		pConferenceID2)
{
	ASSERT(pConferenceID1 != NULL);
	ASSERT(pConferenceID2 != NULL);

	if (memcmp(pConferenceID1->buffer,
	           pConferenceID2->buffer,
			   sizeof(pConferenceID1->buffer)) == 0)
		return TRUE;
	else
		return FALSE;
}



BOOL EqualAddrs(					PCC_ADDR				pAddr1,
									PCC_ADDR				pAddr2)
{
	ASSERT(pAddr1 != NULL);
	ASSERT(pAddr2 != NULL);

	if (pAddr1->nAddrType != pAddr2->nAddrType)
		return FALSE;

	if (pAddr1->bMulticast != pAddr2->bMulticast)
		return FALSE;

	switch (pAddr1->nAddrType) {
		case CC_IP_DOMAIN_NAME:
			if ((pAddr1->Addr.IP_DomainName.wPort == pAddr2->Addr.IP_DomainName.wPort) &&
			    (wcscmp(pAddr1->Addr.IP_DomainName.cAddr, pAddr2->Addr.IP_DomainName.cAddr) == 0))
				return TRUE;
			else
				return FALSE;
		case CC_IP_DOT:
			if ((pAddr1->Addr.IP_Dot.wPort == pAddr2->Addr.IP_Dot.wPort) &&
			    (wcscmp(pAddr1->Addr.IP_Dot.cAddr, pAddr2->Addr.IP_Dot.cAddr) == 0))
				return TRUE;
			else
				return FALSE;
		case CC_IP_BINARY:
			if ((pAddr1->Addr.IP_Binary.wPort == pAddr2->Addr.IP_Binary.wPort) &&
			    (pAddr1->Addr.IP_Binary.dwAddr == pAddr2->Addr.IP_Binary.dwAddr))
				return TRUE;
			else
				return FALSE;
		default:
			ASSERT(0);
			return FALSE;
	}
}



HRESULT ValidateTermCapList(		PCC_TERMCAPLIST			pTermCapList)
{
unsigned    i, j;

	if (pTermCapList == NULL)
		return CC_OK;

	for (i = 0; i < pTermCapList->wLength; i++)
		if (pTermCapList->pTermCapArray[i] == NULL)
		return CC_BAD_PARAM;

	// make sure that all capability IDs are unique
	for (i = 0; i < pTermCapList->wLength; i++) {
		for (j = i + 1; j < pTermCapList->wLength; j++) {
			if (pTermCapList->pTermCapArray[i]->CapId == pTermCapList->pTermCapArray[j]->CapId)
				return CC_BAD_PARAM;
		}
		if ((pTermCapList->pTermCapArray[i]->CapId == H245_INVALID_CAPID) ||
			(pTermCapList->pTermCapArray[i]->CapId == 0))
			return CC_BAD_PARAM;
	}
	return CC_OK;
}



HRESULT ValidateTermCapDescriptors(	PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors,
									PCC_TERMCAPLIST			pTermCapList)
{
WORD				i, j, k, l;
H245_TOTCAPDESC_T	*pTermCapDescriptor;
H245_SIMCAP_T		*pSimCaps;

	if (pTermCapDescriptors == NULL)
		return CC_OK;

	for (i = 0; i < pTermCapDescriptors->wLength; i++) {
		pTermCapDescriptor = pTermCapDescriptors->pTermCapDescriptorArray[i];
		if ((pTermCapDescriptor->CapDescId > 255) ||
			(pTermCapDescriptor->CapDesc.Length == 0) ||
			(pTermCapDescriptor->CapDesc.Length > H245_MAX_SIMCAPS))
			return CC_BAD_PARAM;
		for (j = i + 1; j < pTermCapDescriptors->wLength; j++) {
			if (pTermCapDescriptor->CapDescId ==
				pTermCapDescriptors->pTermCapDescriptorArray[j]->CapDescId) {
				return CC_BAD_PARAM;
			}
		}
		for (j = 0; j < pTermCapDescriptor->CapDesc.Length; j++) {
			pSimCaps = &(pTermCapDescriptor->CapDesc.SimCapArray[j]);
			if ((pSimCaps->Length == 0) ||
				(pSimCaps->Length > H245_MAX_ALTCAPS))
				return CC_BAD_PARAM;
			for (k = 0; k < pSimCaps->Length; k++) {
				for (l = 0; l < pTermCapList->wLength; l++) {
					if (pSimCaps->AltCaps[k] ==
						pTermCapList->pTermCapArray[l]->CapId)
						break;
				}
				if (l == pTermCapList->wLength)
					// the capability descriptor contains a capability ID
					// which is not present in the capability table
					return CC_BAD_PARAM;
			}
		}
	}
	return CC_OK;
}



HRESULT ValidateAddr(				PCC_ADDR				pAddr)
{
	if (pAddr == NULL)
		return CC_OK;
	if ((pAddr->nAddrType != CC_IP_DOMAIN_NAME) &&
		(pAddr->nAddrType != CC_IP_DOT) &&
		(pAddr->nAddrType != CC_IP_BINARY))
		return CC_BAD_PARAM;
	return CC_OK;
}



HRESULT CopyAddr(					PCC_ADDR				*ppDest,
									PCC_ADDR				pSource)
{
	ASSERT(ppDest != NULL);
  
    if (pSource == NULL) {
        *ppDest = NULL;
        return CC_OK;
    }
    *ppDest = (PCC_ADDR)Malloc(sizeof(CC_ADDR));
    if (*ppDest == NULL)
        return CC_NO_MEMORY;
    **ppDest = *pSource;
    return CC_OK;
}



HRESULT FreeAddr(					PCC_ADDR				pAddr)
{
    if (pAddr == NULL)
        return CC_OK;
    Free(pAddr);
    return CC_OK;
}



HRESULT SetQ931Port(				PCC_ADDR				pAddr)
{
	if (pAddr == NULL)
		return CC_OK;
	switch (pAddr->nAddrType) {
		case CC_IP_DOMAIN_NAME:
			if (pAddr->Addr.IP_DomainName.wPort == 0)
				pAddr->Addr.IP_DomainName.wPort = CC_H323_HOST_CALL;
			return CC_OK;
		case CC_IP_DOT:
			if (pAddr->Addr.IP_Dot.wPort == 0)
				pAddr->Addr.IP_Dot.wPort = CC_H323_HOST_CALL;
			return CC_OK;
		case CC_IP_BINARY:
			if (pAddr->Addr.IP_Binary.wPort == 0)
				pAddr->Addr.IP_Binary.wPort = CC_H323_HOST_CALL;
			return CC_OK;
	}

	ASSERT(0);
	return CC_INTERNAL_ERROR;
}



HRESULT ValidateDisplay(			PWSTR					pszDisplay)
{
	return CC_OK;
}



HRESULT CopyDisplay(				PWSTR					*ppDest,
									PWSTR					pSource)
{
	ASSERT(ppDest != NULL);
  
    if (pSource == NULL) {
        *ppDest = NULL;
        return CC_OK;
    }
    *ppDest = (WCHAR *)Malloc((wcslen(pSource)+1)*sizeof(WCHAR));
    if (*ppDest == NULL)
        return CC_NO_MEMORY;
	wcscpy(*ppDest, pSource);
    return CC_OK;
}



HRESULT FreeDisplay(				PWSTR					pszDisplay)
{
	Free(pszDisplay);
	return CC_OK;
}



HRESULT ValidateTerminalID(			PCC_OCTETSTRING			pTerminalID)
{
	return ValidateOctetString(pTerminalID);
}



HRESULT CopyTerminalID(				PCC_OCTETSTRING			*ppDest,
									PCC_OCTETSTRING			pSource)
{
	ASSERT(ppDest != NULL);

    return CopyOctetString(ppDest, pSource);
}



HRESULT FreeTerminalID(				PCC_OCTETSTRING			pTerminalID)
{
    return FreeOctetString(pTerminalID);
}



HRESULT SetTerminalType(			TRISTATE				tsMultipointController,
									BYTE					*pbTerminalType)
{
	switch (tsMultipointController) {
		case TS_TRUE:
			*pbTerminalType = 240;
			break;
		case TS_UNKNOWN:
			*pbTerminalType = 70;
			break;
		case TS_FALSE:
			*pbTerminalType = 50;
			break;
		default:
			ASSERT(0);
			*pbTerminalType = 0;
			break;
	}
	return CC_OK;
}



HRESULT CopyH245TermCapList(		PCC_TERMCAPLIST			*ppDest,
									PCC_TERMCAPLIST			pSource)
{
WORD	i;
HRESULT	status;

	ASSERT(ppDest != NULL);
  
    if (pSource == NULL) {
        *ppDest = NULL;
        return CC_OK;
    }

	*ppDest = (PCC_TERMCAPLIST)Malloc(sizeof(CC_TERMCAPLIST));
	if (*ppDest == NULL)
		return CC_NO_MEMORY;

	(*ppDest)->wLength = pSource->wLength;
	(*ppDest)->pTermCapArray =
		(PPCC_TERMCAP)Malloc(sizeof(PCC_TERMCAP) * pSource->wLength);
	if ((*ppDest)->pTermCapArray == NULL) {
		(*ppDest)->wLength = 0;
		DestroyH245TermCapList(ppDest);
		return CC_NO_MEMORY;
	}
	for (i = 0; i < pSource->wLength; i++) {
		status = H245CopyCap(&((*ppDest)->pTermCapArray[i]), pSource->pTermCapArray[i]);
		if (status != H245_ERROR_OK) {
			(*ppDest)->wLength = i;
			DestroyH245TermCapList(ppDest);
			return status;
		}
	}
	return CC_OK;
}



HRESULT CopyH245TermCapDescriptors(	PCC_TERMCAPDESCRIPTORS	*ppDest,
									PCC_TERMCAPDESCRIPTORS	pSource)
{
WORD		i;
HRESULT		status;

	ASSERT(ppDest != NULL);
  
    if (pSource == NULL) {
        *ppDest = NULL;
        return CC_OK;
    }

	(*ppDest) = (PCC_TERMCAPDESCRIPTORS)Malloc(sizeof(CC_TERMCAPDESCRIPTORS));
	if (*ppDest == NULL)
		return CC_NO_MEMORY;

	(*ppDest)->wLength = pSource->wLength;
	(*ppDest)->pTermCapDescriptorArray = (H245_TOTCAPDESC_T **)Malloc(sizeof(H245_TOTCAPDESC_T *) *
			                                                pSource->wLength);
	if ((*ppDest)->pTermCapDescriptorArray == NULL) {
		(*ppDest)->wLength = 0;
		DestroyH245TermCapDescriptors(ppDest);
		return CC_NO_MEMORY;
	}

	for (i = 0; i < pSource->wLength; i++) {
		status = H245CopyCapDescriptor(&((*ppDest)->pTermCapDescriptorArray[i]),
									   pSource->pTermCapDescriptorArray[i]);
		if (status != H245_ERROR_OK) {
			(*ppDest)->wLength = i;
			DestroyH245TermCapDescriptors(ppDest);
			return status;	
		}
	}
	return CC_OK;
}



HRESULT CreateH245DefaultTermCapDescriptors(
									PCC_TERMCAPDESCRIPTORS	*ppDest,
									PCC_TERMCAPLIST			pTermCapList)
{
H245_TOTCAPDESC_T	TermCapDescriptor;
WORD				i;
HRESULT				status;

	ASSERT(ppDest != NULL);

	if (pTermCapList == NULL) {
		*ppDest = NULL;
        return CC_OK;
    }

	*ppDest = (PCC_TERMCAPDESCRIPTORS)Malloc(sizeof(CC_TERMCAPDESCRIPTORS));
	if (*ppDest == NULL)
		return CC_NO_MEMORY;

	if (pTermCapList->wLength == 0) {
		(*ppDest)->wLength = 0;
		(*ppDest)->pTermCapDescriptorArray = NULL;
		return CC_OK;
	}

	(*ppDest)->wLength = 1;
	(*ppDest)->pTermCapDescriptorArray = (H245_TOTCAPDESC_T **)Malloc(sizeof(H245_TOTCAPDESC_T *));
	if ((*ppDest)->pTermCapDescriptorArray == NULL) {
		(*ppDest)->wLength = 0;
		DestroyH245TermCapDescriptors(ppDest);
		return CC_NO_MEMORY;
	}

	TermCapDescriptor.CapDesc.Length = pTermCapList->wLength;
	TermCapDescriptor.CapDescId = 0;

	for (i = 0; i < pTermCapList->wLength; i++) {
		TermCapDescriptor.CapDesc.SimCapArray[i].Length = 1;
		TermCapDescriptor.CapDesc.SimCapArray[i].AltCaps[0] =
			pTermCapList->pTermCapArray[i]->CapId;
	}

	status = H245CopyCapDescriptor(&((*ppDest)->pTermCapDescriptorArray[0]),
								   &TermCapDescriptor);
	if (status != H245_ERROR_OK) {
		(*ppDest)->wLength = 0;
		DestroyH245TermCapDescriptors(ppDest);
		return status;	
	}
	return CC_OK;
}



HRESULT DestroyH245TermCap(			PPCC_TERMCAP			ppTermCap)
{
	ASSERT(ppTermCap != NULL);

	if (*ppTermCap == NULL)
		return CC_OK;

	H245FreeCap(*ppTermCap);
	*ppTermCap = NULL;
	return CC_OK;
}



HRESULT UnregisterTermCapListFromH245(
									PCONFERENCE				pConference,
									PCC_TERMCAPLIST			pTermCapList)
{
WORD		i, j;
PCALL		pCall;
PCC_HCALL	CallList;
WORD		wNumCalls;
HRESULT		status;
HRESULT		SaveStatus;

	ASSERT(pConference != NULL);

	if (pTermCapList == NULL)
		return CC_OK;

	EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);

	SaveStatus = CC_OK;
	for (i = 0; i < pTermCapList->wLength; i++) {
		ASSERT(pTermCapList->pTermCapArray[i] != NULL);
		for (j = 0; j < wNumCalls; j++) {
			if (LockCall(CallList[j], &pCall) == CC_OK) {
				status = H245DelLocalCap(pCall->H245Instance,
								         pTermCapList->pTermCapArray[i]->CapId);
				if (status != CC_OK)
					SaveStatus = status;
				UnlockCall(pCall);
			}
		}
	}
	if (CallList != NULL)
		Free(CallList);
	return SaveStatus;
}



HRESULT DestroyH245TermCapList(		PCC_TERMCAPLIST			*ppTermCapList)
{
WORD		i;

	ASSERT(ppTermCapList != NULL);

	if (*ppTermCapList == NULL)
		return CC_OK;

	for (i = 0; i < (*ppTermCapList)->wLength; i++) {
		ASSERT((*ppTermCapList)->pTermCapArray[i] != NULL);
	H245FreeCap((*ppTermCapList)->pTermCapArray[i]);
	}
	if ((*ppTermCapList)->pTermCapArray != NULL)
		Free((*ppTermCapList)->pTermCapArray);
	Free(*ppTermCapList);
	*ppTermCapList = NULL;
	return CC_OK;
}



HRESULT UnregisterTermCapDescriptorsFromH245(
									PCONFERENCE				pConference,
									PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors)
{
WORD		i, j;
PCALL		pCall;
PCC_HCALL	CallList;
WORD		wNumCalls;
HRESULT		status;
HRESULT		SaveStatus;

	ASSERT(pConference != NULL);

	if (pTermCapDescriptors == NULL)
		return CC_OK;

	EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);

	SaveStatus = CC_OK;
	for (i = 0; i < pTermCapDescriptors->wLength; i++) {
		ASSERT(pTermCapDescriptors->pTermCapDescriptorArray[i] != NULL);
		for (j = 0; j < wNumCalls; j++) {
			if (LockCall(CallList[j], &pCall) == CC_OK) {
				status = H245DelCapDescriptor(pCall->H245Instance,
									          pTermCapDescriptors->pTermCapDescriptorArray[i]->CapDescId);
				if (status != CC_OK)
					SaveStatus = status;
				UnlockCall(pCall);
			}
		}
	}
	if (CallList != NULL)
		Free(CallList);
	return SaveStatus;
}



HRESULT DestroyH245TermCapDescriptors(	PCC_TERMCAPDESCRIPTORS	*ppTermCapDescriptors)
{
WORD				i;

	ASSERT(ppTermCapDescriptors != NULL);

	if (*ppTermCapDescriptors == NULL)
		return CC_OK;

	for (i = 0; i < (*ppTermCapDescriptors)->wLength; i++) {
		ASSERT((*ppTermCapDescriptors)->pTermCapDescriptorArray[i] != NULL);
		H245FreeCapDescriptor((*ppTermCapDescriptors)->pTermCapDescriptorArray[i]);
	}
	if ((*ppTermCapDescriptors)->pTermCapDescriptorArray != NULL)
		Free((*ppTermCapDescriptors)->pTermCapDescriptorArray);
	Free(*ppTermCapDescriptors);
	*ppTermCapDescriptors = NULL;
	return CC_OK;
}



HRESULT HostToH245IPNetwork(		BYTE					*NetworkArray,
									DWORD					dwAddr)
{
	if (NetworkArray == NULL) {
		ASSERT(0);
		return CC_BAD_PARAM;
	}

	NetworkArray[0] = HIBYTE(HIWORD(dwAddr));
	NetworkArray[1] = LOBYTE(HIWORD(dwAddr));
	NetworkArray[2] = HIBYTE(LOWORD(dwAddr));
	NetworkArray[3] = LOBYTE(LOWORD(dwAddr));

	return CC_OK;
}



HRESULT H245IPNetworkToHost(		DWORD					*pdwAddr,
									BYTE					*NetworkArray)
{
	if ((pdwAddr == NULL) || (NetworkArray == NULL)) {
		ASSERT(0);
		return CC_BAD_PARAM;
	}

	*pdwAddr = NetworkArray[0] * 0x01000000 +
		       NetworkArray[1] * 0x00010000 +
			   NetworkArray[2] * 0x00000100 +
			   NetworkArray[3] * 0x00000001;

	return CC_OK;
}



HRESULT ProcessRemoteHangup(		CC_HCALL				hCall,
									HQ931CALL				hQ931Initiator,
									BYTE					bHangupReason)
{
PCALL								pCall;
CC_HCONFERENCE						hConference;
PCONFERENCE							pConference;
HRESULT								status;
HQ931CALL							hQ931Call;
H245_INST_T							H245Instance;
PCHANNEL							pChannel;
WORD								wNumChannels;
PCC_HCHANNEL						ChannelList;
WORD								i;
WORD								wNumCalls;
PCC_HCALL							CallList;
PCALL								pOldCall;
CC_CONNECT_CALLBACK_PARAMS			ConnectCallbackParams;
CC_PEER_DROP_CALLBACK_PARAMS		PeerDropCallbackParams;
CC_PEER_CHANGE_CAP_CALLBACK_PARAMS	PeerChangeCapCallbackParams;
BOOL								bConferenceTermCapsChanged;
HRESULT								CallbackStatus;

	if (hCall == CC_INVALID_HANDLE)
		return CC_BAD_PARAM;

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		return CC_BAD_PARAM;

	hConference = pCall->hConference;
	hQ931Call = pCall->hQ931Call;
	H245Instance = pCall->H245Instance;
	PeerDropCallbackParams.hCall = pCall->hCall;
	if (pCall->pPeerParticipantInfo == NULL) {
		PeerDropCallbackParams.TerminalLabel.bMCUNumber = 255;
		PeerDropCallbackParams.TerminalLabel.bTerminalNumber = 255;
		PeerDropCallbackParams.pPeerTerminalID = NULL;
	} else {
		PeerDropCallbackParams.TerminalLabel = pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
		if (pCall->pPeerParticipantInfo->TerminalIDState == TERMINAL_ID_VALID)
			PeerDropCallbackParams.pPeerTerminalID = &pCall->pPeerParticipantInfo->ParticipantInfo.TerminalID;
		else
			PeerDropCallbackParams.pPeerTerminalID = NULL;
	}

	if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
		(pConference->tsMultipointController == TS_TRUE))
		CreateConferenceTermCaps(pConference, &bConferenceTermCapsChanged);
	else
		bConferenceTermCapsChanged = FALSE;

	// Remove all TX, RX and PROXY channels associated with this call
	EnumerateChannelsInConference(&wNumChannels,
								  &ChannelList,
								  pConference,
								  TX_CHANNEL | RX_CHANNEL | PROXY_CHANNEL);
	for (i = 0; i < wNumChannels; i++) {
		if (LockChannel(ChannelList[i], &pChannel) == CC_OK) {
			if (pChannel->hCall == hCall)
				FreeChannel(pChannel);
			else
				UnlockChannel(pChannel);
		}
	}
	if (ChannelList != NULL)
		Free(ChannelList);

	switch (bHangupReason)
	{
	case CC_REJECT_NORMAL_CALL_CLEARING:
		CallbackStatus = CC_OK;
		break;
	case CC_REJECT_GATEKEEPER_TERMINATED:
		CallbackStatus = CC_GATEKEEPER_REFUSED;
		bHangupReason = CC_REJECT_NORMAL_CALL_CLEARING;
		break;
	default:
		CallbackStatus = CC_PEER_REJECT;
	} // switch

	if (pCall->CallType == THIRD_PARTY_INVITOR) {
		MarkCallForDeletion(pCall);

		ConnectCallbackParams.pNonStandardData = pCall->pPeerNonStandardData;
		ConnectCallbackParams.pszPeerDisplay = pCall->pszPeerDisplay;
		ConnectCallbackParams.bRejectReason = bHangupReason;
		ConnectCallbackParams.pTermCapList = pCall->pPeerH245TermCapList;
		ConnectCallbackParams.pH2250MuxCapability = pCall->pPeerH245H2250MuxCapability;
		ConnectCallbackParams.pTermCapDescriptors = pCall->pPeerH245TermCapDescriptors;
		ConnectCallbackParams.pLocalAddr = pCall->pQ931LocalConnectAddr;
 		if (pCall->pQ931DestinationAddr == NULL)
			ConnectCallbackParams.pPeerAddr = pCall->pQ931PeerConnectAddr;
		else
			ConnectCallbackParams.pPeerAddr = pCall->pQ931DestinationAddr;
		ConnectCallbackParams.pVendorInfo = pCall->pPeerVendorInfo;
		ConnectCallbackParams.bMultipointConference = TRUE;
		ConnectCallbackParams.pConferenceID = &pConference->ConferenceID;
		ConnectCallbackParams.pMCAddress = pConference->pMultipointControllerAddr;
		ConnectCallbackParams.pAlternateAddress = NULL;
		ConnectCallbackParams.dwUserToken = pCall->dwUserToken;
		InvokeUserConferenceCallback(pConference,
									 CC_CONNECT_INDICATION,
									 CallbackStatus,
									 &ConnectCallbackParams);
		// Need to validate the conference and call handles; the associated
		// objects may have been deleted during user callback on this thread
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
		if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
			FreeCall(pCall);
		Q931Hangup(hQ931Call, bHangupReason);
		return CC_OK;
	}

	if (pCall->CallType == THIRD_PARTY_INTERMEDIARY) {
		if ((hQ931Initiator == pCall->hQ931CallInvitor) &&
		    (hQ931Initiator != CC_INVALID_HANDLE)) {
			pCall->hQ931CallInvitor = CC_INVALID_HANDLE;
			UnlockCall(pCall);
			UnlockConference(pConference);
			return CC_OK;
		} else {
			if (pCall->CallState != CALL_COMPLETE) {
				if (pCall->hQ931CallInvitor != CC_INVALID_HANDLE)
					Q931Hangup(pCall->hQ931CallInvitor, CC_REJECT_UNDEFINED_REASON);
				if (ValidateCall(hCall) == CC_OK)
					Q931Hangup(pCall->hQ931Call, bHangupReason);
			}
		}
	}

	if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
		(pConference->tsMultipointController == TS_TRUE)) {
		if (pCall->pPeerParticipantInfo != NULL) {
			EnumerateCallsInConference(&wNumCalls,
									   &CallList,
									   pConference,
									   ESTABLISHED_CALL);
			for (i = 0; i < wNumCalls; i++) {
				if (CallList[i] != hCall) {
					if (LockCall(CallList[i], &pOldCall) == CC_OK) {
						if (pCall->pPeerParticipantInfo != NULL)
							H245ConferenceIndication(
											 pOldCall->H245Instance,
											 H245_IND_TERMINAL_LEFT,	// Indication Type
											 0,							// SBE number; ignored here
											 pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber,	// MCU number
											 pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber);
						if (bConferenceTermCapsChanged)
							// Send new term caps
							SendTermCaps(pOldCall, pConference);
						UnlockCall(pOldCall);
					}
				}
			}
			if (CallList != NULL)
				Free(CallList);
		}

		InvokeUserConferenceCallback(pConference,
						 CC_PEER_DROP_INDICATION,
						 CC_OK,
						 &PeerDropCallbackParams);
		
		if (ValidateCall(hCall) == CC_OK)
			FreeCall(pCall);

		if (ValidateConference(hConference) == CC_OK) {
			if (bConferenceTermCapsChanged) {
				// Generate CC_PEER_CHANGE_CAP callback
				PeerChangeCapCallbackParams.pTermCapList =
					pConference->pConferenceTermCapList;
				PeerChangeCapCallbackParams.pH2250MuxCapability =
					pConference->pConferenceH245H2250MuxCapability;
				PeerChangeCapCallbackParams.pTermCapDescriptors =
					pConference->pConferenceTermCapDescriptors;
				InvokeUserConferenceCallback(pConference,
											 CC_PEER_CHANGE_CAP_INDICATION,
											 CC_OK,
											 &PeerChangeCapCallbackParams);
			}
		}

		if (ValidateConference(hConference) == CC_OK) {
			if (pConference->bDeferredDelete) {
				ASSERT(pConference->LocalEndpointAttached == DETACHED);
				EnumerateCallsInConference(&wNumCalls, NULL, pConference, ALL_CALLS);
				if (wNumCalls == 0) {
					FreeConference(pConference);
					return CC_OK;
				}
			}
			UnlockConference(pConference);
		}
		return CC_OK;
	} else {
		status = EnumerateChannelsInConference(&wNumChannels,
			                                   &ChannelList,
											   pConference,
											   ALL_CHANNELS);
		if (status == CC_OK) {
			// free all the channels
			for (i = 0; i < wNumChannels; i++) {
				if (LockChannel(ChannelList[i], &pChannel) == CC_OK)
					// Notice that since we're going to hangup, we don't need to
					// close any channels
					FreeChannel(pChannel);	
			}
			if (ChannelList != NULL)
				Free(ChannelList);
		}

		if (H245Instance != H245_INVALID_ID)
			status = H245ShutDown(H245Instance);
		else
			status = H245_ERROR_OK;
	
		if (status == H245_ERROR_OK) {
			status = Q931Hangup(hQ931Call, CC_REJECT_NORMAL_CALL_CLEARING);
			// Q931Hangup may legitimately return CS_BAD_PARAM, because the Q.931 call object
			// may have been deleted at this point
			if (status == CS_BAD_PARAM)
				status = CC_OK;
		} else
			Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);

		if (pConference->bDeferredDelete) {
			ASSERT(pConference->LocalEndpointAttached == DETACHED);
			FreeConference(pConference);
		} else {
			ReInitializeConference(pConference);

			InvokeUserConferenceCallback(pConference,
										 CC_CONFERENCE_TERMINATION_INDICATION,
										 CallbackStatus,
										 NULL);

			if (ValidateConference(hConference) == CC_OK)
				UnlockConference(pConference);
		}
		return CC_OK;
	}
	// We should never reach this point
	ASSERT(0);
}



HRESULT DefaultSessionTableConstructor(
									CC_HCONFERENCE			hConference,
									DWORD					dwConferenceToken,
									BOOL					bCreate,
									BOOL					*pbSessionTableChanged,
									WORD					wListCount,
									PCC_TERMCAPLIST			pTermCapList[],
									PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors[],
									PCC_SESSIONTABLE		*ppSessionTable)
{
WORD			i;
HRESULT			status;
PCONFERENCE		pConference;
WORD			wNumChannels;
PCC_HCHANNEL	ChannelList;
PCHANNEL		pChannel;
WORD			wNumCalls;
PCC_HCALL		CallList;
PCALL			pCall;
BYTE			bSessionID;
WORD			wPort;
DWORD			dwAddr;
WCHAR			szSessionDescription[100];
WCHAR			ss[10];

	ASSERT(hConference != CC_INVALID_HANDLE);
	ASSERT(ppSessionTable != NULL);
	
	if (*ppSessionTable != NULL) {
		for (i = 0; i < (*ppSessionTable)->wLength; i++) {
			if ((*ppSessionTable)->SessionInfoArray[i].pTermCap != NULL)
				H245FreeCap((*ppSessionTable)->SessionInfoArray[i].pTermCap);
			FreeAddr((*ppSessionTable)->SessionInfoArray[i].pRTPAddr);
			FreeAddr((*ppSessionTable)->SessionInfoArray[i].pRTCPAddr);
		}
		if ((*ppSessionTable)->SessionInfoArray != NULL)
			Free((*ppSessionTable)->SessionInfoArray);
		Free(*ppSessionTable);
		*ppSessionTable = NULL;
	}

	if (bCreate == FALSE)
		return CC_OK;

	*ppSessionTable = NULL;
	if (pbSessionTableChanged != NULL)
		*pbSessionTableChanged = FALSE;

	status = LockConference(hConference, &pConference);
	if (status != CC_OK)
		return status;

	if ((pConference->ConferenceMode == UNCONNECTED_MODE) ||
	    (pConference->ConferenceMode == POINT_TO_POINT_MODE)) {
		UnlockConference(pConference);
		return CC_BAD_PARAM;
	}

	// pConference->ConferenceMode == MULTIPOINT_MODE
	// Create one session entry for each open channel on this conference

	bSessionID = 1;
	wPort = 2050;

	// Set dwAddr
	EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
	if (wNumCalls == 0) {
		UnlockConference(pConference);
		return CC_INTERNAL_ERROR;
	}

	status = LockCall(CallList[0], &pCall);
	if (status != CC_OK) {
		Free(CallList);
		UnlockConference(pConference);
		return status;
	}

	if (pCall->pQ931LocalConnectAddr == NULL) {
		Free(CallList);
		UnlockCall(pCall);
		UnlockConference(pConference);
		return CC_INTERNAL_ERROR;
	}

	if (pCall->pQ931LocalConnectAddr->nAddrType != CC_IP_BINARY) {
		Free(CallList);
		UnlockCall(pCall);
		UnlockConference(pConference);
		return CC_INTERNAL_ERROR;
	}

	// Construct dwAddr from one of the unicast Q.931 addresses by setting the high
	// nibble of the Q.931 address to 0xE
	dwAddr = (pCall->pQ931LocalConnectAddr->Addr.IP_Binary.dwAddr & 0xEFFFFFFF) | 0xE0000000;

	UnlockCall(pCall);
	Free(CallList);
	
	EnumerateChannelsInConference(&wNumChannels, &ChannelList, pConference, TX_CHANNEL);
	
	*ppSessionTable = (PCC_SESSIONTABLE)Malloc(sizeof(CC_SESSIONTABLE));
	if (*ppSessionTable == NULL) {
		Free(ChannelList);
		UnlockConference(pConference);
		return CC_NO_MEMORY;
	}
	(*ppSessionTable)->wLength = wNumChannels;
	if (wNumChannels == 0)
		(*ppSessionTable)->SessionInfoArray = NULL;
	else {
		(*ppSessionTable)->SessionInfoArray =
			(PCC_SESSIONINFO)Malloc(sizeof(CC_SESSIONINFO) * wNumChannels);
		if ((*ppSessionTable)->SessionInfoArray == NULL) {
			Free(ChannelList);
			UnlockConference(pConference);
			(*ppSessionTable)->wLength = 0;
			DefaultSessionTableConstructor(
								hConference,
								dwConferenceToken,
								FALSE,	// bCreate,
								NULL,	// pbSessionTableChanged,
								0,		// wListCount,
								NULL,	// pTermCapList[],
								NULL,	// pTermCapDescriptors[],
								ppSessionTable);
			return CC_NO_MEMORY;
		}
		for (i = 0; i < wNumChannels; i++) {
			(*ppSessionTable)->SessionInfoArray[i].bSessionID = bSessionID++;

			(*ppSessionTable)->SessionInfoArray[i].bAssociatedSessionID = 0;

			wcscpy(szSessionDescription, L"Session ");
			_itow((int)(*ppSessionTable)->SessionInfoArray[i].bSessionID,
				  ss, 10);
			wcscat(szSessionDescription, ss);
	
			(*ppSessionTable)->SessionInfoArray[i].SessionDescription.wOctetStringLength =
				(WORD)((wcslen(szSessionDescription)+1)*sizeof(WCHAR));
			(*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString =
				(BYTE *)Malloc((*ppSessionTable)->SessionInfoArray[i].SessionDescription.wOctetStringLength);
			if ((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString == NULL) {
				Free(ChannelList);
				UnlockConference(pConference);
				(*ppSessionTable)->wLength = i;
				DefaultSessionTableConstructor(
								hConference,
								dwConferenceToken,
								FALSE,	// bCreate,
								NULL,	// pbSessionTableChanged,
								0,		// wListCount,
								NULL,	// pTermCapList[],
								NULL,	// pTermCapDescriptors[],
								ppSessionTable);
				return CC_NO_MEMORY;
			}
			memcpy((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString,
				    szSessionDescription,
					(*ppSessionTable)->SessionInfoArray[i].SessionDescription.wOctetStringLength);
			
			status = LockChannel(ChannelList[i], &pChannel);
			if (status != CC_OK) {
				Free((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString);
				Free(ChannelList);
				UnlockConference(pConference);
				(*ppSessionTable)->wLength = i;
				DefaultSessionTableConstructor(
								hConference,
								dwConferenceToken,
								FALSE,	// bCreate,
								NULL,	// pbSessionTableChanged,
								0,		// wListCount,
								NULL,	// pTermCapList[],
								NULL,	// pTermCapDescriptors[],
								ppSessionTable);
				return CC_NO_MEMORY;
			}
			status = H245CopyCap(&(*ppSessionTable)->SessionInfoArray[i].pTermCap,
				                 pChannel->pTxH245TermCap);
			UnlockChannel(pChannel);
			if (status != H245_ERROR_OK) {
				Free((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString);
				Free(ChannelList);
				UnlockConference(pConference);
				(*ppSessionTable)->wLength = i;
				DefaultSessionTableConstructor(
								hConference,
								dwConferenceToken,
								FALSE,	// bCreate,
								NULL,	// pbSessionTableChanged,
								0,		// wListCount,
								NULL,	// pTermCapList[],
								NULL,	// pTermCapDescriptors[],
								ppSessionTable);
				return status;
			}
			
			(*ppSessionTable)->SessionInfoArray[i].pRTPAddr = 
				(PCC_ADDR)Malloc(sizeof(CC_ADDR));
			if ((*ppSessionTable)->SessionInfoArray[i].pRTPAddr == NULL) {
				H245FreeCap((*ppSessionTable)->SessionInfoArray[i].pTermCap);
				Free((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString);
				Free(ChannelList);
				UnlockConference(pConference);
				(*ppSessionTable)->wLength = i;
				DefaultSessionTableConstructor(
								hConference,
								dwConferenceToken,
								FALSE,	// bCreate,
								NULL,	// pbSessionTableChanged,
								0,		// wListCount,
								NULL,	// pTermCapList[],
								NULL,	// pTermCapDescriptors[],
								ppSessionTable);
				return CC_NO_MEMORY;
			}
			(*ppSessionTable)->SessionInfoArray[i].pRTPAddr->nAddrType = CC_IP_BINARY;
			(*ppSessionTable)->SessionInfoArray[i].pRTPAddr->bMulticast = TRUE;
			(*ppSessionTable)->SessionInfoArray[i].pRTPAddr->Addr.IP_Binary.wPort = wPort++;
			(*ppSessionTable)->SessionInfoArray[i].pRTPAddr->Addr.IP_Binary.dwAddr = dwAddr;
			
			(*ppSessionTable)->SessionInfoArray[i].pRTCPAddr = 
				(PCC_ADDR)Malloc(sizeof(CC_ADDR));
			if ((*ppSessionTable)->SessionInfoArray[i].pRTCPAddr == NULL) {
				H245FreeCap((*ppSessionTable)->SessionInfoArray[i].pTermCap);
				FreeAddr((*ppSessionTable)->SessionInfoArray[i].pRTPAddr);
				Free((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString);
				Free(ChannelList);
				UnlockConference(pConference);
				(*ppSessionTable)->wLength = i;
				DefaultSessionTableConstructor(
								hConference,
								dwConferenceToken,
								FALSE,	// bCreate,
								NULL,	// pbSessionTableChanged,
								0,		// wListCount,
								NULL,	// pTermCapList[],
								NULL,	// pTermCapDescriptors[],
								ppSessionTable);
				return CC_NO_MEMORY;
			}
			(*ppSessionTable)->SessionInfoArray[i].pRTCPAddr->nAddrType = CC_IP_BINARY;
			(*ppSessionTable)->SessionInfoArray[i].pRTCPAddr->bMulticast = TRUE;
			(*ppSessionTable)->SessionInfoArray[i].pRTCPAddr->Addr.IP_Binary.wPort = wPort++;
			(*ppSessionTable)->SessionInfoArray[i].pRTCPAddr->Addr.IP_Binary.dwAddr = dwAddr;
		}
	}

	Free(ChannelList);
	UnlockConference(pConference);
	if (pbSessionTableChanged != NULL)
		*pbSessionTableChanged = TRUE;

	return CC_OK;
}



HRESULT DefaultTermCapConstructor(	CC_HCONFERENCE					hConference,
									DWORD							dwConferenceToken,
									BOOL							bCreate,
									BOOL							*pbTermCapsChanged,
									WORD							wListCount,
									PCC_TERMCAPLIST					pInTermCapList[],
									PCC_TERMCAPDESCRIPTORS			pInTermCapDescriptors[],
									PCC_TERMCAPLIST					*ppOutTermCapList,
									PCC_TERMCAPDESCRIPTORS			*ppOutTermCapDescriptors)
{
HRESULT				status;
PCONFERENCE			pConference;
WORD				wNumChannels;
PCC_HCHANNEL		ChannelList;
WORD				i;
PCHANNEL			pChannel;

	ASSERT(hConference != CC_INVALID_HANDLE);
	ASSERT(ppOutTermCapList != NULL);
	ASSERT(ppOutTermCapDescriptors != NULL);
	
	if (*ppOutTermCapList != NULL) {
		DestroyH245TermCapList(ppOutTermCapList);
		*ppOutTermCapList = NULL;
	}

	if (*ppOutTermCapDescriptors != NULL) {
		DestroyH245TermCapDescriptors(ppOutTermCapDescriptors);
		*ppOutTermCapDescriptors = NULL;
	}
	
	if (bCreate == FALSE)
		return CC_OK;

	*ppOutTermCapList = NULL;
	*ppOutTermCapDescriptors = NULL;
	if (pbTermCapsChanged != NULL)
		*pbTermCapsChanged = FALSE;

	status = LockConference(hConference, &pConference);
	if (status != CC_OK)
		return status;

	if (pConference->LocalEndpointAttached == NEVER_ATTACHED) {
		// Copy the local term caps to the conference term caps
		status = CopyH245TermCapList(ppOutTermCapList, pConference->pLocalH245TermCapList);
		if (status != CC_OK) {
			UnlockConference(pConference);
			return CC_NO_MEMORY;
		}

		// Copy the local term cap descriptors to the conference term cap descriptors
		status = CopyH245TermCapDescriptors(ppOutTermCapDescriptors, pConference->pLocalH245TermCapDescriptors);
		if (status != CC_OK) {
			UnlockConference(pConference);
			return CC_NO_MEMORY;
		}
	} else { // pConference->LocalEndpointAttached != NEVER_ATTACHED
		// Create one term cap entry for each open channel on this conference
		
		EnumerateChannelsInConference(&wNumChannels, &ChannelList, pConference, TX_CHANNEL);

		*ppOutTermCapList = (PCC_TERMCAPLIST)Malloc(sizeof(CC_TERMCAPLIST));
		if (*ppOutTermCapList == NULL) {
			Free(ChannelList);
			UnlockConference(pConference);
			return CC_NO_MEMORY;
		}
		(*ppOutTermCapList)->wLength = wNumChannels;
		if (wNumChannels == 0)
			(*ppOutTermCapList)->pTermCapArray = NULL;
		else {
			(*ppOutTermCapList)->pTermCapArray =
				(PPCC_TERMCAP)Malloc(sizeof(PCC_TERMCAP) * wNumChannels);
			if ((*ppOutTermCapList)->pTermCapArray == NULL) {
				Free(ChannelList);
				UnlockConference(pConference);
				(*ppOutTermCapList)->wLength = 0;
				DefaultTermCapConstructor(
										hConference,
										dwConferenceToken,
										FALSE,		// bCreate
										NULL,		// pbTermCapsChanged
										0,			// wListCount
										NULL,		// pInTermCapList[]
										NULL,		// pInTermCapDescriptors[]
										ppOutTermCapList,
										ppOutTermCapDescriptors);
				return CC_NO_MEMORY;
			}
			for (i = 0; i < wNumChannels; i++) {
				status = LockChannel(ChannelList[i], &pChannel);
				if (status != CC_OK) {
					Free(ChannelList);
					UnlockConference(pConference);
					(*ppOutTermCapList)->wLength = i;
					DefaultTermCapConstructor(
										hConference,
										dwConferenceToken,
										FALSE,		// bCreate
										NULL,		// pbTermCapsChanged
										0,			// wListCount
										NULL,		// pInTermCapList[]
										NULL,		// pInTermCapDescriptors[]
										ppOutTermCapList,
										ppOutTermCapDescriptors);
					return CC_NO_MEMORY;
				}
				status = H245CopyCap(&((*ppOutTermCapList)->pTermCapArray[i]),
									 pChannel->pTxH245TermCap);
				UnlockChannel(pChannel);
				if (status != H245_ERROR_OK) {
					Free(ChannelList);
					UnlockConference(pConference);
					(*ppOutTermCapList)->wLength = i;
					DefaultTermCapConstructor(
										hConference,
										dwConferenceToken,
										FALSE,		// bCreate
										NULL,		// pbTermCapsChanged
										0,			// wListCount
										NULL,		// pInTermCapList[]
										NULL,		// pInTermCapDescriptors[]
										ppOutTermCapList,
										ppOutTermCapDescriptors);
					return status;
				}

				(*ppOutTermCapList)->pTermCapArray[i]->Dir = H245_CAPDIR_LCLRXTX;
				(*ppOutTermCapList)->pTermCapArray[i]->CapId = (WORD)(i+1);
			}
		}

		Free(ChannelList);
		UnlockConference(pConference);

		// create a new descriptor list
		status = CreateH245DefaultTermCapDescriptors(ppOutTermCapDescriptors,
													 *ppOutTermCapList);
		if (status != CC_OK) {
			DefaultTermCapConstructor(
							hConference,
							dwConferenceToken,
							FALSE,		// bCreate
							NULL,		// pbTermCapsChanged
							0,			// wListCount
							NULL,		// pInTermCapList[]
							NULL,		// pInTermCapDescriptors[]
							ppOutTermCapList,
							ppOutTermCapDescriptors);
			return CC_NO_MEMORY;
		}
	}  // pConference->LocalEndpointAttached != NEVER_ATTACHED

	if (pbTermCapsChanged != NULL)
		*pbTermCapsChanged = TRUE;

	return CC_OK;
}



HRESULT AcceptCall(					PCALL					pCall,
									PCONFERENCE				pConference)
{
HRESULT				status;
CC_HCALL			hCall;
CC_HCONFERENCE		hConference;
HQ931CALL			hQ931Call;
CC_CONFERENCEID		ConferenceID;
BYTE				bTerminalType;
CC_ADDR				H245Addr;
H245_INST_T			H245Instance;
PCC_VENDORINFO		pVendorInfo;
PCC_NONSTANDARDDATA	pNonStandardData;
PWSTR				pszDisplay;
CC_ENDPOINTTYPE		DestinationEndpointType;
TRISTATE			tsMultipointController;
DWORD               dwLinkLayerPhysicalId;
DWORD				dwBandwidth;

	ASSERT(pCall != NULL);
	ASSERT(pConference != NULL);

	hCall = pCall->hCall;
	hConference = pConference->hConference;
	hQ931Call = pCall->hQ931Call;
	ConferenceID = pCall->ConferenceID;
	pCall->hConference = pConference->hConference;

	status = CopyNonStandardData(&pNonStandardData, pCall->pLocalNonStandardData);
	if (status != CC_OK) {
		UnlockConference(pConference);
		FreeCall(pCall);
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &ConferenceID,
					   NULL,					// alternate address
					   pNonStandardData);		// non-standard data
		return status;
	}

	status = CopyVendorInfo(&pVendorInfo, pConference->pVendorInfo);
	if (status != CC_OK) {
		UnlockConference(pConference);
		FreeCall(pCall);
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &ConferenceID,
					   NULL,					// alternate address
					   pNonStandardData);		// non-standard data
		FreeNonStandardData(pNonStandardData);
		return status;
	}

	status = CopyDisplay(&pszDisplay, pCall->pszLocalDisplay);
	if (status != CC_OK) {
		UnlockConference(pConference);
		FreeCall(pCall);
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &ConferenceID,
					   NULL,					// alternate address
					   pNonStandardData);		// non-standard data
		FreeNonStandardData(pNonStandardData);
		FreeVendorInfo(pVendorInfo);
		return status;
	}

	status = MakeH245PhysicalID(&pCall->dwH245PhysicalID);
	if (status != CC_OK) {
		UnlockConference(pConference);
		FreeCall(pCall);
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &ConferenceID,
					   NULL,					// alternate address
					   pNonStandardData);		// non-standard data
		FreeNonStandardData(pNonStandardData);
		FreeVendorInfo(pVendorInfo);
		FreeDisplay(pszDisplay);
		return status;
	}

	if (pCall->bCallerIsMC) {
		ASSERT(pConference->tsMultipointController != TS_TRUE);
		ASSERT(pConference->bMultipointCapable == TRUE);
		tsMultipointController = TS_FALSE;
	} else
		tsMultipointController = pConference->tsMultipointController;

    //MULTITHREAD
    //Use a tmp ID so we don't clobber the chosen H245Id. 
    //   H245Id=>
    //   <= linkLayerId
    dwLinkLayerPhysicalId = INVALID_PHYS_ID;

	SetTerminalType(tsMultipointController, &bTerminalType);
	pCall->H245Instance = H245Init(H245_CONF_H323,			// configuration
                                   pCall->dwH245PhysicalID,    // H245 physical ID
                                   &dwLinkLayerPhysicalId,     // the link layer ID is returned
								   hCall,					// dwPreserved
								   (H245_CONF_IND_CALLBACK_T)H245Callback, // callback
								   bTerminalType);			
	if (pCall->H245Instance == H245_INVALID_ID) {
		// H245 initialization failure
		UnlockConference(pConference);
		FreeCall(pCall);
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &ConferenceID,
					   NULL,					// alternate address
					   pNonStandardData);		// non-standard data
		FreeNonStandardData(pNonStandardData);
		FreeVendorInfo(pVendorInfo);
		FreeDisplay(pszDisplay);
		return CC_INTERNAL_ERROR;
	}

	H245Instance = pCall->H245Instance;

	// Set the H.245 TCP/IP address to the same IP address on which
	// the Q.931 connection was made; this ensures that if the host
	// is multi-homed, the H.245 will be made on the same IP address
	// as the Q.931 connection.  Set the initial H.245 port to zero,
	// so that it will be dynamically determined.
	ASSERT(pCall->pQ931LocalConnectAddr != NULL);
	H245Addr = *pCall->pQ931LocalConnectAddr;

	switch (pCall->pQ931LocalConnectAddr->nAddrType) {
		case CC_IP_DOMAIN_NAME:
			H245Addr.Addr.IP_DomainName.wPort = 0;
			break;
		case CC_IP_DOT:
			H245Addr.Addr.IP_Dot.wPort = 0;
			break;
		case CC_IP_BINARY:
			H245Addr.Addr.IP_Binary.wPort = 0;
			break;
		default:
			ASSERT(0);
			UnlockConference(pConference);
			FreeCall(pCall);
			H245ShutDown(H245Instance);
			Q931RejectCall(hQ931Call,				// Q931 call handle
						   CC_REJECT_UNDEFINED_REASON,	// reject reason
						   &ConferenceID,
						   NULL,					// alternate address
						   pNonStandardData);		// non-standard data
			FreeNonStandardData(pNonStandardData);
			FreeVendorInfo(pVendorInfo);
			FreeDisplay(pszDisplay);
			return CC_INTERNAL_ERROR;
	}

    status = linkLayerListen(&dwLinkLayerPhysicalId,
							 H245Instance,
							 &H245Addr,
							 NULL);
	if (status != NOERROR) {
		UnlockConference(pConference);
		FreeCall(pCall);
		H245ShutDown(H245Instance);
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &ConferenceID,
					   NULL,					// alternate address
					   pNonStandardData);		// non-standard data
		FreeNonStandardData(pNonStandardData);
		FreeVendorInfo(pVendorInfo);
		FreeDisplay(pszDisplay);
		return status;
	}

	dwBandwidth = pCall->dwBandwidth;

	UnlockConference(pConference);
	UnlockCall(pCall);

	DestinationEndpointType.pVendorInfo = pVendorInfo;
	DestinationEndpointType.bIsTerminal = TRUE;
	DestinationEndpointType.bIsGateway = FALSE;

	status = Q931AcceptCall(hQ931Call,
							pszDisplay,
							pNonStandardData,	// non-standard data
							&DestinationEndpointType,
							&H245Addr,		// H245 address
							dwBandwidth,
							hCall);			// user token
	FreeNonStandardData(pNonStandardData);
	FreeVendorInfo(pVendorInfo);
	FreeDisplay(pszDisplay);
	if (status != CS_OK) {
		if (LockCall(hCall, &pCall) == CC_OK)
			FreeCall(pCall);
		H245ShutDown(H245Instance);
		return status;
	}
	
	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		if (LockCall(hCall, &pCall) == CC_OK)
			FreeCall(pCall);
		H245ShutDown(H245Instance);
		Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
		return status;
	}

	pCall->CallState = TERMCAP;
	pConference->ConferenceID = pCall->ConferenceID;

	status = AddPlacedCallToConference(pCall, pConference);
	if (status != CC_OK) {
		UnlockConference(pConference);
		FreeCall(pCall);
		H245ShutDown(H245Instance);
		Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
		return status;
	}

	status = SendTermCaps(pCall, pConference);
	if (status != CC_OK) {
		UnlockConference(pConference);
		FreeCall(pCall);
		H245ShutDown(H245Instance);
		Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
		return status;
	}
	
	pCall->OutgoingTermCapState = AWAITING_ACK;

	if (pCall->MasterSlaveState == MASTER_SLAVE_NOT_STARTED) {
		status = H245InitMasterSlave(H245Instance,
			                         H245Instance);	// returned as dwTransId in the callback
		if (status != H245_ERROR_OK) {
			UnlockConference(pConference);
			FreeCall(pCall);
			H245ShutDown(H245Instance);
			Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
			return status;
		}
		pCall->MasterSlaveState = MASTER_SLAVE_IN_PROGRESS;
	}

	if (pCall->bCallerIsMC) {
		pConference->tsMultipointController = TS_FALSE;
		pConference->ConferenceMode = MULTIPOINT_MODE;
	}

	UnlockConference(pConference);
	UnlockCall(pCall);
	return CC_OK;
}



HRESULT PlaceCall(					PCALL					pCall,
									PCONFERENCE				pConference)
{
CC_HCALL			hCall;
HRESULT				status;
WORD				wGoal;
HQ931CALL			hQ931Call;
PCC_ALIASNAMES		pCallerAliasNames;
PCC_ALIASNAMES		pCalleeAliasNames;
PCC_ALIASNAMES		pCalleeExtraAliasNames;
PCC_ALIASITEM		pCalleeExtension;
PCC_VENDORINFO		pVendorInfo;
PWSTR				pszDisplay;
PCC_NONSTANDARDDATA	pNonStandardData;
WORD				wNumCalls;
PCC_ADDR			pConnectAddr;
PCC_ADDR			pDestinationAddr;
CC_ADDR				SourceAddr;
CC_ENDPOINTTYPE		SourceEndpointType;
BOOL				bCallerIsMC;
WORD				wCallType;

	ASSERT(pCall != NULL);

	hCall = pCall->hCall;

	if (pCall->CallState == ENQUEUED) {
		// Enqueue the call on the conference object and HResultLeaveCallControl.
		// There will be exactly one placed call for this conference,
		// which is in the process of being placed.  If this call placement
		// completes successfully, all enqueued calls will then be placed.
		// If this call placement fails or is terminated, one enqueued call
		// will be placed
		status = AddEnqueuedCallToConference(pCall, pConference);
		return status;
	}
	
	// CallState == PLACED
	EnumerateCallsInConference(&wNumCalls,
		                       NULL,
		                       pConference,
							   PLACED_CALL | ESTABLISHED_CALL);
	if (EqualConferenceIDs(&pConference->ConferenceID, &InvalidConferenceID))
		wGoal = CSG_CREATE;
	else if ((wNumCalls == 0) && (pConference->tsMultipointController != TS_TRUE))
		wGoal = CSG_JOIN;
	else
		wGoal = CSG_INVITE;

	status = AddPlacedCallToConference(pCall, pConference);
	if (status != CC_OK)
		return status;

	status = CopyAddr(&pConnectAddr, pCall->pQ931PeerConnectAddr);
	if (status != CC_OK)
		return status;
	
	status = CopyAddr(&pDestinationAddr, pCall->pQ931DestinationAddr);
	if (status != CC_OK) {
		FreeAddr(pConnectAddr);
		return status;
	}

	status = Q931CopyAliasNames(&pCallerAliasNames, pCall->pLocalAliasNames);
	if (status != CS_OK) {
		FreeAddr(pConnectAddr);
		FreeAddr(pDestinationAddr);
		return status;
	}

	status = CopyVendorInfo(&pVendorInfo, pConference->pVendorInfo);
	if (status != CC_OK) {
		FreeAddr(pConnectAddr);
		FreeAddr(pDestinationAddr);
		Q931FreeAliasNames(pCallerAliasNames);
		return status;
	}
	
	status = CopyDisplay(&pszDisplay, pCall->pszLocalDisplay);
	if (status != CC_OK) {
		FreeAddr(pConnectAddr);
		FreeAddr(pDestinationAddr);
		Q931FreeAliasNames(pCallerAliasNames);
		FreeVendorInfo(pVendorInfo);
		return status;
	}
	
	status = Q931CopyAliasNames(&pCalleeAliasNames, pCall->pPeerAliasNames);
	if (status != CS_OK) {
		FreeAddr(pConnectAddr);
		FreeAddr(pDestinationAddr);
		Q931FreeAliasNames(pCallerAliasNames);
		FreeVendorInfo(pVendorInfo);
		FreeDisplay(pszDisplay);
		return status;
	}
	
	status = Q931CopyAliasNames(&pCalleeExtraAliasNames,
							    pCall->pPeerExtraAliasNames);
	if (status != CS_OK) {
		FreeAddr(pConnectAddr);
		FreeAddr(pDestinationAddr);
		Q931FreeAliasNames(pCallerAliasNames);
		FreeVendorInfo(pVendorInfo);
		FreeDisplay(pszDisplay);
		Q931FreeAliasNames(pCalleeAliasNames);
		return status;
	}

	status = Q931CopyAliasItem(&pCalleeExtension,
							   pCall->pPeerExtension);
	if (status != CS_OK) {
		FreeAddr(pConnectAddr);
		FreeAddr(pDestinationAddr);
		Q931FreeAliasNames(pCallerAliasNames);
		FreeVendorInfo(pVendorInfo);
		FreeDisplay(pszDisplay);
		Q931FreeAliasNames(pCalleeAliasNames);
		Q931FreeAliasNames(pCalleeExtraAliasNames);
		return status;
	}

	status = CopyNonStandardData(&pNonStandardData, pCall->pLocalNonStandardData);
	if (status != CC_OK) {
		FreeAddr(pConnectAddr);
		FreeAddr(pDestinationAddr);
		Q931FreeAliasNames(pCallerAliasNames);
		FreeVendorInfo(pVendorInfo);
		FreeDisplay(pszDisplay);
		Q931FreeAliasNames(pCalleeAliasNames);
		Q931FreeAliasNames(pCalleeExtraAliasNames);
		Q931FreeAliasItem(pCalleeExtension);
		return status;
	}

	bCallerIsMC = (pConference->tsMultipointController == TS_TRUE ? TRUE : FALSE);
	// Note that if pConference->ConferenceMode == POINT_TO_POINT_MODE, this call attempt
	// will result in a multipoint call if successful, so set the wCallType accordingly
	wCallType = (WORD)((pConference->ConferenceMode == UNCONNECTED_MODE) ? CC_CALLTYPE_PT_PT : CC_CALLTYPE_N_N);

	SourceEndpointType.pVendorInfo = pVendorInfo;
	SourceEndpointType.bIsTerminal = TRUE;
	SourceEndpointType.bIsGateway = FALSE;

	// Cause our local Q.931 connect address to be placed in the
	// Q.931 setup-UUIE sourceAddress field
	SourceAddr.nAddrType = CC_IP_BINARY;
	SourceAddr.bMulticast = FALSE;
	SourceAddr.Addr.IP_Binary.dwAddr = 0;
	SourceAddr.Addr.IP_Binary.wPort = 0;

	status = Q931PlaceCall(&hQ931Call,				// Q931 call handle
		                   pszDisplay,
	                       pCallerAliasNames,
						   pCalleeAliasNames,
                           pCalleeExtraAliasNames,	// pCalleeExtraAliasNames
                           pCalleeExtension,		// pCalleeExtension
		                   pNonStandardData,		// non-standard data
						   &SourceEndpointType,
                           NULL, // pszCalledPartyNumber
						   pConnectAddr,
						   pDestinationAddr,
						   &SourceAddr,				// source address
						   bCallerIsMC,
						   &pCall->ConferenceID,	// conference ID
						   wGoal,
						   wCallType,
						   hCall,					// user token
						   (Q931_CALLBACK)Q931Callback, 	// callback
						   pCall->dwBandwidth,
#ifdef GATEKEEPER
                           pCall->GkiCall.usCRV);       // CRV
#else
                           0);                          // CRV
#endif GATEKEEPER
	FreeAddr(pConnectAddr);
	FreeAddr(pDestinationAddr);
	Q931FreeAliasNames(pCallerAliasNames);
	FreeVendorInfo(pVendorInfo);
	FreeDisplay(pszDisplay);
	Q931FreeAliasNames(pCalleeAliasNames);
	Q931FreeAliasNames(pCalleeExtraAliasNames);
	Q931FreeAliasItem(pCalleeExtension);
	FreeNonStandardData(pNonStandardData);
	if (status != CS_OK)
		return status;
	
	pCall->hQ931Call = hQ931Call;
	return CC_OK;
}



HRESULT SendTermCaps(				PCALL					pCall,
									PCONFERENCE				pConference)
{
HRESULT					status;
WORD					i;
H245_TOTCAPDESC_T		*pTermCapDescriptor;
PCC_TERMCAP				pH2250MuxCapability;
PCC_TERMCAPLIST			pTermCapList;
PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors;

	ASSERT(pCall != NULL);
	ASSERT(pConference != NULL);

	if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
		(pConference->tsMultipointController == TS_TRUE)) {
		pH2250MuxCapability = pConference->pConferenceH245H2250MuxCapability;
		pTermCapList = pConference->pConferenceTermCapList;
		pTermCapDescriptors = pConference->pConferenceTermCapDescriptors;
	} else {
		pH2250MuxCapability = pConference->pLocalH245H2250MuxCapability;
		pTermCapList = pConference->pLocalH245TermCapList;
		pTermCapDescriptors = pConference->pLocalH245TermCapDescriptors;
	}

	ASSERT(pH2250MuxCapability != NULL);
	ASSERT(pTermCapList != NULL);
	ASSERT(pTermCapDescriptors != NULL);

	// First send out the H.225.0 capability
	status = H245SetLocalCap(pCall->H245Instance,
							 pH2250MuxCapability,
							 &pH2250MuxCapability->CapId);
	ASSERT(pH2250MuxCapability->CapId == 0);
	if (status != H245_ERROR_OK)
		return status;

	// Now send out the terminal capabilities
	for (i = 0; i < pTermCapList->wLength; i++) {
		status = H245SetLocalCap(pCall->H245Instance,
		                         pTermCapList->pTermCapArray[i],
							     &pTermCapList->pTermCapArray[i]->CapId);
		if (status != H245_ERROR_OK)
			return status;
	}

	// Finally send out the capability descriptors
	for (i = 0; i < pTermCapDescriptors->wLength; i++) {
		pTermCapDescriptor = pTermCapDescriptors->pTermCapDescriptorArray[i];
		status = H245SetCapDescriptor(pCall->H245Instance,
		                              &pTermCapDescriptor->CapDesc,
								      &pTermCapDescriptor->CapDescId);
		if (status != H245_ERROR_OK)
			return status;
	}

	status = H245SendTermCaps(pCall->H245Instance,
		                      pCall->H245Instance);	// returned as dwTransId in the callback
	return status;
}



HRESULT SessionTableToH245CommunicationTable(
									PCC_SESSIONTABLE		pSessionTable,
									H245_COMM_MODE_ENTRY_T	*pH245CommunicationTable[],
									BYTE					*pbCommunicationTableCount)
{
WORD	i, j;
WORD	wStringLength;

	ASSERT(pH245CommunicationTable != NULL);
	ASSERT(pbCommunicationTableCount != NULL);

	if ((pSessionTable == NULL) || (pSessionTable->wLength == 0)) {
		*pH245CommunicationTable = NULL;
		*pbCommunicationTableCount = 0;
		return CC_OK;
	}

	if (pSessionTable->SessionInfoArray == NULL) {
		*pH245CommunicationTable = NULL;
		*pbCommunicationTableCount = 0;
		return CC_BAD_PARAM;
	}

	*pH245CommunicationTable = (H245_COMM_MODE_ENTRY_T *)Malloc(sizeof(H245_COMM_MODE_ENTRY_T) * pSessionTable->wLength);
	if (*pH245CommunicationTable == NULL) {
		*pbCommunicationTableCount = 0;
		return CC_NO_MEMORY;
	}

	*pbCommunicationTableCount = (BYTE)pSessionTable->wLength;

	for (i = 0; i < pSessionTable->wLength; i++) {
		(*pH245CommunicationTable)[i].pNonStandard = NULL;
		(*pH245CommunicationTable)[i].sessionID = pSessionTable->SessionInfoArray[i].bSessionID;
		if (pSessionTable->SessionInfoArray[i].bAssociatedSessionID == 0)
			(*pH245CommunicationTable)[i].associatedSessionIDPresent = FALSE;
		else {
			(*pH245CommunicationTable)[i].associatedSessionIDPresent = TRUE;
			(*pH245CommunicationTable)[i].associatedSessionID = pSessionTable->SessionInfoArray[i].bAssociatedSessionID;
		}
		(*pH245CommunicationTable)[i].terminalLabelPresent = FALSE;
		wStringLength = pSessionTable->SessionInfoArray[i].SessionDescription.wOctetStringLength;
		if (wStringLength > 0) {
			(*pH245CommunicationTable)[i].pSessionDescription = (unsigned short *)Malloc(sizeof(unsigned short) * wStringLength);
			if ((*pH245CommunicationTable)[i].pSessionDescription == NULL) {
				for (j = 0; j < i; j++)
					Free((*pH245CommunicationTable)[j].pSessionDescription);
				Free(*pH245CommunicationTable);
				*pbCommunicationTableCount = 0;
				return CC_NO_MEMORY;
			}
			memcpy((*pH245CommunicationTable)[i].pSessionDescription,
				   pSessionTable->SessionInfoArray[i].SessionDescription.pOctetString,
				   wStringLength);
		} else
			(*pH245CommunicationTable)[i].pSessionDescription = NULL;
		(*pH245CommunicationTable)[i].wSessionDescriptionLength = wStringLength;
		(*pH245CommunicationTable)[i].dataType = *pSessionTable->SessionInfoArray[i].pTermCap;
		if (pSessionTable->SessionInfoArray[i].pRTPAddr == NULL)
			(*pH245CommunicationTable)[i].mediaChannelPresent = FALSE;
		else {
			if (pSessionTable->SessionInfoArray[i].pRTPAddr->nAddrType != CC_IP_BINARY) {
			for (j = 0; j <= i; j++)
				if ((*pH245CommunicationTable)[j].pSessionDescription != NULL)
					Free((*pH245CommunicationTable)[j].pSessionDescription);
				Free(*pH245CommunicationTable);
				*pbCommunicationTableCount = 0;
				return CC_BAD_PARAM;
			}
			if (pSessionTable->SessionInfoArray[i].pRTPAddr->bMulticast)
				(*pH245CommunicationTable)[i].mediaChannel.type = H245_IP_MULTICAST;
			else
				(*pH245CommunicationTable)[i].mediaChannel.type = H245_IP_UNICAST;
			(*pH245CommunicationTable)[i].mediaChannel.u.ip.tsapIdentifier =
				pSessionTable->SessionInfoArray[i].pRTPAddr->Addr.IP_Binary.wPort;
			HostToH245IPNetwork((*pH245CommunicationTable)[i].mediaChannel.u.ip.network,
								pSessionTable->SessionInfoArray[i].pRTPAddr->Addr.IP_Binary.dwAddr);
			(*pH245CommunicationTable)[i].mediaChannelPresent = TRUE;
		}
		if (pSessionTable->SessionInfoArray[i].pRTCPAddr == NULL)
			(*pH245CommunicationTable)[i].mediaControlChannelPresent = FALSE;
		else {
			if (pSessionTable->SessionInfoArray[i].pRTCPAddr->nAddrType != CC_IP_BINARY) {
			for (j = 0; j <= i; j++)
				if ((*pH245CommunicationTable)[j].pSessionDescription != NULL)
					Free((*pH245CommunicationTable)[j].pSessionDescription);
				Free(*pH245CommunicationTable);
				*pbCommunicationTableCount = 0;
				return CC_BAD_PARAM;
			}
			if (pSessionTable->SessionInfoArray[i].pRTCPAddr->bMulticast)
				(*pH245CommunicationTable)[i].mediaControlChannel.type = H245_IP_MULTICAST;
			else
				(*pH245CommunicationTable)[i].mediaControlChannel.type = H245_IP_UNICAST;
			(*pH245CommunicationTable)[i].mediaControlChannel.u.ip.tsapIdentifier =
				pSessionTable->SessionInfoArray[i].pRTCPAddr->Addr.IP_Binary.wPort;
			HostToH245IPNetwork((*pH245CommunicationTable)[i].mediaControlChannel.u.ip.network,
								pSessionTable->SessionInfoArray[i].pRTCPAddr->Addr.IP_Binary.dwAddr);
			(*pH245CommunicationTable)[i].mediaControlChannelPresent = TRUE;
		}
		(*pH245CommunicationTable)[i].mediaGuaranteed = FALSE;
		(*pH245CommunicationTable)[i].mediaGuaranteedPresent = TRUE;
		(*pH245CommunicationTable)[i].mediaControlGuaranteed = FALSE;
		(*pH245CommunicationTable)[i].mediaControlGuaranteedPresent = TRUE;
	}

	return CC_OK;
}



HRESULT H245CommunicationTableToSessionTable(
									H245_COMM_MODE_ENTRY_T	H245CommunicationTable[],
									BYTE					bCommunicationTableCount,
									PCC_SESSIONTABLE		*ppSessionTable)
{
WORD	i, j;
HRESULT	status;

	ASSERT(ppSessionTable != NULL);

	if (H245CommunicationTable == NULL)
		if (bCommunicationTableCount == 0) {
			*ppSessionTable = NULL;
			return CC_OK;
		} else
			return CC_BAD_PARAM;
	else
		if (bCommunicationTableCount == 0)
			return CC_BAD_PARAM;

	*ppSessionTable = (PCC_SESSIONTABLE)Malloc(sizeof(CC_SESSIONTABLE));
	if (*ppSessionTable == NULL)
		return CC_NO_MEMORY;

	(*ppSessionTable)->wLength = bCommunicationTableCount;

	(*ppSessionTable)->SessionInfoArray = (PCC_SESSIONINFO)Malloc(sizeof(CC_SESSIONINFO) * bCommunicationTableCount);
	if ((*ppSessionTable)->SessionInfoArray == NULL) {
		Free(*ppSessionTable);
		*ppSessionTable = NULL;
		return CC_NO_MEMORY;
	}

	for (i = 0; i < bCommunicationTableCount; i++) {
		(*ppSessionTable)->SessionInfoArray[i].bSessionID = H245CommunicationTable[i].sessionID;
		if (H245CommunicationTable[i].associatedSessionIDPresent)
			(*ppSessionTable)->SessionInfoArray[i].bAssociatedSessionID =
				H245CommunicationTable[i].associatedSessionID;
		else
			(*ppSessionTable)->SessionInfoArray[i].bAssociatedSessionID = 0;
		(*ppSessionTable)->SessionInfoArray[i].SessionDescription.wOctetStringLength =
			H245CommunicationTable[i].wSessionDescriptionLength;
		if ((*ppSessionTable)->SessionInfoArray[i].SessionDescription.wOctetStringLength == 0)
			(*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString = NULL;
		else {
			(*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString =
				(BYTE *)Malloc(H245CommunicationTable[i].wSessionDescriptionLength);
			if ((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString == NULL) {
				for (j = 0; j < i; j++) {
					H245FreeCap((*ppSessionTable)->SessionInfoArray[j].pTermCap);
					if ((*ppSessionTable)->SessionInfoArray[j].pRTPAddr != NULL)
						Free((*ppSessionTable)->SessionInfoArray[j].pRTPAddr);
					if ((*ppSessionTable)->SessionInfoArray[j].pRTCPAddr != NULL)
						Free((*ppSessionTable)->SessionInfoArray[j].pRTCPAddr);
				}
				Free((*ppSessionTable)->SessionInfoArray);
				Free(*ppSessionTable);
				return CC_NO_MEMORY;
			}
			memcpy((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString,
				   H245CommunicationTable[i].pSessionDescription,
				   H245CommunicationTable[i].wSessionDescriptionLength);
		}
		status = H245CopyCap(&(*ppSessionTable)->SessionInfoArray[i].pTermCap,
							 &H245CommunicationTable[i].dataType);
		if (status != H245_ERROR_OK) {
			if ((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString != NULL)
				Free((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString);
			for (j = 0; j < i; j++) {
				H245FreeCap((*ppSessionTable)->SessionInfoArray[j].pTermCap);
				if ((*ppSessionTable)->SessionInfoArray[j].pRTPAddr != NULL)
					Free((*ppSessionTable)->SessionInfoArray[j].pRTPAddr);
				if ((*ppSessionTable)->SessionInfoArray[j].pRTCPAddr != NULL)
					Free((*ppSessionTable)->SessionInfoArray[j].pRTCPAddr);
			}
			Free((*ppSessionTable)->SessionInfoArray);
			Free(*ppSessionTable);
			return status;
		}
		if ((H245CommunicationTable[i].mediaChannelPresent) &&
		    ((H245CommunicationTable[i].mediaChannel.type == H245_IP_MULTICAST) ||
		     (H245CommunicationTable[i].mediaChannel.type == H245_IP_UNICAST))) {
			(*ppSessionTable)->SessionInfoArray[i].pRTPAddr = (PCC_ADDR)Malloc(sizeof(CC_ADDR));
			if ((*ppSessionTable)->SessionInfoArray[i].pRTPAddr == NULL) {
				if ((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString != NULL)
					Free((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString);
				H245FreeCap((*ppSessionTable)->SessionInfoArray[i].pTermCap);
				for (j = 0; j < i; j++) {
					H245FreeCap((*ppSessionTable)->SessionInfoArray[j].pTermCap);
					if ((*ppSessionTable)->SessionInfoArray[j].pRTPAddr != NULL)
						Free((*ppSessionTable)->SessionInfoArray[j].pRTPAddr);
					if ((*ppSessionTable)->SessionInfoArray[j].pRTCPAddr != NULL)
						Free((*ppSessionTable)->SessionInfoArray[j].pRTCPAddr);
				}
				Free((*ppSessionTable)->SessionInfoArray);
				Free(*ppSessionTable);
				return CC_NO_MEMORY;
			}
			(*ppSessionTable)->SessionInfoArray[i].pRTPAddr->nAddrType = CC_IP_BINARY;
			if (H245CommunicationTable[i].mediaChannel.type == H245_IP_MULTICAST)
				(*ppSessionTable)->SessionInfoArray[i].pRTPAddr->bMulticast = TRUE;
			else
				(*ppSessionTable)->SessionInfoArray[i].pRTPAddr->bMulticast = FALSE;
			(*ppSessionTable)->SessionInfoArray[i].pRTPAddr->Addr.IP_Binary.wPort =
				H245CommunicationTable[i].mediaChannel.u.ip.tsapIdentifier;
			H245IPNetworkToHost(&(*ppSessionTable)->SessionInfoArray[i].pRTPAddr->Addr.IP_Binary.dwAddr,
								H245CommunicationTable[i].mediaChannel.u.ip.network);
		} else
			(*ppSessionTable)->SessionInfoArray[i].pRTPAddr = NULL;
 		if ((H245CommunicationTable[i].mediaControlChannelPresent) &&
		    ((H245CommunicationTable[i].mediaControlChannel.type == H245_IP_MULTICAST) ||
		     (H245CommunicationTable[i].mediaControlChannel.type == H245_IP_UNICAST))) {
			(*ppSessionTable)->SessionInfoArray[i].pRTCPAddr = (PCC_ADDR)Malloc(sizeof(CC_ADDR));
			if ((*ppSessionTable)->SessionInfoArray[i].pRTCPAddr == NULL) {
				if ((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString != NULL)
					Free((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString);
				H245FreeCap((*ppSessionTable)->SessionInfoArray[i].pTermCap);
				if ((*ppSessionTable)->SessionInfoArray[i].pRTPAddr != NULL)
					Free((*ppSessionTable)->SessionInfoArray[i].pRTPAddr);
				for (j = 0; j < i; j++) {
					H245FreeCap((*ppSessionTable)->SessionInfoArray[j].pTermCap);
					if ((*ppSessionTable)->SessionInfoArray[j].pRTPAddr != NULL)
						Free((*ppSessionTable)->SessionInfoArray[j].pRTPAddr);
					if ((*ppSessionTable)->SessionInfoArray[j].pRTCPAddr != NULL)
						Free((*ppSessionTable)->SessionInfoArray[j].pRTCPAddr);
				}
				Free((*ppSessionTable)->SessionInfoArray);
				Free(*ppSessionTable);
				return CC_NO_MEMORY;
			}
			(*ppSessionTable)->SessionInfoArray[i].pRTCPAddr->nAddrType = CC_IP_BINARY;
			if (H245CommunicationTable[i].mediaChannel.type == H245_IP_MULTICAST)
				(*ppSessionTable)->SessionInfoArray[i].pRTCPAddr->bMulticast = TRUE;
			else
				(*ppSessionTable)->SessionInfoArray[i].pRTCPAddr->bMulticast = FALSE;
			(*ppSessionTable)->SessionInfoArray[i].pRTCPAddr->Addr.IP_Binary.wPort =
				H245CommunicationTable[i].mediaControlChannel.u.ip.tsapIdentifier;
			H245IPNetworkToHost(&(*ppSessionTable)->SessionInfoArray[i].pRTCPAddr->Addr.IP_Binary.dwAddr,
								H245CommunicationTable[i].mediaControlChannel.u.ip.network);
		} else
			(*ppSessionTable)->SessionInfoArray[i].pRTCPAddr = NULL;
	}
	return CC_OK;
}



HRESULT FreeH245CommunicationTable(	H245_COMM_MODE_ENTRY_T	H245CommunicationTable[],
									BYTE					bCommunicationTableCount)
{
WORD	i;

	if (H245CommunicationTable == NULL)
		if (bCommunicationTableCount == 0)
			return CC_OK;
		else
			return CC_BAD_PARAM;
	else
		if (bCommunicationTableCount == 0)
			return CC_BAD_PARAM;

	for (i = 0; i < bCommunicationTableCount; i++)
		if (H245CommunicationTable[i].pSessionDescription != NULL)
			Free(H245CommunicationTable[i].pSessionDescription);
	Free(H245CommunicationTable);
	return CC_OK;
}



HRESULT _PrepareTermCapLists(		PCONFERENCE				pConference,
									WORD					*pwListCount,
									PCC_TERMCAPLIST			**ppTermCapList,
									PCC_TERMCAPDESCRIPTORS	**ppTermCapDescriptorList,
									PCALL					*pCallList[])
{
WORD		i;
WORD		wNumCalls;
WORD		wOffset;
PCC_HCALL	CallList;
PCALL		pCall;

	ASSERT(pConference != NULL);
	ASSERT(pwListCount != NULL);
	ASSERT(ppTermCapList != NULL);
	ASSERT(ppTermCapDescriptorList != NULL);
	ASSERT(pCallList != NULL);

	EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);

	if ((pConference->LocalEndpointAttached == DETACHED) && (wNumCalls > 0))
		wOffset = 0;
	else
		// LocalEndpointAttached is either UNATTACHED or ATTACHED, or there are no calls
		// in the conference; in the latter case, we need to have some term caps in
		// order to form the conference term cap set (which cannot be empty)
		wOffset = 1;

	*pwListCount = (WORD)(wNumCalls + wOffset);

	*ppTermCapList = (PCC_TERMCAPLIST *)Malloc(sizeof(PCC_TERMCAPLIST) * (*pwListCount));
	if (*ppTermCapList == NULL) {
		Free(CallList);
		return CC_NO_MEMORY;
	}

	*ppTermCapDescriptorList = (PCC_TERMCAPDESCRIPTORS *)Malloc(sizeof(PCC_TERMCAPDESCRIPTORS) * (*pwListCount));
	if (*ppTermCapDescriptorList == NULL) {
		Free(CallList);
		Free(*ppTermCapList);
		return CC_NO_MEMORY;
	}

	*pCallList = (PCALL *)Malloc(sizeof(PCALL) * (*pwListCount));
	if (*pCallList == NULL) {
		Free(CallList);
		Free(*ppTermCapList);
		Free(*ppTermCapDescriptorList);
		return CC_NO_MEMORY;
	}

	// Fill in pTermCapList and pTermCapDescriptorList
	if (wOffset == 1) {
		// The local endpoint is attached to the conference, so fill in the first
		// slot in both lists with the local term cap and descriptor lists
		(*ppTermCapList)[0] = pConference->pLocalH245TermCapList;
		(*ppTermCapDescriptorList)[0] = pConference->pLocalH245TermCapDescriptors;
	}
	for (i = 0; i < wNumCalls; i++) {
		if (LockCall(CallList[i], &pCall) == CC_OK) {
			(*ppTermCapList)[i+wOffset] = pCall->pPeerH245TermCapList;
			(*ppTermCapDescriptorList)[i+wOffset] = pCall->pPeerH245TermCapDescriptors;
			(*pCallList)[i] = pCall;
		} else {
			(*ppTermCapList)[i+wOffset] = NULL;
			(*ppTermCapDescriptorList)[i+wOffset] = NULL;
			(*pCallList)[i] = NULL;
		}
	}
	for (i = 0; i < wOffset; i++)
		(*pCallList)[wNumCalls+i] = NULL;
	Free(CallList);
	return CC_OK;
}



HRESULT _FreeTermCapLists(			WORD					wListCount, 
									PCC_TERMCAPLIST			*pTermCapList,
									PCC_TERMCAPDESCRIPTORS	*pTermCapDescriptorList,
									PCALL					pCallList[])
{
WORD	i;

	for (i = 0; i < wListCount; i++)
		if (pCallList[i] != NULL)
			UnlockCall(pCallList[i]);
	if (pTermCapList != NULL)
		Free(pTermCapList);
	if (pTermCapDescriptorList != NULL)
		Free(pTermCapDescriptorList);
	Free(pCallList);
	return CC_OK;
}



HRESULT CreateConferenceSessionTable(
									PCONFERENCE				pConference,
									BOOL					*pbSessionTableChanged)
{
HRESULT					status;
PCALL					*pCallList;
PCC_TERMCAPLIST			*pTermCapList;
PCC_TERMCAPDESCRIPTORS	*pTermCapDescriptorList;
WORD					wListCount;

	ASSERT(pConference != NULL);

	if (pConference->bSessionTableInternallyConstructed == TRUE) {
		status = FreeConferenceSessionTable(pConference);
		if (status != CC_OK)
			return status;
		pConference->bSessionTableInternallyConstructed = FALSE;
	}

	status = _PrepareTermCapLists(pConference,
								  &wListCount,
								  &pTermCapList,
								  &pTermCapDescriptorList,
								  &pCallList);
	if (status != CC_OK)
		return status;

	status = pConference->SessionTableConstructor(
									pConference->hConference,
									pConference->dwConferenceToken,
									TRUE,		// bCreate
									pbSessionTableChanged,
									wListCount,
									pTermCapList,
									pTermCapDescriptorList,
									&pConference->pSessionTable);

	_FreeTermCapLists(wListCount,
					  pTermCapList,
					  pTermCapDescriptorList,
					  pCallList);
	return status;
}



HRESULT FreeConferenceSessionTable(	PCONFERENCE				pConference)
{
HRESULT	status;

	ASSERT(pConference != NULL);

	if (pConference->bSessionTableInternallyConstructed)
		status = DefaultSessionTableConstructor(
									pConference->hConference,
									pConference->dwConferenceToken,
									FALSE,		// bCreate
									NULL,		// pbSessionTableChanged
									0,			// wListCount
									NULL,		// pTermCapList[]
									NULL,		// pTermCapDescriptors[]
									&pConference->pSessionTable);
	else
		status = pConference->SessionTableConstructor(
									pConference->hConference,
									pConference->dwConferenceToken,
									FALSE,		// bCreate
									NULL,		// pbSessionTableChanged
									0,			// wListCount
									NULL,		// pTermCapList[]
									NULL,		// pTermCapDescriptors[]
									&pConference->pSessionTable);
	pConference->pSessionTable = NULL;
	return status;
}



HRESULT CreateConferenceTermCaps(	PCONFERENCE				pConference,
									BOOL					*pbTermCapsChanged)
{
HRESULT					status;
WORD					wListCount;
PCALL					*pCallList;
PCC_TERMCAPLIST			*pInTermCapList;
PCC_TERMCAPDESCRIPTORS	*pInTermCapDescriptors;

	ASSERT(pConference != NULL);

	if (pConference->pConferenceH245H2250MuxCapability != NULL)
		H245FreeCap(pConference->pConferenceH245H2250MuxCapability);

	ASSERT(pConference->pLocalH245H2250MuxCapability != NULL);
	status = H245CopyCap(&pConference->pConferenceH245H2250MuxCapability,
						 pConference->pLocalH245H2250MuxCapability);
	if (status != H245_ERROR_OK)
		return status;

	status = _PrepareTermCapLists(pConference,
								  &wListCount,
								  &pInTermCapList,
								  &pInTermCapDescriptors,
								  &pCallList);
	if (status != CC_OK)
		return status;

	status = UnregisterTermCapListFromH245(pConference,
										   pConference->pConferenceTermCapList);
	if (status != CC_OK)
		return status;

	status = UnregisterTermCapDescriptorsFromH245(pConference,
												  pConference->pConferenceTermCapDescriptors);
	if (status != CC_OK)
		return status;

	status = pConference->TermCapConstructor(
									pConference->hConference,
									pConference->dwConferenceToken,
									TRUE,		// bCreate
									pbTermCapsChanged,
									wListCount,
									pInTermCapList,
									pInTermCapDescriptors,
									&pConference->pConferenceTermCapList,
									&pConference->pConferenceTermCapDescriptors);

	_FreeTermCapLists(wListCount,
					  pInTermCapList,
					  pInTermCapDescriptors,
					  pCallList);
	return status;
}



HRESULT FreeConferenceTermCaps(		PCONFERENCE				pConference)
{
HRESULT	status;

	ASSERT(pConference != NULL);

	status = pConference->TermCapConstructor(
									pConference->hConference,
									pConference->dwConferenceToken,
									FALSE,		// bCreate
									NULL,		// pbTermCapsChanged
									0,			// wListCount
									NULL,		// pInTermCapList[]
									NULL,		// pInTermCapDescriptors[]
									&pConference->pConferenceTermCapList,
									&pConference->pConferenceTermCapDescriptors);
	pConference->pConferenceTermCapList = NULL;
	pConference->pConferenceTermCapDescriptors = NULL;
	return status;
}



HRESULT FindEnqueuedRequest(		PCALL_QUEUE				pQueueHead,
									CC_HCALL				hEnqueuedCall)
{
PCALL_QUEUE	pQueueItem;

	ASSERT(hEnqueuedCall != CC_INVALID_HANDLE);

	pQueueItem = pQueueHead;

	while (pQueueItem != NULL) {
		if (pQueueItem->hCall == hEnqueuedCall)
			break;
		pQueueItem = pQueueItem->pNext;
	}
	if (pQueueItem == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT EnqueueRequest(				PCALL_QUEUE				*ppQueueHead,
									CC_HCALL				hEnqueuedCall)
{
PCALL_QUEUE	pQueueItem;

	ASSERT(ppQueueHead != NULL);
	ASSERT(hEnqueuedCall != CC_INVALID_HANDLE);

	// Make sure we're not enqueuing a duplicate request
	pQueueItem = *ppQueueHead;
	while (pQueueItem != NULL) {
		if (pQueueItem->hCall == hEnqueuedCall)
			return CC_OK;
		pQueueItem = pQueueItem->pNext;
	}

	pQueueItem = (PCALL_QUEUE)Malloc(sizeof(CALL_QUEUE));
	if (pQueueItem == NULL)
		return CC_NO_MEMORY;
	pQueueItem->hCall = hEnqueuedCall;
	pQueueItem->pPrev = NULL;
	pQueueItem->pNext = *ppQueueHead;
	if (*ppQueueHead != NULL)
		(*ppQueueHead)->pPrev = pQueueItem;
	*ppQueueHead = pQueueItem;
	return CC_OK;
}



HRESULT DequeueRequest(				PCALL_QUEUE				*ppQueueHead,
									PCC_HCALL				phEnqueuedCall)

{
PCALL_QUEUE	pQueueItem;

	ASSERT(ppQueueHead != NULL);

	if (phEnqueuedCall != NULL)
		*phEnqueuedCall = CC_INVALID_HANDLE;

	if (*ppQueueHead == NULL)
		return CC_BAD_PARAM;

	pQueueItem = *ppQueueHead;
	*ppQueueHead = (*ppQueueHead)->pNext;
	if (*ppQueueHead != NULL)
		(*ppQueueHead)->pPrev = NULL;

	if (phEnqueuedCall != NULL)
		*phEnqueuedCall = pQueueItem->hCall;
	Free(pQueueItem);
	return CC_OK;
}



HRESULT DequeueSpecificRequest(		PCALL_QUEUE				*ppQueueHead,
									CC_HCALL				hEnqueuedCall)
{
PCALL_QUEUE	pQueueItem;

	ASSERT(ppQueueHead != NULL);
	ASSERT(hEnqueuedCall != CC_INVALID_HANDLE);

	pQueueItem = *ppQueueHead;
	while (pQueueItem != NULL)
		if (pQueueItem->hCall == hEnqueuedCall)
			break;
		else
			pQueueItem = pQueueItem->pNext;

	if (pQueueItem == NULL)
		return CC_BAD_PARAM;

	if (pQueueItem->pNext != NULL)
		pQueueItem->pNext->pPrev = pQueueItem->pPrev;
	if (pQueueItem->pPrev == NULL)
		*ppQueueHead = pQueueItem->pNext;
	else
		pQueueItem->pPrev->pNext = pQueueItem->pNext;

	Free(pQueueItem);
	return CC_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\callcont\ccutils.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/ccutils.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.40  $
 *	$Date:   31 Jan 1997 20:36:02  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#define Malloc(size) malloc(size)
#define Free(p) free(p)

void * MallocDbg(                                       DWORD                                   dwSize,
									PSTR					pszFile, 
									int						nLine);

void FreeDbg(						void *					pMem,
									PSTR					pszFile, 
									int						nLine);

HRESULT InitializeLock(				PLOCK					pLock);

HRESULT DeleteLock(					PLOCK					pLock);

HRESULT AcquireLock(				PLOCK					pLock);

HRESULT AcquireTimedLock(			PLOCK					pLock,
									DWORD					dwTimeout,
									BOOL					*pbTimedOut);

HRESULT RelinquishLock(				PLOCK					pLock);

BOOL EqualConferenceIDs(			PCC_CONFERENCEID		pConferenceID1,
									PCC_CONFERENCEID		pConferenceID2);

BOOL EqualAddrs(					PCC_ADDR				pAddr1,
									PCC_ADDR				pAddr2);

HRESULT ValidateOctetString(		PCC_OCTETSTRING			pOctetString);

HRESULT CopyOctetString(			PCC_OCTETSTRING			*ppDest,
									PCC_OCTETSTRING			pSource);

HRESULT FreeOctetString(			PCC_OCTETSTRING			pOctetString);

HRESULT CopySeparateStack(			H245_ACCESS_T			**ppDest,
									H245_ACCESS_T			*pSource);

HRESULT FreeSeparateStack(			H245_ACCESS_T			*pSeparateStack);

HRESULT ValidateNonStandardData(	PCC_NONSTANDARDDATA		pNonStandardData);

HRESULT CopyNonStandardData(		PCC_NONSTANDARDDATA		*ppDest,
									PCC_NONSTANDARDDATA		pSource);

HRESULT FreeNonStandardData(		PCC_NONSTANDARDDATA		pNonStandardData);

HRESULT ValidateVendorInfo(			PCC_VENDORINFO			pVendorInfo);

HRESULT CopyVendorInfo(				PCC_VENDORINFO			*ppDest,
									PCC_VENDORINFO			pSource);

HRESULT FreeVendorInfo(				PCC_VENDORINFO			pVendorInfo);

HRESULT ValidateTermCapList(		PCC_TERMCAPLIST			pTermCapList);

HRESULT ValidateTermCapDescriptors(	PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors,
									PCC_TERMCAPLIST			pTermCapList);

HRESULT ValidateAddr(				PCC_ADDR				pAddr);

HRESULT CopyAddr(					PCC_ADDR				*ppDest,
									PCC_ADDR				pSource);

HRESULT FreeAddr(					PCC_ADDR				pAddr);

HRESULT SetQ931Port(				PCC_ADDR				pAddr);

HRESULT ValidateDisplay(			PWSTR					pszDisplay);

HRESULT CopyDisplay(				PWSTR					*ppDest,
									PWSTR					pSource);

HRESULT FreeDisplay(				PWSTR					pszDisplay);

HRESULT ValidateTerminalID(			PCC_OCTETSTRING			pTerminalID);

HRESULT CopyTerminalID(				PCC_OCTETSTRING			*ppDest,
									PCC_OCTETSTRING			pSource);

HRESULT FreeTerminalID(				PCC_OCTETSTRING			pTerminalID);

HRESULT SetTerminalType(			TRISTATE				tsMultipointController,
									BYTE					*pbTerminalType);

HRESULT CopyH245TermCapList(		PCC_TERMCAPLIST			*ppDest,
									PCC_TERMCAPLIST			pSource);

HRESULT CopyH245TermCapDescriptors(	PCC_TERMCAPDESCRIPTORS	*ppDest,
									PCC_TERMCAPDESCRIPTORS	pSource);

HRESULT CreateH245DefaultTermCapDescriptors(
									PCC_TERMCAPDESCRIPTORS	*ppDest,
									PCC_TERMCAPLIST			pTermCapList);

HRESULT DestroyH245TermCap(			PPCC_TERMCAP			ppTermCap);

HRESULT UnregisterTermCapListFromH245(		
									PCONFERENCE				pConference,
									PCC_TERMCAPLIST			pTermCapList);

HRESULT DestroyH245TermCapList(		PCC_TERMCAPLIST			*ppTermCapList);

HRESULT UnregisterTermCapDescriptorsFromH245(
									PCONFERENCE				pConference,
									PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors);

HRESULT DestroyH245TermCapDescriptors(
									PCC_TERMCAPDESCRIPTORS	*ppTermCapDescriptors);

HRESULT HostToH245IPNetwork(		BYTE					*NetworkArray,
									DWORD					dwAddr);

HRESULT H245IPNetworkToHost(		DWORD					*pdwAddr,
									BYTE					*NetworkArray);

HRESULT ProcessRemoteHangup(		CC_HCALL				hCall,
									HQ931CALL				hQ931Initiator,
									BYTE					bHangupReason);

HRESULT DefaultSessionTableConstructor(
									CC_HCONFERENCE			hConference,
									DWORD					dwConferenceToken,
									BOOL					bCreate,
									BOOL					*pbSessionTableChanged,
									WORD					wListCount,
									PCC_TERMCAPLIST			pTermCapList[],
									PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors[],
									PCC_SESSIONTABLE		*ppSessionTable);

HRESULT DefaultTermCapConstructor(	CC_HCONFERENCE					hConference,
									DWORD							dwConferenceToken,
									BOOL							bCreate,
									BOOL							*pbTermCapsChanged,
									WORD							wListCount,
									PCC_TERMCAPLIST					pInTermCapList[],
									PCC_TERMCAPDESCRIPTORS			pInTermCapDescriptors[],
									PCC_TERMCAPLIST					*ppOutTermCapList,
									PCC_TERMCAPDESCRIPTORS			*ppOutTermCapDescriptors);

HRESULT AcceptCall(					PCALL					pCall,
									PCONFERENCE				pConference);

HRESULT PlaceCall(					PCALL					pCall,
									PCONFERENCE				pConference);

HRESULT SendTermCaps(				PCALL					pCall,
									PCONFERENCE				pConference);

HRESULT SessionTableToH245CommunicationTable(
									PCC_SESSIONTABLE		pSessionTable,
									H245_COMM_MODE_ENTRY_T	*pH245CommunicationTable[],
									BYTE					*pbCommunicationTableCount);

HRESULT H245CommunicationTableToSessionTable(
									H245_COMM_MODE_ENTRY_T	H245CommunicationTable[],
									BYTE					bCommunicationTableCount,
									PCC_SESSIONTABLE		*ppSessionTable);

HRESULT FreeH245CommunicationTable(	H245_COMM_MODE_ENTRY_T	H245CommunicationTable[],
									BYTE					bCommunicationTableCount);

HRESULT CreateConferenceSessionTable(
									PCONFERENCE				pConference,
									BOOL					*pbSessionTableChanged);

HRESULT FreeConferenceSessionTable(	PCONFERENCE				pConference);

HRESULT CreateConferenceTermCaps(	PCONFERENCE				pConference,
									BOOL					*pbTermCapsChanged);

HRESULT FreeConferenceTermCaps(		PCONFERENCE				pConference);

HRESULT EnqueueRequest(				PCALL_QUEUE				*ppQueueHead,
									CC_HCALL				hEnqueuedCall);

HRESULT DequeueRequest(				PCALL_QUEUE				*ppQueueHead,
									PCC_HCALL				phEnqueuedCall);

HRESULT DequeueSpecificRequest(		PCALL_QUEUE				*ppQueueHead,
									CC_HCALL				hEnqueuedCall);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\callcont\ccmain.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/ccmain.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.81.1.1  $
 *	$Date:   23 Jun 1997 15:58:02  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#include <winerror.h>
#ifdef GATEKEEPER
#include "gkiman.h"
#endif // GATEKEEPER


#define MASTER_SLAVE_RETRY_MAX 10

typedef struct {
#ifdef DBG
	CRITICAL_SECTION	LockInfoLock;
	WORD				wLockCount;
	WORD				wNumQueuedThreads;
	HANDLE				hOwningThread;
#endif
	HANDLE				Lock;
} LOCK, *PLOCK;

typedef struct {
	LOCK				Lock;
	WORD				wNumThreads;
} THREADCOUNT;

typedef enum {
	INITIALIZING_STATE,
	OPERATIONAL_STATE,
	SHUTDOWN_STATE
} CALL_CONTROL_STATE;

// The following typedef is not in callcont.h because it is only used internally
typedef DWORD	HHANGUP, *PHHANGUP;

typedef enum {
	TS_FALSE,
	TS_TRUE,
	TS_UNKNOWN
} TRISTATE;

typedef enum {
	UNCONNECTED_MODE,
	POINT_TO_POINT_MODE,
	MULTIPOINT_MODE
} CONFMODE;

typedef enum {
	NEVER_ATTACHED,	// Endpoint has never been attached to the conference
	ATTACHED,		// Endpoint is currently attached to the conference
	DETACHED		// Endpoint was once attached to the conference, but is now detached
} ATTACHSTATE;

typedef struct CallQueue_t {
	CC_HCALL			hCall;
	struct CallQueue_t	*pNext;
	struct CallQueue_t	*pPrev;
} CALL_QUEUE, *PCALL_QUEUE;

#define NUM_TERMINAL_ALLOCATION_SLOTS	24		// 24*sizeof(BYTE) = 192 = max. terminal number
#define NUM_CHANNEL_ALLOCATION_SLOTS	32		// 32*sizeof(BYTE) = 256 = max. channel number

typedef enum {
	TERMINAL_ID_INVALID,
	TERMINAL_ID_REQUESTED,
	TERMINAL_ID_VALID
} TERMINALIDSTATE;

typedef struct {
	TERMINALIDSTATE			TerminalIDState;
	CC_PARTICIPANTINFO		ParticipantInfo;
	PCALL_QUEUE				pEnqueuedRequestsForTerminalID; // list of calls waiting to get this peer's terminal ID
} PARTICIPANTINFO, *PPARTICIPANTINFO;


typedef struct Conference_t {
	CC_HCONFERENCE			hConference;		// handle for this conference object
	CC_CONFERENCEID			ConferenceID;		// conference ID (0 => conference ID has not
												//   been established)
	PARTICIPANTINFO			LocalParticipantInfo;
	BYTE					TerminalNumberAllocation[NUM_TERMINAL_ALLOCATION_SLOTS];
	BYTE					ChannelNumberAllocation[NUM_CHANNEL_ALLOCATION_SLOTS];
	BOOL					bDeferredDelete;
	BOOL					bMultipointCapable;
	BOOL					bForceMC;
	BOOL					bAutoAccept;
	ATTACHSTATE				LocalEndpointAttached;
	BOOL					bDynamicConferenceID;
	BOOL					bDynamicTerminalID;
	PCC_TERMCAP				pLocalH245H2250MuxCapability;
	PCC_TERMCAPLIST			pLocalH245TermCapList;			// terminal capabilities
	PCC_TERMCAPDESCRIPTORS	pLocalH245TermCapDescriptors;	// terminal capability descriptors
	BOOL					bSessionTableInternallyConstructed;  // TRUE => session table must be
												// deallocated by Call Control; FALSE => must be
												// deallocated by SessionTableConstructor
	PCC_SESSIONTABLE		pSessionTable;
	PCC_TERMCAP				pConferenceH245H2250MuxCapability;
	PCC_TERMCAPLIST			pConferenceTermCapList;
	PCC_TERMCAPDESCRIPTORS	pConferenceTermCapDescriptors;
	DWORD					dwConferenceToken;	// conference token specified by user in
												//   CreateConference()
	CC_SESSIONTABLE_CONSTRUCTOR SessionTableConstructor;
	CC_TERMCAP_CONSTRUCTOR	TermCapConstructor;
	CC_CONFERENCE_CALLBACK	ConferenceCallback;	// conference callback location
	CC_CONFERENCE_CALLBACK	SaveConferenceCallback;	// saved copy of the conference callback location
	struct Call_t			*pEnqueuedCalls;
	struct Call_t			*pPlacedCalls;
	struct Call_t			*pEstablishedCalls;
	struct Call_t			*pVirtualCalls;
	struct Channel_t		*pChannels;
	TRISTATE				tsMultipointController;
	TRISTATE				tsMaster;
	CONFMODE				ConferenceMode;
	PCC_ADDR				pMultipointControllerAddr;
	PCC_VENDORINFO			pVendorInfo;
	PCALL_QUEUE				pEnqueuedRequestModeCalls;
	BOOL					bInTable;
	struct Conference_t		*pNextInTable;
	struct Conference_t		*pPrevInTable;
	LOCK					Lock;
} CONFERENCE, *PCONFERENCE, **PPCONFERENCE;

// State of call object
typedef enum {
	INCOMING,		// incoming call request has been received,
					//   but not yet accepted or rejected
	ENQUEUED,		// call has been enqueued on conference for later placement
	PLACED,			// call has been placed, awaiting RINGING, CONNECT or RELEASECOMPLETE
	RINGING,		// RINGING received, awaiting CONNECT or RELEASECOMPLETE
	TERMCAP,		// CONNECT received or incoming call accepted,
					//   awaiting completion of terminal capability exchange
	CALL_COMPLETE	// call placement complete (either success or failure)
} CALLSTATE;

typedef enum {
	NEED_TO_SEND_TERMCAP,
	AWAITING_TERMCAP,
	AWAITING_ACK,
	TERMCAP_COMPLETE
} TERMCAPSTATE;

typedef enum {
	MASTER_SLAVE_NOT_STARTED,
	MASTER_SLAVE_IN_PROGRESS,
	MASTER_SLAVE_COMPLETE
} MASTERSLAVESTATE;

typedef enum {
	CALLER,
	CALLEE,
	VIRTUAL,
	THIRD_PARTY_INVITOR,
	THIRD_PARTY_INTERMEDIARY	// we're the MC in a third party invite
} CALLTYPE;

typedef struct Call_t {
	CC_HCALL				hCall;
	CC_HCONFERENCE			hConference;
	HQ931CALL				hQ931Call;
	HQ931CALL				hQ931CallInvitor;		// Invitor in third party invite
	PPARTICIPANTINFO		pPeerParticipantInfo;
	BOOL					bMarkedForDeletion;
	PCC_NONSTANDARDDATA		pLocalNonStandardData;
	PCC_NONSTANDARDDATA		pPeerNonStandardData;
	PCC_ADDR				pQ931LocalConnectAddr;
	PCC_ADDR				pQ931PeerConnectAddr;
	PCC_ADDR				pQ931DestinationAddr;
	PCC_ADDR				pSourceCallSignalAddr;
	PCC_TERMCAPLIST			pPeerH245TermCapList;
	PCC_TERMCAP				pPeerH245H2250MuxCapability;
	PCC_TERMCAPDESCRIPTORS	pPeerH245TermCapDescriptors;
	PCC_ALIASNAMES			pLocalAliasNames;
	PCC_ALIASNAMES			pPeerAliasNames;
	PCC_ALIASNAMES			pPeerExtraAliasNames;
	PCC_ALIASITEM			pPeerExtension;
	PWSTR					pszLocalDisplay;
	PWSTR					pszPeerDisplay;
	PCC_VENDORINFO			pPeerVendorInfo;
	DWORD					dwUserToken;
	TERMCAPSTATE			OutgoingTermCapState;	// NEED_TO_SEND_TERMCAP, AWAITING_ACK, or
													// TERMCAP_COMPLETE
	TERMCAPSTATE			IncomingTermCapState;	// AWAITING_TERMCAP or TERMCAP_COMPLETE
	MASTERSLAVESTATE		MasterSlaveState;
	struct Call_t			*pNext;
	struct Call_t			*pPrev;
	CALLSTATE				CallState;
	CALLTYPE				CallType;
	BOOL					bCallerIsMC;
	CC_CONFERENCEID			ConferenceID;
	BOOL					bLinkEstablished;
	H245_INST_T				H245Instance;
	DWORD					dwH245PhysicalID;
	WORD					wMasterSlaveRetry;
	DWORD					dwBandwidth;
#ifdef GATEKEEPER
   GKICALL           GkiCall;
#endif // GATEKEEPER
	BOOL					bInTable;
	struct Call_t			*pNextInTable;
	struct Call_t			*pPrevInTable;
	LOCK					Lock;
} CALL, *PCALL, **PPCALL;

// Channel types must be bit maps
#define TX_CHANNEL			0x01
#define RX_CHANNEL			0x02
#define TXRX_CHANNEL		0x04	// bi-directional channel
#define PROXY_CHANNEL		0x08
#define ALL_CHANNELS		(TX_CHANNEL | RX_CHANNEL | TXRX_CHANNEL | PROXY_CHANNEL)

typedef struct Channel_t {
	CC_HCHANNEL				hChannel;
	CC_HCONFERENCE			hConference;
	DWORD					dwUserToken;
	BYTE					bSessionID;
	BYTE					bAssociatedSessionID;
	WORD					wLocalChannelNumber;
	WORD					wRemoteChannelNumber;
	BOOL					bMultipointChannel;
	WORD					wNumOutstandingRequests;
	PCC_TERMCAP				pTxH245TermCap;
	PCC_TERMCAP				pRxH245TermCap;
	H245_MUX_T				*pTxMuxTable;
	H245_MUX_T				*pRxMuxTable;
	H245_ACCESS_T			*pSeparateStack;
	CC_HCALL				hCall;
	BYTE					bChannelType;
	BOOL					bCallbackInvoked;
	TRISTATE				tsAccepted;
	PCALL_QUEUE				pCloseRequests;
	PCC_ADDR				pLocalRTPAddr;
	PCC_ADDR				pLocalRTCPAddr;
	PCC_ADDR				pPeerRTPAddr;
	PCC_ADDR				pPeerRTCPAddr;
	DWORD                   dwBandwidth;
	BOOL					bLocallyOpened;
	struct Channel_t		*pNext;
	struct Channel_t		*pPrev;
	BOOL					bInTable;
	struct Channel_t		*pNextInTable;
	struct Channel_t		*pPrevInTable;
	LOCK					Lock;
} CHANNEL, *PCHANNEL, **PPCHANNEL;

typedef struct Listen_t {
	CC_HLISTEN				hListen;
	CC_ADDR					ListenAddr;
	DWORD					dwListenToken;
	CC_LISTEN_CALLBACK		ListenCallback;
	HQ931LISTEN				hQ931Listen;
	PCC_ALIASNAMES			pLocalAliasNames;	// local alias names
	BOOL					bInTable;
	struct Listen_t			*pNextInTable;
	struct Listen_t			*pPrevInTable;
	LOCK					Lock;
} LISTEN, *PLISTEN, **PPLISTEN;

typedef struct Hangup_t {
	HHANGUP					hHangup;
	CC_HCONFERENCE			hConference;
	DWORD					dwUserToken;
	WORD					wNumCalls;
	BOOL					bInTable;
	struct Hangup_t			*pNextInTable;
	struct Hangup_t			*pPrevInTable;
	LOCK					Lock;
} HANGUP, *PHANGUP, **PPHANGUP;

#ifdef FORCE_SERIALIZE_CALL_CONTROL
#define EnterCallControlTop()      {CCLOCK_AcquireLock(); \
									AcquireLock(&ThreadCount.Lock); \
									ThreadCount.wNumThreads++; \
									RelinquishLock(&ThreadCount.Lock);}

#define LeaveCallControlTop(f)     {HRESULT stat; \
	                                stat = f; \
									AcquireLock(&ThreadCount.Lock); \
				                    ThreadCount.wNumThreads--; \
									RelinquishLock(&ThreadCount.Lock); \
									CCLOCK_RelinquishLock(); \
                                    return stat;}
#else
#define EnterCallControlTop()  EnterCallControl()
#define LeaveCallControlTop(f) HResultLeaveCallControl(f) 
#endif

#define EnterCallControl()         {AcquireLock(&ThreadCount.Lock); \
									ThreadCount.wNumThreads++; \
									RelinquishLock(&ThreadCount.Lock);}

#define NullLeaveCallControl()     {AcquireLock(&ThreadCount.Lock); \
									ThreadCount.wNumThreads--; \
									RelinquishLock(&ThreadCount.Lock); \
                                    return;}

#define HResultLeaveCallControl(f) {HRESULT stat; \
	                                stat = f; \
									AcquireLock(&ThreadCount.Lock); \
				                    ThreadCount.wNumThreads--; \
									RelinquishLock(&ThreadCount.Lock); \
                                    return stat;}

#define DWLeaveCallControl(f)      {DWORD	stat; \
	                                stat = f; \
									AcquireLock(&ThreadCount.Lock); \
				                    ThreadCount.wNumThreads--; \
									RelinquishLock(&ThreadCount.Lock); \
                                    return stat;}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\callcont\chanman.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/chanman.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.20.1.0  $
 *	$Date:   20 Jun 1997 14:18:40  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

HRESULT InitChannelManager();

HRESULT DeInitChannelManager();

HRESULT AllocAndLockChannel(		PCC_HCHANNEL			phChannel,
									PCONFERENCE				pConference,
									CC_HCALL				hCall,
									PCC_TERMCAP				pTxTermCap,
									PCC_TERMCAP				pRxTermCap,
									H245_MUX_T				*pTxMuxTable,
									H245_MUX_T				*pRxMuxTable,
									H245_ACCESS_T			*pSeparateStack,
									DWORD					dwUserToken,
									BYTE					bChannelType,
									BYTE					bSessionID,
									BYTE					bAssociatedSessionID,
									WORD					wRemoteChannelNumber,
									PCC_ADDR				pLocalRTPAddr,
									PCC_ADDR				pLocalRTCPAddr,
									PCC_ADDR				pPeerRTPAddr,
									PCC_ADDR				pPeerRTCPAddr,
									BOOL					bLocallyOpened,
									DWORD					dwBandwidth,
									PPCHANNEL				ppChannel);

HRESULT AddLocalAddrPairToChannel(	PCC_ADDR				pRTPAddr,
									PCC_ADDR				pRTCPAddr,
									PCHANNEL				pChannel);

HRESULT AddSeparateStackToChannel(	H245_ACCESS_T			*pSeparateStack,
									PCHANNEL				pChannel);

HRESULT FreeChannel(				PCHANNEL				pChannel);

HRESULT LockChannel(				CC_HCHANNEL				hChannel,
									PPCHANNEL				ppChannel);

HRESULT LockChannelAndConference(	CC_HCHANNEL				hChannel,
									PPCHANNEL				ppChannel,
									PPCONFERENCE			ppConference);

HRESULT ValidateChannel(			CC_HCHANNEL				hChannel);

HRESULT UnlockChannel(				PCHANNEL				pChannel);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\callcont\chanman.c ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/chanman.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.43.1.0  $
 *	$Date:   20 Jun 1997 14:18:24  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/
#pragma warning ( disable : 4115 4201 4214 )
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#pragma warning ( default : 4115 4201 4214 )
#include "apierror.h"
#include "incommon.h"
#include "callcont.h"
#include "q931.h"
#include "ccmain.h"
#include "ccutils.h"
#include "listman.h"
#include "q931man.h"
#include "userman.h"
#include "callman.h"
#include "confman.h"
#include "chanman.h"


static BOOL			bChannelInited = FALSE;

static struct {
	PCHANNEL			pHead;
	LOCK				Lock;
} ChannelTable;

static struct {
	CC_HCHANNEL			hChannel;
	LOCK				Lock;
} ChannelHandle;



HRESULT InitChannelManager()
{
	ASSERT(bChannelInited == FALSE);

	ChannelTable.pHead = NULL;
	InitializeLock(&ChannelTable.Lock);

	ChannelHandle.hChannel = CC_INVALID_HANDLE + 1;
	InitializeLock(&ChannelHandle.Lock);

	bChannelInited = TRUE;
	return CC_OK;
}



HRESULT DeInitChannelManager()
{
PCHANNEL	pChannel;
PCHANNEL	pNextChannel;

	if (bChannelInited == FALSE)
		return CC_OK;

	pChannel = ChannelTable.pHead;
	while (pChannel != NULL) {
		AcquireLock(&pChannel->Lock);
		pNextChannel = pChannel->pNextInTable;
		FreeChannel(pChannel);
		pChannel = pNextChannel;
	}

	DeleteLock(&ChannelHandle.Lock);
	DeleteLock(&ChannelTable.Lock);
	bChannelInited = FALSE;
	return CC_OK;
}



HRESULT _AddChannelToTable(			PCHANNEL				pChannel)
{
	ASSERT(pChannel != NULL);
	ASSERT(pChannel->hChannel != CC_INVALID_HANDLE);
	ASSERT(pChannel->bInTable == FALSE);

	AcquireLock(&ChannelTable.Lock);

	pChannel->pNextInTable = ChannelTable.pHead;
	pChannel->pPrevInTable = NULL;
	if (ChannelTable.pHead != NULL)
		ChannelTable.pHead->pPrevInTable = pChannel;
	ChannelTable.pHead = pChannel;

	pChannel->bInTable = TRUE;

	RelinquishLock(&ChannelTable.Lock);
	return CC_OK;
}



HRESULT _RemoveChannelFromTable(	PCHANNEL				pChannel)
{
CC_HCHANNEL		hChannel;
BOOL			bTimedOut;

	ASSERT(pChannel != NULL);
	ASSERT(pChannel->bInTable == TRUE);

	// Caller must have a lock on the channel object;
	// in order to avoid deadlock, we must:
	//   1. unlock the channel object,
	//   2. lock the ChannelTable,
	//   3. locate the channel object in the ChannelTable (note that
	//      after step 2, the channel object may be deleted from the
	//      ChannelTable by another thread),
	//   4. lock the channel object (someone else may have the lock)
	//   5. remove the channel object from the ChannelTable,
	//   6. unlock the ChannelTable
	//
	// The caller can now safely unlock and destroy the channel object,
	// since no other thread will be able to find the object (its been
	// removed from the ChannelTable), and therefore no other thread will
	// be able to lock it.

	// Save the channel handle; its the only way to look up
	// the channel object in the ChannelTable. Note that we
	// can't use pChannel to find the channel object, since
	// pChannel may be free'd up, and another channel object
	// allocated at the same address
	hChannel = pChannel->hChannel;

	// step 1
	RelinquishLock(&pChannel->Lock);

step2:
	// step 2
	AcquireLock(&ChannelTable.Lock);

	// step 3
	pChannel = ChannelTable.pHead;
	while ((pChannel != NULL) && (pChannel->hChannel != hChannel))
		pChannel = pChannel->pNextInTable;

	if (pChannel != NULL) {
		// step 4
		AcquireTimedLock(&pChannel->Lock,10,&bTimedOut);
		if (bTimedOut) {
			RelinquishLock(&ChannelTable.Lock);
			Sleep(0);
			goto step2;
		}
		// step 5
		if (pChannel->pPrevInTable == NULL)
			ChannelTable.pHead = pChannel->pNextInTable;
		else
			pChannel->pPrevInTable->pNextInTable = pChannel->pNextInTable;

		if (pChannel->pNextInTable != NULL)
			pChannel->pNextInTable->pPrevInTable = pChannel->pPrevInTable;

		pChannel->pPrevInTable = NULL;
		pChannel->pNextInTable = NULL;
		pChannel->bInTable = FALSE;
	}

	// step 6
	RelinquishLock(&ChannelTable.Lock);

	if (pChannel == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT _MakeChannelHandle(			PCC_HCHANNEL			phChannel)
{
	AcquireLock(&ChannelHandle.Lock);
	*phChannel = ChannelHandle.hChannel++;
	RelinquishLock(&ChannelHandle.Lock);
	return CC_OK;
}


HRESULT AllocAndLockChannel(		PCC_HCHANNEL			phChannel,
									PCONFERENCE				pConference,
									CC_HCALL				hCall,
									PCC_TERMCAP				pTxTermCap,
									PCC_TERMCAP				pRxTermCap,
									H245_MUX_T				*pTxMuxTable,
									H245_MUX_T				*pRxMuxTable,
									H245_ACCESS_T			*pSeparateStack,
									DWORD					dwUserToken,
									BYTE					bChannelType,
									BYTE					bSessionID,
									BYTE					bAssociatedSessionID,
									WORD					wRemoteChannelNumber,
									PCC_ADDR				pLocalRTPAddr,
									PCC_ADDR				pLocalRTCPAddr,
									PCC_ADDR				pPeerRTPAddr,
									PCC_ADDR				pPeerRTCPAddr,
									BOOL					bLocallyOpened,
									DWORD					dwBandwidth,
									PPCHANNEL				ppChannel)
{
HRESULT		status;
	
	ASSERT(bChannelInited == TRUE);

	// all parameters should have been validated by the caller
	ASSERT(phChannel != NULL);
	ASSERT(pConference != NULL);
	ASSERT((bChannelType == TX_CHANNEL) ||
		   (bChannelType == RX_CHANNEL) ||
		   (bChannelType == TXRX_CHANNEL) ||
		   (bChannelType == PROXY_CHANNEL));
	ASSERT(ppChannel != NULL);

	// set phChannel now, in case we encounter an error
	*phChannel = CC_INVALID_HANDLE;

	*ppChannel = (PCHANNEL)Malloc(sizeof(CHANNEL));
	if (*ppChannel == NULL)
		return CC_NO_MEMORY;

	(*ppChannel)->bInTable = FALSE;
	(*ppChannel)->bMultipointChannel = FALSE;
	(*ppChannel)->hCall = hCall;
	(*ppChannel)->wNumOutstandingRequests = 0;
	(*ppChannel)->pTxH245TermCap = NULL;
	(*ppChannel)->pRxH245TermCap = NULL;
	(*ppChannel)->pTxMuxTable = NULL;
	(*ppChannel)->pRxMuxTable = NULL;
	(*ppChannel)->pSeparateStack = NULL;
	(*ppChannel)->pCloseRequests = NULL;
	(*ppChannel)->pLocalRTPAddr = NULL;
	(*ppChannel)->pLocalRTCPAddr = NULL;
	(*ppChannel)->pPeerRTPAddr = NULL;
	(*ppChannel)->pPeerRTCPAddr = NULL;
	(*ppChannel)->dwUserToken = dwUserToken;
	(*ppChannel)->hConference = pConference->hConference;
	(*ppChannel)->bSessionID = bSessionID;
	(*ppChannel)->bAssociatedSessionID = bAssociatedSessionID;
	(*ppChannel)->wLocalChannelNumber = 0;
	(*ppChannel)->wRemoteChannelNumber = 0;
	(*ppChannel)->bLocallyOpened = bLocallyOpened;
	(*ppChannel)->dwBandwidth = dwBandwidth;
	(*ppChannel)->pNextInTable = NULL;
	(*ppChannel)->pPrevInTable = NULL;
	(*ppChannel)->pNext = NULL;
	(*ppChannel)->pPrev = NULL;
	
	InitializeLock(&(*ppChannel)->Lock);
	AcquireLock(&(*ppChannel)->Lock);

	status = _MakeChannelHandle(&(*ppChannel)->hChannel);
	if (status != CC_OK) {
		FreeChannel(*ppChannel);
		return status;
	}

	if (bLocallyOpened == TRUE)
		(*ppChannel)->tsAccepted = TS_TRUE;
	else
		(*ppChannel)->tsAccepted = TS_UNKNOWN;

	if (pTxMuxTable != NULL) {
		(*ppChannel)->pTxMuxTable = (H245_MUX_T *)Malloc(sizeof(H245_MUX_T));
		if ((*ppChannel)->pTxMuxTable == NULL) {
			FreeChannel(*ppChannel);
			return CC_NO_MEMORY;
		}
		*(*ppChannel)->pTxMuxTable = *pTxMuxTable;
	}

	if (pRxMuxTable != NULL) {
		(*ppChannel)->pRxMuxTable = (H245_MUX_T *)Malloc(sizeof(H245_MUX_T));
		if ((*ppChannel)->pRxMuxTable == NULL) {
			FreeChannel(*ppChannel);
			return CC_NO_MEMORY;
		}
		*(*ppChannel)->pRxMuxTable = *pRxMuxTable;
	}

	if (pSeparateStack != NULL) {
		status = CopySeparateStack(&(*ppChannel)->pSeparateStack,
								   pSeparateStack);
		if (status != CC_OK) {
			FreeChannel(*ppChannel);
			return status;
		}
	}

	(*ppChannel)->bChannelType = bChannelType;
	(*ppChannel)->bCallbackInvoked = FALSE;
	if (pTxTermCap != NULL) {
		status = H245CopyCap(&(*ppChannel)->pTxH245TermCap, pTxTermCap);
		if (status != H245_ERROR_OK) {
			FreeChannel(*ppChannel);
			return status;
		}
	}
	if (pRxTermCap != NULL) {
		status = H245CopyCap(&(*ppChannel)->pRxH245TermCap, pRxTermCap); 
		if (status != H245_ERROR_OK) {
			FreeChannel(*ppChannel);
			return status;
		}
	}
	if (pLocalRTPAddr != NULL) {
		(*ppChannel)->pLocalRTPAddr = (PCC_ADDR)Malloc(sizeof(CC_ADDR));
		if ((*ppChannel)->pLocalRTPAddr == NULL) {
			FreeChannel(*ppChannel);
			return CC_NO_MEMORY;
		}
		*(*ppChannel)->pLocalRTPAddr = *pLocalRTPAddr;
	}
	if (pLocalRTCPAddr != NULL) {
		(*ppChannel)->pLocalRTCPAddr = (PCC_ADDR)Malloc(sizeof(CC_ADDR));
		if ((*ppChannel)->pLocalRTCPAddr == NULL) {
			FreeChannel(*ppChannel);
			return CC_NO_MEMORY;
		}
		*(*ppChannel)->pLocalRTCPAddr = *pLocalRTCPAddr;
	}
	if (pPeerRTPAddr != NULL) {
		(*ppChannel)->pPeerRTPAddr = (PCC_ADDR)Malloc(sizeof(CC_ADDR));
		if ((*ppChannel)->pPeerRTPAddr == NULL) {
			FreeChannel(*ppChannel);
			return CC_NO_MEMORY;
		}
		*(*ppChannel)->pPeerRTPAddr = *pPeerRTPAddr;
	}
	if (pPeerRTCPAddr != NULL) {
		(*ppChannel)->pPeerRTCPAddr = (PCC_ADDR)Malloc(sizeof(CC_ADDR));
		if ((*ppChannel)->pPeerRTCPAddr == NULL) {
			FreeChannel(*ppChannel);
			return CC_NO_MEMORY;
		}
		*(*ppChannel)->pPeerRTCPAddr = *pPeerRTCPAddr;
	}
	
	*phChannel = (*ppChannel)->hChannel;

	// add the conference to the conference table
	status = _AddChannelToTable(*ppChannel);
	if (status != CC_OK) {
		FreeChannel(*ppChannel);
		return status;
	}

	switch (bChannelType) {
		case TX_CHANNEL:			
			status = AllocateChannelNumber(pConference, &(*ppChannel)->wLocalChannelNumber);
			if (status != CC_OK) {
				FreeChannel(*ppChannel);
				return status;
			}
			(*ppChannel)->wRemoteChannelNumber = 0;
			break;

		case RX_CHANNEL:
			(*ppChannel)->wLocalChannelNumber = 0;
			(*ppChannel)->wRemoteChannelNumber = wRemoteChannelNumber;
			break;

		case TXRX_CHANNEL:
			status = AllocateChannelNumber(pConference, &(*ppChannel)->wLocalChannelNumber);
			if (status != CC_OK) {
				FreeChannel(*ppChannel);
				return status;
			}
			if (bLocallyOpened)
				(*ppChannel)->wRemoteChannelNumber = 0;
			else
				(*ppChannel)->wRemoteChannelNumber = wRemoteChannelNumber;
			break;

		case PROXY_CHANNEL:
			status = AllocateChannelNumber(pConference, &(*ppChannel)->wLocalChannelNumber);
			if (status != CC_OK) {
				FreeChannel(*ppChannel);
				return status;
			}
			(*ppChannel)->wRemoteChannelNumber = wRemoteChannelNumber;
			break;

		default:
			ASSERT(0);
			break;
	}
	
	return CC_OK;
}



HRESULT AddLocalAddrPairToChannel(	PCC_ADDR				pRTPAddr,
									PCC_ADDR				pRTCPAddr,
									PCHANNEL				pChannel)
{
	ASSERT(pChannel != NULL);

	if (pRTPAddr != NULL) {
		if (pChannel->pLocalRTPAddr == NULL) {
			pChannel->pLocalRTPAddr = (PCC_ADDR)Malloc(sizeof(CC_ADDR));
			if (pChannel->pLocalRTPAddr == NULL)
				return CC_NO_MEMORY;
		}
		*pChannel->pLocalRTPAddr = *pRTPAddr;
	}

	if (pRTCPAddr != NULL) {
		if (pChannel->pLocalRTCPAddr == NULL) {
			pChannel->pLocalRTCPAddr = (PCC_ADDR)Malloc(sizeof(CC_ADDR));
			if (pChannel->pLocalRTCPAddr == NULL)
				return CC_NO_MEMORY;
		}
		*pChannel->pLocalRTCPAddr = *pRTCPAddr;
	}

	return CC_OK;
}



HRESULT AddSeparateStackToChannel(	H245_ACCESS_T			*pSeparateStack,
									PCHANNEL				pChannel)
{
	ASSERT(pSeparateStack != NULL);
	ASSERT(pChannel != NULL);

	if (pChannel->pSeparateStack != NULL)
		return CC_BAD_PARAM;

	pChannel->pSeparateStack = (H245_ACCESS_T *)Malloc(sizeof(H245_ACCESS_T));
	if (pChannel->pSeparateStack == NULL)
		return CC_NO_MEMORY;
	*pChannel->pSeparateStack = *pSeparateStack;
	return CC_OK;
}



// Caller must have a lock on the channel object
HRESULT FreeChannel(				PCHANNEL				pChannel)
{
HRESULT				status;
CC_HCHANNEL			hChannel;
PCONFERENCE			pConference;

	ASSERT(pChannel != NULL);

	// caller must have a lock on the channel object,
	// so there's no need to re-lock it
	
	hChannel = pChannel->hChannel;
	if (pChannel->hConference != CC_INVALID_HANDLE) {
		UnlockChannel(pChannel);
		status = LockChannelAndConference(hChannel, &pChannel, &pConference);
		if (status != CC_OK)
			return status;
	}

	if (pChannel->bInTable == TRUE)
		if (_RemoveChannelFromTable(pChannel) == CC_BAD_PARAM)
			// the channel object was deleted by another thread,
			// so just return CC_OK
			return CC_OK;

	if (pChannel->hConference != CC_INVALID_HANDLE)
		RemoveChannelFromConference(pChannel, pConference);

	if (pChannel->pSeparateStack != NULL)
		FreeSeparateStack(pChannel->pSeparateStack);

	if (pChannel->pTxMuxTable != NULL)
		Free(pChannel->pTxMuxTable);

	if (pChannel->pRxMuxTable != NULL)
		Free(pChannel->pRxMuxTable);

	if (pChannel->pTxH245TermCap != NULL)
		H245FreeCap(pChannel->pTxH245TermCap);

	if (pChannel->pRxH245TermCap != NULL)
		H245FreeCap(pChannel->pRxH245TermCap);

	while (DequeueRequest(&pChannel->pCloseRequests, NULL) == CC_OK);

	if (pChannel->pLocalRTPAddr != NULL)
		Free(pChannel->pLocalRTPAddr);

	if (pChannel->pLocalRTCPAddr != NULL)
		Free(pChannel->pLocalRTCPAddr);

	if (pChannel->pPeerRTPAddr != NULL)
		Free(pChannel->pPeerRTPAddr);

	if (pChannel->pPeerRTCPAddr != NULL)
		Free(pChannel->pPeerRTCPAddr);

	if (pChannel->wLocalChannelNumber != 0) {
		FreeChannelNumber(pConference, pChannel->wLocalChannelNumber);
	}

	if (pChannel->hConference != CC_INVALID_HANDLE)
		UnlockConference(pConference);

	// Since the channel object has been removed from the ChannelTable,
	// no other thread will be able to find the channel object and obtain
	// a lock, so its safe to unlock the channel object and delete it here
	RelinquishLock(&pChannel->Lock);
	DeleteLock(&pChannel->Lock);
	Free(pChannel);
	return CC_OK;
}



HRESULT LockChannel(				CC_HCHANNEL				hChannel,
									PPCHANNEL				ppChannel)
{
BOOL	bTimedOut;

	ASSERT(hChannel != CC_INVALID_HANDLE);
	ASSERT(ppChannel != NULL);

step1:
	AcquireLock(&ChannelTable.Lock);

	*ppChannel = ChannelTable.pHead;
	while ((*ppChannel != NULL) && ((*ppChannel)->hChannel != hChannel))
		*ppChannel = (*ppChannel)->pNextInTable;

	if (*ppChannel != NULL) {
		AcquireTimedLock(&(*ppChannel)->Lock,10,&bTimedOut);
		if (bTimedOut) {
			RelinquishLock(&ChannelTable.Lock);
			Sleep(0);
			goto step1;
		}
	}

	RelinquishLock(&ChannelTable.Lock);

	if (*ppChannel == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT LockChannelAndConference(	CC_HCHANNEL				hChannel,
									PPCHANNEL				ppChannel,
									PPCONFERENCE			ppConference)
{
HRESULT			status;
CC_HCONFERENCE	hConference;

	ASSERT(hChannel != CC_INVALID_HANDLE);
	ASSERT(ppChannel != NULL);
	ASSERT(ppConference != NULL);

	status = LockChannel(hChannel, ppChannel);
	if (status != CC_OK)
		return status;
	
	if ((*ppChannel)->hConference == CC_INVALID_HANDLE) {
		UnlockChannel(*ppChannel);
		return CC_BAD_PARAM;
	}

	hConference = (*ppChannel)->hConference;
	UnlockChannel(*ppChannel);

	status = LockConference(hConference, ppConference);
	if (status != CC_OK)
		return status;

	status = LockChannel(hChannel, ppChannel);
	if (status != CC_OK) {
		UnlockConference(*ppConference);
		return status;
	}
	
	return CC_OK;
}



HRESULT ValidateChannel(			CC_HCHANNEL				hChannel)
{
PCHANNEL	pChannel;

	ASSERT(hChannel != CC_INVALID_HANDLE);

	AcquireLock(&ChannelTable.Lock);

	pChannel = ChannelTable.pHead;
	while ((pChannel != NULL) && (pChannel->hChannel != hChannel))
		pChannel = pChannel->pNextInTable;

	RelinquishLock(&ChannelTable.Lock);

	if (pChannel == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT UnlockChannel(				PCHANNEL				pChannel)
{
	ASSERT(pChannel != NULL);

	RelinquishLock(&pChannel->Lock);
	return CC_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\callcont\confman.c ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/confman.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.91  $
 *	$Date:   04 Mar 1997 17:35:06  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#pragma warning ( disable : 4115 4201 4214 )
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#pragma warning ( default : 4115 4201 4214 )
#include "apierror.h"
#include "incommon.h"
#include "callcont.h"
#include "q931.h"
#include "ccmain.h"
#include "confman.h"
#include "ccutils.h"
#include "chanman.h"
#include "callman.h"


static BOOL		bConferenceInited = FALSE;

static struct {
	PCONFERENCE			pHead;
	LOCK				Lock;
} ConferenceTable;

static struct {
	CC_HCONFERENCE		hConference;
	LOCK				Lock;
} ConferenceHandle;


CC_CONFERENCEID	 InvalidConferenceID;



HRESULT InitConferenceManager()
{
	ASSERT(bConferenceInited == FALSE);

	ConferenceTable.pHead = NULL;
	InitializeLock(&ConferenceTable.Lock);

	ConferenceHandle.hConference = CC_INVALID_HANDLE + 1;
	InitializeLock(&ConferenceHandle.Lock);

	memset(&InvalidConferenceID, 0, sizeof(InvalidConferenceID));

	bConferenceInited = TRUE;
	return CC_OK;
}



HRESULT DeInitConferenceManager()
{
PCONFERENCE	pConference;
PCONFERENCE	pNextConference;

	if (bConferenceInited == FALSE)
		return CC_OK;

	pConference = ConferenceTable.pHead;
	while (pConference != NULL) {
		AcquireLock(&pConference->Lock);
		pNextConference = pConference->pNextInTable;
		FreeConference(pConference);
		pConference = pNextConference;
	}

	DeleteLock(&ConferenceHandle.Lock);
	DeleteLock(&ConferenceTable.Lock);
	bConferenceInited = FALSE;
	return CC_OK;
}



HRESULT _CreateLocalH245H2250MuxCapability(
									PCONFERENCE				pConference)
{
HRESULT				status;
CC_TERMCAP			TermCap;
struct MultipointCapability_mediaDistributionCapability         RXMediaDistributionCapability;
struct MultipointCapability_mediaDistributionCapability		TXMediaDistributionCapability;
struct MultipointCapability_mediaDistributionCapability		RXTXMediaDistributionCapability;

	ASSERT(pConference != NULL);

	if (pConference->pLocalH245H2250MuxCapability != NULL)
		H245FreeCap(pConference->pLocalH245H2250MuxCapability);

	TermCap.Dir = H245_CAPDIR_LCLRXTX;
	TermCap.DataType = H245_DATA_MUX;
	TermCap.ClientType = H245_CLIENT_MUX_H2250;
	TermCap.CapId = 0;  // CapId = 0 is a special case for mux capabilities
	TermCap.Cap.H245Mux_H2250.maximumAudioDelayJitter = 60;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.multicastCapability = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.multiUniCastConference = FALSE;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.mediaDistributionCapability = &RXMediaDistributionCapability;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.mediaDistributionCapability->next = NULL;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.mediaDistributionCapability->value.bit_mask = 0;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.mediaDistributionCapability->value.centralizedControl = FALSE;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.mediaDistributionCapability->value.distributedControl = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.mediaDistributionCapability->value.centralizedAudio = FALSE;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.mediaDistributionCapability->value.distributedAudio = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.mediaDistributionCapability->value.centralizedVideo = FALSE;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.mediaDistributionCapability->value.distributedVideo = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.mediaDistributionCapability->value.centralizedData = NULL;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.mediaDistributionCapability->value.distributedData = NULL;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.multicastCapability = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.multiUniCastConference = FALSE;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.mediaDistributionCapability = &TXMediaDistributionCapability;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.mediaDistributionCapability->next = NULL;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.mediaDistributionCapability->value.bit_mask = 0;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.mediaDistributionCapability->value.centralizedControl = FALSE;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.mediaDistributionCapability->value.distributedControl = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.mediaDistributionCapability->value.centralizedAudio = FALSE;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.mediaDistributionCapability->value.distributedAudio = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.mediaDistributionCapability->value.centralizedVideo = FALSE;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.mediaDistributionCapability->value.distributedVideo = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.mediaDistributionCapability->value.centralizedData = NULL;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.mediaDistributionCapability->value.distributedData = NULL;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.multicastCapability = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.multiUniCastConference = FALSE;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability = &RXTXMediaDistributionCapability;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability->next = NULL;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability->value.bit_mask = 0;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability->value.centralizedControl = FALSE;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability->value.distributedControl = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability->value.centralizedAudio = FALSE;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability->value.distributedAudio = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability->value.centralizedVideo = FALSE;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability->value.distributedVideo = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability->value.centralizedData = NULL;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability->value.distributedData = NULL;
	TermCap.Cap.H245Mux_H2250.mcCapability.centralizedConferenceMC = FALSE;
	TermCap.Cap.H245Mux_H2250.mcCapability.decentralizedConferenceMC = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.rtcpVideoControlCapability = FALSE;
	TermCap.Cap.H245Mux_H2250.mediaPacketizationCapability.h261aVideoPacketization = FALSE;
	
	status = H245CopyCap(&pConference->pLocalH245H2250MuxCapability,
						 &TermCap);
	return status;
}



HRESULT _AddConferenceToTable(		PCONFERENCE				pConference)
{
PCONFERENCE	pCurrent;

	ASSERT(pConference != NULL);
	ASSERT(pConference->hConference != CC_INVALID_HANDLE);
	ASSERT(pConference->bInTable == FALSE);

	AcquireLock(&ConferenceTable.Lock);

	// If a valid non-zero conference ID was specified, make sure
	// there's not a duplicate in the conference table
	if (!EqualConferenceIDs(&pConference->ConferenceID, &InvalidConferenceID)) {
		pCurrent = ConferenceTable.pHead;
		while (pCurrent != NULL) {
			if (EqualConferenceIDs(&pCurrent->ConferenceID,
				                   &pConference->ConferenceID)) {
				RelinquishLock(&ConferenceTable.Lock);
				return CC_DUPLICATE_CONFERENCE_ID;
			}
			pCurrent = pCurrent->pNextInTable;
		}
	}

	pConference->pNextInTable = ConferenceTable.pHead;
	pConference->pPrevInTable = NULL;
	if (ConferenceTable.pHead != NULL)
		ConferenceTable.pHead->pPrevInTable = pConference;
	ConferenceTable.pHead = pConference;

	pConference->bInTable = TRUE;

	RelinquishLock(&ConferenceTable.Lock);
	return CC_OK;
}



HRESULT _RemoveConferenceFromTable(	PCONFERENCE				pConference)
{
CC_HCONFERENCE	hConference;
BOOL			bTimedOut;

	ASSERT(pConference != NULL);
	ASSERT(pConference->bInTable == TRUE);

	// Caller must have a lock on the conference object;
	// in order to avoid deadlock, we must:
	//   1. unlock the conference object,
	//   2. lock the ConferenceTable,
	//   3. locate the conference object in the ConferenceTable (note that
	//      after step 2, the conference object may be deleted from the
	//      ConferenceTable by another thread),
	//   4. lock the conference object (someone else may have the lock)
	//   5. remove the conference object from the ConferenceTable,
	//   6. unlock the ConferenceTable
	//
	// The caller can now safely unlock and destroy the conference object,
	// since no other thread will be able to find the object (its been
	// removed from the ConferenceTable), and therefore no other thread will
	// be able to lock it.

	// Save the conference handle; its the only way to look up
	// the conference object in the ConferenceTable. Note that we
	// can't use pConference to find the conference object, since
	// pConference may be free'd up, and another conference object
	// allocated at the same address
	hConference = pConference->hConference;

	// step 1
	RelinquishLock(&pConference->Lock);

step2:
	// step 2
	AcquireLock(&ConferenceTable.Lock);

	// step 3
	pConference = ConferenceTable.pHead;
	while ((pConference != NULL) && (pConference->hConference != hConference))
		pConference = pConference->pNextInTable;

	if (pConference != NULL) {
		// step 4
		AcquireTimedLock(&pConference->Lock,10,&bTimedOut);
		if (bTimedOut) {
			RelinquishLock(&ConferenceTable.Lock);
			Sleep(0);
			goto step2;
		}
		// step 5
		if (pConference->pPrevInTable == NULL)
			ConferenceTable.pHead = pConference->pNextInTable;
		else
			pConference->pPrevInTable->pNextInTable = pConference->pNextInTable;

		if (pConference->pNextInTable != NULL)
			pConference->pNextInTable->pPrevInTable = pConference->pPrevInTable;

		pConference->pNextInTable = NULL;
		pConference->pPrevInTable = NULL;
		pConference->bInTable = FALSE;
	}

	// step 6
	RelinquishLock(&ConferenceTable.Lock);

	if (pConference == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT _MakeConferenceHandle(		PCC_HCONFERENCE			phConference)
{
	AcquireLock(&ConferenceHandle.Lock);
	*phConference = ConferenceHandle.hConference++;
	RelinquishLock(&ConferenceHandle.Lock);
	return CC_OK;
}



HRESULT AllocateTerminalNumber(		PCONFERENCE				pConference, 
									H245_TERMINAL_LABEL_T	*pH245TerminalLabel)
{
unsigned	i, j;
BYTE	bMask;

	ASSERT(pConference != NULL);
	ASSERT(pH245TerminalLabel != NULL);
	ASSERT(pConference->ConferenceMode == MULTIPOINT_MODE);
	ASSERT(pConference->tsMultipointController == TS_TRUE);
	
	for (i = 0; i < NUM_TERMINAL_ALLOCATION_SLOTS; i++) {
		bMask = 0x01;
		if (pConference->TerminalNumberAllocation[i] != 0xFF) {
			for (j = 0; j < 8; j++) {
				if ((pConference->TerminalNumberAllocation[i] & bMask) == 0) {
					pConference->TerminalNumberAllocation[i] |= bMask;
					pH245TerminalLabel->mcuNumber = pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber;
                                        pH245TerminalLabel->terminalNumber = (TerminalNumber)((i * 8) + j + 1);
					return CC_OK;
				}
				bMask *= 2;
			}
		}
	}
	// No more terminal numbers are available for this conference
	return CC_BAD_PARAM;
}



HRESULT FreeTerminalNumber(			PCONFERENCE				pConference,
									BYTE					bTerminalNumber)
{
unsigned	i, j;
BYTE	bMask;

	ASSERT(pConference != NULL);

	if (bTerminalNumber > NUM_TERMINAL_ALLOCATION_SLOTS * 8)
		return CC_BAD_PARAM;

	--bTerminalNumber;
	i = bTerminalNumber / 8;
	j = bTerminalNumber % 8;
	bMask = (BYTE)(0x01 << j);
	if ((pConference->TerminalNumberAllocation[i] & bMask) == 0)
		return CC_BAD_PARAM;
        pConference->TerminalNumberAllocation[i] &= ~bMask;
        return CC_OK;
}



HRESULT AllocateChannelNumber(		PCONFERENCE				pConference, 
									WORD					*pwChannelNumber)
{
unsigned    i, j;
BYTE	bMask;

	ASSERT(pConference != NULL);
	ASSERT(pwChannelNumber != NULL);

	for (i = 0; i < NUM_CHANNEL_ALLOCATION_SLOTS; i++) {
		bMask = 0x01;
		if (pConference->ChannelNumberAllocation[i] != 0xFF) {
			for (j = 0; j < 8; j++) {
				if ((pConference->ChannelNumberAllocation[i] & bMask) == 0) {
					pConference->ChannelNumberAllocation[i] |= bMask;
					*pwChannelNumber = (WORD) (((i * 8) + j) +
						               (pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber << 8));
					return CC_OK;
				}
				bMask *= 2;
			}
		}
	}
	// No more channel numbers are available for this conference
	*pwChannelNumber = 0;
	return CC_BAD_PARAM;
}



HRESULT FreeChannelNumber(			PCONFERENCE				pConference,
									WORD					wChannelNumber)
{
unsigned    i, j;
BYTE	bMask;

	ASSERT(pConference != NULL);

	wChannelNumber &= 0xFF;

	if ((wChannelNumber > NUM_CHANNEL_ALLOCATION_SLOTS * 8) ||
		(wChannelNumber == 0))
		return CC_BAD_PARAM;

	i = wChannelNumber / 8;
	j = wChannelNumber % 8;
	bMask = (BYTE)(0x01 << j);
	if ((pConference->ChannelNumberAllocation[i] & bMask) == 0)
		return CC_BAD_PARAM;
	pConference->ChannelNumberAllocation[i] &= ~bMask;
        return CC_OK;
}



HRESULT AllocAndLockConference(		PCC_HCONFERENCE			phConference,
									PCC_CONFERENCEID		pConferenceID,
									BOOL					bMultipointCapable,
									BOOL					bForceMultipointController,
									PCC_TERMCAPLIST			pLocalTermCapList,
									PCC_TERMCAPDESCRIPTORS	pLocalTermCapDescriptors,
									PCC_VENDORINFO			pVendorInfo,
									PCC_OCTETSTRING			pTerminalID,
									DWORD					dwConferenceToken,
									CC_SESSIONTABLE_CONSTRUCTOR SessionTableConstructor,
									CC_TERMCAP_CONSTRUCTOR	TermCapConstructor,
									CC_CONFERENCE_CALLBACK	ConferenceCallback,
									PPCONFERENCE			ppConference)

{
WORD				i;
HRESULT				status;
TRISTATE			tsMultipointController;
	
	ASSERT(bConferenceInited == TRUE);

	// all parameters should have been validated by the caller
	ASSERT(phConference != NULL);
	ASSERT(pLocalTermCapList != NULL);
#ifdef DBG
	if (pLocalTermCapList->wLength != 0)
		ASSERT(pLocalTermCapList->pTermCapArray != NULL);

	for (i = 0; i < pLocalTermCapList->wLength; i++)
		ASSERT(pLocalTermCapList->pTermCapArray[i] != NULL);

	if (pLocalTermCapDescriptors != NULL) {
		ASSERT(pLocalTermCapDescriptors->pTermCapDescriptorArray != NULL);
		for (i = 0; i < pLocalTermCapDescriptors->wLength; i++)
			ASSERT(pLocalTermCapDescriptors->pTermCapDescriptorArray[i] != NULL);
	}
#endif
	ASSERT(pVendorInfo != NULL);
	ASSERT(SessionTableConstructor != NULL);
	ASSERT(TermCapConstructor != NULL);
	ASSERT(ConferenceCallback != NULL);
	ASSERT(ppConference != NULL);

	// set phConference now, in case we encounter an error
	*phConference = CC_INVALID_HANDLE;

	*ppConference = (PCONFERENCE)Malloc(sizeof(CONFERENCE));
	if (*ppConference == NULL)
		return CC_NO_MEMORY;

	if (bForceMultipointController == TRUE)
		tsMultipointController = TS_TRUE;
	else if (bMultipointCapable == TRUE)
		tsMultipointController = TS_UNKNOWN;
	else
		tsMultipointController = TS_FALSE;

	(*ppConference)->bInTable = FALSE;
	(*ppConference)->LocalParticipantInfo.TerminalIDState = TERMINAL_ID_INVALID;
	(*ppConference)->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber = 1;
	(*ppConference)->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber = 255;
	(*ppConference)->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString = NULL;
	(*ppConference)->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength = 0;
 	(*ppConference)->LocalParticipantInfo.pEnqueuedRequestsForTerminalID = NULL;

	for (i = 0; i < NUM_TERMINAL_ALLOCATION_SLOTS; i++)
		(*ppConference)->TerminalNumberAllocation[i] = 0;
	// Channel 0 is reserved for the H.245 control channel
	(*ppConference)->ChannelNumberAllocation[0] = 0x01;
	for (i = 1; i < NUM_CHANNEL_ALLOCATION_SLOTS; i++)
		(*ppConference)->ChannelNumberAllocation[i] = 0;
	(*ppConference)->bMultipointCapable = bMultipointCapable;
	(*ppConference)->bForceMC = bForceMultipointController;
	(*ppConference)->SessionTableConstructor = SessionTableConstructor;
	(*ppConference)->TermCapConstructor = TermCapConstructor;
	(*ppConference)->dwConferenceToken = dwConferenceToken;
	(*ppConference)->bDeferredDelete = FALSE;
	(*ppConference)->bAutoAccept = FALSE;  // ignored unless ConferenceCallback is NULL
	(*ppConference)->LocalEndpointAttached = NEVER_ATTACHED;
	(*ppConference)->ConferenceCallback = ConferenceCallback;
	(*ppConference)->SaveConferenceCallback = ConferenceCallback;
	(*ppConference)->bSessionTableInternallyConstructed = FALSE;
	(*ppConference)->pSessionTable = NULL;
	(*ppConference)->pConferenceH245H2250MuxCapability = NULL;
	(*ppConference)->pConferenceTermCapList = NULL;
	(*ppConference)->pConferenceTermCapDescriptors = NULL;
	(*ppConference)->pLocalH245H2250MuxCapability = NULL;
	(*ppConference)->pLocalH245TermCapList = NULL;
	(*ppConference)->pLocalH245TermCapDescriptors = NULL;
	(*ppConference)->pEnqueuedCalls = NULL;
	(*ppConference)->pPlacedCalls = NULL;
	(*ppConference)->pEstablishedCalls = NULL;
	(*ppConference)->pVirtualCalls = NULL;
	(*ppConference)->pChannels = NULL;
	(*ppConference)->tsMultipointController = tsMultipointController;
	(*ppConference)->tsMaster = TS_UNKNOWN;
	(*ppConference)->pMultipointControllerAddr = NULL;
	(*ppConference)->ConferenceMode = UNCONNECTED_MODE;
	(*ppConference)->pVendorInfo = NULL;
	(*ppConference)->pEnqueuedRequestModeCalls = NULL;
	(*ppConference)->pNextInTable = NULL;
	(*ppConference)->pPrevInTable = NULL;
	
	if (pConferenceID == NULL) {
		pConferenceID = &InvalidConferenceID;
		(*ppConference)->bDynamicConferenceID = TRUE;
	} else
		(*ppConference)->bDynamicConferenceID = FALSE;

	(*ppConference)->ConferenceID = *pConferenceID;

	InitializeLock(&(*ppConference)->Lock);
	AcquireLock(&(*ppConference)->Lock);
	
	status = _MakeConferenceHandle(&(*ppConference)->hConference);
	if (status != CC_OK) {
		FreeConference(*ppConference);
		return status;
	}
	
	if (pTerminalID != NULL) {
		(*ppConference)->bDynamicTerminalID = FALSE;
		(*ppConference)->LocalParticipantInfo.TerminalIDState = TERMINAL_ID_VALID;
		(*ppConference)->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength =
			pTerminalID->wOctetStringLength;
		(*ppConference)->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString =
			(BYTE *)Malloc(pTerminalID->wOctetStringLength);
		if ((*ppConference)->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString == NULL) {
			FreeConference(*ppConference);
			return CC_NO_MEMORY;
		}
		memcpy((*ppConference)->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString,
			   pTerminalID->pOctetString,
			   pTerminalID->wOctetStringLength);
	} else {
		(*ppConference)->bDynamicTerminalID = TRUE;
	}

	status = _CreateLocalH245H2250MuxCapability(*ppConference);
	if (status != CC_OK) {
		FreeConference(*ppConference);
		return status;
	}

	// make a local copy of pTermCapList
	status = CopyH245TermCapList(&(*ppConference)->pLocalH245TermCapList,
								 pLocalTermCapList);
	if (status != CC_OK) {
		FreeConference(*ppConference);
		return CC_NO_MEMORY;
	}

	// create a new descriptor list if one was not supplied
	if (pLocalTermCapDescriptors == NULL)
		status = CreateH245DefaultTermCapDescriptors(&(*ppConference)->pLocalH245TermCapDescriptors,
									                 (*ppConference)->pLocalH245TermCapList);
	else
		// make a local copy of pTermCapDescriptors
		status = CopyH245TermCapDescriptors(&(*ppConference)->pLocalH245TermCapDescriptors,
											pLocalTermCapDescriptors);

	if (status != CC_OK) {
		FreeConference(*ppConference);
		return CC_NO_MEMORY;
	}

	status = CopyVendorInfo(&((*ppConference)->pVendorInfo), pVendorInfo);
	if (status != CC_OK) {
		FreeConference(*ppConference);
		return status;
	}

	*phConference = (*ppConference)->hConference;

	// add the conference to the conference table
	status = _AddConferenceToTable(*ppConference);
	if (status != CC_OK)
		FreeConference(*ppConference);

	// CreateConferenceTermCaps() must be called after _AddConferenceToTable(),
	// since it will re-lock the conference object
	if ((*ppConference)->tsMultipointController == TS_TRUE) {
		status = CreateConferenceTermCaps(*ppConference, NULL);
		if (status != CC_OK) {
			FreeConference(*ppConference);
			return status;
		}
	}
	
	return status;
}



HRESULT RemoveCallFromConference(	PCALL					pCall,
									PCONFERENCE				pConference)
{
	ASSERT(pCall != NULL);
	ASSERT(pConference != NULL);
	// The call object must have been removed from the call table
	// prior to removing it from the associated conference object.
	// This assures us that no other thread is waiting for a lock on it.
	ASSERT(pCall->bInTable == FALSE);

	if (pCall->pPrev == NULL) {
		// the call object is either at the head of the enqueued call list, 
		// the head of the placed call list, the head of the established
		// call list, the head of the virtual call list, or is detached
		// from the conference
		if (pConference->pEnqueuedCalls == pCall)
			// The call is on the enqueued call list
			pConference->pEnqueuedCalls = pCall->pNext;
		else if (pConference->pPlacedCalls == pCall)
			// the call is on the placed call list
			pConference->pPlacedCalls = pCall->pNext;
		else if (pConference->pEstablishedCalls == pCall)
			// the call is on the established call list
			pConference->pEstablishedCalls = pCall->pNext;
		else if (pConference->pVirtualCalls == pCall)
			pConference->pVirtualCalls = pCall->pNext;
	} else
		pCall->pPrev->pNext = pCall->pNext;

	if (pCall->pNext != NULL)
		pCall->pNext->pPrev = pCall->pPrev;

	pCall->pNext = NULL;
	pCall->pPrev = NULL;

	return CC_OK;
}



HRESULT RemoveEnqueuedCallFromConference(
									PCONFERENCE				pConference,
									PCC_HCALL				phCall)
{
	ASSERT(pConference != NULL);
	ASSERT(phCall != NULL);

	if (pConference->pEnqueuedCalls == NULL) {
		// No enqueued calls; this is not an error, since the caller can't tell
		// whether there are any enqueued calls in this conference
		*phCall = CC_INVALID_HANDLE;
		return CC_OK;
	}

	// Move the call object from the enqueued call list to the placed
	// call list.

	// Note that another thread may have a lock on the enqueued call
	// object, and may be trying to delete it; they will first need to
	// lock the conference object (which this thread has locked), remove
	// the call object from the enqueued call list, then free the call object.
	// We are therefore safe in creating a pointer to the call object, although
	// we may not examine or change any of its contents other than hCall (read-only),
	// pNext and pPrev.
	
	*phCall = pConference->pEnqueuedCalls->hCall;
	pConference->pEnqueuedCalls = pConference->pEnqueuedCalls->pNext;
	if (pConference->pEnqueuedCalls != NULL)
		pConference->pEnqueuedCalls->pPrev = NULL;
	return CC_OK;
}



HRESULT RemoveChannelFromConference(PCHANNEL				pChannel,
									PCONFERENCE				pConference)
{
	ASSERT(pChannel != NULL);
	ASSERT(pConference != NULL);

	// The channel object must have been removed from the channel table
	// prior to removing it from the associated conference object.
	// This assures us that no other thread is waiting for a lock on it.
	ASSERT(pChannel->bInTable == FALSE);

	if (pChannel->pPrev == NULL) {
		// the channel object is at the head of the channel list,
		// or has been detached from the conference
		if (pConference->pChannels == pChannel)
			pConference->pChannels = pChannel->pNext;
	} else
		pChannel->pPrev->pNext = pChannel->pNext;

	if (pChannel->pNext != NULL)
		pChannel->pNext->pPrev = pChannel->pPrev;

	pChannel->pNext = NULL;
	pChannel->pPrev = NULL;

	return CC_OK;
}



HRESULT AddEnqueuedCallToConference(PCALL					pCall,
									PCONFERENCE				pConference)
{
	ASSERT(pCall != NULL);
	ASSERT(pConference != NULL);
	ASSERT(EqualConferenceIDs(&pCall->ConferenceID, &InvalidConferenceID));
	ASSERT(EqualConferenceIDs(&pConference->ConferenceID, &InvalidConferenceID));
	ASSERT(pConference->pPlacedCalls != NULL);
	// Call cannot already be associated with the conference
	ASSERT(pCall->pNext == NULL);
	ASSERT(pCall->pPrev == NULL);

	pCall->hConference = pConference->hConference;

	pCall->pNext = pConference->pEnqueuedCalls;
	pCall->pPrev = NULL;
	if (pConference->pEnqueuedCalls != NULL) {
		ASSERT(pConference->pEnqueuedCalls->pPrev == NULL);
		pConference->pEnqueuedCalls->pPrev = pCall;
	}
	pConference->pEnqueuedCalls = pCall;
	return CC_OK;
}



HRESULT AddPlacedCallToConference(	PCALL					pCall,
									PCONFERENCE				pConference)
{
	ASSERT(pCall != NULL);
	ASSERT(pConference != NULL);

	if (EqualConferenceIDs(&pConference->ConferenceID,
			               &InvalidConferenceID)) {
		// If a conference ID has not been assigned, but there are
		// placed or enqueued calls on the conference, the conference ID
		// will be assigned by a callee when the first of these calls completes.
		// Since pCall has an assigned conference ID (which will differ from
		// the ID to be assigned to this conference), we cannot assign pCall
		// to this conference.
		ASSERT(pConference->pEstablishedCalls == NULL);
		if (pConference->pPlacedCalls != NULL)
			return CC_BAD_PARAM;
		else
			pConference->ConferenceID = pCall->ConferenceID;
	} else
		if (!EqualConferenceIDs(&pConference->ConferenceID,
			                    &pCall->ConferenceID))
			return CC_BAD_PARAM;

	pCall->hConference = pConference->hConference;

	// Unlink pCall from pConference, if necessary
	if (pCall->pPrev == NULL) {
		// pCall is at the head of either the enqueued call list,
		// the placed call list, or the established call list, or
		// is not yet associated with the conference object
		if (pConference->pEnqueuedCalls == pCall)
			pConference->pEnqueuedCalls = pCall->pNext;
		else if (pConference->pPlacedCalls == pCall)
			pConference->pPlacedCalls = pCall->pNext;
		else if (pConference->pEstablishedCalls == pCall)
			pConference->pEstablishedCalls = pCall->pNext;
	} else
		pCall->pPrev->pNext = pCall->pNext;

	if (pCall->pNext != NULL)
		pCall->pNext->pPrev = pCall->pPrev;

	// Now link pCall into the placed call list
	pCall->pNext = pConference->pPlacedCalls;
	pCall->pPrev = NULL;
	if (pConference->pPlacedCalls != NULL) {
		ASSERT(pConference->pPlacedCalls->pPrev == NULL);
		pConference->pPlacedCalls->pPrev = pCall;
	}
	pConference->pPlacedCalls = pCall;
	return CC_OK;
}



HRESULT AddEstablishedCallToConference(
									PCALL					pCall,
									PCONFERENCE				pConference)
{
	ASSERT(pCall != NULL);
	ASSERT(pConference != NULL);
	ASSERT((EqualConferenceIDs(&pConference->ConferenceID, &InvalidConferenceID)) ||
		   (EqualConferenceIDs(&pCall->ConferenceID, &pConference->ConferenceID)));

	if (EqualConferenceIDs(&pConference->ConferenceID, &InvalidConferenceID)) {
		// If a conference ID has not been assigned, but there are
		// placed or enqueued calls on the conference, the conference ID
		// will be assigned by a callee when the first of these calls completes.
		// Since pCall has an assigned conference ID (which will differ from
		// the ID to be assigned to this conference), we cannot assign pCall
		// to this conference.
		ASSERT(pConference->pEstablishedCalls == NULL);
		pConference->ConferenceID = pCall->ConferenceID;
	} else if (!EqualConferenceIDs(&pConference->ConferenceID, &pCall->ConferenceID))
		return CC_BAD_PARAM;

	pCall->hConference = pConference->hConference;

	// Unlink pCall from pConference, if necessary
	if (pCall->pPrev == NULL) {
		// pCall is at the head of either the enqueued call list,
		// the placed call list, or the established call list, or
		// is not yet associated with the conference object
		if (pConference->pEnqueuedCalls == pCall)
			pConference->pEnqueuedCalls = pCall->pNext;
		else if (pConference->pPlacedCalls == pCall)
			pConference->pPlacedCalls = pCall->pNext;
		else if (pConference->pEstablishedCalls == pCall)
			pConference->pEstablishedCalls = pCall->pNext;
	} else
		pCall->pPrev->pNext = pCall->pNext;

	if (pCall->pNext != NULL)
		pCall->pNext->pPrev = pCall->pPrev;
	
	// Now link pCall into the established call list
	pCall->pNext = pConference->pEstablishedCalls;
	pCall->pPrev = NULL;
	if (pConference->pEstablishedCalls != NULL) {
		ASSERT(pConference->pEstablishedCalls->pPrev == NULL);
		pConference->pEstablishedCalls->pPrev = pCall;
	}
	pConference->pEstablishedCalls = pCall;
	return CC_OK;
}



HRESULT AddVirtualCallToConference(	PCALL					pCall,
									PCONFERENCE				pConference)
{
	ASSERT(pCall != NULL);
	ASSERT(pConference != NULL);
	ASSERT(pConference->ConferenceMode == MULTIPOINT_MODE);
	ASSERT(pConference->tsMultipointController == TS_FALSE);
	// Call cannot already be associated with the conference
	ASSERT(pCall->pNext == NULL);
	ASSERT(pCall->pPrev == NULL);

	pCall->hConference = pConference->hConference;

	pCall->pNext = pConference->pVirtualCalls;
	pCall->pPrev = NULL;
	if (pConference->pVirtualCalls != NULL) {
		ASSERT(pConference->pVirtualCalls->pPrev == NULL);
		pConference->pVirtualCalls->pPrev = pCall;
	}
	pConference->pVirtualCalls = pCall;
	return CC_OK;
}



HRESULT AddChannelToConference(		PCHANNEL				pChannel,
									PCONFERENCE				pConference)
{
PPCHANNEL	ppChannel;

	ASSERT(pChannel != NULL);
	ASSERT((pChannel->bChannelType == TX_CHANNEL) ||
		   (pChannel->bChannelType == RX_CHANNEL) ||
		   (pChannel->bChannelType == TXRX_CHANNEL) ||
		   (pChannel->bChannelType == PROXY_CHANNEL));
	ASSERT(pConference != NULL);
	ASSERT(pChannel->hConference == pConference->hConference);
	ASSERT(pChannel->pNext == NULL);
	ASSERT(pChannel->pPrev == NULL);
	ASSERT(pConference->ConferenceMode != UNCONNECTED_MODE);

	if (pConference->pEstablishedCalls == NULL)
		// Can't open a channel unless we have at least one established call
		return CC_BAD_PARAM;

	ppChannel = &pConference->pChannels;

	pChannel->pNext = *ppChannel;
	pChannel->pPrev = NULL;
	if (*ppChannel != NULL) {
		ASSERT((*ppChannel)->pPrev == NULL);
		(*ppChannel)->pPrev = pChannel;
	}
	*ppChannel = pChannel;
	if (pConference->ConferenceMode == POINT_TO_POINT_MODE)
		pChannel->bMultipointChannel = FALSE;
	else
		pChannel->bMultipointChannel = TRUE;
	return CC_OK;
}



// Caller must have a lock on the conference object
// There must be no calls on this conference object
// (previous calls must have been cleared by calling Hangup())
HRESULT FreeConference(			PCONFERENCE				pConference)
{
CC_HCONFERENCE		hConference;
PCALL				pVirtualCall;
WORD				wNumCalls;
WORD				i;
PCC_HCALL			CallList;
WORD				wNumChannels;
PCC_HCHANNEL		ChannelList;
PCHANNEL			pChannel;

	ASSERT(pConference != NULL);
	ASSERT(pConference->pEnqueuedCalls == NULL);
	ASSERT(pConference->pPlacedCalls == NULL);
	ASSERT(pConference->pEstablishedCalls == NULL);
	
	// caller must have a lock on the conference object,
	// so there's no need to re-lock it
	
	hConference = pConference->hConference;

	if (pConference->bInTable == TRUE)
		if (_RemoveConferenceFromTable(pConference) == CC_BAD_PARAM)
			// the conference object was deleted by another thread,
			// so just return CC_OK
			return CC_OK;

	if (pConference->pLocalH245H2250MuxCapability != NULL)
		H245FreeCap(pConference->pLocalH245H2250MuxCapability);

	// free up the LocalTermCapList elements
	DestroyH245TermCapList(&pConference->pLocalH245TermCapList);

	// free up the local terminal capability descriptors
	DestroyH245TermCapDescriptors(&pConference->pLocalH245TermCapDescriptors);

	if (pConference->pMultipointControllerAddr != NULL)
		Free(pConference->pMultipointControllerAddr);

	if (pConference->pVendorInfo != NULL)
		FreeVendorInfo(pConference->pVendorInfo);

	if (pConference->pSessionTable != NULL)
		FreeConferenceSessionTable(pConference);

	if (pConference->pConferenceH245H2250MuxCapability != NULL)
		H245FreeCap(pConference->pConferenceH245H2250MuxCapability);

	if ((pConference->pConferenceTermCapList != NULL) ||
		(pConference->pConferenceTermCapDescriptors != NULL))
		FreeConferenceTermCaps(pConference);

	if (pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString != NULL)
		Free(pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString);
	
	while (DequeueRequest(&pConference->LocalParticipantInfo.pEnqueuedRequestsForTerminalID, NULL) == CC_OK);

	EnumerateCallsInConference(&wNumCalls, &CallList, pConference, VIRTUAL_CALL);
	for (i = 0; i < wNumCalls; i++)
		if (LockCall(CallList[i], &pVirtualCall) == CC_OK)
			FreeCall(pVirtualCall);
	if (CallList != NULL)
		Free(CallList);

	EnumerateChannelsInConference(&wNumChannels, &ChannelList, pConference, ALL_CHANNELS);
	for (i = 0; i < wNumChannels; i++)
		if (LockChannel(ChannelList[i], &pChannel) == CC_OK)
		FreeChannel(pChannel);
	if (ChannelList != NULL)
		Free(ChannelList);

	while (DequeueRequest(&pConference->pEnqueuedRequestModeCalls, NULL) == CC_OK);

	// since the conference object has been removed from the ConferenceTable,
	// no other thread will be able to find the conference object and obtain
	// a lock, so its safe to unlock the conference object and delete it here
	RelinquishLock(&pConference->Lock);
	DeleteLock(&pConference->Lock);
	Free(pConference);
	return CC_OK;
}



HRESULT LockConference(				CC_HCONFERENCE			hConference,
									PPCONFERENCE			ppConference)
{
BOOL	bTimedOut;

	ASSERT(hConference != CC_INVALID_HANDLE);
	ASSERT(ppConference != NULL);

step1:
	AcquireLock(&ConferenceTable.Lock);

	*ppConference = ConferenceTable.pHead;
	while ((*ppConference != NULL) && ((*ppConference)->hConference != hConference))
		*ppConference = (*ppConference)->pNextInTable;

	if (*ppConference != NULL) {
		AcquireTimedLock(&(*ppConference)->Lock,10,&bTimedOut);
		if (bTimedOut) {
			RelinquishLock(&ConferenceTable.Lock);
			Sleep(0);
			goto step1;
		}
	}

	RelinquishLock(&ConferenceTable.Lock);

	if (*ppConference == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT LockConferenceEx(			CC_HCONFERENCE			hConference,
									PPCONFERENCE			ppConference,
									TRISTATE				tsDeferredDelete)
{
BOOL	bTimedOut;

	ASSERT(hConference != CC_INVALID_HANDLE);
	ASSERT(ppConference != NULL);

step1:
	AcquireLock(&ConferenceTable.Lock);

	*ppConference = ConferenceTable.pHead;
	while ((*ppConference != NULL) && ((*ppConference)->hConference != hConference))
		*ppConference = (*ppConference)->pNextInTable;

	if (*ppConference != NULL) {
		AcquireTimedLock(&(*ppConference)->Lock,10,&bTimedOut);
		if (bTimedOut) {
			RelinquishLock(&ConferenceTable.Lock);
			Sleep(0);
			goto step1;
		}
		if (tsDeferredDelete == TS_TRUE) {
			if ((*ppConference)->bDeferredDelete != TRUE) {
				RelinquishLock(&(*ppConference)->Lock);
				*ppConference = NULL;
			}
		} else if (tsDeferredDelete == TS_FALSE) {
			if ((*ppConference)->bDeferredDelete != FALSE) {
				RelinquishLock(&(*ppConference)->Lock);
				*ppConference = NULL;
			}
		}
	}

	RelinquishLock(&ConferenceTable.Lock);

	if (*ppConference == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT ValidateConference(			CC_HCONFERENCE			hConference)
{
PCONFERENCE	pConference;

	ASSERT(hConference != CC_INVALID_HANDLE);

	AcquireLock(&ConferenceTable.Lock);

	pConference = ConferenceTable.pHead;
	while ((pConference != NULL) && (pConference->hConference != hConference))
		pConference = pConference->pNextInTable;

	RelinquishLock(&ConferenceTable.Lock);

	if (pConference == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT LockConferenceID(			PCC_CONFERENCEID		pConferenceID,
									PPCONFERENCE			ppConference)
{
BOOL	bTimedOut;

	ASSERT(!EqualConferenceIDs(pConferenceID, &InvalidConferenceID));
	ASSERT(ppConference != NULL);
	// There may be many conference objects in the table with unassigned
	// conference IDs (ConferenceID = InvalidConferenceID).  The caller may
	// never ask us to search for an unassigned conference ID.

step1:
	AcquireLock(&ConferenceTable.Lock);

	*ppConference = ConferenceTable.pHead;
	while ((*ppConference != NULL) &&
		   (!EqualConferenceIDs(&(*ppConference)->ConferenceID, pConferenceID)))
		*ppConference = (*ppConference)->pNextInTable;

	if (*ppConference != NULL) {
		AcquireTimedLock(&(*ppConference)->Lock,10,&bTimedOut);
		if (bTimedOut) {
			RelinquishLock(&ConferenceTable.Lock);
			Sleep(0);
			goto step1;
		}
	}

	RelinquishLock(&ConferenceTable.Lock);

	if (*ppConference == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT FindChannelInConference(	WORD					wChannel,
									BOOL					bLocalChannel,
									BYTE					bChannelType,
									CC_HCALL				hCall,
									PCC_HCHANNEL			phChannel,
									PCONFERENCE				pConference)
{
PCHANNEL	pChannel;
WORD		wChannelNumber;

	ASSERT(wChannel != 0);
	ASSERT(phChannel != NULL);
	ASSERT(pConference != NULL);

	*phChannel = CC_INVALID_HANDLE;

	pChannel = pConference->pChannels;
	while (pChannel != NULL) {
		if (bLocalChannel)
			wChannelNumber = pChannel->wLocalChannelNumber;
		else
			wChannelNumber = pChannel->wRemoteChannelNumber;
		if ((wChannelNumber == wChannel) &&
		    ((pChannel->bChannelType & bChannelType) != 0) &&
		    ((hCall == CC_INVALID_HANDLE) ||
		    (pChannel->hCall == hCall)))
			break;
		pChannel = pChannel->pNext;
	}
	if (pChannel == NULL)
		return CC_BAD_PARAM;
	*phChannel = pChannel->hChannel;
	return CC_OK;
}



HRESULT EnumerateConferences(		PWORD					pwNumConferences,
									CC_HCONFERENCE			ConferenceList[])
{
WORD		wIndexLimit;
PCONFERENCE	pConference;


	if ((*pwNumConferences != 0) && (ConferenceList == NULL))
		return CC_BAD_PARAM;
	if ((*pwNumConferences == 0) && (ConferenceList != NULL))
		return CC_BAD_PARAM;

	wIndexLimit = *pwNumConferences;
	*pwNumConferences = 0;

	AcquireLock(&ConferenceTable.Lock);

	pConference = ConferenceTable.pHead;
	while (pConference != NULL) {
		if (*pwNumConferences < wIndexLimit)
			ConferenceList[*pwNumConferences] = pConference->hConference;
		(*pwNumConferences)++;
		pConference = pConference->pNextInTable;
	}

	RelinquishLock(&ConferenceTable.Lock);

	return CC_OK;
}



HRESULT EnumerateCallsInConference(	WORD					*pwNumCalls,
									PCC_HCALL				pCallList[],
									PCONFERENCE				pConference,
									BYTE					bCallType)
{
WORD	i;
PCALL	pCall;

	ASSERT(pwNumCalls != NULL);
	ASSERT(pConference != NULL);

	*pwNumCalls = 0;

	if (bCallType & ENQUEUED_CALL) {
		pCall = pConference->pEnqueuedCalls;
		while (pCall != NULL) {
			(*pwNumCalls)++;
			pCall = pCall->pNext;
		}
	}

	if (bCallType & PLACED_CALL) {
		pCall = pConference->pPlacedCalls;
		while (pCall != NULL) {
			(*pwNumCalls)++;
			pCall = pCall->pNext;
		}
	}

	if (bCallType & ESTABLISHED_CALL) {
		pCall = pConference->pEstablishedCalls;
		while (pCall != NULL) {
			(*pwNumCalls)++;
			pCall = pCall->pNext;
		}
	}

	if (bCallType & VIRTUAL_CALL) {
		pCall = pConference->pVirtualCalls;
		while (pCall != NULL) {
			(*pwNumCalls)++;
			pCall = pCall->pNext;
		}
	}

	if (pCallList == NULL)
		return CC_OK;

	if (*pwNumCalls == 0) {
		*pCallList = NULL;
		return CC_OK;
	}

	*pCallList = (PCC_HCALL)Malloc(sizeof(CC_HCALL) * (*pwNumCalls));
	if (*pCallList == NULL)
		return CC_NO_MEMORY;

	i = 0;

	if (bCallType & ENQUEUED_CALL) {
		pCall = pConference->pEnqueuedCalls;
		while (pCall != NULL) {
			(*pCallList)[i] = pCall->hCall;
			i++;
			pCall = pCall->pNext;
		}
	}

	if (bCallType & PLACED_CALL) {
		pCall = pConference->pPlacedCalls;
		while (pCall != NULL) {
			(*pCallList)[i] = pCall->hCall;
			i++;
			pCall = pCall->pNext;
		}
	}

	if (bCallType & ESTABLISHED_CALL) {
		pCall = pConference->pEstablishedCalls;
		while (pCall != NULL) {
			(*pCallList)[i] = pCall->hCall;
			i++;
			pCall = pCall->pNext;
		}
	}

	if (bCallType & VIRTUAL_CALL) {
		pCall = pConference->pVirtualCalls;
		while (pCall != NULL) {
			(*pCallList)[i] = pCall->hCall;
			i++;
			pCall = pCall->pNext;
		}
	}
	return CC_OK;
}



HRESULT EnumerateChannelsInConference(
									WORD					*pwNumChannels,
									PCC_HCHANNEL			pChannelList[],
									PCONFERENCE				pConference,
									BYTE					bChannelType)
{
WORD		i;
PCHANNEL	pChannel;

	ASSERT(pwNumChannels != NULL);
	ASSERT(pConference != NULL);

	*pwNumChannels = 0;

	pChannel = pConference->pChannels;

	while (pChannel != NULL) {
		if (pChannel->bChannelType & bChannelType)
			(*pwNumChannels)++;
		pChannel = pChannel->pNext;
	}

	if (pChannelList == NULL)
		return CC_OK;

	if (*pwNumChannels == 0) {
		*pChannelList = NULL;
		return CC_OK;
	}

	*pChannelList = (PCC_HCHANNEL)Malloc(sizeof(CC_HCHANNEL) * (*pwNumChannels));
	if (*pChannelList == NULL)
		return CC_NO_MEMORY;

	i = 0;
	pChannel = pConference->pChannels;
		
	while (pChannel != NULL) {
		if (pChannel->bChannelType & bChannelType) {
			(*pChannelList)[i] = pChannel->hChannel;
			i++;
		}
		pChannel = pChannel->pNext;
	}

	return CC_OK;
}



HRESULT EnumerateTerminalLabelsInConference(
									WORD					*pwNumTerminalLabels,
									H245_TERMINAL_LABEL_T   *pH245TerminalLabelList[],
									PCONFERENCE				pConference)
{
WORD	i, j;
WORD	wIndex;
BYTE	bMask;

	ASSERT(pwNumTerminalLabels != NULL);
	ASSERT(pConference != NULL);

	// First count the number of known terminals
	*pwNumTerminalLabels = 0;
	for (i = 0; i < NUM_TERMINAL_ALLOCATION_SLOTS; i++) {
		if (pConference->TerminalNumberAllocation[i] != 0) {
			bMask = 0x01;
			for (j = 0; j < 8; j++) {
				if ((pConference->TerminalNumberAllocation[i] & bMask) != 0)
					(*pwNumTerminalLabels)++;
				bMask *= 2;
			}
		}
	}
	if (pConference->LocalEndpointAttached == ATTACHED)
		(*pwNumTerminalLabels)++;

	if (pH245TerminalLabelList == NULL)
		return CC_OK;

	if (*pwNumTerminalLabels == 0)
		*pH245TerminalLabelList = NULL;

	*pH245TerminalLabelList = (H245_TERMINAL_LABEL_T *)Malloc(sizeof(H245_TERMINAL_LABEL_T) *
												       (*pwNumTerminalLabels));
	if (*pH245TerminalLabelList == NULL)
		return CC_NO_MEMORY;

	wIndex = 0;
	for (i = 0; i < NUM_TERMINAL_ALLOCATION_SLOTS; i++) {
		if (pConference->TerminalNumberAllocation[i] != 0) {
			bMask = 0x01;
			for (j = 0; j < 8; j++) {
				if ((pConference->TerminalNumberAllocation[i] & bMask) != 0) {
					(*pH245TerminalLabelList)[wIndex].mcuNumber = pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber;
                                        (*pH245TerminalLabelList)[wIndex].terminalNumber = (TerminalNumber) ((i * 8) + j + 1);
					wIndex++;
				}	
				bMask *= 2;
			}
		}
	}
	if (pConference->LocalEndpointAttached == ATTACHED) {
		(*pH245TerminalLabelList)[wIndex].mcuNumber = pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber;
		(*pH245TerminalLabelList)[wIndex].terminalNumber = 0;
	}
	return CC_OK;
}



HRESULT UnlockConference(			PCONFERENCE				pConference)
{
	ASSERT(pConference != NULL);

	RelinquishLock(&pConference->Lock);
	return CC_OK;
}



HRESULT AsynchronousDestroyConference(
									CC_HCONFERENCE			hConference,
									BOOL					bAutoAccept)
{
HRESULT			status;
PCONFERENCE		pConference;
WORD			wNumCalls;
WORD			wNumChannels;
WORD			i;
PCHANNEL		pChannel;
PCC_HCHANNEL	ChannelList;

	status = LockConference(hConference, &pConference);
	if (status != CC_OK)
		return status;

	status = EnumerateCallsInConference(&wNumCalls, NULL, pConference, REAL_CALLS);
	if (status != CC_OK) {
		UnlockConference(pConference);
		return status;
	}

	// This is an illegal call if:
	// 1. The local endpoint is currently attached;
	// 2. The local endpoint has never been attached, but is in the
	// process of placing a call
	if ((pConference->LocalEndpointAttached == ATTACHED) ||
	    ((pConference->LocalEndpointAttached == NEVER_ATTACHED) &&
		 (wNumCalls > 0))) {
		UnlockConference(pConference);
		return CC_BAD_PARAM;
	}

	pConference->ConferenceCallback = NULL;

	// can't destroy a conference if there are active calls
	if (wNumCalls != 0) {
		pConference->bDeferredDelete = TRUE;
		pConference->bAutoAccept = bAutoAccept;
		UnlockConference(pConference);
		return CC_OK;
	}

	status = EnumerateChannelsInConference(&wNumChannels,
		                                   &ChannelList,
										   pConference,
										   ALL_CHANNELS);
	if (status != CC_OK) {
		UnlockConference(pConference);
		return status;
	}

	// free all the channels
	for (i = 0; i < wNumChannels; i++) {
		if (LockChannel(ChannelList[i], &pChannel) == CC_OK)
			// Notice that since we're going to hangup, we don't need to
			// close any channels
			FreeChannel(pChannel);
	}

	if (ChannelList != NULL)
		Free(ChannelList);

	FreeConference(pConference);
	
	return CC_OK;
}



HRESULT FindPeerParticipantInfo(	H245_TERMINAL_LABEL_T	H245TerminalLabel,
									PCONFERENCE				pConference,
									BYTE					bCallType,
									PCALL					*ppCall)
{
WORD		wNumCalls;
PCC_HCALL	CallList;
WORD		i;
HRESULT		status;

	ASSERT(pConference != NULL);
	ASSERT(ppCall != NULL);

	status = EnumerateCallsInConference(&wNumCalls,
										&CallList,
										pConference,
										bCallType);
	if (status != CC_OK)
		return status;

	for (i = 0; i < wNumCalls; i++) {
		if (LockCall(CallList[i], ppCall) == CC_OK) {
			if ((*ppCall)->pPeerParticipantInfo != NULL)
				if (((*ppCall)->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber ==
					 H245TerminalLabel.mcuNumber) &&
					((*ppCall)->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber ==
					 H245TerminalLabel.terminalNumber)) {
						Free(CallList);
						return CC_OK;
					}
			UnlockCall(*ppCall);
		}
	}
	if (CallList != NULL)
		Free(CallList);
	*ppCall = NULL;
	return CC_BAD_PARAM;
}



HRESULT ReInitializeConference(		PCONFERENCE				pConference)
{
PCALL				pCall;
WORD				wNumCalls;
WORD				i;
PCC_HCALL			CallList;
PCHANNEL			pChannel;
WORD				wNumChannels;
PCC_HCHANNEL		ChannelList;
HRESULT				status;

	ASSERT(pConference != NULL);

	if (pConference->bDynamicConferenceID == TRUE)
		pConference->ConferenceID = InvalidConferenceID;
	
	pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber = 1;
	pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber = 255;
	if (pConference->bDynamicTerminalID == TRUE) {
		pConference->LocalParticipantInfo.TerminalIDState = TERMINAL_ID_INVALID;
		Free(pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString);
		pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString = NULL;
		pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength = 0;
	}
	while (DequeueRequest(&pConference->LocalParticipantInfo.pEnqueuedRequestsForTerminalID, NULL) == CC_OK);
	for (i = 0; i < NUM_TERMINAL_ALLOCATION_SLOTS; i++)
		pConference->TerminalNumberAllocation[i] = 0;
	// Channel 0 is reserved for the H.245 control channel
	pConference->ChannelNumberAllocation[0] = 0x01;
	for (i = 1; i < NUM_CHANNEL_ALLOCATION_SLOTS; i++)
		pConference->ChannelNumberAllocation[i] = 0;
	pConference->bDeferredDelete = FALSE;
	pConference->bAutoAccept = FALSE;  // ignored unless ConferenceCallback is NULL	
	pConference->LocalEndpointAttached = NEVER_ATTACHED;
	if (pConference->pSessionTable != NULL)
		FreeConferenceSessionTable(pConference);
	_CreateLocalH245H2250MuxCapability(pConference);
	if (pConference->pConferenceH245H2250MuxCapability != NULL) {
		H245FreeCap(pConference->pConferenceH245H2250MuxCapability);
		pConference->pConferenceH245H2250MuxCapability = NULL;
	}
	if ((pConference->pConferenceTermCapList != NULL) ||
		(pConference->pConferenceTermCapDescriptors != NULL))
		FreeConferenceTermCaps(pConference);
	pConference->bSessionTableInternallyConstructed = FALSE;
	pConference->ConferenceCallback = pConference->SaveConferenceCallback;

	EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ALL_CALLS);
	for (i = 0; i < wNumCalls; i++)
		if (LockCall(CallList[i], &pCall) == CC_OK)
			FreeCall(pCall);
	if (CallList != NULL)
		Free(CallList);

	EnumerateChannelsInConference(&wNumChannels, &ChannelList, pConference, ALL_CHANNELS);
	for (i = 0; i < wNumChannels; i++)
		if (LockChannel(ChannelList[i], &pChannel) == CC_OK)
			FreeChannel(pChannel);
	if (ChannelList != NULL)
		Free(ChannelList);

	if (pConference->bForceMC == TRUE)
		pConference->tsMultipointController = TS_TRUE;
	else if (pConference->bMultipointCapable == TRUE)
		pConference->tsMultipointController = TS_UNKNOWN;
	else
		pConference->tsMultipointController = TS_FALSE;
	pConference->tsMaster = TS_UNKNOWN;
	pConference->ConferenceMode = UNCONNECTED_MODE;
	if (pConference->pMultipointControllerAddr != NULL) {
		Free(pConference->pMultipointControllerAddr);
		pConference->pMultipointControllerAddr = NULL;
	}

	while (DequeueRequest(&pConference->pEnqueuedRequestModeCalls, NULL) == CC_OK);

	if (pConference->tsMultipointController == TS_TRUE)
		status = CreateConferenceTermCaps(pConference, NULL);
	else
		status = CC_OK;

	return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\callcont\gkiman.c ===
/****************************************************************************
 *
 * $Archive:   S:\sturgeon\src\callcont\vcs\gkiman.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 * Copyright (c) 1996 Intel Corporation.
 *
 * $Revision:   1.77.1.6  $
 * $Date:   21 Aug 1997 16:56:32  $
 * $Author:   Helgebal  $
 *
 * Deliverable:
 *
 * Abstract:
 *
 * Notes:
 *
 *  Much effort has gone into working around the following constraints of
 *  the GKI interface:
 *  1) Only one admission request can be pending at a time. This is because
 *     the hCall is unknown until it completes.
 *  2) Only one bandwidth request per call can be pending at a time.
 *  3) Any pending bandwidth request must complete before issuing a
 *     disengage request.
 *  4) Any calls must be disengaged before issuing a deregistration request.
 *
 ***************************************************************************/
#ifdef GATEKEEPER

#pragma warning ( disable : 4115 4201 4214 4514)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "incommon.h"
#include "ccerror.h"
#include "isrg.h"
#include "gkiexp.h"
#include "callman2.h"
#ifdef FORCE_SERIALIZE_CALL_CONTROL
#include "cclock.h"
#endif // FORCE_SERIALIZE_CALL_CONTROL
#pragma warning ( default : 4115 4201 4214)

#if defined(DBG)

void GKDbgPrint(DWORD dwLevel,

#ifdef UNICODE_TRACE
				LPTSTR pszFormat,
#else
				LPSTR pszFormat,
#endif               
                ...);

#define GKDBG(_x_)  GKDbgPrint _x_

#else

#define GKDBG(_x_)

#endif

extern HINSTANCE        ghCallControlInstance;

#define Malloc(size) GlobalAlloc(GMEM_FIXED, size)
#define ReAlloc(p, size) GlobalReAlloc(p, GMEM_FIXED, size)
#define Free(p) GlobalFree(p)

#ifdef FORCE_SERIALIZE_CALL_CONTROL
#define EnterCallControlTop()      {CCLOCK_AcquireLock();}

#define LeaveCallControlTop(f)     {HRESULT stat; \
	                                stat = f; \
									CCLOCK_RelinquishLock(); \
                                    return stat;}
#else
#define EnterCallControlTop()      
#define LeaveCallControlTop(f)     {HRESULT stat; \
	                                stat = f; \
                                    return stat;}
#endif

#define DEFAULT_LISTEN_HANDLE   0xFFFFFFFF

#define GKIMAN_BASE             WM_USER

#define MIN_BANDWIDTH           1
#define MAX_BANDWIDTH           (0xFFFFFFFF / 100)

#define GKI_ADMITTING_HANDLE    ((HANDLE)-1)
#define GKI_BYPASS_HANDLE       ((HANDLE)-2)

// GKI Manager state
#define STATE_START                0
#define STATE_CLASS_REGISTERED     1
#define STATE_WINDOW_CREATED       2
#define STATE_REGISTERING          3
#define STATE_REGISTERING_REREG    4
#define STATE_REGISTERING_UNREG    5
#define STATE_REGISTERED           6
#define STATE_ADMITTING            7
#define STATE_ADMITTING_REREG      8
#define STATE_ADMITTING_UNREG      9
#define STATE_DISENGAGING         10
#define STATE_DISENGAGING_REREG   11
#define STATE_UNREGISTERING       12
#define STATE_UNREGISTERING_REREG 13
#define STATE_REG_BYPASS          14



typedef HRESULT (*PGKI_RegistrationRequest)(long             lVersion,
                                    SeqTransportAddr     *pCallSignalAddr, 
                                    EndpointType         *pTerminalType,
                                    SeqAliasAddr         *pAliasAddr, 
                                    HWND                 hWnd,
                                    WORD                 wBaseMessage,
                                    unsigned short       usRegistrationTransport /* = ipAddress_chosen */);

typedef HRESULT (*PGKI_UnregistrationRequest)(void);

typedef HRESULT (*PGKI_LocationRequest)(SeqAliasAddr         *pLocationInfo);

typedef HRESULT (*PGKI_AdmissionRequest)(unsigned short      usCallTypeChoice,
                                    SeqAliasAddr         *pDestinationInfo,
                                    TransportAddress     *pDestCallSignalAddress,
                                    SeqAliasAddr         *pDextExtraCallInfo,
                                    BandWidth            bandWidth,
                                    ConferenceIdentifier *pConferenceID,
                                    BOOL                 activeMC,
                                    BOOL                 answerCall,
                                    unsigned short       usCallTransport /* = ipAddress_chosen */);

typedef HRESULT (*PGKI_BandwidthRequest)(HANDLE              hModCall, 
                                    unsigned short       usCallTypeChoice,
                                    BandWidth            bandWidth);

typedef HRESULT (*PGKI_DisengageRequest)(HANDLE hCall);

typedef HRESULT (*PGKI_CleanupRequest)(void);

HRESULT Q931CopyAliasNames(PCC_ALIASNAMES *ppTarget, PCC_ALIASNAMES pSource);
HRESULT Q931FreeAliasNames(PCC_ALIASNAMES pSource);
#define CopyAliasNames Q931CopyAliasNames
#define FreeAliasNames Q931FreeAliasNames



typedef struct _LISTEN
{
  struct _LISTEN *  pNext;
  PCC_ALIASNAMES    pAliasNames;
  DWORD             hListen;
  DWORD             dwAddr;
  WORD              wPort;
} LISTEN, *PLISTEN;

//
// GKI Manager Global Data
//
CRITICAL_SECTION  GkiLock;
const char      szClassName[]         = "GkiManWndClass";
HWND            hwndGki               = 0;
ATOM            atomGki               = 0;
unsigned int    uGkiState             = STATE_START;
PLISTEN         pListenList           = NULL;
unsigned int    uGkiCalls             = 0;
unsigned int    uPendingDisengages    = 0;

HINSTANCE				   hGkiDll					  = 0;
PGKI_RegistrationRequest   pGKI_RegistrationRequest   = NULL;
PGKI_UnregistrationRequest pGKI_UnregistrationRequest = NULL;
PGKI_LocationRequest       pGKI_LocationRequest       = NULL;
PGKI_AdmissionRequest      pGKI_AdmissionRequest      = NULL;
PGKI_BandwidthRequest      pGKI_BandwidthRequest      = NULL;
PGKI_DisengageRequest      pGKI_DisengageRequest      = NULL;
PGKI_CleanupRequest		   pGKI_CleanupRequest        = NULL;


HRESULT ValidateCall(DWORD hCall);
HRESULT	LastGkiError = CC_GKI_STATE;

//
// Forward declarations
//
LONG APIENTRY GkiWndProc(HWND hWnd, UINT message, UINT wParam, LONG lParam);



//
// Helper subroutines
//

#ifdef    DBG

typedef struct _GKIMAP
{
  HRESULT       hResult;
  char *        pString;
} GKIMAP;

GKIMAP GkiErrorNames[] =
{
  GKI_OK,               "GKI_OK",
  GKI_EXIT_THREAD,      "GKI_EXIT_THREAD",
  GKI_REDISCOVER,       "GKI_REDISCOVER",
  GKI_DELETE_CALL,      "GKI_DELETE_CALL",
  GKI_GCF_RCV,          "GKI_GCF_RCV",
  GKI_NO_MEMORY,        "GKI_NO_MEMORY",
  GKI_NO_THREAD,        "GKI_NO_THREAD",
  GKI_HANDLE_ERROR,     "GKI_HANDLE_ERROR",
  GKI_ALREADY_REG,      "GKI_ALREADY_REG",
  GKI_VERSION_ERROR,    "GKI_VERSION_ERROR",
  GKI_ENCODER_ERROR,    "GKI_ENCODER_ERROR",
  GKI_NOT_REG,          "GKI_NOT_REG",
  GKI_BUSY,             "GKI_BUSY",
  GKI_NO_TA_ERROR,      "GKI_NO_TA_ERROR",
  GKI_NO_RESPONSE,      "GKI_NO_RESPONSE",
  GKI_DECODER_ERROR,    "GKI_DECODER_ERROR",
};

char *StateNames[] =
{
  "STATE_START",
  "STATE_CLASS_REGISTERED",
  "STATE_WINDOW_CREATED",
  "STATE_REGISTERING",
  "STATE_REGISTERING_REREG",
  "STATE_REGISTERING_UNREG",
  "STATE_REGISTERED",
  "STATE_ADMITTING",
  "STATE_ADMITTING_REREG",
  "STATE_ADMITTING_UNREG",
  "STATE_DISENGAGING",
  "STATE_DISENGAGING_REREG",
  "STATE_UNREGISTERING",
  "STATE_UNREGISTERING_REREG",
  "STATE_REG_BYPASS",
};

char *CallStateNames[] =
{
  "GCS_START",
  "GCS_WAITING",
  "GCS_ADMITTING",
  "GCS_ADMITTING_CLOSE_PENDING",
  "GCS_ADMITTED",
  "GCS_CHANGING",
  "GCS_CHANGING_CLOSE_PENDING",
  "GCS_DISENGAGING",
};

char szBuffer[128];

char * GkiErrorName(char *szFormat, HRESULT hResult)
{
  register int  nIndex = sizeof(GkiErrorNames) / sizeof(GkiErrorNames[0]);
  char          szTemp[32];

  while (nIndex > 0)
  {
    if (GkiErrorNames[--nIndex].hResult == hResult)
    {
      wsprintf(szBuffer, szFormat, GkiErrorNames[nIndex].pString);
      return szBuffer;
    }
  }

  wsprintf(szTemp, "Unknown(0x%x)", hResult);
  wsprintf(szBuffer, szFormat, szTemp);
  return szBuffer;
} // GkiErrorName()

char * StateName(char *szFormat, unsigned uState)
{
  char szTemp[32];
  if (uState < (sizeof(StateNames)/sizeof(StateNames[0])))
  {
    wsprintf(szBuffer, szFormat, StateNames[uState]);
  }
  else
  {
    wsprintf(szTemp, "Unknown(%d)", uState);
    wsprintf(szBuffer, szFormat, szTemp);
  }
  return szBuffer;
} // StateName()

char * CallStateName(char *szFormat, unsigned uCallState)
{
  char szTemp[32];
  if (uCallState <= (sizeof(CallStateNames)/sizeof(CallStateNames[0])))
  {
    wsprintf(szBuffer, szFormat, CallStateNames[uCallState]);
  }
  else
  {
    wsprintf(szTemp, "Unknown(%d)", uCallState);
    wsprintf(szBuffer, szFormat, szTemp);
  }
  return szBuffer;
} // CallStateName()

#else

#define GkiErrorName(x,y)   ""
#define StateName(x,y)      ""
#define CallStateName(x,y)  ""

#endif // DBG



HRESULT MapRegistrationRejectReason(register UINT uReason)
{
  register HRESULT lReason;

  // TBD - Map reason code into CC_xxx HRESULT
  switch (uReason)
  {
  case discoveryRequired_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case RgstrtnRjctRsn_invldRvsn_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case invalidCallSignalAddress_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case invalidRASAddress_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case duplicateAlias_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case invalidTerminalType_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case RgstrtnRjctRsn_undfndRsn_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case transportNotSupported_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  default:
    lReason = CC_GATEKEEPER_REFUSED;
  } // switch

  return lReason;
} // MapRegistrationRejectReason()



HRESULT MapAdmissionRejectReason(register UINT uReason)
{
  register HRESULT lReason;

  // TBD - Map reason code into CC_xxx HRESULT
  switch (uReason)
  {
  case calledPartyNotRegistered_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case ARRn_invldPrmssn_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case AdmssnRjctRsn_rqstDnd_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case AdmssnRjctRsn_undfndRsn_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case callerNotRegistered_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case routeCallToGatekeeper_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case invldEndpntIdntfr_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case AdmssnRjctRsn_rsrcUnvlbl_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  default:
    lReason = CC_GATEKEEPER_REFUSED;
  } // switch

  return lReason;
} // MapAdmissionRejectReason()



HRESULT MapBandwidthRejectReason(register UINT uReason)
{
  register HRESULT lReason;

  // TBD - Map reason code into CC_xxx HRESULT
  switch (uReason)
  {
  case notBound_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case invalidConferenceID_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case BndRjctRsn_invldPrmssn_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case insufficientResources_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case BndRjctRsn_invldRvsn_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case BndRjctRsn_undfndRsn_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  default:
    lReason = CC_GATEKEEPER_REFUSED;
  } // switch

  return lReason;
} // MapBandwidthRejectReason()



/*
 *  NOTES
 *    GkiLock must be locked before calling this routine!
 */

static PLISTEN ListenEnqueue(register PLISTEN pListen)
{
  if (pListenList && pListenList->hListen == DEFAULT_LISTEN_HANDLE)
  {
    PLISTEN pDefaultListen = pListenList;
    pListenList = pListenList->pNext;
    Free(pDefaultListen);
  }
  pListen->pNext = pListenList;
  return pListenList = pListen;
} // ListenEnqueue()



/*
 *  NOTES
 *    GkiLock must be locked before calling this routine!
 */

static PLISTEN ListenDequeue(register DWORD hListen)
{
  register PLISTEN      pListen = pListenList;
  register PLISTEN      pListenPrev;

  if (pListen)
  {
    if (pListen->hListen == hListen)
    {
      pListenList = pListen->pNext;
    }
    else
    {
      do
      {
        pListenPrev = pListen;
        pListen = pListen->pNext;
      } while (pListen && pListen->hListen != hListen);
      if (pListen)
      {
        pListenPrev->pNext = pListen->pNext;
      }
    }
  }

  return pListen;
} // ListenDequeue()



/*
 *  NOTES
 *    Since the pGkiCall is locked, we don't need a critical section
 *    around the queue manipulation code.
 */

static PBWREQ BwReqEnqueue(register PGKICALL pGkiCall, register PBWREQ pBwReq)
{
  pBwReq->pNext = NULL;
  if (pGkiCall->pBwReqHead)
  {
    pGkiCall->pBwReqTail->pNext = pBwReq;
  }
  else
  {
    pGkiCall->pBwReqHead = pBwReq;
  }
  return pGkiCall->pBwReqTail = pBwReq;
} // BwReqEnqueue()



/*
 *  NOTES
 *    Since the pGkiCall is locked, we don't need a critical section
 *    around the queue manipulation code.
 */

static PBWREQ BwReqDequeue(register PGKICALL pGkiCall)
{
  register PBWREQ pBwReq = pGkiCall->pBwReqHead;
  if (pBwReq)
  {
    pGkiCall->pBwReqHead = pBwReq->pNext;
  }
  return pBwReq;
} // BwReqDequeue()



DWORD GetIpAddress(void)
{
  DWORD dwAddr;
  char szHostName[128];
  if (gethostname(szHostName, sizeof(szHostName)) == 0)
  {
    struct hostent *pHostent;
    pHostent = gethostbyname(szHostName);
    if (pHostent != NULL)
    {
      ASSERT(pHostent->h_addrtype == AF_INET);
      dwAddr = *((DWORD *)pHostent->h_addr_list[0]);
      return ntohl(dwAddr);
    }
  }

  return INADDR_ANY;
} // GetIpAddress()



// Caveat: *pAlias should be initialized to all 0 before calling!

static HRESULT CopyAliasItem(SeqAliasAddr *pAlias, PCC_ALIASITEM pAliasItem)
{
  unsigned int uDigit;
  unsigned int uPrefixLength;
  unsigned int uDataLength;

  if (pAliasItem->pData == NULL || pAliasItem->wDataLength == 0)
    return CC_BAD_PARAM;

  if (pAliasItem->pPrefix)
  {
    // Strip off terminating NULs if included in prefix length
    uPrefixLength = pAliasItem->wPrefixLength;
    while (uPrefixLength && pAliasItem->pPrefix[uPrefixLength - 1] == 0)
      --uPrefixLength;
  }
  else
  {
    uPrefixLength = 0;
  }

  uDataLength = pAliasItem->wDataLength;

  switch (pAliasItem->wType)
  {
  case CC_ALIAS_H323_ID:
    pAlias->value.choice = h323_ID_chosen;
    pAlias->value.u.h323_ID.value = Malloc((uPrefixLength + uDataLength) * sizeof(pAliasItem->pData[0]));
    if (pAlias->value.u.h323_ID.value == NULL)
    {
      GKDBG((1, "CopyAliasItem: Could not allocate %d bytes memory",
               (uPrefixLength + uDataLength) * sizeof(pAliasItem->pData[0])));
      return CC_NO_MEMORY;
    }
    if (uPrefixLength)
    {
      memcpy(&pAlias->value.u.h323_ID.value[0],
             pAliasItem->pPrefix,
             uPrefixLength * sizeof(pAliasItem->pPrefix[0]));
      memcpy(&pAlias->value.u.h323_ID.value[uPrefixLength],
             pAliasItem->pData,
             uDataLength * sizeof(pAliasItem->pData[0]));
    }
    else
    {
      memcpy(&pAlias->value.u.h323_ID.value[0],
             pAliasItem->pData,
             uDataLength * sizeof(pAliasItem->pData[0]));
    }
    pAlias->value.u.h323_ID.length = (unsigned short)(uPrefixLength + uDataLength);
    break;

  case CC_ALIAS_H323_PHONE:
    pAlias->value.choice = e164_chosen;
    if (uPrefixLength)
    {
      for (uDigit = 0; uDigit < uPrefixLength; ++uDigit)
      {
        pAlias->value.u.e164[uDigit] = (char)pAliasItem->pPrefix[uDigit];
      }
      for (uDigit = 0; uDigit < uDataLength; ++uDigit)
      {
        pAlias->value.u.e164[uDigit + uPrefixLength] = (char)pAliasItem->pData[uDigit];
      }
    }
    else
    {
      for (uDigit = 0; uDigit < uDataLength; ++uDigit)
      {
        pAlias->value.u.e164[uDigit] = (char)pAliasItem->pData[uDigit];
      }
    }
    break;

  default:
    GKDBG((1, "CopyAliasItem: Bad alias name type %d", pAliasItem->wType));
    return CC_BAD_PARAM;
  } // switch

  return NOERROR;
} // CopyAliasItem()



/*
 *  NOTES
 *    Must have Call locked before calling!
 */

static void GkiAllocCall(PGKICALL pGkiCall, HANDLE hGkiCall)
{
  ASSERT(pGkiCall != NULL);
  ASSERT(hGkiCall != 0);
  ASSERT(hGkiCall != GKI_ADMITTING_HANDLE);
  pGkiCall->hGkiCall = hGkiCall;
  pGkiCall->uGkiCallState = GCS_ADMITTED;
  ++uGkiCalls;
  GKDBG((1, "GkiAllocCall: uGkiCalls = %d", uGkiCalls));
} // GkiAllocCall()



/*
 *  NOTES
 *    Must have Call locked before calling!
 */

static HRESULT GkiCancelCall(PGKICALL pGkiCall, void *pConference)
{
  DWORD                 hCall;

  ASSERT(pGkiCall != NULL);
  pConference = pConference;            // Disable compiler warning
  hCall = pGkiCall->hCall;

  GKDBG((1, CallStateName("GkiCancelCall <- Call State = %s", pGkiCall->uGkiCallState), 0));

  switch (pGkiCall->uGkiCallState)
  {
  case GCS_START:
    break;

  case GCS_WAITING:
    ASSERT(pGkiCall->hGkiCall == 0);
    if (pGkiCall->bAnswerCall)
      AcceptCallReject(pGkiCall->pCall, pConference, CC_GATEKEEPER_REFUSED);
    else
      PlaceCallReject (pGkiCall->pCall, pConference, CC_GATEKEEPER_REFUSED);
    break;

  case GCS_ADMITTING:
  case GCS_ADMITTING_CLOSE_PENDING:
    ASSERT(pGkiCall->hGkiCall == GKI_ADMITTING_HANDLE);
    if (pGkiCall->bAnswerCall)
      AcceptCallReject(pGkiCall->pCall, pConference, CC_GATEKEEPER_REFUSED);
    else
      PlaceCallReject (pGkiCall->pCall, pConference, CC_GATEKEEPER_REFUSED);
    break;

  case GCS_ADMITTED:
  case GCS_CHANGING:
  case GCS_CHANGING_CLOSE_PENDING:
  case GCS_DISENGAGING:
    ASSERT(pGkiCall->hGkiCall != 0);
    ASSERT(pGkiCall->hGkiCall != GKI_ADMITTING_HANDLE);
    Disengage(pGkiCall->pCall);
    return NOERROR;

  default:
    GKDBG((1, "GkiCancelCall: Invalid call state %d", pGkiCall->uGkiCallState));
  } // switch

  if (ValidateCall(hCall) == NOERROR && pGkiCall->uGkiCallState != GCS_START)
  {
    GkiFreeCall(pGkiCall);
  }

  GKDBG((1, CallStateName("GkiCancelCall -> Call State = %s", pGkiCall->uGkiCallState), 0));
  return NOERROR;
} // GkiCancelCall()



/*
 *  NOTES
 *    Must have Call locked before calling!
 */

static HRESULT GkiCancelAdmitting(PGKICALL pGkiCall, void *pConference)
{
  ASSERT(pGkiCall != NULL);
  pConference = pConference;            // Disable compiler warning

  GKDBG((1, CallStateName("GkiCancelAdmitting <- Call State = %s", pGkiCall->uGkiCallState), 0));

  switch (pGkiCall->uGkiCallState)
  {
  case GCS_ADMITTING:
    ASSERT(pGkiCall->hGkiCall == GKI_ADMITTING_HANDLE);
    pGkiCall->hGkiCall = 0;
    pGkiCall->uGkiCallState = GCS_WAITING;
    break;

  case GCS_ADMITTING_CLOSE_PENDING:
    ASSERT(pGkiCall->hGkiCall == GKI_ADMITTING_HANDLE);
    GkiFreeCall(pGkiCall);
    break;

  } // switch

  GKDBG((1, CallStateName("GkiCancelAdmitting -> Call State = %s", pGkiCall->uGkiCallState), 0));
  return NOERROR;
} // GkiCancelAdmitting()



/*
 *  NOTES
 *    Must have Call locked before calling!
 */

static HRESULT CheckPendingBandwidth(PGKICALL pGkiCall);

static HRESULT GatekeeperNotFound(PGKICALL pGkiCall, void *pConference)
{
  ASSERT(pGkiCall != NULL);
  ASSERT(pConference != NULL);

  GKDBG((1, CallStateName("GatekeeperNotFound <- Call State = %s", pGkiCall->uGkiCallState), 0));

  switch (pGkiCall->uGkiCallState)
  {
  case GCS_START:
  case GCS_ADMITTED:
    break;

  case GCS_WAITING:
  case GCS_ADMITTING:
    GkiOpenCall(pGkiCall, pConference);
    break;

  case GCS_ADMITTING_CLOSE_PENDING:
  case GCS_CHANGING_CLOSE_PENDING:
  case GCS_DISENGAGING:
    GkiCloseCall(pGkiCall);
    break;

  case GCS_CHANGING:
    pGkiCall->uGkiCallState = GCS_ADMITTED;
    pGkiCall->uBandwidthAllocated = MAX_BANDWIDTH;
    CheckPendingBandwidth(pGkiCall);
    break;

  default:
    GKDBG((1, "GatekeeperNotFound: Invalid call state %d", pGkiCall->uGkiCallState));
  } // switch

  GKDBG((1, CallStateName("GatekeeperNotFound -> Call State = %s", pGkiCall->uGkiCallState), 0));
  return NOERROR;
} // GatekeeperNotFound()



/*
 *  NOTES
 *    GkiLock must be locked before calling this routine!
 */

static HRESULT GkiRegister(void)
{
  register HRESULT      status = NOERROR;

  ASSERT(pListenList != NULL);

  switch (uGkiState)
  {
  case STATE_START:
    // Register window class
    {
      WNDCLASS wndclass = { 0, GkiWndProc, 0, 0, 0, 0, 0, 0, NULL, szClassName };
      atomGki = RegisterClass(&wndclass);
      if (atomGki == 0)
      {
        status = HRESULT_FROM_WIN32(GetLastError());
        GKDBG((1, "GkiRegister: Error 0x%x registering class", status));
        break;
      }
    }
    uGkiState = STATE_CLASS_REGISTERED;

  // Fall-through to next case

  case STATE_CLASS_REGISTERED:
    // Create window to receive GKI messages
    hwndGki = CreateWindow(szClassName, "", WS_OVERLAPPED, 0, 0, 0, 0, 0, 0, 0, NULL);
    if (hwndGki == 0)
    {
      status = HRESULT_FROM_WIN32(GetLastError());
      GKDBG((1, "GkiRegister: Error 0x%x creating window", status));
      break;
    }
    uGkiState = STATE_WINDOW_CREATED;

    // Fall-through to next case

  case STATE_WINDOW_CREATED:
    {
      PLISTEN           pListen;
      unsigned          uListens    = 0;
      unsigned          uAliasNames = 0;
      SeqTransportAddr *pTransportAddrs;
      SeqAliasAddr     *pAliasAddrs;
      PCC_ALIASITEM     pAliasItem;
      unsigned          uIndex;
      unsigned          uDigit;
      EndpointType      TerminalType = {0};

      // Count Transport Addresses and Alias Names
      pListen = pListenList;
      while (pListen)
      {
        // Count the Transport Address
        ++uListens;

        if (pListen->pAliasNames)
        {
          // Count the Alias Names
          uAliasNames += pListen->pAliasNames->wCount;
        }
        pListen = pListen->pNext;
      }

      pTransportAddrs = Malloc(uListens * sizeof(*pTransportAddrs));
      if (pTransportAddrs == NULL)
      {
        GKDBG((1, "GkiRegister: Could not allocate %d Transport Addresses", uListens));
        return CC_NO_MEMORY;
      }

      if (uAliasNames)
      {
        pAliasAddrs = Malloc(uAliasNames * sizeof(*pAliasAddrs));
        if (pAliasAddrs == NULL)
        {
          Free(pTransportAddrs);
          GKDBG((1, "GkiRegister: Could not allocate %d Alias Addresses", uAliasNames));
          return CC_NO_MEMORY;
        }
      }
      else
      {
        pAliasAddrs = NULL;
      }

      pListen     = pListenList;
      uListens    = 0;
      uAliasNames = 0;
      while (pListen)
      {
        // Initialize a transport address
        // TBD - throw out duplicates
        pTransportAddrs[uListens].next = &pTransportAddrs[uListens + 1];
        pTransportAddrs[uListens].value.choice = ipAddress_chosen;
        pTransportAddrs[uListens].value.u.ipAddress.ip.length = 4;
        *((DWORD *)pTransportAddrs[uListens].value.u.ipAddress.ip.value) = pListen->dwAddr;
        pTransportAddrs[uListens].value.u.ipAddress.port = pListen->wPort;

        // Add any alias names to list
        // TBD - throw out duplicates
        if (pListen->pAliasNames)
        {
          pAliasItem = pListen->pAliasNames->pItems;
          for (uIndex = 0; uIndex < pListen->pAliasNames->wCount; ++uIndex, ++pAliasItem)
          {
            pAliasAddrs[uAliasNames].next = &pAliasAddrs[uAliasNames + 1];
            switch (pAliasItem->wType)
            {
            case CC_ALIAS_H323_ID:
              pAliasAddrs[uAliasNames].value.choice = h323_ID_chosen;
              pAliasAddrs[uAliasNames].value.u.h323_ID.length = pAliasItem->wDataLength;
              pAliasAddrs[uAliasNames].value.u.h323_ID.value  = pAliasItem->pData;
              break;

            case CC_ALIAS_H323_PHONE:
              pAliasAddrs[uAliasNames].value.choice = e164_chosen;
              memset(pAliasAddrs[uAliasNames].value.u.e164, 0, sizeof(pAliasAddrs[uAliasNames].value.u.e164));
              for (uDigit = 0; uDigit < pAliasItem->wDataLength; ++uDigit)
              {
                pAliasAddrs[uAliasNames].value.u.e164[uDigit] = (char)pAliasItem->pData[uDigit];
              }
              break;

            default:
              Free(pAliasAddrs);
              Free(pTransportAddrs);
              GKDBG((1, "GkiRegister: Bad alias name type %d",
                      pAliasItem->wType));
              return CC_BAD_PARAM;
            } // switch
            ++uAliasNames;
          } // for
        } // if
        ++uListens;
        pListen = pListen->pNext;
      } // while
      pTransportAddrs[uListens - 1].next = NULL;
      if (pAliasAddrs)
      {
        pAliasAddrs[uAliasNames - 1].next = NULL;
      }

      // Initialize TerminalType
      TerminalType.bit_mask = terminal_present;
      TerminalType.mc       = TRUE;

      uGkiState = STATE_REGISTERING;
      GKDBG((1, "GKI_RegistrationRequest called...", 0));
      status =
        pGKI_RegistrationRequest(GKI_VERSION,       // lVersion
                                 pTransportAddrs,   // pCallSignalAddr
                                 &TerminalType,     // pTerminalType
                                 pAliasAddrs,       // pRgstrtnRgst_trmnlAls
                                 hwndGki,           // hWnd
                                 GKIMAN_BASE,       // wBaseMessage
                                 ipAddress_chosen); // usRegistrationTransport
      if (status == NOERROR)
      {
        GKDBG((1, GkiErrorName("GKI_RegistrationRequest returned %s", status), 0));
      }
      else
      {
        GKDBG((1, GkiErrorName("GKI_RegistrationRequest returned %s", status), 0));
        uGkiState = STATE_WINDOW_CREATED;
      }
      if (pAliasAddrs)
        Free(pAliasAddrs);
      if (pTransportAddrs)
        Free(pTransportAddrs);
    }
    break;

  case STATE_REGISTERING:
  case STATE_REGISTERING_REREG:
  case STATE_REGISTERING_UNREG:
    uGkiState = STATE_REGISTERING_REREG;
    break;

  case STATE_REGISTERED:
    uGkiState = STATE_UNREGISTERING_REREG;
    GKDBG((1, "GKI_UnregistrationRequest called...", 0));
    status = pGKI_UnregistrationRequest();
    if (status == NOERROR)
    {
      GKDBG((1, GkiErrorName("GKI_UnregistrationRequest returned %s", status), 0));
    }
    else
    {
      GKDBG((1, GkiErrorName("GKI_UnregistrationRequest returned %s", status), 0));
      uGkiState = STATE_REG_BYPASS;
      ApplyToAllCalls(GatekeeperNotFound);
    }
    break;

  case STATE_ADMITTING:
  case STATE_ADMITTING_REREG:
  case STATE_ADMITTING_UNREG:
    uGkiState = STATE_ADMITTING_REREG;
    break;

  case STATE_DISENGAGING:
    uGkiState = STATE_DISENGAGING_REREG;
    break;

  case STATE_DISENGAGING_REREG:
    break;

  case STATE_UNREGISTERING:
    uGkiState = STATE_UNREGISTERING_REREG;
    break;

  case STATE_UNREGISTERING_REREG:
    break;

  case STATE_REG_BYPASS:
    break;

  default:
    GKDBG((1, "GkiRegister: Invalid state %d", uGkiState));
    status = LastGkiError;
  } // switch

  return status;
} // GkiRegister()



/*
 *  NOTES
 *    GkiLock must be locked before calling this routine!
 */

HRESULT GkiCloseCallNoError(PGKICALL pGkiCall, void *pConference)
{
  ASSERT(pGkiCall != NULL);
  pConference = pConference;            // Disable compiler warning
  if (pGkiCall->uGkiCallState != GCS_START)
    GkiCloseCall(pGkiCall);
  return NOERROR;
} // GkiCloseCallNoError()

HRESULT GkiUnregister(void)
{
  register HRESULT      status = NOERROR;

  switch (uGkiState)
  {
  case STATE_REG_BYPASS:
    ApplyToAllCalls(GkiCancelCall);
    uGkiState = STATE_WINDOW_CREATED;
    break;

  case STATE_UNREGISTERING_REREG:
    uGkiState = STATE_UNREGISTERING;
    break;

  case STATE_UNREGISTERING:
    break;

  case STATE_DISENGAGING_REREG:
    if (uGkiCalls != 0 || uPendingDisengages != 0)
    {
      uGkiState = STATE_DISENGAGING;
    }
    else
    {
      uGkiState = STATE_REGISTERED;
      return GkiUnregister();
    }
    break;

  case STATE_DISENGAGING:
    if (uGkiCalls == 0 && uPendingDisengages == 0)
    {
      uGkiState = STATE_REGISTERED;
      return GkiUnregister();
    }
    break;

  case STATE_ADMITTING_UNREG:
  case STATE_ADMITTING_REREG:
  case STATE_ADMITTING:
    uGkiState = STATE_ADMITTING_UNREG;
    break;

  case STATE_REGISTERING_UNREG:
  case STATE_REGISTERING_REREG:
  case STATE_REGISTERING:
    uGkiState = STATE_REGISTERING_UNREG;
    break;

  case STATE_REGISTERED:
    if (uGkiCalls)
    {
      // Issue Disengage Request for every call
      uGkiState = STATE_DISENGAGING;
      ApplyToAllCalls(GkiCloseCallNoError);
      break;

    }
    else
    {
      // Issue Unregistration Request
      uGkiState = STATE_UNREGISTERING;
      GKDBG((1, "GKI_UnregistrationRequest called...", 0));
      status = pGKI_UnregistrationRequest();
      if (status == NOERROR)
      {
        GKDBG((1, GkiErrorName("GKI_UnregistrationRequest returned %s", status), 0));
      }
      else
      {
        GKDBG((1, GkiErrorName("GKI_UnregistrationRequest returned %s", status), 0));
        uGkiState = STATE_WINDOW_CREATED;
      }
    }
    break;

  case STATE_WINDOW_CREATED:
  case STATE_CLASS_REGISTERED:
  case STATE_START:
    GKDBG((1, StateName("GkiUnregister: Already in uninitialized state %s", uGkiState), 0));
    status = LastGkiError;
    break;

  default:
    GKDBG((1, "GkiUnregister: Invalid state %d", uGkiState));
    status = LastGkiError;
  } // switch

  return status;
} // GkiUnregister()



void DeInitGkiManager(void)
{
  register PLISTEN      pListen;

  EnterCriticalSection(&GkiLock);

#if 0
  // TBD - When called from DllMain PROCESS_DETACH, this does not work because
  // apparently the socket to the Gatekeeper has already been closed.
  if (uGkiState != STATE_START)
  {
    GkiUnregister();
    uGkiState = STATE_START;
  }
#else
  uGkiState = STATE_START;
#endif

  while (pListenList)
  {
    pListen = pListenList;
    pListenList = pListenList->pNext;
    if (pListen->pAliasNames)
    {
      FreeAliasNames(pListen->pAliasNames);
    }
    Free(pListen);
  }

  pGKI_RegistrationRequest   = NULL;
  pGKI_UnregistrationRequest = NULL;
  pGKI_LocationRequest       = NULL;
  pGKI_AdmissionRequest      = NULL;
  pGKI_BandwidthRequest      = NULL;
  pGKI_DisengageRequest      = NULL;
  if (hGkiDll)
  {
	if (pGKI_CleanupRequest)
          pGKI_CleanupRequest();

#if defined(REMOVE_FROM_TSP)
    FreeLibrary(hGkiDll);
#endif // REMOVE_FROM_TSP
  }
  pGKI_CleanupRequest = NULL;

  LeaveCriticalSection(&GkiLock);
  DeleteCriticalSection(&GkiLock);
  DestroyWindow(hwndGki);
  UnregisterClass(szClassName, 0);
} // DeInitGkiManager()



HRESULT InitGkiManager(void)
{
  InitializeCriticalSection(&GkiLock);

#if defined(REMOVE_FROM_TSP)

  hGkiDll = LoadLibrary("GKI.DLL");
  if (hGkiDll == NULL)
  {
    DeInitGkiManager();
  	return CC_GKI_LOAD;
  }

  pGKI_RegistrationRequest   = (PGKI_RegistrationRequest)  GetProcAddress(hGkiDll, "GKI_RegistrationRequest");
  pGKI_UnregistrationRequest = (PGKI_UnregistrationRequest)GetProcAddress(hGkiDll, "GKI_UnregistrationRequest");
  pGKI_LocationRequest       = (PGKI_LocationRequest)      GetProcAddress(hGkiDll, "GKI_LocationRequest");
  pGKI_AdmissionRequest      = (PGKI_AdmissionRequest)     GetProcAddress(hGkiDll, "GKI_AdmissionRequest");
  pGKI_BandwidthRequest      = (PGKI_BandwidthRequest)     GetProcAddress(hGkiDll, "GKI_BandwidthRequest");
  pGKI_DisengageRequest      = (PGKI_DisengageRequest)     GetProcAddress(hGkiDll, "GKI_DisengageRequest");
  pGKI_CleanupRequest        = (PGKI_CleanupRequest)       GetProcAddress(hGkiDll, "GKI_CleanupRequest");
  
  if (pGKI_RegistrationRequest   == NULL ||
      pGKI_UnregistrationRequest == NULL ||
      pGKI_LocationRequest       == NULL ||
      pGKI_AdmissionRequest      == NULL ||
      pGKI_BandwidthRequest      == NULL ||
      pGKI_DisengageRequest      == NULL ||
	  pGKI_CleanupRequest        == NULL)
  {
    DeInitGkiManager();
  	return CC_GKI_LOAD;
  }

#else  // REMOVE_FROM_TSP

  pGKI_RegistrationRequest   = GKI_RegistrationRequest;
  pGKI_UnregistrationRequest = GKI_UnregistrationRequest;
  pGKI_LocationRequest       = GKI_LocationRequest;
  pGKI_AdmissionRequest      = GKI_AdmissionRequest;
  pGKI_BandwidthRequest      = GKI_BandwidthRequest;
  pGKI_DisengageRequest      = GKI_DisengageRequest;
  pGKI_CleanupRequest        = GKI_CleanupRequest;

#endif // REMOVE_FROM_TSP

  return NOERROR;
} // InitGkiManager()



//
// Entry Points
//

HRESULT GkiFreeCall(PGKICALL pGkiCall)
{
  HRESULT               status = NOERROR;

  ASSERT(pGkiCall != NULL);
  ASSERT(pGkiCall->uGkiCallState != GCS_START);
  pGkiCall->hGkiCall = 0;

  while (pGkiCall->pBwReqHead)
  {
    Free(BwReqDequeue(pGkiCall));
  }

  if (pGkiCall->pCalleeAliasNames)
  {
	Q931FreeAliasNames(pGkiCall->pCalleeAliasNames);
    pGkiCall->pCalleeAliasNames = NULL;
  }

  if (pGkiCall->pCalleeExtraAliasNames != NULL)
  {
	Q931FreeAliasNames(pGkiCall->pCalleeExtraAliasNames);
    pGkiCall->pCalleeExtraAliasNames = NULL;
  }

  switch (pGkiCall->uGkiCallState)
  {
  case GCS_START:
  case GCS_WAITING:
    break;

  case GCS_ADMITTING:
    ASSERT(uGkiState == STATE_ADMITTING);
    switch (uGkiState)
    {
    case STATE_ADMITTING:
      uGkiState = STATE_REGISTERED;
      break;
    } // switch
    break;

  case GCS_ADMITTING_CLOSE_PENDING:
    ASSERT(uGkiState == STATE_ADMITTING || uGkiState == STATE_ADMITTING_UNREG || uGkiState == STATE_ADMITTING_REREG);
    switch (uGkiState)
    {
    case STATE_ADMITTING:
      uGkiState = STATE_REGISTERED;
      break;
    case STATE_ADMITTING_UNREG:
      uGkiState = STATE_REGISTERED;
      status = GkiUnregister();
      break;
    case STATE_ADMITTING_REREG:
      uGkiState = STATE_REGISTERED;
      status = GkiRegister();
      break;
    } // switch
    break;

  case GCS_ADMITTED:
  case GCS_CHANGING:
  case GCS_CHANGING_CLOSE_PENDING:
  case GCS_DISENGAGING:
    --uGkiCalls;
    GKDBG((1, "GkiFreeCall: uGkiCalls = %d", uGkiCalls));
    break;

  default:
    GKDBG((1, "GkiFreeCall: Invalid call state %d", pGkiCall->uGkiCallState));
  } // switch

  pGkiCall->uGkiCallState = GCS_START;

  if (uGkiCalls == 0 && uPendingDisengages == 0)
  {
    switch (uGkiState)
    {
    case STATE_DISENGAGING:
      uGkiState = STATE_REGISTERED;
      status = GkiUnregister();
      break;
    case STATE_DISENGAGING_REREG:
      uGkiState = STATE_REGISTERED;
      status = GkiRegister();
      break;
    } // switch
    if (pListenList && pListenList->hListen == DEFAULT_LISTEN_HANDLE)
    {
      GkiCloseListen(DEFAULT_LISTEN_HANDLE);
    }
  }

  return status;
} // GkiFreeCall()



HRESULT GkiCloseListen  (DWORD hListen)
{
  register PLISTEN      pListen;
  register HRESULT      status;

  GKDBG((1, StateName("GkiCloseListen <- State = %s", uGkiState), 0));
  EnterCriticalSection(&GkiLock);

  pListen = ListenDequeue(hListen);
  if (pListen == NULL)
  {
    status = CC_GKI_LISTEN_NOT_FOUND;
  }
  else
  {
    if (pListen->pAliasNames)
    {
      FreeAliasNames(pListen->pAliasNames);
    }
    Free(pListen);
    if (pListenList)
    {
      status = GkiRegister();
    }
    else
    {
      status = GkiUnregister();
    }
  }

  LeaveCriticalSection(&GkiLock);
  GKDBG((1, StateName("GkiCloseListen -> State = %s", uGkiState), 0));
  return status;
} // GkiCloseListen()



HRESULT  GkiOpenListen  (DWORD hListen, PCC_ALIASNAMES pAliasNames, DWORD dwAddr, WORD wPort)
{
  register PLISTEN      pListen;
  register HRESULT      status = NOERROR;

  GKDBG((1, StateName("GkiOpenListen <- State = %s", uGkiState), 0));
  EnterCriticalSection(&GkiLock);

  // Check for invalid IP address
  if (dwAddr == INADDR_ANY || dwAddr == INADDR_NONE)
  {
    dwAddr = GetIpAddress();
    if (dwAddr == INADDR_ANY)
      return CC_GKI_IP_ADDRESS;
  }

  // Check for invalid alias list
  if (pAliasNames)
  {
    PCC_ALIASITEM       pAliasItem;
    unsigned int        uIndex;

    if (pAliasNames->wCount == 0)
    {
      GKDBG((1, "GkiOpenListen: Alias name wCount == 0", 0));
      return CC_BAD_PARAM;
    }
    pAliasItem = pAliasNames->pItems;
    for (uIndex = 0; uIndex < pAliasNames->wCount; ++uIndex, ++pAliasItem)
    {
      if (pAliasItem->wDataLength == 0 || pAliasItem->pData == NULL)
      {
        // Bad alias item
        GKDBG((1, "GkiOpenListen: Bad alias item (wDataLength = %d)",
                pAliasItem->wDataLength));
        return CC_BAD_PARAM;
      }
    }
  }

  pListen = (PLISTEN)Malloc(sizeof(*pListen));
  if (pListen)
  {
    if (pAliasNames)
    {
      status = CopyAliasNames(&pListen->pAliasNames, pAliasNames);
      if (status != NOERROR)
      {
        GKDBG((1, "GkiOpenListen: CopyAliasNames returned 0x%x", status));
        LeaveCriticalSection(&GkiLock);
        return status;
      }
    }
    else
    {
      pListen->pAliasNames = NULL;
    }

    pListen->hListen = hListen;
    pListen->dwAddr  = ntohl(dwAddr);
    pListen->wPort   = wPort;
    ListenEnqueue(pListen);
    status = GkiRegister();
  } // if
  else
  {
    GKDBG((1, "GkiOpenListen: Could not allocate listen structure", 0));
    status = CC_NO_MEMORY;
  } // else

  LeaveCriticalSection(&GkiLock);
  GKDBG((1, StateName("GkiOpenListen -> State = %s", uGkiState), 0));
  return status;
} // GkiOpenListen()



/*
 *  NOTES
 *    Must have Call locked before calling!
 */

HRESULT GkiCloseCall(PGKICALL pGkiCall)
{
  HRESULT               status = NOERROR;

  ASSERT(pGkiCall != NULL);
  GKDBG((1, CallStateName("GkiCloseCall <- Call State = %s", pGkiCall->uGkiCallState), 0));

  while (pGkiCall->pBwReqHead)
  {
    Free(BwReqDequeue(pGkiCall));
  }

  if (pGkiCall->uGkiCallState == GCS_START)
  {
    GKDBG((1, CallStateName("GkiCloseCall: Call already in state %s", pGkiCall->uGkiCallState), 0));
    status = CC_GKI_CALL_STATE;
  }
  else
  {
    switch (uGkiState)
    {
    case STATE_START:
      break;

    case STATE_REG_BYPASS:
      status = GkiFreeCall(pGkiCall);
      break;

    default:
      switch (pGkiCall->uGkiCallState)
      {
      case GCS_WAITING:
        status = GkiFreeCall(pGkiCall);
        break;

      case GCS_ADMITTING:
        pGkiCall->uGkiCallState = GCS_ADMITTING_CLOSE_PENDING;
        break;

      case GCS_ADMITTING_CLOSE_PENDING:
      case GCS_CHANGING_CLOSE_PENDING:
      case GCS_DISENGAGING:
        GKDBG((1, CallStateName("GkiCloseCall: Call already in closing state %s", pGkiCall->uGkiCallState), 0));
        status = CC_GKI_CALL_STATE;
        break;

      case GCS_ADMITTED:
        pGkiCall->uGkiCallState = GCS_DISENGAGING;
        GKDBG((1, "GKI_DisengageRequest called...", 0));
        ++uPendingDisengages;
        status = pGKI_DisengageRequest(pGkiCall->hGkiCall);
        if (status == NOERROR)
        {
          GKDBG((1, GkiErrorName("GKI_DisengageRequest returned %s", status), 0));
        }
        else
        {
          --uPendingDisengages;
          GKDBG((1, GkiErrorName("GKI_DisengageRequest returned %s", status), 0));
          GkiFreeCall(pGkiCall);
        }
        break;

      case GCS_CHANGING:
        pGkiCall->uGkiCallState = GCS_CHANGING_CLOSE_PENDING;
        break;

      default:
        GKDBG((1, CallStateName("GkiCloseCall: Call in invalid state %s", pGkiCall->uGkiCallState), 0));
        status = CC_GKI_CALL_STATE;
      } // switch
    } // switch
  } // else

  GKDBG((1, StateName("GkiCloseCall -> State = %s", uGkiState), 0));
  return status;
} // GkiCloseCall()



/*
 *  NOTES
 *    Must have Call locked before calling!
 */

static HRESULT BandwidthRejected(PGKICALL pGkiCall, UINT Reason)
{
  HRESULT               status = NOERROR;
  PBWREQ                pBwReq;
  DWORD                 hCall;

  ASSERT(pGkiCall != NULL);
  pBwReq = BwReqDequeue(pGkiCall);
  hCall  = pGkiCall->hCall;

  if (pBwReq)
  {
    if ((pGkiCall->uBandwidthUsed + pBwReq->uChannelBandwidth) <= pGkiCall->uBandwidthAllocated)
    {
      if (pBwReq->Type == TX)
      {
        OpenChannelConfirm  (pBwReq->hChannel);
      }
      else
      {
        AcceptChannelConfirm(pBwReq->hChannel);
      }
    }
    else
    {
      if (pBwReq->Type == TX)
      {
        OpenChannelReject   (pBwReq->hChannel, MapBandwidthRejectReason(Reason));
      }
      else
      {
        AcceptChannelReject (pBwReq->hChannel, MapBandwidthRejectReason(Reason));
      }
    }
    Free(pBwReq);
    if (ValidateCall(hCall) == NOERROR)
    {
      CheckPendingBandwidth(pGkiCall);
    }
  }

  return status;
} // BandwidthRejected()



/*
 *  NOTES
 *    Must have Call locked before calling!
 */

static HRESULT CheckPendingBandwidth(PGKICALL pGkiCall)
{
  HRESULT               status = NOERROR;
  PBWREQ                pBwReq;
  DWORD                 hCall;

  ASSERT(pGkiCall != NULL);
  ASSERT(pGkiCall->uGkiCallState == GCS_ADMITTED);
  hCall = pGkiCall->hCall;

  while (pGkiCall->pBwReqHead != NULL &&
         (pGkiCall->uBandwidthUsed + pGkiCall->pBwReqHead->uChannelBandwidth) <= pGkiCall->uBandwidthAllocated)
  {
    pBwReq = BwReqDequeue(pGkiCall);
    ASSERT(pBwReq != NULL);
    pGkiCall->uBandwidthUsed += pBwReq->uChannelBandwidth;
    if (pBwReq->Type == TX)
    {
      OpenChannelConfirm(pBwReq->hChannel);
    }
    else
    {
      AcceptChannelConfirm(pBwReq->hChannel);
    }
    Free(pBwReq);
    if (ValidateCall(hCall) != NOERROR)
    {
      return status;
    }
  }

  if (pGkiCall->pBwReqHead != NULL)
  {
    pGkiCall->uGkiCallState = GCS_CHANGING;
    GKDBG((1, "GKI_BandwidthRequest called...", 0);
    status = pGKI_BandwidthRequest(pGkiCall->hGkiCall,
                                   pGkiCall->usCallTypeChoice,
                                   pGkiCall->uBandwidthUsed + pGkiCall->pBwReqHead->uChannelBandwidth));
    if (status == NOERROR)
    {
      GKDBG((1, GkiErrorName("GKI_BandwidthRequest returned %s", status), 0));
    }
    else
    {
      GKDBG((1, GkiErrorName("GKI_BandwidthRequest returned %s", status), 0));
      BandwidthRejected(pGkiCall, BndRjctRsn_undfndRsn_chosen);
    }
  }

  return status;
} // CheckPendingBandwidth()



static void FreeAliasList(SeqAliasAddr *pAliasAddrs)
{
  register SeqAliasAddr *pAlias = pAliasAddrs;
  while (pAlias)
  {
    if (pAlias->value.choice == h323_ID_chosen && pAlias->value.u.h323_ID.value)
      Free(pAlias->value.u.h323_ID.value);
    pAlias = pAlias->next;
  }
  Free(pAlias);
} // FreeAliasList()



/*
 *  NOTES
 *    Must have Call locked before calling!
 *
 *    The following fields in the GKICALL structure must be properly filled
 *    in before calling this function:
 *      pCall                 Pointer back to containing CALL structure.
 *      CallType              Type of call.
 *      uBandwidthRequested   Initial bandwidth for call.
 *      pConferenceId         Pointer to conference ID buffer.
 *      bActiveMC             TRUE if calling party has an active MC.
 *      bAnswerCall           ???
 */

HRESULT GkiOpenCall (PGKICALL pGkiCall, void *pConference)
{
  HRESULT               status = NOERROR;
  DWORD                 hCall;
  TransportAddress      SrcCallSignalAddress;
  TransportAddress *    pSrcCallSignalAddress;
  TransportAddress      DestCallSignalAddress;
  TransportAddress *    pDestCallSignalAddress;
  SeqAliasAddr *        pAliasAddrs;
  SeqAliasAddr *        pExtraAliasAddrs;
  SeqAliasAddr *        pAlias;
  PCC_ALIASITEM         pAliasItem;
  unsigned              uCount;
  unsigned              uIndex;
  ConferenceIdentifier  ConferenceId;

  ASSERT(pGkiCall != NULL);
  ASSERT(pConference != NULL);
  GKDBG((1, StateName("GkiOpenCall <- State = %s", uGkiState), 0));
  EnterCriticalSection(&GkiLock);

  switch (uGkiState)
  {
  case STATE_REG_BYPASS:
    ASSERT(pGkiCall->uGkiCallState == GCS_START || pGkiCall->uGkiCallState == GCS_WAITING || pGkiCall->uGkiCallState == GCS_ADMITTING);
    hCall = pGkiCall->hCall;
    GkiAllocCall(pGkiCall, GKI_BYPASS_HANDLE);
    pGkiCall->uBandwidthAllocated = MAX_BANDWIDTH;
    if (pGkiCall->bAnswerCall)
    {
      status = AcceptCallConfirm(pGkiCall->pCall, pConference);
      if (status == NOERROR && ValidateCall(hCall) == NOERROR)
      {
        CheckPendingBandwidth(pGkiCall);
      }
    }
    else if (pGkiCall->dwIpAddress == 0)
    {
      status = PlaceCallReject  (pGkiCall->pCall, pConference, CC_INVALID_WITHOUT_GATEKEEPER);
    }
    else
    {
      status = PlaceCallConfirm (pGkiCall->pCall, pConference);
      if (status == NOERROR && ValidateCall(hCall) == NOERROR)
      {
        CheckPendingBandwidth(pGkiCall);
      }
    }
    break;

  case STATE_REGISTERING:
  case STATE_REGISTERING_REREG:
  case STATE_ADMITTING:
    pGkiCall->uGkiCallState = GCS_WAITING;
    break;

  case STATE_REGISTERED:
    switch (pGkiCall->CallType)
    {
    case POINT_TO_POINT:
      pGkiCall->usCallTypeChoice = pointToPoint_chosen;
      break;
    case ONE_TO_MANY:
      pGkiCall->usCallTypeChoice = oneToN_chosen;
      break;
    case MANY_TO_ONE:
      pGkiCall->usCallTypeChoice = nToOne_chosen;
      break;
    case MANY_TO_MANY:
      pGkiCall->usCallTypeChoice = nToN_chosen;
      break;
    default:
      LeaveCriticalSection(&GkiLock);
      GKDBG((1, "GkiOpenCall -> Invalid CallType %d", pGkiCall->CallType));
      return CC_BAD_PARAM;
    } // switch

    pSrcCallSignalAddress = NULL;
    pDestCallSignalAddress = NULL;
    pAliasAddrs            = NULL;
    pExtraAliasAddrs       = NULL;

    if (pGkiCall->dwSrcCallSignalIpAddress != 0 && pGkiCall->wSrcCallSignalPort != 0)
    {
      SrcCallSignalAddress.choice = ipAddress_chosen;
      SrcCallSignalAddress.u.ipAddress.ip.length = 4;
      *((DWORD *)SrcCallSignalAddress.u.ipAddress.ip.value) = pGkiCall->dwSrcCallSignalIpAddress;
      SrcCallSignalAddress.u.ipAddress.port = pGkiCall->wSrcCallSignalPort;
      pSrcCallSignalAddress = &SrcCallSignalAddress;
    }

    if (pGkiCall->dwIpAddress != 0 && pGkiCall->wPort != 0)
    {
      DestCallSignalAddress.choice = ipAddress_chosen;
      DestCallSignalAddress.u.ipAddress.ip.length = 4;
      *((DWORD *)DestCallSignalAddress.u.ipAddress.ip.value) = pGkiCall->dwIpAddress;
      DestCallSignalAddress.u.ipAddress.port = pGkiCall->wPort;
      pDestCallSignalAddress = &DestCallSignalAddress;
    }

    if (pGkiCall->pCalleeAliasNames)
    {
//      pDestCallSignalAddress = NULL;
      uCount = pGkiCall->pCalleeAliasNames->wCount;
      pAliasAddrs = Malloc(uCount * sizeof(*pAliasAddrs));
      if (pAliasAddrs == NULL)
      {
        LeaveCriticalSection(&GkiLock);
        GKDBG((1, "GkiOpenCall: Could not allocate %d Alias Addresses", uCount));
        return CC_NO_MEMORY;
      }
      memset(pAliasAddrs, 0, uCount * sizeof(*pAliasAddrs));
      pAlias = pAliasAddrs;
      pAliasItem = pGkiCall->pCalleeAliasNames->pItems;
      for (uIndex = 0; uIndex < uCount; ++uIndex)
      {
        status = CopyAliasItem(pAlias, pAliasItem);
        if (status != NOERROR)
        {
          LeaveCriticalSection(&GkiLock);
          GKDBG((1, "GkiOpenCall: CopyAliasItem returned %d", status));
          FreeAliasList(pAliasAddrs);
          return status;
        }
        pAlias->next = pAlias + 1;
        ++pAlias;
        ++pAliasItem;
      } // for
      --pAlias;
      pAlias->next = NULL;
    }

    if (pGkiCall->pCalleeExtraAliasNames)
    {
      uCount = pGkiCall->pCalleeExtraAliasNames->wCount;
      pExtraAliasAddrs = Malloc(uCount * sizeof(*pExtraAliasAddrs));
      if (pExtraAliasAddrs == NULL)
      {
        LeaveCriticalSection(&GkiLock);
        GKDBG((1, "GkiOpenCall: Could not allocate %d Alias Addresses", uCount));
        if (pAliasAddrs)
          FreeAliasList(pAliasAddrs);
        return CC_NO_MEMORY;
      }
      memset(pExtraAliasAddrs, 0, uCount * sizeof(*pExtraAliasAddrs));
      pAlias = pExtraAliasAddrs;
      pAliasItem = pGkiCall->pCalleeExtraAliasNames->pItems;
      for (uIndex = 0; uIndex < uCount; ++uIndex)
      {
        status = CopyAliasItem(pAlias, pAliasItem);
        if (status != NOERROR)
        {
          LeaveCriticalSection(&GkiLock);
          GKDBG((1, "GkiOpenCall: CopyAliasItem returned %d", status));
          if (pAliasAddrs)
            FreeAliasList(pAliasAddrs);
          FreeAliasList(pExtraAliasAddrs);
          return status;
        }
        pAlias->next = pAlias + 1;
        ++pAlias;
        ++pAliasItem;
      } // for
      --pAlias;
      pAlias->next = NULL;
    }

    if (pGkiCall->uBandwidthRequested < MIN_BANDWIDTH)
    {
      pGkiCall->uBandwidthRequested = MIN_BANDWIDTH;
    }
    ASSERT(pGkiCall->uBandwidthAllocated == 0);
    ASSERT(pGkiCall->uBandwidthUsed == 0);

    memcpy(ConferenceId.value, pGkiCall->pConferenceId, 16);
    if (((DWORD *)pGkiCall->pConferenceId)[0] != 0 ||
        ((DWORD *)pGkiCall->pConferenceId)[1] != 0 ||
        ((DWORD *)pGkiCall->pConferenceId)[2] != 0 ||
        ((DWORD *)pGkiCall->pConferenceId)[3] != 0)
    {
      ConferenceId.length = 16;
    }
    else
    {
      ConferenceId.length = 0;
    }

    pGkiCall->hGkiCall = GKI_ADMITTING_HANDLE;
    if (pDestCallSignalAddress != NULL || pAliasAddrs != NULL)
    {
      uGkiState = STATE_ADMITTING;
      pGkiCall->uGkiCallState = GCS_ADMITTING;
      GKDBG((1, "GKI_AdmissionRequest called...", 0);
      status = pGKI_AdmissionRequest(pGkiCall->usCallTypeChoice,    // usCallTypeChoice.
                                     pAliasAddrs,                   // pDestinationInfo
									 pGkiCall->bAnswerCall ? pSrcCallSignalAddress : pDestCallSignalAddress,
                                     pExtraAliasAddrs,              // pDestExtraCallInfo,
                                     pGkiCall->uBandwidthRequested, // bandWidth,
                                     &ConferenceId,                 // pConferenceID,
                                     pGkiCall->bActiveMC,           // activeMC,
                                     pGkiCall->bAnswerCall,         // answerCall,
                                     ipAddress_chosen));             // usCallTransport
      if (status == NOERROR)
      {
        GKDBG((1, GkiErrorName("GKI_AdmissionRequest returned %s", status), 0));
      }
      else
      {
        GKDBG((1, GkiErrorName("GKI_AdmissionRequest returned %s", status), 0));
      }
    }
    else
    {
      pGkiCall->hGkiCall = 0;
      status = CC_BAD_PARAM;
    }

    if (status != NOERROR)
    {
      uGkiState = STATE_REGISTERED;
      GkiCancelCall(pGkiCall, pConference);
    }

    if (pAliasAddrs)
      FreeAliasList(pAliasAddrs);
    if (pExtraAliasAddrs)
      FreeAliasList(pExtraAliasAddrs);
    break;

  case STATE_START:
  case STATE_CLASS_REGISTERED:
  case STATE_WINDOW_CREATED:
    pGkiCall->uGkiCallState = GCS_WAITING;
    status = GkiOpenListen(DEFAULT_LISTEN_HANDLE, NULL, 0, 1720);
    break;

  default:
    GKDBG((1, StateName("GkiOpenCall: Invalid state %s", uGkiState), 0));
    status = LastGkiError;
  } // switch

  LeaveCriticalSection(&GkiLock);
  GKDBG((1, CallStateName("GkiOpenCall -> Call State = %s", pGkiCall->uGkiCallState), 0));
  return status;
} // GkiOpenCall()



/*
 *  NOTES
 *    Must have Call locked before calling!
 */

HRESULT GkiOpenChannel(PGKICALL pGkiCall, unsigned uChannelBandwidth, DWORD hChannel, CHANNELTYPE Type)
{
  HRESULT               status = NOERROR;
  PBWREQ                pBwReq;

  ASSERT(pGkiCall != NULL);
  GKDBG((1, CallStateName("GkiOpenChannel <- Call State = %s", pGkiCall->uGkiCallState), 0));

  pBwReq = (PBWREQ)Malloc(sizeof(*pBwReq));
  if (pBwReq == NULL)
  {
    GKDBG((1, "GkiOpenChannel: Memory allocation failed", 0));
    return CC_NO_MEMORY;
  }

  pBwReq->uChannelBandwidth = uChannelBandwidth / 100;
  pBwReq->hChannel          = hChannel;
  pBwReq->Type              = Type;
  BwReqEnqueue(pGkiCall, pBwReq);
  switch (pGkiCall->uGkiCallState)
  {
  case GCS_WAITING:
  case GCS_ADMITTING:
  case GCS_CHANGING:
    // Must wait for current operation to complete
    break;

  case GCS_ADMITTED:
    status = CheckPendingBandwidth(pGkiCall);
    break;

  default:
    GKDBG((1, "GkiOpenChannel: Invalid call state %d", pGkiCall->uGkiCallState));
    status = CC_GKI_CALL_STATE;
  } // switch

  GKDBG((1, CallStateName("GkiOpenChannel -> Call State = %s", pGkiCall->uGkiCallState), 0));
  return status;
} // GkiOpenChannel()



/*
 *  NOTES
 *    Must have Call locked before calling!
 */

HRESULT GkiCloseChannel(PGKICALL pGkiCall, unsigned uChannelBandwidth, DWORD hChannel)
{
  PBWREQ                pBwReq;
  PBWREQ                pBwReq1;

  ASSERT(pGkiCall != NULL);
  GKDBG((1, CallStateName("GkiCloseChannel <- Call State = %s", pGkiCall->uGkiCallState), 0));

  // If Bandwidth request is still in queue, bandwidth has not been allocated
  pBwReq = pGkiCall->pBwReqHead;
  if (pBwReq)
  {
    if (pBwReq->hChannel == hChannel)
    {
      Free(BwReqDequeue(pGkiCall));
      GKDBG((1, CallStateName("GkiCloseChannel -> Call State = %s", pGkiCall->uGkiCallState), 0));
      return NOERROR;
    }
    while ((pBwReq1 = pBwReq->pNext) != NULL)
    {
      if (pBwReq1->hChannel == hChannel)
      {
        if (pGkiCall->pBwReqTail == pBwReq1)
        {
          pGkiCall->pBwReqTail = pBwReq;
        }
        pBwReq->pNext = pBwReq1->pNext;
        Free(pBwReq1);
        GKDBG((1, CallStateName("GkiCloseChannel -> Call State = %s", pGkiCall->uGkiCallState), 0));
        return NOERROR;
      }
    }
  }

  pGkiCall->uBandwidthUsed -= (uChannelBandwidth / 100);
  GKDBG((1, CallStateName("GkiCloseChannel -> Call State = %s", pGkiCall->uGkiCallState), 0));
  return NOERROR;
} // GkiCloseChannel()



unsigned GkiGetBandwidth(PGKICALL pGkiCall)
{
  ASSERT(pGkiCall != NULL);
  return pGkiCall->uBandwidthAllocated * 100;
} // GkiGetBandwidth()



//
// GkiWndProc subroutines
//

/*
 *  NOTES
 *    Must have Call locked before calling!
 */

static HRESULT CheckPendingOpen(PGKICALL pGkiCall, void *pConference)
{
  HRESULT               status = NOERROR;

  ASSERT(pGkiCall != NULL);
  ASSERT(pConference != NULL);

  switch (uGkiState)
  {
  case STATE_REGISTERED:
  case STATE_REG_BYPASS:
    // TBD - Can only open 1!!!
    ASSERT(pGkiCall->uGkiCallState != GCS_ADMITTING);
    if (pGkiCall->uGkiCallState == GCS_WAITING)
    {
      status = GkiOpenCall(pGkiCall, pConference);
    }
    break;

  default:
    status = LastGkiError;
  } // switch

  return status;
} // CheckPendingOpen()



static void GkiNoResponse(HWND hWnd)
{
  HRESULT               status;

  switch (uGkiState)
  {
  case STATE_START:
  case STATE_CLASS_REGISTERED:
  case STATE_WINDOW_CREATED:
  case STATE_REG_BYPASS:
    break;

  case STATE_REGISTERING:
  case STATE_REGISTERING_REREG:
  case STATE_REGISTERING_UNREG:
    GKDBG((1, "GkiWndProc: dummy GKI_REG_REJECT", 0));
    PostMessage(hWnd, GKIMAN_BASE + GKI_REG_REJECT, 0, 0);
    break;

  case STATE_ADMITTING:
  case STATE_ADMITTING_REREG:
    ApplyToAllCalls(GkiCancelAdmitting);
    uGkiState = STATE_REGISTERED;

    // Fall-through to next case

  case STATE_REGISTERED:
    if (uGkiCalls == 0)
    {
      GkiRegister();
    }
    else
    {
      uGkiState = STATE_REG_BYPASS;
      ApplyToAllCalls(GatekeeperNotFound);
      GKDBG((1, "GKI_UnregistrationRequest called...", 0));
      status = pGKI_UnregistrationRequest();
      if (status == NOERROR)
      {
        GKDBG((1, GkiErrorName("GKI_UnregistrationRequest returned %s", status), 0));
      }
      else
      {
        GKDBG((1, GkiErrorName("GKI_UnregistrationRequest returned %s", status), 0));
      }
    }
    break;

  case STATE_ADMITTING_UNREG:
    ApplyToAllCalls(GkiCancelAdmitting);
    uGkiState = STATE_REGISTERED;
    GkiUnregister();
    break;

  case STATE_DISENGAGING:
    ApplyToAllCalls(GatekeeperNotFound);
    ASSERT(uGkiCalls == 0);
    uGkiState = STATE_REGISTERED;
    GkiUnregister();
    break;

  case STATE_DISENGAGING_REREG:
    ApplyToAllCalls(GatekeeperNotFound);
    ASSERT(uGkiCalls == 0);
    uGkiState = STATE_REGISTERED;
    GkiRegister();
    break;

  case STATE_UNREGISTERING:
  case STATE_UNREGISTERING_REREG:
    GKDBG((1, "GkiWndProc: dummy GKI_UNREG_CONFIRM", 0));
    PostMessage(hWnd, GKIMAN_BASE + GKI_UNREG_CONFIRM, 0, 0);
    break;

  default:
    GKDBG((1, "GkiWndProc: Bad uGkiState %d", uGkiState));
  } // switch
} // GkiNoResponse()



LONG APIENTRY GkiWndProc(
  HWND hWnd,                /* window handle                   */
  UINT message,             /* type of message                 */
  UINT wParam,              /* additional information          */
  LONG lParam)              /* additional information          */
{
  CallReturnInfo *      pCallReturnInfo;
  PGKICALL              pGkiCall;
  void *                pConference;
  DWORD                 hCall;
  DWORD                 hConference;
  HRESULT               status;

  if (message < GKIMAN_BASE)
  {
    return DefWindowProc(hWnd, message, wParam, lParam);
  }

  EnterCallControlTop();

  GKDBG((1, StateName("GkiWndProc <- State = %s", uGkiState), 0));

  switch (message)
  {
  case GKIMAN_BASE + GKI_REG_CONFIRM:
    GKDBG((1, "GkiWndProc: GKI_REG_CONFIRM", 0));
    switch (uGkiState)
    {
    case STATE_REGISTERING:
      uGkiState = STATE_REGISTERED;
      ApplyToAllCalls(CheckPendingOpen);
      break;
    case STATE_REGISTERING_REREG:
      uGkiState = STATE_REGISTERED;
      GkiRegister();
      break;
    case STATE_REGISTERING_UNREG:
      uGkiState = STATE_REGISTERED;
      GkiUnregister();
      break;
    default:
      GKDBG((1, StateName("GkiWndProc: GKI_REG_CONFIRM in state %s", uGkiState), 0));
    } // switch
    break;

  case GKIMAN_BASE + GKI_REG_DISCOVERY:
    GKDBG((1, "GkiWndProc: GKI_REG_DISCOVERY", 0));
    ASSERT(uGkiState == STATE_REGISTERING || uGkiState == STATE_REGISTERING_REREG || uGkiState == STATE_REGISTERING_UNREG);
    break;

  case GKIMAN_BASE + GKI_REG_REJECT:
    GKDBG((1, "GkiWndProc: GKI_REG_REJECT Reason = %d", wParam));
    switch (uGkiState)
    {
    case STATE_REGISTERING:
      ApplyToAllCalls(GkiCancelCall);
      EnterCriticalSection(&GkiLock);
      while (pListenList)
      {
        register PLISTEN pListen = pListenList;
        pListenList = pListen->pNext;
        LeaveCriticalSection(&GkiLock);
        ListenReject(pListen->hListen, MapRegistrationRejectReason(wParam));
        if (pListen->pAliasNames)
        {
            FreeAliasNames(pListen->pAliasNames);
        }
        Free(pListen);
        EnterCriticalSection(&GkiLock);
      }
      LeaveCriticalSection(&GkiLock);
      uGkiState = STATE_WINDOW_CREATED;
      break;
    case STATE_REGISTERING_REREG:
      uGkiState = STATE_WINDOW_CREATED;
      GkiRegister();
      break;
    case STATE_REGISTERING_UNREG:
      uGkiState = STATE_WINDOW_CREATED;
      GkiUnregister();
      break;
    default:
      GKDBG((1, StateName("GkiWndProc: GKI_REG_REJECT in state %s", uGkiState), 0));
    } // switch
    break;

  case GKIMAN_BASE + GKI_REG_BYPASS:
    GKDBG((1, "GkiWndProc: GKI_REG_BYPASS", 0));
    switch (uGkiState)
    {
    case STATE_REGISTERING:
    case STATE_REGISTERING_REREG:
      uGkiState = STATE_REG_BYPASS;
      ApplyToAllCalls(CheckPendingOpen);
      break;
    case STATE_REGISTERING_UNREG:
      uGkiState = STATE_WINDOW_CREATED;
      GkiUnregister();
      break;
    default:
      GKDBG((1, StateName("GkiWndProc: GKI_REG_BYPASS in state %s", uGkiState), 0));
    } // switch
    break;

  case GKIMAN_BASE + GKI_UNREG_CONFIRM:
    GKDBG((1, "GkiWndProc: GKI_UNREG_CONFIRM", 0));
    switch (uGkiState)
    {
    case STATE_REGISTERING:
    case STATE_REGISTERING_REREG:
    case STATE_REGISTERED:
    case STATE_ADMITTING:
    case STATE_ADMITTING_REREG:
    case STATE_DISENGAGING_REREG:
    case STATE_UNREGISTERING_REREG:
      uGkiState = STATE_WINDOW_CREATED;
      GkiRegister();
      break;

    default:
      GKDBG((1, StateName("GkiWndProc: GKI_UNREG_CONFIRM in state %s", uGkiState), 0));

      // Fall through to next case

    case STATE_ADMITTING_UNREG:
    case STATE_DISENGAGING:
      ApplyToAllCalls(GkiCancelCall);

      // Fall-through to next case

    case STATE_REGISTERING_UNREG:
    case STATE_UNREGISTERING:
      uGkiState = STATE_WINDOW_CREATED;

      // Fall-through to next case

    case STATE_CLASS_REGISTERED:
    case STATE_WINDOW_CREATED:

      // Fall-through to next case

    case STATE_START:
    case STATE_REG_BYPASS:
      break;

    } // switch
    break;

  case GKIMAN_BASE + GKI_UNREG_REJECT:
    GKDBG((1, "GkiWndProc: GKI_UNREG_REJECT Reason = %d", wParam));
    switch (uGkiState)
    {
    case STATE_UNREGISTERING:
      uGkiState = STATE_WINDOW_CREATED;
      GkiUnregister();
      break;
    case STATE_UNREGISTERING_REREG:
      uGkiState = STATE_WINDOW_CREATED;
      GkiRegister();
      break;
    default:
      GKDBG((1, StateName("GkiWndProc: GKI_UNREG_REJECT in state %s", uGkiState), 0));
    } // switch
    break;

  case GKIMAN_BASE + GKI_ADM_CONFIRM:
    GKDBG((1, "GkiWndProc: GKI_ADM_CONFIRM", 0));
    switch (uGkiState)
    {
    case STATE_ADMITTING:
      uGkiState = STATE_REGISTERED;
      pCallReturnInfo = (CallReturnInfo *) lParam;
      if (LockGkiCallAndConference(GKI_ADMITTING_HANDLE, &pGkiCall, &pConference, &hCall, &hConference) == NOERROR)
      {
        GKDBG((1, CallStateName("GkiWndProc: Call State = %s", pGkiCall->uGkiCallState), 0));
        pGkiCall->usCallModelChoice   = pCallReturnInfo->callModel.choice;
        pGkiCall->uBandwidthAllocated = pCallReturnInfo->bandWidth;
        pGkiCall->usCRV = pCallReturnInfo->callReferenceValue;
        memcpy(pGkiCall->pConferenceId, pCallReturnInfo->conferenceID.value, 16);
        switch (pGkiCall->uGkiCallState)
        {
        case GCS_ADMITTING:
          GkiAllocCall(pGkiCall, pCallReturnInfo->hCall);
          if (pGkiCall->bAnswerCall)
          {
            status = AcceptCallConfirm(pGkiCall->pCall, pConference);
          }
          else
          {
            ASSERT(pCallReturnInfo->destCallSignalAddress.choice == ipAddress_chosen);
            pGkiCall->dwIpAddress = *((DWORD *)pCallReturnInfo->destCallSignalAddress.u.ipAddress.ip.value);
            pGkiCall->dwIpAddress = pGkiCall->dwIpAddress;
            pGkiCall->wPort = pCallReturnInfo->destCallSignalAddress.u.ipAddress.port;
            status = PlaceCallConfirm(pGkiCall->pCall, pConference);
          }
          if (status == NOERROR && ValidateCall(hCall) == NOERROR)
            CheckPendingBandwidth(pGkiCall);
          break;

        case GCS_ADMITTING_CLOSE_PENDING:
          GkiAllocCall(pGkiCall, pCallReturnInfo->hCall);
          GkiCloseCall(pGkiCall);
          break;

        default:
          GKDBG((1, CallStateName("GkiWndProc: GKI_ADM_CONFIRM in call state %s", pGkiCall->uGkiCallState), 0));
        } // switch
        UnlockGkiCallAndConference(pGkiCall, pConference, hCall, hConference);
      } // if
      else
      {
        GKDBG((1, "GkiWndProc: GKI_ADM_CONFIRM handle not found", 0));
      }
      ApplyToAllCalls(CheckPendingOpen);
      break;

    case STATE_ADMITTING_UNREG:
      uGkiState = STATE_REGISTERED;
      GkiUnregister();
      break;

    default:
        GKDBG((1, StateName("GkiWndProc: GKI_ADM_CONFIRM in state %s", uGkiState), 0));
    } // switch
    break;

  case GKIMAN_BASE + GKI_ADM_REJECT:
    GKDBG((1, "GkiWndProc: GKI_ADM_REJECT Reason = %d", wParam));
    switch (uGkiState)
    {
    case STATE_ADMITTING:
      pCallReturnInfo = (CallReturnInfo *) lParam;
      if (LockGkiCallAndConference(GKI_ADMITTING_HANDLE, &pGkiCall, &pConference, &hCall, &hConference) == NOERROR)
      {
		ASSERT(pGkiCall->uGkiCallState == GCS_ADMITTING);
        switch (wParam)
        {
        case calledPartyNotRegistered_chosen:
          if (pGkiCall->bAnswerCall)
          {
            // The gateway has gone away and come back without our notice!
            GkiCancelAdmitting(pGkiCall, pConference);
            uGkiState = STATE_REGISTERED;
            GkiRegister();
            GKDBG((1, StateName("GkiWndProc -> State = %s", uGkiState), 0));
            LeaveCallControlTop(0);
          }
          break;
        case callerNotRegistered_chosen:
          if (pGkiCall->bAnswerCall == FALSE)
          {
            // The gateway has gone away and come back without our notice!
            GkiCancelAdmitting(pGkiCall, pConference);
            uGkiState = STATE_REGISTERED;
            GkiRegister();
            GKDBG((1, StateName("GkiWndProc -> State = %s", uGkiState), 0));
            LeaveCallControlTop(0);
          }
        } // switch
        GkiFreeCall(pGkiCall);
        if (pGkiCall->bAnswerCall)
          AcceptCallReject(pGkiCall->pCall, pConference, MapAdmissionRejectReason(wParam));
        else
          PlaceCallReject (pGkiCall->pCall, pConference, MapAdmissionRejectReason(wParam));
        UnlockGkiCallAndConference(pGkiCall, pConference, hCall, hConference);
      } // if
      else
      {
        GKDBG((1, "GkiWndProc: GKI_ADM_REJECT handle not found", 0));
      }
      uGkiState = STATE_REGISTERED;
      ApplyToAllCalls(CheckPendingOpen);
      break;

    case STATE_ADMITTING_REREG:
      pCallReturnInfo = (CallReturnInfo *) lParam;
      if (LockGkiCallAndConference(GKI_ADMITTING_HANDLE, &pGkiCall, &pConference, &hCall, &hConference) == NOERROR)
      {
		ASSERT(pGkiCall->uGkiCallState == GCS_ADMITTING_CLOSE_PENDING);
        GkiFreeCall(pGkiCall);
        if (pGkiCall->bAnswerCall)
        {
          AcceptCallReject(pGkiCall->pCall, pConference, MapAdmissionRejectReason(wParam));
        }
        else
        {
          PlaceCallReject (pGkiCall->pCall, pConference, MapAdmissionRejectReason(wParam));
        }
        UnlockGkiCallAndConference(pGkiCall, pConference, hCall, hConference);
      } // if
      else
      {
        GKDBG((1, "GkiWndProc: GKI_ADM_REJECT handle not found", 0));
      }
      uGkiState = STATE_REGISTERED;
      GkiRegister();
      break;

    case STATE_ADMITTING_UNREG:
      pCallReturnInfo = (CallReturnInfo *) lParam;
      if (LockGkiCallAndConference(GKI_ADMITTING_HANDLE, &pGkiCall, &pConference, &hCall, &hConference) == NOERROR)
      {
		ASSERT(pGkiCall->uGkiCallState == GCS_ADMITTING_CLOSE_PENDING);
        GkiFreeCall(pGkiCall);
        if (pGkiCall->bAnswerCall)
        {
          AcceptCallReject(pGkiCall->pCall, pConference, MapAdmissionRejectReason(wParam));
        }
        else
        {
          PlaceCallReject (pGkiCall->pCall, pConference, MapAdmissionRejectReason(wParam));
        }
        UnlockGkiCallAndConference(pGkiCall, pConference, hCall, hConference);
      } // if
      else
      {
        GKDBG((1, "GkiWndProc: GKI_ADM_REJECT handle not found", 0));
      }
      uGkiState = STATE_REGISTERED;
      GkiUnregister();
      break;

    default:
        GKDBG((1, StateName("GkiWndProc: GKI_ADM_REJECT in state %s", uGkiState), 0));
    } // switch
    break;

  case GKIMAN_BASE + GKI_BW_CONFIRM:
    GKDBG((1, "GkiWndProc: GKI_BW_CONFIRM", 0));
    switch (uGkiState)
    {
    case STATE_REGISTERED:
      pCallReturnInfo = (CallReturnInfo *) lParam;
      if (LockGkiCallAndConference(pCallReturnInfo->hCall, &pGkiCall, &pConference, &hCall, &hConference) == NOERROR)
      {
        GKDBG((1, CallStateName("GkiWndProc: Call State = %s", pGkiCall->uGkiCallState), 0));
        pGkiCall->uBandwidthAllocated = pCallReturnInfo->bandWidth;
        switch (pGkiCall->uGkiCallState)
        {
        case GCS_ADMITTED:
          if (pGkiCall->uBandwidthUsed < pGkiCall->uBandwidthAllocated)
          {
            BandwidthShrunk(pGkiCall->pCall,
                            pConference,
                            pGkiCall->uBandwidthAllocated,
                            ((long)pGkiCall->uBandwidthAllocated) - ((long)pGkiCall->uBandwidthUsed));
          }
          break;

        case GCS_CHANGING:
          pGkiCall->uGkiCallState = GCS_ADMITTED;
          CheckPendingBandwidth(pGkiCall);
          break;

        case GCS_CHANGING_CLOSE_PENDING:
          pGkiCall->uGkiCallState = GCS_ADMITTED;
          GkiCloseCall(pGkiCall);
          break;

        default:
          GKDBG((1, CallStateName("GkiWndProc: GKI_BW_CONFIRM in call state %s", pGkiCall->uGkiCallState), 0));
        } // switch
        UnlockGkiCallAndConference(pGkiCall, pConference, hCall, hConference);
      } // if
      else
      {
        GKDBG((1, "GkiWndProc: GKI_BW_CONFIRM handle not found", 0));
      } // else
      break;

    default:
      GKDBG((1, StateName("GkiWndProc: GKI_BW_CONFIRM in GKI state %s", uGkiState), 0));
    } // switch
    break;

  case GKIMAN_BASE + GKI_BW_REJECT:
    GKDBG((1, "GkiWndProc: GKI_BW_REJECT Reason = %d", wParam));
    switch (uGkiState)
    {
    case STATE_REGISTERED:
      pCallReturnInfo = (CallReturnInfo *) lParam;
      if (LockGkiCallAndConference(pCallReturnInfo->hCall, &pGkiCall, &pConference, &hCall, &hConference) == NOERROR)
      {
        GKDBG((1, CallStateName("GkiWndProc: Call State = %s", pGkiCall->uGkiCallState), 0));
        pGkiCall->uBandwidthAllocated = pCallReturnInfo->bandWidth;
        switch (pGkiCall->uGkiCallState)
        {
        case GCS_CHANGING:
          pGkiCall->uGkiCallState = GCS_ADMITTED;
          BandwidthRejected(pGkiCall, wParam);
          if (ValidateCall(hCall) == NOERROR)
          {
            CheckPendingBandwidth(pGkiCall);
          }
          break;

        case GCS_CHANGING_CLOSE_PENDING:
          pGkiCall->uGkiCallState = GCS_ADMITTED;
          GkiCloseCall(pGkiCall);
          break;

        default:
          GKDBG((1, CallStateName("GkiWndProc: GKI_BW_REJECT in state %s", pGkiCall->uGkiCallState), 0));
        } // switch
        UnlockGkiCallAndConference(pGkiCall, pConference, hCall, hConference);
      } // if
      else
      {
        GKDBG((1, "GkiWndProc: GKI_BW_REJECT handle not found", 0));
      }
      break;

    default:
      GKDBG((1, StateName("GkiWndProc: GKI_BW_REJECT in state %s", uGkiState), 0));
    } // switch
    break;

  case GKIMAN_BASE + GKI_DISENG_CONFIRM:
    GKDBG((1, "GkiWndProc: GKI_DISENG_CONFIRM", 0));
    if (LockGkiCall((HANDLE)lParam, &pGkiCall) == NOERROR)
    {
      GKDBG((1, CallStateName("GkiWndProc: Call State = %s", pGkiCall->uGkiCallState), 0));
      switch (pGkiCall->uGkiCallState)
      {
      case GCS_DISENGAGING:
        --uPendingDisengages;
        break;

      default:
        GKDBG((1, CallStateName("GkiWndProc: GKI_DISENG_CONFIRM in call state %s", pGkiCall->uGkiCallState), 0));
      } // switch
      GkiFreeCall(pGkiCall);
      Disengage(pGkiCall->pCall);
    } // if
    else if (uPendingDisengages != 0)
    {
      --uPendingDisengages;
      if (uPendingDisengages == 0)
      {
        switch (uGkiState)
        {
        case STATE_DISENGAGING:
          uGkiState = STATE_REGISTERED;
          GkiUnregister();
          break;
        case STATE_DISENGAGING_REREG:
          uGkiState = STATE_REGISTERED;
          GkiRegister();
          break;
        } // switch
        if (pListenList && pListenList->hListen == DEFAULT_LISTEN_HANDLE)
        {
          GkiCloseListen(DEFAULT_LISTEN_HANDLE);
        }
      } // if
    } // else if
    else
    {
      GKDBG((1, "GkiWndProc: GKI_DISENG_CONFIRM handle not found", 0));
    }
    break;

  case GKIMAN_BASE + GKI_DISENG_REJECT:
    GKDBG((1, "GkiWndProc: GKI_DISENG_REJECT Reason = %d", wParam));
    if (LockGkiCall((HANDLE)lParam, &pGkiCall) == NOERROR)
    {
      GKDBG((1, CallStateName("GkiWndProc: Call State = %s", pGkiCall->uGkiCallState), 0));
      switch (pGkiCall->uGkiCallState)
      {
      case GCS_DISENGAGING:
        // Pretend we received a Disengage Confirm
        --uPendingDisengages;
        break;

      default:
        GKDBG((1, CallStateName("GkiWndProc: GKI_DISENG_REJECT in call state %s", pGkiCall->uGkiCallState), 0));
      } // switch
      GkiFreeCall(pGkiCall);
      Disengage(pGkiCall->pCall);
    } // if
    else if (uPendingDisengages != 0)
    {
      // Pretend we received a Disengage Confirm
      --uPendingDisengages;
      if (uPendingDisengages == 0)
      {
        switch (uGkiState)
        {
        case STATE_DISENGAGING:
          uGkiState = STATE_REGISTERED;
          GkiUnregister();
          break;
        case STATE_DISENGAGING_REREG:
          uGkiState = STATE_REGISTERED;
          GkiRegister();
          break;
        } // switch
        if (pListenList && pListenList->hListen == DEFAULT_LISTEN_HANDLE)
        {
          GkiCloseListen(DEFAULT_LISTEN_HANDLE);
        }
      } // if
    } // else if
    else
    {
      GKDBG((1, "GkiWndProc: GKI_DISENG_REJECT handle not found", 0));
    }
    break;

  case GKIMAN_BASE + GKI_LOCATION_CONFIRM:
    GKDBG((1, "GkiWndProc: GKI_LOCATION_CONFIRM", 0));
    break;

  case GKIMAN_BASE + GKI_LOCATION_REJECT:
    GKDBG((1, "GkiWndProc: GKI_LOCATION_REJECT Reason = %d", wParam));
    break;

  case GKIMAN_BASE + GKI_ERROR:
    GKDBG((1, GkiErrorName("GkiWndProc: GKI_ERROR %s %%d", lParam), wParam));
    switch (lParam)
    {
    case GKI_NO_RESPONSE:
	  LastGkiError = lParam;
      GkiNoResponse(hWnd);
      break;
#if 1
// TEMPORARY KLUDGE FOR WINSOCK 2 BETA 1.6 OPERATION
	case MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_WINSOCK,0xffff):
      uGkiState = STATE_REG_BYPASS;
      ApplyToAllCalls(CheckPendingOpen);
	  break;
#endif
    default:
	  LastGkiError = lParam;
      GkiUnregister();
    } // switch
    break;

  default:
    GKDBG((1, "Unknown message %d", message));
  } // switch

  GKDBG((1, StateName("GkiWndProc -> State = %s", uGkiState), 0));
  LeaveCallControlTop(0);
} // GkiWndProc()

#if defined(DBG)

DWORD g_dwH225DbgLevel = 0;
BOOL  g_fInitialized = FALSE;

void GKDbgInit() {

#define H323_REGKEY_ROOT \
    TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\H323TSP")

#define H323_REGVAL_DEBUGLEVEL \
    TEXT("DebugLevel")

#define H323_REGVAL_H225DEBUGLEVEL \
    TEXT("H225DebugLevel")

    HKEY hKey;
    LONG lStatus;
    DWORD dwValue;
    DWORD dwValueSize;
    DWORD dwValueType;
    LPSTR pszValue;
    LPSTR pszKey = H323_REGKEY_ROOT;

    // only call this once
    g_fInitialized = TRUE;

    // open registry subkey
    lStatus = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                pszKey,
                0,
                KEY_READ,
                &hKey
                );

    // validate return code
    if (lStatus != ERROR_SUCCESS) {
        return; // bail...
    }
    
    // initialize values
    dwValueType = REG_DWORD;
    dwValueSize = sizeof(DWORD);

    // retrieve ras debug level
    pszValue = H323_REGVAL_H225DEBUGLEVEL;

    // query for registry value
    lStatus = RegQueryValueEx(
                hKey,
                pszValue,
                NULL,
                &dwValueType,
                (LPBYTE)&dwValue,
                &dwValueSize
                );                    

    // validate return code
    if (lStatus != ERROR_SUCCESS) {

        // initialize values
        dwValueType = REG_DWORD;
        dwValueSize = sizeof(DWORD);

        // retrieve tsp debug level
        pszValue = H323_REGVAL_DEBUGLEVEL;

        // query for registry value
        lStatus = RegQueryValueEx(
                    hKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (LPBYTE)&dwValue,
                    &dwValueSize
                    );
    }

    // validate return code
    if (lStatus == ERROR_SUCCESS) {

        // update debug level
        g_dwH225DbgLevel = dwValue;
    }

    // close key
    RegCloseKey(hKey);
}

void GKDbgPrint(DWORD dwLevel,

#ifdef UNICODE_TRACE
				LPTSTR pszFormat,
#else
				LPSTR pszFormat,
#endif               
                ...)
{
#define DEBUG_FORMAT_HEADER     "H225 "
#define DEBUG_FORMAT_TIMESTAMP  "[%02u:%02u:%02u.%03u"
#define DEBUG_FORMAT_THREADID   ",tid=%x] "

#define MAXDBG_STRLEN        512

    va_list Args;
    SYSTEMTIME SystemTime;
    char szDebugMessage[MAXDBG_STRLEN+1];
    int nLengthRemaining;
    int nLength = 0;

    // make sure initialized
    if (g_fInitialized == FALSE) {
        GKDbgInit();
    }

    // validate debug log level
    if (dwLevel > g_dwH225DbgLevel) {
        return; // bail...
    }

    // retrieve local time
    GetLocalTime(&SystemTime);

    // add component header to the debug message
    nLength += sprintf(&szDebugMessage[nLength],
                       DEBUG_FORMAT_HEADER
                       );

    // add timestamp to the debug message
    nLength += sprintf(&szDebugMessage[nLength],
                       DEBUG_FORMAT_TIMESTAMP,
                       SystemTime.wHour,
                       SystemTime.wMinute,
                       SystemTime.wSecond,
                       SystemTime.wMilliseconds
                       );

    // add thread id to the debug message
    nLength += sprintf(&szDebugMessage[nLength],
                       DEBUG_FORMAT_THREADID,
                       GetCurrentThreadId()
                       );

    // point at first argument
    va_start(Args, pszFormat);

    // determine number of bytes left in buffer
    nLengthRemaining = sizeof(szDebugMessage) - nLength;

    // add user specified debug message
    _vsnprintf(&szDebugMessage[nLength],
               nLengthRemaining,
               pszFormat,
               Args
               );

    // release pointer
    va_end(Args);

    // output message to specified sink
    OutputDebugString(szDebugMessage);
    OutputDebugString("\n");
}

#endif

#else  // GATEKEEPER
static char ch;	// Kludge around warning C4206: nonstandard extension used : translation unit is empty
#endif // GATEKEEPER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\callcont\confman.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/confman.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.39  $
 *	$Date:   31 Jan 1997 13:44:26  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

// Call types must be bit maps
#define ENQUEUED_CALL		0x01
#define PLACED_CALL			0x02
#define ESTABLISHED_CALL	0x04
#define VIRTUAL_CALL		0x08
#define REAL_CALLS			(ENQUEUED_CALL | PLACED_CALL | ESTABLISHED_CALL)
#define ALL_CALLS			(REAL_CALLS | VIRTUAL_CALL)

HRESULT InitConferenceManager();

HRESULT DeInitConferenceManager();

HRESULT AllocateTerminalNumber(		PCONFERENCE				pConference, 
									H245_TERMINAL_LABEL_T	*pH245TerminalLabel);

HRESULT FreeTerminalNumber(			PCONFERENCE				pConference,
									BYTE					bTerminalNumber);

HRESULT AllocateChannelNumber(		PCONFERENCE				pConference, 
									WORD					*pwChannelNumber);

HRESULT FreeChannelNumber(			PCONFERENCE				pConference,
									WORD					wChannelNumber);

HRESULT AllocAndLockConference(		PCC_HCONFERENCE			phConference,
									PCC_CONFERENCEID		pConferenceID,
									BOOL					bMultipointCapable,
									BOOL					bForceMultipointController,
									PCC_TERMCAPLIST			pLocalTermCapList,
									PCC_TERMCAPDESCRIPTORS	pLocalTermCapDescriptors,
									PCC_VENDORINFO			pVendorInfo,
									PCC_OCTETSTRING			pTerminalID,
									DWORD					dwConferenceToken,
									CC_SESSIONTABLE_CONSTRUCTOR SessionTableConstructor,
									CC_TERMCAP_CONSTRUCTOR	TermCapConstructor,
									CC_CONFERENCE_CALLBACK	ConferenceCallback,
									PPCONFERENCE			ppConference);

HRESULT RemoveCallFromConference(	PCALL					pCall,
									PCONFERENCE				pConference);

HRESULT RemoveEnqueuedCallFromConference(
									PCONFERENCE				pConference,
									PCC_HCALL				phCall);

HRESULT RemoveChannelFromConference(PCHANNEL				pChannel,
									PCONFERENCE				pConference);

HRESULT AddEnqueuedCallToConference(PCALL					pCall,
									PCONFERENCE				pConference);

HRESULT AddPlacedCallToConference(	PCALL					pCall,
									PCONFERENCE				pConference);

HRESULT AddEstablishedCallToConference(
									PCALL					pCall,
									PCONFERENCE				pConference);

HRESULT AddVirtualCallToConference(	PCALL					pCall,
									PCONFERENCE				pConference);

HRESULT AddChannelToConference(		PCHANNEL				pChannel,
									PCONFERENCE				pConference);

HRESULT FreeConference(				PCONFERENCE				pConference);

HRESULT LockConference(				CC_HCONFERENCE			hConference,
									PPCONFERENCE			ppConference);

HRESULT LockConferenceEx(			CC_HCONFERENCE			hConference,
									PPCONFERENCE			ppConference,
									TRISTATE				tsDeferredDelete);

HRESULT ValidateConference(			CC_HCONFERENCE			hConference);

HRESULT LockConferenceID(			PCC_CONFERENCEID		pConferenceID,
									PPCONFERENCE			ppConference);

HRESULT FindChannelInConference(	WORD					wChannel,
									BOOL					bLocalChannel,
									BYTE					bChannelType,
									CC_HCALL				hCall,
									PCC_HCHANNEL			phChannel,
									PCONFERENCE				pConference);

HRESULT EnumerateConferences(		PWORD					pwNumConferences,
									CC_HCONFERENCE			ConferenceList[]);

HRESULT EnumerateCallsInConference(	WORD					*pwNumCalls,
									PCC_HCALL				pCallList[],
									PCONFERENCE				pConference,
									BYTE					bCallType);

HRESULT EnumerateChannelsInConference(
									WORD					*pwNumChannels,
									PCC_HCHANNEL			pChannelList[],
									PCONFERENCE				pConference,
									BYTE					bChannelType);

HRESULT EnumerateTerminalLabelsInConference(
									WORD					*pwNumTerminalLabels,
									H245_TERMINAL_LABEL_T   *pH245TerminalLabelList[],
									PCONFERENCE				pConference);

HRESULT UnlockConference(			PCONFERENCE				pConference);

HRESULT AsynchronousDestroyConference(
									CC_HCONFERENCE			hConference,
									BOOL					bAutoAccept);

HRESULT FindPeerParticipantInfo(	H245_TERMINAL_LABEL_T	H245TerminalLabel,
									PCONFERENCE				pConference,
									BYTE					bCallType,
									PCALL					*ppCall);

HRESULT ReInitializeConference(		PCONFERENCE				pConference);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\callcont\gkiman.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/gkiman.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1996 Intel Corporation.
 *
 *	$Revision:   1.19.1.0  $
 *	$Date:   23 Jun 1997 15:58:04  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *
 *	Notes:
 *
 ***************************************************************************/

#ifdef GATEKEEPER

#ifndef GKIMAN_H
#define GKIMAN_H

typedef enum _CHANNELTYPE
{
  TX,
  RX
} CHANNELTYPE;

typedef struct _BWREQ
{
  struct _BWREQ *   pNext;
  unsigned int      uChannelBandwidth;
  DWORD             hChannel;
  CHANNELTYPE       Type;
} BWREQ, *PBWREQ;

typedef enum _CALLTYPE
{
  POINT_TO_POINT  = 1,
  ONE_TO_MANY,
  MANY_TO_ONE,
  MANY_TO_MANY
} CALLTYPE;

typedef struct _GKICALL
{
  struct _GKICALL * pNext;
  struct _BWREQ *   pBwReqHead;
  struct _BWREQ *   pBwReqTail;
  unsigned int      uGkiCallState;
#define GCS_START                   0
#define GCS_WAITING                 1
#define GCS_ADMITTING               2
#define GCS_ADMITTING_CLOSE_PENDING 3
#define GCS_ADMITTED                4
#define GCS_CHANGING                5
#define GCS_CHANGING_CLOSE_PENDING  6
#define GCS_DISENGAGING             7
  void *            pCall;
  CALLTYPE          CallType;
  unsigned int      uBandwidthRequested;
  unsigned int      uBandwidthAllocated;
  unsigned int      uBandwidthUsed;
  unsigned char     *pConferenceId;
  BOOL              bConferenceIdPresent;
  BOOL              bActiveMC;
  BOOL              bAnswerCall;
  BOOL              bGatekeeperRouted;
  HANDLE            hGkiCall;
  DWORD             hCall;
  DWORD             dwSrcCallSignalIpAddress;
  unsigned short    wSrcCallSignalPort;
  DWORD             dwIpAddress;
  unsigned short    wPort;
  unsigned short    usCallModelChoice;
  unsigned short    usCallTypeChoice;
  unsigned short    usCRV;
  PCC_ALIASNAMES    pCalleeAliasNames;
  PCC_ALIASNAMES    pCalleeExtraAliasNames;
} GKICALL, *PGKICALL, **PPGKICALL;

HRESULT GkiOpenListen  (DWORD hListen, PCC_ALIASNAMES pAliasNames, DWORD dwAddr, WORD wPort);
HRESULT GkiCloseListen (DWORD hListen);
HRESULT GkiOpenCall    (PGKICALL pGkiCall, void *pConference);
HRESULT GkiCloseCall   (PGKICALL pGkiCall);
HRESULT GkiFreeCall    (PGKICALL pGkiCall);
HRESULT GkiOpenChannel (PGKICALL pGkiCall, unsigned uChannelBandwidth, DWORD hChannel, CHANNELTYPE Type);
HRESULT GkiCloseChannel(PGKICALL pGkiCall, unsigned uChannelBandwidth, DWORD hChannel);

#endif // GKIMAN_H

#endif // GATEKEEPER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\callcont\hangman.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/hangman.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.4  $
 *	$Date:   Aug 12 1996 09:40:22  $
 *	$Author:   mandrews  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/


HRESULT InitHangupManager();

HRESULT DeInitHangupManager();

HRESULT AllocAndLockHangup(			PHHANGUP				phHangup,
									CC_HCONFERENCE			hConference,
									DWORD					dwUserToken,
									PPHANGUP				ppHangup);

HRESULT FreeHangup(					PHANGUP					pHangup);

HRESULT LockHangup(					HHANGUP					hHangup,
									PPHANGUP				ppHangup);

HRESULT ValidateHangup(				HHANGUP					hHangup);

HRESULT UnlockHangup(				PHANGUP					pHangup);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\callcont\hangman.c ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/Hangman.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.16  $
 *	$Date:   22 Jan 1997 14:55:52  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#pragma warning ( disable : 4115 4201 4214 )
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#pragma warning ( default : 4115 4201 4214 )
#include "apierror.h"
#include "incommon.h"
#include "callcont.h"
#include "q931.h"
#include "ccmain.h"
#include "ccutils.h"
#include "hangman.h"


static BOOL		bHangupInited = FALSE;

static struct {
	PHANGUP				pHead;
	LOCK				Lock;
} HangupTable;

static struct {
	HHANGUP				hHangup;
	LOCK				Lock;
} HangupHandle;


HRESULT InitHangupManager()
{
	ASSERT(bHangupInited == FALSE);

	HangupTable.pHead = NULL;
	InitializeLock(&HangupTable.Lock);

	HangupHandle.hHangup = CC_INVALID_HANDLE + 1;
	InitializeLock(&HangupHandle.Lock);

	bHangupInited = TRUE;
	return CC_OK;
}



HRESULT DeInitHangupManager()
{
PHANGUP		pHangup;
PHANGUP		pNextHangup;

	if (bHangupInited == FALSE)
		return CC_OK;

	pHangup = HangupTable.pHead;
	while (pHangup != NULL) {
		AcquireLock(&pHangup->Lock);
		pNextHangup = pHangup->pNextInTable;
		FreeHangup(pHangup);
		pHangup = pNextHangup;
	}

	DeleteLock(&HangupHandle.Lock);
	DeleteLock(&HangupTable.Lock);
	bHangupInited = FALSE;
	return CC_OK;
}



HRESULT _AddHangupToTable(			PHANGUP					pHangup)
{
	ASSERT(pHangup != NULL);
	ASSERT(pHangup->hHangup != CC_INVALID_HANDLE);
	ASSERT(pHangup->bInTable == FALSE);

	AcquireLock(&HangupTable.Lock);

	pHangup->pNextInTable = HangupTable.pHead;
	pHangup->pPrevInTable = NULL;
	if (HangupTable.pHead != NULL)
		HangupTable.pHead->pPrevInTable = pHangup;
	HangupTable.pHead = pHangup;

	pHangup->bInTable = TRUE;

	RelinquishLock(&HangupTable.Lock);
	return CC_OK;
}



HRESULT _RemoveHangupFromTable(		PHANGUP					pHangup)
{
HHANGUP		hHangup;
BOOL		bTimedOut;

	ASSERT(pHangup != NULL);
	ASSERT(pHangup->bInTable == TRUE);

	// Caller must have a lock on the hangup object;
	// in order to avoid deadlock, we must:
	//   1. unlock the hangup object,
	//   2. lock the HangupTable,
	//   3. locate the hangup object in the HangupTable (note that
	//      after step 2, the hangup object may be deleted from the
	//      HangupTable by another thread),
	//   4. lock the hangup object (someone else may have the lock)
	//   5. remove the hangup object from the HangupTable,
	//   6. unlock the HangupTable
	//
	// The caller can now safely unlock and destroy the hangup object,
	// since no other thread will be able to find the object (its been
	// removed from the HangupTable), and therefore no other thread will
	// be able to lock it.

	// Save the hangup handle; its the only way to look up
	// the hangup object in the HangupTable. Note that we
	// can't use pHangup to find the hangup object, since
	// pHangup may be free'd up, and another hangup object
	// allocated at the same address
	hHangup = pHangup->hHangup;

	// step 1
	RelinquishLock(&pHangup->Lock);

step2:
	// step 2
	AcquireLock(&HangupTable.Lock);

	// step 3
	pHangup = HangupTable.pHead;
	while ((pHangup != NULL) && (pHangup->hHangup != hHangup))
		pHangup = pHangup->pNextInTable;

	if (pHangup != NULL) {
		// step 4
		AcquireTimedLock(&pHangup->Lock,10,&bTimedOut);
		if (bTimedOut) {
			RelinquishLock(&HangupTable.Lock);
			Sleep(0);
			goto step2;
		}
		// step 5
		if (pHangup->pPrevInTable == NULL)
			HangupTable.pHead = pHangup->pNextInTable;
		else
			pHangup->pPrevInTable->pNextInTable = pHangup->pNextInTable;

		if (pHangup->pNextInTable != NULL)
			pHangup->pNextInTable->pPrevInTable = pHangup->pPrevInTable;

		pHangup->pNextInTable = NULL;
		pHangup->pPrevInTable = NULL;
		pHangup->bInTable = FALSE;
	}

	// step 6
	RelinquishLock(&HangupTable.Lock);

	if (pHangup == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT _MakeHangupHandle(			PHHANGUP				phHangup)
{
	AcquireLock(&HangupHandle.Lock);
	*phHangup = HangupHandle.hHangup++;
	RelinquishLock(&HangupHandle.Lock);
	return CC_OK;
}



HRESULT AllocAndLockHangup(			PHHANGUP				phHangup,
									CC_HCONFERENCE			hConference,
									DWORD					dwUserToken,
									PPHANGUP				ppHangup)
{
HRESULT		status;
	
	ASSERT(bHangupInited == TRUE);

	// all parameters should have been validated by the caller
	ASSERT(phHangup != NULL);
	ASSERT(hConference != CC_INVALID_HANDLE);
	ASSERT(ppHangup != NULL);

	// set phHangup now, in case we encounter an error
	*phHangup = CC_INVALID_HANDLE;

	*ppHangup = (PHANGUP)Malloc(sizeof(HANGUP));
	if (*ppHangup == NULL)
		return CC_NO_MEMORY;

	(*ppHangup)->bInTable = FALSE;
	status = _MakeHangupHandle(&(*ppHangup)->hHangup);
	if (status != CC_OK) {
		Free(*ppHangup);
		return status;
	}
	
	(*ppHangup)->hConference = hConference;
	(*ppHangup)->wNumCalls = 0;
	(*ppHangup)->dwUserToken = dwUserToken;
	(*ppHangup)->pNextInTable = NULL;
	(*ppHangup)->pPrevInTable = NULL;

	InitializeLock(&(*ppHangup)->Lock);
	AcquireLock(&(*ppHangup)->Lock);

	*phHangup = (*ppHangup)->hHangup;

	// add the Hangup to the Hangup table
	status = _AddHangupToTable(*ppHangup);
	if (status != CC_OK)
		FreeHangup(*ppHangup);
	
	return status;
}



// Caller must have a lock on the Hangup object
HRESULT FreeHangup(					PHANGUP				pHangup)
{
HHANGUP		hHangup;

	ASSERT(pHangup != NULL);

	// caller must have a lock on the Hangup object,
	// so there's no need to re-lock it
	
	hHangup = pHangup->hHangup;

	if (pHangup->bInTable == TRUE)
		if (_RemoveHangupFromTable(pHangup) == CC_BAD_PARAM)
			// the Hangup object was deleted by another thread,
			// so just return CC_OK
			return CC_OK;

	// Since the hangup object has been removed from the HangupTable,
	// no other thread will be able to find the hangup object and obtain
	// a lock, so its safe to unlock the hangup object and delete it here
	RelinquishLock(&pHangup->Lock);
	DeleteLock(&pHangup->Lock);
	Free(pHangup);
	return CC_OK;
}



HRESULT LockHangup(					HHANGUP					hHangup,
									PPHANGUP				ppHangup)
{
BOOL	bTimedOut;

	ASSERT(hHangup != CC_INVALID_HANDLE);
	ASSERT(ppHangup != NULL);

step1:
	AcquireLock(&HangupTable.Lock);

	*ppHangup = HangupTable.pHead;
	while ((*ppHangup != NULL) && ((*ppHangup)->hHangup != hHangup))
		*ppHangup = (*ppHangup)->pNextInTable;

	if (*ppHangup != NULL) {
		AcquireTimedLock(&(*ppHangup)->Lock,10,&bTimedOut);
		if (bTimedOut) {
			RelinquishLock(&HangupTable.Lock);
			Sleep(0);
			goto step1;
		}
	}

	RelinquishLock(&HangupTable.Lock);

	if (*ppHangup == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT ValidateHangup(				HHANGUP					hHangup)
{
PHANGUP	pHangup;

	ASSERT(hHangup != CC_INVALID_HANDLE);

	AcquireLock(&HangupTable.Lock);

	pHangup = HangupTable.pHead;
	while ((pHangup != NULL) && (pHangup->hHangup != hHangup))
		pHangup = pHangup->pNextInTable;

	RelinquishLock(&HangupTable.Lock);

	if (pHangup == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT UnlockHangup(				PHANGUP					pHangup)
{
	ASSERT(pHangup != NULL);

	RelinquishLock(&pHangup->Lock);
	return CC_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\callcont\h245man.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/h245man.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.13  $
 *	$Date:   Aug 27 1996 11:07:30  $
 *	$Author:   mandrews  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

HRESULT InitH245Manager();

HRESULT DeInitH245Manager();

HRESULT MakeH245PhysicalID(			DWORD					*pdwH245PhysicalID);

HRESULT H245Callback(				H245_CONF_IND_T			*pH245ConfIndData,
									void					*pMisc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\callcont\listman.c ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/Listman.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.22  $
 *	$Date:   22 Jan 1997 14:55:52  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#pragma warning ( disable : 4115 4201 4214 )
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#pragma warning ( default : 4115 4201 4214 )
#include "apierror.h"
#include "incommon.h"
#include "callcont.h"
#include "q931.h"
#include "ccmain.h"
#include "ccutils.h"
#include "listman.h"


static BOOL		bListenInited = FALSE;

static struct {
	PLISTEN				pHead;
	LOCK				Lock;
} ListenTable;

static struct {
	CC_HLISTEN			hListen;
	LOCK				Lock;
} ListenHandle;


HRESULT InitListenManager()
{
	ASSERT(bListenInited == FALSE);

	ListenTable.pHead = NULL;
	InitializeLock(&ListenTable.Lock);

	ListenHandle.hListen = CC_INVALID_HANDLE + 1;
	InitializeLock(&ListenHandle.Lock);

	bListenInited = TRUE;
	return CC_OK;
}



HRESULT DeInitListenManager()
{
PLISTEN		pListen;
PLISTEN		pNextListen;

	if (bListenInited == FALSE)
		return CC_OK;

	pListen = ListenTable.pHead;
	while (pListen != NULL) {
		AcquireLock(&pListen->Lock);
		pNextListen = pListen->pNextInTable;
		FreeListen(pListen);
		pListen = pNextListen;
	}

	DeleteLock(&ListenHandle.Lock);
	DeleteLock(&ListenTable.Lock);
	bListenInited = FALSE;
	return CC_OK;
}



HRESULT _AddListenToTable(			PLISTEN					pListen)
{
	ASSERT(pListen != NULL);
	ASSERT(pListen->hListen != CC_INVALID_HANDLE);
	ASSERT(pListen->bInTable == FALSE);

	AcquireLock(&ListenTable.Lock);

	pListen->pNextInTable = ListenTable.pHead;
	pListen->pPrevInTable = NULL;
	if (ListenTable.pHead != NULL)
		ListenTable.pHead->pPrevInTable = pListen;
	ListenTable.pHead = pListen;

	pListen->bInTable = TRUE;

	RelinquishLock(&ListenTable.Lock);
	return CC_OK;
}



HRESULT _RemoveListenFromTable(		PLISTEN					pListen)
{
CC_HLISTEN		hListen;
BOOL			bTimedOut;

	ASSERT(pListen != NULL);
	ASSERT(pListen->bInTable == TRUE);

	// Caller must have a lock on the listen object;
	// in order to avoid deadlock, we must:
	//   1. unlock the listen object,
	//   2. lock the ListenTable,
	//   3. locate the listen object in the ListenTable (note that
	//      after step 2, the listen object may be deleted from the
	//      ListenTable by another thread),
	//   4. lock the listen object (someone else may have the lock)
	//   5. remove the listen object from the ListenTable,
	//   6. unlock the ListenTable
	//
	// The caller can now safely unlock and destroy the listen object,
	// since no other thread will be able to find the object (its been
	// removed from the ListenTable), and therefore no other thread will
	// be able to lock it.

	// Save the listen handle; its the only way to look up
	// the listen object in the ListenTable. Note that we
	// can't use pListen to find the listen object, since
	// pListen may be free'd up, and another listen object
	// allocated at the same address
	hListen = pListen->hListen;

	// step 1
	RelinquishLock(&pListen->Lock);

step2:
	// step 2
	AcquireLock(&ListenTable.Lock);

	// step 3
	pListen = ListenTable.pHead;
	while ((pListen != NULL) && (pListen->hListen != hListen))
		pListen = pListen->pNextInTable;

	if (pListen != NULL) {
		// step 4
		AcquireTimedLock(&pListen->Lock,10,&bTimedOut);
		if (bTimedOut) {
			RelinquishLock(&ListenTable.Lock);
			Sleep(0);
			goto step2;
		}
		// step 5
		if (pListen->pPrevInTable == NULL)
			ListenTable.pHead = pListen->pNextInTable;
		else
			pListen->pPrevInTable->pNextInTable = pListen->pNextInTable;

		if (pListen->pNextInTable != NULL)
			pListen->pNextInTable->pPrevInTable = pListen->pPrevInTable;

		pListen->pNextInTable = NULL;
		pListen->pPrevInTable = NULL;
		pListen->bInTable = FALSE;
	}

	// step 6
	RelinquishLock(&ListenTable.Lock);

	if (pListen == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT _MakeListenHandle(			PCC_HLISTEN				phListen)
{
	AcquireLock(&ListenHandle.Lock);
	*phListen = ListenHandle.hListen++;
	RelinquishLock(&ListenHandle.Lock);
	return CC_OK;
}



HRESULT AllocAndLockListen(			PCC_HLISTEN				phListen,
									PCC_ADDR				pListenAddr,
									HQ931LISTEN				hQ931Listen,
									PCC_ALIASNAMES			pLocalAliasNames,
									DWORD					dwListenToken,
									CC_LISTEN_CALLBACK		ListenCallback,
									PPLISTEN				ppListen)
{
HRESULT		status;
	
	ASSERT(bListenInited == TRUE);

	// all parameters should have been validated by the caller
	ASSERT(phListen != NULL);
	ASSERT(pListenAddr != NULL);
	ASSERT(ListenCallback != NULL);
	ASSERT(ppListen != NULL);

	// set phListen now, in case we encounter an error
	*phListen = CC_INVALID_HANDLE;

	*ppListen = (PLISTEN)Malloc(sizeof(LISTEN));
	if (*ppListen == NULL)
		return CC_NO_MEMORY;

	(*ppListen)->bInTable = FALSE;
	status = _MakeListenHandle(&(*ppListen)->hListen);
	if (status != CC_OK) {
		Free(*ppListen);
		return status;
	}
	
	// make a local copy of the ListenAddr
	(*ppListen)->ListenAddr = *pListenAddr;
	(*ppListen)->hQ931Listen = hQ931Listen;
	(*ppListen)->dwListenToken = dwListenToken;
	(*ppListen)->pLocalAliasNames = NULL;
	(*ppListen)->ListenCallback = ListenCallback;
	(*ppListen)->pNextInTable = NULL;
	(*ppListen)->pPrevInTable = NULL;
	(*ppListen)->pLocalAliasNames = NULL;

	InitializeLock(&(*ppListen)->Lock);
	AcquireLock(&(*ppListen)->Lock);

	*phListen = (*ppListen)->hListen;

	// make a local copy of the local alias names
	status = Q931CopyAliasNames(&(*ppListen)->pLocalAliasNames, pLocalAliasNames);
	if (status != CS_OK) {
		FreeListen(*ppListen);
		*phListen = CC_INVALID_HANDLE;
		return status;
	}

	// add the Listen to the Listen table
	status = _AddListenToTable(*ppListen);
	if (status != CC_OK)
		FreeListen(*ppListen);
	
	return status;
}



// Caller must have a lock on the Listen object
HRESULT FreeListen(					PLISTEN				pListen)
{
CC_HLISTEN		hListen;

	ASSERT(pListen != NULL);

	// caller must have a lock on the Listen object,
	// so there's no need to re-lock it

	hListen = pListen->hListen;

	if (pListen->bInTable == TRUE)
		if (_RemoveListenFromTable(pListen) == CC_BAD_PARAM)
			// the Listen object was deleted by another thread,
			// so just return CC_OK
			return CC_OK;

	if (pListen->pLocalAliasNames != NULL)
		Q931FreeAliasNames(pListen->pLocalAliasNames);
	
	// Since the listen object has been removed from the ListenTable,
	// no other thread will be able to find the listen object and obtain
	// a lock, so its safe to unlock the listen object and delete it here
	RelinquishLock(&pListen->Lock);
	DeleteLock(&pListen->Lock);
	Free(pListen);
	return CC_OK;
}



HRESULT LockListen(					CC_HLISTEN				hListen,
									PPLISTEN				ppListen)
{
BOOL	bTimedOut;

	ASSERT(hListen != CC_INVALID_HANDLE);
	ASSERT(ppListen != NULL);

step1:
	AcquireLock(&ListenTable.Lock);

	*ppListen = ListenTable.pHead;
	while ((*ppListen != NULL) && ((*ppListen)->hListen != hListen))
		*ppListen = (*ppListen)->pNextInTable;

	if (*ppListen != NULL) {
		AcquireTimedLock(&(*ppListen)->Lock,10,&bTimedOut);
		if (bTimedOut) {
			RelinquishLock(&ListenTable.Lock);
			Sleep(0);
			goto step1;
		}
	}

	RelinquishLock(&ListenTable.Lock);

	if (*ppListen == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT ValidateListen(				CC_HLISTEN				hListen)
{
PLISTEN	pListen;

	ASSERT(hListen != CC_INVALID_HANDLE);

	AcquireLock(&ListenTable.Lock);

	pListen = ListenTable.pHead;
	while ((pListen != NULL) && (pListen->hListen != hListen))
		pListen = pListen->pNextInTable;

	RelinquishLock(&ListenTable.Lock);

	if (pListen == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT UnlockListen(				PLISTEN					pListen)
{
	ASSERT(pListen != NULL);

	RelinquishLock(&pListen->Lock);
	return CC_OK;
}



HRESULT GetLastListenAddress(		PCC_ADDR				pListenAddr)
{
HRESULT	status;
PLISTEN	pListen;
PLISTEN	pLastListen;

	ASSERT(pListenAddr != NULL);

	AcquireLock(&ListenTable.Lock);

	pListen = ListenTable.pHead;
	pLastListen = pListen;
	while (pListen != NULL) {
		if (pLastListen->hListen < pListen->hListen)
			pLastListen = pListen;
		pListen = pListen->pNextInTable;
	}

	if (pLastListen == NULL)
		status = CC_BAD_PARAM;
	else {
		status = CC_OK;
		*pListenAddr = pLastListen->ListenAddr;
	}	

	RelinquishLock(&ListenTable.Lock);
	return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\callcont\h245man.c ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/h245man.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.225.1.1  $
 *	$Date:   23 Jun 1997 15:58:08  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#pragma warning ( disable : 4057 4100 4115 4201 4214)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#pragma warning ( default : 4115 4201 4214)
#include "apierror.h"
#include "incommon.h"
#include "callcont.h"
#include "q931.h"
#include "ccmain.h"
#include "listman.h"
#include "q931man.h"
#include "userman.h"
#include "callman.h"
#include "confman.h"
#include "h245man.h"
#include "chanman.h"
#include "hangman.h"
#include "ccutils.h"
#include "linkapi.h"


extern CALL_CONTROL_STATE	CallControlState;
extern THREADCOUNT			ThreadCount;

static BOOL		bH245ManagerInited = FALSE;

static struct {
	DWORD				dwPhysicalID;
	LOCK				Lock;
} PhysicalID;



HRESULT InitH245Manager()
{
	ASSERT(bH245ManagerInited == FALSE);

	// Note -- don't use a physical ID of 0; the physical ID gets mapped
	// to an H245 instance of the same value, and an H245 instance of
	// 0 is invalid
	PhysicalID.dwPhysicalID = 1;
	InitializeLock(&PhysicalID.Lock);

	bH245ManagerInited = TRUE;
	return CC_OK;
}



HRESULT DeInitH245Manager()
{
	if (bH245ManagerInited == FALSE)
		return CC_OK;

	DeleteLock(&PhysicalID.Lock);
	bH245ManagerInited = FALSE;
	return CC_OK;
}



HRESULT MakeH245PhysicalID(			DWORD					*pdwH245PhysicalID)
{
	AcquireLock(&PhysicalID.Lock);
	*pdwH245PhysicalID = PhysicalID.dwPhysicalID++;
	RelinquishLock(&PhysicalID.Lock);
	return CC_OK;
}



HRESULT _ConstructTermCapList(		PCC_TERMCAPLIST			*ppTermCapList,
									PCC_TERMCAP				*ppH2250MuxCap,
									PCC_TERMCAPDESCRIPTORS	*ppTermCapDescriptors,
									PCALL					pCall)
{
#define MAX_TERM_CAPS		257
#define MAX_TERM_CAP_DESC	255
H245_TOTCAP_T *				pTermCapArray[MAX_TERM_CAPS];
H245_TOTCAPDESC_T *			pTermCapDescriptorArray[MAX_TERM_CAP_DESC];
unsigned long				CapArrayLength;
unsigned long				CapDescriptorArrayLength;
unsigned long				i, j;
HRESULT						status;

	ASSERT(ppTermCapList != NULL);
	ASSERT(*ppTermCapList == NULL);
	ASSERT(ppH2250MuxCap != NULL);
	ASSERT(*ppH2250MuxCap == NULL);
	ASSERT(ppTermCapDescriptors != NULL);
	ASSERT(*ppTermCapDescriptors == NULL);
	ASSERT(pCall != NULL);

	CapArrayLength = MAX_TERM_CAPS;
	CapDescriptorArrayLength = MAX_TERM_CAP_DESC;

	status = H245GetCaps(pCall->H245Instance,
		                 H245_CAPDIR_RMTRXTX,
					     H245_DATA_DONTCARE,
					     H245_CLIENT_DONTCARE,
					     pTermCapArray,
					     &CapArrayLength,
					     pTermCapDescriptorArray,
					     &CapDescriptorArrayLength);
	if (status != H245_ERROR_OK) {
		*ppTermCapList = NULL;
		*ppH2250MuxCap = NULL;
		*ppTermCapDescriptors = NULL;
		return status;
	}

	// Check the term cap list to see if an H.225.0 mux capability is present;
	// this capability is treated as a special case
	*ppH2250MuxCap = NULL;
	for (i = 0; i < CapArrayLength; i++) {
		ASSERT(pTermCapArray[i] != NULL);
		if (pTermCapArray[i]->CapId == 0) {
			*ppH2250MuxCap = pTermCapArray[i];
			--CapArrayLength;
			for (j = i; j < CapArrayLength; j++)
				pTermCapArray[j] = pTermCapArray[j+1];
			break;
		}
	}

	if (CapArrayLength == 0)
		*ppTermCapList = NULL;
	else {
		*ppTermCapList = (PCC_TERMCAPLIST)Malloc(sizeof(CC_TERMCAPLIST));
		if (*ppTermCapList == NULL) {
			for (i = 0; i < CapArrayLength; i++)
				H245FreeCap(pTermCapArray[i]);
			if (*ppH2250MuxCap != NULL)
				H245FreeCap(*ppH2250MuxCap);
			for (i = 0; i < CapDescriptorArrayLength; i++)
				H245FreeCapDescriptor(pTermCapDescriptorArray[i]);
			return CC_NO_MEMORY;
		}

		(*ppTermCapList)->wLength = (WORD)CapArrayLength;
		(*ppTermCapList)->pTermCapArray =
			(H245_TOTCAP_T **)Malloc(sizeof(H245_TOTCAP_T *) * CapArrayLength);
		if ((*ppTermCapList)->pTermCapArray == NULL) {
			Free(*ppTermCapList);
			for (i = 0; i < CapArrayLength; i++)
				H245FreeCap(pTermCapArray[i]);
			if (*ppH2250MuxCap != NULL)
				H245FreeCap(*ppH2250MuxCap);
			for (i = 0; i < CapDescriptorArrayLength; i++)
				H245FreeCapDescriptor(pTermCapDescriptorArray[i]);
			*ppTermCapList = NULL;
			*ppH2250MuxCap = NULL;
			*ppTermCapDescriptors = NULL;
			return CC_NO_MEMORY;
		}

		for (i = 0; i < CapArrayLength; i++)
			(*ppTermCapList)->pTermCapArray[i] = pTermCapArray[i];
	}

	if (CapDescriptorArrayLength == 0)
		*ppTermCapDescriptors = NULL;
	else {
		*ppTermCapDescriptors = (PCC_TERMCAPDESCRIPTORS)Malloc(sizeof(CC_TERMCAPDESCRIPTORS));
		if (*ppTermCapDescriptors == NULL) {
			for (i = 0; i < CapArrayLength; i++)
				H245FreeCap(pTermCapArray[i]);
			if (*ppH2250MuxCap != NULL)
				H245FreeCap(*ppH2250MuxCap);
			for (i = 0; i < CapDescriptorArrayLength; i++)
				H245FreeCapDescriptor(pTermCapDescriptorArray[i]);
			if (*ppTermCapList != NULL) {
				Free((*ppTermCapList)->pTermCapArray);
				Free(*ppTermCapList);
			}
			*ppTermCapList = NULL;
			*ppH2250MuxCap = NULL;
			*ppTermCapDescriptors = NULL;
			return CC_NO_MEMORY;
		}

		(*ppTermCapDescriptors)->wLength = (WORD)CapDescriptorArrayLength;
		(*ppTermCapDescriptors)->pTermCapDescriptorArray =
			(H245_TOTCAPDESC_T **)Malloc(sizeof(H245_TOTCAPDESC_T *) * CapDescriptorArrayLength);
		if ((*ppTermCapDescriptors)->pTermCapDescriptorArray == NULL) {
			for (i = 0; i < CapArrayLength; i++)
				H245FreeCap(pTermCapArray[i]);
			if (*ppH2250MuxCap != NULL)
				H245FreeCap(*ppH2250MuxCap);
			for (i = 0; i < CapDescriptorArrayLength; i++)
				H245FreeCapDescriptor(pTermCapDescriptorArray[i]);
			if (*ppTermCapList != NULL) {
				Free((*ppTermCapList)->pTermCapArray);
				Free(*ppTermCapList);
			}
			Free(*ppTermCapDescriptors);
			*ppTermCapList = NULL;
			*ppH2250MuxCap = NULL;
			*ppTermCapDescriptors = NULL;
			return CC_NO_MEMORY;
		}

		for (i = 0; i < CapDescriptorArrayLength; i++)
			(*ppTermCapDescriptors)->pTermCapDescriptorArray[i] = pTermCapDescriptorArray[i];
	}
	return CC_OK;
}



HRESULT _ProcessConnectionComplete(	PCONFERENCE				pConference,
									PCALL					pCall)
{
CC_HCONFERENCE						hConference;
CC_HCALL							hCall;
HQ931CALL							hQ931Call;
HQ931CALL							hQ931CallInvitor;
HRESULT								status;
CC_CONNECT_CALLBACK_PARAMS			ConnectCallbackParams;
CC_MULTIPOINT_CALLBACK_PARAMS		MultipointCallbackParams;
CC_PEER_CHANGE_CAP_CALLBACK_PARAMS	PeerChangeCapCallbackParams;
CC_PEER_ADD_CALLBACK_PARAMS			PeerAddCallbackParams;
WORD								i;
BOOL								bMultipointConference;
H245_TRANSPORT_ADDRESS_T			Q931Address;
PDU_T								Pdu;
CALLTYPE							CallType;
WORD								wNumCalls;
PCC_HCALL							CallList;
WORD								wNumChannels;
PCC_HCHANNEL						ChannelList;
PCHANNEL							pChannel;
PCALL								pOldCall;
CC_HCALL							hOldCall;
BYTE								bNewTerminalNumber;
BYTE								bNewMCUNumber;
CC_ENDPOINTTYPE						DestinationEndpointType;
H245_COMM_MODE_ENTRY_T				*pH245CommunicationTable;
BYTE								bCommunicationTableCount;
BOOL								bSessionTableChanged;
CONFMODE							PreviousConferenceMode;
CC_ADDR								MCAddress;
BOOL								bConferenceTermCapsChanged;
H245_INST_T							H245Instance;
PCC_TERMCAP							pTxTermCap;
PCC_TERMCAP							pRxTermCap;
H245_MUX_T							*pTxMuxTable;
H245_MUX_T							*pRxMuxTable;

	ASSERT(pConference != NULL);
	ASSERT(pCall != NULL);
	ASSERT(pCall->hConference == pConference->hConference);

	hConference = pConference->hConference;
	hCall = pCall->hCall;
	hQ931Call = pCall->hQ931Call;
	hQ931CallInvitor = pCall->hQ931CallInvitor;
	H245Instance = pCall->H245Instance;
	CallType = pCall->CallType;

	// Note that pConference->ConferenceMode refers to the conference mode BEFORE
	// this connection attempt completes.  If the current conference mode is
	// point-to-point, this connection (if successful) will result in a multipoint
	// conference.  We want to reflect in the CONNECT callback the connection mode
	// that would exist if the connect attempt is successful.
	if ((pConference->ConferenceMode == POINT_TO_POINT_MODE) ||
		(pConference->ConferenceMode == MULTIPOINT_MODE) ||
		(pCall->bCallerIsMC))
		bMultipointConference = TRUE;
	else
		bMultipointConference = FALSE;

	// Initialize all fields of ConnectCallbackParams now
	ConnectCallbackParams.pNonStandardData = pCall->pPeerNonStandardData;
	ConnectCallbackParams.pszPeerDisplay = pCall->pszPeerDisplay;
	ConnectCallbackParams.bRejectReason = CC_REJECT_UNDEFINED_REASON;
	ConnectCallbackParams.pTermCapList = pCall->pPeerH245TermCapList;
	ConnectCallbackParams.pH2250MuxCapability = pCall->pPeerH245H2250MuxCapability;
	ConnectCallbackParams.pTermCapDescriptors = pCall->pPeerH245TermCapDescriptors;
	ConnectCallbackParams.pLocalAddr = pCall->pQ931LocalConnectAddr;
	if (pCall->pQ931DestinationAddr == NULL)
		ConnectCallbackParams.pPeerAddr = pCall->pQ931PeerConnectAddr;
	else
		ConnectCallbackParams.pPeerAddr = pCall->pQ931DestinationAddr;
	ConnectCallbackParams.pVendorInfo = pCall->pPeerVendorInfo;
	ConnectCallbackParams.bMultipointConference = bMultipointConference;
	ConnectCallbackParams.pConferenceID = &pConference->ConferenceID;
	ConnectCallbackParams.pMCAddress = pConference->pMultipointControllerAddr;
	ConnectCallbackParams.pAlternateAddress = NULL;
	ConnectCallbackParams.dwUserToken = pCall->dwUserToken;

	status = AddEstablishedCallToConference(pCall, pConference);
	if (status != CC_OK) {
		MarkCallForDeletion(pCall);

		if (CallType == THIRD_PARTY_INTERMEDIARY)
			Q931RejectCall(hQ931CallInvitor,
						   CC_REJECT_UNDEFINED_REASON,
						   &pCall->ConferenceID,
						   NULL,	// alternate address
						   pCall->pPeerNonStandardData);

		if ((CallType == CALLER) || (CallType == THIRD_PARTY_INVITOR) ||
			((CallType == CALLEE) && (pConference->LocalEndpointAttached == NEVER_ATTACHED)))
			InvokeUserConferenceCallback(pConference,
										 CC_CONNECT_INDICATION,
										 status,
										 &ConnectCallbackParams);

		if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
			FreeCall(pCall);
		H245ShutDown(H245Instance);
		Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);

		return status;
	}

	if (((pConference->ConferenceMode == POINT_TO_POINT_MODE) ||
		 (pConference->ConferenceMode == MULTIPOINT_MODE)) &&
		(pConference->tsMultipointController == TS_TRUE))
		status = CreateConferenceTermCaps(pConference, &bConferenceTermCapsChanged);
	else {
		status = CC_OK;
		bConferenceTermCapsChanged = FALSE;
	}
	if (status != CC_OK) {
		MarkCallForDeletion(pCall);

		if (CallType == THIRD_PARTY_INTERMEDIARY)
			Q931RejectCall(pCall->hQ931CallInvitor,
						   CC_REJECT_UNDEFINED_REASON,
						   &pCall->ConferenceID,
						   NULL,	// alternate address
						   pCall->pPeerNonStandardData);

		if ((CallType == CALLER) || (CallType == THIRD_PARTY_INVITOR) ||
			((CallType == CALLEE) && (pConference->LocalEndpointAttached == NEVER_ATTACHED)))
			InvokeUserConferenceCallback(pConference,
										 CC_CONNECT_INDICATION,
										 status,
										 &ConnectCallbackParams);

		if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
			FreeCall(pCall);
		H245ShutDown(H245Instance);
		Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);

		return status;
	}

	if (pConference->tsMultipointController == TS_TRUE) {
		// Send MCLocationIndication
		status = GetLastListenAddress(&MCAddress);
		if (status == CC_OK) {
			ASSERT(MCAddress.nAddrType == CC_IP_BINARY);
			Q931Address.type = H245_IP_UNICAST;
			Q931Address.u.ip.tsapIdentifier =
				MCAddress.Addr.IP_Binary.wPort;
			HostToH245IPNetwork(Q931Address.u.ip.network,
							    MCAddress.Addr.IP_Binary.dwAddr);
			H245MCLocationIndication(pCall->H245Instance,
									 &Q931Address);
		}
	}

	EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);

	if (pConference->ConferenceMode == UNCONNECTED_MODE) {
		ASSERT(pConference->pSessionTable == NULL);
		ASSERT(wNumCalls == 1);

		pConference->ConferenceMode = POINT_TO_POINT_MODE;
	} else { // we're currently in point-to-point mode or multipoint mode

		if (pConference->tsMultipointController == TS_TRUE) {
			PreviousConferenceMode = pConference->ConferenceMode;
			pConference->ConferenceMode = MULTIPOINT_MODE;

			// In the future, we may want to construct a new session table
			// each time a new peer is added to the conference
			if (PreviousConferenceMode == POINT_TO_POINT_MODE) {
				// Assign a terminal label to ourselves
				// Note that we reserve a terminal number of 0 for ourselves
				// if we're the MC
				ASSERT(pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber == 255);
				pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber = 0;

				// Create a new session table
				CreateConferenceSessionTable(
							pConference,
							&bSessionTableChanged);
			} else
				// For the current implementation, don't cause a new
				// CommunicationModeCommand to be issued when a new peer is added
				// unless we're switching from point-to-point to multipoint mode
				// (in which case bSessionTableChanged is ignored)
				bSessionTableChanged = FALSE;

			if (bSessionTableChanged)
				SessionTableToH245CommunicationTable(pConference->pSessionTable,
													 &pH245CommunicationTable,
													 &bCommunicationTableCount);
			else
				pH245CommunicationTable = NULL;

			// Send MultipointModeCommand to new call
			Pdu.choice = MSCMg_cmmnd_chosen;
			Pdu.u.MSCMg_cmmnd.choice = miscellaneousCommand_chosen;
			// logical channel number is irrelavent but needs to be filled in
			Pdu.u.MSCMg_cmmnd.u.miscellaneousCommand.logicalChannelNumber = 1;
			Pdu.u.MSCMg_cmmnd.u.miscellaneousCommand.type.choice = multipointModeCommand_chosen;
			H245SendPDU(pCall->H245Instance, &Pdu);

			status = AllocatePeerParticipantInfo(pConference, &pCall->pPeerParticipantInfo);
			if (status == CC_OK) {
				bNewMCUNumber = pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber;
				bNewTerminalNumber = pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber;
				// Send TerminalNumberAssign to new call
				H245ConferenceIndication(pCall->H245Instance,
										 H245_IND_TERMINAL_NUMBER_ASSIGN,// Indication Type
										 0,							// SBE number; ignored here
										 pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber,			// MCU number
										 pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber);		// terminal number
				
				// Send EnterH243TerminalID to new call
				H245ConferenceRequest(pCall->H245Instance,
									  H245_REQ_ENTER_H243_TERMINAL_ID,
									  pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber,
									  pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber);
				pCall->pPeerParticipantInfo->TerminalIDState = TERMINAL_ID_REQUESTED;
			} else {
				// Unable to assign a terminal number to the new call
				bNewMCUNumber = 0;
				bNewTerminalNumber = 0;
			}

			if (pH245CommunicationTable != NULL) {
				// Send CommunicationModeCommand to new call
				status = H245CommunicationModeCommand(pCall->H245Instance,
													  pH245CommunicationTable,
													  bCommunicationTableCount);
			}

			if (PreviousConferenceMode == POINT_TO_POINT_MODE) {
				// Generate MULTIPOINT callback
				MultipointCallbackParams.pTerminalInfo = &pConference->LocalParticipantInfo.ParticipantInfo;
				MultipointCallbackParams.pSessionTable = pConference->pSessionTable;
				InvokeUserConferenceCallback(pConference,
											 CC_MULTIPOINT_INDICATION,
											 CC_OK,
											 &MultipointCallbackParams);
				if (ValidateConference(hConference) != CC_OK) {
					if (ValidateCall(hCall) == CC_OK) {
						pCall->CallState = CALL_COMPLETE;
						UnlockCall(pCall);
					}
					Free(CallList);
					return CC_OK;
				}

				// Generate CC_PEER_CHANGE_CAP callback
				PeerChangeCapCallbackParams.pTermCapList =
					pConference->pConferenceTermCapList;
				PeerChangeCapCallbackParams.pH2250MuxCapability =
					pConference->pConferenceH245H2250MuxCapability;
				PeerChangeCapCallbackParams.pTermCapDescriptors =
					pConference->pConferenceTermCapDescriptors;
				InvokeUserConferenceCallback(pConference,
											 CC_PEER_CHANGE_CAP_INDICATION,
											 CC_OK,
											 &PeerChangeCapCallbackParams);
				if (ValidateConference(hConference) != CC_OK) {
					if (ValidateCall(hCall) == CC_OK) {
						pCall->CallState = CALL_COMPLETE;
						UnlockCall(pCall);
					}
					Free(CallList);
					return CC_OK;
				}

				ASSERT(wNumCalls == 2); // one existing call and new call
				if (CallList[0] == hCall)
					hOldCall = CallList[1];
				else
					hOldCall = CallList[0];

				if (LockCall(hOldCall, &pOldCall) == CC_OK) {
					// Send MultipointModeCommand to old call
					Pdu.choice = MSCMg_cmmnd_chosen;
					Pdu.u.MSCMg_cmmnd.choice = miscellaneousCommand_chosen;
					// logical channel number is irrelavent but needs to be filled in
					Pdu.u.MSCMg_cmmnd.u.miscellaneousCommand.logicalChannelNumber = 1;
					Pdu.u.MSCMg_cmmnd.u.miscellaneousCommand.type.choice = multipointModeCommand_chosen;
					H245SendPDU(pOldCall->H245Instance, &Pdu);

					status = AllocatePeerParticipantInfo(pConference,
														 &pOldCall->pPeerParticipantInfo);
					if (status == CC_OK) {
						// Send TerminalNumberAssign to old call
						H245ConferenceIndication(pOldCall->H245Instance,
												 H245_IND_TERMINAL_NUMBER_ASSIGN,// Indication Type
												 0,							// SBE number; ignored here
												 pOldCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber,				// MCU number
												 pOldCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber);	// terminal number
						
						// Send EnterH243TerminalID to old call
						H245ConferenceRequest(pOldCall->H245Instance,
											  H245_REQ_ENTER_H243_TERMINAL_ID,
											  pOldCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber,
											  pOldCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber);
						pOldCall->pPeerParticipantInfo->TerminalIDState = TERMINAL_ID_REQUESTED;
					}

					if (pH245CommunicationTable != NULL) {
						// Send CommunicationModeCommand to old call
						status = H245CommunicationModeCommand(pOldCall->H245Instance,
															  pH245CommunicationTable,
															  bCommunicationTableCount);
	
						FreeH245CommunicationTable(pH245CommunicationTable,
												   bCommunicationTableCount);
					}

					// Send TerminalJoinedConference (this call) to old call
					H245ConferenceIndication(pOldCall->H245Instance,
											 H245_IND_TERMINAL_JOINED,	// Indication Type
											 0,							// SBE number; ignored here
											 pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber,			// MCU number
                                                                                         pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber);      // terminal number // terminal number of MC

					if (bNewTerminalNumber != 0) {
						// Send TerminalJoinedConference (new call) to old call
						H245ConferenceIndication(pOldCall->H245Instance,
												 H245_IND_TERMINAL_JOINED,	// Indication Type
												 0,							// SBE number; ignored here
												 bNewMCUNumber,				// MCU number
												 bNewTerminalNumber);		// terminal number

						// Generate PEER_ADD callback for old call
						PeerAddCallbackParams.hCall = pOldCall->hCall;
						PeerAddCallbackParams.TerminalLabel =
							pOldCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
						PeerAddCallbackParams.pPeerTerminalID = NULL;
						InvokeUserConferenceCallback(pConference,
											 CC_PEER_ADD_INDICATION,
											 CC_OK,
											 &PeerAddCallbackParams);
						if (ValidateConference(hConference) != CC_OK) {
							if (ValidateCall(hOldCall) == CC_OK)
								UnlockCall(pCall);
							if (ValidateCall(hCall) == CC_OK) {
								pCall->CallState = CALL_COMPLETE;
								UnlockCall(pCall);
							}
							Free(CallList);
							return CC_OK;
						}
					}

					// Send new term caps to old call
					SendTermCaps(pOldCall, pConference);

					UnlockCall(pOldCall);
				}
			} else { // we're currently in multipoint mode
				EnumerateChannelsInConference(&wNumChannels,
											  &ChannelList,
											  pConference,
											  TX_CHANNEL | PROXY_CHANNEL | TXRX_CHANNEL);
				for (i = 0; i < wNumChannels; i++) {
					if (LockChannel(ChannelList[i], &pChannel) == CC_OK) {
						if (pChannel->bMultipointChannel) {
							if ((pChannel->bChannelType == TX_CHANNEL) ||
								((pChannel->bChannelType == TXRX_CHANNEL) &&
								 (pChannel->bLocallyOpened == TRUE))) {
								pTxTermCap = pChannel->pTxH245TermCap;
								pTxMuxTable = pChannel->pTxMuxTable;
								pRxTermCap = pChannel->pRxH245TermCap;
								pRxMuxTable = pChannel->pRxMuxTable;
							} else {
								// Note: since this is a proxy or remotely-opened 
								// bi-directional channel, RxTermCap and RxMuxTable
								// contain the channel's term cap and mux table,
								// and must be sent to other endpoints as the
								// Tx term cap and mux table;
								// TxTermCap and TxMuxTable should be NULL
								pTxTermCap = pChannel->pRxH245TermCap;
								pTxMuxTable = pChannel->pRxMuxTable;
								pRxTermCap = pChannel->pTxH245TermCap;
								pRxMuxTable = pChannel->pTxMuxTable;
							}
	
							status = H245OpenChannel(
										pCall->H245Instance,
										pChannel->hChannel,		// dwTransId
										pChannel->wLocalChannelNumber,
										pTxTermCap,				// TxMode
										pTxMuxTable,			// TxMux
										H245_INVALID_PORT_NUMBER,	// TxPort
										pRxTermCap,				// RxMode
										pRxMuxTable,			// RxMux
										pChannel->pSeparateStack);
							if ((status == CC_OK) && (pChannel->wNumOutstandingRequests != 0))
								(pChannel->wNumOutstandingRequests)++;
						}
						UnlockChannel(pChannel);
					}
				}
				Free(ChannelList);

				for (i = 0; i < wNumCalls; i++) {
					// Don't send a message to the endpoint that just joined the conference!
					if (CallList[i] != hCall) {
						if (LockCall(CallList[i], &pOldCall) == CC_OK) {
							if (bNewTerminalNumber != 0)
								// Send TerminalJoinedConference (new call) to old call
								H245ConferenceIndication(pOldCall->H245Instance,
														 H245_IND_TERMINAL_JOINED,	// Indication Type
														 0,							// SBE number; ignored here
														 bNewMCUNumber,				// MCU number
														 bNewTerminalNumber);		// terminal number
							// Send CommunicationModeCommand, if necessary
							if (pH245CommunicationTable != NULL)
								status = H245CommunicationModeCommand(pOldCall->H245Instance,
																	  pH245CommunicationTable,
																	  bCommunicationTableCount);
							if (bConferenceTermCapsChanged)
								// Send new term caps
								SendTermCaps(pOldCall, pConference);

							UnlockCall(pOldCall);
						}
					}
				}
				if (bConferenceTermCapsChanged) {
					// Generate CC_PEER_CHANGE_CAP callback
					PeerChangeCapCallbackParams.pTermCapList =
						pConference->pConferenceTermCapList;
					PeerChangeCapCallbackParams.pH2250MuxCapability =
						pConference->pConferenceH245H2250MuxCapability;
					PeerChangeCapCallbackParams.pTermCapDescriptors =
						pConference->pConferenceTermCapDescriptors;
					InvokeUserConferenceCallback(pConference,
												 CC_PEER_CHANGE_CAP_INDICATION,
												 CC_OK,
												 &PeerChangeCapCallbackParams);
					if (ValidateConference(hConference) != CC_OK) {
						if (ValidateCall(hCall) == CC_OK) {
							pCall->CallState = CALL_COMPLETE;
							UnlockCall(pCall);
						}
						Free(CallList);
						return CC_OK;
					}
				}
			}

			// Generate PEER_ADD callback
			PeerAddCallbackParams.hCall = pCall->hCall;
			PeerAddCallbackParams.TerminalLabel =
				pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
			PeerAddCallbackParams.pPeerTerminalID = NULL;
			InvokeUserConferenceCallback(pConference,
								 CC_PEER_ADD_INDICATION,
								 CC_OK,
								 &PeerAddCallbackParams);
			if (ValidateConference(hConference) != CC_OK) {
				if (ValidateCall(hCall) == CC_OK) {
					pCall->CallState = CALL_COMPLETE;
					UnlockCall(pCall);
					Free(CallList);
					return CC_OK;
				}
			}

			if (CallType == THIRD_PARTY_INTERMEDIARY) {
				DestinationEndpointType.pVendorInfo = pCall->pPeerVendorInfo;
				DestinationEndpointType.bIsTerminal = TRUE;
				DestinationEndpointType.bIsGateway = FALSE;

				status = Q931AcceptCall(pCall->hQ931CallInvitor,
										pCall->pszPeerDisplay,
										pCall->pPeerNonStandardData,
										&DestinationEndpointType,
										NULL,
										pCall->dwBandwidth,
										pCall->hCall);
				Q931Hangup(pCall->hQ931CallInvitor, CC_REJECT_NORMAL_CALL_CLEARING);
			}
		} // if (pConference->tsMultipointController == TS_TRUE)
	}

	Free(CallList);

	if (ValidateConference(hConference) == CC_OK)
		if ((CallType == CALLER) || (CallType == THIRD_PARTY_INVITOR) ||
			((CallType == CALLEE) && (pConference->LocalEndpointAttached == NEVER_ATTACHED))) {
			// This CONNECT must apply to the local endpoint
			pConference->LocalEndpointAttached = ATTACHED;
			InvokeUserConferenceCallback(pConference,
										 CC_CONNECT_INDICATION,
										 CC_OK,
										 &ConnectCallbackParams);
		}
	// Need to validate the conference and call handles; the associated
	// objects may have been deleted during user callback on this thread
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);

	if (ValidateCall(hCall) == CC_OK) {
		pCall->CallState = CALL_COMPLETE;
		UnlockCall(pCall);
	}
	return status;
}



HRESULT _IndUnimplemented(			H245_CONF_IND_T			*pH245ConfIndData)
{
	return H245_ERROR_NOSUP;
}



HRESULT _IndFlowControl(			H245_CONF_IND_T			*pH245ConfIndData)
{
HRESULT								status;
CC_HCALL							hCall;
PCALL								pCall;
PCONFERENCE							pConference;
CC_HCONFERENCE						hConference;
CC_HCHANNEL							hChannel;
PCHANNEL							pChannel;
CC_FLOW_CONTROL_CALLBACK_PARAMS		FlowControlCallbackParams;

	if (pH245ConfIndData->u.Indication.u.IndFlowControl.Scope != H245_SCOPE_CHANNEL_NUMBER)
		return H245_ERROR_NOSUP;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		// This may be OK, if the call was cancelled while
		// call setup was in progress.
		return H245_ERROR_OK;
	}

	hConference = pCall->hConference;
	UnlockCall(pCall);

	if (FindChannelInConference(pH245ConfIndData->u.Indication.u.IndFlowControl.Channel,
								TRUE,	// local channel number
		                        TX_CHANNEL | PROXY_CHANNEL,
								CC_INVALID_HANDLE,
		                        &hChannel,
								pConference) != CC_OK) {
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	if (LockChannel(hChannel, &pChannel) != CC_OK) {
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}
	
	if (pChannel->bChannelType == TX_CHANNEL) {
		UnlockChannel(pChannel);
		FlowControlCallbackParams.hChannel = hChannel;
		FlowControlCallbackParams.dwRate =
			pH245ConfIndData->u.Indication.u.IndFlowControl.dwRestriction;
		// H.245 gives us the flow rate in units of 100 bps
		if (pH245ConfIndData->u.Indication.u.IndFlowControl.dwRestriction != H245_NO_RESTRICTION)
			FlowControlCallbackParams.dwRate *=	100;
		InvokeUserConferenceCallback(pConference,
									 CC_FLOW_CONTROL_INDICATION,
									 CC_OK,
									 &FlowControlCallbackParams);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
	} else { // pChannel->bChannelType == PROXY_CHANNEL
		if (LockCall(pChannel->hCall, &pCall) == CC_OK) {
			H245FlowControl(pCall->H245Instance,
							pH245ConfIndData->u.Indication.u.IndFlowControl.Scope,
							pChannel->wRemoteChannelNumber,
							pH245ConfIndData->u.Indication.u.IndFlowControl.wResourceID,
							pH245ConfIndData->u.Indication.u.IndFlowControl.dwRestriction);
			UnlockCall(pCall);
		}
		UnlockChannel(pChannel);
		UnlockConference(pConference);
	}
	return H245_ERROR_OK;
}



HRESULT _IndEndSession(				H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL	hCall;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (hCall != CC_INVALID_HANDLE)
		ProcessRemoteHangup(hCall, CC_INVALID_HANDLE, CC_REJECT_NORMAL_CALL_CLEARING);
	return H245_ERROR_OK;
}



HRESULT _IndCapability(				H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL							hCall;
PCALL								pCall;
HRESULT								status;
PCONFERENCE							pConference;
CC_HCONFERENCE						hConference;
CC_PEER_CHANGE_CAP_CALLBACK_PARAMS	PeerChangeCapCallbackParams;
BOOL								bConferenceTermCapsChanged;
WORD								wNumCalls;
PCC_HCALL							CallList;
PCALL								pOldCall;
WORD								i;

	// We received a TerminalCapabilitySet message from a peer

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		// This may be OK, if the call was cancelled while
		// call setup was in progress.
		return H245_ERROR_OK;
	}

	hConference = pCall->hConference;

	if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
		(pConference->tsMultipointController == TS_TRUE))
		CreateConferenceTermCaps(pConference, &bConferenceTermCapsChanged);
	else
		bConferenceTermCapsChanged = FALSE;

	pCall->bLinkEstablished = TRUE;

	pCall->IncomingTermCapState = TERMCAP_COMPLETE;

	if (pCall->CallState == TERMCAP) {
		ASSERT(pCall->pPeerH245TermCapList == NULL);
		ASSERT(pCall->pPeerH245H2250MuxCapability == NULL);
		ASSERT(pCall->pPeerH245TermCapDescriptors == NULL);
	} else {
		DestroyH245TermCapList(&pCall->pPeerH245TermCapList);
		DestroyH245TermCap(&pCall->pPeerH245H2250MuxCapability);
		DestroyH245TermCapDescriptors(&pCall->pPeerH245TermCapDescriptors);
	}

	_ConstructTermCapList(&(pCall->pPeerH245TermCapList),
			              &(pCall->pPeerH245H2250MuxCapability),
						  &(pCall->pPeerH245TermCapDescriptors),
			              pCall);

	if ((pCall->OutgoingTermCapState == TERMCAP_COMPLETE) &&
		(pCall->IncomingTermCapState == TERMCAP_COMPLETE) &&
	    (pCall->CallState == TERMCAP) &&
		(pCall->MasterSlaveState == MASTER_SLAVE_COMPLETE)) {
		// Note that _ProcessConnectionComplete() returns with pConference and pCall unlocked
		_ProcessConnectionComplete(pConference, pCall);
		return H245_ERROR_OK;
	}

	if (pCall->CallState == CALL_COMPLETE) {
		if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
			(pConference->tsMultipointController == TS_TRUE)) {
			CreateConferenceTermCaps(pConference, &bConferenceTermCapsChanged);
			if (bConferenceTermCapsChanged) {
				EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
				for (i = 0; i < wNumCalls; i++) {
					// Don't send a message to the endpoint that just joined the conference!
					if (CallList[i] != hCall) {
						if (LockCall(CallList[i], &pOldCall) == CC_OK) {
							// Send new term caps
							SendTermCaps(pOldCall, pConference);
							UnlockCall(pOldCall);
						}
					}
				}
				if (CallList != NULL)
					Free(CallList);

				// Generate CC_PEER_CHANGE_CAP callback
				PeerChangeCapCallbackParams.pTermCapList =
					pConference->pConferenceTermCapList;
				PeerChangeCapCallbackParams.pH2250MuxCapability =
					pConference->pConferenceH245H2250MuxCapability;
				PeerChangeCapCallbackParams.pTermCapDescriptors =
					pConference->pConferenceTermCapDescriptors;
				InvokeUserConferenceCallback(pConference,
											 CC_PEER_CHANGE_CAP_INDICATION,
											 CC_OK,
											 &PeerChangeCapCallbackParams);
			}
		} else {
			PeerChangeCapCallbackParams.pTermCapList = pCall->pPeerH245TermCapList;
			PeerChangeCapCallbackParams.pH2250MuxCapability = pCall->pPeerH245H2250MuxCapability;
			PeerChangeCapCallbackParams.pTermCapDescriptors = pCall->pPeerH245TermCapDescriptors;
			InvokeUserConferenceCallback(pConference,
										 CC_PEER_CHANGE_CAP_INDICATION,
										 CC_OK,
										 &PeerChangeCapCallbackParams);
		}
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
		if (ValidateCall(hCall) == CC_OK)
			UnlockCall(pCall);
		return H245_ERROR_OK;
	}

	UnlockCall(pCall);
	UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _IndOpenT120(				H245_CONF_IND_T			*pH245ConfIndData)
{
BOOL									bFailed;
CC_T120_CHANNEL_REQUEST_CALLBACK_PARAMS	T120ChannelRequestCallbackParams;
CC_HCALL								hCall;
PCALL									pCall;
CC_HCONFERENCE							hConference;
PCONFERENCE								pConference;
CC_HCHANNEL								hChannel;
PCHANNEL								pChannel;
CC_TERMCAP								RxTermCap;
CC_TERMCAP								TxTermCap;
H245_MUX_T								RxH245MuxTable;
H245_MUX_T								TxH245MuxTable;
CC_ADDR									T120Addr;
CC_OCTETSTRING							ExternalReference;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK) {
		// Can't cancel with H245, because we don't have the H245 instance
		return H245_ERROR_OK;
	}

	hConference = pCall->hConference;
	
	if (pH245ConfIndData->u.Indication.u.IndOpen.RxDataType != H245_DATA_DATA ||
	    pH245ConfIndData->u.Indication.u.IndOpen.RxClientType != H245_CLIENT_DAT_T120 ||
	    pH245ConfIndData->u.Indication.u.IndOpen.pRxCap == NULL ||
	    pH245ConfIndData->u.Indication.u.IndOpen.pRxCap->H245Dat_T120.application.choice != DACy_applctn_t120_chosen ||
	    pH245ConfIndData->u.Indication.u.IndOpen.pRxCap->H245Dat_T120.application.u.DACy_applctn_t120.choice != separateLANStack_chosen ||
 	    pH245ConfIndData->u.Indication.u.IndOpen.TxDataType != H245_DATA_DATA ||
	    pH245ConfIndData->u.Indication.u.IndOpen.TxClientType != H245_CLIENT_DAT_T120 ||
	    pH245ConfIndData->u.Indication.u.IndOpen.pTxCap == NULL ||
	    pH245ConfIndData->u.Indication.u.IndOpen.pTxCap->H245Dat_T120.application.choice != DACy_applctn_t120_chosen ||
	    pH245ConfIndData->u.Indication.u.IndOpen.pTxCap->H245Dat_T120.application.u.DACy_applctn_t120.choice != separateLANStack_chosen) {
		bFailed = TRUE;
    } else {
	    bFailed = FALSE;
    }

	if (pH245ConfIndData->u.Indication.u.IndOpen.pSeparateStack) {
		if ((pH245ConfIndData->u.Indication.u.IndOpen.pSeparateStack->networkAddress.choice == localAreaAddress_chosen) &&
			(pH245ConfIndData->u.Indication.u.IndOpen.pSeparateStack->networkAddress.u.localAreaAddress.choice == unicastAddress_chosen) &&
			(pH245ConfIndData->u.Indication.u.IndOpen.pSeparateStack->networkAddress.u.localAreaAddress.u.unicastAddress.choice == UnicastAddress_iPAddress_chosen)) {
			T120Addr.nAddrType = CC_IP_BINARY;
			T120Addr.bMulticast = FALSE;
			T120Addr.Addr.IP_Binary.wPort =
				pH245ConfIndData->u.Indication.u.IndOpen.pSeparateStack->networkAddress.u.localAreaAddress.u.unicastAddress.u.UnicastAddress_iPAddress.tsapIdentifier;
			H245IPNetworkToHost(&T120Addr.Addr.IP_Binary.dwAddr,
			                    pH245ConfIndData->u.Indication.u.IndOpen.pSeparateStack->networkAddress.u.localAreaAddress.u.unicastAddress.u.UnicastAddress_iPAddress.network.value);
		} else {
			bFailed = TRUE;
		}
	}

	if (bFailed) {
 		H245OpenChannelReject(pCall->H245Instance,	// H245 instance
							  pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,
							  H245_REJ);			// rejection reason
		UnlockConference(pConference);
		UnlockCall(pCall);
		return H245_ERROR_OK;
	}

	RxTermCap.Dir = H245_CAPDIR_RMTTX;
	RxTermCap.DataType = pH245ConfIndData->u.Indication.u.IndOpen.RxDataType;
	RxTermCap.ClientType = pH245ConfIndData->u.Indication.u.IndOpen.RxClientType;
	RxTermCap.CapId = 0;	// not used for channels
	RxTermCap.Cap = *pH245ConfIndData->u.Indication.u.IndOpen.pRxCap;

	TxTermCap.Dir = H245_CAPDIR_RMTTX;
	TxTermCap.DataType = pH245ConfIndData->u.Indication.u.IndOpen.TxDataType;
	TxTermCap.ClientType = pH245ConfIndData->u.Indication.u.IndOpen.TxClientType;
	TxTermCap.CapId = 0;	// not used for channels
	TxTermCap.Cap = *pH245ConfIndData->u.Indication.u.IndOpen.pTxCap;

	RxH245MuxTable = *pH245ConfIndData->u.Indication.u.IndOpen.pRxMux;
	if ((pCall->pPeerParticipantInfo != NULL) &&
		(pCall->pPeerParticipantInfo->TerminalIDState == TERMINAL_ID_VALID)) {
		RxH245MuxTable.u.H2250.destinationPresent = TRUE;
		RxH245MuxTable.u.H2250.destination.mcuNumber = pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber;
		RxH245MuxTable.u.H2250.destination.terminalNumber = pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber;
	} else
		RxH245MuxTable.u.H2250.destinationPresent = FALSE;

	TxH245MuxTable = *pH245ConfIndData->u.Indication.u.IndOpen.pTxMux;
	TxH245MuxTable.u.H2250.destinationPresent = FALSE;

	if (AllocAndLockChannel(&hChannel,
							pConference,
							hCall,
							&TxTermCap,			// Tx terminal capability
							&RxTermCap,			// Rx terminal capability
							&TxH245MuxTable,	// Tx H245 mux table
							&RxH245MuxTable,	// Rx H245 mux table
							pH245ConfIndData->u.Indication.u.IndOpen.pSeparateStack, // separate stack
							0,					// user token
							TXRX_CHANNEL,		// channel type
							0,					// session ID
							0,					// associated session ID
							pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,	// remote bi-dir channel number
							NULL,				// pLocalRTPAddr
							NULL,				// pLocalRTCPAddr
							NULL,				// pPeerRTPAddr
							NULL,				// pPeerRTCPAddr
							FALSE,				// locally opened
							0,					// bandwidth
							&pChannel) != CC_OK) {

		H245OpenChannelReject(pCall->H245Instance,	// H245 instance
							  pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,
							  H245_REJ);			// rejection reason
		UnlockConference(pConference);
		UnlockCall(pCall);
		return H245_ERROR_OK;
	}

	if (AddChannelToConference(pChannel, pConference) != CC_OK) {
		H245OpenChannelReject(pCall->H245Instance,	// H245 instance
							  pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,
							  H245_REJ);			// rejection reason
		UnlockConference(pConference);
		UnlockCall(pCall);
		FreeChannel(pChannel);
		return H245_ERROR_OK;
	}

	T120ChannelRequestCallbackParams.hChannel = hChannel;
	if (pH245ConfIndData->u.Indication.u.IndOpen.pSeparateStack == NULL) {
		T120ChannelRequestCallbackParams.bAssociateConference = FALSE;
		T120ChannelRequestCallbackParams.pExternalReference = NULL;
		T120ChannelRequestCallbackParams.pAddr = NULL;
	} else {
		T120ChannelRequestCallbackParams.bAssociateConference = 
			pH245ConfIndData->u.Indication.u.IndOpen.pSeparateStack->associateConference;		
		if (pH245ConfIndData->u.Indication.u.IndOpen.pSeparateStack->bit_mask & externalReference_present) {
                        ExternalReference.wOctetStringLength = (WORD)
				pH245ConfIndData->u.Indication.u.IndOpen.pSeparateStack->externalReference.length;
			ExternalReference.pOctetString =
				pH245ConfIndData->u.Indication.u.IndOpen.pSeparateStack->externalReference.value;
			T120ChannelRequestCallbackParams.pExternalReference = &ExternalReference;
		} else
			T120ChannelRequestCallbackParams.pExternalReference = NULL;
		T120ChannelRequestCallbackParams.pAddr = &T120Addr;
	}
	if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
		(pConference->tsMultipointController == TS_TRUE))
		T120ChannelRequestCallbackParams.bMultipointController = TRUE;
	else
		T120ChannelRequestCallbackParams.bMultipointController = FALSE;
	if (pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.destinationPresent) {
		T120ChannelRequestCallbackParams.TerminalLabel.bMCUNumber =
			(BYTE)pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.destination.mcuNumber;
		T120ChannelRequestCallbackParams.TerminalLabel.bTerminalNumber =
			(BYTE)pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.destination.terminalNumber;
	} else {
		T120ChannelRequestCallbackParams.TerminalLabel.bMCUNumber = 255;
		T120ChannelRequestCallbackParams.TerminalLabel.bTerminalNumber = 255;
	}

	pChannel->wNumOutstandingRequests = 1;

	InvokeUserConferenceCallback(pConference,
		                         CC_T120_CHANNEL_REQUEST_INDICATION,
								 CC_OK,
								 &T120ChannelRequestCallbackParams);

	if (ValidateChannel(hChannel) == CC_OK)
		UnlockChannel(pChannel);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);

	return H245_ERROR_OK;
}



HRESULT _IndOpen(					H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL								hCall;
PCALL									pCall;
PCALL									pOldCall;
CC_HCONFERENCE							hConference;
PCONFERENCE								pConference;
WORD									wNumCalls;
PCC_HCALL								CallList;
CC_HCHANNEL								hChannel;
PCHANNEL								pChannel;
CC_TERMCAP								TermCap;
CC_ADDR									PeerRTPAddr;
CC_ADDR									PeerRTCPAddr;
CC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS	RxChannelRequestCallbackParams;
BYTE									bChannelType;
WORD									i;
H245_MUX_T								H245MuxTable;
PCC_ADDR								pLocalRTPAddr;
PCC_ADDR								pLocalRTCPAddr;
PCC_ADDR								pPeerRTPAddr;
PCC_ADDR								pPeerRTCPAddr;
BOOL									bFoundSession;
HRESULT									status;

	// First check to see if this is a T.120 channel request,
	// as T.120 channels are handled differently then other channels
	if (pH245ConfIndData->u.Indication.u.IndOpen.RxClientType == H245_CLIENT_DAT_T120) {
		status = _IndOpenT120(pH245ConfIndData);
		return status;
	}

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK) {
		// Can't cancel with H245, because we don't have the H245 instance
		return H245_ERROR_OK;
	}

	// Make sure that this is not a bi-directional channel
	if ((pH245ConfIndData->u.Indication.u.IndOpen.pTxMux != NULL) ||
            (pH245ConfIndData->u.Indication.u.IndOpen.pRxCap == NULL)) {		
		H245OpenChannelReject(pCall->H245Instance,	// H245 instance
							  pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,
							  H245_REJ);			// rejection reason
		UnlockConference(pConference);
		UnlockCall(pCall);
		return H245_ERROR_OK;
	}

	hConference = pCall->hConference;
	
	TermCap.Dir = H245_CAPDIR_RMTTX;
	TermCap.DataType = pH245ConfIndData->u.Indication.u.IndOpen.RxDataType;
	TermCap.ClientType = pH245ConfIndData->u.Indication.u.IndOpen.RxClientType;
	TermCap.CapId = 0;	// not used for Rx channels
	TermCap.Cap = *pH245ConfIndData->u.Indication.u.IndOpen.pRxCap;
	
	RxChannelRequestCallbackParams.pChannelCapability = &TermCap;

	if ((pH245ConfIndData->u.Indication.u.IndOpen.pRxMux != NULL) &&
		(pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->Kind == H245_H2250)) {
		RxChannelRequestCallbackParams.bSessionID =
			pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.sessionID;
		if (pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.associatedSessionIDPresent)
			RxChannelRequestCallbackParams.bAssociatedSessionID =
				pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.associatedSessionID;
		else
			RxChannelRequestCallbackParams.bAssociatedSessionID = 0;
		if (pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.silenceSuppressionPresent)
			RxChannelRequestCallbackParams.bSilenceSuppression =
				pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.silenceSuppression;
		else
			RxChannelRequestCallbackParams.bSilenceSuppression = FALSE;
		if ((pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.mediaChannelPresent) &&
			((pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.mediaChannel.type == H245_IP_MULTICAST) ||
			(pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.mediaChannel.type == H245_IP_UNICAST))) {
			RxChannelRequestCallbackParams.pPeerRTPAddr = &PeerRTPAddr;
			PeerRTPAddr.nAddrType = CC_IP_BINARY;
			if (pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.mediaChannel.type == H245_IP_MULTICAST)
				PeerRTPAddr.bMulticast = TRUE;
			else
				PeerRTPAddr.bMulticast = FALSE;
			PeerRTPAddr.Addr.IP_Binary.wPort =
				pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.mediaChannel.u.ip.tsapIdentifier;
			H245IPNetworkToHost(&PeerRTPAddr.Addr.IP_Binary.dwAddr,
			                    pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.mediaChannel.u.ip.network);
		} else
			RxChannelRequestCallbackParams.pPeerRTPAddr = NULL;

		if ((pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.mediaControlChannelPresent) &&
			((pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.mediaControlChannel.type == H245_IP_MULTICAST) ||
			(pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.mediaControlChannel.type == H245_IP_UNICAST))) {
			RxChannelRequestCallbackParams.pPeerRTCPAddr = &PeerRTCPAddr;
			PeerRTCPAddr.nAddrType = CC_IP_BINARY;
			if (pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.mediaControlChannel.type == H245_IP_MULTICAST)
				PeerRTCPAddr.bMulticast = TRUE;
			else
				PeerRTCPAddr.bMulticast = FALSE;
			PeerRTCPAddr.Addr.IP_Binary.wPort =
				pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.mediaControlChannel.u.ip.tsapIdentifier;
			H245IPNetworkToHost(&PeerRTCPAddr.Addr.IP_Binary.dwAddr,
			                    pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.mediaControlChannel.u.ip.network);
		} else
			RxChannelRequestCallbackParams.pPeerRTCPAddr = NULL;

		if (pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.destinationPresent) {
			RxChannelRequestCallbackParams.TerminalLabel.bMCUNumber =
				(BYTE)pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.destination.mcuNumber;
			RxChannelRequestCallbackParams.TerminalLabel.bTerminalNumber =
				(BYTE)pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.destination.terminalNumber;
		} else {
			RxChannelRequestCallbackParams.TerminalLabel.bMCUNumber = 255;
			RxChannelRequestCallbackParams.TerminalLabel.bTerminalNumber = 255;
		}

		if (pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.dynamicRTPPayloadTypePresent)
			RxChannelRequestCallbackParams.bRTPPayloadType =
				pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.dynamicRTPPayloadType;
		else
			RxChannelRequestCallbackParams.bRTPPayloadType = 0;
	} else {
		H245OpenChannelReject(pCall->H245Instance,	// H245 instance
							  pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,
							  H245_REJ);			// rejection reason
		UnlockConference(pConference);
		UnlockCall(pCall);
		return H245_ERROR_OK;
	}

	// XXX -- someday we should allow dynamic sessions to be created on the MC
	if (pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.sessionID == 0) {
		H245OpenChannelReject(pCall->H245Instance,	// H245 instance
							  pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,
							  H245_REJ);			// rejection reason
		UnlockConference(pConference);
		UnlockCall(pCall);
		return H245_ERROR_OK;
	}

	if (pConference->ConferenceMode == MULTIPOINT_MODE) {
		if ((pConference->tsMultipointController == TS_TRUE) &&
			((RxChannelRequestCallbackParams.pPeerRTPAddr != NULL) ||
			 (RxChannelRequestCallbackParams.pPeerRTCPAddr != NULL)) ||
		    ((pConference->tsMultipointController == TS_FALSE) &&
			 ((RxChannelRequestCallbackParams.pPeerRTPAddr == NULL) ||
			  (RxChannelRequestCallbackParams.pPeerRTCPAddr == NULL) ||
			  (RxChannelRequestCallbackParams.bSessionID == 0)))) {
  			H245OpenChannelReject(pCall->H245Instance,	// H245 instance
								  pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,
								  H245_REJ);			// rejection reason
			UnlockConference(pConference);
			UnlockCall(pCall);
			return H245_ERROR_OK;
		}

		// Validate session ID
		pLocalRTPAddr = NULL;
		pLocalRTCPAddr = NULL;
		bFoundSession = FALSE;
		if (pConference->pSessionTable != NULL) {
			for (i = 0; i < pConference->pSessionTable->wLength; i++) {
				if (pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.sessionID ==
					pConference->pSessionTable->SessionInfoArray[i].bSessionID) {
					bFoundSession = TRUE;
					pLocalRTPAddr = pConference->pSessionTable->SessionInfoArray[i].pRTPAddr;
					pLocalRTCPAddr = pConference->pSessionTable->SessionInfoArray[i].pRTCPAddr;
					break;
				}
			}
		}
		if (bFoundSession == FALSE)	{
			H245OpenChannelReject(pCall->H245Instance,	// H245 instance
								  pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,
								  H245_REJ);			// rejection reason
			UnlockConference(pConference);
			UnlockCall(pCall);
			return H245_ERROR_OK;
		}

		ASSERT(pLocalRTPAddr != NULL);
		ASSERT(pLocalRTCPAddr != NULL);

		if (pConference->tsMultipointController == TS_TRUE) {
			pPeerRTPAddr = pLocalRTPAddr;
			pPeerRTCPAddr = pLocalRTCPAddr;
			RxChannelRequestCallbackParams.pPeerRTPAddr = pLocalRTPAddr;
			RxChannelRequestCallbackParams.pPeerRTCPAddr = pLocalRTCPAddr;
			bChannelType = PROXY_CHANNEL;
		} else { // multipoint mode, not MC
			pLocalRTPAddr = RxChannelRequestCallbackParams.pPeerRTPAddr;
			pLocalRTCPAddr = RxChannelRequestCallbackParams.pPeerRTCPAddr;
			pPeerRTPAddr = RxChannelRequestCallbackParams.pPeerRTPAddr;
			pPeerRTCPAddr = RxChannelRequestCallbackParams.pPeerRTCPAddr;
			bChannelType = RX_CHANNEL;
		}
	} else { // not multipoint mode
		pLocalRTPAddr = NULL;
		pLocalRTCPAddr = NULL;
		pPeerRTPAddr = RxChannelRequestCallbackParams.pPeerRTPAddr;
		pPeerRTCPAddr = RxChannelRequestCallbackParams.pPeerRTCPAddr;
		bChannelType = RX_CHANNEL;
	}

	H245MuxTable = *pH245ConfIndData->u.Indication.u.IndOpen.pRxMux;
	if ((pCall->pPeerParticipantInfo != NULL) &&
		(pCall->pPeerParticipantInfo->TerminalIDState == TERMINAL_ID_VALID)) {
		H245MuxTable.u.H2250.destinationPresent = TRUE;
		H245MuxTable.u.H2250.destination.mcuNumber = pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber;
		H245MuxTable.u.H2250.destination.terminalNumber = pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber;
	} else
		H245MuxTable.u.H2250.destinationPresent = FALSE;
	if (pLocalRTPAddr != NULL) {
		if (pLocalRTPAddr->bMulticast)
			H245MuxTable.u.H2250.mediaChannel.type = H245_IP_MULTICAST;
		else
			H245MuxTable.u.H2250.mediaChannel.type = H245_IP_UNICAST;
		H245MuxTable.u.H2250.mediaChannel.u.ip.tsapIdentifier =
			pLocalRTPAddr->Addr.IP_Binary.wPort;
		HostToH245IPNetwork(H245MuxTable.u.H2250.mediaChannel.u.ip.network,
							pLocalRTPAddr->Addr.IP_Binary.dwAddr);
		H245MuxTable.u.H2250.mediaChannelPresent = TRUE;
	} else
		H245MuxTable.u.H2250.mediaChannelPresent = FALSE;
	if (pLocalRTCPAddr != NULL) {
		if (pLocalRTCPAddr->bMulticast)
			H245MuxTable.u.H2250.mediaControlChannel.type = H245_IP_MULTICAST;
		else
			H245MuxTable.u.H2250.mediaControlChannel.type = H245_IP_UNICAST;
		H245MuxTable.u.H2250.mediaControlChannel.u.ip.tsapIdentifier =
			pLocalRTCPAddr->Addr.IP_Binary.wPort;
		HostToH245IPNetwork(H245MuxTable.u.H2250.mediaControlChannel.u.ip.network,
							pLocalRTCPAddr->Addr.IP_Binary.dwAddr);
		H245MuxTable.u.H2250.mediaControlChannelPresent = TRUE;
	} else
		H245MuxTable.u.H2250.mediaControlChannelPresent = FALSE;

	if (AllocAndLockChannel(&hChannel,
							pConference,
							hCall,
							NULL,				// Tx terminal capability
							&TermCap,			// Rx terminal capability
							NULL,				// Tx H245 mux table
							&H245MuxTable,		// Rx H245 mux table
							NULL,				// separate stack
							0,					// user token
							bChannelType,
							pH245ConfIndData->u.Indication.u.IndOpen.pRxMux->u.H2250.sessionID,
							RxChannelRequestCallbackParams.bAssociatedSessionID,
							pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,
							pLocalRTPAddr,		// pLocalRTPAddr
							pLocalRTCPAddr,		// pLocalRTCPAddr
							pPeerRTPAddr,		// pPeerRTPAddr
							pPeerRTCPAddr,		// pPeerRTCPAddr
							FALSE,				// locally opened
							0,					// bandwidth
							&pChannel) != CC_OK) {

		H245OpenChannelReject(pCall->H245Instance,	// H245 instance
							  pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,
							  H245_REJ);			// rejection reason
		UnlockConference(pConference);
		UnlockCall(pCall);
		return H245_ERROR_OK;
	}

	if (AddChannelToConference(pChannel, pConference) != CC_OK) {
		H245OpenChannelReject(pCall->H245Instance,	// H245 instance
							  pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,
							  H245_REJ);			// rejection reason
		UnlockConference(pConference);
		UnlockCall(pCall);
		FreeChannel(pChannel);
		return H245_ERROR_OK;
	}

	RxChannelRequestCallbackParams.hChannel = hChannel;
	
	if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
		(pConference->tsMultipointController == TS_TRUE)) {
		// Open this channel to each peer in the conference (except the peer
		// that requested this channel)
		EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
		for (i = 0; i < wNumCalls; i++) {
			if (CallList[i] != hCall) {
				if (LockCall(CallList[i], &pOldCall) == CC_OK) {
					ASSERT(pChannel->bChannelType == PROXY_CHANNEL);
					// Note: since this is a proxy channel, RxTermCap and RxMuxTable
					// contain the channel's term cap and mux table, and must be sent
					// to other endpoints as the Tx term cap and mux table;
					// TxTermCap and TxMuxTable should be NULL
					if (H245OpenChannel(pOldCall->H245Instance,
										pChannel->hChannel,		// dwTransId
										pChannel->wLocalChannelNumber,
										pChannel->pRxH245TermCap,	// TxMode
										pChannel->pRxMuxTable,		// TxMux
										H245_INVALID_PORT_NUMBER,	// TxPort
										pChannel->pTxH245TermCap,	// RxMode
										pChannel->pTxMuxTable,		// RxMux
										pChannel->pSeparateStack) == CC_OK)
						(pChannel->wNumOutstandingRequests)++;
					UnlockCall(pOldCall);
				}
			}
		}
		Free(CallList);
		if (pConference->LocalEndpointAttached == ATTACHED)
			(pChannel->wNumOutstandingRequests)++;
		if (pChannel->wNumOutstandingRequests == 0) {
			H245OpenChannelReject(pCall->H245Instance,	// H245 instance
								  pH245ConfIndData->u.Indication.u.IndOpen.RxChannel,
								  H245_REJ);			// rejection reason
			UnlockConference(pConference);
			UnlockCall(pCall);
			FreeChannel(pChannel);
			return H245_ERROR_OK;
		}
	} else
		pChannel->wNumOutstandingRequests = 1;
	
	InvokeUserConferenceCallback(pConference,
		                         CC_RX_CHANNEL_REQUEST_INDICATION,
								 CC_OK,
								 &RxChannelRequestCallbackParams);

	if (ValidateChannel(hChannel) == CC_OK)
		UnlockChannel(pChannel);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);

	return H245_ERROR_OK;
}



HRESULT _IndOpenConf(				H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL								hCall;
PCALL									pCall;
CC_HCONFERENCE							hConference;
PCONFERENCE								pConference;
CC_HCHANNEL								hChannel;
CC_ACCEPT_CHANNEL_CALLBACK_PARAMS	    AcceptChannelCallbackParams;

    // Bi-directional channel open initiated by remote peer is now complete.
    // Local peer may now send data over this channel.

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pConference->hConference;
	UnlockCall(pCall);

	if (FindChannelInConference(pH245ConfIndData->u.Indication.u.IndOpenConf.TxChannel,
								FALSE,	// remote channel number
		                        TXRX_CHANNEL,
								hCall,
		                        &hChannel,
								pConference) != CC_OK) {
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	AcceptChannelCallbackParams.hChannel = hChannel;
	
	InvokeUserConferenceCallback(pConference,
		                         CC_ACCEPT_CHANNEL_INDICATION,
								 CC_OK,
								 &AcceptChannelCallbackParams);

	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);

	return H245_ERROR_OK;
}



HRESULT _IndMstslv(					H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL					hCall;
PCALL						pCall;
PCONFERENCE					pConference;
CC_CONNECT_CALLBACK_PARAMS	ConnectCallbackParams;
CC_HCALL					hEnqueuedCall;
PCALL						pEnqueuedCall;
CC_HCONFERENCE				hConference;
HRESULT						status;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK) {
		// Can't cancel with H245, because we don't have the H245 instance
		return H245_ERROR_OK;
	}

	ASSERT(pCall->MasterSlaveState != MASTER_SLAVE_COMPLETE);

	switch (pH245ConfIndData->u.Indication.u.IndMstSlv) {
	    case H245_MASTER:
		    pConference->tsMaster = TS_TRUE;
		    if (pConference->tsMultipointController == TS_UNKNOWN) {
			    ASSERT(pConference->bMultipointCapable == TRUE);
			    pConference->tsMultipointController = TS_TRUE;

			    // place all calls enqueued on this conference object
			    for ( ; ; ) {
				    // Start up all enqueued calls, if any exist
				    status = RemoveEnqueuedCallFromConference(pConference, &hEnqueuedCall);
				    if ((status != CC_OK) || (hEnqueuedCall == CC_INVALID_HANDLE))
					    break;

				    status = LockCall(hEnqueuedCall, &pEnqueuedCall);
				    if (status == CC_OK) {
					    pEnqueuedCall->CallState = PLACED;

					    status = PlaceCall(pEnqueuedCall, pConference);
					    UnlockCall(pEnqueuedCall);
				    }
			    }
		    }
	        break;

	    case H245_SLAVE:
		    ASSERT(pConference->tsMaster != TS_TRUE);
		    ASSERT(pConference->tsMultipointController != TS_TRUE);
		    pConference->tsMaster = TS_FALSE;
		    pConference->tsMultipointController = TS_FALSE;

		    // XXX -- we may eventually want to re-enqueue these requests
		    // and set an expiration timer
		    hConference = pConference->hConference;
				
		    for ( ; ; ) {
			    status = RemoveEnqueuedCallFromConference(pConference, &hEnqueuedCall);
			    if ((status != CC_OK) || (hEnqueuedCall == CC_INVALID_HANDLE))
				    break;

			    status = LockCall(hEnqueuedCall, &pEnqueuedCall);
			    if (status == CC_OK) {
				    MarkCallForDeletion(pEnqueuedCall);
				    ConnectCallbackParams.pNonStandardData = pEnqueuedCall->pPeerNonStandardData;
				    ConnectCallbackParams.pszPeerDisplay = pEnqueuedCall->pszPeerDisplay;
				    ConnectCallbackParams.bRejectReason = CC_REJECT_UNDEFINED_REASON;
				    ConnectCallbackParams.pTermCapList = pEnqueuedCall->pPeerH245TermCapList;
				    ConnectCallbackParams.pH2250MuxCapability = pEnqueuedCall->pPeerH245H2250MuxCapability;
				    ConnectCallbackParams.pTermCapDescriptors = pEnqueuedCall->pPeerH245TermCapDescriptors;
				    ConnectCallbackParams.pLocalAddr = pEnqueuedCall->pQ931LocalConnectAddr;
	                if (pEnqueuedCall->pQ931DestinationAddr == NULL)
		                ConnectCallbackParams.pPeerAddr = pEnqueuedCall->pQ931PeerConnectAddr;
	                else
		                ConnectCallbackParams.pPeerAddr = pEnqueuedCall->pQ931DestinationAddr;
				    ConnectCallbackParams.pVendorInfo = pEnqueuedCall->pPeerVendorInfo;
				    ConnectCallbackParams.bMultipointConference = TRUE;
				    ConnectCallbackParams.pConferenceID = &pConference->ConferenceID;
				    ConnectCallbackParams.pMCAddress = pConference->pMultipointControllerAddr;
					ConnectCallbackParams.pAlternateAddress = NULL;
				    ConnectCallbackParams.dwUserToken = pEnqueuedCall->dwUserToken;

				    InvokeUserConferenceCallback(pConference,
									    CC_CONNECT_INDICATION,
									    CC_NOT_MULTIPOINT_CAPABLE,
									    &ConnectCallbackParams);
				    if (ValidateCallMarkedForDeletion(hEnqueuedCall) == CC_OK)
					    FreeCall(pEnqueuedCall);
				    if (ValidateConference(hConference) != CC_OK) {
					    if (ValidateCall(hCall) == CC_OK)
						    UnlockCall(pCall);
					    return H245_ERROR_OK;
				    }
			    }
		    }
	        break;

	    default: // H245_INDETERMINATE
			UnlockConference(pConference);
			if (++pCall->wMasterSlaveRetry < MASTER_SLAVE_RETRY_MAX) {
				H245InitMasterSlave(pCall->H245Instance, pCall->H245Instance);
			    UnlockCall(pCall);
			} else {
			    UnlockCall(pCall);
				ProcessRemoteHangup(hCall, CC_INVALID_HANDLE, CC_REJECT_UNDEFINED_REASON);
			}
			return H245_ERROR_OK;
	} // switch

	pCall->MasterSlaveState = MASTER_SLAVE_COMPLETE;

	if ((pCall->OutgoingTermCapState == TERMCAP_COMPLETE) &&
		(pCall->IncomingTermCapState == TERMCAP_COMPLETE) &&
	    (pCall->CallState == TERMCAP) &&
		(pCall->MasterSlaveState == MASTER_SLAVE_COMPLETE)) {
		// Note that _ProcessConnectionComplete() returns with pConference and pCall unlocked
		_ProcessConnectionComplete(pConference, pCall);
		return H245_ERROR_OK;
	}
	UnlockCall(pCall);
	UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _IndClose(					H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL							hCall;
PCALL								pCall;
CC_HCONFERENCE						hConference;
PCONFERENCE							pConference;
CC_HCHANNEL							hChannel;
PCHANNEL							pChannel;
WORD								i;
WORD								wNumCalls;
PCC_HCALL							CallList;
CC_RX_CHANNEL_CLOSE_CALLBACK_PARAMS	RxChannelCloseCallbackParams;
#ifdef    GATEKEEPER
unsigned                            uBandwidth;
#endif // GATEKEEPER 

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pCall->hConference;
	UnlockCall(pCall);

	if (FindChannelInConference(pH245ConfIndData->u.Indication.u.IndClose.Channel,
							    FALSE,	// remote channel number
		                        RX_CHANNEL | TXRX_CHANNEL | PROXY_CHANNEL,
								hCall,
		                        &hChannel,
								pConference) != CC_OK) {
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	if (LockChannel(hChannel, &pChannel) != CC_OK)
		return H245_ERROR_OK;

	EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);

#ifdef    GATEKEEPER
	if (pChannel->bChannelType != TXRX_CHANNEL) {
		uBandwidth = pChannel->dwBandwidth / 100;
		for (i = 0; i < wNumCalls; i++) {
			if (LockCall(CallList[i], &pCall) == CC_OK) {
				if (uBandwidth && pCall->GkiCall.uBandwidthUsed >= uBandwidth) {
					if (GkiCloseChannel(&pCall->GkiCall, pChannel->dwBandwidth, hChannel) == CC_OK) {
						uBandwidth = 0;
						UnlockCall(pCall);
						break;
					}
				}
				UnlockCall(pCall);
			}
		} // for
	}
#endif // GATEKEEPER

	if (pChannel->bChannelType == PROXY_CHANNEL) {
		ASSERT(pConference->ConferenceMode == MULTIPOINT_MODE);
		ASSERT(pConference->tsMultipointController == TS_TRUE);
		ASSERT(pChannel->bMultipointChannel == TRUE);

		for (i = 0; i < wNumCalls; i++) {
			if (CallList[i] != hCall) {
				if (LockCall(CallList[i], &pCall) == CC_OK) {
					H245CloseChannel(pCall->H245Instance,	// H245 instance
				                     0,						// dwTransId
							         pChannel->wLocalChannelNumber);
					UnlockCall(pCall);
				}
			}
		}
	}

	if (CallList != NULL)
	    Free(CallList);

	if (pChannel->tsAccepted == TS_TRUE) {
		RxChannelCloseCallbackParams.hChannel = hChannel;
		InvokeUserConferenceCallback(pConference,
									 CC_RX_CHANNEL_CLOSE_INDICATION,
									 CC_OK,
									 &RxChannelCloseCallbackParams);
	}

	if (ValidateChannel(hChannel) == CC_OK)
		FreeChannel(pChannel);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _IndRequestClose(			H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL							hCall;
PCALL								pCall;
CC_HCONFERENCE						hConference;
PCONFERENCE							pConference;
CC_HCHANNEL							hChannel;
PCHANNEL							pChannel;
CC_TX_CHANNEL_CLOSE_REQUEST_CALLBACK_PARAMS	TxChannelCloseRequestCallbackParams;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pCall->hConference;
	UnlockCall(pCall);

	if (FindChannelInConference(pH245ConfIndData->u.Indication.u.IndClose.Channel,
								TRUE,	// local channel number
		                        TX_CHANNEL | TXRX_CHANNEL | PROXY_CHANNEL,
								CC_INVALID_HANDLE,
		                        &hChannel,
								pConference) != CC_OK) {
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	if (LockChannel(hChannel, &pChannel) != CC_OK) {
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}
	
	if ((pChannel->bChannelType == TX_CHANNEL) ||
	    (pChannel->bChannelType == TXRX_CHANNEL)) {
		EnqueueRequest(&pChannel->pCloseRequests, hCall);
		UnlockChannel(pChannel);
		TxChannelCloseRequestCallbackParams.hChannel = hChannel;
		InvokeUserConferenceCallback(pConference,
							 CC_TX_CHANNEL_CLOSE_REQUEST_INDICATION,
							 CC_OK,
							 &TxChannelCloseRequestCallbackParams);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
	} else { // pChannel->bChannelType == PROXY_CHANNEL
		if (LockCall(pChannel->hCall, &pCall) == CC_OK) {
			// Note that dwTransID is set to the call handle of the peer who
			// initiated the close channel request. When the close channel response
			// is received, the dwTransID gives us back the call handle to which
			// the response must be forwarded
			H245CloseChannelReq(pCall->H245Instance,
								hCall,	// dwTransID
								pChannel->wRemoteChannelNumber);
			UnlockCall(pCall);
		}
		UnlockChannel(pChannel);
		UnlockConference(pConference);
	}
	return H245_ERROR_OK;
}


	
HRESULT _IndNonStandard(			H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL									hCall;
PCALL										pCall;
CC_HCONFERENCE								hConference;
PCONFERENCE									pConference;
CC_RX_NONSTANDARD_MESSAGE_CALLBACK_PARAMS	RxNonStandardMessageCallbackParams;

	// We only handle H221 non-standard messages; if pwObjectId is non-NULL,
	// ignore the message
	if (pH245ConfIndData->u.Indication.u.IndNonstandard.pwObjectId != NULL)
		return H245_ERROR_OK;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pCall->hConference;

	switch (pH245ConfIndData->u.Indication.Indicator) {
		case H245_IND_NONSTANDARD_REQUEST:
			RxNonStandardMessageCallbackParams.bH245MessageType = CC_H245_MESSAGE_REQUEST;
			break;
		case H245_IND_NONSTANDARD_RESPONSE:	
 			RxNonStandardMessageCallbackParams.bH245MessageType = CC_H245_MESSAGE_RESPONSE;
			break;
		case H245_IND_NONSTANDARD_COMMAND:	
 			RxNonStandardMessageCallbackParams.bH245MessageType = CC_H245_MESSAGE_COMMAND;
			break;
		case H245_IND_NONSTANDARD:	
 			RxNonStandardMessageCallbackParams.bH245MessageType = CC_H245_MESSAGE_INDICATION;
			break;
		default:
			UnlockConference(pConference);
			return H245_ERROR_NOSUP;
	}

	RxNonStandardMessageCallbackParams.NonStandardData.sData.pOctetString =
		pH245ConfIndData->u.Indication.u.IndNonstandard.pData;
	RxNonStandardMessageCallbackParams.NonStandardData.sData.wOctetStringLength =
		(WORD)pH245ConfIndData->u.Indication.u.IndNonstandard.dwDataLength;
	RxNonStandardMessageCallbackParams.NonStandardData.bCountryCode =
		pH245ConfIndData->u.Indication.u.IndNonstandard.byCountryCode;	
	RxNonStandardMessageCallbackParams.NonStandardData.bExtension =
		pH245ConfIndData->u.Indication.u.IndNonstandard.byExtension;
	RxNonStandardMessageCallbackParams.NonStandardData.wManufacturerCode =
		pH245ConfIndData->u.Indication.u.IndNonstandard.wManufacturerCode;
	RxNonStandardMessageCallbackParams.hCall = pCall->hCall;
	if (pCall->pPeerParticipantInfo != NULL)
		RxNonStandardMessageCallbackParams.InitiatorTerminalLabel =
			pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
	else {
		RxNonStandardMessageCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
		RxNonStandardMessageCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
	}
				 
	InvokeUserConferenceCallback(pConference,
		                         CC_RX_NONSTANDARD_MESSAGE_INDICATION,
								 CC_OK,
								 &RxNonStandardMessageCallbackParams);

	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	return H245_ERROR_OK;
}



HRESULT _IndMiscellaneous(			H245_CONF_IND_T			*pH245ConfIndData,
									MiscellaneousIndication	*pMiscellaneousIndication)
{
HRESULT						status = CC_OK;
CC_HCALL					hCall;
PCALL						pCall;
PCALL						pOldCall;
CC_HCONFERENCE				hConference;
PCONFERENCE					pConference;
CC_HCHANNEL					hChannel;
PCHANNEL					pChannel;
WORD						i;
WORD						wNumCalls;
PCC_HCALL					CallList;
PDU_T						Pdu;
CC_MUTE_CALLBACK_PARAMS		MuteCallbackParams;
CC_UNMUTE_CALLBACK_PARAMS	UnMuteCallbackParams;
CC_H245_MISCELLANEOUS_INDICATION_CALLBACK_PARAMS	H245MiscellaneousIndicationCallbackParams;

	if (pMiscellaneousIndication == NULL)
		// Should never hit this case
		return H245_ERROR_NOSUP;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pCall->hConference;

	switch (pMiscellaneousIndication->type.choice) {
		case logicalChannelActive_chosen:
		case logicalChannelInactive_chosen:

			UnlockCall(pCall);

			if (FindChannelInConference(pMiscellaneousIndication->logicalChannelNumber,
										FALSE,	// remote channel number
										RX_CHANNEL | PROXY_CHANNEL,
										hCall,
										&hChannel,
										pConference) != CC_OK) {
				UnlockConference(pConference);
				return H245_ERROR_OK;
			}

			if (LockChannel(hChannel, &pChannel) != CC_OK) {
				UnlockConference(pConference);
				return H245_ERROR_OK;
			}

			if (pChannel->bChannelType == PROXY_CHANNEL) {
				ASSERT(pConference->ConferenceMode == MULTIPOINT_MODE);
				ASSERT(pConference->tsMultipointController == TS_TRUE);
				ASSERT(pChannel->bMultipointChannel == TRUE);

				// Construct an H.245 PDU to hold a miscellaneous indication
				// of "logical channel inactive" (mute) or "logical channel active" (unmute)
				Pdu.choice = indication_chosen;
				Pdu.u.indication.choice = miscellaneousIndication_chosen;
				Pdu.u.indication.u.miscellaneousIndication.logicalChannelNumber =
					pChannel->wLocalChannelNumber;
				Pdu.u.indication.u.miscellaneousIndication.type.choice =
					pMiscellaneousIndication->type.choice;

				EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
				for (i = 0; i < wNumCalls; i++) {
					if (CallList[i] != hCall) {
						if (LockCall(CallList[i], &pCall) == CC_OK) {
							H245SendPDU(pCall->H245Instance, &Pdu);
							UnlockCall(pCall);
						}
					}
				}
				Free(CallList);
			}

			if (pMiscellaneousIndication->type.choice == logicalChannelActive_chosen) {
				if (pChannel->tsAccepted == TS_TRUE) {
					UnMuteCallbackParams.hChannel = hChannel;
					InvokeUserConferenceCallback(pConference,
												 CC_UNMUTE_INDICATION,
												 CC_OK,
												 &UnMuteCallbackParams);
				}
			} else {
				if (pChannel->tsAccepted == TS_TRUE) {
					MuteCallbackParams.hChannel = hChannel;
					InvokeUserConferenceCallback(pConference,
												 CC_MUTE_INDICATION,
												 CC_OK,
												 &MuteCallbackParams);
				}
			}

			if (ValidateChannel(hChannel) == CC_OK)
				UnlockChannel(pChannel);
			if (ValidateConference(hConference) == CC_OK)
				UnlockConference(pConference);
			status = H245_ERROR_OK;
			break;

		case multipointConference_chosen:
		case cnclMltpntCnfrnc_chosen:
			// We're required to support receipt of this indication, but I have no
			// idea what we're supposed to do with it
			UnlockCall(pCall);
			UnlockConference(pConference);
			status = H245_ERROR_OK;
			break;

		case vdIndctRdyTActvt_chosen:
		case MIn_tp_vdTmprlSptlTrdOff_chosen:
			if (FindChannelInConference(pMiscellaneousIndication->logicalChannelNumber,
										FALSE,	// remote channel number
										RX_CHANNEL | PROXY_CHANNEL,
										hCall,
										&hChannel,
										pConference) != CC_OK) {
				UnlockCall(pCall);
				UnlockConference(pConference);
				return H245_ERROR_OK;
			}

			if (LockChannel(hChannel, &pChannel) != CC_OK) {
				UnlockCall(pCall);
				UnlockConference(pConference);
				return H245_ERROR_OK;
			}

			if (pChannel->bChannelType == PROXY_CHANNEL) {
				ASSERT(pConference->ConferenceMode == MULTIPOINT_MODE);
				ASSERT(pConference->tsMultipointController == TS_TRUE);
				ASSERT(pChannel->bMultipointChannel == TRUE);

				// Construct an H.245 PDU to hold a miscellaneous indication
				// of "video indicate ready to activate" or 
				// "video temporal spatial tradeoff"
				Pdu.choice = indication_chosen;
				Pdu.u.indication.choice = miscellaneousIndication_chosen;
				Pdu.u.indication.u.miscellaneousIndication.logicalChannelNumber =
					pChannel->wLocalChannelNumber;
				Pdu.u.indication.u.miscellaneousIndication.type.choice =
					pMiscellaneousIndication->type.choice;

				EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
				for (i = 0; i < wNumCalls; i++) {
					if (CallList[i] != hCall) {
						if (LockCall(CallList[i], &pOldCall) == CC_OK) {
							H245SendPDU(pOldCall->H245Instance, &Pdu);
							UnlockCall(pOldCall);
						}
					}
				}
				Free(CallList);
			}

			if (pChannel->tsAccepted == TS_TRUE) {
				H245MiscellaneousIndicationCallbackParams.hCall = hCall;
				if (pCall->pPeerParticipantInfo == NULL) {
					H245MiscellaneousIndicationCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
					H245MiscellaneousIndicationCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
				} else
					H245MiscellaneousIndicationCallbackParams.InitiatorTerminalLabel =
						pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
				H245MiscellaneousIndicationCallbackParams.hChannel = hChannel;
				H245MiscellaneousIndicationCallbackParams.pMiscellaneousIndication =
					pMiscellaneousIndication;

				status = InvokeUserConferenceCallback(pConference,
											 CC_H245_MISCELLANEOUS_INDICATION_INDICATION,
											 CC_OK,
											 &H245MiscellaneousIndicationCallbackParams);
				if (status != CC_OK)
					status = H245_ERROR_NOSUP;
			} else
				status = H245_ERROR_OK;

			if (ValidateChannel(hChannel) == CC_OK)
				UnlockChannel(pChannel);
			if (ValidateCall(hCall) == CC_OK)
				UnlockCall(pCall);
			if (ValidateConference(hConference) == CC_OK)
				UnlockConference(pConference);
			break;

		case videoNotDecodedMBs_chosen:
			if (FindChannelInConference(pMiscellaneousIndication->logicalChannelNumber,
										TRUE,	// local channel number
										TX_CHANNEL | PROXY_CHANNEL,
										CC_INVALID_HANDLE,
										&hChannel,
										pConference) != CC_OK) {
				UnlockCall(pCall);
				UnlockConference(pConference);
				return H245_ERROR_OK;
			}

			if (LockChannel(hChannel, &pChannel) != CC_OK) {
				UnlockCall(pCall);
				UnlockConference(pConference);
				return H245_ERROR_OK;
			}

			if (pChannel->bChannelType == TX_CHANNEL) {
				H245MiscellaneousIndicationCallbackParams.hCall = hCall;
				if (pCall->pPeerParticipantInfo == NULL) {
					H245MiscellaneousIndicationCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
					H245MiscellaneousIndicationCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
				} else
					H245MiscellaneousIndicationCallbackParams.InitiatorTerminalLabel =
						pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
				H245MiscellaneousIndicationCallbackParams.hChannel = hChannel;
				H245MiscellaneousIndicationCallbackParams.pMiscellaneousIndication =
					pMiscellaneousIndication;

				status = InvokeUserConferenceCallback(pConference,
											 CC_H245_MISCELLANEOUS_INDICATION_INDICATION,
											 CC_OK,
											 &H245MiscellaneousIndicationCallbackParams);
				if (status != CC_OK)
					status = H245_ERROR_NOSUP;

				if (ValidateChannel(hChannel) == CC_OK)
					UnlockChannel(pChannel);
				if (ValidateCall(hCall) == CC_OK)
					UnlockCall(pCall);
				if (ValidateConference(hConference) == CC_OK)
					UnlockConference(pConference);
				return status;
			} else {
				// Proxy channel; forward the request to the transmitter
  				ASSERT(pConference->ConferenceMode == MULTIPOINT_MODE);
				ASSERT(pConference->tsMultipointController == TS_TRUE);
				ASSERT(pChannel->bMultipointChannel == TRUE);

				// Construct an H.245 PDU to hold a miscellaneous indication
				// of "video not decoded MBs" 
				Pdu.choice = indication_chosen;
				Pdu.u.indication.choice = miscellaneousIndication_chosen;
				Pdu.u.indication.u.miscellaneousIndication.logicalChannelNumber =
					pChannel->wRemoteChannelNumber;
				Pdu.u.indication.u.miscellaneousIndication.type.choice =
					pMiscellaneousIndication->type.choice;

				if (LockCall(pChannel->hCall, &pOldCall) == CC_OK) {
					H245SendPDU(pOldCall->H245Instance, &Pdu);
					UnlockCall(pOldCall);
				}
				UnlockChannel(pChannel);
				UnlockCall(pCall);
				UnlockConference(pConference);
				return H245_ERROR_OK;
			}
			// We should never reach here
			ASSERT(0);

		default:
			// Miscellaneous indication	not containing channel information
			// Pass it up to the client
			H245MiscellaneousIndicationCallbackParams.hCall = hCall;
			if (pCall->pPeerParticipantInfo == NULL) {
				H245MiscellaneousIndicationCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
				H245MiscellaneousIndicationCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
			} else
				H245MiscellaneousIndicationCallbackParams.InitiatorTerminalLabel =
					pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
			H245MiscellaneousIndicationCallbackParams.hChannel = CC_INVALID_HANDLE;;
			H245MiscellaneousIndicationCallbackParams.pMiscellaneousIndication =
				pMiscellaneousIndication;

			status = InvokeUserConferenceCallback(pConference,
										 CC_H245_MISCELLANEOUS_INDICATION_INDICATION,
										 CC_OK,
										 &H245MiscellaneousIndicationCallbackParams);

			if (status != CC_OK)
				status = H245_ERROR_NOSUP;
			if (ValidateCall(hCall) == CC_OK)
				UnlockCall(pCall);
			if (ValidateConference(hConference) == CC_OK)
				UnlockConference(pConference);
			break;
	}

	return status;

	// We should never reach this point
	ASSERT(0);
}



HRESULT _IndMiscellaneousCommand(	H245_CONF_IND_T			*pH245ConfIndData,
									MiscellaneousCommand	*pMiscellaneousCommand)
{
CC_HCALL					hCall;
PCALL						pCall;
PCALL						pOldCall;
CC_HCONFERENCE				hConference;
PCONFERENCE					pConference;
HRESULT						status = CC_OK;
WORD						wChoice;
CC_HCHANNEL					hChannel;
PCHANNEL					pChannel;
PDU_T						Pdu;
CC_H245_MISCELLANEOUS_COMMAND_CALLBACK_PARAMS	H245MiscellaneousCommandCallbackParams;

	if (pMiscellaneousCommand == NULL)
		// Should never hit this case
		return H245_ERROR_NOSUP;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pConference->hConference;

	switch (pMiscellaneousCommand->type.choice) {
		case multipointModeCommand_chosen:
			if (pConference->bMultipointCapable == FALSE) {
				// We can't support multipoint operation, so treat this as if
				// we received a remote hangup indication
				UnlockConference(pConference);
				UnlockCall(pCall);
				ProcessRemoteHangup(hCall, CC_INVALID_HANDLE, CC_REJECT_NORMAL_CALL_CLEARING);
				return H245_ERROR_OK;
			} else {
				pConference->ConferenceMode = MULTIPOINT_MODE;

				// Send TerminalListRequest
				H245ConferenceRequest(pCall->H245Instance,
									  H245_REQ_TERMINAL_LIST,
									  pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber,
									  pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber);
			}
			status = H245_ERROR_OK;
			break;

		case cnclMltpntMdCmmnd_chosen:
			// We're required to support receipt of this command, but I have no
			// idea what we're supposed to do with it
			status = H245_ERROR_OK;
			break;

		case videoFreezePicture_chosen:
		case videoFastUpdatePicture_chosen:
		case videoFastUpdateGOB_chosen:
		case MCd_tp_vdTmprlSptlTrdOff_chosen:
		case videoSendSyncEveryGOB_chosen:
		case videoFastUpdateMB_chosen:
		case vdSndSyncEvryGOBCncl_chosen:
			if (FindChannelInConference(pMiscellaneousCommand->logicalChannelNumber,
										TRUE,	// local channel number
										TX_CHANNEL | PROXY_CHANNEL,
										CC_INVALID_HANDLE,
										&hChannel,
										pConference) != CC_OK) {
				UnlockCall(pCall);
				UnlockConference(pConference);
				return H245_ERROR_OK;
			}

			if (LockChannel(hChannel, &pChannel) != CC_OK) {
				UnlockCall(pCall);
				UnlockConference(pConference);
				return H245_ERROR_OK;
			}

			if (pChannel->bChannelType == TX_CHANNEL) {
				H245MiscellaneousCommandCallbackParams.hCall = hCall;
				if (pCall->pPeerParticipantInfo == NULL) {
					H245MiscellaneousCommandCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
					H245MiscellaneousCommandCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
				} else
					H245MiscellaneousCommandCallbackParams.InitiatorTerminalLabel =
						pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
				H245MiscellaneousCommandCallbackParams.hChannel = hChannel;
				wChoice = pMiscellaneousCommand->type.choice;
				if ((wChoice == videoFreezePicture_chosen) ||
					(wChoice == videoFastUpdatePicture_chosen) ||
					(wChoice == videoFastUpdateGOB_chosen) ||
					(wChoice == videoFastUpdateMB_chosen))
					H245MiscellaneousCommandCallbackParams.bH323ActionRequired = TRUE;
				else
					H245MiscellaneousCommandCallbackParams.bH323ActionRequired = FALSE;
				H245MiscellaneousCommandCallbackParams.pMiscellaneousCommand =
					pMiscellaneousCommand;

				status = InvokeUserConferenceCallback(pConference,
											 CC_H245_MISCELLANEOUS_COMMAND_INDICATION,
											 CC_OK,
											 &H245MiscellaneousCommandCallbackParams);
				if (status != CC_OK)
					status = H245_ERROR_NOSUP;

				if (ValidateChannel(hChannel) == CC_OK)
					UnlockChannel(pChannel);
				if (ValidateCall(hCall) == CC_OK)
					UnlockCall(pCall);
				if (ValidateConference(hConference) == CC_OK)
					UnlockConference(pConference);
				return status;
			} else {
				// Proxy channel; forward the request to the transmitter
  				ASSERT(pConference->ConferenceMode == MULTIPOINT_MODE);
				ASSERT(pConference->tsMultipointController == TS_TRUE);
				ASSERT(pChannel->bMultipointChannel == TRUE);

				Pdu.choice = MSCMg_cmmnd_chosen;
				Pdu.u.MSCMg_cmmnd.choice = miscellaneousCommand_chosen;
				Pdu.u.MSCMg_cmmnd.u.miscellaneousCommand.logicalChannelNumber =
					pChannel->wRemoteChannelNumber;
				Pdu.u.MSCMg_cmmnd.u.miscellaneousCommand = *pMiscellaneousCommand;
				if (LockCall(pChannel->hCall, &pOldCall) == CC_OK) {
					H245SendPDU(pOldCall->H245Instance, &Pdu);
					UnlockCall(pOldCall);
				}
				UnlockChannel(pChannel);
				UnlockCall(pCall);
				UnlockConference(pConference);
				return H245_ERROR_OK;
			}
			// We should never reach here
			ASSERT(0);

		default:
			// Unrecognized miscellaneous command
			// Pass it up to the client
			H245MiscellaneousCommandCallbackParams.hCall = hCall;
			if (pCall->pPeerParticipantInfo == NULL) {
				H245MiscellaneousCommandCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
				H245MiscellaneousCommandCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
			} else
				H245MiscellaneousCommandCallbackParams.InitiatorTerminalLabel =
					pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
			H245MiscellaneousCommandCallbackParams.hChannel = CC_INVALID_HANDLE;
			H245MiscellaneousCommandCallbackParams.bH323ActionRequired = FALSE;
			H245MiscellaneousCommandCallbackParams.pMiscellaneousCommand =
				pMiscellaneousCommand;
			status = InvokeUserConferenceCallback(pConference,
												  CC_H245_MISCELLANEOUS_COMMAND_INDICATION,
												  CC_OK,
												  &H245MiscellaneousCommandCallbackParams);
			if (status != CC_OK)
				status = H245_ERROR_NOSUP;
			if (ValidateCall(hCall) == CC_OK)
				UnlockCall(pCall);
			if (ValidateConference(hConference) == CC_OK)
				UnlockConference(pConference);
			return status;
	}

	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);

	return status;

	// We should never reach this point
	ASSERT(0);
}



HRESULT _IndMCLocation(				H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL					hCall;
PCALL						pCall;
PCONFERENCE					pConference;
CC_CONNECT_CALLBACK_PARAMS	ConnectCallbackParams;
PCALL						pEnqueuedCall;
CC_HCALL					hEnqueuedCall;
HRESULT						status;
CC_HCONFERENCE				hConference;

	if (pH245ConfIndData->u.Indication.u.IndMcLocation.type != H245_IP_UNICAST)
		return H245_ERROR_OK;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;

	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	UnlockCall(pCall);

	hConference = pConference->hConference;

	if (pConference->tsMultipointController != TS_FALSE) {
		// We don't expect to receive an MCLocationIndication until master/slave
		// has completed, at which time tsMultipointController will change from
		// TS_UNKNOWN to either TS_TRUE or TS_FALSE.
		UnlockConference(pConference);
		return H245_ERROR_NOSUP;
	}

	if (pConference->pMultipointControllerAddr == NULL) {
		pConference->pMultipointControllerAddr = (PCC_ADDR)Malloc(sizeof(CC_ADDR));
		if (pConference->pMultipointControllerAddr == NULL) {
			UnlockConference(pConference);
			return H245_ERROR_OK;
		}
	}
	pConference->pMultipointControllerAddr->nAddrType = CC_IP_BINARY;
	pConference->pMultipointControllerAddr->bMulticast = FALSE;
	pConference->pMultipointControllerAddr->Addr.IP_Binary.wPort =
		pH245ConfIndData->u.Indication.u.IndMcLocation.u.ip.tsapIdentifier;
	H245IPNetworkToHost(&pConference->pMultipointControllerAddr->Addr.IP_Binary.dwAddr,
						pH245ConfIndData->u.Indication.u.IndMcLocation.u.ip.network);

	// place all calls enqueued on this conference object
	for ( ; ; ) {
		// Start up all enqueued calls, if any exist
		status = RemoveEnqueuedCallFromConference(pConference, &hEnqueuedCall);
		if ((status != CC_OK) || (hEnqueuedCall == CC_INVALID_HANDLE))
			break;

		status = LockCall(hEnqueuedCall, &pEnqueuedCall);
		if (status == CC_OK) {
			// Place Call to MC
			pEnqueuedCall->CallState = PLACED;
			pEnqueuedCall->CallType = THIRD_PARTY_INVITOR;
			if (pEnqueuedCall->pQ931DestinationAddr == NULL)
				pEnqueuedCall->pQ931DestinationAddr = pEnqueuedCall->pQ931PeerConnectAddr;
			if (pEnqueuedCall->pQ931PeerConnectAddr == NULL)
				pEnqueuedCall->pQ931PeerConnectAddr = (PCC_ADDR)Malloc(sizeof(CC_ADDR));
			if (pEnqueuedCall->pQ931PeerConnectAddr == NULL) {
				MarkCallForDeletion(pEnqueuedCall);
				ConnectCallbackParams.pNonStandardData = pEnqueuedCall->pPeerNonStandardData;
				ConnectCallbackParams.pszPeerDisplay = pEnqueuedCall->pszPeerDisplay;
				ConnectCallbackParams.bRejectReason = CC_REJECT_UNDEFINED_REASON;
				ConnectCallbackParams.pTermCapList = pEnqueuedCall->pPeerH245TermCapList;
				ConnectCallbackParams.pH2250MuxCapability = pEnqueuedCall->pPeerH245H2250MuxCapability;
				ConnectCallbackParams.pTermCapDescriptors = pEnqueuedCall->pPeerH245TermCapDescriptors;
				ConnectCallbackParams.pLocalAddr = pEnqueuedCall->pQ931LocalConnectAddr;
	            if (pEnqueuedCall->pQ931DestinationAddr == NULL)
		            ConnectCallbackParams.pPeerAddr = pEnqueuedCall->pQ931PeerConnectAddr;
	            else
		            ConnectCallbackParams.pPeerAddr = pEnqueuedCall->pQ931DestinationAddr;
				ConnectCallbackParams.pVendorInfo = pEnqueuedCall->pPeerVendorInfo;
				ConnectCallbackParams.bMultipointConference = TRUE;
				ConnectCallbackParams.pConferenceID = &pConference->ConferenceID;
				ConnectCallbackParams.pMCAddress = pConference->pMultipointControllerAddr;
				ConnectCallbackParams.pAlternateAddress = NULL;
				ConnectCallbackParams.dwUserToken = pEnqueuedCall->dwUserToken;

				InvokeUserConferenceCallback(pConference,
									 CC_CONNECT_INDICATION,
									 CC_NO_MEMORY,
									 &ConnectCallbackParams);

				if (ValidateCallMarkedForDeletion(hEnqueuedCall) == CC_OK)
					FreeCall(pEnqueuedCall);
				if (ValidateConference(hConference) != CC_OK)
					return H245_ERROR_OK;
			}
			pEnqueuedCall->pQ931PeerConnectAddr = pConference->pMultipointControllerAddr;

			status = PlaceCall(pEnqueuedCall, pConference);
			UnlockCall(pEnqueuedCall);
		}
	}

	UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _IndConferenceRequest(		H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL					hCall;
PCALL						pCall;
PCALL						pPeerCall;
CC_HCONFERENCE				hConference;
PCONFERENCE					pConference;
HRESULT						status;
H245_TERMINAL_LABEL_T		*H245TerminalLabelList;
H245_TERMINAL_LABEL_T		H245TerminalLabel;
WORD						wNumTerminalLabels;
CC_H245_CONFERENCE_REQUEST_CALLBACK_PARAMS	H245ConferenceRequestCallbackParams;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pConference->hConference;

	switch (pH245ConfIndData->u.Indication.u.IndConferReq.RequestType) {
		case H245_REQ_ENTER_H243_TERMINAL_ID:
			switch (pConference->LocalParticipantInfo.TerminalIDState) {
				case TERMINAL_ID_INVALID:
					UnlockCall(pCall);
					EnqueueRequest(&pConference->LocalParticipantInfo.pEnqueuedRequestsForTerminalID,
								   hCall);
					pConference->LocalParticipantInfo.TerminalIDState = TERMINAL_ID_REQUESTED;
					InvokeUserConferenceCallback(pConference,
									 CC_TERMINAL_ID_REQUEST_INDICATION,
									 CC_OK,
									 NULL);
					if (ValidateConference(hConference) == CC_OK)
						UnlockConference(pConference);
					return H245_ERROR_OK;

				case TERMINAL_ID_REQUESTED:
					UnlockCall(pCall);
					EnqueueRequest(&pConference->LocalParticipantInfo.pEnqueuedRequestsForTerminalID,
								   hCall);
					UnlockConference(pConference);
					return H245_ERROR_OK;

				case TERMINAL_ID_VALID:
					H245ConferenceResponse(pCall->H245Instance,
										   H245_RSP_TERMINAL_ID,
										   pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber,
										   pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber,
										   pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString,
										   (BYTE)pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength,
										   NULL,					// terminal list
										   0);						// terminal list count
					UnlockCall(pCall);
					UnlockConference(pConference);
					return H245_ERROR_OK;

				default:
					ASSERT(0);
			}

		case H245_REQ_TERMINAL_LIST:
			if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
				(pConference->tsMultipointController == TS_TRUE)) {
				status = EnumerateTerminalLabelsInConference(&wNumTerminalLabels,
													      &H245TerminalLabelList,
														  pConference);
				if (status == CC_OK)
					H245ConferenceResponse(pCall->H245Instance,
										   H245_RSP_TERMINAL_LIST,
										   pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber,
										   pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber,
										   pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString,
										   (BYTE)pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength,
										   H245TerminalLabelList,		// terminal list
										   wNumTerminalLabels);			// terminal list count
				if (H245TerminalLabelList != NULL)
					Free(H245TerminalLabelList);
				status = H245_ERROR_OK;
			} else
				status = H245_ERROR_NOSUP;
			break;

		case H245_REQ_TERMINAL_ID:
			if (pConference->tsMultipointController != TS_TRUE) {
				status = H245_ERROR_NOSUP;
				break;
			}

			if (pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber !=
				pH245ConfIndData->u.Indication.u.IndConferReq.byMcuNumber) {
				// This terminal ID wasn't allocated by this MC, so return without a response
				status = H245_ERROR_OK;
				break;
			}

			// First check to see whether the requested terminal ID is ours
			if (pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber ==
				 pH245ConfIndData->u.Indication.u.IndConferReq.byTerminalNumber) {
			    if (pConference->LocalEndpointAttached != ATTACHED) {
					status = H245_ERROR_OK;
					break;
				}

  				switch (pConference->LocalParticipantInfo.TerminalIDState) {
					case TERMINAL_ID_INVALID:
						UnlockCall(pCall);
						EnqueueRequest(&pConference->LocalParticipantInfo.pEnqueuedRequestsForTerminalID,
									   hCall);
						pConference->LocalParticipantInfo.TerminalIDState = TERMINAL_ID_REQUESTED;
						InvokeUserConferenceCallback(pConference,
										 CC_TERMINAL_ID_REQUEST_INDICATION,
										 CC_OK,
										 NULL);
						if (ValidateConference(hConference) == CC_OK)
							UnlockConference(pConference);
						return H245_ERROR_OK;

					case TERMINAL_ID_REQUESTED:
						UnlockCall(pCall);
						EnqueueRequest(&pConference->LocalParticipantInfo.pEnqueuedRequestsForTerminalID,
									   hCall);
						UnlockConference(pConference);
						return H245_ERROR_OK;

					case TERMINAL_ID_VALID:
						H245ConferenceResponse(pCall->H245Instance,
											   H245_RSP_MC_TERMINAL_ID,
											   pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber,
											   pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber,
											   pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString,
											   (BYTE)pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength,
											   NULL,					// terminal list
											   0);						// terminal list count
						UnlockCall(pCall);
						UnlockConference(pConference);
						return H245_ERROR_OK;

					default:
						ASSERT(0);
				}
			}

			H245TerminalLabel.mcuNumber = pH245ConfIndData->u.Indication.u.IndConferReq.byMcuNumber;
			H245TerminalLabel.terminalNumber = pH245ConfIndData->u.Indication.u.IndConferReq.byTerminalNumber;

			FindPeerParticipantInfo(H245TerminalLabel,
									pConference,
									ESTABLISHED_CALL,
									&pPeerCall);
			if (pPeerCall == NULL) {
				// We don't know about the existance of this terminal ID, so return without a response
				status = H245_ERROR_OK;
				break;
			}

			if (pPeerCall->pPeerParticipantInfo == NULL) {
				UnlockCall(pPeerCall);
				status = H245_ERROR_OK;
				break;
			}

			switch (pPeerCall->pPeerParticipantInfo->TerminalIDState) {
				case TERMINAL_ID_INVALID:
					EnqueueRequest(&pPeerCall->pPeerParticipantInfo->pEnqueuedRequestsForTerminalID,
								   hCall);
					pPeerCall->pPeerParticipantInfo->TerminalIDState = TERMINAL_ID_REQUESTED;
  					H245ConferenceRequest(pPeerCall->H245Instance,
										  H245_REQ_ENTER_H243_TERMINAL_ID,
										  pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber,
										  pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber);
					break;

				case TERMINAL_ID_REQUESTED:
					EnqueueRequest(&pPeerCall->pPeerParticipantInfo->pEnqueuedRequestsForTerminalID,
								   hCall);
					break;

				case TERMINAL_ID_VALID:
					H245ConferenceResponse(pCall->H245Instance,
										   H245_RSP_MC_TERMINAL_ID,
										   pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber,
										   pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber,
										   pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.pOctetString,
										   (BYTE)pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.wOctetStringLength,
										   NULL,			// terminal list
										   0);				// terminal list count
					break;

				default:
					ASSERT(0);
					break;
			}
			UnlockCall(pPeerCall);
			status = H245_ERROR_OK;
			break;

		default:
			H245ConferenceRequestCallbackParams.hCall = hCall;
			if (pCall->pPeerParticipantInfo == NULL) {
				H245ConferenceRequestCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
				H245ConferenceRequestCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
			} else
				H245ConferenceRequestCallbackParams.InitiatorTerminalLabel =
					pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
			H245ConferenceRequestCallbackParams.RequestType =
				pH245ConfIndData->u.Indication.u.IndConferReq.RequestType;
			H245ConferenceRequestCallbackParams.TerminalLabel.bMCUNumber =
				pH245ConfIndData->u.Indication.u.IndConferReq.byMcuNumber;
			H245ConferenceRequestCallbackParams.TerminalLabel.bTerminalNumber =
				pH245ConfIndData->u.Indication.u.IndConferReq.byTerminalNumber;
			status = InvokeUserConferenceCallback(pConference,
												  CC_H245_CONFERENCE_REQUEST_INDICATION,
												  CC_OK,
												  &H245ConferenceRequestCallbackParams);
			if (status != CC_OK)
				status = H245_ERROR_NOSUP;
			break;
	}

	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return status;
}



HRESULT _IndConferenceResponse(		H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL						hCall;
PCALL							pCall;
PCALL							pPeerCall;
CC_HCALL						hEnqueuedCall;
PCALL							pEnqueuedCall;
CC_HCALL						hVirtualCall;
CC_HCALL						hPeerCall;
PCALL							pVirtualCall;
PCONFERENCE						pConference;
CC_HCONFERENCE					hConference;
HRESULT							status;
WORD							i;
PPARTICIPANTINFO				pPeerParticipantInfo;
H245_TERMINAL_LABEL_T			TerminalLabel;
CC_PEER_ADD_CALLBACK_PARAMS		PeerAddCallbackParams;
CC_PEER_UPDATE_CALLBACK_PARAMS	PeerUpdateCallbackParams;
CC_H245_CONFERENCE_RESPONSE_CALLBACK_PARAMS	H245ConferenceResponseCallbackParams;
CC_OCTETSTRING					OctetString;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pConference->hConference;

	switch (pH245ConfIndData->u.Indication.u.IndConferRsp.ResponseType) {
		case H245_RSP_TERMINAL_LIST:
			if (pConference->tsMultipointController == TS_FALSE) {
				for (i = 0; i < pH245ConfIndData->u.Indication.u.IndConferRsp.wTerminalListCount; i++) {
					if ((pH245ConfIndData->u.Indication.u.IndConferRsp.pTerminalList[i].mcuNumber ==
						 pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber) &&
						(pH245ConfIndData->u.Indication.u.IndConferRsp.pTerminalList[i].terminalNumber ==
						 pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber))
						// This terminal number refers to us
						continue;
					FindPeerParticipantInfo(pH245ConfIndData->u.Indication.u.IndConferRsp.pTerminalList[i],
											pConference,
											VIRTUAL_CALL,
											&pPeerCall);
					if (pPeerCall != NULL) {
						// We already know this peer's terminal label, and we
						// eithet know its terminal ID or we have a pending request
						// to obtain it
						UnlockCall(pPeerCall);
						continue;
					}

					// We don't know about this peer.
					// Create a virtual call object for it, and issue a request
					// for its terminal ID
					status = AllocAndLockCall(&hVirtualCall,
											  pConference->hConference,
											  CC_INVALID_HANDLE,	// hQ931Call
											  CC_INVALID_HANDLE,	// hQ931CallInvitor
											  NULL,					// pLocalAliasNames
											  NULL,					// pPeerAliasNames
											  NULL,					// pPeerExtraAliasNames
											  NULL,					// pPeerExtension
											  NULL,					// pLocalNonStandardData
											  NULL,					// pPeerNonStandardData
											  NULL,					// pszLocalDisplay
											  NULL,					// pszPeerDisplay
											  NULL,					// pPeerVendorInfo
											  NULL,					// pQ931LocalConnectAddr
											  NULL,					// pQ931PeerConnectAddr
											  NULL,					// pQ931DestinationAddr
											  NULL,					// pSourceCallSignalAddr
											  VIRTUAL,				// CallType
											  FALSE,				// bCallerIsMC
											  0,					// dwUserToken
											  CALL_COMPLETE,		// InitialCallState
											  0,					// bandwidth
											  &pConference->ConferenceID,
											  &pVirtualCall);
					if (status == CC_OK) {
						status = AllocatePeerParticipantInfo(NULL,
														     &pPeerParticipantInfo);
						if (status == CC_OK) {
							pVirtualCall->pPeerParticipantInfo =
								pPeerParticipantInfo;
							pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber =
								(BYTE)pH245ConfIndData->u.Indication.u.IndConferRsp.pTerminalList[i].mcuNumber;
							pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber =
								(BYTE)pH245ConfIndData->u.Indication.u.IndConferRsp.pTerminalList[i].terminalNumber;
							AddVirtualCallToConference(pVirtualCall,
													   pConference);
							// Send RequestTerminalID
							H245ConferenceRequest(pCall->H245Instance,
										          H245_REQ_TERMINAL_ID,
										          (BYTE)pH245ConfIndData->u.Indication.u.IndConferRsp.pTerminalList[i].mcuNumber,
												  (BYTE)pH245ConfIndData->u.Indication.u.IndConferRsp.pTerminalList[i].terminalNumber);
							pPeerParticipantInfo->TerminalIDState = TERMINAL_ID_REQUESTED;

							// Generate PEER_ADD callback
							PeerAddCallbackParams.hCall = hVirtualCall;
							PeerAddCallbackParams.TerminalLabel =
								pVirtualCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
							PeerAddCallbackParams.pPeerTerminalID = NULL;
							InvokeUserConferenceCallback(pConference,
												 CC_PEER_ADD_INDICATION,
												 CC_OK,
												 &PeerAddCallbackParams);
							if (ValidateCall(hVirtualCall) == CC_OK)
								UnlockCall(pVirtualCall);
						} else
							FreeCall(pVirtualCall);
					}
				}
			}
			status = H245_ERROR_OK;
			break;

		case H245_RSP_MC_TERMINAL_ID:
			if (pConference->tsMultipointController == TS_FALSE) {
				TerminalLabel.mcuNumber = pH245ConfIndData->u.Indication.u.IndConferRsp.byMcuNumber;
				TerminalLabel.terminalNumber = pH245ConfIndData->u.Indication.u.IndConferRsp.byTerminalNumber;
				FindPeerParticipantInfo(TerminalLabel,
										pConference,
										VIRTUAL_CALL,
										&pPeerCall);
				if (pPeerCall != NULL) {
					hPeerCall = pPeerCall->hCall;
					if (pPeerCall->pPeerParticipantInfo->TerminalIDState != TERMINAL_ID_VALID) {
						pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.pOctetString =
							(BYTE *)Malloc(pH245ConfIndData->u.Indication.u.IndConferRsp.byOctetStringLength);
						if (pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.pOctetString == NULL) {
							UnlockCall(pPeerCall);
							status = H245_ERROR_OK;
							break;
						}
						memcpy(pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.pOctetString,
							   pH245ConfIndData->u.Indication.u.IndConferRsp.pOctetString,
							   pH245ConfIndData->u.Indication.u.IndConferRsp.byOctetStringLength);
						pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.wOctetStringLength =
							pH245ConfIndData->u.Indication.u.IndConferRsp.byOctetStringLength;
						pPeerCall->pPeerParticipantInfo->TerminalIDState = TERMINAL_ID_VALID;
						
						PeerUpdateCallbackParams.hCall = hPeerCall;
						PeerUpdateCallbackParams.TerminalLabel =
							pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
						PeerUpdateCallbackParams.pPeerTerminalID = &pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID;
						InvokeUserConferenceCallback(pConference,
													 CC_PEER_UPDATE_INDICATION,
													 CC_OK,
													 &PeerUpdateCallbackParams);
					}
					if (ValidateCall(hPeerCall) == CC_OK)
						UnlockCall(pPeerCall);
				}
			}
			status = H245_ERROR_OK;
			break;

		case H245_RSP_TERMINAL_ID:
			if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
				(pConference->tsMultipointController == TS_TRUE)) {
				TerminalLabel.mcuNumber = pH245ConfIndData->u.Indication.u.IndConferRsp.byMcuNumber;
				TerminalLabel.terminalNumber = pH245ConfIndData->u.Indication.u.IndConferRsp.byTerminalNumber;
				FindPeerParticipantInfo(TerminalLabel,
										pConference,
										ESTABLISHED_CALL,
										&pPeerCall);
				if (pPeerCall != NULL) {
					hPeerCall = pPeerCall->hCall;
					if (pPeerCall->pPeerParticipantInfo->TerminalIDState != TERMINAL_ID_VALID) {
						pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.pOctetString =
							(BYTE *)Malloc(pH245ConfIndData->u.Indication.u.IndConferRsp.byOctetStringLength);
						if (pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.pOctetString == NULL) {
							UnlockCall(pPeerCall);
							status = H245_ERROR_OK;
							break;
						}
						memcpy(pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.pOctetString,
							   pH245ConfIndData->u.Indication.u.IndConferRsp.pOctetString,
							   pH245ConfIndData->u.Indication.u.IndConferRsp.byOctetStringLength);
						pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.wOctetStringLength =
							pH245ConfIndData->u.Indication.u.IndConferRsp.byOctetStringLength;
						pPeerCall->pPeerParticipantInfo->TerminalIDState = TERMINAL_ID_VALID;
						
						// Dequeue and respond to each enqueued request for this terminal ID
						while (DequeueRequest(&pPeerCall->pPeerParticipantInfo->pEnqueuedRequestsForTerminalID,
											  &hEnqueuedCall) == CC_OK) {
							if (LockCall(hEnqueuedCall, &pEnqueuedCall) == CC_OK) {
								H245ConferenceResponse(pEnqueuedCall->H245Instance,
													   H245_RSP_MC_TERMINAL_ID,
													   pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber,
													   pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber,
													   pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.pOctetString,
													   (BYTE)pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.wOctetStringLength,
													   NULL,			// terminal list
													   0);				// terminal list count

								UnlockCall(pEnqueuedCall);
							}
						}

						// Generate a CC_PEER_UPDATE_INDICATION callback
						PeerUpdateCallbackParams.hCall = hPeerCall;
						PeerUpdateCallbackParams.TerminalLabel =
							pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
						PeerUpdateCallbackParams.pPeerTerminalID = &pPeerCall->pPeerParticipantInfo->ParticipantInfo.TerminalID;
						InvokeUserConferenceCallback(pConference,
													 CC_PEER_UPDATE_INDICATION,
													 CC_OK,
													 &PeerUpdateCallbackParams);
					}
					if (ValidateCall(hPeerCall) == CC_OK)
						UnlockCall(pPeerCall);
				}
			}
			status = H245_ERROR_OK;
			break;

		default:
			H245ConferenceResponseCallbackParams.hCall = hCall;
			if (pCall->pPeerParticipantInfo == NULL) {
				H245ConferenceResponseCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
				H245ConferenceResponseCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
			} else
				H245ConferenceResponseCallbackParams.InitiatorTerminalLabel =
					pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
			H245ConferenceResponseCallbackParams.ResponseType =
				pH245ConfIndData->u.Indication.u.IndConferRsp.ResponseType;
			H245ConferenceResponseCallbackParams.TerminalLabel.bMCUNumber =
				pH245ConfIndData->u.Indication.u.IndConferRsp.byMcuNumber;
			H245ConferenceResponseCallbackParams.TerminalLabel.bTerminalNumber =
				pH245ConfIndData->u.Indication.u.IndConferRsp.byTerminalNumber;
			if ((pH245ConfIndData->u.Indication.u.IndConferRsp.pOctetString == NULL) ||
				(pH245ConfIndData->u.Indication.u.IndConferRsp.byOctetStringLength == 0)) {
				H245ConferenceResponseCallbackParams.pOctetString = NULL;
			} else {
				OctetString.pOctetString =
					pH245ConfIndData->u.Indication.u.IndConferRsp.pOctetString;
				OctetString.wOctetStringLength =
					pH245ConfIndData->u.Indication.u.IndConferRsp.byOctetStringLength;
				H245ConferenceResponseCallbackParams.pOctetString = &OctetString;
			}
			if (pH245ConfIndData->u.Indication.u.IndConferRsp.wTerminalListCount == 0) {
				H245ConferenceResponseCallbackParams.pTerminalList = NULL;
				H245ConferenceResponseCallbackParams.wTerminalListCount = 0;
				status = CC_OK;
			} else {
				H245ConferenceResponseCallbackParams.pTerminalList =
					(CC_TERMINAL_LABEL *)Malloc(sizeof(CC_TERMINAL_LABEL) *
						pH245ConfIndData->u.Indication.u.IndConferRsp.wTerminalListCount);
				if (H245ConferenceResponseCallbackParams.pTerminalList == NULL) {
					H245ConferenceResponseCallbackParams.wTerminalListCount = 0;
					status = CC_NO_MEMORY;
				} else {
					for (i = 0; i < pH245ConfIndData->u.Indication.u.IndConferRsp.wTerminalListCount; i++) {
						H245ConferenceResponseCallbackParams.pTerminalList[i].bMCUNumber =
							(BYTE)pH245ConfIndData->u.Indication.u.IndConferRsp.pTerminalList[i].mcuNumber;
						H245ConferenceResponseCallbackParams.pTerminalList[i].bMCUNumber =
							(BYTE)pH245ConfIndData->u.Indication.u.IndConferRsp.pTerminalList[i].terminalNumber;
					}
					H245ConferenceResponseCallbackParams.wTerminalListCount =
						pH245ConfIndData->u.Indication.u.IndConferRsp.wTerminalListCount;
					status = CC_OK;
				}
			}
			status = InvokeUserConferenceCallback(pConference,
												  CC_H245_CONFERENCE_RESPONSE_INDICATION,
												  status,
												  &H245ConferenceResponseCallbackParams);
			if (status != CC_OK)
				status = H245_ERROR_NOSUP;
			if (H245ConferenceResponseCallbackParams.pTerminalList != NULL)
				Free(H245ConferenceResponseCallbackParams.pTerminalList);
			break;
	}

	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return status;
}




HRESULT _IndConferenceCommand(		H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL						hCall;
PCALL							pCall;
PCALL							pOldCall;
PCONFERENCE						pConference;
CC_HCONFERENCE					hConference;
WORD							i;
WORD							wNumCalls;
PCC_HCALL						CallList;
WORD							wNumChannels;
PCC_HCHANNEL					ChannelList;
PCHANNEL						pChannel;
CC_HCHANNEL						hChannel;
CALLSTATE						CallState;
HQ931CALL						hQ931Call;
H245_INST_T						H245Instance;
HRESULT							status = CC_OK;
CC_H245_CONFERENCE_COMMAND_CALLBACK_PARAMS	H245ConferenceCommandCallbackParams;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pConference->hConference;

	switch (pH245ConfIndData->u.Indication.u.IndConferCmd.CommandType) {
		case H245_CMD_DROP_CONFERENCE:
			if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
				(pConference->tsMultipointController == TS_TRUE)) {
				UnlockCall(pCall);
				EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ALL_CALLS);
				for (i = 0; i < wNumCalls; i++) {
					if (LockCall(CallList[i], &pCall) == CC_OK) {
						hQ931Call = pCall->hQ931Call;
						H245Instance = pCall->H245Instance;
						CallState = pCall->CallState;
						FreeCall(pCall);
						switch (CallState) {
							case ENQUEUED:
								break;

							case PLACED:
							case RINGING:
								Q931Hangup(hQ931Call, CC_REJECT_NORMAL_CALL_CLEARING);
								break;

							default:
								H245ShutDown(H245Instance);
								Q931Hangup(hQ931Call, CC_REJECT_NORMAL_CALL_CLEARING);
								break;
						}
					}
				}
				if (CallList != NULL)
					Free(CallList);

				EnumerateChannelsInConference(&wNumChannels,
											  &ChannelList,
											  pConference,
											  ALL_CHANNELS);
				for (i = 0; i < wNumChannels; i++) {
					if (LockChannel(ChannelList[i], &pChannel) == CC_OK) 
						FreeChannel(pChannel);
				}
				if (ChannelList != NULL)
					Free(ChannelList);
						
				InvokeUserConferenceCallback(
									 pConference,
			                         CC_CONFERENCE_TERMINATION_INDICATION,
									 CC_OK,
									 NULL);
				if (ValidateConference(hConference) == CC_OK) {
					if (pConference->bDeferredDelete)
						FreeConference(pConference);
					else {
						ReInitializeConference(pConference);
						UnlockConference(pConference);
					}
				}
				return H245_ERROR_OK;
			}
			status = H245_ERROR_OK;
			break;

		case brdcstMyLgclChnnl_chosen:
		case cnclBrdcstMyLgclChnnl_chosen:
			if (FindChannelInConference(pH245ConfIndData->u.Indication.u.IndConferCmd.Channel,
										FALSE,	// remote channel number
										RX_CHANNEL | PROXY_CHANNEL,
										hCall,
										&hChannel,
										pConference) != CC_OK) {
				UnlockCall(pCall);
				UnlockConference(pConference);
				return H245_ERROR_OK;
			}

			if (LockChannel(hChannel, &pChannel) != CC_OK) {
				UnlockCall(pCall);
				UnlockConference(pConference);
				return H245_ERROR_OK;
			}
			
			if (pChannel->bChannelType == PROXY_CHANNEL) {
				ASSERT(pConference->ConferenceMode == MULTIPOINT_MODE);
				ASSERT(pConference->tsMultipointController == TS_TRUE);
				ASSERT(pChannel->bMultipointChannel == TRUE);

				EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
				for (i = 0; i < wNumCalls; i++) {
					if (CallList[i] != hCall) {
						if (LockCall(CallList[i], &pOldCall) == CC_OK) {
							H245ConferenceCommand(pOldCall->H245Instance,
												  pH245ConfIndData->u.Indication.u.IndConferCmd.CommandType,
												  pChannel->wLocalChannelNumber,
												  pH245ConfIndData->u.Indication.u.IndConferCmd.byMcuNumber,
												  pH245ConfIndData->u.Indication.u.IndConferCmd.byTerminalNumber);
							UnlockCall(pOldCall);
						}
					}
				}
				Free(CallList);
			}

			if (pChannel->tsAccepted == TS_TRUE) {
				H245ConferenceCommandCallbackParams.hCall = hCall;
				H245ConferenceCommandCallbackParams.hChannel = hChannel;
				if (pCall->pPeerParticipantInfo == NULL) {
					H245ConferenceCommandCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
					H245ConferenceCommandCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
				} else
					H245ConferenceCommandCallbackParams.InitiatorTerminalLabel =
						pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
				H245ConferenceCommandCallbackParams.CommandType =
					pH245ConfIndData->u.Indication.u.IndConferCmd.CommandType;
				H245ConferenceCommandCallbackParams.TerminalLabel.bMCUNumber =
					pH245ConfIndData->u.Indication.u.IndConferCmd.byMcuNumber;
				H245ConferenceCommandCallbackParams.TerminalLabel.bTerminalNumber =
					pH245ConfIndData->u.Indication.u.IndConferCmd.byTerminalNumber;
				status = InvokeUserConferenceCallback(pConference,
													  CC_H245_CONFERENCE_COMMAND_INDICATION,
													  CC_OK,
													  &H245ConferenceCommandCallbackParams);
				if (status != CC_OK)
					status = H245_ERROR_NOSUP;
			} else
				status = H245_ERROR_OK;

			if (ValidateChannel(hChannel) == CC_OK)
				UnlockChannel(pChannel);
			if (ValidateCall(hCall) == CC_OK)
				UnlockCall(pCall);
			if (ValidateConference(hConference) == CC_OK)
				UnlockConference(pConference);
			return status;

		default:
			// Unrecognized conference command
			// Pass it up to the client
			H245ConferenceCommandCallbackParams.hCall = hCall;
			if (pCall->pPeerParticipantInfo == NULL) {
				H245ConferenceCommandCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
				H245ConferenceCommandCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
			} else
				H245ConferenceCommandCallbackParams.InitiatorTerminalLabel =
					pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
			H245ConferenceCommandCallbackParams.CommandType =
				pH245ConfIndData->u.Indication.u.IndConferCmd.CommandType;
			H245ConferenceCommandCallbackParams.TerminalLabel.bMCUNumber =
				pH245ConfIndData->u.Indication.u.IndConferCmd.byMcuNumber;
			H245ConferenceCommandCallbackParams.TerminalLabel.bTerminalNumber =
				pH245ConfIndData->u.Indication.u.IndConferCmd.byTerminalNumber;
			H245ConferenceCommandCallbackParams.hChannel = CC_INVALID_HANDLE;
			
			status = InvokeUserConferenceCallback(pConference,
												  CC_H245_CONFERENCE_COMMAND_INDICATION,
												  CC_OK,
												  &H245ConferenceCommandCallbackParams);
			if (status != CC_OK)
				status = H245_ERROR_NOSUP;
			if (ValidateCall(hCall) == CC_OK)
				UnlockCall(pCall);
			if (ValidateConference(hConference) == CC_OK)
				UnlockConference(pConference);
			return status;
	}

	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return status;
}



HRESULT _IndConference(				H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL						hCall;
PCALL							pCall;
PCALL							pPeerCall;
PCONFERENCE						pConference;
CC_HCONFERENCE					hConference;
H245_TERMINAL_LABEL_T			H245TerminalLabel;
PPARTICIPANTINFO				pPeerParticipantInfo;
HRESULT							status;
CC_HCALL						hVirtualCall;
PCALL							pVirtualCall;
CC_PEER_ADD_CALLBACK_PARAMS		PeerAddCallbackParams;
CC_PEER_DROP_CALLBACK_PARAMS	PeerDropCallbackParams;
CC_H245_CONFERENCE_INDICATION_CALLBACK_PARAMS	H245ConferenceIndicationCallbackParams;


	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pConference->hConference;

	switch (pH245ConfIndData->u.Indication.u.IndConfer.IndicationType) {
		case H245_IND_TERMINAL_NUMBER_ASSIGN:
			if (pConference->tsMultipointController == TS_FALSE) {
				pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber =
					pH245ConfIndData->u.Indication.u.IndConfer.byMcuNumber;
				pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber =
					pH245ConfIndData->u.Indication.u.IndConfer.byTerminalNumber;
			}
			status = H245_ERROR_OK;
			break;

		case H245_IND_TERMINAL_JOINED:
			if (pConference->tsMultipointController == TS_FALSE) {
				if ((pH245ConfIndData->u.Indication.u.IndConfer.byMcuNumber ==
					 pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber) &&
					(pH245ConfIndData->u.Indication.u.IndConfer.byTerminalNumber ==
					 pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber)) {
					// This message refers to us
					status = H245_ERROR_OK;
					break;
				}

				H245TerminalLabel.mcuNumber = pH245ConfIndData->u.Indication.u.IndConfer.byMcuNumber;
				H245TerminalLabel.terminalNumber = pH245ConfIndData->u.Indication.u.IndConfer.byTerminalNumber;
				FindPeerParticipantInfo(H245TerminalLabel,
										pConference,
										VIRTUAL_CALL,
										&pPeerCall);
				if (pPeerCall != NULL) {
					// We already know this peer's terminal label, and we
					// eithet know its terminal ID or we have a pending request
					// to obtain it
					UnlockCall(pPeerCall);
					status = H245_ERROR_OK;
					break;
				}

				// We don't know about this peer.
				// Create a virtual call object for it, and issue a request
				// for its terminal ID
				status = AllocAndLockCall(&hVirtualCall,
										  pConference->hConference,
										  CC_INVALID_HANDLE,	// hQ931Call
										  CC_INVALID_HANDLE,	// hQ931CallInvitor
										  NULL,					// pLocalAliasNames
										  NULL,					// pPeerAliasNames
										  NULL,					// pPeerExtraAliasNames
										  NULL,					// pPeerExtension
										  NULL,					// pLocalNonStandardData
										  NULL,					// pPeerNonStandardData
										  NULL,					// pszLocalDisplay
										  NULL,					// pszPeerDisplay
										  NULL,					// pPeerVendorInfo
										  NULL,					// pQ931LocalConnectAddr
										  NULL,					// pQ931PeerConnectAddr
										  NULL,					// pQ931DestinationAddr
										  NULL,					// pSourceCallSignalAddr
										  VIRTUAL,				// CallType
										  FALSE,				// bCallerIsMC
										  0,					// dwUserToken
										  CALL_COMPLETE,		// InitialCallState
										  0,					// bandwidth
										  &pConference->ConferenceID,
										  &pVirtualCall);
				if (status == CC_OK) {
					status = AllocatePeerParticipantInfo(NULL,
														 &pPeerParticipantInfo);
					if (status == CC_OK) {
						pVirtualCall->pPeerParticipantInfo =
							pPeerParticipantInfo;
						pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber =
							(BYTE)H245TerminalLabel.mcuNumber;
						pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber =
							(BYTE)H245TerminalLabel.terminalNumber;
						AddVirtualCallToConference(pVirtualCall,
												   pConference);
						// Send RequestTerminalID
						H245ConferenceRequest(pCall->H245Instance,
										      H245_REQ_TERMINAL_ID,
										      (BYTE)H245TerminalLabel.mcuNumber,
											  (BYTE)H245TerminalLabel.terminalNumber);
						pPeerParticipantInfo->TerminalIDState = TERMINAL_ID_REQUESTED;

						// Generate PEER_ADD callback
						PeerAddCallbackParams.hCall = hVirtualCall;
						PeerAddCallbackParams.TerminalLabel =
							pVirtualCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
						PeerAddCallbackParams.pPeerTerminalID = NULL;
						InvokeUserConferenceCallback(pConference,
											 CC_PEER_ADD_INDICATION,
											 CC_OK,
											 &PeerAddCallbackParams);
						if (ValidateCall(hVirtualCall) == CC_OK)
	 						UnlockCall(pVirtualCall);
						if (ValidateConference(hConference) == CC_OK)
							UnlockConference(pConference);
						UnlockCall(pCall);
						return H245_ERROR_OK;
					} else
						FreeCall(pVirtualCall);
				}
			}
			status = H245_ERROR_OK;
			break;

		case H245_IND_TERMINAL_LEFT:
			if (pConference->tsMultipointController == TS_FALSE) {
				H245TerminalLabel.mcuNumber = pH245ConfIndData->u.Indication.u.IndConfer.byMcuNumber;
				H245TerminalLabel.terminalNumber = pH245ConfIndData->u.Indication.u.IndConfer.byTerminalNumber;
				
				status = FindPeerParticipantInfo(H245TerminalLabel,
												 pConference,
												 VIRTUAL_CALL,
												 &pVirtualCall);
				if (status == CC_OK) {
					ASSERT(pVirtualCall != NULL);
					ASSERT(pVirtualCall->pPeerParticipantInfo != NULL);
					// Save the virtual call handle; we'll need to validate the virtual
					// call object after returning from the conference callback
					hVirtualCall = pVirtualCall->hCall;
					PeerDropCallbackParams.hCall = hVirtualCall;
					PeerDropCallbackParams.TerminalLabel = pVirtualCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
					if (pVirtualCall->pPeerParticipantInfo->TerminalIDState == TERMINAL_ID_VALID)
						PeerDropCallbackParams.pPeerTerminalID = &pVirtualCall->pPeerParticipantInfo->ParticipantInfo.TerminalID;
					else
						PeerDropCallbackParams.pPeerTerminalID = NULL;
				} else {
					// Set pVirtualCall to NULL to indicate that we don't have
					// a virtual call object that needs to be free'd up later
					pVirtualCall = NULL;
					PeerDropCallbackParams.hCall = CC_INVALID_HANDLE;
					PeerDropCallbackParams.TerminalLabel.bMCUNumber = pH245ConfIndData->u.Indication.u.IndConfer.byMcuNumber;
					PeerDropCallbackParams.TerminalLabel.bTerminalNumber = pH245ConfIndData->u.Indication.u.IndConfer.byTerminalNumber;
					PeerDropCallbackParams.pPeerTerminalID = NULL;
				}

				hConference = pConference->hConference;

				// Generate a CC_PEER_DROP_INDICATION callback
				InvokeUserConferenceCallback(pConference,
											 CC_PEER_DROP_INDICATION,
											 CC_OK,
											 &PeerDropCallbackParams);
				if (ValidateConference(hConference) == CC_OK)
					UnlockConference(pConference);
				// Check to see if we have a virtual call object that needs to be free'd up
				if (pVirtualCall != NULL)
					if (ValidateCall(hVirtualCall) == CC_OK)
						FreeCall(pVirtualCall);
				UnlockCall(pCall);
				return H245_ERROR_OK;
			}
			status = H245_ERROR_OK;
			break;

		default:
			H245ConferenceIndicationCallbackParams.hCall = hCall;
			if (pCall->pPeerParticipantInfo == NULL) {
				H245ConferenceIndicationCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
				H245ConferenceIndicationCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
			} else
				H245ConferenceIndicationCallbackParams.InitiatorTerminalLabel =
					pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
			H245ConferenceIndicationCallbackParams.IndicationType =
				pH245ConfIndData->u.Indication.u.IndConfer.IndicationType;
			H245ConferenceIndicationCallbackParams.bSBENumber =
				pH245ConfIndData->u.Indication.u.IndConfer.bySbeNumber;
			H245ConferenceIndicationCallbackParams.TerminalLabel.bMCUNumber =
				pH245ConfIndData->u.Indication.u.IndConfer.byMcuNumber;
			H245ConferenceIndicationCallbackParams.TerminalLabel.bTerminalNumber =
				pH245ConfIndData->u.Indication.u.IndConfer.byTerminalNumber;
			status = InvokeUserConferenceCallback(pConference,
												  CC_H245_CONFERENCE_INDICATION_INDICATION,
												  CC_OK,
												  &H245ConferenceIndicationCallbackParams);
			if (status != CC_OK)
				status = H245_ERROR_NOSUP;
			break;
	}
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return status;
}



HRESULT _IndCommunicationModeCommand(
									H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL						hCall;
PCALL							pCall;
CC_HCONFERENCE					hConference;
PCONFERENCE						pConference;
CC_MULTIPOINT_CALLBACK_PARAMS	MultipointCallbackParams;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	if (pConference->tsMultipointController == TS_TRUE) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	hConference = pConference->hConference;

	// Destroy the old session table
	FreeConferenceSessionTable(pConference);

	H245CommunicationTableToSessionTable(
									pH245ConfIndData->u.Indication.u.IndCommRsp.pTable,
									pH245ConfIndData->u.Indication.u.IndCommRsp.byTableCount,
									&pConference->pSessionTable);
	
	pConference->bSessionTableInternallyConstructed = TRUE;

	// Generate MULTIPOINT callback
	MultipointCallbackParams.pTerminalInfo = &pConference->LocalParticipantInfo.ParticipantInfo;
	MultipointCallbackParams.pSessionTable = pConference->pSessionTable;
	InvokeUserConferenceCallback(pConference,
								 CC_MULTIPOINT_INDICATION,
								 CC_OK,
								 &MultipointCallbackParams);

	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _IndVendorIdentification(	H245_CONF_IND_T			*pH245ConfIndData,
									VendorIdentification	*pVendorIdentification)
{
CC_HCALL						hCall;
PCALL							pCall;
CC_HCONFERENCE					hConference;
PCONFERENCE						pConference;
CC_NONSTANDARDDATA				NonStandardData;
CC_OCTETSTRING					ProductNumber;
CC_OCTETSTRING					VersionNumber;
CC_VENDOR_ID_CALLBACK_PARAMS	VendorIDCallbackParams;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pConference->hConference;

	VendorIDCallbackParams.hCall = hCall;
	if (pCall->pPeerParticipantInfo == NULL) {
		VendorIDCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
		VendorIDCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
	} else
		VendorIDCallbackParams.InitiatorTerminalLabel =
			pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;

	if (pVendorIdentification->vendor.choice == h221NonStandard_chosen) {
		NonStandardData.sData.pOctetString = NULL;
		NonStandardData.sData.wOctetStringLength = 0;
		NonStandardData.bCountryCode = (BYTE)pVendorIdentification->vendor.u.h221NonStandard.t35CountryCode;
		NonStandardData.bExtension = (BYTE)pVendorIdentification->vendor.u.h221NonStandard.t35Extension;
		NonStandardData.wManufacturerCode = pVendorIdentification->vendor.u.h221NonStandard.manufacturerCode;
		VendorIDCallbackParams.pNonStandardData = &NonStandardData;
	} else
		VendorIDCallbackParams.pNonStandardData = NULL;

	if (pVendorIdentification->bit_mask & productNumber_present) {
		ProductNumber.pOctetString =
			pVendorIdentification->productNumber.value;
                ProductNumber.wOctetStringLength = (WORD)
			pVendorIdentification->productNumber.length;
		VendorIDCallbackParams.pProductNumber = &ProductNumber;
	} else
		VendorIDCallbackParams.pProductNumber = NULL;
	if (pVendorIdentification->bit_mask & versionNumber_present) {
		VersionNumber.pOctetString =
			pVendorIdentification->versionNumber.value;
                VersionNumber.wOctetStringLength = (WORD)
			pVendorIdentification->versionNumber.length;
		VendorIDCallbackParams.pVersionNumber = &VersionNumber;
	} else
		VendorIDCallbackParams.pVersionNumber = NULL;

	InvokeUserConferenceCallback(pConference,
								 CC_VENDOR_ID_INDICATION,
								 CC_OK,
								 &VendorIDCallbackParams);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _IndH2250MaximumSkew(		H245_CONF_IND_T			*pH245ConfIndData)
{
HRESULT			status;
CC_HCONFERENCE	hConference;
PCONFERENCE		pConference;
CC_HCALL		hCall;
PCC_HCALL		CallList;
WORD			wNumCalls;
WORD			i;
PCALL			pCall;
PCALL			pOldCall;
CC_HCHANNEL		hChannel1;
PCHANNEL		pChannel1;
CC_HCHANNEL		hChannel2;
PCHANNEL		pChannel2;
CC_MAXIMUM_AUDIO_VIDEO_SKEW_CALLBACK_PARAMS	MaximumAudioVideoSkewCallbackParams;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		// This may be OK, if the call was cancelled while
		// call setup was in progress.
		return H245_ERROR_OK;
	}

	hConference = pCall->hConference;
	UnlockCall(pCall);

	if (FindChannelInConference(pH245ConfIndData->u.Indication.u.IndH2250MaxSkew.LogicalChannelNumber1,
		                        FALSE,	// remote channel number
								RX_CHANNEL | PROXY_CHANNEL,
								hCall,
		                        &hChannel1,
								pConference) != CC_OK) {
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	if (LockChannel(hChannel1, &pChannel1) != CC_OK) {
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}
	
	if (pChannel1->bChannelType == RX_CHANNEL) {
		UnlockChannel(pChannel1);
		if (FindChannelInConference(pH245ConfIndData->u.Indication.u.IndH2250MaxSkew.LogicalChannelNumber2,
		                        FALSE,	// remote channel number
								RX_CHANNEL,
								hCall,
		                        &hChannel2,
								pConference) != CC_OK) {
			UnlockConference(pConference);
			return H245_ERROR_OK;
		}
		if (LockChannel(hChannel2, &pChannel2) != CC_OK) {
			UnlockConference(pConference);
			return H245_ERROR_OK;
		}
		if (pChannel2->bChannelType != RX_CHANNEL) {
			UnlockChannel(pChannel2);
			UnlockConference(pConference);
			return H245_ERROR_OK;
		}
		UnlockChannel(pChannel2);

		MaximumAudioVideoSkewCallbackParams.hChannel1 = hChannel1;
		MaximumAudioVideoSkewCallbackParams.hChannel2 = hChannel2;
		MaximumAudioVideoSkewCallbackParams.wMaximumSkew =
			pH245ConfIndData->u.Indication.u.IndH2250MaxSkew.wSkew;
		InvokeUserConferenceCallback(pConference,
									 CC_MAXIMUM_AUDIO_VIDEO_SKEW_INDICATION,
									 CC_OK,
									 &MaximumAudioVideoSkewCallbackParams);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
	} else { // pChannel1->bChannelType == PROXY_CHANNEL
		if (FindChannelInConference(pH245ConfIndData->u.Indication.u.IndH2250MaxSkew.LogicalChannelNumber2,
									FALSE,	// remote channel number
									PROXY_CHANNEL,
									hCall,
									&hChannel2,
									pConference) != CC_OK) {
			UnlockChannel(pChannel1);
			UnlockConference(pConference);
			return H245_ERROR_OK;
		}
		if (LockChannel(hChannel2, &pChannel2) != CC_OK) {
			UnlockChannel(pChannel1);
			UnlockConference(pConference);
			return H245_ERROR_OK;
		}
		if (pChannel1->hCall != pChannel2->hCall) {
			UnlockChannel(pChannel1);
			UnlockChannel(pChannel2);
			UnlockConference(pConference);
			return H245_ERROR_OK;
		}

		EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
		for (i = 0; i < wNumCalls; i++) {
			if (CallList[i] != hCall) {
				if (LockCall(CallList[i], &pOldCall) == CC_OK) {
 					H245H2250MaximumSkewIndication(pOldCall->H245Instance,
											pChannel1->wLocalChannelNumber,
											pChannel2->wLocalChannelNumber,
											pH245ConfIndData->u.Indication.u.IndH2250MaxSkew.wSkew);
					UnlockCall(pCall);
				}
			}
		}

		if (CallList != NULL)
			Free(CallList);

		if ((pChannel1->tsAccepted == TS_TRUE) && (pChannel2->tsAccepted == TS_TRUE)) {
 			MaximumAudioVideoSkewCallbackParams.hChannel1 = hChannel1;
			MaximumAudioVideoSkewCallbackParams.hChannel2 = hChannel2;
			MaximumAudioVideoSkewCallbackParams.wMaximumSkew =
				pH245ConfIndData->u.Indication.u.IndH2250MaxSkew.wSkew;
			InvokeUserConferenceCallback(pConference,
										 CC_MAXIMUM_AUDIO_VIDEO_SKEW_INDICATION,
										 CC_OK,
										 &MaximumAudioVideoSkewCallbackParams);
		}

		if (ValidateChannel(hChannel1) == CC_OK)
			UnlockChannel(pChannel1);
		if (ValidateChannel(hChannel2) == CC_OK)
			UnlockChannel(pChannel2);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
	}
	return H245_ERROR_OK;
}



HRESULT _IndUserInput(				H245_CONF_IND_T			*pH245ConfIndData)
{
HRESULT			status;
CC_HCALL		hCall;
PCALL			pCall;
CC_HCONFERENCE	hConference;
PCONFERENCE		pConference;
CC_USER_INPUT_CALLBACK_PARAMS	UserInputCallbackParams;

	// only support user input kind string
	if (pH245ConfIndData->u.Indication.u.IndUserInput.Kind != H245_USERINPUT_STRING) {
	    return H245_ERROR_OK;
	}

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		// This may be OK, if the call was cancelled while
		// call setup was in progress.
		return H245_ERROR_OK;
	}

	hConference = pConference->hConference;

	UserInputCallbackParams.hCall = hCall;
	UserInputCallbackParams.pUserInput =
	    pH245ConfIndData->u.Indication.u.IndUserInput.u.pGenString;

	InvokeUserConferenceCallback(pConference,
								 CC_USER_INPUT_INDICATION,
								 CC_OK,
								 &UserInputCallbackParams);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _IndSendTerminalCapabilitySet(
									H245_CONF_IND_T			*pH245ConfIndData)
{
HRESULT			status;
CC_HCALL		hCall;
PCALL			pCall;
PCONFERENCE		pConference;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		// This may be OK, if the call was cancelled while
		// call setup was in progress.
		return H245_ERROR_OK;
	}

	SendTermCaps(pCall, pConference);
	UnlockCall(pCall);
	UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _IndModeRequest(			H245_CONF_IND_T			*pH245ConfIndData)
{
HRESULT			status;
CC_HCALL		hCall;
PCALL			pCall;
CC_HCONFERENCE	hConference;
PCONFERENCE		pConference;
CC_REQUEST_MODE_CALLBACK_PARAMS	RequestModeCallbackParams;

	hCall = pH245ConfIndData->u.Indication.dwPreserved;
	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		// This may be OK, if the call was cancelled while
		// call setup was in progress.
		return H245_ERROR_OK;
	}

	hConference = pConference->hConference;

    EnqueueRequest(&pConference->pEnqueuedRequestModeCalls, hCall);

	RequestModeCallbackParams.hCall = hCall;
	if (pCall->pPeerParticipantInfo == NULL) {
		RequestModeCallbackParams.InitiatorTerminalLabel.bMCUNumber = 255;
		RequestModeCallbackParams.InitiatorTerminalLabel.bTerminalNumber = 255;
	} else
		RequestModeCallbackParams.InitiatorTerminalLabel =
			pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
	RequestModeCallbackParams.pRequestedModes =
		pH245ConfIndData->u.Indication.u.IndMrse.pRequestedModes;

	InvokeUserConferenceCallback(pConference,
								 CC_REQUEST_MODE_INDICATION,
								 CC_OK,
								 &RequestModeCallbackParams);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _ConfUnimplemented(			H245_CONF_IND_T			*pH245ConfIndData)
{
	return H245_ERROR_NOSUP;
}



HRESULT _ConfBiDirectionalOpen(		H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL			hCall;
CC_HCHANNEL			hChannel;
CC_HCONFERENCE		hConference;
PCHANNEL			pChannel;
PCONFERENCE			pConference;
BOOL				bAccept;
HRESULT				status;
CC_ADDR				T120Addr;
CC_OCTETSTRING		ExternalReference;
CC_T120_CHANNEL_OPEN_CALLBACK_PARAMS	T120ChannelOpenCallbackParams;

	hCall = pH245ConfIndData->u.Confirm.dwPreserved;
	if (hCall == CC_INVALID_HANDLE)
		return H245_ERROR_OK;

	hChannel = pH245ConfIndData->u.Confirm.dwTransId;
	if (hChannel == CC_INVALID_HANDLE)
		return H245_ERROR_OK;

	if (LockChannelAndConference(hChannel, &pChannel, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pConference->hConference;

	if (pChannel->bChannelType != TXRX_CHANNEL) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	if ((pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.AccRej == H245_ACC) &&
	    (pH245ConfIndData->u.Confirm.Error == H245_ERROR_OK)) {
		pChannel->wNumOutstandingRequests = 0;
		bAccept = TRUE;
	} else {
		(pChannel->wNumOutstandingRequests)--;
		bAccept = FALSE;
	}

	T120ChannelOpenCallbackParams.hChannel = hChannel;
	T120ChannelOpenCallbackParams.hCall = hCall;
	T120ChannelOpenCallbackParams.dwUserToken = pChannel->dwUserToken;
	T120ChannelOpenCallbackParams.dwRejectReason = 0;

	if (bAccept) {
		status = CC_OK;
		if (pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.pSeparateStack) {
			if ((pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.pSeparateStack->networkAddress.choice == localAreaAddress_chosen) &&
				(pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.pSeparateStack->networkAddress.u.localAreaAddress.choice == unicastAddress_chosen) &&
				(pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.pSeparateStack->networkAddress.u.localAreaAddress.u.unicastAddress.choice == UnicastAddress_iPAddress_chosen)) {
				T120Addr.nAddrType = CC_IP_BINARY;
				T120Addr.bMulticast = FALSE;
				T120Addr.Addr.IP_Binary.wPort =
					pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.pSeparateStack->networkAddress.u.localAreaAddress.u.unicastAddress.u.UnicastAddress_iPAddress.tsapIdentifier;
				H245IPNetworkToHost(&T120Addr.Addr.IP_Binary.dwAddr,
									pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.pSeparateStack->networkAddress.u.localAreaAddress.u.unicastAddress.u.UnicastAddress_iPAddress.network.value);
				T120ChannelOpenCallbackParams.pAddr = &T120Addr;
			} else {
 				T120ChannelOpenCallbackParams.pAddr = NULL;
			}
			T120ChannelOpenCallbackParams.bAssociateConference = 
				pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.pSeparateStack->associateConference;		
			if (pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.pSeparateStack->bit_mask & externalReference_present) {
                                ExternalReference.wOctetStringLength = (WORD)
					pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.pSeparateStack->externalReference.length;
				ExternalReference.pOctetString =
					pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.pSeparateStack->externalReference.value;
				T120ChannelOpenCallbackParams.pExternalReference = &ExternalReference;
			} else
				T120ChannelOpenCallbackParams.pExternalReference = NULL;
		} else {
 			T120ChannelOpenCallbackParams.pAddr = NULL;
			T120ChannelOpenCallbackParams.bAssociateConference = FALSE;
			T120ChannelOpenCallbackParams.pExternalReference = NULL;
		}
	} else { // bAccept == FALSE
		if (pH245ConfIndData->u.Confirm.Error == H245_ERROR_OK)
			status = CC_PEER_REJECT;
		else
			status = pH245ConfIndData->u.Confirm.Error;
	 		
		T120ChannelOpenCallbackParams.pAddr = NULL;
		T120ChannelOpenCallbackParams.bAssociateConference = FALSE;
		T120ChannelOpenCallbackParams.pExternalReference = NULL;
		T120ChannelOpenCallbackParams.dwRejectReason =
			pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.AccRej;
	}

	InvokeUserConferenceCallback(pConference,
								 CC_T120_CHANNEL_OPEN_INDICATION,
								 status,
								 &T120ChannelOpenCallbackParams);

	if (ValidateChannel(hChannel) == CC_OK)
		if (bAccept)
			UnlockChannel(pChannel);
		else
			FreeChannel(pChannel);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);

	return H245_ERROR_OK;
}



HRESULT _ConfOpenT120(	H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL			hCall;
CC_HCHANNEL			hChannel;
CC_HCONFERENCE		hConference;
PCHANNEL			pChannel;
PCONFERENCE			pConference;
HRESULT				status;
CC_T120_CHANNEL_OPEN_CALLBACK_PARAMS	T120ChannelOpenCallbackParams;

	hCall = pH245ConfIndData->u.Confirm.dwPreserved;
	if (hCall == CC_INVALID_HANDLE)
		return H245_ERROR_OK;

	hChannel = pH245ConfIndData->u.Confirm.dwTransId;
	if (hChannel == CC_INVALID_HANDLE)
		return H245_ERROR_OK;

	if (LockChannelAndConference(hChannel, &pChannel, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pConference->hConference;

	if (pChannel->bChannelType != TXRX_CHANNEL) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	if ((pH245ConfIndData->u.Confirm.u.ConfOpen.AccRej == H245_ACC) &&
	    (pH245ConfIndData->u.Confirm.Error == H245_ERROR_OK)) {
		// We expect to get a ConfOpenNeedRsp callback for this case;
		// Since we're not sure how we got here, just bail out
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	T120ChannelOpenCallbackParams.hChannel = hChannel;
	T120ChannelOpenCallbackParams.hCall = hCall;
	T120ChannelOpenCallbackParams.dwUserToken = pChannel->dwUserToken;

	if (pH245ConfIndData->u.Confirm.Error == H245_ERROR_OK)
		status = CC_PEER_REJECT;
	else
		status = pH245ConfIndData->u.Confirm.Error;
	 		
	T120ChannelOpenCallbackParams.pAddr = NULL;
	T120ChannelOpenCallbackParams.bAssociateConference = FALSE;
	T120ChannelOpenCallbackParams.pExternalReference = NULL;
	T120ChannelOpenCallbackParams.dwRejectReason =
		pH245ConfIndData->u.Confirm.u.ConfOpenNeedRsp.AccRej;

	InvokeUserConferenceCallback(pConference,
								 CC_T120_CHANNEL_OPEN_INDICATION,
								 status,
								 &T120ChannelOpenCallbackParams);

	if (ValidateChannel(hChannel) == CC_OK)
		FreeChannel(pChannel);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);

	return H245_ERROR_OK;
}



HRESULT _ConfOpen(					H245_CONF_IND_T			*pH245ConfIndData)
{
HRESULT								status;
CC_ADDR								PeerRTPAddr;
PCC_ADDR							pPeerRTPAddr;
CC_ADDR								PeerRTCPAddr;
PCC_ADDR							pPeerRTCPAddr;
CC_HCHANNEL							hChannel;
PCHANNEL							pChannel;
CC_HCONFERENCE						hConference;
PCONFERENCE							pConference;
CC_TX_CHANNEL_OPEN_CALLBACK_PARAMS	TxChannelOpenCallbackParams;
PCALL								pCall;
BOOL								bAccept;
H245_MUX_T							H245MuxTable;
WORD								i;
#ifdef    GATEKEEPER
unsigned                            uBandwidth;
WORD								wNumCalls;
PCC_HCALL							CallList;
#endif // GATEKEEPER

	// a channel was opened

	hChannel = pH245ConfIndData->u.Confirm.dwTransId;
	if (hChannel == CC_INVALID_HANDLE)
		return H245_ERROR_OK;

	if (LockChannelAndConference(hChannel, &pChannel, &pConference) != CC_OK)
		return H245_ERROR_OK;

	if (pChannel->bChannelType == TXRX_CHANNEL) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		return _ConfOpenT120(pH245ConfIndData);
	}

	hConference = pConference->hConference;

	if (pChannel->wNumOutstandingRequests == 0) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	if ((pH245ConfIndData->u.Confirm.u.ConfOpen.AccRej == H245_ACC) &&
	    (pH245ConfIndData->u.Confirm.Error == H245_ERROR_OK)) {
		pChannel->wNumOutstandingRequests = 0;
		bAccept = TRUE;
	} else {
		(pChannel->wNumOutstandingRequests)--;
		bAccept = FALSE;
#ifdef    GATEKEEPER
		uBandwidth = pChannel->dwBandwidth / 100;
	    if (uBandwidth != 0 && pChannel->bChannelType != TXRX_CHANNEL) {
	        EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
		    for (i = 0; i < wNumCalls; ++i) {
			    if (LockCall(CallList[i], &pCall) == CC_OK) {
				    if (pCall->GkiCall.uBandwidthUsed >= uBandwidth) {
					    if (GkiCloseChannel(&pCall->GkiCall, pChannel->dwBandwidth, hChannel) == CC_OK) {
						    UnlockCall(pCall);
						    break;
					    }
				    }
				    UnlockCall(pCall);
			    }
		    } // for
	        if (CallList != NULL)
	            Free(CallList);
	    }
#endif // GATEKEEPER

	}
	
	if (pChannel->wNumOutstandingRequests == 0) {

		if (pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux == NULL) {
			pPeerRTPAddr = NULL;
			pPeerRTCPAddr = NULL;
		} else {
			ASSERT(pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->Kind == H245_H2250ACK);
			if ((pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->u.H2250ACK.mediaChannelPresent) &&
				((pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->u.H2250ACK.mediaChannel.type == H245_IP_MULTICAST) ||
				(pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->u.H2250ACK.mediaChannel.type == H245_IP_UNICAST))) {
				
				pPeerRTPAddr = &PeerRTPAddr;
				PeerRTPAddr.nAddrType = CC_IP_BINARY;
				if (pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->u.H2250ACK.mediaChannel.type == H245_IP_MULTICAST)
					PeerRTPAddr.bMulticast = TRUE;
				else
					PeerRTPAddr.bMulticast = FALSE;
				H245IPNetworkToHost(&PeerRTPAddr.Addr.IP_Binary.dwAddr,
									pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->u.H2250ACK.mediaChannel.u.ip.network);
				PeerRTPAddr.Addr.IP_Binary.wPort =
					pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->u.H2250ACK.mediaChannel.u.ip.tsapIdentifier;
			} else
				pPeerRTPAddr = NULL;

			if ((pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->u.H2250ACK.mediaControlChannelPresent) &&
				((pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->u.H2250ACK.mediaControlChannel.type == H245_IP_MULTICAST) ||
				(pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->u.H2250ACK.mediaControlChannel.type == H245_IP_UNICAST))) {
				
				pPeerRTCPAddr = &PeerRTCPAddr;
				PeerRTCPAddr.nAddrType = CC_IP_BINARY;
				if (pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->u.H2250ACK.mediaControlChannel.type == H245_IP_MULTICAST)
					PeerRTCPAddr.bMulticast = TRUE;
				else
					PeerRTCPAddr.bMulticast = FALSE;
				H245IPNetworkToHost(&PeerRTCPAddr.Addr.IP_Binary.dwAddr,
									pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->u.H2250ACK.mediaControlChannel.u.ip.network);
				PeerRTCPAddr.Addr.IP_Binary.wPort =
					pH245ConfIndData->u.Confirm.u.ConfOpen.pTxMux->u.H2250ACK.mediaControlChannel.u.ip.tsapIdentifier;
			} else
				pPeerRTCPAddr = NULL;
		}

		if ((pPeerRTPAddr == NULL) || (pPeerRTCPAddr == NULL)) {
			if (pConference->pSessionTable != NULL) {
				for (i = 0; i < pConference->pSessionTable->wLength; i++) {
					if (pConference->pSessionTable->SessionInfoArray[i].bSessionID ==
						pChannel->bSessionID) {
						if (pPeerRTPAddr == NULL)
							pPeerRTPAddr = pConference->pSessionTable->SessionInfoArray[i].pRTPAddr;
						if (pPeerRTCPAddr == NULL)
							pPeerRTCPAddr = pConference->pSessionTable->SessionInfoArray[i].pRTCPAddr;
						break;
					}
				}
			}
		}

		if ((pChannel->pPeerRTPAddr == NULL) && (pPeerRTPAddr != NULL))
			CopyAddr(&pChannel->pPeerRTPAddr, pPeerRTPAddr);
		if ((pChannel->pPeerRTCPAddr == NULL) && (pPeerRTCPAddr != NULL))
			CopyAddr(&pChannel->pPeerRTCPAddr, pPeerRTCPAddr);

		if (pChannel->bChannelType == PROXY_CHANNEL) {
			if (LockCall(pChannel->hCall, &pCall) == CC_OK) {
	
				if (bAccept) {
					H245MuxTable.Kind = H245_H2250ACK;
					H245MuxTable.u.H2250ACK.nonStandardList = NULL;

					if (pPeerRTPAddr != NULL) {
						if (pPeerRTPAddr->bMulticast)
							H245MuxTable.u.H2250ACK.mediaChannel.type = H245_IP_MULTICAST;
						else
							H245MuxTable.u.H2250ACK.mediaChannel.type = H245_IP_UNICAST;
						H245MuxTable.u.H2250ACK.mediaChannel.u.ip.tsapIdentifier =
							pPeerRTPAddr->Addr.IP_Binary.wPort;
						HostToH245IPNetwork(H245MuxTable.u.H2250ACK.mediaChannel.u.ip.network,
											pPeerRTPAddr->Addr.IP_Binary.dwAddr);
						H245MuxTable.u.H2250ACK.mediaChannelPresent = TRUE;
					} else
						H245MuxTable.u.H2250ACK.mediaChannelPresent = FALSE;

					if (pPeerRTCPAddr != NULL) {
						if (pPeerRTCPAddr->bMulticast)
							H245MuxTable.u.H2250ACK.mediaControlChannel.type = H245_IP_MULTICAST;
						else
							H245MuxTable.u.H2250ACK.mediaControlChannel.type = H245_IP_UNICAST;
						H245MuxTable.u.H2250ACK.mediaControlChannel.u.ip.tsapIdentifier =
							pPeerRTCPAddr->Addr.IP_Binary.wPort;
						HostToH245IPNetwork(H245MuxTable.u.H2250ACK.mediaControlChannel.u.ip.network,
											pPeerRTCPAddr->Addr.IP_Binary.dwAddr);
						H245MuxTable.u.H2250ACK.mediaControlChannelPresent = TRUE;
					} else
						H245MuxTable.u.H2250ACK.mediaControlChannelPresent = FALSE;

					H245MuxTable.u.H2250ACK.dynamicRTPPayloadTypePresent = FALSE;
					H245MuxTable.u.H2250ACK.sessionIDPresent = TRUE;
					H245MuxTable.u.H2250ACK.sessionID = pChannel->bSessionID;
					
					status = H245OpenChannelAccept(pCall->H245Instance,
												   0,					// dwTransId
												   pChannel->wRemoteChannelNumber, // Rx channel
												   &H245MuxTable,
												   0,						// Tx channel
												   NULL,					// Tx mux
												   H245_INVALID_PORT_NUMBER,// Port
												   NULL);
				} else { // bAccept == FALSE
					status = H245OpenChannelReject(pCall->H245Instance,
												   pChannel->wRemoteChannelNumber,  // Rx channel
												   (unsigned short)pH245ConfIndData->u.Confirm.u.ConfOpen.AccRej);	// rejection reason
				}
				UnlockCall(pCall);
			}
		}

		TxChannelOpenCallbackParams.hChannel = hChannel;
		TxChannelOpenCallbackParams.pPeerRTPAddr = pPeerRTPAddr;
		TxChannelOpenCallbackParams.pPeerRTCPAddr = pPeerRTCPAddr;
		TxChannelOpenCallbackParams.dwUserToken = pChannel->dwUserToken;

		if (bAccept) {
			status = CC_OK;
			TxChannelOpenCallbackParams.dwRejectReason = H245_ACC;
		} else { // bAccept = FALSE
			if (pH245ConfIndData->u.Confirm.Error == H245_ERROR_OK)
				status = CC_PEER_REJECT;
			else
				status = pH245ConfIndData->u.Confirm.Error;
			TxChannelOpenCallbackParams.dwRejectReason =
				pH245ConfIndData->u.Confirm.u.ConfOpen.AccRej;
		}

		if ((pChannel->bCallbackInvoked == FALSE) &&
		    ((pChannel->bChannelType == TX_CHANNEL) ||
			 ((pChannel->bChannelType == TXRX_CHANNEL) &&
			  (pChannel->bLocallyOpened == TRUE)))) {
			pChannel->bCallbackInvoked = TRUE;

			InvokeUserConferenceCallback(pConference,
										 CC_TX_CHANNEL_OPEN_INDICATION,
										 status,
										 &TxChannelOpenCallbackParams);
		}

		if (ValidateChannel(hChannel) == CC_OK)
			if (bAccept)
				UnlockChannel(pChannel);
			else
				FreeChannel(pChannel);
	} else
		UnlockChannel(pChannel);

	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _ConfClose(					H245_CONF_IND_T			*pH245ConfIndData)
{
    if (pH245ConfIndData->u.Confirm.Error != H245_ERROR_OK) {
        // TBD - Report error to Call Control client
    }

	return H245_ERROR_OK;
}



HRESULT _ConfRequestClose(			H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL							hCall;
CC_HCHANNEL							hChannel;
PCHANNEL							pChannel;
CC_HCONFERENCE						hConference;
PCONFERENCE							pConference;
PCALL								pCall;
H245_ACC_REJ_T						AccRej;

	hCall = pH245ConfIndData->u.Confirm.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pCall->hConference;
	UnlockCall(pCall);

    if (pH245ConfIndData->u.Confirm.Error == H245_ERROR_OK)
	    AccRej = pH245ConfIndData->u.Confirm.u.ConfReqClose.AccRej;
    else
        AccRej = H245_REJ;

	// Note: the only time we need to take any real action is when the channel
	// is a proxy channel, and the local endpoint is not the one which requested
	// the channel closure; in this case, we simply forward the closure response
	// on to the endpoint which initiated the request.
	// If the channel is an RX or TXRX channel, the channel object was deleted
	// when our client requested the channel closure, so there's no real work to
	// be done.
	// If the channel is a proxy channel which our client requested be closed,
	// the channel object will remain around until closed by the TX side, but we
	// don't need (nor do we have a mechanism) to inform our client of receipt
	// of this channel closure response.
	
	if (FindChannelInConference(pH245ConfIndData->u.Confirm.u.ConfReqClose.Channel,
								FALSE,	// remote channel number
								PROXY_CHANNEL,
								hCall,
								&hChannel,
								pConference) != CC_OK) {
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	// Set hCall to the peer which initiated the close channel request
	hCall = pH245ConfIndData->u.Confirm.dwTransId;
	if (hCall == CC_INVALID_HANDLE) {
		// The local endpoint was the one who requested the channel closure,
		// so there's no one to forwards this response onto. We don't provide
		// a callback for informing our client of receipt of this response,
		// so we can simply clean up and return
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	if (LockChannel(hChannel, &pChannel) != CC_OK) {
		UnlockConference(pConference);
		return H245_ERROR_OK;
	}

	// Forward this response onto the endpoint which requested the channel closure
	if (LockCall(hCall, &pCall) == CC_OK) {
		H245CloseChannelReqResp(pCall->H245Instance,
								AccRej,
								pChannel->wLocalChannelNumber);
		UnlockCall(pCall);
	}

	UnlockChannel(pChannel);
	UnlockConference(pConference);
	return H245_ERROR_OK;
}



#if 0

HRESULT _ConfShutdown(				H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL				hCall;
PCALL					pCall;
CC_HCONFERENCE			hConference;
PCONFERENCE				pConference;
HRESULT					status;
HQ931CALL				hQ931Call;
H245_INST_T				H245Instance;

#if 1
// Sync 2 - specific code

	hCall = pH245ConfIndData->u.Confirm.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	hConference = pCall->hConference;

	if (pConference->tsMultipointController == TS_TRUE) {
		// XXX -- invoke user callback with "peer drop indication"
	} else {
		H245Instance = pCall->H245Instance;
		hQ931Call = pCall->hQ931Call;
		FreeCall(pCall);

		if (H245Instance != H245_INVALID_ID)
			status = H245ShutDown(H245Instance);
		else
			status = H245_ERROR_OK;

		if (status == H245_ERROR_OK) {
			status = Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
			// Q931Hangup may legitimately return CS_BAD_PARAM, because the Q.931 call object
			// may have been deleted at this point
			if (status == CS_BAD_PARAM)
				status = CC_OK;
		} else
			Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);

		InvokeUserConferenceCallback(pConference,
			                         CC_CONFERENCE_TERMINATION_INDICATION,
									 status,
									 NULL);

		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);

		return H245_ERROR_OK;
	}
#else
// Probably sync 3 code
HHANGUP						hHangup;
PHANGUP						pHangup;
CC_HANGUP_CALLBACK_PARAMS	HangupCallbackParams;

	hHangup = pH245ConfIndData->u.Confirm.dwTransId;
	if (hHangup == CC_INVALID_HANDLE)
		return H245_ERROR_OK;

	if (LockHangup(hHangup, &pHangup) != CC_OK)
		return H245_ERROR_OK;

	pHangup->wNumCalls--;
	if (pHangup->wNumCalls == 0) {
		hConference = pHangup->hConference;
		if (LockConference(hConference, &pConference) != CC_OK) {
			UnlockHangup(pHangup);
			return H245_ERROR_OK;
		}
		HangupCallbackParams.dwUserToken = pHangup->dwUserToken;
		InvokeUserConferenceCallback(pConference->ConferenceCallback,
			                         CC_HANGUP_INDICATION,
									 CC_OK,
									 hConference,
									 pConference->dwConferenceToken,
									 &HangupCallbackParams);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
		if (ValidateHangup(hHangup) == CC_OK)
			FreeHangup(pHangup);
		return H245_ERROR_OK;
	} else
		UnlockHangup(pHangup);
	return H245_ERROR_OK;
#endif // Sync 3 code
}

#endif



HRESULT _ConfInitMstslv(			H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL					hCall;
PCALL						pCall;
PCONFERENCE					pConference;
CC_CONNECT_CALLBACK_PARAMS	ConnectCallbackParams;
CC_HCALL					hEnqueuedCall;
PCALL						pEnqueuedCall;
CC_HCONFERENCE				hConference;
HRESULT						status;

	hCall = pH245ConfIndData->u.Confirm.dwPreserved;
	if (LockCallAndConference(hCall, &pCall, &pConference) != CC_OK)
		return H245_ERROR_OK;

	ASSERT(pCall->MasterSlaveState != MASTER_SLAVE_COMPLETE);

	switch (pH245ConfIndData->u.Confirm.u.ConfMstSlv) {
        case H245_MASTER:
		    pConference->tsMaster = TS_TRUE;
		    if (pConference->tsMultipointController == TS_UNKNOWN) {
			    ASSERT(pConference->bMultipointCapable == TRUE);
			    pConference->tsMultipointController = TS_TRUE;

			    // place all calls enqueued on this conference object
			    for ( ; ; ) {
				    // Start up all enqueued calls, if any exist
				    status = RemoveEnqueuedCallFromConference(pConference, &hEnqueuedCall);
				    if ((status != CC_OK) || (hEnqueuedCall == CC_INVALID_HANDLE))
					    break;

				    status = LockCall(hEnqueuedCall, &pEnqueuedCall);
				    if (status == CC_OK) {
					    pEnqueuedCall->CallState = PLACED;

					    status = PlaceCall(pEnqueuedCall, pConference);
					    UnlockCall(pEnqueuedCall);
				    }
			    }
		    }
            break;

        case H245_SLAVE:
		    ASSERT(pConference->tsMaster != TS_TRUE);
		    ASSERT(pConference->tsMultipointController != TS_TRUE);
		    pConference->tsMaster = TS_FALSE;
		    pConference->tsMultipointController = TS_FALSE;

		    // XXX -- we may eventually want to re-enqueue these requests
		    // and set an expiration timer
		    hConference = pConference->hConference;
				
		    for ( ; ; ) {
			    status = RemoveEnqueuedCallFromConference(pConference, &hEnqueuedCall);
			    if ((status != CC_OK) || (hEnqueuedCall == CC_INVALID_HANDLE))
				    break;

			    status = LockCall(hEnqueuedCall, &pEnqueuedCall);
			    if (status == CC_OK) {
				    MarkCallForDeletion(pEnqueuedCall);
				    ConnectCallbackParams.pNonStandardData = pEnqueuedCall->pPeerNonStandardData;
				    ConnectCallbackParams.pszPeerDisplay = pEnqueuedCall->pszPeerDisplay;
				    ConnectCallbackParams.bRejectReason = CC_REJECT_UNDEFINED_REASON;
				    ConnectCallbackParams.pTermCapList = pEnqueuedCall->pPeerH245TermCapList;
				    ConnectCallbackParams.pH2250MuxCapability = pEnqueuedCall->pPeerH245H2250MuxCapability;
				    ConnectCallbackParams.pTermCapDescriptors = pEnqueuedCall->pPeerH245TermCapDescriptors;
				    ConnectCallbackParams.pLocalAddr = pEnqueuedCall->pQ931LocalConnectAddr;
	                if (pEnqueuedCall->pQ931DestinationAddr == NULL)
		                ConnectCallbackParams.pPeerAddr = pEnqueuedCall->pQ931PeerConnectAddr;
	                else
		                ConnectCallbackParams.pPeerAddr = pEnqueuedCall->pQ931DestinationAddr;
				    ConnectCallbackParams.pVendorInfo = pEnqueuedCall->pPeerVendorInfo;
				    ConnectCallbackParams.bMultipointConference = TRUE;
				    ConnectCallbackParams.pConferenceID = &pConference->ConferenceID;
				    ConnectCallbackParams.pMCAddress = pConference->pMultipointControllerAddr;
					ConnectCallbackParams.pAlternateAddress = NULL;
				    ConnectCallbackParams.dwUserToken = pEnqueuedCall->dwUserToken;

				    InvokeUserConferenceCallback(pConference,
									    CC_CONNECT_INDICATION,
									    CC_NOT_MULTIPOINT_CAPABLE,
									    &ConnectCallbackParams);
				    if (ValidateCallMarkedForDeletion(hEnqueuedCall) == CC_OK)
					    FreeCall(pEnqueuedCall);
				    if (ValidateConference(hConference) != CC_OK) {
					    if (ValidateCall(hCall) == CC_OK)
						    UnlockCall(pCall);
					    return H245_ERROR_OK;
				    }
			    }
		    }
            break;

        default: // H245_INDETERMINATE
			UnlockConference(pConference);
			if (++pCall->wMasterSlaveRetry < MASTER_SLAVE_RETRY_MAX) {
				H245InitMasterSlave(pCall->H245Instance, pCall->H245Instance);
			    UnlockCall(pCall);
			} else {
			    UnlockCall(pCall);
				ProcessRemoteHangup(hCall, CC_INVALID_HANDLE, CC_REJECT_UNDEFINED_REASON);
			}
			return H245_ERROR_OK;
	} // switch

	pCall->MasterSlaveState = MASTER_SLAVE_COMPLETE;

	if ((pCall->OutgoingTermCapState == TERMCAP_COMPLETE) &&
		(pCall->IncomingTermCapState == TERMCAP_COMPLETE) &&
	    (pCall->CallState == TERMCAP) &&
		(pCall->MasterSlaveState == MASTER_SLAVE_COMPLETE)) {
		// Note that _ProcessConnectionComplete() returns with pConference and pCall unlocked
		_ProcessConnectionComplete(pConference, pCall);
		return H245_ERROR_OK;
	}

	UnlockCall(pCall);
	UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _ConfSendTermCap(			H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL		hCall;
PCALL			pCall;
HRESULT			status;
PCONFERENCE		pConference;

	// A TerminalCapabilitySet message was successfully sent from this endpoint

	hCall = pH245ConfIndData->u.Confirm.dwPreserved;
	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		// This may be OK, if the call was cancelled while
		// call setup was in progress.
		return H245_ERROR_OK;
	}

    if (pH245ConfIndData->u.Confirm.Error == H245_ERROR_OK &&
        pH245ConfIndData->u.Confirm.u.ConfSndTcap.AccRej == H245_ACC) {
	    pCall->OutgoingTermCapState = TERMCAP_COMPLETE;
	    if ((pCall->IncomingTermCapState == TERMCAP_COMPLETE) &&
	        (pCall->CallState == TERMCAP) &&
		    (pCall->MasterSlaveState == MASTER_SLAVE_COMPLETE)) {
		    // Note that _ProcessConnectionComplete() returns with pConference and pCall unlocked
		    _ProcessConnectionComplete(pConference, pCall);
		    return H245_ERROR_OK;
	    }
    } else if (pCall->CallState == TERMCAP) {
        // Report error to Call Control client
		UnlockConference(pConference);
		UnlockCall(pCall);
		ProcessRemoteHangup(hCall, CC_INVALID_HANDLE, CC_REJECT_UNDEFINED_REASON);
	    return H245_ERROR_OK;
    }
    
	UnlockConference(pConference);
	UnlockCall(pCall);
	return H245_ERROR_OK;
}



HRESULT _ConfRequestMode(			H245_CONF_IND_T			*pH245ConfIndData)
{
HRESULT			status;
CC_HCALL		hCall;
PCALL			pCall;
CC_HCONFERENCE	hConference;
PCONFERENCE		pConference;
CC_REQUEST_MODE_RESPONSE_CALLBACK_PARAMS	RequestModeResponseCallbackParams;

	hCall = pH245ConfIndData->u.Confirm.dwPreserved;
	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		// This may be OK, if the call was cancelled while
		// call setup was in progress.
		return H245_ERROR_OK;
	}
	
	hConference = pConference->hConference;

	RequestModeResponseCallbackParams.hCall = hCall;
	if (pCall->pPeerParticipantInfo == NULL) {
		RequestModeResponseCallbackParams.TerminalLabel.bMCUNumber = 255;
		RequestModeResponseCallbackParams.TerminalLabel.bTerminalNumber = 255;
	} else
		RequestModeResponseCallbackParams.TerminalLabel =
			pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
	switch (pH245ConfIndData->u.Confirm.u.ConfMrse) {
		case wllTrnsmtMstPrfrrdMd_chosen:
			RequestModeResponseCallbackParams.RequestModeResponse = CC_WILL_TRANSMIT_PREFERRED_MODE;
			break;
		case wllTrnsmtLssPrfrrdMd_chosen:
			RequestModeResponseCallbackParams.RequestModeResponse = CC_WILL_TRANSMIT_LESS_PREFERRED_MODE;
			break;
		default:
			RequestModeResponseCallbackParams.RequestModeResponse = CC_REQUEST_DENIED;
			break;
	}
	InvokeUserConferenceCallback(pConference,
								 CC_REQUEST_MODE_RESPONSE_INDICATION,
								 pH245ConfIndData->u.Confirm.Error,
								 &RequestModeResponseCallbackParams);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _ConfRequestModeReject(		H245_CONF_IND_T			*pH245ConfIndData)
{
HRESULT			status;
CC_HCALL		hCall;
PCALL			pCall;
CC_HCONFERENCE	hConference;
PCONFERENCE		pConference;
CC_REQUEST_MODE_RESPONSE_CALLBACK_PARAMS	RequestModeResponseCallbackParams;

	hCall = pH245ConfIndData->u.Confirm.dwPreserved;
	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		// This may be OK, if the call was cancelled while
		// call setup was in progress.
		return H245_ERROR_OK;
	}
	
	hConference = pConference->hConference;

	RequestModeResponseCallbackParams.hCall = hCall;
	if (pCall->pPeerParticipantInfo == NULL) {
		RequestModeResponseCallbackParams.TerminalLabel.bMCUNumber = 255;
		RequestModeResponseCallbackParams.TerminalLabel.bTerminalNumber = 255;
	} else
		RequestModeResponseCallbackParams.TerminalLabel =
			pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
	switch (pH245ConfIndData->u.Confirm.u.ConfMrseReject) {
		case H245_REJ_UNAVAILABLE:
			RequestModeResponseCallbackParams.RequestModeResponse = CC_MODE_UNAVAILABLE;
			break;
		case H245_REJ_MULTIPOINT:
			RequestModeResponseCallbackParams.RequestModeResponse = CC_MULTIPOINT_CONSTRAINT;
			break;
		case H245_REJ_DENIED:
			RequestModeResponseCallbackParams.RequestModeResponse = CC_REQUEST_DENIED;
			break;
		default:
			RequestModeResponseCallbackParams.RequestModeResponse = CC_REQUEST_DENIED;
			break;
	}
	InvokeUserConferenceCallback(pConference,
								 CC_REQUEST_MODE_RESPONSE_INDICATION,
								 pH245ConfIndData->u.Confirm.Error,
								 &RequestModeResponseCallbackParams);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _ConfRequestModeExpired(		H245_CONF_IND_T			*pH245ConfIndData)
{
HRESULT			status;
CC_HCALL		hCall;
PCALL			pCall;
CC_HCONFERENCE	hConference;
PCONFERENCE		pConference;
CC_REQUEST_MODE_RESPONSE_CALLBACK_PARAMS	RequestModeResponseCallbackParams;

	hCall = pH245ConfIndData->u.Confirm.dwPreserved;
	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		// This may be OK, if the call was cancelled while
		// call setup was in progress.
		return H245_ERROR_OK;
	}
	
	hConference = pConference->hConference;

	RequestModeResponseCallbackParams.hCall = hCall;
	if (pCall->pPeerParticipantInfo == NULL) {
		RequestModeResponseCallbackParams.TerminalLabel.bMCUNumber = 255;
		RequestModeResponseCallbackParams.TerminalLabel.bTerminalNumber = 255;
	} else
		RequestModeResponseCallbackParams.TerminalLabel =
			pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
	RequestModeResponseCallbackParams.RequestModeResponse = CC_REQUEST_DENIED;
	InvokeUserConferenceCallback(pConference,
								 CC_REQUEST_MODE_RESPONSE_INDICATION,
								 pH245ConfIndData->u.Confirm.Error,
								 &RequestModeResponseCallbackParams);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _ConfRoundTrip(				H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL							hCall;
PCALL								pCall;
CC_HCONFERENCE						hConference;
PCONFERENCE							pConference;
HRESULT								status;
CC_PING_RESPONSE_CALLBACK_PARAMS	PingCallbackParams;	

	hCall = pH245ConfIndData->u.Confirm.dwPreserved;
	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		// This may be OK, if the call was cancelled while
		// call setup was in progress.
		return H245_ERROR_OK;
	}
	
	hConference = pConference->hConference;

	PingCallbackParams.hCall = hCall;
	if (pCall->pPeerParticipantInfo == NULL) {
		PingCallbackParams.TerminalLabel.bMCUNumber = 255;
		PingCallbackParams.TerminalLabel.bTerminalNumber = 255;
	} else
		PingCallbackParams.TerminalLabel =
			pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
	PingCallbackParams.bResponse = TRUE;
	InvokeUserConferenceCallback(pConference,
								 CC_PING_RESPONSE_INDICATION,
								 pH245ConfIndData->u.Confirm.Error,
								 &PingCallbackParams);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT _ConfRoundTripExpired(		H245_CONF_IND_T			*pH245ConfIndData)
{
CC_HCALL		hCall;
PCALL			pCall;
CC_HCONFERENCE	hConference;
PCONFERENCE		pConference;
HRESULT								status;
CC_PING_RESPONSE_CALLBACK_PARAMS	PingCallbackParams;	

	hCall = pH245ConfIndData->u.Confirm.dwPreserved;
	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		// This may be OK, if the call was cancelled while
		// call setup was in progress.
		return H245_ERROR_OK;
	}
	
	hConference = pConference->hConference;

	PingCallbackParams.hCall = hCall;
	if (pCall->pPeerParticipantInfo == NULL) {
		PingCallbackParams.TerminalLabel.bMCUNumber = 255;
		PingCallbackParams.TerminalLabel.bTerminalNumber = 255;
	} else
		PingCallbackParams.TerminalLabel =
			pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
	PingCallbackParams.bResponse = FALSE;
	InvokeUserConferenceCallback(pConference,
								 CC_PING_RESPONSE_INDICATION,
								 pH245ConfIndData->u.Confirm.Error,
								 &PingCallbackParams);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	return H245_ERROR_OK;
}



HRESULT H245Callback(				H245_CONF_IND_T			*pH245ConfIndData,
									void					*pMisc)
{
HRESULT	status = H245_ERROR_OK;

	EnterCallControl();

	if (CallControlState != OPERATIONAL_STATE)
		HResultLeaveCallControl(H245_ERROR_OK);

	if (pH245ConfIndData == NULL)
		HResultLeaveCallControl(H245_ERROR_OK);

	if (pH245ConfIndData->Kind == H245_CONF) {
		switch (pH245ConfIndData->u.Confirm.Confirm) {
			
			case H245_CONF_INIT_MSTSLV:
				status = _ConfInitMstslv(pH245ConfIndData);
				break;

			case H245_CONF_SEND_TERMCAP:
				status = _ConfSendTermCap(pH245ConfIndData);
				break;

			case H245_CONF_OPEN:
				status = _ConfOpen(pH245ConfIndData);
				break;

			case H245_CONF_NEEDRSP_OPEN:
				status = _ConfBiDirectionalOpen(pH245ConfIndData);
				break;

			case H245_CONF_CLOSE:
				status = _ConfClose(pH245ConfIndData);
				break;

			case H245_CONF_REQ_CLOSE:
				status = _ConfRequestClose(pH245ConfIndData);
				break;

//			case H245_CONF_MUXTBL_SND:      not valid for H.323 MuliplexEntrySend
//			case H245_CONF_RMESE:           not valid for H.323 RequestMultiplexEntry
//			case H245_CONF_RMESE_REJECT:    not valid for H.323 RequestMultiplexEntryReject
//			case H245_CONF_RMESE_EXPIRED:   not valid for H.323

			case H245_CONF_MRSE:
				status = _ConfRequestMode(pH245ConfIndData);
				break;

			case H245_CONF_MRSE_REJECT:
				status = _ConfRequestModeReject(pH245ConfIndData);
				break;

			case H245_CONF_MRSE_EXPIRED:
				status = _ConfRequestModeExpired(pH245ConfIndData);
				break;

			case H245_CONF_RTDSE:
				status = _ConfRoundTrip(pH245ConfIndData);
				break;

			case H245_CONF_RTDSE_EXPIRED:
				status = _ConfRoundTripExpired(pH245ConfIndData);
				break;

			default:
				status = _ConfUnimplemented(pH245ConfIndData);
				break;
		}
	} else if (pH245ConfIndData->Kind == H245_IND) {
		switch (pH245ConfIndData->u.Indication.Indicator) {
			
 			case H245_IND_MSTSLV:
				status = _IndMstslv(pH245ConfIndData);
				break;

			case H245_IND_CAP:
				status = _IndCapability(pH245ConfIndData);
				break;

			case H245_IND_CESE_RELEASE:
                // Remote has abandoned TerminalCapabilitySet
                // No longer need to send TerminalCapabilitySetAck
                // We can probably get away with ignoring this,
                // but we should NOT return FunctionNotSupported!
				break;

			case H245_IND_OPEN:
				status = _IndOpen(pH245ConfIndData);
				break;

			case H245_IND_OPEN_CONF:
                // Bi-directionl channel open complete
				status = _IndOpenConf(pH245ConfIndData);
				break;

			case H245_IND_CLOSE:
				status = _IndClose(pH245ConfIndData);
				break;

			case H245_IND_REQ_CLOSE:
				status = _IndRequestClose(pH245ConfIndData);
				break;

			case H245_IND_CLCSE_RELEASE:
                // Remote has abandoned RequestChannelClose
                // No longer need to send RequestChannelCloseAck and CloseLogicalChannel
                // We can probably get away with ignoring this,
                // but we should NOT return FunctionNotSupported!
				break;

//			case H245_IND_MUX_TBL:          not valid in H.323 MuliplexEntrySend
//			case H245_IND_MTSE_RELEASE      not valid in H.323 MuliplexEntrySendRelease
//			case H245_IND_RMESE             not valid in H.323 RequestMuliplexEntry
//			case H245_IND_RMESE_RELEASE     not valid in H.323 RequestMuliplexEntryRelease

			case H245_IND_MRSE:
				status = _IndModeRequest(pH245ConfIndData);
				break;

			case H245_IND_MRSE_RELEASE:
                // Remote has abandoned RequestMode
                // No longer need to send RequestModeAck or RequestModeReject
                // We can probably get away with ignoring this,
                // but we should NOT return FunctionNotSupported!
				break;

//			case H245_IND_MLSE:             We don't support looping back data

			case H245_IND_MLSE_RELEASE:
                // Required to accept this message
                break;

			case H245_IND_NONSTANDARD_REQUEST:
			case H245_IND_NONSTANDARD_RESPONSE:
			case H245_IND_NONSTANDARD_COMMAND:
			case H245_IND_NONSTANDARD:
				 status = _IndNonStandard(pH245ConfIndData);
				break;

			case H245_IND_MISC_COMMAND:
				status = _IndMiscellaneousCommand(pH245ConfIndData, pMisc);
				break;

			case H245_IND_MISC:
				status = _IndMiscellaneous(pH245ConfIndData, pMisc);
				break;
				
			case H245_IND_COMM_MODE_REQUEST:
				status = _IndUnimplemented(pH245ConfIndData); // TBD
				break;

//			case H245_IND_COMM_MODE_RESPONSE:   We never send request!

			case H245_IND_COMM_MODE_COMMAND:
				status = _IndCommunicationModeCommand(pH245ConfIndData);
				break;

			case H245_IND_CONFERENCE_REQUEST:
				status = _IndConferenceRequest(pH245ConfIndData);
				break;

			case H245_IND_CONFERENCE_RESPONSE:
				status = _IndConferenceResponse(pH245ConfIndData);
				break;

			case H245_IND_CONFERENCE_COMMAND:
				status = _IndConferenceCommand(pH245ConfIndData);
				break;

			case H245_IND_CONFERENCE:
				status = _IndConference(pH245ConfIndData);
				break;
	
			case H245_IND_SEND_TERMCAP:
				status = _IndSendTerminalCapabilitySet(pH245ConfIndData);
				break;

//			case H245_IND_ENCRYPTION:       Not valid in H.323

			case H245_IND_FLOW_CONTROL:
				status = _IndFlowControl(pH245ConfIndData);
				break;

			case H245_IND_ENDSESSION:
				status = _IndEndSession(pH245ConfIndData);
				break;

			case H245_IND_FUNCTION_NOT_UNDERSTOOD:
				// We don't do anything with this but we still want to
                // return H245_ERROR_OK so H.245 does not sent
                // FunctionNotSupported back to remote peer!
				break;

			case H245_IND_JITTER:
                // It is ok to ignore this; no response is expected
                break;

//			case H245_IND_H223_SKEW:        Not valid in H.323
//			case H245_IND_NEW_ATM_VC:       Not valid in H.323

			case H245_IND_USERINPUT:
				status = _IndUserInput(pH245ConfIndData);
				break;

			case H245_IND_H2250_MAX_SKEW:
				status = _IndH2250MaximumSkew(pH245ConfIndData);
				break;

			case H245_IND_MC_LOCATION:
				status = _IndMCLocation(pH245ConfIndData);
				break;

			case H245_IND_VENDOR_ID:
				status = _IndVendorIdentification(pH245ConfIndData, pMisc);
				break;

			case H245_IND_FUNCTION_NOT_SUPPORTED:
				// We don't do anything with this but we still want to
                // return H245_ERROR_OK so H.245 does not sent
                // FunctionNotSupported back to remote peer!
				break;

//			case H245_IND_H223_RECONFIG:        Not valid in H.323
//			case H245_IND_H223_RECONFIG_ACK:    Not valid in H.323
//			case H245_IND_H223_RECONFIG_REJECT: Not valid in H.323
			default:
				status = _IndUnimplemented(pH245ConfIndData);
				break;
		}
	}
	HResultLeaveCallControl(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\callcont\q931man.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/q931man.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.14  $
 *	$Date:   Aug 12 1996 09:40:40  $
 *	$Author:   mandrews  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

HRESULT InitQ931Manager();

HRESULT DeInitQ931Manager();

DWORD Q931Callback(					BYTE					bEvent,
									HQ931CALL				hQ931Call,
									DWORD					dwListenToken,
									DWORD					dwUserToken,
									void *					pEventData);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\callcont\listman.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/listman.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.10  $
 *	$Date:   10 Dec 1996 11:26:46  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/


HRESULT InitListenManager();

HRESULT DeInitListenManager();

HRESULT AllocAndLockListen(			PCC_HLISTEN				phListen,
									PCC_ADDR				pListenAddr,
									HQ931LISTEN				hQ931Listen,
									PCC_ALIASNAMES			pLocalAliasNames,
									DWORD					dwListenToken,
									CC_LISTEN_CALLBACK		ListenCallback,
									PPLISTEN				ppListen);

HRESULT FreeListen(					PLISTEN					pListen);

HRESULT LockListen(					CC_HLISTEN				hListen,
									PPLISTEN				ppListen);

HRESULT ValidateListen(				CC_HLISTEN				hListen);

HRESULT UnlockListen(				PLISTEN					pListen);

HRESULT GetLastListenAddress(		PCC_ADDR				pListenAddr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\callcont\resource.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************/
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by callcont.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\callcont\userman.c ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/Userman.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.22  $
 *	$Date:   22 Jan 1997 14:55:54  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#pragma warning ( disable : 4115 4201 4214 )
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#pragma warning ( default : 4115 4201 4214 )
#include "apierror.h"
#include "incommon.h"
#include "callcont.h"
#include "q931.h"
#include "ccmain.h"



HRESULT InitUserManager()
{
	return CC_OK;
}



HRESULT DeInitUserManager()
{
	return CC_OK;
}



HRESULT InvokeUserListenCallback(	PLISTEN						pListen,
									HRESULT						status,
									PCC_LISTEN_CALLBACK_PARAMS	pListenCallbackParams)
{
	ASSERT(pListen != NULL);
	ASSERT(pListenCallbackParams != NULL);

	pListen->ListenCallback(status, pListenCallbackParams);

	return CC_OK;
}



HRESULT InvokeUserConferenceCallback(
									PCONFERENCE				pConference,
									BYTE					bIndication,
									HRESULT					status,
									void *					pConferenceCallbackParams)
{
HRESULT		ReturnStatus;

	ASSERT(pConference != NULL);
	// Note that ConferenceCallback and/or pConferenceCallbackParams may legitimately be NULL

	if ((pConference->ConferenceCallback != NULL) &&
		(pConference->LocalEndpointAttached != DETACHED)) {
		ReturnStatus = pConference->ConferenceCallback(bIndication,
													   status,
													   pConference->hConference,
													   pConference->dwConferenceToken,
													   pConferenceCallbackParams);
	} else {
		ReturnStatus = CC_OK;
	}
	return ReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\callcont\userman.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/userman.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.10  $
 *	$Date:   Aug 12 1996 09:40:44  $
 *	$Author:   mandrews  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

HRESULT InitUserManager();

HRESULT DeInitUserManager();

HRESULT InvokeUserListenCallback(	PLISTEN						pListen,
									HRESULT						status,
									PCC_LISTEN_CALLBACK_PARAMS	pListenCallbackParams);

HRESULT InvokeUserConferenceCallback(
									PCONFERENCE				pConference,
									BYTE					bIndication,
									HRESULT					status,
									void *					pConferenceCallbackParams);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\callcont\q931man.c ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/q931man.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.138.1.1  $
 *	$Date:   23 Jun 1997 15:58:12  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#pragma warning ( disable : 4100 4115 4201 4214 )
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#pragma warning ( default : 4115 4201 4214 )
#include "apierror.h"
#include "incommon.h"
#include "callcont.h"
#include "q931.h"
#include "ccmain.h"
#include "listman.h"
#include "q931man.h"
#include "userman.h"
#include "callman.h"
#include "confman.h"
#include "h245man.h"
#include "linkapi.h"
#include "ccutils.h"


extern CALL_CONTROL_STATE	CallControlState;
extern THREADCOUNT			ThreadCount;
extern CC_CONFERENCEID		InvalidConferenceID;


HRESULT InitQ931Manager()
{
	return CC_OK;
}



HRESULT DeInitQ931Manager()
{
	return CC_OK;
}



DWORD _GenerateListenCallback(		PLISTEN					pListen,
									HQ931CALL				hQ931Call,
									PCSS_CALL_INCOMING		pCallIncomingData)
{
HRESULT						status;
CC_HLISTEN					hListen;
CC_LISTEN_CALLBACK_PARAMS	ListenCallbackParams;
PCALL						pCall;
CC_HCALL					hCall;

	ASSERT(pListen != NULL);
	ASSERT(pCallIncomingData != NULL);

	hListen = pListen->hListen;

	status = AllocAndLockCall(
		&hCall,							// pointer to call handle
		CC_INVALID_HANDLE,				// conference handle
		hQ931Call,						// Q931 call handle
		CC_INVALID_HANDLE,				// Q931 call handle for third party invitor
		pCallIncomingData->pCalleeAliasList,
		pCallIncomingData->pCallerAliasList,
		NULL,							// pPeerExtraAliasNames
		NULL,							// pPeerExtension
		NULL,							// local non-standard data
		pCallIncomingData->pNonStandardData,	// remote non-standard data
		NULL,							// local display value
		pCallIncomingData->pszDisplay,	// remote display value
		pCallIncomingData->pSourceEndpointType->pVendorInfo,// remote vendor info
		pCallIncomingData->pLocalAddr,	// local address
		pCallIncomingData->pCallerAddr,	// connect address
		NULL,							// destination address
		pCallIncomingData->pSourceAddr,	// source call signal address
		CALLEE,							// call direction
		pCallIncomingData->bCallerIsMC,
		0,								// user token; user will specify in AcceptRejectCall
		INCOMING,						// initial call state
		0,								// bandwidth
		&pCallIncomingData->ConferenceID,	// conference ID
		&pCall);						// pointer to call object

	if (status != CC_OK) {
		UnlockListen(pListen);
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &pCallIncomingData->ConferenceID,
					   NULL,					// alternate address
					   NULL);					// non-standard data
		return 1;
	}	
	
	// Map from Q.931 goals to Call Control goals
	switch (pCallIncomingData->wGoal) {
		case CSG_JOIN:
			ListenCallbackParams.wGoal = CC_GOAL_JOIN;
			break;
		case CSG_CREATE:
			ListenCallbackParams.wGoal = CC_GOAL_CREATE;
			break;
		case CSG_INVITE:
			ListenCallbackParams.wGoal = CC_GOAL_INVITE;
			break;
	}

	ListenCallbackParams.hCall = hCall;
	ListenCallbackParams.pCallerAliasNames = pCallIncomingData->pCallerAliasList;
	ListenCallbackParams.pCalleeAliasNames = pCallIncomingData->pCalleeAliasList;
	ListenCallbackParams.pNonStandardData = pCallIncomingData->pNonStandardData;
	ListenCallbackParams.pszDisplay = pCallIncomingData->pszDisplay;
	ListenCallbackParams.pVendorInfo = NULL;
	ListenCallbackParams.ConferenceID = pCallIncomingData->ConferenceID;
	ListenCallbackParams.pCallerAddr = pCallIncomingData->pCallerAddr;
	ListenCallbackParams.pCalleeAddr = pCallIncomingData->pLocalAddr;
	ListenCallbackParams.dwListenToken = pListen->dwListenToken;

	UnlockCall(pCall);

	// Invoke the user callback -- the listen object is locked during the callback,
	// but the associated call object is unlocked (to prevent deadlock if
	// CC_AcceptCall() or CC_RejectCall() is called during the callback from a
	// different thread, and the callback thread blocks pending completion of 
	// CC_AcceptCall() or CC_RejectCall())
	InvokeUserListenCallback(pListen,
							 CC_OK,
							 &ListenCallbackParams);

	// Need to validate the listen handle; the associated object may have been
	// deleted during the user callback by this thread
	if (ValidateListen(hListen) == CC_OK)
		UnlockListen(pListen);

	status = LockCall(hCall, &pCall);
	if ((status == CC_OK) && (pCall->CallState == INCOMING)) {
		UnlockCall(pCall);
		return 0;	// cause a ringing condition to occur
	} else {
		// call object has been deleted, or exists in a non-incoming state
		if (status == CC_OK)
			// call object exists in a non-incoming state; AcceptRejectCall
			// may have been invoked from the user callback
			UnlockCall(pCall);
//                return 1;       // don't cause a ringing condition to occur
	}
			
//        // We should never reach this point
//        ASSERT(0);
	return 1;
}



DWORD _Q931CallIncoming(			HQ931CALL				hQ931Call,
									CC_HLISTEN				hListen,
									PCSS_CALL_INCOMING		pCallIncomingData)
{
HRESULT						status;
PLISTEN						pListen;
PCONFERENCE					pConference;
PCALL						pCall;
CC_HCALL					hCall;

	ASSERT(hListen != CC_INVALID_HANDLE);
	ASSERT(pCallIncomingData != NULL);
	ASSERT(!EqualConferenceIDs(&pCallIncomingData->ConferenceID, &InvalidConferenceID));

	if ((pCallIncomingData->wGoal != CSG_CREATE) &&
		(pCallIncomingData->wGoal != CSG_JOIN) &&
		(pCallIncomingData->wGoal != CSG_INVITE)) {
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &pCallIncomingData->ConferenceID,
					   NULL,					// alternate address
					   NULL);					// non-standard data
		return 1;
	}

	status = LockListen(hListen, &pListen);
	if (status != CC_OK) {
		// the listen was presumably cancelled by the user,
		// but we haven't informed Call Setup yet
		Q931RejectCall(hQ931Call,				// Q931 call handle
			           CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &pCallIncomingData->ConferenceID,
					   NULL,					// alternate address
					   NULL);					// non-standard data
		return 1;
	}

	// Look for wConferenceID in conference list
	status = LockConferenceID(&pCallIncomingData->ConferenceID, &pConference);
	if (status == CC_OK) {
		// We found a matching conference ID
		if ((pConference->bDeferredDelete) &&
			((pConference->bAutoAccept == FALSE) ||
			 ((pConference->tsMultipointController == TS_TRUE) &&
			 (pCallIncomingData->bCallerIsMC == TRUE)))) {
			UnlockListen(pListen);
			UnlockConference(pConference);
			Q931RejectCall(hQ931Call,				// Q931 call handle
						   CC_REJECT_UNDEFINED_REASON,	// reject reason
						   &pCallIncomingData->ConferenceID,
						   NULL,					// alternate address
						   NULL);					// non-standard data
			return 1;
		} else {
			if (pConference->tsMultipointController == TS_TRUE) {
				if ((pCallIncomingData->pCalleeDestAddr == NULL) ||
					((pCallIncomingData->pCalleeDestAddr != NULL) &&
					 (EqualAddrs(pCallIncomingData->pLocalAddr,
					             pCallIncomingData->pCalleeDestAddr)))) {
					switch (pCallIncomingData->wGoal) {
						case CSG_CREATE:
							UnlockListen(pListen);
							UnlockConference(pConference);
							Q931RejectCall(hQ931Call,				// Q931 call handle
										   CC_REJECT_UNDEFINED_REASON,	// reject reason
										   &pCallIncomingData->ConferenceID,
										   NULL,					// alternate address
										   NULL);					// non-standard data
							return 1;
						case CSG_JOIN:
							if ((pConference->bDeferredDelete) &&
								(pConference->bAutoAccept == TRUE)) {
								// Auto accept
								status = AllocAndLockCall(
									&hCall,							// pointer to call handle
									pConference->hConference,		// conference handle
									hQ931Call,						// Q931 call handle
									CC_INVALID_HANDLE,				// Q931 call handle for third party invitor
									pCallIncomingData->pCalleeAliasList,
									pCallIncomingData->pCallerAliasList,
									NULL,							// pPeerExtraAliasNames
									NULL,							// pPeerExtension
									NULL,							// local non-standard data
									pCallIncomingData->pNonStandardData,	// remote non-standard data
									NULL,							// local display value
									pCallIncomingData->pszDisplay,	// remote display value
									pCallIncomingData->pSourceEndpointType->pVendorInfo,// remote vendor info
									pCallIncomingData->pLocalAddr,	// local address
									pCallIncomingData->pCallerAddr,	// connect address
									NULL,							// destination address
									pCallIncomingData->pSourceAddr,	// source call signal address
									CALLEE,							// call type
									pCallIncomingData->bCallerIsMC,
									0,								// user token; user will specify in AcceptRejectCall
									INCOMING,						// initial call state
									0,								// bandwidth
									&pCallIncomingData->ConferenceID,	// conference ID
									&pCall);						// pointer to call object

								if (status != CC_OK) {
									UnlockListen(pListen);
									UnlockConference(pConference);
									Q931RejectCall(hQ931Call,				// Q931 call handle
												   CC_REJECT_UNDEFINED_REASON,	// reject reason
												   &pCallIncomingData->ConferenceID,
												   NULL,					// alternate address
												   NULL);					// non-standard data
									return 1;
								}
								AcceptCall(pCall, pConference);
								return 1;	// Don't send back a RINGING indication
							} else {
								UnlockConference(pConference);
								return _GenerateListenCallback(pListen,
															   hQ931Call,
															   pCallIncomingData);
							}
						case CSG_INVITE:
							UnlockListen(pListen);
							UnlockConference(pConference);
							Q931RejectCall(hQ931Call,				// Q931 call handle
										   CC_REJECT_IN_CONF,		// reject reason
										   &pCallIncomingData->ConferenceID,
										   NULL,					// alternate address
										   NULL);					// non-standard data
							return 1;
					} // switch (wGoal)
				} else { // connect addr != destination addr
					switch (pCallIncomingData->wGoal) {
						case CSG_CREATE:
						case CSG_JOIN:
							UnlockListen(pListen);
							UnlockConference(pConference);
							Q931RejectCall(hQ931Call,				// Q931 call handle
										   CC_REJECT_UNDEFINED_REASON,	// reject reason
										   &pCallIncomingData->ConferenceID,
										   NULL,					// alternate address
										   NULL);					// non-standard data
							return 1;
						case CSG_INVITE:
							// 3rd party invite
							if (pCallIncomingData->bCallerIsMC == TRUE) {
								UnlockListen(pListen);
								UnlockConference(pConference);
								Q931RejectCall(hQ931Call,				// Q931 call handle
											   CC_REJECT_UNDEFINED_REASON,	// reject reason
											   &pCallIncomingData->ConferenceID,
											   NULL,					// alternate address
											   NULL);					// non-standard data
								return 1;
							}
							status = AllocAndLockCall(
								&hCall,							// pointer to call handle
								pConference->hConference,		// conference handle
								CC_INVALID_HANDLE,				// Q931 call handle
								hQ931Call,						// Q931 call handle for third party invitor
								pCallIncomingData->pCallerAliasList, // local alias names
								pCallIncomingData->pCalleeAliasList, // remote alias names
								NULL,							// pPeerExtraAliasNames
								NULL,							// pPeerExtension
								pCallIncomingData->pNonStandardData, // local non-standard data
								NULL,							// remote non-standard data
								pCallIncomingData->pszDisplay,	// local display value
								NULL,							// remote display value
								NULL,							// remote vendor info
								NULL,							// local address
								pCallIncomingData->pCalleeDestAddr,	// connect address
								pCallIncomingData->pCalleeDestAddr,	// destination address
								pCallIncomingData->pSourceAddr,	// source call signal address
								THIRD_PARTY_INTERMEDIARY,			// call type
								TRUE,							// caller (this endpoint) is MC
								0,								// user token; user will specify in AcceptRejectCall
								PLACED,							// initial call state
								0,								// bandwidth
								&pCallIncomingData->ConferenceID,	// conference ID
								&pCall);						// pointer to call object

							if (status != CC_OK) {
								UnlockListen(pListen);
								UnlockConference(pConference);
								Q931RejectCall(hQ931Call,				// Q931 call handle
											   CC_REJECT_UNDEFINED_REASON,	// reject reason
											   &pCallIncomingData->ConferenceID,
											   NULL,					// alternate address
											   NULL);					// non-standard data
								return 1;
							}
							PlaceCall(pCall, pConference);
							UnlockCall(pCall);
							UnlockConference(pConference);
							return 1;	// Don't send back a RINGING indication
					} // switch (wGoal)
				}
			} else { // pConference->tsMultipointController != TS_TRUE
				if ((pCallIncomingData->pCalleeDestAddr == NULL) ||
					((pCallIncomingData->pCalleeDestAddr != NULL) &&
					 (EqualAddrs(pCallIncomingData->pLocalAddr,
					             pCallIncomingData->pCalleeDestAddr)))) {
					switch (pCallIncomingData->wGoal) {
						case CSG_CREATE:
							UnlockListen(pListen);
							UnlockConference(pConference);
							Q931RejectCall(hQ931Call,				// Q931 call handle
										   CC_REJECT_UNDEFINED_REASON,	// reject reason
										   &pCallIncomingData->ConferenceID,
										   NULL,					// alternate address
										   NULL);					// non-standard data
							return 1;
						case CSG_JOIN:
						case CSG_INVITE:
							UnlockConference(pConference);
							return _GenerateListenCallback(pListen,
														   hQ931Call,
														   pCallIncomingData);
					} // switch (wGoal)
				} else { // connect addr != destination addr
					UnlockListen(pListen);
					UnlockConference(pConference);
					Q931RejectCall(hQ931Call,				// Q931 call handle
								   CC_REJECT_UNDEFINED_REASON,	// reject reason
								   &pCallIncomingData->ConferenceID,
								   NULL,					// alternate address
								   NULL);					// non-standard data
					return 1;
				} // connect addr != destination addr
			} // pConference->tsMultipointController != TS_TRUE
		} // Matching conference ID
	} else if (status == CC_BAD_PARAM) {
		// This is OK; it simply means that we did not find a matching conference ID
		if (((pCallIncomingData->pCalleeDestAddr != NULL) &&
			(EqualAddrs(pCallIncomingData->pLocalAddr,
					    pCallIncomingData->pCalleeDestAddr))) ||
		    (pCallIncomingData->pCalleeDestAddr == NULL)) {
				return _GenerateListenCallback(pListen,
											   hQ931Call,
											   pCallIncomingData);
		} else { // connect addr != destination addr
			UnlockListen(pListen);
			Q931RejectCall(hQ931Call,				// Q931 call handle
						   CC_REJECT_UNDEFINED_REASON,	// reject reason
						   &pCallIncomingData->ConferenceID,
						   NULL,					// alternate address
						   NULL);					// non-standard data
			return 1;
		}
	} else { // fatal error in LockConference
		UnlockListen(pListen);
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &pCallIncomingData->ConferenceID,
					   NULL,					// alternate address
					   NULL);					// non-standard data
		return 1;	
	}
	
	// We should never reach this point
	ASSERT(0);
	return 1;
}



DWORD _Q931CallRemoteHangup(		HQ931CALL				hQ931Call,
									CC_HLISTEN				hListen,
									CC_HCALL				hCall)
{
CC_LISTEN_CALLBACK_PARAMS	ListenCallbackParams;
PCALL						pCall;
PLISTEN						pListen;

	if (hCall == CC_INVALID_HANDLE) {
		// Either we've already informed the user of the hangup,
		// or the user has not yet accepted or rejected the incoming
		// call request
		ASSERT(hListen != CC_INVALID_HANDLE);

		if (LockQ931Call(hCall, hQ931Call, &pCall) != CC_OK)
			return 0;

		hCall = pCall->hCall;

		if (pCall->hConference != CC_INVALID_HANDLE) {
			UnlockCall(pCall);
			// XXX -- need bHangupReason
			ProcessRemoteHangup(hCall, hQ931Call, CC_REJECT_NORMAL_CALL_CLEARING);
			return 0;
		}

		if (LockListen(hListen, &pListen) != CC_OK) {
			FreeCall(pCall);
			return 0;
		}

		MarkCallForDeletion(pCall);

		ListenCallbackParams.hCall = pCall->hCall;
		ListenCallbackParams.pCallerAliasNames = pCall->pPeerAliasNames;
		ListenCallbackParams.pCalleeAliasNames = pCall->pLocalAliasNames;
		ListenCallbackParams.pNonStandardData = pCall->pPeerNonStandardData;
		ListenCallbackParams.pszDisplay = pCall->pszPeerDisplay;
		ListenCallbackParams.pVendorInfo = pCall->pPeerVendorInfo;
		ListenCallbackParams.wGoal = CC_GOAL_CREATE;	// igonred in this callback
		ListenCallbackParams.ConferenceID = pCall->ConferenceID;
		ListenCallbackParams.pCallerAddr = pCall->pQ931PeerConnectAddr;
		ListenCallbackParams.pCalleeAddr = pCall->pQ931LocalConnectAddr;
		ListenCallbackParams.dwListenToken = pListen->dwListenToken;

		InvokeUserListenCallback(pListen,
		                         CC_PEER_CANCEL,
								 &ListenCallbackParams);

		// Need to validate the listen and call handles; the associated objects may
		// have been deleted during the user callback by this thread
		if (ValidateListen(hListen) == CC_OK)
			UnlockListen(pListen);
		if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
			FreeCall(pCall);
	} else
		// XXX -- need bHangupReason
		ProcessRemoteHangup(hCall, hQ931Call, CC_REJECT_NORMAL_CALL_CLEARING);

	return 0;
}



DWORD _Q931CallRejected(			HQ931CALL				hQ931Call,
									CC_HCALL				hCall,
									PCSS_CALL_REJECTED		pCallRejectedData)
{
PCALL						pCall;
CC_HCONFERENCE				hConference;
PCONFERENCE					pConference;
HRESULT						status;
CC_CONNECT_CALLBACK_PARAMS	ConnectCallbackParams;
HQ931CALL					hQ931CallInvitor;
CC_ENDPOINTTYPE				SourceEndpointType;
CALLTYPE					CallType;             
CC_CONFERENCEID				ConferenceID;
CC_ADDR						SourceAddr;
WORD						wNumCalls;
WORD                        wQ931Goal;  
WORD                        wQ931CallType;

	status = LockCall(hCall, &pCall);
	if (status != CC_OK)
		return 0;

	CallType = pCall->CallType;
	ConferenceID = pCall->ConferenceID;
    
	if ((pCall->hQ931Call != hQ931Call) ||
		((pCall->CallState != PLACED) && (pCall->CallState != RINGING))) {
		// The peer must be in a bad state; we don't expect to receive this message now
		UnlockCall(pCall);
		return 0;
	}

	if (CallType == THIRD_PARTY_INTERMEDIARY) {
		hQ931CallInvitor = pCall->hQ931CallInvitor;
		FreeCall(pCall);
		if (hQ931CallInvitor != CC_INVALID_HANDLE)
			Q931RejectCall(hQ931CallInvitor,
						   pCallRejectedData->bRejectReason,
						   &ConferenceID,
						   NULL,	// alternate address
						   NULL);	// non-standard data
		return 0;
	}

	if (pCall->hConference == CC_INVALID_HANDLE) {
		// Call is not attached to a conference
		FreeCall(pCall);
		return 0;
	}

	UnlockCall(pCall);

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		return 0;

	ConnectCallbackParams.pNonStandardData = pCallRejectedData->pNonStandardData;
	ConnectCallbackParams.pszPeerDisplay = NULL;
	ConnectCallbackParams.bRejectReason = pCallRejectedData->bRejectReason;
	ConnectCallbackParams.pTermCapList = NULL;
	ConnectCallbackParams.pH2250MuxCapability = NULL;
	ConnectCallbackParams.pTermCapDescriptors = NULL;	
	ConnectCallbackParams.pLocalAddr = pCall->pQ931LocalConnectAddr;
	if (pCall->pQ931DestinationAddr == NULL)
		ConnectCallbackParams.pPeerAddr = pCall->pQ931PeerConnectAddr;
	else
		ConnectCallbackParams.pPeerAddr = pCall->pQ931DestinationAddr;
	ConnectCallbackParams.pVendorInfo = pCall->pPeerVendorInfo;

	if (pCallRejectedData->bRejectReason == CC_REJECT_ROUTE_TO_MC)
    {
		ConnectCallbackParams.bMultipointConference = TRUE;
        wQ931Goal = CSG_JOIN;
        wQ931CallType = CC_CALLTYPE_N_N;
    }
	else
    {
        // Goal and CallType need to be changed for multipoint support.
		ConnectCallbackParams.bMultipointConference = FALSE;
        wQ931Goal = CSG_CREATE;
        wQ931CallType = CC_CALLTYPE_PT_PT;
    }
	ConnectCallbackParams.pConferenceID = &pCallRejectedData->ConferenceID;
	if (pCallRejectedData->bRejectReason == CC_REJECT_ROUTE_TO_MC)
		ConnectCallbackParams.pMCAddress = pCallRejectedData->pAlternateAddr;
	else
		ConnectCallbackParams.pMCAddress = NULL;
	ConnectCallbackParams.pAlternateAddress = pCallRejectedData->pAlternateAddr;
	ConnectCallbackParams.dwUserToken = pCall->dwUserToken;

	// save a copy of the conference handle; we'll need it to validate
	// the conference object after returning from the user callback
	hConference = pConference->hConference;

	if (((pCallRejectedData->bRejectReason == CC_REJECT_ROUTE_TO_MC) ||
		 (pCallRejectedData->bRejectReason == CC_REJECT_CALL_FORWARDED) ||
		 (pCallRejectedData->bRejectReason == CC_REJECT_ROUTE_TO_GATEKEEPER)) &&
		(EqualConferenceIDs(&pCallRejectedData->ConferenceID, &pCall->ConferenceID)) &&
		(pCallRejectedData->pAlternateAddr != NULL)) {
		// XXX - In order to be H.323 compliant here, we need to re-permission this call
		// through the gatekeeper because:
		// 1. The rerouted call may be going to another gatekeeper zone.
		// 2. The alternate address may be NULL, and we may have to resolve the
		//    alternate alias name list through the gatekeeper
		SourceEndpointType.pVendorInfo = pConference->pVendorInfo;
		SourceEndpointType.bIsTerminal = TRUE;
		SourceEndpointType.bIsGateway = FALSE;

		// Cause our local Q.931 connect address to be placed in the
		// Q.931 setup-UUIE sourceAddress field
		SourceAddr.nAddrType = CC_IP_BINARY;
		SourceAddr.bMulticast = FALSE;
		SourceAddr.Addr.IP_Binary.dwAddr = 0;
		SourceAddr.Addr.IP_Binary.wPort = 0;

		status = Q931PlaceCall(&pCall->hQ931Call,			// Q931 call handle
			                   pCall->pszLocalDisplay,
			                   pCall->pLocalAliasNames,
							   pCall->pPeerAliasNames,
                               pCall->pPeerExtraAliasNames,	// pExtraAliasList
                               pCall->pPeerExtension,		// pExtensionAliasItem
			                   pCall->pLocalNonStandardData,// non-standard data
							   &SourceEndpointType,
                               NULL,						// pszCalledPartyNumber
							   pCallRejectedData->pAlternateAddr, // connect address
							   pCall->pQ931DestinationAddr,	// destination address
							   NULL,						// source address
							   FALSE,						// bIsMC
							   &pCall->ConferenceID,		// conference ID
							   wQ931Goal,					// goal
							   wQ931CallType,				// call type
							   hCall,						// user token
							   (Q931_CALLBACK)Q931Callback,	// callback
							   pCall->dwBandwidth,
#ifdef GATEKEEPER
                               pCall->GkiCall.usCRV);       // CRV
#else
                               0);                          // CRV
#endif GATEKEEPER
		if (status != CS_OK) {
			MarkCallForDeletion(pCall);
			InvokeUserConferenceCallback(pConference,
										 CC_CONNECT_INDICATION,
										 status,
										 &ConnectCallbackParams);

			if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
				FreeCall(pCall);

			if (ValidateConference(hConference) != CC_OK)
				return 0;

			for ( ; ; ) {
				// Start up an enqueued call, if one exists
				status = RemoveEnqueuedCallFromConference(pConference, &hCall);
				if ((status != CC_OK) || (hCall == CC_INVALID_HANDLE))
					break;

				status = LockCall(hCall, &pCall);
				if (status == CC_OK) {
					pCall->CallState = PLACED;

					status = PlaceCall(pCall, pConference);
					UnlockCall(pCall);
					if (status == CC_OK)
						break;
				}
			}
			return 0;
		}
		UnlockCall(pCall);
		UnlockConference(pConference);
		return 0;
	}

	MarkCallForDeletion(pCall);

	if ((CallType == CALLER) || (CallType == THIRD_PARTY_INVITOR) ||
		((CallType == CALLEE) && (pConference->LocalEndpointAttached == NEVER_ATTACHED))) {
		InvokeUserConferenceCallback(pConference,
									 CC_CONNECT_INDICATION,
									 CC_PEER_REJECT,
									 &ConnectCallbackParams);
	}
	
	if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
		FreeCall(pCall);

	// Need to validate conference handle; the associated object may
	// have been deleted during the user callback in this thread
	if (ValidateConference(hConference) != CC_OK)
		return 0;

	for ( ; ; ) {
		// Start up an enqueued call, if one exists
		status = RemoveEnqueuedCallFromConference(pConference, &hCall);
		if ((status != CC_OK) || (hCall == CC_INVALID_HANDLE))
			break;

		status = LockCall(hCall, &pCall);
		if (status == CC_OK) {
			pCall->CallState = PLACED;

			status = PlaceCall(pCall, pConference);
			UnlockCall(pCall);
			if (status == CC_OK)
				break;
		}
	}
	
	EnumerateCallsInConference(&wNumCalls, NULL, pConference, REAL_CALLS);

	if (wNumCalls == 0) {
		if (pConference->bDeferredDelete) {
			ASSERT(pConference->LocalEndpointAttached == DETACHED);
			FreeConference(pConference);
		} else {
			if ((pConference->ConferenceMode != MULTIPOINT_MODE) ||
				(pConference->tsMultipointController != TS_TRUE))
				ReInitializeConference(pConference);
			UnlockConference(pConference);
		}
	} else {
		UnlockConference(pConference);
	}
	return 0;
}



DWORD _Q931CallAccepted(			HQ931CALL				hQ931Call,
									CC_HCALL				hCall,
									PCSS_CALL_ACCEPTED		pCallAcceptedData)
{
HRESULT						status;
PCALL						pCall;
CC_HCONFERENCE				hConference;
PCONFERENCE					pConference;
CC_CONNECT_CALLBACK_PARAMS	ConnectCallbackParams;
BYTE						bTerminalType;
BOOL						bMultipointConference;
CALLTYPE					CallType;
HQ931CALL					hQ931CallInvitor;
H245_INST_T					H245Instance;
DWORD                       dwLinkLayerPhysicalId;

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		return 0;

	CallType = pCall->CallType;
	hConference = pConference->hConference;
	hQ931Call = pCall->hQ931Call;
	hQ931CallInvitor = pCall->hQ931CallInvitor;

	ASSERT((pCall->hQ931Call == hQ931Call) || (pCall->hQ931CallInvitor == hQ931Call));

	if ((pConference->ConferenceMode == POINT_TO_POINT_MODE) ||
		(pConference->ConferenceMode == MULTIPOINT_MODE))
		bMultipointConference = TRUE;
	else
		bMultipointConference = FALSE;

	// Initialize ConnectCallbackParams
	ConnectCallbackParams.pNonStandardData = pCallAcceptedData->pNonStandardData;
	ConnectCallbackParams.pszPeerDisplay = pCallAcceptedData->pszDisplay;
	ConnectCallbackParams.bRejectReason = CC_REJECT_UNDEFINED_REASON;	// field ignored
	ConnectCallbackParams.pTermCapList = NULL;
	ConnectCallbackParams.pH2250MuxCapability = NULL;
	ConnectCallbackParams.pTermCapDescriptors = NULL;
	ConnectCallbackParams.pLocalAddr = pCall->pQ931LocalConnectAddr;
	ConnectCallbackParams.pPeerAddr = pCallAcceptedData->pCalleeAddr;
	ConnectCallbackParams.pVendorInfo = pCall->pPeerVendorInfo;
	ConnectCallbackParams.bMultipointConference = bMultipointConference;
	ConnectCallbackParams.pConferenceID = &pConference->ConferenceID;
	ConnectCallbackParams.pMCAddress = pConference->pMultipointControllerAddr;
	ConnectCallbackParams.pAlternateAddress = NULL;
	ConnectCallbackParams.dwUserToken = pCall->dwUserToken;

	if (pCallAcceptedData->pCalleeAddr) {
		// Set pCall->pQ931DestinationAddr to the destination address that we got from Q931.
		// Note that we may not current have a destination address (if the client didn't
		// specify one), or we may currently have a destination address	in domain name format
		// which we need to change to binary format
		if (pCall->pQ931DestinationAddr == NULL)
			pCall->pQ931DestinationAddr = (PCC_ADDR)Malloc(sizeof(CC_ADDR));
		if (pCall->pQ931DestinationAddr != NULL)
			*pCall->pQ931DestinationAddr = *pCallAcceptedData->pCalleeAddr;
	}

	if ((!EqualConferenceIDs(&pConference->ConferenceID, &InvalidConferenceID)) &&
		(!EqualConferenceIDs(&pConference->ConferenceID, &pCallAcceptedData->ConferenceID))) {

		MarkCallForDeletion(pCall);

		if (CallType == THIRD_PARTY_INTERMEDIARY) {
			if (hQ931CallInvitor != CC_INVALID_HANDLE)
				Q931RejectCall(hQ931CallInvitor,
							   CC_REJECT_UNDEFINED_REASON,
							   &pCallAcceptedData->ConferenceID,
							   NULL,	// alternate address
							   pCallAcceptedData->pNonStandardData);
		} else {
			if ((CallType == CALLER) || (CallType == THIRD_PARTY_INVITOR) ||
			    ((CallType == CALLEE) && (pConference->LocalEndpointAttached == NEVER_ATTACHED)))
				InvokeUserConferenceCallback(pConference,
											 CC_CONNECT_INDICATION,
											 CC_INTERNAL_ERROR,
											 &ConnectCallbackParams);
		}
		if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
			FreeCall(pCall);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
		Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
		return 0;
	}

	pConference->ConferenceID = pCallAcceptedData->ConferenceID;
	pCall->ConferenceID = pCallAcceptedData->ConferenceID;
	// Copy the newly-supplied peer address into the call object.
	// This is preferable if the original peer address was in IP dot
	// or domain name format
	if (CallType != THIRD_PARTY_INVITOR) {
		if (pCallAcceptedData->pCalleeAddr != NULL) {
			if (pCall->pQ931DestinationAddr == NULL)
				pCall->pQ931DestinationAddr = (PCC_ADDR)Malloc(sizeof(CC_ADDR));
			if (pCall->pQ931DestinationAddr != NULL)
				*pCall->pQ931DestinationAddr = *pCallAcceptedData->pCalleeAddr;
		}
		
		if (pCallAcceptedData->pLocalAddr != NULL) {
			if (pCall->pQ931LocalConnectAddr == NULL)
				pCall->pQ931LocalConnectAddr = (PCC_ADDR)Malloc(sizeof(CC_ADDR));
			if (pCall->pQ931LocalConnectAddr != NULL)
				*pCall->pQ931LocalConnectAddr = *pCallAcceptedData->pLocalAddr;
		}
	}

	ASSERT(pCall->pPeerNonStandardData == NULL);
	CopyNonStandardData(&pCall->pPeerNonStandardData,
		                pCallAcceptedData->pNonStandardData);

	ASSERT(pCall->pszPeerDisplay == NULL);
	CopyDisplay(&pCall->pszPeerDisplay,
		        pCallAcceptedData->pszDisplay);

	ASSERT(pCall->pPeerVendorInfo == NULL);
	CopyVendorInfo(&pCall->pPeerVendorInfo,
	               pCallAcceptedData->pDestinationEndpointType->pVendorInfo);

	if (CallType == THIRD_PARTY_INVITOR) {
		pCall->CallState = CALL_COMPLETE;
		ConnectCallbackParams.pPeerAddr = pCall->pQ931DestinationAddr;
		MarkCallForDeletion(pCall);
		InvokeUserConferenceCallback(pConference,
									 CC_CONNECT_INDICATION,
									 CC_OK,
									 &ConnectCallbackParams);
		if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
			FreeCall(pCall);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
		return 0;
	}

	pCall->CallState = TERMCAP;

	status = MakeH245PhysicalID(&pCall->dwH245PhysicalID);
	if (status != CC_OK) {
		
		MarkCallForDeletion(pCall);

		if (CallType == THIRD_PARTY_INTERMEDIARY) {
			if (hQ931CallInvitor != CC_INVALID_HANDLE)
				Q931RejectCall(hQ931CallInvitor,
							   CC_REJECT_UNDEFINED_REASON,
							   &pCallAcceptedData->ConferenceID,
							   NULL,	// alternate address
							   pCallAcceptedData->pNonStandardData);
		} else {
			if ((CallType == CALLER) || (CallType == THIRD_PARTY_INVITOR) ||
			    ((CallType == CALLEE) && (pConference->LocalEndpointAttached == NEVER_ATTACHED)))
				InvokeUserConferenceCallback(pConference,
											 CC_CONNECT_INDICATION,
											 status,
											 &ConnectCallbackParams);
		}
		Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
		if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
			FreeCall(pCall);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
		return 0;
	}

    //MULTITHREAD
    //Use a tmp ID so we don't clobber the chosen H245Id. 
    //   H245Id=>
    //   <= linkLayerId
    dwLinkLayerPhysicalId = INVALID_PHYS_ID;

	SetTerminalType(pConference->tsMultipointController, &bTerminalType);
	pCall->H245Instance = H245Init(H245_CONF_H323,
                                   pCall->dwH245PhysicalID,
                                   &dwLinkLayerPhysicalId,
								   hCall,
								   (H245_CONF_IND_CALLBACK_T)H245Callback,
								   bTerminalType);
	if (pCall->H245Instance == H245_INVALID_ID) {
		MarkCallForDeletion(pCall);
		if (CallType == THIRD_PARTY_INTERMEDIARY) {
			if (hQ931CallInvitor != CC_INVALID_HANDLE)
				Q931RejectCall(hQ931CallInvitor,
							   CC_REJECT_UNDEFINED_REASON,
							   &pCallAcceptedData->ConferenceID,
							   NULL,	// alternate address
							   pCallAcceptedData->pNonStandardData);
		} else {
			if ((CallType == CALLER) || (CallType == THIRD_PARTY_INVITOR) ||
			    ((CallType == CALLEE) && (pConference->LocalEndpointAttached == NEVER_ATTACHED)))
				InvokeUserConferenceCallback(pConference,
											 CC_CONNECT_INDICATION,
											 CC_INTERNAL_ERROR,
											 &ConnectCallbackParams);
		}
		Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
		if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
			FreeCall(pCall);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
		return 0;
	}

	H245Instance = pCall->H245Instance;

	// XXX -- need to define connect callback routine
    // Send in the Id we got back from H245Init.
    status = linkLayerConnect(dwLinkLayerPhysicalId,
		                      pCallAcceptedData->pH245Addr,
							  NULL);
	if (status != NOERROR) {

		MarkCallForDeletion(pCall);

		if (CallType == THIRD_PARTY_INTERMEDIARY) {
			if (hQ931CallInvitor != CC_INVALID_HANDLE)
				Q931RejectCall(hQ931CallInvitor,
							   CC_REJECT_UNDEFINED_REASON,
							   &pCallAcceptedData->ConferenceID,
							   NULL,	// alternate address
							   pCallAcceptedData->pNonStandardData);
		} else {
			if ((CallType == CALLER) || (CallType == THIRD_PARTY_INVITOR) ||
			    ((CallType == CALLEE) && (pConference->LocalEndpointAttached == NEVER_ATTACHED)))
				InvokeUserConferenceCallback(pConference,
											 CC_CONNECT_INDICATION,
											 status,
											 &ConnectCallbackParams);
		}
		H245ShutDown(H245Instance);
		Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
		if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
			FreeCall(pCall);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
		return 0;
	}

	pCall->bLinkEstablished = TRUE;

	status = SendTermCaps(pCall, pConference);
	if (status != CC_OK) {

		MarkCallForDeletion(pCall);

		if (CallType == THIRD_PARTY_INTERMEDIARY) {
			if (hQ931CallInvitor != CC_INVALID_HANDLE)
				Q931RejectCall(hQ931CallInvitor,
							   CC_REJECT_UNDEFINED_REASON,
							   &pCallAcceptedData->ConferenceID,
							   NULL,	// alternate address
							   pCallAcceptedData->pNonStandardData);
		} else {
			if ((CallType == CALLER) || (CallType == THIRD_PARTY_INVITOR) ||
			    ((CallType == CALLEE) && (pConference->LocalEndpointAttached == NEVER_ATTACHED)))
				InvokeUserConferenceCallback(pConference,
											 CC_CONNECT_INDICATION,
											 CC_NO_MEMORY,
											 &ConnectCallbackParams);
		}
		H245ShutDown(H245Instance);
		Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
		if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
			FreeCall(pCall);
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
		return 0;
	}
	
	pCall->OutgoingTermCapState = AWAITING_ACK;

	if (pCall->MasterSlaveState == MASTER_SLAVE_NOT_STARTED) {
		status = H245InitMasterSlave(pCall->H245Instance,
			                         pCall->H245Instance);	// returned as dwTransId in the callback
		if (status != H245_ERROR_OK) {

			MarkCallForDeletion(pCall);

			if (CallType == THIRD_PARTY_INTERMEDIARY) {
				if (hQ931CallInvitor != CC_INVALID_HANDLE)
					Q931RejectCall(hQ931CallInvitor,
								   CC_REJECT_UNDEFINED_REASON,
								   &pCallAcceptedData->ConferenceID,
								   NULL,	// alternate address
								   pCallAcceptedData->pNonStandardData);
			} else {
				if ((CallType == CALLER) || (CallType == THIRD_PARTY_INVITOR) ||
			        ((CallType == CALLEE) && (pConference->LocalEndpointAttached == NEVER_ATTACHED)))
					InvokeUserConferenceCallback(pConference,
												 CC_CONNECT_INDICATION,
												 status,
												 &ConnectCallbackParams);
			}
			H245ShutDown(H245Instance);
			Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
			if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
				FreeCall(pCall);
			if (ValidateConference(hConference) == CC_OK)
				UnlockConference(pConference);
			return 0;
		}
		pCall->MasterSlaveState = MASTER_SLAVE_IN_PROGRESS;
	}

	UnlockConference(pConference);
	UnlockCall(pCall);
	return 0;
}



DWORD _Q931CallRinging(				HQ931CALL				hQ931Call,
									CC_HCALL				hCall)
{
PCALL						pCall;
CC_HCONFERENCE				hConference;
PCONFERENCE					pConference;
HRESULT						status;
CC_RINGING_CALLBACK_PARAMS	RingingCallbackParams;
CC_CONFERENCEID				ConferenceID;

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		Q931RejectCall(hQ931Call,				// Q931 call handle
		               CC_REJECT_UNDEFINED_REASON,	// reject reason
					   NULL,					// conference ID
					   NULL,					// alternate address
					   NULL);					// non-standard data
		return 0;
	}

	ConferenceID = pCall->ConferenceID;

	if ((pCall->hQ931Call != hQ931Call) || (pCall->CallState != PLACED)) {
		// The peer must be in a bad state; we don't expect to receive this message now
		UnlockCall(pCall);
		return 0;
	}

	pCall->CallState = RINGING;

	if (pCall->CallType == THIRD_PARTY_INTERMEDIARY) {
		// Send "ringing" indication to pCall->hQ931CallInvitor
		Q931Ringing(pCall->hQ931CallInvitor,
			        NULL);	// pCRV
		UnlockConference(pConference);
		UnlockCall(pCall);
		return 0;
	}

	RingingCallbackParams.pNonStandardData = NULL;
	RingingCallbackParams.dwUserToken = pCall->dwUserToken;

	// save a copy of the conference handle; we'll need it to validate
	// the conference object after returning from the user callback
	hConference = pConference->hConference;

	InvokeUserConferenceCallback(pConference,
		                         CC_RINGING_INDICATION,
								 CC_OK,
								 &RingingCallbackParams);
	
	// Need to validate conference and call handles; the associated objects may
	// have been deleted during the user callback in this thread
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pCall);
	return 0;
}



DWORD _Q931CallFailed(				HQ931CALL				hQ931Call,
									CC_HCALL				hCall,
									PCSS_CALL_FAILED		pCallFailedData)
{
PCALL						pCall;
CC_HCONFERENCE				hConference;
PCONFERENCE					pConference;
HQ931CALL					hQ931CallInvitor;
HRESULT						status;
CC_CONNECT_CALLBACK_PARAMS	ConnectCallbackParams;
CALLTYPE					CallType;
CC_CONFERENCEID				ConferenceID;
WORD						wNumCalls;

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		return 0;

	CallType = pCall->CallType;
	ConferenceID = pCall->ConferenceID;

	if (pCall->hQ931Call != hQ931Call) {
		UnlockConference(pConference);
		UnlockCall(pCall);
		return 0;
	}

	if (CallType == THIRD_PARTY_INTERMEDIARY) {
		hQ931CallInvitor = pCall->hQ931CallInvitor;
		FreeCall(pCall);
		UnlockConference(pConference);
		if (hQ931CallInvitor != CC_INVALID_HANDLE)
			Q931RejectCall(hQ931CallInvitor,
						   CC_REJECT_UNREACHABLE_DESTINATION,
						   &ConferenceID,
						   NULL,	// alternate address
						   NULL);	// non-standard data
		return 0;
	}

	ConnectCallbackParams.pNonStandardData = NULL;
	ConnectCallbackParams.pszPeerDisplay = NULL;
	ConnectCallbackParams.bRejectReason = CC_REJECT_UNREACHABLE_DESTINATION;
	ConnectCallbackParams.pTermCapList = NULL;
	ConnectCallbackParams.pH2250MuxCapability = NULL;
	ConnectCallbackParams.pTermCapDescriptors = NULL;	
	ConnectCallbackParams.pLocalAddr = pCall->pQ931LocalConnectAddr;
 	if (pCall->pQ931DestinationAddr == NULL)
		ConnectCallbackParams.pPeerAddr = pCall->pQ931PeerConnectAddr;
	else
		ConnectCallbackParams.pPeerAddr = pCall->pQ931DestinationAddr;
	ConnectCallbackParams.pVendorInfo = pCall->pPeerVendorInfo;
	ConnectCallbackParams.bMultipointConference = FALSE;
	ConnectCallbackParams.pConferenceID = &pConference->ConferenceID;
	ConnectCallbackParams.pMCAddress = NULL;
	ConnectCallbackParams.pAlternateAddress = NULL;
	ConnectCallbackParams.dwUserToken = pCall->dwUserToken;

	// save a copy of the conference handle; we'll need it to validate
	// the conference object after returning from the user callback
	hConference = pConference->hConference;

	MarkCallForDeletion(pCall);

	if ((CallType == CALLER) || (CallType == THIRD_PARTY_INVITOR) ||
	    ((CallType == CALLEE) && (pConference->LocalEndpointAttached == NEVER_ATTACHED))) {
		InvokeUserConferenceCallback(pConference,
									 CC_CONNECT_INDICATION,
									 pCallFailedData->error,
									 &ConnectCallbackParams);
	}
	if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
		FreeCall(pCall);
	// Need to validate conference handle; the associated object may
	// have been deleted during the user callback in this thread
	if (ValidateConference(hConference) != CC_OK)
		return 0;

	for ( ; ; ) {
		// Start up an enqueued call, if one exists
		status = RemoveEnqueuedCallFromConference(pConference, &hCall);
		if ((status != CC_OK) || (hCall == CC_INVALID_HANDLE))
			break;

		status = LockCall(hCall, &pCall);
		if (status == CC_OK) {
			pCall->CallState = PLACED;

			status = PlaceCall(pCall, pConference);
			UnlockCall(pCall);
			if (status == CC_OK)
				break;
		}
	}

	EnumerateCallsInConference(&wNumCalls, NULL, pConference, REAL_CALLS);

	if (wNumCalls == 0) {
		if (pConference->bDeferredDelete) {
			ASSERT(pConference->LocalEndpointAttached == DETACHED);
			FreeConference(pConference);
		} else {
			if ((pConference->ConferenceMode != MULTIPOINT_MODE) ||
				(pConference->tsMultipointController != TS_TRUE))
				ReInitializeConference(pConference);
			UnlockConference(pConference);
		}
	} else {
		UnlockConference(pConference);
	}
	return 0;
}



DWORD _Q931CallConnectionClosed(	HQ931CALL				hQ931Call,
									CC_HCALL				hCall)
{
	return 0;
}



DWORD Q931Callback(					BYTE					bEvent,
									HQ931CALL				hQ931Call,
									DWORD					dwListenToken,
									DWORD					dwUserToken,
									void *					pEventData)
{
DWORD	dwStatus;

	EnterCallControl();

	if (CallControlState != OPERATIONAL_STATE)
		DWLeaveCallControl(0);

	switch (bEvent) {
		case Q931_CALL_INCOMING:
			dwStatus = _Q931CallIncoming(hQ931Call, (CC_HLISTEN)dwListenToken,
				                         (PCSS_CALL_INCOMING)pEventData);
			break;

		case Q931_CALL_REMOTE_HANGUP:
			dwStatus = _Q931CallRemoteHangup(hQ931Call, (CC_HLISTEN)dwListenToken,
				                             (CC_HCALL)dwUserToken);
			break;

		case Q931_CALL_REJECTED:
			dwStatus =  _Q931CallRejected(hQ931Call, (CC_HCALL)dwUserToken,
				                          (PCSS_CALL_REJECTED)pEventData);
			break;

		case Q931_CALL_ACCEPTED:
			dwStatus =  _Q931CallAccepted(hQ931Call, (CC_HCALL)dwUserToken,
				                          (PCSS_CALL_ACCEPTED)pEventData);
			break;

		case Q931_CALL_RINGING:
			dwStatus =  _Q931CallRinging(hQ931Call, (CC_HCALL)dwUserToken);
			break;

		case Q931_CALL_FAILED:
			dwStatus = _Q931CallFailed(hQ931Call, (CC_HCALL)dwUserToken,
				                       (PCSS_CALL_FAILED)pEventData);
			break;

		case Q931_CALL_CONNECTION_CLOSED:
			dwStatus = _Q931CallConnectionClosed(hQ931Call, (CC_HCALL)dwUserToken);
			break;

		default:
			ASSERT(0);
			dwStatus = 0;
			break;
	}
	DWLeaveCallControl(dwStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\inc\api_vers.h ===
#define API_VERSION "CJ006"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\inc\api.h ===
/******************************************************************************
 *
 *   INTEL Corporation Proprietary Information				   
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.				   
 *									   
 *   This listing is supplied under the terms of a license agreement	   
 *   with INTEL Corporation and may not be used, copied, nor disclosed	   
 *   except in accordance with the terms of that agreement.		   
 *
 *****************************************************************************/

/******************************************************************************
 *									   
 *  $Workfile:   api.h  $
 *  $Revision:   1.5  $
 *  $Modtime:   06 Jun 1996 17:10:36  $
 *  $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/api.h_v  $	
 * 
 *    Rev 1.5   06 Jun 1996 18:43:08   EHOWARDX
 * Unnested tracker structure and eliminated PLOCK macros.
 * 
 *    Rev 1.4   29 May 1996 15:20:40   EHOWARDX
 * Change to use HRESULT.
 * 
 *    Rev 1.3   20 May 1996 14:31:54   EHOWARDX
 * Got rid of asynchronous EndSession/Shutdown stuff.
 * 
 *    Rev 1.2   16 May 1996 15:55:56   EHOWARDX
 * Replaced LocalSequenceNum with LocalCapDescIdNum.
 * 
 *    Rev 1.1   13 May 1996 23:15:46   EHOWARDX
 * Fixed remote termcap handling.
 * 
 *    Rev 1.0   09 May 1996 21:04:42   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.17   09 May 1996 19:38:20   EHOWARDX
 * Redesigned locking logic and added new functionality.
 * 
 *    Rev 1.16   15 Apr 1996 15:58:14   cjutzi
 * 
 * - added phase2 back
 * 
 *    Rev 1.15   15 Apr 1996 13:59:42   cjutzi
 * 
 * - added conflict resolution
 *  needed to change the api data structure to keep track of the
 *   outstanding data type.. 
 * 
 * 
 *    Rev 1.13   01 Apr 1996 16:50:48   cjutzi
 * 
 * - Completed ENdConnection, and made asynch.. rather
 * than sync.. as before
 * Changed H245ShutDown to be sync rather than async..
 * 
 *    Rev 1.12   26 Mar 1996 09:49:08   cjutzi
 * 
 * - ok.. Added Enter&Leave&Init&Delete Critical Sections for Ring 0
 * 
 *    Rev 1.11   13 Mar 1996 14:11:38   cjutzi
 * 
 * - removed trace message from PLOCK and VLOCK
 * d
 * 
 *    Rev 1.10   13 Mar 1996 09:14:06   cjutzi
 * - changed LPCRITICAL SECTION to CRITICAL_SECITON *
 * 
 *    Rev 1.9   12 Mar 1996 15:49:08   cjutzi
 * 
 * - added locking
 * 
 *    Rev 1.8   08 Mar 1996 14:08:02   cjutzi
 * 
 * - added MuxCapsSet and MuxTable stuff for tracking.. 
 * 
 *    Rev 1.7   05 Mar 1996 09:55:08   cjutzi
 * 
 * - added mux table stuff
 * 
 *    Rev 1.6   01 Mar 1996 13:47:26   cjutzi
 * 
 * - added a state to Tracker for release indications from fsm
 * 
 *    Rev 1.5   15 Feb 1996 10:48:00   cjutzi
 * - added some structs to API
 * - added some defines for API
 * 
 *    Rev 1.4   09 Feb 1996 16:43:06   cjutzi
 * 
 * - added some states
 * - added some tracker types
 *  $Ident$
 *
 *****************************************************************************/

#ifndef _API_H
#define _API_H

/********************************************************/
/*		api Decl				*/
/********************************************************/
#include <h245api.h>		/* Instance and TypeDefs  */
#include <h245sys.x>		/* critical section stuff */
#include <h245asn1.h>		/* for TermCaps		  */

/* STATES */


#define TRANSMIT 		0
#define RECEIVE			1

#define H245_LOCAL 		2
#define H245_REMOTE		3

/* from api_util.c */
HRESULT api_init   (struct InstanceStruct *pInstance);
HRESULT api_deinit (struct InstanceStruct *pInstance);

typedef struct H245_LINK_T
{
  struct H245_LINK_T 	*p_next;
} H245_LINK_T;

typedef
enum {
  API_TERMCAP_T = 0,
  API_OPEN_CHANNEL_T,
  API_CLOSE_CHANNEL_T,
  API_MSTSLV_T,
  API_SEND_MUX_T,
  API_RECV_MUX_T,

} API_TRACKER_T;


typedef
enum {
  API_ST_WAIT_RMTACK = 0x10,		/* waiting for remote ask	*/
  API_ST_WAIT_LCLACK,			/* waiting for local ack 	*/
  API_ST_WAIT_LCLACK_CANCEL,		/* request was canceled.. 	*/
  API_ST_WAIT_CONF,			/* waiting for open confirm (bi only) */
  API_ST_IDLE				/* for open only 		*/

} API_TRACKER_STATE_T;


typedef
enum {
  API_CH_ALLOC_UNDEF = 0x20,
  API_CH_ALLOC_LCL,
  API_CH_ALLOC_RMT
} API_TRACKER_CH_ALLOC_T;

typedef
enum {
  API_CH_TYPE_UNDEF = 0x030,
  API_CH_TYPE_UNI,
  API_CH_TYPE_BI
} API_TRACKER_CH_T;


/* Tracker Structure */
typedef struct
{
  API_TRACKER_CH_ALLOC_T  ChannelAlloc;	/* who allocated the channel 	   */
  API_TRACKER_CH_T	  ChannelType; 	/* either bi or uni 		   */
  DWORD			  TxChannel;	/* for bi&uni-directional channel  */
  DWORD			  RxChannel;	/* for bi-directional channel only */
  H245_CLIENT_T		  DataType;	/* data type used for conflict     */
    					/* detection 			   */
} TrackerChannelStruct;

typedef union
{
  /* 
  API_OPEN_CHANNEL_T,
  API_CLOSE_CHANNEL_T,
  */
  TrackerChannelStruct  Channel;
  
  /*
  API_SEND_MUX_T,
  API_RECV_MUX_T,
  */
  DWORD			MuxEntryCount;

  /* don't care */
  /*
  API_MSTSLV_T,
  API_TERMCAP_T
  */
} TrackerUnion;

typedef struct TrackerStruct
{
  struct TrackerStruct 	*p_next;
  struct TrackerStruct	*p_prev;
  DWORD			TransId;
  API_TRACKER_STATE_T	State;
  API_TRACKER_T		TrackerType;
  TrackerUnion          u;
} Tracker_T;

/* API Structure */
typedef struct 
{
  enum {
    APIMS_Undef,
    APIMS_InProcess,
    APIMS_Master,
    APIMS_Slave
  }				 MasterSlave;	 /* master or slave or inprocess */
  enum {
    APIST_Undef,
    APIST_Inited,
    APIST_Connecting,
    APIST_Connected,
    APIST_Disconnected
  }				 SystemState;	 /* */

  DWORD				 MuxCapsSet;
  DWORD				 dwPreserved;
  H245_CONF_IND_CALLBACK_T	 ConfIndCallBack;/* callback for H245 Client	*/
  
  H245_CAPID_T                   LocalCapIdNum;  
  H245_CAPDESCID_T      	 LocalCapDescIdNum;
  
  MltmdSystmCntrlMssg		 PDU_LocalTermCap; 
  MltmdSystmCntrlMssg		 PDU_RemoteTermCap;
#define TERMCAPSET u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet
  Tracker_T			*pTracker;
} API_STRUCT_T;

#endif // _API_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\inc\h245com.h ===
/******************************************************************************
 *
 *   INTEL Corporation Proprietary Information				   
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.			
 *									   
 *   This listing is supplied under the terms of a license agreement	   
 *   with INTEL Corporation and may not be used, copied, nor disclosed	   
 *   except in accordance with the terms of that agreement.		   
 *
 *****************************************************************************/

/******************************************************************************
 *									   
 *  $Workfile:   h245com.h  $						
 *  $Revision:   1.6  $							
 *  $Modtime:   Mar 04 1997 17:38:42  $					
 *  $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/h245com.h_v  $	
 * 
 *    Rev 1.6   Mar 04 1997 17:53:24   tomitowx
 * process detach fix
 * 
 *    Rev 1.5   12 Dec 1996 15:53:48   EHOWARDX
 * 
 * Master Slave Determination kludge.
 * 
 *    Rev 1.4   10 Jun 1996 16:51:20   EHOWARDX
 * Added Configuration parameter to InstanceCreate().
 * 
 *    Rev 1.3   04 Jun 1996 13:24:38   EHOWARDX
 * Fixed warnings in Release build.
 * 
 *    Rev 1.2   29 May 1996 15:21:30   EHOWARDX
 * No change.
 * 
 *    Rev 1.1   28 May 1996 14:10:00   EHOWARDX
 * Tel Aviv update.
 * 
 *    Rev 1.0   09 May 1996 21:04:48   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.17   09 May 1996 19:38:10   EHOWARDX
 * Redesigned locking logic and added new functionality.
 * 
 *    Rev 1.16   04 Apr 1996 18:06:30   cjutzi
 * - added shutdown lock
 * 
 *    Rev 1.15   26 Mar 1996 13:39:56   cjutzi
 * - fixed assert warning message
 * 
 *    Rev 1.14   26 Mar 1996 13:24:26   cjutzi
 * 
 * - added pragma for release code.. to disable warning messages
 *   from H245TRACE
 * 
 *    Rev 1.13   26 Mar 1996 09:49:34   cjutzi
 * 
 * - ok.. Added Enter&Leave&Init&Delete Critical Sections for Ring 0
 * 
 *    Rev 1.12   26 Mar 1996 08:40:44   cjutzi
 * 
 * 
 *    Rev 1.11   25 Mar 1996 17:54:44   cjutzi
 * 
 * - broke build.. backstep
 * 
 *    Rev 1.10   25 Mar 1996 17:21:32   cjutzi
 * 
 * - added h245sys.x to the global includes for the enter critical 
 *   section stuff
 * 
 *    Rev 1.9   18 Mar 1996 09:14:10   cjutzi
 * 
 * - sorry.. removed timer lock.. not needed. 
 * 
 *    Rev 1.8   18 Mar 1996 08:48:38   cjutzi
 * - added timer lock
 * 
 *    Rev 1.7   13 Mar 1996 14:08:20   cjutzi
 * - removed ASSERT when NDEBUG is defined
 * 
 * 
 *    Rev 1.6   13 Mar 1996 09:50:16   dabrown1
 * added winspox.h for CRITICAL_SECTION definition
 * 
 *    Rev 1.5   12 Mar 1996 15:48:24   cjutzi
 * 
 * - added instance table lock
 * 
 *    Rev 1.4   28 Feb 1996 09:36:22   cjutzi
 * 
 * - added ossGlobal p_ossWorld for debug PDU tracing and PDU verification
 * 
 *    Rev 1.3   21 Feb 1996 12:18:52   EHOWARDX
 * Added parenthesis around n in H245ASSERT() macro.
 * Note: Logical not (!) has higher operator precedence than equal/not equal
 * (== or !=). Therefore, in many places this assert was not acting as the
 * author intended. It is always a good idea to fully parenthesize expressions
 * in macros!
 * 
 *    Rev 1.2   09 Feb 1996 16:19:52   cjutzi
 * 
 * - Added export InstanceTbl to module.. from h245init.x
 * - added trace
 * - added Assert define's
 *  $Ident$
 *
 *****************************************************************************/

#ifndef _H245COM_H_
#define _H245COM_H_
#include "h245api.h"
#include "h245sys.x"		/* critical section stuff */
#include "api.h"		/* api includes */
#include "sendrcv.x"
#include "h245fsm.h"

#ifndef OIL
# define RESULT unsigned long
#endif

void H245Assert (LPSTR, int, LPSTR);
void H245Panic  (LPSTR, int);
#if defined(DBG)
#define H245ASSERT(n) { if (!(n)) H245Assert(__FILE__,__LINE__,"n"); }
#define H245PANIC()   { H245Panic(__FILE__,__LINE__); }
#else
#define H245ASSERT(n)
#define H245PANIC()
#endif

/*
 * Trace Level Definitions:
 * 
 *	0 - no trace on at all
 *	1 - only errors
 *	2 - PDU tracking
 *	3 - PDU and SendReceive packet tracing
 *	4 - Main API Module level tracing
 *	5 - Inter Module level tacing #1
 *	6 - Inter Module level tacing #2
 *	7 - <Undefined>
 *	8 - <Undefined>
 *	9 - <Undefined>
 *	10- and above.. free for all
 */
#if defined(DBG)
void H245TRACE (H245_INST_T inst, DWORD level, LPSTR format, ...);
#else
/* disable H245TRACE warning message too may parameters for macro */
#pragma warning (disable:4002)
#define H245TRACE()
#endif

#define MAXINST 256

extern  DWORD g_dwH245DbgLevel;

typedef struct TimerList 
{
  struct TimerList    * pNext;
  void		      * pContext;
  H245TIMERCALLBACK     pfnCallBack;
  DWORD                 dwAlarm;

} TimerList_T;

typedef struct InstanceStruct 
{
  DWORD		    dwPhysId;           // Physical Identifier
  DWORD		    dwInst;             // H.245 client instance Identifier
  H245_CONFIG_T	    Configuration;      // Client type
  ASN1_CODER_INFO *pWorld;              // Context for ASN.1 encode/decode

  /* context for subsystems */
  API_STRUCT_T      API;                // API subsystem substructure
  hSRINSTANCE       SendReceive;        // Send/Receive subsystem substructure
  Fsm_Struct_t      StateMachine;       // State Machine subsystem substructure

  TimerList_T      *pTimerList;         // Linked list of running timeout timers
  char              fDelete;            // TRUE to delete instance
  char              LockCount;          // Nested critical section count
  char              bMasterSlaveKludge; // TRUE if remote is same version
  char              bReserved;
};

struct InstanceStruct * InstanceCreate(DWORD dwPhysId, H245_CONFIG_T Configuration);
struct InstanceStruct * InstanceFind  (DWORD dwPhysId);
struct InstanceStruct * InstanceLock(H245_INST_T dwInst);
int InstanceUnlock(struct InstanceStruct *pInstance);
int InstanceDelete(struct InstanceStruct *pInstance);
int InstanceUnlock_ProcessDetach(struct InstanceStruct *pInstance, BOOL fProcessDetach);


#endif /* _H245COM_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\inc\h245plog.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************/

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// AUTHOR       Stacy Bell
//
// DESCRIPTION
//              This file contains protocol logging definitions needed by H245 and
//              the H245 PDU logging class.
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

// This define identifies the H245 protocol as the one to be logged.  In the 
// H245 code, it is used only in the InteropLoad() call.  
// For example:  H245Logger = InteropLoad( H245LOG_PROTOCOL );
//
#define H245LOG_PROTOCOL "H245_PDU"

// PDU encoding type flags and PDU type flags.  These flags are passed from
// H245 to the logging via user data.  Bit 1 represents whether the PDU
// was sent or received.
//

#define H245LOG_SENT_PDU                1UL
#define H245LOG_RECEIVED_PDU            0UL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\cc\h245\inc\h245fsm.h ===
/***********************************************************************
 *                                                                     *
 * Filename: h245fsm.h                                                 *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   H245FSM.H  $
 * $Revision:   1.6  $
 * $Modtime:   09 Dec 1996 13:40:40  $
 * $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/H245FSM.H_v  $
 * 
 *    Rev 1.6   09 Dec 1996 13:40:52   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.5   29 Jul 1996 16:57:14   EHOWARDX
 * Added H.223 Annex A Reconfiguration events.
 * 
 *    Rev 1.4   01 Jul 1996 22:08:32   EHOWARDX
 * 
 * Updated stateless events.
 * 
 *    Rev 1.3   30 May 1996 23:38:20   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.2   29 May 1996 15:21:34   EHOWARDX
 * Change to use HRESULT.
 * 
 *    Rev 1.1   28 May 1996 14:10:04   EHOWARDX
 * Tel Aviv update.
 * 
 *    Rev 1.0   09 May 1996 21:04:50   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.12.1.3   09 May 1996 19:43:58   EHOWARDX
 * Eliminated two events for B-LCSE gratuitous state and changed
 * 2 macros.
 * 
 *    Rev 1.12.1.2   15 Apr 1996 10:43:34   EHOWARDX
 * Update.
 * 
 *    Rev 1.12.1.1   10 Apr 1996 21:06:10   EHOWARDX
 * Added 5 new state entitys.
 * 
 *    Rev 1.12.1.0   05 Apr 1996 11:47:14   EHOWARDX
 * Branched.
 *                                                                     *
 ***********************************************************************/

#ifndef H245FSM_H
#define H245FSM_H

#ifdef OIL
# include <oil.x>
#else
# pragma warning( disable : 4115 4201 4214 4514 )
# include <windows.h>
#endif

#include <stdlib.h>
#include "fsmexpor.h"
#include "sr_api.h"

#define MAXSTATES  4

#define SUCCESS 0
#define FAIL   -1

#define BAD                 (Output_t) -1
#ifdef IGNORE
#undef IGNORE
#endif
#define IGNORE              (Output_t) NUM_OUTPUTS

typedef MltmdSystmCntrlMssg PDU_t;



// Signalling Entity definitions
typedef unsigned char Entity_t;

// Per-channel Signalling Entities
#define LCSE_OUT    (Entity_t) 0 // Uni-directional Logical Channel signalling Signalling Entity - Out-going
#define LCSE_IN     (Entity_t) 1 // Uni-directional Logical Channel signalling Signalling Entity - In-coming
#define BLCSE_OUT   (Entity_t) 2 // Bi-directional  Logical Channel signalling Signalling Entity - Out-going
#define BLCSE_IN    (Entity_t) 3 // Bi-directional  Logical Channel signalling Signalling Entity - In-coming
#define CLCSE_OUT   (Entity_t) 4 // Close           Logical Channel signalling Signalling Entity - Out-going
#define CLCSE_IN    (Entity_t) 5 // Close           Logical Channel signalling Signalling Entity - In-coming

// Per H.245 Instance Signalling Entities
#define CESE_OUT    (Entity_t) 6 // Capability Exchange Signalling Entity - Out-going
#define CESE_IN     (Entity_t) 7 // Capability Exchange Signalling Entity - In-coming
#define MTSE_OUT    (Entity_t) 8 // Multiplex Table Signalling Entity - Out-going
#define MTSE_IN     (Entity_t) 9 // Multiplex Table Signalling Entity - In-coming
#define RMESE_OUT   (Entity_t)10 // Request Multiplex Entry Signalling Entity - Out-going
#define RMESE_IN    (Entity_t)11 // Request Multiplex Entry Signalling Entity - In-coming
#define MRSE_OUT    (Entity_t)12 // Mode Request Signalling Entity - Out-going
#define MRSE_IN     (Entity_t)13 // Mode Request Signalling Entity - In-coming
#define MLSE_OUT    (Entity_t)14 // Maintenance Loop Signalling Entity - Out-going
#define MLSE_IN     (Entity_t)15 // Maintenance Loop Signalling Entity - In-coming
#define MSDSE       (Entity_t)16 // Master Slave Determination Signalling Entity
#define RTDSE       (Entity_t)17 // Round Trip Delay Signalling Entity
#define STATELESS   (Entity_t)18 // No state machine associated with PDU

#define NUM_ENTITYS           19



// Event definitions
typedef unsigned int Event_t;

// Out-going Uni-directional Logical Channel (LCSE_OUT) events
#define ReqUEstablish                   (Event_t)  0
#define OpenUChAckPDU                   (Event_t)  1
#define OpenUChRejectPDU                (Event_t)  2
#define CloseUChAckPDU                  (Event_t)  3
#define ReqURelease                     (Event_t)  4
#define T103Expiry                      (Event_t)  5

// In-coming Uni-directional Logical Channel (LCSE_IN) events
#define OpenUChPDU                      (Event_t)  6
#define CloseUChPDU                     (Event_t)  7
#define ResponseUEstablish              (Event_t)  8
#define EstablishUReject                (Event_t)  9

// Out-going Bi-directional Logical Channel (BLCSE_OUT) events
#define ReqBEstablish                   (Event_t) 10
#define OpenBChAckPDU                   (Event_t) 11
#define OpenBChRejectPDU                (Event_t) 12
#define CloseBChAckPDU                  (Event_t) 13
#define ReqClsBLCSE                     (Event_t) 14
#define RspConfirmBLCSE                 (Event_t) 15
#define T103OutExpiry                   (Event_t) 16

// In-coming Bi-directional Logical Channel (BLCSE_IN) events
#define OpenBChPDU                      (Event_t) 17
#define CloseBChPDU                     (Event_t) 18
#define ResponseBEstablish              (Event_t) 19
#define OpenBChConfirmPDU               (Event_t) 20
#define OpenRejectBLCSE                 (Event_t) 21
#define T103InExpiry                    (Event_t) 22

// Out-going Request Close Logical Channel (CLCSE_OUT) events
#define ReqClose                        (Event_t) 23
#define ReqChCloseAckPDU                (Event_t) 24
#define ReqChCloseRejectPDU             (Event_t) 25
#define T108Expiry                      (Event_t) 26

// In-coming Request Close Logical Channel (CLCSE_IN) events
#define ReqChClosePDU                   (Event_t) 27
#define ReqChCloseReleasePDU            (Event_t) 28
#define CLCSE_CLOSE_response            (Event_t) 29
#define CLCSE_REJECT_request            (Event_t) 30

// Out-going Terminal Capablity Exchange (CESE_OUT) events
#define TransferCapRequest              (Event_t) 31
#define TermCapSetAckPDU                (Event_t) 32
#define TermCapSetRejectPDU             (Event_t) 33
#define T101Expiry                      (Event_t) 34

// In-coming Terminal Capablity Exchange (CESE_IN) events
#define TermCapSetPDU                   (Event_t) 35
#define TermCapSetReleasePDU            (Event_t) 36
#define CESE_TRANSFER_response          (Event_t) 37
#define CESE_REJECT_request             (Event_t) 38

// Out-going Multiplex Table (MTSE_OUT) events
#define MTSE_TRANSFER_request           (Event_t) 39
#define MultiplexEntrySendAckPDU        (Event_t) 40
#define MultiplexEntrySendRejectPDU     (Event_t) 41
#define T104Expiry                      (Event_t) 42

// In-coming Multiplex Table (MTSE_IN) events
#define MultiplexEntrySendPDU           (Event_t) 43
#define MultiplexEntrySendReleasePDU    (Event_t) 44
#define MTSE_TRANSFER_response          (Event_t) 45
#define MTSE_REJECT_request             (Event_t) 46

// Out-going Request Multiplex Entry (RMESE_OUT) events
#define RMESE_SEND_request              (Event_t) 47
#define RequestMultiplexEntryAckPDU     (Event_t) 48
#define RequestMultiplexEntryRejectPDU  (Event_t) 49
#define T107Expiry                      (Event_t) 50

// In-coming Request Multiplex Entry (RMESE_IN) events
#define RequestMultiplexEntryPDU        (Event_t) 51
#define RequestMultiplexEntryReleasePDU (Event_t) 52
#define RMESE_SEND_response             (Event_t) 53
#define RMESE_REJECT_request            (Event_t) 54

// Out-going Mode Request (MRSE_OUT) events
#define MRSE_TRANSFER_request           (Event_t) 55
#define RequestModeAckPDU               (Event_t) 56
#define RequestModeRejectPDU            (Event_t) 57
#define T109Expiry                      (Event_t) 58

// In-coming Mode Request (MRSE_IN) events
#define RequestModePDU                  (Event_t) 59
#define RequestModeReleasePDU           (Event_t) 60
#define MRSE_TRANSFER_response          (Event_t) 61
#define MRSE_REJECT_request             (Event_t) 62

// Out-going Maintenance Loop (MLSE_OUT) events
#define MLSE_LOOP_request               (Event_t) 63
#define MLSE_OUT_RELEASE_request        (Event_t) 64
#define MaintenanceLoopAckPDU           (Event_t) 65
#define MaintenanceLoopRejectPDU        (Event_t) 66
#define T102Expiry                      (Event_t) 67

// In-coming Maintenance Loop (MLSE_IN) events
#define MaintenanceLoopRequestPDU       (Event_t) 68
#define MaintenanceLoopOffCommandPDU    (Event_t) 69
#define MLSE_LOOP_response              (Event_t) 70
#define MLSE_IN_RELEASE_request         (Event_t) 71

// Master Slave Determination (MSDSE) events
#define MSDetReq                        (Event_t) 72
#define MSDetPDU                        (Event_t) 73
#define MSDetAckPDU                     (Event_t) 74
#define MSDetRejectPDU                  (Event_t) 75
#define MSDetReleasePDU                 (Event_t) 76
#define T106Expiry                      (Event_t) 77

// Round Trip Delay Delay (RTDSE) events
#define RTDSE_TRANSFER_request          (Event_t) 78
#define RoundTripDelayRequestPDU        (Event_t) 79
#define RoundTripDelayResponsePDU       (Event_t) 80
#define T105Expiry                      (Event_t) 81

#define NUM_STATE_EVENTS                          82

// Events with no associated state entity
#define NonStandardRequestPDU           (Event_t) 82
#define NonStandardResponsePDU          (Event_t) 83
#define NonStandardCommandPDU           (Event_t) 84
#define NonStandardIndicationPDU        (Event_t) 85
#define MiscellaneousCommandPDU         (Event_t) 86
#define MiscellaneousIndicationPDU      (Event_t) 87
#define CommunicationModeRequestPDU     (Event_t) 88
#define CommunicationModeResponsePDU    (Event_t) 89
#define CommunicationModeCommandPDU     (Event_t) 90
#define ConferenceRequestPDU            (Event_t) 91
#define ConferenceResponsePDU           (Event_t) 92
#define ConferenceCommandPDU            (Event_t) 93
#define ConferenceIndicationPDU         (Event_t) 94
#define SendTerminalCapabilitySetPDU    (Event_t) 95
#define EncryptionCommandPDU            (Event_t) 96
#define FlowControlCommandPDU           (Event_t) 97
#define EndSessionCommandPDU            (Event_t) 98
#define FunctionNotUnderstoodPDU        (Event_t) 99
#define JitterIndicationPDU             (Event_t)100
#define H223SkewIndicationPDU           (Event_t)101
#define NewATMVCIndicationPDU           (Event_t)102
#define UserInputIndicationPDU          (Event_t)103
#define H2250MaximumSkewIndicationPDU   (Event_t)104
#define MCLocationIndicationPDU         (Event_t)105
#define VendorIdentificationPDU         (Event_t) 106
#define FunctionNotSupportedPDU         (Event_t) 107
#define H223ReconfigPDU                 (Event_t)108
#define H223ReconfigAckPDU              (Event_t)109
#define H223ReconfigRejectPDU           (Event_t)110

#define NUM_EVENTS                               111



// Output function definitions
typedef unsigned char Output_t;

// Out-going Open Uni-directional Logical Channel (LCSE_OUT) state functions
#define EstablishReleased               (Output_t)  0
#define OpenAckAwaitingE                (Output_t)  1
#define OpenRejAwaitingE                (Output_t)  2
#define ReleaseAwaitingE                (Output_t)  3
#define T103AwaitingE                   (Output_t)  4
#define ReleaseEstablished              (Output_t)  5
#define OpenRejEstablished              (Output_t)  6
#define CloseAckEstablished             (Output_t)  7
#define CloseAckAwaitingR               (Output_t)  8
#define OpenRejAwaitingR                (Output_t)  9
#define T103AwaitingR                   (Output_t) 10
#define EstablishAwaitingR              (Output_t) 11

// In-coming Open Uni-directional Logical Channel (LCSE_IN) state functions
#define OpenReleased                    (Output_t) 12
#define CloseReleased                   (Output_t) 13
#define ResponseAwaiting                (Output_t) 14
#define ReleaseAwaiting                 (Output_t) 15
#define CloseAwaiting                   (Output_t) 16
#define OpenAwaiting                    (Output_t) 17
#define CloseEstablished                (Output_t) 18
#define OpenEstablished                 (Output_t) 19

// Out-going Open Bi-directional Logical Channel (BLCSE_OUT) state functions
#define EstablishReqBReleased           (Output_t) 20
#define OpenChannelAckBAwaitingE        (Output_t) 21
#define OpenChannelRejBAwaitingE        (Output_t) 22
#define ReleaseReqBOutAwaitingE         (Output_t) 23
#define T103ExpiryBAwaitingE            (Output_t) 24
#define ReleaseReqBEstablished          (Output_t) 25
#define OpenChannelRejBEstablished      (Output_t) 26
#define CloseChannelAckBEstablished     (Output_t) 27
#define CloseChannelAckAwaitingR        (Output_t) 28
#define OpenChannelRejBAwaitingR        (Output_t) 29
#define T103ExpiryBAwaitingR            (Output_t) 30
#define EstablishReqAwaitingR           (Output_t) 31

// In-coming Open Bi-directional Logical Channel (BLCSE_IN) state functions
#define OpenChannelBReleased            (Output_t) 32
#define CloseChannelBReleased           (Output_t) 33
#define EstablishResBAwaitingE          (Output_t) 34
#define ReleaseReqBInAwaitingE          (Output_t) 35
#define CloseChannelBAwaitingE          (Output_t) 36
#define OpenChannelBAwaitingE           (Output_t) 37
#define OpenChannelConfirmBAwaitingE    (Output_t) 38
#define T103ExpiryBAwaitingC            (Output_t) 39
#define OpenChannelConfirmBAwaitingC    (Output_t) 40
#define CloseChannelBAwaitingC          (Output_t) 41
#define OpenChannelBAwaitingC           (Output_t) 42
#define CloseChannelBEstablished        (Output_t) 43
#define OpenChannelBEstablished         (Output_t) 44

// Out-going Request Close Logical Channel (CLCSE_OUT) state functions
#define CloseRequestIdle                (Output_t) 45
#define RequestCloseAckAwaitingR        (Output_t) 46
#define RequestCloseRejAwaitingR        (Output_t) 47
#define T108ExpiryAwaitingR             (Output_t) 48

// In-coming Request Close Logical Channel (CLCSE_IN) state functions
#define RequestCloseIdle                (Output_t) 49
#define CloseResponseAwaitingR          (Output_t) 50
#define RejectRequestAwaitingR          (Output_t) 51
#define RequestCloseReleaseAwaitingR    (Output_t) 52
#define RequestCloseAwaitingR           (Output_t) 53

// Out-going Terminal Capability Exchange (CESE_OUT) state functions
#define RequestCapIdle                  (Output_t) 54
#define TermCapAckAwaiting              (Output_t) 55
#define TermCapRejAwaiting              (Output_t) 56
#define T101ExpiryAwaiting              (Output_t) 57

// In-coming Terminal Capability Exchange (CESE_IN) state functions
#define TermCapSetIdle                  (Output_t) 58
#define ResponseCapAwaiting             (Output_t) 59
#define RejectCapAwaiting               (Output_t) 60
#define TermCapReleaseAwaiting          (Output_t) 61
#define TermCapSetAwaiting              (Output_t) 62

// Out-going Multiplex Table (MTSE_OUT) state functions
#define MTSE0_TRANSFER_request          (Output_t) 63
#define MTSE1_TRANSFER_request          (Output_t) 64
#define MTSE1_MultiplexEntrySendAck     (Output_t) 65
#define MTSE1_MultiplexEntrySendRej     (Output_t) 66
#define MTSE1_T104Expiry                (Output_t) 67

// In-coming Multiplex Table (MTSE_IN) state functions
#define MTSE0_MultiplexEntrySend        (Output_t) 68
#define MTSE1_MultiplexEntrySend        (Output_t) 69
#define MTSE1_MultiplexEntrySendRelease (Output_t) 70
#define MTSE1_TRANSFER_response         (Output_t) 71
#define MTSE1_REJECT_request            (Output_t) 72

// Out-going Request Multiplex Entry (RMESE_OUT) state functions
#define RMESE0_SEND_request             (Output_t) 73
#define RMESE1_SEND_request             (Output_t) 74
#define RMESE1_RequestMuxEntryAck       (Output_t) 75
#define RMESE1_RequestMuxEntryRej       (Output_t) 76
#define RMESE1_T107Expiry               (Output_t) 77

// In-coming Request Multiplex Entry (RMESE_IN) state functions
#define RMESE0_RequestMuxEntry          (Output_t) 78
#define RMESE1_RequestMuxEntry          (Output_t) 79
#define RMESE1_RequestMuxEntryRelease   (Output_t) 80
#define RMESE1_SEND_response            (Output_t) 81
#define RMESE1_REJECT_request           (Output_t) 82

// Out-going Request Mode (MRSE_OUT) state functions
#define MRSE0_TRANSFER_request          (Output_t) 83
#define MRSE1_TRANSFER_request          (Output_t) 84
#define MRSE1_RequestModeAck            (Output_t) 85
#define MRSE1_RequestModeRej            (Output_t) 86
#define MRSE1_T109Expiry                (Output_t) 87

// In-coming Request Mode (MRSE_OUT) state functions
#define MRSE0_RequestMode               (Output_t) 88
#define MRSE1_RequestMode               (Output_t) 89
#define MRSE1_RequestModeRelease        (Output_t) 90
#define MRSE1_TRANSFER_response         (Output_t) 91
#define MRSE1_REJECT_request            (Output_t) 92

// Out-going Request Mode (MLSE_OUT) state functions
#define MLSE0_LOOP_request              (Output_t) 93
#define MLSE1_MaintenanceLoopAck        (Output_t) 94
#