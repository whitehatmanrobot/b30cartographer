****************
//
// An HHSOS owned counter.
// This is the number of bad boots we have suffered (meaning the HHSOS could not
// successfully init).  When this number gets too big, we stop trying to init.
// This will cause AWCHKSOS to alert the user of the problem.
//

#define BAD_BOOTS_COUNTER      3

//
// ****************************************************************************


// These values for wFlags (in IFSetCounterValue) - some are mutually exclusive

// If CLEARSET is set the value is cleared before being added - otherwise it is just added
// Currently you cannot request a double long and a timestamp

// For now the interrupt has no context but in the future it might be useful

#define COUNTER_CLEARSET          0x0001
#define COUNTER_DOUBLE_LONG       0x0002
#define COUNTER_UPDATE_TIMESTAMP  0x0004
#define COUNTER_INTERRUPT_CONTEXT 0x1000

// Only here temporarily until everything gets moved to new values

#define COUNTER_VALUESET     (COUNTER_CLEARSET | COUNTER_UPDATE_TIMESTAMP)
#define COUNTER_ADDVALUE     0x0100
#define COUNTER_TIMESTAMP    0x0200
#define COUNTER_NOTIMESTAMP  COUNTER_DOUBLE_LONG
#define PROCESS_CONTEXT      0x0300
#define INTERRUPT_CONTEXT    COUNTER_INTERRUPT_CONTEXT

/********
    @doc    EXTERNAL  IFAXOS

    @types  COUNTERENTRY    | Used to store 4 and 8 byte Counters.

    @field  DWORD   | dwCounterVal1 | For a 4 byte counter, the value of the
           counter. For an 8 byte counter, the low order
           4 bytes of the value of the counter.

    @field  DWORD   | dwTimeStamp | For a 4 byte counter, the time at
           which the counter was last reset. The fields in the timestamp are:
           @flag  Bits 0-4 | Second divided by 2
           @flag  Bits 5-10|   Minute (0-59)
           @flag  Bits 11-15 | Hour (0-23 on a 24 hour clock)
           @flag  Bits 16-20 | Day of the month (1-31)
           @flag  Bits 21-24 | Month (1 = January, 2 = February, etc.)
           @flag  Bits 25-31 | Year offset from 1980 (add 1980 to get actual year)

           For an 8 byte counter, dwTimeStamp is the high order 4 bytes of the
           counter value.

    @comm   Used by the IFNvramGetCounterValue function.

    @xref   <f IFNvramGetCounterValue>
********/
typedef struct tagCOUNTERENTRY {
   DWORD dwCounterVal1;
   DWORD dwTimeStamp;
} COUNTERENTRY, FAR *LPCOUNTERENTRY;

//-------------------------- Prototypes ----------------------------------

#if defined(WFW) || defined(WIN32)

#define IFNvramSetError(dw,lpb,w)              (0)
#define IFNvramSetErrorInterrupt(dw,lpb,w)         (0)
#define IFNvramGetError(lperrlog,lpwMaxEntries) (0)
#define IFNvramSetCounterValue(p1,p2,p3,p4)    (0)
#define IFNvramGetCounterValue(w1,lpentry)         (0)
#define IFNvramAllocScratchBuf(wSize)          (NULL)

#else

BOOL WINAPI     IFNvramSetError(DWORD, LPBYTE, WORD);
BOOL WINAPI     IFNvramSetErrorInterrupt(DWORD, LPBYTE, WORD);
BOOL FAR CDECL  IFNvramvSetError(DWORD dwError,WORD nErrs,...) ;
BOOL WINAPI     IFNvramGetError(LPERRORLOGENTRY lperrlog,LPWORD lpwMaxEntries) ;
BOOL WINAPI     IFNvramSetCounterValue(WORD, DWORD, DWORD, WORD);
BOOL WINAPI     IFNvramGetCounterValue(WORD, LPCOUNTERENTRY);
BOOL WINAPI     IFNvramFlushToFileLog(VOID) ;
BOOL WINAPI     IFNvramInitFileLog(VOID) ;
LPBYTE WINAPI   IFNvramAllocScratchBuf(WORD wSize);

#endif

/********
    @doc    EXTERNAL   IFAXOS

    @api    BOOL | _lflush | Flushes all pending writes to a file handle.

    @parm   HFILE  | hf    | A file handle obtained from _lopen or OpenFile

    @rdesc  Returns TRUE for success, FALSE for failure.

    @comm   This function will flush all pending writes to disk.

            For Win16 implementations, this currently always fails.
*********/

BOOL WINAPI _lflush(HFILE hf);


// the following is for service messages
#define IF_ST_END_SOSBK        (IF_SERVICE_START+0)
#define IF_ST_END_SOSRST       (IF_SERVICE_START+1)


#ifdef __cplusplus
} // extern "C" {
#endif

#endif  // _INC_IFAXOS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\lhutil.h ===
/// hdrutil.h

// Macros and types to support encode/decode of linearized headers

#ifndef _LHUTIL_H
#define _LHUTIL_H

#ifdef __cplusplus
extern "C"  {
#endif

#include <awrt.h>
#include <lineariz.h>
#include <sosmapi.h>
#include <awsec.h>
#include <lhprot.h>

///////////////////////////////////////////////////////////////////////////
/// Extern variables
///

// DEBUG
#ifdef DEBUG
extern DBGPARAM dpCurSettings;
#define ZONE_LINEARIZER (0x0001 & dpCurSettings.ulZoneMask)
#define ZONE_LIN_VERBOSE (0x0002 & dpCurSettings.ulZoneMask)
extern WORD wHashSize;
#endif

///////////////////////////////////////////////////////////////////////////
/// Errors
///

#ifndef NO_ERROR
#  define NO_ERROR (0)
#endif

#define ERR_MEMORY_ERROR (1)
#define ERR_INVALID_OCTETS (2)
#define ERR_UNEXPECTED_OCTETS (3)
#define ERR_UNEXPECTED_LENGTH (4)
#define ERR_DATASTREAM_ERROR (5)

// Define this small because we only use it on the header !!
#define MAX_OCTETBLOCK_SIZE     256


///////////////////////////////////////////////////////////////////////////
/// Types
///

typedef unsigned char   OCTET;

typedef DWORD OCTETSINK;
typedef DWORD OCTETSOURCE;
typedef DWORD OCTETFILE;


typedef struct _LININST {
   DWORD       octets;             // Source/sink for linearized format. This
                                   // is used to get at all the data.
   DWORD       dwGlobalError;      // Error for this job
   LPDATACB    lpfnData;           // Callback to read/write source/sink
   DWORD       dwHashInstance;     // Hashing instance ...
   BYTE        rgb[MAX_OCTETBLOCK_SIZE];   // For decoding memory ...
} LININST, FAR *LPLININST, NEAR *NPLININST;


//------------------------------------------------------------------------

// This def relies on the fact that there is a variable called
// lininst in the calling function which pts to the instance
#define AllocLinMemMacro(lpRet, uSize)  lpRet = lplinst->rgb;

// Nothing to do since its in the instance
#define FreeLinMemMacro(lpVal)  (VOID)(0)

#define OctetInMacro(lplinst, pOctet)   OctetDataMacro(GPM_GETDATA, lplinst, (LPBYTE)pOctet, 1)
#define OctetOutMacro(lplinst, Octet)   \
   {   \
       OCTET   oct = Octet;    \
       OctetDataMacro(GPM_PUTDATA, lplinst, (LPBYTE)&oct, 1);    \
   }
#define OctetBlockInMacro(lplinst, lpb, size) OctetDataMacro(GPM_GETDATA, lplinst, lpb, size)
#define OctetBlockOutMacro(lplinst, lpb, size) OctetDataMacro(GPM_PUTDATA, lplinst, lpb, size)

#define OctetDataMacro(gpm, lplinst, lpb, size)  \
   do {    \
       if ((*lplinst->lpfnData)(gpm, lplinst->octets, (LPBYTE)(lpb), size, NULL)!=size)   \
       {   \
           DEBUGMSG(1, (THIS_FUNCTION ":Octet read/write Failed !!\r\n")); \
           lplinst->dwGlobalError = ERR_DATASTREAM_ERROR;   \
           goto error; \
       }   \
       /* Hash it if necessary */  \
       if (lplinst->dwHashInstance) \
       {   \
           DEBUGSTMT(wHashSize+=size); \
           DEBUGCHK(size <= 0xffff);   \
           SendBFTHash(lplinst->dwHashInstance, (LPBYTE)(lpb), (WORD)size); \
       }   \
   }   \
   while (0)


/// Utility functions to encode / decode a header
#define WriteHdrOpen(lplinst)   \
{   \
   OctetOutMacro(lplinst, TAG_MESSAGE_HEADER);  \
   ASN1EncodeIndefiniteLengthMacro(lplinst);   \
}

#define WriteHdrClose(lplinst)  \
{   \
   ASN1EncodeEndOfContentsOctetsMacro(lplinst);    \
   WriteHashMacro(lplinst);    \
}

#define WriteOrigOpen(lplinst) \
   OctetOutMacro (lplinst, TAG_FROM); \
   ASN1EncodeIndefiniteLengthMacro(lplinst);   \
   OctetOutMacro (lplinst, TAG_RECIP_DESC);   \
   ASN1EncodeIndefiniteLengthMacro(lplinst);

#define WriteOrigClose(lplinst)  \
   ASN1EncodeEndOfContentsOctetsMacro(lplinst);    \
   ASN1EncodeEndOfContentsOctetsMacro(lplinst);

#define WriteRecipOpen(lplinst) \
   OctetOutMacro (lplinst, TAG_TO); \
   ASN1EncodeIndefiniteLengthMacro(lplinst);   \
   OctetOutMacro (lplinst, TAG_RECIP_DESC);   \
   ASN1EncodeIndefiniteLengthMacro(lplinst);

#define WriteRecipClose(lplinst) WriteOrigClose(lplinst)

#define WriteString(lplinst, tag, string)   \
   ASN1EncodePrimitiveStringImplicitMacro(lplinst, tag, string, lstrlen(string)+1)

// Hashing macros
#define StartHashMacro(lplinst) \
{   \
   if (!(lplinst->dwHashInstance = StartBFTHash())) \
   {   \
       DEBUGMSG(1, (THIS_FUNCTION ":Error getting hash instance!\n\r"));    \
       lplinst->dwGlobalError = ERR_NOMEMORY;  \
       goto error; \
   }   \
   DEBUGSTMT(wHashSize=0);     \
}

#define WriteHashMacro(lplinst)  \
{   \
   BYTE    bHash[16]; \
   BYTE    bSalt[3]; \
   _fmemset(bHash, 0, sizeof(bHash));  \
   _fmemset(bSalt, 0, sizeof(bSalt));  \
   /* Complete the hash if we initialized it */    \
   if (lplinst->dwHashInstance) \
   {   \
       DoneBFTHash(lplinst->dwHashInstance, bSalt, bHash); \
       lplinst->dwHashInstance = 0; \
   }   \
   OctetBlockOutMacro(lplinst, bSalt, sizeof(bSalt));  \
   OctetBlockOutMacro(lplinst, bHash, sizeof(bHash));  \
   DEBUGMSG(ZONE_LINEARIZER, ("Lhutil: Hdr Hash Size %u\r\n", wHashSize)); \
}

#define CheckHashMacro(lplinst) \
{   \
   BYTE    rgbMsgHash[19], rgbNewHash[16]; \
   DWORD   dwInstance = lplinst->dwHashInstance; \
   /* Reset instance so we dont hash the msg hash */   \
   lplinst->dwHashInstance = 0; \
   OctetBlockInMacro(lplinst, rgbMsgHash, sizeof(rgbMsgHash)); \
   /* Generate current hash using same salt */ \
   DoneBFTHash(dwInstance, rgbMsgHash, rgbNewHash); \
   /* Compare them */ \
   if (! BinComp(sizeof(rgbNewHash), rgbMsgHash+3,  \
     sizeof(rgbNewHash), rgbNewHash) != 0)    \
   {   \
       DEBUGMSG(1, ("ERROR: Hash Does not match !!!\n\r")); \
       lplinst->dwGlobalError = ERR_GENERAL_FAILURE;   \
       goto error; \
   }   \
}

///////////////////////////////////////////////////////////////////////////
/// Internal funcion prototypes
///
BOOL __fastcall BinComp(DWORD cbA, PVOID lpA, DWORD cbB, PVOID lpB);

#ifdef __cplusplus
}   // extern "C"
#endif

#endif  // hdrutil_inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\lineariz.h ===
#ifndef _LIN_H
#define _LIN_H

#ifdef __cplusplus
extern "C" {
#endif

/* 
 * For File Linearizer, define NO_MAPI, undefine MAPI1
 */
#ifndef NO_MAPI
#if defined(MAPI1) && !defined(MAPIDEFS_H)

// MAPI include files
#include <mapiwin.h>
#include <mapidbg.h>
#undef HTASK
#include <ole2.h>
#include <mapidefs.h>
#include <mapicode.h>
#include <mapitags.h>
#include <mapiguid.h>
#include <mapispi.h>
#include <imessage.h>
#include <mapix.h>
#include <mapiutil.h>
#include <tnef.h>
#endif
#endif

#include <lhprot.h>

#pragma message("Including: " __FILE__)

#ifdef WIN32
#define _loadds
#endif

/***************************************************************************

   Name      : linearizer.h

   Comment   : Contains all linearizer access API declarations

   Functions : (see Prototypes just below)


***************************************************************************/

// version number of the linearized format. This must be from 1 to 7 max.
// Must be 1 fro Snowball-compatible version of linearizer. Increment this
// count when the linearized format changes so that msgs encoded in the
// new format can no longer be decoded by older versions of the linearizer.
// (even though the newer linearizers can still decode msg encoded with older
// ones). Used in NSF


/***************************************************************************

   @doc    EXTERNAL LINEARIZER SRVRDLL

    @topic  Microsoft At Work Linearized File Format  |

            This section describes the format of a Microsoft At Work
            linearized file. This is the standard format used for
            transmitting any Microsoft At Work rendered image,
            or any binary file using an Microsoft At Work LMI provider.

            A linearized message consists of three parts. The first part is
            a header defined by the <t LINHEADER> structure. This is a simple
            C structure which can be read & manipulated at offset 0 of the file.

            The second part contains extended header information. This includes
            items like the message subject, recipient address information,
            sender address information, poll names and so on. Because the size
            of this portion can vary (depending on the number of recipients &
            size of the strings), it is encoded using ASN1.  The format for this
            part is explained in <t Extended Linearized Header>.  To make it
            easier to understand and construct this part, helper functions are
            provided to manipulate items in this part.

            The third part contains the message data. For binary files this
            would contain all the attached files along with their descriptions.
            For rendered messages, this contains the rendered images for all
            the pages. This part may be encrypted if the user chose to send
            his message secured. LMI providers do not need to interpret or create
            this portion of the message.

    @xref   <t LINHEADER>, <t Extended Linearized Header>

***************************************************************************/

#define LINHEADER_OFFSET    0

// Errors
#define ERR_NOMEMORY           0x0001
#define ERR_SEC_NOMATCH        0x8000
#define ERR_FILE_ERROR         0x0040
#define ERR_MAPI_ERROR         0x0008
#define ERR_GENERAL_FAILURE    0x0080

#define NO_ENCRYPT          0
#define KEY_ENCRYPT         1
#define PASSWORD_ENCRYPT    2


/********
    @doc    EXTERNAL    LINEARIZER  SRVRDLL

    @type   NONE | Extended Linearized Header |

    @comm   This describes the format of the extended header part
            of any Microsoft At Work linearized message.  This header
            is encoded using the CCITT standard ASN.1 encoding.  This
            means that all fields are tagged with a type and a length
            followed by the value.

    @comm   These are a number of fields which can be part of the header.
            Unless mentioned explicitly, all fields are optional.

    @flag   HDRTAG_SUBJECT | An ASCII string containing the subject of the
            message. Used by the cover page renderer.
    @flag   HDRTAG_POLLNAME | An ASCII string containing the name of the
            object being polled for if the message type is LINMSG_POLLREQ_ADDRESS,
            LINMSG_POLLREQ_FILE or LINMSG_POLLREQ_MSGNAME.
    @flag   HDRTAG_PASSWORD | A password string to be associated with the
            message. This would typically be valid for poll requests or relay
            request messages.
    @flag   HDRTAG_FROM | A <t Linearized Header Recipient> structure giving
            details about the originator of the message.
    @flag   HDRTAG_TO | An array of <t Linearized Header Recipient> structures giving
            details for all recipients on the TO list of the message.
    @flag   HDRTAG_CC | An array of <t Linearized Header Recipient> structures giving
            details for all recipients on the CC list of the message.
    @flag   HDRTAG_BCC | An array of <t Linearized Header Recipient> structures giving
            details for all recipients on the BCC list of the message.
    @flag   HDRTAG_RAWATTACH | If the LIN_RAWDATA_ONLY flag is set in the <e LINHEADER.uFlags>
            field of the header, then this field contains a <t Linearized Header Raw Data>
            structure describing this data.

    @comm   In general, Microsoft At Work enabled servers do not have to deal
            with this portion of the header.  The Microsoft At Work client will
            create and decipher this.  Some LMI providers might need to interpret
            it to add more value, like  responding to poll requests without
            involving the client or automatically printing out received image faxes.

            To make it easier for these people to use, a library of routines to build and
            decipher these will be provided.  Please see <t Linearized Header Helper Functions>.

    @xref   <t LINHEADER>, <t Microsoft At Work Linearized File Format>,
            <t Linearized Header Recipient>, <t Linearized Header Raw Data>, <t Linearized Header Helper Functions>
********/


/********
    @doc    EXTERNAL    LINEARIZER  SRVRDLL

    @type   NONE | Linearized Header Recipient |

    @comm   This describes the format for each recipient information structure in
            the extended linearized header.  The structure is itself ASN.1 encoded,
            and just like the header, is composed of several fields.  Unless
            otherwise indicated fields are optional.  A lot of the fields are used
            for digital cover pages.

    @flag   RECIPTAG_VOICEPHONE   | String containing the voice phone number for the
            recipient if any.
    @flag   RECIPTAG_LOCATION1  | String containing the first line of the recipients
            physical routing address (for exampe, Company Name).
    @flag   RECIPTAG_LOCATION2 | String containing the second line of the recipients
            physical routing address (for example, Microsoft Way).
    @flag   RECIPTAG_LOCATION3 | String containing the third line of the recipients
            physical routing address (for example, Redmond WA 98052).
    @flag   RECIPTAG_FRIENDLYNAME | String containing the friendly name for the
            recipient (as you want displayed on the cover page).
    @flag   RECIPTAG_ADDRESS | String containing the Microsoft At Work address for
            the recipient (eg. BillG@+1-206-8828080)
    @flag   RECIPTAG_ALTADDRESS | Alternate Microsoft At Work address for the recipient.
    @flag   RECIPTAG_PASSWORD   | If the recipient is of type RECIP_RELAYPOINT this
            contains a password to validate use of this station as a relay point.
    @flag   RECIPTAG_PARAMS | If the recipient is of type RECIP_RELAYPOINT this
            contains any parameters for this point (for example, send at cheap times).
    @flag   RECIPTAG_NEXTHOPINDEX | Used if the recipient is of type RECIP_RELAY.
            It indicates the index of the next hop for this relay message. This
            field essentially creates a linked list of recipient relay points
            for routing of the message.

    @xref   <t Extended Linearized Header>
********/

/********
    @doc    EXTERNAL LINEARIZER SRVRDLL

    @type   NONE | Linearized Header Raw Data |
    @comm   The structure for a describing a
            raw attached format.  The structure is ASN.1 encoded, and just like
            the header, is composed of several fields.  Unless otherwise indicated
            fields are optional.

    @flag   ATTTAG_TYPE |  A dword describing the type of data being attached. See
            <t STD_DATA_TYPES> for the list of possible types.

    @comm   The data type implies the format for the raw data. Any parameters
            required for the raw data should be encoded as part of the data.

    @xref   <t Extended Linearized Header>
    @end
********/

/********
    @doc    EXTERNAL LINEARIZER SRVRDLL

    @api    DWORD | LinOpenSession | Opens a session with the linearizer. 
            A new session has to be opened for every new encoding/decoding 
            operation.

    @parm   DWORD | dwDataContext | Context. This is a file handle cast to
            a DWORD.

    @parm   LPDATACB | lpfnData | A callback function which is used by the 
            linearizer to read the input data stream if delinearizing, or 
            write the output data stream if linearizing. Parameters are
            exactly the same as _lread/_lwrite. The dwDataContext parameter
            is passed back as the second parameter to this function.

    @parm   LPSTREAMDATACB | lpfnStreamData | A callback function used 
            to write to attachment pipe handles while delinearizing,
            or to read from attach pipes while linearizing.

    @parm   LPTSTR | lpszOurAddress | Far ptr to string containing the 
            address of this machine. Must be of the form 
            \<name\>@\<phone number\>, where \<phone number\> is the 
            canonical phone number, ie of the form 
            +\<country code\>[\<area code\>]\<local number\>

    @parm   LPTSTR | lpszOurDisplayName | Far ptr to string containing
            the friendly name of this machine.

    @rdesc  DWORD | Session handle on success, FALSE on failure.

    @comm   Any session opened with LinOpenSession *must* be closed by
            a corresponding call to LinCloseSession.
    @end
********/
#if defined(FILELINZ)
DWORD FAR PASCAL LinOpenSession(DWORD dwDataContext,
  LPDATACB lpfnData, LPSTREAMDATACB lpfnStreamData,
  LPTSTR lpszOurAddress, LPTSTR lpszOurDisplayName);

BOOL WINAPI LinSetSecurityParams
(
   DWORD dwLinInst,  // handle from LinOpenSession
   WORD wEncrypt,    // 0=none, 1=key, 2=password
   BOOL fSign,       // reserved for future use
   LPSTR lpszPass,   // password or address for public key
   DWORD dwSecInst,  // 1 for password encrypt/decrypt
   LPSTR lpszUser    // user's address for private key
);

#elif defined (MAPI1)
#ifndef NO_MAPI
DWORD FAR PASCAL LinOpenSession(DWORD dwDataContext, LPMAPISUP lpMAPISup,
  LPDATACB lpfnData, LPSTREAMDATACB lpfnStreamData,
  LPTSTR lpszOurAddress, LPTSTR lpszOurDisplayName);
#endif

BOOL WINAPI LinSetSecurityParams
(
  DWORD dwLinInst,  // handle from LinOpenSession
  WORD wEncrypt,    // 0=none, 1=key, 2=password
  BOOL fSign,       // reserved for future use
  LPSTR lpszPass,   // password or address for public key
  DWORD dwSecInst,  // 1 for password encrypt/decrypt
  LPSTR lpszUser    // user's address for private key
);

#endif

// API to get back a mapping from a byte offset into the linearized
// stream to an attach num/page number. This works for both encoding
// and decoding. Only the last ten page/attachment boundaries are
// stored.  Valid only if the byte offset is smaller than the number of
// bytes of the stream that the linearizer has already processed.
// Return Value:
// HIBYTE(HIWORD): Attachment number. 0 means we havent yet started
//                  processing any attachments.
// LOBYTE(HIWORD): Page number. For binary attachments this is always
//                  going to be 1. For images, if this is 0 we havent yet
//                  processed any pages.
// LOWORD:      Byte offset within the current attachment/page in 256 byte
//              chunks. Multiply by 256 to get the actual byte offset.
DWORD WINAPI GetPosition(DWORD dwLinInst, DWORD dwPos);

/********
    @doc    EXTERNAL LINEARIZER SRVRDLL

    @api    BOOL | LinCloseSession | Closes a previously opened linearizer 
            session.

    @parm   DWORD | dwLinInst | a valid linearizer session handle previously 
            returned by LinOpenSession.

    @rdesc  BOOL | TRUE for success.

    @comm   Any session opened with LinOpenSession *must* be closed by
            a corresponding call to LinCloseSession.
    @end
********/

BOOL FAR PASCAL _loadds LinCloseSession(DWORD dwLinInst);


/***************************************************************************

   Name      : LinEncodeMessage

   Purpose   : Linearizes a message

   Parameters: dwLinInst: Linearizer instance returned from LinOpenSession

                hamc/lpMessage: Handle to an open message in the store. For
                  linearizing this is the message to be sent.

   Returns   : 0 for success. Only error conditions are out of memory or
                invalid parameter structures.

   Comment   :

***************************************************************************/
/********
    @doc    EXTERNAL LINEARIZER SRVRDLL

    @api    DWORD | LinEncodeHeader | Creates a linearized header.

    @parm   DWORD | dwLinInst | A valid linearizer session handle previously 
            returned by LinOpenSession.
    @parm   HFILE | hFile | A handle to an open file that the linearized
            header is to be written to.

    @rdesc  DWORD | 0 for success. Only error conditions are out of memory or
            invalid parameter structures.

    @end
********/

#if defined (FILELINZ)
DWORD FAR PASCAL _loadds LinEncodeHeader(DWORD dwLinInst, HFILE hFile);
#elif defined (MAPI1)
#if !defined (NO_MAPI)
DWORD FAR PASCAL _loadds LinEncodeHeader(DWORD dwLinInst, LPMESSAGE lpMessage);
DWORD FAR PASCAL _loadds LinEncodeMessage(DWORD dwLinInst, LPMESSAGE lpMessage);
DWORD FAR PASCAL _loadds LinEncodeData(DWORD dwLinInst, LPMESSAGE lpMessage);
#endif
#endif

/***************************************************************************

   Name      : LinDecodeMessage

   Purpose   : Decodes a linearized message

   Parameters: dwLinInst: Handle returned by a previous LinOpenSession

                lpMessage: Handle to a newly created Mapi message which
                    needs to be filled in.

   Returns   : 0 for success.

   Comment   :

***************************************************************************/
/********
    @doc    EXTERNAL LINEARIZER SRVRDLL

    @api    DWORD | LinDecodeHeader | Decodes a linearized header.

    @parm   DWORD | dwLinInst | A valid linearizer sesison handle previously 
            returned by LinOpenSession.

    @parm   HFILE | hFile | A handle to an open CLF file that the linearized
            header is decoded and writtin to.

    @rdesc  DWORD | 0 for success. Only error conditions are out of memory or
            invalid parameter structures.

    @end
********/

// Decode Header must be called before calling decode message.

#if defined (FILELINZ)
DWORD FAR PASCAL _loadds LinDecodeHeader(DWORD dwLinInst, HFILE hFile);
#elif defined (MAPI1)
#if !defined (NO_MAPI)
DWORD FAR PASCAL _loadds LinDecodeHeader(DWORD dwlinst, LPMESSAGE lpMessage,
                                         LPDWORD lpdwRet, LPFILETIME lpft);
DWORD FAR PASCAL _loadds LinDecodeMessage(DWORD dwLinInst, LPMESSAGE lpMessage);
DWORD FAR PASCAL _loadds LinDecodeData(DWORD dwLinInst, LPMESSAGE lpMessage);
#endif
#endif


/********
    @doc    EXTERNAL LINEARIZER SRVRDLL

    @api    DWORD | LinReplaceHeader | Replace a linearized header.

    @parm   DWORD | dwLinInst | A valid linearizer sesison handle previously 
            returned by LinOpenSession.

    @parm   HFILE | hFile | A handle to an open CLF file that contains the 
            information for the new linearized header.

    @parm   DWORD | dwOldStream | A valid linearizer sesison handle previously 
            returned by LinOpenSession.

    @parm   LPDATACB | lpfnOldRead | A callback function which is used by the 
            linearizer to read the input data stream if delinearizing, or 
            write the output data stream if linearizing. Parameters are
            exactly the same as _lread/_lwrite. The dwDataContext parameter
            is passed back as the second parameter to this function.

    @parm   DWORD | dwNewStream | A valid linearizer sesison handle previously 
            returned by LinOpenSession.

    @parm   LPDATACB | lpfnNewWrite | A callback function which is used by the 
            linearizer to read the input data stream if delinearizing, or 
            write the output data stream if linearizing. Parameters are
            exactly the same as _lread/_lwrite. The dwDataContext parameter
            is passed back as the second parameter to this function.

    @rdesc  DWORD | 0 for success. Only error conditions are out of memory or
            invalid parameter structures.

    @comm   This api takes an existing linearized file, strips the old 
            linearized header, and replaces it with the new linearized
            header as specified by the CLF file.

    @end
********/
#if defined (FILELINZ)
DWORD FAR PASCAL _loadds LinReplaceHeader(HFILE hfHeaderCLF,
        DWORD dwOldStream, LPDATACB lpfnOldRead,      // Old stream
        DWORD dwNewStream, LPDATACB lpfnNewWrite);    // New stream
#endif



#ifdef __cplusplus
} // extern "C" {
#endif

#endif  // LIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\lhprot.h ===
#ifndef _LHPROT_H
#define _LHPROT_H
#pragma message("Including: " __FILE__)

#ifdef __cplusplus
extern "C" {
#endif

#include <buffers.h>


// Function prototypes encode/decode of linearized headers: These API's are exported by LHUtil

//------------------------ Prototype Definitions -------------------------
/***************************************************************************

   @doc    EXTERNAL LINEARIZER SRVRDLL

    @topic  Linearized Header Helper Functions |

            These functions are used by the LMI Provider to get or modify fields
            in the header portion of the Linearized Data File:
            <t DiscardLinHeader>, <t CreateSimpleHeader>, <t DecodeLinHeader>

            They typically use callback functions to read and write the actual
            data from the file:
            <t Linearizer Data CallBack>,
            <t Linearizer Seek CallBack>

    @xref   <t LINHEADER>, <t Extended Linearized Header>
    @end

***************************************************************************/

/********
    @doc    EXTERNAL LINEARIZER SRVRDLL

    @type   NONE | GETPUTMODE | Mode of operation for the Linearizer 
            Seek Callback and Linearizer Data Callback functions.

    @emem   GPM_GETBUF |          
    @emem   GPM_PUTBUF |         
    @emem   GPM_PUTDATA | 
    @emem   GPM_GETDATA |
    @emem   GPM_OPENPIPEREAD |
    @emem   GPM_OPENPIPEWRITE |
    @emem   GPM_CLOSEPIPEREAD |
    @emem   GPM_CLOSEPIPEWRITE |
    @emem   GPM_GETEOF |         

    @comm   LHUtil should only use GPM_GETDATA and GPM_PUTDATA enumerations.

    @end
********/
// gpm = mode of callback
//   GPM_PUTDATA
//   GPM_GETDATA
//   GPM_OPENPIPEREAD
//   GPM_OPENPIPEWRITE
//   GPM_CLOSEPIPEREAD
//   GPM_CLOSEPIPEWRITE
// dwDataContext = File Handle cast to DWORD for GETDATA and PUTDATA
//                 Property Tag for OPENPIPE
//                 Stream Pointer for CLOSEPIPE
// lpb = buffer pointer for GETDATA and PUTDATA
// uLen = Length of Read/Write for GETDATA and PUTDATA
//       Object Type for OPENPIPE
//            OT_ATTACH
//            OT_MESSAGE
//            etc.
// lpObject = MAPI Object to open stream on OPENPIPE
//
// Returns value: GETDATA, PUTDATA: Bytes/read/written. 0 for failure.
//                OPENPIPE: lpIStream to read/write from, 0 on failure.
//                CLOSEPIPE: 0 on failure, non-zero on success

// Callback to get & put data from PSI or open/close pipe handles
// Mode can be one of
typedef enum
{
   GPM_GETBUF,         
   GPM_PUTBUF,         
   GPM_PUTDATA,
   GPM_GETDATA,
   GPM_OPENPIPEREAD,
   GPM_OPENPIPEWRITE,
   GPM_CLOSEPIPEREAD,
   GPM_CLOSEPIPEWRITE,
   GPM_GETEOF,         
}
GETPUTMODE;

// Call back to open a stream on a mapi object needs to know what kind of object
// it is.
typedef enum
{
    OT_ATTACH,          // Object is an lpAttach
    OT_MESSAGE          // Object is an lpMessage
}
OBJECT_TYPE;



// Same params as _llseek
/********
    @doc    EXTERNAL LINEARIZER SRVRDLL

    @cb     LONG | Linearizer Seek CallBack | Callback function for seeking in the
            data stream.

    @parm   HFILE | hFile | file handle
    @parm   LONG | lOffset | offset to seek
    @parm   INT | nOrigin | 0 moves the file pointer lOffset bytes from the beginning of the file.
            1 moves the file pointer lOffset bytes from the current position.
            2 moves the file pointer lOffset bytes from the end of the file.

    @rdesc  Returns HFILE_ERROR (-1) on error, othersize, returns the new file pointer position.

    @comm   This function should be implemented by the caller of <t Linearized Header Helper Functions>.

    @xref   <t Linearized Header Helper Functions>, <t Extended Linearized Header>
    @end
********/
#ifndef DOS16
typedef LONG (WINAPI *LPSEEKCB) (HFILE hf, LONG offset, INT nOrigin);
#else
typedef LONG (*LPSEEKCB) (HFILE hf, LONG offset, INT nOrigin);  //DOS - is cdecl function
#endif


/********
    @doc    EXTERNAL LINEARIZER SRVRDLL

    @cb     LONG | Linearizer Data CallBack | Callback function for reading/writing in the
            data stream.

    @parm   GETPUTMODE | gpm | Desired action from callback.
    @parm   DWORD | dwDataContext | handle of file/stream.
    @parm   LPBYTE | lpb | buffer for read/write data
    @parm   UINT | uLen | size of buffer
    @parm   LPBUFFER | lpbfDontUse | reserved buffer parameter.

    @rdesc  Returns DWORD specific to the action.

    @comm   This function should be implemented by the caller of <t Linearized Header Helper Functions>.

    @xref   <t DiscardLinHeader>, <t DecodeLinHeader>, <t CreateSimpleHeader>, <t Linearized Header Helper Functions>,
    @end
********/
typedef DWORD (WINAPI * LPDATACB)
       (GETPUTMODE gpm, DWORD dwDataContext, LPBYTE lpb, UINT uLen, LPVOID lpReserved);

// Callback to read/write data from a pipe
// dwHandle: LOWORD is the pipe handle
// lpBuf is an LPBUFFER if we are writing, NULL if we are reading
// Return value on read is LPBUFFER for success. 0 for failure.
//                 on write is 0 for failure, non-zero for success
// END_OF_JOB buffer terminates data stream.

typedef LPBUFFER (WINAPI * LPSTREAMDATACB)(DWORD dwHandle, DWORD cbData, LPBUFFER lpbf);

/*******
   @doc    EXTERNAL    LINEARIZER SRVRDLL

   @types  LINHEADER   | Linearizer Header structure

   @field  WORD    | uHeaderSize   | Size of this header in bytes.

   @field  WORD    | uTotalSize    | Total size occupied by this header.

   @field  WORD    | uMsgType  | Can be any of the following.
   @flag   LINMSG_SEND | Normal send message. Message must contain
           sender information & at least one recipient.
   @flag   LINMSG_POLLREQ_ADDRESS | Polls for a document for a particular
           address. Extended header must contain sender information, the
           address for which messages are desired (as the pollname), and
           the password decided upon.
   @flag   LINMSG_POLLREQ_FILE | Polls for a directory or file on the
           recipient system.  The extended header must contain sender
           information, the file system path to be accessed (as the
           pollname), and the password decided upon.
   @flag   LINMSG_POLLREQ_MSGNAME | Polls for a particular message name.
           The extended header must contain sender information, the
           message name wanted (as the pollname), and the password decided
           upon.
   @flag   LINMSG_POLLREQ_G3 | Standard G3 compliant poll request. Polls for
           any file which has been stored at the recipient machine.  Neither
           pollname nor password are required.
   @flag   LINMSG_RELAYREQ | This is a request to send a relay message. If
           password validation is required the extended header may contain
           a password.
   @field  WORD | uFlags | Can be a combination of any of the following:
   @flag   LIN_ENCRYPTED   | Indicates that the message data is encrypted. If no
           other specific encryption bits are set, baseline password encryption is
           assumed.
   @flag   LIN_PUBKEY_ENCRYPTED | Indicates that public key encryption was used.
   @flag   LIN_IMAGE_ONLY | Indicates that the message data contains rendered images
           only. Correct setting of this flag is not mandatory.
   @flag   LIN_RAWDATA_ONLY | Indicates that the message data portion consists of
           raw unframed data.  If this flag is set, the extended header must contain
           the description for this data. This Flag is *never* set for data on the
           wire.  It is only meant to allow more efficient exchange of data between
           the client and the LMI provider.  For example, the client might generate
           an MH encoded file and put it into a linearized format using this flag. The
           LMI provider would then interpret the header and send the raw data along
           the wire.  Not currently used.
   @flag   LIN_NULL_BODY | Introduced in version 2.  Indicates that there is no
           body, or that the body contains no useful information (for example, it
           may be all white space with no important formatting information).
           In other words, the recipient is free to discard the body. If this
           flag is not set, the message data MUST contain a valid body.
   @flag   LIN_MASK_COMPRESS | Introduced in version 2.  Mask that extracts
           compression level.  Currently must be set to 0 or 1.
   @field  WORD | uNumRecipients | Tells the number of recipients this message
           is intended for. Also indicates the size of the <e LINHEADER.rguRecipTypes[]>
           array.
   @field  WORD | rguRecipTypes[]  |  An array of size <e LINHEADER.uNumRecipients>
           each element of which indicates  what kind of operations the recieving system
           needs to perform for this recipient. The sending machine needs to update these
           types before sending an instance of this message to any recipient (see the
           example below). All other detailed information about the recipients are
           in the extended header. The different types are:
   @flag   RECIP_DISPLAY  |
           This instance of the message is not intended for this recipient. Information
           is provided for display purposes only.
   @flag   RECIP_LOCAL  |
           The recipient is local to the receiving machine.
   @flag   RECIP_RELAY  |
           The recipient has to be reached via a series of relay points.  The
           uHopIndex field in the extended header points to the current hop if
           the receiver is a relay point.  The uHopIndex field forms a linked
           list of all the remaining hops.
   @flag   RECIP_RELAYPOINT |
           This is a relay point for one of the relay recipients.  The message
           password and params specify the relay password and options if any.
           NextHopIndex specifies the next relay point if any in this route.

   @comm   This header needs to be created by the caller and passed in to the linearizer. It
           then needs to be specialized (that is, the recipient types need to be correctly set)
           before starting the actual transmission.

   @ex     Specializing a Linearized Header |

           Suppose a message has two recipients A & B, each at different machines (phone numbers).

           When sending to the recipient A, the recipient types should be marked as :
           Recipient A: RECIP_LOCAL
           Recipient B: RECIP_DISPLAY

           When sending to the recipient B, the recipient types should be marked as :
           Recipient A: RECIP_DISPLAY
           Recipient B: RECIP_LOCAL

   @xref   <t Extended Linearized Header>, <t Microsoft At Work Linearized File Format>

*******/
#pragma warning (disable: 4200)
// Linearized file header
typedef struct _LINHEADER {
    WORD    uHeaderSize;
    WORD    uTotalSize;
    WORD    uMsgType;
    WORD    uFlags;
    WORD    uNumRecipients;
    WORD    rguRecipTypes[];
} LINHEADER, FAR * LPLINHEADER, NEAR * NPLINHEADER;
#pragma warning (default:4200)

// Possible message types (uMsgType)
#define LINMSG_SEND             1
#define LINMSG_POLLREQ_ADDRESS  2
#define LINMSG_POLLREQ_FILE     3
#define LINMSG_POLLREQ_MSGNAME  4
#define LINMSG_POLLREQ_G3       5
#define LINMSG_RELAYREQ         6

// Message type flags (uFlags). All undefined bits are reserved
#define LIN_ENCRYPTED           0x0001
#define LIN_PUBKEY_ENCRYPTED    0x0002
#define LIN_IMAGE_ONLY          0x0004
#define LIN_RAWDATA_ONLY        0x0008
// New flags in version 2
#define LIN_NULL_BODY           0x0010
#define LIN_MASK_COMPRESS       0x00E0
#define LIN_SHIFT_COMPRESS      5

// Possible Recipient Types (rguRecipTypes)
#define RECIP_DISPLAY           1
#define RECIP_LOCAL             2
#define RECIP_RELAY             3
#define RECIP_RELAYPOINT        4


/********
    @doc    EXTERNAL LINEARIZER SRVRDLL

    @api    BOOL | DiscardLinHeader | Seeks past the linearized header.

    @parm   HFILE | hFile | File handle of linearized data.
    @parm   LPDATACB | lpfnReadCB | <t Linearizer Data CallBack>
    @parm   LPSEEKCB | lpfnSeekCB | <t Linearizer Seek CallBack>
    @parm   BOOL | fVerify | TRUE to verify integrity of linheader
    @parm   LPUINT | lpvCompress | Return compression version here.  Ignored if NULL.
    @rdesc  TRUE on success.

    @comm   This function seeks past the linearized headers of a linearized file.

    @xref   <t Linearized Header Helper Functions>
    @end
********/
BOOL WINAPI DiscardLinHeader(HFILE hf, LPDATACB lpfnReadCB,
  LPSEEKCB lpfnSeekCB, BOOL fVerify, LPUINT lpvCompress);


/********
    @doc    EXTERNAL LINEARIZER SRVRDLL

    @api    BOOL | CreateSimpleHeader | Creates a simple linearized header.

    @parm   HFILE | hFile | File handle to write to.
    @parm   LPSTR | lpszFromAdd | Email address of sender
    @parm   LPSTR | lpszFromName | Display name of sender
    @parm   LPSTR | lpszToAddress | Address of recipient
    @parm   LPSTR | lpszToName | Display name of recipient
    @parm   LPSTR | lpszSubject | Message subject
    @parm   LPDATACB | lpfnReadCB | <t Linearizer Data CallBack>
    @parm   BOOL | fHash | Must be set to TRUE

    @rdesc  TRUE on success.

    @comm   This function creates a simple linearized header including one
            recipient.  This is typically used to create a linearized header
            for received G3 faxes.
    @xref   <t Linearized Header Helper Functions>
    @end
********/
BOOL WINAPI CreateSimpleHeader(HFILE hf, LPSTR lpszFromAdd, LPSTR lpszFromName,
  LPSTR lpszToAddress, LPSTR lpszToName, LPSTR lpszSubject, LPDATACB lpfnWriteCB,
  BOOL fHash);

/********
    @doc    EXTERNAL LINEARIZER SRVRDLL

    @api    BOOL | DecodeLinHeader | Decodes a linearized header.

    @parm   HFILE | hFile | File handle of linearized data.
    @parm   LPDATACB | lpfnReadCB | <t Linearizer Data CallBack>
    @parm   LPSEEKCB | lpfnSeekCB | <t Linearizer Seek CallBack>
    @parm   LPLINHEADER | lplh | Linearized header
    @parm   DWORD | dwAddBufLen | size of lpszFromAddress buffer
    @parm   LPSTR | lpszFromAddress | return sender's address here
    @parm   DWORD | dwNameBufLen | size of lpszFromName buffer
    @parm   LPSTR | lpszFromName | return sender's display name here
    @parm   DWORD | dwSubBufLen | size of lpszSubject
    @parm   LPSTR | lpszSubject | return message subject here
    @parm   BOOL | fVerify | TRUE to verify integrity of linheader

    @rdesc  TRUE on success.

    @comm   This function decodes the linearized header into it's subject,
            sender name and sender email address.

    @xref   <t Linearized Header Helper Functions>
    @end
********/
BOOL WINAPI DecodeLinHeader(HFILE hf, LPDATACB lpfnReadCB, LPSEEKCB lpfnSeekCB,
  LPLINHEADER lplh, DWORD dwAddBufLen, LPSTR lpszFromAddress,
  DWORD dwNameBufLen, LPSTR lpszFromName, DWORD dwSubBufLen,
  LPSTR lpszSubject, BOOL fVerify);

/********
    @doc    EXTERNAL LINEARIZER SRVRDLL

    @api    BOOL | LHSetCompress | This function sets the compression level 
            of an existing linearized file.

    @parm   HFILE | hFile | File handle of linearized data.
    @parm   LPDATACB | lpfnReadCB | <t Linearizer Data CallBack> or NULL to use _lread.
    @parm   LPDATACB | lpfnWriteCB | <t Linearizer Data CallBack> or NULL to use _lwrite.
    @parm   LPSEEKCB | lpfnSeekCB | <t Linearizer Seek CallBack> or NULL to use _llseek.
    @parm   UINT | vCompress | Compression level (Currently 0 and 1 are supported.)

    @rdesc  TRUE on success.

    @comm   This function doesn't effect actual data compression, only the header value.

    @xref   <t Linearized Header Helper Functions>
    @end
********/
// Sets compression level of linearized file.
BOOL WINAPI LHSetCompress
(
	HFILE hf,                // read/write handle
	LPDATACB lpfnReadCB,     // NULL for _lread
	LPDATACB lpfnWriteCB,    // NULL for _lwrite
	LPSEEKCB lpfnSeekCB,     // NULL for _llseek
	UINT vCompress           // compression level
);


// This takes ptrs to space to hold the decoded strings. Pass in NULL if
// you are not interested. Passing in all NULL's makes this function
// equivalent to DiscardLinHeader(slightly more inefficient though).
// The maximum buffer size required for any of the strings in 512 bytes.
// For 99.99% of the cases, the recommended max sizes below shouldbe
// good enough
#define MAX_SUBJECT_LENGTH 255
#ifndef MAX_ADDRESS_LENGTH
#define MAX_ADDRESS_LENGTH 128
#endif


#ifdef __cplusplus
} // extern "C" {
#endif

#endif  // _LHPROT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\lpc.h ===
//
//      LPC.H           Local Remote Procedure Call
//
//      History:
//              2/27/94 JosephJ Created.
//

//#define NEW_LPC

#ifdef NEW_LPC
enum {
        eSRVR_UNREG=0,
        eSRVR_IDLE,
        eSRVR_BUSY
} SERVER_STATE;

enum {
        eCALL_NONE=0,
        eCALL_REQUESTED,
        eCALL_PROCESSING,
        eCALL_ABANDONED,
        eCALL_DONE,
        eCALL_DONE_ACK
} CALL_STATE;

#define dwSIG_SHARED 0x567D56DBL
#define dwSIG_SERVER 0x50704B2BL
#define dwSIG_CLIENT 0xBF9B1A63L

typedef struct {
        DWORD dwSig;                    // Must be dwSIG_SHARED above
        DWORD dwClientIDs;              // Bitmap of currently bound client IDs;
        DWORD dwSrvrID;                 // ID of current server.
        DWORD dwSrvrState;              // SERVER_STATE enum
        DWORD dwCallState;              // CALL_STATE enum
        DWORD dwCallClientID;           // ID of client that placed current call.
        DWORD dwDataSize;               // Size of following data
        BYTE  rgbData[];
} SHARED_DATA, FAR * LPSHARED_DATA;
#endif // NEW_LPC

typedef struct {

    // Service name
    char rgchService[MAX_PATHNAME_SIZE+1];

    // Shared Memory
    HANDLE      hMap;           // hMap of shared data.
    HANDLE      hMtx;           // Controls access to the shared data.
                                                // Created by anyone (thread that
                                                // created it is responsible for initializing the
                                                // shared memory it guards).
                                                // Only the server can grab it for extended periods
                                                // of time -- precisely when it is processing a call.
    BOOL        fGrabbed;       // True if mutex grabbed by this process.

        // Events;
    HANDLE hevSrvrFree;// Used to signal to clients that the server is idle.
                                                // AUTO reset, created non-signalled by anyone.
        HANDLE hevCallAvail;// Used to signal to the server that a call is avilable
                                                // Manual reset. Created non-signalled by anyone.
        HANDLE hevCallDone;     // If Server: event of client that placed current
                                                //              call. Used to  signal to the client that it's
                                                //              call is done. It is also used determine if the
                                                //              client is still around by trying to open this
                                                //              named event.
                                                // If Client: it's event, signalled by server. Created
                                                //              when calling ClientBind.
                                                // Manual reset. ONE per client. Created nonsignalled
                                                // by client when doing a ClientBind.
    HANDLE      hevCallDoneAck; // Used to signal to the server that the call-done
                                                // has been picked up by the client.
                                                // Manual reset. Created non-signalled by anyone.

#ifdef NEW_LPC
        LPSHARED_DATA lpSharedData; // Pointer to shared data.

        DWORD dwSrvrID;         // Server: My ID; Client: Server I last dealt with.
        DWORD dwClientID;       // Server: Client I last dealt with. Server: My ID.


#else // !NEW_LPC

    DWORD       dwSharedDataSize;
    LPVOID      lpvSharedData;

    // Events
    HANDLE      hevSrvcReg;

    enum {eSS_UNDEF=0, eSS_REG, eSS_UNREG} eState;
#endif // !NEW_LPC

} SHARED_STATE, FAR * LPSHARED_STATE;

typedef struct {

#ifdef NEW_LPC
        DWORD dwSig;    // MUST be dwSIG_SERVER above.
#else // !NEW_LPC
    DWORD  dwInstanceID;
    enum {eS_UNINIT=0, eS_INIT} eState;
#endif // !NEW_LPC

    HANDLE hDummyEvent;

    SHARED_STATE SState;

} SERVER_LOCAL_STATE, FAR * LPSERVER_LOCAL_STATE;

typedef struct {

#ifdef NEW_LPC
        DWORD dwSig;    // MUST be dwSIG_CLIENT above.
#else   NEW_LPC
    DWORD  dwInstanceID;
    DWORD  dwServerInstanceID;
#endif //!NEW_LPC

    SHARED_STATE SState;

} CLIENT_LOCAL_STATE, FAR * LPCLIENT_LOCAL_STATE;

typedef void (FAR *LPFNCALLHANDLER)(DWORD dwID,
                 DWORD dwDataSize, LPBYTE lpbData);
        // Server call handling function.

BOOL  ServerRegister(LPSTR lpszService, LPSERVER_LOCAL_STATE);
        // Registers a server. Only one server can be registered for
        // a particular service name.
        // Initializes server_local_state. Returns TRUE on success.

BOOL  ServerUnRegister(LPSERVER_LOCAL_STATE);
        // Unregisters the service. Invalidates data in server_local_state.
        // Returns true on success.

#ifdef NEW_LPC
BOOL  ClientCheckIfServerPresent(LPSTR lpszService);
        // Returns true iff a server for this service exists. May be called
        // at any time (even before ClientBind).  It may be used for the client
        // to determine whether to launch the server.
        // This is not foolproof: for example, the server may exit just after
        // this call returns true, or the server may exist, but be hung.
#endif // NEW_LPC

BOOL  ClientBind(LPSTR lpszService, DWORD dwTimeout, LPCLIENT_LOCAL_STATE);
        // Binds to the specified service, initializes client_local_state.
        // Returns TRUE on success.

BOOL  ClientUnBind(LPCLIENT_LOCAL_STATE lpClient);
        // Binds from the specified service.
        // Returns TRUE on success.

BOOL  ClientMakeCall(LPCLIENT_LOCAL_STATE, DWORD dwTimeout,
        DWORD dwID, DWORD dwSize, LPBYTE lpbData);
        // Returns only when complete...
        // Copies all data to shared mem, and copies back when
        // done.  Never times out. Returns FALSE if there was
        // some problem with the rpc system, or if bad parameters.

BOOL  ClientMakeCallEx(LPSTR lpszService, DWORD dwID, DWORD dwSize, LPBYTE lpbData);
        // Immediate binding version of ClientMakeCall.
        // Returns only when complete...
        // Copies all data to shared mem, and copies back when
        // done.  Never times out. Returns FALSE if there was
        // some problem with the rpc system, or if bad parameters.


BOOL  ServerListen(LPSERVER_LOCAL_STATE, LPFNCALLHANDLER, HANDLE hev2, DWORD dwTimeout);
        // Blocks until call received, then
        // calls lpfnCallHandler(id,size,data) once and returns when call is
        // handled. Returns FALSE iff listen timed out. The intension here
        // is for the server to repeatedly call ServerListen. Each time
        // either one call is handled or the function times out.

// Following functions are for calling only by LibEntry, on process
// Creation and termination.... When the LPC functionality is moved
// into a separate DLL, this will migrate into an internal header file.
void LPCInternalInit(void);
void LPCInternalDeInit(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\lmi.h ===
#ifndef _SERVERDLL_INC
#define _SERVERDLL_INC

#ifdef __cplusplus
extern "C" {
#endif

/***************************************************************************

	Name      : lmi.h

	Comment   : Defines the Logical Modem Interface.

	Created   : 9/9/93

	Author    : Sharad Mathur

	Contribs  :

	Changes   : 12/29/93: Changed UINTS to WORDS
				12/29/93: Put min length restriction on String in LMI_AddModem
				12/29/93: Changed display string comments to remove "Fax Modem 
on"
				12/29/93: Changed NetAuthenticateDll API
				8/4/94  : Defined FAXERROR
				8/4/94  : Changed capabilities to bits & added new ones
				8/4/94  : Changed SERVERSTATE to be a bitfield
				8/4/94  : Changed NetReportRecv & LMI_ReportSends to return 
DWORD
					  counts.
		8/4/94  : Changed enum's to #define's
		8/4/94  : Changed LPSTR to LPTSTR, & added fUnicode.
				9/23/94 : Added Poll request support -
                                                  LMIPOLLREQUEST, POLLTYPE, wszPollRequest(LMISENDJOB),
                                                  dwPollContext(LMIRECVSTATUS), POLL_REQUEST capability
				9/23/94 : Added Custom msg options support
                                                  LMI_SetCustomMsgOptions, 
wrgbCustomOptionsOffset(LMISENDJOB),
						  CUSTOM_MSG_OPTIONS capability.
				9/23/94 : Added 4 ext error codes to T30_DIALFAIL.
				9/23/94 : Added lpatError to LMI_CheckProvider.
				9/26/94 : Added NRR_COMMITTED_RECEIVE to 
LMI_ReportReceives
				10/6/94 : Added ABOVE64K_STRUCTURES to caps, and made total
                                                  size & struct offsets in LMISENDJOB DWORDS.
				10/6/94 : Made all structs DWORDS aligned.
				10/6/94 : Added User request fields to LMI_ReportSends
                                10/6/94 : Added user request flags to LMI_GetQueueFile
                                10/6/94 : Changed dwNumEntries in LMIQUEUEFILEHEADER to dword
				10/6/94 : Updated AtWork address definition to include \@ & |
				10/7/94 : Consolidated all unsupported dialchar codes.
				10/17/94: Added NCUDIAL_BADDIALSTRING
				10/17/94: Moved lpatClientName from LMI_InitProvider to 
LMI_InitLogicalModem
				10/17/94: Added LMIERR_PROVIDER_BUSY

		03/16/95 (kentse)  The big reorg.  changed from Srvrdll to
                                   LMI.  (A large change).
                04/05/95 (kentse)  Completed the big rewrite.

***************************************************************************/


#define MAX_SERVERNAME_SIZE     32
#define MAX_SUBJECT_SIZE        128


typedef ATOM FAR*   LPATOM;
typedef UINT FAR*   LPUINT;


////////////////////////  OVERVIEWS ///////////////////////////////////////
/****
    @doc    EXTERNAL    SRVRDLL    OVERVIEW

    @topic  Introduction to the Logical Modem Interface | The Logical Modem
	Interface (LMI) was developed to facilitate the easy creation of a fax
            	service provider for a Microsoft Fax transport running on a PC.  Microsoft 
	Fax is supported in Windows 95 and will be supported in the shell update 
	release of Windows NT 3.51.  There is also support in Windows for 
	Workgroups<tm> 3.11 (where Microsoft Fax was known as Microsoft At 
	Work <tm>).  A fax service provider written to the LMI will work on all 
	these platforms.  For this discussion of the LMI, no distinction is made 
	between operating environments.

	The Logical Modem Interface divides Microsoft Fax support in Windows 
	into two parts: a fax transport that sits above the LMI, and
	one or more LMI providers that sit underneath.  The fax transport is
	a messaging provider integrated with mail (MAPI) that can
	expose faxing capabilities to the user in many ways.  Most fundamentally,
	faxing capability is exposed through the Microsoft Mail or Microsoft 
	Exchange Send Note form, where fax is treated as just another valid
	address type by the user.  But faxing capability is also exposed to the user 
	through a <lq>print to fax<rq> mechanism hooked into the printing system 
	(this user interface is more typical for alternative fax packages).
	In the new Windows shell, fax is also exposed through a <lq>send fax 
	wizard<rq>. Regardless of the method chosen by the user to compose a fax, 
	once <lq>sent<rq> by the user the fax message ends up as a message in the 
	mail store.  In general, any outbound message in the store is extracted by MAPI, 
	and, if addressed to one or more fax recipients, the message is handed over to 
	the fax transport for delivery.

	The fax transport performs several types of processing on a fax message after
	receiving it from MAPI.  The objective of this processing is to create a data 
	stream that contains the actual bits that need to be sent across the wire.  (It is 
	assumed that in most cases, a fax will be sent over a PSTN connection.  This need 
	not always be so, such as in the case of a NetFax server.)  The format of this 
	data might be one of the standard MH, MR, or MMR formats; or it might be the 
	Microsoft Fax linearized file format, which allows multiple, binary attachments.  
	The transport intelligently decides which format or formats to generate (more than 
	one may be generated) based partly on cached (or unknown) capabilities of the 
	recipient, and partly on preferences expressed by the user.  Especially in cases
	where the transport cannot decide the best format, it may generate several, 
	postponing the actual decision of which to send until run time.
	
	Once the appropriate formats have been generated, the main work of the fax 
	transport is done.  From that point, responsibility for sending the fax belongs
	to the active LMI provider.  The user could have several LMI providers 
	installed, such as a local modem and a network fax service provider, but only 
	one can be active at a time.  

	The fax transport has no knowledge of any physical modem or phone line.  It 
	only knows about the existence of a <lq>logical modem<rq>.  The transport can 
	submit jobs to be sent over this modem without worrying about how they will be sent.  
	An LMI provider can accept these jobs and complete them in any way, including 
	by forwarding the data to a different machine (which could be running a custom 
	operating system) where a physical fax modem is installed.

	Once it completes sending the fax, the LMI provider must return the results of 
	the send to the sending fax transport.  Because sending faxes and communicating 
	between 	machines can be time-consuming, the interface is completely asynchronous.  
	None of the calls into the interface require blocking of the fax transport while the 
	LMI provider performs some operation.  The LMI provider benefits from this division 
	of labor because all of the intelligence is kept common in the fax transport,
	including all knowledge about keeping capabilities, rendering
	attachments to the message, getting data from OLE objects, and so on.

	The LMI is designed so that all structures and data passed
	through the interface are already marshaled into blocks of BYTES.
	This simplifies the implementation of the LMI provider in the case where the 
	provider is used with a network front-end processor and where the actual fax
	call is not made in the same process context as the provider
	interface.  The LMI provider must parse the structures, dial
	the numbers, and send the appropriate format across the connection.  To 
	communicate with other Microsoft Fax-enabled machines over a PSTN 
	connection, the LMI provider must be able to talk the Microsoft Extended Fax 
	Protocol (MEFP) on the wire.  MEFP is a set of NSF extensions to the ITU T.30 
	protocol; the details of this protocol are documented elsewhere.  The current
	document assumes that the LMI provider can talk to Microsoft Fax clients and 
	decipher their capabilities in order to make intelligent decisions about which 
	format is to be sent.

	There is a wide range of functionality an LMI provider may choose
	to provide.  At the simplest, an LMI provider can decide to only
	provide send-fax services, with no capability of queuing,
	scheduling, and so on.  A more complex LMI provider can have
	it's own phone books, generate cover pages, print incoming faxes,
	do inbound routing of other faxes, do load balancing with multiple
	hardware phone lines, and much more.  The LMI encourages vendors to
	differentiate their offerings.  The same fax transport can talk to
	an LMI provider with any kind of functionality.  The fax transport
	makes dynamic decisions based on capability flags that are part of
	the LMI.

	Except for a few configuration functions, the interface is guaranteed to be
	called from a single process context. 
	However, the client software can consist of multiple threads,
	each of which may call portions of this interface. 
	It is possible for a second API to be called while 
	still in the middle of a previous call (the calls would be in different 
	thread contexts).  This is important.  It means that the LMI provider must 
	protect itself from reentrancy issues. 

	A logical modem is treated as a single queue to which jobs can be sent.  There is 
	not necessarily a one-to-one correspondence between a logical modem and a 
	physical modem.  An implementation can hide several modems behind a single
	queue and do load balancing among the modems.

            	Important: Unless explicitly stated otherwise, an LMI provider should not
            	present any user interface in any interface calls.  Many of these calls are 
	made in the background and are not expected to put up UI (including 
	message boxes).

    @topic  Overview of the LMI Provider Interface | 	This document describes the 
	services a fax provider must implement to act as a fax provider to a Microsoft 
	Fax client through the LMI.  The interface has several main components.  The 
	parts are installation, configuration, queue administration and status, 
	sending faxes, receiving faxes, and uploading documents and cover pages.  
	Each of these is covered in detail in the following sections.

	It is useful to present a high-level overview of how the fax transport 
	calls into the Logical Modem Interface.  At first, the transport's
	configuration user interface calls <f LMI_AddModem> and
	<f LMI_RemoveModem> to control which modems exist in the list
	of available modems.  It also calls <f LMI_ExchangeCaps>
	to make any necessary configuration decisions.  When the fax transport 
	initializes, it calls <f LMI_InitProvider> and <f LMI_InitLogicalModem>.  
	The transport can then send faxes with <f LMI_SendFax>.   The transport
	polls for the status of sent faxes with <f LMI_ReportSend> and looks at the 
	provider's queue with <f LMI_GetQueueFile>.  To abort or reschedule 
	a fax that has been sent but has not yet left the queue, the transport 
	can call <f LMI_AbortSendJob> and <f LMI_RescheduleSendJob>.   
	The transport polls for received faxes with <f LMI_ReportReceives>. 
	Finally, the transport calls <f LMI_DeinitLogicalModem> and
	<f LMI_DeinitProvider> when it is time to shut down.

            	A useful example to study for understanding the flow across the
	LMI is the simple case of a send on one machine leading to a 
	receive on another.  A send starts off as a note composed in a
	mail client by the user.  In this example, the user types in some 
	text and attaches a bitmap.  The user addresses the note to
	a single fax recipient at the phone number 555-1234 and chooses 
	to send the note in the best format possible at the cheap-rate time.  When
	the note is ready, the user <lq>sends<rq> the note (this really 
	just saves the message to the store).  

	The message is then picked up from the store and is handed to 
	the fax transport, because the message has a fax recipient.  The 
	fax transport looks into its capability database for the number 
	555-1234, but (in this example) finds no entry.  Because the user chose 
	to send the message in the best format possible, the fax transport converts the
	message into two formats: a rendered, MMR version (images only) and a 
	linearized file-format version (binary file).  For the rendered version, the 
	transport itself renders the text; calls Paintbrush to render the bitmap 
	file; and finally generates a file combining the rendered images, to which 
	it attaches a linearized header.  For the linearized version, the transport 
	calls the linearizer, which assembles the binary attachments as-is into
	a file with a linearized header.

	After creating the two separate files, the fax transport calls 
	<f LMI_SendFax> in the LMI provider.  In the call, the transport passes 
	in the details of the job as well as the file name for each of the 
	two formats that were generated.  In response to the call, the LMI provider 
	examines the details of the send job.   Seeing that the fax (in this example)
	is to be sent at cheap rates, it leaves the job on its internal queue.  The fax
	transport periodically polls the LMI provider for the status of the fax.

	When cheap times roll around, the LMI provider connects to 555-1234
	using a local modem and sends the appropriate format (the MMR file if the 
	receiver is a G3 fax machine, or the linearized file if the receiver uses 
	Microsoft Fax).  The next time the fax transport calls <f LMI_ReportSend> 
	after the fax is sent over the wire, the LMI provider returns the final status of 
	the send job.  Upon receipt of this status, the fax transport passes it on to the
	user, typically generating a Non-Delivery Report (NDR) if there was an 
	error, or moving the message into the Sent Mail folder if the send was
            	successful.  

	Received faxes are available immediately to the LMI provider on the remote
	machine, since it is the one picking up the phone.  The LMI provider then 
	has to decide to which client the message needs to be routed.  For reception of
	G3 faxes, intelligent decisions are not possible since there is no structured 
	routing information; routing to some default client is probably best.  For 
	Microsoft Fax messages, the LMI provider can interpret the linearized header
	(using some helper functions) and extract the Microsoft
	Fax address of the recipient.  If this address contains a routing name,
	the name can be matched to a list of clients and the fax can be easily routed.

	Once the LMI provider has decided on the recipient client, it waits for that 
	client's fax transport to regularly poll for new faxes. When polled (by a call 
	to <f LMI_ReportReceives>), the provider creates a file with the received data 
	in an appropriate format.  If the fax was received from a G3 fax machine, the 
	provider	can use helper functions to construct a file starting with a linearized header, 
	followed	by AWG3 page headers, finally followed by the data.  For linearized file-format 
	faxes, the exact data received is passed in.  Finally, the client fax transport parses the 
	data file (of whichever format) and creates a new message in the mail client Inbox 
	containing the data in a format the user can view.
	
    @topic  Installation  | 
	Installing a new LMI provider module is a two step process.  First, the 
	installation program must create an entry in the MSATWORK.INF file 
	as defined below.

	MSATWORK.INF file format:

	[External Devices]<nl>
	\<device name\>=\<description\><nl>
	.<nl>
	.<nl>
	\<device name\>=\<description\>

	[\<device name\>]<nl>
	Display Name=\<name to show devices list box\><nl>
	DLL Name=\<name of the DLL for this device\><nl>
	Flags=\<see below\><nl>

	[\<device name\>]<nl>
	Display Name=\<name to show devices list box\><nl>
	DLL Name=\<name of the DLL for this device\><nl>
	Flags=\<see below\>

	Explanation:

	\<device name\>: Name of the section of the below device.<nl>
	\<description\>: Description of the device, for INF-file purposes
	only, not used anywhere else.<nl>
	Display Name: Name of the device.  This name will be displayed
	in the AddDevice dialog listbox.<nl>
	DLL Name: Name of the DLL that services this device.<nl>
	Flags: Currently will be zero.  Can be used for various device
	capabilities, like whether this device allows setup, etc.

	Example:

	[External Devices]<nl>
	IFAX=An intelligent fax machine<nl>
	AcmeFax=A future fax provider

	[IFAX]<nl>
	Display Name=Intelligent fax machine<nl>
	DLL Name=ifax32.dll<nl>
	Flags=0

	[AcmeFax]<nl>
	DLL Name=acme32.dll

	Next, when the user installs a new fax modem from the 
	configuration interface, the user is presented with a list of all strings 
	from the Display Name section of the MSATWORK.INF file.  When the 
	user chooses Display Name, <f LMI_AddModem> is called to allow the 
	LMI provider to put up a dialog box that asks the user to choose a
	logical modem from that LMI provider.  

            <f LMI_AddModem> returns a string representing the logical modem
	the user has selected.  This string is then displayed in the list of
	currently available modems.  The user can choose the current default 
	fax modem from this list.

    @topic  Configuration |
	The user is allowed to configure any of the available
	fax modems (logical modems). <f LMI_ConfigureModem> is called for
	the appropriate LMI provider.  This function allows the user
	to do whatever remote configuration options are permitted.  These may
	be divided into user-configurable and administrator-configurable
	options.  In general, there should be very few user configurable
	options.  For administrator options, this function should
	probably use some kind of password protection.

    @topic  Initialization |
	When the fax transport starts, the <f LMI_InitProvider> function
	is called for the appropriate LMI provider.  Then, the
	<f LMI_InitLogicalModem> function is called for the modem the
	client wants to use.  This function intializes the logical
	modem and return to the client a handle to the modem, as well as the 
	modems capabilities.  The capabilities include support for advanced
	features and are used by the client to decide what kind of
	operations are supported by the LMI provider.  An example of an
	important capability is whether or not the modem is Microsoft Fax
	enabled.  The phone number of the modem is some other 
	information returned by this call.  Several logical modems may be
	initialized at the same time.  All operations on a modem use the
	handle returned by the <f LMI_InitLogicalModem> call.

    @topic  Queue Management |
	To allow the user to see up-to-date status for all the jobs of an
	LMI provider, functions have been defined to let the client
	monitor and administer the provider's queue.
	<f LMI_GetQueueFile> is called whenever the user wants to see the
	queue.  This function gives access to a specific set of information
	about each job in the provider's queue.  The information is
	displayed in a uniform manner by the fax transport.  To allow
	value-added, extended-status displays, arbitrary binary
	information can also be passed back as part of the status.  If
	the user wants detailed status on a particular job,
	<f LMI_DisplayCustomStatus> is called with this binary
	information to display more detailed status.  If the user wants
	to cancel or reschedule jobs, the functions <f LMI_AbortSendJob>
	and <f LMI_RescheduleSendJob> may be called.

    @topic  Sending Faxes |
	When a fax is to be sent, the transport assumes all responsibility
	for rendering the appropriate formats for transmission.  The transport
	maintains a cache of the capabilities for all fax machines it has
	talked to before and uses the database to attempt intelligent decisions 
	about the most efficient format to be sent.  The transport also takes 
	into account explicit user preferences.
	
	There are three different formats that can be sent.  The first is
	for sending to standard fax machines and consists of MH, MR or
	MMR data.  The second format is a linearized EFAX message containing 
	only image data.  The third format is a linearized EFAX message containing 
	binary data.  All three formats are always preceded by a linearized header
	describing the file.  See <lq>Microsoft At Work Linearized File Format<rq> 
	for details of this header.  Details of the fax file format are in <lq>AWG3 File
	Format<rq>.

	When the fax has been sent, the LMI provider reports the final
	status for the job via <f LMI_ReportSend>.  This function is
	polled periodically by the fax transport.  Along with the final
	status, the Provider must return the newly found capabilities of
	all the recipients of the fax.  The client can also ask for
	attention using the <f LMI_CheckProvider> function.

	Poll requests are also submitted using LMI_SendFax. Fields in the LMISENDJOB
	structure provide the information for the poll request.

    @topic  Receiving Faxes|
	    All received faxes need to be routed by the fax transport to the
	    appropriate LMI provider.  The Microsoft At Work fax transport
            polls for received faxes using the <f LMI_ReportReceives>
	    function.

	    As with sent faxes, received faxes can be in any one of three
	    formats.  The header for the file describes the format and gives
	    information about the recipients of this message.  All formats
	    MUST have a linearized header describing the format and contents
            of the message.  See
            <lq>Microsoft At Work Linearized File Format<rq>
	    for details of this header.  Details of the Fax file format are
            in <lq>AWG3 File Format<rq>.
****/




/********
    @doc    EXTERNAL    SRVRDLL DATATYPES

    @topic  Microsoft At Work Address |

	    This section describes the Microsoft At Work address format. In
	    its most common form, this consists of a name and a phone number.
	    The phone number is assumed to begin at the last @ in the address.
	    In its more complex forms, the name could contain more routing
	    information.

	    Ideally, the phone number in the address is in the canonical form.
	    This consists of
	    +\<country code\>[\<area code\>]\<local number\>[\|\<suffix\>].

	    Other important things to note: An @ can be escaped by using a
            backslash, and a suffix may be added to the canonical number
	    by using a \| symbol after the number and following that with the
	    suffix.

    @ex     Some Examples: |
	    A simple Micsosoft At Work Address might look like

		JohnDoe@+1(206)5551212|$999

	    which would indicate that after dialing the number, we should wait
	    for a beep and dial a 999. THe receiving number would then route
	    to JohnDoe.  If the number is an IFAX machine, John would have an
	    account with the login JohnDoe, or if the number was a PC, JohnDoe
	    would be the email alias for his account.
			
	    In general, the <name> part of the address must be interpreted by
	    the receiving machine and can contain any routing information
	    necessary for inbound routing by this machine.

*********/




/****
    @doc    EXTERNAL    SRVRDLL    OVERVIEW

    @topic  Constants|
            The following section contains a list of predefined return codes,
            error codes, and other predefined values used throughout this
            document.

****/

/********
    @doc    EXTERNAL  SRVRDLL DATATYPES

    @type   NONE | LMI_RETURN | Return codes for LMI provider API's.

    @emem   LMI_SUCCESS | No error - function was successful.

    @emem   LMIERR_CONNECT_FAILED | Connection to Provider failed. Client
            should go offline.

    @emem   LMIERR_NOT_SUPPORTED | Some function/parameter was not
            supported by this LMI provider.

    @emem   LMIERR_OPERATION_FAILED | Generic failure code.

    @emem   LMIERR_OP_CANCELLED | Operation canceled by user.

    @emem   LMIERR_PROVIDER_BUSY | The Provider was temporarily unavailable to
            accept requests. This might be useful for Providers which have
            limits on the number of connections supported. The clients response
            to this error code should be to try and retry the operation if
            possible, particularly for API's like <f LMI_SendFax>. However,
            some clients may treat this as a failure.

    @emem   LMIERR_SERVER_RESOURCES_LOW | The Provider failed due to a low
            resource situation on a server.

********/

typedef DWORD LMI_RETURN;

#define LMI_SUCCESS                     0
#define LMIERR_CONNECT_FAILED           1
#define LMIERR_NOT_SUPPORTED            2
#define LMIERR_OPERATION_FAILED         3
#define LMIERR_OP_CANCELLED             4
#define LMIERR_PROVIDER_BUSY            5
#define LMIERR_SERVER_RESOURCES_LOW     6


/********
    @doc    EXTERNAL  SRVRDLL DATATYPES

    @type   NONE | FAXERROR |
            DWORD Error status codes returned in the
            <t LMIFORMAT>, <t LMIRECIPSTATUS>, <t LMISENDSTATUS>, and
            <t LMIRECVSTATUS> structures. This error consists of three parts:
            an error code, an extended error code, and error specific data
            (in some cases). The extended error code must be set to
            T30_UNKNOWN if the means for setting a more meaningful error are
            not available. A value of zero in the data field implies that
            there is no valid data for this error. In those cases where the
			extended error or data fields are unused, they must be set to zero.
			This is to allow these fields to be used in the future.

    @emem   Error Code | The low BYTE of the low word of the error is the
            error code. Use the macro GetErrCode(error) to extract this
            BYTE. The error codes defined are:

        @flag  T30_CALLFAIL | An error occured during actual
               transmission of the fax. Detailed error status can be determined
               from the extended error field.
        @flag  T30_DIALFAIL | An error occured during dialing
               the fax number. Detailed error status can be determined from
               the extended error field.
        @flag  T30_ANSWERFAIL | An error occured during answering of a phone
               call.  Detailed error status can be determined from the extended
               error field.
        @flag  T30_NOMODEM | The Provider could not find any hardware modem
               to send the fax over. This would typically indicate that the user
               had physically removed some hardware from the machine.
        @flag  T30_FILE_ERROR | An error occured trying to read or parse the
               format files which were passed in. Detailed error status may
               be found in the extended error.
        @flag  T30_MODEMERROR | An error occured while trying to talk with
               the hardware modem.
        @flag  T30_PORTBUSY | The port on which the hardware modem was
               installed cannot be opened.  Extended error status contains more
               details.
        @flag  T30_MODEMDEAD | The hardware modem has stopped responding to
               any AT commands. This typically requires some human intervention,
               such as turning the power off and back on.
        @flag  RES_NOMEMORY | The Provider ran out of memory resources.
        @flag  RES_LOWDISK | The Provider ran out of disk space.
        @flag  USER_ABORT | The job was cancelled on a user request.
        @flag  RENDERING_FAILURE | For Provider's that do any rendering, this
               indicates the class of failures which result in the inability to
               render a final format to be sent. Extended errors give more
               details.
        @flag  RES_LOW_SERVER | The Provider failed due to a low resource
               problem on a server.
        @flag  CUSTOM_ERROR | If the Provider happens to get an error
               which does not fall into any of the classes specifically
               defined here, then it can pass back a custom error. In this
               case the data field contains a global atom
               which identifies a string describing the error in terms
               understandable to the user.  NOTE: This error is not supported
               by Windows 95, but will be in a later release.
        @flag  GENERAL_FAILURE | Indicates a serious internal error in the
               software.

    @emem   Extended error codes for T30_DIALFAIL | Any of the following could
            be the reason for a dial failure:

        @flag  NCUDIAL_ERROR | Detailed error is unknown.
        @flag  NCUDIAL_BUSY | The called number was busy.
        @flag  NCUDIAL_NOANSWER | The dialed number did not answer.
        @flag  NCUDIAL_NODIALTONE | No dialtone could be detected.
        @flag  NCUDIAL_MODEMERROR | There was some hardware problem in
               the modem while trying to dial.
        @flag  NCUDIAL_BADDIALSTRING | The dial string was badly formed. In
               general, logical modems should try to be as robust as possible,
               ignoring characters which are not understood. This error code
               should only be used for cases where the string is so obviously
               malformed that there is no point even attempting to dial.

    @emem   Extended error codes for T30_ANSWERFAIL | The provider does not have
			to report receives which failed in the answering phase itself.
			However, if it chooses to do so, the following codes apply:

        @flag  NCUANSWER_ERROR | Detailed error is unknown.
        @flag  NCUANSWER_NORING | No ring was detected.
        @flag  NCUANSWER_MODEMERROR | There was some hardware problem in
               the modem while trying to answer.

    @emem   Extended error codes for T30_PORTBUSY | The port could be busy for
            two reasons:

        @flag  PORTBUSY_SELFUSE | The port is already being used by us. A common
				case causing this error is if a  receive is in progress. The
				client will typically retry the call at a later time,
				transparently to the user.
        @flag  PORTBUSY_OTHERAPP | The device or port is used by some other
               application.

    @emem   Extended error codes for T30_CALLFAIL | This is likely to be the
	    most common error, and very detailed error codes are defined for
            it. The extended error can be any of the following:

        @flag T30FAILS_T1 | Send T1 timeout (No NSF/DIS Received).
        @flag T30FAILS_TCF_DCN | Received DCN after TCF.
        @flag T30FAILS_3TCFS_NOREPLY | No reply to three attempts at training
              (TCF).
        @flag T30FAILS_3TCFS_DISDTC | Remote does not see our TCFs.
        @flag T30FAILS_TCF_UNKNOWN | Got garbage response to TCF.
        @flag T30FAILS_SENDMODE_PHASEC | Modem error or timeout at start of
              page.
        @flag T30FAILS_MODEMSEND_PHASEC | Modem error or timeout within page.
        @flag T30FAILS_MODEMSEND_ENDPHASEC | Modem error or timeout at end of
              page.
        @flag T30FAILSE_SENDMODE_PHASEC | Modem error or timeout at start of
              ECM page.
        @flag T30FAILSE_MODEMSEND_PHASEC | Modem error or timeout within ECM
              page.
        @flag T30FAILSE_MODEMSEND_ENDPHASEC | Modem error or timeout at end of
              ECM page.
        @flag T30FAILSE_BADPPR | Bad PPR received from receiver.
        @flag T30FAILS_3POSTPAGE_NOREPLY | No response after page: Probably
              receiver hungup during page transmit.
        @flag T30FAILS_POSTPAGE_DCN | Received DCN after page.
        @flag T30FAILSE_3POSTPAGE_NOREPLY | No response after page. Probably
              receiver hungup during page transmit.
        @flag T30FAILSE_POSTPAGE_DCN | Received DCN after ECM page.
        @flag T30FAILSE_POSTPAGE_UNKNOWN | Received garbage after ECM page.
        @flag T30FAILSE_RR_T5 | Receiver was not ready for more than 60 seconds
              during ECM flow-control.
        @flag T30FAILSE_RR_DCN | Received DCN after RR during ECM flow-control.
        @flag T30FAILSE_RR_3xT4 | No response from receiver during ECM
              flow-control.
        @flag T30FAILSE_CTC_3xT4 | No response from receiver after CTC
              (ECM baud-rate fallback).
        @flag T30FAILSE_CTC_UNKNOWN | Garbage response from receiver after CTC
              (ECM baud-rate fallback).
        @flag T30FAILR_PHASEB_DCN | Receiver: Sender decided we're incompatible.
        @flag T30FAILR_T1 | Receiver: Caller is not a fax machine or hung up.
        @flag T30FAILR_UNKNOWN_DCN1 | Receiver: Received DCN when command was
              expected.
        @flag T30FAILR_T2 | Receiver: No command was received for seven seconds.
        @flag T30FAILR_UNKNOWN_UNKNOWN2 | Receiver: Received garbage when
              command was expected.
        @flag T30FAILR_MODEMRECV_PHASEC | Receiver: Page not received, modem
              error or timeout at start of page.
        @flag T30FAILRE_MODEMRECV_PHASEC | Receiver: Data not received, modem
              error or timeout during page.
        @flag T30FAILRE_PPS_RNR_LOOP | Receiver: Timeout during ECM flow
              control after PPS.
        @flag T30FAILRE_EOR_RNR_LOOP | Receiver: Timeout during ECM flow
              control after EOR.
        @flag T30FAIL_NODEA_UNKNOWN | Sender: Garbage frames instead of DIS/DTC.
        @flag T30FAILS_POSTPAGE_UNKNOWN | Sender: Unknown response after page.
        @flag T30FAILS_POSTPAGE_OVER | Sender: We've sent a DCN (decided to
              end call).
        @flag T30FAILS_4PPR_ERRORS | Sender: Too many line errors in ECM mode.
        @flag T30FAILS_FTT_FALLBACK | Sender: Receiver doesn't like our
              training at all speeds.
        @flag T30FAILS_RTN_FALLBACK | Sender: Too many line errors in non-ECM
              mode even at 2400.
        @flag T30FAILS_4PPR_FALLBACK | Sender: Too many line errors in ECM mode
              even at 2400.
        @flag T30FAILS_MG3_NOFILE | Negotiation failed: Remote was G3 and there
              was no AWG3 format to send.
        @flag T30FAILS_NEGOT_ENCODING | Negotiation failed: Encoding mismatch.
        @flag T30FAILS_NEGOT_WIDTH | Negotiation failed: Paper Size Not
              Supported.
        @flag T30FAILS_NEGOT_LENGTH | Negotiation failed: Paper Size Not
              Supported.
        @flag T30FAILS_NEGOT_RES | Negotiation failed: Resolution Not Supported.
        @flag T30FAILS_EFX_BADFILE | Bad Linearized file was passed.
        @flag T30FAILS_MG3_BADFILE | Bad AWG3 file was passed in.
        @flag T30FAIL_ABORT | User abort
        @flag T30FAILS_SECURITY_NEGOT | Negotiation failed: Remote machine does
              not support security. If set, the error data contains the
              security version number supported by the recipient.
        @flag T30FAILS_NEGOT_MSGPROTOCOL | Negotiation failed: Remote machine
              does not support a compatible message protocol. If set, the
              error data contains the message protocol version number
              supported by the recipient.
        @flag T30FAILS_NEGOT_SECURITY | Negotiation failed: Remote machine does not support
              security. If set, the error data contains the security version number supported
              by the recipient.
        @flag T30FAILS_NEGOT_BINARYDATA | Negotiation failed: Remote machine
              does not support receiving binary data.
        @flag T30FAILS_NEGOT_COMPRESSION | Negotiation failed: Remote machine
              does not support a compatible version of compression. If set,
              the error data contains the compression version supported by
              the recipient.
        @flag T30FAILS_NEGOT_POLLING | Negotiation failed: Remote machine does
              not support polling.
        @flag T30FAILS_NEGOT_POLLBYNAME | Negotiation failed: Remote machine
              does not support poll by name.
        @flag T30FAILS_NEGOT_POLLBYRECIP | Negotiation failed: Remote machine
              does not support poll by recipient name.
        @flag T30FAILS_NEGOT_FILEPOLL | Negotiation failed: Remote machine
              does not support poll by filename.

    @emem   Error data values for T30_CALLFAIL | Error data must be zero for negotiation failures. For all other failures, the error data may be set
            to one of the following fields:

        @flag T30_SENTNONE | Indicates that no pages were sent at all.
        @flag T30_SENTSOME | Indicates that some pages were successfuly
              transmitted and acknowledged by the remote machine.
        @flag T30_SENTALL | Indicates that all pages were successfuly sent.
              This should not really happen; it would generally indicate a
              successful transmission.

    @emem   Extended error codes for T30_FILE_ERROR | This error indicates a
            problem in one of the format files sent across the interface by
            the client. Different possible extended error codes are:

        @flag AWG3_INVALID_LINHDR | The linearized header at the head of the
              AWG3 file was invalid.
        @flag AWG3_INVALID_AWG3HDR | An invalid AWG3 header was found in the
              file.
        @flag LIN_INVALIDHDR | A linearized file had an invalid header.


********/

typedef DWORD FAXERROR;

#define GetErrCode(fe)  (LOBYTE(LOWORD(fe)))
#define GetExtErrCode(fe)  (HIBYTE(LOWORD(fe)))
#define GetErrData(fe)  (HIWORD(fe))
#define FormFaxError(ErrCode,ExtErrCode,ErrData) MAKELONG(MAKEWORD(ErrCode,ExtErrCode),ErrData)

// Error codes
#define T30_CALLFAIL                    2
#define T30_DIALFAIL                    4
#define T30_ANSWERFAIL                  5
#define T30_NOMODEM                     9
#define T30_FILE_ERROR                  11
#define T30_MODEMERROR                  15
#define T30_PORTBUSY                    16
#define T30_MODEMDEAD                   17

#define RES_NOMEMORY                    64
#define RES_LOWDISK                     65
#define USER_ABORT                      66
#define RENDERING_FAILURE               67
#define RES_LOW_SERVER                  68

#define CUSTOM_ERROR                    254
#define GENERAL_FAILURE                 255

// Extended Error codes
#define T30_UNKNOWN                     0

// RENDERING_FAILURE
#define ATTACH_NOT_PRINTABLE            1
#define COVER_TEMPLATE_INVALID          2

// T30_FILE_ERROR
#define AWG3_INVALID_LINHDR             1
#define AWG3_INVALID_AWG3HDR            2
#define LIN_INVALIDHDR                  3

// T30_DIALFAIL
#define NCUDIAL_ERROR                   0
#define NCUDIAL_BUSY                    2
#define NCUDIAL_NOANSWER                3
#define NCUDIAL_NODIALTONE              4
#define NCUDIAL_MODEMERROR              5
#define NCUDIAL_UNSUPPORTED_DIALCHAR    6
#define NCUDIAL_BADDIALSTRING           7

// Extended error code for T30_ANSWERFAIL
#define NCUANSWER_ERROR                 0
#define NCUANSWER_NORING                8
#define NCUANSWER_MODEMERROR            5

// Extended error code for T30_PORTBUSY
#define PORTBUSY_SELFUSE                0
#define PORTBUSY_OTHERAPP               1


// Includes T30FAIL.H so that the values here (which should be a subset of
//  those in T30FAIL.H) are kept in sync.
#include <t30fail.h>

// Extended error code for T30_CALLFAIL
#define T30FAILS_T1                     6       // Send T1 timeout (No NSF/DIS Recvd)
#define T30FAILS_TCF_DCN                7       // Recvd DCN after TCF (weird...)
#define T30FAILS_3TCFS_NOREPLY          8       // No reply to 3 attempts at training (TCF)
#define T30FAILS_3TCFS_DISDTC           9       // Remote does not see our TCFs for some reason
#define T30FAILS_TCF_UNKNOWN            10      // Got garbage response to TCF

#define T30FAILS_SENDMODE_PHASEC        11      // Modem Error/Timeout at start of page
#define T30FAILS_MODEMSEND_PHASEC       12      // Modem Error/Timeout within page
#define T30FAILS_MODEMSEND_ENDPHASEC    14      // Modem Error/Timeout at end of page

#define T30FAILSE_SENDMODE_PHASEC       15      // Modem Error/Timeout at start of ECM page
#define T30FAILSE_MODEMSEND_PHASEC      17      // Modem Error/Timeout within ECM page
#define T30FAILSE_MODEMSEND_ENDPHASEC   19      // Modem Error/Timeout at end of ECM page
#define T30FAILSE_BADPPR                20      // Bad PPR recvd from Recvr (bug on recvr)

#define T30FAILS_3POSTPAGE_NOREPLY      21      // No response after page: Probably Recvr hungup during page transmit
#define T30FAILS_POSTPAGE_DCN           22      // Recvd DCN after page. (weird...)

#define T30FAILSE_3POSTPAGE_NOREPLY     23      // No response after page: Probably Recvr hungup during page transmit
#define T30FAILSE_POSTPAGE_DCN          24      // Recvd DCN after ECM page. (weird...)
#define T30FAILSE_POSTPAGE_UNKNOWN      25      // Recvd garbage after ECM page.

#define T30FAILSE_RR_T5                 26      // Recvr was not ready for more than 60secs during ECM flow-control
#define T30FAILSE_RR_DCN                27      // Recvd DCN after RR during ECM flow-control(weird...)
#define T30FAILSE_RR_3xT4               28      // No response from Recvr during ECM flow-control
#define T30FAILSE_CTC_3xT4              29      // No response from Recvr after CTC (ECM baud-rate fallback)
#define T30FAILSE_CTC_UNKNOWN           30      // Garbage response from Recvr after CTC (ECM baud-rate fallback)

#define T30FAILR_PHASEB_DCN             35      // Recvr: Sender decided we're incompatible
#define T30FAILR_T1                     36      // Recvr: Caller is not a fax machine or hung up

#define T30FAILR_UNKNOWN_DCN1           37      // Recvr: Recvd DCN when command was expected(1)
#define T30FAILR_T2                     38      // Recvr: No command was recvd for 7 seconds
#define T30FAILR_UNKNOWN_UNKNOWN2       40      // Recvr: Recvd grabge when command was expected

#define T30FAILR_MODEMRECV_PHASEC       41      // Recvr: Page not received, modem error or timeout at start of page
#define T30FAILRE_MODEMRECV_PHASEC      42      // Recvr: Data not received, modem error or 

#define T30FAILRE_PPS_RNR_LOOP          43      // Recvr: Timeout during ECM flow control after PPS (bug)
#define T30FAILRE_EOR_RNR_LOOP          44      // Recvr: Timeout during ECM flow control after EOR (bug)

#define T30FAIL_NODEA_UNKNOWN           45      // Sender: Garbage frames instead of DIS/DTC

#define T30FAILS_POSTPAGE_UNKNOWN       47      // Sender: Unknown response after page
#define T30FAILS_POSTPAGE_OVER          48      // Sender: We've sent a DCN (decided to end call)
#define T30FAILS_4PPR_ERRORS            50      // Sender: Too many line errors in ECM mode

#define T30FAILS_FTT_FALLBACK           51      // Sender: Recvr doesn't like our training at all speeds
#define T30FAILS_RTN_FALLBACK           52      // Sender: Too many line errors in non-ECM mode even at 2400
#define T30FAILS_4PPR_FALLBACK          53      // Sender: Too many line errors in ECM mode even at 2400

#define T30FAILS_MG3_NOFILE             63      // Negotiation failed: Remote in G3-only and no MG3 file *** Email Form Not Supported ***
#define T30FAILS_NEGOT_ENCODING         64      // Negotiation failed: Encoding mismatch
#define T30FAILS_NEGOT_WIDTH            66      // Negotiation failed: Send image too wide    *** Paper Size Not Supported ***
#define T30FAILS_NEGOT_LENGTH           67      // Negotiation failed: Send image too long    *** Paper Size Not Supported ***
#define T30FAILS_NEGOT_RES              68      // Negotiation failed: Resolution mismatch    *** Resolution Not Supported ***

#define T30FAILS_EFX_BADFILE            69      // Bad EFX file
#define T30FAILS_MG3_BADFILE            71      // Bad MG3 file

#define T30FAIL_ABORT                   87      // User abort

#define T30FAILS_SECURITY_NEGOT         110// Negotiation failed: Remote in G3-only and no MG3 file *** Email Form Not Supported ***

// New failure codes
#define T30FAILS_NEGOT_MSGPROTOCOL      128
#define T30FAILS_NEGOT_SECURITY         129
#define T30FAILS_NEGOT_BINARYDATA       130
#define T30FAILS_NEGOT_COMPRESSION      131

#define T30FAILS_NEGOT_COVERATTACH      132
#define T30FAILS_NEGOT_ADDRATTACH       133
#define T30FAILS_NEGOT_METAFILE         134

#define T30FAILS_NEGOT_POLLING          135
#define T30FAILS_NEGOT_POLLBYNAME       136
#define T30FAILS_NEGOT_POLLBYRECIP      137
#define T30FAILS_NEGOT_FILEPOLL         138
#define T30FAILS_NEGOT_RELAY            139


// Data word
// Data for T30_CALLFAIL - non negotiation errors
#define T30_UNKNOWN                     0
#define T30_SENTALL                     1
#define T30_SENTNONE                    2
#define T30_SENTSOME                    3


/********
    @doc    EXTERNAL    SRVRDLL DATATYPES

    @type   NONE | FORMATTYPE | These are all the different kinds of formats
            that can be rendered for sending. It is typedef'd to a WORD.

    @emem   LMIFORMAT_G3 | A standard T4/T6 encoded file, with a linearizer
            header put on top of it. See <lq>AWG3 File Format<rq> for details.

    @emem   LMIFORMAT_LIN_IMAGE | A Linearized Microsoft At Work rendered
            image file.

    @emem   LMIFORMAT_LIN_BINARY | A linearized binary file.

********/

typedef WORD FORMATTYPE;

#define LMIFORMAT_G3            1
#define LMIFORMAT_LIN_IMAGE     2
#define LMIFORMAT_LIN_BINARY    3
#define LMIFORMAT_STORE_REF     4


/********
    @doc    EXTERNAL    SRVRDLL DATATYPES

    @type   NONE | POLLTYPE | These are all the different kinds of poll
            requests that can be sent. It is typedef'd to a WORD.

    @emem   POLLREQ_ADDRESS | Polls for a document for a particular
            address. The Poll name is the address for which messages are
            desired, and a password can also be used. This feature
			is unimplemented and should not be used.

    @emem   POLLREQ_FILE | Polls for a directory or file on the recipient
	    system. The poll name contains the file system path to be accessed,
	    and a password can also be used. This feature is unimplemented and
		should not be used.

    @emem   POLLREQ_MSGNAME | Polls for a particular message name.
	    The poll name contains the message name wanted,
	    and a password can also be used.

    @emem   POLLREQ_G3 | Standard G3 compliant poll request. Polls for
            any file which has been stored at the recipient machine. Neither
	    pollname or password are currently supported.

		All poll types except POLLREQ G3 require both sender and receiver to be
		Microsoft Extended Fax Protocol (MEFP)-enabled.
********/

typedef WORD POLLTYPE;

#define POLLREQ_ADDRESS         1
#define POLLREQ_FILE            2
#define POLLREQ_MSGNAME         3
#define POLLREQ_G3              4


/********
    @doc    EXTERNAL    SRVRDLL DATATYPES

    @type   NONE |SCHEDTYPE | Kinds of possible scheduling. Typedef'd to
            a WORD.

    @emem   SCHED_ASAP | Schedule immediately.

    @emem   SCHED_BEFORE | Schedule immediately, and fail if the specified
            time is past.

    @emem   SCHED_AFTER | Schedule any time after the specified time is past.

    @emem   SCHED_CHEAPTIMES | Schedule only between cheap time periods
            as specified by the Provider's local settings.  Only the time of
            day, as specified by the start time and stop time elements of the
            <t SENDJOBTIME> structure, have any meaning.  In fact, the day,
            date, month, and year are not guaranteed to be filled in.

********/

typedef WORD SCHEDTYPE;

#define SCHED_ASAP              1
#define SCHED_BEFORE            2
#define SCHED_AFTER             3
#define SCHED_CHEAPTIMES        4


/********
    @doc    EXTERNAL    SRVRDLL

    @type   NONE | PROVIDERSTATE | A DWORD which describes the state of the Provider.
            Can consist of a combination of the following flags:

    @emem   PROVIDER_OK   | Standard OK state - no action is required.

    @emem   PROVIDER_OFFLINE  | Provider is offline - client should do
	    the same.  Offline indicates that the Provider is no longer
	    actively able to send or receive jobs.

    @emem   PROVIDER_NO_RESPONSE  | No response from Provider. Client
	    should go offline.

    @emem   PROVIDER_BADERROR | Bad error at Provider. Client should go
	    offline.

    @emem   PROVIDER_RECEIVES_WAITING | Client should poll for receives.

    @emem   PROVIDER_SENDS_COMPLETED | Client should poll for completed
	    send status.
********/

typedef DWORD PROVIDERSTATE;

#define PROVIDER_OK               0x0000
#define PROVIDER_OFFLINE          0x0001
#define PROVIDER_NO_RESPONSE      0x0002
#define PROVIDER_BADERROR         0x0004
#define PROVIDER_RECEIVES_WAITING 0x0008
#define PROVIDER_SENDS_COMPLETED  0x0010


/********
    @doc    EXTERNAL    SRVRDLL

    @type   NONE | JOBSTATE | A WORD identifying the state of a fax job.

    @emem   jstNewMsg | Just received from mail spooler.
    @emem   jstProcessingRecipients | Deciding what needs to be sent.
    @emem   jstRendering | Being rendered (Used internally by client).
    @emem   jstReadyToSend | Waiting to be schedulable.
    @emem   jstSchedulable | Ready to be transmitted.
    @emem   jstTransmitting | Being transmitted.
    @emem   jstWaitingForServer | Given to network Provider (Used internally
            by client).
    @emem   jstWaitingForClient | Waiting for client to take back.

********/

typedef WORD JOBSTATE;

#define jstNewMsg               0
#define jstProcessingRecipients 1
#define jstRendering            2
#define jstReadyToSend          3
#define jstSchedulable          4
#define jstTransmitting         5
#define jstAllDone              6
#define jstWaitingForServer     7
#define jstWaitingForClient     8




/****
    @doc    EXTERNAL    SRVRDLL    OVERVIEW

    @topic  Data Structures |
	    Most structures defined here are in a packed format; that is,
            there are no pointers to external objects.  This is done so
	    they can be easily stored in a file or transmitted as a block
	    across the network.

            Most structures
            have two size fields.  The HeaderSize field gives the defined
	    size of the structure, which is used for versioning the structure.
	    If the structure is expanded in the future, this size can be
	    used to maintain backward compatibility. The TotalSize field
	    indicates the size of the whole structure along with all its data.

	    All strings and other variable-length data items such as
	    structures are represented in the structure by an offset from the
	    beginning of the structure.  The actual data for these elements
	    begins at that offset.  The length of the data is indicated by
	    the item itself.  If it is a string, it is null-terminated.  If
	    it is another structure, the size fields will convey this
	    information.

	    All files referenced in the structures are created in the spool
	    directory specified in LMI_InitProvider.

****/


/********
    @doc    EXTERNAL    SRVRDLL DATATYPES

    @types  LMICUSTOMOPTION | Overlay of LMI Custom Option data.  For
            MAPI 1.0, Win32 implementations, this structure is found
            in the MAPI message property PR_FAX_LMI_CUSTOM_OPTION
            (property tag value 0x4513.)

    @field  DWORD | dwTotalSize | Total number of BYTES occupied by the
            structure along with its concomitant variable sized data.

    @field  WORD | wHeaderSize | Gives the size for the fixed
            size header portion of the structure.

    @field  WORD | wNumRecords | Number of records in the Custom Option
            data.  This is also eqaul to the size of the dwOffsetTable.

    @field  DWORD | dwOffsetTable[] | Table of offsets to the records
            of type LMICUSTOMOPTIONRECORD.  All offsets are from the
            top of the LMICUSTOMOPTION structure.  The records should
            directly follow this array.
********/

#ifndef RC_INVOKED
#pragma warning (disable: 4200)
#endif

typedef struct _LMICUSTOMOPTION {
	DWORD           dwTotalSize;
	WORD            wHeaderSize;
   WORD            wNumRecords;
	DWORD           dwOffsetTable[0];
}   LMICUSTOMOPTION, FAR *LPLMICUSTOMOPTION;


/********
    @doc    EXTERNAL    SRVRDLL DATATYPES

    @types  LMICUSTOMOPTIONRECORD | Record overlay of LMI Custom Option data.

    @field  DWORD | dwTotalSize | Total number of BYTES occupied by the
            structure along with its concomitant variable sized data.

    @field  WORD | wHeaderSize | Gives the size for the fixed
            size header portion of the structure.

    @field  WORD | wPad | Keep DWORD alignment.

    @field  CHAR | szUniqueName[32] | Unique name specified by
            provider.  This is used for identification of the
            provider's record within the LMICUSTOMOPTION and should
            contain some encoding of the provider developer company.
            eg, "Microsoft:Netfax".  The string MUST be null
            terminated so that providers may do strcmp's to detect
            their own section.

    @field  BYTE | lpData[] | Here's the data.

********/
typedef struct _LMICUSTOMOPTIONRECORD {
	DWORD           dwTotalSize;
	WORD            wHeaderSize;
   WORD            wPad;
	CHAR            szUniqueName[32];
	BYTE            lpData[];
}   LMICUSTOMOPTIONRECORD, FAR *LPLMICUSTOMOPTIONRECORD;

#ifndef RC_INVOKED
#pragma warning (default: 4200)
#endif

/********
    @doc    EXTERNAL    SRVRDLL DATATYPES

    @types  LMIFORMAT | Describes a format.

    @field  WORD | wHeaderSize | Gives the size for the fixed
            size header portion of the structure.

    @field  WORD | wTotalSize | Total number of BYTES occupied by the
            structure along with its concomitant variable sized data.

    @field  FAXERROR | feError | Indicates if there were any errors while
            trying to generate this format. If this field is not set to
            zero, the format file pointed to by the szFileName field may be
            invalid and should not be used.  This error value might need to be
            propagated into the <e LMIRECIPSTATUS.feError> field for recipients
            which fail as a result of this format not being ready.

    @field  CHAR | szFileName[16] | The filename containing the actual
            format data.

    @field  FORMATTYPE | ftFormatType | Which format this represents.

    @field  WORD | wPad | Keep DWORD alignment.
********/
typedef struct _LMIFORMAT {
	WORD            wHeaderSize;
	WORD            wTotalSize;
	FAXERROR        feError;
	CHAR            szFileName[16];
	FORMATTYPE      ftFormatType;
        WORD            wPad;
}   LMIFORMAT, FAR *LPLMIFORMAT;
#define MAXFORMATSIZE   (sizeof(LMIFORMAT))


/********
    @doc    EXTERNAL    SRVRDLL DATATYPES

    @types  LMIPOLLREQUEST | Describes a poll request message.

    @field  WORD | wHeaderSize | Gives the size for the fixed
            size header portion of the structure.

    @field  WORD | wTotalSize | Total number of BYTES occupied by the
            structure along with its concomitant variable sized data.

    @field  WORD | wszRecipName | The name of this recipient.  This
            is present only if this recipient is from a Provider implemented
            address book. In this case <e LMIRECIPIENT.wszAddressOffset> is zero.

    @field  WORD | wszAddressOffset | The Microsoft At Work address for this
            recipient.  Not present for recipients implemented in the
            Provider's address book. See <t Microsoft At Work Address> for
            details.

    @field  DWORD | dwPollContext |
	The  provider should report this value in the dwPollContext field
	of the LMIRECVSTATUS structure for all the messages received as a
	result of this poll request. This enables the client to associate the
	received messages (reported to the client via LMI_ReportReceives)
	with a particular poll request.  A value of zero is valid, but not
	useful, because all non-polled receives reported by LMI_ReportReceives
	have zero as the dwPollContext in their LMIRECVSTATUS structure.

    @field  POLLTYPE | ptPollType | What type of a poll request this is.

    @field  WORD | wszPollNameOffset | The name to be sent along with the
            poll request. The specific semantic meaning depends on the poll
            type.

    @field  WORD | wszPollPasswordOffset | Offset to the password to be sent
            along with the poll request.

    @field  WORD | wPad | Keep DWORD alignment.
********/
typedef struct _LMIPOLLREQUEST {
	WORD            wHeaderSize;
	WORD            wTotalSize;
	WORD            wszRecipName;
	WORD            wszAddressOffset;
        DWORD           dwPollContext;
        POLLTYPE        ptPollType;
        WORD            wszPollNameOffset;
        WORD            wszPollPasswordOffset;
        WORD            wPad;
}   LMIPOLLREQUEST, FAR *LPLMIPOLLREQUEST;


/********
    @doc    EXTERNAL    SRVRDLL

    @types  LMIQUEUEDATA | Represents queue information about a single job.

    @field  WORD | wHeaderSize | Gives the size for the fixed
            size header portion of the structure.

    @field  WORD | wTotalSize | Total number of BYTES occupied by the
            structure along with its concomitant variable sized data.

    @field  DWORD | dwUniqueID | This can be used by the Provider to
            pass in a context.  Along with <e LMIQUEUEDATA.dwUniqueID2> and
            <e LMIQUEUEDATA.wszSenderMachineNameOffset> this
            must uniquely identify this job.

    @field  DWORD | dwUniqueID2 | See <e LMIQUEUEDATA.dwUniqueID>.

    @field  WORD | wszSenderMachineNameOffset | Points to a string which
            identifies the machine originating this job.  Used for display in
            the queue.  Also uniquely identifies the job along with the unique
            ID's.  This should be the same as the string pointed to by the
            <e LMISENDJOB.wszSenderMachineNameOffset> field in <t LMISENDJOB>.

    @field  WORD | wszSubjectOffset | Offset to the subject of this
            message.  This should be the same as the string pointed to by the
            <e LMISENDJOB.wszSubjectOffset> field in <t LMISENDJOB>.

    @field  DWORD | dwSize | This should be the same as what was passed
            in as <e LMISENDJOB.dwTotalFileSize> in <t LMISENDJOB>.

    @field  WORD | wNumRecipients | This should be the same as what was passed
            in as <e LMISENDJOB.wNumRecipients> in <t LMISENDJOB>.

    @field  JOBSTATE | jstState | Current overall status for this job.

    @field  WORD | wNumRecipDone | Number of recipients for which transmission
            has been completed, either succesfully or unsuccesfully.

    @field  WORD | wtmSendTimeOffset | Current scheduling state for this
            job.  Offset to a <t SENDJOBTIME> structure.

    @field  WORD | wrgbCustomStatusOffset | Offset to Provider defined custom
            status information.  This is passed to the
            <f LMI_DisplayCustomStatus> function when the user asks to see
            detailed status for this job.

    @field  WORD | wCustomDataSize | Size of the custom data pointed to by
            the <e LMISENDJOB.wrgbCustomStatusOffset> field.

********/

typedef struct _LMIQUEUEDATA {
	WORD        wHeaderSize;
	WORD        wTotalSize;
	DWORD       dwUniqueID;
	DWORD       dwUniqueID2;
	WORD        wszSenderMachineNameOffset;
	WORD        wszSubjectOffset;
	DWORD       dwSize;
	WORD        wNumRecipients;
	JOBSTATE    jstState;
	WORD        wNumRecipDone;
	WORD        wtmSendTimeOffset;
	WORD        wrgbCustomStatusOffset;
	WORD        wCustomDataSize;
}   LMIQUEUEDATA, NEAR *NPLMIQUEUEDATA, FAR *LPLMIQUEUEDATA;


/********
    @doc    EXTERNAL SRVRDLL

    @types  LMIQUEUEFILEHEADER | A queue file consists of this header followed
            by the queue data.

    @field  DWORD | dwSig | This must be set to SIG_QUEUEFILE.

    @field  DWORD | dwSize | Must be set to the total file size.

    @field  DWORD | dwNumEntries | Number of queue entries in the file. The
            header is followed by this many <t LMIQUEUEDATA> structures.
********/

#define SIG_QUEUEFILE   0x56873
typedef struct _LMIQUEUEFILEHEADER {
	DWORD       dwSig;                  // Should always be NQFH
	DWORD       dwSize;                 // Total file size
	DWORD       dwNumEntries;           // Num of entries in the file
}   LMIQUEUEFILEHEADER;


/********
    @doc    EXTERNAL    SRVRDLL DATATYPES

    @types  LMIRECIPIENT | Describes a recipient.

    @field  WORD | wHeaderSize | Gives the size for the fixed
            size header portion of the structure.

    @field  WORD | wTotalSize | Total number of BYTES occupied by the
            structure along with its concomitant variable sized data.

    @field  WORD | wszRecipName | The name of this recipient. This
            is present only if this recipient is from a Provider implemented
            address book. In this case <e LMIRECIPIENT.wszAddressOffset> is
            zero and <e LMIRECIPIENT.szCoverFile> is a reference to a template
            on the Provider.

    @field  WORD | wszAddressOffset | The Microsoft At Work address for this
            recipient.  Not present for recipients implemented in the
            Provider's address book. See <lq>Microsoft At Work Address<rq> for
            details.

    @field  CHAR | szCoverFile[16] | The filename containing the cover
            page data if any for this recipient.  This could be a reference to
            a previously uploaded template if this is a recipient from the
            Provider's address book.  If the first word of this character array
            is 0 but the second word is non-null, then the second word represent
            a WORD offset into the LMIRECIPIENT structure where the fully
            qualified path may be found.

    @field  CHAR | szEncryptFile[16] | If one of the linearized formats
            pointed to by this recipient structure is a public key encrypted
            message being sent to multiple recipients, then this field contains
            the filename for a linearized format of the message encrypted with
            this recipients public key. This field will not be valid under any
            other circumstance.

    @field  WORD | wG3FormatIndex | If non-zero, this specifies a 1-based
            index into the format structure array.  It implies that this
            recipient can accept this version of the G3 format.  Note that
            there may still be some run time conversions necessary on this
            format at the time of sending.  For instance, the format may be
            MMR, whereas on calling it may be discovered that the recipient
            only accepts MH.  In this case, the Provider is responsible
            for converting this on the fly.

    @field  WORD | wLinImageFormatIndex | Index into the format array. Pointer
            to a linearized image format which can be sent to this recipient.

    @field  WORD | wLinBinaryFormatIndex | Index into the format array. Pointer
            to a linearized binary format which can be sent to this recipient.

    @field  WORD | wPad | Keep DWORD alignment.
						
********/

typedef struct _LMIRECIPIENT {
	WORD            wHeaderSize;
	WORD            wTotalSize;
	WORD            wszRecipName;
	WORD            wszAddressOffset;
	CHAR            szCoverFile[16];
	CHAR            szEncryptFile[16];
	WORD            wG3FormatIndex;
	WORD            wLinImageFormatIndex;
	WORD            wLinBinaryFormatIndex;
        WORD            wPad;
}  LMIRECIPIENT, FAR *LPLMIRECIPIENT;
#define MAXRECIPIENTSIZE    (sizeof(LMIRECIPIENT) + MAX_ADDRESS_LENGTH)


/*******
    @doc    EXTERNAL    SRVRDLL DATATYPES

    @types  LMIRECIPSTATUS | Used to convey information for the final
            status of the completed send for a recipient.

    @field  WORD | wHeaderSize | Gives the size for the fixed
            size header portion of the structure.

    @field  WORD | wTotalSize | Total number of BYTES occupied by the
            structure along with its concomitant variable sized data.

    @field  WORD | wrcCapsOffset | An offset to a <t MACHINECAPS> structure
            containing the updated capabilites for this recipient.

    @field  FORMATTYPE | ftSentFormat | The format type which was finally sent
            to this recipient.

    @field  FAXERROR | feError | The final status for this recipient.

    @field  SYSTEMTIME | dtTransmitTime | The time at which the fax was last
            attempted to be sent.

    @field  DWORD | dwConnectTime | Connect time for the transmission in
            seconds.

*******/

typedef struct _LMIRECIPSTATUS {
	WORD            wHeaderSize;
	WORD            wTotalSize;
	WORD            wrcCapsOffset;
	FORMATTYPE      ftSentFormat;
	FAXERROR        feError;
	DWORD           dwConnectTime;
	SYSTEMTIME      dtTransmitTime;
} LMIRECIPSTATUS, FAR *LPLMIRECIPSTATUS;


/********
    @doc    EXTERNAL    SRVRDLL

    @types  LMIRECVSTATUS | Gives the status for a received fax.

    @field  WORD | wHeaderSize | Gives the size for the fixed
            size header portion of the structure.

    @field  WORD | wTotalSize | Total number of BYTES occupied by the
            structure along with its concomitant variable sized data.

    @field  FAXERROR | feError | The final status for this receive.

    @field  SYSTEMTIME | dtRecvTime | Should be filled with the time at
            which the fax was received.

    @field  DWORD | dwConnectTime | The connect time for the
            transmission in seconds.

    @field  DWORD | dwPollContext | If this receive was actually in response
            to a poll request, then this will be set to the same value which
            was passed in in the <t LMIPOLLREQUEST> structure sent along with
            the poll request.

    @field  ATOM | atFile | The filename containing the received fax file. This
            file should be in the spool directory agreed upon in the
            <f LMI_InitLogicalModem> call.

    @field  WORD | wPad | Keep DWORD alignment.

********/

typedef struct _LMIRECVSTATUS {
	WORD        wHeaderSize;
	WORD        wTotalSize;
	FAXERROR    feError;
	SYSTEMTIME  dtRecvTime;
	DWORD       dwConnectTime;
        DWORD       dwPollContext;
	ATOM        atFile;
        WORD        wPad;
}  LMIRECVSTATUS, FAR *LPLMIRECVSTATUS;


/********
    @doc    EXTERNAL    SRVRDLL DATATYPES

    @types  LMISENDJOB | Describes a new fax job. A fax job specifies a send to
			one or more recipients.

    @field  DWORD | dwTotalSize | Total number of BYTES occupied by the
            structure along with its concomitant variable sized data.

    @field  WORD | wHeaderSize | Gives the size for the fixed
            size header portion of the structure.

    @field  WORD | fUnicode | Indicates whether the string pointed to by
            <e LMISENDJOB.wszSenderMachineNameOffset> is a Unicode string or
            not.
	
    @field  WORD | wszSenderMachineNameOffset | Points to a string which
            identifies the machine originating this job.  Used for display in
            the queue. Also uniquely identifies the job along with the unique
            ID's.

    @field  WORD | wszSubjectOffset | Subject of the message. Used for display
            purposes in the queue.

    @field  DWORD | dwUniqueID | Used by the client to uniquely identify
            this send fax job along with <e LMISENDJOB.dwUniqueID2>.

    @field  DWORD | dwUniqueID2 | Used along with <e LMISENDJOB.dwUniqueID> to
            identify this job.

    @field  DWORD | dwBillingCode | Billing code for this job. This is to allow
            Providers to keep accurate billing logs.

    @field  DWORD | dwTotalFileSize | An approximation for the total size
            of the data required to be transmitted for this message for all
            recipients combined.  Meant for display purposes in the queue to allow some
            idea of how long the job is likely to take.

    @field  WORD | wtmSendTimeOffset | Offset to a <t SENDJOBTIME> scheduling
            structure.

    @field  WORD | wprPollRequestOffset | Offset to a poll request structure.
            See <t LMIPOLLREQUEST> for details.  If this offset is set, there
            are no recipient or format structures associated with this job. In
            other words, the rgwStructOffsets field will be zero.

    @field  WORD | wrgbCustomOptionOffset | Offset to custom message options
            set for this message.  This is an offset to data returned by a
            call to <f LMI_SetCustomMsgOptions>.  The first DWORD of the data
            indicates the size of the data.

    @field  WORD | wNumRecipients | The number of recipients for this job.

    @field  WORD | wNumFormats | The number of rendered formats associated
            with this job.

    @field  WORD | wPad | Keep DWORD alignment.
						
    @field  DWORD | rgdwStructOffsets[] | Array of size
            <e LMISENDJOB.wNumFormats> and <e LMISENDJOB.wNumRecipients>
            offsets to format and recipient structures. The <t LMISENDJOB>
            structure is followed by all these structures. The <t LMIFORMAT>
            structures come first.

********/

#ifndef RC_INVOKED
#pragma warning (disable: 4200)
#endif

// The basic fax job structure for any send
typedef struct _LMISENDJOB {
	DWORD           dwTotalSize;
	WORD            wHeaderSize;
	WORD            fUnicode;
	WORD            wszSenderMachineNameOffset;
	WORD            wszSubjectOffset;
	DWORD           dwUniqueID;
	DWORD           dwUniqueID2;
	DWORD           dwBillingCode;
	DWORD           dwTotalFileSize;
	WORD            wtmSendTimeOffset;
        WORD            wprPollRequestOffset;
        WORD            wrgbCustomOptOffset;
	WORD            wNumRecipients;
	WORD            wNumFormats;
        WORD            wPad;
	DWORD           rgdwStructOffsets[];
}  LMISENDJOB, FAR *LPLMISENDJOB;

#ifndef RC_INVOKED
#pragma warning (default: 4200)
#endif


/********
    @doc    EXTERNAL    SRVRDLL DATATYPES

    @types  LMISENDSTATUS | Conveys back status information at the end of a
            send job.

    @field  WORD | wHeaderSize | Gives the size for the fixed
            size header portion of the structure.

    @field  WORD | wTotalSize | Total number of BYTES occupied by the
            structure along with its concomitant variable sized data.

    @field  FAXERROR | feJobError | Indicates any global error which
            caused all recipients to fail, such as cancellation by the user, or
            an out of memory situation.  This should only be set if none of
            the recipients for this message were succesfully contacted.

    @field  DWORD | dwUniqueID | Used by the client to uniquely identify
            this send fax job along with <e LMISENDSTATUS.dwUniqueID2>.
            This should be the same as the one passed in the <t LMISENDJOB>
            structure.

    @field  DWORD | dwUniqueID2 | Used along with <e LMISENDSTATUS.dwUniqueID>
            to identify this job.  Should be the same as the one passed in the
            <t LMISENDJOB> structure.

    @field  WORD | fUnicode | Indicates that the
            <e LMISENDSTATUS.szSenderMachineName> field contains a unicode
            string.

    @field  WORD | wPad | Keep DWORD alignment.
	
    @field  CHAR | szSenderMachineName[MAX_SERVERNAME_SIZE * 2] | Points to a
            string which identifies the machine originating this job.
            This should be the same as the one passed in the <t LMISENDJOB>
            structure.

    @field  LMIRECIPSTATUS | rgnrsRecipStatus[] | An array of recipient status
            structures, one for each recipient of the message. These structures
            are not required if <e LMISENDSTATUS.feJobError> is set. If present,
            the order of recipients in this array must be the same as the order in
            which they were submitted in the <t LMISENDJOB> structure.

********/
#ifndef RC_INVOKED
#pragma warning (disable: 4200)
#endif

typedef struct _LMISENDSTATUS {
	WORD            wHeaderSize;
	WORD            wTotalSize;
	FAXERROR        feJobError;
	DWORD           dwUniqueID;
	DWORD           dwUniqueID2;
	WORD            fUnicode;
        WORD            wPad;
	CHAR            szSenderMachineName[MAX_SERVERNAME_SIZE*2];
        LMIRECIPSTATUS  rgnrsRecipStatus[];
} LMISENDSTATUS, FAR *LPLMISENDSTATUS;

#ifndef RC_INVOKED
#pragma warning (default: 4200)
#endif


/*******
    @doc    EXTERNAL    SRVRDLL DATATYPES

    @types  MACHINECAPS | This structure describes the capabilites for a
            fax machine. It is used to return updated capabilities for
            any fax machine contacted and allows intelligent preprocessing
            the next time a fax is sent to the same number.

    @field  WORD | wHeaderSize | Gives the size for the fixed size header
            portion of the structure.

    @field  WORD | wTotalSize | Total number of BYTES occupied by the
            structure along with its concomitant variable sized data.

    @field  WORD | wbDISCapsOffset | Offset to a DIS frame containing
	    capabilities of the machine. The format of the frame is defined
	    by the <t FR> structure.
	
    @field  WORD | wbNSFCapsOffset | Offset to a sequence of encrypted
            Microsoft At Work NSF frames containing At Work capabilities for
            the machine. The format of each frame is defined by the <t FR>
            structure. A frame with a null type and 0 length terminates the
            sequence. Valid for any Microsoft At Work enabled Provider.
*******/

typedef struct {
	WORD    wHeaderSize;
	WORD    wTotalSize;
	WORD    wbDISCapsOffset;
	WORD    wbNSFCapsOffset;
} MACHINECAPS, FAR *LPMACHINECAPS;


/********
    @doc    EXTERNAL    SRVRDLL  INITIALIZATION

    @types  MODEMCAPS | Specifies all the capabilities for a logical modem. When
			specified by the client (for example in LMI_ExchangeCaps), the
			structure represents the capabilities which are supported
			by the client.

    @field  WORD | wHeaderSize | Size of this structure.

    @field  WORD | wTotalSize  | Total size with concomitant data.

    @field  DWORD | dwGenCaps | Lists general capabilities. The following flags
            can be set:
		
        @flag OWN_ADDRESS_BOOK | Indicates that the modem can maintain it's own
              address book.
        @flag ADVANCED_STORE | Indicates that the modem can manage its own
              store and upload messages to it.
        @flag COVER_PAGE_RENDERER | Indicates that the modem can render
              Microsoft At Work cover page templates.
        @flag REAL_TIME_STATUS | Indicates that real time status updates for
              the current job are supported.
        @flag MULTIPLE_RECIPIENTS | Indicatest that messages can be sent to
              multiple recipients.
        @flag PER_RECIP_COVER | Indicates that per recipient cover pages are
              supported. If this is not set, the <e LMIRECIPIENT.szCoverFile>
              field of the <t LMIRECIPIENT> structure will not be used.
        @flag PER_RECIP_ENCRYPTION | Indicates that key encrypted sends to
              multiple recipients are supported. If this is not set,
              the <e LMIRECIPIENT.szEncryptFile> field of
              the <t LMIRECIPIENT> structure will never be used.
        @flag CUSTOM_MSG_OPTIONS | Indicates that the modem supports setting of
              custom per message options. If not set, the function
              <f LMI_SetCustomMsgOptions> need not be implemented.
        @flag POLL_REQUEST | Indicates that poll requests using T30 fields
              is supported. If not, the <t LMIPOLLREQUEST> structure should
              not be used.
        @flag ABOVE64K_STRUCTURES | Indicates that the <t LMISENDJOB> structure
              can have a total size > 64K.  For x86 based systems, this allows
              far pointers to be used instead of huge pointers.

        @flag ALLOW_SHARING | Indicates that this device can be shared.


        @flag PRECIOUS_RESOURCE | Indicates that this device is a precious
              resource on the local machine which may need to be shared with
              other MAPI providers.  For example, a modem which may be used
              by another provider to access dial-up services for mail delivery.
              The MAPI transport will use this flag to determine if it should
              support MAPI's FlushQueues semantics.

    @field  DWORD   | dwSchedCaps | Lists scheduling related capabilities. The
            following flags are defined:

        @flag SUPPORT_QUEUEING | Indicates whether the modem can queue up
              multiple jobs at a time, or can only process them one at a time.
        @flag ALLOW_SCHED_ASAP | Indicates that jobs can be scheduled as ASAP.
        @flag ALLOW_SCHED_AFTER | Indicates that jobs can be scheduled as
              SCHED_AFTER.
        @flag ALLOW_SCHED_BEFORE | Indicates that jobs can be scheduled as
              SCHED_BEFORE.
        @flag ALLOW_SCHED_CHEAPTIMES | Indicates that jobs can be scheduled
              for cheap times. This capability assumes that the cheap times are
              defined by the Provider.
        @flag ALLOW_CLIENT_CHEAPTIMES | Allows the client to set the cheap
              times independently for each job.
        @flag USE_UTC_TIMES | Indicates that the times indicated in the
              <t SENDJOBTIME> structure are in UTC and not in local time. If
              any of the client or the Provider do not support this capability
              the times will revert to being local times.

    @field  WORD | wmcOffset | Offset to <t MACHINECAPS> structure which should
            be filled in with all the capabilities which this modem has:
            essentially what it would send back to a caller in the
            DIS and NSF frames.

    @field  WORD | wMaxRetries | Indicates the maximum number of retries
            permitted for a send. The client should not set the
            <e SENDJOBTIME.wNumRetries> field of the <t SENDJOBTIME> structure
            to a number greater than this.

    @field  WORD | wMinTimeBetweenRetries | Specifies the minimum amount of
            time that can be specified between retries. The client should never
            set the <e SENDJOBTIME.wMinBetweenRetries> field of the
            <t SENDJOBTIME> structure to anything less than this.

    @field  WORD | wPad | Keep DWORD alignment.
						
********/

typedef struct {
	WORD    wHeaderSize;
	WORD    wTotalSize;
	DWORD   dwGenCaps;
	DWORD   dwSchedCaps;
	WORD    wmcOffset;
	WORD    wMaxRetries;
	WORD    wMinTimeBetweenRetries;
	WORD    wPad;
}  MODEMCAPS, FAR *LPMODEMCAPS;

// General caps
#define OWN_ADDRESS_BOOK        0x0001
#define ADVANCED_STORE          0x0002
#define COVER_PAGE_RENDERER     0x0004
#define REAL_TIME_STATUS        0x0008
#define MULTIPLE_RECIPIENTS     0x0010
#define PER_RECIP_COVER         0x0020
#define PER_RECIP_ENCRYPTION    0x0040
#define CUSTOM_MSG_OPTIONS      0x0080
#define POLL_REQUEST            0x0100
#define ABOVE64K_STRUCTURES     0x0200
#define ALLOW_SHARING           0x0400
#define ALLOW_RESHARING         0x0800
#define PRECIOUS_RESOURCE       0x1000

// Sched caps
#define SUPPORT_QUEUEING        0x0001
#define ALLOW_SCHED_ASAP        0x0002
#define ALLOW_SCHED_AFTER       0x0004
#define ALLOW_SCHED_BEFORE      0x0008
#define ALLOW_SCHED_CHEAPTIMES  0x0010
#define ALLOW_CLIENT_CHEAPTIMES 0x0020
#define USE_UTC_TIMES           0x0040


/********
    @doc    EXTERNAL    SRVRDLL DATATYPES

    @types  SENDJOBTIME | Contains all the scheduling informations for a job.

    @field  WORD | wHeaderSize | Size of this structure.

    @field  WORD | wNumRetries | Maximum number of retries for busy numbers.

    @field  WORD | wMinBetweenRetries | Minutes to be allowed to elapse between successive
            retries.

    @field  SCHEDTYPE | stSchedType | Type of scheduling required for this job.

    @field  SYSTEMTIME | dtStartTime | Time after which job is schedulable.

    @field  SYSTEMTIME  | dtStopTime | Time after which job is not schedulable.

********/

typedef struct {
	WORD        wHeaderSize;
	WORD        wNumRetries;
	WORD        wMinBetweenRetries;
	SCHEDTYPE   stSchedType;
	SYSTEMTIME  dtStopTime;
	SYSTEMTIME  dtStartTime;
} SENDJOBTIME, FAR *LPSENDJOBTIME;




/****
    @doc    EXTERNAL    SRVRDLL

    @topic  The Logical Modem Interface |
            The following section details the functions that make up the
            Logical Modem Interface.

****/


/********
    @doc    EXTERNAL    SRVRDLL

    @api    LMI_RETURN | LMI_AbortSendJob | Aborts the specified send job
	    from the Provider's queue.

    @parm   DWORD | dwLogicalModem | The logical modem from whose queue the
	    job is to be cancelled. 

    @parm   LPTSTR | lpszSenderMachineName | String identifying the sender
	    machine name.  This parameter, along with the <p dwUniqueID> and
	    <p dwUniqueID2> uniquely identify this job for the Provider.
	    These all must be same as the values passed in the
            <t LMISENDJOB> structure passed into <f LMI_SendFax>.

    @parm   DWORD | dwUniqueID | See <p lpszSenderMachineName>.

    @parm   DWORD | dwUniqueID2 | See <p lpszSenderMachineName>.

    @rdesc  LMI_SUCCESS on success.

    @comm   The abort can be performed asynchronously by the Provider.  Return
	    from this function does not imply any guarantees as to the time
	    within which the job will be aborted.  The provider reports
		the final state of the job via LMI_ReportSend. The client will ensure
	    that this function is only called to abort jobs which were
	    initiated on its machine.

********/

LMI_RETURN FAR PASCAL LMI_AbortSendJob(DWORD dwLogicalModem,
                                       LPTSTR lpszSenderMachineName,
                                       DWORD dwUniqueID,
                                       DWORD dwUniqueID2);
typedef LMI_RETURN (FAR PASCAL FAR *LPLMI_AbortSendJob)(DWORD dwLogicalModem,
                                                        LPTSTR lpszSenderMachineName,
                                                        DWORD dwUniqueID,
                                                        DWORD dwUniqueID2);

/********

    @doc    EXTERNAL    SRVRDLL INSTALLATION

    @func   LMI_RETURN | LMI_AddModem | Called to add a new logical modem to
	    the list of current modems.

    @parm   HWND | hDlg | The window handle of the parent dialog box.  This
	    should be used as the parent for any new dialog boxes which are
	    displayed.

    @parm   LPTSTR | modembuf | Pointer to the buffer where the call
	    should return a zero-terminated string uniquely identifying the
	    logical modem the user selected.  <p buflen> gives the maximum
	    length this string can be (including the zero termination).

    @parm   WORD | buflen | Length of the buffer pointed to by
            <p modembuf>.  This is guaranteed to be at least 64 BYTES.
	
    @rdesc  The dialog should handle notifying the user of errors if it can
	    put its first dialog up.

    @comm   This function is called to put up a dialog box allowing the user
	    to select a logical modem to add to the list of current modems.
	    The function should return a displayable string that is shown
	    in the user list.  This is also the string which is passed in to
            identify the modem in the <f LMI_InitLogicalModem> call.

********/

LMI_RETURN FAR PASCAL LMI_AddModem(HWND hDlg,
                                   LPTSTR modembuf,
                                   WORD buflen);
typedef LMI_RETURN (FAR PASCAL FAR *LPLMI_AddModem)(HWND hDlg,
                                                    LPTSTR modembuf,
                                                    WORD buflen);


/********
    @doc    EXTERNAL    SRVRDLL

    @api    PROVIDERSTATE | LMI_CheckProvider | Pings the Provider to see if it
	    is alive.

    @rdesc  Returns state of Provider.  This return value can be used to make
	    the client poll the Provider for events.

    @comm   This can be called periodically by the client and should be
	    implemented in as efficient a manner as possible.  It can be
	    used by the client to decide whether it needs to go offline
	    among other things.

	    It is not mandatory for this to return a completely accurate
	    state of the Provider.  If finding this information is very
	    expensive, the Provider can, at its discretion, do this less
	    frequently, and return the stale state in the intermediate polls.

    @parm   DWORD | dwLogicalModem | Handle representing the logical modem to
	    be checked.

    @parm   LPATOM | lpatError | If there was an error and the Provider is
	    having problems, a global atom containing a descriptive string
	    for this error can be returned here.  Any string returned will be
	    displayed to the user at the client's discretion.  The atom will
	    be freed by the client.
********/

PROVIDERSTATE FAR PASCAL LMI_CheckProvider(DWORD dwLogicalModem,
                                           LPATOM lpatError);
typedef PROVIDERSTATE (FAR PASCAL FAR *LPLMI_CheckProvider) (DWORD dwLogicalModem,
                                                             LPATOM lpatError);


/*******
    @doc    EXTERNAL    SRVRDLL CONFIGURATION

    @api    LMI_RETURN | LMI_ConfigureModem | Called to let the user
	    configure a logical modem.

    @parm   HWND | hDlg  | The window handle of the parent dialog box. This
	    should be used as the parent for any new dialog boxes which are
	    displayed.

    @parm   LPTSTR | lpszModem | Pointer to string representing the logical
	    modem to be configured.  This is the same string which was
            returned by <f LMI_AddModem>.

    @rdesc  Returns LMI_SUCCESS if successful.

*******/

LMI_RETURN FAR PASCAL  LMI_ConfigureModem(HWND hDlg,
                                          LPTSTR lpszModem);


/********
    @doc    EXTERNAL    SRVRDLL

    @api    LMI_RETURN | LMI_DeinitLogicalModem | Deinitializes the
	    specified logical modem.

    @parm   DWORD | dwLogicalModem | Handle representing the logical modem to
	    be deinitialized.

    @rdesc  LMI_SUCCESS if successful.
********/

LMI_RETURN FAR PASCAL LMI_DeinitLogicalModem (DWORD dwLogicalModem);
typedef LMI_RETURN (FAR PASCAL FAR *LPLMI_DeinitLogicalModem) (DWORD 
dwLogicalModem);


/********
    @doc    EXTERNAL    SRVRDLL
	
    @api    LMI_RETURN | LMI_DeinitProvider| Deinitializes the LMI provider.

    @rdesc  LMI_SUCCESS if successful.
********/

LMI_RETURN FAR PASCAL LMI_DeinitProvider (VOID);
typedef LMI_RETURN (FAR PASCAL FAR *LPLMI_DeinitProvider) (VOID);


/********
    @doc    EXTERNAL    SRVRDLL

    @api    LMI_RETURN | LMI_DisplayCustomStatus | Displays extended status
	    information for a job.

    @parm   HWND | hwndParent | Parent window handle which should be used for
	    displaying any dialogs.

    @parm   LPBYTE | lpbCustomData | Pointer to the start of the custom
	    data associated with this job.

    @parm   WORD | wCustomDataSize | Size in BYTES of the data pointed to
	    by <p lpbCustomData>.
*********/
	
LMI_RETURN FAR PASCAL LMI_DisplayCustomStatus(HWND hwndParent,
                                              LPBYTE lpbCustomData,
                                              WORD wCustomDataSize);
typedef LMI_RETURN (FAR PASCAL FAR *LPLMI_DisplayCustomStatus)(HWND hwndParent,
                                                               LPBYTE lpbCustomData,
                                                               WORD wCustomDataSize);
/********
    @doc    EXTERNAL    SRVRDLL

    @api    LMI_RETURN | LMI_ExchangeCaps | Allows the client and the Provider
            to exchangde <t MODEMCAPS> structures without having to initialize
            the Provider or a logical modem.  This is one of two calls which
            can be made without an initialized modem.

    @parm   LPTSTR | lpszLogicalModem | Pointer to string identifying logical
            modem the caps belong to.

    @parm   LPMODEMCAPS | lpmcClient | Pointer to a <t MODEMCAPS> structure
            that describes the capabilities of the client. This should be used
            by the Provider to decide which formats can be understood by the
	    client.  For instance, if the client only understands MH, then
	    the Provider would need to convert any received faxes into MH
            before reporting them in <f LMI_ReportReceives>. Similarly, this
	    can indicate to the Provider whether or not features such as
            uploading of messages and Provider address books are supported by
            this particular client implementation.  If this pointer is null,
            it should be ignored.

    @parm   LPMODEMCAPS | lpmcProvider | Points to a <t MODEMCAPS> structure
            which should be filled in with the capabilities of this Provider.
	    The size of the memory pointed to by this structure is filled in
	    the wTotalSize field of the structure. If this pointer is null,
            no capabilities need to be returned.

    @rdesc  LMI_SUCCESS on success.

    @comm   It is perfectly valid for a Provider to return LMIERR_NOT_SUPPORTED
            for this call.  A Provider may need to do this if it cannot
            determine the modem capabilities without actually initializing
            the modem.
********/

LMI_RETURN FAR PASCAL LMI_ExchangeCaps (LPTSTR lpszLogicalModem,
                                        LPMODEMCAPS lpmcClient,
                                        LPMODEMCAPS lpmcProvider);
typedef LMI_RETURN (FAR PASCAL FAR *LPLMI_ExchangeCaps)(LPTSTR lpszLogicalModem,
                                                        LPMODEMCAPS lpmcClient,
                                                        LPMODEMCAPS lpmcProvider);


/********
    @doc    EXTERNAL    SRVRDLL

    @api    DWORD | LMI_GetQueueFile | Retrieves the name of the queue file
	    for a logical modem from the Provider.

    @parm   DWORD | dwLogicalModem | A handle to the logical modem for which
	    the queue is desired. If a valid handle is supplied, the
	    <p lpszLogicalModemName> parameter should
	    be NULL.

    @parm   LPTSTR | lpszLogicalModemName | A string identifying the logical
	    modem for which the user wants to see the queue, if this modem
            has not been initialized previously.  This is one of two APIs which
            can be called without initializing a modem.  If this parameter is
	    used, the <p dwLogicalModem> parameter should be ignored.

    @parm   LPATOM | lpatFileName | The function should return a global
	    atom containing a fully qualified path name to the queue file.
	    This does not have to be on the local disk.  The pathname should
	    be such that it can be passed to a Windows CreateFile call.

    @parm   WORD | wFlags | Can be any combination of the following flags:

	    @flag NGQ_USER_REQUEST | Implies that the queue update request
	    is being made due to an explicit user refresh request. Transports
	    which have expensive updates can use this to divide the normal
	    refresh rate while making sure that explicit requeusts do not
	    get ignored.

    @rdesc  LMI_SUCCESS on success.

    @comm   Ideally the client should be able to retrieve the queue for any
            logical modem supported by this Provider, not necessarily the
	    one which is currently initialized. This allows the client to
	    choose a new modem intelligently if needed.

********/

#define NGQ_USER_REQUEST        0x0001

LMI_RETURN FAR PASCAL LMI_GetQueueFile (DWORD dwLogicalModem,
                                       LPTSTR lpszLogicalModemName,
                                       LPATOM lpatFileName,
                                       WORD wFlags);
typedef LMI_RETURN (FAR PASCAL FAR *LPLMI_GetQueueFile)(DWORD dwLogicalModem,
                                                       LPTSTR lpszLogicalModemName,
                                                       LPATOM lpatFileName,
                                                       WORD wFlags);

/********
    @doc    EXTERNAL    SRVRDLL

    @api    LMI_RETURN | LMI_InitLogicalModem | Used to initialize a particular
	    logical modem.

    @parm   LPTSTR | lpszLogicalModem | String identifying the logical modem
	    to be initialized.

    @parm   LPDWORD | lpdwLogicalModem | A DWORD handle representing this
	    logical modem should be returned in this pointer if the function
	    is successful. The handle is valid until the client calls
		LMI_DeinitLogicalModem with this handle.

    @parm   LPATOM | lpatClientName | A global atom containing an ASCII name
	    identifying this client must be returned here. This string is
	    used in the queue displays to identify jobs from this client on
	    the Provider. It is used by clients to restrict the jobs which
	    can be cancelled or rescheduled from their machines, so it
	    should be unique enough to prevent security holes. All string
		comparisons using this name should be case-insensitive because case
		is not necessarily preserved when using atoms.

    @parm   LPATOM | lpatPhone | A global atom containing the canonical phone
	    number for this logical modem. This is used to construct the
	    client's Microsoft At Work Address, and is the number put into
	    the FROM field of any messages sent. This needs to be filled in
	    if a non-null pointer is passed in.

    @parm   LPMODEMCAPS | lpmc | Points to a <t MODEMCAPS> structure which
	    should be filled in with the capabilities of this logical modem.
	    The size of the memory pointed to by this structure is filled in
	    the wTotalSize field of the structure. If this pointer is null,
	    no capabilities need to be returned.

    @rdesc  LMI_SUCCESS if successful. A handle to the logical modem should
	    be returned in <p lpdwLogicalModem>.

    @comm   Initializes a logical modem for further operations. The Provider
	    should use this to set up any necessary connections, and to make
	    sure that the Provider is up and running. The handle returned by
	    this function is used by any subsequent functions invoked for
	    this modem. Multiple modems may be initialized at the same time.
	    The handle returned may be used in multiple process contexts, so
	    the  implementor should make sure any memory it references can be
	    accessed in different process contexts.
********/

LMI_RETURN FAR PASCAL LMI_InitLogicalModem (LPTSTR lpszLogicalModem,
                                            LPDWORD lpdwLogicalModem,
                                            LPATOM lpatClientName,
                                            LPATOM lpatPhone,
                                            LPMODEMCAPS lpmc);
typedef LMI_RETURN (FAR PASCAL FAR *LPLMI_InitLogicalModem) (LPTSTR lpszLogicalModem,
                                                             LPDWORD lpdwLogicalModem,
                                                             LPATOM lpatClientName,
                                                             LPATOM lpatPhone,
                                                             LPMODEMCAPS lpmc);

/********
    @doc    EXTERNAL    SRVRDLL

    @api    LMI_RETURN | LMI_InitProvider | Used to initialize the LMI provider.

    @parm   LPTSTR | lpszCurSpoolDir | Pointer to the current spool directory.
	    The spool directory is where all intermediate format files get
	    created, and where the client expects received fax files.

    @parm   LPMODEMCAPS | lpmcClient | Pointer to a <t MODEMCAPS> structure that
	    describes the capabilities of the client. This should be used by
	    the Provider to decide which formats can be understood by the
	    client.  For instance, if the client only understands MH, then
	    the Provider would need to convert any received faxes into MH
            before reporting them in <f LMI_ReportReceives>. Similarly, this
	    can indicate to the Provider whether or not features such as
            uploading of messages and Provider address books are supported by
	    this particular client implementation.

    @parm   LPTSTR | lpszDefRecipAdd | For incoming G3 faxes for which the
	    recipient is unknown, this address should be used. This typically
	    happens for faxes received from G3 machines without a programmed
	    CSI. In this case, this address should be put inside the
	    linearized header on the AWG3 file.  If this address ends in an
            <lq>@<rq> the Provider should append the phone number of the modem on
	    which the fax was received, as well as any locally-obtained
		subaddressing information, using the Microsoft Fax Address format.
		For example, if the provider detects a DID string \<did\>, it
		should append <lq>\<local-phone-number>\|\<did\><rq> after the
		<lq>@<rq> sign.

    @parm   LPTSTR | lpszDefRecipName | Friendly name to be used for the
	    default recipient.  Goes along with <p lpszDefRecipAdd> to form
	    an address pair.

    @rdesc  LMI_SUCCESS if successful.

    @comm   This call is made once per session. It is guaranteed to be the
	    first call made to the Provider.

********/

LMI_RETURN FAR PASCAL LMI_InitProvider (LPTSTR lpszCurSpoolDir,
                                        LPMODEMCAPS lpmc,
                                        LPTSTR lpszDefRecipAdd,
                                        LPSTR lpszDefRecipName);
typedef LMI_RETURN (FAR PASCAL FAR *LPLMI_InitProvider) (LPTSTR lpszCurSpoolDir,
                                                         LPMODEMCAPS lpmc,
                                                         LPTSTR lpszDefRecipAdd,
                                                         LPSTR lpszDefRecipName);

/********

    @doc    EXTERNAL    SRVRDLL INSTALLATION

    @func   LMI_RETURN | LMI_RemoveModem | Called when a logical modem is removed
	    from the list of current modems.

    @parm   LPTSTR | lpszModem | Pointer to the string identifying the
	    logical modem being removed.

    @rdesc  Returns LMI_SUCCESS if successful.

    @comm   This call should be used to delete any context which has been
	    cached for this logical modem. For instance, if in the
            <f LMI_AddModem> call, a lot of connection information had been
            stored in an ini file with the key being returned as the logical
	    modem name, then this call would be used to delete this
	    information.

********/


LMI_RETURN FAR PASCAL LMI_RemoveModem(LPTSTR lpszModem);
typedef LMI_RETURN (FAR PASCAL FAR * LPLMI_RemoveModem)(LPTSTR lpszModem);


/********
    @doc    EXTERNAL    SRVRDLL

    @api    DWORD | LMI_ReportReceives | Lets LMI provider report back
	    received faxes.

    @parm   DWORD | dwLogicalModem | Handle representing the logical modem
	    to be checked. If this is null, all logical modems owned by this
	    Provider should be checked.

    @parm   WORD | wFlags | Can consist of a combination of the following
	    flags:

	    @flag NRR_USER_REQUEST | This flag will be set if new faxes are
	    being checked for on an explicit user request.  This is meant for
	    transports which tend to reduce the number of times they actually
            check for receives to reduce overhead. Providers should make
	    sure to do the checks when this flag is set.
				
	    @flag NRR_RETRIEVE_DATA | Set if the client wishes to process the 1st receive
		in the queue. If set, the provider fills out a LMIRECVSTATUS
		structure and specifies a pointer to it in *lplpnrtStatus. If
		the client makes successive calls specifying NRR_RETRIEVE_DATA (but not
		NRR_COMMITTED_RECV), information on the same receive (the 1st one
		on the queue) should be returned. Each time, a fresh atom needs to
		be allocated for the atFile field in LMIRECVSTATUS, and the client
		is responsible  for freeing this atom. If this flag is not set,
		indicates that the client wants to
	    simply find out if there are any receives waiting, and the provider
	    should ignore lplpnrtStaus.

	    @flag NRR_COMMITTED_RECV | Indicates that the previous receive
	    has been committed to permanent storage by the client and can be
	    deleted by the Provider from its queue. It also indicates that
            the memory used for the LMIRECVSTATUS structure for that job can
	    be freed or reused. Until this point, the Provider must not
	    remove the received fax from its internal permanent storage.
	    This helps avoid a fax being lost if the power goes off in the
	    middle of the handoff. In the worst case, it causes two copies of
	    the received fax to be processed instead of none.
		If this flag is specified, NRR_RETRIEVE_DATA is irrelevant and if
		specified should be ignored by the provider.

    @parm   LPDWORD | lpdwNumRecvs | Pointer to a DWORD which should be
	    filled in with the number of new received faxes which are waiting
	    to be picked up. If NRR_RETRIEVE_DATA is set in wFlags, the
	    received fax being returned in the current call should not be
	    included in this count.
			
    @parm   LPLMIRECVSTATUS FAR* | lplpnrtStatus | Pointer to a pointer
            which should be set to point to a <t LMIRECVSTATUS> structure.
	    The client assumes this pointer to point into accesible memory which is
	    valid until the next call made with the flag
	    NRR_COMMITTED_RECEIVE set. There can never be more than one
	    pending receive, so a single piece of memory can be reused.
	    This should be set only if <p wFlags> has the RETRIEVE_DATA flag
	    set. The atom passed in this structure will be freed by the
	    client. It should be set to null if there are no receives.

    @rdesc  Returns LMI_SUCCESS if succesful.

    @comm   It is possible for receives to be routed independent of this API
	    directly to the client's mail store. This would happen if the
	    client and Provider could communicate using another mail transport
	    (such as Microsoft SFS) to do this more easily.
********/

#define NRR_USER_REQUEST        0x0001
#define NRR_RETRIEVE_DATA       0x0002
#define NRR_COMMITTED_RECV      0x0004

LMI_RETURN FAR PASCAL LMI_ReportReceives(DWORD dwLogicalModem,
                                         WORD wFlags,
                                         LPDWORD lpdwNumRecvs,
                                         LPLMIRECVSTATUS FAR *lplpnrtStatus);

typedef LMI_RETURN (FAR PASCAL FAR *LPLMI_ReportReceives)(DWORD dwLogicalModem,
                                                          WORD wFlags,
                                                          LPDWORD lpdwNumRecvs,
                                                          LPLMIRECVSTATUS FAR *lplpnrtStatus);


/********
    @doc    EXTERNAL    SRVRDLL

    @api    LMI_RETURN | LMI_ReportSend | Reports status of completed send jobs.

    @parm   DWORD | dwLogicalModem | Handle representing the logical modem
	    to be checked. If this is null, all logical modems owned by this
	    Provider should be checked.

    @parm   WORD | wFlags | Can consist of a combination of the following
	    flags:

	    @flag NRS_USER_REQUEST | This flag will be set if the fax status
	    is being checked for on an explicit user request.  This is meant
	    for transports which tend to reduce the number of times they
	    actually check for receives to reduce overhead. Such transports
	    should make sure to do the checks when this flag is set.
				
	    @flag NRS_RETRIEVE_DATA | If set, indicates that the client wishes to
		process the status for the first one in the queue. If not set,
		indicates that the client wants to
	    simply find out if there are any jobs completed.

    @parm   LPDWORD | lpdwNumDone | Pointer to a DWORD which should be filled
	    in with the number of jobs which have been completed and are
	    waiting to be picked up. If NRS_RETRIEVE_DATA flag is set, then
	    this should be filled in with the number of jobs left not
	    counting the one being returned in this call.
			
    @parm   LPLMISENDSTATUS FAR* | lplpnstStatus | Pointer to a pointer which
            should be set to point to a <t LMISENDSTATUS> structure. The
	    client assumes this pointer to be valid until the next call it
	    makes to this function. It should be set to null if there are no
	    completed sends. It should only be filled in if NRS_RETRIEVE_DATA
	    is set in wFlags.

    @rdesc  Returns LMI_SUCCESS if succesful.
********/

#define NRS_USER_REQUEST        0x0001
#define NRS_RETRIEVE_DATA       0x0002

LMI_RETURN FAR PASCAL LMI_ReportSend(DWORD dwLogicalModem,
                                     WORD wFlags,
                                     LPDWORD lpdwNumDone,
                                     LPLMISENDSTATUS FAR *lplpnstStatus);

typedef LMI_RETURN (FAR PASCAL FAR *LPLMI_ReportSend)(DWORD dwLogicalModem,
                                                      WORD wFlags,
                                                      LPDWORD lpdwNumDone,
                                                      LPLMISENDSTATUS FAR *lplpnstStatus);

/********
    @doc    EXTERNAL    SRVRDLL

    @api    LMI_RETURN | LMI_RescheduleSendJob  | Reschedules the specified
            send job from the Provider's queue.

    @parm   DWORD | dwLogicalModem | The logical modem in whose queue the
	    job to be rescheduled lives. This does not have to be the
	    currently active modem.

    @parm   LPTSTR | lpszSenderMachineName | Pointer to a string identifying
	    the sender machine name. This parameter, along with the
	    <p dwUniqueID> and <p dwUniqueID2> uniquely identify this job for
	    the Provider. These all must be same as the values passed in the
            <t LMISENDJOB> structure passed into <f LMI_SendFax>.

    @parm   DWORD | dwUniqueID | See <p lpszSenderMachineName>.

    @parm   DWORD | dwUniqueID2 | See <p lpszSenderMachineName>.

    @parm   LPSENDJOBTIME | lpsjtNewTime | Pointer to a new <t SENDJOBTIME>
	    structure containing the reschedule information.

    @rdesc  LMI_SUCCESS on success.

    @comm   The reschedule can be performed asyncronously by the Provider.
	    Return from this function does not imply any guarantee as to the
	    time within which the job will be rescheduled. The client will
	    ensure that this function is only called to reschedule jobs which
	    were initiated on its machine.

********/

LMI_RETURN FAR PASCAL LMI_RescheduleSendJob (DWORD dwLogicalModem,
                                             LPTSTR lpszSenderMachineName,
                                             DWORD dwUniqueID,
                                             DWORD dwUniqueID2,
                                             LPSENDJOBTIME lpsjtNewTime);

typedef LMI_RETURN (FAR PASCAL FAR *LPLMI_RescheduleSendJob) (DWORD dwLogicalModem,
                                                              LPTSTR lpszSenderMachineName,
                                                              DWORD dwUniqueID,
                                                              DWORD dwUniqueID2,
                                                              LPSENDJOBTIME lpsjtNewTime);

/*******
    @doc    EXTERNAL    SRVRDLL

    @api    LMI_RETURN | LMI_SendFax | Accepts a job for sending. Job is already
	    completely rendered.

    @parm   DWORD | dwLogicalModem | Handle representing the logical modem
	    from which this should be sent.

    @parm   LPLMISENDJOB | lpnj | Points to a <t LMISENDJOB> structure
	    containing all the pertinent information about this job. The
	    structure is allocated by the client and is freed on return of
	    this call.

    @rdesc  Returns LMI_SUCCESS if the job is accepted.  A successful return
		   of this function implies that the job has been queued for
		   subsequent processing and transmission. This function should
		   fail only if there is a general failure in the provider or a
		   parameter validation failure. Processing or transmission failures
			should be returned in the appropriate <f LMI_ReportSend> call.

*******/

LMI_RETURN FAR PASCAL LMI_SendFax (DWORD dwLogicalModem,
                                   LPLMISENDJOB lpnj);

typedef LMI_RETURN (FAR PASCAL FAR * LPLMI_SendFax) (DWORD dwLogicalModem,
                                                     LPLMISENDJOB lpnj);


/*******
    @doc    EXTERNAL    SRVRDLL

    @api    LPBYTE | LMI_SetCustomMsgOptions | This function is called to
	    allow the user to set custom per message options.

    @parm   DWORD | dwLogicalModem | Handle representing the logical modem
	    which is currently in use.

    @parm   LPBYTE | lpbOld | Pointer to a previously returned piece of
	    memory which needs to be freed. If this parameter is being used
	    the function should simply free the memory and return without
	    putting up any UI.

    @rdesc  Returns a pointer to a memory block containing all the custom
	    information which has been set. The first DWORD of the block
	    MUST contain the total size of the memory being used. This data
            will be passed along with the <t LMISENDJOB> structure when this
	    message is finally submitted.  The memory will be freed by
	    calling this same API again with the memory pointer passed in as
	    a parameter.
	
    @comm   This function can be used to enable all kinds of advance options
	    to the user. One example of this could be usage of TAPI locations
	    and credit cards for calls. If the Provider can support these, it
	    can allow the user to setup credit card calls and then use these
	    when resolving the phone numbers into dialable strings. If the
	    Provider is using the TAPI translation services, the user could
	    select a specific outbound device or line for the call, and
            do a credit card ID override on cards setup on the Provider TAPI
	    setup.

*******/

LPBYTE FAR PASCAL LMI_SetCustomMsgOptions(DWORD dwLogicalModem,
                                          LPBYTE lpbOld);
typedef LPBYTE (FAR PASCAL FAR *LPLMI_SetCustomMsgOptions)(DWORD dwLogicalModem,
                                                           LPBYTE lpbOld);

#ifdef __cplusplus
} // extern "C" {
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\mem.h ===
/*
 -  MEM.H
 -
 *      Microsoft At Work Fax Messaging Service Configuration
 *              Memory allocation header file
 *
 *      Revision History:
 *
 *      When            Who                                     What
 *      --------        ------------------  ---------------------------------------
 *      7.20.93         Yoram Yaacovi           Created. Code moved here from file.h
 */


typedef SCODE (STDAPICALLTYPE *LPALLOCATEBUFFER)(
        ULONG                   cbSize,
        LPVOID FAR *    lppBuffer
);

typedef SCODE (STDAPICALLTYPE *LPALLOCATEMORE)(
        ULONG                   cbSize,
        LPVOID                  lpObject,
        LPVOID FAR *    lppBuffer
);

typedef ULONG (STDAPICALLTYPE *LPFREEBUFFER)(
        LPVOID                  lpBuffer
);

// Allocation array constants. Use these constants to define your choice of size
#define NUM_OF_ALLOCATIONS      10              // number of allocation chains
#define NUM_OF_CHUNKS           200             // number of allocations per chain
typedef void *MEMALLOCATIONS[NUM_OF_ALLOCATIONS][NUM_OF_CHUNKS];

// A kind-of memory "support" object. Should maintain the same structure as LPPROPSTORAGE
// (at least the same offsets for the memory allocation routines).
// Used to pass the address of the memory allocation routines to the String... functions in mem.c
typedef struct _PROP_MEM
{
        LONG lcInit;
        HRESULT hLastError;
        LPTSTR szLastError;

        /*
         *  memory routines
         */
        LPALLOCATEBUFFER lpAllocBuff;
        LPALLOCATEMORE lpAllocMore;
        LPFREEBUFFER lpFreeBuff;
        LPMALLOC lpMalloc;

        // Pointer to the storage object
        DWORD  lpStorage;

        // Pointer to the profile section
        DWORD  lpProfileSection;

} PROPMEM, *LPPROPMEM;

#define CBPROPMEM  sizeof(PROPMEM)

// Error Codes returned by the memory allocation functions
#define MAWF_SUCCESS                    0L                              // returned on success
#define MAWF_E_NOT_ENOUGH_MEMORY        E_OUTOFMEMORY   // returned on unsuccssful allocation
#define MAWF_E_INVALID_ARG                      E_INVALIDARG    // returned     on an invalid argument
                                                                                                        // including on NULL pointer argument to MAWFFreeBuff
// Memory allocation functions
BOOL                    InitAllocations(void);
BOOL                    DestroyAllocations(void);
ALLOCATEBUFFER  MAWFAllocBuff;
ALLOCATEMORE    MAWFAllocMore;
FREEBUFFER              MAWFFreeBuff;
BOOL                    StringAllocBuff(LPPROPMEM, LPTSTR, LPVOID, LPSTR, HWND);
BOOL                    StringAllocMore(LPPROPMEM, LPTSTR, LPVOID, LPVOID, LPSTR, HWND);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\mon.h ===
// COMM MONITOR CODE
// 2/11/95      JosephJ Created
//
//      The functions MonInit, MonDeInit, MonPut and MonDump may be used
//  to  timestamp and log all reads from/writes using the comm apis.
//  MonDump creates two files, one a byte buffer, and the 2nd
//  an array of MONREC structures, each structure containing a timestamp
//  and an offset into the first file that points to the actual comm data.




// Following two macros to be called before each write attempt
// and after each non-zero read.
#       define INMON(pTG, lpb, cb) \
        (pTG->gMonInfo.fInited && MonPutComm(pTG, fMON_COMM_IN, lpb,cb))
#       define OUTMON(pTG, lpb, cb) \
        (pTG->gMonInfo.fInited && MonPutComm(pTG, fMON_COMM_OUT, lpb,cb))
#       define  PUTEVENT(pTG, wFlags, ID, SubID, dw0, dw1, lpsz)\
        (pTG->gMonInfo.fInited && MonPutEvent(pTG, wFlags, ID, SubID, dw0, dw1, lpsz))

//File extensions for the mon-file
#define szMON_EXT "mon"


// Min and  Max sizes of internal buffers allocated for monitoring.
// MonInit will enforce that the sizes fall within this range.
#define MIN_MRBUFSIZE           (65536L>>2)
#define MIN_DATABUFSIZE         65536L

#define MAX_MRBUFSIZE           1000000L
#define MAX_DATABUFSIZE         1000000L

// Following structure records time of each call to read/write
// to comm. It also contains an offset into a circular buffer which
// contains all data writen to/read from comm port.
// wFlags is a word of information that was specified in the call to MonPut
// Currently it is a combination of the fMON_* flags above.
typedef struct
{
        WORD wFlags;            // One of fMON_* flags above. (A parameter to MonPut)
        WORD wcb;                       // Number of bytes of variable-lenghth data
        DWORD dwTickCount;      // GetTickCount at time of MonPut call
        DWORD dwOffset;         // Offset into circular byte-buffer where data is.
} MONREC, FAR *LPMONREC;


#define MFR_COMMDATA    1
#define MFR_EVENT               2

// Following flags are specified in the wFlags param of MonPut. They
// are  saved in the corresponding field of the MONREC structures.
#define fMON_COMM_RESERVED      (0x1<<15) // Should never be used.
#define fMON_COMM_IN            (0x1<<0) // Read operation
#define fMON_COMM_OUT           (0x1<<1) // Write operation
#define fMON_COMM_CMDRESP       (0x1<<3) // We believe modem is in command mode
#define fMON_COMM_DATA          (0x1<<4) // We believe modem is in data mode

#define EVENT_ID_TXTMSG         1               // Generic text message.
#define EVENT_ID_MON            10              // Related to the monitoring processitself.

#define EVENT_ID_T30_BASE       100             // T30-protocol-stack related.
#define EVENT_ID_T30_CALLSTATE  100     // T30-protocol: call state related.

#define EVENT_ID_MODEM_BASE     200             // Modem-related
#define EVENT_ID_MODEM_STATE    200     // Initialize modem

#define EVENT_SubID_NULL        0               // Nothing.

#define EVENT_SubID_MON_DUMP 1          // Dump (write to file) of in-memory record
                                                                        // TextID contains timestamp of start, as
                                                                        // well as number of puts, and bytes written
                                                                        // dwData0=dwData1=0
                                                                        // SubID=0

#define EVENT_SubID_T30_CS_SEND_START   1       // Initiate T.30 Send
                                                                        // Displayable phone number is embedded in
                                                                        // TxtMessage.
                                                                        // dwData0=dwData1=0;
#define EVENT_SubID_T30_CS_SEND_END     2       // End T.30 Send
                                                                        // dwData0=result code
#define EVENT_SubID_T30_CS_RECV_START   11      // Initiate T.30 Recv
                                                                        // dwData0=dwData1=0;
#define EVENT_SubID_T30_CS_RECV_END     12      // End T.30 Recv
                                                                        // dwData0=result code

#define EVENT_SubID_MODEM_INIT_START 1  // About to issue commands to Init modem
#define EVENT_SubID_MODEM_INIT_END 2    // Done initing.
                                                                        // dwData0=return code


#define EVENT_SubID_MODEM_DEINIT_START 11 // About to issue commands to deinit
#define EVENT_SubID_MODEM_DEINIT_END  12 // Done deiniting.
                                                                        // dwData0=return code

#define EVENT_SubID_MODEM_SENDMODE_START 21 // About to issue commands to deinit
#define EVENT_SubID_MODEM_SENDMODE_END  22 // Done deiniting.
                                                                        // dwData0=return code

#define EVENT_SubID_MODEM_RECVMODE_START 31 // About to issue commands to deinit
#define EVENT_SubID_MODEM_RECVMODE_END  32 // Done deiniting.
                                                                        // dwData0=return code

#define EVENT_SubID_MODEM_DIAL_START 41 // About to issue commands to dial
                                                                                // szTxtMsg contains dial string
                                                                                // In retail, digits after first 4
                                                                                // are zapped.
#define EVENT_SubID_MODEM_DIAL_END  42 // Done dialing
                                                                        // dwData0=return code

#define EVENT_SubID_MODEM_ANSWER_START 51 // About to issue commands to answer
#define EVENT_SubID_MODEM_ANSWER_END  52 // Done with the answer command
                                                                        // dwData0=return code

#define EVENT_SubID_MODEM_HANGUP_START 61 // About to issue commands to answer
#define EVENT_SubID_MODEM_HANGUP_END  62 // Done with the answer command
                                                                        // dwData0=return code


#pragma pack(1)
typedef struct {
        WORD wTotalSize;
        WORD wHeaderSize;
        WORD wType;             // One of the MFR_* defines
        WORD wFlags;    // type dependant
        DWORD dwTickCount;      // GetTickCount() at time of call to MonPut.
} MONFRAME_BASE, FAR *LPMONFRAME_BASE;
#pragma pack()

// Following inserted in mon file to document data structure.
// Make sure it matches above structure.
#define szMONFRM_DESC001\
                "struct{WORD wcbTot; WORD wcbHdr; WORD wTyp; WORD wFlg; DWORD dwTick}"
// Update version when structure changes.
#define szMONFRM_VER001 "V.100"

#pragma pack(1)
typedef struct {
        WORD wTotalSize;
        WORD wHeaderSize;
        WORD wType;             // One of the MFR_* defines
        WORD wFlags;    // One of the fMON_COMM_* values.
        DWORD dwTickCount;      // GetTickCount() at time of call to MonPut.
        WORD wcb;          // Count of bytes following.
        BYTE rgb[];             // Actuall bytes of comm data.
} MONFRAME_COMM, FAR *LPMONFRAME_COMM;
#pragma pack()

#define fEVENT_ERROR_MASK        0x111
#define fEVENT_ERROR_NONE        0x000
#define fEVENT_ERROR_FATAL       0x001
#define fEVENT_ERROR_SERIOUS 0x010
#define fEVENT_ERROR_MSGFAIL 0x011
#define fEVENT_ERROR_OTHER       0x100
#define fEVENT_ERROR_WARNING 0x101

#define fEVENT_TRACELEVEL_MASK 0x11000
#define fEVENT_TRACELEVEL_0    0x00000  // Vital: MUST display
#define fEVENT_TRACELEVEL_1    0x01000  // Important
#define fEVENT_TRACELEVEL_2    0x10000  // Less important
#define fEVENT_TRACELEVEL_3    0x11000  // Least important

#define MAX_TXTMSG_SIZE 128                             // Max size of text msg in a MONFRAME_EVENT structure.

#pragma pack(1)
typedef struct {
        WORD    wTotalSize;
        WORD    wHeaderSize;
        WORD    wType;                  // Should be MFR_EVENT
        WORD    wFlags;                 // One of the fEVENT_* flags.
        DWORD   dwTickCount;    // GetTickCount() at time of call to MonPut.
        WORD    wID;                    // ID of event. One of the EVENT_ID_* defines
        WORD    wSubID;                 // Sub ID of event. One of the EVENT_SubID_* defines
        DWORD   dwInstanceID;   // Instance ID of event within this file.
        DWORD   dwData0;                // ID-specific data
        DWORD   dwData1;                // ID-specific data
        SYSTEMTIME st;  // SystemTime at time of call to MonPut
        WORD    wTxtMsgOff;// Offset to null-terminated text message, if any
        WORD    wcbTxtMsg; // Size of null-terminated text message, if any
} MONFRAME_EVENT, FAR *LPMONFRAME_EVENT;
#pragma pack()

//  Monitor Options -- passed into MonInit
typedef struct {

        // Buffer options
        DWORD dwMRBufSize;              // preferred size -- actual size may be different
        DWORD dwDataBufSize;    // preferred size -- actual size may be different

        // File options
        DWORD dwMaxExistingSize;// If the size of the existing file
                                                        // is > this, we will rename the existing file
                                                        // and create a new one.
        char rgchDir[64];       // Directory where fax0.mon is to be created.

} MONOPTIONS, FAR * LPMONOPTIONS;

// Global monitor state
typedef struct {

        SYSTEMTIME      stStart;        // Set by MonInit.
        SYSTEMTIME      stDump;         // Set by MonDump.
        BOOL    fFreeOnExit;    // TRUE iff buffers must be freed on exit.
        BOOL    fInited;                // Set in MonInit. Cleared in MonDeInit.

        DWORD   dwNumPuts;              // Number of calls to MonPut
        DWORD   dwNumBytes;             // Cumulative number of bytes specified to MonPut
        UINT    uRefCount;              // Incremented each time MonDump is called
                                                        // Used to new file for each MonDump
                                                        // Cleared in MonInit and MonDeInit
        DWORD   dwEventInstanceID; // ID which is supposed to uniquely identify
                                                        // each event within a file.

        LPMONREC lpmrBuf;               // Pointer to MONREC circular buffer
        DWORD   dwcmrBuf;                       // Size (in units of MONREC) if circular buffer
        LPMONREC lpmrNext;              // Pointer to next available MR

        LPBYTE  lpbBuf;         // Pointer to circular byte buffer.
        DWORD   dwcbBuf;                // Size (in bytes) of above buffer.
        LPBYTE  lpbNext;                // Pointer to next place to write bytes in this buf.

        MONOPTIONS mo;                  // Passed in to MonInit();

} MONINFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\mcfg.h ===
//--------------------------------------------------------------------------
//
// File Name:  MCFG.H
//
// Brief Description:  External header file for the AWMCFG module.
//
// Author:  JosephJ
// History: 3/12/95 Created.
//
// Copyright (c) 1995 Microsoft Corporation
//
//--------------------------------------------------------------------------

enum
{
        MCFG_DO_RESERVED0 = 0,                  // Reserved - don't use

        MCFG_DO_ADVANCED_PROPERTIES = 10,       // Advanced modem props.
                        // dwIn0 == DeviceID
                        // dwIn1 == DeviceIDType
                        // dwIn2 == (DWORD) (LPSTR) lpszSection where profile is stored.
                        //lpdwOut0: reserved, must be 0.
                        //lpdwOut1: reserved, must be 0.
};

BOOL  MCFGConfigure(
        HWND hwndParent,        // IN: If we put up a dialog box
        DWORD dwAction,         // IN: One of the MCFG_DO_* enums above.
        DWORD dwIn0,            // IN: Action-specific param 0
        DWORD dwIn1,            // IN: Action-specific param 1
        DWORD dwIn2,            // IN: Action-specific param 2
        LPDWORD lpdwOut0,       // OUT: Action-specific result 0
        LPDWORD lpdwOut1        // OUT: Action-specific result 1
);

typedef BOOL (WINAPI *LPFNMCFGCONFIGURE)
        ( HWND, DWORD, DWORD, DWORD, DWORD, LPDWORD, LPDWORD);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\ncuparm.h ===
#ifndef _NCUPARAMS_
#define _NCUPARAMS_



// initial defaults for all settings in braces at end

typedef struct {
  USHORT uSize;			// of this structure
  SHORT	DialtoneTimeout;// how long to wait for dial tone (secs)	[30]
  SHORT	AnswerTimeout;	// how long to wait for callee to pick up phone (secs) [60]
  SHORT	DialPauseTime;	// how long to pause for a pause/comma (secs) [2]
  SHORT	FlashTime;		// how long to go off hook for flash (secs) [1]
  SHORT	RingsBeforeAnswer; // 0 to N [0]
  char 	chDialModifier;	// 'T'==tone 'P'==pulse
  SHORT	DialBlind;		// T/F (dial w/o waiting for dialtone) [0]
  SHORT	SpeakerVolume;	// 0 to 3 [1]
  SHORT SpeakerControl;	// 0=off  1=on during dial  2=on always [1];
  SHORT SpeakerRing;	// T/F (generate audible ring on incoming calls NYI) [0]
  USHORT uOEMExtra;		// set to 0
}
NCUPARAMS, far* LPNCUPARAMS;


// MODEM SPECIFIC INFORMATION
// +++ NOTE: 4/9/95 JosephJ: The name CMDTAB is out-of-date -- it contains more
// than just command-strings. It includes such modem-specific info as port-
// speed, whether to the modem (if class1) sends no-FCS after a frame, etc.
// So think about changing this name to something like MDMSP_INFO.
 
enum
{
// GENERAL

	fMDMSP_ANS_GOCLASS_TWICE	= (0x1<<0), // Try AT+FCLASS=1/2 TWICE on
											// answer, to get around clash with
											// incoming RING.
											// If NOT set, just do this once,
											// as in WFW 3.11.


// CLASS1-SPECIFIC

	fMDMSP_C1_NO_SYNC_IF_CMD	= (0x1<<8), // Do not send sync-command (AT)
											// if modem is already in command
											// State (To fix AT14 bug (Elliot
											// bug#2907) -- which returns
											// ERROR to AT+FTH=3 after AT
	fMDMSP_C1_FCS_NO    		= (0x1<<9), // No FCS after frame.
	fMDMSP_C1_FCS_YES_BAD		= (0x1<<10)	// Bad FCS after frame.
											// If neither flag specified,
											// driver will try to determine
											// on-the-fly.
};

typedef struct
{
	LPSTR szReset;
	LPSTR szSetup;
	LPSTR szExit;
	LPSTR szPreDial;
	LPSTR szPreAnswer;
	DWORD dwSerialSpeed;

	DWORD dwFlags;			// One-or-more fMDMSP_* flags defined above.
}
CMDTAB, FAR* LPCMDTAB;


#endif //_NCUPARAMS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\msgsvr.h ===
#define IF_MSGSVR_OPEN			(IF_MSGSVR_START + 0x00)
#define IF_MSGSVR_SOCKET		(IF_MSGSVR_START + 0x01)
#define IF_MSGSVR_CONNECT0		(IF_MSGSVR_START + 0x02)
#define IF_MSGSVR_CONNECT1		(IF_MSGSVR_START + 0x03)
#define IF_MSGSVR_CONNECT2		(IF_MSGSVR_START + 0x04)
#define IF_MSGSVR_CLOSE			(IF_MSGSVR_START + 0x05)
#define IF_MSGSVR_GETLASTERR	(IF_MSGSVR_START + 0x06)
#define IF_MSGSVR_GONEXTPHASE	(IF_MSGSVR_START + 0x07)
#define IF_MSGSVR_CHILDCOMPLETE	(IF_MSGSVR_START + 0x08)
#define IF_MSGSVR_GETNUMTX		(IF_MSGSVR_START + 0x09)
#define IF_MSGSVR_GETTXATOM		(IF_MSGSVR_START + 0x0a)
#define IF_MSGSVR_ACK			(IF_MSGSVR_START + 0x0b)
#define IF_MSGSVR_RECOVERY		(IF_MSGSVR_START + 0x0c)
#define IF_MSGSVR_SHUTDOWN		(IF_MSGSVR_START + 0x0d)
#define IF_MSGSVR_ONHOOKDIAL	(IF_MSGSVR_START + 0x0e)
#define IF_MSGSVR_MANUALRECV	(IF_MSGSVR_START + 0x0f)

#define IF_MSGSVR_MDM_STARTDIAGNOSTIC	(IF_MSGSVR_START + 0x10)
#define IF_MSGSVR_MDM_EXECDIAGNOSTIC	(IF_MSGSVR_START + 0x11)
#define IF_MSGSVR_MDM_ENDDIAGNOSTIC 	(IF_MSGSVR_START + 0x12)

#define ADDRTYPE_FAX	"FAX:"
#define ADDRTYPE_NET	"NET:"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\mysched.h ===
/***************************************************************************
 Name     :     MYSCHED.H
 Comment  :
 Functions:     (see Prototypes just below)

        Copyright (c) Microsoft Corp. 1991, 1992, 1993

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/

///////////////////// Tasking/Sleep/Timing options ///////////////////
//
// There are 4 options available
// (1) Tasking/Sleeping thru DLLSCHED: #defs reqd are !TSK !TMR and !IFK
// (2) Tasking/Sleeping thru an IFKERNEL BGproc: #defs reqd TSK IFK and !TMR
// (3) Tasking thru WIN32: #defs reqd WIN32 !IFK !TMR
//
//      In this file we define the macros for each of these options
/////////////////////////////////////// Tasking/Sleep/Timing options ///////

#define ACTIVESLICE             50


// MySetSlice(x) is defined seperately in BGT30.C and FCOM.C
// MySleep() is defined seperately in BGT30.C and FCOM.C

#       ifdef NCR
#               define FComCriticalNeg(pTG, x)       FComCritical(pTG, x)
#       else    // NCR
#               define FComCriticalNeg(pTG, x)
#       endif

#       ifdef PCR
#               define EnterPageCrit()  FComCritical(pTG, TRUE)
#               define ExitPageCrit()   FComCritical(pTG, FALSE)
#       else
#               define EnterPageCrit(pTG)
#               define ExitPageCrit(pTG)
#       endif

#       define EnterFileT30CritSection() // replaced by Mutex stuff in EFAXRUN.H
#       define ExitFileT30CritSection()  // replaced by Mutex stuff in EFAXRUN.H






// In WIN32 LibMain is called for all sorts of reasons. WEP is not
// directly called. WIN32 version of these macros calls WEP at the
// right time. Also LibMain or WEP do not need to be fixed

#define MYWEP                                                                           \
        int _export CALLBACK WEP(int type)

#define MYLIBMAIN                                                                                       \
        int _export CALLBACK WEP(int type);                                             \
        BOOL _export WINAPI LibMain(HINSTANCE hinst, DWORD dwReason, LPVOID lpv)

#define MYLIBSTARTUP(_szName)                                                                                   \
        DEBUGMSG(1, (SZMOD "LibMain called reason=%lu.P=0x%lx.T=0x%lx\r\n",\
                                (unsigned long) dwReason,\
                                (unsigned long) GetCurrentProcessId(),\
                                (unsigned long) GetCurrentThreadId()\
                                ));             \
        if(dwReason==DLL_THREAD_ATTACH || dwReason==DLL_THREAD_DETACH)          \
                return TRUE;                                                                                                    \
        if(dwReason==DLL_PROCESS_DETACH)                                                                        \
                return WEP(0);                                                                                                  \
        if(dwReason==DLL_PROCESS_ATTACH && (_szName))                                           \
        {                                                                                                                                       \
                HMODULE hM = GetModuleHandle(_szName);                                                  \
                if (hM) DisableThreadLibraryCalls(hM);                                                  \
        }

#define MYLIBSHUTDOWN


#ifdef DEBUG
# ifndef WIN32
#       define SLIPMULT         2
#       define SLIPDIV          2
# else
#       define SLIPMULT         1
#       define SLIPDIV          4
# endif
#       define BEFORESLEEP       DWORD t1, t2; t1=GetTickCount();
#       define AFTERSLEEP(x) t2=GetTickCount();                         \
                if((t2-t1) > (((x)*SLIPMULT)+((x)/SLIPDIV)))    \
                        DEBUGMSG(1, ("!!!SLEPT %ld. Wanted only %d!!!\r\n", (t2-t1), (x)));
#else
#       define BEFORESLEEP
#       define AFTERSLEEP(x)
#endif



//  Note: timeBeginPeriod,timeEndPeriod require mmsystem.h
//                which is not included in windows.h if WIN32_LEAN_AND_MEAN is defined.
#       define MY_TWIDDLETHUMBS(ulTime) \
        { \
                BEFORESLEEP \
                Sleep(ulTime); \
                AFTERSLEEP(ulTime) \
        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\nsfmacro.h ===
/***************************************************************************
 Name     :	NSFMACRO.H
 Comment  :	INTERNAL-ONLY Definitions of BC and NSF related structs

	Copyright (c) 1993 Microsoft Corp.

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/

#ifdef PORTABLE

/***********************************************************************
 *                                                                     *
 * NOTICE: This file has to be ANSI compilable, under GCC on UNIX      *
 * and other ANSI compiles. Be sure to use no MS C specific features   *
 * In particular, don't use // for comments!!!!                        *
 *                                                                     *
 ***********************************************************************/

#define NSFvMsgProtocol(p)	(((((LPBYTE)(p))[1]) & 0x38) >> 3)
#define fBinaryData(p)		(((((LPBYTE)(p))[1]) & 0x40) >> 6)
#define fInwardRouting(p)	(((((LPBYTE)(p))[1]) & 0x80) >> 7)
#define vSecurity(p)		(((((LPBYTE)(p))[2]) & 0x07) >> 0)
#define vMsgCompress(p)		(((((LPBYTE)(p))[2]) & 0x18) >> 3)
#define fDontCache(p)		(((((LPBYTE)(p))[2]) & 0x20) >> 5)
#define OperatingSys(p)		(((((LPBYTE)(p))[3]) & 0x07) >> 0)
#define vShortFlags(p)		(((((LPBYTE)(p))[3]) & 0x18) >> 3)
#define NSFvInteractive(p)	(((((LPBYTE)(p))[3]) & 0xE0) >> 5)
#define DataSpeed(p)		(((((LPBYTE)(p))[4]) & 0x1F) >> 0)
#define DataLink(p)			(((((LPBYTE)(p))[4]) & 0xE0) >> 5)

#define SetBCSTD0(p, l, n, m, b, i)							\
	(((LPBYTE)(p))[0]) = ((((l) & 0x3F) << 0) | (((n) & 0x03) << 6));	\
	(((LPBYTE)(p))[1]) = ((((n) & 0x1C) >> 2) | (((m) & 0x07) << 3) | \
				(((b) & 0x01) << 6) | (((i) & 0x01) << 7));

#define SetBCSTD2(p, s, c, d)									\
	(((LPBYTE)(p))[2]) = ((((s) & 0x07) << 0) | (((c) & 0x03) << 3) | (((d) & 0x01) << 5));	

#define SetBCSTD3(p, o, f, i)								\
	(((LPBYTE)(p))[3]) = ((((o) & 0x07) << 0) | (((f) & 0x03) << 3) | (((i) & 0x07) << 5));

#define SetBCSTD4(p, s, l)									\
	(((LPBYTE)(p))[4]) = ((((s) & 0x1F) << 0) | (((l) & 0x07) << 5));


#define TextEncoding(p)	(((((LPBYTE)(p))[1]) & 0xF8) >> 3)


#define fAnyWidth(p)	(((((LPBYTE)(p))[1]) & 0x08) >> 3)
#define vRamboVer(p)	(((((LPBYTE)(p))[1]) & 0xF0) >> 4)
#define vCoverAttach(p)	(((((LPBYTE)(p))[2]) & 0x07) >> 0)
#define vAddrAttach(p)	(((((LPBYTE)(p))[2]) & 0x18) >> 3)
#define vMetaFile(p)	(((((LPBYTE)(p))[2]) & 0x60) >> 5)
#define HiResolution(p)	(((((LPBYTE)(p))[3]) & 0x0F) >> 0)
#define HiEncoding(p)	(((((LPBYTE)(p))[3]) & 0xF0) >> 4)
#define CutSheetSizes(p) (((LPBYTE)(p))[4])
#define fOddCutSheet(p)	(((((LPBYTE)(p))[5]) & 0x01) >> 0)

#define SetBCIMAGE0(p, l, n, a, r)							\
	(((LPBYTE)(p))[0]) = ((((l) & 0x3F) << 0) | (((n) & 0x03) << 6));	\
	(((LPBYTE)(p))[1]) = ((((n) & 0x1C) >> 2) | (((a) & 0x01) << 3) | \
			(((r) & 0x0F) << 4));

#define SetBCIMAGE2(p, c, a, m)								\
	(((LPBYTE)(p))[2]) = ((((c) & 0x07) << 0) | (((a) & 0x03) << 3) | (((m) & 0x03) << 5));

#define SetBCIMAGE3(p, r, e)								\
	(((LPBYTE)(p))[3]) = ((((r) & 0x0F) << 0) | (((e) & 0x0F) << 4));

#define SetBCIMAGE4(p, c)	(((LPBYTE)(p))[4]) = (c);

#define SetBCIMAGE5(p, c)	(((LPBYTE)(p))[5]) = (((c) & 0x01) << 0);


#define fLowSpeedPoll(p)	 (((((LPBYTE)(p))[1]) & 0x08) >> 3)
#define fHighSpeedPoll(p)	 (((((LPBYTE)(p))[1]) & 0x10) >> 4)
#define fPollByNameAvail(p)	 (((((LPBYTE)(p))[1]) & 0x20) >> 5)
#define fPollByRecipAvail(p) (((((LPBYTE)(p))[1]) & 0x40) >> 6)
#define fFilePolling(p)		 (((((LPBYTE)(p))[1]) & 0x80) >> 7)
#define fExtCapsAvail(p)	 (((((LPBYTE)(p))[2]) & 0x01) >> 0)
#define fNoShortTurn(p)	 	 (((((LPBYTE)(p))[2]) & 0x02) >> 1)
#define vMsgRelay(p)	 	 (((((LPBYTE)(p))[2]) & 0x1C) >> 2)


#define ExtCapsCRC(p)	 	 (((WORD)(((LPBYTE)(p))[3])) | (((WORD)(((LPBYTE)(p))[4])) << 8))
#define SetExtCapsCRC(p, w)  ((((LPBYTE)(p))[3] = (((WORD)(w)) & 0xFF)), (((LPBYTE)(p))[4] = ((((WORD)(w)) >> 8) & 0xFF)))

#define SetBCPOLLCAPS0(p, l, n, lp, hp, pn, pr, pf)			  \
	(((LPBYTE)(p))[0]) = ((((l) & 0x3F) << 0) |  (((n) & 0x03) << 6));  \
	(((LPBYTE)(p))[1]) =  ((((n) & 0x1C) >> 2) | (((lp) & 0x01) << 3) | \
				(((hp) & 0x01) << 4) | (((pn) & 0x01) << 5) | \
				(((pr) & 0x01) << 6) | (((pf) & 0x01) << 7));

#define SetBCPOLLCAPS2(p, e, n, m)							  \
	(((LPBYTE)(p))[2]) = ((((e) & 0x01) << 0) | (((n) & 0x01) << 1) | (((m) & 0x07) << 2));


#define NSSvMsgProtocol(p)		(((((LPBYTE)(p))[1]) & 0x38) >> 3)
#define NSSvInteractive(p)		(((((LPBYTE)(p))[2]) & 0x07) >> 0)

#define SetBCNSS0(p, l, n, m, i)							\
	(((LPBYTE)(p))[0]) = ((((l) & 0x3F) << 0) | (((n) & 0x03) << 6)); \
	(((LPBYTE)(p))[1]) = ((((n) & 0x1C) >> 2) | (((m) & 0x07) << 3)); \
	(((LPBYTE)(p))[2]) = ((((i) & 0x07) << 0));


#define fReturnControl(p)	(((((LPBYTE)(p))[1]) & 0x08) >> 3)
#define PollType(p)			(((((LPBYTE)(p))[1]) & 0xF0) >> 4)
#define NamePass(p)			(((LPBYTE)(p)) + 2) 

#define SetBCPOLLREQ0(p, l, n, f, t) 										\
	(((LPBYTE)(p))[0]) = ((((l) & 0x3F) << 0) | (((n) & 0x03) << 6));	\
	(((LPBYTE)(p))[1]) = ((((n) & 0x1C) >> 2) | (((f) & 0x01) << 3) | 	\
			(((t) & 0x0F) << 4));



#else /** PORTABLE **/


#define NSFvMsgProtocol(p)	((p)->vMsgProtocol)
#define fBinaryData(p)		((p)->fBinaryData)
#define fInwardRouting(p)	((p)->fInwardRouting)
#define vSecurity(p)		((p)->vSecurity)	
#define vMsgCompress(p)		((p)->vMsgCompress)
#define fDontCache(p)		((p)->fDontCache)
#define OperatingSys(p)		((p)->OperatingSys)
#define vShortFlags(p)		((p)->vShortFlags)
#define NSFvInteractive(p)	((p)->vInteractive)
#define DataSpeed(p)		((p)->DataSpeed)	
#define DataLink(p)			((p)->DataLink)		

#define SetBCSTD0(p, l, n, m, b, i)			\
			(((p)->GroupLength)    = (l));	\
			(((p)->GroupNum)	   = (n));	\
			(((p)->vMsgProtocol)   = (m));	\
			(((p)->fBinaryData)	   = (b));	\
			(((p)->fInwardRouting) = (i));	

#define SetBCSTD2(p, s, c, d)				\
			(((p)->vSecurity)	 = (s));	\
			(((p)->vMsgCompress) = (c));	\
			(((p)->fDontCache)   = (d));

#define SetBCSTD3(p, o, f, i)				\
			(((p)->OperatingSys) = (o));	\
			(((p)->vShortFlags)	 = (f));	\
			(((p)->vInteractive) = (i));

#define SetBCSTD4(p, s, l)				\
			(((p)->DataSpeed)	= (s));	\
			(((p)->DataLink)	= (l));

#define TextEncoding(p)		(((LPBCTEXTID)(p))->TextEncoding)	

#define fAnyWidth(p)	 ((p)->fAnyWidth)
#define vRamboVer(p)	 ((p)->vRamboVer)	
#define vCoverAttach(p)	 ((p)->vCoverAttach)
#define vAddrAttach(p)	 ((p)->vAddrAttach)
#define vMetaFile(p)	 ((p)->vMetaFile)	
#define HiResolution(p)	 ((p)->HiResolution)
#define HiEncoding(p)	 ((p)->HiEncoding)		
#define CutSheetSizes(p) ((p)->CutSheetSizes)
#define fOddCutSheet(p)	 ((p)->fOddCutSheet)


#define SetBCIMAGE0(p, l, n, a, r)			\
			(((p)->GroupLength)    = (l));	\
			(((p)->GroupNum)	   = (n));	\
			(((p)->fAnyWidth)      = (a));	\
			(((p)->vRamboVer)	   = (r));

#define SetBCIMAGE2(p, c, a, m)				\
			(((p)->vCoverAttach)   = (c));	\
			(((p)->vAddrAttach)    = (a));	\
			(((p)->vMetaFile)	   = (m));

#define SetBCIMAGE3(p, r, e)   			\
			(((p)->HiResolution) = (r));	\
			(((p)->HiEncoding)   = (e));	\

#define SetBCIMAGE4(p, c)	(((p)->CutSheetSizes) = (c));

#define SetBCIMAGE5(p, c)	(((p)->fOddCutSheet) = (c));


#define fLowSpeedPoll(p)	 ((p)->fLowSpeedPoll)	
#define fHighSpeedPoll(p)	 ((p)->fHighSpeedPoll)
#define fPollByNameAvail(p)	 ((p)->fPollByNameAvail)
#define fPollByRecipAvail(p) ((p)->fPollByRecipAvail)
#define fFilePolling(p)		 ((p)->fFilePolling)		
#define fExtCapsAvail(p)	 ((p)->fExtCapsAvail)	
#define fNoShortTurn(p)	 	 ((p)->fNoShortTurn)
#define vMsgRelay(p)	 	 ((p)->vMsgRelay)
#define ExtCapsCRC(p)	 	 ((p)->ExtCapsCRC)


#define SetExtCapsCRC(p, w)	 (((p)->ExtCapsCRC) = (w))


#define SetBCPOLLCAPS0(p, l, n, lp, hp, pn, pr, pf)	\
			(((p)->GroupLength)    	 = (l));		\
			(((p)->GroupNum)	   	 = (n));		\
			(((p)->fLowSpeedPoll)    = (lp));		\
			(((p)->fHighSpeedPoll)	 = (hp));		\
			(((p)->fPollByNameAvail) = (pn));		\
			(((p)->fPollByRecipAvail)= (pr));		\
			(((p)->fFilePolling) 	 = (pf));

#define SetBCPOLLCAPS2(p, e, n, m)				\
			(((p)->fExtCapsAvail)	= (e));		\
			(((p)->fNoShortTurn)	= (n));		\
			(((p)->vMsgRelay) 		= (m));


#define NSSvMsgProtocol(p)		((p)->vMsgProtocol)
#define NSSvInteractive(p)		((p)->vInteractive)

#define SetBCNSS0(p, l, n, m, i)		 		\
			(((p)->GroupLength)    	 = (l));	\
			(((p)->GroupNum)	   	 = (n));	\
			(((p)->vMsgProtocol)   	 = (m));	\
			(((p)->vInteractive)	 = (i));	\


#define fReturnControl(p)	(((LPBCPOLLREQ)(p))->fReturnControl)
#define PollType(p)			(((LPBCPOLLREQ)(p))->PollType)
#define NamePass(p)			(((LPBCPOLLREQ)(p))->b)

#define SetBCPOLLREQ0(p, l, n, f, t) 			\
			((((LPBCPOLLREQ)(p))->GroupLength)    = (l));	\
			((((LPBCPOLLREQ)(p))->GroupNum)	      = (n));	\
			((((LPBCPOLLREQ)(p))->fReturnControl) = (f));	\
			((((LPBCPOLLREQ)(p))->PollType)       = (t));	\


#endif /** PORTABLE **/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\modemddi.h ===
/***************************************************************************
 Name     :     MODEMDDI.H
 Comment  :     Interface for Modem/NCU DDI

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/

#ifndef _MODEMDDI_
#define _MODEMDDI_


#include <ncuparm.h>

typedef struct {
        USHORT  uSize;                  // of this structure
        USHORT  uNumLines, uNumFaxModems, uNumDataModems, uNumHandsets;
        BOOL    fToneDial, fPulseDial;
} NCUCONFIG, far* LPNCUCONFIG;


/******************** Not Used *************************

typedef struct {
        USHORT uErrorCode, uErrorFlags, uExtErrorCode, uWarning;
} MODEMSTATUS, far* LPMODEMSTATUS;

#define         MODEMERR_OK                     0
#define         MODEMERR_TIMEOUT        1
#define         MODEMERR_HARDWARE       2
#define         MODEMERR_OVERRUN        3
#define         MODEMERR_DEADMAN        4
#define         MODEMERR_COMPORT        5
#define         MODEMERR_BUG            6
#define         MODEMERR_RESOURCES      7
#define         MODEMERR_BADPARAM       8

#define         MODEMERR_UNDERRUN       11
#define         MODEMERR_BADCOMMAND     12
#define         MODEMERR_BADCRC         13

#define         MODEMERRFLAGS_FATAL                     2
#define         MODEMERRFLAGS_TRANSIENT         1

#define         MODEMWARNING_UNDERRUN           1

// Tone generation etc
#define         TONE_CED        1
#define         TONE_CNG        2

**************************************************************/

typedef struct {
        USHORT  uSize, uClasses, uSendSpeeds, uRecvSpeeds;
        USHORT  uHDLCSendSpeeds, uHDLCRecvSpeeds;
} MODEMCAPS, far* LPMODEMCAPS;

// uClasses is one or more of the below
#define         FAXCLASS0               0x01
#define         FAXCLASS1               0x02
#define         FAXCLASS2               0x04
#define         FAXCLASS2_0             0x08    // Class4==0x10

// uSendSpeeds, uRecvSpeeds, uHDLCSendSpeeds and uHDLCRecvSpeeds
// are one or more of the below. If V27 is provided
// at 2400bps *only*, then V27 is *not* set
// V27 2400 (nonHDLC) is always assumed

#define V27                                     2               // V27ter capability at 4800 bps
#define V29                                     1               // V29 at 7200 & 9600 bps
#define V33                                     4               // V33 at 12000 & 14400 bps
#define V17                                     8               // V17 at 7200 thru 14400 bps
#define V27_V29_V33_V17         11              // 15 --> 11 in T30speak

// used only in selecting modulation -- not in capability
// #define V21                                  7               // V21 ch2 at 300bps
// #define V27_FALLBACK         32              // V27ter capability at 2400 bps



// various calls return & use these
//typedef         HANDLE          HLINE;
//typedef         HANDLE          HCALL;
typedef         HANDLE          HMODEM;

// NCUModemInit returns these
#define INIT_OK                         0
#define INIT_INTERNAL_ERROR     13
#define INIT_MODEMERROR         15
#define INIT_PORTBUSY           16
#define INIT_MODEMDEAD          17
#define INIT_GETCAPS_FAIL       18
#define INIT_USERCANCEL         19

// NCUCheckRing and NCUCheckHandset returns one of these
#define NCUSTATUS_IDLE                  0
#define NCUSTATUS_RINGING               1
#define NCUSTATUS_BUSY                  2
#define NCUSTATUS_OFFHOOK               3
#define NCUSTATUS_NODIALTONE    4
#define NCUSTATUS_ERROR                 5

// NCULink takes one of these flags     (mutually exclusive)
#define NCULINK_HANGUP                  0
#define NCULINK_TX                              1
#define NCULINK_RX                              2
#define NCULINK_OFFHOOK                 3
#define NCULINK_MODEMASK                0x7
// and this flag may be added along with NCULINK_RX
#define NCULINK_IMMEDIATE       16      // don't wait for NCUParams.RingsBeforeAnswer


// NCUDial(and iModemDial), NCUTxDigit, ModemConnectTx and ModemConnectRx return one of
#define         CONNECT_TIMEOUT                 0
#define         CONNECT_OK                              1
#define         CONNECT_BUSY                    2
#define         CONNECT_NOANSWER                3
#define         CONNECT_NODIALTONE              4
#define         CONNECT_ERROR                   5
#define         CONNECT_HANGUP                  6
// NCULink (and iModemAnswer) returns one of the following (or OK or ERROR)
#define CONNECT_RING_ERROR              7       // was ringing when tried NCULINK_TX
#define CONNECT_NORING_ERROR    8       // was not ringing when tried NCULINK_RX
#define CONNECT_RINGEND_ERROR   9       // stopped ringing before
                                                                        // NCUParams.RingsBeforeAnswer count was
                                                                        // was reached when tried NCULINK_RX

/////// SUPPORT FOR ADAPTIVE ANSWER ////////
#define CONNECT_WRONGMODE_DATAMODEM     10      // We're connected as a datamodem.


///////////////////////// Ricoh Only /////////////////////////////////

// ModemConnectTx() and ModemConnectRx() can take this flag.
// ModemConnectTx: When this flag is set, if it detects CED, it begins
//              transmitting 800Hz tone and immediately returns (before
//              tone transmission completes) the return value CONNECT_ESCAPE
// ModemConnectRx: When this flag is set, it enables 800Hz tone detection
//              If the tone is detected, then the return value is CONNECT_ESCAPE

#define RICOHAI_MODE                    128

// ModemConnectRx() and ModemConnectTx() can also return the following
// when 800Hz tone is detected or transmitted

#define CONNECT_ESCAPE                  128

///////////////////////// Ricoh Only /////////////////////////////////




// ModemOpen and ModemGetCaps take one of these for uType
#define         MODEM_FAX                       1
#define         MODEM_DATA                      2

// SendMode and RecvMode take one of these for uModulation
#define V21_300         7               // used an arbitary vacant slot
#define V27_2400        0
#define V27_4800        2
#define V29_9600        1
#define V29_7200        3
#define V33_14400       4
#define V33_12000       6

#define V17_START       8       // every code above this is considered V17
#define V17_14400       8
#define V17_12000       10
#define V17_9600        9
#define V17_7200        11

#define ST_FLAG                 0x10
#define V17_14400_ST    (V17_14400 | ST_FLAG)
#define V17_12000_ST    (V17_12000 | ST_FLAG)
#define V17_9600_ST             (V17_9600 | ST_FLAG)
#define V17_7200_ST             (V17_7200 | ST_FLAG)


// SendMem take one one or more of these for uFlags
// SEND_ENDFRAME must _always_ be TRUE in HDLC mode
// (partial frames are no longer supported)
#define SEND_FINAL                      1
#define SEND_ENDFRAME           2
// #define SEND_STUFF                   4

// RecvMem and RecvMode return one these
#define RECV_OK                                 0
#define RECV_ERROR                              1
#define RECV_TIMEOUT                    2
#define RECV_WRONGMODE                  3       // only Recvmode returns this
#define RECV_EOF                                8
#define RECV_BADFRAME                   16


// Min modem recv buffer size. Used for all recvs
// For IFAX30: *All* RecvMem calls will be called with exactly this size
#define MIN_RECVBUFSIZE                 265

// Max phone number size passed into NCUDial
#define MAX_PHONENUM_LEN        60




/**-- may be used in ModemSendMode ----**/
#define         ifrDIS          1
#define         ifrCSI          2
#define         ifrNSF          3
#define         ifrDTC          4
#define         ifrCIG          5
#define         ifrNSC          6
#define         ifrDCS          7
#define         ifrTSI          8
#define         ifrNSS          9
#define         ifrCFR          10
#define         ifrFTT          11
#define         ifrMPS          12
#define         ifrEOM          13
#define         ifrEOP          14
#define         ifrPWD          15
#define         ifrSEP          16
#define         ifrSUB          17
#define         ifrMCF          18
#define         ifrRTP          19
#define         ifrRTN          20
#define         ifrPIP          21
#define         ifrPIN          22
#define         ifrDCN          23
#define         ifrCRP          24
#define         ifrPRI_MPS      25
#define         ifrPRI_EOM      26
#define         ifrPRI_EOP      27
#define         ifrCTC          28
#define         ifrCTR          29
#define         ifrRR           30
#define         ifrPPR          31
#define         ifrRNR          32
#define         ifrERR          33
#define         ifrPPS_NULL             34
#define         ifrPPS_MPS              35
#define         ifrPPS_EOM              36
#define         ifrPPS_EOP              37
#define         ifrPPS_PRI_MPS  38
#define         ifrPPS_PRI_EOM  39
#define         ifrPPS_PRI_EOP  40
#define         ifrEOR_NULL             41
#define         ifrEOR_MPS              42
#define         ifrEOR_EOM              43
#define         ifrEOR_EOP              44
#define         ifrEOR_PRI_MPS  45
#define         ifrEOR_PRI_EOM  46
#define         ifrEOR_PRI_EOP  47

// don't use these values
// #define              ifrMAX          48
// #define              ifrBAD          49
// #define              ifrTIMEOUT      50
// #define              ifrERROR        51

/**-- may be used in ModemSendMode and ModemRecvMode ----**/
#define         ifrTCF                  55
// #define              ifrPIX          56      // not used anymore
#define         ifrECMPIX               57
#define         ifrPIX_MH               67
#define         ifrPIX_MR               68
#define         ifrPIX_SWECM    69

/**-- may be used in ModemRecvMode ----**/
// each value corresponds to one of the "Response Recvd" and
// "Command Recvd" boxes in the T30 flowchart.

#define         ifrPHASEBresponse       58              // receiver PhaseB
#define         ifrTCFresponse          59              // sender after sending TCF
#define         ifrPOSTPAGEresponse     60              // sender after sending MPS/EOM/EOP
#define         ifrPPSresponse          61              // sender after sending PPS-Q
#define         ifrCTCresponse          62              // sender after sending RR
#define         ifrRRresponse           63              // sender after sending RR

#define         ifrPHASEBcommand        64              // sender PhaseB
#define         ifrNODEFcommand         65              // receiver main loop (Node F)
#define         ifrRNRcommand           66              // receiver after sending RNR

#define         ifrEORresponse                  70
#define         ifrNODEFafterWRONGMODE  71      // hint for RecvMode after WRONGMODE
#define         ifrEOFfromRECVMODE              72      // GetCmdResp retval if RecvMode returns EOF
#define         ifrEND          73      // Max legal values (not incl this one)


// messages posted by NCUHandsetNotif and NCURingNotif

#define IF_MODEM_START  (IF_START+0x321)
#define IF_MODEM_END    (IF_START+0x325)

#define IF_NCU_RING             (IF_MODEM_START + 0x00)
#define IF_NCU_HANDSET  (IF_MODEM_START + 0x01)



#endif //_MODEMDDI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\oemint.h ===
#ifdef OEMNSF
#	include <oemnsf.h>

	extern LPFN_OEM_STARTCALL	lpfnOEMStartCall;
	extern LPFN_OEM_ENDCALL		lpfnOEMEndCall;
	extern LPFN_OEM_NSXTOBC		lpfnOEMNSxToBC;
	extern LPFN_OEM_CREATEFRAME	lpfnOEMCreateFrame;
	extern LPFN_OEM_NEXTACTION	lpfnOEMNextAction;
	extern LPFN_OEM_GETBAUDRATE lpfnOEMGetBaudRate;
	extern LPFN_OEM_INITNSF		lpfnOEMInitNSF;
	extern LPFN_OEM_DEINITNSF	lpfnOEMDeInitNSF;

	extern WORD					wOEMFlags;
	extern WORD					wLenOEMID;
	extern BYTE					rgbOEMID[];
	extern BOOL					fUsingOEMProt;

#	ifdef RICOHAI
#	include <ricohai.h>

		extern LPFN_RICOHAISTARTTX	lpfnRicohAIStartTx;
		extern LPFN_RICOHAIENDTX	lpfnRicohAIEndTx;
		extern LPFN_RICOHAISTARTRX	lpfnRicohAIStartRx;
		extern BOOL					fUsingRicohAI;
#	endif //RICOHAI
#endif //OEMNSF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\prep.h ===
#include "defs.h"


#include <ifaxos.h>

#include <awnsfapi.h>
#include <awnsfint.h>

#include "stdio.h"
#include "stdlib.h"

#include <memory.h>

#include "tchar.h"


#include "mysched.h"

#include <filet30.h>
#include <dosio.h>


#include "tipes.h"
#include "et30type.h"
#include "tapi.h"

#include "modemddi.h"
#include "protapi.h"

#include <faxdev.h>
#include "faxutil.h"


#include "timeouts.h"
#include "mon.h"

#include "root.h"

#include "class2.h"

#include "..\..\..\tiff\inc\tifflib.h"
#include "global.h"

#include "fcomapi.h"

#include "rl_debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\phonenum.h ===
#define COUNTRY_CODE_SIZE		10
#define AREA_CODE_SIZE			10
#define TELEPHONE_NUMBER_SIZE	50
#define ROUTING_NAME_SIZE		150
#define CANONICAL_NUMBER_SIZE	(10+COUNTRY_CODE_SIZE+AREA_CODE_SIZE+TELEPHONE_NUMBER_SIZE+ROUTING_NAME_SIZE)

typedef struct tagPARSEDTELNUMBER
{
    TCHAR  szCountryCode[COUNTRY_CODE_SIZE+1];               // country code
    TCHAR  szAreaCode[AREA_CODE_SIZE+1];                     // area code
    TCHAR  szTelNumber[TELEPHONE_NUMBER_SIZE+1];             // telephone number
    TCHAR  szRoutingName[ROUTING_NAME_SIZE+1];               // routing name within the tel number destination
} PARSEDTELNUMBER, *LPPARSEDTELNUMBER;

BOOL   EncodeFaxAddress(LPTSTR lpszFaxAddr, LPPARSEDTELNUMBER lpParsedFaxAddr);
BOOL   DecodeFaxAddress(LPTSTR lpszFaxAddr, LPPARSEDTELNUMBER lpParsedFaxAddr);

/*
 * Function pointer prototypes for fax config functions
 */
typedef BOOL (* PFN_DECODE_FAX_ADDRESS)(LPTSTR lpszFaxAddr, LPPARSEDTELNUMBER lpParsedFaxAddr);
typedef BOOL (* PFN_ENCODE_FAX_ADDRESS)(LPTSTR lpszFaxAddr, LPPARSEDTELNUMBER lpParsedFaxAddr);

#define FAXCFG_DECODE_FAX_ADDRESS   TEXT("DecodeFaxAddress")
#define FAXCFG_ENCODE_FAX_ADDRESS   TEXT("EncodeFaxAddress")
#define FAXCFG_DLL                  TEXT("awfxcg32.dll")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\protapi.h ===
/***************************************************************************
 Name     :     PROTAPI.H
 Comment  : Interface to Protocol DLL

        Copyright (c) Microsoft Corp. 1991, 1992, 1993

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/

#include "protparm.h"

// #define MAXNSFSIZE           40
// #define MAXSEPPWDSIZE        60





#define GET_SEND_MOD                    1
#define GET_RECV_MOD                    2
#define GET_ECM_FRAMESIZE               3
#define GET_PPR_FIF                             4
#define GET_WHATNEXT                    5
#define GET_MINBYTESPERLINE     6
#define RECEIVING_ECM                   7
#define GET_RECV_ECM_FRAMESIZE  8
#define GET_RECVECMFRAMECOUNT   10
#define RESET_RECVECMFRAMECOUNT 11
#define RESET_RECVPAGEACK               12
#define GET_PPS                                 15
#define GET_SEND_ENCODING               16
#define GET_RECV_ENCODING               17


// MUST match MSG_ flags in SOCKET.H
#       define NEXTSEND_MPS                     0x100
#       define NEXTSEND_EOM                     0x200
#       define NEXTSEND_EOP                     0x400
#       define NEXTSEND_ERROR           0x800




#define MINSCAN_0_0_0           7
#define MINSCAN_5_5_5           1
#define MINSCAN_10_10_10        2
#define MINSCAN_20_20_20        0
#define MINSCAN_40_40_40        4

#define MINSCAN_40_20_20        5
#define MINSCAN_20_10_10        3
#define MINSCAN_10_5_5          6

// #define MINSCAN_0_0_?                15              // illegal
// #define MINSCAN_5_5_?                9               // illegal
#define MINSCAN_10_10_5                 10
#define MINSCAN_20_20_10                8
#define MINSCAN_40_40_20                12

#define MINSCAN_40_20_10                13
#define MINSCAN_20_10_5                 11
// #define MINSCAN_10_5_?               14              // illegal
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\protparm.h ===
#ifndef _PROTPARAMS_
#define _PROTPARAMS_


// initial defaults for all settings in braces at end

typedef struct
{
  USHORT uSize;	// size of this structure

  SHORT	IgnoreDIS;				// Num DISs to ignore (set to 1 on echoey satelite lines) [0]
  SHORT	TrainingErrorTolerance;	// 0 to 4 (0=infinite tolerance, 4=very picky) [2]
  SHORT	RecvG3ErrorTolerance;	// 0 to 4 (0=infinite tolerance, 4=very picky) [2]
  SHORT	PadRCP;					// T/F (Fill out RCP to full frame size. Affects G3 only) [0]

  SHORT	HighestSendSpeed; // 2400/4800/7200/9600/12000/14400 [0 == highest avail]
  SHORT	LowestSendSpeed;  // 2400/4800/7200/9600/12000/14400 [0 == lowest avail]
  SHORT	DisableSendECM;	  // T/F (affects ALL sends. Will disable At Work prot & MMR) [0]
  SHORT	Send64ByteECM;	  // T/F (use smaller frames on send) [0]

  SHORT	HighestRecvSpeed; // 2400/4800/7200/9600/12000/14400 [0 == highest avail]
  SHORT	DisableRecvECM;	  // (affects G3 and BFT--recv MMR & BFT are disabled) [0]
  SHORT	Recv64ByteECM;	  // T/F (use smaller frames on recv) [0]


  BOOL	fEnableV17Send;	  // enable V17 (12k/14k) send speeds [1]
  BOOL	fEnableV17Recv;	  // enable V17 (12k/14k) recv speeds [1]
  USHORT uMinScan;		  // determined by printer speed      [MINSCAN_0_0_0]

  SHORT SendT1Timer;	// T1 timer on send (in secs) [0==default]
  SHORT RecvT1Timer;	// T1 timer on recv (in secs) [0==default]

  SHORT RTNAction;		// 0=dropspeed 1=samespeed 2=hangup [0==default]
  SHORT CTCAction;		// 0=dropspeed 1=hangup	   2=TBD	[0==default]

  USHORT EnableG3SendECM;		// enables ECM for MH & MR [0]
  USHORT CopyQualityCheckLevel;	// how strictly to check [0=off 2=default 4=strict]
}
PROTPARAMS, far* LPPROTPARAMS;


#define MIN_CALL_SEPERATION		10000L	 // to be added to the PROTPARMS struct
// #define RECOVERY_RECIPIENT		"System" // not needed anymore--dont add to SOS

    
#define MINSCAN_0_0_0		7
#define MINSCAN_5_5_5		1
#define MINSCAN_10_10_10	2
#define MINSCAN_20_20_20	0
#define MINSCAN_40_40_40	4

#define MINSCAN_40_20_20	5
#define MINSCAN_20_10_10	3
#define MINSCAN_10_5_5		6

// #define MINSCAN_0_0_?		15		// illegal
// #define MINSCAN_5_5_?		9		// illegal
#define MINSCAN_10_10_5			10
#define MINSCAN_20_20_10		8
#define MINSCAN_40_40_20		12

#define MINSCAN_40_20_10		13
#define MINSCAN_20_10_5			11
// #define MINSCAN_10_5_?		14		// illegal



#endif //_PROTPARAMS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\psibg.h ===
#define IF_PSIBG_INIT  		IF_PSIBG_START + 0x001
#define IF_PSIBG_CALL  		IF_PSIBG_START + 0x002
#define IF_PSIBG_ANSWER		IF_PSIBG_START + 0x003
#define IF_PSIBG_LISTEN		IF_PSIBG_START + 0x004
#define IF_PSIBG_HANDSET	IF_PSIBG_START + 0x005
#define IF_PSIBG_ONHOOKDIAL		IF_PSIBG_START + 0x006
#define IF_PSIBG_LINESTATEWND	IF_PSIBG_START + 0x007

#define OHD_START	0x0000	// values for IF_PSIBG_ONHOOKDIAL
#define OHD_END		0xFFFF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\pollenc.h ===
#ifndef NOCHALL
// eliminate PollChallenge stuff

#ifdef UNIX

typedef unsigned long DWORD;
typedef unsigned short WORD;
typedef unsigned char BYTE;
#define WINAPI
#define FAR

#else /* Windows 16 and 32 bit */

#endif

/* Returns 0 for failure, length of wLenOutput used on success */
/* Encrypts challenge with password */
/* wLenChallenge and wLenPassword must be >= 1 */
/* wLenOutput must be >= wLenChallenge */
WORD WINAPI PollEnc(LPBYTE lpbChallenge, WORD wLenChallenge,
		    LPBYTE lpbPassword, WORD wLenPassword,
		    LPBYTE lpbOutput, WORD wLenOutput);


#define PollPassToChallResp(lpbCh, wCh, lpbPas, wPas, lpbOut, wMaxOut)	\
	((!(lpbCh) || !(lpbPas) || !(lpbOut) || !(wCh) || !(wPas) || (wMaxOut)<(wCh)) ? \
		(DEBUGCHK(FALSE), 0) : 										 	\
		PollEnc((lpbCh), (wCh), (lpbPas), (wPas), (lpbOut), (wMaxOut)))

#define ArulsPollPassToChallResp(lpbCh, wCh, lpbPas, wPas, lpbOut, wMaxOut)	\
	((!(lpbCh) || !(lpbPas) || !(lpbOut) || !(wCh) || !(wPas) || (wMaxOut)<(wCh)) ? \
		(BG_CHK(FALSE), 0) : 										 	\
		PollEnc((lpbCh), (wCh), (lpbPas), (wPas), (lpbOut), (wMaxOut)))

#endif //!NOCHALL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\protdump.h ===
//////////////////////// Protocol Dump APIs ////////////////////////////

#ifdef PDUMP    // Protocol Dump





//macros defined to access fields of the protocol dump
#define GETPROTDUMPFRAME(lpprotdump,i)  \
        ((LPFR)(((LPBYTE)(lpprotdump->b)) + lpprotdump->uFrameOff[i]))  \

#define ISSENDFRAME(lpfr)       \
                ((lpfr->ifr & 0x80))

#define GETFCF(lpfr,lpszBuf)    \
                (wsprintf(lpszBuf,              \
                (LPSTR)(rgszFrName[lpfr->ifr & 0x7F])))

#define GETFIF(lpfr,lpszBuf)    \
{       \
        int j;  \
        *lpszBuf = '\0';                \
        for(j=0;j<lpfr->cb;j++) \
                lpszBuf += wsprintf(lpszBuf,"%02x",(WORD)lpfr->fif[j]); \
}


///////// Sample Code for walking & printing Protocol Dump ////////
//
// void PrintDump(LPPROTDUMP lpprotdump)
// {
//      int i, j;
//
//      RETAILMSG((SZMOD "-*-*-*-*-*-*-*-* Print Protocol Dump -*-*-*-*-*-*-*-*-\r\n"));
//
//      for(i=0; i<(int)lpprotdump->uNumFrames; i++)
//      {
//              LPFR lpfr = (LPFR) (((LPBYTE)(lpprotdump->b)) + lpprotdump->uFrameOff[i]);
//              IFR  ifr = (lpfr->ifr & 0x7F);
//              BOOL fSend = (lpfr->ifr & 0x80);
//
//              BG_CHK(ifr <= ifrMAX);
//              RETAILMSG((SZMOD "%s: %s [ ",
//                                      (LPSTR)(fSend ? "Sent" : "Recvd"),
//                                      (LPSTR)(rgszFrName[ifr]) ));
//
//              for(j=0; j<lpfr->cb; j++)
//                      RETAILMSG(("%02x ", (WORD)lpfr->fif[j]));
//
//              RETAILMSG(("]\r\n"));
//      }
//
//      RETAILMSG((SZMOD "-*-*-*-*-*-*-*-* End Protocol Dump -*-*-*-*-*-*-*-*-\r\n"));
// }
//
///////////////////////////////////////////////////////////////////



#ifdef DEFINE_FRNAME_ARRAY

#define ifrMAX                  48

LPSTR rgszFrName[ifrMAX] = {
#define         ifrNULL         0
                                                        "???",
#define         ifrDIS          1
                                                        "DIS",
#define         ifrCSI          2
                                                        "CSI",
#define         ifrNSF          3
                                                        "NSF",
#define         ifrDTC          4
                                                        "DTC",
#define         ifrCIG          5
                                                        "CIG",
#define         ifrNSC          6
                                                        "NSC",
#define         ifrDCS          7
                                                        "DCS",
#define         ifrTSI          8
                                                        "TSI",
#define         ifrNSS          9
                                                        "NSS",
#define         ifrCFR          10
                                                        "CFR",
#define         ifrFTT          11
                                                        "FTT",
#define         ifrMPS          12
                                                        "MPS",
#define         ifrEOM          13
                                                        "EOM",
#define         ifrEOP          14
                                                        "EOP",
#define         ifrPWD          15
                                                        "PWD",
#define         ifrSEP          16
                                                        "SEP",
#define         ifrSUB          17
                                                        "SUB",
#define         ifrMCF          18
                                                        "MCF",
#define         ifrRTP          19
                                                        "RTP",
#define         ifrRTN          20
                                                        "RTN",
#define         ifrPIP          21
                                                        "PIP",
#define         ifrPIN          22
                                                        "PIN",
#define         ifrDCN          23
                                                        "DCN",
#define         ifrCRP          24
                                                        "CRP",
#define         ifrPRI_MPS      25
                                                        "PRI_MPS",
#define         ifrPRI_EOM      26
                                                        "PRI_EOM",
#define         ifrPRI_EOP      27
                                                        "PRI_EOP",
#define         ifrCTC          28
                                                        "CTC",
#define         ifrCTR          29
                                                        "CTR",
#define         ifrRR           30
                                                        "RR" ,
#define         ifrPPR          31
                                                        "PPR",
#define         ifrRNR          32
                                                        "RNR",
#define         ifrERR          33
                                                        "ERR",
#define ifrPPS_NULL     34
                                                         "PPS-NULL",
#define ifrPPS_MPS      35
                                                         "PPS-MPS",
#define ifrPPS_EOM      36
                                                         "PPS-EOM",
#define ifrPPS_EOP      37
                                                         "PPS-EOP",
#define ifrPPS_PRI_MPS  38
                                                         "PPS-PRI-MPS",
#define ifrPPS_PRI_EOM  39
                                                         "PPS-PRI-EOM",
#define ifrPPS_PRI_EOP  40
                                                         "PPS-PRI-EOP",
#define ifrEOR_NULL     41
                                                         "EOR-NULL",
#define ifrEOR_MPS      42
                                                         "EOR-MPS",
#define ifrEOR_EOM      43
                                                         "EOR-EOM",
#define ifrEOR_EOP      44
                                                         "EOR-EOP",
#define ifrEOR_PRI_MPS  45
                                                         "EOR-PRI-MPS",
#define ifrEOR_PRI_EOM  46
                                                         "EOR-PRI-EOM",
#define ifrEOR_PRI_EOP  47
                                                         "EOR-PRI-EOP"
#define ifrMAX                  48
};

#endif //DEFINE_FRNAME_ARRAY

#endif //PDUMP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\property.h ===
/***************************************************************************

        Name      : property.h

        Comment   : Defines the properties used by Microsoft Fax

        Created   : 10/93, from the list of WFW fax properties

        Author(s) : Bruce Kelley and Yoram Yaacovi

        Contribs  :

        Changes   : 8/2/95: documented

        Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.

***************************************************************************/
/*
    @doc    EXTERNAL    MAPI Properties    OVERVIEW

    @topic  Overview of MAPI Properties | Below you will find the list of properties that were
            defined and are being used by Microsoft Fax. These properties
            are defined in the MAPI respective ranges.<nl>
			 <nl>
			 <t PR_AREA_CODE>,<nl>
			 <t PR_ATTACH_SIGNATURE>,<nl>
			 <t PR_COUNTRY_ID>,<nl>
			 <t PR_FAX_ACTIVE_MODEM_NAME>,<nl>
			 <t PR_FAX_BGN_MSG_ON_COVER>,<nl>
			 <t PR_FAX_BILLING_CODE>,<nl>
			 <t PR_FAX_BILLING_CODE_DWORD>,<nl>
			 <t PR_FAX_CALL_CARD_NAME>,<nl>
			 <t PR_FAX_CHEAP_BEGIN_HOUR>,<nl>
			 <t PR_FAX_CHEAP_BEGIN_MINUTE>,<nl>
			 <t PR_FAX_CHEAP_END_HOUR>,<nl>
			 <t PR_FAX_CHEAP_END_MINUTE>,<nl>
			 <t PR_FAX_COVER_PAGE_BODY>,<nl>
			 <t PR_FAX_CP_NAME>,<nl>
			 <t PR_FAX_DEFAULT_COVER_PAGE>,<nl>
			 <t PR_FAX_DELIVERY_FORMAT>,<nl>
			 <t PR_FAX_DISPLAY_PROGRESS>,<nl>
			 <t PR_FAX_EMBED_LINKED_OBJECTS>,<nl>
			 <t PR_FAX_ENABLE_RECIPIENT_OPTIONS>,<nl>
			 <t PR_FAX_ENCRYPTION_KEY>,<nl>
			 <t PR_FAX_FAXJOB>,<nl>
			 <t PR_FAX_IMAGE>,<nl>
			 <t PR_FAX_IMAGE_QUALITY>,<nl>
			 <t PR_FAX_INCLUDE_COVER_PAGE>,<nl>
			 <t PR_FAX_LMI_CUSTOM_OPTION>,<nl>
			 <t PR_FAX_LOGO_STRING>,<nl>
			 <t PR_FAX_LOG_ENABLE>,<nl>
			 <t PR_FAX_LOG_NUM_OF_CALLS>,<nl>
			 <t PR_FAX_MAX_TIME_TO_WAIT>,<nl>
			 <t PR_FAX_MINUTES_BETWEEN_RETRIES>,<nl>
			 <t PR_FAX_MUST_RENDER_ALL_ATTACH>,<nl>
			 <t PR_FAX_NETFAX_DEVICES>,<nl>
			 <t PR_FAX_NOT_EARLIER_DATE>,<nl>
			 <t PR_FAX_NOT_EARLIER_HOUR>,<nl>
			 <t PR_FAX_NOT_EARLIER_MINUTE>,<nl>
			 <t PR_FAX_NUMBER_RETRIES>,<nl>
			 <t PR_FAX_PAPER_SIZE>,<nl>
			 <t PR_FAX_PREVIOUS_STATE>,<nl>
			 <t PR_FAX_PREV_BILLING_CODES>,<nl>
			 <t PR_FAX_PRINT_HEADER>,<nl>
			 <t PR_FAX_PRINT_ORIENTATION>,<nl>
			 <t PR_FAX_PRINT_TO_NAME>,<nl>
			 <t PR_FAX_PRINT_TO_PAGES>,<nl>
			 <t PR_FAX_PRODUCT_NAME>,<nl>
			 <t PR_FAX_PROFILE_VERSION>,<nl>
			 <t PR_FAX_RBA_DATA>,<nl>
			 <t PR_FAX_RECIP_CAPABILITIES>,<nl>
			 <t PR_FAX_SECURITY_RECEIVED>,<nl>
			 <t PR_FAX_SECURITY_SEND>,<nl>
			 <t PR_FAX_SENDER_COUNTRY_ID>,<nl>
			 <t PR_FAX_SENDER_EMAIL_ADDRESS>,<nl>
			 <t PR_FAX_SENDER_NAME>,<nl>
			 <t PR_FAX_SEND_WHEN_TYPE>,<nl>
			 <t PR_FAX_SHARE_DEVICE>,<nl>
			 <t PR_FAX_SHARE_NAME>,<nl>
			 <t PR_FAX_SHARE_PATHNAME>,<nl>
			 <t PR_FAX_TAPI_LOC_ID>,<nl>
			 <t PR_FAX_WORK_OFF_LINE>,<nl>
			 <t PR_HOP_INDEX>,<nl>
			 <t PR_MAILBOX>,<nl>
			 <t PR_MESSAGE_TYPE>,<nl>
			 <t PR_POLLTYPE>,<nl>
			 <t PR_POLL_RETRIEVE_PASSWORD>,<nl>
			 <t PR_POLL_RETRIEVE_SENDME>,<nl>
			 <t PR_POLL_RETRIEVE_TITLE>,<nl>
			 <t PR_RECIP_INDEX>,<nl>
			 <t PR_RECIP_VOICENUM>,<nl>
			 <t PR_TEL_NUMBER>
		 
    @xref <nl>
        <t MAPI Property Ranges>,<nl> 
        <t Microsoft Fax Property Ranges>,<nl> 
        <t Microsoft Fax Address Type>,<nl> 
        <t Microsoft Fax Options>,<nl> 
        <t Fax Address Book Internal Properties>,<nl> 
        <t Scheduling Properties>,<nl> 
        <t Retry Properties>,<nl> 
        <t Cover Page Properties>,<nl> 
        <t Delivery Format Properties>,<nl> 
        <t Fax Transport Identification Properties>,<nl> 
        <t Fax Internal Properties>,<nl> 
        <t Fax Billing Code Properties>,<nl> 
        <t Fax Logging Properties>,<nl> 
        <t Fax Security Properties>,<nl>
        <t Fax Poll Retrieval Properties>,<nl> 
        <t Miscellaneous IFAX Properties>
*/

#define TRANSPORT_ENVELOPE_BASE             0x4000
#define TRANSPORT_RECIP_BASE                0x5800
#define USER_NON_TRANSMIT_BASE              0x6000
#define PROVIDER_INTERNAL_NON_TRANSMIT_BASE 0x6600
#define MESSAGE_CLASS_CONTENT_BASE          0x6800
#define MESSAGE_CLASS_NON_TRANSMIT_BASE     0x7C00

/*
    @doc EXTERNAL   PROPERTIES

    @subtopic  MAPI Property Ranges | The list below was taken from
            mapitags.h in the MAPI SDK. It represents the property ranges
            as defined by MAPI.

        From		To	Kind of property<nl>
        ----------------------------------------------------------<nl>
        0001	0BFF	MAPI_defined envelope property<nl>
        0C00	0DFF	MAPI_defined per-recipient property<nl>
        0E00	0FFF	MAPI_defined non-transmittable property<nl>
        1000	2FFF	MAPI_defined message content property<nl>
        3000	3FFF	MAPI_defined property (usually not message or
                       recipient)<nl>
        4000	57FF	Transport-defined envelope property<nl>
        5800	5FFF	Transport-defined per-recipient property<nl>
        6000	65FF	User-defined non-transmittable property<nl>
        6600	67FF	Provider-defined internal non-transmittable
                        property<nl>
        6800	7BFF	Message class-defined content property<nl>
        7C00	7FFF	Message class-defined non-transmittable
                        property<nl>
        8000	FFFE	User-defined Name-to-id mapped property<nl>

        The 3000-3FFF range is further subdivided as follows:<nl>

        From		To	Kind of property<nl>
        ------------------------------------------------------------<nl>
        3000	33FF	Common property such as display name, entry ID<nl>
        3400	35FF	Message store object<nl>
        3600	36FF	Folder or AB container<nl>
        3700	38FF	Attachment<nl>
        3900	39FF	Address book object<nl>
        3A00	3BFF	Mail user<nl>
        3C00	3CFF	Distribution list<nl>
        3D00	3DFF	Profile section<nl>
        3E00	3FFF	Status object

    @subtopic  Microsoft Fax Property Ranges | Microsoft Fax further defines
            property ranges within the MAPI property ranges in which the
            fax properties are defined. Some offset off the MAPI property
            range was used to reduce the possibility of collision with
            properties defined by other MAPI transports.<nl>

            EFAX_MESSAGE_BASE:<nl>
			 Starting property ID for fax message properties<nl>

			 EFAX_RECIPIENT_BASE:<nl>
			 Starting property ID for fax recipient properties<nl>

            EFAX_OPTIONS_BASE:<nl>
			 Starting property ID for fax properties (options) which
			 are not transmittable. These properties are used for fax
			 setup and are not message or recipient related.
			 Example: current active fax device.
*/

#define EFAX_MESSAGE_BASE      TRANSPORT_ENVELOPE_BASE + 0x500
#define EFAX_RECIPIENT_BASE    TRANSPORT_RECIP_BASE + 0x100
#define EFAX_OPTIONS_BASE      PROVIDER_INTERNAL_NON_TRANSMIT_BASE + 0x100

/*
    @doc EXTERNAL   PROPERTIES
    @subtopic  Microsoft Fax Address Type | Microsoft Fax's address type is "FAX".
            It has major importance, in the sense that the Microsoft Fax
            transport will only handle recipients that have this address
            type in their PR_ADDRTYPE.
*/
#define EFAX_ADDR_TYPE                      "FAX"

/*
    @doc EXTERNAL   PROPERTIES
    @subtopic  Microsoft Fax Options | Microsoft Fax defines some properties
		 that control the way the fax product operates. These properties
		 are mostly fax configuration properties and are stored in the
		 fax transport section in the MAPI profile.<nl>
		 <nl>
		 <t PR_FAX_ACTIVE_MODEM_NAME><nl>
		 <t PR_FAX_WORK_OFF_LINE><nl>
		 <t PR_FAX_SHARE_DEVICE><nl>
		 <t PR_FAX_SHARE_NAME><nl>
		 <t PR_FAX_SENDER_COUNTRY_ID><nl>
		 <t PR_FAX_NETFAX_DEVICES><nl>
		 <t PR_FAX_SHARE_PATHNAME><nl>
		 <t Scheduling Properties><nl>
		 <t Retry Properties><nl>
		 <t Cover Page Properties><nl>
		 <t Delivery Format Properties><nl>
		 <t PR_FAX_BGN_MSG_ON_COVER><nl>
		 <t PR_FAX_TAPI_LOC_ID><nl>
		 <t Fax Security Properties><nl> 
		 <t Fax Poll Retrieval Properties>
*/

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_PRODUCT_NAME |
        Name of the fax product. Used for profile validity
        verification.
    @comm Settable through UI: Yes
*/
#define PR_FAX_PRODUCT_NAME     PROP_TAG(PT_TSTRING, (EFAX_OPTIONS_BASE + 0x0))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_ACTIVE_MODEM_NAME |
        Name of the currently active faxing device. There can be
        only one active fax device at a time.  The name has the
        following format:<nl>
                <lt>name-or-identifier<gt>:<lt>DLL-name<gt><nl>
				 <nl>
        Where:<nl>
                <lt>name-or-identifier<gt> is the name of the active
                    device.  The name can be anything, and is
                    meaningful only for the LMI provider that
                    handles this device.<nl>
				 <nl>
                <lt>DLL-name<gt> is the name of the DLL that handles
                    this device. This DLL must export the LMI
                    interface. See the LMI doc for details.<nl>
    @ex When the active device is a netfax device, the
        name will be something like: |
                    \\faxserver\netfax:awnfax32.dll
    @comm Settable through UI: Yes
*/
#define PR_FAX_ACTIVE_MODEM_NAME            PROP_TAG(PT_TSTRING, (EFAX_OPTIONS_BASE + 0x1))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_WORK_OFF_LINE |
        If TRUE, the Microsoft Fax transport will work offline,
        i.e. it will not kick off the LMI provider for the active
        fax device.
    @comm Settable through UI: No
*/
#define PR_FAX_WORK_OFF_LINE                PROP_TAG(PT_BOOLEAN, (EFAX_OPTIONS_BASE + 0x2))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_SHARE_DEVICE |
        If TRUE, the user selected to share his active fax
        device so that others can fax through it.
    @comm Settable through UI: Yes
*/
#define PR_FAX_SHARE_DEVICE                 PROP_TAG(PT_BOOLEAN, (EFAX_OPTIONS_BASE + 0x3))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_SHARE_NAME |
        If sharing is enabled, this is the name of the share
        that users will use to connect and send faxes through
        the active fax device on this machine.
    @comm Settable through UI: Yes
*/
#define PR_FAX_SHARE_NAME                   PROP_TAG(PT_TSTRING, (EFAX_OPTIONS_BASE + 0x4))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_SENDER_COUNTRY_ID |
        This property is used internally by the fax
        configuration code to store the country ID of the sender.
        There is no guarantee that this property will have the
        appropriate country ID in the profile.
    @comm Settable through UI: No
*/
#define PR_FAX_SENDER_COUNTRY_ID            PROP_TAG(PT_LONG,    (EFAX_OPTIONS_BASE + 0x5))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_NETFAX_DEVICES |
        The name of this property is somewhat misleading. This
        property is a MAPI multi-value property that stores the
        names of the "other" devices the user added to his list
        of available devices. These "other" devices include,
        but are not limited to, netfax devices.
    @comm Settable through UI: Yes
*/
#define PR_FAX_NETFAX_DEVICES               PROP_TAG(PT_MV_STRING8, (EFAX_OPTIONS_BASE + 0x6))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_SHARE_PATHNAME |
        Pathname of the shared fax directory on the sharing
        machine. Don't confuse this with the share name,
        PR_FAX_SHARE_NAME; this is the full pathname to the
        shared directory on the sharing machine, and not the
        name clients will use to connect to this share.
    @comm Settable through UI: No
*/
#define PR_FAX_SHARE_PATHNAME               PROP_TAG(PT_TSTRING, (EFAX_OPTIONS_BASE + 0x7))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_PROFILE_VERSION |
        The version of the Microsoft Fax transport section in
        the MAPI profile.  Set to 0x00000001 in Windows 95.
    @comm Settable through UI: No
*/
#define PR_FAX_PROFILE_VERSION              PROP_TAG(PT_LONG, (EFAX_OPTIONS_BASE + 0x8))

/*
    @doc EXTERNAL   PROPERTIES
    @subtopic  Fax Address Book Internal Properties | These properties
        are used internally by the fax address book provider to
        store the components of a fax address in the wrapped
        fax address book entry.<nl>
        <t PR_MAILBOX><nl>
        <t PR_COUNTRY_ID><nl>
        <t PR_AREA_CODE><nl>
        <t PR_TEL_NUMBER>
    @comm These should probably have been offsets off EFAX_OPTIONS_BASE, but it's
        too late to change now.
    @comm Settable through UI: Yes<nl>
*/
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_COUNTRY_ID |
        The user's return fax number country code.
    @comm Settable through UI: Yes
*/
#define PR_COUNTRY_ID                       PROP_TAG(PT_LONG,PROVIDER_INTERNAL_NON_TRANSMIT_BASE + 0x7)
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_AREA_CODE |
        The user's return fax number area code.
    @comm Settable through UI: Yes
*/
#define PR_AREA_CODE                        PROP_TAG(PT_STRING8,PROVIDER_INTERNAL_NON_TRANSMIT_BASE + 0x8)
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_TEL_NUMBER |
        The user's return fax number.
    @comm Settable through UI: Yes
*/
#define PR_TEL_NUMBER                       PROP_TAG(PT_STRING8,PROVIDER_INTERNAL_NON_TRANSMIT_BASE + 0x9)
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_MAILBOX |
        A routing mailbox for the user's return fax number.
    @comm Settable through UI: Yes
*/
#define PR_MAILBOX                          PROP_TAG(PT_STRING8,PROVIDER_INTERNAL_NON_TRANSMIT_BASE + 0xa)

//
// Non-Transmittable message properties
//

/*
    @doc EXTERNAL   PROPERTIES
    @subtopic Scheduling Properties | These properties are used to specify
        the cheap times or the time to send.  The hour goes in the HOUR
        property, the MINUTE goes into the MINUTE property.  If you set
        PR_FAX_CHEAP_BEGIN_* you must also set PR_FAX_CHEAP_END_*.
        PR_FAX_NOT_EARLIER_DATE is currently not used.  Setting
        PR_FAX_SEND_WHEN_TYPE determines which of these properties to
        use.  If it is set to SEND_ASAP or is absent, they are all
        ignored.  If it is set to SEND_CHEAP, we will use the
        PR_FAX_CHEAP_* properties.  If it is set to SEND_AT_TIME, we
        will use PR_FAX_NOT_EARLIER_*.<nl>
            <t PR_FAX_CHEAP_BEGIN_HOUR><nl>
            <t PR_FAX_CHEAP_BEGIN_MINUTE><nl>
            <t PR_FAX_CHEAP_END_HOUR><nl>
            <t PR_FAX_CHEAP_END_MINUTE><nl>
            <t PR_FAX_NOT_EARLIER_HOUR><nl>
            <t PR_FAX_NOT_EARLIER_MINUTE><nl>
            <t PR_FAX_NOT_EARLIER_DATE>
     @comm Settable through UI: Yes
*/
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_CHEAP_BEGIN_HOUR |
        The hour portion of start of the "cheap times" interval beginning time.
    @comm Settable through UI: Yes
*/
#define PR_FAX_CHEAP_BEGIN_HOUR             PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x1))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_CHEAP_BEGIN_MINUTE |
        The minute portion of start of the "cheap times" interval beginning time.
    @comm Settable through UI: Yes
*/
#define PR_FAX_CHEAP_BEGIN_MINUTE           PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x2))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_CHEAP_END_HOUR |
        The hour portion of start of the "cheap times" interval ending time.
    @comm Settable through UI: Yes
*/
#define PR_FAX_CHEAP_END_HOUR               PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x3))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_CHEAP_END_MINUTE |
        The minute portion of start of the "cheap times" interval ending time.
    @comm Settable through UI: Yes
*/
#define PR_FAX_CHEAP_END_MINUTE             PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x4))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_NOT_EARLIER_HOUR |
        The hour portion of start of the "send at" time.
    @comm Settable through UI: Yes
*/
#define PR_FAX_NOT_EARLIER_HOUR             PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x5))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_NOT_EARLIER_MINUTE |
        The minute portion of start of the "send at" time.
    @comm Settable through UI: Yes
*/
#define PR_FAX_NOT_EARLIER_MINUTE           PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x6))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_NOT_EARLIER_DATE |
        The date portion of start of the "send at" time.
    @comm Settable through UI: Not Yet
    @comm This feature is not yet implemented.
*/
#define PR_FAX_NOT_EARLIER_DATE             PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x7))

/*
    @doc EXTERNAL   PROPERTIES
    @subtopic Retry Properties | These properties specify the retry
        behavior if the dialed fax number is busy.<nl>
        <t PR_FAX_NUMBER_RETRIES><nl>
        <t PR_FAX_MINUTES_BETWEEN_RETRIES>
    @comm Settable through UI: Yes
*/
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_NUMBER_RETRIES |
        The number of times to retry a busy fax number.  If 0, only one attempt will
        be made before an NDR is generated.
    @comm Settable through UI: Yes
*/
#define PR_FAX_NUMBER_RETRIES               PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x8))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_MINUTES_BETWEEN_RETRIES |
        The number of minutes to wait before retrying a busy fax number.
    @comm Settable through UI: Yes
*/
#define PR_FAX_MINUTES_BETWEEN_RETRIES      PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x9))

/*
    @doc EXTERNAL   PROPERTIES
    @subtopic Cover Page Properties | These properties specify cover page
        behavior.<nl>
        <t PR_FAX_INCLUDE_COVER_PAGE><nl>
        <t PR_FAX_COVER_PAGE_BODY><nl>
        <t PR_FAX_BGN_MSG_ON_COVER><nl>
        <t PR_FAX_DEFAULT_COVER_PAGE>
    @comm Settable through UI: Yes
*/
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_INCLUDE_COVER_PAGE |
        If set to TRUE, we will include a cover page IF this fax is sent as Not Editable.
    @comm Settable through UI: Yes
*/
#define PR_FAX_INCLUDE_COVER_PAGE           PROP_TAG(PT_BOOLEAN, (EFAX_MESSAGE_BASE + 0xA))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_COVER_PAGE_BODY |
        This property is obsolete.
    @comm Settable through UI: No
*/
#define PR_FAX_COVER_PAGE_BODY              PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0xB))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_LOGO_STRING |
        This property is obsolete.
*/
#define PR_FAX_LOGO_STRING                  PROP_TAG(PT_STRING8, (EFAX_MESSAGE_BASE + 0xC))

/*
    @doc EXTERNAL   PROPERTIES
    @subtopic Delivery Format Properties | These properties override the
        default delivery format behavior.<nl>
        <t PR_FAX_DELIVERY_FORMAT><nl>
        <t PR_FAX_PRINT_ORIENTATION><nl>
        <t PR_FAX_PAPER_SIZE><nl>
        <t PR_FAX_IMAGE_QUALITY>
*/

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_DELIVERY_FORMAT |
        Determines whether this fax should be sent SEND_EDITABLE,
        SEND_PRINTED or SEND_BEST.
    @xref <t PR_FAX_DELIVERY_FORMAT Values>
    @comm Settable through UI: Yes
*/
#define PR_FAX_DELIVERY_FORMAT              PROP_TAG(PT_LONG,    (EFAX_MESSAGE_BASE + 0xD))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_PRINT_ORIENTATION |
        Determines the orientation for the message body and for attachments
        which don't have their own idea what orientation to print in.
    @xref <t PR_FAX_PRINT_ORIENTATION Values>
    @comm Settable through UI: Yes
*/
#define PR_FAX_PRINT_ORIENTATION            PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0xE))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_PAPER_SIZE |
        Determines what size page should be rendered.
    @xref <t PR_FAX_PAPER_SIZE Values>
    @comm Settable through UI: Yes
*/
#define PR_FAX_PAPER_SIZE                   PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0xF))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_IMAGE_QUALITY |
        Determines the image quality to render, ie, Standard (100x200),
        Fine (200x200), or 300 Dpi.
    @xref <t PR_FAX_IMAGE_QUALITY Values>
    @comm Settable through UI: Yes
*/
#define PR_FAX_IMAGE_QUALITY                PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x10))

/*
    @doc EXTERNAL   PROPERTIES
    @subtopic Fax Transport Identification Properties | These properties
        set the identification of the sender on the message.
        These properties should not be modified outside of the transport.<nl>
        <t PR_FAX_SENDER_NAME><nl>
        <t PR_FAX_SENDER_EMAIL_ADDRESS>
    @comm Settable through UI: Indirectly
*/
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_SENDER_NAME |
         This message property identifies Microsoft Fax transport's idea of the
         sender of the message.  This property is copied from the profile's
         PR_SENDER_NAME and is the display name of the sender.
         This property should not be modified outside of the transport.
    @comm Settable through UI: Indirectly
*/
#define PR_FAX_SENDER_NAME                  PROP_TAG(PT_STRING8, (EFAX_MESSAGE_BASE + 0x11))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_SENDER_EMAIL_ADDRESS |
         This message property identifies Microsoft Fax transport's idea of the
         sender of the message.  This property is copied from the profile's
         PR_SENDER_EMAIL_ADDRESS and is the fax address (number) of the sender.
         This property should not be modified outside of the transport.
    @comm Settable through UI: Indirectly
*/
#define PR_FAX_SENDER_EMAIL_ADDRESS         PROP_TAG(PT_STRING8, (EFAX_MESSAGE_BASE + 0x12))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_LMI_CUSTOM_OPTION |
        This property allows a block of data to be sent directly from the MAPI
        client down to the LMI provider.  This is specifically designed to allow
        for communication from an LMI custom property page to communicate it's
        per-message settings to the LMI.  See the LMI help file for more
        information.
    @comm Settable through UI: No
*/
#define PR_FAX_LMI_CUSTOM_OPTION            PROP_TAG(PT_BINARY,  (EFAX_MESSAGE_BASE + 0x13))
/*
    @doc EXTERNAL   PROPERTIES
    @subtopic Fax Internal Properties | These two properties are internal to
    the fax transport and should not be modified.<nl>
        <t PR_FAX_PREVIOUS_STATE><nl>
        <t PR_FAX_FAXJOB>
    Settable through UI: No
*/
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_PREVIOUS_STATE |
        This property is internal to the fax transport and should not be modified.
    @comm Settable through UI: No
*/
#define PR_FAX_PREVIOUS_STATE               PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x14))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_FAXJOB |
        This property maintains the current state of a sent fax.
        It is removed when the job has been sent or NDR'd.
        This property is internal to the fax transport and should not be modified.
    @comm Settable through UI: No
*/
#define PR_FAX_FAXJOB                       PROP_TAG(PT_BINARY,  (EFAX_MESSAGE_BASE + 0x15))

/*
    @doc EXTERNAL   PROPERTIES
    @subtopic Fax Billing Code Properties | A billing code can be associated
        with a message.  This feature is not yet implemented.<nl>
        <t PR_FAX_BILLING_CODE><nl>
        <t PR_FAX_PREV_BILLING_CODES><nl>
        <t PR_FAX_BILLING_CODE_DWORD>

    @comm Settable through UI: Not Yet.
*/
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_BILLING_CODE |
        A billing code can be associated with a message. This property contains
		the ASCII equivalent of PR_FAX_BILLING_CODE_DWORD and might be dropped in
		future.
        This feature is not yet implemented.
    @comm Settable through UI: Not Yet.
*/
#define PR_FAX_BILLING_CODE                 PROP_TAG(PT_STRING8, (EFAX_MESSAGE_BASE + 0x16))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_PREV_BILLING_CODES |
        This is property is for internal use and is subject to change in the future.
        It is a multi-value MAPI property that contains the list of the last 10
        billing codes that the user used.
        This feature is not yet implemented.
    @comm Settable through UI: Not Yet.
*/
#define PR_FAX_PREV_BILLING_CODES           PROP_TAG(PT_MV_STRING8, (EFAX_MESSAGE_BASE + 0x17))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_BGN_MSG_ON_COVER |
        Set TRUE if the message should start on the cover page.  This is ignored
        if there is no cover page generated.  All Rich Text formatting of the message
        body is lost when this feature is used.
    @comm Settable through UI: Yes
*/
#define PR_FAX_BGN_MSG_ON_COVER             PROP_TAG(PT_BOOLEAN, (EFAX_MESSAGE_BASE + 0x18))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_SEND_WHEN_TYPE |
        Defines how the fax should be scheduled in concert with the Fax
        Scheduling Properties.
    @comm Settable through UI: Yes
*/
#define PR_FAX_SEND_WHEN_TYPE               PROP_TAG(PT_LONG,    (EFAX_MESSAGE_BASE + 0x19))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_DEFAULT_COVER_PAGE |
        Defines which cover page template to use.  Must contain the
        full pathname of the file.
    @comm Settable through UI: Yes
*/
#define PR_FAX_DEFAULT_COVER_PAGE           PROP_TAG(PT_STRING8, (EFAX_MESSAGE_BASE + 0x1A))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_MAX_TIME_TO_WAIT |
        Maximum Time to wait for connection (seconds).
        This property is obsolete.
*/
#define PR_FAX_MAX_TIME_TO_WAIT             PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x1B))

/*
    @doc EXTERNAL   PROPERTIES
    @subtopic Fax Logging Properties | Define behavior of call logging
        feature.
        This feature is not yet implemented.<nl>
        <t PR_FAX_LOG_ENABLE><nl>
        <t PR_FAX_LOG_NUM_OF_CALLS>
    @comm Settable through UI: Not Yet
*/
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_LOG_ENABLE |
        Turn on or off the call logging feature.
        This feature is not yet implemented.
    @comm Settable through UI: Not Yet.
*/
#define PR_FAX_LOG_ENABLE                   PROP_TAG(PT_BOOLEAN, (EFAX_MESSAGE_BASE + 0x1C))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_LOG_NUM_OF_CALLS |
        The number of calls that call logging should keep track of.
        This feature is not yet implemented.
    @comm Settable through UI: Not Yet.
*/
#define PR_FAX_LOG_NUM_OF_CALLS             PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x1D))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_DISPLAY_PROGRESS |
        This property is not used at this time.
*/
// Display call progress
#define PR_FAX_DISPLAY_PROGRESS             PROP_TAG(PT_BOOLEAN, (EFAX_MESSAGE_BASE + 0x1E))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_EMBED_LINKED_OBJECTS |
        This property is set TRUE if the transport should convert linked
        objects to static objects before sending.
    @comm This feature is not yet implemented.
    @comm Settable through UI: Not Yet
*/
#define PR_FAX_EMBED_LINKED_OBJECTS         PROP_TAG(PT_BOOLEAN, (EFAX_MESSAGE_BASE + 0x1F))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_TAPI_LOC_ID | 
    	This property is used to store the TAPI location ID associated with 
		this profile. It is currently not used, i.e. we always use the default
		TAPI location
    @comm Settable through UI: No
*/
#define PR_FAX_TAPI_LOC_ID                  PROP_TAG(PT_LONG,    (EFAX_MESSAGE_BASE + 0x20))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_MUST_RENDER_ALL_ATTACH |
        This property is not used at this time.
*/
#define PR_FAX_MUST_RENDER_ALL_ATTACH       PROP_TAG(PT_BOOLEAN, (EFAX_MESSAGE_BASE + 0x21))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_ENABLE_RECIPIENT_OPTIONS |
        This property is set TRUE if per-recipient options are desired.
    @comm This feature is not yet implemented.
    @comm Settable through UI: Not Yet
*/
#define PR_FAX_ENABLE_RECIPIENT_OPTIONS     PROP_TAG(PT_BOOLEAN, (EFAX_MESSAGE_BASE + 0x22))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_CALL_CARD_NAME |
        This property defines what calling card should be used for this call.
    @comm This feature is not yet implemented.
    @comm Settable through UI: Not Yet
*/
#define PR_FAX_CALL_CARD_NAME               PROP_TAG(PT_STRING8, (EFAX_MESSAGE_BASE + 0x24))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_PRINT_TO_NAME |
        This property defines the RBA data stream placed on the message
        or attachment.  It is internal to Microsoft Fax and should not
        be modified.
    @comm Settable through UI: No
*/
#define PR_FAX_PRINT_TO_NAME                PROP_TAG(PT_STRING8, (EFAX_MESSAGE_BASE + 0x25))

/*
    @doc EXTERNAL   PROPERTIES
    @subtopic Fax Security Properties |
        ??? <nl>
        <t PR_FAX_SECURITY_SEND><nl>
        <t PR_FAX_SECURITY_RECEIVED><nl>
        <t PR_ATTACH_SIGNATURE><nl>
        <t PR_FAX_ENCRYPTION_KEY>
*/
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_SECURITY_SEND |
        ???
    @comm Settable through UI: ??
*/
#define PR_FAX_SECURITY_SEND                PROP_TAG(PT_BINARY,  (EFAX_MESSAGE_BASE + 0x26))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_SECURITY_RECEIVED |
        ???
    @comm Settable through UI: ??
*/
#define PR_FAX_SECURITY_RECEIVED            PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x27))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_RBA_DATA |
        This property defines the RBA data stream placed on a print-to-fax
        message.  It is internal to Microsoft Fax and should not be modified.
    @comm Settable through UI: No
*/
#define PR_FAX_RBA_DATA                     PROP_TAG(PT_BINARY,  (EFAX_MESSAGE_BASE + 0x28))

/*
    @doc EXTERNAL   PROPERTIES
    @subtopic Fax Poll Retrieval Properties | These properties define the
        behavior of a poll retrieve request.  If <t PR_POLL_RETRIEVE_SENDME>
        is SENDME_DEFAULT the default document will be polled from the
        dialed fax.  Otherwise, we will poll for the document named in
        <t PR_POLL_RETRIEVE_TITLE> with the optional password specified in
        <t PR_POLL_RETRIEVE_PASSWORD>.  <t PR_POLLTYPE> is obsolete.
    @xref <t PR_POLL_RETRIEVE_SENDME Values>
    @comm Settable through UI: Yes
*/
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_POLL_RETRIEVE_SENDME |
      If this property contains <t SENDME_DEFAULT>, the default document will be polled
      from the dialed fax number.  Otherwise we will poll for the document named in
      <t PR_POLL_RETRIEVE_TITLE> with the optional password specified in
      <t PR_POLL_RETRIEVE_PASSWORD>.
    @xref <t PR_POLL_RETRIEVE_SENDME Values>
    @comm Settable through UI: Yes
*/
#define PR_POLL_RETRIEVE_SENDME             PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x29))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_POLL_RETRIEVE_TITLE |
        Contains the title of the document to retrive in a polling call.
    @comm Settable through UI: Yes
*/
#define PR_POLL_RETRIEVE_TITLE              PROP_TAG(PT_TSTRING, (EFAX_MESSAGE_BASE + 0x30))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_POLL_RETRIEVE_PASSWORD |
        Contains the password to use in a polling call.
    @comm Settable through UI: Yes
*/
#define PR_POLL_RETRIEVE_PASSWORD           PROP_TAG(PT_TSTRING, (EFAX_MESSAGE_BASE + 0x31))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_POLLTYPE |
        This property is obsolete.
    @comm Settable through UI: No
*/
#define PR_POLLTYPE                         PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x32))


/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_MESSAGE_TYPE |
        This property is used by the poll server.
    @comm This feature is not yet implemented.
*/
#define PR_MESSAGE_TYPE                     PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x33))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_ATTACH_SIGNATURE |
        This property contains the encrypted digital signature for an attachment.
    @comm Settable through UI: Indirectly
*/
#define PR_ATTACH_SIGNATURE                 PROP_TAG(PT_BINARY,  (EFAX_MESSAGE_BASE + 0x34))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_PRINT_TO_PAGES |
        This property is set during the Print-to-Fax operation and contains the
        number of pages printed for use on the cover page.  This is internal to
        Microsoft Fax and should not be modified.
    @comm Settable through UI: No
*/
#define PR_FAX_PRINT_TO_PAGES               PROP_TAG(PT_LONG,    (EFAX_MESSAGE_BASE + 0x35))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_IMAGE |
        This property is set on an incoming linearized image message and contains
        the image data prior to conversion to RBA.  This property is internal to
        Microsoft Fax and should not be modified.
    @comm Settable through UI: No
*/
#define PR_FAX_IMAGE                        PROP_TAG(PT_BINARY,  (EFAX_MESSAGE_BASE + 0x36))

/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_PRINT_HEADER |
        This property controls branding of G3 faxed pages.
    @comm This feature is not yet implemented.
    @comm Settable through UI: Not Yet
*/
#define PR_FAX_PRINT_HEADER                 PROP_TAG(PT_BOOLEAN,  (EFAX_MESSAGE_BASE + 0x37))


/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_BILLING_CODE_DWORD |
        This is the DWORD representation of the billing code. This 
		is the representation that will be tacked to a message.
    @comm This feature is not yet implemented.
    @comm Settable through UI: Not Yet.
*/
#define PR_FAX_BILLING_CODE_DWORD           PROP_TAG(PT_LONG, (EFAX_MESSAGE_BASE + 0x38))

/*
    @doc EXTERNAL   PROPERTIES
    @subtopic Miscellaneous IFAX Properties | These Non-Transmittable
        Mail-User properties are internal to Microsoft Fax or are
        obsolete.  Do not use or rely on them.<nl>
        <t PR_FAX_RECIP_CAPABILITIES><nl>
        <t PR_FAX_CP_NAME><nl>
        <t PR_RECIP_INDEX><nl>
        <t PR_HOP_INDEX><nl>
        <t PR_RECIP_VOICENUM>
*/
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_RECIP_CAPABILITIES |
        May be set on a received fax if the sender sent it.
        This is currently only sent by IFAX.
    @comm Settable through UI: No
*/
#define PR_FAX_RECIP_CAPABILITIES           PROP_TAG(PT_I2,      (EFAX_RECIPIENT_BASE + 0x0))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_CP_NAME |
        This property is not currently used by Microsoft Fax.
    @comm Settable through UI: No
*/
#define PR_FAX_CP_NAME                      PROP_TAG(PT_TSTRING, (EFAX_RECIPIENT_BASE + 0x1))
#define PR_FAX_CP_NAME_W                    PROP_TAG(PT_UNICODE, (EFAX_RECIPIENT_BASE + 0x1))
#define PR_FAX_CP_NAME_A                    PROP_TAG(PT_STRING8, (EFAX_RECIPIENT_BASE + 0x1))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_RECIP_INDEX |
        This recipient property is internal to Microsoft Fax and should not be modified.
    @comm Settable through UI: No
*/
#define PR_RECIP_INDEX                      PROP_TAG(PT_I2,      (EFAX_RECIPIENT_BASE + 0x2))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_HOP_INDEX |
        This recipient property is internal to Microsoft Fax and should not be modified.
    @comm Settable through UI: No
*/
#define PR_HOP_INDEX                        PROP_TAG(PT_I2,      (EFAX_RECIPIENT_BASE + 0x3))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_RECIP_VOICENUM |
        This recipient property may be set on a received fax if the sender sent it.
        It contains the voice phone number associated with that recipient.
    @comm Settable through UI: No
*/
#define PR_RECIP_VOICENUM                   PROP_TAG(PT_TSTRING, (EFAX_RECIPIENT_BASE + 0x4))
/*
    @doc EXTERNAL   PROPERTIES
    @prop PR_FAX_ENCRYPTION_KEY |
        ???
    @comm Settable through UI: Indirectly
*/
#define PR_FAX_ENCRYPTION_KEY               PROP_TAG(PT_BINARY,  (EFAX_RECIPIENT_BASE + 0x5))


/**********************************************************************************

   Property Values Section

***********************************************************************************/

//
// LOGON Properties
//
// Properties we store in the Profile.
//
// The following is used to access the properties in the logon array.
// If you add a property to the profile, you should increment this number!
#define MAX_LOGON_PROPERTIES                10

// Other logon properties:
//  PR_SENDER_NAME                          - in mapitags.h
//  PR_SENDER_EMAIL_ADDRESS                 - in mapitags.h (this file)

#define NUM_SENDER_PROPS            3       // How many sender ID properties?

/*
    @doc    EXTERNAL  PROPERTIES
    @type   NONE | PR_FAX_DELIVERY_FORMAT Values |
            Values for <t PR_FAX_DELIVERY_FORMAT>:
    @emem   SEND_BEST | Use best available. (May be determined at call time if recipient
            capabilities are not yet cached.)  Editable format will be preferred if the
            receiver is capable of receiving editable format. This is the default value.
    @emem   SEND_EDITABLE | Send as email.  If recipient is not capable, NDR.
    @emem   SEND_PRINTED | Send as FAX image.
*/
#define SEND_BEST                  0
#define SEND_EDITABLE              1
#define SEND_PRINTED               2
#define DEFAULT_SEND_AS            SEND_BEST

/*
    @doc    EXTERNAL  PROPERTIES
    @type   NONE | PR_FAX_SEND_WHEN_TYPE Values |
            Values for <t PR_FAX_SEND_WHEN_TYPE>:
    @emem   SEND_ASAP | Send as soon as possible.  (This is the default value.)
    @emem   SEND_CHEAP | Use the cheap times to determine when to send.  These are
            specified in <t PR_FAX_CHEAP_BEGIN_HOUR>, <t PR_FAX_CHEAP_BEGIN_MINUTE>,
            <t PR_FAX_CHEAP_END_HOUR> and <t PR_FAX_CHEAP_END_MINUTE>.
    @emem   SEND_AT_TIME | Send at the time specified in <t PR_FAX_NOT_EARLIER_HOUR> and
            <t PR_FAX_NOT_EARLIER_MINUTE>.
*/
#define SEND_ASAP                  0
#define SEND_CHEAP                 1
#define SEND_AT_TIME               2
#define DEFAULT_SEND_AT            SEND_ASAP

/*
    @doc    EXTERNAL  PROPERTIES
    @type   NONE | PR_FAX_PAPER_SIZE Values |
            Values for <t PR_FAX_PAPER_SIZE>:
    @emem   PAPER_US_LETTER | US Letter size.
    @emem   PAPER_US_LEGAL  | US Legal size.
    @emem   PAPER_A4 | Metric A4 paper size.
    @emem   PAPER_B4 | Metric B4 paper size.
    @emem   PAPER_A4 | Metric A3 paper size.
*/
#define PAPER_US_LETTER            0       // US Letter page size
#define PAPER_US_LEGAL             1
#define PAPER_A4                   2
#define PAPER_B4                   3
#define PAPER_A3                   4
// "real" default page size is in a resource string depending on U.S. vs metric
#define DEFAULT_PAPER_SIZE      PAPER_US_LETTER     // Default page size

/*
    @doc    EXTERNAL  PROPERTIES
    @type   NONE | PR_FAX_PRINT_ORIENTATION Values |
            Values for <t PR_FAX_PRINT_ORIENTATION>:
    @emem   PRINT_PORTRAIT | Portrait printing.  (This is the default value.)
    @emem   PAPER_LANDSCAPE | Landscape printing.
*/
// Print Orientation
// PR_FAX_PRINT_ORIENTATION
#define PRINT_PORTRAIT             0       // Protrait printing
#define PRINT_LANDSCAPE            1
#define DEFAULT_PRINT_ORIENTATION  PRINT_PORTRAIT

/*
    @doc    EXTERNAL  PROPERTIES
    @type   NONE | PR_FAX_IMAGE_QUALITY Values |
            Values for <t PR_FAX_IMAGE_QUALITY>:
    @emem   IMAGE_QUALITY_BEST     | Best available based upon cached capabilities.
    @emem   IMAGE_QUALITY_STANDARD | Standard fax quality.  (About 100 x 200 dpi)
    @emem   IMAGE_QUALITY_FINE     | Fine fax quality.  (About 200 dpi)
    @emem   IMAGE_QUALITY_300DPI   | 300 DPI resolution.
    @emem   IMAGE_QUALITY_400DPI   | 400 DPI resolution.
*/
#define IMAGE_QUALITY_BEST         0
#define IMAGE_QUALITY_STANDARD     1
#define IMAGE_QUALITY_FINE         2
#define IMAGE_QUALITY_300DPI       3
#define IMAGE_QUALITY_400DPI       4
#define DEFAULT_IMAGE_QUALITY      IMAGE_QUALITY_BEST

// Modem specific property values are obsolete
// PR_FAX_SPEAKER_VOLUME
#define NUM_OF_SPEAKER_VOL_LEVELS  4   // Number of speaker volume levels
#define DEFAULT_SPEAKER_VOLUME     2   // Default speaker volume level
#define SPEAKER_ALWAYS_ON          2   // Speaker mode: always on
#define SPEAKER_ON_UNTIL_CONNECT   1   // speaker on unitl connected
#define SPEAKER_ALWAYS_OFF         0   // Speaker off
#define DEFAULT_SPEAKER_MODE       SPEAKER_ON_UNTIL_CONNECT   // Default speaker mode

// PR_FAX_ANSWER_MODE
#define NUM_OF_RINGS                3
#define ANSWER_NO                  0
#define ANSWER_MANUAL               1
#define ANSWER_AUTO                 2
#define DEFAULT_ANSWER_MODE         ANSWER_NO

// Blind Dial
#define DEFAULT_BLIND_DIAL         3
// Comma Delay
#define DEFAULT_COMMA_DELAY            2
// Dial Tone Wait
#define DEFAULT_DIAL_TONE_WAIT     30
// Hangup Delay
#define DEFAULT_HANGUP_DELAY       60

/*
    @doc    EXTERNAL  PROPERTIES
    @type   NONE | PR_POLL_RETRIEVE_SENDME Values |
            Values for <t PR_POLL_RETRIVE_SENDME>:
    @emem   SENDME_DEFAULT      | Poll for the default document
    @emem   SENDME_DOCUMENT     | Poll for the document named in
                                  <t PR_POLL_RETRIEVE_TITLE>.
*/
#define SENDME_DEFAULT              0
#define SENDME_DOCUMENT             1

// PR_POLLTYPE is obsolete
#define POLLTYPE_REQUEST            1
#define POLLTYPE_STORE              2

// Line ID (depends on the value in PR_FAX_ACTIVE_MODEM_TYPE)
// PR_FAX_ACTIVE_MODEM
#define    NO_MODEM                    0xffffffff  // To show no modem is selected

// PR_FAX_TAPI_LOC_ID
#define    NO_LOCATION                 0xffffffff  // No TAPI location
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\rambo.h ===
// Copyright (c) Microsoft Corp. 1994-95

#ifndef _RAMBO_
#define _RAMBO_

#include <windows.h>

#ifndef WIN16		// remove WIN16 irritation
#pragma pack (push)
#pragma pack(1)
#endif


// common header
typedef struct
{
	WORD  cbRest;
	DWORD dwID;
	WORD  wClass;
}
	RESHDR, FAR *LPRESHDR;

// resource classes
#define ID_GLYPH   1
#define ID_BRUSH   2
#define ID_BITMAP  3
#define ID_RPL     4
#define ID_CONTROL 8
#define ID_BAND   10

// control IDs
#define ID_BEGJOB  0x49505741 // "AWPI"
#define ID_ENDPAGE 0x45474150 // "PAGE"
#define ID_ENDJOB  0x4a444e45 // "ENDJ"

// job header
typedef struct BEGJOB
{ 
	// common header
	WORD  cbRest;     // sizeof(BEGJOB) - sizeof(WORD)
	DWORD dwID;       // ID_BEGJOB
	WORD  wClass;     // ID_CONTROL

	// image attributes
	DWORD xBand;      // page width  [pixels]
	DWORD yBand;      // band height [pixels]
	WORD  xRes;       // horizontal resolution [dpi]
	WORD  yRes;       // vertical resolution [dpi]

	// memory attributes
	DWORD cbCache;    // cache size [KB]
	WORD  cResDir;    // directory size
	BYTE  bBitmap;    // bitmap compression
	BYTE  bGlyph;     // glyph compression
	BYTE  bBrush;     // stock brush set
	BYTE  bPad[3];    // reserved, must be 0
}
	BEGJOB, FAR *LPBEGJOB;

// job tailer
typedef struct ENDJOB
{
	// common header
	WORD  cbRest;      // sizeof(ENDJOB) - sizeof(WORD)
	DWORD dwID;        // ID_ENDJOB
	WORD  wClass;      // ID_CONTROL

	// job attributes
	WORD  cPage;       // number of pages
	WORD  yMax;        // maximum height
}
	ENDJOB, FAR *LPENDJOB;

// bitmap header
typedef	struct
{
	BYTE  bComp;
	BYTE  bLeftPad;
	WORD  wHeight;
	WORD  wWidth;
}
	BMPHDR, FAR* LPBMPHDR;

#ifndef WIN16		// remove WIN16 irritation
#pragma pack(pop)
#endif

#endif // _RAMBO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\pumpext.h ===
#ifndef _PUMPEXT_INC
#define _PUMPEXT_INC

#include "property.h"

/***************************************************************************

    Name      : pumpext.h

    Comment   : Defines all external interfaces for the EfaxPump

    Functions : (see Prototypes just below)

    Created   : 11/30/92

    Author    : Sharad Mathur

    Contribs  :

***************************************************************************/

#ifndef DLL_EXPORT
#ifdef WIN32
#define DLL_EXPORT __declspec(dllexport)
#else
#define DLL_EXPORT __export
#endif
#endif


#define SetFaxMgrStatus(ID, lParam, wParam)

void 
SendStatus(HINSTANCE hInst, BOOL PopUpUi, UINT idsFmt, ...);



// ***********************  T30 Transport API's ******************

#define FILET30INIT             "LFileT30Init"
#define FILET30CONFIGURE        "LFileT30Configure"
#define FILET30DEINIT           "LFileT30DeInit"
#define FILET30LISTEN           "LFileT30Listen"
#define FILET30SEND             "LFileT30Send"
#define FILET30ANSWER           "LFileT30Answer"
#define FILET30ABORT            "LFileT30Abort"
#define FILET30REPORTRECV       "LFileT30ReportRecv"
#define FILET30MODEMCLASSES     "LFileT30ModemClasses"
#define FILET30STATUS           "LFileT30Status"
#define FILET30ACKRECV          "LFileT30AckRecv"
#define FILET30SETSTATUSWINDOW  "LFileT30SetStatusWindow"
#define FILET30READINIFILE      "LFileT30ReadIniFile"


// ***********************  LMI  API's *****************************


#define LMI_ABORTSENDJOB            "LMI_AbortSendJob"
#define LMI_ADDMODEM                "LMI_AddModem"
#define LMI_CHECKPROVIDER           "LMI_CheckProvider"
#define LMI_CONFIGUREMODEM          "LMI_ConfigureModem"
#define LMI_DEINITPROVIDER          "LMI_DeinitProvider"
#define LMI_DEINITLOGICALMODEM      "LMI_DeinitLogicalModem"
#define LMI_DISPLAYCUSTOMSTATUS     "LMI_DisplayCustomStatus"
#define LMI_GETQUEUEFILE            "LMI_GetQueueFile"
#define LMI_RESCHEDULESENDJOB       "LMI_RescheduleSendJob"
#define LMI_INITPROVIDER            "LMI_InitProvider"
#define LMI_INITLOGICALMODEM        "LMI_InitLogicalModem"
#define LMI_REPORTRECEIVES          "LMI_ReportReceives"
#define LMI_SENDFAX                 "LMI_SendFax"
#define LMI_REPORTSEND              "LMI_ReportSend"


// ***********************  Queue  API's *****************************

// Time types
typedef WORD    DOSTIME;        // can hold 16-bit time or date


// The following calls are valid only for jobs on the local fax
// queue.

BOOL FAR AbortSendJob(LPSTR lpszSourceServer, DWORD dwPrivateHandle, DWORD dwUniqueID);
// Aborts the specified send job. If abortng the current job, the
// call returns before the abort has actually taken place. The
// abort occurs asynchronously in another process context. There
// are no guarantees as to the time this will take.
// return FALSE if there is no such send job.

// BOOL FAR AbortReceiveJob (VOID);
// Returns FALSE if the modem is currently transmitting something
// since it couldnt possibly be receiving in this case !! Else it
// calls the transport to abort the current job if any. Returns
// TRUE irrespective of whether anything was actually aborted.

BOOL FAR GetDefaultFaxInfo (UINT FAR *lpuDefaultFax, UINT FAR* lpuModemType);
// Gets info about the current modem. uDefaultFax is as read from the
// ini file. fBinary is set to TRUE if binary transfers are supported
// over this modem.

// ***********************  Cover Page API's **************************

// Date structure cimpiant with MAPI
typedef FILETIME MAPIDATE;          // MAPI 1.0 uses NT FILETIME
typedef MAPIDATE * LPMAPIDATE;

// ***********************  Linearizer API's **************************
#define TEXT_ASCII  1
#include <lineariz.h>

// ***********************  Transport API's ***************************

// ***********************  Device Layer API's  ***********************
void CleanupDevlayerSharedMemory(HANDLE hFileMapping, PJOBSUMMARYDATA pjd);
PJOBSUMMARYDATA SetupDevlayerSharedMemory(LPHANDLE lph);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\recover.h ===
#define BCFILE	0
#define LINFILE	1


//////////////////// RFILE Class ///////////////////////
typedef struct
{
	WORD		wAtt;
	WORD		wPage;
	hSecureFile	hsecfile;
}
RFILE, FAR* LPRFILE;

// Need to remember encodings of files, but don't want to increase the NVRAM
// storage requirements for an array of struct RFILE
typedef struct 
{
	LPRFILE lpRFile;
	DWORD 	Encoding;
	DWORD	dwFlush;
	DWORD	dwEndMetaData;
}
RXSFILE, FAR* LPRXSFILE;

typedef struct
{
	WORD	wSigRF;
	WORD	wNumEntries;
	LPRFILE lpRFileTail;	// last valid item
	LPRFILE lpRFileHead;	// first free item
	// empty if Head==Tail. Full if ((Head+1) mod N)==Tail

	WORD	wFlags;			// see below
	WORD	dummy;			// sizeof(RFILEHDR)==sizeof(RFILE) must be true
}
RFILEHDR, FAR* LPRFILEHDR;

#define NVBUFSIZE	2048
#define NUMSPECIAL	2
#define NUMGENERAL	120
#define SIG_RF		0x4d41

// wFlags
#define RFILE_NO_NVRAM	1	// if this flag set then RFILE list is in regular RAM!


#define lprfLim		(lprfStart + NUMGENERAL)
#define lprfTail	(lprfHdr->lpRFileTail)
#define lprfHead	(lprfHdr->lpRFileHead)


#define RFileGetCount() 	\
	( (lprfHead >= lprfTail) ? ((WORD)(lprfHead-lprfTail)) : ((WORD)(NUMGENERAL-(lprfTail-lprfHead))) )


#define MyRegisterSecFile(lprfHdr, lphsec)   \
	((lprfHdr->wFlags & RFILE_NO_NVRAM) ? TRUE : RegisterSecFile(lphsec))

#define MyUnRegisterSecFile(lprfHdr, lphsec) \
	((lprfHdr->wFlags & RFILE_NO_NVRAM) ? TRUE : UnRegisterSecFile(lphsec))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\rendserv.h ===
/********************************************\
 * 
 *  File   : rendserv.h
 *  Author : Kevin Gallo
 *  Created: 9/22/93
 *
 *  Copyright (c) Microsoft Corp. 1993-1994
 *
 *  Overview:
 *
 *  Revision History:
 \********************************************/

#ifndef _RENDSERV_H
#define _RENDSERV_H

// System includes

#ifdef OLE2
#define INC_OLE2 1
#include <objbase.h>
#endif

#include "ifaxos.h"
#ifdef IFAX
#include "awfile.h"
#include "sosutil.h"
#include "device.h"
#endif
#include "render.h"

// Library Name
#ifdef WIN32
#define LIB_RENDSERV "RNDSRV32.DLL"
#else
#define LIB_RENDSERV "RENDSERV.DLL"
#endif

// =================================================================
// Errors - 
//     These occupy the lowest 6 bits of the error 
// =================================================================

#define RSMAKE_ERR(err) (ERR_FUNCTION_START+err)

#define RSERR_GP_FAULT       RSMAKE_ERR(0)  // GP Fault
#define RSERR_OPER_FAIL      RSMAKE_ERR(1)  // The desired operation failed.
#define RSERR_BAD_OPER       RSMAKE_ERR(2)  // User tried to do something invalid
#define RSERR_BAD_DATA       RSMAKE_ERR(3)  // Bad data was passed to a renderer.
#define RSERR_DEV_FAIL       RSMAKE_ERR(4)  // Device failed.
#define RSERR_PROP_FAIL      RSMAKE_ERR(5)  // Could not get a mapi property

// =================================================================
// Methods in subsystems
//     These occupy bits 6-11   -  64 values
// =================================================================

#define RSMAKE_METHOD(method) (method << 6) 

// =================================================================
// General methods
// =================================================================

#define RSMETHOD_UNKNOWN     RSMAKE_METHOD(0)
#define RSMETHOD_OPEN        RSMAKE_METHOD(1)
#define RSMETHOD_CLOSE       RSMAKE_METHOD(2)
#define RSMETHOD_INIT        RSMAKE_METHOD(3)
#define RSMETHOD_READ        RSMAKE_METHOD(4)
#define RSMETHOD_WRITE       RSMAKE_METHOD(5)
#define RSMETHOD_RENDER      RSMAKE_METHOD(6)
#define RSMETHOD_ALLOC       RSMAKE_METHOD(7)
#define RSMETHOD_WINPROC     RSMAKE_METHOD(8)
#define RSMETHOD_START       RSMAKE_METHOD(9)
#define RSMETHOD_ERRREC      RSMAKE_METHOD(10)

// =================================================================
//
// System specific - start at 32
//
// =================================================================

#define RSMETHOD_CUSTOM_START (32)

#define RSMETHOD_GETDEVICES  RSMAKE_METHOD(RSMETHOD_CUSTOM_START)

// =================================================================
//
// Systems
//     These occupy bits 12-15 of the low WORD - 16 values
//
// =================================================================

#define RSMAKE_SYS(sys) (sys << 12)

#define RSSYS_UNKNOWN        RSMAKE_SYS(0)   // Unknown
#define RSSYS_SOS            RSMAKE_SYS(1)   // SOS subsystem
#define RSSYS_FILESYS        RSMAKE_SYS(2)   // File System
#define RSSYS_NETWORK        RSMAKE_SYS(3)   // Network
#define RSSYS_RENDERER       RSMAKE_SYS(4)   // Renderers
#define RSSYS_RENDSERV       RSMAKE_SYS(5)   // Rendering Server
#define RSSYS_DEVICE         RSMAKE_SYS(6)   // Devices
#define RSSYS_THREAD         RSMAKE_SYS(7)   // Threads

// =================================================================
//
//  Error macros
//
// =================================================================

#define RSFormCustomError(sys,method,err) ((WORD) (sys | method | err))
#define RSFormIFError(sys,method,err) \
           (IFErrAssemble(PROCID_NONE,MODID_REND_SERVER,0,RSFormCustomError(sys,method,err)))

#define RSGetErrCode(err)     (err & 0x003f)
#define RSGetErrMethod(err)   (err & 0x0fc0)
#define RSGetErrSys(err)      (err & 0xf000)

// =================================================================

#ifdef __cplusplus
extern "C" {
#endif

typedef LPVOID LPRENDSERVER ;

typedef enum {
    RS_BEGINNING = 0,
    RS_CURRENT = 1,
    RS_END = 2,
} RSOrigin_t ;

#ifdef IFAX

typedef enum {
    RSD_NULL = ATTACH_BY_NULL,
    RSD_FILE = ATTACH_BY_REF_RESOLVESOS,
    RSD_AWFILE = ATTACH_BY_SAVED_SECFILE,
    RSD_PIPE = ATTACH_BY_PIPE,
    RSD_SCANNER_PIPE = ATTACH_BY_SCANNER_PIPE,
    RSD_PRINTER_PIPE = ATTACH_BY_PRINTER_PIPE,
    RSD_METAFILE_PIPE = ATTACH_BY_METAFILE_PIPE,
    RSD_TRANSPORT_PIPE = ATTACH_BY_TRANSPORT_PIPE,
    RSD_LINEARIZER = ATTACH_BY_LINEARIZER,
#ifdef OLE2
    RSD_OLESTREAM,
#endif
    RSD_DIRECT_COPY,
} RSDeviceType_t ;

#else

typedef enum {
    RSD_NULL,
    RSD_FILE,
    RSD_AWG3_HANDLE,
#ifdef OLE2
    RSD_OLESTREAM,
#endif
} RSDeviceType_t ;

#endif

// Define Job Context

typedef WORD HJC ;

//
// Macros for combining Device IDs
// Used to store ID in PR_ATTACH_DEVID property.
// (major is high word and minor is low word)

#define MAKE_DEVID(major,minor) MAKEWORD(minor,major)
#define GET_MINOR_DEVID(id) LOBYTE(id)
#define GET_MAJOR_DEVID(id) HIBYTE(id)

// Encoding structure for PR_ENCODING property
// For now use the encoded values not the real values (match caps structure)
// We may want to set width and height to be exact values

typedef
struct Encoding_t {
    WORD cbStruct ;      // Size of the structure
    DWORD Resolution ;   // The data resolution - see buffer.h for types (AWRES_xxx)
    DWORD Encoding ;     // The data encoding format - see buffer.h for types (xxx_DATA)
    DWORD PageSize  ;    // The page size - see buffer.h for types (AWPAPER_xxx)
    DWORD LengthLimit ;  // The page length - see buffer.h for types (AWLENGTH_xxx)
} Encoding_t , FAR * lpEncoding_t ;    
    

// This is the topology data structure

#ifdef IFAX

#pragma warning (disable: 4200)
typedef
struct TopNode {
    WORD cbSize ;                // Size of node
    char szRenderName[16] ;      // Renderers modules name (cannot be more than 12 characters)
    LPCSTR RenderInfoProc ;      // Must be the Ordinal Number of the getinfo call
    char RenderParam[] ;
} TopNode, FAR * lpTopNode ;

typedef
struct Topology {
    WORD cbSize ;                // Size of the struct itself without nodes (just the header)
    WORD cbTotalSize ;           // Total size of data in struct
    WORD nRenderers ;            // Number of renderers
    WORD uOffset[] ;             // Offsets into this struct where TopNode's are.  There are nRenderers
                                 // of these.
} Topology , FAR * lpTopology ;

#define GET_TOPNODE(Top,idx) ((lpTopNode) (((LPBYTE)Top) + Top->uOffset[idx]))

#pragma warning (default: 4200)

#else

//  A topology will be a linked list of TopNodes

typedef struct TopNode FAR * lpTopNode ;

#pragma warning (disable: 4200)

typedef struct TopNode {
    WORD cbSize ;                // Size of node
    LPTSTR szRenderName ;         // Renderers modules name - (this is the dll)
    LPCSTR RenderInfoProc ;      // Will be passed directly to getprocaddress (i.e. ordinal or name)
    lpTopNode lpNext ;           // Used to create linked list topology
    char RenderParam[] ;
} TopNode ;

#pragma warning (default: 4200)

typedef struct Topology {
    WORD nRenderers ;            // Number of renderers
    lpTopNode lpHead ;           // Pointer to first renderer
    lpTopNode lpTail ;           // Pointer to last renderer
} Topology , FAR * lpTopology ;

#endif

/****
	@doc    EXTERNAL    RENDSERV

	@types  RSProcessInfo_t  |   The Process Pipe information structure.

	@field  HSESSION |  hSession | Specifies the session handle for the device.

	@field  DEVICESTR  |  szDeviceName | Specifies the name of the device to use.

	@field  UCHAR    |  ucMajorDevId | Specifies the Major Id of the device.

	@field  UCHAR    |  ucMinorDevId | Specifies the Minor Id of the device.

	@field  LPVOID   |  lpMode | Specifies the mode structure to be passed to the device.

	@field  UINT     |  cbMode | Specifies the size of mode structure.

	@comm   There are other reserved fields in the structure which have not been
			mentioned here.

	@tagname RSProcessInfo_t
****/

#ifdef IFAX
typedef
struct RSProcessPipeInfo_t {
    HSESSION hSession ;
    DEVICESTR szDeviceName ;
    UCHAR ucMajorDevId ;
    UCHAR ucMinorDevId ;
    LPVOID lpMode ;
    UINT cbMode ;
} RSProcessPipeInfo_t , FAR * lpRSProcessPipeInfo_t ;
#endif

typedef 
struct RSDeviceInfo_t {
    RSDeviceType_t DevType ;
    Encoding_t Encoding ;
    union {
	LPTSTR lpszFileName ;
	HANDLE hFile ;
#ifdef OLE2
	LPSTREAM lpstream ;
#endif
#ifdef IFAX
	hSecureFile SecFileName ;
	HPIPE hpipe ;
	LPMESSAGESOS lpMessage ;
	RSProcessPipeInfo_t ProcInfo ;
#endif
    } ;
} RSDeviceInfo_t ;

typedef RSDeviceInfo_t FAR * lpRSDeviceInfo_t, FAR * FAR * lplpRSDeviceInfo_t ;
typedef const RSDeviceInfo_t FAR * lpCRSDeviceInfo_t, FAR * FAR * lplpCRSDeviceInfo_t ;

#ifdef IFAX

#pragma warning (disable: 4200)

typedef
struct SOSProcessPipeInfo_t {
    HSESSION hSession ;
    DEVICESTR szDeviceName ;
    UCHAR ucMajorDevId ;
    UCHAR ucMinorDevId ;
    UINT cbMode ;
    BYTE Mode[] ;
} SOSProcessPipeInfo_t , FAR * lpSOSProcessPipeInfo_t ;

typedef 
struct SOSDeviceInfo_t {
    UINT cbSize ;
    RSDeviceType_t DevType ;
    Encoding_t Encoding ;
    union {
	char lpszFileName[] ;
	hSecureFile SecFileName ;
	HPIPE hpipe ;
	LPMESSAGESOS lpMessage ;
	SOSProcessPipeInfo_t ProcInfo ;
    } ;
} SOSDeviceInfo_t , FAR * lpSOSDeviceInfo_t, FAR * FAR * lplpSOSDeviceInfo_t ;

#pragma warning (default: 4200)

#endif

typedef void (WINAPI *LPFNACKPROC) (LPRENDSERVER lprs,WORD PageNum,WORD wValue,LPVOID lpvData) ;
typedef void (WINAPI *LPFNSTATUSPROC) (LPRENDSERVER lprs,WORD PageNum,WORD kbytes,LPVOID lpvData) ;

/********
	@doc    EXTERNAL    RENDSERV

	@api    LPRENDSERVER    | RSAlloc   | Allocates a Render Server.

	@rdesc  Returns a pointer to the Rendering Server or NULL if there was not enough memory.
********/
	
EXPORT_DLL LPRENDSERVER WINAPI RSAlloc () ;
EXPORT_DLL void WINAPI RSFree (LPRENDSERVER lprs) ;
	
EXPORT_DLL BOOL WINAPI RSInit (LPRENDSERVER lprs,HJC hjc,HWND hwnd) ;

EXPORT_DLL BOOL WINAPI RSOpen (LPRENDSERVER lprs,
			       lpRSDeviceInfo_t lpSrcInfo,lpRSDeviceInfo_t lpTgtInfo,
			       lpTopology lpTop,LPJOBINFO lpJobInfo) ;
EXPORT_DLL BOOL WINAPI RSClose (LPRENDSERVER lprs) ;

// Returns false if we did not process it

EXPORT_DLL LRESULT WINAPI RSWndProc (LPRENDSERVER lprs,UINT msg,WPARAM wParam,LPARAM lParam) ;

EXPORT_DLL BOOL WINAPI RSRender (LPRENDSERVER lprs,UINT nIterations) ;
EXPORT_DLL BOOL WINAPI RSSetPage (LPRENDSERVER lprs,RSOrigin_t origin,int offset) ;

// These will be called once a page or job ack
// is received (indicating the target has confirmed them.
//
// The last page will call JobAck and not PageAck
//   - thus if these are 5 pages there will be 4 page acks and one job ack

EXPORT_DLL void WINAPI RSSetPageAckCallback(LPRENDSERVER lprs,LPFNACKPROC lpfnAckProc,LPVOID lpvData) ;
EXPORT_DLL void WINAPI RSSetJobAckCallback(LPRENDSERVER lprs,LPFNACKPROC lpfnAckProc,LPVOID lpvData) ;
EXPORT_DLL void WINAPI RSSetStatusCallback(LPRENDSERVER lprs,LPFNSTATUSPROC lpfnStatusProc,LPVOID lpvData) ;
EXPORT_DLL void WINAPI RSSetSrcJobAckCallback(LPRENDSERVER lprs,LPFNACKPROC lpfnAckProc,LPVOID lpvData) ;

EXPORT_DLL void WINAPI RSPause (LPRENDSERVER lprs) ;
EXPORT_DLL void WINAPI RSResume (LPRENDSERVER lprs) ;

EXPORT_DLL void WINAPI RSAbort (LPRENDSERVER lprs) ;
EXPORT_DLL BOOL WINAPI RSSpool (LPRENDSERVER lprs) ;

EXPORT_DLL BOOL WINAPI RSIsBlocking(LPRENDSERVER lprs) ;
EXPORT_DLL BOOL WINAPI RSIsPaused(LPRENDSERVER lprs)  ;
EXPORT_DLL BOOL WINAPI RSIsDone(LPRENDSERVER lprs) ;
EXPORT_DLL BOOL WINAPI RSIsInit(LPRENDSERVER lprs) ;
EXPORT_DLL BOOL WINAPI RSIsOpen(LPRENDSERVER lprs) ;


// This will take the device structures and create a topology using format resolution
// If this succeeds it will render the entire topology calling yield where appropriate 
// and then returning when complete or an error occurs


// If this returns FALSE then this the function will fail and return FALSE

typedef BOOL (WINAPI *LPFNYIELDPROC) (LPVOID lpvData) ;

EXPORT_DLL BOOL WINAPI RSFormatAndRender (lpRSDeviceInfo_t lpSrcInfo,
					  lpRSDeviceInfo_t lpTgtInfo,
					  LPJOBINFO lpJobInfo,
					  LPFNYIELDPROC lpfnYieldProc,
					  LPVOID lpvData) ;

#define ORD_RSFormatAndRender MAKEINTRESOURCE(100) // "RSFormatAndRender"
typedef BOOL (* WINAPI LPFN_RSFormatAndRender)
	(lpRSDeviceInfo_t, lpRSDeviceInfo_t, LPJOBINFO, LPFNYIELDPROC, LPVOID);

	
#ifdef IFAX

typedef struct RSRInfo_t {
    DWORD dwIndex ;
    lpRSDeviceInfo_t lpSrcInfo ;
    lpRSDeviceInfo_t lpTgtInfo ;
    lpTopology lpTop ;
    LPJOBINFO lpJobInfo ;
} RSRInfo_t ;

/********
    @doc    EXTERNAL    RENDERSERV

    @types  RSReason_t  |   The callback function can be called for any of these reasons.

    @emem   RSREASON_NONE  |   No specific reason - simply a test.

    @emem   RSREASON_INIT  |   This is to initialize the structure.  The callback function
            is responsible for setting the following fields of the Render_t structure:

            lpSrcInfo: The source device information structure.
            lpTgtInfo: The target device information structure.
            lpTop    : The topology structure.
            lpJobInfo: The job information structure if required by renderers.
	    hjc      : The job context identifier.
	    hwnd     : The hwnd to have messages for pipe posted to.

    @emem   RSREASON_START  |   Indicates that the rendering will begin.

    @emem   RSREASON_DONE  |   Indicates that rendering is complete.

    @emem   RSREASON_DEINIT  |   Indicates the job information should be freed.  Anything 
            allocated in RSREASON_INIT should be freed.  This is guaranteed to be call if
            the callback returned TRUE from the RSREASON_INIT callback - even if an error
            occurs.

    @emem   RSREASON_STATUS  |   If the status flag was passed in the RSRender call then
            this contains status information.  Not defined yet!

    @emem   RSREASON_YIELD  |   If the yield flag was specified then this gives the callback 
            the opportunity to do other work - such as process the message queue.

    @emem   RSREASON_ERROR  |   Indicates an error has occurred and rendering will be terminated.

********/

typedef enum {
    RSREASON_NONE = 0,
    RSREASON_INIT,
    RSREASON_START,
    RSREASON_DONE,
    RSREASON_DEINIT,

    RSREASON_STATUS,
    RSREASON_YIELD,
    RSREASON_ERROR,
} RSReason_t ;

typedef struct Render_t FAR * LPRender_t ;

typedef BOOL (WINAPI *LPFNRENDSERVPROC) (LPVOID lpvData,DWORD fdwReason,LPRender_t lpRenderData) ;

#define RSR_ASYNC_MODE    0x00000001      // The call will be asyncronous
#define RSR_STATUS_MODE   0x00000002      // Callback will be done for status
#define RSR_YIELD_MODE    0x00000004      // In sync mode yield will be called

EXPORT_DLL BOOL WINAPI RSRenderData(DWORD fdwFlags,
				    LPFNRENDSERVPROC lpfnRSProc,
				    LPVOID lpvData) ;

typedef struct Render_t {
    DWORD fdwFlags ;
    LPFNRENDSERVPROC lpfnRSProc ;
    LPVOID lpvData ;
    
    DWORD dwIndex ;
    lpRSDeviceInfo_t lpSrcInfo ;
    lpRSDeviceInfo_t lpTgtInfo ;
    lpTopology lpTop ;
    LPJOBINFO lpJobInfo ;
    HJC hjc ;
    HWND hwnd ;
    
    WORD wPageNum ;
    WORD wkbytes ;

    DWORD dwError ;

    LPRENDSERVER lprs ;
} Render_t ;

//
// MAPI Specific calls
//

typedef LPVOID LPSOSREND ;

LPSOSREND WINAPI SRSAlloc () ;
void WINAPI SRSFree (LPSOSREND lprs) ;
	
BOOL WINAPI SRSInit (LPSOSREND lprs) ;
BOOL WINAPI SRSOpen (LPSOSREND lprs,ENTRYIDSOS src,ENTRYIDSOS tgt,HJC hjc,HWND hwnd) ;
BOOL WINAPI SRSClose (LPSOSREND lprs) ;
	
LRESULT WINAPI SRSWndProc (LPSOSREND lprs,UINT msg,WPARAM wParam,LPARAM lParam) ;

// This will open the attachment

BOOL WINAPI SRSSetCurAttachNum (LPSOSREND lprs,UINT num) ;

// This will automatically advance to next attachment if autoadvance is TRUE (default)
// If autoadvance is true - the job is done after the last attachent otherwise it
// will be set to true after the current attachment is completed.
//
// If SetCurAttachNum is called the done flag will be reset to FALSE

BOOL WINAPI SRSRender (LPSOSREND lprs,UINT nIterations) ;

LPBUFFER WINAPI SRSGetBuf (LPSOSREND lprs) ;
BOOL WINAPI SRSSetPage (LPSOSREND lprs,RSOrigin_t origin,int offset) ;

BOOL WINAPI SRSGetAutoAdvance (LPSOSREND lprs) ;
void WINAPI SRSSetAutoAdvance (LPSOSREND lprs,BOOL badv) ;

ULONG WINAPI SRSGetNumAttach (LPSOSREND lprs) ;
ULONG WINAPI SRSGetCurAttachNum (LPSOSREND lprs) ;

void WINAPI SRSPause (LPSOSREND lprs) ;
void WINAPI SRSResume (LPSOSREND lprs) ;

void WINAPI SRSAbort (LPSOSREND lprs) ;
BOOL WINAPI SRSSpool (LPSOSREND lprs) ;
BOOL WINAPI SRSPartSave (LPSOSREND lprs) ;

BOOL WINAPI SRSIsBlocking(LPSOSREND lprs) ;
BOOL WINAPI SRSIsPaused(LPSOSREND lprs)  ;
BOOL WINAPI SRSIsDone(LPSOSREND lprs) ;
BOOL WINAPI SRSIsInit(LPSOSREND lprs) ;
BOOL WINAPI SRSIsOpen(LPSOSREND lprs) ;

LPRENDSERVER WINAPI SRSGetRendServer(LPSOSREND lprs) ;

BOOL WINAPI RSRecoverMsg (LPMESSAGESOS lpMsg) ;
UINT WINAPI RSCalculatePageCount(lpRSDeviceInfo_t lpinfo) ;

#endif

#ifdef __cplusplus
} // extern "C"
#endif

#endif // _RENDSERV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\render.h ===
// Copyright (C) Microsoft Corp. 1993
/*==============================================================================
This include file defines the API between the rendserv.dll and renderers.

DATE         NAME       COMMENTS
25-Jun-93    RajeevD    Created.
==============================================================================*/

#ifndef _INC_RENDER
#define _INC_RENDER

#include <ifaxos.h>

#ifdef __cplusplus
extern "C" {
#endif

/***********************************************************************
@doc	RENDER	EXTERNAL	

@type	LPVOID|LPJOB|The renderer context pointer.  This is used by the renderers
	for interfacing to the Rendering Server.
*************************************************************************/

typedef LPVOID LPJOB ;

//
// This function takes the job handle and parameters and renders 
// data with callbacks to the job
//
// On error returns false and returns error with SetLastError()
//

/***********************************************************************
@doc	RENDER	EXTERNAL	

@api	BOOL|RENDERPROC|The main rendering function provided by the renderer.

@parm	LPJOB|lpJob|The Rendering Server handle.  This is used when the renderer
		makes any calls to Rendering Server APIs.

@parm	LPVOID|lpParam|The renderer specific parameter.  This is completely opaque
		to the Rendering Server and is obtained from the topology structure.

@rdesc	Returns TRUE on success or FALSE on failure.  If there was a failure and FALSE
	was return, SetLastError must contain the error information.  If a Rendering 
	Server API failure caused the error, then its error must be return in SetLastError.
*************************************************************************/

typedef BOOL (WINAPI RENDERPROC) (LPJOB lpJob, LPVOID lpParam);
typedef RENDERPROC *LPFN_RENDERPROC ;

/***********************************************************************

@doc	RENDER	EXTERNAL	

@types	RENDERINFO|Structure containing general information about a renderer.

@field	WORD|cbStruct|The Size of the structure.
@field	WORD|cbMinStack|The minimum stack size required by the renderer.
@field	LPFM_RENDERPROC|lpfnRenderProc|The main rendering function for the renderer.
@field	DWORD|dwFlags|Flags containing renderer information.

@xref	<f RENDERGETINFOPROC>
*************************************************************************/

typedef struct {
    WORD cbStruct;                    // set to size of this structure
    WORD cbMinStack;                  // Minimal Stack size
    LPFN_RENDERPROC lpfnRenderProc ;  // Pointer to Render function
    DWORD dwFlags;                    // fields defined above...
} RENDERINFO, FAR *LPRENDERINFO;

//
// This will be called to get the renderer information
// The Info structure will be passed in the size set and the renderer should
// set the size to be its versions
//
// On error returns false and returns error with SetLastError()
//

/***********************************************************************

@doc	RENDER	EXTERNAL	

@api	BOOL|RENDERGETINFOPROC|This function is provided by each renderer.  The Rendering
		Server will call this function to get the <t RENDERINFO> structure.

@parm	LPRENDERINFO|lpInfo|The render info structure used to obtain general renderer
		information.  This is allocated by the Rendering Server and its size is
		stored in the cbStruct field.

@rdesc	Returns TRUE on success or FALSE on failure.  If the renderer returns TRUE all
	known fields should be filled in and cbStruct should be set to indicate which
	fields were known by the renderer.
*************************************************************************/

typedef BOOL (WINAPI RENDERGETINFOPROC) (LPRENDERINFO lpInfo) ;
typedef RENDERGETINFOPROC * LPFN_RENDERGETINFOPROC ;

/*==============================================================================
The JOBINFO structure is used to pass per-job parameters to a renderer.
==============================================================================*/
typedef struct
{
	WORD   cbStruct;  // size of this structure
	LPVOID lpSession; // LPSOSSESSION 
	LPVOID lpMsg  ;   // LPMESSAGESOS message handle (Src message)
	ULONG  nAttach ;  // The attachment number
}
	JOBINFO, FAR * LPJOBINFO;
	
/*==============================================================================
The following buffer services are provided by rendserv.dll:
	RSGetInBuf() gets an input buffer from the input queue.
	RSPutOutBuf() puts an output buffer in the output queue.
	RSGetFreeBuf() gets an empty buffer from the free pool.
  RSPutFreebuf() puts an empty buffer into the free pool.	
  RSMemAlloc() allocates memory
  RSMemFree() frees memory
==============================================================================*/
LPBUFFER  WINAPI RSGetInBuf    (LPJOB lpJob);
BOOL      WINAPI RSPutOutBuf   (LPJOB lpJob, LPBUFFER lpbufOut);
LPBUFFER  WINAPI RSGetFreeBuf  (LPJOB lpJob, SHORT sBufSize);
void      WINAPI RSPutFreeBuf  (LPJOB lpJob, LPBUFFER lpbufFree);
LPVOID    WINAPI RSMemAlloc    (LPJOB lpJob, UINT fuAlloc, LONG lAllocSize,LPWORD lpwActualSize);
BOOL      WINAPI RSMemFree     (LPJOB lpJob, LPVOID lpvMem);
LPJOBINFO WINAPI RSGetJobInfo  (LPJOB lpJob);
BOOL      WINAPI RSYield       (LPJOB lpJob) ;

#define RSGlobalAlloc(a,b,c,d) RSMemAlloc(a,b,c,d)
#define RSGlobalFree(a,b) RSMemFree(a,b)

#ifdef __cplusplus
} // extern "C"
#endif

#endif // _INC_RENDER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\rl_debug.h ===
////////////////////////
// debugging
///////////////////////
#ifdef DEFINE_T30_GLOBALS
    #define DEFINE_T30_EXTERNAL
#else
    #define DEFINE_T30_EXTERNAL   extern
#endif

DEFINE_T30_EXTERNAL  int     gfScrnPrint;
DEFINE_T30_EXTERNAL  int     gfFilePrint;
DEFINE_T30_EXTERNAL  HANDLE  ghLogFile;
DEFINE_T30_EXTERNAL  HFILE   ghComLogFile;

#define SIMULATE_ERROR_TX_IO      1
#define SIMULATE_ERROR_RX_IO      2
#define SIMULATE_ERROR_TX_TIFF    3
#define SIMULATE_ERROR_RX_TIFF    4
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\resexec.h ===
// Copyright (c) Microsoft Corp. 1994

// Resource Executor API

#ifndef _RESEXEC_
#define _RESEXEC_

#ifdef __cplusplus
extern "C" {
#endif

#ifdef IFBGPROC
#ifndef _BITMAP_
#define _BITMAP_

// Win 3.1 Bitmap
typedef struct
{
	int     bmType;
	int     bmWidth;
	int     bmHeight;
	int     bmWidthBytes;
	BYTE    bmPlanes;
	BYTE    bmBitsPixel;
	void FAR* bmBits;
}
	BITMAP, FAR *LPBITMAP;

#endif // _BITMAP_	
#endif // IFBGPROC

typedef struct
{
	WORD wReserved;
	WORD wSize;             // size of this block
	LPBYTE lpData;          // pointer to frame data
}
	FRAME, FAR *LPFRAME;

HANDLE                 // context handle (NULL on failure)
WINAPI hHREOpen
(
	LPVOID lpReserved,   // reserved: set to NULL
	UINT   cbLine,       // maximum page width in bytes
	UINT   cResDir       // entries in resource directory
);

UINT   WINAPI uiHREWrite (HANDLE, LPFRAME, UINT);

UINT   WINAPI uiHREExecute
(
	HANDLE   hRE,        // resource executor context
  LPBITMAP lpbmBand,   // output band buffer
  LPVOID   lpBrushPat  // array of 32x32 brush patterns
);

UINT   WINAPI uiHREClose (HANDLE);

void   WINAPI UnpackGlyphSet (LPVOID, LPVOID);

#ifdef __cplusplus
} // extern "C"
#endif

#endif // _RESEXEC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\smapi.h ===
/* Simple MAPI functions */

#ifndef MAPI_H
#include <mapi.h>
#endif

#if			defined(__cplusplus)
extern	"C"
{
#endif


extern HINSTANCE	hlibMAPI;

typedef ULONG (FAR PASCAL *LPFNMAPILOGON)(ULONG ulUIParam, LPSTR lpszProfileName,
	LPSTR lpszPassword, FLAGS flFlags, ULONG ulReserved, LPLHANDLE lplhSession);

typedef ULONG (FAR PASCAL *LPFNMAPILOGOFF)(LHANDLE lhSession, ULONG ulUIParam, 
	FLAGS flFlags, ULONG ulReserved);

typedef ULONG (FAR PASCAL *LPFNMAPISENDMAIL)(LHANDLE lhSession, ULONG ulUIParam,
	lpMapiMessage lpMessage, FLAGS flFlags, ULONG ulReserved);

typedef ULONG (FAR PASCAL *LPFNMAPISENDDOCUMENTS)(ULONG ulUIParam, LPSTR lpszDelimChar,
	LPSTR lpszFilePaths, LPSTR lpszFileNames, ULONG ulReserved);

typedef ULONG (FAR PASCAL *LPFNMAPIFINDNEXT)(LHANDLE lhSession, ULONG ulUIParam,
	LPSTR lpszMessageType, LPSTR lpszSeedMessageID, FLAGS flFlags,
	ULONG ulReserved, LPSTR lpszMessageID);

typedef ULONG (FAR PASCAL *LPFNMAPIREADMAIL)(LHANDLE lhSession, ULONG ulUIParam,
	LPSTR lpszMessageID, FLAGS flFlags, ULONG ulReserved,
	lpMapiMessage FAR *lppMessage);

typedef ULONG (FAR PASCAL *LPFNMAPISAVEMAIL)(LHANDLE lhSession, ULONG ulUIParam,
	lpMapiMessage lpMessage, FLAGS flFlags, ULONG ulReserved,
	LPSTR lpszMessageID);

typedef ULONG (FAR PASCAL *LPFNMAPIDELETEMAIL)(LHANDLE lhSession, ULONG ulUIParam,
	LPSTR lpszMessageID, FLAGS flFlags, ULONG ulReserved);

typedef ULONG (FAR PASCAL *LPFNMAPIFREEBUFFER)(LPVOID pv);

typedef ULONG (FAR PASCAL *LPFNMAPIADDRESS)(LHANDLE lhSession, ULONG ulUIParam,
	LPSTR lpszCaption, ULONG nEditFields, LPSTR lpszLabels, ULONG nRecips,
	lpMapiRecipDesc lpRecips, FLAGS flFlags, ULONG ulReserved,
	LPULONG lpnNewRecips, lpMapiRecipDesc FAR *lppNewRecips);

typedef ULONG (FAR PASCAL *LPFNMAPIDETAILS)(LHANDLE lhSession, ULONG ulUIParam,
	lpMapiRecipDesc lpRecip, FLAGS flFlags, ULONG ulReserved);

typedef ULONG (FAR PASCAL *LPFNMAPIRESOLVENAME)(LHANDLE lhSession, ULONG ulUIParam,
	LPSTR lpszName, FLAGS flFlags, ULONG ulReserved,
	lpMapiRecipDesc FAR *lppRecip);

extern LPFNMAPILOGON lpfnMAPILogon;
extern LPFNMAPILOGOFF lpfnMAPILogoff;
extern LPFNMAPISENDMAIL lpfnMAPISendMail;
extern LPFNMAPISENDDOCUMENTS lpfnMAPISendDocuments;
extern LPFNMAPIFINDNEXT lpfnMAPIFindNext;
extern LPFNMAPIREADMAIL lpfnMAPIReadMail;
extern LPFNMAPISAVEMAIL lpfnMAPISaveMail;
extern LPFNMAPIDELETEMAIL lpfnMAPIDeleteMail;
extern LPFNMAPIFREEBUFFER lpfnMAPIFreeBuffer;
extern LPFNMAPIADDRESS lpfnMAPIAddress;
extern LPFNMAPIDETAILS lpfnMAPIDetails;
extern LPFNMAPIRESOLVENAME lpfnMAPIResolveName;

#undef MAPILogon
#undef MAPILogoff
#undef MAPISendMail
#undef MAPISendDocuments
#undef MAPIFindNext
#undef MAPIReadMail
#undef MAPISaveMail
#undef MAPIDeleteMail
#undef MAPIFreeBuffer
#undef MAPIAddress
#undef MAPIDetails
#undef MAPIResolveName
#define MAPILogon			(*lpfnMAPILogon)
#define MAPILogoff			(*lpfnMAPILogoff)
#define MAPISendMail		(*lpfnMAPISendMail)
#define MAPISendDocuments	(*lpfnMAPISendDocuments)
#define MAPIFindNext		(*lpfnMAPIFindNext)
#define MAPIReadMail		(*lpfnMAPIReadMail)
#define MAPISaveMail		(*lpfnMAPISaveMail)
#define MAPIDeleteMail		(*lpfnMAPIDeleteMail)
#define MAPIFreeBuffer		(*lpfnMAPIFreeBuffer)
#define MAPIAddress			(*lpfnMAPIAddress)
#define MAPIDetails			(*lpfnMAPIDetails)
#define MAPIResolveName		(*lpfnMAPIResolveName)

extern BOOL InitSimpleMAPI(void);
extern void DeinitSimpleMAPI(void);


#if			defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\root.h ===
// headers\et30type.h is assumed to be included
// ET30ACTION, ET30EVENT

// headers\timeouts.h ... TO
// headers\fr.h       ... IFR


#define  MODEM_CLASS1     1
#define  MODEM_CLASS2     2
#define  MODEM_CLASS2_0   3

typedef ET30ACTION ( __cdecl FAR* LPWHATNEXTPROC)(LPVOID, ET30EVENT, ...);


typedef struct {
        LPWHATNEXTPROC  lpfnWhatNext;
        HMODEM                  hModem;         // Modem driver handle
        HLINE                   hLine;          // NCU driver handle
} ET30PARAMS;


#define MAXRECVFRAMES   20

typedef struct {
        LPFR    rglpfr[MAXRECVFRAMES];
        BYTE    b[];
} FRAMESPACE, far* LPFRAMESPACE;


typedef struct {
        LPFRAMESPACE    lpfs;           // ptr to storage for recvd frames
        UWORD           Nframes;        // Number of recvd frames

        IFR             ifrCommand,
                        ifrResp,
                        ifrSend;
        USHORT          uTrainCount;

        USHORT          uRecvTCFMod;    // for fastexit stuff
        // set this from the DCS and jump straight into RecvTCF

        // Used to decide whether to insert a 1 bit or not (T30 sec 5.3.6.1)
        BOOL            fReceivedDIS;
        BOOL            fReceivedDTC;
        BOOL            fReceivedEOM;
        BOOL            fAtEndOfRecvPage;
        LONG            sRecvBufSize;
        TO              toT1;                   // This is used in MainBody.

#ifdef IFK
        TO              toBuf;                  // This is used to wait for a free buffer
#endif

        // INI file settings related stuff
        USHORT  uSkippedDIS;

        // flag to know when we are doing send-after-send, and so should use
        // SendSilence instead of RecvSilence. If we dont do this, we take
        // too long & Ricoh's protocol tester complains. This is 7071, 7100
        BOOL    fSendAfterSend;

#ifdef MDDI
#       define CLEAR_MISSED_TCFS()
#else // !MDDI
        // Some modems can't train at higher speeds (timeout or return
        // ERRROR on AT+FRM=xxx) with other specific devices, but are OK at lower
        // speeds. So we keep track of the number of times we try to get the TCF,
        // and after the 2nd failed attempt, send an FTT instead of going to
        // node F.
#       define CLEAR_MISSED_TCFS() (pTG->T30.uMissedTCFs=0)
#       define MAX_MISSED_TCFS_BEFORE_FTT 2
        USHORT uMissedTCFs;
#endif  // !MDDI

#ifdef ADAPTIVE_ANSWER
        BOOL fEnableHandoff;
#endif // ADAPTIVE_ANSWER

} ET30T30;



typedef struct {
        DWORD   dwPageSize;     // Size of current page in bytes
        USHORT  uFrameSize;
        USHORT  SendPageCount,
                SendBlockCount,
                SendFrameCount;
        USHORT  FramesSent;
        USHORT  uPPRCount;
        BOOL    fEndOfPage;
        TO      toT5;                   // Used in RR_RNRLoop().

        // Used for suppressing ST_FLAG in first PhaseC following
        // a CTC/CTR (for V.17)
        BOOL    fSentCTC;
        BOOL    fRecvdCTC;

        // Used in Recv
        IFR     ifrPrevCommand;
        BOOL    fRecvEndOfPage;
        BYTE    bRecvBadFrameMask[32];
        BYTE    bPrevPPS[4];
        IFR     ifrPrevResponse;
} ET30ECM;



typedef enum { modeNONE=0, modeNONECM, modeECM, modeECMRETX } PHASECMODE;

typedef struct {
        IFR             ifrLastSent;
        PHASECMODE      modePrevRecv;
        BOOL            fGotWrongMode;
} ET30ECHOPROTECT;














//
// headers\awnsfint.h is assumed to be included
// force include to class1\*.c

#pragma pack(1)         // ensure packed structure

typedef struct {
        BYTE    G1stuff         :3;
        BYTE    G2stuff         :5;

        BYTE    G3Tx            :1; // In DIS indicates poll doc avail. Must be 0 in DCS.
        BYTE    G3Rx            :1;     // Must set to 1 in BOTH DCS/DTC
        BYTE    Baud            :4;
        BYTE    ResFine_200     :1;
        BYTE    MR_2D           :1;

        BYTE    PageWidth       :2;
        BYTE    PageLength      :2;
        BYTE    MinScanCode     :3;
        BYTE    Extend24        :1;

        BYTE    Hand2400        :1;
        BYTE    Uncompressed    :1;
        BYTE    ECM                             :1;
        BYTE    SmallFrame              :1;
        BYTE    ELM                             :1;
        BYTE    Reserved1               :1;
        BYTE    MMR                             :1;
        BYTE    Extend32                :1;

        BYTE    WidthInvalid    :1;
        BYTE    Width2                  :4;
        // 1 == WidthA5_1216
        // 2 == WidthA6_864
        // 4 == WidthA5_1728
        // 8 == WidthA6_1728
        BYTE    Reserved2               :2;
        BYTE    Extend40                :1;

        BYTE    Res8x15                 :1;
        BYTE    Res_300                 :1;
        BYTE    Res16x15_400    :1;
        BYTE    ResInchBased    :1;
        BYTE    ResMetricBased  :1;
        BYTE    MinScanSuperHalf:1;
        BYTE    SEPcap                  :1;
        BYTE    Extend48                :1;

        BYTE    SUBcap                  :1;
        BYTE    PWDcap                  :1;
        BYTE    CanEmitDataFile :1;
        BYTE    Reserved3               :1;
        BYTE    BFTcap                  :1;
        BYTE    DTMcap                  :1;
        BYTE    EDIcap                  :1;
        BYTE    Extend56                :1;

        BYTE    BTMcap                  :1;
        BYTE    Reserved4               :1;
        BYTE    CanEmitCharFile :1;
        BYTE    CharMode                :1;
        BYTE    Reserved5               :3;
        BYTE    Extend64                :1;

} DIS, far* LPDIS, near* NPDIS;

#pragma pack()


#define MAXFRAMES       10
#define MAXSPACE        512

typedef struct
{
        USHORT  uNumFrames;
        USHORT  uFreeSpaceOff;
        LPFR    rglpfr[MAXFRAMES];
        BYTE    b[MAXSPACE];
}
RFS, near* NPRFS;


#define IDFIFSIZE       20    // from protocol\protocol.h

typedef struct {
        BOOL    fInUse;

        ////////////////////////// Client BC parameters
        BCwithTEXT      RecvCaps;                       // ==> NSF/DIS recved
        DWORD           RecvCapsGuard;
        BCwithTEXT      RecvParams;                     // ==> NSS/DCS recvd
        DWORD           RecvParamsGuard;
        BCwithPOLL      RecvPollReq;            // ==> NSC/DTC recvd
        DWORD           RecvPollReqGuard;

        BCwithTEXT      SendCaps;                       // ==> NSF/DIS sent
        DWORD           SendCapsGuard;
        BCwithTEXT      SendParams;                     // ==> NSS/DCS sent
        DWORD           SendParamsGuard;
        BCwithPOLL      SendPollReq;            // ==> NSC/DTC sent
        DWORD           SendPollReqGuard;

        // LPBC lpbcSendCaps;                   // ==> NSF/DIS sent
        // LPBC lpbcSendParams;                 // ==> NSS/DCS sent
        // LPBC lpbcSendPollReq;                // ==> NSC/DTC sent

        BOOL    fRecvCapsGot;
        BOOL    fSendCapsInited;
        BOOL    fSendParamsInited;
        BOOL    fRecvParamsGot;
        BOOL    fRecvPollReqGot;
        BOOL    fSendPollReqInited;

        ////////////////////////// Hardware parameters
        LLPARAMS        llRecvCaps;             // DIS recvd
        LLPARAMS        llSendCaps;             // DIS sent---use uRecvSpeeds
        LLPARAMS        llSendParams;   // used to negotiate DCS--use uSendSpeeds
        LLPARAMS        llNegot;                // DCS sent
        LLPARAMS        llRecvParams;   // recvd DCS

        BOOL            fllRecvCapsGot;
        BOOL            fllSendCapsInited;
        BOOL            fllSendParamsInited;
        BOOL            fllNegotiated;
        BOOL            fllRecvParamsGot;

        BOOL    fHWCapsInited;

        USHORT  HighestSendSpeed;
        USHORT  LowestSendSpeed;

        ////////////////////////// Flags to make decisions with
        // BYTE NextSend;
        // BOOL fSendingECM;
        // BOOL fReceivingECM;
        BOOL    fPageOK;
        BOOL    fAbort;

        ////////////////////////// Current Send/Recv params (to return on ExtFunc)
        // USHORT       uCurRecvBaud;
        // USHORT       uMinBytesPerLine;
        // USHORT       uCurECMFrameSize;
        // USHORT       uRecvECMFrameSize;
        USHORT  uFramesInThisBlock;


        ///////////////////////// NSF/NSC/NSS Received Frames
        RFS             RecvdNS;

        ///////////////////////// CSI/TSI/CIG Received Frames
        BOOL    fRecvdID;
        BYTE    bRemoteID[IDFIFSIZE+1];

        ///////////////////////// DIS Received Frames
        DIS     RemoteDIS;
        USHORT  uRemoteDISlen;
        BOOL    fRecvdDIS;

        ///////////////////////// DTC Received Frames
        DIS     RemoteDTC;
        USHORT  uRemoteDTClen;
        BOOL    fRecvdDTC;

        ///////////////////////// DCS Received Frames
        DIS             RemoteDCS;
        USHORT  uRemoteDCSlen;
        BOOL    fRecvdDCS;

        ///////////////////////// ECM Received Frames
        BYTE    bRemotePPR[32];
        BOOL    fRecvdPPR;
        BYTE    bRemotePPS[4];  // only 3 bytes, but use 4 so we can cast to DWORD
        BOOL    fRecvdPPS;

        ///////////////////////// SUB (subaddress) Received Frames
        BOOL    fRecvdSUB;
        BYTE    bRecipSubAddr[IDFIFSIZE+1];

}
PROT, near* NPPROT;




//
// protapi.h  includes protparm.h
// which defines PROTPARAMS
//


typedef struct
{
        USHORT  uSize;
        SHORT   Class;
        SHORT   PreambleFlags,
                InterframeFlags,
                ClosingFlags;
}
MODEMPARAMS, far* LPMODEMPARAMS;









#define COMMANDBUFSIZE  40


typedef struct {
        // TO           toDialog, toZero;
        TO              toRecv;
        // BYTE bLastReply[REPLYBUFSIZE+1];

        BYTE    bCmdBuf[COMMANDBUFSIZE];
        USHORT  uCmdLen;
        BOOL    fHDLC;
        USHORT  CurMod;
        enum    {SEND, RECV, IDLE } DriverMode;
        enum    {COMMAND, FRH, FTH, FTM, FRM} ModemMode;
        BOOL    fRecvNotStarted;
        // SHORT        sRecvBufSize;

        HWND    hwndNotify;
        BOOL    fSendSWFraming;
        BOOL    fRecvSWFraming;

        enum {RECV_FCS_DUNNO=0, RECV_FCS_NO, RECV_FCS_CHK, RECV_FCS_NOCHK} eRecvFCS;
                // Whether this modem appends FCS on HDLC recv.
                // Modems with AT&T bug don't append FCS.
                // Currently we determine this at run time.

#ifdef ADAPTIVE_ANSWER
        BOOL fEnableHandoff;
#endif // ADAPTIVE_ANSWER

} CLASS1_MODEM;




typedef struct {
        // BYTE fModemInit              :1;             // Reset & synced up with modem
        // BYTE fOffHook                :1;             // Online (either dialled or answered)
        USHORT  ifrHint;                                // current hint
        // BOOL fNCUAbort;                              // When set, means Abort Dial/Answer
} CLASS1_STATUS;




typedef struct
{
        USHORT  uComPort;
        BOOL    fLineInUse;
        BOOL    fModemOpen;
        BOOL    fNCUModemLinked;
}
CLASS1_DDI;


















#define OVBUFSIZE 4096

typedef struct
{
        enum {eDEINIT, eFREE, eALLOC, eIO_PENDING} eState;
        OVERLAPPED ov;
        char rgby[OVBUFSIZE];   // Buffer associated with this overlapped struct.
        DWORD dwcb;                             // Current count of data in this buffer.
} OVREC;

typedef struct
{
        // Timeouts
        DWORD dwTOOutShortInactivity;
        DWORD dwTOOutLongInactivity;
        DWORD dwTOOutShortDeadComm;
        DWORD dwTOOutLongDeadComm;
        DWORD dwTOInOneChar;

} FCOMSETTINGS, FAR * LPFCOMSETTINGS;

typedef struct {
        LONG_PTR             nCid;           // _must_ be 32bits in WIN32 (has to hold a HANDLE) -- AJR 12/16/97, change to LONG_PTR for 64 bits
        int                 CommErr;        // _must_ be 32bits in WIN32
        UWORD   cbInSize;
        UWORD   cbOutSize;
        DCB             dcb;
#ifdef METAPORT
        DCB             dcbOrig;
        BOOL    fExternalHandle;
        BOOL    fStateChanged;
#endif
        COMSTAT comstat;
        BYTE    bDontYield;             // Was a BOOL, now a counter.
#ifdef NTF
        HWND    hwndNotify;             // can use this for timer msgs
#endif
#ifdef WFWBG
        BOOL    fBG;
#endif
        TO              toCommDead, toOnechar, toDrain;
        USHORT  uInterruptOverunCount;
        USHORT  uBufferOverflowCount;
        USHORT  uFramingBreakErrorCount;
        USHORT  uOtherErrorCount;
        BOOL    fCommOpen;

        FCOMSETTINGS CurSettings;

#ifdef WIN32

#       define NUM_OVS 2  // Need atleast 2 to get true overlaped I/O

        // We maintain a queue of overlapped structures, having upto
        // NUM_OVS overlapped writes pending. If NUM_OVS writes are pending,
        // we do a GetOverlappedResult(fWait=TRUE) on the earliest write, and
        // then reuse that structure...

        OVERLAPPED ovAux;       // For ReadFile and WriteFile(MyWriteComm only).

        OVREC rgovr[NUM_OVS]; // For WriteFile
        UINT uovFirst;
        UINT uovLast;
        UINT covAlloced;
        BOOL fDoOverlapped;
        BOOL fovInited;

        OVREC *lpovrCur;

#endif // WIN32

#ifdef ADAPTIVE_ANSWER
        BYTE fEnableHandoff:1;  // True if we are to enable adaptive answer
        BYTE fDataCall:1;               // True if a data call is active.
#endif // ADAPTIVE_ANSWER

} FCOM_COMM;







//
// NCUPARAMS is defined in headers\ncuparm.h, included by .\modemddi.h
// we will force define modemddi.h
//






#define REPLYBUFSIZE    400
#define MAXKEYSIZE              128



typedef struct {
        BYTE    fModemInit              :1;             // Reset & synced up with modem
        BYTE    fOffHook                :1;             // Online (either dialled or answered)
        BOOL    fInDial, fInAnswer, fInDialog;
} FCOM_STATUS;


typedef struct {
        DWORD dwDialCaps;       // One of the LINEDEVCAPSFLAGS_* defined in filet30.h
                                                // (and also in tapi.h)
} MODEMEXTCAPS, FAR *LPMODEMEXTCAPS;



typedef struct {
        BYTE    bLastReply[REPLYBUFSIZE+1];

#ifdef ADAPTIVE_ANSWER
        BYTE    bEntireReply[REPLYBUFSIZE+1]; // Used only for storing
#endif // ADAPTIVE_ANSWER

        TO              toDialog, toZero;
        CMDTAB          CurrCmdTab;
        MODEMCAPS       CurrMdmCaps;
        MODEMEXTCAPS CurrMdmExtCaps;

        // Following point to the location of the profile information.
#       define MAXKEYSIZE 128
        DWORD   dwProfileID;
        char    rgchKey[MAXKEYSIZE];
        char    rgchOEMKey[MAXKEYSIZE];


} FCOM_MODEM;




// Inst from fxrn\efaxrun.h

typedef enum { IDLE1, BEFORE_ANSWER, BEFORE_RECVCAPS, SENDDATA_PHASE,
                                SENDDATA_BETWEENPAGES, /** BEFORE_HANGUP, BEFORE_ACCEPT, **/
                                BEFORE_RECVPARAMS, RECVDATA_PHASE, RECVDATA_BETWEENPAGES,
                                SEND_PENDING } STATE;

#define MAXRECV                 50
#define FILENAMESIZE    15
#define PHONENUMSIZE    60
#define PATHSIZE                150
#define MAXUSERATCMDLEN 80
#define MAXSECTIONLENGTH 80

typedef struct
{
        USHORT  uNumPages;      // keep a running tally as we process the file
        USHORT  vMsgProtocol;
        USHORT  vSecurity;
        USHORT  Encoding;
#ifdef COMPRESS
        USHORT  vMsgCompress;
#endif
        DWORD   AwRes;
        USHORT  PageWidth;
        USHORT  PageLength;
        USHORT  fLin;
        USHORT  fLastPage;

        DWORD   lNextHeaderOffset;
        DWORD   lDataOffset;
        DWORD   lDataSize;

        enum    {
                                RFS_DEINIT=0,   // Either before WriteFileHeader or after WriteFileEnder
                                RFS_INIT,               // After file opened, but before first StartWritePage
                                RFS_INSIDE_PAGE,        // We've called StartWritePage but not EndWritePage
                                RFS_AFTER_PAGE  // After EndWritePage
                        } erfs; // Receive File State

        char    szID[MAXFHBIDLEN + 2];
}
AWFILEINFO, FAR* LPAWFI;

#define MAX_REMOTE_MACHINECAPS_SIZE 256
typedef struct {
        BOOL            fInited;
        BOOL            fAbort;
        BOOL            fExternalHandle; // TRUE iff the comm port handle was
                                                                 // supplied from outside.
        // BOOL         fDiskError;
        // BOOL         fInternalError;
        // BOOL         fRinging;
        STATE           state;
        HWND            hwndSend;
        HWND            hwndRecv;
        HWND            hwndListen;
        USHORT          uRingMessage; // message to post on RING
        HWND            hwndStatus;
        DWORD           dwLineID;
        USHORT          usLineIDType;
        USHORT          uModemClass;
        LONG            sSendBufSize;
        USHORT          uSendDataSize;
        BOOL            fSendPad;
        BYTE            szFaxDir[PATHSIZE + FILENAMESIZE + 1];  // add space to zap in file names
        USHORT          cbFaxDir;
        ATOM            aPhone;
        ATOM            aCapsPhone; // Phone number be used for storing capabilities..
                                                        // Typically in canonical form...
        char            szPath[PATHSIZE + FILENAMESIZE + 1];
        char            szFile[FILENAMESIZE];
        HFILE           hfileMG3, hfileEFX, hfileIFX;
        BOOL            fReceiving;
        BOOL            fSending;

#define MAXRECIPNAMELEN 128
#define MAXSUBJECTLEN   40
#define MAXSENDERLEN  40

        // default RecipName
        BYTE            szDefRecipName[MAXRECIPNAMELEN + 2];
        BYTE            szDefRecipAddr[MAXRECIPNAMELEN + 2];
        BYTE            szDefSubject[MAXSUBJECTLEN + 2];
        BYTE            szNamedSubject[MAXSUBJECTLEN + 2];
        BYTE            szDefSender[MAXSENDERLEN + 2];
        BYTE            szLocalID[MAXRECIPNAMELEN + 2];

        AWFILEINFO      awfi;

        long            cbPage;
        // long         cbPageStart;
        long            cbBlockStart;   // file ptr to start of block
        long            cbBlockSize;    // size of block so far
        HFILE           hfile;

        BCwithTEXT      SendCaps;
        BCwithTEXT      RemoteRecvCaps;
        BCwithTEXT      SendParams;
        BCwithTEXT      RecvParams;
        //BC                      RemoteRecvCaps;
        //BC                      SendParams;
        //BC                      RecvParams;

        USHORT          uPageAcks;
        USHORT          HorizScaling, VertScaling;
        USHORT          HorizScaling300dpi, VertScaling300dpi;
        NCUPARAMS       NcuParams;
        MODEMPARAMS     ModemParams;    // added in the add-class0 hack
        // HMODEM               hModem;
        // HLINE                hLine;
        PROTPARAMS      ProtParams;
        DWORD           FixSerialSpeed;
        // replaced by ProtParams
        // USHORT               HighestSendSpeed, LowestSendSpeed;
        // BOOL         fEnableV17Send, fEnableV17Recv;
        // BOOL         fDisableECM;
        // BOOL         f64ByteECM;
        BOOL            fDisableG3ECM; // If TRUE, will disable *sending* of MMR
                                                           //   (so we don't use ECM when sending to
                                                           //    fax machines).
        BOOL            fDisableSECtoMR; // If TRUE, we won't try to translate
        BOOL            fDisableMRRecv; // If TRUE, we won't advertise ability
                                                                // to receive MR..
        USHORT          uCopyQualityCheckLevel;
        BYTE            szWindowsDir[PATHSIZE + FILENAMESIZE + 1];      // add space to zap in DLL names
        USHORT          cbWindowsDir;
        BOOL            fProtInited;    // for cleanups
#ifdef TSK
        ATOM            aFileMG3, aFileIFX,     aFileEFX;
#endif //TSK
        USHORT          uRecvPageAck;
        USHORT          uNumBadPages;
#ifdef CHK
        BOOL            fRecvChecking;
#endif //CHK
#ifdef SEC
        BOOL            fSendRecoding;
        LPBUFFER        lpbfPrev;
        BOOL            fPassedEOP;
#endif //SEC

// Failure Codes

        USHORT          uFirstFailureCode;
        USHORT          uLastFailureCode;
        BOOL            fLogFailureCode; // write failures to efaxtrans.log
        HFILE           hfileFailureLog;

// Prevent re-entry in FreeOrGetDll + ProcessANswerModeReturn loop
// Re-entry can only happen inside the dialog box so we don't need
// an atomic test-and-set. See bug#1181

        BOOL            fChangingAnswerMode;

// If PostMessage of vital messages (i.e. FILET30DONE only) fails
// (which can happen if the msg queue is full), then try to post
// it again later. See bug#1276

        MSG                     PostMsg;
        DWORD   dwProfileID;
        char    rgchSection[MAXSECTIONLENGTH];

        BOOL    fInPollReq;
#ifdef POLLREQ
        USHORT  PollType;
        BOOL    fPollNoSupportErr;
        char    szDocName[MAXTOTALIDLEN+3];
        char    szPassword[MAXTOTALIDLEN+3];
        BCwithPOLL      SendPollReq;
#endif

#ifdef COMPRESS
        BOOL            fDisableCmprsSend;  // If true, we don't create compressed fls.
        BOOL            fDisableCmprsRecv;  // If true, we don't say we support cmprs.
        HFILE           hfileEFXCmprs;          // Handle of internally generated compressed
                                                // file. This file is opened in  OpenSendFiles (fileio.c).
                                                // and closed  on error (ErrCleanup, init.c)
                                                // or when the call is complete (EndOfCall, init.c)
                                                // From both places, I call the function
                                                // DeleteCompressedFile, fileio.c
        BOOL            fCreatedEFXCmprs;       // True if we've created this file.
        char            szEFXCmprsFile[MAX_PATH]; // full path name
#endif

        BOOL fReinitClass2;                             // Set in FileT30Init, used and cleared
                                                                        // in bgt30.c (call to lpfnClass2Calle[er].

#ifdef ADAPTIVE_ANSWER
        BOOL fEnableHandoff;
#endif // ADAPTIVE_ANSWER

#ifdef USECAPI
        BYTE bRemoteMachineCapsData[MAX_REMOTE_MACHINECAPS_SIZE];
#else // !USECAPI
        BYTE            szTextCaps[TEXTCAPSSIZE];
#endif // !USECAPI
}
INSTDATA, *PINSTDATA;



//memory management
#define STATICBUFSIZE   (MY_BIGBUF_ACTUALSIZE * 2)
#define STATICBUFCOUNT  2




typedef struct {
        HANDLE  hComm;
        CHAR    szDeviceName[1];
} DEVICEID, FAR * LPDEVICEID;

// Device Setting Information BrianL 10/29/96
//
typedef struct  tagDEVCFGHDR  {
    DWORD       dwSize;
    DWORD       dwVersion;
    DWORD       fdwSettings;
}   DEVCFGHDR;


typedef struct  tagDEVCFG  {
    DEVCFGHDR   dfgHdr;
    COMMCONFIG  commconfig;
}   DEVCFG, *PDEVCFG, FAR* LPDEVCFG;



#define IDVARSTRINGSIZE    (sizeof(VARSTRING)+128)
#define ASYNC_TIMEOUT         120000L
#define ASYNC_SHORT_TIMEOUT    20000L
#define BAD_HANDLE(h) (!(h) || (h)==INVALID_HANDLE_VALUE)


// ASCII stuff

typedef struct _FAX_RECEIVE_A {
    DWORD   SizeOfStruct;
    LPSTR  FileName;
    LPSTR  ReceiverName;
    LPSTR  ReceiverNumber;
    DWORD   Reserved[4];
} FAX_RECEIVE_A, *PFAX_RECEIVE_A;


typedef struct _FAX_SEND_A {
    DWORD   SizeOfStruct;
    LPSTR  FileName;
    LPSTR  CallerName;
    LPSTR  CallerNumber;
    LPSTR  ReceiverName;
    LPSTR  ReceiverNumber;
    DWORD   Reserved[4];
} FAX_SEND_A, *PFAX_SEND_A;


typedef struct _COMM_CACHE {
    DWORD  dwMaxSize;
    DWORD  dwCurrentSize;
    DWORD  dwOffset;
    DWORD  fReuse;
    char   lpBuffer[4096];
}  COMM_CACHE;


typedef struct {
        // BYTE fStuffZERO              :1;     // not used. Just set cbLineMin instead
        UWORD   cbLineMin;

        // Output filtering (DLE stuffing and ZERO stuffing only)
        // All inited in FComOutFilterInit()
        LPB             lpbFilterBuf;
        UWORD   cbLineCount;                    // Has to be 16 bits
        BYTE    bLastOutByte;                   // Stuff: last byte of previous input buffer

        // Input filtering (DLE stripping) only.
        // All inited in FComInFilterInit()
        BYTE    fGotDLEETX              :1;
        BYTE    bPrevIn;                // Strip::last byte of prev buffer was DLE
        UWORD   cbPost;
#define POSTBUFSIZE     20
        BYTE    rgbPost[POSTBUFSIZE+1];

} FCOM_FILTER;


typedef struct {
        BYTE    carry;
        BYTE    dec_width;
        BYTE    len;
        enum    { NORMAL=0, FLAG=1, ABORT=2 } flagabort;
} DECODESTATE, far* LPDECODESTATE;


typedef struct {
        BYTE    carry;
        BYTE    enc_width;
        BYTE    len;
} ENCODESTATE, far* LPENCODESTATE;



typedef struct {
        // BOOL fFrameSend;
        // BOOL fFrameRecv;

        // Used by both encode and decode, so can't be
        // both on at the same time
        LPB                     lpbBuf;
        USHORT          cbBufSize;

        // Output framing
        // All inited in FramingSendSetup()
        ENCODESTATE EncodeState;

        // Input frame decoding
        // All inited in FramingRecvSetup()
        DECODESTATE DecodeState;
        USHORT          cbBufCount;             // data count in buf
        LPB                     lpbBufSrc;              // start of data in buf
        SWORD           swEOF;
} COMMODEM_FRAMING;


#define MAXDUMPFRAMES   100
#define MAXDUMPSPACE    400

typedef struct
{
        USHORT  uNumFrames;
        USHORT  uFreeSpaceOff;
        USHORT  uFrameOff[MAXDUMPFRAMES];       // arrays of offsets to frames
        BYTE    b[MAXDUMPSPACE];
} PROTDUMP, FAR* LPPROTDUMP;


typedef struct {
    DWORD      fAvail;
    DWORD      ThreadId;
    HANDLE     FaxHandle;
    LPVOID     pTG;
    HLINE      LineHandle;
    HCALL      CallHandle;
    DWORD      DeviceId;
    HANDLE     CompletionPortHandle;
    ULONG_PTR   CompletionKey;
    DWORD      TiffThreadId;
    DWORD      TimeStart;
    DWORD      TimeUpdated;
    DWORD      CkSum;
} T30_RECOVERY_GLOB;


typedef struct {
    DWORD dwContents;   // Set to 1 (indicates containing key)
    DWORD dwKeyOffset;  // Offset to key from start of this struct.
                        // (not from start of LINEDEVCAPS ).
                        //  8 in our case.
    BYTE rgby[1];       // place containing null-terminated
                        // registry key.
} MDM_DEVSPEC, FAR * LPMDM_DEVSPEC;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\sosmapi.h ===
//
//
//
// Define the SOS names based upon MAPI names
//
//
#define ADRLISTSOS              ADRLIST
#define LPATTACHSOS             LPATTACH
#define LPMESSAGESOS            LPMESSAGE
#define LPSRowSOS               LPSRow
#define LPSOSTABLE              LPMAPITABLE
#define LPSOSSESSION            LPMAPISESSION
#define LPSPropTagArraySOS      LPSPropTagArray
#define LPSPropValueSOS         LPSPropValue
#define LPSRowSetSOS            LPSRowSet
#define PROP_SOS_ID(x)          PROP_ID(x)
#define PROP_SOS_TAG(x, y)      PROP_TAG(x, y)
#define PROP_SOS_TYPE(x)        PROP_TYPE(x)
#define SPropTagArraySOS        SPropTagArray
#define SPropValueSOS           SPropValue
#define PR_SOS_SUBJECT          PR_SUBJECT
#define PR_SOS_SECURITY         PR_SECURITY
// PR_MESSAGE_ID --> PR_SEARCH_KEY
#define PR_SOS_MESSAGE_ID       PR_SEARCH_KEY
// PR_CONVERSATION_ID --> PR_CONVERSATION_KEY
#define PR_SOS_CONVERSATION_ID  PR_CONVERSATION_KEY
// PR_PARENT_ID --> PR_PARENT_KEY
#define PR_SOS_PARENT_ID        PR_PARENT_KEY
#define PR_SOS_SUBMIT_TIME      PR_CLIENT_SUBMIT_TIME
#define PR_SOS_PRIORITY         PR_PRIORITY
#define PR_SOS_SENDER_NAME      PR_SENDER_NAME
#define PR_SOS_ICON             PR_ICON
#define PR_SOS_MINI_ICON        PR_MINI_ICON
#define PR_SOS_BODY             PR_BODY
#define PR_SOS_RECEIPT_TIME     PR_RECEIPT_TIME
#define PR_SOS_EXPIRY_TIME      PR_EXPIRY_TIME
#define PR_SOS_DEFERRED_DELIVERY_TIME   PR_DEFERRED_DELIVERY_TIME
#define PR_SOS_DISPLAY_CC       PR_DISPLAY_CC
#define PR_SOS_DISPLAY_TO       PR_DISPLAY_TO
#define PR_SOS_MESSAGE_FLAGS    PR_MESSAGE_FLAGS
#define PR_SOS_ENTRYID          PR_ENTRYID
#define PR_SOS_PARENT_ENTRYID   PR_PARENT_ENTRYID
#define PR_SOS_OBJECT_TYPE      PR_OBJECT_TYPE
#define PR_SOS_MESSAGE_DELIVERY_TIME    PR_MESSAGE_DELIVERY_TIME
#define PR_SOS_MESSAGE_CLASS    PR_MESSAGE_CLASS
#define PR_SOS_ATTACH_FILENAME  PR_ATTACH_FILENAME
#define PR_SOS_ATTACH_ENCODING  PR_ATTACH_ENCODING
#define PR_SOS_ATTACH_EXTENSION PR_ATTACH_EXTENSION
#define PR_SOS_ATTACH_RENDERING PR_ATTACH_RENDERING
#define PR_SOS_ATTACH_METHOD    PR_ATTACH_METHOD
#define PR_SOS_ATTACH_PATHNAME  PR_ATTACH_PATHNAME
#define PR_SOS_ATTACH_DATA_BIN  PR_ATTACH_DATA_BIN
#define PR_SOS_ATTACH_DATA_OBJ  PR_ATTACH_DATA_OBJ
#define PR_SOS_ATTACH_TAG       PR_ATTACH_TAG
#define PR_SOS_ATTACH_NUM       PR_ATTACH_NUM
#define PR_SOS_RENDERING_POSITION PR_RENDERING_POSITION
#define PR_SOS_RECIPIENT_TYPE   PR_RECIPIENT_TYPE
#define PR_SOS_EMAIL_ADDRESS    PR_EMAIL_ADDRESS
#define PR_SOS_ADDRTYPE         PR_ADDRTYPE

#define PT_SOS_NULL             PT_NULL
#define PT_SOS_STRING8          PT_STRING8
#define PT_SOS_I2               PT_I2
#define PT_SOS_LONG             PT_LONG
#define PT_SOS_ERROR            PT_ERROR
#define PT_SOS_UNSPECIFIED      PT_UNSPECIFIED
#define PT_SOS_SYSTIME          PT_SYSTIME
#define PT_SOS_BINARY           PT_BINARY
#define TABLE_SORT_ASCENDSOS    TABLE_SORT_ASCEND
#define RECIP_ADDSOS            MODRECIP_ADD
#define BOOKMARK_BEGINNINGSOS   BOOKMARK_BEGINNING
#define RELOP_EQSOS             RELOP_EQ
#define SOS_ORIG                MAPI_ORIG
#define SOS_TO                  MAPI_TO
#define SOS_CC                  MAPI_CC
#define SOS_BCC                 MAPI_BCC
#define SOS_DISCRETE            MAPI_DISCRETE
#define HRESULTSOS              HRESULT

// Used for ATTACH_EMBEDDED_MSG
#define MESSAGE_DATA            (CUSTOM_METADATA_TYPE + 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\version.h ===
/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the    *
 *      VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values       *
 *                                                                          *
 ****************************************************************************/

#ifndef VS_FF_DEBUG
/* ver.h defines constants needed by the VS_VERSION_INFO structure */
#ifdef WIN32
#include <winver.h>
#else
#include <ver.h>
#endif
#endif

/*--------------------------------------------------------------*/
/* the following entry should be phased out in favor of         */
/* VER_PRODUCTVERSION_STR, but is used in the shell today.      */
/*--------------------------------------------------------------*/


/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*--------------------------------------------------------------*/

#define VERSION                     "0.0.0"
#define VER_FILEVERSION_STR         "0.0.0\0"
#define VER_FILEVERSION             0,0,0,0
#define VER_PRODUCTVERSION_STR      "0.0.0\0"
#define VER_PRODUCTVERSION          0,0,0,0

// #define OFFICIAL
// #define FINAL

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#ifndef DEBUG
#define VER_DEBUG                   0
#else
#define VER_DEBUG                   VS_FF_DEBUG
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS16
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"
#define VER_PRODUCTNAME_STR         "Microsoft\256 Windows(TM) Operating System\0"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\rgndlg.h ===
//---------------------------------------------------------------------------
// rgndlg.h
//---------------------------------------------------------------------------
// Copyright (c) 1995 Microsoft Corporation
//                 All Rights Reserved
// Information Contained Herein Is Propretary and Confidential.
//---------------------------------------------------------------------------
//
// This module contains header info for regional dialog boxes.  The drawing and positioning
// logic was adapted from the class CBobDialog.  (Used in the Microsoft "Bob" product.) 
//
//---------------------------------------------------------------------------

/* 
 * Important background information
 *
CRgnDialog was taken from  "CBobDialog" source.  The CBobDialog class inherited from 
CDialog, and also had  functionality specific to "Bob" (custom pallettes, 
global knowledge of the "guide" character, custom cursors for these dialogs, 
autoclose upon global system events).  

The first modification was to strip out all references to the "Bob" system. Next, 
MFC dependencies were also stripped out in order to provide a very lightweight 
implementation of the regional dialog functionality, and to provide C clients with
APIs compatible with DialogBox(), DialogBoxParam(), CreateDialog(), and 
CreateDialogParam().  Many MFC references remain within "#ifdef MFC" directives. 

This will not compile if MFC is defined!  

The intent is to suppport MFC AND C clients from the same source base.  This is the
only way to ensure that appearance remains consistent across different build 
environments. The MFC references remain commented out so that re-integration will 
take less effort.
*
*
*/


#if !defined(__RGNDLG_H__)
#define __RGNDLG_H__

#if !defined (STRICT)
#define STRICT 
#endif // !defined(STRICT)

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif


//
//	Dialog styles
//

#define RGNSTYLE_NOSTEM   0x00000000	
#define RGNSTYLE_SPEAK  0x00010000
#define RGNSTYLE_THINK  0x00020000
#define RGNSTYLE_ARROW  0x00030000
#define RGNSTYLE_POINT  0x00040000			
//#define RGNSTYLE_TRANSPARENT  0x00050000	// not yet implemented

#define RGNSTYLE_MINPOINTER RGNSTYLE_SPEAK
#define RGNSTYLE_MAXPOINTER RGNSTYLE_POINT
#define RGNSTYLE_MAX RGNSTYLE_POINT



// RgnDialogBox, RgnDialogBoxParam flags
#define RGNDLG_NOAUTOSIZE 0x00000008		
#define RGNDLG_NOMOVE	  0x00000010
// #define RGNDLG_ALLOWCAPTION	0x00000100  // future implementation


//
//  C wrapper replacements for DialogBox[param]() and CreateDialog[param]()
//

int RgnDialogBox(RECT *pClientRect,ULONG fFlags,ULONG style,HINSTANCE hInst, 
	LPCSTR lpszDlgTemp,HWND hWndOwner, DLGPROC ClientDlgPrc);		

int RgnDialogBoxParam(RECT *pClientRect,ULONG fFlags,ULONG style,HINSTANCE hInst, 
	LPCSTR lpszDlgTemp, HWND hWndOwner, DLGPROC ClientDlgPrc, LPARAM lParamInit); 

HWND CreateRgnDialogParam(RECT *pClientRect,ULONG fFlags,ULONG style,  HINSTANCE hInst, 
	LPCSTR lpszDlgTemp,HWND hWndOwner,DLGPROC ClientDlgPrc,LPARAM lParamInit);

HWND CreateRgnDialog(RECT *pClientRect,ULONG fFlags,ULONG style,HINSTANCE hInst, 
	LPCSTR lpszDlgTemp,HWND hWndOwner, DLGPROC ClientDlgPrc);


#ifdef __cplusplus
} // extern "C"
#endif

//
//	C clients do not need the rest of this
//
#ifdef __cplusplus

typedef ULONG RgnDlgStyle;

#define MAKE_RGNDLG_VALID(f) ((f) & (RGNDLG_NOAUTOSIZE | RGNDLG_NOMOVE))
#define IsStemValid(s) ((s == RGNSTYLE_NOSTEM) || ((s >= RGNSTYLE_MINPOINTER) && (s <= RGNSTYLE_MAXPOINTER)))
#define StemFromStyle(s) (Stem)((IsStemValid(s))? (s) : RGNSTYLE_NOSTEM)


// CRgnDialog flags

const ULONG kfDlgAutoclose = 0x00000001;
const ULONG kfDlgModal = 0x00000002;
const ULONG kfDlgNoActivate = 0x00000004;
const ULONG kfDlgNoSize = RGNDLG_NOAUTOSIZE;
const ULONG kfDlgNoMove = RGNDLG_NOMOVE;
const ULONG kfDlgAutodelete = 0x00000020;
const ULONG kfDlgParamInit = 0x00000040;

// Transparent dialogs have no stem.  If this flag is set by C++ client and a stem type
// also exists, the stem type is ignored.
//const ULONG kfDlgTransparent = 0x00000080;	
// captions could be allowed if some cosmetic tweaking is applied
// const ULONG kfDlgAllowCaption =	RGNDLG_ALLOWCAPTION;

const ULONG kfDlgValid = (kfDlgAutoclose | kfDlgModal | kfDlgNoActivate |
        kfDlgNoSize | kfDlgNoMove | kfDlgAutodelete | kfDlgParamInit);

// Internal flag state

const ULONG kfxDlgChildrenCreated = 0x00000001;
const ULONG kfxDlgPosDone = 0x00000002;
const ULONG kfxDlgSizeDone = 0x00000004;

// Stem, StemSide, StemType

typedef ULONG Stem; // st
typedef ULONG StemSide; // ss
typedef ULONG StemType; // stt

// Stem types

const StemType ksttNone = 0x00000000;
const StemType ksttSpeak = 0x00010000;
const StemType ksttThink = 0x00020000;
const StemType ksttArrow = 0x00030000;
const StemType ksttPoint = 0x00040000;
const StemType ksttValid = 0x00070000;

// Stem sides

// (mikev) bit 0 indicates horisontal or vertical stem
// 1 = Vertical, 0= horizontal
// (mikev) bit 1 indicates left or right, top or bottom
// 1 = right or bottom, 0= left or top

const StemSide kssLeft = 0x00000000;
const StemSide kssTop = 0x00000001;
const StemSide kssRight = 0x00000002;
const StemSide kssBottom = 0x00000003;
const StemSide kssValid = 0x00000003;
const StemSide kssIncr = 0x00000001;

											
inline StemSide StemSideLeftTop(StemSide ss) 
{
    return (ss & ~2);
}

inline StemSide StemSideOpposite(StemSide ss) // (mikev) flip bit 1 (flip side)
{
    return (ss ^ 2);
}

// Stem settings - these are passed to constructors

#define MakeStem(stt, ss) (stt | ss)

const Stem kstSquareLeft = MakeStem(ksttNone, kssLeft);
const Stem kstSquareTop = MakeStem(ksttNone, kssTop);
const Stem kstSquareRight = MakeStem(ksttNone, kssRight);
const Stem kstSquareBottom = MakeStem(ksttNone, kssBottom);
const Stem kstSpeakLeft = MakeStem(ksttSpeak, kssLeft);
const Stem kstSpeakTop = MakeStem(ksttSpeak, kssTop);
const Stem kstSpeakRight = MakeStem(ksttSpeak, kssRight);
const Stem kstSpeakBottom = MakeStem(ksttSpeak, kssBottom);
const Stem kstThinkLeft = MakeStem(ksttThink, kssLeft);
const Stem kstThinkTop = MakeStem(ksttThink, kssTop);
const Stem kstThinkRight = MakeStem(ksttThink, kssRight);
const Stem kstThinkBottom = MakeStem(ksttThink, kssBottom);
const Stem kstArrowLeft = MakeStem(ksttArrow, kssLeft);
const Stem kstArrowTop = MakeStem(ksttArrow, kssTop);
const Stem kstArrowRight = MakeStem(ksttArrow, kssRight);
const Stem kstArrowBottom = MakeStem(ksttArrow, kssBottom);
const Stem kstValid = MakeStem(ksttValid, kssValid);

// The following is NOT a valid stem type, but is
// converted to a valid stem type by CRgnDialog::Init().

const Stem kstDefault = 0xFFFFFFFF;


inline StemType GetStemType(Stem st)
{
    return (StemType)(st & ksttValid);
}

inline StemSide GetStemSide(Stem st)
{
    return (StemSide)(st & kssValid);
}

inline ULONG StemTypeIndex(StemType st)
{
    return (st >> 16) & (ksttValid >> 16);
}

inline ULONG StemSideIndex(StemSide ss)
{
    return ss & kssValid;
}

// Dialog metrics (refer to sdk documentation for meaning of fields)

struct DialogMetrics // dm
{
    DialogMetrics(ULONG cxCorner, ULONG cyCorner, ULONG cpStemBaseWidth,
            ULONG cpStemBaseShift, ULONG cpStemHeight, ULONG cpStemOffset);
        
    ULONG m_cxCorner;
    ULONG m_cyCorner;
    ULONG m_cpStemBaseWidth;
    ULONG m_cpStemBaseShift;
    ULONG m_cpStemHeight;
    ULONG m_cpStemOffset;
    static ULONG s_cxBorder;
    static ULONG s_cyBorder;
};



class CRgnDialog // dlg
{
private:
#ifdef MFC
    DECLARE_DYNAMIC(CRgnDialog);
#endif
#ifndef MFC
	  #define GetStyle() GetWindowLong(m_hWnd, GWL_STYLE)
#endif

    // Declare first for inline use
private:
    ULONG m_ff;                     // public flags passed to constructors
    ULONG m_ffx;                    // Internal flag state
#ifdef MFC 
	CRect m_rcTarget;               // Target rect passed to constructors
	CRect m_rcClient;               // Client rect in screen coordinates
	HCURSOR m_hcurMove;             // Cursor while moving
	HCURSOR m_hcurNormal;           // Normal cursor
#else
	RECT m_rcTarget;               // Target rect passed to constructors
	RECT m_rcClient;               // Client rect in screen coordinates
#endif

    Stem m_st;                      // Stem info passed to constructors
    ULONG m_cpStemOffset;           // Stem offset from top or left of dialog
    DialogMetrics *m_pdm;           // Precalculated dialog metrics
    HBRUSH m_hbrBackground;         // Background brush
  

#ifndef MFC
	HWND hWndClient;
	DLGPROC ClientDlgPrc;
	LPARAM lParamClient;
	HWND m_hWnd;
	#endif
    // Private helpers
private:
	void Init(ULONG ff, RECT *prc, Stem st, /*HINSTANCE hInst, */ HWND hWndOwner, 
		DLGPROC procClient, LPARAM lParamInit);
    //void Init(ULONG ff, RECT *prc, Stem st);
#ifdef MFC
    void CalcClientRect(WINDOWPOS *ppos, CRect *prc);
    void OffsetClientRect(StemSide ss, CRect *prcClient, long cpInset);
    void CalcClientPos(CRect *prcClient, CRect *prcDst);
    void AdjustInsideBoundary(StemSide ss, CRect *prcDlg, CRect *prcClient,
            CRect *prcBoundary, ULONG *pcpStemOffset);
    BOOL FSideInBoundary(StemSide ss, RECT *prc, RECT *prcBoundary,
            long *pcpOverlap);
    void CalcWindowRgn(int xWindow, int yWindow);
    void OnNcPaint(HRGN hrgnUpdate);
    HRGN CreateSpeakRgn(CRect *prcBody);
    HRGN CreateArrowRgn(CRect *prcBody);
    HRGN CreateThinkRgn(CRect *prcBody);
    BOOL SendMessageToChildren(BOOL fStopOnSuccess, UINT wm, WPARAM wp,
            LPARAM lp);
#else
	void CalcClientRect(WINDOWPOS *ppos, RECT *prc);
    void OffsetClientRect(StemSide ss, RECT *prcClient, long cpInset);
    void CalcClientPos(RECT *prcClient, RECT *prcDst);
    void AdjustInsideBoundary(StemSide ss, RECT *prcDlg, RECT *prcClient,
            RECT *prcBoundary, ULONG *pcpStemOffset);
    BOOL FSideInBoundary(StemSide ss, RECT *prc, RECT *prcBoundary,
            long *pcpOverlap);
    void CalcWindowRgn(int xWindow, int yWindow);
    void OnNcPaint(HRGN hrgnUpdate);
    HRGN CreatePointRgn(RECT *prcBody);
    HRGN CreateArrowRgn(RECT *prcBody);
    HRGN CreateThinkRgn(RECT *prcBody);

public:
	BOOL DialogProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
	void PubInit(ULONG ff, RECT *prc, Stem st, /*HINSTANCE hInst, */ HWND hWndOwner, 
		DLGPROC procClient, LPARAM lParamInit);
#endif

protected:
    void CalcWindowPos(WINDOWPOS *ppos);

    // For modeless construction
public:
    inline CRgnDialog() 
    {
        // Set dialog background color to NULL
    
        m_hbrBackground = NULL;

        // Initialize other variables
		Init(0, NULL, 0, NULL, NULL, 0);
    }    

#ifdef MFC
    inline BOOL Create(const char *pszTemplateName, CWnd *pwndParent = NULL,
          ULONG ff = 0, RECT *prc = NULL, Stem st = kstDefault)
    {
        Init(ff, prc, st, NULL, NULL, 0);
		return 1;
    }

    inline BOOL Create(ULONG idTemplate, CWnd *pwndParent = NULL,
            ULONG ff = 0, RECT *prc = NULL, Stem st = kstDefault)
    {
        Init(ff, prc, st, NULL, NULL, 0);
		return 1;
    }

    inline BOOL CreateIndirect(const DLGTEMPLATE *pvDialogTemplate,
            CWnd *pwndParent = NULL, ULONG ff = 0, RECT *prc = NULL,
            Stem st = kstDefault)
    {
        Init(ff, prc, st, NULL, NULL, 0);
		return 1;
    }

    inline BOOL CreateIndirect(HGLOBAL hDialogTemplate,
            CWnd* pwndParent = NULL, ULONG ff = 0, RECT *prc = NULL,
            Stem st = kstDefault)
    {
        Init(ff, prc, st, NULL, NULL, 0);
		return 1;
    }

    // For modal construction
public:

    inline CRgnDialog(const char *pszTemplate, CWnd *pwndParent = NULL,
            ULONG ff = 0, RECT *prc = NULL, Stem st = kstDefault) 
            
    {
        // Set dialog background color to NULL
    
        m_hbrBackground = NULL;

        // Initialize other variables

        Init(ff, prc, st, NULL, NULL, 0);
    }

    inline CRgnDialog(ULONG idTemplate, CWnd *pwndParent = NULL,
            ULONG ff = 0, RECT *prc = NULL, Stem st = kstDefault)
          
    {
        // Set dialog background color to NULL
    
        m_hbrBackground = NULL;

        // Initialize other variables

        Init(ff, prc, st, NULL, NULL, 0);
    }
    virtual int DoModal();
#endif //MFC

    // Public methods
public:
    // Destructor

    ~CRgnDialog()
    {
        if (m_hbrBackground != NULL)
            DeleteObject(m_hbrBackground);
		#ifdef MFC
        if (m_hcurMove != NULL)
            DestroyCursor(m_hcurMove);
        if (m_hcurNormal != NULL)
            DestroyCursor(m_hcurNormal);
		#endif MFC
    }        

#ifdef MFC
    // Returns flags passed into constructor

    inline ULONG GetFlags()
    {
        return m_ff;
    }

    // Returns target rect passed into constructor

    inline BOOL GetTargetRect(RECT *prc)
    {
        *prc = m_rcTarget;

        return TRUE;
    }

    // Returns stem info passed into constructor

    inline Stem GetStem()
    {
        return m_st;
    }

    // Set dialog background brush

    inline BOOL SetBackgroundBrush(HBRUSH hbr)
    {
        if (m_hbrBackground != NULL)
            DeleteObject(m_hbrBackground);

        m_hbrBackground = hbr;

        return TRUE;
    }

    // Get dialog background brush

    inline HBRUSH GetBackgroundBrush()
    {
        return m_hbrBackground;
    }
#endif //MFC
    // Overridden methods
public:
    void EndDialog(int n);
    virtual void CalcWindowRect(RECT *prcClient, UINT idAdjust);
	virtual BOOL OnInitDialog();

protected:
  
    //virtual LRESULT WindowProc(UINT wm, WPARAM wp, LPARAM lp);
    virtual void PostNcDestroy();


protected:
#ifdef MFC
	//{{AFX_MSG(CRgnDialog)
    afx_msg int OnMouseActivate(CWnd *pwnd, UINT ht, UINT wm);
    afx_msg void OnNcCalcSize(BOOL fCalcValidRects, NCCALCSIZE_PARAMS *pcsz);
    afx_msg void OnWindowPosChanging(WINDOWPOS *ppos);
    afx_msg void OnWindowPosChanged(WINDOWPOS *ppos);
    afx_msg BOOL OnEraseBkgnd(CDC *pdc);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg UINT OnNcHitTest(CPoint pt);
	afx_msg void OnPaint();
    afx_msg BOOL OnQueryNewPalette();
	afx_msg BOOL OnSetCursor(CWnd *pwnd, UINT ht, UINT wm);
	afx_msg void OnNcDestroy();
	afx_msg void OnPaletteChanged(CWnd* pFocusWnd);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

#else
public:
    int OnMouseActivate(HWND hWnd, UINT ht, UINT wm);
    int OnNcCalcSize(BOOL fCalcValidRects, NCCALCSIZE_PARAMS *pcsz);
    int  OnWindowPosChanging(WINDOWPOS *ppos);
    void OnWindowPosChanged(WINDOWPOS *ppos);
    BOOL OnEraseBkgnd(HDC hdc);
	int OnCreate(LPCREATESTRUCT lpCreateStruct);
    UINT OnNcHitTest(LPARAM lParam);
	void OnPaint();
    BOOL OnQueryNewPalette();
	BOOL OnSetCursor(HWND hWnd, UINT ht, UINT wm);
	void OnNcDestroy();
	void OnPaletteChanged(HWND hWndChanger);
#endif
};


#endif // defined (_cplusplus)
#endif // !defined(__RGNDLG_H__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\t30gl.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    t30.h

Abstract:

    Globals for t30.dll

Author:

    Rafael Lisitsa (RafaelL) 12-Feb-1996


Revision History:

--*/


#ifdef DEFINE_T30_GLOBALS
    #define DEFINE_T30_EXTERNAL
#else
    #define DEFINE_T30_EXTERNAL   extern
#endif



// DLL global data

#define STATUS_FAIL   0
#define STATUS_OK     1

typedef struct {
    HLINEAPP   LineAppHandle;
    HANDLE     HeapHandle;
    int        fInit;
    int        CntConnect;
    int        Status;
    int        DbgLevel;
    int        T4LogLevel;
    int        MaxErrorLinesPerPage;
    int        MaxConsecErrorLinesPerPage;
    char       TmpDirectory[_MAX_FNAME - 15];
    DWORD      dwLengthTmpDirectory;
} T30_DLL_GLOB;

DEFINE_T30_EXTERNAL  T30_DLL_GLOB  gT30;

DEFINE_T30_EXTERNAL  CRITICAL_SECTION  T30CritSection;




// Per job/thread global data.
#define MAX_T30_CONNECT     100

typedef struct {
    LPVOID    pT30;
    int       fAvail;
} T30_TABLE;

DEFINE_T30_EXTERNAL  T30_TABLE  T30Inst[MAX_T30_CONNECT];


// T30 Recovery per job/thread global data.


DEFINE_T30_EXTERNAL  T30_RECOVERY_GLOB  T30Recovery[MAX_T30_CONNECT];

DEFINE_T30_EXTERNAL  CRITICAL_SECTION  T30RecoveryCritSection;


//
// Run-Time global flag controlling Exception Handling
//

DEFINE_T30_EXTERNAL DWORD glT30Safe;
DEFINE_T30_EXTERNAL DWORD glSimulateError;
DEFINE_T30_EXTERNAL DWORD glSimulateErrorType;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\t30fail.h ===
/***************************************************************************
 Name     : T30FAIL.H
 Comment  : T30 Failure codes moved to a common place, to avoid duplication
    and inconsistency

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
 11/01/94  arulm created
***************************************************************************/



typedef int T30FAILURECODE; // The #define's below

// t30

#define T30FAIL_NULL        0  // unknown or not-applicable
#define T30FAILS_SUCCESS    1  // Send completed successfully 
#define T30FAILSE_SUCCESS   2  // Send ECM completed successfully 
#define T30FAILR_SUCCESS    3  // Recv completed successfully 
#define T30FAILRE_SUCCESS   4  // Recv ECM completed successfully 
#define T30FAIL_SUCCESS     5  // compare code <= this value to tell fail vs success

#define T30FAILS_T1            6  // Send T1 timeout (No NSF/DIS Recvd)
#define T30FAILS_TCF_DCN       7  // Recvd DCN after TCF (weird...)
#define T30FAILS_3TCFS_NOREPLY 8  // No reply to 3 attempts at training (TCF)
#define T30FAILS_3TCFS_DISDTC  9  // Remote does not see our TCFs for some reason
#define T30FAILS_TCF_UNKNOWN   10 // Got garbage response to TCF

#define T30FAILS_SENDMODE_PHASEC     11 // Modem Error/Timeout at start of page
#define T30FAILS_MODEMSEND_PHASEC    12 // Modem Error/Timeout within page
#define T30FAILS_FREEBUF_PHASEC      13 // Error in Freebuf (must be a bug)
#define T30FAILS_MODEMSEND_ENDPHASEC 14 // Modem Error/Timeout at end of page

#define T30FAILSE_SENDMODE_PHASEC     15 // Modem Error/Timeout at start of ECM page
#define T30FAILSE_PHASEC_RETX_EOF     16 // Unexpected EOF when trying to retransmit (bug)
#define T30FAILSE_MODEMSEND_PHASEC    17 // Modem Error/Timeout within ECM page 
#define T30FAILSE_FREEBUF_PHASEC      18 // Error in IFBufFree (muts be a bug)
#define T30FAILSE_MODEMSEND_ENDPHASEC 19 // Modem Error/Timeout at end of ECM page
#define T30FAILSE_BADPPR              20 // Bad PPR recvd from Recvr (bug on recvr)

#define T30FAILS_3POSTPAGE_NOREPLY    21 // No response after page: Probably Recvr hungup during page transmit
#define T30FAILS_POSTPAGE_DCN         22  // Recvd DCN after page. (weird...)

#define T30FAILSE_3POSTPAGE_NOREPLY   23 // No response after page: Probably Recvr hungup during page transmit
#define T30FAILSE_POSTPAGE_DCN        24 // Recvd DCN after ECM page. (weird...)
#define T30FAILSE_POSTPAGE_UNKNOWN    25 // Recvd garbage after ECM page. 

#define T30FAILSE_RR_T5       26 // Recvr was not ready for more than 60secs during ECM flow-control
#define T30FAILSE_RR_DCN      27 // Recvd DCN after RR during ECM flow-control(weird...)
#define T30FAILSE_RR_3xT4     28 // No response from Recvr during ECM flow-control
#define T30FAILSE_CTC_3xT4    29 // No response from Recvr after CTC (ECM baud-rate fallback)
#define T30FAILSE_CTC_UNKNOWN 30 // Garbage response from Recvr after CTC (ECM baud-rate fallback)

#define T30FAIL_BUG0   31
#define T30FAILS_BUG1  32
#define T30FAILSE_BUG2 33
#define T30FAILR_BUG2  34

#define T30FAILR_PHASEB_DCN  35 // Recvr: Sender decided we're incompatible
#define T30FAILR_T1          36 // Recvr: Caller is not a fax machine or hung up

#define T30FAILR_UNKNOWN_DCN1     37 // Recvr: Recvd DCN when command was expected(1)
#define T30FAILR_T2               38 // Recvr: No command was recvd for 7 seconds
#define T30FAILR_UNKNOWN_DCN2     39 // Recvr: Recvd DCN when command was expected(2)
#define T30FAILR_UNKNOWN_UNKNOWN2 40 // Recvr: Recvd grabge when command was expected 

#define T30FAILR_MODEMRECV_PHASEC  41 // Recvr: Page not received, modem error or timeout at start of page
#define T30FAILRE_MODEMRECV_PHASEC 42 // Recvr: Data not received, modem error or timeout during page

#define T30FAILRE_PPS_RNR_LOOP  43 // Recvr: Timeout during ECM flow control after PPS (bug)
#define T30FAILRE_EOR_RNR_LOOP  44 // Recvr: Timeout during ECM flow control after EOR (bug)

// et30prot

#define T30FAIL_NODEA_UNKNOWN    45 // Sender: Garbage frames instead of DIS/DTC
#define T30FAILS_NODEA_NOWORK    46 // Sender: No work to do!! (bug)
 
#define T30FAILS_POSTPAGE_UNKNOWN  47 // Sender: Unknown response after page
#define T30FAILS_POSTPAGE_OVER     48 // Sender: Success!
#define T30FAILSE_ECM_NOPAGES      49 // Sender: ECM Success!
#define T30FAILS_4PPR_ERRORS       50 // Sender: Too many line errors in ECM mode

#define T30FAILS_FTT_FALLBACK   51 // Sender: Recvr doesn't like our training at all speeds
#define T30FAILS_RTN_FALLBACK   52 // Sender: Too many line errors in non-ECM mode even at 2400
#define T30FAILS_4PPR_FALLBACK  53 // Sender: Too many line errors in ECM mode even at 2400

#define T30FAILS_BUG3   54
#define T30FAILSE_BUG4  55
#define T30FAIL_BUG5    56
#define T30FAIL_BUG6    57
#define T30FAIL_BUG7    58
#define T30FAILR_BUG8   59
#define T30FAIL_BUG9    60

///////// The ones below are not used on IFAXen, only on PC platforms /////////
#define T30FAIL_IFAX_LAST    60

//icomfile

#define T30FAILS_NOTINITED      61 // Transport not inited (efaxpump bug)
#define T30FAILS_CASSENDFILE    62 // Error from CASSendFile
#define T30FAILS_MG3_NOFILE     63 // Negot Failed: Remote in G3-only and no MG3 file *** Email Form Not Supported ***
#define T30FAILS_NEGOT_ENCODING 64 // Negot Failed: Encoding mismatch
#define T30FAILS_NEGOT_A5A6     65 // Negot Failed: A5/A6 paper sizes not supported (efaxpump bug)
#define T30FAILS_NEGOT_WIDTH    66 // Negot Failed: Send image too wide *** Paper Size Not Supported ***
#define T30FAILS_NEGOT_LENGTH   67 // Negot Failed: Send image too long    *** Paper Size Not Supported ***
#define T30FAILS_NEGOT_RES      68 // Negot Failed: Resolution mismatch *** Resolution Not Supported ***

#define T30FAILS_EFX_BADFILE    69  // Bad EFX file
#define T30FAILS_IFX_BADFILE    70  // Bad IFX file
#define T30FAILS_MG3_BADFILE    71  // Bad MG3 file
#define T30FAILS_FILEOPEN       72  // Send File Open failed
#define T30FAILS_READFHB        73  // Read FHB failed
#define T30FAILS_BADFHB         74  // Bad FHB

#define T30FAILS_SEEK_HEADER      75 // Seek-to-next-header failed
#define T30FAILS_SEEK_STARTPAGE   76 // Seek-to-page-data failed
#define T30FAILS_SEEK_STARTBLOCK  77 // Seek-to-next-block failed
#define T30FAILS_SEEK_RETX        78 // Seek to block to be retransmitted failed
#define T30FAILS_FILEREAD         79 // File read (for data) failed

#define T30FAILR_NOTINITED     80 // Transport not inited (efaxpump bug)
#define T30FAILR_UNIQFILENAME  81 // Spool directory too full-cannot find uniq name for recv
#define T30FAILR_FILECREATE    82 // Recv File Create failed
#define T30FAILR_FILEWRITE     83 // Recvd file write failed

#define T30FAILS_SEC_FAXCODEC_INIT  84 // Could not init FaxCodec
#define T30FAILS_SEC_FAXCODEC_ERR   85 // FaxCodec returned error
#define T30FAILR_NAMEARRAY_OVF      86 // Too many receives--recvname array overflow

#define T30FAIL_ABORT   87    // User abort

#define T30FAILS_BUG11  88
#define T30FAILR_BUG11  89

// fcom

#define T30FAIL_OTHERCOMM2   90
#define T30FAIL_OTHERCOMM1   91
#define T30FAIL_OTHERCOMM    92
#define T30FAIL_FRAMING2     93
#define T30FAIL_FRAMING1     94
#define T30FAIL_FRAMING      95
#define T30FAIL_BUFOVER2     96
#define T30FAIL_BUFOVER1     97
#define T30FAIL_BUFOVER      98
#define T30FAIL_OVER2        99
#define T30FAIL_OVER1        100
#define T30FAIL_OVER         101

// These should be done away with .. (use T30_DIAL/ANSWER_FAIL instead).
#define T30FAILS_NCUDIAL_ERROR        102
#define T30FAILS_NCUDIAL_OK           103 // Should not happen!!!
#define T30FAILS_NCUDIAL_BUSY         104
#define T30FAILS_NCUDIAL_NOANSWER     105
#define T30FAILS_NCUDIAL_NODIALTONE   106

#define T30FAILR_NCUANSWER_ERROR      107
#define T30FAILR_NCUANSWER_OK         108 // Should not happen!!!
#define T30FAILR_NCUANSWER_NORING     109

#define T30FAILS_SECURITY_NEGOT       110 // Negot Failed: Remote in G3-only and no MG3 file *** Email Form Not Supported ***

// following as documented in netfax interface....
#define     T30FAILS_NEGOT_POLLING          135
#define     T30FAILS_NEGOT_POLLBYNAME       136
#define     T30FAILS_NEGOT_POLLBYRECIP      137
#define     T30FAILS_NEGOT_FILEPOLL         138

#define T30FAIL_LAST 138
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\timeouts.h ===
#ifndef _TIMEOUTS_
#define _TIMEOUTS_

typedef struct tagTO {
        ULONG   ulStart;
        ULONG   ulTimeout;
        ULONG   ulEnd;
} TO, far* LPTO;


#endif //_TIMEOUTS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\tipes.h ===
/***************************************************************************
	Name      :	TIPES.H
	Comment   :	Basic type definitions and universal manifest constants
			    for T30 driver and associated code.

	Copyright (c) Microsoft Corp. 1991, 1992, 1993

	Revision Log
	Num   Date      Name     Description
	--- -------- ---------- -----------------------------------------------
	101	06/02/92	arulm	Changed all type names to upper case. Here and in code
***************************************************************************/



// #include <stdio.h>
// #include <stdlib.h>
// #include <time.h>
#include <string.h> 

// typedef signed char		BOOL;
// typedef unsigned char 	BYTE;
typedef unsigned short 	UWORD;
typedef signed short	SWORD;
// typedef unsigned long	ULONG;
typedef signed long		SLONG;

typedef BYTE far*		LPB;
typedef BYTE near*		NPB;
typedef BYTE near*		NPBYTE;

typedef BOOL far*		LPBOOL;

typedef UWORD far*		LPUWORD;
typedef UWORD near*		NPUWORD;

typedef SWORD far*		LPSWORD;

#define FALSE	0
#define TRUE	1

#ifndef WIN32
#define	MAKEWORD(l,h)	((WORD)(((BYTE)(l)) | (((WORD)((BYTE)(h))) << 8)))
#endif



//-------------------// added NVRAM logging //---------------------//


#ifdef NVLOG
	void _export CDECL MyLogError1(WORD wProcId, WORD wModId, WORD wFile, WORD wLine);
	void _export CDECL MyLogError2(LPSTR szErr, ...);
#	define ERRMSG(m) (ERRORMSG(m), MyLogError1(0, MODID, FILEID, __LINE__), (MyLogError2 m))
#else //NVLOG
#	ifdef IFK
#		define ERRMSG(m) ERRORMSG(m)
#	else
#		define ERRMSG(m) DEBUGMSG(1, m)
#	endif
#endif //NVLOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\xp_schd.h ===
/***************************************************************************

    Name      :     xp_schd.h

    Comment   :     Shared defines between awfaxp32 and scheduler

    Functions :     none

    Created   :     05/23/95

    Author    :     Bruce J Kelley

    Contribs  :

***************************************************************************/

// Name of BusyModem event
#define BUSY_MODEM_EVENT_NAME TEXT("MSFaxBusyModemEvent")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\uiutil.h ===
/*
 -	uiutil.h
 -	common UI stuff
 -	will be included by modules that require these UI services
 -	services are in:	ui\faxcfg\
 -							uiutil.c
 -							tapi.c
 -							comdlg.c
 -							registry.c
 -	DLL for these services: awfxcg32.dll
 *
 *
 */

#include "phonenum.h"

/*
 *	complement the macros in winuser.h to extract notification codes
 */

#ifdef WIN16
#define GET_WM_COMMAND_NOTIFICATION_CODE(wp, lp)			HIWORD(lp)
#define GET_WM_COMMAND_CONTROL_ID(wp, lp)					(wp)
#define GET_WM_COMMAND_CONTROL_HANDLE(wp, lp)				(HWND)(LOWORD)(lp)
#else
#define GET_WM_COMMAND_NOTIFICATION_CODE(wp, lp)			HIWORD(wp)
#define GET_WM_COMMAND_CONTROL_ID(wp, lp)					LOWORD(wp)
#define GET_WM_COMMAND_CONTROL_HANDLE(wp, lp)				(HWND)(lp)
#endif

/***************************
 ******** Constants ********
 ***************************/

#define		DDL_HIDEEXT		0x0001
#define		DDL_DONTRESET	0x0002
#define		DDL_FOLLOWLINKS	0x0004
#define		DDL_MAPIDIALOG	0x0008
// no dirs or temp files allowed!
#define 	FILE_ATTRIB_ALL	( 	FILE_ATTRIBUTE_ARCHIVE 	|\
								FILE_ATTRIBUTE_HIDDEN 	|\
								FILE_ATTRIBUTE_READONLY |\
								FILE_ATTRIBUTE_SYSTEM 	|\
								FILE_ATTRIBUTE_NORMAL		)

/***************************
 ***** Date/time stuff *****
 ***************************/
 
// Time Control constants
#define DATETIME_COMPONENTS     14
#define HOUR            0     /* index into wDateTime */
#define MINUTE          1
#define SECOND          2
#define MONTH           3
#define DAY                     4
#define YEAR            5
#define WEEKDAY         6
#define AMPM            10
#define SEPARATOR       11
#define BORDER          12
#define ARROW           13

/*****************************************************************************
	Dos Date format is:
                bits 0-8 contian the day number within the year.
                bits 9-15 contain the years since 1990.  (ie, 1990 = 0)
                Thus, the earliest date is 1/1/1990, which is reprsented by
				the DOSDATE==1.
*****************************************************************************/
typedef WORD DOSDATE;

// wFormat flags for flags for GetTimeDateStr() wFormat should == FMT_STRxxx
// flags optionally ored with FMT_NOSECONDS

#define FMT_DATE		0x0001
#define FMT_TIME		0x0002
#define FMT_STRMASK 	0x00F0
#define FMT_STRDATE 	0x0011	 // includes FMT_DATE
#define FMT_STRTIME 	0x0022	 // includes FMT_TIME
#define FMT_STRTIMEDATE 0x0033	 // includes FMT_DATE and FMT_TIME
#define FMT_STRDATETIME 0x0043	 // includes FMT_DATE and FMT_TIME
#define FMT_NOSECONDS	0x0100


/***************************
 *** International stuff ***
 ***************************/

/* Suffix length + NULL terminator */
#define TIMESUF_LEN   9

typedef struct            /* International section description */
  {
    char   sCountry[24]; /* Country name */
    int    iCountry;     /* Country code (phone ID) */
    int    iDate;	 /* Date mode (0:MDY, 1:DMY, 2:YMD) */
    int    iTime;        /* Time mode (0: 12 hour clock, 1: 24 ) */
    int    iTLZero;      /* Leading zeros for hour (0: no, 1: yes) */
    int    iCurFmt;      /* Currency mode(0: prefix, no separation
     				      1: suffix, no separation
     				      2: prefix, 1 char separation
     				      3: suffix, 1 char separation) */

    int    iCurDec; 	     /* Currency Decimal Place */
    int    iNegCur;          /* Negative currency pattern
                                 ($1.23), -$1.23, $-1.23, $1.23-, etc. */
    int    iLzero;	     /* Leading zeros of decimal (0: no, 1: yes) */
    int    iDigits;          /* Significant decimal digits */
    int    iMeasure;	     /* Metric 0; British 1 */
    char   s1159[TIMESUF_LEN];     /* Trailing string from 0:00 to 11:59 */
    char   s2359[TIMESUF_LEN];     /* Trailing string from 12:00 to 23:59 */
    char   s1159old[TIMESUF_LEN];  /* Old trailing string from 0:00 to 11:59 */
    char   s2359old[TIMESUF_LEN];  /* Old trailing string from 12:00 to 23:59 */
    char   sCurrency[6];     /* Currency symbol string */
    char   sThousand[4]; /* Thousands separator string */
    char   sDecimal[4];  /* Decimal separator string */
    char   sDateSep[4];     /* Date separator string */
    char   sTime[4];     /* Time separator string */
    char   sList[4];     /* List separator string */
    char   sLongDate[80];
    char   sShortDate[80];
    char   sLanguage[4];
    short  iDayLzero;    /* Day Leading zero for Short Time format */
    short  iMonLzero;    /* Month Leading zero for Short Time format */
    short  iCentury;     /* Display full century in Short Time format */
    short  iLDate;       /* Long Date mode (0:MDY, 1:DMY, 2:YMD) */
  } INTLSTRUCT;
typedef INTLSTRUCT FAR *LPINTL;
typedef INTLSTRUCT NEAR *PINTL;


/******************************************
 *** Telephone number encoding/decoding ***
 ******************************************/

#define tapiVersionCur						0x00010004

// Sender fax number fields (number, country code, area code) flags
#define TEL_AREACODEDISABLE		0x00000002
#define TEL_NOAREACODEDISABLE	0x00000000
#define TEL_MUSTFAXNUMBER		0x00000004 
#define TEL_NOMUSTFAXNUMBER		0x00000000 

// per-country area codes support
#define MANDATORY_AREA_CODES	2
#define OPTIONAL_AREA_CODES		1
#define NO_AREA_CODES			FALSE

/******************************************
 ***********         Modem           ******
 ******************************************/

#define	DEVICE_NAME_SIZE		MAX_PATH/4		// Maximum size for the name of a fax device

typedef struct tagPARSEDMODEM           
{
	WORD	iModemType;							// type of the modem
	DWORD	dwModemID;							// line ID (or com port) for a local modem
	DWORD	dwTAPIPermanentID;					// TAPI permanent line ID
	TCHAR	szDisplayName[DEVICE_NAME_SIZE];	// modem name for netfax devices
	TCHAR	szDeviceTypeName[DEVICE_NAME_SIZE];	// the name for this device type. this
												// connects into the device type structure
} PARSEDMODEM, *LPPARSEDMODEM;

typedef struct tagMODEMPROPS           
{
	ULONG	iAnswerMode;								
	ULONG	iNumRings;								
	ULONG	iBlindDial;								
	ULONG	iCommaDelay;								
	ULONG	iDialToneWait;								
	ULONG	iHangupDelay;								
	ULONG	iSpeakerMode;								
	ULONG	iSpeakerVolume;								
} MODEMPROPS, *LPMODEMPROPS;

/***********************************************************
 *** Prototypes for functions exported from awfxcg32.dll ***
 ***********************************************************/
#ifdef __cplusplus
extern "C" {
#endif
/*
 * General
 */
void	StripExtension(LPTSTR lpFileName, LPTSTR lpExt);
void	StripAnyExtension(LPTSTR lpFileName);
void	ReplaceExtension(LPTSTR lpszPath, LPTSTR lpszNewExt);
void	ReplaceSpecificExtension(LPTSTR lpszPath, LPTSTR lpszOldExt, LPTSTR lpszNewExt);
BOOL	TruncateString(LPTSTR lpszString, LONG nBytes);
LPTSTR	FindEndOfString(LPTSTR stringPtr);
LPTSTR	FindLastCharInString(LPTSTR stringPtr);
BOOL	ReplaceChars(LPTSTR lpszString, TCHAR cCharIn, TCHAR cCharOut);
LPTSTR	ReplaceLastOccurence(LPTSTR lpszString, TCHAR cCharIn, TCHAR cCharOut);
BOOL	IsNumberString(LPSTR lpszString, ULONG n);
BOOL	IsTelNumberString(LPSTR lpszString, ULONG n);
BOOL	MySplitPath(LPTSTR lpszFullPath, LPTSTR lpszPath, LPTSTR lpszFileName, LPTSTR lpszExt);
BOOL	IsFullPath(LPSTR lpszString);
int		MakeMessageBox(HINSTANCE, HWND, DWORD, UINT, UINT, ...);
UINT	GetWindowsDirectoryWithSlash(LPSTR lpBuffer, UINT uSize);
DOSDATE EncodeDosDate(WORD wMonth, WORD wDay, WORD wYear);
DOSDATE EncodeLocalDosDate(BOOL fToday);
void	DecodeDosDate(DOSDATE dosdate, WORD *pwMonth, WORD *pwDay, WORD *pwYear);
int		GetTimeDateStr(WORD wHour, WORD wMinute, WORD wSecond, WORD wMilliseconds,
 		DOSDATE wDosDate, LPTSTR pBuf, int iSizeBuf, WORD wFormat);
int	CountFiles(LPTSTR lpOrigPathSpec, ULONG ulFlags);

/*
 *	localization-related
 */
BOOL	IsDBCSTrailByte(LPTSTR stringPtr, LPTSTR bytePtr);

/*
 *	common dialogs
 */
int WINAPI DDirList(HWND hDlg, LPTSTR lpPathSpec, int nIDListBox, UINT uFileType, UINT uFlags);
BOOL WINAPI DDirSelect(HWND hDlg, LPTSTR lpString, int nCount, int nIDListBox, LPTSTR lpExt);
BOOL GetSelectedCoverPage(HWND hDlg, LPTSTR lpszString, int nCount, int nIDListBox, LPTSTR lpszExt);
BOOL GetCoverPageDisplayName(HWND hDlg, int nCPListCID, LPTSTR lpszFile, ULONG ulFlags,
						LPTSTR lpszDisplayName);

/*
 *	time handling
 */
void InitTimeInfo();
void InitTimeControl(HWND, const int[], short int []);
BOOL HandleTimeControl(HWND, UINT, short, short int[], const int[], WPARAM, LPARAM, ULONG);
void EnableTimeControls(HWND hDlg, const int wCtrlIDs[], BOOL flag);

/*
 *	telephone number-related
 */
// BOOL	EncodeFaxAddress(LPTSTR lpszFaxAddr, LPPARSEDTELNUMBER lpParsedFaxAddr);
// BOOL	DecodeFaxAddress(LPTSTR lpszFaxAddr, LPPARSEDTELNUMBER lpParsedFaxAddr);
BOOL	GetCountry(DWORD dwReqCountryID, LPLINECOUNTRYLIST *lppLineCountryList);
BOOL	GetCountryCode(DWORD dwReqCountryID, DWORD *lpdwCountryCode);
BOOL	GetCountryID(DWORD dwCountryCode, DWORD *lpdwCountryID);
BOOL	InitCountryCodesLB(HWND hLBControl, HWND hAreaCodeControl,DWORD dwCurCountryID,
						HINSTANCE hInst, ULONG ulFlags);
void	HandleCountryCodesLB(HWND hCBControl, HWND hAreaCodeControl, WPARAM wParam, LPARAM lParam);

/*
 *	modem-related
 */
BOOL	EncodeModemName(LPTSTR lpszModemName, LPPARSEDMODEM lpParsedModem);
BOOL	DecodeModemName(LPTSTR lpszModemName, LPPARSEDMODEM lpParsedModem);
BOOL	GetModemProperties(HWND hDlg, LPTSTR lpszModemName, LPMODEMPROPS lpsModemProps);
BOOL	SetModemProperties(HWND hDlg, LPTSTR lpszModemName, LPMODEMPROPS lpsModemProps);

/*
 *	TAPI-related
 */
DWORD	TAPIBasicInit(HINSTANCE hInst, HWND hWnd, LPSTR lpszAppName);
DWORD	InitTAPI(HINSTANCE hInst, HWND hWnd, LPSTR lpszAppName);
BOOL	DeinitTAPI();
WORD	TAPIGetLines(WORD index);
LONG	CallConfigDlg(HWND, LPCSTR);
LONG	SetCurrentLocation(DWORD);
LONG	GetCurrentLocationID( DWORD *lpdwLocation);
LPTSTR	GetCurrentLocationName(void);
DWORD	HowManyLocations(DWORD *lpdwNumLocations);
DWORD	InitLocationParams(HWND hWnd);
LPTSTR	GetCurrentCallingCardName(void);
BOOL	SetCurrentCallingCardName(LPTSTR szCard);
BOOL	GetAreaCode(DWORD dwCountryID, LPTSTR lpszAreaCode);
LPTSTR	GetCurrentLocationAreaCode(void);
DWORD	GetCurrentLocationCountryID(void);
DWORD	GetCurrentLocationCountryCode(void);
DWORD	GetTranslateCaps(LPLINETRANSLATECAPS *lpTransCaps);
DWORD	GetTranslateOutput(LPCSTR lpszAddress, LPLINETRANSLATEOUTPUT *lpTransOutput);
BOOL	ChangeTollList(LPCSTR lpszAddress, DWORD dwWhat);
BOOL	SetTollList(LPCSTR lpszAddress, DWORD dwWhat);
BOOL	AreTollPrefixesSupported(void);
BOOL	IsInTollList(LPCSTR lpszAddress);
ULONG	GetTollList(HWND hWnd, DWORD dwLocID, LPTSTR lpszBuf, DWORD * lpdwBufSize);
ULONG	EditTollListDialog(HWND hWnd);

/*
 *	Registry access functions prototypes
 */
UINT GetInitializerInt(
	HKEY hPDKey,
	LPCTSTR lpszSection,
	LPCTSTR lpszKey,
	INT dwDefault,
	LPCTSTR lpszFile);

DWORD GetInitializerString(
	HKEY hPDKey,
	LPCTSTR lpszSection,
	LPCTSTR lpszKey,
	LPCTSTR lpszDefault,
	LPTSTR lpszReturnBuffer,
	DWORD cchReturnBuffer,
	LPCTSTR lpszFile);

BOOL WriteInitializerString(
	HKEY hPDKey,
	LPCTSTR lpszSection,
	LPCTSTR lpszKey,
	LPCTSTR lpszString,
	LPCTSTR lpszFile);

BOOL WriteInitializerInt(
	HKEY hPDKey,
	LPCTSTR lpszSection,
	LPCTSTR lpszKey,
  	DWORD i,
  	LPCTSTR lpszFile);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\headers\wizdata.h ===
// Merged duplicate copies of this from different versions of sndtoint.h.  -RajeevD

typedef struct
{
   UINT uMode;          //The mode for this data object
   HANDLE hMapiThread;  // If non-NULL, must wait on it before rest of struct is valid!

   LPMAPISESSION lpSes;      //The main session handle
   LPADRBOOK       lpAdrBook;  //The open address book
   LPABCONT lpABCont;   //The open address book container
   LPMESSAGE lpMsg;      //The message that everything is happing to
   LPTSTR lpszDocName;//The document name that was printed
   LPADRLIST lpAdrLst;   //Address List that will be set on the message
   LPTSTR lpszSubject;//The subject of the message
   LPTSTR lpszBody;   //The body of the message
   BOOL bIncCP;         //Include cover page?
   BOOL	bNoteOnCP;		// start the note on the cover page
   TCHAR szCPName[MAX_PATH]; //The name of the cover page selected in the UI
   UINT uPollDoc;    //The type of poll doc to retrieve.  Default or specific
   UINT uPollWhen;   //The time the poll request is to go out
   WORD wSendHour;   //The hour the fax is supposed to go out at
   WORD wSendMinute; //The minute the poll request is supposed to go out at
   TCHAR szPollTitle[MAX_POLL_TITLE];  //The title of the poll request
   TCHAR szPollPasswd[MAX_POLL_PASSWORD];  //The password for the poll request
}
	FAXMAPIDATA, FAR *LPFAXMAPIDATA;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\main\dis.c ===
/***************************************************************************
 Name     :     DIS.C
 Comment  :     Collection if DIS/DCS/DTC and CSI/TSI/CIG mangling routines.
                        They manipulate the DIS struct whose members correspond to the bits
                        of the T30 DIS/DCS/DTC frames.

        Copyright (c) 1993 Microsoft Corp.

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/


#include "prep.h"


#include "protocol.h"

///RSL
#include "glbproto.h"


#define         faxTlog(m)              DEBUGMSG(ZONE_DIS, m)
#define         FILEID                  FILEID_DIS

#ifdef DEBUG
#       define          ST_DIS(x)       if(ZONE_DIS) { x; }
#else
#       define          ST_DIS(x)       { }
#endif

///////// switched from RES-->AWRES values. Table no longer valid /////////
//
//      #define fsim_ILLEGAL    255
//      // converts from RES_ #defines to
//      // DIS bits. Some values have no conversions
//      BYTE F24S_fsim[16] =
//      {
//      /* Converts RES_FINE, RES_200, RES_400, RES_SUPER_SUPER to
//       * ResFine_200, Res16x15_400, ResInchBased, ResMetricBased
//       */
//      /* F24S         fsim */
//      /* 0000 --> 0000 */             0,
//      /* 0001 --> 0101 */             5,
//      /* 0010 -->     0110 */         6,
//      /* 0011 -->     0111 */         7,
//      /* 0100 -->     1010 */         10,
//      /* 0101 -->     XXXX */         fsim_ILLEGAL,
//      /* 0110 -->     1110 */         14,
//      /* 0111 -->     XXXX */         fsim_ILLEGAL,
//      /* 1000 -->     1001 */         8,      /*9,*/          // vanilla Fine mode. No need for metric bit
//      /* 1001 --> 1101 */             13,
//      /* 1010 --> XXXX */             fsim_ILLEGAL,
//      /* 1011 --> XXXX */             fsim_ILLEGAL,
//      /* 1100 --> 1011 */             11,
//      /* 1101 --> XXXX */             fsim_ILLEGAL,
//      /* 1110 --> XXXX */             fsim_ILLEGAL,
//      /* 1111 --> 1111 */             15
//      };
//
///////////////////////////////////////////////////////////////////////








USHORT SetupDISorDCSorDTC(PThrdGlbl pTG, NPDIS npdis, NPBCFAX npbcFax, NPLLPARAMS npll, BOOL fECM, BOOL f64)
{
        // return length of DIS

        USHORT  uLen;



        (MyDebugPrint(pTG,  LOG_ALL,  "In SetOurDIS: baud=0x%02x min=0x%02x res=0x%02x code=0x%02x wide=0x%02x len=0x%02x\r\n",
                                npll->Baud, npll->MinScan, (WORD)npbcFax->AwRes, npbcFax->Encoding, npbcFax->PageWidth, npbcFax->PageLength));

        BG_CHK(npdis);
        BG_CHK((npll->MinScan & ~MINSCAN_MASK) == 0);
        BG_CHK((npbcFax->AwRes & ~AWRES_ALLT30) == 0);
        BG_CHK((npbcFax->Encoding & ~(MH_DATA|MR_DATA|MMR_DATA)) == 0);
        BG_CHK((npbcFax->PageWidth & ~WIDTH_MASK) == 0);
        BG_CHK((npbcFax->PageLength & ~LENGTH_MASK) == 0);
        BG_CHK(npbcFax->fPublicPoll==0 || npbcFax->fPublicPoll==1);
        BG_CHK(fECM==0 || fECM==1);
        BG_CHK(f64==0 || f64==1);
        BG_CHK(!(fECM==0 && f64!=0));

        _fmemset(npdis, 0, sizeof(DIS));

        // npdis->G1stuff  = 0;
        // npdis->G2stuff = 0;
        npdis->G3Rx = 1;  // always ON for DIS & DCS. Indicates T.4 recv Cap/Mode
        npdis->G3Tx = (BYTE) (npbcFax->fPublicPoll);
        // This must be 0 for a DCS frame. The Omnifax G77 and GT choke on it!

        npdis->Baud = npll->Baud;

        npdis->MR_2D    = ((npbcFax->Encoding & MR_DATA) != 0);

        npdis->MMR      = ((npbcFax->Encoding & MMR_DATA) != 0);
        // npdis->MR_2D                 = 0;
        // npdis->MMR                   = 0;

        npdis->PageWidth                = (BYTE) (npbcFax->PageWidth);
        npdis->PageLength               = (BYTE) (npbcFax->PageLength);
        npdis->MinScanCode      = npll->MinScan;

        // npdis->Uncompressed = npdis->ELM = 0;

        npdis->ECM = fECM != FALSE;
        npdis->SmallFrame = f64 != FALSE;


        if(npbcFax->PageWidth > WIDTH_MAX)
        {
                npdis->WidthInvalid = TRUE;
                npdis->Width2 = (npbcFax->PageWidth>>WIDTH_SHIFT);
        }

        // doesn't hold for SendParams (why??)
        // BG_CHK(npbcFax->AwRes & AWRES_mm080_038);
        npdis->Res_300            = 0;  // RSL ((npbcFax->AwRes & AWRES_300_300) != 0);
        npdis->Res8x15            = ((npbcFax->AwRes & AWRES_mm080_154) != 0);


        if (! pTG->SrcHiRes) {
            npdis->ResFine_200 = 0;
        }
        else {
            npdis->ResFine_200      =  ((npbcFax->AwRes & (AWRES_mm080_077|AWRES_200_200)) != 0);
        }

        npdis->Res16x15_400     = ((npbcFax->AwRes & (AWRES_mm160_154|AWRES_400_400)) != 0);
        npdis->ResInchBased = ((npbcFax->AwRes & (AWRES_200_200|AWRES_400_400)) != 0);
        npdis->ResMetricBased = ((npbcFax->AwRes & AWRES_mm160_154) ||
                                                        ((npbcFax->AwRes & AWRES_mm080_077) && npdis->ResInchBased));

/**** switched RES-->AWRES. Table no longer valid *******
        fsim = F24S_fsim[npbcFax->AwRes & 0x0F];
        BG_CHK(fsim != fsim_ILLEGAL);
        npdis->ResFine_200              = ((fsim & 0x08) != 0);         // f
        npdis->Res16x15_400             = ((fsim & 0x04) != 0);         // s
        npdis->ResInchBased             = ((fsim & 0x02) != 0);         // i
        npdis->ResMetricBased   = ((fsim & 0x01) != 0);         // m
**** switched RES-->AWRES. Table no longer valid *******/


        npdis->MinScanSuperHalf = ((npll->MinScan & MINSCAN_SUPER_HALF) != 0);

        if(!fECM) goto done;    // can't have file transfer stuff w/o ECM

/***
        BG_CHK(npll->fNonEfaxBFT==0 || npll->fNonEfaxBFT==1);
        BG_CHK(npll->fNonEfaxSUB==0 || npll->fNonEfaxSUB==1);
        BG_CHK(npll->fNonEfaxSEP==0 || npll->fNonEfaxSEP==1);
        BG_CHK(npll->fNonEfaxPWD==0 || npll->fNonEfaxPWD==1);
        npdis->SEPcap = npll->fNonEfaxSEP;
        npdis->SUBcap = npll->fNonEfaxSUB;
        npdis->PWDcap = npll->fNonEfaxPWD;
        npdis->BFTcap = npdis->CanEmitDataFile = npll->fNonEfaxBFT;

        npdis->DTMcap = npll->fNonEfaxDTM;
        npdis->EDIcap = npll->fNonEfaxEDI;
        npdis->CanEmitCharFile = npdis->CharMode = npll->fNonEfaxCharMode;
***/

done:
        // npdis->Extend24 = npdis->Extend32 = npdis->Extend40 = 0;
        // npdis->Extend48 = npdis->Extend56 = npdis->Extend64 = 0;
        // npdis->Reserved1 = npdis->Reserved2 = npdis->Reserved3 = 0;
        // npdis->Reserved4 = npdis->Reserved5 = 0;


        npdis->Extend24 = npdis->Extend32 = npdis->Extend40 = 0;
        uLen = 3;

#if 0
        for(p = ((NPSTR)npdis)+sizeof(DIS)-1; p>(NPSTR)npdis+2 && *p==0; p--)
                // (MyDebugPrint(pTG,  LOG_ALL,  "t SetOurDIS: Loop p=0x%08lx\r\n", (LPSTR)p))
                        ;
        // p points to last non-zero or to npdis+2 (i.e. 3rd byte)
        for(q = ((NPSTR)npdis)+2; q<p; (*q) |= 0x80, q++)
                // (MyDebugPrint(pTG,  LOG_ALL,  "t SetOurDIS: Loop p=0x%08lx q=0x%08lx\r\n", (LPSTR)p, (LPSTR)q));
                        ;
        // turn high (extend) bit on for all bytes from 3rd (i.e. p+2
        // until the last but one non-zero byte

        // ST_DIS(D_HexPrint((LPSTR)npdis, 8));

        // CHANGE: NEC reports that NTTFAX T31 cannot accept the extra trailing 0
        //         so we should stop sending it!!!
        // // return one more byte in DIS len so that we'll always one extra 0 byte
        // // at the end of each DIS/DCS/DTC. Most fax machines do this, so there must
        // // be some compatibility reason for this
        // // uLen = ((p+1-(NPSTR)npdis) + 1);  // size of DIS to send

        uLen = (p+1-(NPSTR)npdis);      // size of DIS to send
        if(uLen > sizeof(DIS))
                uLen = sizeof(DIS);                             // no extra byte if we have reached end of DIS!
#endif

        (MyDebugPrint(pTG,  LOG_ALL,  "DIS len = %d\r\n", uLen));
        return uLen;
}



///////// switched from RES-->AWRES values. Table no longer valid /////////
//
//      #define F24S_ILLEGAL    255
//      // converts from DIS bits to RES_ #defines
//      Some values have no conversions
//      BYTE fsim_F24S[16] =
//      {
//      /* Converts ResFine_200, Res16x15_400, ResInchBased, ResMetricBased to
//       * AWRES_mm080_077, AWRES_200_200, AWRES_400_400, AWRES_mm160_154
//       */
//      /* fsim         F24S */
//      /* 0000 --> 0000 */             0,
//      /* 0001 -->     XXXX */         F24S_ILLEGAL,
//      /* 0010 -->     XXXX */         F24S_ILLEGAL,
//      /* 0011 --> XXXX */             F24S_ILLEGAL,
//      /* 0100 --> XXXX */             1,      /*F24S_ILLEGAL,*/        // try and make sense of it anyway
//      /* 0101 --> 0001 */             1,
//      /* 0110 --> 0010 */             2,
//      /* 0111 --> 0011 */             3,
//      /* 1000 --> 1000 */             8,
//      /* 1001 --> 1000 */             8,
//      /* 1010 --> 0100 */             4,
//      /* 1011 --> 1100 */             12,
//      /* 1100 --> XXXX */             9,      /*F24S_ILLEGAL,*/       // assume metric preferred
//      /* 1101 --> 1001 */             9,
//      /* 1110 --> 0110 */             6,
//      /* 1111 --> 1111 */             15
//      };
//
///////// switched from RES-->AWRES values. Table no longer valid /////////









void ParseDISorDCSorDTC(PThrdGlbl pTG, NPDIS npDIS, NPBCFAX npbcFax, NPLLPARAMS npll, BOOL fParams)
{
///////////////////////////////////////////////////////////////
// Prepare to get trash (upto 2 bytes) at end of every frame //
///////////////////////////////////////////////////////////////

        // BYTE fsim, F24S;
        NPBYTE npb, npbLim;

// first make sure DIS is clean. We may have picked up some trailing CRCs
// trailing-trash removed by reading the Extend bits

        npb = npbLim = (NPBYTE)npDIS;
        npbLim += sizeof(DIS);
        for(npb+=2; npb<npbLim && (*npb & 0x80); npb++)
                ;
        // exits when npb points past end of structure or
        // points to the first byte with the high bit NOT set
        // i.e. the last VALID byte

        for(npb++; npb<npbLim; npb++)
                *npb = 0;
        // starting with the byte AFTER the last valid byte, until end
        // of the structure, zap all bytes to zero

// parse high level params into NPI

        memset(npbcFax, 0, sizeof(BCFAX));

        npbcFax->AwRes = 0;
        npbcFax->Encoding = 0;

        // Resolution
        if(npDIS->Res8x15)      npbcFax->AwRes |= AWRES_mm080_154;
        if(npDIS->Res_300)      npbcFax->AwRes |= AWRES_300_300;

        if(npDIS->ResInchBased)
        {
                if(npDIS->ResFine_200)  npbcFax->AwRes |= AWRES_200_200;
                if(npDIS->Res16x15_400) npbcFax->AwRes |= AWRES_400_400;
        }
        if(npDIS->ResMetricBased || !npDIS->ResInchBased)
        {
                if(npDIS->ResFine_200)  npbcFax->AwRes |= AWRES_mm080_077;
                if(npDIS->Res16x15_400) npbcFax->AwRes |= AWRES_mm160_154;
        }

/***** switched from RES-->AWRES values. Table no longer valid *****
        fsim = 0;
        if(npDIS->ResFine_200)          fsim |= 0x08;   // f
        if(npDIS->Res16x15_400)         fsim |= 0x04;   // s
        if(npDIS->ResInchBased)         fsim |= 0x02;   // i
        if(npDIS->ResMetricBased)       fsim |= 0x01;   // m
        F24S = fsim_F24S[fsim];
        if(F24S != F24S_ILLEGAL)
        {
                npbcFax->AwRes |= F24S;
        }
        else
        {
                // BG_CHK(FALSE);
                // must be prepared to receive any garbage
        }
***** switched from RES-->AWRES values. Table no longer valid *****/

        // Encoding (MMR only if ECM also supported)
        if(npDIS->MR_2D)                                npbcFax->Encoding |= MR_DATA;
        if(npDIS->MMR && npDIS->ECM)    npbcFax->Encoding |= MMR_DATA;

        if(!fParams)
        {
                // setting up capabilities -- add the "always present" caps
                npbcFax->AwRes |= AWRES_mm080_038;
                npbcFax->Encoding |= MH_DATA;
        }
        else
        {
                // setting up params -- set the defaults if none otehr specified
                if(!npbcFax->AwRes)     npbcFax->AwRes = AWRES_mm080_038;
                if(!npbcFax->Encoding)  npbcFax->Encoding = MH_DATA;

                // if both MR & MMR are set (this happens with Ricoh's fax simulator!)
                // then set just MMR. MH doesnt have an explicit bit, so we set MH
                // here only if nothing else is set. So the only multiple-setting case
                // (for encodings) that we can encounter is (MR|MMR). BUG#6950
                if(npbcFax->Encoding == (MR_DATA|MMR_DATA))
                        npbcFax->Encoding = MMR_DATA;
        }

        // PageWidth and Length
        npbcFax->PageWidth      = npDIS->PageWidth;

        // IFAX Bug#8152: Hack for interpreting invalid value (1,1) as
        // A3, because some fax machines do that. This is
        // as per Note 7 of Table 2/T.30 of ITU-T.30 (1992, page 40).
#define WIDTH_ILLEGAL_A3 0x3
        if (!fParams && npbcFax->PageWidth==WIDTH_ILLEGAL_A3)
        {
                npbcFax->PageWidth=WIDTH_A3;
        }
        npbcFax->PageLength     = npDIS->PageLength;

        // has G3 file available for polling
        npbcFax->fPublicPoll = npDIS->G3Tx;
        // This must be 0 for DCS frames! However if it's not let it pass anyway
        BG_CHK(fParams ? (npDIS->G3Tx==0) : TRUE);


/**** Can't deal with narrow widths yet. Just pretend they're 1728 ****
        if(npDIS->PageWidthInvalid)
                npbcFax->PageWidth = (npdis->PageWidth2 << WIDTH_SHIFT);
***********************************************************************/


// Now low level params LLPARAMS
// Baudrate, ECM, ECM frame size, and MinScan. That's it!

        npll->Baud = npDIS->Baud;
        npll->fECM = npDIS->ECM;
        npll->fECM64 = npDIS->SmallFrame;
        npll->MinScan = npDIS->MinScanCode;
        if(npDIS->MinScanSuperHalf)
                npll->MinScan |= MINSCAN_SUPER_HALF;

        if(!npll->fECM) goto done;      // can't have file transfer stuff w/o ECM

/***
        npll->fNonEfaxSUB = npdis->SUBcap;
        npll->fNonEfaxSEP = npdis->SEPcap;
        npll->fNonEfaxPWD = npdis->PWDcap;
        npll->fNonEfaxBFT = npdis->BFTcap;
        npll->fNonEfaxDTM = npdis->DTMcap;
        npll->fNonEfaxEDI = npdis->EDIcap;
        npll->fNonEfaxCharMode = npdis->CharMode;
***/

done:
        (MyDebugPrint(pTG,  LOG_ALL,  "Ex ParseDIS_DCS: baud=0x%02x min=0x%02x res=0x%02x code=0x%02x wide=0x%02x len=0x%02x\r\n",
                                npll->Baud, npll->MinScan, (WORD)npbcFax->AwRes, npbcFax->Encoding, npbcFax->PageWidth, npbcFax->PageLength));
        ;
}











/* Converts the code for a speed to the speed in BPS */

UWORD CodeToBPS[16] =
{
/* V27_2400             0 */    2400,
/* V29_9600             1 */    9600,
/* V27_4800             2 */    4800,
/* V29_7200             3 */    7200,
/* V33_14400    4 */    14400,
                                                0,
/* V33_12000    6 */    12000,
                                                0,
/* V17_14400    8 */    14400,
/* V17_9600             9 */    9600,
/* V17_12000    10 */   12000,
/* V17_7200             11 */   7200,
                                                0,
                                                0,
                                                0,
                                                0
};


#define msBAD   255

/* Converts a DCS min-scan field code into millisecs */
BYTE msPerLine[8] = { 20, 5, 10, msBAD, 40, msBAD, msBAD, 0 };














USHORT MinScanToBytesPerLine(PThrdGlbl pTG, BYTE MinScan, BYTE Baud)
{
        USHORT uStuff;
        BYTE ms;

        uStuff = CodeToBPS[Baud];
        BG_CHK(uStuff);
        ms = msPerLine[MinScan];
        BG_CHK(ms != msBAD);
        uStuff /= 100;          // StuffBytes = (BPS * ms)/8000
        uStuff *= ms;           // take care not to use longs
        uStuff /= 80;           // or overflow WORD or lose precision
        uStuff += 1;            // Rough fix for truncation problems

        return uStuff;
}





#define ms40    4
#define ms20    0
#define ms10    2
#define ms5             1
#define ms0             7

/* first index is a DIS min-scan capability. 2nd is 0 for normal
 * 1 for fine (1/2) and 2 for super-fine (if 1/2 yet again).
 * Output is the Code to stick in the DCS.
 */

BYTE    MinScanTab[8][3] =
{
        ms20,   ms20,   ms10,
        ms5,    ms5,    ms5,
        ms10,   ms10,   ms5,
        ms20,   ms10,   ms5,
        ms40,   ms40,   ms20,
        ms40,   ms20,   ms10,
        ms10,   ms5,    ms5,
        ms0,    ms0,    ms0
};


#define V_ILLEGAL       255

#define V27_2400        0
#define V27_4800        2
#define V29_9600        1
#define V29_7200        3
#define V33_14400       4
#define V33_12000       6
#define V17_14400       8
#define V17_12000       10
#define V17_9600        9
#define V17_7200        11

#define V27_SLOW                        0
#define V27_ONLY                        2
#define V29_ONLY                        1
#define V33_ONLY                        4
#define V17_ONLY                        8
#define V27_V29                         3
#define V27_V29_V33                     7
#define V27_V29_V33_V17         11
#define V_ALL                           15

/* Converts a capability into the best speed it offers.
 * index will usually be the & of both DIS's Baud rate fields
 * (both having first been "adjusted", i.e. 11 changed to 15)
 * Output is the Code to stick in the DCS.
 */



BYTE BaudNegTab[16] =
{
/* V27_SLOW                     0 --> 0 */      V27_2400,
/* V29_ONLY                     1 --> 1 */      V29_9600,
/* V27_ONLY                     2 --> 2 */      V27_4800,
/* V27_V29                      3 --> 1 */      V29_9600,
                                                                V_ILLEGAL,
                                                                V_ILLEGAL,
                                                                V_ILLEGAL,
/* V27_V29_V33          7 --> 4 */      V33_14400,
                                                                V_ILLEGAL,
                                                                V_ILLEGAL,
                                                                V_ILLEGAL,
/* V27_V29_V33_V17      11 --> 8 */     V17_14400,
                                                                V_ILLEGAL,
                                                                V_ILLEGAL,
                                                                V_ILLEGAL,
/* V_ALL                        15 --> 8 */     V17_14400
};













/***************************************************************************
        Name      :     NegotiateLowLevelParams
        Purpose   :     Takes a received DIS and optionally MS NSF,
                                our HW caps and

                                picks highest common baud rate, ECM is picked if both have it
                                ECM frame size is 256 unless remote DIS has that bit set to 1
                                or we want small frames (compiled-in option).

                                The MinScan time is set to the max.
                                                        (i.e. highest/slowest) of both.

                                Fill results in Negot section of npProt

        CalledFrom:     NegotiateLowLevelParams is called by the sender when a DIS
                                and/or NSF is received.
***************************************************************************/


void NegotiateLowLevelParams(PThrdGlbl pTG, NPLLPARAMS npllRecv, NPLLPARAMS npllSend,
                                        DWORD AwRes, USHORT uEnc, NPLLPARAMS npllNegot)
{
        USHORT  Baud, Baud1, Baud2;
        USHORT  MinScanCode, col;

        ////// negotiate Baudrate, ECM, ECM frame size, and MinScan. That's it!

        Baud1 = npllRecv->Baud;
        Baud2 = npllSend->Baud;
        if(Baud1 == 11) Baud1=15;
        if(Baud2 == 11) Baud2=15;
        Baud = Baud1 & Baud2;
        npllNegot->Baud = BaudNegTab[Baud];
        BG_CHK(npllNegot->Baud != V_ILLEGAL);
        // there is always some common baud rate (i.e. at least 2400 mandatory)

        // ECM. On if both have it. Frame size is small if either
        // party want it so. (though using this bit in the DIS is
        // contrary to the T.30 spec). But we will come to no harm
        // treating it so

        if((uEnc==MH_DATA || uEnc==MR_DATA) && (pTG->ProtParams.EnableG3SendECM==0))
        {
                npllNegot->fECM = 0;
                npllNegot->fECM64 = 0;
        }
        else
        {
                // gotta be TRUE otherwise we've negotiated
                // ourselves into a hole here....
                BG_CHK(npllRecv->fECM && npllSend->fECM);

                npllNegot->fECM   = 0; // RSL BUGBUG (npllRecv->fECM && npllSend->fECM);

                // 64 bytes if receiver request it & we support it
                // npllNegot->fECM64 = (npllRecv->fECM64 && npllSend->fECM64);
                // Exercise sender's prerogative--64 bytes if we have that selected
                // npllNegot->fECM64 = npllSend->fECM64;
                // Use if either want it (i.e. sender selected it or receiver prefers it)
                npllNegot->fECM64 = 0; // RSL BUGBUG (npllRecv->fECM64 || npllSend->fECM64);
        }


        /* Minimum Scan line times. Only Receiver's pref matters.
         * Use teh table above to convert from Receiver's DIS to the
         * required DCS. Col 1 is used if vertical res. is normal (100dpi)
         * Col2 if VR is 200 or 300dpi, (OR if VR is 400dpi, but Bit 46
         * is not set), and Col3 is used if VR is 400dpi *and* Bit 46
         * (MinScanSuperHalf) is set
         */

        if(npllNegot->fECM)
        {
                npllNegot->MinScan = ms0;
        }
        else
        {
                MinScanCode = (npllRecv->MinScan & 0x07);       // low 3 bits

                if(AwRes & (AWRES_mm080_154|AWRES_mm160_154|AWRES_400_400))
                {
                        if(npllRecv->MinScan & MINSCAN_SUPER_HALF)
                                col = 2;
                        else
                                col = 1;
                }
                // T30 says scan time for 300dpi & 200dpi is the same
                else if(AwRes & (AWRES_300_300|AWRES_mm080_077|AWRES_200_200))
                        col = 1;
                else
                        col = 0;

                npllNegot->MinScan = MinScanTab[MinScanCode][col];
        }

        (MyDebugPrint(pTG,  LOG_ALL,  "In NegotiateLL: baud=0x%02x min=0x%02x ECM=%d small=%d\r\n",
                                npllNegot->Baud, npllNegot->MinScan, npllNegot->fECM, npllNegot->fECM64));
}



















USHORT GetStupidReversedFIFs(PThrdGlbl pTG, LPSTR lpstr1, LPSTR lpstr2)
{
        /** Both args always 20 bytes long. Throws away leading & trailing
                blanks, then copies what's left *reversed* into lpstr[].
                Terminates with 0.
        **/

        int i, j, k;

        BG_CHK(lpstr2 && lpstr1);

        // (MyDebugPrint(pTG,  LOG_ALL,  "In GetReverseFIF: lpstr1=0x%08lx lpstr2=0x%08lx lpstr2=%20s\r\n",
        //                      (LPSTR)lpstr1, lpstr2, lpstr2));

        for(k=0; k<IDFIFSIZE && lpstr2[k]==' '; k++)    // k==first nonblank or 20
                ;
        for(j=IDFIFSIZE-1; j>=k && lpstr2[j]==' '; j--) // j==last nonblank or -1
                ;


// RSL 10/30/96 Leave FIF alone: just remove leading/trailing blanks and reverse bytes.
#if 0
        // added to convert single leading space to +. See bug#771 & comments
        // under CreateIdFrame routine. Since lpstr2 is reversed, leading==
        // trailing

        if(j == IDFIFSIZE-2)    // single leading blank only
        {
                lpstr1[0] = '+';
                i = 1;
        }
        else
                i = 0;
#else
        i = 0;
#endif

        for( ; i<IDFIFSIZE && j>=k; i++, j--)
                lpstr1[i] = lpstr2[j];
        lpstr1[i] = 0;

        (MyDebugPrint(pTG,  LOG_ALL,  "GetFIF: Got<%s> produced<%s>\r\n", (LPSTR)lpstr2, (LPSTR)lpstr1));
        // (MyDebugPrint(pTG,  LOG_ALL,  "Ex GetReverseFIF: lpstr1=0x%08lx lpstr2=0x%08lx lpstr1=%20s lpstr2=%20s\r\n",
        //                      (LPSTR)lpstr1, lpstr2, (LPSTR)lpstr1, lpstr2));

        return (USHORT)i;
}





















void CreateStupidReversedFIFs(PThrdGlbl pTG, LPSTR lpstr1, LPSTR lpstr2)
{
        /** Both args always 20 bytes long. Copies LPSTR *reversed* into
                the end of lpstr1[], then pads rest with blank.
                Terminates with a 0
        **/

        int i, j;

        BG_CHK(lpstr2 && lpstr1);

        // (MyDebugPrint(pTG,  LOG_ALL,  "In CreateReverseFIF: lpstr1=0x%08lx lpstr2=0x%08lx lpstr2=%20s\r\n",
        //                      lpstr1, lpstr2, lpstr2));

        for(i=0, j=IDFIFSIZE-1; lpstr2[i] && j>=0; i++, j--)
                lpstr1[j] = lpstr2[i];
        if(j>=0)
                _fmemset(lpstr1, ' ', j+1);
        lpstr1[IDFIFSIZE] = 0;

        // (MyDebugPrint(pTG,  LOG_ALL,  "Ex CreateReverseFIF: lpstr1=0x%08lx lpstr2=0x%08lx lpstr1=%20s lpstr2=%20s\r\n",
        //                      lpstr1, lpstr2, lpstr1, lpstr2));

}


/* Converts a the code for a speed to the code fro the next
 * best (lower) speed. order is
   (V17: 144-120-96-72-V27_2400) (V33: 144 120 V29: 96 72 V27: 48 24)
 */
// NOTE: FRANCE defines the fallback sequence to go from V17_7200 to V27_4800




BYTE DropBaudTab[16] =
{
/* V27_2400     --> X                   0 --> X */      V_ILLEGAL,
/* V29_9600     --> V29_7200    1 --> 3 */      V29_7200,
/* V27_4800     --> V27_2400    2 --> 0 */      V27_2400,
/* V29_7200     --> V27_4800    3 --> 2 */      V27_4800,
/* V33_14400 -> V33_12000       4 --> 6 */      V33_12000,
                                                                                V_ILLEGAL,
/* V33_12000 -> V29_9600        6 --> 1 */      V29_9600,
                                                                                V_ILLEGAL,
/* V17_14400 -> V17_12000       8 -> 10 */      V17_12000,
/* V17_9600 --> V17_7200        9 -> 11 */      V17_7200,
/* V17_12000 -> V17_9600        10 -> 9 */      V17_9600,
/* V17_7200 --> V29_9600        11 -> 1
                         or V29_7200    11 -> 3
USE THIS---> or V27_4800        11 -> 2
                         or V27_2400    11 -> 0 */      V27_4800,
                                                                V_ILLEGAL,
                                                                V_ILLEGAL,
                                                                V_ILLEGAL,
                                                                V_ILLEGAL
};



















BOOL DropSendSpeed(PThrdGlbl pTG)
{
        USHORT  uSpeed;

        BG_CHK(pTG->ProtInst.fllNegotiated);

        // enforce LowestSendSpeed
        if( ((uSpeed=DropBaudTab[pTG->ProtInst.llNegot.Baud]) == V_ILLEGAL) ||
                ((pTG->ProtInst.LowestSendSpeed <= 14400) &&
                        (CodeToBPS[uSpeed] < pTG->ProtInst.LowestSendSpeed)) )
        {
                BG_CHK(pTG->ProtInst.llNegot.Baud==V27_2400 ||
                         CodeToBPS[pTG->ProtInst.llNegot.Baud]==pTG->ProtInst.LowestSendSpeed);
                (MyDebugPrint(pTG,  LOG_ALL,  "DropSpeed--Can't drop (0x%02x)\r\n", pTG->ProtInst.llNegot.Baud));
                return FALSE;
                // speed remains same as before if lowest speed
                // return FALSE to hangup
        }
        else
        {
                (MyDebugPrint(pTG,  LOG_ALL,  "DropSpeed--Now at 0x%02x\r\n", uSpeed));
                pTG->ProtInst.llNegot.Baud = (BYTE) uSpeed;
                return TRUE;
        }
}
















void EnforceMaxSpeed(PThrdGlbl pTG)
{
        // enforce HighestSendSpeed setting
        BG_CHK(!pTG->ProtInst.HighestSendSpeed || (pTG->ProtInst.HighestSendSpeed>=2400 &&
                        pTG->ProtInst.HighestSendSpeed >= pTG->ProtInst.LowestSendSpeed));

        if( pTG->ProtInst.HighestSendSpeed && pTG->ProtInst.HighestSendSpeed >= 2400 &&
                pTG->ProtInst.HighestSendSpeed >= pTG->ProtInst.LowestSendSpeed)
        {
                (MyDebugPrint(pTG,  LOG_ALL,  "MaxSend=%d. Baud=%x BPS=%d, dropping\r\n",
                        pTG->ProtInst.HighestSendSpeed, pTG->ProtInst.llNegot.Baud, CodeToBPS[pTG->ProtInst.llNegot.Baud]));

                while(CodeToBPS[pTG->ProtInst.llNegot.Baud] > pTG->ProtInst.HighestSendSpeed)
                {
                        if(!DropSendSpeed(pTG))
                        {
                                BG_CHK(FALSE);
                                break;
                        }
                }
                (MyDebugPrint(pTG,  LOG_ALL,  "Done---MaxSend=%d. Baud=%x BPS=%d\r\n",
                        pTG->ProtInst.HighestSendSpeed, pTG->ProtInst.llNegot.Baud, CodeToBPS[pTG->ProtInst.llNegot.Baud]));
        }
}














USHORT CopyFrame(PThrdGlbl pTG, LPBYTE lpbDst, LPFR lpfr, USHORT uSize)
{
///////////////////////////////////////////////////////////////
// Prepare to get trash (upto 2 bytes) at end of every frame //
///////////////////////////////////////////////////////////////

        USHORT uDstLen;

        uDstLen = min(uSize, lpfr->cb);
        _fmemset(lpbDst, 0, uSize);
        _fmemcpy(lpbDst, lpfr->fif, uDstLen);
        return uDstLen;
}














void CopyRevIDFrame(PThrdGlbl pTG, LPBYTE lpbDst, LPFR lpfr)
{
///////////////////////////////////////////////////////////////
// Prepare to get trash (upto 2 bytes) at end of every frame //
///////////////////////////////////////////////////////////////

        USHORT  uDstLen;
        char    szTemp[IDFIFSIZE+2];

        uDstLen = min(IDFIFSIZE, lpfr->cb);
        _fmemset(szTemp, ' ', IDFIFSIZE);       // fill spaces (reqd by GetReverse)
        _fmemcpy(szTemp, lpfr->fif, uDstLen);
        szTemp[IDFIFSIZE] = 0;  // zero-terminate

        GetStupidReversedFIFs(pTG, lpbDst, szTemp);

        if(uDstLen!=IDFIFSIZE)
                MyDebugPrint(pTG, LOG_ERR, "<<ERROR>> Bad ID frame\r\n" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\main\debug.h ===
/**--------------------------- Debugging ------------------------**/

#define SZMOD                   "T30: "

#ifdef DEBUG
        extern DBGPARAM dpCurSettings;

#       define ZONE_T30                 ((1L << 0) & dpCurSettings.ulZoneMask)
#       define ZONE_ECM                 ((1L << 1) & dpCurSettings.ulZoneMask)
#       define ZONE_SWECM               ZONE_ECM
#       define ZONE_HD                  ((1L << 2) & dpCurSettings.ulZoneMask)
#       define ZONE_BG                  ((1L << 3) & dpCurSettings.ulZoneMask)
#       define ZONE_FRAMES              ((1L << 4) & dpCurSettings.ulZoneMask)
#       define ZONE_MAIN                ((1L << 5) & dpCurSettings.ulZoneMask)
#       define ZONE_BUFS                ((1L << 12) & dpCurSettings.ulZoneMask)
#       define ZONE_FIL                 ((1L << 13) & dpCurSettings.ulZoneMask)
#       define ZONE_TIMEOUT             ((1L << 14) & dpCurSettings.ulZoneMask)
#       define ZONE_TO                  ((1L << 15) & dpCurSettings.ulZoneMask)
#       define ZONE_IFP                 ((1L << 7) & dpCurSettings.ulZoneMask)
#endif

#ifdef DEBUG
#       define ST_FRAMES(x)     if(ZONE_FRAMES) { x; }
#else
#       define ST_FRAMES(x)     { }
#endif



#define MODID           MODID_AWT30

#define FILEID_ECM              1
#define FILEID_FILTER   2
#define FILEID_HDLC             3
#define FILEID_T30              4
#define FILEID_T30MAIN  5
#define FILEID_TIMEOUTS 6
#define FILEID_IFP              7
#define FILEID_SWECM    8


#ifdef PDUMP    // Protocol Dump
        void RestartDump(PThrdGlbl pTG);
        void DumpFrame(PThrdGlbl pTG, BOOL     fSend, IFR ifr, USHORT cbFIF, LPBYTE lpbFIF);
        void PrintDump(PThrdGlbl pTG);
#else
#       define RestartDump(PThrdGlbl pTG)
#       define DumpFrame(PThrdGlbl pTG, fSend, ifr, cbFIF, lpbFIF)
#       define PrintDump(PThrdGlbl pTG)
#endif

#ifdef DEBUG
        void D_PrintFrame(LPB lpb, UWORD cb);
#else
#       define  D_PrintFrame(lpb, cb)   {}
#endif

// errmsg for echo protection code
#define ECHOMSG(ifr)    RETAILMSG((SZMOD "WARNING: Ignoring ECHO of %s(%d)\r\n", (LPSTR)(rgFrameInfo[ifr].szName), ifr));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\main\ecm.c ===
/***************************************************************************
 Name     :     ECM.C
 Comment  :     Contains the ECM T30 routines
 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/


#include "prep.h"

#include "efaxcb.h"
#include "t30.h"
#include "hdlc.h"
#include "debug.h"

///RSL
#include "glbproto.h"


#define         faxTlog(m)              DEBUGMSG(ZONE_ECM, m)
#define         FILEID                  FILEID_ECM

typedef enum
{
        ECMRECVOK_OK,
        ECMRECVOK_BADFR,
        ECMRECVOK_ABORT
}
ECMRECVOK;

/****************** begin prototypes from ecm.c *****************/
IFR RNR_RRLoop(PThrdGlbl pTG);
IFR CTC_RespRecvd(PThrdGlbl pTG, USHORT uBaud);
BOOL Recv_NotReadyLoop(PThrdGlbl pTG, IFR ifrFirst, IFR ifrLast);
BOOL FillInFrames(PThrdGlbl pTG, USHORT N, LONG sBufSize, USHORT uDataSize);
ECMRECVOK ECMRecvOK(PThrdGlbl pTG);
/***************** end of prototypes from ecm.c *****************/



BYTE RCP[3] = { 0xFF, 0x03, 0x86 };






ET30ACTION      ECMPhaseC(PThrdGlbl pTG, BOOL fReTx)
{
        USHORT          uFrameNum, uFramesSent, uLim;
        SWORD           swRet;
        ULONG           lTotalLen=0;
        LPBYTE          lpPPRMask;
        LPBUFFER        lpbf=0;
        USHORT          uMod;

        /******** Transmitter ECM Phase C. Fig A-7/T.30 (sheet 1) ********/

/***
        switch(action = Params.lpfnWhatNext(pTG, eventSTARTSEND))
        {
          case actionCONTINUE:  break;
          case actionDCN:
          case actionHANGUP:    return action;
          case actionERROR:             return action;  // goto PhaseLoop & exit
          default:                              return BadAction(action);
        }
***/

        pTG->ECM.uFrameSize = ProtGetECMFrameSize(pTG);
        BG_CHK(pTG->ECM.uFrameSize==6 || pTG->ECM.uFrameSize==8);

        // already done in WhatNext
        // uSize = (1 << pTG->ECM.uFrameSize);
        // ICommSetSendMode(TRUE, uSize+ECM_EXTRA, uSize, TRUE);

        if(fReTx)
        {
                lpPPRMask = ProtGetRetransmitMask(pTG);
        }
        else
        {
                pTG->ECM.uPPRCount = 0;

                if(pTG->ECM.fEndOfPage)
                {
                        pTG->ECM.SendPageCount++;
                        pTG->ECM.SendBlockCount = 1;
                        pTG->ECM.dwPageSize=0;

                        faxTlog((SZMOD "Waiting for Startpage in ECM at 0x%08lx\r\n", GetTickCount()));
                        DEBUGSTMT(IFProcProfile((HTASK)(-1), TRUE));

                        // Callback to open file to send. Doesn't return any data
                        if((swRet=GetSendBuf(pTG, 0, SEND_STARTPAGE)) != SEND_OK)
                        {
                                ERRMSG((SZMOD "<<ERROR>> Nonzero return %d from SendProc at Start Page\r\n", swRet));
                                // return actionDCN;
                                return actionERROR;
                        }

                        DEBUGSTMT(IFProcProfile((HTASK)(-1), FALSE));
                        faxTlog((SZMOD "Got Startpage in ECM at 0x%08lx\r\n", GetTickCount()));
                }
                else
                {
                        pTG->ECM.SendBlockCount++;

                        faxTlog((SZMOD "Waiting for Startblock in ECM at 0x%08lx\r\n", GetTickCount()));
                        DEBUGSTMT(IFProcProfile((HTASK)(-1), TRUE));

                        // Callback to open file to send. Doesn't return any data
                        if((swRet=GetSendBuf(pTG, 0, SEND_STARTBLOCK)) != SEND_OK)
                        {
                                ERRMSG((SZMOD "<<ERROR>> Nonzero return %d from SendProc at Start Page\r\n", swRet));
                                // return actionDCN;
                                return actionERROR;
                        }

                        DEBUGSTMT(IFProcProfile((HTASK)(-1), FALSE));
                        faxTlog((SZMOD "Got Startblock in ECM at 0x%08lx\r\n", GetTickCount()));
                }
        }

        faxTlog((SZMOD "Starting ECM Partial Page SEND.......P=%d B=%d ReTx=%d\r\n",
                        pTG->ECM.SendPageCount, pTG->ECM.SendBlockCount, fReTx));
        if(fReTx)
                ICommStatus(pTG, T30STATS_RESEND_ECM, pTG->ECM.SendPageCount, 0, pTG->ECM.SendBlockCount);

        uMod = ProtGetSendMod(pTG);
        if(uMod >= V17_START && !pTG->ECM.fSentCTC) uMod |= ST_FLAG;
        pTG->ECM.fSentCTC = FALSE;

        // here we should use a small timeout (100ms?) and if it fails,
        // should go back to sending the previous V21 frame (which could be DCS
        // or MPS or whatever, which is why it gets complicated & we havn't
        // done it!). Meanwhile use a long timeout, ignore return value
        // and send anyway.

        if(!ModemRecvSilence(pTG, pTG->Params.hModem, RECV_PHASEC_PAUSE, LONG_RECVSILENCE_TIMEOUT))
        {
                ERRMSG((SZMOD "<<ERROR>> ECM Pix RecvSilence(%d, %d) FAILED!!!\r\n", RECV_PHASEC_PAUSE, LONG_RECVSILENCE_TIMEOUT));
        }

        if(!ModemSendMode(pTG, pTG->Params.hModem, uMod, TRUE, ifrECMPIX))
        {
                ERRMSG((SZMOD "<<ERROR>> ModemSendMode failed in Tx ECM PhaseC\r\n"));
                ICommFailureCode(pTG, T30FAILSE_SENDMODE_PHASEC);
                BG_CHK(FALSE);
                return actionERROR;
        }

#ifdef IFAX
        BroadcastMessage(pTG, IF_PSIFAX_DATAMODE, (PSIFAX_SEND|PSIFAX_ECM|(fReTx ? PSIFAX_RESEND : 0)), (uMod & (~ST_FLAG)));
#endif
        faxTlog((SZMOD "SENDING ECM Page Data.....\r\n"));
        FComCriticalNeg(pTG, FALSE);

        uLim = (fReTx ? pTG->ECM.SendFrameCount : 256);
        BG_CHK(uLim);
        BG_CHK(lpbf == 0);

        for(uFrameNum=0, uFramesSent=0, lTotalLen=0, swRet=0; uFrameNum<uLim; uFrameNum++)
        {
                if(!fReTx || (lpPPRMask[uFrameNum/8] & (1 << (uFrameNum%8))))
                {
                        BG_CHK(uFrameNum < 256 && pTG->ECM.uFrameSize <=8);  // shift below won't ovf 16 bits
                        BG_CHK(lpbf == 0);
                        swRet = GetSendBuf(pTG, &lpbf, (fReTx ? ((SLONG)(uFrameNum << pTG->ECM.uFrameSize)) : SEND_SEQ));

                        if(swRet == SEND_ERROR)
                        {
                                ERRMSG((SZMOD "<<ERROR>> Error return from SendProc in ECM retransmit\r\n"));
                                BG_CHK(lpbf == 0);
                                // return actionDCN;    // goto NodeC;
                                return actionERROR;
                        }
                        else if(swRet == SEND_EOF)
                        {
                                BG_CHK(lpbf == 0);
                                if(!fReTx)
                                        break;
                                else
                                {
                                        BG_CHK(FALSE);
                                        ICommFailureCode(pTG, T30FAILSE_PHASEC_RETX_EOF);
                                        return actionDCN;
                                }
                        }
                        BG_CHK(swRet == SEND_OK);

                        BG_CHK(lpbf);
                        BG_CHK(lpbf->lpbBegBuf+4 == lpbf->lpbBegData);

                        lpbf->lpbBegBuf[0] = 0xFF;
                        lpbf->lpbBegBuf[1] = 0x03;
                        lpbf->lpbBegBuf[2] = 0x06;
                        lpbf->lpbBegBuf[3] = (BYTE) uFrameNum;
                        lpbf->lpbBegData -= 4;
                        lpbf->wLengthData += 4;

                        lTotalLen += lpbf->wLengthData;

                        if(!ModemSendMem(pTG, pTG->Params.hModem, lpbf->lpbBegData, lpbf->wLengthData, SEND_ENDFRAME))
                        {
                                ERRMSG((SZMOD "<<ERROR>> DataWrite Timeout in ECM Phase C\r\n"));
                                ICommFailureCode(pTG, T30FAILSE_MODEMSEND_PHASEC);
                                BG_CHK(FALSE);
                                return actionERROR;             // goto error;
                        }

                        // faxTlog((SZMOD "Freeing 0x%08lx in ECM\r\n", lpbf));
                        if(!MyFreeBuf(pTG, lpbf))
                        {
                                ERRMSG((SZMOD "<<ERROR>> FReeBuf failed in ECM Phase C\r\n"));
                                ICommFailureCode(pTG, T30FAILSE_FREEBUF_PHASEC);
                                BG_CHK(FALSE);
                                return actionERROR;             // goto error;
                        }
                        lpbf = 0;
                        uFramesSent++;
                }
        }

        if( !ModemSendMem(pTG, pTG->Params.hModem, RCP, 3, SEND_ENDFRAME) ||
                !ModemSendMem(pTG, pTG->Params.hModem, RCP, 3, SEND_ENDFRAME) ||
                !ModemSendMem(pTG, pTG->Params.hModem, RCP, 3, SEND_ENDFRAME|SEND_FINAL))
        {
                ERRMSG((SZMOD "<<ERROR>> DataWrite Timeout on RCPs\r\n"));
                ICommFailureCode(pTG, T30FAILSE_MODEMSEND_ENDPHASEC);
                BG_CHK(FALSE);
                return actionERROR;             // goto error;
        }
/***
        if(!ModemDrain())
                return FALSE;
***/

        FComCriticalNeg(pTG, TRUE);

        faxTlog((SZMOD "Page Send Done.....len=(%ld, 0x%08x)\r\n", lTotalLen, lTotalLen));
        pTG->ECM.FramesSent = uFramesSent;

        if(!fReTx)
        {
                BG_CHK(lTotalLen>=(ULONG)uFramesSent*4);
                pTG->ECM.dwPageSize+= (lTotalLen-uFramesSent*4); // 4-bytes of framing data
                pTG->ECM.SendFrameCount = uFrameNum;

                switch(GetSendBuf(pTG, 0, SEND_QUERYENDPAGE))
                {
                case SEND_OK:   pTG->ECM.fEndOfPage = FALSE; break;
                case SEND_EOF:  pTG->ECM.fEndOfPage = TRUE;  break;
                default:                ERRMSG((SZMOD "<<ERROR>> Got SEND_ERROR from GetSendBuf at end of page\r\n"));
                                                return actionERROR;
                }
        }
        if(!pTG->ECM.FramesSent)
        {
                ERRMSG((SZMOD "<<ERROR>> Sent 0 frames--Bad PPR recvd or bad send file\r\n"));
                ICommFailureCode(pTG, T30FAILSE_BADPPR);
                return actionERROR;
        }

        pTG->T30.fSendAfterSend = TRUE;      // ECM PhaseC/PIX--PPS-X
        return actionGONODE_V;
}












ET30ACTION      ECMPhaseD(PThrdGlbl pTG)
{
        USHORT          uTryCount, i;
        ET30ACTION      action;
        BYTE            bPPSfif[3];
        LPBYTE          lpPPR;

        /******** Transmitter ECM Phase D. Fig A-8 to A-17/T.30 ********/

        if(!pTG->ECM.fEndOfPage)
        {
                pTG->T30.ifrSend = ifrPPS_NULL;
        }
        else
        {
                switch(action = pTG->Params.lpfnWhatNext(pTG, eventPOSTPAGE))
                {
                        case actionSENDMPS:     pTG->T30.ifrSend = ifrPPS_MPS; break;
                        case actionSENDEOM:     pTG->T30.ifrSend = ifrPPS_EOM; break;
                        case actionSENDEOP:     pTG->T30.ifrSend = ifrPPS_EOP; break;
#ifdef PRI
                        case actionSENDPRIMPS:  pTG->T30.ifrSend = ifrPPS_PRI_MPS; break;
                        case actionSENDPRIEOM:  pTG->T30.ifrSend = ifrPPS_PRI_EOM; break;
                        case actionSENDPRIEOP:  pTG->T30.ifrSend = ifrPPS_PRI_EOP; break;
#endif
                        case actionERROR:       return action;  // goto PhaseLoop & exit
                default:                        return BadAction(pTG, action);
                }
        }

        bPPSfif[0] = pTG->ECM.SendPageCount-1;
        bPPSfif[1] = pTG->ECM.SendBlockCount-1;
        BG_CHK(pTG->ECM.FramesSent && pTG->ECM.FramesSent<=256);
        // bPPSfif[2] = pTG->ECM.SendFrameCount-1;           // don't know which one..!!
        bPPSfif[2] = pTG->ECM.FramesSent-1;                  // this one! For sure

        for(uTryCount=0 ;;)
        {
                SendSingleFrame(pTG, pTG->T30.ifrSend, bPPSfif, 3, 1);

        echoretry:
                pTG->T30.ifrResp = GetResponse(pTG, ifrPPSresponse);
                // if we hear our own frame, try to recv again. DONT retransmit!
                if(pTG->T30.ifrResp==pTG->T30.ifrSend) { ECHOMSG(pTG->T30.ifrResp); goto echoretry; }

                if(pTG->T30.ifrResp != ifrNULL && pTG->T30.ifrResp != ifrBAD)
                        break;

                if(++uTryCount >= 3)
                {
                        ERRMSG((SZMOD "<<ERROR>> ECM 3 PostPages, No reply\r\n"));
                        ICommFailureCode(pTG, T30FAILSE_3POSTPAGE_NOREPLY);
                        return actionDCN;
                }
        }

        switch(pTG->T30.ifrResp)
        {
          case ifrBAD:
          case ifrNULL: BG_CHK(FALSE);  // should never get here
                                        ICommFailureCode(pTG, T30FAILSE_BUG2);
                                        return actionERROR;     // in case they do :-)

          case ifrDCN:  ERRMSG((SZMOD "<<ERROR>> Got ifrDCN from GetResponse after sending post-page command\r\n"));
                                        ICommFailureCode(pTG, T30FAILSE_POSTPAGE_DCN);
                                        return actionHANGUP;
          case ifrPPR:  faxTlog((SZMOD "PPR (P=%d B=%d F=%d) Received: ", pTG->ECM.SendPageCount-1, pTG->ECM.SendBlockCount-1, pTG->ECM.FramesSent-1));
                                        lpPPR = ProtGetRetransmitMask(pTG);
#ifdef DEBUG
                                        for(i=0; i<32; i++)
                                                faxTlog((" %02x", lpPPR[i]));
                                        faxTlog(("]\r\n"));
#endif //DEBUG


                                        if(++pTG->ECM.uPPRCount >= 4)
                                                goto FourthPPR;
                                        return actionGONODE_ECMRETRANSMIT;

          case ifrRNR:  if((pTG->T30.ifrResp=RNR_RRLoop(pTG)) == ifrDCN)
                                        {
                                                ERRMSG((SZMOD "<<ERROR>> RR_RNR loop failed\r\n"));
                                                // ICommFailureCode already called in RR_RNRLoop()
                                                return actionDCN;
                                        }
                                        faxTlog((SZMOD "Got %d from RNR\r\n", pTG->T30.ifrResp));
                                        break;
        }

        switch(pTG->T30.ifrResp)
        {
          case ifrPIP:
          case ifrPIN:
#                                       ifdef PRI
                                                        return GONODE_E;
#                                       else
                                                        ERRMSG((SZMOD "<<WARNING>> Procedure interrupts not supported\r\n"));
                                                        // return actionERROR;
                                                        // fallthru and treat like MCF
                                                        pTG->T30.ifrResp = ifrMCF;
#                                       endif

          case ifrMCF:
                                        {
                                                WORD wSize = (WORD) (pTG->ECM.dwPageSize>>10); //Units are KB
                                                ICommStatus(pTG, T30STATS_CONFIRM_ECM,
                                                        (USHORT) LOBYTE(wSize),
                                                        (USHORT) HIBYTE(wSize),
                                                        (USHORT)(pTG->ECM.SendPageCount&0xff));
                                                ERRMSG((SZMOD "Sending T30STATS_CONFIRM_pTG->ECM. wSize=%u\r\n",
                                                                        (unsigned) wSize));

                                        }
          action=pTG->Params.lpfnWhatNext(pTG, eventGOT_ECM_PPS_RESP,
                                                                (UWORD)pTG->T30.ifrResp, (LPVOID)((DWORD)pTG->T30.ifrSend));
                                        if(pTG->T30.ifrSend==ifrPPS_EOP && pTG->T30.ifrResp==ifrMCF && action==actionDCN)
                                        {
                                                ICommFailureCode(pTG, T30FAILSE_SUCCESS);
                                                return actionDCN_SUCCESS;
                                        }
                                        else
                                                return action;

          default:              ERRMSG((SZMOD "<<ERROR>> Got UNKNOWN from GetResponse after sending post-page command\r\n"));
                                        ICommFailureCode(pTG, T30FAILSE_POSTPAGE_UNKNOWN);
                                        return actionDCN;
        }

FourthPPR:
        action = pTG->Params.lpfnWhatNext(pTG, event4THPPR, (WORD)pTG->ECM.SendFrameCount, (DWORD)pTG->ECM.FramesSent);
        switch(action)
        {
          case actionGONODE_ECMRETRANSMIT:
                        if(CTC_RespRecvd(pTG, ProtGetSendMod(pTG)) == ifrCTR)
                        {
                                pTG->ECM.uPPRCount = 0;
                                pTG->ECM.fSentCTC = TRUE;
                                return actionGONODE_ECMRETRANSMIT;
                        }
                        else
                        {
                                ERRMSG((SZMOD "<<ERROR>> CTC-CTR failed\r\n"));
                                // ICommFailureCode already called in CTC_RespRecvd(pTG)
                                return actionDCN;
                        }

          case actionSENDEOR_EOP:
          case actionDCN:
          case actionERROR:
                        return action;
          default:
                        return BadAction(pTG, action);
                        // none of the EOR stuff
                        // return actionDCN;
        }
}











ET30ACTION      ECMSendEOR_EOP(PThrdGlbl pTG)
{
        // dont set new ICommFailure codes in this function. We have already
        // set the 'too many retries' code

        USHORT          uTryCount;

        for(uTryCount=0 ;;)
        {
                RETAILMSG((SZMOD "<<WARNING>> Sending EOR-EOP\r\n"));

                pTG->T30.ifrSend = ifrEOR_EOP;
                SendEOR_EOP(pTG);

        echoretry:
                pTG->T30.ifrResp = GetResponse(pTG, ifrEORresponse);
                // if we hear our own frame, try to recv again. DONT retransmit!
                if(pTG->T30.ifrResp==pTG->T30.ifrSend) { ECHOMSG(pTG->T30.ifrResp); goto echoretry; }

                if(pTG->T30.ifrResp != ifrNULL && pTG->T30.ifrResp != ifrBAD)
                        break;

                if(++uTryCount >= 3)
                {
                        ERRMSG((SZMOD "<<ERROR>> ECM 3 EORs, No reply\r\n"));
                        return actionDCN;
                }
        }

        switch(pTG->T30.ifrResp)
        {
          case ifrBAD:
          case ifrNULL: BG_CHK(FALSE);  // should never get here
                                        return actionERROR;     // in case they do :-)

          case ifrDCN:  ERRMSG((SZMOD "<<ERROR>> Got ifrDCN from GetResponse after sending EOR\r\n"));
                                        return actionHANGUP;

          case ifrRNR:  RETAILMSG((SZMOD "<<WARNING>> Sent EOR-EOP, got RNR\r\n"));
                                        if((pTG->T30.ifrResp=RNR_RRLoop(pTG)) == ifrDCN)
                                        {
                                                ERRMSG((SZMOD "<<ERROR>> RR_RNR loop failed\r\n"));
                                                // ICommFailureCode already called in RR_RNRLoop(pTG)
                                                return actionDCN;
                                        }
                                        faxTlog((SZMOD "Got %d from RNR\r\n", pTG->T30.ifrResp));
                                        break;
        }

        switch(pTG->T30.ifrResp)
        {
          case ifrERR:  RETAILMSG((SZMOD "<<WARNING>> Sent EOR-EOP. Got ERR. Sending DCN\r\n"));
                                        return actionDCN;
          default:              ERRMSG((SZMOD "<<ERROR>> Got UNKNOWN from GetResponse after sending EOR\r\n"));
                                        return actionDCN;
        }
}



// reduce this so that when externally measured it always ends up less
// then the specified max of 65s, so we pass protocol conformance tests
#define T5_TIMEOUT              62000L                  // 60s + 5s












IFR RNR_RRLoop(PThrdGlbl pTG)
{
        /** Flowchart is:- Enter this on getting an RNR. Then start T5,
                send RR, get response (standard ResponseRecvd routine). If
                no response, send RR again. Repeat 3 times. If RNR response
                recvd, send RR again & repeat, until T5 expires, upon which
                send DCN & hangup.

                This routine returns ifrDCN, implying teh caller should
                go to NodeC, or ifrXXX, which is used as the response to be
                analysed further down the chart. Never returns ifrNULL
        **/

        UWORD   i;
        IFR     ifr;

        TstartTimeOut(pTG, &(pTG->ECM.toT5), T5_TIMEOUT);
        do
        {
                for(i=0; i<3; i++)
                {
                        if(!TcheckTimeOut(pTG, &(pTG->ECM.toT5)))
                        {
                                ERRMSG((SZMOD "<<ERROR>> T5 timeout on Sender\r\n"));
                                ICommFailureCode(pTG, T30FAILSE_RR_T5);
                                return ifrDCN;                                  // T5 timed out
                        }

                        SendRR(pTG);

                echoretry:
                        ifr = GetResponse(pTG, ifrRRresponse);
                        // if we hear our own frame, try to recv again. DONT retransmit!
                        if(ifr==ifrRR) { ECHOMSG(ifr); goto echoretry; }

                        if(ifr!=ifrNULL && ifr!=ifrBAD)
                                break;
                        // on ifrNULL (T4 timeout) we resend RR & try again -- 3 times
                }
        }
        while(ifr == ifrRNR);

        // BG_CHK(ifr!=ifrRNR && ifr!=ifrNULL && ifr!=ifrBAD && ifr!=ifrTIMEOUT);
        // can get BAD or NULL here when i=3
        BG_CHK(ifr!=ifrRNR && ifr!=ifrTIMEOUT);

        if(ifr == ifrDCN)
        {
                ERRMSG((SZMOD "<<ERROR>> Got DCN in response to RR\r\n"));
                ICommFailureCode(pTG, T30FAILSE_RR_DCN);
        }

        if(ifr==ifrBAD || ifr==ifrNULL)
        {
                BG_CHK(i==3);
                ERRMSG((SZMOD "<<ERROR>> No response to RR 3 times\r\n"));
                ICommFailureCode(pTG, T30FAILSE_RR_3xT4);
                ifr=ifrDCN;     // same as T5 timeout
        }
        return ifr;             // finally got a non-RNR response
                                        // return ifrDCN or ifrXXXX (not RNR)
}










IFR CTC_RespRecvd(PThrdGlbl pTG, USHORT uBaud)
{
        UWORD   i;
        IFR     ifr = ifrDCN;
        BYTE    bCTCfif[2];

        BG_CHK((uBaud & (~0x0F)) == 0);
        bCTCfif[0] = 0;
        bCTCfif[1] = (uBaud << 2);

        for(i=0; i<3; i++)
        {
                SendCTC (pTG, bCTCfif);

        echoretry:
                ifr = GetResponse(pTG, ifrCTCresponse);
                // if we hear our own frame, try to recv again. DONT retransmit!
                if(ifr==ifrCTC) { ECHOMSG(ifr); goto echoretry; }


                if(ifr!=ifrNULL && ifr!=ifrBAD)
                        break;
                // on ifrNULL (T4 timeout) we resend RR & try again -- 3 times
        }

        if(ifr==ifrNULL || ifr==ifrBAD)
        {
                BG_CHK(i == 3);
                ERRMSG((SZMOD "<<ERROR>> No response to CTC 3 times\r\n"));
                ICommFailureCode(pTG, T30FAILSE_CTC_3xT4);
                ifr = ifrDCN;
        }
        else if(ifr != ifrCTR)
        {
                ERRMSG((SZMOD "<<ERROR>> Bad response CTC\r\n"));
                ICommFailureCode(pTG, T30FAILSE_CTC_UNKNOWN);
        }
        return ifr;             // return ifrDCN or ifrXXXX
}






ET30ACTION      ECMRecvPhaseD ( PThrdGlbl pTG)
{
        DWORD           CurrPPS;
        ET30ACTION      action;

        switch(pTG->T30.ifrCommand)
        {
        case ifrPRI_MPS:
        case ifrPRI_EOM:
        case ifrPRI_EOP:
#                       ifdef PRI
                                return actionGONODE_RECVPRIQ;
#                       else
                                pTG->T30.ifrCommand = pTG->T30.ifrCommand-ifrPRI_MPS+ifrMPS;
                                break;
#                       endif

        case ifrPPS_PRI_MPS:
        case ifrPPS_PRI_EOM:
        case ifrPPS_PRI_EOP:
#                       ifdef PRI
                                goto RecvPPSPRIQ;
#                       else
                                pTG->T30.ifrCommand = pTG->T30.ifrCommand-ifrPPS_PRI_MPS+ifrPPS_MPS;
                                break;
#                       endif

        case ifrEOR_PRI_MPS:
        case ifrEOR_PRI_EOM:
        case ifrEOR_PRI_EOP:
#                       ifdef PRI
                                goto RecvEORPRIQ;
#                       else
                                pTG->T30.ifrCommand = pTG->T30.ifrCommand-ifrEOR_PRI_MPS+ifrEOR_MPS;
                                break;
#                       endif
        }


UsePrevCommand:

        switch(pTG->T30.ifrCommand)
        {
        case ifrCTC:
                                        EnterPageCrit(); //start CTR--PAGE critsection
                                        pTG->ECM.fRecvdCTC = TRUE;
                                        SendCTR(pTG);
                                        ECHOPROTECT(ifrCTR, modeECMRETX);
                                        return actionGONODE_RECVECMRETRANSMIT;
        case ifrPPS_NULL:
        case ifrPPS_MPS:
        case ifrPPS_EOM:
        case ifrPPS_EOP:
                // saved for PPS--RNR--RR--MCF(missed)--RR--MCF sequences
                pTG->ECM.ifrPrevCommand = pTG->T30.ifrCommand;

                //////BugFix 396//////
                CurrPPS = ProtGetPPS(pTG);
                if(pTG->ECM.ifrPrevResponse==ifrMCF && _fmemcmp(pTG->ECM.bPrevPPS, (LPBYTE)(&CurrPPS), 4)==0)
                        goto GoSendMCF;
                _fmemcpy(pTG->ECM.bPrevPPS, (LPBYTE)(&CurrPPS), 4);
                pTG->ECM.ifrPrevResponse = 0;
                //////BugFix 396//////

                switch(ECMRecvOK(pTG))
                {
                default:
                case ECMRECVOK_ABORT:   return actionERROR;
                case ECMRECVOK_OK:              break;
                case ECMRECVOK_BADFR:
                        EnterPageCrit(); //start PPR--PAGE critsection
                        SendPPR(pTG, pTG->ECM.bRecvBadFrameMask);
                        ECHOPROTECT(ifrPPR, modeECMRETX);
                        return actionGONODE_RECVECMRETRANSMIT;
                }

                // now we can mark eop here
                // #ifdef PRI is on, this won't work (e.g. if the guy sends
                // PRI_MPS at end of page, then this needs to be called but it won't.

                if(pTG->T30.ifrCommand != ifrPPS_NULL
                   && !pTG->ECM.fRecvEndOfPage)              // so we won't call this twice
                {
                        // RECV_ENDDOC if PPS_EOP or PPS_EOM
                        PutRecvBuf(pTG, NULL, ((pTG->T30.ifrCommand==ifrPPS_MPS) ? RECV_ENDPAGE : RECV_ENDDOC));
                        // ignore error/abort. We'll catch it soon enough
                        pTG->ECM.fRecvEndOfPage = TRUE;
                }

                if(!Recv_NotReadyLoop(pTG, ifrPPS_FIRST, ifrPPS_LAST))
                {
                        ICommFailureCode(pTG, T30FAILRE_PPS_RNR_LOOP);
                        return actionHANGUP;
                }

                if(pTG->T30.ifrCommand == ifrPPS_NULL)
                {
                        action = actionSENDMCF;
                }
                else switch(action = pTG->Params.lpfnWhatNext(pTG, eventRECVPOSTPAGECMD,(WORD)pTG->T30.ifrCommand))
                {
                  case actionSENDMCF: break;
                  case actionSENDRTN:
                  case actionHANGUP:
                  case actionERROR:
                  default:                        return BadAction(pTG, action);
                }

#ifdef PRI
                if(pTG->T30.ifrCommand != ifrPPS_NULL)
                {
                        if((action = pTG->Params.lpfnWhatNext(pTG, eventQUERYLOCALINT))==actionTRUE)
                        {
                                ECHOPROTECT(ifrPIP, 0);
                                SendPIP(pTG);
                                break;
                        }
                        else if(action == actionERROR)
                                return action;
                }
#endif //PRI

GoSendMCF:
                pTG->ECM.ifrPrevResponse = ifrMCF;
                if(pTG->T30.ifrCommand == ifrPPS_NULL || pTG->T30.ifrCommand == ifrPPS_MPS)
                {
                        EnterPageCrit(); //start ECM MCF--PAGE critsection
                        ECHOPROTECT(ifrMCF, modeECM);
                        SendMCF(pTG);
                        return actionGONODE_RECVPHASEC;
                }
                ECHOPROTECT(ifrMCF, 0);
                SendMCF(pTG);
                if(pTG->T30.ifrCommand==ifrPPS_EOP)
                        return actionNODEF_SUCCESS;
                else
                        break;

        case ifrEOR_NULL:
        case ifrEOR_MPS:
        case ifrEOR_EOM:
        case ifrEOR_EOP:
                // saved for EOR--RNR--RR--ERR(missed)--RR--ERR sequences
                pTG->ECM.ifrPrevCommand = pTG->T30.ifrCommand;

                if(pTG->T30.ifrCommand!=ifrEOR_NULL
                   && !pTG->ECM.fRecvEndOfPage)              // so we won't call this twice
                {
                        // RECV_ENDDOC if EOR_EOP or EOR_EOM
                        PutRecvBuf(pTG, NULL, ((pTG->T30.ifrCommand==ifrEOR_MPS) ? RECV_ENDPAGE : RECV_ENDDOC));
                        // ignore error/abort. We'll catch it soon enough
                        pTG->ECM.fRecvEndOfPage = TRUE;
                }


                if(!Recv_NotReadyLoop(pTG, ifrEOR_FIRST, ifrEOR_LAST))
                {
                        ICommFailureCode(pTG, T30FAILRE_EOR_RNR_LOOP);
                        return actionHANGUP;
                }

#ifdef PRI
                if(pTG->T30.ifrCommand != ifrPPS_NULL)
                {
                        if((action = pTG->Params.lpfnWhatNext(pTG, eventQUERYLOCALINT))==actionTRUE)
                        {
                                ECHOPROTECT(ifrPIN, 0);
                                SendPIN(pTG);
                                break;
                        }
                        else if(action == actionERROR)
                                return action;
                }
#endif //PRI
                if(pTG->T30.ifrCommand == ifrEOR_NULL || pTG->T30.ifrCommand == ifrEOR_MPS)
                {
                        EnterPageCrit(); //start ERR--PAGE critsection
                        ECHOPROTECT(ifrERR, modeECM);
                        SendERR(pTG);
                        return actionGONODE_RECVPHASEC;
                }
                ECHOPROTECT(ifrERR, 0);
                SendERR(pTG);
                break;

        case ifrRR:
                if(pTG->ECM.ifrPrevCommand)
                {
                        pTG->T30.ifrCommand = pTG->ECM.ifrPrevCommand;
                        goto UsePrevCommand;
                }
                else
                {
                        ERRMSG((SZMOD "<<WARNING>> ignoring ERR at weird time\r\n"));
                        break;
                }

        default:
                ERRMSG((SZMOD "<<WARNING>> Random Command frame received=%d\r\n", pTG->T30.ifrCommand));
                break;  // ignore it
        }
        return actionGONODE_F;

#ifdef PRI
RecvPRIPPS:
        switch(ECMRecvOK(pTG))
        {
        default:
        ECMRECVOK_ABORT:        return actionERROR;
        ECMRECVOK_OK:           break;
        ECMRECVOK_BADFR:
                EnterPageCrit(); //start PRI PPR--PAGE critsection
                ECHOPROTECT(ifrPPR, modeECMRETX);
                SendPPR(pTG, pTG->ECM.bRecvBadFrameMask);
                return actionGONODE_RECVECMRETRANSMIT;
        }
RecvPRIEOR:
        switch(action = pTG->Params.lpfnWhatNext(pTG, eventGOTPRIQ, (WORD)pTG->T30.ifrCommand))
        {
          case actionERROR:             break;  // return to PhaseLoop
          case actionHANGUP:    break;
          case actionGONODE_F:  break;
          case actionSENDPIP:   pTG->T30.ifrSend=ifrPIP; return actionGOVOICE;
          case actionSENDPIN:   pTG->T30.ifrSend=ifrPIN; return actionGOVOICE;
          case actionGO_RECVPOSTPAGE:
                        if(pTG->T30.ifrCommand >= ifrPPS_PRI_FIRST && pTG->T30.ifrCommand <= ifrPPS_PRI_LAST)
                        {
                                pTG->T30.ifrCommand = pTG->T30.ifrCommand-ifrPPS_PRI_MPS+ifrPPS_MPS;
                                goto NodeVIIIa;
                        }
                        else if(pTG->T30.ifrCommand >= ifrEOR_PRI_FIRST && pTG->T30.ifrCommand <= ifrEOR_PRI_LAST)
                        {
                                pTG->T30.ifrCommand = pTG->T30.ifrCommand-ifrEOR_PRI_MPS+ifrEOR_MPS;
                                goto NodeIXa;
                        }
                        else
                        {
                                BG_CHK(FALSE);
                        }
        }
        return action;
#endif //PRI
}






BOOL Recv_NotReadyLoop(PThrdGlbl pTG, IFR ifrFirst, IFR ifrLast)
{
        IFR ifrCommand;

        // OBSOLETE:- (??)
        // this is wrong. We should exit only on DCN I think.
        // We should definitely loop again on BAD
        // dunno about TIMEOUT and NULL

        do
        {
                if(ICommRecvBufIsEmpty(pTG))
                        return TRUE;

                // sleep for a while, to give FMTRES etc some CPU cycles to catch
                // up with us. Can sleep just before sending response, since sender
                // waits upto 3 (6?) secs for it.
#ifndef FILET30
                IFProcSleep(1000);
#endif

                SendRNR(pTG);

        echoretry:
                ifrCommand = GetCommand(pTG, ifrRNRcommand);
                // if we hear our own frame, try to recv again. DONT retransmit!
                if(ifrCommand==ifrRNR) { ECHOMSG(ifrCommand); goto echoretry; }
        }
        while(  ifrCommand==ifrNULL || ifrCommand==ifrBAD ||
                        ifrCommand == ifrRR     ||
                        (ifrCommand >= ifrFirst && ifrCommand <= ifrLast) );

        // This means we exit on any valid frame _except_ RR and the PPS-X
        // or EOR-X we were expecting. We also exit on ifrTIMEOUT which is
        // when the GetCommand() times out without getting any CONNECT.
        // Otherwise we'd end up sending an MCF after timing out which
        // Ricoh's protocol tester doesnt like. (Ricoh's bug numbbers B3-0106)

        return FALSE;   // just hangs up after this
}








ECMRECVOK ECMRecvOK(PThrdGlbl pTG)
{
        USHORT N, i;

        N = ProtGetRecvECMFrameCount(pTG);
        // N==actual number of frames, i.e. PPR value+1

        faxTlog((SZMOD "ECMRecvChk %d frames\r\n", N));
        if(!N || N>256)
        {
                BG_CHK(FALSE);
                return ECMRECVOK_ABORT;
        }

        for(i=0; i<N; i++)
        {
                if(pTG->ECM.bRecvBadFrameMask[i/8] & (1 << (i%8)))
                {
                        faxTlog((SZMOD "ECMRecvChk--bad fr=%d\r\n", i));
                        return ECMRECVOK_BADFR;
                }
        }
        return ECMRECVOK_OK;
}








ET30ACTION      ECMRecvPhaseC(PThrdGlbl pTG, BOOL fRetrans)
{
        /******** Receiver ECM Phase C. Fig A-7/T.30 (sheet 1) ********/

        ULONG           lTotalLen=0;
        USHORT          uRet, uFrameNum, uRCPCount, uSize;
        USHORT          uRecvFrame, uMod;
        LPBUFFER        lpbf;
        LPBUFFER        lpbfShort;

        // There is a race between sending the CFR and sending out an
        // +FRM=xx command, so we want to do it ASAP.

        pTG->ECM.uFrameSize = ProtGetRecvECMFrameSize(pTG);
        BG_CHK(pTG->ECM.uFrameSize==6 || pTG->ECM.uFrameSize==8);
        uSize = (1 << pTG->ECM.uFrameSize);

        uMod = ProtGetRecvMod(pTG);
        if(uMod >= V17_START && !pTG->ECM.fRecvdCTC) uMod |= ST_FLAG;

        pTG->T30.sRecvBufSize = MY_ECMBUF_SIZE;

        if((uRet = ModemECMRecvMode(pTG, pTG->Params.hModem, uMod, PHASEC_TIMEOUT)) != RECV_OK)
        {
                ExitPageCrit();
                ERRMSG((SZMOD "<<WARNING>> ECMPhC: RecvMode ret=%d\r\n", uRet));

                if(!fRetrans)
                {
                        // in case we miss the page entirely
                        // and jump into PhaseD directly

                        // init bad frame bitmask to all-bad
                        memset(pTG->ECM.bRecvBadFrameMask, 0xFF, 32);        // all bad
                        // init the status vars for the PPS/EOR--(RR-RNR)*--PPR/MCF loop
                        pTG->ECM.ifrPrevCommand = 0;
                        // reset the FrameInThisBlock count. Reset only on
                        // non-retransmit. Set when first PPS is recvd
                        ProtResetRecvECMFrameCount(pTG);

                        if(pTG->ECM.fRecvEndOfPage)  // as opposed to end-of-block
                                uRet = (USHORT)PutRecvBuf(pTG, NULL, RECV_STARTPAGE);
                        else
                                uRet = (USHORT)PutRecvBuf(pTG, NULL, RECV_STARTBLOCK);

                        pTG->ECM.fRecvEndOfPage = FALSE;
                        if(!uRet)
                        {
                                ERRMSG((SZMOD "<<ERROR>> Got Error from PutRecvBuf at StartPage/Block\r\n"));
                                return actionERROR;
                        }
                        pTG->EchoProtect.modePrevRecv = modeECM;
                }
                else
                        pTG->EchoProtect.modePrevRecv = modeECMRETX;

                // set global flag if we got WRONGMODE
                pTG->EchoProtect.fGotWrongMode = (uRet==RECV_WRONGMODE);

                // elim flush--does no good & wastes 10ms
                // ModemFlush(pTG->Params.hModem);
                return actionGONODE_F;
                // try to get 300bps command instead
        }
        ExitPageCrit();

        // as soon as we get good carrier ZERO the pTG->EchoProtect state
        _fmemset(&pTG->EchoProtect, 0, sizeof(pTG->EchoProtect));

        // reset this flag AFTER we successfully recv LONG_TRAIN. We may get an
        // echo of our last command, go to NodeF, reject the echo and loop back
        // here. In that case we want to retry LONG train, otherwise we always
        // croak after a CTC
        pTG->ECM.fRecvdCTC = FALSE;

#ifdef IFAX
        BroadcastMessage(pTG, IF_PSIFAX_DATAMODE, (PSIFAX_RECV|PSIFAX_ECM|(fRetrans ? PSIFAX_RERECV : 0)), (uMod & (~ST_FLAG)));
#endif
        faxTlog((SZMOD "RECEIVING ECM Page.......\r\n"));
        if(fRetrans)
                ICommStatus(pTG, T30STATR_RERECV_ECM, 0, 0, 0);

        // Turn yielding on *after* entering receive mode safely!
        FComCriticalNeg(pTG, FALSE);

/***
        switch(action = pTG->Params.lpfnWhatNext(eventSTARTRECV))
        {
          case actionCONTINUE:  break;
          case actionDCN:               ERRMSG((SZMOD "<<ERROR>> Got actionDCN from eventSTARTRECV\r\n"));
                                                        return actionDCN;               // goto NodeC;
          case actionHANGUP:    ERRMSG((SZMOD "<<ERROR>> Got actionHANGUP from eventSTARTRECV\r\n"));
                                                        return action;  // goto NodeB;
          case actionERROR:             return action;
          default:                              return BadAction(action);
        }
***/

        if(!fRetrans)
        {
                memset(pTG->ECM.bRecvBadFrameMask, 0xFF, 32);
                ProtResetRecvECMFrameCount(pTG);

                if(pTG->ECM.fRecvEndOfPage)  // as opposed to end-of-block
                        uRet = (USHORT)PutRecvBuf(pTG, NULL, RECV_STARTPAGE);
                else
                        uRet = (USHORT)PutRecvBuf(pTG, NULL, RECV_STARTBLOCK);
                if(!uRet)
                {
                        ERRMSG((SZMOD "<<ERROR>> Got Error from PutRecvBuf at StartPage/Block\r\n"));
                        return actionERROR;
                }
        }
        pTG->ECM.ifrPrevCommand = 0;
        pTG->ECM.fRecvEndOfPage = FALSE;
        pTG->ECM.ifrPrevResponse = 0;


        DEBUGSTMT(if(fRetrans) D_PSIFAXCheckMask(pTG, pTG->ECM.bRecvBadFrameMask));


// make it large, in case of large buffers & slow modems
#define READ_TIMEOUT    25000

        lpbfShort=0;
        for(uFrameNum=0, lpbf=0, lTotalLen=0, uRCPCount=0, uRet=RECV_OK; uRet!=RECV_EOF;)
        {
                if(lpbf)
                {
                        faxTlog((SZMOD "<<WARNING>> ECM RecvPhC: Freeing leftover Buf 0x%08lx inside loop\r\n", lpbf));
                        MyFreeBuf(pTG,  lpbf);        // need to free after bad frames etc
                }

                lpbf = 0;
                uRet=ModemRecvBuf(pTG, pTG->Params.hModem, TRUE, &lpbf, READ_TIMEOUT);

                if(uRet == RECV_BADFRAME)
                {
                        ERRMSG((SZMOD "<<WARNING>> ModemRecvBuf returns BADFRAME\r\n"));
                        continue;
                }
                else if(uRet == RECV_EOF)
                {
                        BG_CHK(lpbf == 0);
                        if(lpbfShort)
                        {
                                lpbf = lpbfShort;
                                lpbfShort = 0;

                                if(fRetrans && ((USHORT)(lpbf->lpbBegData[3])+1 < ProtGetRecvECMFrameCount(pTG)))
                                {
                                        RETAILMSG((SZMOD "<<WARNING>> DISCARDING Short but not-really-terminal FCD frame(N=%d). len=%d. PADDING to %d!!\r\n",  lpbf->lpbBegData[3], lpbf->wLengthData, uSize+4));
                                        IFBufFree(lpbf);
                                        break;
                                }
                                else
                                {
                                        RETAILMSG((SZMOD "<<WARNING>> Short Terminal FCD frame(N=%d). len=%d. PADDING to %d!!\r\n",  lpbf->lpbBegData[3], lpbf->wLengthData, uSize+4));
                                        BG_CHK(lpbf->wLengthBuf >= uSize+4);
                                        _fmemset(lpbf->lpbBegData+lpbf->wLengthData, 0, (uSize+4-lpbf->wLengthData));
                                        lpbf->wLengthData = uSize+4;
                                        goto skipchks;
                                }
                        }
                        else
                                break;
                }
                else if(uRet != RECV_OK)
                {
                        ERRMSG((SZMOD "<<WARNING>> Got %d from RecvBuf in ECMREcvPhaseC\r\n", uRet));
                        break;
                }
                else if(lpbf==0)
                {
                        // sometimes we get RECV_OK with no data. Treat same as bad frame
                        continue;
                }

                BG_CHK(uRet==RECV_OK && lpbf && lpbf->lpbBegData);

                if(uRCPCount >= 3)
                {
                        ERRMSG((SZMOD "<<WARNING>> Got a good frame after %d RCP\r\n", uRCPCount));
                        continue;
                }

                if( lpbf->lpbBegData[0] != 0xFF ||
                        lpbf->lpbBegData[1] != 0x03 ||
                        (lpbf->lpbBegData[2] & 0x7F) != 0x06)
                {
                        ERRMSG((SZMOD "<<ERROR>> Bad frame (N=%d) not caught FCF=%02x!!\r\n", uFrameNum, lpbf->lpbBegData[2]));
                        BG_CHK(FALSE);
                        continue;
                }

                if(lpbf->lpbBegData[2] == 0x86)
                {
                        // got RCP
                        if(lpbf->wLengthData != 3)
                        {
                                ERRMSG((SZMOD "<<ERROR>> Bad RCP frame len=%d\r\n", lpbf->wLengthData));
                                BG_CHK(FALSE);
                                continue;
                        }
                        uRCPCount++;
                        faxTlog((SZMOD "Got %d RCP\r\n", uRCPCount));
#ifdef CL0
                        if(uRCPCount >= 3)
                        {
                                // tell modem that recv is done
                                // but keep calling RecvMem until we get RECV_EOF
                                ModemEndRecv(pTG, pTG->Params.hModem);
                        }
#endif //CL0
                        continue;
                }

                if(lpbfShort)
                {
                        ERRMSG((SZMOD "<<ERROR>> Short FCD frame(N=%d). len=%d DISCARDING\r\n", lpbfShort->lpbBegData[3], lpbfShort->wLengthData));
                        MyFreeBuf(pTG, lpbfShort);
                        lpbfShort = NULL;
                }
                if(lpbf->wLengthData > (uSize+4))
                {
                        ERRMSG((SZMOD "<<ERROR>> FCD frame too long(N=%d %d). len=%d. DISCARDING\r\n", uFrameNum, lpbf->lpbBegData[3], lpbf->wLengthData));
                        continue;
                }
                else if(lpbf->wLengthData < (uSize+4))
                {
                        RETAILMSG((SZMOD "<<WARNING>> Short FCD frame(N=%d %d). len=%d. Storing\r\n", uFrameNum, lpbf->lpbBegData[3], lpbf->wLengthData));
                        BG_CHK(lpbfShort==0);
                        lpbfShort = lpbf;
                        lpbf = NULL;
                        continue;
                }

skipchks:
                BG_CHK(lpbf->lpbBegData[2] == 0x06);
                BG_CHK(lpbf->wLengthData == (uSize+4));

                uRecvFrame = lpbf->lpbBegData[3];
                lpbf->lpbBegData += 4;
                lpbf->wLengthData -= 4;

                if(!fRetrans)
                {
                        if(uFrameNum > uRecvFrame)
                        {
                                ERRMSG((SZMOD "<<ERROR>> Out of order frame. Got %d Looking for %d\r\n", uRecvFrame, uFrameNum));
                                BG_CHK(FALSE);
                                // ignore this frame in non-debug mode
                                continue;
                        }
                        else if(uFrameNum < uRecvFrame)
                        {
                                if(!FillInFrames(pTG, (USHORT)(uRecvFrame-uFrameNum), pTG->T30.sRecvBufSize, uSize))
                                {
                                        ERRMSG((SZMOD "<<ERROR>> Zero return from PutRecvBuf in FillInFrames\r\n"));
                                        return actionERROR;
                                }
                        }
                        lTotalLen += lpbf->wLengthData;
                }
                uFrameNum = uRecvFrame;

                if(!fRetrans || (pTG->ECM.bRecvBadFrameMask[uFrameNum/8] & (1 << (uFrameNum%8))))
                {
                        BG_CHK(uFrameNum < 256 && pTG->ECM.uFrameSize <=8); // shift below wont ovf 16 bits
                        if(!PutRecvBuf(pTG, lpbf, (fRetrans ? ((SLONG)(uFrameNum << pTG->ECM.uFrameSize)) : RECV_SEQ)))
                        {
                                ERRMSG((SZMOD "<<ERROR>> Zero return from PutRecvBuf in page\r\n"));
                                return actionERROR;
                        }
                        pTG->ECM.bRecvBadFrameMask[uFrameNum/8] &= ~(1 << (uFrameNum%8));
                        uFrameNum++;
                        lpbf = 0;
                }
        }


        if(lpbf)
        {
                ERRMSG((SZMOD "<<ERROR>> ECMRecvPhC: Freeing leftover Buf 0x%08lx outside loop\r\n", lpbf));
                MyFreeBuf(pTG, lpbf);        // need to free after bad frames etc
        }

        if(uRet == RECV_EOF)
        {
                FComCriticalNeg(pTG, TRUE);
                // cant mark end of page until we know if end of page or block etc.
                // PutRecvBuf(NULL, RECV_ENDPAGE);              // to mark end of Page
        }
        else
        {
                ERRMSG((SZMOD "<<ERROR>> DataRead Timeout or Error=%d\r\n", uRet));
                BG_CHK(FALSE);
                ICommFailureCode(pTG, T30FAILRE_MODEMRECV_PHASEC);
                return actionERROR;     // goto error;
        }

        faxTlog((SZMOD "ECM Page Recv Done.....len=(%ld, 0x%08x)\r\n", lTotalLen, lTotalLen));
        ECHOPROTECT(0, 0);
        return actionGONODE_F;  // goto NodeF;                  // get post-message command
}









BOOL FillInFrames(PThrdGlbl pTG, USHORT N, LONG sBufSize, USHORT uDataSize)
{
        USHORT i;
        LPBUFFER        lpbf;

        for(i=0; i<N; i++)
        {
#ifdef IFK
                TstartTimeOut(pTG, &pTG->T30.toBuf, WAITFORBUF_TIMEOUT);
                while(!(lpbf = MyAllocBuf(pTG, sBufSize)))
                {
                        if(!TcheckTimeOut(pTG, &pTG->T30.toBuf))
                        {
                                ERRMSG((SZMOD "<<ERROR>> Giving up on BufAlloc in T30-ECM after %ld millisecs\r\n", ((ULONG)WAITFORBUF_TIMEOUT)));
                                BG_CHK(FALSE);
                                return FALSE;
                        }
                        RETAILMSG((SZMOD "<<ERROR>> BufAlloc failed in T30-pTG->ECM. Trying again\r\n"));
                        IFProcSleep(100);
                }
#else
                if(!(lpbf = MyAllocBuf( pTG, sBufSize)))
                        return FALSE;
#endif

                lpbf->wLengthData = uDataSize;

                if(!PutRecvBuf(pTG, lpbf, RECV_SEQBAD))
                {
                        ERRMSG((SZMOD "<<ERROR>> Zero return from PutRecvBuf in page\r\n"));
                        return FALSE;
                }
        }
        return TRUE;
}






#ifdef SWECM

USHORT ModemECMRecvMode(PThrdGlbl pTG, HMODEM h, USHORT uMod, ULONG ulTimeout)
{
        if(!SWECMRecvSetup(pTG, TRUE))
        {
                BG_CHK(FALSE);
                return RECV_ERROR;
        }
        return ModemRecvMode(pTG, h, uMod, FALSE, ulTimeout, ifrPIX_SWECM);
}

#endif //SWECM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\main\awnsf.c ===
/***************************************************************************
        Name      :     BCNSF.C
        Comment   :     Routines for encoding/encrypting and decoding/decrypting
                                NSF/NSC/NSS frames

         Copyright (c) 1993 Microsoft Corp.
         This source code is absolutely confidential, and cannot be viewed
         by anyone outside Microsoft (even under NDA) without specific
         written permission.

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
***************************************************************************/

#ifdef PUREDATA
#include <memory.h>
#include <string.h>
#define PORTABLE
#define EXTERNAL
#define NOGETTICK
#endif

#ifndef PORTABLE
#       include "defs.h"
#       include <ifaxos.h>
#       include "tipes.h"
#       define MODID                    MODID_AWNSF
#       define FILEID                   1
#else
#ifdef DEBUG
#       include <assert.h>
#       include <string.h>
#endif
#       define  _export
#       define  FALSE                           0
#       define  TRUE                            1
#       define  min(a,b)            (((a) < (b)) ? (a) : (b))
#       ifdef DEBUG
#               define  DEBUGMSG(cond,exp)  ((cond)?((printf exp),1):0)
#               define  BG_CHK(x)                       (fflush(stdout), assert(x))
#       else
#               define  DEBUGMSG(cond,exp)
#               define  BG_CHK(x)
#       endif
#       define _fmemset         memset
#       define _fmemcpy         memcpy
#       define _fstrlen         strlen
#       define _fmemcmp         memcmp
#       define ERRMSG(m)        DEBUGMSG(1, m)
#endif



#include "prep.h"





#include "nsfmacro.h"

///RSL
#include "glbproto.h"

#ifdef NOCHALL
#define bChallResp                      bPass
#define wChallRespLen           wPassLen
#endif

/***********************************************************************
 *                                                                     *
 * NOTICE: This file has to be ANSI compilable, under GCC on UNIX      *
 * and other ANSI compiles. Be sure to use no MS C specific features   *
 * In particular, don't use // for comments!!!!                        *
 *                                                                     *
 ***********************************************************************/

/* #define DEBUG2 */
/* #define DEBUG3 */




#define SZMOD                   "AwNsf: "
#define TRACE(m)        DEBUGMSG(1, m)


#ifdef DEBUG
#       define DEBUGSTMT(x)             x
#else
#       define DEBUGSTMT(x)     (0)
#endif

#ifdef DEBUG2
#       define faxTlog(m)       DEBUGMSG(1, m)
#else
#       define faxTlog(m)
#endif

#ifdef DEBUG3
#       define faxT3log(m)      DEBUGMSG(1, m)
#else
#       define faxT3log(m)
#endif


typedef char FAR*               LPSTR;
typedef unsigned long   ULONG;



#ifdef DEBUG
        void    D_PrintBytes(LPSTR lpstr, LPBYTE lpb, USHORT cb, BOOL f);
        void    DiffIt(PThrdGlbl pTG, LPBYTE lpb1, LPBYTE lpb2, USHORT cb);
#else
#       define  D_PrintBytes(lpstr, lpb, cb, f)
#       define  DiffIt(lpb1, lpb2, cb)
#endif


LPBYTE Permute(PThrdGlbl pTG, LPBYTE lpbIn, USHORT cb, BOOL fReverse);
USHORT ParseNSx(PThrdGlbl pTG, LPBYTE lpb, USHORT uLen, LPBC lpbcOut, USHORT uMaxSize);







BOOL EXPORTAWBC IsAtWorkNSx( LPBYTE lpb, WORD wSize)
{
BG_CHK((GRPSIZE_STD==sizeof(BCSTD)) &&
           (GRPSIZE_FAX==sizeof(BCFAX)) &&
           (GRPSIZE_NSS==sizeof(BCNSS)) &&
           (GRPSIZE_IMAGE==sizeof(BCIMAGE))    &&
           (GRPSIZE_POLLCAPS==sizeof(BCPOLLCAPS)));

        /* this should be tautological */
#ifdef DEBUG
#ifdef PORTABLE
                BG_CHK(BC_SIZE == (sizeof(BCwithHUGE)-BCEXTRA_HUGE-4));
                faxT3log(("BC_SIZE=%d  actual=%d\r\n", BC_SIZE, (sizeof(BCwithHUGE)-BCEXTRA_HUGE-4)));
#else
                BG_CHK(BC_SIZE == sizeof(BC));
                faxT3log(("BC_SIZE=%d sizeof(BC)=%d\r\n", BC_SIZE, sizeof(BC)));
#endif /* PORTABLE */
#endif /* DEBUG */

        if( (wSize > 3) && (wSize < MAXNSFFRAMESIZE) &&
                (lpb[0]==SIG_USA) &&
                (lpb[1]==SIG_ATWORK1) &&
                (lpb[2]==SIG_ATWORK2) )
        {
                return TRUE;
        }
        else
        {
                (MyDebugPrint(0,  LOG_ALL,  "Non-Microsoft At Work NSx l=%d (%02x %02x %02x)\r\n",
                                wSize, lpb[0], lpb[1], lpb[2]));
                return FALSE;
        }
}







 WORD EXPORTBC NSxtoBC(PThrdGlbl pTG, IFR ifr, LPLPFR rglpfr, WORD wNumFrame,
                                                                        LPBC lpbcOut, WORD wBCSize)
 {
        BYTE    bSalt[3];
        BOOL    fGotSalt;
        WORD    wRet = AWERROR_NOTAWFRAME;
        USHORT  iFrame;
   BOOL       fStripFCS = TRUE;

        BG_CHK(ifr==ifrNSF || ifr==ifrNSS || ifr==ifrNSC);

tryagain:

   fGotSalt = FALSE;

        /* zero out BC, but _not_ header parts */
        _fmemset(&(lpbcOut->Std),
                 0,
                 BC_SIZE - (ULONG)(((LPBYTE)(&(lpbcOut->Std))) - ((LPBYTE)lpbcOut)));
        lpbcOut->wTotalSize = BC_SIZE;
        fGotSalt = FALSE;

        for(iFrame=0; iFrame<wNumFrame; iFrame++)
        {
                LPBYTE  lpbIn;
                USHORT  uLen;
                LPBYTE  lpbTemp;

      lpbIn = rglpfr[iFrame]->fif;
      if (fStripFCS)
      {
         if (rglpfr[iFrame]->cb >= 5 ) {
                      uLen  = rglpfr[iFrame]->cb - 2;     /* Subtract 2 to lop off the FCS */
         }
         else
         {                                                         /* Must not have the FCS */
            fStripFCS = FALSE;
            (MyDebugPrint(pTG,  LOG_ALL,  "<<<WRN>>> NSx frame too short, trying again without stripping FCS\r\n"));
            goto tryagain;
         }
      }
      else
         uLen  = rglpfr[iFrame]->cb;

                if(!IsAtWorkNSx(lpbIn, uLen))
                {
                        (MyDebugPrint(pTG,  LOG_ERR,  "<<WARNING>> skipping non-MAW-NSx frame (%d)\r\n", iFrame));
                        DEBUGSTMT(D_PrintBytes("SkippedFrame", lpbIn, uLen, 0));
                        goto skipframe;
                }
                else
                {
                        USHORT  uRet1;

                        DEBUGSTMT(D_PrintBytes("BytesRecvd", lpbIn, uLen, 0));
                        BG_CHK(uLen > 3);
                        uLen -= 3;
                        lpbIn += 3;

                        /** unswap salt/data bytes around (except the NSF signature) **/
                        lpbTemp = Permute(pTG, lpbIn, uLen, TRUE);

                        DEBUGSTMT(D_PrintBytes("AfterPermute", lpbTemp, uLen, 0));

                        if(!fGotSalt)
                        {
                                BG_CHK(wRet == AWERROR_NOTAWFRAME);     /* not yet parsed a frame */
                                /* Snowball can't handle NSF frames longer than 38 bytes */
                                BG_CHK((ifr==ifrNSF) ? (uLen <= (MAXFIRSTNSFSIZE-3)) : TRUE);

                                if(uLen < 3)
                                {
                                        (MyDebugPrint(pTG,  LOG_ERR, "SZMOD <<WARNING>> skipping too-short MAW frame (%d) len=%d\r\n", iFrame, uLen));
                                        goto skipframe;
                                }
                                _fmemcpy(bSalt, lpbTemp, 3);
                                lpbTemp += 3;
                                uLen -= 3;
                                fGotSalt = TRUE;
                        }


                        DEBUGSTMT(D_PrintBytes("AfterDecrypt", lpbTemp, uLen, 0));

                        if((uRet1=ParseNSx(pTG, lpbTemp, uLen, lpbcOut, wBCSize))==0xFFFF)
                        {
/* Some modems don't send the FCS, so if we fail, try again without lopping off the FCS */
            if ((fStripFCS) && (iFrame==0)) {
               fStripFCS = FALSE;
               (MyDebugPrint(pTG,  LOG_ALL,  "<<<WRN>>> Failed to parse NSx frame, trying again without stripping FCS\r\n"));
               goto tryagain;
            }
            else {
                                   (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Failed to parse NSx frame (%d)\r\n", iFrame));
                                   goto skipframe;
            }
                        }
                        else
                        {
                                wRet = AWERROR_OK;
                                (MyDebugPrint(pTG,  LOG_ALL,  "Parsed NSx frame (%d) skipped %d\r\n", iFrame, uRet1));
                        }
                }
 skipframe:
                ;
        }
        return wRet;
  }








USHORT CopyGroupFromFrame(PThrdGlbl pTG, LPBYTE lpbHdrIn, USHORT cbOut, LPBYTE lpbOut)
{
        USHORT uCopyLen;

        uCopyLen = min(GroupLength(lpbHdrIn), cbOut);
        _fmemset(lpbOut, 0, cbOut);
        _fmemcpy(lpbOut, lpbHdrIn, uCopyLen);
        SetGroupLength(lpbHdrIn, uCopyLen);
        return uCopyLen;
}





USHORT CopyIdGroupFromFrame(PThrdGlbl pTG, LPBYTE lpbHdrIn, LPBYTE lpbOut, USHORT cbMaxOut)
{
        USHORT uCopyLen;

        uCopyLen = min(GroupLength(lpbHdrIn)-2, cbMaxOut-1);
        _fmemcpy(lpbOut, lpbHdrIn+2, uCopyLen); /** copy id only! **/
        lpbOut[uCopyLen++] = 0;
        return uCopyLen;
}


        /** returns 0xFFFF on failure and 0 or +ve number == total number
                of bytes skipped in "not understood" or "no-space" groups. **/





USHORT ParseNSx(PThrdGlbl pTG, LPBYTE lpb, USHORT uLen, LPBC lpbcOut, USHORT uMaxSize)
{
        USHORT  uGroupLength;
        USHORT  uRet, uLenOriginal;

        BG_CHK(uMaxSize >= BC_SIZE);

        /*** Don't zero BC here! This can be called multiple times to decode
                 multiple NSx frames into a single BC structure! **/

        uRet = 0;
        uLenOriginal = uLen;

        // RSL
        return (uRet);


        while(uLen)
        {
                uGroupLength = GroupLength(lpb);
                if(uGroupLength < 2 || uGroupLength > uLen)
                {
                        /** If we hit a garbage group-len, we can't continue **/

                        (MyDebugPrint(pTG, LOG_ERR,  "<<ERROR>> Bad NSF format GroupLen=%d wLen=%d\r\n", uGroupLength, uLen));
                        return 0xFFFF;
                }

                switch(GroupNum(lpb))
                {
                case GROUPNUM_STD:
                         CopyGroupFromFrame(pTG, lpb, GRPSIZE_STD, (LPBYTE)(&(lpbcOut->Std)));
                         break;
                case GROUPNUM_TEXTID:
                         if(lpbcOut->wTotalSize < uMaxSize)
                         {
                                lpbcOut->wszTextId = lpbcOut->wTotalSize;
                                lpbcOut->wTextEncoding = TextEncoding( (LPBC)lpb);
                                lpbcOut->wTextIdLen = CopyIdGroupFromFrame(pTG, lpb, (((LPBYTE)lpbcOut) + lpbcOut->wTotalSize), (USHORT)(uMaxSize - lpbcOut->wTotalSize));
                                lpbcOut->wTotalSize += lpbcOut->wTextIdLen;
                                lpbcOut->wTextIdLen--;  /** trailing 0 not included in length **/
                                BG_CHK(lpbcOut->wTotalSize <= uMaxSize);
                         }
                         else
                         {
                                (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> No space for Text Id wSize=%d wMax=%d\r\n", lpbcOut->wTotalSize, uMaxSize));
                                uRet += uGroupLength;
                         }
                         break;
                case GROUPNUM_MACHINEID:
                         if(lpbcOut->wTotalSize < uMaxSize)
                         {
                                lpbcOut->wrgbMachineId = lpbcOut->wTotalSize;
                                lpbcOut->wMachineIdLen = CopyIdGroupFromFrame(pTG, lpb, (((LPBYTE)lpbcOut) + lpbcOut->wTotalSize), (USHORT)(uMaxSize - lpbcOut->wTotalSize));
                                lpbcOut->wTotalSize += lpbcOut->wMachineIdLen;
                                lpbcOut->wMachineIdLen--;  /** trailing 0 not included in length **/
                                BG_CHK(lpbcOut->wTotalSize <= uMaxSize);
                         }
                         else
                         {
                                (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> No space for Machine Id wSize=%d wMax=%d\r\n", lpbcOut->wTotalSize, uMaxSize));
                                uRet += uGroupLength;
                         }
                         break;
                case GROUPNUM_IMAGE:
                         CopyGroupFromFrame(pTG, lpb, GRPSIZE_IMAGE, (LPBYTE)(&(lpbcOut->Image)));
                         break;
                case GROUPNUM_POLLCAPS:
                         CopyGroupFromFrame(pTG, lpb, GRPSIZE_POLLCAPS, (LPBYTE)(&(lpbcOut->PollCaps)));
                         break;
                case GROUPNUM_POLLREQ:
                         if((lpbcOut->wNumPollReq > MAXNSCPOLLREQ) || (lpbcOut->wTotalSize >= uMaxSize))
                         {
                                (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> No space for PollReq wNum=%d wSize=%d wMax=%d\r\n", lpbcOut->wNumPollReq, lpbcOut->wTotalSize, uMaxSize));
                                uRet += uGroupLength;
                         }
                         else
                         {
                                USHORT uTemp;
                                lpbcOut->rgwPollReq[lpbcOut->wNumPollReq] = lpbcOut->wTotalSize;
                                uTemp = CopyGroupFromFrame(pTG, lpb, (USHORT)(uMaxSize-1-lpbcOut->wTotalSize), (((LPBYTE)lpbcOut) + lpbcOut->wTotalSize));
                                (((LPBYTE)lpbcOut) + lpbcOut->wTotalSize)[uTemp++] = 0;
                                lpbcOut->wTotalSize += uTemp;
                                lpbcOut->wNumPollReq++;
                         }
                         break;
                case GROUPNUM_NSS:
                         CopyGroupFromFrame(pTG, lpb, GRPSIZE_NSS, (LPBYTE)(&(lpbcOut->NSS)));
                         faxT3log((SZMOD "ParseNSS: Msg=0x%02x Inter=0x%02x\r\n",
                                        lpbcOut->NSS.vMsgProtocol, lpbcOut->NSS.vInteractive));
                         break;
                default:
                         (MyDebugPrint(pTG, LOG_ALL,  "<<WARNING>> Got unknown %d member (size=%d) in NSF -- ignoring\r\n",
                                                        GroupNum(lpb), uGroupLength));
                         uRet += uGroupLength;
                         break;
                }

                (MyDebugPrint(pTG, LOG_ALL,  "Decoded grp=%d len=%d\r\n", GroupNum(lpb), uGroupLength));
                lpb += uGroupLength;
                uLen -= uGroupLength;
        }
        if(uRet == uLenOriginal)
        {
                (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Skipped over entire frame!\r\n"));
                uRet = 0xFFFF;
        }
        return uRet;
}







USHORT AddGroupToFrame(PThrdGlbl pTG, LPBYTE lpbIn, USHORT cbIn, LPBYTE lpbOut, USHORT cbOut)
{
        USHORT uGroupNum, uGroupLength, cbCopy;

        BG_CHK(cbIn>=2 && cbIn<64);
        BG_CHK(cbOut >= 2);

        uGroupNum = GroupNum(lpbIn);
        uGroupLength = GroupLength(lpbIn);

        faxT3log((SZMOD "cbIn=%d cbOut=%d grplen=%d\r\n", cbIn, cbOut, uGroupLength));

        if( uGroupNum >= GROUPNUM_FIRST &&
                uGroupNum <= GROUPNUM_LAST
                && uGroupLength && cbIn>=2 && cbIn<64 && cbOut>=2)
        {
                BG_CHK(uGroupLength <= cbIn);
                cbIn = min(uGroupLength, cbIn);

                if(uGroupNum != GROUPNUM_MACHINEID && uGroupNum != GROUPNUM_POLLREQ)
                {
                        /** find last non-zero byte **/
                        for( ;cbIn>2 && lpbIn[cbIn-1]==0; cbIn--)
                                ;
                        BG_CHK(cbIn==2 || lpbIn[cbIn-1]!=0);

                        if(cbIn==2 && (lpbIn[1] == (lpbIn[1] & 0x07)))
                        {
                                (MyDebugPrint(pTG,  LOG_ALL,  "Found Group (%d %d) only 11bits long. Not sending\r\n", lpbIn[0], lpbIn[1]));
                                return 0;
                        }
                }
                BG_CHK(cbIn>=2 && cbIn<=63);
                cbCopy = min(cbIn, cbOut);
                _fmemcpy(lpbOut, lpbIn, cbCopy);
                SetGroupLength(lpbOut, cbCopy);  /** set GroupLength correctly  **/
                (MyDebugPrint(pTG, LOG_ALL,  "Encoded grp=%d len=%d\r\n", GroupNum(lpbOut), GroupLength(lpbOut)));
                return cbCopy;
        }
        BG_CHK(uGroupNum == 0);
        BG_CHK(uGroupLength == 0);
        return 0;
}








USHORT AddIdGroupToFrame(PThrdGlbl pTG, USHORT uGroupNum, USHORT cbIn, USHORT uTextEncoding, LPBYTE lpbIn, LPBYTE lpbOut, USHORT cbOut)
{
        USHORT cbCopy;

        /** if(!cbIn) cbIn = _fstrlen((LPSTR)lpbIn); **/

        BG_CHK(cbIn>0);
        BG_CHK(cbIn<=MAXTOTALIDLEN);
        BG_CHK(cbOut >= 2);
        BG_CHK(uGroupNum==GROUPNUM_TEXTID || uGroupNum==GROUPNUM_MACHINEID);

        if( (uGroupNum==GROUPNUM_TEXTID || uGroupNum==GROUPNUM_MACHINEID) &&
                cbIn>0 && cbIn<=MAXTOTALIDLEN && cbOut>=2)
        {
                cbCopy = min(cbIn, cbOut-2);
                _fmemcpy(lpbOut+2, lpbIn, cbCopy);
                SetupTextIdHdr(lpbOut, cbCopy+2, uGroupNum, uTextEncoding);
                (MyDebugPrint(pTG, LOG_ALL,  "Encoded grp=%d len=%d\r\n", GroupNum(lpbOut), GroupLength(lpbOut)));
                return cbCopy+2;
        }
        return 0;
}










 WORD CreateNewFrame(PThrdGlbl pTG, IFR ifr, LPFR lpfr, WORD wMaxOut, BOOL fFirst)
 {
     BYTE bSendSalt[4];

        if(wMaxOut <= (sizeof(FRBASE)+3 + (fFirst ? 3 : 0)))
                return 0;

        lpfr->ifr = ifr;
        lpfr->fif[0] = SIG_USA;
        lpfr->fif[1] = SIG_ATWORK1;
        lpfr->fif[2] = SIG_ATWORK2;
        lpfr->cb = 3;

        if(fFirst)
        {
                DWORD   lTemp;
                lTemp = 1;                              /* get random salt */
                _fmemcpy(bSendSalt, (LPBYTE)(&lTemp), 3); /* don't care if we get low 3 or high 3 */
                _fmemcpy(lpfr->fif+lpfr->cb, bSendSalt, 3);       /* only low 3  bytes of salt sent **/
                lpfr->cb += 3;
        }
        return lpfr->cb;
 }








/** Make sure lpilpfr always points to _current_ lpfr entry **/

 BOOL AddToFrames(PThrdGlbl pTG, IFR ifr, LPLPFR rglpfr, LPWORD lpilpfr, LPBYTE lpbGrp, WORD grpsize, LPWORD lpwMaxOut, BOOL fID, WORD GrpNum, WORD TextEncoding)
 {
        LPFR lpfr;
        USHORT uTemp;

 redo:
        lpfr = rglpfr[*lpilpfr];
        BG_CHK(lpfr);

        if(*lpwMaxOut < grpsize) return FALSE;

        if(!fID)
                uTemp = AddGroupToFrame(pTG, lpbGrp, grpsize, lpfr->fif+lpfr->cb, *lpwMaxOut);
        else
                uTemp = AddIdGroupToFrame(pTG, GrpNum, grpsize, TextEncoding, lpbGrp, lpfr->fif+lpfr->cb, *lpwMaxOut);


        if((int)(lpfr->cb+uTemp) > (((*lpilpfr==0) && (ifr==ifrNSF)) ? MAXFIRSTNSFSIZE : MAXNEXTNSFSIZE))
        {
                WORD wTemp;

                if((*lpilpfr)+1 >= MAXNSFFRAMES)
                        return FALSE;
                lpfr = (LPFR) (((LPBYTE)(lpfr->fif))+lpfr->cb);
                if(!(wTemp = CreateNewFrame(pTG, ifr, lpfr, *lpwMaxOut, FALSE)))
                        return FALSE;
                BG_CHK(*lpwMaxOut >= wTemp);
                *lpwMaxOut -= wTemp;
                (*lpilpfr) += 1;
                rglpfr[*lpilpfr] = lpfr;                                                                                                \

                goto redo;
        }
        lpfr->cb += uTemp;
        *lpwMaxOut -= uTemp;
        return TRUE;
 }














 WORD EXPORTBC BCtoNSx(PThrdGlbl pTG, IFR ifr, LPBC lpbcIn,
                     LPBYTE lpbOut, WORD wMaxOut, LPWORD lpwNumFrame)
 {
        LPLPFR  rglpfr;
        USHORT  ilpfr, i;
        LPFR    lpfr;
        WORD    wTemp;
        LPBYTE  lpbTemp;

        BG_CHK(ifr==ifrNSF || ifr==ifrNSS || ifr==ifrNSC);
        BG_CHK(lpbcIn->wTotalSize >= BC_SIZE);
        BG_CHK(lpbcIn->bctype==SEND_CAPS || lpbcIn->bctype==SEND_PARAMS ||
                lpbcIn->bctype==SEND_POLLREQ || lpbcIn->bctype==RECV_CAPS);
        /* server-->client cap reporting passes in a RECV_CAPS */

        DEBUGSTMT(D_PrintBytes("SendBC", (LPBYTE)lpbcIn, lpbcIn->wTotalSize, 0));

        /* init return values */
        _fmemset(lpbOut, 0, wMaxOut);
        *lpwNumFrame = 0;

        /* set up array of LPFR pointers */
        if(wMaxOut <= (sizeof(LPFR) * MAXNSFFRAMES)) goto nospace;
        rglpfr = (LPLPFR)lpbOut;
        ilpfr = 0;
        lpbOut += (sizeof(LPFR) * MAXNSFFRAMES);
        wMaxOut -= (sizeof(LPFR) * MAXNSFFRAMES);

        lpfr = (LPFR)lpbOut;
        if(!(wTemp = CreateNewFrame(pTG, ifr, lpfr, wMaxOut, TRUE)))
                goto nospace;
        BG_CHK(wMaxOut >= wTemp);
        wMaxOut -= wTemp;
        rglpfr[ilpfr] = lpfr;

        if(!AddToFrames(pTG, ifr, rglpfr, &ilpfr, (LPBYTE)(&(lpbcIn->NSS)), GRPSIZE_NSS, &wMaxOut, 0,0,0))
                goto nospace;
        if(!AddToFrames(pTG, ifr, rglpfr, &ilpfr, (LPBYTE)(&(lpbcIn->Std)), GRPSIZE_STD, &wMaxOut, 0,0,0))
                goto nospace;
        if(!AddToFrames(pTG, ifr, rglpfr, &ilpfr, (LPBYTE)(&(lpbcIn->Image)), GRPSIZE_IMAGE, &wMaxOut, 0,0,0))
                goto nospace;
        if(!AddToFrames(pTG, ifr, rglpfr, &ilpfr, (LPBYTE)(&(lpbcIn->PollCaps)), GRPSIZE_POLLCAPS, &wMaxOut, 0,0,0))
                goto nospace;

#if !defined(EXTERNAL) || defined(TEST)
        if(lpbcIn->wszTextId)
        {
                BG_CHK(lpbcIn->wszTextId < lpbcIn->wTotalSize);
                BG_CHK(lpbcIn->wTextIdLen);
                if(!AddToFrames(pTG, ifr, rglpfr, &ilpfr, (((LPBYTE)lpbcIn) + lpbcIn->wszTextId),
                        lpbcIn->wTextIdLen, &wMaxOut, TRUE, GROUPNUM_TEXTID, lpbcIn->wTextEncoding))
                                goto nospace;
        }

        if(lpbcIn->wrgbMachineId)
        {
                BG_CHK(lpbcIn->wrgbMachineId < lpbcIn->wTotalSize);
                BG_CHK(lpbcIn->wMachineIdLen);
                if(!AddToFrames(pTG, ifr, rglpfr, &ilpfr, (((LPBYTE)lpbcIn) + lpbcIn->wrgbMachineId),
                        lpbcIn->wMachineIdLen, &wMaxOut, TRUE, GROUPNUM_MACHINEID, 0))
                                goto nospace;
        }

        for(i=0; i<lpbcIn->wNumPollReq; i++)
        {
                LPBYTE  lpGrp;
                USHORT  uGrpLen;

                lpGrp = (((LPBYTE)lpbcIn) + lpbcIn->rgwPollReq[i]);
                uGrpLen = GroupLength(lpGrp);
                if(!AddToFrames(pTG, ifr, rglpfr, &ilpfr, lpGrp, uGrpLen, &wMaxOut, 0,0,0))
                        goto nospace;
        }
#endif /* !EXTERNAL || TEST */


        /** done with last frame. Increment ilpfr **/
        ilpfr += 1;

        for(i=0; i<ilpfr; i++)
        {
                USHORT uMin;

                (MyDebugPrint(pTG,  LOG_ALL,  "Frame %d of %d. Len=%d\r\n", i, ilpfr, rglpfr[i]->cb));
                DEBUGSTMT(D_PrintBytes("BeforeEncrypt", rglpfr[i]->fif, rglpfr[i]->cb, 0));

                uMin = (i ? 3 : 6);     /* first frame must have sig + salt = 3+3 */

                if (0) /// RSL (rglpfr[i]->cb < uMin+2)
                {
                        /**  has to have at least 3 + (3) + 2 bytes **/
                        (MyDebugPrint(pTG,  LOG_ERR,  "<<WARNING>> Empty frame\r\n"));
                        /* zap return values so the bogus frame doesnt get used */
                        _fmemset(lpbOut, 0, wMaxOut);
                        *lpwNumFrame = 0;
                        return AWERROR_NULLFRAME;
                }


                DEBUGSTMT(D_PrintBytes("AfterEncrypt", rglpfr[i]->fif, rglpfr[i]->cb, 0));

                /** swap salt/data bytes around **/
                lpbTemp = Permute(pTG, rglpfr[i]->fif+3, (USHORT)(rglpfr[i]->cb-3), FALSE);
                _fmemcpy(rglpfr[i]->fif+3, lpbTemp, rglpfr[i]->cb-3);

                DEBUGSTMT(D_PrintBytes("AfterPermute", rglpfr[i]->fif, rglpfr[i]->cb, 0));
        }

        BG_CHK(wMaxOut >= 0);
        *lpwNumFrame = ilpfr;

        return 0;

 nospace:
        (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> no space\r\n"));
        /* zap return values so the bogus frame(s) dont get used */
        _fmemset(lpbOut, 0, wMaxOut);
        *lpwNumFrame = 0;
        return AWERROR_NOSPACE;
 }










LPBYTE Permute(PThrdGlbl pTG, LPBYTE lpbIn, USHORT cb, BOOL fReverse)
{
        USHORT v, n, i, choice;
        LPBYTE lpbOut=pTG->bOut;

        if(cb < 1 || cb > 255)
        {
                BG_CHK(FALSE);
                return 0;
        }
        v = lpbOut[0] = lpbIn[0];       /** anchor **/
        lpbOut++, lpbIn++;      /** anchor **/
        cb--;

        for(i=0; i<MAXNSFFRAMESIZE; pTG->bRem[i]=(BYTE)i, i++)
                ;

        /** bOut[1] = bOut[2] = bOut[3] = bOut[4] = bOut[5] =' '; **/

        for(i=0, n=cb; n; n--, i++)
        {
                choice = v % n;
                if(!fReverse)
                {
                        lpbOut[i] = lpbIn[pTG->bRem[choice]];
                        v = (v / n) ^ lpbOut[i];
                }
                else
                {
                        lpbOut[pTG->bRem[choice]] = lpbIn[i];
                        v = (v / n) ^ lpbIn[i];
                }
                pTG->bRem[choice] = pTG->bRem[n-1];
                /** printf("%c%c%c%c%c%c\n\r",bOut[0],bOut[1],bOut[2],bOut[3],bOut[4],bOut[5]); **/
        }
        return lpbOut-1;
}





#ifdef DEBUG
void D_PrintBytes(LPSTR lpstr, LPBYTE lpb, USHORT cb, BOOL fAlways)
{
        USHORT i;

#ifndef DEBUG2
        if(fAlways)
#endif /** DEBUG2 **/
        {
                (MyDebugPrint(0,  LOG_ALL,  "[%s]\r\n", (LPSTR)lpstr));
                for(i=0; i<cb; i++)
                {
                        TRACE(("%02x ", (USHORT)lpb[i]));
                        if(((i+1) % 20) == 0)
                                TRACE(("\r\n"));
                }
                TRACE(("\r\n"));
        }
}
#endif /** DEBUG **/





#ifdef DEBUG

void DiffIt(PThrdGlbl pTG, LPBYTE lpb1, LPBYTE lpb2, USHORT cb)
{
        int i;

        TRACE(("DiffIt:\r\n"));
        for(i=0; i<(int)cb; i++)
        {
                if(lpb1[i] != lpb2[i])
                {
                        TRACE(("(%d %02x %02x)\r\n", i, lpb1[i], lpb2[i]));
                }
        }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\main\errstat.c ===
/***************************************************************************
 Name     :     ERRSTAT.C
 Comment  :     Error logging and Status msgs

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/
#include "prep.h"

#include "glbproto.h"
#include "t30gl.h"


#define         faxTlog(m)              DEBUGMSG(ZONE_ERRSTAT, m);

#ifdef FAXWATCH
        char    szFailureLog[]          = "FAXWATCH.LOG";
        // sneaky look at BGT30's private data
#       ifndef TSK
                extern char szPhone[];
#       endif //TSK
#endif //FAXWATCH


// Currently in WIN32, logging (IFDbgPrintf) is provided by efaxrun.dll. This
// should later migrate to awkrnl32.dll.
struct {
        HFILE hfLog;
        BOOL  fInited;
        CRITICAL_SECTION crit;
} gLog = {HFILE_ERROR, FALSE};











void   ICommFailureCode(PThrdGlbl pTG, T30FAILURECODE uT30Fail)
{
        SetFailureCode(pTG, uT30Fail);

}




void SetFailureCode(PThrdGlbl pTG, T30FAILURECODE uT30Fail)
{
        if(!pTG->Inst.uFirstFailureCode)
                pTG->Inst.uFirstFailureCode = (USHORT)uT30Fail;
        else
                pTG->Inst.uLastFailureCode = (USHORT)uT30Fail;
}










void InitFailureCodes(PThrdGlbl pTG)
{
        pTG->Inst.uFirstFailureCode = pTG->Inst.uLastFailureCode = 0;
}





void   ICommStatus(PThrdGlbl pTG, T30STATUS uT30Stat, USHORT uN1, USHORT uN2, USHORT uN3)
{

//        SetStatus(uT30Stat, uN1, uN2, uN3);

}






void SetStatus(PThrdGlbl pTG, T30STATUS uT30Stat, USHORT uN1, USHORT uN2, USHORT uN3)
{
#if 0 ///RSL   was ifdef STATUS
        ULONG lParam;

        BG_CHK((uT30Stat & 0xFF) == uT30Stat);
        BG_CHK((uN1 & 0xFF) == uN1);
        // when N2==Kbytes recvd this goes over 256K sometimes & so rolls
        // around to 0 again.
        // BG_CHK((uN2 & 0xFF) == uN2);
        BG_CHK((uN3 & 0xFF) == uN3);

        lParam = MAKELONG(MAKEWORD(uT30Stat, uN1), MAKEWORD(uN2, uN3));
        if(Inst.fSending || Inst.fInPollReq)
        {
                BG_CHK(Inst.hwndSend && Inst.aPhone);
                PostMessage(Inst.hwndSend, IF_FILET30_STATUS, Inst.aPhone, lParam);
        }
        else if(Inst.hwndStatus)
        {
                PostMessage(Inst.hwndStatus, IF_FILET30_STATUS, 0, lParam);
        }
#endif //STATUS
}




/*
 * MyIFDbgPrintf -- printf to the debugger console
 * Takes printf style arguments.
 * Expects newline characters at the end of the string.
 */
void MyIFDbgPrintf (LPSTR format, ...)
{
    va_list       marker;
    char          String[512];
    char          c;
    UINT          i;
    UINT          u;
    DWORD         dwWritten;


    if ( (gT30.DbgLevel < LOG_ALL ) || (! gfFilePrint) ) {
        return;
    }

    u = 0;

    va_start(marker, format);
    u += wvsprintf(String+u, format, marker);

    //
    // scramble String
    //

    for (i=0; i<u; i++) {
        c = String[i];
        String[i] = ( (c << 4 ) & 0xf0 ) | ( (c >> 4) & 0x0f );
    }


    WriteFile(ghLogFile, String, u, &dwWritten, NULL);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\main\hdlc.c ===
/////// Global #defines that would've gone on the Cmd line //////
/////////////////////////////////////////////////////////////////

/***************************************************************************
        Name      :     HDLC.C
        Comment   :     Contains miscellenous HDLC framing T30 frame recognition and
                                generation routines. Mostly called from the main T30 skeleton
                                in T30.C

        Revision Log

        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
***************************************************************************/

#include "prep.h"

#include "t30.h"
#include "hdlc.h"
#include "debug.h"

///RSL
#include "glbproto.h"


#       define  faxTlog(m)              DEBUGMSG(ZONE_HD, m)
#       define  faxT2log(m)             DEBUGMSG(ZONE_BUFS, m)
#       define  FILEID                  FILEID_HDLC

// CBPFR is a code-based pointer to an FR structure, with the base as
// the current Code segment. It will only be used to access
// the table below which is a CODESEG based constant table.

#define         ifrMAX          48

// This table better match the #defines in et30API.H !!!!
// This is everything you never wanted to know about T30 frames....

FRAME TEXTBASED rgFrameInfo[ifrMAX] = {
#define         ifrNULL         0
                                                        {       0x00, 0, 0, 0,  "ifrNULL!!!" },
#define         ifrDIS          1
                                                        {       0x80, 0, 0, 0xFF,       "DIS"   },
#define         ifrCSI          2
                                                        {       0x40, 0, 0, 0xFF,       "CSI"   },
#define         ifrNSF          3
                                                        {       0x20, 0, 0, 0xFF,       "NSF"   },
#define         ifrDTC          4
                                                        {       0x81, 0, 0, 0xFF,       "DTC"   },
#define         ifrCIG          5
                                                        {       0x41, 0, 0, 0xFF,       "CIG"   },
#define         ifrNSC          6
                                                        {       0x21, 0, 0, 0xFF,       "NSC"   },
#define         ifrDCS          7
                                                        {       0x82, 0, 1, 0xFF,       "DCS"   },
#define         ifrTSI          8
                                                        {       0x42, 0, 1, 0xFF,       "TSI"   },
#define         ifrNSS          9
                                                        {       0x22, 0, 1, 0xFF,       "NSS"   },
#define         ifrCFR          10
                                                        {       0x84, 0, 1, 0,  "CFR"   },
#define         ifrFTT          11
                                                        {       0x44, 0, 1, 0,  "FTT"   },
#define         ifrMPS          12
                                                        {       0x4E, 0, 1, 0,  "MPS"   },
#define         ifrEOM          13
                                                        {       0x8E, 0, 1, 0,  "EOM"   },
#define         ifrEOP          14
                                                        {       0x2E, 0, 1, 0,  "EOP"   },
#define         ifrPWD          15
                                                        {       0xC1, 0, 0, 0xFF,       "PWD"   },
#define         ifrSEP          16
                                                        {       0xA1, 0, 0, 0xFF,       "SEP"   },
#define         ifrSUB          17
                                                        {       0xC2, 0, 1, 0xFF,       "SUB"   },
#define         ifrMCF          18
                                                        {       0x8C, 0, 1, 0,  "MCF"   },
#define         ifrRTP          19
                                                        {       0xCC, 0, 1, 0,  "RTP"   },
#define         ifrRTN          20
                                                        {       0x4C, 0, 1, 0,  "RTN"   },
#define         ifrPIP          21
                                                        {       0xAC, 0, 1, 0,  "PIP"   },
#define         ifrPIN          22
                                                        {       0x2C, 0, 1, 0,  "PIN"   },
#define         ifrDCN          23
                                                        {       0xFA, 0, 1, 0,  "DCN"   },
#define         ifrCRP          24
                                                        {       0x1A, 0, 1, 0,  "CRP"   },
#define         ifrPRI_MPS      25
                                                        {       0x5E, 0, 1, 0,  "PRI_MPS"       },
#define         ifrPRI_EOM      26
                                                        {       0x9E, 0, 1, 0,  "PRI_EOM"       },
#define         ifrPRI_EOP      27
                                                        {       0x3E, 0, 1, 0,  "PRI_EOP"       },

        /********* ECM stuff starts here. T.30 section A.4 ******/

#define         ifrCTC          28
                                                        {       0x12, 0, 1, 2,  "CTC"   },
#define         ifrCTR          29
                                                        {       0xC4, 0, 1, 0,  "CTR"   },
#define         ifrRR           30
                                                        {       0x6E, 0, 1, 0,  "RR"    },
#define         ifrPPR          31
                                                        {       0xBC, 0, 1, 32, "PPR"   },
#define         ifrRNR          32
                                                        {       0xEC, 0, 1, 0,  "RNR"   },
#define         ifrERR          33
                                                        {       0x1C, 0, 1, 0,  "ERR"   },
#define ifrPPS_NULL     34
                                                        {       0xBE, 0x00+1, 1, 3, "PPS-NULL" },
#define ifrPPS_MPS      35
                                                        {       0xBE, 0x4F+1, 1, 3, "PPS-MPS"   },
#define ifrPPS_EOM      36
                                                        {       0xBE, 0x8F+1, 1, 3, "PPS-EOM"   },
#define ifrPPS_EOP      37
                                                        {       0xBE, 0x2F+1, 1, 3, "PPS-EOP"   },
#define ifrPPS_PRI_MPS  38
                                                        {       0xBE, 0x5F+1, 1, 3, "PPS-PRI-MPS"       },
#define ifrPPS_PRI_EOM  39
                                                        {       0xBE, 0x9F+1, 1, 3, "PPS-PRI-EOM"       },
#define ifrPPS_PRI_EOP  40
                                                        {       0xBE, 0x3F+1, 1, 3, "PPS-PRI-EOP"       },
#define ifrEOR_NULL     41
                                                        {       0xCE, 0x00+1, 1, 0, "EOR-NULL" },
#define ifrEOR_MPS      42
                                                        {       0xCE, 0x4F+1, 1, 0, "EOR-MPS" },
#define ifrEOR_EOM      43
                                                        {       0xCE, 0x8F+1, 1, 0, "EOR-EOM" },
#define ifrEOR_EOP      44
                                                        {       0xCE, 0x2F+1, 1, 0, "EOR-EOP" },
#define ifrEOR_PRI_MPS  45
                                                        {       0xCE, 0x5F+1, 1, 0, "EOR-PRI-MPS" },
#define ifrEOR_PRI_EOM  46
                                                        {       0xCE, 0x9F+1, 1, 0, "EOR-PRI-EOM" },
#define ifrEOR_PRI_EOP  47
                                                        {       0xCE, 0x3F+1, 1, 0, "EOR-PRI-EOP" }
#define ifrMAX                  48
};

#define EOX_FIRST      ifrMPS
#define EOX_LAST       ifrEOP
#define PRI_EOX_FIRST  ifrPRI_MPS
#define PRI_EOX_LAST   ifrPRI_EOP
#define PPS_X_FIRST    ifrPPS_NULL
#define PPS_X_LAST     ifrPPS_PRI_EOP

#ifdef DLEHERE
#       define          DLE             0x10
#       define          ETX             0x03
#endif //DLEHERE







/* Converts a the T30 code for a speed to the Class1 code
 * Generates V.17 with Long Training.
 * Add 1 to V.17 codes to get teh Short-train version
 */


/***************************************************************************
        Name      :     CreateFrame()
        Purpose   :     Create an HDLC frame
        Parameters:     IFR     ifr             == ifr number (index into rgfrFrameInfo),
                                                                        of frame to be generated.
                                LPB             lpbFIF  == pointer to FIF BYTEs
                                UWORD   uwFIFLen== length of the pbFIF array
                                BOOL    fFinal  == whether Final frame (to set bit 5 of BYTE 2)
                                NPB             npbOut  == pointer to space for frame
        Returns   : TRUE on success, FALSE if bogus params.
        CalledFrom: By the protocol module (external to the DLL) in addition
                                to internal use.
        Returns   :     Composes frame in lpframe->rgb[]
                                sets lpframe->cb to total length of frame.

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------

***************************************************************************/

UWORD CreateFrame(PThrdGlbl pTG, IFR ifr, LPB lpbFIF, USHORT uFIFLen, BOOL fFinal, LPB lpbOut)
{
        CBPFRAME        cbpframe;       // need to worry about NEAR/FAR here...
                                                        // bpfr is a CODESEG based pointer
        LPB             lpbCurr;
        // UWORD           uw;

        BG_CHK(lpbOut && (uFIFLen>0 || !lpbFIF) && ifr>ifrNULL && ifr<ifrMAX);


        cbpframe                = &rgFrameInfo[ifr];
        lpbCurr         = lpbOut;
        *lpbCurr++      = 0xFF;                                                 // HDLC address field Sec 5.3.4
        *lpbCurr++      = (BYTE)(fFinal ? 0x13 : 0x03); // HDLC control field Sec 5.3.5

        if(pTG->T30.fReceivedDIS && cbpframe->fInsertDISBit)
                *lpbCurr++ = (BYTE)(cbpframe->bFCF1 | 0x01);
        else
                *lpbCurr++ = cbpframe->bFCF1;

        // we're not stuffing here, because we're sure FCF is never 0x10, but
        // use an assert() to make sure
#ifdef DLEHERE
        BG_CHK(*(lpbCurr-1) != DLE);
#endif //DLEHERE


        if(cbpframe->bFCF2)                                             // for ECM frames
                *lpbCurr++ = cbpframe->bFCF2-1;

#ifdef DLEHERE
        BG_CHK(*(lpbCurr-1) != DLE);
#endif //DLEHERE

        if(cbpframe->wFIFLength)        // check if FIF is reqd
        {
                BG_CHK(uFIFLen);

                // Cant stuff with DLEs here, because DLE stuffing has
                // to come *after* SW HDLC framing if any.
                // we _never_ do SW HDLC for negotiation frames (the only
                // ones that come thru here & we need the cycles, so do
                // teh stuffing here again).

                _fmemcpy(lpbCurr, lpbFIF, uFIFLen);
                lpbCurr += uFIFLen;

#ifdef DLEHERE
                for(uw=0; uw<uFIFLen; uw++)
                {
                        if((*lpbCurr++ = lpbFIF[uw]) == DLE)
                                *lpbCurr++ = DLE;                               // stuff DLE
                }
#endif //DLEHERE

        }
        else
        {
                BG_CHK(uFIFLen == 0);
        }

#ifdef DLEHERE
        *lpbCurr++ = DLE;
        *lpbCurr++ = ETX;
        // *lpbCurr++ = '\r';   // RC224ATF sends this along with the frame!
                                                        // now if anyone *needs* it, we're hosed
#endif //DLEHERE

        *lpbCurr = 0;                   // for debugging printouts

        return (UWORD)(lpbCurr-lpbOut);
}









/***************************************************************************
        Name      :     SendFrame
        Purpose   :     Creates & sends HDLC frame & does some logging
        Parameters:     IFR     ifr             == Frame index
                                LPB             lpbFIF  == pointer to FIF data
                                UWORD   uwLen   == length of FIF data
                                BOOL    fFinal  == Set Final bit ON or not. Also
                                                                        whether to wait for OK or CONNECT
                                                                        after sending frame
        Returns   :     TRUE on success, FALSE on failure
        Calls     :     CreateFrame & WriteFrame
        CalledFrom:

        Comment   :     This routine is called from one quadrillion macros
                                defined in HDLC.H, one for each frame.
                                e g. SendCFR() macros to SendHDLC(ifrCFR, NULL, 0, TRUE)

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
***************************************************************************/

#define SF_LASTFR               (SEND_ENDFRAME|SEND_FINAL)
#define SF_NOTLASTFR    (SEND_ENDFRAME)


BOOL SendSingleFrame(PThrdGlbl pTG, IFR ifr, LPB lpbFIF, USHORT uFIFLen, BOOL fSleep)
{
        UWORD   cb;
        BYTE    bSend[MAXFRAMESIZE];

        // has to hold addr+control+FCF+possibly FCF2+FIF+(maybe DLE+ETX+CR+NULL)
        // == FIFlen + 8. Therefore bSend[] better be big enough.
        BG_CHK(uFIFLen+8<sizeof(bSend));

        // on IFAX, we really do want to wait for silence, otherwise we could
        // end up colliding with the other guy & wasting our time. SO give it a
        // very long (3sec?) timeout.
        // Here we always call RecvSilence. The IFAX driver looks for silence
        // to avoid collisions. The Class1 modem driver just uses TwiddleThumbs()
        // not FRS or FTS because they are dangerous and slow.

        // On PCs we should pause before ALL frames _except_ CFR & FTT (because
        // those are too time critical). On IFAX we pause always.

#ifndef MDDI    // no pause before CFR/FTT
        if(ifr!=ifrCFR && ifr!=ifrFTT)
#endif
        {
#ifdef MDDI
                // when we are doing send-after-send, and we should use SendSilence
                // instead of RecvSilence. If we dont do this, we take too long &
                // Ricoh's protocol tester complains. This is Bugs 7071, 7100
                if( pTG->T30.fSendAfterSend &&
                        ((ifr>=EOX_FIRST && ifr<=EOX_LAST) ||
                         (ifr>=PRI_EOX_FIRST && ifr<=PRI_EOX_LAST) ||
                         (ifr>=PPS_X_FIRST && ifr<=PPS_X_LAST)) )
                {
                        (MyDebugPrint(pTG,  LOG_ALL,  "Send V21--Using SendSilence\r\n"));
                        ModemSendSilence(pTG, pTG->Params.hModem, SEND_LOWSPEED_PAUSE, LONG_RECVSILENCE_TIMEOUT);
                }
                else
#endif
                if (fSleep) {
                    if(!ModemRecvSilence(pTG, pTG->Params.hModem, RECV_LOWSPEED_PAUSE, LONG_RECVSILENCE_TIMEOUT))
                   {
                        ERRMSG((SZMOD "<<ERROR>> V21-Single RecvSilence(%d, %d) FAILED!!!\r\n", RECV_LOWSPEED_PAUSE, LONG_RECVSILENCE_TIMEOUT));
                    }
                }
        }
        pTG->T30.fSendAfterSend=FALSE;

        if(!ModemSendMode(pTG, pTG->Params.hModem, V21_300, TRUE, ifr))
        {
                ERRMSG((SZMOD "<<ERROR>> ModemSendMode failed in SendSingleFrame\r\n"));
                return FALSE;
        }

        cb = CreateFrame(pTG,  ifr, lpbFIF, uFIFLen, TRUE, bSend);
        BG_CHK(cb >= uFIFLen+3);
        // BG_CHK(cb >= uFIFLen+5);

        D_PrintFrame(bSend, cb);

        //Protocol Dump
        DumpFrame(pTG, TRUE, ifr, uFIFLen, lpbFIF);

        if(!ModemSendMem(pTG,  pTG->Params.hModem, bSend, cb, SF_LASTFR))
                return FALSE;

        return TRUE;
}






BOOL SendManyFrames(PThrdGlbl pTG, LPLPFR lplpfr, USHORT uNumFrames)
{
        USHORT i;
        UWORD   cb;
        BYTE    bSend[MAXFRAMESIZE];
        ULONG   ulTimeout;
        IFR             ifrHint;

        // ifrHint == last one
        ifrHint = lplpfr[uNumFrames-1]->ifr;

        // when sending DIS, DCS or DTC we may collide with DCS, DIS or DIS
        // coming from the other side. This can be really long
        // (preamble+2NSFs+CSI+DIS > 5secs) so wait for upto 10 secs!

        if(ifrHint==ifrDIS || ifrHint==ifrDCS || ifrHint==ifrDTC ||
           ifrHint==ifrNSS || ifrHint==ifrNSF || ifrHint==ifrNSC)
                ulTimeout = REALLY_LONG_RECVSILENCE_TIMEOUT;    // 10secs
        else
                ulTimeout = LONG_RECVSILENCE_TIMEOUT;                   // 3secs

        // on IFAX, we really do want to wait for silence, otherwise we could
        // end up colliding with the other guy & wasting our time. SO give it a
        // very long (3sec?) timeout.
        // Here we always call RecvSilence. The IFAX driver looks for silence
        // to avoid collisions. The Class1 modem driver just uses TwiddleThumbs()
        // not FRS or FTS because they are dangerous and slow.

        // We always pause before multi-frame sets
#ifdef MDDI
        // when we are doing send-after-send, and we should use SendSilence
        // instead of RecvSilence. If we dont do this, we take too long &
        // Ricoh's protocol tester complains. This is Bugs 7071, 7100
        if(pTG->T30.fSendAfterSend && (ifrHint==ifrDIS || ifrHint==ifrNSF))
        {
                (MyDebugPrint(pTG,  LOG_ALL,  "Send V21--Using SendSilence\r\n"));
                ModemSendSilence(pTG,  pTG->Params.hModem, SEND_LOWSPEED_PAUSE, LONG_RECVSILENCE_TIMEOUT);
        }
        else
#endif
        if(!ModemRecvSilence(pTG, pTG->Params.hModem, RECV_LOWSPEED_PAUSE, ulTimeout))
        {
                ERRMSG((SZMOD "<<ERROR>> V21-Multi RecvSilence(%d, %d) FAILED!!!\r\n", RECV_LOWSPEED_PAUSE, ulTimeout));
        }
        pTG->T30.fSendAfterSend=FALSE;

        if(!ModemSendMode(pTG, pTG->Params.hModem, V21_300, TRUE, ifrHint))
        {
                ERRMSG((SZMOD "<<ERROR>> ModemSendMode failed in SendManyFrames\r\n"));
                return FALSE;
        }

        for(i=0; i<uNumFrames; i++)
        {
                // has to hold addr+control+FCF+possibly FCF2+FIF+(maybe DLE+ETX+CR+NULL)
                // == FIFlen + 8. Therefore bSend[] better be big enough.
                BG_CHK(lplpfr[i]->cb+8<sizeof(bSend));

                cb = CreateFrame(pTG, lplpfr[i]->ifr, lplpfr[i]->fif, lplpfr[i]->cb, (USHORT)(i==(uNumFrames-1)), bSend);

                D_PrintFrame(bSend, cb);

                //Protocol Dump
                DumpFrame(pTG, TRUE, lplpfr[i]->ifr, lplpfr[i]->cb, lplpfr[i]->fif);

                if(!ModemSendMem(pTG, pTG->Params.hModem, bSend, (USHORT)cb,
                                (USHORT)((i==(USHORT)(uNumFrames-1)) ? SF_LASTFR : SF_NOTLASTFR)))
                        return FALSE;
        }
        return TRUE;
}





/***************************************************************************
        Name      :     SendTCF
        Purpose   :     Send a TCF signal. Waits until OK response from modem at end.
        Parameters:
        Returns   :     TRUE/FALSE

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------

***************************************************************************/

#define min(x,y)        (((x) < (y)) ? (x) : (y))





BOOL SendZeros(PThrdGlbl pTG, USHORT uCount, BOOL fFinal)
{
#define         TCF_BUFSIZE     256
        BYTE    bZero[TCF_BUFSIZE];
        int             i;              // must be signed

        _fmemset(bZero, 0, TCF_BUFSIZE);
        for(i=uCount; i>0; i -= TCF_BUFSIZE)
        {
                if(i <= TCF_BUFSIZE)
                {
                        // no need to stuff. They're all zeros!
                        if(!ModemSendMem(pTG, pTG->Params.hModem, bZero, (USHORT)i, (USHORT)(fFinal?SEND_FINAL:0)))
                           return FALSE;
                }
                else
                {
                        // no need to stuff. They're all zeros!
                        if(!ModemSendMem(pTG, pTG->Params.hModem, bZero, (USHORT)TCF_BUFSIZE, (USHORT) 0))
                           return FALSE;
                }
        }
        return TRUE;
}

// length of TCF = 1.5 * bpscode * 100 / 8 == 75 * bpscode / 4






BOOL SendTCF(PThrdGlbl pTG)
{
        USHORT  uCount;
        USHORT  uCurMod;

        (MyDebugPrint(pTG,  LOG_ALL,  "SENDING Training.....at %lx \r\n", GetTickCount() ));

        uCurMod = ProtGetSendMod(pTG);
        // *Don't* add ST_FLAG. Need long train for TCF
        BG_CHK((uCurMod & (~0x0F)) == 0);

#ifndef MDDI2
        // length of TCF = 1.5 * bps / 8
        uCount = TCFLen[uCurMod & 0x0F];        // kill the ST_FLAG first

        // FTT testing!!
        // uCount = 450;
#endif

#if (PAGE_PREAMBLE_DIV != 0)
        BG_CHK(PAGE_PREAMBLE_DIV);
        // (uCount / PAGE_PREAMBLE_DIV) zeros will be sent in ModemSendMode
        uCount -= (uCount / (PAGE_PREAMBLE_DIV));
#endif // (PAGE_PREAMBLE_DIV != 0)


#if 0 // RSL
        // **DON'T** call RecvSilence here since it is a send-followed-by-send
        // case. _Only_ call RecvSilence in recv-followed-by-send cases
        if(!ModemSendSilence(pTG, pTG->Params.hModem, SEND_PHASEC_PAUSE, SHORT_SENDSILENCE_TIMEOUT))
        {
                ERRMSG((SZMOD "<<ERROR>> TCF SendSilence(%d, %d) FAILED!!!\r\n", SEND_PHASEC_PAUSE, SHORT_SENDSILENCE_TIMEOUT));
        }
#endif


#ifdef MDDI2
        return ModemSendTCF(pTG, pTG->Params.hModem, uCurMod, 1500);
#else //MDDI2
        if(!ModemSendMode(pTG, pTG->Params.hModem, uCurMod, FALSE, ifrTCF))
        {
                ERRMSG((SZMOD "<<ERROR>> ModemSendMode failed in SendTCF\r\n"));
                return FALSE;
        }
        if(!SendZeros(pTG, uCount, TRUE))                    // Send TCF zeros
                return FALSE;
        (MyDebugPrint(pTG,  LOG_ALL,  "TCF Send Done.....\r\n"));
        return TRUE;
#endif //MDDI2
}






/***************************************************************************
        Name      :     SendRTC
        Purpose   :     SendRTC sends 6 eols, DLE-ETX, CR-LF asynchronously,
        Parameters:     none
        Returns   :     nothing
        Comment   :     Currently SendRTC sends packed EOLs, but some Fax cards may
                                require BYTE-aligned EOLs, so watch out. All receivers
                                should theoretically accept BYTE-aligned EOLs, but not
                                all machines are 100% to the spec.

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------

***************************************************************************/

BOOL SendRTC(PThrdGlbl pTG, BOOL fFinal)
{
        BYTE    bBuf[13];
        USHORT  uEnc, uLen;

        uEnc = ProtGetSendEncoding(pTG);
        BG_CHK(uEnc==MR_DATA || uEnc==MH_DATA);

        if(uEnc == MR_DATA)
        {

            (MyDebugPrint(pTG,  LOG_ALL,  "Send MR RTC\n"));

                // MR RTC is EOL+1 6 times. Data produced by Faxcodec end in a
                // byte-aligned EOL i.e. 0x80. So I need to put out (1 + EOL)
                // 6 times. Simplest is to send out (0x01 0x80) 6 times
                // bBuf[0] = 0x01;      bBuf[1] = 0x80; bBuf[2] = 0x01; bBuf[3] = 0x80;
                // bBuf[4] = 0x01;      bBuf[5] = 0x80; bBuf[6] = 0x01; bBuf[7] = 0x80;
                // bBuf[8] = 0x01;      bBuf[9] = 0x80; bBuf[10]= 0x01; bBuf[11]= 0x80;
                // bBuf[12] = 0;        // for debugging printouts
                // uLen = 12;
                // But Ricoh claims this is incorrect, so we need to send a compact
                // RTC, i.e. exactly 11 0s for each EOL. 1 + (eol+1)x5 is
                // 01 30 00 06 C0 00 18 00 03
                bBuf[0] = 0x01; bBuf[1] = 0x30; bBuf[2] = 0x00; bBuf[3] = 0x06;
                bBuf[4] = 0xC0; bBuf[5] = 0x00; bBuf[6] = 0x18; bBuf[7] = 0x00;
                bBuf[8] = 0x03; bBuf[9] = 0x00;
                uLen = 9;
        }
        else
        {

            (MyDebugPrint(pTG,  LOG_ALL,  "Send MH RTC\n"));

                // bBuf[0] = 0x00;      bBuf[1] = 0x20; bBuf[2] = 0x00;
                // bBuf[3] = 0x02;      bBuf[4] = 0x20; bBuf[5] = 0x00;
                // bBuf[6] = 0x02;      bBuf[7] = 0x20; bBuf[8] = 0x00;
                // bBuf[9] = 0x02;      bBuf[10] = 0;   // for debugging printouts
                // uLen = 10;
                // But Ricoh claims this is incorrect, so we need to send a compact
                // RTC, i.e. exactly 11 0s for each EOL. (eol)x5 is
                // 00 08 80 00 08 80 00 08
                bBuf[0] = 0x00; bBuf[1] = 0x08; bBuf[2] = 0x80; bBuf[3] = 0x00;
                bBuf[4] = 0x08; bBuf[5] = 0x80; bBuf[6] = 0x00; bBuf[7] = 0x08;
                bBuf[8] = 0x00;
                uLen = 8;
        }

        // no need to stuff
        return ModemSendMem(pTG, pTG->Params.hModem, bBuf, uLen, (USHORT)(fFinal ? SEND_FINAL : 0));
}




/***************************************************************************
        Name      :     GetTCF()
        Purpose   :     Receive a TCF signal, analyse it, recognize "good" or "bad"
        Parameters:     none

        Returns   :     1 if a "good" signal is received.
                                0 on error
                                -1 if too short TCF signal
                                -2 if too many errors

        Comment   :     The CCITT does not tell us what consitutes a good training,
                                so I'm playing blind here. If we are too stringent we'll fail
                                to ever sync. If we are too liberal, we'll end up with a high
                                error rate when we could have dropped baud rate & got a
                                perfectly good signal.

                                Emperically I observe bits of contigous trash at the
                                beginning and end of the training even on a perfectly good
                                line. (OK, I now know this is known as the turn-on and
                                turn-off sequence. So what we have now is
                                <turnon trash><1111s><0000s (training)><1111s><turnoff trash>

                                The turnon/turnoff trash & the marks (1111s) should not
                                interfere with recognizing a perfectly good training signal.
                                The trash is isolated from the 00s by FFs

                                Algo: Wait for the first good burst of zeros, then count
                                zeros, and randomly interspersed non-zero (these represent
                                real noise errors).     Stop counting when we get a burst of FFs.
                                Now make sure teh zero burst is long enough & the "real"
                                error rate is not too high.

                                Lots of parameters here:-

                                        flP_ERROR == keep Prob(error) below this. Between 0 and 1
                                        uwZEROmin == how many zeros before we start counting
                                        uwTURNOFFmin == how much consecutive trash before we
                                                                        ignore rest

                                Tune these parameters after real testing with real lines!!!
                                (maybe a phone line simulator with a lil white noise -- Yeah!!)

                                At the end of this function, (nZeros/nTotal) is an estimate
                                of the probability that a byte gets thru OK. Call this PB.
                                Then prob. that a line of average 30-40 bytes gets through
                                is PB^30. If we drop the expected number of OK lines as low
                                as 80% this still means that PB must be no lower than
                                the 30th root of 0.8, which is 0.9925. Therefore
                                flP_ERROR must be less than 0.75%

                                At PL=90%, PB rises to 0.9965 and flP_ERROR to 0.0035


        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
***************************************************************************/

// We read the TCF in units of One-Tenth of nominal TCF length
// We discard the first 2 chunks (20%), examine the next 4 chunks (40%)
// discard the rest. If the length is between 6 & 13 chunks (60% to 130%)
// and the error rates in chunk 2 & 3 is below the threshold we declare
// it OK. This (a) accepts too-short TCFs (some Class2 modems), and
// too long ones. (b) ignores leading and trailing trash (c) Can afford
// to be pretty strict with the core of the TCF

USHORT OneTenthTCFLen[16] =
{
/* V27_2400             0 */    45,
/* V29_9600             1 */    180,
/* V27_4800             2 */    90,
/* V29_7200             3 */    135,
/* V33_14400    4 */    270,
                                                0,
/* V33_12000    6 */    225,
                                                0,
/* V17_14400    8 */    270,
/* V17_9600             9 */    180,
/* V17_12000    10 */   225,
/* V17_7200             11 */   135,
                                                0,
                                                0,
                                                0,
                                                0
};

#define RECV_TCFBUFSIZE         270             // must be >= max chunk in above table
#define MIN_TCFLEN                      4               // measured in 10ths of the nominal length
#define MAX_TCFLEN                      13              // measured in 10ths of the nominal length
#define CHECKTCF_START          2               // lowest 10th to measure (20% and up)
#define CHECKTCF_STOP           5               // highest 10th to measure (upto 59%)

#define MAX_ERRS_PER_1000               20              // Increased from 1% to 2%. Be more lax

#ifdef MDDI

#       define RECVBUF_SLACK    0       // OEM drivers fill buffer of any size
                                                                // NOT! -- Xerox's Cactus driver is based
                                                                // on our Class1 driver -- but we don't care
                                                                // now, do we?
#else
#       define RECVBUF_SLACK    3       // Class1 driver fills only > 3, and leaves 3 empty spaces
#endif







SWORD GetTCF(PThrdGlbl pTG)
{
        USHORT  uCurMod, uChunkSize, uLength, uMeasuredLength, uErrCount;
        USHORT  uPhase, uNumRead, uEOF, i;
        BYTE    bRecvTCF[RECV_TCFBUFSIZE + RECVBUF_SLACK];
        SWORD   swRet;

        // uCurMod = ProtGetRecvMod();
        uCurMod = pTG->T30.uRecvTCFMod;
        BG_CHK((uCurMod & (~0x0F)) == 0);

        // *Don't* add ST_FLAG since we need long training for TCF
        pTG->T30.sRecvBufSize = 0;

        // Need a CritSection for receiving TCF. Must call Exit on every path out of here
        EnterPageCrit();        // start the GetTCF critsection

        if(ModemRecvMode(pTG, pTG->Params.hModem, uCurMod, FALSE, TCF_TIMEOUT, ifrTCF) != RECV_OK)
        {
                ExitPageCrit(); // end the GetTCF critsection
                swRet=  -1112;
                goto missedit;
        }

        pTG->CommCache.fReuse = 1;


        ExitPageCrit(); // end the GetTCF critsection
        (MyDebugPrint(pTG,  LOG_ALL,  "Receiving TCF: Mod=%d\r\n", uCurMod));

// make it large, in case of large buffers & slow modems
#define READ_TIMEOUT    10000

        uChunkSize = OneTenthTCFLen[uCurMod];
        BG_CHK(uChunkSize+RECVBUF_SLACK <= sizeof(bRecvTCF));
        uErrCount = 0;
        uLength = 0;
        uMeasuredLength = 0;
        for(uPhase=0; ;uPhase++)
        {
                // read a whole chunk
                for(uNumRead=0; uNumRead<uChunkSize; )
                {
                        USHORT uTemp = 0;
                        uEOF = ModemRecvMem(pTG, pTG->Params.hModem, bRecvTCF+uNumRead, (USHORT) (uChunkSize-uNumRead+RECVBUF_SLACK), READ_TIMEOUT, &uTemp);
                        BG_CHK(uTemp <= (uChunkSize-uNumRead));
                        uNumRead+=uTemp;

                        if(uEOF==RECV_EOF)
                                break;
                        else if(uEOF != RECV_OK)
                        {
                                swRet =  -1113;
                                goto missedit;
                        }
                }
                BG_CHK(uEOF==RECV_EOF || (uEOF==RECV_OK && uNumRead==uChunkSize));

                // ignore phases 0, 1, and 6 and above
                if(uPhase>=CHECKTCF_START && uPhase<=CHECKTCF_STOP)
                {
                        for(i=0; i< uNumRead; i++)
                        {
                                if(bRecvTCF[i])
                                        uErrCount++;
                                uMeasuredLength++;
                        }
                }
                uLength += uNumRead;

                if(uEOF==RECV_EOF)
                        break;
        }
        // comes here on EOF only
        BG_CHK(uEOF==RECV_EOF);

        // Official length must be at least 1.5s -10% = 1.35secs
        // We allow much more latitude because length variation
        // cannot be caused by line noise, only be bugs at the sender
        //
        // E.g. Fury DNE 1086 (German modem) sends a TCF that's too short
        // (sends 600 bytes at 4800 and 200 at 2400). This is less than
        // half of what we expect.
        // TCF with few errs (i.e. uErrCount==0) and is greater
        // that half of the min length we expect (i.e. longer
        // than 375 for 4800 and 172 for 2400) then accept it
        // (allow if uErr<=2 (arbitary small number))
        if(uPhase<MIN_TCFLEN || uPhase>MAX_TCFLEN)      // length<40% or >139%
        {
                ERRMSG(("BAD TCF length (%d), expected %d, Min %d uPhase=%d\r\n", uLength,
                                uChunkSize*10, uChunkSize*MIN_TCFLEN, uChunkSize*MAX_TCFLEN, uPhase));
                swRet = -1000;  // too short or long
        }
        else
        {
                // Calc errors per 1000 = (uErrCount * 1000)/uMeasuredLength
                BG_CHK(uMeasuredLength);
                swRet = (SWORD)((((DWORD)uErrCount) * 1000L) / ((DWORD)uMeasuredLength));

                if(swRet > MAX_ERRS_PER_1000)
                {
                        swRet = (-swRet);
                        ERRMSG((SZMOD "TOO MANY TCF ERRORS: swRet=%d uErrCount=%d uMeasured=%d uLength=%d uPhase=%d\r\n",
                                        swRet, uErrCount, uMeasuredLength, uLength, uPhase));
                }
        }

        BG_CHK(swRet >= -1000);
        (MyDebugPrint(pTG,  LOG_ALL,  "GetTCF -- returning %d\r\n", swRet));
        return swRet;

missedit:
        (MyDebugPrint(pTG,  LOG_ALL,  "GetTCF -- MISSED IT!! returning %d\r\n", swRet));
        return swRet;
}






/***************************************************************************
        Name      :     DEBUG.C
        Comment   :     Factored out debug code
        Functions :     (see Prototypes just below)

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
***************************************************************************/

#ifdef DEBUG

void D_PrintFrame(LPB lpb, UWORD cb)
{
        UWORD   uw, j;
        IFR             ifr;
#define PRINTFRAMEBUFSIZE       256
        BYTE    b2[PRINTFRAMEBUFSIZE];

        for(ifr=1; ifr<ifrMAX; ifr++)
                if(rgFrameInfo[ifr].bFCF1 ==
                   (BYTE)(rgFrameInfo[ifr].fInsertDISBit ?
                          (lpb[2] & 0xFE) : lpb[2]))
                                        break;
        if(ifr == ifrMAX) ifr = 0;

        j = (UWORD)wsprintf((LPSTR)b2, " (%s) 0x%02x [", (LPSTR)(rgFrameInfo[ifr].szName), lpb[2]);

        for(uw=3; uw<cb;)
                j += (UWORD)wsprintf((LPSTR)b2+j, "%02x ", (UWORD)lpb[uw++]);

        j += (UWORD)wsprintf((LPSTR)b2+j, "]\r\n");

        DEBUGMSG(1, (SZMOD "%s\r\n", (LPSTR)b2));
}

#endif













USHORT ModemRecvBuf(PThrdGlbl pTG, HMODEM hModem, BOOL fECM, LPBUFFER far* lplpbf, ULONG ulTimeout)
{
        USHORT uRet;

        // (MyDebugPrint(pTG,  LOG_ALL,  "In ModemRecvBuf lplpbf=%08lx ulTimeout=%ld\r\n", lplpbf, ulTimeout));

        BG_CHK(lplpbf);
        BG_CHK(pTG->T30.sRecvBufSize);
#ifdef IFK
        TstartTimeOut(pTG,  &pTG->T30.toBuf, WAITFORBUF_TIMEOUT);
        while(!(*lplpbf = MyAllocBuf(pTG, pTG->T30.sRecvBufSize)))
        {
                if(!TcheckTimeOut(pTG, &pTG->T30.toBuf))
                {
                        ERRMSG((SZMOD "<<ERROR>> Giving up on BufAlloc in T30 after %ld millisecs\r\n", ((ULONG)WAITFORBUF_TIMEOUT)));
                        BG_CHK(FALSE);
                        return RECV_ERROR;
                }
                RETAILMSG((SZMOD "<<ERROR>> BufAlloc failed in T30. Trying again\r\n"));
                IFProcSleep(100);
        }
#else
        if(!(*lplpbf = MyAllocBuf(pTG, pTG->T30.sRecvBufSize)))
                return RECV_ERROR;
#endif

        MyDebugPrint(pTG,  LOG_ALL,  "In ModemRecvBuf allocated %d bytes \n",  pTG->T30.sRecvBufSize);


#ifdef SWECM
        if(fECM)
                uRet = SWECMRecvFrame(pTG, hModem, (*lplpbf)->lpbBegBuf,
                                (*lplpbf)->wLengthBuf, ulTimeout, &((*lplpbf)->wLengthData));
        else
#endif
                uRet = ModemRecvMem(pTG, hModem, (*lplpbf)->lpbBegBuf,
                                (*lplpbf)->wLengthBuf, ulTimeout, &((*lplpbf)->wLengthData));


        if(!((*lplpbf)->wLengthData))
        {
                (MyDebugPrint(pTG,  LOG_ALL,  "Got 0 bytes from ModemRecvMem--freeing Buf 0x%08lx\r\n", *lplpbf));
                MyFreeBuf(pTG, *lplpbf);
                *lplpbf = NULL;
                BG_CHK(uRet != RECV_OK);
                // moved this error case handling out, since it's different for
                // ECM and non-ECM cases. In both cases want to ignore rather than
                // abort, so RECV_ERROR is not an appropriate return value
                // if(uRet==RECV_OK) uRet=RECV_ERROR;   // just in case. see bug#1492
        }

        if(*lplpbf)
                faxT2log((SZMOD "Ex ModemRecvBuf lpbf=%08lx uSize=%d uCount=%d uRet=%d\r\n", *lplpbf, (*lplpbf)->wLengthBuf, (*lplpbf)->wLengthData, uRet));
         else
                faxT2log((SZMOD "Ex ModemRecvBuf lpbf=null uRet=%d\r\n", uRet));

        return uRet;
}







#ifdef PDUMP    // Protocol Dump

#include <protdump.h>



void RestartDump(PThrdGlbl pTG)
{
        (MyDebugPrint(pTG,  LOG_ALL,  "Restart Dump old=%d off=%d\r\n", pTG->fsDump.uNumFrames, pTG->fsDump.uFreeSpaceOff));
        pTG->fsDump.uNumFrames = 0;
        pTG->fsDump.uFreeSpaceOff = 0;
}



void DumpFrame(PThrdGlbl pTG, BOOL     fSend, IFR ifr, USHORT cbFIF, LPBYTE lpbFIF)
{
        LPFR lpfr;

        if( pTG->fsDump.uNumFrames >= MAXDUMPFRAMES ||
                pTG->fsDump.uFreeSpaceOff+cbFIF+sizeof(FRBASE) >= MAXDUMPSPACE)
        {
                DEBUGMSG(1, (SZMOD " Out of dump space num=%d size=%d\r\n",
                                pTG->fsDump.uNumFrames, pTG->fsDump.uFreeSpaceOff));
                return;
        }

        lpfr = (LPFR) (((LPBYTE)(pTG->fsDump.b)) + pTG->fsDump.uFreeSpaceOff);
        lpfr->ifr = ifr;
        if(fSend) lpfr->ifr |= 0x80;
        lpfr->cb = (BYTE) cbFIF;
        if(cbFIF)
        {
                _fmemcpy(lpfr->fif, lpbFIF, cbFIF);
        }

        pTG->fsDump.uFrameOff[pTG->fsDump.uNumFrames++] =
            (USHORT)((((LPBYTE)(lpfr)) - ((LPBYTE)(pTG->fsDump.b))));
        pTG->fsDump.uFreeSpaceOff += (cbFIF + sizeof(FRBASE));

        BG_CHK(pTG->fsDump.uNumFrames <= MAXDUMPFRAMES);
        BG_CHK(pTG->fsDump.uFreeSpaceOff <= MAXDUMPSPACE);
}



void PrintDump(PThrdGlbl pTG)
{
        int i, j;

        (MyDebugPrint(pTG,  LOG_ALL,  "-*-*-*-*-*-*-*-* Print Protocol Dump -*-*-*-*-*-*-*-*-\r\n"));

        for(i=0; i<(int)pTG->fsDump.uNumFrames; i++)
        {
                LPFR lpfr = (LPFR) (((LPBYTE)(pTG->fsDump.b)) + pTG->fsDump.uFrameOff[i]);
                IFR  ifr = (lpfr->ifr & 0x7F);
                BOOL fSend = (lpfr->ifr & 0x80);

                BG_CHK(ifr <= ifrMAX);
                (MyDebugPrint(pTG,  LOG_ALL,  "%s: %s [ ",
                                        (LPSTR)(fSend ? "Sent" : "Recvd"),
                                        (LPSTR)(ifr ? rgFrameInfo[ifr].szName : "???") ));

                for(j=0; j<lpfr->cb; j++)
                       (MyDebugPrint(pTG,  LOG_ALL, "%02x ", (WORD)lpfr->fif[j]));

                (MyDebugPrint(pTG,  LOG_ALL, "]\r\n"));
        }

        (MyDebugPrint(pTG,  LOG_ALL,  "-*-*-*-*-*-*-*-* End Protocol Dump -*-*-*-*-*-*-*-*-\r\n"));
}

#endif //PDUMP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\main\hdlc.h ===
/*************************************************************************
        hdlc.h

        Contains stuff pertaining to sending and recieving HDLC frames
        that are defined in the T30 spec.
*************************************************************************/

// On PCs we should pause before ALL frames _except_ CFR & FTT (because
// those are too time critical). In IFAX we look for silence always.
// This is handled in HDLC.C

// On PCs we use TwiddleThumbs() (FTS and FRS are dangerous)
// In IFAX we must use RecvSilence (safe in IFAX) to avoid collisions
// This is handled inside the Modem driver. AWT30 always call RecvSilence
// (in HDLC.C), and the Class1 modem driver uses TwiddleThumbs()
// not FRS or FTS, while teh IFAX driver looks for real silence


// In WFW don't pause before CFR/FTT. Delay may get too long!!
#define SendCFR(pTG)       (SendSingleFrame(pTG,ifrCFR,0,0,1))
#define SendFTT(pTG)       (SendSingleFrame(pTG,ifrFTT,0,0,1))

// must pause before MCF/RTN always
#define SendMCF(pTG)       (SendSingleFrame(pTG,ifrMCF,0,0,1))
#define SendRTN(pTG)       (SendSingleFrame(pTG,ifrRTN,0,0,1))

/*** never send RTP
#define SendRTP()       (SendSingleFrame(ifrRTP,0,0))
***/

// no harm in pausing before DCN.
#define SendDCN(pTG)       (SendSingleFrame(pTG,ifrDCN,0,0,1))

#ifdef USECRP
#       define  SendCRP(pTG)                (SendSingleFrame(pTG,ifrCRP,0,0,1))
#else
#       define  SendCRP(pTG)                (0)
#endif

// we've eliminated the post-page pause, so we need to pause before these
// frames. In any case, that's all handled inside the modem driver.
// We make a single call to ModemRecSilence()
#define SendEOM(pTG)                       (SendSingleFrame(pTG,ifrEOM,0,0,1))
#define SendMPS(pTG)                       (SendSingleFrame(pTG,ifrMPS,0,0,1))
#define SendEOP(pTG)                       (SendSingleFrame(pTG,ifrEOP,0,0,1))
#define SendPRI_EOM(pTG)           (SendSingleFrame(pTG,ifrPRI_EOM,0,0,1))
#define SendPRI_MPS(pTG)           (SendSingleFrame(pTG,ifrPRI_MPS,0,0,1))
#define SendPRI_EOP(pTG)           (SendSingleFrame(pTG,ifrPRI_EOP,0,0,1))
#define SendPIP(pTG)                       (SendSingleFrame(pTG,ifrPIP,0,0.1))
#define SendPIN(pTG)                       (SendSingleFrame(pTG,ifrPIN,0,0,1))

// do we need a pause before RR/CTC/ERR/CTR etc?
// in RR & CTC we have all teh time in the world, so must pause
// ERR & CTR I dunno, so I'm pausing anyway
#define SendRR(pTG)                (SendSingleFrame(pTG,ifrRR,0,0,1))
#define SendCTC(pTG,fif)    (SendSingleFrame(pTG,ifrCTC,fif,2,1))
#define SendERR(pTG)               (SendSingleFrame(pTG,ifrERR,0,0,1))
#define SendCTR(pTG)               (SendSingleFrame(pTG,ifrCTR,0,0,1))

// PPR/RNR sent in same logical spot as MCF so use delay
#define SendPPR(pTG,fif)    (SendSingleFrame(pTG,ifrPPR,fif,32,1))
#define SendRNR(pTG)               (SendSingleFrame(pTG,ifrRNR,0,0,1))

// add this...
#define SendEOR_EOP(pTG)           (SendSingleFrame(pTG,ifrEOR_EOP, 0, 0, 1))

#define TEXTBASED

typedef struct {
        BYTE    bFCF1;
        BYTE    bFCF2;
        BYTE    fInsertDISBit;
        BYTE    wFIFLength;             // required FIF length, 0 if none, FF if variable
        char*   szName;
} FRAME;

typedef FRAME TEXTBASED *CBPFRAME;

// CBPFRAME is a based pointer to a FRAME structure, with the base as
// the current Code segment. It will only be used to access
// the frame table which is a CODESEG based constant table.


// This is everything you never wanted to know about T30 frames....
#define         ifrMAX          48
extern FRAME TEXTBASED rgFrameInfo[ifrMAX];





/****************** begin prototypes from hdlc.c *****************/
BOOL SendSingleFrame(PThrdGlbl pTG, IFR ifr, LPB lpbFIF, USHORT uFIFLen, BOOL fSleep);
BOOL SendManyFrames(PThrdGlbl pTG, LPLPFR lplpfr, USHORT uNumFrames);
BOOL SendZeros(PThrdGlbl pTG, USHORT uCount, BOOL fFinal);
BOOL SendTCF(PThrdGlbl pTG);
BOOL SendRTC(PThrdGlbl pTG, BOOL);
SWORD GetTCF(PThrdGlbl pTG);
/***************** end of prototypes from hdlc.c *****************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\main\nsfenc.h ===
/* Key must be 3 bytes of random key, datalen is the length of data */
void FAR PASCAL RC4ENC(BYTE FAR *key, WORD datalen, BYTE FAR *data);
DWORD FAR PASCAL RandDWord(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\main\protapi.c ===
/***************************************************************************
 Name     :     PROTHELP.C
 Comment  :     Protocol Initialization & helper functions
 Functions:     (see Prototypes just below)

        Copyright (c) 1993 Microsoft Corp.

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/

#include "prep.h"


#include "efaxcb.h"

#include "protocol.h"


///RSL
#include "glbproto.h"


#define faxTlog(m)      DEBUGMSG(ZONE_PROTAPI, m)
#define FILEID          FILEID_PROTAPI










BOOL WINAPI ET30ProtOpen(PThrdGlbl pTG, BOOL fCaller)
{
        (MyDebugPrint(pTG, LOG_ALL,  "In ProtocolOpen\r\n"));

        BG_CHK(sizeof(DIS) == 8);

        if(!pTG->ProtInst.fInUse)
        {
                memset(&pTG->ProtInst, 0, sizeof(PROT));

                pTG->ProtInst.RecvCaps.wTotalSize =
                pTG->ProtInst.RecvParams.wTotalSize =
                pTG->ProtInst.RecvPollReq.wTotalSize = sizeof(BC);

                pTG->ProtInst.SendCaps.wTotalSize =
                pTG->ProtInst.SendParams.wTotalSize =
                pTG->ProtInst.SendPollReq.wTotalSize = sizeof(BC);

                pTG->ProtInst.RecvCapsGuard  =
                pTG->ProtInst.RecvParamsGuard =
                pTG->ProtInst.RecvPollReqGuard = 0xA55A5AA5L;

                pTG->ProtInst.SendCapsGuard  =
                pTG->ProtInst.SendParamsGuard =
                pTG->ProtInst.SendPollReqGuard = 0xA55A5AA5L;

                pTG->ProtInst.fInUse = TRUE;

                _fmemset(&pTG->ProtParams, 0, sizeof(pTG->ProtParams));

#       ifdef OEMNSF
                wLenOEMID = 0;
                wOEMFlags = 0;
                fUsingOEMProt = 0;

                if(lpfnOEMStartCall)
                        wOEMFlags = lpfnOEMStartCall(fCaller, &wLenOEMID, rgbOEMID);
                if(wLenOEMID > 4) wLenOEMID = 4;
#       endif //OEMNSF

                return TRUE;
        }
        else
        {
                BG_CHK(FALSE);
                return FALSE;
        }
}













BOOL  WINAPI ET30ProtClose(PThrdGlbl pTG)
{
        (MyDebugPrint(pTG,  LOG_ALL, "In ProtocolClose\r\n"));

        pTG->ProtInst.fInUse = FALSE;

        BG_CHK(pTG->ProtInst.RecvCapsGuard  == 0xA55A5AA5L);
        BG_CHK(pTG->ProtInst.RecvParamsGuard == 0xA55A5AA5L);
        BG_CHK(pTG->ProtInst.RecvPollReqGuard == 0xA55A5AA5L);
        BG_CHK(pTG->ProtInst.SendCapsGuard  == 0xA55A5AA5L);
        BG_CHK(pTG->ProtInst.SendParamsGuard == 0xA55A5AA5L);
        BG_CHK(pTG->ProtInst.SendPollReqGuard == 0xA55A5AA5L);

#ifdef DEBUG
        (MyDebugPrint(pTG, LOG_ALL,  "Sending Caps & Params\r\n"));
        if(pTG->ProtInst.fRecvCapsGot)               D_PrintBC((LPBC)&pTG->ProtInst.RecvCaps, 0, 0);
        if(pTG->ProtInst.fllRecvCapsGot)             D_PrintBC(0, "RecvCaps", &pTG->ProtInst.llRecvCaps);
        if(pTG->ProtInst.fllSendParamsInited) D_PrintBC(0, "Send Negot Position", &pTG->ProtInst.llSendParams);
        if(pTG->ProtInst.fSendParamsInited)  D_PrintBC((LPBC)&pTG->ProtInst.SendParams, 0, 0);
        if(pTG->ProtInst.fllNegotiated)              D_PrintBC(0, "SendParams", &pTG->ProtInst.llNegot);

        (MyDebugPrint(pTG, LOG_ALL,  "Receiving Caps & Params\r\n"));
        if(pTG->ProtInst.fSendCapsInited)    D_PrintBC((LPBC)&pTG->ProtInst.SendCaps, 0, 0);
        if(pTG->ProtInst.fllSendCapsInited)  D_PrintBC(0, "SendCaps", &pTG->ProtInst.llSendCaps);
        if(pTG->ProtInst.fRecvParamsGot)             D_PrintBC((LPBC)&pTG->ProtInst.RecvParams, 0, 0);
        if(pTG->ProtInst.fllRecvParamsGot)   D_PrintBC(0, "RecvParams", &pTG->ProtInst.llRecvParams);

        (MyDebugPrint(pTG, LOG_ALL,  "Polling Caps & Params\r\n"));
        if(pTG->ProtInst.fSendPollReqInited) D_PrintBC((LPBC)&pTG->ProtInst.SendPollReq, 0, 0);
        if(pTG->ProtInst.fRecvPollReqGot)    D_PrintBC((LPBC)&pTG->ProtInst.RecvPollReq, 0, 0);

#endif //DEBUG

#ifdef OEMNSF
        if(wOEMFlags && lpfnOEMEndCall)
        {
                lpfnOEMEndCall();
                wOEMFlags = 0;
        }
#endif

        return TRUE;
}











BOOL ProtGetBC(PThrdGlbl pTG, BCTYPE bctype, BOOL fSleep)
{
        LPBC lpbc;
        USHORT uSpace;

        (MyDebugPrint(pTG, LOG_ALL,  "In ProtGetBC: bctype=%d\r\n", bctype));

        lpbc = ICommGetBC(pTG, bctype, fSleep);

        if(lpbc)
        {
                BG_CHK(lpbc->wTotalSize >= sizeof(BC));
                switch(bctype)
                {
                case SEND_CAPS:
                        BG_CHK(lpbc->bctype == SEND_CAPS);
                        uSpace = sizeof(pTG->ProtInst.SendCaps);
                        if(lpbc->wTotalSize > uSpace)
                                goto nospace;
                        _fmemcpy(&pTG->ProtInst.SendCaps, lpbc, lpbc->wTotalSize);
                        pTG->ProtInst.fSendCapsInited = TRUE;
                        break;
                case SEND_PARAMS:
                        if(lpbc->bctype == SEND_PARAMS)
                        {
                                uSpace = sizeof(pTG->ProtInst.SendParams);
                                if(lpbc->wTotalSize > uSpace)
                                        goto nospace;
                                _fmemcpy(&pTG->ProtInst.SendParams, lpbc, lpbc->wTotalSize);
                                pTG->ProtInst.fSendParamsInited = TRUE;
                        }
                        else if(lpbc->bctype == SEND_POLLREQ)
                        {
                                uSpace = sizeof(pTG->ProtInst.SendPollReq);
                                if(lpbc->wTotalSize > uSpace)
                                        goto nospace;
                                _fmemcpy(&pTG->ProtInst.SendPollReq, lpbc, lpbc->wTotalSize);
                                pTG->ProtInst.fSendPollReqInited = TRUE;
                        }
                        else
                        {
                            // RSL  BUGBUG
                            // RSL  BG_CHK(FALSE);
                            // RSL  goto error;

                            uSpace = sizeof(pTG->ProtInst.SendParams);
                            if(lpbc->wTotalSize > uSpace)
                                    goto nospace;
                           //  _fmemcpy(&pTG->ProtInst.SendParams, lpbc, lpbc->wTotalSize);
                            pTG->ProtInst.fSendParamsInited = TRUE;

                        }

                        break;
                default:
                        BG_CHK(FALSE);
                        goto error;
                        break;
                }
                return TRUE;
        }
        else
        {
                BG_CHK(fSleep);
                (MyDebugPrint(pTG, LOG_ALL,  "Ex ProtGetBC: bctype=%d --> FAILED\r\n", bctype));
                return FALSE;
        }
nospace:
        (MyDebugPrint(pTG, LOG_ERR,  "<<ERROR>> BC too big size=%d space=%d\r\n", lpbc->wTotalSize, uSpace));
error:


        MyDebugPrint(pTG, LOG_ALL, "ATTENTION: ProtGetBC pTG->ProtInst.fAbort = TRUE\n");
        pTG->ProtInst.fAbort = TRUE;
        return FALSE;
}





#define SetupLL(npll, B, M, E, f64)             \
        (((npll)->Baud=(BYTE)(B)), ((npll)->MinScan=(BYTE)(M)), ((npll)->fECM=(BYTE)(E)), ((npll)->fECM64=(BYTE)(f64)))














BOOL  WINAPI ET30ProtSetProtParams(PThrdGlbl pTG, LPPROTPARAMS lp, USHORT uSendSpeeds, USHORT uRecvSpeeds)
{
        BG_CHK(uRecvSpeeds && uSendSpeeds);
        BG_CHK((uRecvSpeeds & ~BAUD_MASK) == 0);
        BG_CHK((uSendSpeeds & ~BAUD_MASK) == 0);

        BG_CHK(lp->uSize >= sizeof(pTG->ProtParams));
        _fmemcpy(&pTG->ProtParams, lp, min(sizeof(pTG->ProtParams), lp->uSize));

        // Hardware params
        SetupLL(&(pTG->ProtInst.llSendCaps), uRecvSpeeds, lp->uMinScan,
                !lp->DisableRecvECM, (lp->DisableRecvECM ? 0 : lp->Recv64ByteECM));
        pTG->ProtInst.fllSendCapsInited = TRUE;

        SetupLL(&(pTG->ProtInst.llSendParams), uSendSpeeds, MINSCAN_0_0_0,
                !lp->DisableSendECM, (lp->DisableSendECM ? 0 : lp->Send64ByteECM));
        pTG->ProtInst.fllSendParamsInited = TRUE;

        /*****
                pTG->ProtInst.llSendCaps.Baud = uRecvSpeeds;
                pTG->ProtInst.llSendCaps.MinScan = uMinScan;
                pTG->ProtInst.llSendParams.Baud = uSendSpeeds;
                pTG->ProtInst.llSendParams.MinScan = MINSCAN_0_0_0;
        ******/

        pTG->ProtInst.fHWCapsInited = TRUE;

        if(lp->HighestSendSpeed && lp->HighestSendSpeed != 0xFFFF)
                pTG->ProtInst.HighestSendSpeed = lp->HighestSendSpeed;
        else
                pTG->ProtInst.HighestSendSpeed = 0;

        if(lp->LowestSendSpeed && lp->LowestSendSpeed != 0xFFFF)
                pTG->ProtInst.LowestSendSpeed = lp->LowestSendSpeed;
        else
                pTG->ProtInst.LowestSendSpeed = 0;

        (MyDebugPrint(pTG,  LOG_ALL, "Done with HW caps (recv, send)\r\n"));
        // OK to print -- not online
        D_PrintBC(0, "Recv HWCaps", &(pTG->ProtInst.llSendCaps));
        D_PrintBC(0, "Send HWCaps", &(pTG->ProtInst.llSendParams));
        (MyDebugPrint(pTG,  LOG_ALL, "Highest=%d Lowest=%d\r\n", pTG->ProtInst.HighestSendSpeed, pTG->ProtInst.LowestSendSpeed));

        return TRUE;
}











void GetRecvPageAck(PThrdGlbl pTG)
{
        USHORT uRet;

        pTG->ProtInst.fPageOK = 0;
        switch(uRet = ICommGetRecvPageAck(pTG, TRUE))
        {
        case 0:
        case 1:         pTG->ProtInst.fPageOK = uRet;
             break;

        default:
            MyDebugPrint(pTG, LOG_ALL, "ATTENTION: GetRecvPageAck pTG->ProtInst.fAbort = TRUE\n");
            pTG->ProtInst.fAbort = TRUE;
            BG_CHK(FALSE);
            break;
        }
        (MyDebugPrint(pTG, LOG_ALL,  "GetPageAck-->%d\r\n", uRet));
}















void  WINAPI ET30ProtAbort(PThrdGlbl pTG, BOOL fEnable)
{
        // bug#696 -- sometimes on aborts this gets called with fEnable==0
        // even after ET30ProtClose has been called. This is harmless so
        // don't BG_CHK. But it must _not_ be called with fEnable==TRUE
        // if pTG->ProtInst.fInUse is 0, i.e. we're not inited

        BG_CHK(fEnable ? pTG->ProtInst.fInUse : TRUE);
        // ICommFailureCode already set

        MyDebugPrint(pTG, LOG_ALL, "ATTENTION: ET30ProtAbort pTG->ProtInst.fAbort=%d\n", fEnable);
        pTG->ProtInst.fAbort = fEnable;
}

















DWORD_PTR ProtExtFunction(PThrdGlbl pTG, USHORT uFunction)
{
        NPPROT  npProt = &pTG->ProtInst;
        BG_CHK(pTG->ProtInst.fInUse);

        switch(uFunction)
        {
        case GET_SEND_MOD:                      BG_CHK(npProt->fllNegotiated);
                                                                return npProt->llNegot.Baud;
        case GET_RECV_MOD:                      BG_CHK(npProt->fllRecvParamsGot);
                                                                return npProt->llRecvParams.Baud;
        case GET_ECM_FRAMESIZE:         BG_CHK(npProt->fllNegotiated);
                                                                return (npProt->llNegot.fECM64 ? 6 : 8);
        case GET_PPR_FIF:                       BG_CHK(npProt->fRecvdPPR);
                                                                return (ULONG_PTR)((LPBYTE)npProt->bRemotePPR);
        case GET_WHATNEXT:                      return (ULONG_PTR)((LPWHATNEXTPROC)WhatNext);
        case GET_MINBYTESPERLINE:       BG_CHK(npProt->fllNegotiated);
                                                                return MinScanToBytesPerLine(pTG, npProt->llNegot.MinScan, npProt->llNegot.Baud);
        case RECEIVING_ECM:                     if(!npProt->fllRecvParamsGot)
                                                                {
                                                                        (MyDebugPrint(pTG, LOG_ALL,  "<<WARNING>> No RecvParams--assuming non-ECM\r\n"));
                                                                        return FALSE;
                                                                }
                                                                else
                                                                        return npProt->llRecvParams.fECM;
        case GET_RECV_ECM_FRAMESIZE:BG_CHK(npProt->fllRecvParamsGot);
                                                                return (npProt->llRecvParams.fECM64 ? 6 : 8);
        case GET_RECVECMFRAMECOUNT:     BG_CHK(npProt->fRecvdPPS);
                                                                BG_CHK(npProt->uFramesInThisBlock);
                                                                BG_CHK(npProt->uFramesInThisBlock <= 256);
                                                                return (DWORD)(npProt->uFramesInThisBlock);
        case GET_PPS:                           return *((DWORD*)(npProt->bRemotePPS));
        case RESET_RECVECMFRAMECOUNT:   npProt->uFramesInThisBlock=0;
                                                                return 0;
        case RESET_RECVPAGEACK:         npProt->fPageOK=FALSE;
                                                                return 0;
        case GET_SEND_ENCODING:         BG_CHK(npProt->fSendParamsInited);
                                                                return npProt->SendParams.Fax.Encoding;
        case GET_RECV_ENCODING:         BG_CHK(npProt->fRecvParamsGot);
                                                                return npProt->RecvParams.Fax.Encoding;
        default:                                        BG_CHK(FALSE); return 0;
        }
}


#ifdef DEBUG

char* szBCTYPE[] = {
"NONE",
"SEND_CAPS",
"RECV_CAPS",
"SEND_PARAMS",
"RECV_PARAMS",
"SEND_POLLREQ",
"RECV_POLLREQ"
};














void D_PrintBC(LPBC lpbc, LPSTR szll, LPLLPARAMS lpll)
{
        int i;

  if(lpbc)
  {
        faxTlog((SZMOD "%s: Std: l=%d n=%d vMsg=%d fBin=%d fIn=%d vSec=%d vCmpr=%d OS=%d vFl=%d\r\n",
                (LPSTR)(szBCTYPE[lpbc->bctype]), lpbc->Std.GroupLength, lpbc->Std.GroupNum,
                lpbc->Std.vMsgProtocol, lpbc->Std.fBinaryData, lpbc->Std.fInwardRouting,
                lpbc->Std.vSecurity, lpbc->Std.vMsgCompress, lpbc->Std.OperatingSys,
                lpbc->Std.vShortFlags));
        faxTlog((SZMOD "    vInt=%d Dspd=%x Dlnk=%x Fax: fPol=%d Res=%x Enc=%x Wid=%x Len=%x\r\n",
                lpbc->Std.vInteractive, lpbc->Std.DataSpeed, lpbc->Std.DataLink,
                lpbc->Fax.fPublicPoll,
                (WORD)lpbc->Fax.AwRes, lpbc->Fax.Encoding, lpbc->Fax.PageWidth,
                lpbc->Fax.PageLength));
        faxTlog((SZMOD "    TextID: Code=%d Len=%d Id=%s\r\n",
                lpbc->wTextEncoding, lpbc->wTextIdLen, (LPSTR)(lpbc->wszTextId ? OffToLP(lpbc, wszTextId) : "none") ));
        // faxTlog((SZMOD "    NumID: Id=%s\r\n",
        //      (LPSTR)(lpbc->wszNumId ? OffToLP(lpbc, wszNumId) : "none") ));
        faxTlog((SZMOD "    NSS: l=%d n=%d vMsg=%d vInter=%d\r\n",
                lpbc->NSS.GroupLength, lpbc->NSS.GroupNum,
                lpbc->NSS.vMsgProtocol, lpbc->NSS.vInteractive));
        faxTlog((SZMOD "    Image: len=%d num=%d Poll: len=%d num=%d fHi=%d fLo=%d\r\n",
                lpbc->Image.GroupLength, lpbc->Image.GroupNum,
                lpbc->PollCaps.GroupLength, lpbc->PollCaps.GroupNum,
                lpbc->PollCaps.fHighSpeedPoll, lpbc->PollCaps.fLowSpeedPoll));
#ifdef NOCHALL
        faxTlog((SZMOD "    PollReq: num=%d\r\n", lpbc->wNumPollReq));
#else
        faxTlog((SZMOD "    PollReq: num=%d ChallLen=%d\r\n",
                lpbc->wNumPollReq, lpbc->wChallengeLen));
#endif

        for(i=0; i<(int)lpbc->wNumPollReq && i<MAXNSCPOLLREQ; i++)
        {
                LPBCPOLLREQ lp = (LPBCPOLLREQ)OffToLP(lpbc, rgwPollReq[i]);

                faxTlog((SZMOD "    PollReq[%d]: len=%d num=%d fRet=%d type=%d Title=%s\r\n",
                        i, lp->GroupLength, lp->GroupNum, lp->fReturnControl, lp->PollType,
                        (LPSTR)(lp->b) ));
        }
  }
  if(lpll)
  {
        BG_CHK(szll);
        faxTlog((SZMOD "%s: Baud=%x MinScan=%x ECM=%d 64=%d\r\n", (LPSTR)szll,
                lpll->Baud, lpll->MinScan, lpll->fECM, lpll->fECM64));
  }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\main\memutil.c ===
/***************************************************************************
 Name     :     MEMUTIL.C
 Comment  :     Mem mgmnt and utilty functions

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/


#include "prep.h"

#ifdef WIN32_LEAN_AND_MEAN              // for timeBeginPeriod and timeEndPeriod
#       include <mmsystem.h>
#endif


#include "glbproto.h"


#define SZMOD  "Memory: "



void MyAllocInit(PThrdGlbl pTG)
{
        pTG->uCount=0;
        pTG->uUsed=0;
}






LPBUFFER MyAllocBuf(PThrdGlbl pTG, LONG sSize)
{
        LPBUFFER        lpbf;

        BG_CHK(sSize > 0);
        if(pTG->uCount >= STATICBUFCOUNT)
        {
                (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Already alloced %d bufs\r\n", pTG->uCount));
                BG_CHK(FALSE);
                return NULL;
        }
        else if(pTG->uUsed+sSize > STATICBUFSIZE)
        {
                (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Already alloced %d bytes out of %d. Want %d\r\n", pTG->uUsed, STATICBUFSIZE, sSize));
                BG_CHK(FALSE);
                return NULL;
        }

        // init header
        // pTG->bfStaticBuf[pTG->uCount].lpbdBufData = NULL;
        // Initialize fields
        // pTG->bfStaticBuf[pTG->uCount].lpbdBufData->header.uRefCount = 1;
        pTG->bfStaticBuf[pTG->uCount].lpbCurPtr = pTG->bfStaticBuf[pTG->uCount].lpbBegData =
                                                  pTG->bfStaticBuf[pTG->uCount].lpbBegBuf =
                                                  pTG->bStaticBufData + pTG->uUsed;

        pTG->bfStaticBuf[pTG->uCount].wLengthBuf = (USHORT) sSize;
        pTG->uUsed += (USHORT) sSize;
        // pTG->bfStaticBuf[pTG->uCount].lpbfNextBuf = NULL;
        // pTG->bfStaticBuf[pTG->uCount].uReadOnly = FALSE;
        pTG->bfStaticBuf[pTG->uCount].wLengthData = 0;
        pTG->bfStaticBuf[pTG->uCount].dwMetaData = 0;

        lpbf = &(pTG->bfStaticBuf[pTG->uCount++]);

        // wsprintf(szTemp, "%d %d %x %08lx %08lx %08lx\r\n", sSize, pTG->uCount, pTG->uUsed, lpbf, lpbf->lpbBegBuf, lpbf->lpbBegData);
        // OutputDebugStr(szTemp);

        return lpbf;
}








BOOL MyFreeBuf(PThrdGlbl pTG, LPBUFFER lpbf)
{
        if(pTG->uCount==0 || lpbf!= &(pTG->bfStaticBuf[pTG->uCount-1]))
        {
                (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Not alloced or out-of-order free. Count=%d lpbf=%08lx bf=%08lx\r\n",
                                pTG->uCount, lpbf, (LPBUFFER)&pTG->bfStaticBuf));
                BG_CHK(FALSE);
                return FALSE;
        }
        pTG->uCount--;
        BG_CHK(lpbf->lpbBegBuf == pTG->bStaticBufData+pTG->uUsed-lpbf->wLengthBuf);
        pTG->uUsed -= lpbf->wLengthBuf;
        return TRUE;
}









LPVOID IFMemAlloc (UINT fuAlloc, LONG lAllocSize, LPWORD lpwActualSize)
{
   DWORD dwSize;
   LPVOID  lpv = NULL;


   // Find the required size
   if (lAllocSize > 0)  {
       dwSize = (DWORD)lAllocSize;
   }
   else {
       if (lAllocSize == RAW_DATA_SIZE)
           dwSize=16000;
       else if (lAllocSize == COMPRESS_DATA_SIZE)
           dwSize=2000;
       else if (lAllocSize == SMALL_HEADER_SIZE)
           dwSize = sizeof(BUFFER);
       else
           return NULL;
   }

   lpv = MemAlloc(dwSize);
   if (lpwActualSize) {
       if (lpv) {
           *lpwActualSize = (UINT) dwSize;
       }
       else {
           *lpwActualSize = 0;
       }
   }



   return lpv;
}





BOOL IFMemFree (LPVOID lpvMem)
{
   MemFree(lpvMem);
   return 1;

}





////////////////////////////////////////////////////////
// from utils\runtime\buffers.c
////////////////////////////////////////////////////////

typedef struct _BUFFERDATA {
        // Private portion
        struct {
        UINT    uRefCount;
        UINT    uFiller;        // maintain alignment
        } header;

        // public portion
        BYTE    rgbData[];      // Actual data
} BUFFERDATA;

// signature
#define BUFFER_SIGNATURE        4656    // decimal so that it can be used in





LPBUFFER IFBufAlloc (LONG lBufSize)
{
        register        LPBUFFER        lpbf;
        WORD    wActualSize;


        // First do resource management to decide whether this job can be
        // allocated these extra resources or not.

        // If we reach this point we can try and allocate the buffer header

        if (!(lpbf = (LPBUFFER) IFMemAlloc (0, SMALL_HEADER_SIZE, &wActualSize))) {
                return NULL;
        }

        if (lBufSize) {
                // We need to allocate the data portion too ...
                // increase the data size by 4 if he is explicitly asking
                // for some amount to make space for ref count etc
                if (lBufSize > 0) {
                        // sizeof evaluates at compile time so its OK
                        // that lpbdBufData is Null !!
                        lBufSize += sizeof(lpbf->lpbdBufData->header);
                }

                if (!(lpbf->lpbdBufData = (BUFFERDATA FAR*) IFMemAlloc (0, lBufSize, &wActualSize))) {
                        // Free everything and return error ..
                        IFMemFree (lpbf);
                        return NULL;
                }

                // Initialize fields
                lpbf->lpbdBufData->header.uRefCount = 1;
                lpbf->lpbCurPtr = lpbf->lpbBegData = lpbf->lpbBegBuf
                                                = lpbf->lpbdBufData->rgbData;
                // take out space for uRefCount & wFiller
                lpbf->wLengthBuf = wActualSize - sizeof(lpbf->lpbdBufData->header);
        }
        else  {
                // No data - buffer will contain metadata only
                lpbf->lpbdBufData = NULL;
                lpbf->lpbCurPtr = lpbf->lpbBegData = lpbf->lpbBegBuf = NULL;
                lpbf->wLengthBuf = 0;
        }

        // Now initialize all the rest of the common fields
        lpbf->lpbfNextBuf = NULL;

        lpbf->fReadOnly = FALSE;
        lpbf->wLengthData = 0;
        lpbf->dwMetaData = 0;

#ifdef VALIDATE
        lpbf->sentinel = BUFFER_SIGNATURE;
#endif


        return lpbf;
}







BOOL IFBufFree (LPBUFFER lpbf)
{
        register BOOL bRetVal;



        if (lpbf->lpbdBufData && (!--lpbf->lpbdBufData->header.uRefCount)) {
                // both header and data need to be freed
                bRetVal = IFMemFree(lpbf->lpbdBufData);
                bRetVal = bRetVal && IFMemFree(lpbf);
        }
        else {
                // only the buffer header needs to be freed. Either the buffer only
                // contained metadata, or the data is still being referenced.
                bRetVal = IFMemFree(lpbf);
        }

        return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\main\negot.c ===
/***************************************************************************
 Name     :     NEGOT.C
 Comment  :     Capability handling and negotiation

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/

#include "prep.h"


#include "protocol.h"

#include "glbproto.h"

BOOL     glLoRes=0;  // Simulate LoRes from Remote when TX
#define         faxTlog(m)              DEBUGMSG(ZONE_NEGOT, m);


#       define INST_ENCODING    pTG->Inst.awfi.Encoding
#       define INST_VSECURITY   pTG->Inst.awfi.vSecurity
#       define INST_RESOLUTION  pTG->Inst.awfi.AwRes
#       define INST_PAGEWIDTH   pTG->Inst.awfi.PageWidth
#       define INST_PAGELENGTH  pTG->Inst.awfi.PageLength



//////// Move these hardcoded values to an INI file ////////

#define CAPS_WIDTH              WIDTH_A4
#define ENCODE_CAPS             (MH_DATA | MR_DATA )  // RSL | MMR_DATA)

// Current suppored linearized verson +++ (change to vMSG_IFAX100 when we
//                      have enabled Linearized published images).
#define vMSG_WIN95              vMSG_IFAX100 // vMSG_SNOW

//#  define CAPS_RES 0

//#if 0
#ifdef DPI_400
#  define CAPS_RES  (AWRES_mm080_038 | AWRES_mm080_077 | AWRES_200_200 | AWRES_300_300 | AWRES_mm080_154 | AWRES_160_154 | AWRES_400_400)
#else
#  define CAPS_RES  (AWRES_mm080_038 | AWRES_mm080_077 | AWRES_200_200 | AWRES_300_300)
#endif
//#endif



/********* These are the Ricoh thresholds--they're too simplistic *****
USHORT MaxBadLines[4][4] =
{
        {110, 220, 330, 440 },          // CheckLevel=1    10%
        { 82, 165, 248, 330 },          // CheckLevel=2    7.5%
        { 55, 110, 165, 220 },          // CheckLevel=3    5%
        { 27,  55,  83, 110 }           // CheckLevel=4    2.5%
};

USHORT MaxConsecBad[4][4] =
{
        { 6, 12, 18, 24 },                      // CheckLevel=1
        { 5, 10, 15, 20 },                      // CheckLevel=2
        { 4,  8, 12, 16 },                      // CheckLevel=3
        { 3,  6,  9, 12 }                       // CheckLevel=4
};
*****************/

////////////////////////////////////////////////////////////////
// Don't delete this -- these were my thresholds _before_ I talked to Ricoh
////////
// higher thresholds, tapering off, because
// at higher resolutions we want cleaner copy.
// USHORT MaxBadLines[4] = { 33, 66, 84, 99 }; // 3.5, 3, 2.5, 2.25 %bad
// USHORT MaxConsecBad[4] = { 5, 9, 12, 15 };    // 2/3rd of a 10pt char is 9,18,27,36 lines
////////////////////////////////////////////////////////////////

USHORT MaxBadLines[4][4] =
{
        { 77, 132, 165, 198 },  // CheckLevel=1  7, 6, 5, 4.5% bad
        { 58,  99, 124, 149 },  // CheckLevel=2  5.25, 4.5, 3.75, 3.375% bad
        { 39,  66,  83, 99 },   // CheckLevel=3  3.5, 3, 2.5, 2.25% bad
        { 19,  33,  41, 50 }    // CheckLevel=4  1.75, 1.5, 1.25, 1.125% bad
};

USHORT MaxConsecBad[4][4] =
{
        { 7, 13, 18, 23 },              // CheckLevel=1
        { 6, 11, 15, 19 },              // CheckLevel=2
        { 5,  9, 12, 15 },              // CheckLevel=3
        { 4,  7,  9, 11 }               // CheckLevel=4
};


        // lBad = DWORD with max. consecutive badlines in low word
        //                      and total number of bad lines in high word.
        // res==resolution (using ENCODE_ values)
        // i = vertical res index into table above (0=100, 1=200, 2=300 3=400)










/** Widths in pixels must be exactly correct for MH decoding to work.
        the width above are for NORMAL, FINE, 200dpi and SUPER resolutions.
        At 400dpi or SUPER_SUPER exactly twice as amny pixels must be supplied
        and at 300dpi exactly 1.5 times.

                                        A4                      B4                      A3
                200             1728/216        2048/256        2432/304
                300             2592/324        3072/384        3648/456
                400             3456/432        4096/512        4864/608
**/

// first index is 200/300/400dpi horiz res (inch or mm based)
// second index is width A4/B4/A3

USHORT ResWidthToBytes[3][3] =
{
        { 216, 256, 304 },
        { 324, 384, 456 },
        { 432, 512, 608 }
};













BYTE BestEncoding[8] =
{
        0,      // none (error)
        1,      // MH only
        2,      // MR only
        2,      // MR & MH
        4,      // MMR only
        4,      // MMR & MH
        4,      // MMR & MR
        4       // MMR & MR & MH
};











BOOL NegotiateCaps(PThrdGlbl pTG)
{
        USHORT Res;

        if (glLoRes) {
            pTG->Inst.RemoteRecvCaps.Fax.AwRes = 0;
        }

        memset(&pTG->Inst.SendParams, 0, sizeof(pTG->Inst.SendParams));
        pTG->Inst.SendParams.bctype = SEND_PARAMS;
        // They should be set. This code here is correct--arulm
        // +++ Following three are not set in pcfax11
        pTG->Inst.SendParams.wBCSize = sizeof(BC);
        pTG->Inst.SendParams.wBCVer = VER_AWFXPROT100;
        pTG->Inst.SendParams.wTotalSize = sizeof(BC);

        // +++ Initialize ID from our own SendCaps...
        {
                char rgchID[MAXFHBIDLEN+2];
                GetTextId(&pTG->Inst.SendCaps, rgchID, MAXFHBIDLEN+1);
                PutTextId((LPBC)&pTG->Inst.SendParams, sizeof(pTG->Inst.SendParams),
                                        rgchID, _fstrlen(rgchID), TEXTCODE_ASCII);
        }

        // RSL BUGBUG this should be set from fax UI
        ////////////////////////////////////////////

        pTG->Inst.awfi.Encoding = ENCODE_CAPS;  // MR_DATA | MH_DATA;
        if (! pTG->SrcHiRes) {
            pTG->Inst.awfi.AwRes = 0;
        }
        else {
            pTG->Inst.awfi.AwRes = CAPS_RES;  // AWRES_200_200;
        }


////////////// Width, Length, Res & Enc /////////////////////////////


        /////// Encoding ///////

        BG_CHK(pTG->Inst.RemoteRecvCaps.Fax.Encoding && pTG->Inst.RemoteRecvCaps.Fax.Encoding < 8);
        // this next BG_CHK seems bogus...?
        // BG_CHK(pTG->Inst.ProtParams.fDisableECM ? (!(pTG->Inst.RemoteRecvCaps.Fax.Encoding & MMR_DATA)) : 1);

        BG_CHK(INST_ENCODING && INST_ENCODING < 8);
        BG_CHK(BestEncoding[INST_ENCODING] == INST_ENCODING); // check just 1 bit set


#define  SEND_RECODE_TO     INST_ENCODING


        // If pTG->Inst.fDisableG3ECM, we will refuse to send MMR
        if (pTG->Inst.fDisableG3ECM && (pTG->Inst.RemoteRecvCaps.Fax.Encoding & MMR_DATA))
        {
                (MyDebugPrint(pTG,  LOG_ERR, "<WARNING> - fDisableG3ECM => NOT using MMR\r\n"));
                pTG->Inst.RemoteRecvCaps.Fax.Encoding &= ~MMR_DATA;
        }

        if(!(pTG->Inst.SendParams.Fax.Encoding =
                        BestEncoding[(INST_ENCODING | SEND_RECODE_TO) &
                                pTG->Inst.RemoteRecvCaps.Fax.Encoding]))
        {
                // No matching Encoding not supported
                (MyDebugPrint(pTG,  LOG_ERR,  "Negotiation failed: SendEnc %d CanRecodeTo %d RecvCapsEnc %d. No match\r\n",
                                INST_ENCODING, SEND_RECODE_TO, pTG->Inst.RemoteRecvCaps.Fax.Encoding));
                SetFailureCode(pTG, T30FAILS_NEGOT_ENCODING);
                goto error;
        }



        // check just 1 bit set
        BG_CHK(BestEncoding[pTG->Inst.SendParams.Fax.Encoding]  ==
                         pTG->Inst.SendParams.Fax.Encoding);
        BG_CHK(pTG->Inst.SendParams.Fax.Encoding == INST_ENCODING);


        /////// Width ///////

        pTG->Inst.RemoteRecvCaps.Fax.PageWidth &= 0x0F;      // castrate all A5/A6 widths
        if(INST_PAGEWIDTH > 0x0F)
        {
                // A5 or A6. Can quit or send as A4
                // INST_PAGEWIDTH = WIDTH_A4;
                (MyDebugPrint(pTG,  LOG_ERR,  "Negotiation failed: A5/A6 images not supported\r\n"));
                SetFailureCode(pTG, T30FAILS_NEGOT_A5A6);
                goto error;
        }

        if(pTG->Inst.RemoteRecvCaps.Fax.PageWidth < INST_PAGEWIDTH)
        {
                // or do some scaling
                (MyDebugPrint(pTG,  LOG_ERR,  "Negotiation failed: Image too wide\r\n"));
                SetFailureCode(pTG, T30FAILS_NEGOT_WIDTH);
                goto error;
        }
        else
                pTG->Inst.SendParams.Fax.PageWidth = INST_PAGEWIDTH;

        /////// Length ///////

        if(pTG->Inst.RemoteRecvCaps.Fax.PageLength < INST_PAGELENGTH)
        {
                (MyDebugPrint(pTG,  LOG_ERR,  "Negotiation failed: Image too long\r\n"));
                SetFailureCode(pTG, T30FAILS_NEGOT_LENGTH);
                goto error;
        }
        else
                pTG->Inst.SendParams.Fax.PageLength = INST_PAGELENGTH;

        /////// Res ///////

        // pick best resolution
        pTG->Inst.HorizScaling = 0;
        pTG->Inst.VertScaling = 0;

        // test scaling to NORMAL
        // pTG->Inst.RemoteRecvCaps.Fax.AwRes = AWRES_mm080_038;

        Res = (USHORT) (INST_RESOLUTION & pTG->Inst.RemoteRecvCaps.Fax.AwRes);
        if(Res) // send native
                pTG->Inst.SendParams.Fax.AwRes = Res;
        else
        {
                BG_CHK(INST_RESOLUTION != AWRES_mm080_038);
                BG_CHK(pTG->Inst.RemoteRecvCaps.Fax.AwRes & AWRES_mm080_038);

                switch(INST_RESOLUTION)
                {
                case AWRES_mm160_154:
                        if(AWRES_400_400 & pTG->Inst.RemoteRecvCaps.Fax.AwRes)
                        {
                                pTG->Inst.SendParams.Fax.AwRes = AWRES_400_400;
                        }

                        else
                        {
                                (MyDebugPrint(pTG,  LOG_ERR,  "Negotiation failed: 16x15.4 image and no horiz scaling\r\n"));
                                SetFailureCode(pTG, T30FAILS_NEGOT_RES);
                                goto error;
                        }

                        break;

                case AWRES_mm080_154:
#ifdef VS
                        if(pTG->Inst.SendParams.Fax.Encoding == MMR_DATA)
#endif //VS
                        {
                                (MyDebugPrint(pTG,  LOG_ERR,  "Negotiation failed: 8x15.4 image and no vert scaling\r\n"));
                                SetFailureCode(pTG, T30FAILS_NEGOT_RES);
                                goto error;
                        }
#ifdef VS
                        if(AWRES_mm080_077 & pTG->Inst.RemoteRecvCaps.Fax.AwRes)
                        {
                                pTG->Inst.SendParams.Fax.AwRes = AWRES_mm080_077;
                                pTG->Inst.VertScaling = 2;
                        }
                        else if(AWRES_200_200 & pTG->Inst.RemoteRecvCaps.Fax.AwRes)
                        {
                                pTG->Inst.SendParams.Fax.AwRes = AWRES_200_200;
                                pTG->Inst.VertScaling = 2;
                        }
                        else
                        {
                                pTG->Inst.SendParams.Fax.AwRes = AWRES_mm080_038;
                                pTG->Inst.VertScaling = 4;
                        }
#endif //VS
                        break;

                case AWRES_mm080_077:
                        if(AWRES_200_200 & pTG->Inst.RemoteRecvCaps.Fax.AwRes)
                        {
                                pTG->Inst.SendParams.Fax.AwRes = AWRES_200_200;
                        }
#ifdef VS
                        else if(pTG->Inst.SendParams.Fax.Encoding == MMR_DATA)
#else //VS
                        else
#endif //VS
                        {
                                (MyDebugPrint(pTG,  LOG_ERR,  "Negotiation failed: 8x7.7 image and no vert scaling\r\n"));
                                SetFailureCode(pTG, T30FAILS_NEGOT_RES);
                                goto error;
                        }
#ifdef VS
                        else
                        {
                                pTG->Inst.SendParams.Fax.AwRes = AWRES_mm080_038;
                                pTG->Inst.VertScaling = 2;
                        }
#endif //VS
                        break;

                case AWRES_400_400:
                        if(AWRES_mm160_154 & pTG->Inst.RemoteRecvCaps.Fax.AwRes)
                        {
                                pTG->Inst.SendParams.Fax.AwRes = AWRES_mm160_154;
                        }

                        else
                        {
                                (MyDebugPrint(pTG,  LOG_ERR,  "Negotiation failed: 400dpi image and no horiz scaling\r\n"));
                                SetFailureCode(pTG, T30FAILS_NEGOT_RES);
                                goto error;
                        }

                        break;

                case AWRES_300_300:

                        {
                                (MyDebugPrint(pTG,  LOG_ERR,  "Negotiation failed: 300dpi image and no non-integer scaling\r\n"));
                                SetFailureCode(pTG, T30FAILS_NEGOT_RES);
                                goto error;
                        }
                        break;

                case AWRES_200_200:
                        if(AWRES_mm080_077 & pTG->Inst.RemoteRecvCaps.Fax.AwRes)
                        {
                                pTG->Inst.SendParams.Fax.AwRes = AWRES_mm080_077;
                        }
#ifdef VS
                        else if(pTG->Inst.SendParams.Fax.Encoding == MMR_DATA)
#else //VS
                        else
#endif //VS
                        {
                                (MyDebugPrint(pTG,  LOG_ERR,  "Negotiation failed: 200dpi image and no vert scaling\r\n"));
                                SetFailureCode(pTG, T30FAILS_NEGOT_RES);
                                goto error;
                        }
#ifdef VS
                        else
                        {
                                pTG->Inst.SendParams.Fax.AwRes = AWRES_mm080_038;
                                pTG->Inst.VertScaling = 2;
                        }
#endif //VS
                        break;

                default:
                        BG_CHK(FALSE);
                }
        }

#ifdef VS
        if(pTG->Inst.VertScaling)
        {
                BG_CHK(pTG->Inst.SendParams.Fax.Encoding != MMR_DATA);
                //RSL InitVertScale(pTG->Inst.VertScaling);
        }
#endif //VS


        (MyDebugPrint(pTG,  LOG_ALL,  "Negotiation Succeeded: Res=%d PageWidth=%d Len=%d Enc=%d HSc=%d VSc=%d HSc3=%d VSc3=%d\r\n",
                        pTG->Inst.SendParams.Fax.AwRes, pTG->Inst.SendParams.Fax.PageWidth, pTG->Inst.SendParams.Fax.PageLength,
                        pTG->Inst.SendParams.Fax.Encoding, pTG->Inst.HorizScaling, pTG->Inst.VertScaling,
                        pTG->Inst.HorizScaling300dpi, pTG->Inst.VertScaling300dpi));
        return TRUE;


error:
        return FALSE;
}


void InitCapsBC(PThrdGlbl pTG, LPBC lpbc, USHORT uSize, BCTYPE bctype)
{
        memset(lpbc, 0, uSize);
        lpbc->bctype = bctype;
        // They should be set. This code here is correct--arulm
        // +++ Following three lines are not in pcfax11
        lpbc->wBCSize = sizeof(BC);
        lpbc->wBCVer = VER_AWFXPROT100;
        lpbc->wTotalSize = sizeof(BC);

        lpbc->Std.GroupNum              = GROUPNUM_STD;
        lpbc->Std.GroupLength   = sizeof(BCSTD);
        lpbc->Std.vMsgProtocol  = vMSG_WIN95;
        lpbc->Std.fBinaryData   = TRUE;
//      lpbc->Std.fInwardRouting        = FALSE;

        // NOSECURITY is defined for France build etc.
        lpbc->Std.vSecurity             = 0;

        lpbc->Std.OperatingSys  = OS_WIN16;
//      lpbc->Std.vShortFlags   = 0;
//      lpbc->Std.vInteractive  = 0;
//      lpbc->Std.DataSpeed             = 0;
//      lpbc->Std.DataLink              = 0;


//      lpbc->Fax.fPublicPoll = 0;
        if (! pTG->SrcHiRes) {
            lpbc->Fax.AwRes = 0;
        }
        else {
            lpbc->Fax.AwRes = CAPS_RES;
        }

        lpbc->Fax.Encoding      = ENCODE_CAPS;

        if (0) // RSL (pTG->Inst.fDisableMRRecv)
        {
                ERRMSG(( SZMOD "<<WARNING>> Disabling MR Receive capability\r\n"));
                lpbc->Fax.Encoding      &= ~MR_DATA;
        }
        lpbc->Fax.PageWidth     = CAPS_WIDTH;           // can be upto A3
        lpbc->Fax.PageLength    = LENGTH_UNLIMITED;

        lpbc->Image.GroupNum            = GROUPNUM_IMAGE;
        lpbc->Image.GroupLength = sizeof(BCIMAGE);
        lpbc->Image.vRamboVer           = vRAMBO_VER1;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\main\recv.c ===
/***************************************************************************
 Name     :     RECV.C
 Comment  :     Receiver functions

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/

#include "prep.h"


#include <comdevi.h>
#include <faxcodec.h>

#include "efaxcb.h"

//#include "debug.h"

#include "cas.h"
#include "bgt30.h"
//#include "dynload.h"

#include "awg3file.h"


#include "glbproto.h"
#include "t30gl.h"


#define         faxTlog(m)              DEBUGMSG(ZONE_RECV, m);

#define RINGIGNORE_TIMEOUT      60000L
#define RINGINACTIVITY_TIMEOUT  15000L






BOOL   ICommRecvParams(PThrdGlbl pTG, LPBC lpBC)
{
        BOOL    fLin;
        BOOL    fRet = FALSE;


        BG_CHK(lpBC);
        BG_CHK(lpBC->bctype == RECV_PARAMS);
        BG_CHK(lpBC->wTotalSize>=sizeof(BC));
        BG_CHK(lpBC->wTotalSize<=sizeof(pTG->Inst.RecvParams));

        if (pTG->fAbortRequested) {
            MyDebugPrint(pTG, LOG_ALL, "ICommRecvParams. got ABORT at %ld", GetTickCount() );
            fRet = FALSE;
            goto mutexit;
        }

        if(pTG->Inst.fAbort) // RecvParams
        {
                fRet = FALSE;
                goto mutexit;
        }

        if(pTG->Inst.state != BEFORE_RECVPARAMS)
        {
                // this will break if we send EOM...
                // then we should go back into RECV_CAPS state
                fRet = TRUE;
                goto mutexit;
        }

        _fmemset(&pTG->Inst.RecvParams, 0, sizeof(pTG->Inst.RecvParams));
        _fmemcpy(&pTG->Inst.RecvParams, lpBC, min(sizeof(pTG->Inst.RecvParams), lpBC->wTotalSize));

        // first try EFAX, then IFAX then G3
        // pTG->Inst.fG3 = FALSE;
        BG_CHK(lpBC->Std.GroupNum == 0);
        BG_CHK(lpBC->Std.GroupLength <= sizeof(BCHDR));

        if( lpBC->NSS.GroupNum == GROUPNUM_NSS &&
                lpBC->NSS.GroupLength >= sizeof(BCHDR) &&
                lpBC->NSS.vMsgProtocol != 0)
        {
                /***
                if(!lpBC->NSS.fBinaryData)      // vMsgProtocol != 0 && Binary
                {
                        pTG->Inst.szFile[9]='I';     pTG->Inst.szFile[10]='F'; pTG->Inst.szFile[11]='X';
                        fLin=TRUE;
                }
                else
                ***/
                // on recv don't know if binary files or not, so always assume
                {
                        pTG->Inst.szFile[9]='E';     pTG->Inst.szFile[10]='F'; pTG->Inst.szFile[11]='X';
                        fLin=TRUE;
                }
        }
        else    // not Msg Protocol must be G3
        {
                BG_CHK(lpBC->NSS.vMsgProtocol == 0);
                pTG->Inst.szFile[9]='M';     pTG->Inst.szFile[10]='G'; pTG->Inst.szFile[11]='3';
                fLin = FALSE;
        }

        wsprintf(pTG->Inst.szPath, "%s%s", (LPSTR)pTG->Inst.szFaxDir, (LPSTR)pTG->Inst.szFile);

        // make sure we don't have a file already open

        pTG->Inst.cbPage = 0;


#ifdef CHK
        pTG->Inst.fRecvChecking = FALSE;
#endif // CHK

        pTG->Inst.uNumBadPages = 0;
        BG_CHK(pTG->Inst.fReceiving || (!pTG->Inst.fReceiving));  ///RSL && uMyListen==2));
        pTG->Inst.fReceiving = TRUE; // we now do this in FileT30Answer as well...


       // BCtoAWFI(lpBC, &pTG->Inst.awfi);
       // WriteFileHeader(pTG->Inst.hfile, &pTG->Inst.awfi, fLin);
        pTG->Inst.awfi.fLin = fLin != FALSE;

        pTG->Inst.state = RECVDATA_BETWEENPAGES;
        fRet = TRUE;
        // fall through


mutexit:
        return fRet;
}






void   ICommGotDisconnect(PThrdGlbl pTG)
{

    //    faxTlog((SZMOD "GotDisconnect\r\n"));


}






void   ICommSetRecvMode(PThrdGlbl pTG, BOOL fECM)
{

    //    faxTlog((SZMOD "SetRecvMode fECM=%d\r\n", fECM));

}









USHORT   ICommGetRecvPageAck(PThrdGlbl pTG, BOOL fSleep)
{
        USHORT uRet = 2;

      //  ENTER_EFAXRUN_MUTEX;

    // error == 2
       // faxTlog((SZMOD "GetRecvPageAck = %d\r\n", pTG->Inst.uRecvPageAck));
        uRet = pTG->Inst.uRecvPageAck;

//mutexit:
        //EXIT_EFAXRUN_MUTEX;
        return uRet;
}










BOOL   ICommPutRecvBuf(PThrdGlbl pTG, LPBUFFER lpbf, SLONG slOffset)
{
        /**
                slOffset == RECV_STARTBLOCK     marks beginning of new block
                slOffset == RECV_STARTPAGE      marks beginning of new block *and* page
                slOffset == RECV_ENDPAGE        marks end of page
                slOffset == RECV_ENDDOC         marks end of document (close file etc.)
                (for all above no data supplied -- i.e lpbf == 0)

                slOffset == RECV_SEQ    means put buffer at current file position
                slOffset >= 0   gives the offset in bytes from the last marked position
                                                (beginning of block) to put buffer

                pTG->Inst.cbBlockStart is always the file offset of start of current block
                pTG->Inst.cbBlockSize and cbPage are only used fro debugging
        **/

        BOOL    fRet = TRUE;
        DWORD   BytesWritten;
        DWORD   NumHandles=2;
        HANDLE  HandlesArray[2];
        DWORD   WaitResult = WAIT_TIMEOUT;
        CHAR    Buffer[DECODE_BUFFER_SIZE];
        BOOL    fEof;
        DWORD   BytesToRead;
        DWORD   BytesHaveRead;
        DWORD   BytesLeft;


        HandlesArray[0] = pTG->AbortReqEvent;

        switch (slOffset)
        {
                case RECV_STARTBLOCK:
                        MyDebugPrint(pTG, LOG_ALL, "ICommPutRecvBuf called. Reason: RECV_STARTBLOCK\r\n");
                        break;
                case RECV_STARTPAGE:
                        MyDebugPrint(pTG, LOG_ALL, "ICommPutRecvBuf called. Reason: RECV_STARTPAGE\r\n");
                        break;
                case RECV_ENDPAGE:
                        MyDebugPrint(pTG, LOG_ALL, "ICommPutRecvBuf called. Reason: RECV_ENDPAGE\r\n");
                        break;
                case RECV_ENDDOC:
                        MyDebugPrint(pTG, LOG_ALL, "ICommPutRecvBuf called. Reason: RECV_ENDDOC\r\n");
                        break;
                default:
                        break;
        }


        if(slOffset==RECV_ENDPAGE || slOffset==RECV_ENDDOC)
        {
                BG_CHK(pTG->Inst.state == RECVDATA_PHASE);
                BG_CHK(lpbf == 0);

                pTG->Inst.uRecvPageAck = TRUE;


                //SetStatus((pTG->Inst.uRecvPageAck ? T30STATR_CONFIRM : T30STATR_REJECT), pTG->Inst.awfi.uNumPages, 0, 0);

                //////////// moved to ICommGetRecvPageAck() callback ////////////
                //      if(pTG->Inst.uModemClass==FAXCLASS1 || pTG->Inst.uModemClass == FAXCLASS0)
                //      {
                //              LPFNCHK(lpfnET30ProtRecvPageAck);
                //              lpfnET30ProtRecvPageAck(pTG->Inst.uRecvPageAck);
                //      }
                //      else
                //////////// moved to ICommGetRecvPageAck() callback ////////////

#if defined(CL2) || defined(CL2_0)
                //////////// moved to ICommGetRecvPageAck() callback ////////////
                //      if(pTG->Inst.uModemClass==FAXCLASS2 || pTG->Inst.uModemClass==FAXCLASS2_0)
                //      {
                //              LPFNCHK(lpfnClass2RecvPageAck);
                //              lpfnClass2RecvPageAck(pTG->Inst.uRecvPageAck);
                //      }
                ////////////// moved to ICommGetRecvPageAck() callback ////////////
#endif //CL2


                //here we need to wait until helper thread finishes with the page

                if (! pTG->fPageIsBad) {
                    MyDebugPrint(pTG, LOG_ALL, "RECV: EOP. Not bad yet. Start waiting for Rx_thrd to finish at %ld\n",
                                 GetTickCount() );


                    HandlesArray[1] = pTG->ThrdDoneSignal;

                    if ( ( WaitResult = WaitForMultipleObjects(NumHandles, HandlesArray, FALSE, RX_ACK_THRD_TIMEOUT) ) == WAIT_TIMEOUT) {
                        pTG->fPageIsBad = 1;
                        MyDebugPrint(pTG, LOG_ALL, "RECV: ERROR. EOP. Never waked up by Rx_thrd at %ld\n", GetTickCount() );
                    }
                    else {
                        MyDebugPrint(pTG, LOG_ALL, "RECV: EOP. Waked up by Rx_thrd at %ld\n", GetTickCount() );
                    }
                }

                if (WaitResult == WAIT_OBJECT_0) {
                    (MyDebugPrint(pTG,  LOG_ALL, "RECV: wait for next page ABORTED at %ld \n", GetTickCount() ) );

                    if (pTG->InFileHandleNeedsBeClosed) {
                        CloseHandle(pTG->InFileHandle);
                        pTG->InFileHandleNeedsBeClosed = 0;
                    }

                    return FALSE;
                }

                //
                // If page is good then write it to a TIFF file.
                //

                if (! pTG->fPageIsBad) {

                    if ( ! TiffStartPage( (HANDLE) pTG->Inst.hfile ) ) {
                        MyDebugPrint(pTG, LOG_ERR,  "RECV: ERROR TiffStartPage failed\r\n");

                        if (pTG->InFileHandleNeedsBeClosed) {
                            CloseHandle(pTG->InFileHandle);
                            pTG->InFileHandleNeedsBeClosed = 0;
                        }

                        return FALSE;
                    }

                    if ( SetFilePointer(pTG->InFileHandle, 0, NULL, FILE_BEGIN) == 0xffffffff ) {
                        MyDebugPrint(pTG, LOG_ERR,  "RECV: ERROR SetFilePointer failed le=%ld\r\n", GetLastError() );

                        if (pTG->InFileHandleNeedsBeClosed) {
                            CloseHandle(pTG->InFileHandle);
                            pTG->InFileHandleNeedsBeClosed = 0;
                        }

                        return FALSE;
                    }

                    fEof = 0;
                    BytesLeft = pTG->BytesIn;

                    while (! fEof) {

                        if (BytesLeft <= DECODE_BUFFER_SIZE) {
                            BytesToRead = BytesLeft;
                            fEof = 1;
                        }
                        else {
                            BytesToRead = DECODE_BUFFER_SIZE;
                            BytesLeft  -= DECODE_BUFFER_SIZE;
                        }

                        if (! ReadFile(pTG->InFileHandle, Buffer, BytesToRead, &BytesHaveRead, NULL ) ) {
                            MyDebugPrint(pTG, LOG_ERR,  "RECV: ERROR ReadFile failed le=%ld\r\n", GetLastError() );

                            if (pTG->InFileHandleNeedsBeClosed) {
                                CloseHandle(pTG->InFileHandle);
                                pTG->InFileHandleNeedsBeClosed = 0;
                            }

                            return FALSE;
                        }

                        if (BytesToRead != BytesHaveRead) {
                            MyDebugPrint(pTG, LOG_ERR,  "RECV: ERROR ReadFile have read=%d wanted=%d\n", BytesHaveRead, BytesToRead);

                            if (pTG->InFileHandleNeedsBeClosed) {
                                CloseHandle(pTG->InFileHandle);
                                pTG->InFileHandleNeedsBeClosed = 0;
                            }

                            return FALSE;
                        }

                        if (! TiffWriteRaw( (HANDLE) pTG->Inst.hfile, Buffer, BytesToRead ) ) {
                            MyDebugPrint(pTG, LOG_ERR,  "RECV: ERROR TiffWriteRaw failed \n");

                            if (pTG->InFileHandleNeedsBeClosed) {
                                CloseHandle(pTG->InFileHandle);
                                pTG->InFileHandleNeedsBeClosed = 0;
                            }

                            return FALSE;
                        }

                        MyDebugPrint(pTG, LOG_ALL,  "RECV: TiffWriteRaw done \n");

                    }

                    pTG->PageCount++;

                    MyDebugPrint(pTG, LOG_ALL, "Calling TiffEndPage page=%d bytes=%d \n", pTG->PageCount, pTG->BytesIn);

                    if (! TiffEndPage( (HANDLE) pTG->Inst.hfile ) ) {
                        MyDebugPrint(pTG, LOG_ERR,  "RECV: ERROR TiffEndPage failed \n");

                        if (pTG->InFileHandleNeedsBeClosed) {
                            CloseHandle(pTG->InFileHandle);
                            pTG->InFileHandleNeedsBeClosed = 0;
                        }

                        return FALSE;
                    }

                }


                if (pTG->InFileHandleNeedsBeClosed) {
                    CloseHandle(pTG->InFileHandle);
                    pTG->InFileHandleNeedsBeClosed = 0;
                }



                if(slOffset == RECV_ENDDOC)
                {
                        // if page was bad, mark it so in the return value for this call
                        // (otherwise EFAXPUMP will not display "above received fax contains
                        // errors). This is will only work if last page is bad. To be more
                        // accurate we should count the bad pages and if they are non-zero
                        // we should mark the recvd document as CALLFAIL.

#if 0
                    if (glSimulateError && (glSimulateErrorType == SIMULATE_ERROR_RX_IO) ) {
                        SimulateError( EXCEPTION_ACCESS_VIOLATION);
                    }
#endif

                        MyDebugPrint(pTG, LOG_ALL, "Calling TiffClose\r\n");

                        if ( pTG->fTiffOpenOrCreated ) {
                            TiffClose( (HANDLE) pTG->Inst.hfile );
                            pTG->fTiffOpenOrCreated = 0;
                        }

                        // request Rx_thrd to terminate itself.
                        pTG->ReqTerminate = 1;
                        SetEvent(pTG->ThrdSignal);

                        pTG->Inst.state = BEFORE_RECVPARAMS;

                }
                else
                        pTG->Inst.state = RECVDATA_BETWEENPAGES;

        }
        else if(slOffset == RECV_STARTPAGE)
        {
                // Fax Server wants to know when we start RX new page
                SignalStatusChange(pTG, FS_RECEIVING);

                BG_CHK(pTG->Inst.state == RECVDATA_BETWEENPAGES);
                BG_CHK(lpbf == 0);

                pTG->Inst.cbPage = 0;
                pTG->Inst.cbBlockSize = 0;
                pTG->Inst.state = RECVDATA_PHASE;
                pTG->Inst.awfi.lDataSize = 0;
                // awfi.lNextHeaderOffset here points to current header (starts at ptr to first pageheader in BCtoAWFI)
                // awfi.lDataOffset set to point to the actual data. NOT the count DWORD
                pTG->Inst.awfi.lDataOffset = pTG->Inst.awfi.lNextHeaderOffset + sizeof(AWG3HEADER) + 4;
                pTG->Inst.awfi.uNumPages++;

                ///ICommStatus(T30STATR_RECV, pTG->Inst.awfi.uNumPages, 0, 0);
                ///lOldRecvCount = 0;

                if( pTG->Inst.RecvParams.NSS.vMsgProtocol == 0 && // G3
                        pTG->Inst.RecvParams.Fax.Encoding != MMR_DATA &&      // MH or MR only
                        pTG->Inst.uCopyQualityCheckLevel)
                {

                        // For Recvd T4 checking
                        BG_CHK((pTG->Inst.RecvParams.Fax.Encoding == MH_DATA) ||
                                         (pTG->Inst.RecvParams.Fax.Encoding == MR_DATA));
                        BG_CHK(pTG->Inst.RecvParams.Fax.PageWidth <= WIDTH_MAX);
                        // +++ 4/25/95 JosephJ WARNING -- we could be doing ecm-MH or
                        // ecm-MR, so we really need to check if we're receiving ECM or
                        // not. Unfortunately this information is currently not propogated
                        // back up from T.30 and it's too late to that -- so (HACK)
                        // we enable receive-checking here, but disable it later
                        // if we get a RECV_STARTBLOCK or a >=0 lsOffset (later indicates
                        // a resend. The proper fix for this is to propogate the
                        // fact that we're doing ecm up from t.30.

                }


                // seek to right place, write out enough space for header
                // and place file ptr in the right place to write data


                //
                // start Helper thread once per RX session
                //

                if (!pTG->fTiffThreadCreated) {
                    USHORT    uEnc;
                    DWORD     TiffConvertThreadId;

                    if (pTG->ModemClass != MODEM_CLASS1) {
                        if (pTG->Encoding == MR_DATA) {
                          pTG->TiffConvertThreadParams.tiffCompression =  TIFF_COMPRESSION_MR;
                        }
                        else {
                          pTG->TiffConvertThreadParams.tiffCompression =  TIFF_COMPRESSION_MH;
                        }

                        if (pTG->Resolution & (AWRES_mm080_077 |  AWRES_200_200) ) {
                          pTG->TiffConvertThreadParams.HiRes = 1;
                        }
                        else {
                          pTG->TiffConvertThreadParams.HiRes = 0;
                        }
                    }
                    else {

                        uEnc = ProtGetRecvEncoding(pTG);
                        BG_CHK(uEnc==MR_DATA || uEnc==MH_DATA);
                       
                        if (uEnc == MR_DATA) {
                            pTG->TiffConvertThreadParams.tiffCompression =  TIFF_COMPRESSION_MR;
                        }
                        else {
                            pTG->TiffConvertThreadParams.tiffCompression =  TIFF_COMPRESSION_MH;
                        }
                       
                        if (pTG->ProtInst.RecvParams.Fax.AwRes & (AWRES_mm080_077 |  AWRES_200_200) ) {
                            pTG->TiffConvertThreadParams.HiRes = 1;
                        }
                        else {
                            pTG->TiffConvertThreadParams.HiRes = 0;
                        }
                    }

                    _fmemcpy (pTG->TiffConvertThreadParams.lpszLineID, pTG->lpszPermanentLineID, 8);
                    pTG->TiffConvertThreadParams.lpszLineID[8] = 0;

                    (MyDebugPrint(pTG,  LOG_ALL, "RECV: Creating TIFF helper thread  comp=%d res=%d at %ld \n", 
                                        pTG->TiffConvertThreadParams.tiffCompression, 
                                        pTG->TiffConvertThreadParams.HiRes,
                                        GetTickCount() ) );

                    pTG->hThread = CreateThread(
                                  NULL,
                                  0,
                                  (LPTHREAD_START_ROUTINE) PageAckThreadSafe,
                                  (LPVOID) pTG,
                                  0,
                                  &TiffConvertThreadId
                                  );

                    if (!pTG->hThread) {
                        (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> TiffConvertThread create FAILED\r\n"));
                        return FALSE;
                    }

                    pTG->fTiffThreadCreated = 1;
                    pTG->AckTerminate = 0;
                    pTG->fOkToResetAbortReqEvent = 0;

                    if ( (pTG->RecoveryIndex >=0 ) && (pTG->RecoveryIndex < MAX_T30_CONNECT) ) {
                        T30Recovery[pTG->RecoveryIndex].TiffThreadId = TiffConvertThreadId;
                        T30Recovery[pTG->RecoveryIndex].CkSum = ComputeCheckSum(
                                                                        (LPDWORD) &T30Recovery[pTG->RecoveryIndex].fAvail,
                                                                        sizeof ( T30_RECOVERY_GLOB ) / sizeof (DWORD) - 1 );

                    }

                }

                _fmemcpy (pTG->InFileName, gT30.TmpDirectory, gT30.dwLengthTmpDirectory);
                _fmemcpy (&pTG->InFileName[gT30.dwLengthTmpDirectory], pTG->TiffConvertThreadParams.lpszLineID, 8);
                sprintf  (&pTG->InFileName[gT30.dwLengthTmpDirectory+8], "%s", ".RX");

                DeleteFileA(pTG->InFileName);

                if ( ( pTG->InFileHandle = CreateFileA(pTG->InFileName, GENERIC_WRITE | GENERIC_READ, FILE_SHARE_READ,
                                           NULL, OPEN_ALWAYS, 0, NULL) ) == INVALID_HANDLE_VALUE ) {

                    (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> RECV: Create file %s FAILED le=%lx\n"), GetLastError() );
                    return FALSE;
                }

                pTG->InFileHandleNeedsBeClosed = 1;

                // Reset control data for the new page ack, interface
                pTG->fLastReadBlock = 0;
                pTG->BytesInNotFlushed = 0;
                pTG->BytesIn = 0;
                pTG->BytesOut = 0;
                pTG->fPageIsBad = 0;
                ResetEvent(pTG->ThrdDoneSignal);

                // get current offset
///                pTG->Inst.cbBlockStart = DosSeek(pTG->Inst.hfile, 0, 1);
        }
        else if(slOffset == RECV_STARTBLOCK)
        {
                BG_CHK(pTG->Inst.state == RECVDATA_PHASE);
                BG_CHK(lpbf == 0);
#ifdef CHK
                BG_CHK(!pTG->Inst.fRecvChecking); // MUST NOT have Recv Checking in ECM
                // Above check will fail if encoding is MH or MR -- see
                // 4/25/95 JosephJ WARNING above -- we have a workaround -- see below
                // if (slOffset>=0)
#endif

                // seek to end of file (we may be arbitrarily in the middle)
                // and get file pos
///             pTG->Inst.cbBlockStart = DosSeek(pTG->Inst.hfile, 0, 2);
                pTG->Inst.cbBlockSize = 0;
        }
        else if(slOffset >= 0)
        {
                BG_CHK(pTG->Inst.state == RECVDATA_PHASE);
#if 0 //RSL ifdef CHK
                if (pTG->Inst.fRecvChecking)
                {
                        BG_CHK((pTG->Inst.RecvParams.Fax.Encoding == MH_DATA) ||
                                         (pTG->Inst.RecvParams.Fax.Encoding == MR_DATA));
                        // +++ Above should be BG_CHK(FALSE), but see
                        // 4/25/95 JosephJ WARNING above.
                        MyDebugPrint(pTG, LOG_ALL, "<<WARNING>> Disabling RecvChecking for MH/MR ECM recv\r\n");
                        pTG->Inst.fRecvChecking=FALSE;
                }
#endif
                // This may not hold since we may not even have gotten the
                // whole block the first time around, so Size cannot be
                // accurately calculated
                // BG_CHK(slOffset <= pTG->Inst.cbBlockSize);
                BG_CHK(((ULONG)slOffset) <= (((ULONG)lpbf->wLengthData) << 8));
                if(slOffset >= pTG->Inst.cbBlockSize)
                {
                        pTG->Inst.cbPage += (long)lpbf->wLengthData;
                }

                MyFreeBuf(pTG, lpbf);
        }
        else if (slOffset == RECV_FLUSH) {
            if (! FlushFileBuffers (pTG->InFileHandle ) ) {
                MyDebugPrint(pTG, LOG_ALL, "ERROR: FlushFileBuffers FAILED LE=%lx at %ld \n",
                    GetLastError(), GetTickCount() );

                return FALSE;
            }

            MyDebugPrint(pTG, LOG_ALL, "RECV: ThrdSignal FLUSH at %ld \n", GetTickCount() );

            pTG->BytesIn = pTG->BytesInNotFlushed;

            if (! pTG->fPageIsBad) {
                SetEvent(pTG->ThrdSignal);
            }

            return TRUE;

        }
        else // if(slOffset == RECV_SEQ)
        {
                BG_CHK(pTG->Inst.state == RECVDATA_PHASE);
                BG_CHK(slOffset==RECV_SEQ || slOffset==RECV_SEQBAD);

                MyDebugPrint(pTG, LOG_ALL, "Write RAW Page ptr=%x; len=%d Time=%ld\r\n",
                            lpbf->lpbBegData, lpbf->wLengthData, GetTickCount() );


                if ( ! WriteFile( pTG->InFileHandle, lpbf->lpbBegData, lpbf->wLengthData, &BytesWritten, NULL ) ) {
                    MyDebugPrint(pTG, LOG_ALL, "ERROR: WriteFile FAILED %s ptr=%x; len=%d LE=%d Time=%ld\r\n",
                         pTG->InFileName, lpbf->lpbBegData, lpbf->wLengthData, GetLastError(), GetTickCount() );

                    return FALSE;
                }

                if (BytesWritten != lpbf->wLengthData) {
                    MyDebugPrint(pTG, LOG_ALL, "ERROR: WriteFile %s written ONLY %d ptr=%x; len=%d LE=%d Time=%ld\r\n",
                          pTG->InFileName, BytesWritten, lpbf->lpbBegData, lpbf->wLengthData, GetLastError(), GetTickCount() );

                    fRet = FALSE;
                    return fRet;
                }

                pTG->BytesInNotFlushed += BytesWritten;

                // control helper thread
                if ( (!pTG->fTiffThreadRunning) || (pTG->fLastReadBlock) ) {
                    if ( (pTG->BytesInNotFlushed - pTG->BytesOut > DECODE_BUFFER_SIZE) || (pTG->fLastReadBlock) ) {
                        if (! FlushFileBuffers (pTG->InFileHandle ) ) {
                            MyDebugPrint(pTG, LOG_ALL, "ERROR: FlushFileBuffers FAILED LE=%lx at %ld \n",
                                GetLastError(), GetTickCount() );

                            fRet = FALSE;
                            return fRet;
                        }


                        pTG->BytesIn = pTG->BytesInNotFlushed;

                        if (! pTG->fPageIsBad) {
                            MyDebugPrint(pTG, LOG_ALL, "RECV: ThrdSignal at %ld \n", GetTickCount() );
                            pTG->fTiffThreadRunning = 1;
                            SetEvent(pTG->ThrdSignal);
                        }

                    }
                }


                pTG->Inst.cbPage += (long)lpbf->wLengthData;
                pTG->Inst.cbBlockSize += lpbf->wLengthData;

                ///if((pTG->Inst.cbPage - lOldRecvCount) >= 4000)
                {
                        ///USHORT usKB = (USHORT) (LongShr8(pTG->Inst.cbPage) >> 2);
                        ///SetStatus(T30STATR_RECV, pTG->Inst.awfi.uNumPages, LOBYTE(usKB), HIBYTE(usKB));
                        ///lOldRecvCount = pTG->Inst.cbPage;
                }


#if 0 //RSL ifdef CHK
                if(pTG->Inst.fRecvChecking)
                {
                        // For Recvd  T4 checking
                        // why bother? He doesn't use it & it's 0 from startup time anyway...
                        // _fmemset(&bfDummy, 0, sizeof(BUFFER));
                        BG_CHK(lpfnFaxCodecConvert);
                        BG_CHK(lpT4Inst);
                        ///lpfnFaxCodecConvert(lpT4Inst, lpbf, &bfDummy);
                }
#endif //CHK

                MyFreeBuf(pTG, lpbf);
        }
        fRet = TRUE;



        return fRet;
}








LPBC   ICommGetBC(PThrdGlbl pTG, BCTYPE bctype, BOOL fSleep)
{
        LPBC    lpbc = NULL;

        BG_CHK(bctype==SEND_CAPS || bctype==SEND_PARAMS);

        if(bctype == SEND_CAPS)
        {
                BG_CHK(pTG->Inst.SendCaps.bctype == SEND_CAPS);
                lpbc = (LPBC)&pTG->Inst.SendCaps;
        }
        else
        {
#ifdef POLLREQ
                if(pTG->Inst.fInPollReq)
                {
                        BG_CHK(pTG->Inst.SendPollReq.bctype == SEND_POLLREQ);
                        lpbc = (LPBC)(&(pTG->Inst.SendPollReq));
                }
                else
#endif //POLLREQ
                {
                        BG_CHK(pTG->Inst.SendParams.bctype == SEND_PARAMS);
                        lpbc = (LPBC)(&(pTG->Inst.SendParams));
                }

                // in cases where DIS is received again after sending DCS-TCF,
                // this gets called multiple times & we need to return the same
                // SendParams BC each time
        }


        return lpbc;
}






BOOL   ICommRecvPollReq(PThrdGlbl pTG, LPBC lpBC)
{
        BOOL fRet = FALSE;

        return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\main\protocol.h ===
/***************************************************************************
 Name     :     PROTOCOL.H
 Comment  :     Data structure definitionc for protocol DLL

        Copyright (c) 1993 Microsoft Corp.

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/

#include <fr.h>
#include "oemint.h"

/************************************
        This structure is meant to track the Group-3 FIF for DIS and DTC
        frames. The FIF is arranged so that the bits are numbered from
        1 upward in teh order they are received. Since Modem/Comm
        behaviour puts received bits in a byte from low to high
        and the bytes into memory at increasing addresses, the bits
        need to run in memory from lowest bit of first byte through
        the highest bit and then on to the next address.

        Need to watch out for sudden reversal of the high-low order
        of bits and of bytes.

        The MS C7 compiler puts bit-fields into BYTES from low
        to high, so this should correspond. Don't change the BYTEs
        below to WORD as then we'll run into high-low byte flipping
        nonsense.

        If a bit-field crosses a byte boundary we're in trouble.
*************************************/

#define fsFreePtr(pTG, npfs)         ((npfs)->b + (npfs)->uFreeSpaceOff)
#define fsFreeSpace(pTG, npfs)       (sizeof((npfs)->b) - (npfs)->uFreeSpaceOff)
#define fsStart(pTG, npfs)           ((npfs)->b)
#define fsLim(pTG, npfs)                     (((npfs)->b) + sizeof((npfs)->b))
#define fsSize(pTG, npfs)            (sizeof((npfs)->b))


#define BAUD_MASK               0xF             // 4 bits wide
#define WIDTH_SHIFT             4               // next item must be 2^this
#define WIDTH_MASK              0xF3    // top 4 and bottom 3
#define LENGTH_MASK             0x3

#define MINSCAN_SUPER_HALF      8
#define MINSCAN_MASK    0xF                     // actually 4 bits wide too











#ifdef UECM
#       define  NONEFAXECM      1
#else
#       define  NONEFAXECM      0
#endif


#define ZeroRFS(pTG, lp)     _fmemset(lp, 0, sizeof(RFS))


/****************** begin prototypes from sendfr.c *****************/
VOID BCtoNSFCSIDIS(PThrdGlbl pTG, NPRFS npfs, NPBC npbc, NPLLPARAMS npll);
VOID BCtoNSCCIGDTC(PThrdGlbl pTG, NPRFS npfs, NPBC npbc, NPLLPARAMS npll);
// void CreateSEPPWDFrames(NPRFS npfs, NPBC npbc);
void CreateNSForNSCorNSS(PThrdGlbl pTG, IFR ifr, NPRFS npfs, NPBC npbc, BOOL fSendID);
void CreateIDFrame(PThrdGlbl pTG, IFR ifr, NPRFS npfs, LPSTR, BOOL fStrip);
void CreateDISorDTC(PThrdGlbl pTG, IFR ifr, NPRFS npfs, NPBCFAX npbcFax, NPLLPARAMS npll);
VOID CreateNSSTSIDCS(PThrdGlbl pTG, NPPROT npProt, NPRFS npfs, USHORT uWhichDCS);
VOID CreateNSS(PThrdGlbl pTG, NPRFS npfs, NPBCSTD npbcStd);
void CreateDCS(PThrdGlbl pTG, NPRFS, NPBCFAX npbcFax, NPLLPARAMS npll);
/***************** end of prototypes from sendfr.c *****************/


/****************** begin prototypes from recvfr.c *****************/
BOOL AwaitSendParamsAndDoNegot(PThrdGlbl pTG, BOOL fSleep);
void GotRecvCaps(PThrdGlbl pTG);
void GotPollReq(PThrdGlbl pTG);
void GotRecvParams(PThrdGlbl pTG);
void AddNumIdToBC(PThrdGlbl pTG, LPSTR szId, LPBC lpbc, USHORT uMaxSize, BOOL fForce);
/***************** end of prototypes from recvfr.c *****************/

/****************** begin prototypes from dis.c *****************/
USHORT SetupDISorDCSorDTC(PThrdGlbl pTG, NPDIS npdis, NPBCFAX npbcFax, NPLLPARAMS npll, BOOL fECM, BOOL f64);
void ParseDISorDCSorDTC(PThrdGlbl pTG, NPDIS npDIS, NPBCFAX npbcFax, NPLLPARAMS npll, BOOL fParams);
USHORT MinScanToBytesPerLine(PThrdGlbl pTG, BYTE Minscan, BYTE Baud);
void NegotiateLowLevelParams(PThrdGlbl pTG, NPLLPARAMS npllRecv, NPLLPARAMS npllSend, DWORD AwRes, USHORT uEnc, NPLLPARAMS npllNegot);
USHORT GetStupidReversedFIFs(PThrdGlbl pTG, LPSTR lpstr1, LPSTR lpstr2);
void CreateStupidReversedFIFs(PThrdGlbl pTG, LPSTR lpstr1, LPSTR lpstr2);
BOOL DropSendSpeed(PThrdGlbl pTG);
USHORT CopyFrame(PThrdGlbl pTG, LPBYTE lpbDst, LPFR lpfr, USHORT uSize);
void CopyRevIDFrame(PThrdGlbl pTG, LPBYTE lpbDst, LPFR lpfr);
void EnforceMaxSpeed(PThrdGlbl pTG);
/***************** end of prototypes from dis.c *****************/




/****************** begin prototypes from whatnext.c *****************/
ET30ACTION  __cdecl FAR WhatNext(PThrdGlbl pTG, ET30EVENT event,
                                                                WORD wArg1, DWORD lArg2, DWORD lArg3);
/***************** end of prototypes from whatnext.c *****************/


/****************** begin prototypes from protapi.c *****************/
void GetRecvPageAck(PThrdGlbl pTG);
/****************** end of prototypes from protapi.c *****************/

/****************** begin prototypes from oem.c *****************/
#ifdef OEMNSF
        WORD CreateOEMFrames(pTG, IFR ifr, WORD pos, NPBC npbcIn, NPLLPARAMS npllIn, NPRFS npfs);
#else
#       define CreateOEMFrames(pTG, ifr, pos, npbcIn, npllIn, npfs) (0)
#endif

/****************** end prototypes from oem.c *****************/


/**--------------------------- Debugging ------------------------**/

#define SZMOD                   "Eprot: "

#ifdef DEBUG
        extern DBGPARAM dpCurSettings;

#       define ZONE_PROTAPI             ((1L << 6) & dpCurSettings.ulZoneMask)
#       define ZONE_WHATNEXT    ((1L << 7) & dpCurSettings.ulZoneMask)
#       define ZONE_DIS                 ((1L << 8) & dpCurSettings.ulZoneMask)
#       define ZONE_RECVFR              ((1L << 9) & dpCurSettings.ulZoneMask)
#       define ZONE_SENDFR              ((1L << 10) & dpCurSettings.ulZoneMask)
#       define ZONE_OEM                 ((1L << 11) & dpCurSettings.ulZoneMask)
        extern void D_PrintBC(LPBC lpbc, LPSTR lpsz, LPLLPARAMS lpll);
#else
#       define D_PrintBC(x, y, z)
#endif



#define MODID                           MODID_AWT30

#define FILEID_DIS                      31
#define FILEID_PROTAPI          32
#define FILEID_RECVFR           33
#define FILEID_SENDFR           34
#define FILEID_WHATNEXT         35
#define FILEID_OEMNSF           36


#ifdef NSF_TEST_HOOKS

#       define BC_TO_NSX(pTG, _ifr, _npbc, _ptr, _wcb,  _lpw) \
                ((NSFTestGetNSx(pTG, _ifr, _npbc, _ptr, _wcb,  _lpw)) \
                 ? 0 : BCtoNSx(pTG, _ifr, _npbc, _ptr, _wcb,  _lpw))

#       define NSX_TO_BC(pTG, _ifr, _lpfr, _wcbfr, _npbc, _wcbBC)\
                (NSFTestPutNSx(pTG, _ifr, _lpfr, _wcbfr, _npbc,  _wcbBC), \
                 NSxtoBC(pTG, _ifr, _lpfr, _wcbfr, _npbc, _wcbBC))

        BOOL NSFTestGetNSx (PThrdGlbl pTG, IFR ifr, LPBC lpbcIn,
                                        LPBYTE lpbOut, WORD wMaxOut, LPWORD lpwNumFrame);
        BOOL NSFTestPutNSx(PThrdGlbl pTG, IFR ifr, LPLPFR rglpfr, WORD wNumFrame,
                                                LPBC lpbcOut, WORD wBCSize);

#else // !NSF_TEST_HOOKS

#       define BC_TO_NSX(pTG, _ifr, _npbc, _ptr, _wcb,  _lpw) \
                 BCtoNSx(pTG, _ifr, _npbc, _ptr, _wcb,  _lpw)

#       define NSX_TO_BC(pTG, _ifr, _lpfr, _wcbfr, _npbc, _wcbBC)\
                 NSxtoBC(pTG, _ifr, _lpfr, _wcbfr, _npbc, _wcbBC)

#endif // !NSF_TEST_HOOKS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\main\recvfr.c ===
/***************************************************************************
 Name     :     RECVFR.C
 Comment  :
 Functions:     (see Prototypes just below)

        Copyright (c) 1993 Microsoft Corp.

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/

#include "prep.h"


#include "efaxcb.h"

#include "protocol.h"

///RSL
#include "glbproto.h"



#define faxTlog(m)      DEBUGMSG(ZONE_RECVFR, m)
#define FILEID          FILEID_RECVFR






USHORT FindMSNSx(PThrdGlbl pTG, NPRFS npRecvd)
{
        USHORT  i;

        for(i=0; i<npRecvd->uNumFrames; i++)
        {
                BG_CHK(i < MAXFRAMES);
                if(IsAtWorkNSx(npRecvd->rglpfr[i]->fif, npRecvd->rglpfr[i]->cb))
                {
                        faxTlog((SZMOD "Found MS NSx!!\r\n"));
                        return i+1;
                }
        }
        return 0;
}





void GotRecvFrames(PThrdGlbl pTG, IFR ifr, NPRFS npRecvd, NPDIS npdis, LPBYTE lpbRecvdID,
                                        LPBYTE lpbRecipSubAddr, BCTYPE bctype, NPBC npbc, USHORT wBCSize,
                                        NPLLPARAMS npll)
{
        USHORT          uRet1=0, uRet2=0;

        InitBC(npbc, wBCSize, bctype);

        // RSL remove NSF processing.
        uRet1 = 0;

        if(npRecvd->uNumFrames) // recvd some NSXs
        {
                // scope out NSXs
                if(uRet1)                  // RSL = FindMSNSx(pTG, npRecvd))
                {
                        // found MS NSXs

                        BG_CHK((ifr!=ifrNSF) ? (pTG->ProtInst.llSendCaps.fECM && uRet1==1) : TRUE);
                        // if we got MS NSCs or NSSs then we must be able to do ECM
                        // and we can't get can't get other peoples NSSs/NSCs at same time

                        // setup BC first
                        npbc->bctype = bctype;

                        // all short ptrs into DGROUP get correctly cast to LPs we hope...
                        if(uRet2 = NSX_TO_BC(pTG, ifr, npRecvd->rglpfr, npRecvd->uNumFrames, npbc, wBCSize))
                        {
                                (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> got error %d parsing NSX\r\n", uRet2));
                                // forget we got an NSX
                                // zero out BC again
                                InitBC( npbc, wBCSize, bctype);
                                uRet1 = 0;
                        }
#ifndef NOCHALL
                        else
                        {
                                if(ifr==ifrNSF)
                                {
                                        USHORT uChallLen;
                                        // Poll challenge string is the first POLL_CHALLENGE_LEN
                                        // bytes (following the B5 00 76 signature) of the first
                                        // MS NSF _received_ or the whole thing if it is shorter
                                        // than that
                                        BG_CHK(npRecvd->rglpfr[uRet1-1]->cb > 3);
                                        uChallLen = min(npRecvd->rglpfr[uRet1-1]->cb-3, POLL_CHALLENGE_LEN);
                                        AppendToBCLen( npbc, wBCSize, npRecvd->rglpfr[uRet1-1]->fif+3,
                                                                uChallLen, wChallenge, wChallengeLen);
                                }
                                else if(ifr==ifrNSC)
                                {
                                        // for NSC append _our_ challenge string, i.e.
                                        // first POLL_CHALLENGE_LEN bytes (following the B5 00 76
                                        // signature) of the first MS NSF that _we_sent_out
                                        // or the whole thing if it is shorter than that

                                        AppendToBCLen(npbc, wBCSize, pTG->bSavedChallenge,
                                                pTG->uSavedChallengeLen, wChallenge, wChallengeLen);
                                }
                                // for NSS wChallenge==NULL
                        }
#endif //!NOCHALL
                }
#ifdef OEMNSF
                else if(wOEMFlags && lpfnOEMNSxToBC)
                {
#pragma message("WARNING: OEMNsxToBC: The code here for removing and restoring the FCS bytes hasn't been tested!!!")
                        USHORT uRet3;
         USHORT iFrame;
                        // OEM NSX DLL exists --> do something  for(iFrame=0; iFrame<wNumFrame; iFrame++)

              for(iFrame=0; iFrame < npRecvd->uNumFrames; iFrame++)
                      npRecvd->rglpfr[iFrame]->cb -= 2;     // Subtract 2 to lop off the FCS

                        if(!(uRet3 = lpfnOEMNSxToBC(ifr, npRecvd->rglpfr, npRecvd->uNumFrames, npbc, wBCSize, npll)))
                        {
            //It might be a modem that doesn't pass us the FCS, try again
            for(iFrame=0; iFrame < npRecvd->uNumFrames; iFrame++)
                         npRecvd->rglpfr[iFrame]->cb += 2;     // Put  last two bytes back on
                                // zero out BC again
                                InitBC(pTG, npbc, wBCSize, bctype);
            if(!(uRet3 = lpfnOEMNSxToBC(ifr, npRecvd->rglpfr, npRecvd->uNumFrames, npbc, wBCSize, npll)))
                           {
               (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> got error parsing OEM NSF\r\n"));
                                   // zero out BC again
                                   InitBC(pTG, npbc, wBCSize, bctype);
            }
                        }
                        else
                        {
                                faxTlog((SZMOD "Using OEM Protocol\r\n"));
                                fUsingOEMProt = TRUE;
                                if(uRet3 & OEMNSF_IGNORE_DIS)
                                        npdis = NULL;
                                if(uRet3 & OEMNSF_IGNORE_CSI)
                                        lpbRecvdID = NULL;
                        }
                }
#endif
        }

        if(npdis)
        {
                // extract DIS caps     into BC and LL
                ParseDISorDCSorDTC(pTG, npdis, &(npbc->Fax), npll, (ifr==ifrNSS ? TRUE : FALSE));
        }

        // If an ID is recvd in NSF/NSS/NSC the CSI/TSI/CIG should NOT overwrite it
        if(lpbRecvdID && !HasTextId(npbc))
        {
                PutTextId(npbc, wBCSize, lpbRecvdID, (int)_fstrlen(lpbRecvdID), TEXTCODE_ASCII);
                //PutNumId(npbc, wBCSize, lpbRecvdID, (int) _fstrlen(lpbRecvdID), TEXTCODE_ASCII);
        }

        // If a subaddress is recvd in NSF/NSS/NSC the SUB frame should NOT overwrite it
        if(lpbRecipSubAddr && !HasRecipSubAddr( npbc))
        {
                PutRecipSubAddr( npbc, wBCSize, lpbRecipSubAddr, (int)_fstrlen(lpbRecipSubAddr));
        }


        if(uRet1 > 0)
        {
                npll->fECM = TRUE;      // ignore ECM bit in DIS, if MS NSF present
        }
}







BOOL AwaitSendParamsAndDoNegot(PThrdGlbl pTG, BOOL fSleep)
{
        // This does actual negotiation & gets SENDPARAMS. It could potentially
        // return SEND_POLLREQ instead.
        if(!ProtGetBC(pTG, SEND_PARAMS, fSleep))
        {
                if(fSleep)
                {
                        // ICommFailureCode already set
                        MyDebugPrint(pTG, LOG_ALL, "ATTENTION: AwaitSendParamsAndDoNegot pTG->ProtInst.fAbort = TRUE\n");
                        pTG->ProtInst.fAbort = TRUE;
                }
                return FALSE;
        }

        // negotiate low-level params here. (a) because this is where
        // high-level params are negotiated (b) because it's inefficient to
        // do it on each DCS (c) because RTN breaks otherwise--see bug#731

        // llRecvCaps and llSendParams are set only at startup
        // SendParams are set in ProtGetBC just above
        // llNegot is the return value. So this can be called
        // only at the end of this function

        // negot lowlevel params if we are sending and not polling
        if(!pTG->ProtInst.fAbort && pTG->ProtInst.fSendParamsInited)
        {
                NegotiateLowLevelParams(pTG, &pTG->ProtInst.llRecvCaps, &pTG->ProtInst.llSendParams,
                                                        pTG->ProtInst.SendParams.Fax.AwRes,
                                                        pTG->ProtInst.SendParams.Fax.Encoding,
                                                        &pTG->ProtInst.llNegot);
                pTG->ProtInst.fllNegotiated = TRUE;

                // This chnages llNegot->Baud according to the MaxSpeed settings
                EnforceMaxSpeed(pTG);
        }
        return TRUE;
}













void GotRecvCaps(PThrdGlbl pTG)
{
        BG_CHK(pTG->ProtInst.fRecvdDIS);

        if(!pTG->ProtInst.llSendParams.fECM)
        {
                // if we can't do ECM on send, ignore the received NSFs
                // zap the ECM bits of the received DTC
                pTG->ProtInst.RemoteDIS.ECM = 0;
                pTG->ProtInst.RemoteDIS.SmallFrame = 0;
        }

        GotRecvFrames(pTG, ifrNSF, &pTG->ProtInst.RecvdNS,
                (pTG->ProtInst.fRecvdDIS ? &pTG->ProtInst.RemoteDIS : NULL),
                (pTG->ProtInst.fRecvdID  ?  pTG->ProtInst.bRemoteID : NULL),
                (pTG->ProtInst.fRecvdSUB ?  pTG->ProtInst.bRecipSubAddr : NULL),
                RECV_CAPS, (NPBC)&pTG->ProtInst.RecvCaps, sizeof(pTG->ProtInst.RecvCaps),
                &pTG->ProtInst.llRecvCaps);

        pTG->ProtInst.fRecvCapsGot = TRUE;
        pTG->ProtInst.fllRecvCapsGot = TRUE;

#ifdef FILET30
        // Send up raw caps.
        ICommRawCaps(
                pTG,
                (LPBYTE) (pTG->ProtInst.fRecvdID ?  pTG->ProtInst.bRemoteID: NULL),
                (LPBYTE) (pTG->ProtInst.fRecvdDIS ? (LPBYTE) (&(pTG->ProtInst.RemoteDIS)):NULL),
                (USHORT) (pTG->ProtInst.fRecvdDIS ? pTG->ProtInst.uRemoteDISlen:0),
                (LPFR FAR *) (pTG->ProtInst.RecvdNS.uNumFrames ? pTG->ProtInst.RecvdNS.rglpfr:NULL),
                (USHORT) (pTG->ProtInst.RecvdNS.uNumFrames)
        );

#endif

        // send off BC struct to higher level
        if(!ICommRecvCaps(pTG, (LPBC)&pTG->ProtInst.RecvCaps))
        {
                // ICommFailureCode already set
                MyDebugPrint(pTG, LOG_ALL, "ATTENTION: GotRecvCaps pTG->ProtInst.fAbort = TRUE\n");
                pTG->ProtInst.fAbort = TRUE;
        }

        // This need to be moved into whatnext.NodeA so that we can set
        // param to FALSE (no sleep) and do the stall thing
        AwaitSendParamsAndDoNegot(pTG, TRUE);
}
















void GotPollReq(PThrdGlbl pTG)
{
        BG_CHK(pTG->ProtInst.fRecvdDTC);

        if(!pTG->ProtInst.llSendParams.fECM)
        {
                // if we can't do ECM on send, ignore the received NSFs
                // zap the ECM bits of the received DTC
                pTG->ProtInst.RemoteDTC.ECM = 0;
                pTG->ProtInst.RemoteDTC.SmallFrame = 0;
        }

        GotRecvFrames(pTG, ifrNSC, &pTG->ProtInst.RecvdNS,
                (pTG->ProtInst.fRecvdDTC ? &pTG->ProtInst.RemoteDTC : NULL),
                (pTG->ProtInst.fRecvdID  ?  pTG->ProtInst.bRemoteID : NULL),
                (pTG->ProtInst.fRecvdSUB ?  pTG->ProtInst.bRecipSubAddr : NULL),
                RECV_POLLREQ, (NPBC)&pTG->ProtInst.RecvPollReq, sizeof(pTG->ProtInst.RecvPollReq),
                &pTG->ProtInst.llRecvCaps);

        pTG->ProtInst.fRecvPollReqGot = TRUE;
        pTG->ProtInst.fllRecvCapsGot = TRUE;

        // send off BC struct to higher level
        if(!ICommRecvPollReq(pTG, (LPBC)&pTG->ProtInst.RecvPollReq))
        {
                // ICommFailureCode already set
                MyDebugPrint(pTG, LOG_ALL, "ATTENTION: GetPollReq pTG->ProtInst.fAbort = TRUE\n");
                pTG->ProtInst.fAbort = TRUE;
        }


        //
        // This need to be moved into whatnext.NodeA so that we can set
        // param to FALSE (no sleep) and do the stall thing
        AwaitSendParamsAndDoNegot(pTG, TRUE);
}









void GotRecvParams(PThrdGlbl pTG)
{
        GotRecvFrames(pTG, ifrNSS, &pTG->ProtInst.RecvdNS,
                (pTG->ProtInst.fRecvdDCS ? (&pTG->ProtInst.RemoteDCS) : NULL),
                (pTG->ProtInst.fRecvdID ? pTG->ProtInst.bRemoteID : NULL),
                (pTG->ProtInst.fRecvdSUB ?  pTG->ProtInst.bRecipSubAddr : NULL),
                RECV_PARAMS, (NPBC)&pTG->ProtInst.RecvParams, sizeof(pTG->ProtInst.RecvParams),
                &pTG->ProtInst.llRecvParams);

        // If DCS has fECM set then we must've said we could do ECM
        BG_CHK(pTG->ProtInst.llRecvParams.fECM ? pTG->ProtInst.llSendCaps.fECM : 1);

        pTG->ProtInst.fRecvParamsGot = TRUE;
        pTG->ProtInst.fllRecvParamsGot = TRUE;

        if(!ICommRecvParams(pTG, (LPBC)&pTG->ProtInst.RecvParams)) {
                MyDebugPrint(pTG, LOG_ALL, "ATTENTION: GotRecvParams pTG->ProtInst.fAbort = TRUE\n");
                pTG->ProtInst.fAbort = TRUE;
        }

        ICommSetRecvMode(pTG, ProtReceivingECM(pTG));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\main\registry.c ===
/***************************************************************************
 Name     :     REGISTRY.C
 Comment  :     INIfile handling

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/

#include "prep.h"

#include "efaxcb.h"
#include "t30.h"
#include "hdlc.h"


#include "debug.h"
#include "glbproto.h"

             
             
             
#ifdef USE_REGISTRY
// The default database to us
#       define DATABASE_KEY   HKEY_LOCAL_MACHINE

        // These are NOT localizable items.
#       define szKEYPREFIX "SOFTWARE\\Microsoft\\Fax\\Devices"
#       define szKEYCLASS  "DATA"
DWORD my_atoul(LPSTR lpsz);
#else   // !USE_REGISTRY
        BOOL expand_key(DWORD dwKey, LPSTR FAR *lplpszKey,
                                                LPSTR FAR *lplpszProfileName);
#endif  // !USE_REGISTRY










ULONG_PTR   ProfileOpen(DWORD dwProfileID, LPSTR lpszSection, DWORD dwFlags)
{
        ULONG_PTR dwRet = 0;

#ifdef USE_REGISTRY
        char rgchKey[128];
        HKEY hKey=0;
        HKEY hBaseKey = DATABASE_KEY;
        LONG l;
        LPSTR lpszPrefix;
        DWORD sam=0;
        BG_CHK(sizeof(hKey)<=sizeof(ULONG_PTR));

        if (dwProfileID==OEM_BASEKEY)
        {
                hBaseKey = HKEY_LOCAL_MACHINE;
                lpszPrefix= ""; // we don't prepend szKEYPREFIX
                if (!lpszSection) goto failure;
        }
        else if (lpszSection)
        {
                lpszPrefix= szKEYPREFIX "\\";
        }
        else
        {
                lpszPrefix= szKEYPREFIX;
                lpszSection="";
        }

        if ((lstrlen(lpszPrefix)+lstrlen(lpszSection))>=sizeof(rgchKey))
                goto failure;
        lstrcpy(rgchKey, lpszPrefix);
        lstrcat(rgchKey, lpszSection);

        sam = 0;
        if (dwFlags &fREG_READ) sam |= KEY_READ;
        if (dwFlags &fREG_WRITE) sam |= KEY_WRITE;

        if (dwFlags & fREG_CREATE)
        {
                DWORD dwDisposition=0;
                DWORD dwOptions = (dwFlags & fREG_VOLATILE)
                                    ?REG_OPTION_VOLATILE
                                    :REG_OPTION_NON_VOLATILE;
                sam = KEY_READ | KEY_WRITE; // we force sam to this when creating.
                l = RegCreateKeyEx(
                                   hBaseKey,        //  handle of open key
                                   rgchKey,                     //  address of name of subkey to open
                                   0,               //  reserved
                                   szKEYCLASS,      //  address of class string
                                   dwOptions,           // special options flag
                                   sam,                         // desired security access
                                   NULL,            // address of key security structure
                                   &hKey,           // address of buffer for opened handle
                                   &dwDisposition       // address of dispostion value buffer
                           );
        }
        else
        {
                l = RegOpenKeyEx(
                                   hBaseKey,            //  handle of open key
                                   rgchKey,                             //  address of name of subkey to open
                                   0,                   //  reserved
                                   sam ,                        // desired security access
                                   &hKey                // address of buffer for opened handle
                           );
        }

        if (l!=ERROR_SUCCESS)
        {
                //LOG((_ERR, "RegCreateKeyEx returns error %ld\n", (long) l));
                goto failure;
        }

        dwRet = (ULONG_PTR) hKey;

#else   // !USE_REGISTRY

                LPSTR lpszFile= szINIFILE;
                ATOM aSection, aProfile;

                // NULL lpszSection not supported.
                if (!lpszSection) goto failure;

                if (!(aSection = GlobalAddAtom(lpszSection)))
                        goto failure;
                if (!(aProfile = GlobalAddAtom(lpszFile)))
                        {GlobalDeleteAtom(aSection); goto failure;}
                dwRet = MAKELONG(aSection, aProfile);

#endif  // !USE_REGISTRY

        BG_CHK(dwRet);
        return dwRet;

failure:
        return 0;
}








UINT   
ProfileListGetInt(
    ULONG_PTR  KeyList[10],
    LPSTR     lpszValueName,
    UINT      uDefault
)          

{
    int       i;
    int       Num=0;
    UINT      uRet = uDefault;
    BOOL      fExist = 0;

   for (i=0; i<10; i++) {
      if (KeyList[i] == 0) {
         Num = i-1;
         break;
      }
   }


   for (i=Num; i>=0; i--)  {
      uRet = ProfileGetInt (KeyList[i], lpszValueName, uDefault, &fExist);
      if (fExist) {
           return uRet;
      }
   }


   return uRet;


}

UINT   ProfileGetInt(ULONG_PTR dwKey, LPSTR lpszValueName, UINT uDefault, BOOL *fExist)
{

        UINT uRet = uDefault;
        char rgchBuf[128];
        DWORD dwType;
        DWORD dwcbSize=sizeof(rgchBuf);
        LONG l = RegQueryValueEx(
                (HKEY) dwKey,
                lpszValueName,
                0,
                &dwType,
                rgchBuf,
                &dwcbSize
        );

        if (fExist) {
            *fExist = 0;
        }

        if (l!=ERROR_SUCCESS)
        {
                //LOG((_ERR, "RegQueryValueEx returned error %ld\n", (long) l));
                goto end;
        }

        if (fExist) {
            *fExist = 1;
        }


        if (dwType != REG_SZ)
        {
                //LOG((_ERR, "RegQueryValueEx value type not string:0x%lx\n",
                //                       (unsigned long) dwType));
                goto end;
        }
        uRet = (UINT) my_atoul(rgchBuf);

end:
        return uRet;
}













DWORD   ProfileGetString(ULONG_PTR dwKey, LPSTR lpszValueName,
                LPSTR lpszDefault, LPSTR lpszBuf , DWORD dwcbMax)
{
        DWORD dwRet = 0;

#ifdef USE_REGISTRY
        DWORD dwType;
        LONG l = RegQueryValueEx(
                (HKEY) dwKey,
                lpszValueName,
                0,
                &dwType,
                lpszBuf,
                &dwcbMax
        );

        if (l!=ERROR_SUCCESS)
        {
                //LOG((_ERR, "RegQueryValueEx returned error %ld\n", (long) l));
                goto copy_default;
        }

        if (dwType != REG_SZ)
        {
                //LOG((_ERR, "RegQueryValueEx value type not string:0x%lx\n",
                        //               (unsigned long) dwType));
                goto copy_default;
        }

        // Make sure we null-terminate the string and return the true string
        // length..
        if (dwcbMax) {lpszBuf[dwcbMax-1]=0; dwcbMax = (DWORD) lstrlen(lpszBuf);}
        dwRet = dwcbMax;
        goto end;

#else   // USE_REGISTRY

        LPSTR lpszKey;
        LPSTR lpszProfileName;
        if (!expand_key(dwKey, &lpszKey, &lpszProfileName)) goto copy_default;

        dwRet = GetPrivateProfileString(lpszKey, lpszValueName,
                lpszDefault, lpszBuf , (INT) dwcbMax,
                lpszProfileName);
        goto end;

#endif // USE_REGISTRY

        BG_CHK(FALSE);

copy_default:

        dwRet = 0;
        if (!lpszDefault || !*lpszDefault)
        {
                if (dwcbMax) *lpszBuf=0;
        }
        else
        {
                UINT cb = _fstrlen(lpszDefault)+1;
                if (cb>(UINT)dwcbMax) cb=dwcbMax;
                if (cb)
                {
                        _fmemcpy(lpszBuf, lpszDefault, cb);
                        lpszBuf[cb-1]=0;
                        dwRet = cb-1;
                }
        }
        // fall through...

end:
        return dwRet;

}















BOOL   
ProfileWriteString(
    ULONG_PTR dwKey,
    LPSTR lpszValueName,
    LPSTR lpszBuf,
    BOOL  fRemoveCR
    )

{
        // NOTE: If lpszValueName is null, delete the key. (can't do this in,
        //                              the registry, unfortunately).
        //           If lpszBuf is null pointer -- "delete" this value.
        BOOL fRet=FALSE;

#ifdef USE_REGISTRY
        LONG l;
        if (!lpszValueName) goto end;

        if (!lpszBuf)
        {
                // delete value...
                l = RegDeleteValue((HKEY) dwKey, lpszValueName);
                if (l!=ERROR_SUCCESS) goto end;
        }
        else
        {
            if (fRemoveCR) {
               RemoveCR (lpszBuf);
            }

            l = RegSetValueEx((HKEY) dwKey, lpszValueName, 0, REG_SZ,
                                    lpszBuf, lstrlen(lpszBuf)+1);
                if (l!=ERROR_SUCCESS)
                {
                        //LOG((_ERR,
                        //      "RegSetValueEx(\"%s\", \"%s\") returned error %ld\n",
                        //              (LPSTR) lpszValueName,
                        //              (LPSTR) lpszBuf,
                        //              (long) l));
                        goto end;
                }
        }
        fRet = TRUE;
        goto end;

#else   // !USE_REGISTRY
        LPSTR lpszKey;
        LPSTR lpszProfileName;
        if (!expand_key(dwKey, &lpszKey, &lpszProfileName)) goto end;

        fRet = WritePrivateProfileString(lpszKey, lpszValueName,
                                                lpszBuf, lpszProfileName);
        goto end;
#endif  // !USE_REGISTRY

        BG_CHK(FALSE);

end:
        return fRet;
}






















void    ProfileClose(ULONG_PTR dwKey)
{
#ifdef USE_REGISTRY
        if (RegCloseKey((HKEY)dwKey)!=ERROR_SUCCESS)
        {
                //LOG((_WRN, "Couldn't close registry key:%lu\n\r",
                //      (unsigned long) dwKey));
        }
#else
        BG_CHK(LOWORD(dwKey)); GlobalDeleteAtom(LOWORD(dwKey));
        BG_CHK(HIWORD(dwKey)); GlobalDeleteAtom(HIWORD(dwKey));
#endif
}



















BOOL   ProfileDeleteSection(DWORD dwProfileID, LPSTR lpszSection)
{

#ifdef USE_REGISTRY
        char rgchKey[128];
        LPSTR lpszPrefix= szKEYPREFIX "\\";

        if (dwProfileID==OEM_BASEKEY) goto failure; // Can't delete this

        if ((lstrlen(lpszPrefix)+lstrlen(lpszSection))>=sizeof(rgchKey))
                goto failure;
        lstrcpy(rgchKey, lpszPrefix);
        lstrcat(rgchKey, lpszSection);

        return (RegDeleteKey(DATABASE_KEY, rgchKey)==ERROR_SUCCESS);

failure:
        return FALSE;

#else   // !USE_REGISTRY

    return      WritePrivateProfileString(lpszSection, NULL, NULL, szINIFILE);

#endif  // !USE_REGISTRY
}







BOOL 
ProfileCopyTree(
     DWORD dwProfileIDTo,
     LPSTR lpszSectionTo,
     DWORD dwProfileIDFr,
     LPSTR lpszSectionFr)
{


        BOOL    fRet=TRUE;
        char    SecTo[200];
        char    SecFr[200];



        //
        //  Since there is no CopyKeyWithAllSubkeys API, it is difficult to write generic tree-walking algorithm.
        //  We will hard-code the keys here.
        //
        
        // copy Fax key always

        ProfileCopySection(dwProfileIDTo,
                           lpszSectionTo,
                           dwProfileIDFr,
                           lpszSectionFr,
                           TRUE);

        
        // copy Fax/Class1 key if exists

        sprintf(SecTo, "%s\\Class1", lpszSectionTo);
        sprintf(SecFr, "%s\\Class1", lpszSectionFr);

        ProfileCopySection(dwProfileIDTo,
                           SecTo,
                           dwProfileIDFr,
                           SecFr,
                           FALSE);

        // copy Fax/Class1/AdaptiveAnswer key if exists

        sprintf(SecTo, "%s\\Class1\\AdaptiveAnswer", lpszSectionTo);
        sprintf(SecFr, "%s\\Class1\\AdaptiveAnswer", lpszSectionFr);

        ProfileCopySection(dwProfileIDTo,
                           SecTo,
                           dwProfileIDFr,
                           SecFr,
                           FALSE);


        // copy Fax/Class1/AdaptiveAnswer/Answer key if exists

        sprintf(SecTo, "%s\\Class1\\AdaptiveAnswer\\AnswerCommand", lpszSectionTo);
        sprintf(SecFr, "%s\\Class1\\AdaptiveAnswer\\AnswerCommand", lpszSectionFr);

        ProfileCopySection(dwProfileIDTo,
                           SecTo,
                           dwProfileIDFr,
                           SecFr,
                           FALSE);








        // copy Fax/Class2 key if exists

        sprintf(SecTo, "%s\\Class2", lpszSectionTo);
        sprintf(SecFr, "%s\\Class2", lpszSectionFr);

        ProfileCopySection(dwProfileIDTo,
                           SecTo,
                           dwProfileIDFr,
                           SecFr,
                           FALSE);


        // copy Fax/Class2/AdaptiveAnswer key if exists

        sprintf(SecTo, "%s\\Class2\\AdaptiveAnswer", lpszSectionTo);
        sprintf(SecFr, "%s\\Class2\\AdaptiveAnswer", lpszSectionFr);

        ProfileCopySection(dwProfileIDTo,
                           SecTo,
                           dwProfileIDFr,
                           SecFr,
                           FALSE);


        // copy Fax/Class2/AdaptiveAnswer/Answer key if exists

        sprintf(SecTo, "%s\\Class2\\AdaptiveAnswer\\AnswerCommand", lpszSectionTo);
        sprintf(SecFr, "%s\\Class2\\AdaptiveAnswer\\AnswerCommand", lpszSectionFr);

        ProfileCopySection(dwProfileIDTo,
                           SecTo,
                           dwProfileIDFr,
                           SecFr,
                           FALSE);








        // copy Fax/Class2_0 key if exists

        sprintf(SecTo, "%s\\Class2_0", lpszSectionTo);
        sprintf(SecFr, "%s\\Class2_0", lpszSectionFr);

        ProfileCopySection(dwProfileIDTo,
                           SecTo,
                           dwProfileIDFr,
                           SecFr,
                           FALSE);

        // copy Fax/Class2_0/AdaptiveAnswer key if exists

        sprintf(SecTo, "%s\\Class2_0\\AdaptiveAnswer", lpszSectionTo);
        sprintf(SecFr, "%s\\Class2_0\\AdaptiveAnswer", lpszSectionFr);

        ProfileCopySection(dwProfileIDTo,
                           SecTo,
                           dwProfileIDFr,
                           SecFr,
                           FALSE);


        // copy Fax/Class2/AdaptiveAnswer/Answer key if exists

        sprintf(SecTo, "%s\\Class2_0\\AdaptiveAnswer\\AnswerCommand", lpszSectionTo);
        sprintf(SecFr, "%s\\Class2_0\\AdaptiveAnswer\\AnswerCommand", lpszSectionFr);

        ProfileCopySection(dwProfileIDTo,
                           SecTo,
                           dwProfileIDFr,
                           SecFr,
                           FALSE);


        
        return fRet;


}











BOOL   
ProfileCopySection(
      DWORD   dwProfileIDTo,
      LPSTR   lpszSectionTo,  
      DWORD   dwProfileIDFr,
      LPSTR   lpszSectionFr,
      BOOL    fCreateAlways
)

{

        BOOL    fRet=FALSE;
        DWORD   iValue=0;
        DWORD   cbValue, cbData, dwType;
        char    rgchValue[60], rgchData[256];
        HKEY    hkFr;
        HKEY    hkTo; 
         
        hkFr = (HKEY) ProfileOpen(dwProfileIDFr, lpszSectionFr, fREG_READ);

        if ( (!hkFr) && (!fCreateAlways) ) {
           return fRet;

        }


        hkTo = (HKEY) ProfileOpen(dwProfileIDTo, lpszSectionTo,
                                                                fREG_CREATE |fREG_READ|fREG_WRITE);

        if (!hkTo || !hkFr) goto end;

        iValue=0;dwType=0;cbValue=sizeof(rgchValue);cbData=sizeof(rgchData);
        while(RegEnumValue(hkFr, iValue, rgchValue, &cbValue,
                                                NULL, &dwType, rgchData, &cbData)==ERROR_SUCCESS)
        {

                if (RegQueryValueEx(hkFr, rgchValue, NULL, &dwType, rgchData, &cbData)
                                ==ERROR_SUCCESS)
                {
            if (RegSetValueEx(hkTo, rgchValue, 0, dwType, rgchData, cbData)
                                                                        == ERROR_SUCCESS)
                        {
                                fRet=TRUE;
                        }
                }
                iValue++;dwType=0;cbValue=sizeof(rgchValue);cbData=sizeof(rgchData);
        }

end:
        if (hkTo) RegCloseKey(hkTo);
        if (hkFr) RegCloseKey(hkFr);
        return fRet;

}















DWORD   ProfileGetData(ULONG_PTR dwKey, LPSTR lpszValueName,
                        LPBYTE lpbBuf , DWORD dwcbMax)
{
#ifndef USE_REGISTRY
        return 0;
#else   // USE_REGISTRY
        DWORD dwType;
        LONG l = RegQueryValueEx(
                (HKEY) dwKey,
                lpszValueName,
                0,
                &dwType,
                lpbBuf,
                &dwcbMax
        );

        if (l!=ERROR_SUCCESS)
        {
                //LOG((_ERR, "RegQueryValueEx returned error %ld\n", (long) l));
                goto copy_default;
        }

        if (dwType != REG_BINARY)
        {
                goto copy_default;
        }

        return dwcbMax;

copy_default:
        return 0;

#endif  // USE_REGISTRY
}
















BOOL   ProfileWriteData(ULONG_PTR dwKey, LPSTR lpszValueName,
                        LPBYTE lpbBuf, DWORD dwcb)
{
#ifndef USE_REGISTRY
        return 0;
#else   // USE_REGISTRY
        LONG l = ~(ERROR_SUCCESS);
        if (!lpszValueName) goto end;

        if (!lpbBuf)
        {
                // delete value...
                l = RegDeleteValue((HKEY) dwKey, lpszValueName);
        }
        else
        {
        l = RegSetValueEx((HKEY) dwKey, lpszValueName, 0, REG_BINARY,
                                    lpbBuf, dwcb);
        }

end:
        return (l==ERROR_SUCCESS);
#endif  // USE_REGISTRY
}

#ifdef USE_REGISTRY
DWORD my_atoul(LPSTR lpsz)
{
    unsigned i=8, c;
    unsigned long ul=0;
    while(i-- && (c=*lpsz++)) {
        ul*=10;
    switch(c) {
        case '0': break;
        case '1':ul+=1; break;
        case '2':ul+=2; break;
        case '3':ul+=3; break;
        case '4':ul+=4; break;
        case '5':ul+=5; break;
        case '6':ul+=6; break;
        case '7':ul+=7; break;
        case '8':ul+=8; break;
        case '9':ul+=9; break;
        default: goto end;
        }
    }
end:
    return ul;

}
#endif // USE_REGISTRY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\main\rx_thrd.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    rx_thrd.c

Abstract:

    This module implements async. MR/MH page decoding in a separate thread.

Author:

    Rafael Lisitsa (RafaelL) 14-Aug-1996

Revision History:

--*/

#include "prep.h"

#include "efaxcb.h"
#include "t30.h"
#include "hdlc.h"
#include "debug.h"

#include "tiff.h"
#include "..\..\..\tiff\src\fasttiff.h"

#include "glbproto.h"
#include "t30gl.h"


// 15 min.
#define WAIT_FOR_NEXT_STRIP_RX_TIMEOUT      900000
#define RET_NEXT_STRIP_RX_TIMEOUT           1


DWORD
PageAckThreadSafe(
    PThrdGlbl   pTG
    )

{


    DWORD   RetCode;


    if (glT30Safe) {

        __try {

            RetCode = PageAckThread(pTG);

        } __except (EXCEPTION_EXECUTE_HANDLER) {
            //
            // Signal to the Main T.30 Thread that we crashed
            //
            return (FALSE);

        }
    }
    else  {

        RetCode = PageAckThread(pTG);

    }


    return (RetCode);

}

DWORD
PageAckThread(
    PThrdGlbl   pTG
    )

{
    DWORD             tiffCompression = pTG->TiffConvertThreadParams.tiffCompression;
    BOOL              HiRes = pTG->TiffConvertThreadParams.HiRes;
    DWORD             RetCode = FALSE;
    DWORD             RetFlags = 0;
    DWORD             ThrdDoneRetCode;
    char              InFileName[_MAX_FNAME];


    //
    // Set the appropriate PRTY for this thread
    // I/O threads run at 15. TIFF - at 9...11
    //

    MyDebugPrint(pTG, LOG_ALL, "TIFF_RX: Started at %ld \n", GetTickCount() );

    if (! SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_HIGHEST) ) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR TIFF_RX: SetThreadPriority HIGHEST failed le=%x \n", GetLastError() );
        SignalHelperError(pTG);
        goto error_exit;
    }

    // binary file has fixed name based on lineID; it is created and updated by T.30 RX I/O thread.
    _fmemcpy (InFileName, gT30.TmpDirectory, gT30.dwLengthTmpDirectory);
    _fmemcpy (&InFileName[gT30.dwLengthTmpDirectory], pTG->TiffConvertThreadParams.lpszLineID, 8);
    sprintf  (&InFileName[gT30.dwLengthTmpDirectory+8], ".RX");

    do {


        RetFlags = 0;

        if (tiffCompression == TIFF_COMPRESSION_MR) {
            ThrdDoneRetCode = DecodeMRFaxPageAsync (
                                        pTG,
                                        &RetFlags,
                                        InFileName,
                                        HiRes);
        }
        else {
            ThrdDoneRetCode = DecodeMHFaxPageAsync (
                                        pTG,
                                        &RetFlags,
                                        InFileName
                                        );
        }

        if ( RetFlags == RET_NEXT_STRIP_RX_TIMEOUT ) {
            DeleteFile(InFileName);
            return (FALSE);
        }

        SetEvent(pTG->ThrdDoneSignal);

    } while (! pTG->ReqTerminate);

    DeleteFile(InFileName);
    MyDebugPrint(pTG, LOG_ALL, "TIFF_RX: Terminated at %ld \n", GetTickCount() );

    RetCode = TRUE;


error_exit:

    pTG->AckTerminate = 1;
    pTG->fOkToResetAbortReqEvent = 1;

    SetEvent(pTG->ThrdAckTerminateSignal);

    MyDebugPrint(pTG, LOG_ALL, "TIFF_RX: PageAckThread EXITs at %ld \n", GetTickCount() );

    return (RetCode);


}











BOOL
DecodeMHFaxPageAsync(
    PThrdGlbl           pTG,
    DWORD               *RetFlags,
    char                *InFileName
    )

{
    HANDLE              InFileHandle;
    DWORD               i;
    DWORD               Lines;
    DWORD               BadFaxLines;
    DWORD               ConsecBadLines=0;

    DWORD               AllowedBadFaxLines = gT30.MaxErrorLinesPerPage;
    DWORD               AllowedConsecBadLines = gT30.MaxConsecErrorLinesPerPage;


    LPDWORD             EndPtr;
    LPDWORD             EndBuffer;


    LPDWORD             lpdwResPtr;
    LPDWORD             lpdwRead;
    BYTE                ResBit;
    BOOL                fTestLength;
    BOOL                fError;
    BOOL                fFirstRead;

    DWORD               Buffer[DECODE_BUFFER_SIZE / sizeof(DWORD)];
    DWORD               GoodStripSize = 0;
    BOOL                fLastReadBlockSync;   // needs to be sync. fetched, updated by RX I/O thrd.
    DWORD               BytesReuse;
    DWORD               BytesDelta;
    DWORD               BytesToRead;
    DWORD               BytesHaveRead;
    DWORD               PageCount;
    BOOL                fAfterFirstEOL;
    DWORD               NumHandles=2;
    HANDLE              HandlesArray[2];
    DWORD               WaitResult;
    BOOL                ResScan;

    //
    // At Start of Page
    //

    HandlesArray[0] = pTG->AbortReqEvent;
    HandlesArray[1] = pTG->ThrdSignal;

    pTG->fTiffThreadRunning = 0;


    do {

        WaitResult = WaitForMultipleObjects(NumHandles, HandlesArray, FALSE, WAIT_FOR_NEXT_STRIP_RX_TIMEOUT);

        if (WaitResult == WAIT_TIMEOUT) {
            *RetFlags = RET_NEXT_STRIP_RX_TIMEOUT;
            return FALSE;
        }

        if (WaitResult == WAIT_FAILED) {
            MyDebugPrint(pTG, LOG_ERR, "TIFF_RX: WaitForMultipleObjects FAILED le=%lx at %ld \n",
                                        GetLastError(), GetTickCount() );
        }

        if ( pTG->ReqTerminate || (WaitResult == WAIT_OBJECT_0) )   {
            MyDebugPrint(pTG,  LOG_ALL, "TIFF_RX: wait for next page ABORTED at %ld \n", GetTickCount() ) ;

            pTG->fOkToResetAbortReqEvent = 1;

            return TRUE;
        }

    } while (pTG->fPageIsBad);



    pTG->fTiffThreadRunning = 1;



    Lines = 0;
    BadFaxLines = 0;

    PageCount = pTG->PageCount;
    fAfterFirstEOL = 0;



    fLastReadBlockSync = pTG->fLastReadBlock;

    MyDebugPrint(pTG, LOG_ALL, "TIFF_RX: DecodeMHFaxPageAsync waked up fLastReadBlockSync=%d at %ld \n",
                              fLastReadBlockSync,   GetTickCount() );


    if ( ( InFileHandle = CreateFileA(InFileName, GENERIC_READ, FILE_SHARE_WRITE | FILE_SHARE_READ,
                                       NULL, OPEN_EXISTING, 0, NULL) ) == INVALID_HANDLE_VALUE ) {
        MyDebugPrint(pTG, LOG_ERR, "TIFF_RX: ERROR FATAL PAGE DecodeMHFaxPageAsync COULD NOT open %s at %ld \n",
            InFileName, GetTickCount() );

        pTG->fPageIsBad = 1;
        return FALSE;
    }

    fFirstRead = 1;
    pTG->BytesOut = 0;

    // Buffer is DWORD aligned
    lpdwResPtr = Buffer;
    ResBit = 0;

    EndBuffer = Buffer + ( DECODE_BUFFER_SIZE / sizeof(DWORD) );

    //
    // loop thru all blocks
    //
    do {

        //
        // Read the next RAW block prepared by main I/O thread
        //

        if (fFirstRead) {
            lpdwRead = Buffer;
            BytesReuse = 0;
            BytesToRead = DECODE_BUFFER_SIZE;
            fTestLength = DO_NOT_TEST_LENGTH;
        }
        else {
            BytesReuse = (DWORD)((EndBuffer - lpdwResPtr) * sizeof (DWORD));
            CopyMemory( (char *) Buffer, (char *) lpdwResPtr, BytesReuse);
            lpdwRead = Buffer + (BytesReuse / sizeof (DWORD) );
            BytesToRead = DECODE_BUFFER_SIZE -  BytesReuse;
            fTestLength = DO_TEST_LENGTH;
        }

        lpdwResPtr = Buffer;

        BytesDelta = pTG->BytesIn - pTG->BytesOut;

        if (BytesDelta < DECODE_BUFFER_SIZE) {
            if (! fLastReadBlockSync) {
                MyDebugPrint(pTG, LOG_ERR, "TIFF_RX: ERROR FATAL PAGE LOGIC. SYNC. DecodeMHFaxPageAsync file %s Bytes: IN:%d OUT:%d  at %ld \n",
                    InFileName, pTG->BytesIn, pTG->BytesOut, GetTickCount() );

                pTG->fPageIsBad = 1;
                goto bad_exit;
            }
        }


        if (fLastReadBlockSync) {
            if (BytesDelta < BytesToRead) {
                BytesToRead = BytesDelta;
            }
        }


        if (! ReadFile(InFileHandle, lpdwRead, BytesToRead, &BytesHaveRead, NULL ) ) {
            MyDebugPrint(pTG, LOG_ERR, "TIFF_RX: ERROR FATAL PAGE DecodeMHFaxPageAsync COULD NOT READ file %s Bytes: IN:%d OUT:%d WANTED:%d LE=%x at %ld \n",
                InFileName, pTG->BytesIn, pTG->BytesOut, BytesToRead, GetLastError(), GetTickCount() );

            pTG->fPageIsBad = 1;
            goto bad_exit;
        }

        if (BytesHaveRead != BytesToRead) {
            MyDebugPrint(pTG, LOG_ERR, "TIFF_RX: ERROR FATAL PAGE DecodeMHFaxPageAsync ReadFile count=%d WANTED=%d file %s Bytes: IN:%d OUT:%d at %ld \n",
                BytesHaveRead, BytesToRead, InFileName, pTG->BytesIn, pTG->BytesOut, GetTickCount() );

            pTG->fPageIsBad = 1;
            goto bad_exit;
        }


        if ( fLastReadBlockSync && (BytesToRead == BytesDelta) ) {
            EndPtr = Buffer + ( (BytesReuse + BytesToRead) / sizeof(DWORD) );
        }
        else {
            //
            // leave 1000*4 = 4000 bytes ahead if not final block to make sure
            // we always have one full line ahead.
            //
            EndPtr = EndBuffer - 1000;
        }

        pTG->BytesOut += BytesToRead;
        GoodStripSize += BytesToRead;

        MyDebugPrint(pTG, LOG_ERR, "TIFF_RX: DecodeMHFaxPageAsync BytesIn=%d Out=%d Read=%d ResBit=%d StartPtr=%lx EndPtr=%lx Reuse=%d \n",
                        pTG->BytesIn, pTG->BytesOut, BytesToRead, ResBit, Buffer, EndPtr, BytesReuse);

        //
        // find first EOL in a block
        //

        if (! FindNextEol (lpdwResPtr, ResBit, EndBuffer, &lpdwResPtr, &ResBit, fTestLength, &fError) ) {
            MyDebugPrint(pTG, LOG_ERR, "TIFF_RX: ERROR Couldn't find EOL fTestLength=%d fError=%d\n", fTestLength, fError);
            pTG->fPageIsBad = 1;
            goto bad_exit;
        }


        fAfterFirstEOL = 1;


        //
        // Scan the next segment
        //

        __try {

             ResScan = ScanMhSegment(&lpdwResPtr,
                                     &ResBit,
                                     EndPtr,
                                     EndBuffer,
                                     &Lines,
                                     &BadFaxLines,
                                     &ConsecBadLines,
                                     AllowedBadFaxLines,
                                     AllowedConsecBadLines);

#if 0
            if (glSimulateError && (glSimulateErrorType == SIMULATE_ERROR_RX_TIFF) ) {
                SimulateError( EXCEPTION_ACCESS_VIOLATION);
            }
#endif

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            //
            // try to use the Recovery data
            //

            DWORD      dwCkSum;
            int        fFound=0;
            PThrdGlbl  pTG;
            DWORD      dwThreadId = GetCurrentThreadId();


            fFound = 0;

            for (i=0; i<MAX_T30_CONNECT; i++) {
                if ( (! T30Recovery[i].fAvail) && (T30Recovery[i].TiffThreadId == dwThreadId) ) {
                    if ( ( dwCkSum = ComputeCheckSum( (LPDWORD) &T30Recovery[i].fAvail,
                                                      sizeof ( T30_RECOVERY_GLOB ) / sizeof (DWORD) - 1) ) == T30Recovery[i].CkSum ) {

                        pTG                  = (PThrdGlbl) T30Recovery[i].pTG;
                        fFound = 1;
                        break;
                    }
                }
            }


           *RetFlags = RET_NEXT_STRIP_RX_TIMEOUT;
           CloseHandle(InFileHandle);

           if (fFound == 1) {
               pTG->fPageIsBad = 1;
           }

           return (FALSE);

        }




        if (ResScan == TIFF_SCAN_SUCCESS) {
            goto good_exit;
        }
        else if (ResScan == TIFF_SCAN_FAILURE) {
            MyDebugPrint(pTG, LOG_ALL, "TIFF_RX: ERROR: ScanMhSegment returns %d at %ld \n", ResScan, GetTickCount() );
            pTG->fPageIsBad = 1;
            goto bad_exit;
        }
        else if (ResScan != TIFF_SCAN_SEG_END) {
            MyDebugPrint(pTG, LOG_ALL, "TIFF_RX: ERROR: ScanMhSegment returns INVALID %d at %ld \n", ResScan, GetTickCount() );
            pTG->fPageIsBad = 1;
            goto bad_exit;
        }



//lNextBlock:
        // here we make decision as to whether do the next block OR block (not enough data avail).
        if (fLastReadBlockSync && (pTG->BytesOut == pTG->BytesIn) ) {
            //
            // BugBug (andrewr) tiff spec says that MH doesn't use RTC or EOL.
            // since we're out of data at this point (in = out) and we're at the
            // end of a segment, let's just say the page is done.  The worst
            // that can happen is the end of the page is messed up.  This change 
            // allows us to receive some MH class 2 faxes that we couldn't before.
            //
            MyDebugPrint(pTG, LOG_ALL, "TIFF_RX: ERROR: Didn't find RTC  at %ld \n",  GetTickCount() );
            //pTG->fPageIsBad = 1;
            //goto bad_exit;
            goto good_exit;
        }


        MyDebugPrint(pTG, LOG_ALL, "TIFF_RX: Done with next strip at %ld BytesIn=%d Out=%d Lines=%d Bad=%d ConsecBad=%d Processed %d bytes \n",
                          GetTickCount(), pTG->BytesIn, pTG->BytesOut, Lines, BadFaxLines, ConsecBadLines,
                          (lpdwResPtr - Buffer) * sizeof(DWORD)    );

        fLastReadBlockSync = pTG->fLastReadBlock;

        if ( (pTG->BytesIn - pTG->BytesOut < DECODE_BUFFER_SIZE) && (! fLastReadBlockSync) )   {
            MyDebugPrint(pTG, LOG_ALL, "TIFF_RX: Waiting for next strip to be avail. at %ld \n",
                              GetTickCount() );

            pTG->fTiffThreadRunning = 0;

            WaitResult = WaitForMultipleObjects(NumHandles, HandlesArray, FALSE, WAIT_FOR_NEXT_STRIP_RX_TIMEOUT);

            if (WaitResult == WAIT_TIMEOUT) {
                *RetFlags = RET_NEXT_STRIP_RX_TIMEOUT;
                goto bad_exit;
            }


            if (WaitResult == WAIT_FAILED) {
                MyDebugPrint(pTG, LOG_ERR, "TIFF_RX: WaitForMultipleObjects FAILED le=%lx at %ld \n",
                                            GetLastError(), GetTickCount() );
            }

            if ( pTG->ReqTerminate || (WaitResult == WAIT_OBJECT_0) )   {
                MyDebugPrint(pTG,  LOG_ALL, "TIFF_RX: wait for next page ABORTED at %ld \n", GetTickCount() ) ;
                goto bad_exit;
            }


            pTG->fTiffThreadRunning = 1;

            fLastReadBlockSync = pTG->fLastReadBlock;

            MyDebugPrint(pTG, LOG_ALL, "TIFF_RX: Waked up with next strip. fLastReadBlockSync=%d BytesIn=%d Out=%d at %ld \n",
                         fLastReadBlockSync,  pTG->BytesIn, pTG->BytesOut, GetTickCount() );

        }

        fFirstRead = 0;

    } while ( ! pTG->ReqTerminate );

    MyDebugPrint(pTG, LOG_ALL, "TIFF_RX: ERROR: Got Terminate request at %ld \n", GetTickCount() );
    pTG->fPageIsBad = 1;

    goto bad_exit;




good_exit:
    CloseHandle(InFileHandle);
    return TRUE;



bad_exit:
    CloseHandle(InFileHandle);
    return FALSE;

}








BOOL
DecodeMRFaxPageAsync(
    PThrdGlbl           pTG,
    DWORD               *RetFlags,
    char                *InFileName,
    BOOL                HiRes
    )


{
    HANDLE              InFileHandle;
    DWORD               i;
    DWORD               Lines;
    DWORD               BadFaxLines;
    DWORD               ConsecBadLines=0;

    DWORD               AllowedBadFaxLines = gT30.MaxErrorLinesPerPage;
    DWORD               AllowedConsecBadLines = gT30.MaxConsecErrorLinesPerPage;

    LPDWORD             EndPtr;
    LPDWORD             EndBuffer;

    LPDWORD             lpdwResPtr;
    LPDWORD             lpdwRead;
    BYTE                ResBit;
    BOOL                fTestLength;
    BOOL                fError;

    BOOL                fFirstRead;

    DWORD               Buffer[DECODE_BUFFER_SIZE / sizeof(DWORD)];
    DWORD               GoodStripSize = 0;
    BOOL                fLastReadBlockSync;   // needs to be sync. fetched, updated by RX I/O thrd.
    DWORD               BytesReuse;
    DWORD               BytesDelta;
    DWORD               BytesToRead;
    DWORD               BytesHaveRead;

    BOOL                f1D;

    DWORD               PageCount;
    BOOL                fAfterFirstEOL;
    DWORD               NumHandles=2;
    HANDLE              HandlesArray[2];
    DWORD               WaitResult;
    BOOL                ResScan;

    //
    // At Start of Page
    //

    HandlesArray[0] = pTG->AbortReqEvent;
    HandlesArray[1] = pTG->ThrdSignal;

    pTG->fTiffThreadRunning = 0;


    do {

        WaitResult = WaitForMultipleObjects(NumHandles, HandlesArray, FALSE, WAIT_FOR_NEXT_STRIP_RX_TIMEOUT);

        if (WaitResult == WAIT_TIMEOUT) {
            *RetFlags = RET_NEXT_STRIP_RX_TIMEOUT;
            return FALSE;
        }


        if (WaitResult == WAIT_FAILED) {
            MyDebugPrint(pTG, LOG_ERR, "TIFF_RX: WaitForMultipleObjects FAILED le=%lx at %ld \n",
                                        GetLastError(), GetTickCount() );
        }

        if ( pTG->ReqTerminate || ( WaitResult == WAIT_OBJECT_0) )   {
            MyDebugPrint(pTG,  LOG_ALL, "TIFF_RX: wait for next page ABORTED at %ld \n", GetTickCount() ) ;
            return TRUE;
        }

    } while (pTG->fPageIsBad);



    pTG->fTiffThreadRunning = 1;

    Lines = 0;
    BadFaxLines = 0;

    PageCount = pTG->PageCount;
    fAfterFirstEOL = 0;


    fLastReadBlockSync = pTG->fLastReadBlock;

    MyDebugPrint(pTG, LOG_ALL, "TIFF_RX: DecodeMRFaxPageAsync waked up fLastReadBlockSync=%d at %ld \n",
                              fLastReadBlockSync,   GetTickCount() );


    if ( ( InFileHandle = CreateFileA(InFileName, GENERIC_READ, FILE_SHARE_WRITE | FILE_SHARE_READ,
                                       NULL, OPEN_EXISTING, 0, NULL) ) == INVALID_HANDLE_VALUE ) {
        MyDebugPrint(pTG, LOG_ERR, "TIFF_RX: ERROR FATAL PAGE DecodeMRFaxPageAsync COULD NOT open %s at %ld \n",
            InFileName, GetTickCount() );

        pTG->fPageIsBad = 1;
        return FALSE;
    }

    fFirstRead = 1;
    pTG->BytesOut = 0;

    // Buffer is DWORD aligned
    lpdwResPtr = Buffer;
    ResBit = 0;

    EndBuffer = Buffer + ( DECODE_BUFFER_SIZE / sizeof(DWORD) );

    //
    // loop thru all blocks
    //
    do {

        //
        // Read the next RAW block prepared by main I/O thread
        //

        if (fFirstRead) {
            lpdwRead = Buffer;
            BytesReuse = 0;
            BytesToRead = DECODE_BUFFER_SIZE;
            fTestLength = DO_NOT_TEST_LENGTH;
        }
        else {
            BytesReuse = (DWORD)((EndBuffer - lpdwResPtr) * sizeof (DWORD));
            CopyMemory( (char *) Buffer, (char *) lpdwResPtr, BytesReuse);
            lpdwRead = Buffer + (BytesReuse / sizeof (DWORD) );
            BytesToRead = DECODE_BUFFER_SIZE -  BytesReuse;
            fTestLength = DO_TEST_LENGTH;
        }

        lpdwResPtr = Buffer;

        BytesDelta = pTG->BytesIn - pTG->BytesOut;

        if (BytesDelta < DECODE_BUFFER_SIZE) {
            if (! fLastReadBlockSync) {
                MyDebugPrint(pTG, LOG_ERR, "TIFF_RX: ERROR FATAL PAGE LOGIC. SYNC. DecodeMRFaxPageAsync file %s Bytes: IN:%d OUT:%d  at %ld \n",
                    InFileName, pTG->BytesIn, pTG->BytesOut, GetTickCount() );

                pTG->fPageIsBad = 1;
                goto bad_exit;
            }
        }

        if (fLastReadBlockSync) {
            if (BytesDelta < BytesToRead) {
                BytesToRead = BytesDelta;
            }
        }


        if (! ReadFile(InFileHandle, lpdwRead, BytesToRead, &BytesHaveRead, NULL ) ) {
            MyDebugPrint(pTG, LOG_ERR, "TIFF_RX: ERROR FATAL PAGE DecodeMRFaxPageAsync COULD NOT READ file %s Bytes: IN:%d OUT:%d WANTED:%d LE=%x at %ld \n",
                InFileName, pTG->BytesIn, pTG->BytesOut, BytesToRead, GetLastError(), GetTickCount() );

            pTG->fPageIsBad = 1;
            goto bad_exit;
        }

        if (BytesHaveRead != BytesToRead) {
            MyDebugPrint(pTG, LOG_ERR, "TIFF_RX: ERROR FATAL PAGE DecodeMRFaxPageAsync ReadFile count=%d WANTED=%d file %s Bytes: IN:%d OUT:%d at %ld \n",
                BytesHaveRead, BytesToRead, InFileName, pTG->BytesIn, pTG->BytesOut, GetTickCount() );

            pTG->fPageIsBad = 1;
            goto bad_exit;
        }


        if ( fLastReadBlockSync && (BytesToRead == BytesDelta) ) {
            EndPtr = Buffer + ( (BytesReuse + BytesToRead) / sizeof(DWORD) );
        }
        else {
            //
            // leave 1000*4 = 4000 bytes ahead if not final block to make sure
            // we always have one full line ahead.
            //
            EndPtr = EndBuffer - 1000;
        }

        pTG->BytesOut += BytesToRead;
        GoodStripSize += BytesToRead;


        MyDebugPrint(pTG, LOG_ERR, "TIFF_RX: DecodeMRFaxPageAsync BytesIn=%d Out=%d Read=%d ResBit=%d StartPtr=%lx EndPtr=%lx Reuse=%d \n",
                        pTG->BytesIn, pTG->BytesOut, BytesToRead, ResBit, Buffer, EndPtr, BytesReuse);





        //
        // find first EOL
        //

        f1D = 1;

        if (! FindNextEol (lpdwResPtr, ResBit, EndBuffer, &lpdwResPtr, &ResBit, fTestLength, &fError) ) {
            MyDebugPrint(pTG, LOG_ERR, "TIFF_RX: ERROR Couldn't find EOL fTestLength=%d fError=%d\n", fTestLength, fError);
            pTG->fPageIsBad = 1;
            goto bad_exit;
        }

        fAfterFirstEOL = 1;

        //
        // Scan the next segment
        //

        __try {

            ResScan = ScanMrSegment(&lpdwResPtr,
                                    &ResBit,
                                     EndPtr,
                                     EndBuffer,
                                    &Lines,
                                    &BadFaxLines,
                                    &ConsecBadLines,
                                     AllowedBadFaxLines,
                                     AllowedConsecBadLines,
                                    &f1D);

#if 0
            if (glSimulateError && (glSimulateErrorType == SIMULATE_ERROR_RX_TIFF) ) {
                SimulateError( EXCEPTION_ACCESS_VIOLATION);
            }
#endif


        } __except (EXCEPTION_EXECUTE_HANDLER) {

          //
          // try to use the Recovery data
          //

          DWORD      dwCkSum;
          int        fFound=0;
          PThrdGlbl  pTG;
          DWORD      dwThreadId = GetCurrentThreadId();


          fFound = 0;

          for (i=0; i<MAX_T30_CONNECT; i++) {
              if ( (! T30Recovery[i].fAvail) && (T30Recovery[i].TiffThreadId == dwThreadId) ) {
                  if ( ( dwCkSum = ComputeCheckSum( (LPDWORD) &T30Recovery[i].fAvail,
                                                    sizeof ( T30_RECOVERY_GLOB ) / sizeof (DWORD) - 1) ) == T30Recovery[i].CkSum ) {

                      pTG                  = (PThrdGlbl) T30Recovery[i].pTG;
                      fFound = 1;
                      break;
                  }
              }
          }


          *RetFlags = RET_NEXT_STRIP_RX_TIMEOUT;
          CloseHandle(InFileHandle);

          if (fFound == 1) {
            pTG->fPageIsBad = 1;
          }

          return (FALSE);

        }



        if (ResScan == TIFF_SCAN_SUCCESS) {
            goto good_exit;
        }
        else if (ResScan == TIFF_SCAN_FAILURE) {
            MyDebugPrint(pTG, LOG_ALL, "TIFF_RX: ERROR: ScanMrSegment returns %d at %ld \n", ResScan, GetTickCount() );
            pTG->fPageIsBad = 1;
            goto bad_exit;
        }
        else if (ResScan != TIFF_SCAN_SEG_END) {
            MyDebugPrint(pTG, LOG_ALL, "TIFF_RX: ERROR: ScanMrSegment returns INVALID %d at %ld \n", ResScan, GetTickCount() );
            pTG->fPageIsBad = 1;
            goto bad_exit;
        }



//lNextBlock:
        // here we make decision as to whether to do the next segment OR to block (not enough data avail).
        if (fLastReadBlockSync && (pTG->BytesOut == pTG->BytesIn) ) {
            MyDebugPrint(pTG, LOG_ALL, "TIFF_RX: ERROR: Didn't find RTC  Bad=%d ConsecBad=%d Good=%d at %ld \n",
                BadFaxLines, ConsecBadLines, Lines, GetTickCount() );
            pTG->fPageIsBad = 1;
            goto bad_exit;
        }


        MyDebugPrint(pTG, LOG_ALL, "TIFF_RX: Done with next strip at %ld BytesIn=%d Out=%d Lines=%d Bad=%d ConsecBad=%d Processed %d bytes \n",
                          GetTickCount(), pTG->BytesIn, pTG->BytesOut, Lines, BadFaxLines, ConsecBadLines,
                          (lpdwResPtr - Buffer) * sizeof(DWORD)    );

        fLastReadBlockSync = pTG->fLastReadBlock;

        if ( (pTG->BytesIn - pTG->BytesOut < DECODE_BUFFER_SIZE) && (! fLastReadBlockSync) )   {
            MyDebugPrint(pTG, LOG_ALL, "TIFF_RX: Waiting for next strip to be avail. at %ld \n",
                              GetTickCount() );

            pTG->fTiffThreadRunning = 0;

            WaitResult = WaitForMultipleObjects(NumHandles, HandlesArray, FALSE, WAIT_FOR_NEXT_STRIP_RX_TIMEOUT);

            if (WaitResult == WAIT_TIMEOUT) {
                *RetFlags = RET_NEXT_STRIP_RX_TIMEOUT;
                goto bad_exit;
            }


            if (WaitResult == WAIT_FAILED) {
                MyDebugPrint(pTG, LOG_ERR, "TIFF_RX: WaitForMultipleObjects FAILED le=%lx at %ld \n",
                                            GetLastError(), GetTickCount() );
            }

            if ( pTG->ReqTerminate || ( WaitResult == WAIT_OBJECT_0) )   {
                MyDebugPrint(pTG,  LOG_ALL, "TIFF_RX: wait for next page ABORTED at %ld \n", GetTickCount() ) ;
                goto bad_exit;
            }


            pTG->fTiffThreadRunning = 1;

            fLastReadBlockSync = pTG->fLastReadBlock;

            MyDebugPrint(pTG, LOG_ALL, "TIFF_RX: Waked up with next strip. fLastReadBlockSync=%d BytesIn=%d Out=%d at %ld \n",
                         fLastReadBlockSync,  pTG->BytesIn, pTG->BytesOut, GetTickCount() );

        }

        fFirstRead = 0;

    } while ( ! pTG->ReqTerminate );

    MyDebugPrint(pTG, LOG_ALL, "TIFF_RX: ERROR: Got Terminate request at %ld \n", GetTickCount() );
    pTG->fPageIsBad = 1;

    goto bad_exit;




good_exit:
    CloseHandle(InFileHandle);
    return TRUE;



bad_exit:
    CloseHandle(InFileHandle);
    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\main\send.c ===
/***************************************************************************
 Name     :     SEND.C
 Comment  :     Sender functions

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/

#include "prep.h"


#include <comdevi.h>
#include <faxcodec.h>

#include "efaxcb.h"

//#include "debug.h"

#include "cas.h"
#include "bgt30.h"
//#include "dynload.h"

#include "tiff.h"

#include "glbproto.h"

#include "t30gl.h"





SWORD   ICommGetSendBuf(PThrdGlbl pTG, LPBUFFER far* lplpbf, SLONG slOffset)
{

        /**
                slOffset == SEND_STARTBLOCK     marks beginning of new block
                slOffset == SEND_STARTPAGE      marks beginning of new block *and* page
                                        (returns with data from the "appropriate" file offset).

                slOffset == SEND_QUERYENDPAGE cbecks if end of page

                slOffset == SEND_SEQ    means get buffer from current file position
                slOffset >= 0   gives the offset in bytes from the last marked position
                                                (beginning of block) to start reading from

                Inst.cbBlockStart is always file offset of start of current block
                Inst.cbBlockSize is bytes sent of current block in first transmission
                Inst.cbPage is bytes left to transmit in current page

                returns: SEND_ERROR     on error, SEND_EOF on eof, SEND_OK otherwise.
                                 Does not return data on EOF or ERROR, i.e. *lplpbf==0
        **/

        SWORD           sRet = SEND_ERROR;
        LPBUFFER        lpbf;
        BOOL            HiRes=0;
        DWORD           dwBytesRead;



        if (pTG->fAbortRequested) {
            MyDebugPrint(pTG, LOG_ALL, "ICommGetSendBuf. got ABORT at %ld\n", GetTickCount() );
            sRet = SEND_ERROR;
            goto mutexit;
        }

        if(pTG->Inst.fAbort)         // GetSendBuf
        {
                // SetFailureCode already called
                sRet = SEND_ERROR;
                goto mutexit;
        }

        if(slOffset == SEND_QUERYENDPAGE)
        {
                MyDebugPrint(pTG, LOG_ALL, "SendBuf--query EndPage\r\n");

                BG_CHK(pTG->Inst.state == SENDDATA_PHASE || pTG->Inst.state == SENDDATA_BETWEENPAGES);
                if(pTG->Inst.cbPage == 0 || pTG->Inst.cbPage == -1)       // end of page
                {
                        pTG->Inst.cbPage = -1;
                        pTG->Inst.state = SENDDATA_BETWEENPAGES;
                        sRet = SEND_EOF;
                        goto mutexit;
                }
                else
                {
                        sRet = SEND_OK; // no data returned
                        goto mutexit;
                }
        }

        if(slOffset == SEND_STARTPAGE)
        {

                pTG->fTxPageDone=0;

                // Delete last successfully transmitted Tiff Page file.

                _fmemcpy (pTG->InFileName, gT30.TmpDirectory, gT30.dwLengthTmpDirectory);
                _fmemcpy (&pTG->InFileName[gT30.dwLengthTmpDirectory], pTG->lpszPermanentLineID, 8);
                if (pTG->PageCount != 0)  {
                    sprintf( &pTG->InFileName[gT30.dwLengthTmpDirectory+8], ".%03d",  pTG->PageCount);
                    if (! DeleteFileA (pTG->InFileName) ) {
                        MyDebugPrint(pTG, LOG_ERR, "ERROR: file %s can't be deleted; le=%lx at %ld \n",
                                                    pTG->InFileName, GetLastError(), GetTickCount() );

                    }

                }

                pTG->PageCount++ ;
                pTG->CurrentIn++ ;

                MyDebugPrint(pTG, LOG_ALL, "SendBuf: Starting New PAGE %d cbBlockSize=%ld First=%d Last=%d time=%ld\n",
                            pTG->PageCount, pTG->Inst.cbBlockSize, pTG->FirstOut, pTG->LastOut, GetTickCount() );

                // Server wants to know when we start TX new page.
                SignalStatusChange(pTG, FS_TRANSMITTING);

                BG_CHK(pTG->Inst.state == SENDDATA_BETWEENPAGES);
                BG_CHK(pTG->Inst.cbPage == -1);

                if (pTG->CurrentOut < pTG->CurrentIn ) {
                    MyDebugPrint(pTG, LOG_ERR, "ERROR: TIFF PAGE hadn't been started CurrentOut=%d; CurrentIn=%d at %ld \n",
                                               pTG->CurrentOut, pTG->CurrentIn, GetTickCount() );

                    sRet = SEND_ERROR;
                    goto mutexit;
                }


                // some slack for 1st page
                if ( (pTG->CurrentOut == pTG->CurrentIn) && (pTG->CurrentIn == 1 ) ) {

                    MyDebugPrint(pTG, LOG_ALL, "SEND: Wait for 1st page: CurrentOut=%d; In=%d at %ld \n",
                                               pTG->CurrentOut, pTG->CurrentIn, GetTickCount() );


                    if ( WaitForSingleObject(pTG->FirstPageReadyTxSignal, 5000)  == WAIT_TIMEOUT ) {
                        MyDebugPrint(pTG, LOG_ERR, "SEND: TIMEOUT ERROR Wait for 1st page: CurrentOut=%d; In=%d at %ld \n",
                                                   pTG->CurrentOut, pTG->CurrentIn, GetTickCount() );
                    }


                    MyDebugPrint(pTG, LOG_ALL, "SEND: Wakeup for 1st page: CurrentOut=%d; In=%d at %ld \n",
                                               pTG->CurrentOut, pTG->CurrentIn, GetTickCount() );

                }

                // open the file created by tiff thread

                sprintf( &pTG->InFileName[gT30.dwLengthTmpDirectory+8], ".%03d",  pTG->PageCount);

                if ( ( pTG->InFileHandle = CreateFileA(pTG->InFileName, GENERIC_READ, FILE_SHARE_READ,
                                                   NULL, OPEN_EXISTING, 0, NULL) ) == INVALID_HANDLE_VALUE ) {
                    MyDebugPrint(pTG, LOG_ERR, "ERROR: OpenFile %s fails; CurrentOut=%d; CurrentIn=%d at %ld \n",
                                               pTG->InFileName, pTG->CurrentOut, pTG->CurrentIn, GetTickCount() );

                    sRet = SEND_ERROR;
                    goto mutexit;
                }

                pTG->InFileHandleNeedsBeClosed = 1;


                if ( pTG->CurrentOut == pTG->CurrentIn ) {
                    MyDebugPrint(pTG, LOG_ALL, "WARNING: CurrentOut=%d; CurrentIn=%d at %ld \n",
                                               pTG->CurrentOut, pTG->CurrentIn, GetTickCount() );

                }

                //
                // Signal TIFF thread to start preparing new page if needed.
                //

                if  ( (! pTG->fTiffDocumentDone) && (pTG->LastOut - pTG->CurrentIn < 2) ) {
                    ResetEvent(pTG->ThrdSignal);
                    pTG->ReqStartNewPage = 1;
                    pTG->AckStartNewPage = 0;

                    MyDebugPrint(pTG, LOG_ALL, "SIGNAL NEW PAGE CurrentOut=%d; CurrentIn=%d at %ld \n",
                                               pTG->CurrentOut, pTG->CurrentIn, GetTickCount() );

                    SetEvent(pTG->ThrdSignal);
                }



                // uOldPermilleDone = 0;
                // SetStatus(T30STATS_SEND, pTG->Inst.awfi.uNumPages, 0, 0);

                pTG->Inst.cbPage = pTG->Inst.awfi.lDataSize;                      // size of page
                pTG->Inst.cbBlockStart = pTG->Inst.awfi.lDataOffset;      // start of 1st block
                pTG->Inst.cbBlockSize = 0;                                           // current size of block


                pTG->Inst.state = SENDDATA_PHASE;
                slOffset = SEND_SEQ;
                sRet = SEND_OK;
                goto mutexit;
        }
        else if(slOffset == SEND_STARTBLOCK)
        {
                // called in ECM mode at start of each block. Not called
                // in the first block of each page (STARTPAGE) is called
                // instead. Therefore BlockStart and BlockSize can never
                // be 0

                MyDebugPrint(pTG, LOG_ERR, "ERROR: ECM SendBuf: Starting New BLOCK. cbBlockSize=%ld\r\n", pTG->Inst.cbBlockSize);
                sRet = SEND_ERROR;
                goto mutexit;



        }

        BG_CHK(lplpbf);
        *lplpbf=0;

        if(slOffset == SEND_SEQ) {

            if (pTG->fTxPageDone) {

#if 0
                if (glSimulateError && (glSimulateErrorType == SIMULATE_ERROR_TX_IO) ) {
                    SimulateError( EXCEPTION_ACCESS_VIOLATION);
                }
#endif



                sRet = SEND_EOF;
                //BUGBUG RSL delete this file after page is acknowleged

                if (pTG->InFileHandleNeedsBeClosed) {
                    CloseHandle(pTG->InFileHandle);
                    pTG->InFileHandleNeedsBeClosed = 0;
                }
                goto mutexit;
            }

            lpbf = MyAllocBuf(pTG, pTG->Inst.sSendBufSize);
            BG_CHK(lpbf);
            BG_CHK(pTG->Inst.uSendDataSize <= lpbf->wLengthBuf-4);

            lpbf->lpbBegData = lpbf->lpbBegBuf+4;
            lpbf->dwMetaData = pTG->Inst.awfi.Encoding;

            lpbf->wLengthData = (unsigned) pTG->Inst.sSendBufSize;

            if ( ! ReadFile(pTG->InFileHandle, lpbf->lpbBegData, lpbf->wLengthData, &dwBytesRead, 0) )  {
                MyDebugPrint(pTG, LOG_ERR, "ERROR:Can't read %d bytes from %s \n", lpbf->wLengthData, pTG->InFileName);

                MyFreeBuf (pTG, lpbf);
                sRet = SEND_ERROR;
                goto mutexit;

            }

            if ( lpbf->wLengthData != (unsigned) dwBytesRead )  {
                if (pTG->fTiffPageDone || (pTG->CurrentIn != pTG->CurrentOut) ) {
                    // actually reached EndOfPage
                    lpbf->wLengthData = (unsigned) dwBytesRead;
                    pTG->fTxPageDone = 1;
                }
                else {
                    MyDebugPrint(pTG, LOG_ERR, "ERROR:Wanted %d bytes but ONLY %d ready from %s at %ld\n",
                                     lpbf->wLengthData, dwBytesRead, pTG->InFileName, GetTickCount() );

                    MyFreeBuf (pTG, lpbf);
                    sRet = SEND_ERROR;
                    goto mutexit;
                }
            }

            *lplpbf = lpbf;

            MyDebugPrint(pTG, LOG_ALL, "SEND_SEQ: length=%d \n", lpbf->wLengthData);
        }



        sRet = SEND_OK;

mutexit:

        return sRet;
}











void   ICommRawCaps(PThrdGlbl pTG, LPBYTE lpbCSI, LPBYTE lpbDIS, USHORT cbDIS,
                                                        LPFR FAR * rglpfrNSF, USHORT wNumFrames)
{

}











void   ICommSetSendMode(PThrdGlbl pTG, BOOL fECM, LONG sBufSize, USHORT uDataSize, BOOL fPad)
{
        BG_CHK(sBufSize && uDataSize && uDataSize <= sBufSize-4);
        pTG->Inst.sSendBufSize = sBufSize;
        pTG->Inst.uSendDataSize = uDataSize;
        pTG->Inst.fSendPad      = fPad;

}









USHORT   ICommNextSend(PThrdGlbl pTG)
{
        USHORT uRet = NEXTSEND_ERROR;

        if (pTG->PageCount >= pTG->TiffInfo.PageCount) {
            pTG->Inst.awfi.fLastPage = 1;
        }


        if(pTG->Inst.awfi.fLastPage)
                uRet = NEXTSEND_EOP;
        else
                uRet = NEXTSEND_MPS;



        MyDebugPrint(pTG, LOG_ALL, "ICommNextSend uRet=%d, fLastPage=%d \n", uRet,  pTG->Inst.awfi.fLastPage);

        return uRet;
}












BOOL   ICommSendPageAck(PThrdGlbl pTG, BOOL fAck)
{
        BOOL fRet = FALSE;


        BG_CHK(pTG->Inst.state == SENDDATA_BETWEENPAGES);

        if(fAck)
        {
                SetStatus(pTG, T30STATS_CONFIRM, pTG->Inst.awfi.uNumPages, 0, 0);
                pTG->Inst.uPageAcks++;
                fRet = FALSE;
        }
        else
        {
                SetStatus(pTG, T30STATS_REJECT, pTG->Inst.awfi.uNumPages, 0, 0);
#               ifdef RETRANS
//                        RewindSendPage();
                        fRet = TRUE;
#               else  // RETRANS
                        fRet = FALSE;
#               endif // RETRANS
        }

//mutexit:
        return fRet;
}




void 
ICommGotAnswer(
   PThrdGlbl pTG
)

{

        BG_CHK(pTG->Inst.state == BEFORE_ANSWER);
        pTG->Inst.state = BEFORE_RECVCAPS;

}








BOOL   ICommRecvCaps(PThrdGlbl pTG, LPBC lpBC)
{
    USHORT  uType;
    BOOL    fRet = FALSE;



#if 0
    BG_CHK(lpBC);
    BG_CHK(lpBC->bctype == RECV_CAPS);
    BG_CHK(lpBC->wTotalSize>=sizeof(BC));
    BG_CHK(lpBC->wTotalSize<=sizeof(pTG->Inst.RemoteRecvCaps));
    BG_CHK(pTG->Inst.fSending || pTG->Inst.fInPollReq);
#endif

    if (pTG->fAbortRequested) {
        MyDebugPrint(pTG, LOG_ALL, "ICommRecvCaps. got ABORT at %ld", GetTickCount() );
        fRet = FALSE;
        goto mutexit;
    }

    if(pTG->Inst.fAbort)         // recv caps
    {
            fRet = FALSE;
            goto mutexit;
    }

    if(pTG->Inst.state != BEFORE_RECVCAPS)
    {
            (MyDebugPrint(pTG,  LOG_ALL, "<<WARNING>> Got caps unexpectedly--ignoring\r\n"));
            // this will break if we send EOM...
            // then we should go back into RECV_CAPS state
            fRet = TRUE;
//RSL       goto mutexit;
    }

    _fmemset(&pTG->Inst.RemoteRecvCaps, 0, sizeof(pTG->Inst.RemoteRecvCaps));
    _fmemcpy(&pTG->Inst.RemoteRecvCaps, lpBC, min(sizeof(pTG->Inst.RemoteRecvCaps), lpBC->wTotalSize));

    if(lpBC->Std.vMsgProtocol == 0) // not Msg Protocol must be G3
            uType = DEST_G3;
    else if(!lpBC->Std.fBinaryData) // vMsgProtocol != 0 && !Binary
            uType = DEST_IFAX;
    else
            uType = DEST_EFAX;


#if 0 // RSL
#ifdef USECAPI
    // update capabilities database.
    // Note: +++ assumes UpdateCapabilitiesEntry overhead is small...
    //       If not, we'll have to do this after the call is over...
    {
            char    szPhone[PHONENUMSIZE];
            BG_CHK(pTG->Inst.aCapsPhone);

            if (!GlobalGetAtomName(pTG->Inst.aCapsPhone, szPhone, sizeof(szPhone)))
                    {BG_CHK(FALSE);}
            // +++ NYI First call normalizing function for phone...
            if (UpdateCapabilitiesEntry(szPhone,
                             lpBC->wTotalSize,
                             (LPBYTE) lpBC) != ERROR_SUCCESS)
            {
                    (MyDebugPrint(pTG,  LOG_ERR, SZMOD "<<ERROR>> Couldn't update remote caps\r\n"));
            }
    }
#else // !USECAPI
    PostMessage(pTG->Inst.hwndSend, IF_FILET30_DESTTYPERES, pTG->Inst.aPhone,
                            (LPARAM)MAKELONG(MAKEWORD(uType, lpBC->Fax.AwRes),
                                                             MAKEWORD(lpBC->Fax.Encoding, lpBC->Std.vSecurity)));
#endif // !USECAPI


#ifdef POLLREQ
    if(pTG->Inst.fInPollReq)
    {
            BG_CHK(!pTG->Inst.fSending);
            fRet = DoPollReq(lpBC);
            goto mutexit;
    }
#endif

#ifdef TSK
    // must be before Negotiate caps
    if(!OpenSendFiles(pTG->Inst.aFileMG3, pTG->Inst.aFileIFX, pTG->Inst.aFileEFX))
    {
            faxTlog((SZMOD "Can't open Send Files\r\n"));
            SetFailureCode(T30FAILS_FILEOPEN);
            fRet = FALSE;
            goto mutexit;
    }
#endif //TSK
#endif // 0 RSL



    if(!NegotiateCaps(pTG))
    {
            _fmemset(&pTG->Inst.SendParams, 0, sizeof(pTG->Inst.SendParams));
            // SetFailureCode already called
            fRet = FALSE;
            goto mutexit;
    }



    ////////// Now done in the ICommGetBC callback ////////
    //      if(pTG->Inst.uModemClass==FAXCLASS1 || pTG->Inst.uModemClass == FAXCLASS0)
    //      {
    //              LPFNCHK(lpfniET30ProtSetBC);
    //              // Set Send Params
    //              if(!lpfniET30ProtSetBC((LPBC)&pTG->Inst.SendParams, SEND_PARAMS))
    //              {
    //                      // SetFailureCode already called
    //                      fRet = FALSE;
    //                      goto mutexit;
    //              }
    //      }
    //      else
    ////////// Now done in the ICommGetBC callback ////////

#if defined(CL2) || defined(CL2_0)
    ////////// Now done in the ICommGetBC callback ////////
    //      if(pTG->Inst.uModemClass==FAXCLASS2 || pTG->Inst.uModemClass==FAXCLASS2_0)
    //      {
    //              LPFNCHK(lpfnClass2SetBC);
    //              // Set CLASS2 Send Params
    //              if(!lpfnClass2SetBC((LPBC)&pTG->Inst.SendParams, SEND_PARAMS))
    //              {
    //                      // SetFailureCode already called
    //                      fRet = FALSE;
    //                      goto mutexit;
    //              }
    //      }
    ////////// Now done in the ICommGetBC callback ////////
#endif //CL2

    pTG->Inst.state = SENDDATA_BETWEENPAGES;

    pTG->Inst.uPageAcks = 0;
    pTG->Inst.cbPage = -1;
#       ifdef CHK
            pTG->Inst.fRecvChecking = FALSE;
#       endif // CHK

    fRet = TRUE;

mutexit:

    return fRet;


    return (fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\main\t30.h ===
/***************************************************************************
 Name     :     T30.H
 Comment  :     Main include file for T30 driver.
                        All common structire defns etc.
 Functions:     (see Prototypes just below)

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/

#include "timeouts.h"


/**---------------------- #define of sizes of things ---------------------

        Frames can be at most 2.55 secs (sent) or 3.45 secs (recvd) long, or
        2.55 * 300/8 = 96 bytes and 132 bytes long respectively

        For clumps of received frames, we collect them in a GlobalAlloced
        space for passing to teh WhatNext callback function. We arbitrarily
        decide to allow at most 10 frames and at most 500 bytes at a time.
        (500 bytes = 500/(300/8) = 13.33 secs, so that should be quite enough)

---------------------- #define of sizes of things ---------------------**/

//#define ECM_TOTALFRAMESIZE    (ECM_FRAME_SIZE + 4)


// Used for calling ModemSync(). The shorter one during calls,
// the longer one only on hangup and stuff
#define RESYNC_TIMEOUT1         1100
#define RESYNC_TIMEOUT2         500


// This are way too long. We have built-in delays anyway, so don't need
// the full time, and the recvrs have to recv from other fax machines
// so take it easy here
// #define PHASEC_PAUSE                 100     // how long to pause before TCF/phase C
#define RECV_PHASEC_PAUSE               55      // used by RecvSil() before TCF/phase C
#define SEND_PHASEC_PAUSE               75      // used by SendSil() before TCF/phase C
// ModemRecvSilence() always waits a bit longer than the amount requested
// so to get it right we ask for the minimum required, i.e. 55ms
// However ModemSendSilence() is pretty accurate, so ask for teh exact
// nominal amount, i.e. 75ms


// How long to try for AT+FRM before timing out and trying
// for an AT+FRH instead. Must be 100% *sure* to get page if there
// is one, because there's no recovery after missing that. But must
// also be sure to get the 2nd CTC if there is one.
// Other critical situations:- MCF is missed, and sender resends MPS
// We miss this because we're in FRM, but we mustn't miss the 3rd one!
// Ditto with DCS-TCF-missedCFR. Can't get 2nd, but we'll get 3rd
// #define PHASEC_TIMEOUT               2800L           // 2.8s
// increase this to 3200. Limit is 3550, but we need 200ms or so to restart
// receiving FRH=3
#ifdef MDDI
        // if we are on an IFAX we can DEPEND on teh RECV_WRONGMODE code
        // being correctly implemented. In fact we need to because to handle
        // satelite delays, echos etc this timeout need to be LONG (equal
        // to T2 in fact), so we cant wait to timeout before recving V21
        // so the only way we're going to handle eth above situations is
        // if we always get the +FCERROR/WRONGMODE resp at the right time
#       define PHASEC_TIMEOUT   6000L   // 6secs
#else
#       define PHASEC_TIMEOUT   3300L   // 3.3s
#endif


// How long to try for AT+FRM in TCF before timing out and trying
// +FRH. Mustn't miss TCF, but if we do, must catch next DCS
// increase this to 3200. Limit is 3550, but we need 200ms or so to restart
// receiving FRH=3
#define TCF_TIMEOUT             3300L           // 3.3s


// don't need this one. Besides don't want to send it at startup when
// we're already transmitting HDLC. This can cause problems, if we already
// have a delay (example after TCF, sending CFR. Delay is now 115, it will
// become 180 or so).
// #define LOWSPEED_PAUSE               60              // how long to pause before HDLC
// reduce this too
#define RECV_LOWSPEED_PAUSE     55              // used by RecvSil() before HDLC
#define SEND_LOWSPEED_PAUSE     75              // used by SendSil() before HDLC
// ModemRecvSilence() always waits a bit longer than the amount requested
// so to get it right we ask for the minimum required, i.e. 55ms
// However ModemSendSilence() is pretty accurate, so ask for teh exact
// nominal amount, i.e. 75ms

// How long of silence to look for before sending V.21. (IFAX/MDDI only)
// Use LOWSPEED_PAUSE defined above.

// How long of silence to look for before sending PhaseC. (IFAX/MDDI only)
// use 40ms or more (want to be pretty sure we got silenec)
// ---> we use PHASEC_PAUSE which is OK

// How long to look for silence before sending high-speed.
// If this fails we go ahead and send anyway, so we don't want
// it too long. But we want to try pretty hard to get silence,
// because otherwise the other side will miss my training.
// 3secs is about how long a NSF-DIS takes. If we hit one
// we want to wait until it's done, not timeout??
#define LONG_RECVSILENCE_TIMEOUT        3000 // how long to wait for silence before send HDLC or PIX

// when sending DIS, DCS or DTC we may collide with DCS, DIS or DIS coming
// from the other side. This can be really long (preamble+2NSFs+CSI+DIS > 5secs)
// so wait for upto 6 secs (preamble + 150+ bytes)
#define REALLY_LONG_RECVSILENCE_TIMEOUT 6000 // how long to wait for silence before send DIS/DCS/DTC

// Used before TCF
#define SHORT_SENDSILENCE_TIMEOUT       100  // how long to wait for send-silence before TCF








#define ECHOPROTECT(ifr, mode)  { pTG->EchoProtect.ifrLastSent=ifr; pTG->EchoProtect.modePrevRecv=mode; pTG->EchoProtect.fGotWrongMode=0; }



/*****
// INI file settings related stuff
typedef struct
{
        USHORT  uIgnoreDIS;                     // non-zero==number of DIS to be ignored
        USHORT  uRecvT1Timer;           // 0==default otherwise==number of seconds
        USHORT  uSendT1Timer;           // 0==default otherwise==number of seconds

        // BOOL fTotalErrsOnly; // 0==burst 1==total
        // BOOL fNo999;                 // can't dial 999
        // USHORT       uCSICompare;    // 0==no compare 1==just existence of CSI
                                                        // 2==4 digits 3==8 digits
}
ET30INISETTINGS;
*****/

#define ECM_NEWPAGE             2
#define ECM_NEWBLOCK    1
#define ECM_RETRANSMIT  0





extern USHORT TCFLen[];



#define BadAction(pTG, a)            (ERRMSG((SZMOD "<<ERROR>> BadAction %d\r\n", a)), ICommFailureCode(pTG, T30FAIL_BUG0), BG_CHK(FALSE), actionERROR)
#define GetResponse(pTG, ifr)        GetCmdResp(pTG, FALSE, ifr)
#define GetCommand(pTG, ifr)         GetCmdResp(pTG, TRUE, ifr)

#define GetSendBuf(pTG, lplpbf, slOffset)    ICommGetSendBuf(pTG, lplpbf, slOffset)
#define PutRecvBuf(pTG, lpbf, slOffset)      ICommPutRecvBuf(pTG, lpbf, slOffset)


/****************** begin prototypes from ecm.c *****************/
ET30ACTION      ECMPhaseC(PThrdGlbl pTG, BOOL fReTx);
// ET30ACTION   ECMPhaseCRetrans(void);
ET30ACTION      ECMPhaseD(PThrdGlbl pTG);
ET30ACTION      ECMSendEOR_EOP(PThrdGlbl pTG);
ET30ACTION      ECMRecvPhaseD(PThrdGlbl pTG);
ET30ACTION      ECMRecvPhaseC(PThrdGlbl pTG, BOOL);
/***************** end of prototypes from ecm.c *****************/

/****************** begin prototypes from hdlc.c *****************/
USHORT ModemRecvBuf(PThrdGlbl pTG, HMODEM hModem, BOOL fECM, LPBUFFER far* lplpbf, ULONG ulTimeout);
/***************** end of prototypes from hdlc.c *****************/

/****************** begin prototypes from t30.c *****************/
IFR GetCmdResp(PThrdGlbl pTG, BOOL fCommand, USHORT ifrResp);
/***************** end of prototypes from t30.c *****************/



/****************** begin prototypes from t30main.c *****************/
USHORT T30MainBody(PThrdGlbl pTG, BOOL fCaller, ET30ACTION actionInitial, HLINE hLine, HMODEM hModem);
// BOOL GetDev(USHORT uPort);
// BOOL FreeDev(void);
/***************** end of prototypes from t30main.c *****************/




#define GetDevAndDial(pTG, port, phone)              (GetDev(pTG, port) && Dial(pTG, phone))
#define GetDevAndAnswer(pTG, port)                   (GetDev(pTG, port) && Answer(pTG))



#ifdef SWECM
#   pragma  message ("--------- WARNING: Software ECM ENABLED ----------")
        USHORT ModemECMRecvMode(PThrdGlbl pTG, HMODEM h, USHORT uMod, ULONG ulTimeout);
        BOOL SWECMSendSetup(PThrdGlbl pTG, BOOL fOn);
        BOOL SWECMRecvSetup(PThrdGlbl pTG, BOOL fOn);
        USHORT SWECMRecvFrame(PThrdGlbl pTG, HMODEM hModem, LPBYTE lpb, USHORT cbMax, ULONG ulTimeout, USHORT far* lpcbRecv);
        void D_HexPrint(LPB b1, UWORD incnt);
/***************** end of prototypes from swecm.c *****************/

#else
#       define ModemECMRecvMode(pTG, h, mod, t)      ModemRecvMode(pTG, h, mod, TRUE, t, ifrECMPIX)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\main\sendfr.c ===
/***************************************************************************
 Name     :     SENDFR.C
 Comment  :
 Functions:     (see Prototypes just below)

        Copyright (c) 1993 Microsoft Corp.

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/

#include "prep.h"

#include "efaxcb.h"

#include "protocol.h"

///RSL
#include "glbproto.h"

#define faxTlog(m)      DEBUGMSG(ZONE_SENDFR, m)
#define FILEID          FILEID_SENDFR








VOID BCtoNSFCSIDIS(PThrdGlbl pTG, NPRFS npfs, NPBC npbc, NPLLPARAMS npll)
{
        // Use bigger buf. Avoid truncating Id before stripping alphas
        char    szCSI[MAXTOTALIDLEN + 2];

        //BG_CHK(npbc->bctype==SEND_CAPS);
        //BG_CHK(npbc->wTotalSize >= sizeof(BC));

        ZeroRFS(pTG, npfs);

        // extract ID
        // GetTextId(npbc, szCSI, MAXTOTALIDLEN+1);

        if (pTG->LocalID) {
            strcpy (szCSI, pTG->LocalID);
        }


#ifdef OEMNSF
        CreateOEMFrames(pTG, ifrNSF, OEMNSF_POSBEFORE, npbc, npll, npfs);
#endif

        // RSL no NSF
#if 0
        // Send MS NSFs IFF ECM is enabled
        if (1) /// RSL (pTG->ProtInst.llSendCaps.fECM)
        {
                // Now create MS NSx
                CreateNSForNSCorNSS(pTG, ifrNSF, npfs, npbc, FALSE); // NO id in NSF
        }
        else
        {
                // zap MMR out of our DIS
                npbc->Fax.Encoding &= (~MMR_DATA);
        }
#endif

#ifdef OEMNSF
        CreateOEMFrames(pTG, ifrNSF, OEMNSF_POSAFTER, npbc, npll, npfs);
#endif


        if(_fstrlen(szCSI))
                CreateIDFrame(pTG, ifrCSI, npfs, szCSI, FALSE); // RSL: DON'T strip non-numerics for CSI

        CreateDISorDTC(pTG, ifrDIS, npfs, &npbc->Fax, npll);
}








VOID BCtoNSCCIGDTC(PThrdGlbl pTG, NPRFS npfs, NPBC npbc, NPLLPARAMS npll)
{
        // Use bigger buf. Avoid truncating Id before stripping alphas
        char    szCIG[MAXTOTALIDLEN + 2];
        BOOL    fSkipDTC;
        BOOL    fSkipCIG;

        BG_CHK(npbc->bctype==SEND_POLLREQ);
        BG_CHK(npbc->wTotalSize >= sizeof(BC));

        ZeroRFS(pTG, npfs);

        fSkipDTC = 0;
        fSkipCIG = 0;

        // extract ID
        GetTextId(npbc, szCIG, MAXTOTALIDLEN+1);

#ifdef OEMNSF
        if(fUsingOEMProt)
        {
                WORD    wFlags;

                BG_CHK(wOEMFlags);
                wFlags = CreateOEMFrames(pTG, ifrNSC, OEMNSF_POSBEFORE, npbc, npll, npfs);

                fSkipDTC = ((wFlags & OEMNSF_DONTSEND_DCS) != 0);
                fSkipCIG = ((wFlags & OEMNSF_DONTSEND_TSI) != 0);
        }
        else
#endif
        {
                if(npbc->wNumPollReq)
                {
                        // if we have NSC poll reqs send NSC _with_ our ID. This is reqd
                        // for return addressing of response. See bug#6224 and 6675. In
                        // this case CIG is redundant so dont send it.
                        // NOTE: The real check we want to do is to see if we are polling
                        // another AtWork amchine or a G3. This test is just a proxy. The
                        // result is a residual bug that G3/blind-polls from IFAX-to-IFAX
                        // will NOT be routed correctly, even though they could/should.
                        // G3/Blind-polls from IFAX-to-G3 will never be routed correctly
                        // so long as we rely on the pollee to do the routing, but IFAX
                        // to G3 blind polls wil work if we replace the
                        //              if(wNumPollReq)
                        // test with a
                        //              if(pollee is AtWork)
                        //
                        CreateNSForNSCorNSS(pTG, ifrNSC, npfs, npbc, TRUE);  // ID in NSC with poll req
                        fSkipCIG = TRUE;
                }
                else
                {
                        // no NSC poll reqs, so only send our basic NSC
                        // (ie. to advert capabilities) if we have ECM
                        // Dont send our ID in this case. CIG is good enough
                        if(pTG->ProtInst.llSendCaps.fECM)
                                CreateNSForNSCorNSS(pTG, ifrNSC, npfs, npbc, FALSE); // no id in NSC w/o poll req
                }
        }

        if(!pTG->ProtInst.llSendCaps.fECM)
        {
                // zap MMR out of our DTC
                npbc->Fax.Encoding &= (~MMR_DATA);
        }

        if(!fSkipCIG && _fstrlen(szCIG))
                CreateIDFrame(pTG, ifrCIG, npfs, szCIG, TRUE);
        // Strip non-numerics for CIG. Our FULL ID (used for addressing the
        // response) is sent in the NSC if we have NSC poll requests, so the
        // CIG is only for G3 display purposes. Strip alphas to conform
        // to spec & cut it down to size

        if(!fSkipDTC)
                CreateDISorDTC(pTG, ifrDTC, npfs, &npbc->Fax, npll);
}











void CreateNSForNSCorNSS(PThrdGlbl pTG, IFR ifr, NPRFS npfs, NPBC npbc, BOOL fSendID)
{
        WORD    wNumFrames;
        USHORT  uRet;
        int     i;
        // be sure to init these to zero
        WORD    wsz=0, wEnc=0, wLen=0;

#ifdef DEBUG
        // check BCtype first
        switch(ifr)
        {
          case ifrNSF:  /* RSL BG_CHK(npbc->bctype == SEND_CAPS); */ break;
          case ifrNSS:  BG_CHK(npbc->bctype == SEND_PARAMS); break;
          case ifrNSC:  BG_CHK(npbc->bctype == SEND_POLLREQ); break;
        }
#endif //DEBUG
        // RSL BG_CHK(npbc->wTotalSize >= sizeof(BC));


        if(!fSendID)
        {
                // if we dont want to send the ID, save the ptrs/params of text id
                // and zap it out of the BC struct before calling AWNSF
                // We restore everything before exiting this function
                wsz = npbc->wszTextId;
                wLen = npbc->wTextIdLen;
                wEnc = npbc->wTextEncoding;
                npbc->wszTextId = npbc->wTextIdLen = npbc->wTextEncoding = 0;
        }

        if(uRet = BC_TO_NSX(pTG, ifr, npbc, fsFreePtr(pTG, npfs), (WORD) fsFreeSpace(pTG, npfs), &wNumFrames))
        {
                (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> BCtoNSx returned error %d\r\n", uRet));
                // go restore pointers if neccesary
                goto done;
        }
        else if(wNumFrames)
        {
                LPLPFR rglpfr = (LPLPFR)fsFreePtr(pTG, npfs);
                LPBYTE lpbLim = (LPBYTE)fsFreePtr(pTG, npfs);

                for(i=0; i<(int)wNumFrames; i++)
                {
                        (MyDebugPrint(pTG, LOG_ALL,  "Created NSF/NSC, len=%d\r\n", rglpfr[i]->cb));
                        BG_CHK((LPBYTE)(rglpfr[i]) >= fsStart(pTG, npfs));
                        BG_CHK(rglpfr[i]->fif+rglpfr[i]->cb <= fsLim(pTG, npfs));

#ifndef NOCHALL
                        if(ifr==ifrNSF && i==0)
                        {
                                BG_CHK(rglpfr[i]->cb > 3);
                                pTG->uSavedChallengeLen = min(rglpfr[i]->cb-3, POLL_CHALLENGE_LEN);
                                _fmemcpy(pTG->bSavedChallenge, rglpfr[i]->fif+3, pTG->uSavedChallengeLen);
                        }
#endif //!NOCHALL

                        if(npfs->uNumFrames < MAXFRAMES)
                        {
                                npfs->rglpfr[npfs->uNumFrames++] = rglpfr[i];
                                lpbLim = max(lpbLim, rglpfr[i]->fif+rglpfr[i]->cb);
                        }
                        else { BG_CHK(FALSE); break; }
                }
                npfs->uFreeSpaceOff = (USHORT)(lpbLim - ((LPBYTE)(npfs->b)));
                BG_CHK(npfs->uFreeSpaceOff <= fsSize(pTG, npfs) && npfs->uNumFrames <= MAXFRAMES);
        }
        else { BG_CHK(FALSE); }

done:
        // restore TextId in BC, if we had zapped it out!
        if(wsz)  npbc->wszTextId         = wsz;
        if(wLen) npbc->wTextIdLen        = wLen;
        if(wEnc) npbc->wTextEncoding = wEnc;
        return;
}









void CreateIDFrame(PThrdGlbl pTG, IFR ifr, NPRFS npfs, LPSTR szId, BOOL fStrip)
{
        BYTE szTemp[IDFIFSIZE+2];
        USHORT i, j;
        NPFR    npfr;

        npfr = (NPFR) fsFreePtr(pTG, npfs);
        if( fsFreeSpace(pTG, npfs) <= (sizeof(FRBASE)+IDFIFSIZE) ||
                npfs->uNumFrames >= MAXFRAMES)
        {
                BG_CHK(FALSE);
                return;
        }

if(fStrip)
{
        // CreateID strips non-numeric parts. Must send TSI when
        // we do EFAX-to-EFAX in G3 mode. See bug#771

        for(i=0, j=0; szId[i] && j<IDFIFSIZE; i++)
        {
                // copy over all numerics and NON-LEADING blanks
                // throw away all leading blanks
                if( (szId[i] >= '0' && szId[i] <= '9') ||
                        (szId[i] == ' ' && j != 0))
                {
                        szTemp[j++] = szId[i];
                }
                // send + and - as space. At other end, when we get a
                // single leading space convert that to +. Leave other spaces
                // unmolested. This is so that EFAX-to-EFAX in G3 mode
                // with canonical numbers, reply will work correctly
                // see bug#771
                if(szId[i] == '+' || szId[i] == '-')
                {
                        szTemp[j++] = ' ';
                }
        }
        szTemp[j++] = 0;
}
else
{
        _fmemcpy(szTemp, szId, IDFIFSIZE);
        szTemp[IDFIFSIZE] = 0;
}

        (MyDebugPrint(pTG,  LOG_ALL, "CreateID: Got<%s> Sent<%s>\r\n", (LPSTR)szId, (LPSTR)szTemp));

        if(_fstrlen(szTemp))
        {
                CreateStupidReversedFIFs(pTG, npfr->fif, szTemp);

                npfr->ifr = ifr;
                npfr->cb = IDFIFSIZE;
                npfs->rglpfr[npfs->uNumFrames++] = npfr;
                npfs->uFreeSpaceOff += IDFIFSIZE+sizeof(FRBASE);
                BG_CHK(npfs->uFreeSpaceOff <= fsSize(pTG, npfs) && npfs->uNumFrames <= MAXFRAMES);
        }
        else
        {
                (MyDebugPrint(pTG, LOG_ALL,  "WARNING: %s ID is EMPTY. Not sending\r\n", (LPSTR)(fStrip ? "STRIPPED" : "ORIGINAL") ));
        }
}


















void CreateDISorDTC(PThrdGlbl pTG, IFR ifr, NPRFS npfs, NPBCFAX npbcFax, NPLLPARAMS npll)
{
        USHORT  uLen;
        NPFR    npfr;

        if( fsFreeSpace(pTG, npfs) <= (sizeof(FRBASE)+sizeof(DIS)) ||
                npfs->uNumFrames >= MAXFRAMES)
        {
                BG_CHK(FALSE);
                return;
        }
        npfr = (NPFR) fsFreePtr(pTG, npfs);

        uLen = SetupDISorDCSorDTC(pTG, (NPDIS)npfr->fif, npbcFax, npll, 0, npll->fECM64);
        BG_CHK(uLen >= 3 && uLen <= 8);
        // BG_CHK(npfr->fif[uLen-1] == 0);      // send a final 0 byte

        npfr->ifr = ifr;
        npfr->cb = (BYTE) uLen;
        npfs->rglpfr[npfs->uNumFrames++] = npfr;
        npfs->uFreeSpaceOff += uLen+sizeof(FRBASE);
        BG_CHK(npfs->uFreeSpaceOff <= fsSize(pTG, npfs) && npfs->uNumFrames <= MAXFRAMES);
}






















VOID CreateNSSTSIDCS(PThrdGlbl pTG, NPPROT npProt, NPRFS npfs, USHORT uWhichDCS)
{

        // uWhichDCS:: 0==1st DCS  1==after NoReply  2==afterFTT

        NPBC    npbc = (NPBC)&(npProt->SendParams);
        BOOL    fEfax;
        // Use bigger buf. Avoid truncating Id before stripping alphas
        char    szTSI[MAXTOTALIDLEN + 2];


        BG_CHK(npProt->fSendParamsInited);
        BG_CHK(npbc->bctype==SEND_PARAMS);
        BG_CHK(npbc->wTotalSize >= sizeof(BC));

        BG_CHK(npProt->fllRecvCapsGot);
        BG_CHK(npProt->fllSendParamsInited);
        BG_CHK(npProt->fHWCapsInited);

/********** moved to the RECVCAPS point. see bug#731 ********************
        if(uWhichDCS==0)                        // don't renegotiate after NoRely or FTT
        {
                NegotiateLowLevelParams(&npProt->llRecvCaps, &npProt->llSendParams,
                        npbc->Fax.AwRes, npbc->Fax.Encoding, &npProt->llNegot);
                npProt->fllNegotiated = TRUE;
                EnforceMaxSpeed(npProt);
        }
*************************************************************************/

        BG_CHK(npProt->fllNegotiated);

        // don't print -- too slow
        // (MyDebugPrint(pTG,  "In CreateNSSTSIDCS after negotiation\r\n"));
        // D_PrintBC(npbc, &npProt->llNegot);

        ZeroRFS(pTG, npfs);

        // Send only TSI-DCS or NSS-DCS. Never a need to send TSI with NSS
        // (can bundle ID into message)

        // extract ID
        // BUGBUG RSL need to get from the Registry.

        // GetTextId(npbc, szTSI, MAXTOTALIDLEN+1);
        if (pTG->LocalID) {
            strcpy (szTSI, pTG->LocalID);
        }


#ifdef OEMNSF
        if(fUsingOEMProt)       // using OEM, not MS At Work NSSs
        {
                WORD wFlags;

                BG_CHK(wOEMFlags);

                wFlags = CreateOEMFrames(pTG, ifrNSS, 0, npbc, &npProt->llNegot, npfs);
                BG_CHK(wFlags);

                if(!(wFlags & OEMNSF_DONTSEND_TSI))
                        CreateIDFrame(pTG, ifrTSI, npfs, szTSI, TRUE); //STRIP alphas in TSI

                if(!(wFlags & OEMNSF_DONTSEND_DCS))
                        CreateDCS(pTG, npfs, &(npbc->Fax), &npProt->llNegot);
        }
        else
#endif //OEMNSF
        {
                fEfax = (npbc->NSS.vMsgProtocol != 0);

                // RSL no NSF
                if(0)
                {
                        // must be TRUE otheriwse we have negotaited ourselves into a corner here
                        BG_CHK(npProt->llNegot.fECM);
                        CreateNSForNSCorNSS(pTG, ifrNSS, npfs, npbc, FALSE); // no ID in NSS
                }
                else
                {
                        // CreateID strips non-numeric parts. Must send TSI when
                        // we do EFAX-to-EFAX in G3 mode. See bug#771
                        if(_fstrlen(szTSI))
                        {
                                // This is for Snowball, as per bug#771
                                CreateIDFrame(pTG, ifrTSI, npfs, szTSI, FALSE); //RSL: DON'T STRIP alphas in TSI
                        }
                }

                CreateDCS(pTG, npfs, &(npbc->Fax), &npProt->llNegot);

                BG_CHK((npbc->NSS.vMsgProtocol == 0) ||
                                (!npbc->Fax.AwRes && !npbc->Fax.Encoding));
        }
}











void CreateDCS(PThrdGlbl pTG, NPRFS npfs, NPBCFAX npbcFax, NPLLPARAMS npll)
{
        USHORT  uLen;
        NPFR    npfr;

        if( fsFreeSpace(pTG, npfs) <= (sizeof(FRBASE)+sizeof(DIS)) ||
                npfs->uNumFrames >= MAXFRAMES)
        {
                BG_CHK(FALSE);
                return;
        }
        npfr = (NPFR) fsFreePtr(pTG, npfs);

        BG_CHK(npbcFax->fPublicPoll==0);
        npbcFax->fPublicPoll = 0;
                // the G3Poll bit *has* to be 0 in DCS
                // else the OMNIFAX G77 and GT croak
                // the PWD/SEP/SUB bits *have* to be 0 in DCS
                // Baud rate, ECM and ECM frame size according to lowlevel negotiation
                // everything else according to high level negotiation

        uLen = SetupDISorDCSorDTC(pTG, (NPDIS)npfr->fif, npbcFax,
                                                                npll, npll->fECM, npll->fECM64);

        BG_CHK(uLen >= 3 && uLen <= 8);
        // BG_CHK(npfr->fif[uLen-1] == 0);      // send a final 0 byte
        // make sure that DCS we send is no longer than the DIS we receive.
        // This should automatically be so
        BG_CHK(pTG->ProtInst.uRemoteDISlen ? (uLen-1 <= pTG->ProtInst.uRemoteDISlen) : TRUE);
        BG_CHK(pTG->ProtInst.uRemoteDTClen ? (uLen-1 <= pTG->ProtInst.uRemoteDTClen) : TRUE);

        // If DCS is longer than the recvd DIS truncate the DCS to the same
        // length as the DIS. (It should never be more than 1byte longer --
        // because of the extra 0).

        if(pTG->ProtInst.uRemoteDISlen && (pTG->ProtInst.uRemoteDISlen < uLen))
                uLen = pTG->ProtInst.uRemoteDISlen;
        else if(pTG->ProtInst.uRemoteDTClen && (pTG->ProtInst.uRemoteDTClen < uLen))
                uLen = pTG->ProtInst.uRemoteDTClen;

        npfr->ifr = ifrDCS;
        npfr->cb = (BYTE) uLen;
        npfs->rglpfr[npfs->uNumFrames++] = npfr;
        npfs->uFreeSpaceOff += uLen+sizeof(FRBASE);
        BG_CHK(npfs->uFreeSpaceOff <= fsSize(pTG, npfs) && npfs->uNumFrames <= MAXFRAMES);
}

#ifdef NSF_TEST_HOOKS

#pragma message("<<WARNING>> INCLUDING NSF TEST HOOKS")









BOOL NSFTestGetNSx (PThrdGlbl pTG, IFR ifr, LPBC lpbcIn,
                      LPBYTE lpbOut, WORD wMaxOut, LPWORD lpwNumFrame)
{
        BOOL fRet=FALSE;
        DWORD_PTR dwKey=ProfileOpen(DEF_BASEKEY, szNSFTEST, fREG_READ);
        char rgchTmp32[32];
        LPSTR lpsz=NULL;
        UINT ucb,ucb0;
        if (!dwKey) goto end;

        switch(ifr)
        {
          case ifrNSF:  lpsz = "NSF";   break;
          case ifrNSS:  lpsz = "NSS";   break;
          case ifrNSC:  lpsz = "NSC";   break;
          default:      BG_CHK(FALSE);          goto end;
        }

        wsprintf(rgchTmp32, "Send%sFrameCount", (LPSTR) lpsz);
        *lpwNumFrame = (WORD) ProfileGetInt(dwKey, rgchTmp32, 0, NULL);

        if(!*lpwNumFrame) goto end;

        // Save space for frame pointer array
        ucb=sizeof(LPFR) * *lpwNumFrame;
        if (wMaxOut <= ucb) goto end;

        wsprintf(rgchTmp32, "Send%sFrames", (LPSTR) lpsz);
        ucb0=ProfileGetData(dwKey, rgchTmp32, lpbOut+ucb, wMaxOut-ucb);
        if (!ucb0) goto end;

#ifdef DEBUG
        {
                char rgchTmp64[64];
                UINT u,v;
                (MyDebugPrint(pTG,  LOG_ERR, "\r\nTEST-NSF: Dump  of %u send frame(s):\r\n",
                                        (unsigned) *lpwNumFrame));
                rgchTmp64[0]=0;
                for (u=0,v=0;u<ucb0;u++)
                {
                  v += wsprintf(rgchTmp64+v, " %02x", (unsigned) lpbOut[ucb+u]);
                  if ((v+8) >= sizeof(rgchTmp64))
                  {
                        (MyDebugPrint(pTG,  LOG_ERR,  "\t%s\r\n", (LPSTR) rgchTmp64));
                        v=0;
                        rgchTmp64[0]=0;
                  }
                }
                (MyDebugPrint(pTG,  LOG_ERR,  "\t%s\r\n", (LPSTR) rgchTmp64));

        }
#endif
        // Initialize frame pointer array
        {
                UINT u;
                UINT ucbtot = ucb+ucb0;
                for (u=0;u<*lpwNumFrame;u++)
                {
                        LPFR lpfr = (LPFR) (lpbOut+ucb);
                        (MyDebugPrint(pTG,  LOG_ERR, "NSFTest: u=%lu, ifr=%lu, cb=%lu, ucb=%lu\r\n",
                                        (unsigned long) u,
                                        (unsigned long) lpfr->ifr,
                                        (unsigned long) lpfr->cb,
                                        (unsigned long) ucb));
                        if (lpfr->ifr!=ifr) goto bad_frames;
                        if (lpfr->cb>100) // awnsfapi.h says max frame size=70.
                                goto bad_frames;
                        if ((ucb+sizeof(FRBASE)+lpfr->cb)>ucbtot)
                                goto bad_frames;

                        ((LPFR *)(lpbOut))[u] = lpfr;
                        ucb+=sizeof(FRBASE)+lpfr->cb;
                }
        }

        fRet=TRUE;
        goto end;

bad_frames:
        (MyDebugPrint(pTG,  LOG_ERR, "TEST-NSF: Bad frames from registry\r\n"));
        // fall through..

end:
        if (dwKey) ProfileClose(dwKey);

        if (!fRet) {(MyDebugPrint(pTG,  LOG_ALL,  "WARNING: NSFTestGetNSx FAILS!\r\n"));}

        return fRet;
}


















BOOL NSFTestPutNSx(PThrdGlbl pTG, IFR ifr, LPLPFR rglpfr, WORD wNumFrame,
                                                LPBC lpbcOut, WORD wBCSize)
{
        BOOL fRet=FALSE;
        DWORD_PTR dwKey=ProfileOpen(DEF_BASEKEY, szNSFTEST, fREG_CREATE|fREG_WRITE);
        char rgchTmp32[32];
        char rgchTmp10[10];
        BYTE rgbTmp256[256];
        LPSTR lpsz=NULL;
        UINT    u;
        UINT ucb=0;

        if (!dwKey) goto end;

        switch(ifr)
        {
          case ifrNSF:  lpsz = "NSF";   break;
          case ifrNSS:  lpsz = "NSS";   break;
          case ifrNSC:  lpsz = "NSC";   break;
          default:      BG_CHK(FALSE);          goto end;
        }

        // Tack frames together...
        ucb=0;
        for(u=0; u<wNumFrame; u++)
        {
                UINT    uLen = sizeof(FRBASE)+rglpfr[u]->cb;

                if ((ucb+uLen) > sizeof(rgbTmp256))
                {
                        (MyDebugPrint(pTG,  LOG_ERR,  "<<WARNING>>NSFTEST: Out of space!\r\n"));
                        break;
                }
                _fmemcpy(rgbTmp256+ucb, (LPBYTE)rglpfr[u], uLen);
                ucb+=uLen;
        }

        if(u)
        {
                wsprintf(rgchTmp32, "Recvd%sFrames", (LPSTR) lpsz);
                if (!ProfileWriteData(dwKey, rgchTmp32, rgbTmp256, ucb)) goto end;
        }

        wsprintf(rgchTmp32, "Recvd%sFrameCount", (LPSTR) lpsz);
        wsprintf(rgchTmp10, "%u", (unsigned) (u&0xff));
        if (!ProfileWriteString(dwKey, rgchTmp32, rgchTmp10, FALSE)) goto end;


        fRet=TRUE;

end:
        if (dwKey) ProfileClose(dwKey);

        if (!fRet) {(MyDebugPrint(pTG,  LOG_ERR,  "NSFTestPutNSx FAILS!\r\n"));}

        return fRet;
}

#endif // NSF_TEST_HOOKS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\main\t30u.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    t30u.c

Abstract:

    This is the interface with T.30 DLL

Author:

    Rafael Lisitsa (RafaelL) 2-Feb-1996


Revision History:

--*/


#define UNICODE
#define _UNICODE



#include "prep.h"


#include "tiff.h"

#include "glbproto.h"

#include "t30gl.h"



///////////////////////////////////////////////////////////////////////////////////
VOID  CALLBACK
T30LineCallBackFunction(
    HANDLE              hFax,
    DWORD               hDevice,
    DWORD               dwMessage,
    DWORD_PTR           dwInstance,
    DWORD_PTR           dwParam1,
    DWORD_PTR           dwParam2,
    DWORD_PTR           dwParam3
    )

{

T30LineCallBackFunctionA(
    hFax,
    hDevice,
    dwMessage,
    dwInstance,
    dwParam1,
    dwParam2,
    dwParam3
    );


} /* LineCallBackProc */











///////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI
FaxDevInitialize(
    IN  HLINEAPP                  LineAppHandle,
    IN  HANDLE                    HeapHandle,
    OUT PFAX_LINECALLBACK        *LineCallbackFunction,
    IN  PFAX_SERVICE_CALLBACK     FaxServiceCallback
    )
{


return(
FaxDevInitializeA(
    LineAppHandle,
    HeapHandle,
    LineCallbackFunction,
    FaxServiceCallback
    ));

}



///////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI
FaxDevStartJob(
    HLINE           LineHandle,
    DWORD           DeviceId,
    PHANDLE         pFaxHandle,
    HANDLE          CompletionPortHandle,
    ULONG_PTR        CompletionKey
    )

{

return(
FaxDevStartJobA(
    LineHandle,
    DeviceId,
    pFaxHandle,
    CompletionPortHandle,
    CompletionKey
    ));



}




///////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI
FaxDevEndJob(
    HANDLE          FaxHandle
    )

{

return(
FaxDevEndJobA(
    FaxHandle
    ));


}




///////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI
FaxDevSend(
    IN  HANDLE FaxHandle,
    IN  PFAX_SEND FaxSend,
    IN  PFAX_SEND_CALLBACK FaxSendCallback
    )

{


    FAX_SEND_A      NewFaxSend;

    NewFaxSend.SizeOfStruct = FaxSend->SizeOfStruct;
    NewFaxSend.FileName = UnicodeStringToAnsiString (FaxSend->FileName);
    NewFaxSend.CallerName = UnicodeStringToAnsiString (FaxSend->CallerName);
    NewFaxSend.CallerNumber = UnicodeStringToAnsiString (FaxSend->CallerNumber);
    NewFaxSend.ReceiverName = UnicodeStringToAnsiString (FaxSend->ReceiverName);
    NewFaxSend.ReceiverNumber = UnicodeStringToAnsiString (FaxSend->ReceiverNumber);




return(
FaxDevSendA(
    FaxHandle,
    &NewFaxSend,
    FaxSendCallback
    ));


}


///////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI
FaxDevReceive(
    HANDLE              FaxHandle,
    HCALL               CallHandle,
    PFAX_RECEIVE        FaxReceive
    )


{


    FAX_RECEIVE_A       NewFaxReceive;


    NewFaxReceive.SizeOfStruct = FaxReceive->SizeOfStruct;
    NewFaxReceive.FileName = UnicodeStringToAnsiString(FaxReceive->FileName);
    NewFaxReceive.ReceiverName = UnicodeStringToAnsiString(FaxReceive->ReceiverName);
    NewFaxReceive.ReceiverNumber = UnicodeStringToAnsiString(FaxReceive->ReceiverNumber);



    return(
        FaxDevReceiveA(
            FaxHandle,
            CallHandle,
            &NewFaxReceive
            ));


}


///////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI
FaxDevReportStatus(
    IN  HANDLE FaxHandle OPTIONAL,
    OUT PFAX_DEV_STATUS FaxStatus,
    IN  DWORD FaxStatusSize,
    OUT LPDWORD FaxStatusSizeRequired
    )


{

return(
FaxDevReportStatusA(
    FaxHandle,
    FaxStatus,
    FaxStatusSize,
    FaxStatusSizeRequired
    ));

}


///////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI
FaxDevAbortOperation(
    HANDLE              FaxHandle
    )


{


return(
FaxDevAbortOperationA(
    FaxHandle
    ));


}


////////////////////////////////////////////////////////////////////////////




HANDLE
TiffCreateW(
    LPWSTR FileName,
    DWORD  CompressionType,
    DWORD  ImageWidth,
    DWORD  FillOrder,
    DWORD  HiRes
    )

{



return(
TiffCreate(
    FileName,
    CompressionType,
    ImageWidth,
    FillOrder,
    HiRes
    ));

}





HANDLE
TiffOpenW(
    LPWSTR FileName,
    PTIFF_INFO TiffInfo,
    BOOL ReadOnly
    )


{

return (
TiffOpen(
    FileName,
    TiffInfo,
    ReadOnly,
    FILLORDER_LSB2MSB
    ));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\main\t30api.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    t30api.c

Abstract:

    This is the interface with T.30 DLL

Author:

    Rafael Lisitsa (RafaelL) 2-Feb-1996


Revision History:

--*/

#define  DEFINE_T30_GLOBALS
#include "prep.h"


#include "tiff.h"

#include "glbproto.h"

#include "t30gl.h"


///RSL Wes should export this.
#define  TAPI_VERSION       0x00020000
#define  ABORT_ACK_TIMEOUT  20000




///////////////////////////////////////////////////////////////////////////////////
VOID  CALLBACK
T30LineCallBackFunctionA(
    HANDLE              hFax,
    DWORD               hDevice,
    DWORD               dwMessage,
    DWORD_PTR           dwInstance,
    DWORD_PTR           dwParam1,
    DWORD_PTR           dwParam2,
    DWORD_PTR           dwParam3
    )

{
    LONG_PTR             i;
    PThrdGlbl           pTG = NULL;
    char                rgchTemp128[128];
    LPSTR               lpszMsg = "Unknown";

    MyDebugPrint(pTG, LOG_ALL, "!!! LineCallBack !!! hFax=%lx, dev=%lx, msg=%lx, dwInst=%lx,P1=%lx, P2=%lx, P3=%lx\n",
                hFax, hDevice, dwMessage, dwInstance, dwParam1, dwParam2, (unsigned long) dwParam3);

    // find the thread that this callback belongs to
    //----------------------------------------------

    i = (LONG_PTR) hFax;

    if (i < 1   ||   i >= MAX_T30_CONNECT) {
        MyDebugPrint(pTG, LOG_ALL, "T30LineCallback-wrong handle=%x\n", i);
        return;
    }


    if ( (! T30Inst[i].fAvail) && T30Inst[i].pT30) {
        pTG = (PThrdGlbl) T30Inst[i].pT30;
    }
    else {
        MyDebugPrint(pTG, LOG_ERR, "ERROR:T30LineCallback-handle=%x invalid \n", i);
        return;
    }



    switch (dwMessage) {
    case LINE_LINEDEVSTATE:
                    lpszMsg = "LINE_LINEDEVSTATE";
        if (dwParam1 == LINEDEVSTATE_RINGING)
                    {
                            MyDebugPrint(pTG, LOG_ALL, "Ring Count = %lx\n", (unsigned long) dwParam3);

                    }
        else if (dwParam1 == LINEDEVSTATE_REINIT)
                    {

                    }
            break;

    case LINE_ADDRESSSTATE:
                    lpszMsg = "LINE_ADDRESSSTATE";
            break;

    /* process state transition */
    case LINE_CALLSTATE:
                    lpszMsg = "LINE_CALLSTATE";

                    if (dwParam1 == LINECALLSTATE_CONNECTED) {
                        pTG->fGotConnect = TRUE;
                    }
                    else if (dwParam1 == LINECALLSTATE_IDLE) {
                        if (pTG->fDeallocateCall == 0)  {

                            pTG->fDeallocateCall = 1;

#if 0
//
// this is now performed in the fax service
//
                            lRet = lineDeallocateCall( (HCALL) hDevice);
                            if (lRet) {
                                MyDebugPrint(pTG, LOG_ERR, "ERROR: IDLE lineDeallocateCall returns %lx\n", lRet);
                            }
                            else {
                                MyDebugPrint(pTG, LOG_ALL, "IDLE lineDeallocateCall SUCCESS\n");
                            }
#endif
                        }
                    }

        break;

    case LINE_CREATE:
                    lpszMsg = "LINE_CREATE";
            break;

    case LINE_CLOSE:
                    lpszMsg = "LINE_CLOSE";


            break; // LINE_CLOSE

    /* handle simple tapi request. */
    case LINE_REQUEST:
                    lpszMsg = "LINE_REQUEST";
            break; // LINE_REQUEST

    /* handle the assync completion of TAPI functions
       lineMakeCall/lineDropCall */
    case LINE_REPLY:
                    lpszMsg = "LINE_REPLY";
                    if (!hDevice)
                            {itapi_async_signal(pTG, (DWORD)dwParam1, (DWORD)dwParam2, dwParam3);}
                    else
                            MyDebugPrint(pTG, LOG_ALL, "Ignoring LINE_REPLY with nonzero device\n");
            break;

    /* other messages that can be processed */
    case LINE_CALLINFO:
                    lpszMsg = "LINE_CALLINFO";
        break;

    case LINE_DEVSPECIFIC:
                    lpszMsg = "LINE_DEVSPECIFIC";
        break;

    case LINE_DEVSPECIFICFEATURE:
                    lpszMsg = "LINE_DEVSPECIFICFEATURE";
        break;

    case LINE_GATHERDIGITS:
                    lpszMsg = "LINE_GATHERDIGITS";
        break;

    case LINE_GENERATE:
                    lpszMsg = "LINE_GENERATE";
        break;

    case LINE_MONITORDIGITS:
                    lpszMsg = "LINE_MONITORDIGITS";
        break;

    case LINE_MONITORMEDIA:
                    lpszMsg = "LINE_MONITORMEDIA";
        break;

    case LINE_MONITORTONE:
                    lpszMsg = "LINE_MONITORTONE";
        break;

    } /* switch */

    _stprintf(rgchTemp128,
            "%s(p1=0x%lx, p2=0x%lx, p3=0x%lx)",
                    (LPTSTR) lpszMsg,
                    (unsigned long) dwParam1,
                    (unsigned long) dwParam2,
                    (unsigned long) dwParam3);

    MyDebugPrint(pTG, LOG_ALL, "Device:0x%lx; Message:%s\n", (unsigned long) hDevice,
                                    (LPTSTR) rgchTemp128);

} /* LineCallBackProc */











///////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI
FaxDevInitializeA(
    IN  HLINEAPP                 LineAppHandle,
    IN  HANDLE                   HeapHandle,
    OUT PFAX_LINECALLBACK        *LineCallbackFunction,
    IN  PFAX_SERVICE_CALLBACK    FaxServiceCallback
    )

/*++

Routine Description:
    Device Provider Initialization.


Arguments:


Return Value:


--*/

{   int          i;
    LONG         lRet;
    TCHAR        LogFileLocation[256];
    HKEY         hKey;
    DWORD        dwType;
    DWORD        dwSizeNeed;
    int          iLen;


    gT30.LineAppHandle = LineAppHandle;
    gT30.HeapHandle    = HeapHandle;
    gT30.fInit         = TRUE;


    HeapExistingInitialize(gT30.HeapHandle);
    FaxTiffInitialize();

    *LineCallbackFunction =  T30LineCallBackFunction;

    for (i=1; i<MAX_T30_CONNECT; i++) {
        T30Inst[i].fAvail = TRUE;
        T30Inst[i].pT30   = NULL;
    }

    InitializeCriticalSection(&T30CritSection);



    for (i=0; i<MAX_T30_CONNECT; i++) {
        T30Recovery[i].fAvail = TRUE;
    }

    InitializeCriticalSection(&T30RecoveryCritSection);


    // debugging

    gfScrnPrint = 0;
    gfFilePrint = 1;     // leave it alone


    lRet = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    "Software\\Microsoft\\Fax\\Device Providers\\Microsoft Modem Device Provider",
                    0,
                    KEY_READ,
                    &hKey);

    if (lRet == ERROR_SUCCESS) {

        dwSizeNeed = sizeof(int);

        lRet = RegQueryValueEx(
                               hKey,
                               "ModemLogLevel",
                               0,
                               &dwType,
                               (LPBYTE) &gT30.DbgLevel,
                               &dwSizeNeed);

        if ( ( lRet != ERROR_SUCCESS) || (dwType != REG_DWORD) ) {


            gT30.DbgLevel = 0;
            gfFilePrint = 0;
        }



        ProfileGetString( (ULONG_PTR) hKey,
                           "ModemLogLocation",
                           "C:",
                           LogFileLocation,
                           sizeof(LogFileLocation) - 1);


        // RSL TEMP. to save RAW COM T4 data from the modem

        dwSizeNeed = sizeof(int);

        lRet = RegQueryValueEx(
                               hKey,
                               "T4LogLevel",
                               0,
                               &dwType,
                               (LPBYTE) &gT30.T4LogLevel,
                               &dwSizeNeed);

        if ( ( lRet != ERROR_SUCCESS) || (dwType != REG_DWORD) ) {
            gT30.T4LogLevel = 0;
        }

        dwSizeNeed = sizeof(int);


        lRet = RegQueryValueEx(
                               hKey,
                               "MaxErrorLinesPerPage",
                               0,
                               &dwType,
                               (LPBYTE) &gT30.MaxErrorLinesPerPage,
                               &dwSizeNeed);

        if ( ( lRet != ERROR_SUCCESS) || (dwType != REG_DWORD) ) {
            gT30.MaxErrorLinesPerPage = 110;
        }

        dwSizeNeed = sizeof(int);

        lRet = RegQueryValueEx(
                               hKey,
                               "MaxConsecErrorLinesPerPage",
                               0,
                               &dwType,
                               (LPBYTE) &gT30.MaxConsecErrorLinesPerPage,
                               &dwSizeNeed);

        if ( ( lRet != ERROR_SUCCESS) || (dwType != REG_DWORD) ) {
            gT30.MaxConsecErrorLinesPerPage = 110;
        }

        //
        // Exception Handling enable / disable
        //

        dwSizeNeed = sizeof(int);

        lRet = RegQueryValueEx(
                               hKey,
                               "DisableEH",
                               0,
                               &dwType,
                               (LPBYTE) &glT30Safe,
                               &dwSizeNeed);

        if ( ( lRet != ERROR_SUCCESS) || (dwType != REG_DWORD) ) {
            glT30Safe = 1;
        }


        dwSizeNeed = sizeof(int);

        lRet = RegQueryValueEx(
                               hKey,
                               "SimulateError",
                               0,
                               &dwType,
                               (LPBYTE) &glSimulateError,
                               &dwSizeNeed);

        if ( ( lRet != ERROR_SUCCESS) || (dwType != REG_DWORD) ) {
            glSimulateError = 0;
        }


        dwSizeNeed = sizeof(int);

        lRet = RegQueryValueEx(
                               hKey,
                               "SimulateErrorType",
                               0,
                               &dwType,
                               (LPBYTE) &glSimulateErrorType,
                               &dwSizeNeed);

        if ( ( lRet != ERROR_SUCCESS) || (dwType != REG_DWORD) ) {
            glSimulateErrorType = 0;
        }








    }
    else {

        lstrcpy( LogFileLocation, "c:");
        gT30.DbgLevel = 0;
        gT30.T4LogLevel = 0;
    }



    lstrcat(LogFileLocation, "\\faxt30.log");

    if (gT30.DbgLevel == 0)
        gfFilePrint = 0;



    if (gfFilePrint) {

        if ( (ghLogFile = CreateFileA(LogFileLocation, GENERIC_WRITE, FILE_SHARE_READ,
                                   NULL, CREATE_ALWAYS, 0, NULL) ) == INVALID_HANDLE_VALUE ) {

            OutputDebugString("CANNOT CREATE faxt30.log\n");
        }
    }


    if (gT30.T4LogLevel) {
        iLen = lstrlen (LogFileLocation);
        LogFileLocation[iLen-3] = 'c';
        LogFileLocation[iLen-2] = 'o';
        LogFileLocation[iLen-1] = 'm';

        if ( (ghComLogFile = _lcreat (LogFileLocation, 0) ) == HFILE_ERROR ) {
            OutputDebugString("CANNOT CREATE faxt30.com\n");
        }
    }



    // temp. directory

    gT30.dwLengthTmpDirectory = GetTempPathA (_MAX_FNAME - 15, gT30.TmpDirectory);
    if (gT30.dwLengthTmpDirectory > _MAX_FNAME - 15) {
        MyDebugPrint( (PThrdGlbl) 0, LOG_ERR, "FaxDevInit__A GetTempPathA needs %d have %d bytes\n",
                       gT30.dwLengthTmpDirectory , (_MAX_FNAME - 15) );
        return (FALSE);
    }

    if (!gT30.dwLengthTmpDirectory)  {
        MyDebugPrint( (PThrdGlbl) 0, LOG_ERR, "FaxDevInit__A GetTempPathA fails le=%x\n", GetLastError() );
        return (FALSE);
    }



    MyDebugPrint( (PThrdGlbl) 0, LOG_ALL, "EP: FaxDevInit__A hLineApp=%x heap=%x TempDir=%s Len=%d at %ld \n",
                  LineAppHandle,
                  HeapHandle,
                  gT30.TmpDirectory,
                  gT30.dwLengthTmpDirectory,
                  GetTickCount() );



    gT30.Status = STATUS_OK;



    return (TRUE);
}



///////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI
FaxDevStartJobA(
    HLINE           LineHandle,
    DWORD           DeviceId,
    PHANDLE         pFaxHandle,
    HANDLE          CompletionPortHandle,
    ULONG_PTR        CompletionKey
    )

/*++

Routine Description:
    Device Provider Initialization.


Arguments:


Return Value:


--*/

{


    PThrdGlbl       pTG=NULL;
    int             i;
    int             fFound=0;


    MyDebugPrint(pTG, LOG_ALL, "EP: FaxDevStartJob__A LineHandle=%x, DevID=%x, pFaxH=%x Port=%x, Key=%x at %ld \n",
                  LineHandle,
                  DeviceId,
                  pFaxHandle,
                  CompletionPortHandle,
                  CompletionKey,
                  GetTickCount()
                  );



    gT30.CntConnect++;
    if (gT30.CntConnect >= MAX_T30_CONNECT)  {
        MyDebugPrint(pTG, LOG_ERR, "ERROR: Exceeded # of connections (curr=%d, allowed=%d\n",
                    gT30.CntConnect, MAX_T30_CONNECT );
        return (FALSE);
    }



    if ( (pTG =  (PThrdGlbl) T30AllocThreadGlobalData() ) == NULL )  {
        MyDebugPrint(pTG, LOG_ERR, "ERROR: FaxDevStartJob: can't malloc\n");
        return (FALSE);
    }


    EnterCriticalSection(&T30CritSection);

    for (i=1; i<MAX_T30_CONNECT; i++) {
        if (T30Inst[i].fAvail) {
            T30Inst[i].pT30    = (LPVOID) pTG;
            T30Inst[i].fAvail  = FALSE;
            *pFaxHandle = (HANDLE) i;
            fFound = 1;
            break;
        }
    }

    LeaveCriticalSection(&T30CritSection);

    if (!fFound)
        return (FALSE);


    pTG->LineHandle = LineHandle;
    pTG->DeviceId   = DeviceId;
    pTG->FaxHandle  = (HANDLE) pTG;
    pTG->CompletionPortHandle = CompletionPortHandle;
    pTG->CompletionKey = CompletionKey;

    // initialization
    //---------------------------

    pTG->hevAsync = CreateEvent(NULL, FALSE, FALSE, NULL);
    pTG->CtrlEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    pTG->ThrdSignal = CreateEvent(NULL, FALSE, FALSE, NULL);
    pTG->ThrdDoneSignal = CreateEvent(NULL, FALSE, FALSE, NULL);
    pTG->ThrdAckTerminateSignal = CreateEvent(NULL, FALSE, FALSE, NULL);
    pTG->FirstPageReadyTxSignal = CreateEvent(NULL, FALSE, FALSE, NULL);

    pTG->AbortReqEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    pTG->AbortAckEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    ResetEvent(pTG->AbortReqEvent);


    pTG->fWaitingForEvent = FALSE;

    pTG->fDeallocateCall = 0;

    MyAllocInit(pTG);

    pTG->StatusId     = 0;
    pTG->StringId     = 0;
    pTG->PageCount    = 0;
    pTG->CSI          = 0;
    pTG->CallerId     = 0;
    pTG->RoutingInfo  = 0;

    // helper image threads sync. flags
    pTG->AckTerminate = 1;
    pTG->fOkToResetAbortReqEvent = 1;

    pTG->Inst.awfi.fLastPage = 0;



    return (TRUE);
}




///////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI
FaxDevEndJobA(
    HANDLE          FaxHandle
    )

/*++

Routine Description:
    Device Provider Initialization.


Arguments:


Return Value:


--*/

{

    PThrdGlbl  pTG=NULL;
    LONG_PTR    i;



    MyDebugPrint( (PThrdGlbl) 0, LOG_ALL, "EP: FaxDevEndJob FaxHandle=%x \n", FaxHandle);


    // find instance data
    //------------------------

    i = (LONG_PTR) FaxHandle;

    if (i < 1   ||  i >= MAX_T30_CONNECT)  {
        MyDebugPrint(pTG, LOG_ERR, "ERROR: FaxDevEndJob - got wrong FaxHandle=%d\n", i);
        return (FALSE);
    }

    if (T30Inst[i].fAvail) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR: FaxDevEndJob - got wrong FaxHandle (marked as free) %d\n", i);
        return (FALSE);
    }

    pTG = (PThrdGlbl) T30Inst[i].pT30;

    if (pTG->hevAsync) {
        CloseHandle(pTG->hevAsync);
    }

    if (pTG->CtrlEvent) {
        CloseHandle(pTG->CtrlEvent);
    }

    if (pTG->StatusId == FS_NOT_FAX_CALL) {
        CloseHandle( (HANDLE) pTG->Comm.nCid );
    }

    if (pTG->ThrdSignal) {
        CloseHandle(pTG->ThrdSignal);
    }

    if (pTG->ThrdDoneSignal) {
        CloseHandle(pTG->ThrdDoneSignal);
    }

    if (pTG->ThrdAckTerminateSignal) {
        CloseHandle(pTG->ThrdAckTerminateSignal);
    }


    if (pTG->FirstPageReadyTxSignal) {
        CloseHandle(pTG->FirstPageReadyTxSignal);
    }

    if (pTG->AbortReqEvent) {
        CloseHandle(pTG->AbortReqEvent);
    }

    if (pTG->AbortAckEvent) {
        CloseHandle(pTG->AbortAckEvent);
    }




    if (pTG->hThread) {
        CloseHandle(pTG->hThread);
    }





    MemFree(pTG->lpwFileName);

    pTG->fRemoteIdAvail = 0;

    if (pTG->RemoteID) {
        MemFree(pTG->RemoteID);
    }

    CleanModemInfStrings(pTG);

    MemFree(pTG);


    EnterCriticalSection(&T30CritSection);

    T30Inst[i].fAvail = TRUE;
    T30Inst[i].pT30   = NULL;
    gT30.CntConnect--;


    LeaveCriticalSection(&T30CritSection);


    MyDebugPrint(0, LOG_ALL, "FaxDevEndJob %d \n", FaxHandle);
    // RSL PrintAllocationsT30();


    return (TRUE);


}




///////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI
FaxDevSendA(
    IN  HANDLE                 FaxHandle,
    IN  PFAX_SEND_A            FaxSend,
    IN  PFAX_SEND_CALLBACK     FaxSendCallback
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{

    LONG_PTR               i;
    PThrdGlbl             pTG=NULL;
    LONG                  lRet;
    DWORD                 dw;
    LPVARSTRING           lpVarStr=0;
    LPDEVICEID            lpDeviceID=0;
    LPLINEDEVCAPS         lpLineDevCaps;
    LPSTR                 lpszFaxNumber;
    BYTE                  buf[ sizeof(LINEDEVCAPS)+1000 ];
    LONG                  lResult=0;
    LPLINECALLPARAMS      lpCallParams;
    HCALL                 CallHandle;
    BYTE                  rgby [sizeof(LINETRANSLATEOUTPUT)+64];
    LPLINETRANSLATEOUTPUT lplto1 = (LPLINETRANSLATEOUTPUT) rgby;
    LPLINETRANSLATEOUTPUT lplto;
    BOOL                  RetCode;
    DWORD                 dwNeededSize;
    LPDEVCFG              lpDevCfg;
    LPMODEMSETTINGS       lpModemSettings;
    LPMDM_DEVSPEC         lpDSpec;
    int                   fFound=0;
    int                   RecoveryIndex = -1;
    char                  rgchKey[256];
    HKEY                  hKey;
    DWORD                 dwType;
    DWORD                 dwSize;


__try {

    MyDebugPrint( (PThrdGlbl) 0, LOG_ALL, "EP: FaxDevSendA FaxHandle=%x, FaxSend=%x, FaxSendCallback=%x at %ld \n",
                   FaxHandle, FaxSend, FaxSendCallback, GetTickCount() );


    // find instance data
    //------------------------

    i = (LONG_PTR) FaxHandle;

    if (i < 1   ||  i >= MAX_T30_CONNECT)  {

        MemFree(FaxSend->FileName);
        MemFree(FaxSend->CallerName);
        MemFree(FaxSend->CallerNumber);
        MemFree(FaxSend->ReceiverName);
        MemFree(FaxSend->ReceiverNumber);

        return (FALSE);

    }

    if (T30Inst[i].fAvail) {

        MemFree(FaxSend->FileName);
        MemFree(FaxSend->CallerName);
        MemFree(FaxSend->CallerNumber);
        MemFree(FaxSend->ReceiverName);
        MemFree(FaxSend->ReceiverNumber);

        return (FALSE);
    }

    pTG = (PThrdGlbl) T30Inst[i].pT30;
    pTG->RecoveryIndex = -1;


    lpszFaxNumber = FaxSend->ReceiverNumber;


    pTG->Operation = T30_TX;

    // store LocalID

    if (FaxSend->CallerNumber == NULL) {
        pTG->LocalID[0] = 0;
    }
    else {
        _fmemcpy(pTG->LocalID, FaxSend->CallerNumber, min (_fstrlen(FaxSend->CallerNumber), sizeof(pTG->LocalID) - 1) );
        pTG->LocalID [ min (_fstrlen(FaxSend->CallerNumber), sizeof(pTG->LocalID) - 1) ] = 0;
    }



    // go to TAPI pass-through mode
    //-------------------------------

    lpCallParams = itapi_create_linecallparams();

    if (!itapi_async_setup(pTG)) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR: FaxDevSend: itapi_async_setup failed \n");

        MemFree (lpCallParams);

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;
        goto l_exit;
    }


    lRet = lineMakeCall (pTG->LineHandle,
                         &CallHandle,
                         lpszFaxNumber,
                         0,
                         lpCallParams);

    if (lRet < 0) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR: lineMakeCall returns ERROR value 0x%lx\n", (unsigned long) lRet);
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_LINE_UNAVAILABLE);

        MemFree (lpCallParams);

        RetCode = FALSE;
        goto l_exit;

    }
    else {
        MyDebugPrint(pTG, LOG_ALL, "lineMakeCall returns 0x%lx\n", (unsigned long) lRet);
    }



    if(!itapi_async_wait(pTG, (DWORD)lRet, (LPDWORD)&lRet, NULL, ASYNC_TIMEOUT)) {
        MyDebugPrint(pTG, LOG_ERR,  "ERROR: FaxDevSend: itapi_async_wait failed \n");
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_LINE_UNAVAILABLE);

        MemFree (lpCallParams);

        RetCode = FALSE;
        goto l_exit;

    }

    // now we wait for the connected message
    //--------------------------------------

    for (dw=50; dw<10000; dw = dw*120/100) {
        Sleep(dw);
        if (pTG->fGotConnect)
             break;
    }

    if (!pTG->fGotConnect) {
         MyDebugPrint(pTG, LOG_ERR, "ERROR: Failure waiting for  CONNECTED message....\n");
         // We ignore... goto failure1;
    }



    MemFree (lpCallParams);

    pTG->CallHandle = CallHandle;

    //
    // Add entry to the Recovery Area.
    //

    fFound = 0;

    for (i=0; i<MAX_T30_CONNECT; i++) {

        if (T30Recovery[i].fAvail) {
            EnterCriticalSection(&T30RecoveryCritSection);

            T30Recovery[i].fAvail               = FALSE;
            T30Recovery[i].ThreadId             = GetCurrentThreadId();
            T30Recovery[i].FaxHandle            = FaxHandle;
            T30Recovery[i].pTG                  = (LPVOID) pTG;
            T30Recovery[i].LineHandle            = pTG->LineHandle;
            T30Recovery[i].CallHandle            = CallHandle;
            T30Recovery[i].DeviceId             = pTG->DeviceId;
            T30Recovery[i].CompletionPortHandle = pTG->CompletionPortHandle;
            T30Recovery[i].CompletionKey         = pTG->CompletionKey;
            T30Recovery[i].TiffThreadId          = 0;
            T30Recovery[i].TimeStart             = GetTickCount();
            T30Recovery[i].TimeUpdated           = T30Recovery[i].TimeStart;
            T30Recovery[i].CkSum                 = ComputeCheckSum( (LPDWORD) &T30Recovery[i].fAvail,
                                                                     sizeof ( T30_RECOVERY_GLOB ) / sizeof (DWORD) - 1);

            LeaveCriticalSection(&T30RecoveryCritSection);
            fFound = 1;
            RecoveryIndex = (int)i;
            pTG->RecoveryIndex = (int)i;

            break;
        }
    }

    if (! fFound) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR:Couldn't find available space for Recovery\n");
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;
        goto l_exit;
    }


    // get the handle to a Comm port
    //----------------------------------

    lpVarStr = (LPVARSTRING) MemAlloc(IDVARSTRINGSIZE);
    if (!lpVarStr) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR:Couldn't allocate space for lpVarStr\n");
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;
        goto l_exit;
    }

    _fmemset(lpVarStr, 0, IDVARSTRINGSIZE);
    lpVarStr->dwTotalSize = IDVARSTRINGSIZE;


    lRet = lineGetID(pTG->LineHandle,
                     0,  // +++ addr
                     CallHandle,
                     LINECALLSELECT_CALL,   // dwSelect,
                     lpVarStr,              //lpDeviceID,
                     "comm/datamodem" );    //lpszDeviceClass

    if (lRet) {
         MyDebugPrint(pTG, LOG_ERR,  "ERROR:lineGetID returns error 0x%lx\n", (unsigned long) lRet);

         pTG->fFatalErrorWasSignaled = 1;
         SignalStatusChange(pTG, FS_LINE_UNAVAILABLE);

         RetCode = FALSE;
         goto l_exit;
    }



    // extract id
    if (lpVarStr->dwStringFormat != STRINGFORMAT_BINARY) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR: String format is not binary\n");

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);

        RetCode = FALSE;
        goto l_exit;
    }

    if (lpVarStr->dwUsedSize<sizeof(DEVICEID)) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR: linegetid : Varstring size too small\n");

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);

        RetCode = FALSE;
        goto l_exit;
    }

    lpDeviceID = (LPDEVICEID) ((LPBYTE)(lpVarStr)+lpVarStr->dwStringOffset);

    MyDebugPrint(pTG, LOG_ALL, "lineGetID returns handle 0x%08lx, \"%s\"\n",
                            (ULONG_PTR) lpDeviceID->hComm,
                            (LPSTR) lpDeviceID->szDeviceName);

    pTG->hComm = lpDeviceID->hComm;


    if (BAD_HANDLE(pTG->hComm)) {
        MyDebugPrint(pTG, LOG_ERR, "ERR:lineGetID returns NULL hComm\n");
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;
        goto l_exit;
    }


    // get the Modem configuration (speaker, etc.) from TAPI
    //------------------------------------------------------

    _fmemset(lpVarStr, 0, IDVARSTRINGSIZE);
    lpVarStr->dwTotalSize = IDVARSTRINGSIZE;

    lResult = lineGetDevConfig(pTG->DeviceId,
                               lpVarStr,
                               "comm/datamodem");

    if (lResult) {
        if (lpVarStr->dwTotalSize < lpVarStr->dwNeededSize) {
            dwNeededSize = lpVarStr->dwNeededSize;
            MemFree (lpVarStr);
            if ( ! (lpVarStr = (LPVARSTRING) MemAlloc(dwNeededSize) ) ) {
                MyDebugPrint(pTG, LOG_ERR, "ERR: Can't allocate %d bytes for lineGetDevConfig\n");
                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_FATAL_ERROR);
                RetCode = FALSE;
                goto l_exit;
            }

            _fmemset(lpVarStr, 0, dwNeededSize);
            lpVarStr->dwTotalSize = dwNeededSize;

            lResult = lineGetDevConfig(pTG->DeviceId,
                                       lpVarStr,
                                       "comm/datamodem");

            if (lResult) {
                MyDebugPrint(pTG, LOG_ERR, "ERR: lineGetDevConfig returns %x, le=%x", lResult, GetLastError() );

                MemFree (lpVarStr);

                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_FATAL_ERROR);
                RetCode = FALSE;
                goto l_exit;
            }
        }
        else {
            MyDebugPrint(pTG, LOG_ERR, "ERR: 1st lineGetDevConfig returns %x, le=%x", lResult, GetLastError() );

            MemFree (lpVarStr);

            pTG->fFatalErrorWasSignaled = 1;
            SignalStatusChange(pTG, FS_FATAL_ERROR);
            RetCode = FALSE;
            goto l_exit;
        }
    }

    //
    // extract DEVCFG
    //
    if (lpVarStr->dwStringFormat != STRINGFORMAT_BINARY) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR: String format is not binary for lineGetDevConfig\n");

        MemFree (lpVarStr);

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;
        goto l_exit;
    }

    if (lpVarStr->dwUsedSize<sizeof(DEVCFG)) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR: lineGetDevConfig : Varstring size returned too small\n");

        MemFree (lpVarStr);

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;
        goto l_exit;
    }

    lpDevCfg = (LPDEVCFG) ((LPBYTE)(lpVarStr)+lpVarStr->dwStringOffset);

    lpModemSettings = (LPMODEMSETTINGS) ( (LPBYTE) &(lpDevCfg->commconfig.wcProviderData) );

    pTG->dwSpeakerVolume = lpModemSettings->dwSpeakerVolume;
    pTG->dwSpeakerMode   = lpModemSettings->dwSpeakerMode;
    
    if ( lpModemSettings->dwPreferredModemOptions & MDM_BLIND_DIAL ) {
       pTG->fBlindDial = 1;
    }
    else {
       pTG->fBlindDial = 0;
    }

    MyDebugPrint(pTG, LOG_ALL, "lineGetDevConfig returns SpeakerVolume=%x, Mode=%x BlindDial=%d \n",
                               pTG->dwSpeakerVolume, pTG->dwSpeakerMode, pTG->fBlindDial );

    MemFree (lpVarStr);
    lpVarStr=0;

    // get dwPermanentLineID
    // ---------------------------

    lpLineDevCaps = (LPLINEDEVCAPS) buf;

    _fmemset(lpLineDevCaps, 0, sizeof (buf) );
    lpLineDevCaps->dwTotalSize = sizeof(buf);


    lResult = lineGetDevCaps(gT30.LineAppHandle,
                             pTG->DeviceId,
                             TAPI_VERSION,
                             0,
                             lpLineDevCaps);

    if (lResult) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR:lineGetDevCaps failed\n");

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);

        RetCode = FALSE;
        goto l_exit;
    }

    if (lpLineDevCaps->dwNeededSize > lpLineDevCaps->dwTotalSize) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR:lineGetDevCaps NOT enough MEMORY\n");
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);

        RetCode = FALSE;
        goto l_exit;
    }

    // Save the permanent ID.
    //------------------------

    pTG->dwPermanentLineID = lpLineDevCaps->dwPermanentLineID;
    _stprintf (pTG->lpszPermanentLineID, "%08d\\Modem", pTG->dwPermanentLineID);
    MyDebugPrint(pTG, LOG_ALL, "Permanent Line ID=%s\n", pTG->lpszPermanentLineID);


    // Get the Unimodem key name for this device
    //------------------------------------------

    lpDSpec = (LPMDM_DEVSPEC) (  ( (LPBYTE) lpLineDevCaps) + lpLineDevCaps->dwDevSpecificOffset);

    if ( (lpLineDevCaps->dwDevSpecificSize < sizeof(MDM_DEVSPEC) ) ||
         (lpLineDevCaps->dwDevSpecificSize <= lpDSpec->dwKeyOffset) )  {
            
          MyDebugPrint(pTG, LOG_ERR, "Devspecifc caps size is only %lu",
                    (unsigned long) lpLineDevCaps->dwDevSpecificSize );

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);

        RetCode = FALSE;
        goto l_exit;
    }
    else {
            UINT u = lpLineDevCaps->dwDevSpecificSize - lpDSpec->dwKeyOffset;

#define szAPPEND "\\FAX"
            
            if ( (lpDSpec->dwContents != 1) || (lpDSpec->dwKeyOffset != 8 ) ) {
                    MyDebugPrint(pTG, LOG_ERR, "Nonstandard Devspecific: dwContents=%lu; dwKeyOffset=%lu",
                            (unsigned long) lpDSpec->dwContents,
                            (unsigned long) lpDSpec->dwKeyOffset );

                    pTG->fFatalErrorWasSignaled = 1;
                    SignalStatusChange(pTG, FS_FATAL_ERROR);

                    RetCode = FALSE;
                    goto l_exit;

            }
            
            if (u) {
                    _fmemcpy(rgchKey, lpDSpec->rgby, u);
                    
                    if (rgchKey[u])   {
                            MyDebugPrint(pTG, LOG_ERR, "rgchKey not null terminated!" );
                            rgchKey[u-1]=0;
                    }

                    //
                    // Get ResponsesKeyName
                    //

                    lRet = RegOpenKeyEx(
                                    HKEY_LOCAL_MACHINE,
                                    rgchKey,
                                    0,
                                    KEY_READ,
                                    &hKey);
                
                    if (lRet != ERROR_SUCCESS) {
                       MyDebugPrint(pTG, LOG_ERR, "Can't read Unimodem key %s\n", rgchKey);
   
                       pTG->fFatalErrorWasSignaled = 1;
                       SignalStatusChange(pTG, FS_FATAL_ERROR);
   
                       RetCode = FALSE;
                       goto l_exit;
                    }

                    dwSize = sizeof( pTG->ResponsesKeyName);

                    lRet = RegQueryValueEx(
                            hKey,
                            "ResponsesKeyName",
                            0,
                            &dwType,
                            pTG->ResponsesKeyName,
                            &dwSize);

                    RegCloseKey(hKey);

                    if (lRet != ERROR_SUCCESS) {
                       MyDebugPrint(pTG, LOG_ERR, "Can't read Unimodem key\\ResponsesKeyName %s\n", rgchKey);
   
                       pTG->fFatalErrorWasSignaled = 1;
                       SignalStatusChange(pTG, FS_FATAL_ERROR);
   
                       RetCode = FALSE;
                       goto l_exit;
                    }

                    lstrcpy(pTG->lpszUnimodemKey, rgchKey);

                    //  Append  "\\Fax" to the key
                    
                    u = lstrlen(rgchKey);
                    if (u) {
                        lstrcpy(rgchKey+u, (LPSTR) szAPPEND);
                    }

                    lstrcpy(pTG->lpszUnimodemFaxKey, rgchKey);
                    MyDebugPrint(pTG, LOG_ALL, "Unimodem Fax key=%s\n", pTG->lpszUnimodemFaxKey);
            }
    }



    // Convert the destination# to a dialable
    //--------------------------------------------

    // find out how big a buffer should be
    //
    _fmemset(rgby, 0, sizeof(rgby));
    lplto1->dwTotalSize = sizeof(rgby);

    lRet = lineTranslateAddress (gT30.LineAppHandle,
                                 pTG->DeviceId,
                                 TAPI_VERSION,
                                 lpszFaxNumber,
                                 0,      // dwCard
                                 LINETRANSLATEOPTION_CANCELCALLWAITING,
                                 lplto1);

    if (lRet) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR:Can't translate dest. address %s\n", lpszFaxNumber);
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;
        goto l_exit;
    }


    if (lplto1->dwNeededSize <= 0) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR:Can't dwNeededSize<0 for Fax# %s\n", lpszFaxNumber);
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;
        goto l_exit;
    }


    lplto = MemAlloc(lplto1->dwNeededSize);
    if (! lplto) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR:Couldn't allocate space for lplto\n");
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;
        goto l_exit;
    }

    lplto->dwTotalSize = lplto1->dwNeededSize;

    lRet = lineTranslateAddress (gT30.LineAppHandle,
                                 pTG->DeviceId,
                                 TAPI_VERSION,
                                 lpszFaxNumber,
                                 0,      // dwCard
                                 LINETRANSLATEOPTION_CANCELCALLWAITING,
                                 lplto);

    if (lRet) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR:Can't translate dest. address %s\n", lpszFaxNumber);
        MemFree(lplto);

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;
        goto l_exit;
    }

    if (lplto->dwNeededSize > lplto->dwTotalSize) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR: NeedSize=%d > TotalSize=%d for Fax# %s\n",
                     lplto->dwNeededSize ,lplto->dwTotalSize, lpszFaxNumber);
        MemFree(lplto);

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;
        goto l_exit;
    }


    _fmemcpy (pTG->lpszDialDestFax, ( (char *) lplto) + lplto->dwDialableStringOffset, lplto->dwDialableStringSize);
    MyDebugPrint(pTG, LOG_ALL, "Dialable Dest is %s\n", pTG->lpszDialDestFax);

    MemFree(lplto);


    /// RSL -revisit, may decrease prty during computation
    if (! SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL) ) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR: SetThreadPriority TIME CRITICAL failed le=%x", GetLastError() );
    }


    // initialize modem
    //--------------------

    T30ModemInit(pTG, pTG->hComm, 0, LINEID_TAPI_PERMANENT_DEVICEID,
                      DEF_BASEKEY, pTG->lpszPermanentLineID, fMDMINIT_ANSWER);


    pTG->Inst.ProtParams.uMinScan = MINSCAN_0_0_0;
    ET30ProtSetProtParams(pTG, &pTG->Inst.ProtParams, pTG->FComModem.CurrMdmCaps.uSendSpeeds, pTG->FComModem.CurrMdmCaps.uRecvSpeeds);

    InitCapsBC( pTG, (LPBC) &pTG->Inst.SendCaps, sizeof(pTG->Inst.SendCaps), SEND_CAPS);

    // store the TIFF filename
    //-------------------------

    pTG->lpwFileName = AnsiStringToUnicodeString(FaxSend->FileName);

    if ( !pTG->fTiffOpenOrCreated) {
        pTG->Inst.hfile =  PtrToUlong (TiffOpenW (pTG->lpwFileName,
                                                  &pTG->TiffInfo,
                                                  TRUE) );


        if (! (pTG->Inst.hfile)) {
            MyDebugPrint(pTG, LOG_ERR, "ERROR:Can't open tiff file %s\n", pTG->lpwFileName);
            // pTG->StatusId = FS_TIFF_SRC_BAD
            pTG->fFatalErrorWasSignaled = 1;
            SignalStatusChange(pTG, FS_FATAL_ERROR);
            RetCode = FALSE;
            goto l_exit;
        }

        if (pTG->TiffInfo.YResolution == 98) {
            pTG->SrcHiRes = 0;
        }
        else {
            pTG->SrcHiRes = 1;
        }

        pTG->fTiffOpenOrCreated = 1;

        MyDebugPrint(pTG, LOG_ALL, "Successfully opened TIFF Yres=%d HiRes=%d\n",
                          pTG->TiffInfo.YResolution, pTG->SrcHiRes);
    }
    else {
        MyDebugPrint(pTG, LOG_ERR, "ERROR:tiff file %s is OPENED already\n", pTG->lpwFileName);
        MyDebugPrint(pTG, LOG_ERR, "ERROR:Can't open tiff file %s\n", pTG->lpwFileName);
        // pTG->StatusId = FS_TIFF_SRC_BAD
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;
        goto l_exit;
    }





    // Fax Service Callback
    //----------------------

    if (!FaxSendCallback(FaxHandle,
                         CallHandle,
                         0,
                         0) ) {

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);

        RetCode = FALSE;
        goto l_exit;
    }


    // Send the Fax
    //-----------------------------------------------------------------------


    // here we already know what Class we will use for a particular modem.
    //-------------------------------------------------------------------

    if (pTG->ModemClass == MODEM_CLASS2) {
       Class2Init(pTG);
       RetCode = T30Cl2Tx (pTG, pTG->lpszDialDestFax);
    }
    else if (pTG->ModemClass == MODEM_CLASS2_0) {
       Class20Init(pTG);
       RetCode = T30Cl20Tx (pTG, pTG->lpszDialDestFax);
    }
    else if (pTG->ModemClass == MODEM_CLASS1) { 
       RetCode = T30Cl1Tx(pTG, pTG->lpszDialDestFax);
    }


    // delete all the files that are left

    _fmemcpy (pTG->InFileName, gT30.TmpDirectory, gT30.dwLengthTmpDirectory);
    _fmemcpy (&pTG->InFileName[gT30.dwLengthTmpDirectory], pTG->lpszPermanentLineID, 8);

    for (dw = pTG->CurrentIn; dw <= pTG->LastOut; dw++) {
        sprintf( &pTG->InFileName[gT30.dwLengthTmpDirectory+8], ".%03d",  dw);
        if (! DeleteFileA (pTG->InFileName) ) {
            MyDebugPrint(pTG, LOG_ERR, "ERROR: file %s can't be deleted; le=%lx at %ld \n",
                                        pTG->InFileName, GetLastError(), GetTickCount() );

        }
    }


    if (pTG->fTiffOpenOrCreated) {
        TiffClose( (HANDLE) pTG->Inst.hfile);
        pTG->fTiffOpenOrCreated = 0;
    }


    iModemClose(pTG);

    // release the line
    //-----------------------------

    if (pTG->fDeallocateCall == 0)  {

        //
        // line never was signalled IDLE, need to lineDrop first
        //

        if (!itapi_async_setup(pTG)) {
            MyDebugPrint(pTG, LOG_ERR, "ERROR: FaxDevSend: lineDrop itapi_async_setup failed \n");
            if (!pTG->fFatalErrorWasSignaled) {
                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_FATAL_ERROR);
            }

            RetCode = FALSE;
            goto l_exit;
        }

        lRet = lineDrop (pTG->CallHandle, NULL, 0);

        if (lRet < 0) {
            MyDebugPrint(pTG, LOG_ERR,  "ERROR: lineDrop failed %lx\n", lRet);
            // return (FALSE);
        }
        else {
            MyDebugPrint(pTG, LOG_ALL, "lineDrop returns request %d\n", lRet);

            if(!itapi_async_wait(pTG, (DWORD)lRet, (LPDWORD)&lRet, NULL, ASYNC_SHORT_TIMEOUT)) {
                MyDebugPrint(pTG, LOG_ERR, "ERROR: FaxDevSend: itapi_async_wait failed on lineDrop\n");

                goto l_exit;
            }

            MyDebugPrint(pTG, LOG_ALL,  "lineDrop SUCCESS\n");
        }

        //
        //deallocating call
        //

        // it took us some time since first test
        if (pTG->fDeallocateCall == 0)  {

            pTG->fDeallocateCall = 1;

#if 0
//
// this is now performed in the fax service
//
            lRet = lineDeallocateCall(pTG->CallHandle );
            if (lRet) {
                MyDebugPrint(pTG, LOG_ERR, "ERROR: lineDeallocateCall returns %lx\n", lRet);
            }
            else {
                MyDebugPrint(pTG, LOG_ALL, "lineDeallocateCall SUCCESS\n");
            }
#endif
        }
    }

l_exit:

    if ( (RetCode == FALSE) && (pTG->StatusId == FS_COMPLETED) ) {
       MyDebugPrint(pTG, LOG_ERR, "ERROR: exit FaxDevSend success but later failed \n");
       RetCode = TRUE;
    }

    if ( (RecoveryIndex >= 0) && (RecoveryIndex < MAX_T30_CONNECT) ) {
        T30Recovery[RecoveryIndex].fAvail = TRUE;
    }

    /// RSL -revisit, may decrease prty during computation
    if (! SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_NORMAL) ) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR: SetThreadPriority Normal failed le=%x", GetLastError() );
    }

    if (pTG->InFileHandleNeedsBeClosed) {
        CloseHandle(pTG->InFileHandle);
        pTG->InFileHandleNeedsBeClosed = 0;
    }



    MemFree(FaxSend->FileName);
    MemFree(FaxSend->CallerName);
    MemFree(FaxSend->CallerNumber);
    MemFree(FaxSend->ReceiverName);
    MemFree(FaxSend->ReceiverNumber);

    if (!pTG->AckTerminate) {

        if ( WaitForSingleObject(pTG->ThrdAckTerminateSignal, TX_WAIT_ACK_TERMINATE_TIMEOUT)  == WAIT_TIMEOUT ) {
            MyDebugPrint(pTG, LOG_ERR, "WARNING: Never got AckTerminate \n");
        }
    }

    MyDebugPrint(pTG, LOG_ALL, "Got AckTerminate OK at %ld \n", GetTickCount() );

    SetEvent(pTG->AbortAckEvent);

    MyDebugPrint(pTG, LOG_ALL, "FaxDevSendA rets %d at %ld \n", RetCode, GetTickCount() );

    return (RetCode);


} __except (EXCEPTION_EXECUTE_HANDLER) {

    //
    // try to use the Recovery data
    //

    DWORD      dwCkSum;
    HCALL      CallHandle;
    HANDLE     CompletionPortHandle;
    ULONG_PTR   CompletionKey;
    PThrdGlbl  pTG;
    DWORD      dwThreadId = GetCurrentThreadId();

    fFound = 0;

    for (i=0; i<MAX_T30_CONNECT; i++) {
        if ( (! T30Recovery[i].fAvail) && (T30Recovery[i].ThreadId == dwThreadId) ) {
            if ( ( dwCkSum = ComputeCheckSum( (LPDWORD) &T30Recovery[i].fAvail,
                                              sizeof ( T30_RECOVERY_GLOB ) / sizeof (DWORD) - 1) ) == T30Recovery[i].CkSum ) {

                CallHandle           = T30Recovery[i].CallHandle;
                CompletionPortHandle = T30Recovery[i].CompletionPortHandle;
                CompletionKey        = T30Recovery[i].CompletionKey;
                pTG                  = (PThrdGlbl) T30Recovery[i].pTG;

                fFound = 1;
                T30Recovery[i].fAvail = TRUE;
                break;
            }
        }
    }

    if (fFound == 0) {
        //
        // Need to indicate that FaxT30 couldn't recover by itself.
        //
        return (FALSE);
    }



    //
    // get out of Pass-through
    //

    if (!itapi_async_setup(pTG)) {
        return (FALSE);
    }

    lRet = lineSetCallParams(CallHandle,
                             LINEBEARERMODE_VOICE,
                             0,
                             0xffffffff,
                             NULL);


    if (lRet < 0) {
         return (FALSE);
    }
    else {
        if(!itapi_async_wait(pTG, (DWORD)lRet, (LPDWORD)&lRet, NULL, ASYNC_TIMEOUT)) {
            return (FALSE);
        }
    }


    //
    // hang up
    //

    if (!itapi_async_setup(pTG)) {
        return (FALSE);
    }

    lRet = lineDrop (CallHandle, NULL, 0);

    if (lRet < 0) {
         return (FALSE);
    }
    else {
        if(!itapi_async_wait(pTG, (DWORD)lRet, (LPDWORD)&lRet, NULL, ASYNC_TIMEOUT)) {
            return (FALSE);
        }

        // SignalRecoveryStatusChange(  &T30Recovery[i] );
    }

    //
    // Deallocate
    //

    lRet = lineDeallocateCall (CallHandle);

    if (lRet < 0) {
         return (FALSE);
    }
    else {

        SignalRecoveryStatusChange( &T30Recovery[i] );
    }


    if (pTG->InFileHandleNeedsBeClosed) {
        CloseHandle(pTG->InFileHandle);
    }

    SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_NORMAL);

    return (FALSE);

}




}


///////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI
FaxDevReceiveA(
    HANDLE              FaxHandle,
    HCALL               CallHandle,
    PFAX_RECEIVE_A      FaxReceive
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{

    LONG_PTR             i;
    PThrdGlbl           pTG=NULL;
    long                lRet;
    DWORD               dw;
    LPVARSTRING         lpVarStr=0;
    LPDEVICEID          lpDeviceID=0;
    LPLINEDEVCAPS       lpLineDevCaps;
    BYTE                buf[ sizeof(LINEDEVCAPS)+1000 ];
    LONG                lResult=0;
    BOOL                RetCode;
    DWORD               dwNeededSize;
    LPDEVCFG            lpDevCfg;
    LPMODEMSETTINGS     lpModemSettings;
    int                 fFound=0;
    int                 RecoveryIndex = -1;
    LPMDM_DEVSPEC       lpDSpec;
    char                rgchKey[256];
    HKEY                hKey;
    DWORD               dwType;
    DWORD               dwSize;


__try {

    MyDebugPrint( (PThrdGlbl) 0, LOG_ALL, "EP: FaxDevReceiveA FaxHandle=%x, CallHandle=%x, FaxReceive=%x at %ld \n",
                   FaxHandle, CallHandle, FaxReceive, GetTickCount() );




    // find instance data
    //------------------------

    i = (LONG_PTR) FaxHandle;

    if (i < 1   ||  i >= MAX_T30_CONNECT)  {
        MemFree(FaxReceive->FileName);
        MemFree(FaxReceive->ReceiverName);
        MemFree(FaxReceive->ReceiverNumber);

        MyDebugPrint( (PThrdGlbl) 0, LOG_ALL, "EP: ERROR i FaxDevReceiveA FaxHandle=%x, CallHandle=%x, FaxReceive=%x at %ld \n",
                       FaxHandle, CallHandle, FaxReceive, GetTickCount() );

        
        return (FALSE);


    }

    if (T30Inst[i].fAvail) {

        MemFree(FaxReceive->FileName);
        MemFree(FaxReceive->ReceiverName);
        MemFree(FaxReceive->ReceiverNumber);

        MyDebugPrint( (PThrdGlbl) 0, LOG_ALL, "EP: ERROR AVAIL FaxDevReceiveA FaxHandle=%x, CallHandle=%x, FaxReceive=%x at %ld \n",
                       FaxHandle, CallHandle, FaxReceive, GetTickCount() );
        
                     
        
        return (FALSE);


    }

    pTG = (PThrdGlbl) T30Inst[i].pT30;

    pTG->CallHandle = CallHandle;


    //
    // Add entry to the Recovery Area.
    //

    fFound = 0;

    for (i=0; i<MAX_T30_CONNECT; i++) {

        if (T30Recovery[i].fAvail) {
            EnterCriticalSection(&T30RecoveryCritSection);

            T30Recovery[i].fAvail               = FALSE;
            T30Recovery[i].ThreadId             = GetCurrentThreadId();
            T30Recovery[i].FaxHandle            = FaxHandle;
            T30Recovery[i].pTG                  = (LPVOID) pTG;
            T30Recovery[i].LineHandle            = pTG->LineHandle;
            T30Recovery[i].CallHandle            = CallHandle;
            T30Recovery[i].DeviceId             = pTG->DeviceId;
            T30Recovery[i].CompletionPortHandle = pTG->CompletionPortHandle;
            T30Recovery[i].CompletionKey         = pTG->CompletionKey;
            T30Recovery[i].TiffThreadId          = 0;
            T30Recovery[i].TimeStart             = GetTickCount();
            T30Recovery[i].TimeUpdated           = T30Recovery[i].TimeStart;
            T30Recovery[i].CkSum                 = ComputeCheckSum( (LPDWORD) &T30Recovery[i].fAvail,
                                                                     sizeof ( T30_RECOVERY_GLOB ) / sizeof (DWORD) - 1);

            LeaveCriticalSection(&T30RecoveryCritSection);
            fFound = 1;
            RecoveryIndex = (int)i;
            pTG->RecoveryIndex = (int)i;

            break;
        }
    }

    if (! fFound) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR:Couldn't find available space for Recovery\n");
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;
        goto l_exit;
    }


    pTG->Operation = T30_RX;
    
    // store LocalID

    if (FaxReceive->ReceiverNumber == NULL) {
        pTG->LocalID[0] = 0;
    }
    else {
        _fmemcpy(pTG->LocalID, FaxReceive->ReceiverNumber, min (_fstrlen(FaxReceive->ReceiverNumber), sizeof(pTG->LocalID) - 1) );
        pTG->LocalID [ min (_fstrlen(FaxReceive->ReceiverNumber), sizeof(pTG->LocalID) - 1) ] = 0;
    }


    // tiff
    //-----------------------------------------------


    pTG->lpwFileName = AnsiStringToUnicodeString(FaxReceive->FileName);
    pTG->SrcHiRes = 1;


    // take line over from TAPI
    //--------------------------

    pTG->fGotConnect = FALSE;


    // initiate passthru

    if (!itapi_async_setup(pTG)) {
        MyDebugPrint(pTG, LOG_ERR,  "ERROR: FaxDevReceive: itapi_async_setup failed \n");
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);

        RetCode = FALSE;
        goto l_exit;
    }


    lRet = lineSetCallParams(CallHandle,
                             LINEBEARERMODE_PASSTHROUGH,
                             0,
                             0xffffffff,
                             NULL);

    if (lRet < 0) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR: FaxDevReceive: lineSetCallParams failed \n");

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);

        RetCode = FALSE;
        goto l_exit;
    }
    else {
         MyDebugPrint(pTG, LOG_ALL, "lpfnlineSetCallParams returns ID %ld\n", (long) lRet);
    }


    if(!itapi_async_wait(pTG, (DWORD)lRet, &lRet, NULL, ASYNC_TIMEOUT)) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR: FaxDevReceive: itapi_async_wait failed \n");
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);

        RetCode = FALSE;
        goto l_exit;
    }

    // now we wait for the connected message
    //--------------------------------------

    for (dw=50; dw<10000; dw = dw*120/100) {
        Sleep(dw);
        if (pTG->fGotConnect)
             break;
    }

    if (!pTG->fGotConnect) {
         MyDebugPrint(pTG, LOG_ERR, "ERROR:Failure waiting for  CONNECTED message....\n");
         // We ignore...
    }


    // get the handle to a Comm port
    //----------------------------------

    lpVarStr = (LPVARSTRING) MemAlloc(IDVARSTRINGSIZE);
    if (!lpVarStr) {
        MyDebugPrint(pTG, LOG_ALL, "ERROR:Couldn't allocate space for lpVarStr\n");

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);

        RetCode = FALSE;
        goto l_exit;
    }

    _fmemset(lpVarStr, 0, IDVARSTRINGSIZE);
    lpVarStr->dwTotalSize = IDVARSTRINGSIZE;

    MyDebugPrint(pTG, LOG_ALL, "Calling lineGetId\n");

    lRet = lineGetID(pTG->LineHandle,
                     0,  // +++ addr
                     CallHandle,
                     LINECALLSELECT_CALL,   // dwSelect,
                     lpVarStr,              //lpDeviceID,
                     "comm/datamodem" );    //lpszDeviceClass

    if (lRet) {
         MyDebugPrint(pTG, LOG_ERR, "ERROR:lineGetID returns error 0x%lx\n", (unsigned long) lRet);

         pTG->fFatalErrorWasSignaled = 1;
         SignalStatusChange(pTG, FS_FATAL_ERROR);

         RetCode = FALSE;
         goto l_exit;
    }

    MyDebugPrint(pTG, LOG_ALL, "lineGetId returned SUCCESS\n");


    // extract id
    if (lpVarStr->dwStringFormat != STRINGFORMAT_BINARY) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR:String format is not binary\n");

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);

        RetCode = FALSE;
        goto l_exit;
    }

    if (lpVarStr->dwUsedSize<sizeof(DEVICEID)) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR:Varstring size too small\n");

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);

        RetCode = FALSE;
        goto l_exit;
    }

    lpDeviceID = (LPDEVICEID) ((LPBYTE)(lpVarStr)+lpVarStr->dwStringOffset);

    MyDebugPrint(pTG, LOG_ALL, "lineGetID returns handle 0x%08lx, \"%s\"\n",
                            (ULONG_PTR) lpDeviceID->hComm,
                            (LPSTR) lpDeviceID->szDeviceName);

    pTG->hComm = lpDeviceID->hComm;


    if (BAD_HANDLE(pTG->hComm)) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR:lineGetID returns NULL hComm\n");

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);

        RetCode = FALSE;
        goto l_exit;
    }


    // get the Modem configuration (speaker, etc.) from TAPI
    //------------------------------------------------------

    _fmemset(lpVarStr, 0, IDVARSTRINGSIZE);
    lpVarStr->dwTotalSize = IDVARSTRINGSIZE;

    lResult = lineGetDevConfig(pTG->DeviceId,
                               lpVarStr,
                               "comm/datamodem");

    if (lResult) {
        if (lpVarStr->dwTotalSize < lpVarStr->dwNeededSize) {
            dwNeededSize = lpVarStr->dwNeededSize;
            MemFree (lpVarStr);
            if ( ! (lpVarStr = (LPVARSTRING) MemAlloc(dwNeededSize) ) ) {
                MyDebugPrint(pTG, LOG_ERR, "ERR: Can't allocate %d bytes for lineGetDevConfig\n");

                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_FATAL_ERROR);

                RetCode = FALSE;
                goto l_exit;
            }

            _fmemset(lpVarStr, 0, dwNeededSize);
            lpVarStr->dwTotalSize = dwNeededSize;

            lResult = lineGetDevConfig(pTG->DeviceId,
                                       lpVarStr,
                                       "comm/datamodem");

            if (lResult) {
                MyDebugPrint(pTG, LOG_ERR, "ERR: lineGetDevConfig returns %x, le=%x", lResult, GetLastError() );

                MemFree (lpVarStr);

                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_FATAL_ERROR);
                RetCode = FALSE;
                goto l_exit;
            }
        }
        else {
            MyDebugPrint(pTG, LOG_ERR, "ERR: 1st lineGetDevConfig returns %x, le=%x", lResult, GetLastError() );

            MemFree (lpVarStr);

            pTG->fFatalErrorWasSignaled = 1;
            SignalStatusChange(pTG, FS_FATAL_ERROR);
            RetCode = FALSE;
            goto l_exit;
        }
    }

    //
    // extract DEVCFG
    //
    if (lpVarStr->dwStringFormat != STRINGFORMAT_BINARY) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR: String format is not binary for lineGetDevConfig\n");

        MemFree (lpVarStr);

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;
        goto l_exit;
    }

    if (lpVarStr->dwUsedSize<sizeof(DEVCFG)) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR: lineGetDevConfig : Varstring size returned too small\n");

        MemFree (lpVarStr);

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;
        goto l_exit;
    }

    lpDevCfg = (LPDEVCFG) ((LPBYTE)(lpVarStr)+lpVarStr->dwStringOffset);

    lpModemSettings = (LPMODEMSETTINGS) ( (LPBYTE) &(lpDevCfg->commconfig.wcProviderData) );

    pTG->dwSpeakerVolume = lpModemSettings->dwSpeakerVolume;
    pTG->dwSpeakerMode   = lpModemSettings->dwSpeakerMode;


    MyDebugPrint(pTG, LOG_ALL, "lineGetDevConfig returns SpeakerVolume=%x, Volume=%x\n",
                               pTG->dwSpeakerVolume, pTG->dwSpeakerMode);

    MemFree (lpVarStr);
    lpVarStr=0;


    // get dwPermanentLineID
    // ---------------------------

    lpLineDevCaps = (LPLINEDEVCAPS) buf;

    _fmemset(lpLineDevCaps, 0, sizeof (buf) );
    lpLineDevCaps->dwTotalSize = sizeof(buf);


    lResult = lineGetDevCaps(gT30.LineAppHandle,
                             pTG->DeviceId,
                             TAPI_VERSION,
                             0,
                             lpLineDevCaps);

    if (lResult) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR:lineGetDevCaps failed\n");

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);

        RetCode = FALSE;
        goto l_exit;
    }

    if (lpLineDevCaps->dwNeededSize > lpLineDevCaps->dwTotalSize) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR:lineGetDevCaps NOT enough MEMORY\n");

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);

        RetCode = FALSE;
        goto l_exit;
    }

    // Save the permanent ID.
    //------------------------
    pTG->dwPermanentLineID =lpLineDevCaps->dwPermanentLineID;
    _stprintf (pTG->lpszPermanentLineID, "%08d\\Modem", pTG->dwPermanentLineID);
    MyDebugPrint(pTG, LOG_ALL, "Permanent Line ID=%s\n", pTG->lpszPermanentLineID);


    // Get the Unimodem key name for this device
    //------------------------------------------

    lpDSpec = (LPMDM_DEVSPEC) (  ( (LPBYTE) lpLineDevCaps) + lpLineDevCaps->dwDevSpecificOffset);

    if ( (lpLineDevCaps->dwDevSpecificSize < sizeof(MDM_DEVSPEC) ) ||
         (lpLineDevCaps->dwDevSpecificSize <= lpDSpec->dwKeyOffset) )  {
            
          MyDebugPrint(pTG, LOG_ERR, "Devspecifc caps size is only %lu",
                    (unsigned long) lpLineDevCaps->dwDevSpecificSize );

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);

        RetCode = FALSE;
        goto l_exit;
    }
    else {
            UINT u = lpLineDevCaps->dwDevSpecificSize - lpDSpec->dwKeyOffset;

#define szAPPEND "\\FAX"
            
            if ( (lpDSpec->dwContents != 1) || (lpDSpec->dwKeyOffset != 8 ) ) {
                    MyDebugPrint(pTG, LOG_ERR, "Nonstandard Devspecific: dwContents=%lu; dwKeyOffset=%lu",
                            (unsigned long) lpDSpec->dwContents,
                            (unsigned long) lpDSpec->dwKeyOffset );

                    pTG->fFatalErrorWasSignaled = 1;
                    SignalStatusChange(pTG, FS_FATAL_ERROR);

                    RetCode = FALSE;
                    goto l_exit;

            }
            
            if (u) {
                    _fmemcpy(rgchKey, lpDSpec->rgby, u);

                    if (rgchKey[u])   {
                            MyDebugPrint(pTG, LOG_ERR, "rgchKey not null terminated!" );
                            rgchKey[u-1]=0;
                    }

                    //
                    // Get ResponsesKeyName value
                    //

                    lRet = RegOpenKeyEx(
                                    HKEY_LOCAL_MACHINE,
                                    rgchKey,
                                    0,
                                    KEY_READ,
                                    &hKey);
                
                    if (lRet != ERROR_SUCCESS) {
                       MyDebugPrint(pTG, LOG_ERR, "Can't read Unimodem key %s\n", rgchKey);
   
                       pTG->fFatalErrorWasSignaled = 1;
                       SignalStatusChange(pTG, FS_FATAL_ERROR);
   
                       RetCode = FALSE;
                       goto l_exit;
                    }

                    dwSize = sizeof( pTG->ResponsesKeyName);

                    lRet = RegQueryValueEx(
                            hKey,
                            "ResponsesKeyName",
                            0,
                            &dwType,
                            pTG->ResponsesKeyName,
                            &dwSize);

                    RegCloseKey(hKey);

                    if (lRet != ERROR_SUCCESS) {
                       MyDebugPrint(pTG, LOG_ERR, "Can't read Unimodem key\\ResponsesKeyName %s\n", rgchKey);
   
                       pTG->fFatalErrorWasSignaled = 1;
                       SignalStatusChange(pTG, FS_FATAL_ERROR);
   
                       RetCode = FALSE;
                       goto l_exit;
                    }


                    //  Append  "\\Fax" to the key
                    
                    u = lstrlen(rgchKey);
                    if (u) {
                        lstrcpy(rgchKey+u, (LPSTR) szAPPEND);
                    }

                    lstrcpy(pTG->lpszUnimodemFaxKey, rgchKey);
                    MyDebugPrint(pTG, LOG_ALL, "Unimodem Fax key=%s\n", pTG->lpszUnimodemFaxKey);
            }
    }


    /// RSL -revisit, may decrease prty during computation
    if (! SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL) ) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR: SetThreadPriority TIME CRITICAL failed le=%x", GetLastError() );
    }

    // initialize modem
    //--------------------

    T30ModemInit(pTG, pTG->hComm, 0, LINEID_TAPI_PERMANENT_DEVICEID,
                      DEF_BASEKEY, pTG->lpszPermanentLineID, fMDMINIT_ANSWER);


    pTG->Inst.ProtParams.uMinScan = MINSCAN_0_0_0;
    ET30ProtSetProtParams(pTG, &pTG->Inst.ProtParams, pTG->FComModem.CurrMdmCaps.uSendSpeeds, pTG->FComModem.CurrMdmCaps.uRecvSpeeds);

    InitCapsBC( pTG, (LPBC) &pTG->Inst.SendCaps, sizeof(pTG->Inst.SendCaps), SEND_CAPS);

    // answer the call and receive a fax
    //-----------------------------------

    // here we already know what Class we will use for a particular modem.
    //-------------------------------------------------------------------

    if (pTG->ModemClass == MODEM_CLASS2) {
       Class2Init(pTG);
       RetCode = T30Cl2Rx (pTG);
    }
    else if (pTG->ModemClass == MODEM_CLASS2_0) {
       Class20Init(pTG);
       RetCode = T30Cl20Rx (pTG);
    }
    else if (pTG->ModemClass == MODEM_CLASS1) { 
       RetCode = T30Cl1Rx(pTG);
    }

    if ( pTG->fTiffOpenOrCreated ) {
        TiffClose( (HANDLE) pTG->Inst.hfile );
        pTG->fTiffOpenOrCreated = 0;
    }


    iModemClose(pTG);


#ifdef ADAPTIVE_ANSWER

    if (pTG->Comm.fEnableHandoff &&  pTG->Comm.fDataCall) {
        MyDebugPrint(pTG, LOG_ALL, "DataCall dont hangup\n");
        RetCode = FALSE;
        goto l_exit;
    }
#endif






    // release the line
    //-----------------------------

    if (pTG->fDeallocateCall == 0)  {

        //
        // line never was signalled IDLE, need to lineDrop first
        //

        if (!itapi_async_setup(pTG)) {
            MyDebugPrint(pTG, LOG_ERR, "ERROR: FaxDevReceive: lineDrop itapi_async_setup failed \n");

            if (!pTG->fFatalErrorWasSignaled) {
                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_FATAL_ERROR);
            }

            RetCode = FALSE;
            goto l_exit;
        }

        lRet = lineDrop (pTG->CallHandle, NULL, 0);

        if (lRet < 0) {
            MyDebugPrint(pTG, LOG_ERR, "ERROR: lineDrop failed %lx\n", lRet);

            if (!pTG->fFatalErrorWasSignaled) {
                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_FATAL_ERROR);
            }

            RetCode = FALSE;
            goto l_exit;
        }
        else {
            MyDebugPrint(pTG, LOG_ALL, "lineDrop returns request %d\n", lRet);
        }

        if(!itapi_async_wait(pTG, (DWORD)lRet, &lRet, NULL, ASYNC_SHORT_TIMEOUT)) {
            MyDebugPrint(pTG, LOG_ERR, "ERROR: FaxDevReceive: itapi_async_wait failed on lineDrop\n");

            goto l_exit;
        }

        MyDebugPrint(pTG, LOG_ALL, "lineDrop SUCCESS\n");

        //
        //deallocating call
        //

        if (pTG->fDeallocateCall == 0)  {

            pTG->fDeallocateCall = 1;

#if 0
//
// this is now performed in the fax service
//
            lRet = lineDeallocateCall(pTG->CallHandle );
            if (lRet) {
                MyDebugPrint(pTG, LOG_ERR, "ERROR: lineDeallocateCall returns %lx\n", lRet);
            }
            else {
                MyDebugPrint(pTG, LOG_ALL, "lineDeallocateCall SUCCESS\n");
            }
#endif
        }
    }



l_exit:

    if ( (RetCode == FALSE) && (pTG->StatusId == FS_COMPLETED) ) {
       MyDebugPrint(pTG, LOG_ERR, "ERROR: exit FaxDevReceive success but later failed \n");
       RetCode = TRUE;
    }


    if ( (RecoveryIndex >= 0) && (RecoveryIndex < MAX_T30_CONNECT) ) {
        T30Recovery[RecoveryIndex].fAvail = TRUE;
    }

    if (! SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_NORMAL) ) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR: SetThreadPriority Normal failed le=%x", GetLastError() );
    }

    if (pTG->InFileHandleNeedsBeClosed) {
        CloseHandle(pTG->InFileHandle);
        pTG->InFileHandleNeedsBeClosed = 0;
    }

    if (!pTG->AckTerminate) {
        if ( WaitForSingleObject(pTG->ThrdAckTerminateSignal, RX_WAIT_ACK_TERMINATE_TIMEOUT)  == WAIT_TIMEOUT ) {
            MyDebugPrint(pTG, LOG_ERR, "WARNING: Never got AckTerminate \n");
        }
    }

    MyDebugPrint(pTG, LOG_ALL, "Got AckTerminate OK at %ld \n", GetTickCount() );

    SetEvent(pTG->AbortAckEvent);



    MemFree(FaxReceive->FileName);
    MemFree(FaxReceive->ReceiverName);
    MemFree(FaxReceive->ReceiverNumber);

    MyDebugPrint(pTG, LOG_ALL, "FaxDevReceiveA rets %d at %ld \n", RetCode, GetTickCount() );
    
    return (RetCode);


} __except (EXCEPTION_EXECUTE_HANDLER) {

    //
    // try to use the Recovery data
    //

    DWORD      dwCkSum;
    HCALL      CallHandle;
    HANDLE     CompletionPortHandle;
    ULONG_PTR   CompletionKey;
    PThrdGlbl  pTG;
    DWORD      dwThreadId = GetCurrentThreadId();

    fFound = 0;

    for (i=0; i<MAX_T30_CONNECT; i++) {
        if ( (! T30Recovery[i].fAvail) && (T30Recovery[i].ThreadId == dwThreadId) ) {
            if ( ( dwCkSum = ComputeCheckSum( (LPDWORD) &T30Recovery[i].fAvail,
                                              sizeof ( T30_RECOVERY_GLOB ) / sizeof (DWORD) - 1) ) == T30Recovery[i].CkSum ) {

                CallHandle           = T30Recovery[i].CallHandle;
                CompletionPortHandle = T30Recovery[i].CompletionPortHandle;
                CompletionKey        = T30Recovery[i].CompletionKey;
                pTG                  = (PThrdGlbl) T30Recovery[i].pTG;

                T30Recovery[i].fAvail = TRUE;
                fFound = 1;
                break;
            }
        }
    }

    if (fFound == 0) {
        //
        // Need to indicate that FaxT30 couldn't recover by itself.
        //
        return (FALSE);
    }

    //
    // get out of Pass-through
    //

    if (!itapi_async_setup(pTG)) {
        return (FALSE);
    }

    lRet = lineSetCallParams(CallHandle,
                             LINEBEARERMODE_VOICE,
                             0,
                             0xffffffff,
                             NULL);


    if (lRet < 0) {
         return (FALSE);
    }
    else {
        if(!itapi_async_wait(pTG, (DWORD)lRet, (LPDWORD)&lRet, NULL, ASYNC_TIMEOUT)) {
            return (FALSE);
        }
    }


    //
    // hang up
    //

    if (!itapi_async_setup(pTG)) {
        return (FALSE);
    }

    lRet = lineDrop (CallHandle, NULL, 0);

    if (lRet < 0) {
         return (FALSE);
    }
    else {
        if(!itapi_async_wait(pTG, (DWORD)lRet, (LPDWORD)&lRet, NULL, ASYNC_TIMEOUT)) {
            return (FALSE);
        }

        // SignalRecoveryStatusChange(  &T30Recovery[i] );
    }

    //
    // Deallocate
    //

    lRet = lineDeallocateCall (CallHandle);

    if (lRet < 0) {
         return (FALSE);
    }
    else {

        SignalRecoveryStatusChange( &T30Recovery[i] );
    }


    if (pTG->InFileHandleNeedsBeClosed) {
        CloseHandle(pTG->InFileHandle);
    }

    SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_NORMAL);

    return (FALSE);

}



}


///////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI
FaxDevReportStatusA(
    IN  HANDLE FaxHandle OPTIONAL,
    OUT PFAX_DEV_STATUS FaxStatus,
    IN  DWORD FaxStatusSize,
    OUT LPDWORD FaxStatusSizeRequired
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    LONG_PTR         i;
    PThrdGlbl       pTG;
    LPWSTR          lpwCSI;   // inside the FaxStatus struct.
    LPBYTE          lpTemp;



    *FaxStatusSizeRequired = sizeof (FAX_DEV_STATUS);

    __try {

        if (FaxStatusSize < *FaxStatusSizeRequired ) {
            MyDebugPrint(0,  LOG_ALL, "EP: WARNING:FaxDevReportStatus: wrong size passed=%d, expected not less than %d\n",
                           FaxStatusSize,
                          *FaxStatusSizeRequired);
            goto failure;
        }

        if (FaxHandle == NULL) {
            // means global status
            MyDebugPrint(0, LOG_ERR, "EP: FaxDevReportStatus NULL FaxHandle; gT30.Status=%d \n", gT30.Status);
               
            if (gT30.Status == STATUS_FAIL) {
                goto failure;
            }
            else {
                return (TRUE);
            }
        }
        else {
            // find instance data
            //------------------------

            i = (LONG_PTR) FaxHandle;

            if (i < 1   ||  i >= MAX_T30_CONNECT)  {
                MyDebugPrint(0, LOG_ERR,  "EP: ERROR:FaxDevReportStatus - got wrong FaxHandle=%d\n", i);
                goto failure;
            }

            if (T30Inst[i].fAvail) {
                MyDebugPrint(0, LOG_ERR, "EP: ERROR:FaxDevReportStatus - got wrong FaxHandle (marked as free) %d\n", i);
                goto failure;
            }

            pTG = (PThrdGlbl) T30Inst[i].pT30;

            FaxStatus->StatusId    = pTG->StatusId;
            FaxStatus->StringId    = pTG->StringId;
            FaxStatus->PageCount   = pTG->PageCount;

            if (pTG->fRemoteIdAvail) {
                lpTemp = (LPBYTE) FaxStatus;
                lpTemp +=  sizeof(FAX_DEV_STATUS);
                lpwCSI = (LPWSTR) lpTemp;
                wcscpy(lpwCSI, pTG->RemoteID);
                FaxStatus->CSI = (LPWSTR) lpwCSI;
            }
            else {
                FaxStatus->CSI         = NULL;
            }

            FaxStatus->CallerId    = NULL; // (char *) AnsiStringToUnicodeString(pTG->CallerId);
            FaxStatus->RoutingInfo = NULL; // (char *) AnsiStringToUnicodeString(pTG->RoutingInfo);

            MyDebugPrint(pTG, LOG_ALL, "EP: FaxDevReportStatus rets %lx \n", pTG->StatusId);

            return (TRUE);
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        MyDebugPrint(0, LOG_ERR, "EP: ERROR:FaxDevReportStatus crashed accessing data\n");
        return (FALSE);
    }

    MyDebugPrint(0, LOG_ERR, "EP: ERROR:FaxDevReportStatus wrong return\n");
    return (TRUE);


failure:
    return (FALSE);

}

///////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI
FaxDevAbortOperationA(
    HANDLE              FaxHandle
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{

    LONG_PTR         i;
    PThrdGlbl       pTG=NULL;
    long            lRet;


    MyDebugPrint( (PThrdGlbl) 0, LOG_ALL, "EP: FaxDevAbortOperationA FaxHandle=%x at %ld \n", FaxHandle, GetTickCount() );



    // find instance data
    //------------------------

    i = (LONG_PTR) FaxHandle;

    if (i < 1   ||  i >= MAX_T30_CONNECT)  {
        MyDebugPrint(pTG, LOG_ERR, "FaxDevAbort - got wrong FaxHandle=%d\n", i);
        return (FALSE);
    }

    if (T30Inst[i].fAvail) {
        MyDebugPrint(pTG, LOG_ERR, "FaxDevAbort - got wrong FaxHandle (marked as free) %d\n", i);
        return (FALSE);
    }

    pTG = (PThrdGlbl) T30Inst[i].pT30;

    if (pTG->fAbortRequested) {
        MyDebugPrint(pTG, LOG_ERR, "FaxDevAbort - ABORT request had been POSTED already\n");
        return (FALSE);
    }


    if (pTG->StatusId == FS_NOT_FAX_CALL) {
        MyDebugPrint( pTG, LOG_ALL, "Abort on DATA call at %ld\n", GetTickCount() );

        if (!itapi_async_setup(pTG)) {
            MyDebugPrint(pTG, LOG_ERR, "ERROR: FaxDevAbortOperationA: itapi_async_setup failed \n");
            return (FALSE);
        }

        lRet = lineDrop(pTG->CallHandle, NULL, 0);

        if (lRet < 0)  {
            MyDebugPrint(pTG, LOG_ERR, "ERROR: FaxDevAbortOperationA: lineDrop failed %x \n", lRet);
            return (FALSE);
        }

        if( !itapi_async_wait(pTG, (DWORD)lRet, (LPDWORD)&lRet, NULL, ASYNC_TIMEOUT)) {
            MyDebugPrint(pTG, LOG_ERR, "ERROR: FaxDevAbortOperationA: async_wait lineDrop failed at %ld \n", GetTickCount() );
            return (FALSE);
        }

        MyDebugPrint( (PThrdGlbl) 0, LOG_ALL, "EP: FaxDevAbortOperationA finished SUCCESS \n");
        return (TRUE);
    }

    //
    // real ABORT request.
    //

    MyDebugPrint( pTG, LOG_ALL, "FaxDevAbort: ABORT requested %ld\n", GetTickCount() );

    pTG->fFatalErrorWasSignaled = 1;
    SignalStatusChange(pTG, FS_USER_ABORT);


    // set the global abort flag for pTG
    pTG->fAbortRequested = 1;

    // set the abort flag for imaging threads
    pTG->ReqTerminate = 1;

    // signal manual-reset event to everybody waiting on multiple objects
    if (! SetEvent(pTG->AbortReqEvent) ) {
        MyDebugPrint(pTG, LOG_ERR, "FaxDevAbort -SetEvent FAILED le=%lx at %ld\n", GetLastError(), GetTickCount() );
    }

    // check to see whether pTG gracefully and timely shut itself down
    if ( WaitForSingleObject(pTG->AbortAckEvent, ABORT_ACK_TIMEOUT) == ABORT_ACK_TIMEOUT ) {
        MyDebugPrint(pTG, LOG_ERR, "FaxDevAbort - ABORT ACK timeout at %ld\n", GetTickCount() );
        return (FALSE);
    }

    MyDebugPrint(pTG, LOG_ALL, "FaxDevAbort - ABORT ACK at %ld\n", GetTickCount() );

    MyDebugPrint( (PThrdGlbl) 0, LOG_ALL, "EP: FaxDevAbortOperationA finished SUCCESS at %ld \n", GetTickCount() );
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\main\t30util.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    t30util.c

Abstract:

    Utilities for t30

Author:

    Rafael Lisitsa (RafaelL) 2-Feb-1996


Revision History:

--*/

#include "prep.h"


#include "glbproto.h"
#include "t30gl.h"

#define IDVARSTRINGSIZE     (sizeof(VARSTRING)+128)
#define BAD_HANDLE(h)       (!(h) || (h)==INVALID_HANDLE_VALUE)


///////////////////////////////////////////////////////////////////////////////////
PVOID
T30AllocThreadGlobalData(
    VOID
    )
{

    PVOID   pTG;

    pTG = MemAlloc (sizeof(ThrdGlbl) );
    FillMemory (pTG, sizeof(ThrdGlbl), 0);


    return (pTG);


}



/////////////////////////////////////////////////////////////




BOOL itapi_async_setup(PThrdGlbl pTG)
{

    EnterCriticalSection(&T30CritSection);

    if (pTG->fWaitingForEvent) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR:Already waiting for event!\n");
    }

    if (pTG->dwSignalledRID) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR:Nonzero old NONZERO ID 0x%lx\n",(unsigned long) pTG->dwSignalledRID);
    }

    pTG->fWaitingForEvent=TRUE;

    ResetEvent(pTG->hevAsync);

    LeaveCriticalSection(&T30CritSection);


    return TRUE;

}







BOOL itapi_async_wait(PThrdGlbl pTG,
                      DWORD dwRequestID,
                      PDWORD lpdwParam2,
                      PDWORD_PTR lpdwParam3,
                      DWORD dwTimeout)
{

    DWORD                 NumHandles=2;
    HANDLE                HandlesArray[2];
    DWORD                 WaitResult;

    if (!pTG->fWaitingForEvent) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR:Not waiting for event!\n");
        // ASSERT(FALSE);
    }

    HandlesArray[1] = pTG->AbortReqEvent;

    //
    // We want to be able to un-block ONCE only from waiting on I/O when the AbortReqEvent is signaled.
    //

    if (pTG->fAbortRequested) {

        if (pTG->fOkToResetAbortReqEvent && (!pTG->fAbortReqEventWasReset)) {
            MyDebugPrint(pTG,  LOG_ALL,  "itapi_async_wait RESETTING AbortReqEvent at %lx\n",GetTickCount() );
            pTG->fAbortReqEventWasReset = 1;
            ResetEvent(pTG->AbortReqEvent);
        }

        pTG->fUnblockIO = 1;
    }

    HandlesArray[0] = pTG->hevAsync;

    if (pTG->fUnblockIO) {
        NumHandles = 1;
    }
    else {
        NumHandles = 2;
    }


    WaitResult = WaitForMultipleObjects(NumHandles, HandlesArray, FALSE, dwTimeout);

    if (WaitResult == WAIT_FAILED) {
        MyDebugPrint(pTG, LOG_ERR, "itapi_async_wait: WaitForMultipleObjects FAILED le=%lx at %ld \n",
                                    GetLastError(), GetTickCount() );
    }

    if ( (NumHandles == 2) && (WaitResult == WAIT_OBJECT_0 + 1) ) {
        pTG->fUnblockIO = 1;

        MyDebugPrint(pTG, LOG_ALL, "itapi_async_wait ABORTED at %ld\n", GetTickCount() );
        return FALSE;
    }


    switch( WaitResult ) {

        case (WAIT_OBJECT_0):  {
            BOOL fRet=TRUE;

            EnterCriticalSection(&T30CritSection);

            if(pTG->dwSignalledRID == dwRequestID) {
                 pTG->dwSignalledRID = 0;
                 pTG->fWaitingForEvent = FALSE;
            }
            else {
                 MyDebugPrint(pTG, LOG_ERR, "ERROR:Request ID mismatch. Input:0x%p; Curent:0x%p\n",
                                 dwRequestID,
                                 pTG->dwSignalledRID);
                 fRet=FALSE;
            }

            LeaveCriticalSection(&T30CritSection);

            if (!fRet)
                goto failure;
        }

        break;

        case WAIT_TIMEOUT:
                MyDebugPrint(pTG, LOG_ERR, "ERROR:Wait timed out. RequestID=0x%p\n",
                                        dwRequestID);
                goto failure;


        default:
                MyDebugPrint(pTG, LOG_ERR, "ERROR:Wait returns error. GetLastError=%ld\n",
                                        (long) GetLastError());
                goto failure;
        }


        if (lpdwParam2) *lpdwParam2 = pTG->dwSignalledParam2;

        if (lpdwParam3) *lpdwParam3 = pTG->dwSignalledParam3;

        return TRUE;



failure:
        EnterCriticalSection(&T30CritSection);

        if(pTG->dwSignalledRID==dwRequestID) {
                pTG->dwSignalledRID=0;
                pTG->fWaitingForEvent=FALSE;
        }

        LeaveCriticalSection(&T30CritSection);

        return FALSE;
}







BOOL itapi_async_signal(PThrdGlbl pTG,
                        DWORD dwRequestID,
                        DWORD dwParam2,
                        DWORD_PTR dwParam3)
{
        BOOL fRet=FALSE;


        EnterCriticalSection(&T30CritSection);

        if (!pTG->fWaitingForEvent) {
                MyDebugPrint(pTG, LOG_ERR, "ERROR:Not waiting for event, ignoring ID=0x%lx \n",
                                (unsigned long) dwRequestID);
                goto end;
        }


        if (pTG->dwSignalledRID) {
                MyDebugPrint(pTG, LOG_ERR, "ERROR:Nonzero old NONZERO ID 0x%lx. New ID=0x%lx \n",
                                (unsigned long) pTG->dwSignalledRID,
                                (unsigned long) dwRequestID);
        }

        pTG->dwSignalledRID=dwRequestID;
        pTG->dwSignalledParam2= 0;
        pTG->dwSignalledParam3= 0;

        if (!SetEvent(pTG->hevAsync)) {
                MyDebugPrint(pTG, LOG_ERR, "ERROR:SetEvent(0x%lx) returns failure code: %ld \n",
                                (ULONG_PTR) pTG->hevAsync,
                                (long) GetLastError());
                fRet=FALSE;
                goto end;
        }

        pTG->dwSignalledParam2= dwParam2;
        pTG->dwSignalledParam3= dwParam3;

        fRet=TRUE;
end:
        LeaveCriticalSection(&T30CritSection);
        return fRet;
}






VOID
MyDebugPrint(
    PThrdGlbl   pTG,
    int         DbgLevel,
    LPSTR       Format,
    ...
    )

{
    char          buf[1024];
    char          c;
    va_list       arg_ptr;
    int           u;
    int           i;
    DWORD         dwWritten;


    if ( (DbgLevel > gT30.DbgLevel) || (! gfFilePrint) ) {
        return;
    }

    va_start(arg_ptr, Format);

    if (pTG == NULL) {
        wsprintf(buf, "----");
    }
    else {
        wsprintf(buf, "-%02d-", pTG->DeviceId);
    }

    u = wvsprintf(&buf[4], Format, arg_ptr) + 4;

//    _vsnprintf(buf, sizeof(buf), Format, arg_ptr);
    va_end(arg_ptr);

    //
    // scramble buf
    //

    for (i=0; i<u; i++) {
        c = buf[i];
        buf[i] = ( (c << 4 ) & 0xf0 ) | ( (c >> 4) & 0x0f );
    }


    WriteFile(ghLogFile, buf, u, &dwWritten, NULL);



}





#define CALLPARAMS_SIZE (sizeof(LINECALLPARAMS)+512)


LPLINECALLPARAMS itapi_create_linecallparams(void)
{
     UINT cb = CALLPARAMS_SIZE;
     LPLINECALLPARAMS lpParams = MemAlloc(cb);

     if (!lpParams)
          goto end;

     _fmemset(lpParams,0, cb);
     lpParams->dwTotalSize= cb;

    lpParams->dwBearerMode = LINEBEARERMODE_PASSTHROUGH;
    lpParams->dwMediaMode = LINEMEDIAMODE_DATAMODEM; // Unimodem only accepts


    lpParams->dwCallParamFlags = 0;
    lpParams->dwAddressMode = LINEADDRESSMODE_ADDRESSID;
    lpParams->dwAddressID = 0; // +++ assumes addreddid 0.
    lpParams->dwCalledPartySize = 0; // +++
    lpParams->dwCalledPartyOffset = 0; // +++

end:
        return lpParams;
}





BOOL
SignalStatusChange(
    PThrdGlbl   pTG,
    DWORD       StatusId
    )

{

    FAX_DEV_STATUS  *pFaxStatus;
    LPWSTR          lpwCSI;       // inside the FaxStatus struct.
    LPBYTE          lpTemp;

    //
    // If Aborting OR completed then do NOT override the statusId
    //

    if ( (pTG->StatusId == FS_USER_ABORT) || (pTG->StatusId == FS_COMPLETED) ) {
        return (TRUE);
    }

    pTG->StatusId = StatusId;

    // should use HeapAlloc because FaxSvc frees it.
    pFaxStatus = HeapAlloc(gT30.HeapHandle , HEAP_ZERO_MEMORY,  sizeof(FAX_DEV_STATUS) + 4096 );

    if (!pFaxStatus) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR: SignalStatusChange HeapAlloc failed\n");
        goto failure;
    }

    pFaxStatus->SizeOfStruct = sizeof (FAX_DEV_STATUS) + 4096;
    pFaxStatus->StatusId = pTG->StatusId;
    pFaxStatus->StringId = pTG->StringId;

    if (pTG->StatusId == FS_RECEIVING) {
        pFaxStatus->PageCount = pTG->PageCount + 1;
    }
    else {
        pFaxStatus->PageCount = pTG->PageCount;
    }

    if (pTG->fRemoteIdAvail) {
        lpTemp = (LPBYTE) pFaxStatus;
        lpTemp +=  sizeof(FAX_DEV_STATUS);
        lpwCSI = (LPWSTR) lpTemp;
        wcscpy(lpwCSI, pTG->RemoteID);
        pFaxStatus->CSI = (LPWSTR) lpwCSI;
    }
    else {
        pFaxStatus->CSI         = NULL;
    }

    // RSL BUGBUG
    pFaxStatus->CallerId = NULL;
    pFaxStatus->RoutingInfo = NULL;


    if (! PostQueuedCompletionStatus(pTG->CompletionPortHandle,
                                     sizeof (FAX_DEV_STATUS),
                                     pTG->CompletionKey,
                                     (LPOVERLAPPED) pFaxStatus) )  {

        MyDebugPrint(pTG, LOG_ERR, "ERROR: PostQueuedCompletionStatus failed LE=%x\n",
                          GetLastError() );
        goto failure;
    }


    MyDebugPrint(pTG, LOG_ALL, "SignalStatusChange ID=%x Page=%d \n", pTG->StatusId, pTG->PageCount);


    return (TRUE);



failure:

    return (FALSE);



}





BOOL
SignalRecoveryStatusChange(
    T30_RECOVERY_GLOB       *Recovery
    )

{

    FAX_DEV_STATUS  *pFaxStatus;


    // should use HeapAlloc because FaxSvc frees it.
    pFaxStatus = HeapAlloc(gT30.HeapHandle , HEAP_ZERO_MEMORY,  sizeof(FAX_DEV_STATUS) + 4096 );

    if (!pFaxStatus) {
        goto failure;
    }

    pFaxStatus->SizeOfStruct = sizeof (FAX_DEV_STATUS) + 4096;
    pFaxStatus->StatusId = FS_FATAL_ERROR;   // RSL better: FS_FSP_EXCEPTION_HANDLED;
    pFaxStatus->StringId = 0;

    pFaxStatus->PageCount = 0;

    pFaxStatus->CSI         = NULL;

    pFaxStatus->CallerId = NULL;
    pFaxStatus->RoutingInfo = NULL;


    if (! PostQueuedCompletionStatus(Recovery->CompletionPortHandle,
                                     sizeof (FAX_DEV_STATUS),
                                     Recovery->CompletionKey,
                                     (LPOVERLAPPED) pFaxStatus) )  {

        goto failure;
    }


    return (TRUE);



failure:

    return (FALSE);



}



DWORD
ComputeCheckSum(
    LPDWORD     BaseAddr,
    DWORD       NumDwords
    )
{

    DWORD   RetValue = 0;
    DWORD   i;

    for (i=0; i<NumDwords; i++) {
        RetValue += *(BaseAddr+i);
    }

    return (RetValue);

}






VOID
SimulateError(
    DWORD   ErrorType
    )


{

    LPDWORD     lpdwPtr;
    DWORD       dw1,
                dw2;


    switch (ErrorType) {
        case  EXCEPTION_ACCESS_VIOLATION:
             lpdwPtr = NULL;
             *lpdwPtr = 5;

             break;



        case  EXCEPTION_INT_DIVIDE_BY_ZERO:
             dw1 = 5;
             dw2 = dw1 - 1;
             dw2 = dw1 / (dw1 + dw2 - 9);

             break;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\main\t30.c ===
/***************************************************************************
 Name     :     T30.C
 Comment  :     Contains the main T30 routine, which drives this whole baby.
                        It calls the user-supplied protocol function to make all the
                        protocol decision functions. Thus in a sense this merely
                        a hollow shell.

                        This file should be read together with the appropriate
                        protocol function that is in use, and the T30 flowchart
                        (the enhanced one which includes ECM that is supplied in
                        T.30 Appendix-A). Ideally the (paper) copy of the chart
                        which I've annotated to chow which nodes are implemented
                        in the protocol callback function.

                        The other routines contained here implement the T.30
                        flowchart "subroutines" labelled "Response Received"
                        "Command Received", "RR Response Received" and "CTC
                        Response Received". All of which are called (only)
                        from ET30MainBody().

                        Most of teh real work is farmed out to HDLC.C (and macros
                        in HDLC.H), so the T30 routine is reasonably lucid.

                        It's organized as a block of statements with gotos between
                        them to closely mirror the T30 flowchart. (It's actually
                    uncannily close!)

 Functions:     (see Prototypes just below)

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
 06/14/92 arulm Created it in the new incarnation for the first time. The
                                T30Main() function is re-written to call WhatNext() at *all*
                                decision points. Some parts are simplified. It bears some
                                resemblance to the original. Command/ResponseReceived is
                                completely re-written.
 06/15/92 arulm Added ECM. Still havn't tried compiling it.
 06/16/92 arulm First successful compile.

***************************************************************************/

#include "prep.h"

#include "efaxcb.h"
#include "t30.h"
#include "hdlc.h"

#include "..\comm\modemint.h"
#include "..\comm\fcomint.h"
#include "..\comm\mdmcmds.h"


#include "debug.h"

#include "tiff.h"

#include "glbproto.h"

#include "t30gl.h"




#define         faxTlog(m)              DEBUGMSG(ZONE_T30, m)
#define         faxT2log(m)             DEBUGMSG(ZONE_FRAMES, m)
#define         FILEID                  FILEID_T30


#ifdef MDDI             // zero-stuffing
#       define SetStuffZERO(x)  T30SetStuffZERO(x)
        extern void T30SetStuffZERO(PThrdGlbl pTG, USHORT cbLineMin);
        extern BOOL FilterSendMem(PThrdGlbl pTG, HMODEM h, LPBYTE lpb, USHORT uCount);
#else
#       define SetStuffZERO(pTG, x)                          FComSetStuffZERO(pTG, x)
#       define FilterSendMem(pTG, h, lpb, uCnt)      ModemSendMem(pTG, h, lpb, uCnt, 0)
#endif


#ifdef DEBUG
#       define  TIMESTAMP(str)  \
                faxTlog((SZMOD "TIMESTAMP %lu %s--\r\n", (unsigned long) GetTickCount(), (LPSTR) (str)));
#else  // !DEBUG
#       define  TIMESTAMP(str)
#endif // !DEBUG






/***************************************************************************
 Name     :     ET30MainBody
 Purpose  :     This is the main T30. It's main purpose is to faithfully
                        reproduce the flowchart on pages 100-103 of Fascicle VII.3
                        of the CCITT blue book, Recomendation T30.

                        It is to be called from the protocol module after a call has
                        been successfully placed or answered & the modem is in HDLC
                        receive or send mode respectively. It conducts the entire call,
                        making callbacks at all decision points to a protocol-supplied
                        callback function. It also calls protocol-supplied callback
                        functions to get data to send and to unload received data.

 Returns  :     When it returns, the phone is on hook & the modem reset.
                        It returns TRUE on successful call completion, and FALSE on
                        error. In all cases, GetLastError() will return the completion
                        status.


 Arguments:
 Comment  :     This function is supposed to mirror the flowchart
                        so it is structured as a series of statement blocks and a rats
                        nest of Gotos. Yes I hate GOTOs too. Havn't used one in years,
                        but try to do this yourself sometime in a "structured" way.

                        The Labels used are the same as those used in the Flowchart, and
                        the blocks are arranged in approximately teh same order as in
                        the chart, so reading both together will be a pleasant surprise.
                        Make sure you use the chart in the __APPENDIX-A__ of the
                        **1988** (or Blue Book) CCITT specs. The chart in teh main body
                        of teh spec is (a) deceptively similar (b) out-of-date

 Calls    :     All of HDLC.C, some of MODEM.C, and a little of FCOM.C.
                        all the rest of the functions in this file.
 Called By:

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
 06/15/92 arulm Adding ECM. Making it compilable
***************************************************************************/

#ifdef MDDI
#       // Ricohs protocol tester complains if this exceeds 40secs
#       define T1_TIMEOUT       35000L  // use exact 35s nominal value
#else
#       define T1_TIMEOUT       40000L  // 35s + 5s. On PCs be more lax
#endif


// #define T2_TIMEOUT   7000                    // 6s + 1s
#define T2_TIMEOUT              6000                    // 6s
#define T3_TIMEOUT              15000L                  // 10s + 5s
// #define T4_TIMEOUT   3450                    // 3s + 15%
#define T4_TIMEOUT              3000                    // 3s
// #define T4_TIMEOUT   2550                    // 3s - 15%

// if our DCS-TCF collides with the recvrs 2nd NSF-DIS or NSC-DTC
// then if the lengths are just right, we can end up in lock step
// after the first try, increase the TCF-response timeout so we
// get out of lock step! This is bug#6847
#define TCFRESPONSE_TIMEOUT_SLACK       500     // 0.5 secs


/****************** begin prototypes from t30.c *****************/
ET30ACTION PhaseNodeA(PThrdGlbl pTG);
ET30ACTION PhaseNodeT(PThrdGlbl pTG);
ET30ACTION PhaseNodeD(PThrdGlbl pTG, BOOL);
ET30ACTION NonECMPhaseC(PThrdGlbl pTG );
ET30ACTION NonECMPhaseD(PThrdGlbl pTG );
ET30ACTION RecvPhaseB(PThrdGlbl pTG, ET30ACTION action);
ET30ACTION PhaseNodeF(PThrdGlbl pTG, BOOL, BOOL);
ET30ACTION PhaseRecvCmd(PThrdGlbl pTG );
ET30ACTION PhaseGetTCF(PThrdGlbl pTG, IFR, BOOL);
ET30ACTION NonECMRecvPhaseC(PThrdGlbl pTG);
ET30ACTION NonECMRecvPhaseD(PThrdGlbl pTG);
/***************** end of prototypes from t30.c *****************/




USHORT T30MainBody(PThrdGlbl pTG, BOOL fCaller, ET30ACTION actionInitial, HLINE hLine, HMODEM hModem )
{
        ET30ACTION              action;
        USHORT                  uRet;
        BOOL                    fEnteredHalfway;

        uRet = T30_CALLFAIL;

        FComCriticalNeg(pTG, TRUE);

        (MyDebugPrint(pTG, LOG_ALL,  "\r\n\r\n\r\n\r\n\r\n======================= Entering MainBody ==============================\r\n\r\n\r\n\r\n"));

        // zero-init the 3 global structs T30, ECM and Params. After this some
        // fields are inited to non-zero below. Rest are set approp elsewhere
        // in the code (hopefully before use :-)
        _fmemset(&pTG->Params, 0, sizeof(pTG->Params));
        _fmemset(&pTG->T30, 0, sizeof(pTG->T30));
        _fmemset(&pTG->ECM, 0, sizeof(pTG->ECM));
        _fmemset(&pTG->EchoProtect, 0, sizeof(pTG->EchoProtect));

        pTG->Params.hModem = hModem;
        pTG->Params.hLine = hLine;
        pTG->Params.lpfnWhatNext = ProtGetWhatNext(pTG);

        // INI file settings related stuff
        pTG->T30.uSkippedDIS = 0;

        // Initialize this global. Very Important!! See HDLC.C for usage.
        pTG->T30.fReceivedDIS = FALSE;
        pTG->T30.fReceivedDTC = FALSE;
        pTG->T30.fReceivedEOM = FALSE;
        pTG->T30.uTrainCount = 0;
        pTG->T30.uRecvTCFMod = 0xFFFF;
        pTG->T30.ifrCommand = pTG->T30.ifrResp = pTG->T30.ifrSend = 0;

        pTG->ECM.ifrPrevResponse = 0;
        pTG->ECM.SendPageCount = 0;
        pTG->ECM.fEndOfPage = pTG->ECM.fRecvEndOfPage = TRUE;
        pTG->T30.fAtEndOfRecvPage = FALSE;

        pTG->ECM.fSentCTC = FALSE;
        pTG->ECM.fRecvdCTC = FALSE;

#ifdef SMM
        pTG->T30.lpfs = (LPFRAMESPACE)pTG->bStaticRecvdFrameSpace;
#else
#error NYI ERROR: Code Not Complete--Have to pick GMEM_ flags (FIXED? SHARE?)
        ...also have to call IFProcSetResFlags(hinstMe).....
        pTG->T30.lpfs = (LPFRAMESPACE)IFMemAlloc(0,TOTALRECVDFRAMESPACE, &uwJunk);
#endif
        pTG->T30.Nframes = 0;




        fEnteredHalfway = FALSE;

        if(actionInitial != actionNULL)
        {
                (MyDebugPrint(pTG,  LOG_ERR,  "<<WARNING>> Got Initial Action = %d\r\n", actionInitial));
                action = actionInitial;
                fEnteredHalfway = TRUE;
                BG_CHK(action==actionGONODE_F || action==actionGONODE_D);
        }
        else if(fCaller)        // choose the right entry point
                action = actionGONODE_T;
        else
        {
                action = actionGONODE_R1;
                pTG->T30.fSendAfterSend = TRUE;      // CED--NSF/DIS
        }

        // fall through into PhaseLoop



        /******** Phase loop ********/

//PhaseLoop:
        for(;;)
        {
                /******************************************************************************
                        T = Start of Phase be for transmitter
                        R1 = Start of Phase B for callee
                        R2 = start of Phase B for poller
                        A = Poll/Send decision point
                        D =     Start of DCS/TCF
                        F = Recv Command loop
                        RecvCmd = Interpretation of pre-page cmds
                        RecvPhaseC = Start of Rx PhaseC (ECM and Non-pTG->ECM. New Page in ECM mode)

                        I = Start of Tx PhaseC (ECM & Non-pTG->ECM. New page in ECM mode)
                        II = Start of Tx Non-ECM PhaseD
                        III = Start of Rx Non-ECM PhaseD
                        IV = Start of Tx ECM PhaseC (Same page, new block)
                        V = Start of Tx ECM PhaseD (end of partial page)
                        VII = Start of Rx ECM PhaseD

                        RecvPRIQ = Handling of recvd PRI-Q commands
                        E = Handling of received PIP/PIN responses
                *******************************************************************************/

                switch(action)
                {
                case actionGONODE_T:    (MyDebugPrint(pTG, LOG_ALL,  "EndPhase: Got actionGONODE_T\r\n"));
                                                                action = PhaseNodeT(pTG);
                                                                break;

                case actionGONODE_D:    (MyDebugPrint(pTG, LOG_ALL,  "EndPhase: Got actionGONODE_D\r\n"));
                                                                action = PhaseNodeD(pTG, fEnteredHalfway);
                                                                fEnteredHalfway = FALSE;
                                                                break;

                case actionGONODE_A:    (MyDebugPrint(pTG, LOG_ALL,  "EndPhase: Got actionGONODE_A\r\n"));
                                                                action = PhaseNodeA(pTG);
                                                                break;

                case actionGONODE_R1:   (MyDebugPrint(pTG, LOG_ALL,  "EndPhase: Got actionGONODE_R1\r\n"));
                                                                action = RecvPhaseB(pTG, action);
                                                                break;

                case actionGONODE_R2:   (MyDebugPrint(pTG, LOG_ALL,  "EndPhase: Got actionGONODE_R2\r\n"));
                                                                action = RecvPhaseB(pTG, action);
                                                                break;

                case actionNODEF_SUCCESS:
                                                                (MyDebugPrint(pTG, LOG_ALL,  "EndPhase: Got actionNODEF_SUCCESS\r\n"));
                                                                action = PhaseNodeF(pTG, TRUE, FALSE);
                                                                break;

                case actionGONODE_F:    (MyDebugPrint(pTG, LOG_ALL,  "EndPhase: Got actionGONODE_F\r\n"));
                                                                action = PhaseNodeF(pTG, FALSE, fEnteredHalfway);
                                                                fEnteredHalfway = FALSE;
                                                                break;

                case actionGONODE_RECVCMD:
                                                                (MyDebugPrint(pTG, LOG_ALL,  "EndPhase: Got actionGONODE_RECVCMD\r\n"));
                                                                action = PhaseRecvCmd(pTG);
                                                                break;


                case actionGONODE_I:    (MyDebugPrint(pTG, LOG_ALL,  "EndPhase: Got actionGONODE_I\r\n"));
                                                                action = NonECMPhaseC(pTG);
                                                                break;

                case actionGONODE_II:   (MyDebugPrint(pTG, LOG_ALL,  "EndPhase: Got actionGONODE_II\r\n"));
                                                                action = NonECMPhaseD(pTG);
                                                                break;

                case actionGONODE_III:  (MyDebugPrint(pTG, LOG_ALL,  "EndPhase: Got actionGONODE_III\r\n"));
                                                                action = NonECMRecvPhaseD(pTG);
                                                                break;

                case actionGONODE_IV:   (MyDebugPrint(pTG, LOG_ALL,  "EndPhase: Got actionGONODE_IV_New\r\n"));
                                                                action = ECMPhaseC(pTG, FALSE);      // ReTx
                                                                break;

                case actionGONODE_ECMRETRANSMIT:
                                                                (MyDebugPrint(pTG, LOG_ALL,  "EndPhase: Got actionGONODE_ECMRETRANSMIT\r\n"));
                                                                action = ECMPhaseC(pTG, TRUE);       // ReTx
                                                                break;

                case actionGONODE_V:    (MyDebugPrint(pTG, LOG_ALL,  "EndPhase: Got actionGONODE_V\r\n"));
                                                                action = ECMPhaseD(pTG);
                                                                break;

                case actionSENDEOR_EOP: (MyDebugPrint(pTG, LOG_ALL,  "EndPhase: Got actionSENDEOR_EOP\r\n"));
                                                                action = ECMSendEOR_EOP(pTG);
                                                                break;


                case actionGONODE_VII:  (MyDebugPrint(pTG, LOG_ALL,  "EndPhase: Got actionGONODE_VII\r\n"));
                                                                action = ECMRecvPhaseD(pTG);
                                                                break;

                case actionGONODE_RECVPHASEC:
                                                                // (MyDebugPrint(pTG, LOG_ALL,  "EndPhase: Got actionGONODE_RECVPHASEC\r\n"));
/**/
                                                                if(ProtReceivingECM(pTG))
                                                                        action = ECMRecvPhaseC(pTG, FALSE);
                                                                else
/**/
                                                                        action = NonECMRecvPhaseC(pTG);
                                                                break;

                case actionGONODE_RECVECMRETRANSMIT:
                                                                // (MyDebugPrint(pTG, LOG_ALL,  "EndPhase: Got actionGONODE_RECVECMRETRANSMIT\r\n"));
                                                                BG_CHK(ProtReceivingECM(pTG));
                                                                action = ECMRecvPhaseC(pTG, TRUE);
                                                                break;


                case actionNULL:                BG_CHK(FALSE);
                                                                goto error;

                case actionDCN_SUCCESS: (MyDebugPrint(pTG, LOG_ALL,  "EndPhase: Got actionDCN_SUCCESS\r\n"));
                                                                uRet = T30_CALLDONE;
                                                                goto NodeC;     // successful end of send call

                case actionHANGUP_SUCCESS:
                                                                (MyDebugPrint(pTG, LOG_ALL,  "EndPhase: Got actionHANGUP_SUCCESS\r\n"));
                                                                ICommGotDisconnect(pTG);
                                                                uRet = T30_CALLDONE;
                                                                goto NodeB;     // successful end of recv call

                case actionDCN:                 (MyDebugPrint(pTG, LOG_ALL,  "EndPhase: Got actionDCN\r\n"));
                                                                goto NodeC;

                case actionHANGUP:              (MyDebugPrint(pTG, LOG_ALL,  "EndPhase: Got actionHANGUP\r\n"));
                        // This should only be called on a _successful_ completion,
                        // otherwise we get either (a) a DCN that MSGHNDLR does not
                        // want OR (b) A fake EOJ posted to MSGHNDLR. See bug#4019
                        ////// ICommGotDisconnect(); /////
                                                                goto NodeB;

                case actionERROR:               (MyDebugPrint(pTG, LOG_ALL,  "EndPhase: Got actionERROR\r\n"));
                                                                // ICommStatus(T30STAT_ERROR, 0, 0, 0);
                                                                goto error;

                default:                                BG_CHK(FALSE);
                                                                goto error;

#               ifdef PRI
                        case actionGONODE_RECVPRIQ:
                                                                (MyDebugPrint(pTG, LOG_ALL,  "EndPhase: Got actionGONODE_RECVPRIQ\r\n"));
                                                                goto RecvPriQ;

                        case actionGONODE_E:(MyDebugPrint(pTG, LOG_ALL,  "EndPhase: Got actionGONODE_E\r\n"));
                                                                goto NodeE;
                        case actionGOVOICE:     (MyDebugPrint(pTG, LOG_ALL,  "EndPhase: Got actionGOVOICE\r\n"));
                                                                goto VoiceLine;
#               endif
                }
        }









        /******** PRI-Q stuff (Rx side) ********/
#ifdef PRI
        // no fall through here
        BG_CHK(FALSE);
RecvPRIQ:
        switch(action = pTG->Params.lpfnWhatNext(pTG, eventGOTPRIQ, (WORD)pTG->T30.ifrCommand))
        {
          case actionSENDPIP:   pTG->T30.ifrSend=ifrPIP; goto VoiceLine;
          case actionSENDPIN:   pTG->T30.ifrSend=ifrPIN; goto VoiceLine;
          case actionGONODE_F:  CLEAR_MISSED_TCFS();    break;
          case actionGO_RECVPOSTPAGE:
                        pTG->T30.ifrCommand = pTG->T30.ifrCommand-ifrPRI_MPS+ifrMPS;
                        action = GONODE_III;
                        break;
          case actionHANGUP:    break;
          case actionERROR:             break;  // goto PhaseLoop & exit
////      default:                              return BadAction(action);
        }
        goto PhaseLoop;


        /******** PIP/PIN stuff (Tx side) ********/

        // no fall through here
        BG_CHK(FALSE);
NodeE:
        switch(action = pTG->Params.lpfnWhatNext(pTG, eventGOTPIPPIN,
                                                        (WORD)pTG->T30.ifrResp, (DWORD)pTG->T30.ifrSend))
        {
          case actionGOVOICE:   goto VoiceLine;
          case actionGONODE_A:  BG_CHK(FALSE);  // dunno what to do here
          case actionDCN:               (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Got actionDCN from eventGOTPIPPIN\r\n"));
                                                        action = actionDCN;
                                                        break;
          case actionERROR:             break;  // goto PhaseLoop & exit
////      default:                              return BadAction(action);
        }
        goto PhaseLoop;
        // no fall through here

VoiceLine:
        SendSingleFrame(pTG, pTG->T30.ifrSend, 0, 0, 1);             // re-send PRI-Q or send PIP/PIN
        switch(action = pTG->Params.lpfnWhatNext(pTG, eventVOICELINE))
        {
          case actionHANGUP:    (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Got actionHANGUP from eventVOICELINE\r\n"));
                                                        action = actionHANGUP;
                                                        break;
          case actionGONODE_T:
          case actionGONODE_R1:
          case actionGONODE_R2: break;
          case actionERROR:             break;  // goto PhaseLoop & exit
////      default:                              return BadAction(action);
        }
        goto PhaseLoop;
#endif




error:
        (MyDebugPrint(pTG,  LOG_ERR,  "=======******* USER ABORT or TRANSPORT FATAL ERROR *******========\r\n"));

        // must call this always, because it's resets the Modem Driver's
        // global state (e.g. shuts down SW framing & filters if open,
        // resets the state variables etc (EndMode()))
        // Must call it before the SendDCN() because SendDCN causes
        // BG_CHKs if in strange state.

        ModemSync(pTG, pTG->Params.hModem, RESYNC_TIMEOUT1);

        if(pTG->T30.fReceivedDIS || pTG->T30.fReceivedDTC)
                SendDCN(pTG);

        // hangup in T30Main
        // NCULink(pTG->Params.hLine, 0, 0, NCULINK_HANGUP);
        // already hungup?

#ifndef SMM
        IFMemFree(pTG, pTG->T30.lpfs);
#endif
        FComCriticalNeg(pTG, FALSE);
        uRet = T30_CALLFAIL;
        goto done;


NodeC:
#ifdef MDDI
        ModemSync(pTG, pTG->Params.hModem, RESYNC_TIMEOUT1);
#else // !MDDI
        // +++ 4/12/95 Win95 hack --  to prevent ModemSync from sending
        // an AT here.
        ModemSyncEx(pTG, pTG->Params.hModem, RESYNC_TIMEOUT1, fMDMSYNC_DCN);
#endif // !MDDI
        SendDCN(pTG);
        // falls through here
NodeB:

        // call this here also??
        // ModemSync(pTG->Params.hModem, RESYNC_TIMEOUT1);

        // hangup in T30Main
        // NCULink(pTG->Params.hLine, 0, 0, NCULINK_HANGUP);

#ifndef SMM
        IFMemFree(pTG, pTG->T30.lpfs);
#endif
        FComCriticalNeg(pTG, FALSE);
        // fall through to done:

done:
        return uRet;
}
// End of T30 routine!!!!!!!!!

















ET30ACTION PhaseNodeA(PThrdGlbl pTG)
{
        MyDebugPrint (pTG, LOG_ALL, "T30: PhaseNodeA \n" );

        if(pTG->T30.ifrCommand == ifrDIS)
                pTG->T30.fReceivedDIS = TRUE;
        else if(pTG->T30.ifrCommand == ifrDTC)
                pTG->T30.fReceivedDTC = TRUE;

        return (pTG->Params.lpfnWhatNext) (pTG, eventNODE_A, (WORD)pTG->T30.ifrCommand);
}
















ET30ACTION PhaseNodeT(PThrdGlbl pTG)
{

        MyDebugPrint (pTG, LOG_ALL, "T30: PhaseNodeT \n" );

        /******** Transmitter Phase B. Fig A-7/T.30 (sheet 1) ********/
        // NodeT:

        // Have to redo this "DIS bit" everytime through PhaseB
        pTG->T30.fReceivedDIS = FALSE;
        // also the Received EOM stuff
        pTG->T30.fReceivedEOM = FALSE;
        // and teh received-DTC stuff
        pTG->T30.fReceivedDTC = FALSE;


        // INI file settings related stuff
        if(pTG->ProtParams.SendT1Timer)
                TstartTimeOut(pTG, &pTG->T30.toT1, pTG->ProtParams.SendT1Timer);
        else
                TstartTimeOut(pTG, &pTG->T30.toT1, T1_TIMEOUT);
        do
        {
                if(pTG->Params.lpfnWhatNext(pTG, eventNODE_T) == actionERROR)
                        break;

                // no need for echo protection. We havnt transmitted anything!
                switch(pTG->T30.ifrCommand=GetCommand(pTG, ifrPHASEBcommand))
                {
                  // ifrTIMEOUT means no flags before T2
                  // ifrNULL means timeout, or loss of carrier, or no flags
                  // or no frame. ifrBAD means *only* bad frames recvd.
                  case ifrBAD:          SendCRP(pTG); // and fall thru to NULL/TIMEOUT
                  case ifrTIMEOUT:
                  case ifrNULL:         break;

                  case ifrDIS:  // INI file settings related stuff
                                                if(pTG->ProtParams.IgnoreDIS && ((int)pTG->T30.uSkippedDIS < pTG->ProtParams.IgnoreDIS))
                                                {
                                                        (MyDebugPrint(pTG,  LOG_ERR,  "<<WARNING>> Ignoring First DIS\r\n"));
                                                        pTG->T30.uSkippedDIS++;
                                                        break;  // continue with T1 loop
                                                }
                  case ifrDTC:
                  // case ifrNSF:
                  // case ifrNSC:
                                        return actionGONODE_A;  // got a valid frame

                  default:      (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Caller T1: Got random ifr=%d\r\n", pTG->T30.ifrCommand));
                                        break;  // continue with T1 loop
                }
        }
        while(TcheckTimeOut(pTG, &pTG->T30.toT1));

        (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>>  T1 timeout at Caller\r\n"));
        ICommFailureCode(pTG, T30FAILS_T1);
        return actionHANGUP;
}












ET30ACTION PhaseNodeD(PThrdGlbl pTG, BOOL fEnteredHere)
{
        LPLPFR          lplpfr;
        USHORT          N;
        ET30ACTION      action;
        USHORT          uWhichDCS;      // 0=first, 1=after NoReply 2=afterFTT
        DWORD           TiffConvertThreadId;


        /******** Transmitter Phase B2. Fig A-7/T.30 (sheet 1) ********/

        MyDebugPrint (pTG, LOG_ALL, "T30: PhaseNodeD \n" );

        if (pTG->Inst.SendParams.Fax.Encoding == MR_DATA) {
            pTG->TiffConvertThreadParams.tiffCompression = TIFF_COMPRESSION_MR;
        }
        else {
            pTG->TiffConvertThreadParams.tiffCompression = TIFF_COMPRESSION_MH;
        }


        if (pTG->Inst.SendParams.Fax.AwRes & ( AWRES_mm080_077 | AWRES_200_200 ) ) {
            pTG->TiffConvertThreadParams.HiRes = 1;
        }
        else {
            pTG->TiffConvertThreadParams.HiRes = 0;

            // use LoRes TIFF file prepared by FaxSvc

            // pTG->lpwFileName[ wcslen(pTG->lpwFileName) - 1] = (unsigned short) ('$');

        }

        _fmemcpy (pTG->TiffConvertThreadParams.lpszLineID, pTG->lpszPermanentLineID, 8);
        pTG->TiffConvertThreadParams.lpszLineID[8] = 0;


        uWhichDCS = 0;

NodeD:
        N = 0;
        lplpfr = 0;
        action = pTG->Params.lpfnWhatNext(pTG, eventSENDDCS,(WORD)uWhichDCS,
                                                (ULONG_PTR)((LPUWORD)&N),(ULONG_PTR)((LPLPLPFR)&lplpfr));
        switch(action)
        {
          case actionDCN:                       (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Got actionDCN from eventSENDDCS(uWhichDCS=%d)\r\n", uWhichDCS));
                                                                return actionDCN;
          case actionSENDDCSTCF:        break;
          case actionSKIPTCF:           break;  // Ricoh hook
          case actionERROR:                     return action;  // goto PhaseLoop & exit
          default:                                      return BadAction(pTG, action);
        }

NodeDprime:     // used only by TCF--no reply

        ICommStatus(pTG, T30STATS_TRAIN, ProtGetSendMod(pTG), (USHORT)(pTG->T30.uTrainCount+1), 0);
        SendManyFrames(pTG, lplpfr, N);

        if(action != actionSKIPTCF)             // Ricoh hook
        {
                if (!pTG->fTiffThreadCreated) {
                     (MyDebugPrint(pTG,  LOG_ALL, "Creating TIFF helper thread \r\n"));
                     pTG->hThread = CreateThread(
                                   NULL,
                                   0,
                                   (LPTHREAD_START_ROUTINE) TiffConvertThreadSafe,
                                   (LPVOID) pTG,
                                   0,
                                   &TiffConvertThreadId
                                   );

                     if (!pTG->hThread) {
                         (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> TiffConvertThread create FAILED\r\n"));
                         return actionDCN;
                     }

                     pTG->fTiffThreadCreated = 1;
                     pTG->AckTerminate = 0;
                     pTG->fOkToResetAbortReqEvent = 0;

                     if ( (pTG->RecoveryIndex >=0 ) && (pTG->RecoveryIndex < MAX_T30_CONNECT) ) {
                         T30Recovery[pTG->RecoveryIndex].TiffThreadId = TiffConvertThreadId;
                         T30Recovery[pTG->RecoveryIndex].CkSum = ComputeCheckSum(
                                                                         (LPDWORD) &T30Recovery[pTG->RecoveryIndex].fAvail,
                                                                         sizeof ( T30_RECOVERY_GLOB ) / sizeof (DWORD) - 1 );

                     }
                }


                (MyDebugPrint(pTG,  LOG_ALL, "SENDING TCF\r\n"));
                SendTCF(pTG);
                pTG->T30.uTrainCount++;
                (MyDebugPrint(pTG, LOG_ALL,  "TCF Send Done\r\n"));
        }

        // no need for echo protection? Wouldnt know what to do anyway!
        pTG->T30.ifrResp = GetResponse(pTG, ifrTCFresponse);

#ifdef RICOHAI
                if(fEnteredHere)
                {
                        if(pTG->T30.ifrResp != ifrCFR && pTG->T30.ifrResp != ifrFTT)
                        {
                                (MyDebugPrint(pTG,  LOG_ERR,  "<<WARNING>> Send-side AI protocol failed\r\n"));
                                fUsingOEMProt = 0;
                                return actionGONODE_T;
                        }
                }
#else
                BG_CHK(!fEnteredHere);
#endif


        switch(pTG->T30.ifrResp)
        {
          case ifrDCN:          (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Got ifrDCN in GetResponse after sending TCF\r\n"));
                                                ICommFailureCode(pTG, T30FAILS_TCF_DCN);
                                                return actionHANGUP;    // got DCN. Must hangup
          case ifrBAD:  // ifrBAD means *only* bad frames recvd. Treat like NULL
          case ifrNULL:                                 // timeout. May try again
                if(pTG->T30.uTrainCount >= 3)
                {
                        (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Got no reply after 3 TCFs\r\n"));
                        ICommFailureCode(pTG, T30FAILS_3TCFS_NOREPLY);
                        return actionDCN;
                }
                else
                {
                        uWhichDCS = 1;
                        // goto NodeD;                  // send new DCS??
                        goto NodeDprime;        // resend *same* DCS, same baudrate
                }

          case ifrDIS:
          case ifrDTC:
                if(pTG->T30.uTrainCount >= 3)
                {
                        (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Got DIS/DTC after 3 TCFs\r\n"));
                        ICommFailureCode(pTG, T30FAILS_3TCFS_DISDTC);
                        return actionDCN;
                }
                else
                {
                        pTG->T30.ifrCommand = pTG->T30.ifrResp;
                        return actionGONODE_A;
                }

          case ifrFTT:
                // reset training count on FTT since we drop speed. Want to try
                // 3 times _without_ a response (DIS DTC doesn't count) before
                // giving up
                pTG->T30.uTrainCount = 0;
                uWhichDCS = 2;
                goto NodeD;

          case ifrCFR:
                pTG->T30.uTrainCount = 0;
                switch(action = pTG->Params.lpfnWhatNext(pTG, eventGOTCFR))
                {
                  case actionGONODE_I:                  // Non-ECM PhaseC
                  case actionGONODE_IV:                 // ECM PhaseC, new page
                                                                                return action;
                  case actionGONODE_D:                  goto NodeD;                     // Ricoh hook
                  case actionERROR:                             return action;  // goto PhaseLoop & exit
                  default:                                              return BadAction(pTG, action);
                }
          default:
          {
                (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Unknown Reply to TCF\r\n"));
                ICommFailureCode(pTG, T30FAILS_TCF_UNKNOWN);
                return actionDCN;
          }
        }
        BG_CHK(FALSE);
}












ET30ACTION      NonECMPhaseC(PThrdGlbl pTG)
{
        /******** Transmitter Phase C. Fig A-7/T.30 (sheet 1) ********/

        LPBUFFER        lpbf=0;
        ULONG           lTotalLen=0;
        SWORD           swRet;
        USHORT          uMod, uEnc;

        (MyDebugPrint(pTG, LOG_ALL,  "T30: NonECMPhaseC Starting Page SEND.......\r\n"));

/***
        switch(action = pTG->Params.lpfnWhatNext(eventSTARTSEND))
        {
          case actionCONTINUE:  break;
          case actionDCN:
          case actionHANGUP:    return action;
          case actionERROR:             return action;  // goto PhaseLoop & exit
          default:                              return BadAction(action);
        }
***/

        // already done in WhatNext
        // ICommSetSendMode(FALSE, MY_BIGBUF_SIZE, MY_BIGBUF_ACTUALSIZE-4, FALSE);

        // Callback to open file to send. Returns no data

        (MyDebugPrint(pTG, LOG_ALL,  "Waiting for Startpage in T30 at 0x%08lx\r\n", GetTickCount()));
        DEBUGSTMT(IFProcProfile((HTASK)(-1), TRUE));

        if((swRet=GetSendBuf(pTG, 0, SEND_STARTPAGE)) != SEND_OK)
        {
                (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Nonzero return %d from SendProc at Start Page\r\n", swRet));
                // return actionDCN;
                return actionERROR;
        }

        DEBUGSTMT(IFProcProfile((HTASK)(-1), FALSE));
        (MyDebugPrint(pTG,  LOG_ALL, "Got Startpage in T30 at 0x%08lx\r\n", GetTickCount()));

        uEnc = ProtGetSendEncoding(pTG);
        BG_CHK(uEnc==MR_DATA || uEnc==MH_DATA);
        uMod = ProtGetSendMod(pTG);
        // in non-ECM mode, PhaseC is ALWAYS with short-train.
        // Only TCF uses long-train
        if(uMod >= V17_START) uMod |= ST_FLAG;

        //(MyDebugPrint(pTG,  "Calling SendMode in T30 at 0x%08lx\r\n", GetTickCount()));

        // **MUST** call RecvSilence here since it is recv-followed-by-send case
        // here we should use a small timeout (100ms?) and if it fails,
        // should go back to sending the previous V21 frame (which could be DCS
        // or MPS or whatever, which is why it gets complicated & we havn't
        // done it!). Meanwhile use a long timeout, ignore return value
        // and send anyway.
        if(!ModemRecvSilence(pTG, pTG->Params.hModem, RECV_PHASEC_PAUSE, LONG_RECVSILENCE_TIMEOUT))
        {
                (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Non-ECM PIX RecvSilence(%d, %d) FAILED!!!\r\n", RECV_PHASEC_PAUSE, LONG_RECVSILENCE_TIMEOUT));
        }

        if(!ModemSendMode(pTG, pTG->Params.hModem, uMod, FALSE, (IFR)((uEnc==MR_DATA) ? ifrPIX_MR : ifrPIX_MH)))
        {
                (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> ModemSendMode failed in Tx PhaseC\r\n"));
                ICommFailureCode(pTG, T30FAILS_SENDMODE_PHASEC);
                BG_CHK(FALSE);
                return actionERROR;
        }

        //(MyDebugPrint(pTG,  "Done SendMode in T30 at 0x%08lx\r\n", GetTickCount()));

        // need to send these quickly to avoid underrun (see bug842).
        // Also move the preamble/postamble into the ModemSendMode
        // and ModemSendMem(FINAL)
        // Already sent (in ModemSendMode)
        // SendZeros(PAGE_PREAMBLE, FALSE);      // Send some zeros to warm up....
        // (MyDebugPrint(pTG,  "SENT Preamble Training.....\r\n"));

        //  need to set line min zeros here. get from prot and call Modem
        SetStuffZERO(pTG, (ProtGetMinBytesPerLine(pTG)) );  // Enable ZERO stuffing

        // Start yielding *after* entering PhaseC and getting some stuff into the buffer
        FComCriticalNeg(pTG, FALSE);

        // DONT SEND an EOL here. See BUG#6441. We now make sure the EOL is
        // added by FAXCODEC. At this level we only append the RTC

#ifdef IFAX
        BroadcastMessage(pTG, IF_PSIFAX_DATAMODE, PSIFAX_SEND, (uMod & (~ST_FLAG)));
#endif
        (MyDebugPrint(pTG,  LOG_ALL, "SENDING Page Data.....at %ld \n", GetTickCount()));

        lTotalLen = 0;
        BG_CHK(lpbf == 0);
        while((swRet=GetSendBuf(pTG, &lpbf, SEND_SEQ)) == SEND_OK)
        {
                BG_CHK(lpbf);
                if(!lpbf->wLengthData)
                {
                        (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Got 0 bytes from GetSendBuf--freeing buf\r\n"));
                        MyFreeBuf(pTG, lpbf);
                        continue;
                }

                lTotalLen += lpbf->wLengthData;

                if(!FilterSendMem(pTG, pTG->Params.hModem, lpbf->lpbBegData, lpbf->wLengthData))
                {
                        (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> DataWrite Timeout in NON-ECM Phase C\r\n"));
                        ICommFailureCode(pTG, T30FAILS_MODEMSEND_PHASEC);
                        BG_CHK(FALSE);
                        return actionERROR;             // goto error;
                }

                // (MyDebugPrint(pTG,  "Freeing 0x%08lx in NON-ECM\r\n", lpbf));
                if(!MyFreeBuf(pTG, lpbf))
                {
                        (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> FReeBuf failed in NON-ECM Phase C\r\n"));
                        ICommFailureCode(pTG, T30FAILS_FREEBUF_PHASEC);
                        BG_CHK(FALSE);
                        return actionERROR;             // goto error;
                }
                lpbf = 0;
        }
        BG_CHK(!lpbf);

        if(swRet == SEND_ERROR)
        {
                (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Error in SendBuf\r\n"));
                // return actionDCN;
                return actionERROR;
        }
        BG_CHK(swRet == SEND_EOF);

        (MyDebugPrint(pTG,  LOG_ALL, "SENDING RTC.....at %ld \n", GetTickCount()));

        SetStuffZERO(pTG, 0);        // Disable ZERO stuffing BEFORE sending RTC!

        if(!SendRTC(pTG, FALSE))                     // RTC and final flag NOT set
        {
                (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Error in SendMem at end-PhaseC\r\n"));
                BG_CHK(FALSE);
                ICommFailureCode(pTG, T30FAILS_MODEMSEND_ENDPHASEC);
                return actionERROR;                     // error return from ModemSendMem
        }

        // Turn off yielding *before* the buffer completely drains
        FComCriticalNeg(pTG, TRUE);

#if (PAGE_POSTAMBLE_DIV != 0)
        BG_CHK(PAGE_POSTAMBLE_DIV);
        // Send zeros to cool off FINAL flag SET
        SendZeros(pTG, (USHORT)(TCFLen[uMod & 0x0F] / (PAGE_POSTAMBLE_DIV)), TRUE);
#else
        // Need this!! Need to send the SEND_EOF flag to modem driver
        SendZeros(pTG, 1, TRUE);             // sending 0 bytes is a bit unsafe....
#endif // (PAGE_POSTAMBLE_DIV != 0)


        // I think this can precede the SEND_FINAL code,
        // to be _very_ safe put it after the whole buffer has drained

        // need to set line min back to 0 here.
        //+++SetStuffZERO(0);   // Disable ZERO stuffing

        (MyDebugPrint(pTG, LOG_ALL,  "Page Send Done.....len=(%ld, 0x%08x)\r\n", lTotalLen, lTotalLen));
        pTG->T30.fSendAfterSend = TRUE;      // PhaseC/PIX--MPS/EOM/EOP
        return actionGONODE_II;
}













ET30ACTION NonECMPhaseD(PThrdGlbl pTG)
{
        USHORT          uTryCount;
        ET30ACTION      action;

        /******** Transmitter Phase D. Fig A-7/T.30 (sheet 2) ********/
        // NodeII:

        MyDebugPrint (pTG, LOG_ALL, "T30: NonECMPhaseD \n" );

        switch(action = pTG->Params.lpfnWhatNext(pTG, eventPOSTPAGE))
        {
                case actionSENDMPS:     pTG->T30.ifrSend = ifrMPS; break;
                case actionSENDEOM:     pTG->T30.ifrSend = ifrEOM; break;
                case actionSENDEOP:     pTG->T30.ifrSend = ifrEOP; break;
#ifdef PRI
                case actionSENDPRIMPS:  pTG->T30.ifrSend = ifrPRIMPS; break;
                case actionSENDPRIEOM:  pTG->T30.ifrSend = ifrPRIEOM; break;
                case actionSENDPRIEOP:  pTG->T30.ifrSend = ifrPRIEOP; break;
#endif
                case actionERROR:       return action;  // goto PhaseLoop & exit
            default:                    return BadAction(pTG, action);
        }

        for(uTryCount=0;;)
        {
                (MyDebugPrint(pTG, LOG_ALL,  "Sending postpage in T30 at %ld\r\n", GetTickCount()));

                // RSL dont sleep here
                SendSingleFrame(pTG, pTG->T30.ifrSend, 0, 0, 0);

        echoretry:
                pTG->T30.ifrResp = GetResponse(pTG, ifrPOSTPAGEresponse);
                // if we hear our own frame, try to recv again. DONT retransmit!
                if(pTG->T30.ifrResp==pTG->T30.ifrSend) { ECHOMSG(pTG->T30.ifrResp); goto echoretry; }

                (MyDebugPrint(pTG, LOG_ALL,   "Got postpage resp in T30 at %08ld\r\n", GetTickCount()));

                if(pTG->T30.ifrResp != ifrNULL && pTG->T30.ifrResp != ifrBAD)
                        break;

                if(++uTryCount >= 3)
                {
                        (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Got no reply after 3 post-page commands\r\n"));
                        ICommFailureCode(pTG, T30FAILS_3POSTPAGE_NOREPLY);
                        return actionDCN;
                }
        }

        switch(pTG->T30.ifrResp)
        {
          case ifrBAD:  // ifrBAD means *only* bad frames recvd. Treat like NULL
          case ifrNULL:         BG_CHK(FALSE);          // these should never get here
                                                ICommFailureCode(pTG, T30FAILS_BUG1);
                                                return actionERROR;             // in case they do

          case ifrDCN:          (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Got ifrDCN from GetResponse after sending post-page command\r\n"));
                                                ICommFailureCode(pTG, T30FAILS_POSTPAGE_DCN);
                                                return actionHANGUP;
          case ifrPIN:
          case ifrPIP:
#                                               ifdef PRI
                                                        goto NodeE;
#                                               else
                                                        (MyDebugPrint(pTG,  LOG_ERR,  "<<WARNING>> Procedure interrupts not supported\r\n"));
                                                        pTG->T30.ifrResp = pTG->T30.ifrResp - ifrPIP + ifrRTP;
                                                        // ICommFailureCode(T30FAILS_POSTPAGE_PIPPIN);
                                                        // return actionERROR;
                                                        // return actionDCN;
#                                               endif
          // default: // fallthrough    --- MCF, RTN, RTP
        }

        action = pTG->Params.lpfnWhatNext(pTG, eventGOTPOSTPAGERESP,
                                                        (WORD)pTG->T30.ifrResp, (DWORD)pTG->T30.ifrSend);

        if(pTG->T30.ifrSend==ifrEOP &&
                (pTG->T30.ifrResp==ifrMCF || pTG->T30.ifrResp==ifrRTP)
                        && action==actionDCN)
        {
                ICommFailureCode(pTG, T30FAILS_SUCCESS);
                return actionDCN_SUCCESS;
        }
        else
                return action;
}










ET30ACTION      RecvPhaseB(PThrdGlbl pTG, ET30ACTION action)
{
        LPLPFR          lplpfr;
        USHORT          N, i;
        
        /******** Receiver Phase B. Fig A-7/T.30 (sheet 1) ********/

        MyDebugPrint (pTG, LOG_ALL, "T30: RecvPhaseB \n" );

        if(action == actionGONODE_R1)
        {
                // NodeR1:
                // Have to redo this "DIS bit" everytime through PhaseB
                pTG->T30.fReceivedDIS = FALSE;       // set to FALSE when sending DIS
                // also the Received EOM stuff
                pTG->T30.fReceivedEOM = FALSE;
                // and teh received-DTC stuff
                pTG->T30.fReceivedDTC = FALSE;
                N = 0;
                lplpfr = 0;
                action = pTG->Params.lpfnWhatNext(pTG, eventSENDDIS,(WORD)0,
                                        (ULONG_PTR)((LPUWORD)&N),(ULONG_PTR)((LPLPLPFR)&lplpfr));
        }
        else
        {
                // NodeR2:
                BG_CHK(action == actionGONODE_R2);
                // fix the Received EOM stuff
                pTG->T30.fReceivedEOM = FALSE;
                N = 0;
                lplpfr = 0;
                action = pTG->Params.lpfnWhatNext(pTG, eventSENDDTC,(WORD)0,
                                        (ULONG_PTR)((LPUWORD)&N),(ULONG_PTR)((LPLPLPFR)&lplpfr));
        }

        switch(action)
        {
          case actionDCN:               (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Got actionDCN from eventSENDDIS or SENDDTC\r\n"));
                                                        return actionDCN;
          case actionSEND_DIS:
          case actionSEND_DTC:  break;
          case actionERROR:             return action;  // goto PhaseLoop & exit
          default:                              return BadAction(pTG, action);
        }

        // INI file settings related stuff
        if(pTG->ProtParams.RecvT1Timer)
                TstartTimeOut(pTG, &pTG->T30.toT1, pTG->ProtParams.RecvT1Timer);
        else
                TstartTimeOut(pTG, &pTG->T30.toT1, T1_TIMEOUT);
        do
        {
                ICommStatus(pTG, T30STATR_TRAIN, 0, 0, 0);

                if(pTG->Params.lpfnWhatNext(pTG, eventNODE_R) == actionERROR)
                        break;

                TIMESTAMP("Sending NSF-DIS")
                SendManyFrames(pTG, lplpfr, N);
/**
                for(i=0; i<N; i++)
                        SendFrame( lplpfr[i]->ifr, lplpfr[i]->fif, lplpfr[i]->cb, i==(N-1));
**/

                pTG->T30.uRecvTCFMod = 0xFFFF;

echoretry:
                TIMESTAMP("Getting Response")



                pTG->T30.ifrCommand=GetResponse(pTG, ifrPHASEBresponse);
                // if we hear our own frame, try to recv again. DONT retransmit!
                for(i=0; i<N; i++)
                {
                        if(pTG->T30.ifrCommand == lplpfr[i]->ifr)
                        {
                                ECHOMSG(pTG->T30.ifrCommand);
                                goto echoretry;
                        }
                }

                switch(pTG->T30.ifrCommand)
                {
                  case ifrNSS:  // do same as for DCS
                  case ifrDCS:  return PhaseGetTCF(pTG, pTG->T30.ifrCommand, FALSE);
                  case ifrBAD:  // ifrBAD means *only* bad frames recvd. Treat like NULL
                  case ifrNULL: break;          // out of the switch() and continue with loop
                  case ifrDCN:
                                                (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Got DCN after DIS or DTC\r\n"));
                                                ICommFailureCode(pTG, T30FAILR_PHASEB_DCN);
                                                return actionHANGUP;    //bugfix #478
                  default:              return actionGONODE_RECVCMD;
                }
        }
        while(TcheckTimeOut(pTG, &(pTG->T30.toT1)));

        (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> T1 timeout on Receiver\r\n"));
        ICommFailureCode(pTG, T30FAILR_T1);
        return actionDCN;
}


















ET30ACTION      PhaseNodeF(PThrdGlbl pTG, BOOL fEopMcf, BOOL fEnteredHere)
{
        USHORT  uFLoopCount;


        MyDebugPrint (pTG, LOG_ALL, "T30: PhaseNodeF \n" );


// NodeF:
        uFLoopCount = 0;
NodeFprime:
        for(;;)
        {
                pTG->T30.uRecvTCFMod = 0xFFFF;

        echoretry:
                pTG->T30.ifrCommand = GetCommand(pTG, (USHORT)(pTG->EchoProtect.fGotWrongMode ? ifrNODEFafterWRONGMODE : ifrNODEFcommand));

                // reset the fGotWrongMode flag
                pTG->EchoProtect.fGotWrongMode = 0;

                // if we hear the last frame we sent, try to recv again. DONT retx!
                // bug--might have matched ifrNULL...
                // added: if ModemRecvMode() returns EOF then also retry. RecvMode
                // returns RECV_EOF only if we pass it the ifrNODEFafterWRONGMODE hint
                // and it senses silence (i.e. we saw a V21 echo but missed it). In
                // this case we want to retry the high speed PIX recv
                if(pTG->EchoProtect.ifrLastSent && (pTG->T30.ifrCommand==pTG->EchoProtect.ifrLastSent || pTG->T30.ifrCommand==ifrEOFfromRECVMODE))
                {
                        ECHOMSG(pTG->T30.ifrCommand);
                        switch(pTG->EchoProtect.modePrevRecv)
                        {
                        default:
                        case modeNONE:   goto echoretry;
                        case modeNONECM: return actionGONODE_RECVPHASEC;
                        case modeECM:    return actionGONODE_RECVPHASEC;
                        case modeECMRETX:return actionGONODE_RECVECMRETRANSMIT;
                        }
                }

                // as soon as we get anything else ZERO the pTG->EchoProtect state
                _fmemset(&pTG->EchoProtect, 0, sizeof(pTG->EchoProtect));

                // reset this flag if we fail completely to train after a CTC. We may
                // get an echo of our last command, go to NodeF, reject the echo and
                // loop back to ECMRecvPhaseC. AT that point we need this flag STILL
                // set so we try to recv LONG train. HOWEVER should the ECMRecvPhaseC
                // fail for some OTHER reason than echo, this flag need to be reset
                // here or it may stay alive confusing something much later.
                pTG->ECM.fRecvdCTC = FALSE;

#ifdef RICOHAI
                if(fEnteredHere)
                {
                        if(pTG->T30.ifrCommand!=ifrNSS)
                        {
                                (MyDebugPrint(pTG,  LOG_ERR,  "<<WARNING>> Recv-side AI protocol failed\r\n"));
                                fUsingOEMProt = 0;
                                return actionGONODE_R1;
                        }
                }
#else
                BG_CHK(!fEnteredHere);
#endif

                switch(pTG->T30.ifrCommand)
                {
                  // ifrNULL means T2 timeout, or loss of carrier, or no flags
                  // or no frame. ifrBAD means *only* bad frame(s) recvd.

                  case ifrNSS:          // do same as for DCS
                  case ifrDCS:          return PhaseGetTCF(pTG, pTG->T30.ifrCommand, fEnteredHere);
                                                        // ifrDCS is highly time-critical!!


                  case ifrBAD:          SendCRP(pTG);      // and fall thru to ifrNULL
                  case ifrNULL:         break;          // Loop again, until timeout

                  case ifrTIMEOUT:      goto T2Timeout;
                                                        // ifrTIMEOUT means T2 timed out without flags...

                  case ifrDCN:          if(fEopMcf)
                                                        {
                                                                ICommFailureCode(pTG, T30FAILR_SUCCESS);
                                                                return actionHANGUP_SUCCESS;
                                                        }
                                                        else
                                                        {
                                                                (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> DCN following UNKNOWN on Receiver\r\n"));
                                                                ICommFailureCode(pTG, T30FAILR_UNKNOWN_DCN1);
                                                                return actionHANGUP;
                                                        }

                  default:                      return actionGONODE_RECVCMD;
                }
        }

T2Timeout:
        (MyDebugPrint(pTG,  LOG_ERR,  "<<WARNING>> T2 timed out\r\n"));

        // restart PhaseB after T2 timeout IFF (a) EOM or PPS-EOM was recvd
        // AND (b) If we are in ECM mode, the last response sent was n MCF
        // This avoids us doing this after sending a CTR, RNR or PPR
        // Ricoh's protocol conformance tester doesnt like this. This is
        // Ricoh's bug numbbers B3-0142, 0143, 0144
        if(pTG->T30.fReceivedEOM && (ProtReceivingECM(pTG) ? (pTG->ECM.ifrPrevResponse==ifrMCF) : TRUE) )
                return actionGONODE_R1;

        else if(ProtReceivingECM(pTG) && ++uFLoopCount<3)
                goto NodeFprime;

#ifdef PRI
        else // no EOM && (no ECM || 3 times)
        {
                if((pTG->Params.lpfnWhatNext(pTG, eventQUERYLOCALINT))==actionTRUE)
                        goto NodeF;
        }
#endif

        (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Got T2 timeout in GetCommand\r\n"));
        ICommFailureCode(pTG, T30FAILR_T2);
        return actionHANGUP;
}
















ET30ACTION PhaseRecvCmd(PThrdGlbl pTG)
{
        ET30ACTION action;

        MyDebugPrint (pTG, LOG_ALL, "T30: PhaseRecvCmd \n" );

        if(pTG->T30.ifrCommand == ifrDCN)
        {
                (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Got DCN in GetCommand\r\n"));
                ICommFailureCode(pTG, T30FAILR_UNKNOWN_DCN2);
                return actionHANGUP;
        }

        if( pTG->T30.ifrCommand==ifrDTC || pTG->T30.ifrCommand==ifrDCS ||
                pTG->T30.ifrCommand==ifrDIS || pTG->T30.ifrCommand==ifrNSS)
        {
                switch(action = pTG->Params.lpfnWhatNext(pTG, eventRECVCMD, (WORD)pTG->T30.ifrCommand))
                {
                  case actionGETTCF:    (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> MainBody: Wrong Way to GETTCF\r\n"));
                                                                ICommFailureCode(pTG, T30FAILR_BUG2);
                                                                BG_CHK(FALSE);
                                                                return actionERROR;
                  case actionGONODE_A:  return actionGONODE_A;
                  case actionGONODE_D:  return action;
                  case actionHANGUP:    (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Got actionHANGUP from eventRECVCMD\r\n"));
                                                                return action;
                  case actionERROR:             return action;  // goto PhaseLoop & exit
                  default:                              return BadAction(pTG, action);
                }
        }


        if( pTG->T30.ifrCommand == ifrEOM     || pTG->T30.ifrCommand == ifrPRI_EOM         ||
                pTG->T30.ifrCommand == ifrPPS_EOM || pTG->T30.ifrCommand == ifrPPS_PRI_EOM ||
                pTG->T30.ifrCommand == ifrEOR_EOM || pTG->T30.ifrCommand == ifrEOR_PRI_EOM)
                        pTG->T30.fReceivedEOM = TRUE;

        if(ProtReceivingECM(pTG))
                return actionGONODE_VII;

        else if(pTG->T30.ifrCommand >= ifrPRI_FIRST && pTG->T30.ifrCommand <= ifrPRI_LAST)
        {
#ifdef PRI
                return actionGONODE_RECVPRIQ;
#else
                pTG->T30.ifrCommand = pTG->T30.ifrCommand-ifrPRI_MPS+ifrMPS;
                // fall thru to GONODEIII
#endif
        }

        if(pTG->T30.ifrCommand >= ifrMPS && pTG->T30.ifrCommand <= ifrEOP)
                return actionGONODE_III;
        else
        {
                (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Got UNKNOWN in GetCommand\r\n"));
                ICommFailureCode(pTG, T30FAILR_UNKNOWN_UNKNOWN2);
                return actionHANGUP;
        }

/***
        else if(pTG->T30.ifrCommand >= ifrMPS && pTG->T30.ifrCommand <= ifrEOP)
                return actionGONODE_III;

        else if(pTG->T30.ifrCommand >= ifrECM_FIRST && ProtReceivingECM())
                return actionGONODE_VII;

#ifdef PRI
        else if(pTG->T30.ifrCommand >= ifrPRI_FIRST && pTG->T30.ifrCommand <= ifrPRI_LAST)
                return actionGONODE_RECVPRIQ;
#endif
***/
}















ET30ACTION PhaseGetTCF(PThrdGlbl pTG, IFR ifr, BOOL fEnteredHere)
{
        SWORD   swRet;
        IFR             ifrDummy;
        ET30ACTION action;


        MyDebugPrint (pTG, LOG_ALL, "T30: PhaseGetTCF \n" );


        if(pTG->T30.uRecvTCFMod == 0xFFFF)           // uninitialised
        {
                ECHOPROTECT(0, 0);
                CLEAR_MISSED_TCFS();
                action = actionGONODE_F;
                goto error;
        }
#ifdef OEMNSF
        else if(pTG->T30.uRecvTCFMod == 0xFF)
        {
                swRet = 0;
                goto sendcfr;
        }
#endif

        swRet = GetTCF(pTG);       // swRet = errs per 1000, +ve or 0 if we think its good
                                                // -ve if we think its bad. -1111 if other error
                                                // -1000 if too short

        if(swRet < -1000)
        {
                BG_CHK(swRet == -1112 || swRet == -1113);
                (MyDebugPrint(pTG,  LOG_ERR,  "<<WARNING>> Timed out/missed getting TCF\r\n"));
                ECHOPROTECT(0, 0);

#ifndef MDDI

                pTG->T30.uMissedTCFs++;
                if (pTG->T30.uMissedTCFs >= MAX_MISSED_TCFS_BEFORE_FTT)
                {
                        (MyDebugPrint(pTG,  LOG_ERR,  "<<WARNING>> Sending FTT after %u missed TCFs\r\n",
                                                                (unsigned) pTG->T30.uMissedTCFs));
                        CLEAR_MISSED_TCFS();
                        swRet = -1000; // We pretend we got a too-short TCF.
                }
                else
#endif  // !MDDI
                {
                        action = actionGONODE_F;
                        goto error;
                }
        }

#ifdef OEMNSF
sendcfr:
#endif

        // Here we can also signal the frames received before DCS!
        // Were no longer in time-critical mode, so call all the
        // callbacks we skipped. One for recording the received frames
        // and one for handling teh received command, i.e. DCS.
        // (the only options the protocol has is actionGETTCF or HANGUP)

        ifrDummy = ifr;
        action = pTG->Params.lpfnWhatNext(pTG, eventGOTFRAMES, pTG->T30.Nframes,
                                (ULONG_PTR)((LPLPFR)(pTG->T30.lpfs->rglpfr)), (ULONG_PTR)((LPIFR)(&ifrDummy)));
        if(action == actionERROR)
                goto error;

        if(ifr != ifrDummy)
        {
                switch(ifrDummy)
                {
                case ifrNULL:
                case ifrBAD:
                        (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Got ifrBAD from whatnext after recv TCF\r\n"));
                        ECHOPROTECT(0, 0);
                        CLEAR_MISSED_TCFS();
                        action = actionGONODE_F;
                        goto error;
                default:
                        BG_CHK(FALSE);
                        break;
                }
        }

        // BG_CHK(action == actionNULL);
        // BG_CHK(ifrDummy == ifr);


        // Now call teh callback to check the received TCF and
        // return either FTT or CFR

        switch(action = pTG->Params.lpfnWhatNext(pTG, eventGOTTCF,(WORD)swRet))
        {
          case actionSENDCFR:
                        (MyDebugPrint(pTG, LOG_ALL,   "Good TCF\r\n"));
                        EnterPageCrit();                // start the CFR--PAGE critsection
                        SendCFR(pTG);              // after sending CFR we are again in a race
                        ECHOPROTECT(ifrCFR, 0); // dunno recv mode yet
                        return actionGONODE_RECVPHASEC;
          case actionSENDFTT:
                        (MyDebugPrint(pTG,  LOG_ERR,  "<<WARNING>> Bad TCF.....!!!\r\n"));
                        SendFTT(pTG);
                        ECHOPROTECT(ifrFTT, 0);
                        CLEAR_MISSED_TCFS();
                        return actionGONODE_F;
          case actionERROR:
                        goto error;
          default:
                        action = BadAction(pTG, action);
                        goto error;
        }

error:
        // missed TCF or no NSS. Did _not_ reply to TCF
        // if we sent a reply, must _not_ come here

#ifdef RICOHAI
        if(fEnteredHere)
                return actionGONODE_R1;
#else
        BG_CHK(!fEnteredHere);
#endif

        return action;
}














ET30ACTION      NonECMRecvPhaseC(PThrdGlbl pTG)
{
        /******** Receiver Phase C. Fig A-7/T.30 (sheet 1) ********/

        LPBUFFER        lpbf;
        ULONG           lTotalLen=0;
        USHORT          uRet, uMod, uEnc;
        DWORD           tiffCompression;
        LPSTR           lpsTemp;
        DWORD           HiRes;

        // There is a race between sending the CFR and sending out an
        // +FRM=xx command, so we want to do it ASAP.


        MyDebugPrint (pTG, LOG_ALL, "T30: NonECMRecvPhaseC \n" );

        uEnc = ProtGetRecvEncoding(pTG);
        BG_CHK(uEnc==MR_DATA || uEnc==MH_DATA);

        if (uEnc == MR_DATA) {
            tiffCompression =  TIFF_COMPRESSION_MR;
        }
        else {
            tiffCompression =  TIFF_COMPRESSION_MH;
        }

        if (pTG->ProtInst.RecvParams.Fax.AwRes & (AWRES_mm080_077 |  AWRES_200_200) ) {
            HiRes = 1;
        }
        else {
            HiRes = 0;
        }



        //
        // do it once per RX
        //

        if ( !pTG->fTiffOpenOrCreated) {
            //
            // top 32bits of 64bit handle are guaranteed to be zero
            //
            pTG->Inst.hfile =  PtrToUlong(TiffCreateW ( pTG->lpwFileName,
                                                         tiffCompression,
                                                         1728,
                                                         FILLORDER_LSB2MSB,
                                                         HiRes
                                                         ) );

            if (! (pTG->Inst.hfile)) {

                lpsTemp = UnicodeStringToAnsiString(pTG->lpwFileName);
                MyDebugPrint(pTG, LOG_ERR, "ERROR:Can't create tiff file %s compr=%d \n",
                                           lpsTemp,
                                           tiffCompression);

                MemFree(lpsTemp);

                return actionERROR;
            }

            pTG->fTiffOpenOrCreated = 1;

            lpsTemp = UnicodeStringToAnsiString(pTG->lpwFileName);

            MyDebugPrint(pTG, LOG_ALL, "Created tiff file %s compr=%d HiRes=%d \n",
                                       lpsTemp,  tiffCompression, HiRes);

            MemFree(lpsTemp);
        }



        uMod = ProtGetRecvMod(pTG);
        // in non-ECM mode, PhaseC is ALWAYS with short-train.
        // Only TCF uses long-train
        if(uMod >= V17_START) uMod |= ST_FLAG;

        pTG->T30.sRecvBufSize = MY_BIGBUF_SIZE;
        if((uRet = ModemRecvMode(pTG, pTG->Params.hModem, uMod, FALSE, PHASEC_TIMEOUT,
                                        (IFR)((uEnc==MR_DATA) ? ifrPIX_MR : ifrPIX_MH))) != RECV_OK)
        {
                ExitPageCrit();

                // reset Page ack. In case we miss page completely
                ProtResetRecvPageAck(pTG);

                (MyDebugPrint(pTG,  LOG_ERR,  "<<WARNING>> NonECMPhC: RecvMode returned %d\r\n", uRet));

                pTG->EchoProtect.modePrevRecv = modeNONECM;
                // set global flag if we got WRONGMODE
                pTG->EchoProtect.fGotWrongMode = (uRet==RECV_WRONGMODE);

                // elim flush--does no good & wastes 10ms
                // ModemFlush(pTG->Params.hModem);
                CLEAR_MISSED_TCFS();
                return actionGONODE_F;
                // try to get 300bps command
                // return actionHANGUP;
                // goto error instead. No way to recover from here!
        }
        ExitPageCrit();

        // as soon as we get good carrier ZERO the EchoProtect state
        _fmemset(&pTG->EchoProtect, 0, sizeof(pTG->EchoProtect));

#ifdef IFAX
        BroadcastMessage(pTG, IF_PSIFAX_DATAMODE, PSIFAX_RECV, (uMod & (~ST_FLAG)));
#endif
        (MyDebugPrint(pTG, LOG_ALL,  "RECEIVING Page.......\r\n"));

        // reset Page ack
        ProtResetRecvPageAck(pTG);

        // Turn yielding on *after* entering receive mode safely!
        FComCriticalNeg(pTG, FALSE);

/***
        switch(action = pTG->Params.lpfnWhatNext(eventSTARTRECV))
        {
          case actionCONTINUE:  break;
          case actionDCN:               (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Got actionDCN from eventSTARTRECV\r\n"));
                                                        return actionDCN;               // goto NodeC;
          case actionHANGUP:    (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Got actionHANGUP from eventSTARTRECV\r\n"));
                                                        return actionHANGUP;    // goto NodeB;
          case actionERROR:             return action;  // goto PhaseLoop & exit
          default:                              return BadAction(action);
        }
***/

/***
        BG_CHK((BOOL)Comm.dcb.fOutX == FALSE);
        // Paranoia! Dont want to take ^Q/^S from modem to
        // be XON/XOFF in the receive data phase!!
        FComInFilterInit();
***/

        // to mark start of Page
        if(!PutRecvBuf(pTG, NULL, RECV_STARTPAGE))
        {
                (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Zero return from PutRecvBuf(start page)\r\n"));
                return actionERROR;
        }


// make it large, in case of large buffers & slow modems
#define READ_TIMEOUT    25000

        lTotalLen = 0;
        do
        {
                uRet=ModemRecvBuf(pTG, pTG->Params.hModem, FALSE, &lpbf, READ_TIMEOUT);
                // lpbf==0 && uRet==RECV_OK just does nothing & loops back
                if (uRet == RECV_EOF) {
                    // indicate that this is actually last recv_seq (we've got dle/etx already).
                    (MyDebugPrint(pTG,  LOG_ALL,  "RECV: NonECMRecvPhaseC  fLastReadBlock = 1 \n"));
                    pTG->fLastReadBlock = 1;
                }


                if(lpbf)
                {
                        lTotalLen += lpbf->wLengthData;


                        if(!PutRecvBuf(pTG, lpbf, RECV_SEQ))
                        {
                                (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Zero return from PutRecvBuf in page\r\n"));
                                return actionERROR;
                        }
                        lpbf = 0;
                }
                else {
                    if ( pTG->fLastReadBlock == 1) {
                        PutRecvBuf(pTG, lpbf, RECV_FLUSH);
                    }
                }
        }
        while(uRet == RECV_OK);

        if(uRet == RECV_EOF)
        {
                FComCriticalNeg(pTG, TRUE);
                pTG->T30.fAtEndOfRecvPage = TRUE;
                // call this *after* getting MPS/EOM/EOP
                // PutRecvBuf(NULL, RECV_ENDPAGE);              // to mark end of Page
        }
        else
        {
                // Timeout from ModemRecvBuf
                (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> DataRead Timeout or Error=%d\r\n", uRet));
                // BG_CHK(FALSE);
                ICommFailureCode(pTG, T30FAILR_MODEMRECV_PHASEC);
                return actionERROR;     // goto error;
        }

        (MyDebugPrint(pTG, LOG_ALL,  "Page Recv Done.....len=(%ld, 0x%08x)\r\n", lTotalLen, lTotalLen));
        ECHOPROTECT(0, 0);
        CLEAR_MISSED_TCFS();
        return actionGONODE_F;  // goto NodeF;                  // get post-message command
}
















ET30ACTION NonECMRecvPhaseD(PThrdGlbl pTG)
{
        ET30ACTION      action;
        ET30ACTION      ret;

        MyDebugPrint (pTG, LOG_ALL, "T30: NonECMRecvPhaseD \n" );


        /******** Receiver Phase D. Fig A-7/T.30 (sheet 2) ********/
        // NodeIII:

/** Here the T30 flowchart is all BS. Fundamentally relying on
        a +FCERROR response is not possible, so what we do here really
        depends on what we've got. (According to the T30 flowchart we
        return to NodeF after sending MCF/RTP/RTN, in all cases. What we
        now know is that,

                after MPS/MCF goto RecvPhaseC to get the next page
                after EOM/MCF goto NodeR1 and send NSF etc all over again
                        ***changed*** go back to NodeF, wait for T2 timeout
                        before sending DIS all over again.
                after EOP/MCF goto NodeF, where GetResponse() will get
                                          a DCN and we end up in NodeB (disconnect)

                after xxx/RTN or xxx/RTP, I don't know what to do, but my guess
                                          (looking at the Sender side of T30 flowchart) is:-

                after MPS/RTx goto NodeF        (sender goes to NodeD)
                after EOP/RTx goto NodeF        (sender goes to D or C)
                after EOM/RTx goto NodeR1       (sender goes to NodeT)
                        ***changed*** go back to NodeF, wait for T2 timeout
                        before sending DIS all over again.

****/

        // only MPS/EOM/EOP commands come here

        if(pTG->T30.fAtEndOfRecvPage)                // so we won't call this twice
        {
                // This calls ET30ProtRecvPageAck so that WhatNext can choose
                // MCF or RTN respectively. So it *must* be done before the
                // call to WhatNext below

                // RECV_ENDDOC if EOP or EOM
                PutRecvBuf(pTG, NULL, ((pTG->T30.ifrCommand==ifrMPS) ? RECV_ENDPAGE : RECV_ENDDOC));
                // ignore error/abort. We'll catch it soon enough
                pTG->T30.fAtEndOfRecvPage = FALSE;
        }

        // returns MCF if page was OK, or RTN if it was bad
        ret=actionGONODE_F;
        ECHOPROTECT(0, 0);
        CLEAR_MISSED_TCFS();
        switch(action = pTG->Params.lpfnWhatNext(pTG, eventRECVPOSTPAGECMD,(WORD)pTG->T30.ifrCommand))
        {
          case actionSENDMCF: if(pTG->T30.ifrCommand==ifrMPS)
                                                  {
                                                        EnterPageCrit(); //start MPS--PAGE critsection
                                                        ECHOPROTECT(ifrMCF, modeNONECM);
                                                        ret=actionGONODE_RECVPHASEC;
                                                  }
                                                  else if(pTG->T30.ifrCommand==ifrEOP)
                                                  {
                                                        ECHOPROTECT(ifrMCF, 0);
                                                        CLEAR_MISSED_TCFS();
                                                        ret=actionNODEF_SUCCESS;
                                                  }
                                                  SendMCF(pTG);
                                                  break;

          case actionSENDRTN: ECHOPROTECT(ifrRTN, 0);
                                                  SendRTN(pTG);
                                                  break;

          case actionHANGUP:  (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Got actionHANGUP from eventRECVPOSTPAGECMD\r\n"));
                                                  ret=actionHANGUP;
                                                  break;
          // case actionSENDRTP: SendRTP(pTG); break;      // never send RTP
          case actionERROR:       ret=action; break;    // goto PhaseLoop & exit
          default:                        return BadAction(pTG, action);
        }
        return ret;
}















/***************************************************************************
 Name     :     IFR GetCmdResp(BOOL fCommand)
 Purpose  :     Implement the "Command Received" and "Response Received"
                        subroutines in the T.30 flowchart. The following macros are
                        defined:-

                        #define GetResponse()   GetCmdResp(FALSE)
                        #define GetCommand()    GetCmdResp(TRUE)

                        where the first form results in a faithful implem.
                        of the "Response Received" subroutine, the 2nd one
                        changes two things (i) the timeout for getting falgs goes from
                        T4 to T2, and (ii) if the routine times out on the very
                        first frame without getting flags (i.e. T2 times out)
                        it returns ifrTIMEOUT. This results in the "Command Recvd"
                        and the enclosing T2 loop being implemented in this
                        routine.

                        Upon receiving a set of frames, this routine assembles them
                        into the ET30FR structs pointed to by rglpfr, and if any
                        of them have a non-null FIF, or if >1 frame are received, it
                        calls (*Callbacks.Callbacks.lpWhatNext)().

                        Finally it returns the ifr of the last frame received, if
                        all frames were good, or ifrBAD if *all* frames were bad.

                        The algorithm it implements is very close to the "Response
                        Received" flowchart, minus the "Transmit DCN" box & below.
                        It returns ifrNULL or ifrBAD corresponding to return via
                        Node 2, (i.e. ifrNULL for timeout and other errors), ifrBAD
                        for bad frames, *iff* it can resync and get 200ms of silence
                        following these. ifrERROR for Node 1 (i.e. any error or timeout
                        after which we cannot resync or get silence for 200ms),
                        and ifrDCN for Node 3 (i.e. DCN was received).
                        <<<Node1 (ifrERROR is bad, so we dont use it. On error
                        we immediately return BAD or NULL or TIMEOUT and allow retry>>>
                        The "Optional Response" box is replaced by a "Not final frame".
                        A "start T4" box is assumed at "Enter" and a "Reset T4" box
                        is assumed after "process optional response"

                        It also modifies the flowchart in that *all* the frames are got
                        until a final frame, even if an FCS error frame is recvd. This
                        is partly because after an erroneous frame we have absolutely
                        no idea how long to wait until we either get silence or timeout
                        and hangup. ALso it may be more robust. The main routine
                        throws away the entire set of frames if one is bad.

                        The     callback function is called before any return and it gets
                        a pointer to the desired return vakue, so it can modify this.


 Arguments:     whether it is called as "Command Received" or as
                        "Response Received"

 Returns  :     ifrNULL -- timeout
                        ifrTIMEOUT -- T2 timed out before first flag
                                                  (returns this if and only if fCommand==TRUE)
                        ifrBAD  -- all frames received were bad
                        ifrDCN -- DCN was received. The only valid action is "goto NodeB"
                        ifrXXXX -- last received frame
 Calls    :
 Called By:     GetResponse() GetCommand1() and GetCommand2() macros (ONLY!)
                        These are called only from ET30MainBody.
 Comment  :     Watch out for timeouts > 65535 (max UWORD)

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
 06/15/92 arulm Created for first time (completely from scratch)
***************************************************************************/


IFR GetCmdResp(PThrdGlbl pTG, BOOL fCommand, USHORT ifrHint)
{
        /*** we need to try for T4 to get a frame here. The way Class1 modems
                 works, as long as no flags are received, the AT+FRH=3 command will
                 time out and return ERROR. CONNECT is returned as soon as flags
                 are received. Some modems return <CR><LF>OK<CR><LF><CR><LF>CONNECT
                 which is still taken care of by out new ModemDialog which throws
                 away blank lines and looks for the expected answer i.e. "CONNECT"
                 in this case, in multi-line responses.
        ***/

        BYTE                    bRecv[MAXFRAMESIZE];
        BOOL                    fFinal, fNoFlags, fGotFIF, fGotBad;
        IFR                             ifr, ifrLastGood;
        USHORT                  uRet, uRecv, j;
        ET30ACTION              action;
        LPLPFR                  lplpfr;
        LPFR                    lpfrNext;
        BOOL                    fResync=0;
        ULONG                   ulTimeout;
        BOOL                    fGotEofFromRecvMode=0;

        // need to init these first
        pTG->T30.Nframes=0, fFinal=FALSE, fNoFlags=TRUE, fGotFIF=FALSE, fGotBad=FALSE;
        ifrLastGood=ifrNULL;

        // figure out the timeout
        if(fCommand)
                ulTimeout = T2_TIMEOUT;
        else
                ulTimeout = T4_TIMEOUT;
        // if we're sending DCS-TCF and waiting for CFR, we increase the timeout each time
        // we fail, to avoid getting an infinite collision. This fixes bug#6847
        if(ifrHint==ifrTCFresponse && pTG->T30.uTrainCount>1)
        {
                ulTimeout += TCFRESPONSE_TIMEOUT_SLACK;
                (MyDebugPrint(pTG, LOG_ALL,  "Get TCF response: traincount=%d timeout=%ld\r\n", pTG->T30.uTrainCount, ulTimeout));
        }

        lplpfr = pTG->T30.lpfs->rglpfr;
        lpfrNext = (LPFR)(pTG->T30.lpfs->b);

        pTG->T30.sRecvBufSize = 0;
        uRet = ModemRecvMode(pTG, pTG->Params.hModem, V21_300, TRUE, ulTimeout, ifrHint);
        if(uRet == RECV_TIMEOUT || uRet == RECV_ERROR)
        {
                (MyDebugPrint(pTG,  LOG_ERR,  "<<WARNING>> RecvMode failed=%d\r\n", uRet));
                fResync = TRUE;
                goto error;
        }
        else if(uRet == RECV_WRONGMODE)
        {
                // BG_CHK(FALSE);       // just so we know who gives it!!
                (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Got FCERROR from FRH=3\r\n"));
                // treat like timeout
                // fReSync = FALSE;     // no need to resync
                goto error;
        }
        else if(uRet == RECV_EOF)
        {
                // ModemRecvMode() returns EOF then return ifrEOF immediately. RecvMode
                // returns RECV_EOF only if we pass it the ifrNODEFafterWRONGMODE hint
                // and it senses silence (i.e. we saw a V21 echo but missed it). In
                // this case we want to retry the high speed PIX recv again immediately
                (MyDebugPrint(pTG,  LOG_ERR,  "WARNING: ECHO--Got EOF from V21 RecvMode\r\n"));
                fGotEofFromRecvMode=TRUE;
                goto error;
        }
        BG_CHK(uRet == RECV_OK);

        for( ;!fFinal; )
        {
                if((((LPB)lpfrNext+sizeof(FR)+30-(LPB)pTG->T30.lpfs) > TOTALRECVDFRAMESPACE)
                        || (pTG->T30.Nframes >= MAXRECVFRAMES))
                {
                        (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Out of space for received frames. Haaalp!!\r\n"));
                        pTG->T30.Nframes = 0;
                        // fGotBad = TRUE;      // fGotBad = FALSE;
                        lplpfr = pTG->T30.lpfs->rglpfr;
                        lpfrNext = (LPFR)(pTG->T30.lpfs->b);
                        // BG_CHK(FALSE);
                        // fall through
                }

                uRet = ModemRecvMem(pTG, pTG->Params.hModem, bRecv, MAXFRAMESIZE, ulTimeout, &uRecv);

                if(uRet == RECV_TIMEOUT)
                {
                        fResync = TRUE;
                        goto error;                             // timeout in FRH=3
                }

                fNoFlags = FALSE;

                if(uRet == RECV_EOF)
                {
                        (MyDebugPrint(pTG,  LOG_ERR,  "<<WARNING>> Got NO CARRIER, but no final bit\r\n"));
                        BG_CHK(uRecv == 0);
                        goto error;             // ignore good frames if we got any, because we
                                                        // must've missed the last (most important) one

                        // fFinal = TRUE;       // pretend we got fFinal
                        // continue;
                }
                else if(uRet == RECV_ERROR)
                {
                        fResync = TRUE;
                        goto error;                             // error in FRH=3
                }

                /** Sometimes modems give use ERROR even when teh frame is good.
                        Happens a lot from Though to PP144MT on CFR. So we ignore the
                        BADFRAME response, and check the recvd data for ourselves.
                        First stage--check the FF-03/13-FCF. If this is OK (i.e. got
                        a known FCF) and no FIF reqd and data length is correct
                        then accept it. But if the frame requires an FIF and we
                        got a BADFRAME response then don't accept it even if it
                        looks good--too dangerous.
                        2nd-stage(NYI)--keep a table of CRCs for each fixed frame & check
                        them ourselves.
                **/

#ifdef MDDI     // badframe handling
                else if(uRet == RECV_BADFRAME)
                        goto badframe;
                BG_CHK(uRet==RECV_OK);
#else
                BG_CHK(uRet == RECV_OK || uRet==RECV_BADFRAME);
#endif

                // faxT2log(("FRAME>>> \r\n"));
                // ST_FRAMES(D_HexPrint(bRecv, uRecv));

                /*** Got Valid OK Frame. Now analyse it. In general here we
                         want to be pretty lax in recognizing frames. Oftentimes
                         we have mucho garbage thrown in.
                         <CHANGE> Actually we're checking strictly now....

                         If we get a bad frame, we mark this in the lpfrfr[] array
                         and go on to try and get another frame.
                         <CHANGE> We've stopped saving bad frames
                ***/

                // AT&T modem gives us frames w/o CRC, so we get just 1 byte here!!
                // <CHNAGE> fixed that at driver level, so we always get 3 bytes here
                // IFF it is a valid frame
                if(uRecv < 3)
                        goto badframe;

                if(bRecv[0] != 0xFF)
                        goto badframe;

                if(bRecv[1] == 0x03)
                        fFinal = FALSE;
                else if(bRecv[1] == 0x13)
                {
                        fFinal = TRUE;
#ifdef CL0
                        // tell modem that recv is done
                        // but keep calling RecvMem until we get RECV_EOF
                        ModemEndRecv(pTG, pTG->Params.hModem);
#endif //CL0
                }
                else
                        goto badframe;

                for(ifr=1; ifr<ifrMAX; ifr++)
                {
                        if(rgFrameInfo[ifr].fInsertDISBit)
                        {
                                // Mask off the DIS bit
                                if(rgFrameInfo[ifr].bFCF1 != (BYTE)(bRecv[2] & 0xFE))
                                        continue;
                        }
                        else
                        {
                                if(rgFrameInfo[ifr].bFCF1 != bRecv[2])
                                        continue;
                        }

                        j=3;
                        if(rgFrameInfo[ifr].bFCF2)
                        {
                                // AT&T modem gives us frames w/o CRC, so we get just 1 byte frames!!
                                if(uRecv < 4)
                                        goto badframe;

                                if((BYTE)(rgFrameInfo[ifr].bFCF2-1) != bRecv[3])
                                        continue;
                                j++;
                        }
                        BG_CHK(j <= uRecv);
                        if(rgFrameInfo[ifr].wFIFLength == 0xFF) // var length FIF
                        {
                                // Var length frames
                                // Cant accept it if the modem thought they it was bad
                                // accept it IFF RECV_OK & FIFlen>0
                                if(uRet==RECV_OK && (j < uRecv))
                                        fGotFIF = TRUE;
                                else
                                {
                                        (MyDebugPrint(pTG,  LOG_ERR, "Discarding Bad Frame: uRet=%d FIFlen=%d Reqd=Var\r\n", uRet, (uRecv-j)));
                                        goto badframe;
                                }
                        }
                        else if(rgFrameInfo[ifr].wFIFLength) // fixed length FIF
                        {
                                // if frame length is exactly right then accept it
                                // else if modem said frame was ok and length is
                                // longer than expected then accept it too
                                if((j+rgFrameInfo[ifr].wFIFLength) == uRecv)
                                        fGotFIF = TRUE;
                                else if(uRet==RECV_OK && (j+rgFrameInfo[ifr].wFIFLength < uRecv))
                                        fGotFIF = TRUE;
                                else
                                {
                                        (MyDebugPrint(pTG,  LOG_ERR, "Discarding Bad Frame: uRet=%d FIFlen=%d Reqd=%d\r\n", uRet, (uRecv-j), rgFrameInfo[ifr].wFIFLength));
                                        goto badframe;
                                }
                        }
                        else    // no FIF reqd
                        {
                                if(j != uRecv)
                                {
                                        (MyDebugPrint(pTG, LOG_ALL,  "Weird frame(2)\r\n"));
                                        BG_CHK(j < uRecv);

                                        // see the BADFRAME comment block above on why we do this
                                        if(uRet != RECV_OK)
                                                goto badframe;

                                        // accept it even if wrong length *iff* uRet==RECV_OK
                                        // goto badframe;

                                        // **additional** reason to do this that 2 bytes of extra
                                        // CRC may be present. This happens because of the AT&T and
                                        // NEC modems that doen't give CRC, so we do no CRC lopping-off
                                        // in the modem driver. So accept it anyway here.
                                }
                        }

                        goto goodframe;
                }

                // fall through here when ifr == ifrMAX
                BG_CHK(ifr==ifrMAX);
badframe:
                (MyDebugPrint(pTG,  LOG_ERR,  "<<WARNING>> IGNORING Bad Frame (Size=%d) -->\r\n", uRecv));
                // D_HexPrint(bRecv, uRecv);


                //Protocol Dump
                DumpFrame(pTG, FALSE, 0, uRecv, bRecv);


                fGotBad = TRUE;                 // remember we got a bad frame

        // Don't want to save bad frames
        /***
                // mark frame as bad
                ifr = ifrBAD;
                lpfrNext->ifr = ifrBAD;
                lpfrNext->cb = (BYTE)uRecv;
                _fmemcpy(lpfrNext->fif, bRecv, uRecv);

                lplpfr[pTG->T30.Nframes] = lpfrNext;
                pTG->T30.Nframes++;
                lpfrNext++;                     // skips over only the base part of frame
                lpfrNext = ((LPBYTE)lpfrNext + uRecv);  // skips over FIF too
        ***/

                continue;
                // loop back here for the next frame

goodframe:
                // (MyDebugPrint(pTG,  "FRAME RECEIVED: (%s) 0x%02x -->\r\n", (LPSTR)(rgFrameInfo[ifr].szName), bRecv[2]));
                // ST_T30_2(D_HexPrint(bRecv, uRecv));


                ifrLastGood = ifr;      // save last good ifr

                lpfrNext->ifr = ifr;
                if(uRecv > j)
                {
                        lpfrNext->cb = uRecv-j;
                        _fmemcpy(lpfrNext->fif, bRecv+j, uRecv-j);

                        //Protocol Dump
                        DumpFrame(pTG, FALSE, ifr, (USHORT)(uRecv-j), bRecv+j);
                }
                else
                {
                        lpfrNext->cb = 0;
                        BG_CHK(uRecv == j);

                        //Protocol Dump
                        DumpFrame(pTG, FALSE, ifr, 0, 0);
                }

                lplpfr[pTG->T30.Nframes] = lpfrNext;
                pTG->T30.Nframes++;

                ///////////// back to NSS-DCS form ////////////
                if(ifr==ifrDCS && fFinal)
                {
                        // Need to set receive speed, since bypass all callbacks
                        // now and go straight to AT+FRM=xx

                        pTG->T30.uRecvTCFMod = (((lpfrNext->fif[1])>>2) & 0x0F);
                        (MyDebugPrint(pTG,  LOG_ALL, "cmdresp-DCS fx sp=%d\r\n", pTG->T30.uRecvTCFMod));
                        // fastexit:
                        BG_CHK(ifr==ifrDCS);
                        return ifr;             // ifr of final frame
                }
#ifdef OEMNSF
                else if(ifr==ifrNSS && lpfnOEMGetBaudRate && fUsingOEMProt)
                {
                        WORD wRet = lpfnOEMGetBaudRate(pTG, lpfrNext->fif, lpfrNext->cb, fFinal);
                        if(wRet)
                        {
                                BG_CHK(fFinal);
                                if(LOBYTE(wRet) == OEMNSF_GET_TCF)
                                {
                                        (MyDebugPrint(pTG, LOG_ALL,  "cmdresp-NSS fx sp=%d\r\n", pTG->T30.uRecvTCFMod));
                                        pTG->T30.uRecvTCFMod = HIBYTE(wRet);
                                        BG_CHK(ifr==ifrNSS);
                                        return ifr;
                                }
                                else if(LOBYTE(wRet) == OEMNSF_NO_TCF)
                                {
                                        (MyDebugPrint(pTG, LOG_ALL,  "cmdresp-NSS fx sp=%d\r\n", pTG->T30.uRecvTCFMod));
                                        pTG->T30.uRecvTCFMod = 0xFF;
                                        BG_CHK(ifr==ifrNSS);
                                        return ifr;
                                }
                        }
                        else if(fFinal)
                        {
                                (MyDebugPrint(pTG,  LOG_ERR, "<<ERROR>> OEMGetBaudRate returned %d for FINAL frame. Using standard T30\r\n"));
                                fUsingOEMProt = 0;
                                return ifrNULL;
                        }
                }
#endif


                lpfrNext++;                             // skips over only the base part of frame
                lpfrNext = (LPFR)((LPBYTE)lpfrNext + (uRecv-j));        // skips over FIF too

                if(ifr == ifrCRP)
                {
                        fGotBad = TRUE; // pretend we got a bad response (so the T30 chart says!)
                        // fResync = FALSE;
                        goto error;             // exit, but get 200ms of silence
                                                        // caller will resend command
                }
                if(ifr == ifrDCN)
                        goto exit2;             // exit. Don't call callback function!

                // loop back here for the next frame
        }
        BG_CHK(fFinal); // only reason we ever drop through here

        // let ifrDCN also come through here. No hurry, so we can report
        // it to the protocol module. If we got *only* bad frames, here we'll
        // return ifrBAD
//exit:
        if(!pTG->T30.Nframes ||                      // we got no good frames
                (ifr != ifrLastGood))   // final frame was bad
        {
                (MyDebugPrint(pTG,  LOG_ERR,  "<<WARNING>> Got %d good frames. LastGood=%d Last=%d. Ignoring ALL\r\n",
                                        pTG->T30.Nframes, ifrLastGood, ifr ));
                // fResync = FALSE;
                goto error;
        }

        // ifr of final frame
        BG_CHK(ifr == ifrLastGood);
        if(pTG->T30.Nframes>1 || fGotFIF)
        {
                action=pTG->Params.lpfnWhatNext(pTG, eventGOTFRAMES, pTG->T30.Nframes,
                                                (ULONG_PTR)lplpfr, (ULONG_PTR)((LPIFR)&ifr));
                BG_CHK(action==actionNULL || action==actionERROR);
        }
exit2:
        // ifr can be changed by callback function (e.g. if bad FIFs)
        if(ifr==ifrDTC)
                pTG->T30.fReceivedDTC = TRUE;
        return ifr;             // ifr of final frame

error:
        // comes here on getting RECV_TIMEOUT, RECV_WRONGMODE, RECV_ERROR
        // and ifrCRP, or on getting no Frames
        // fReSync is set on RECV_TIMEOUT or RECV_ERROR

#ifdef DEBUG
        if(pTG->T30.Nframes>0 && ifr!=ifrCRP && ifrLastGood!=ifrCRP)
        {
                (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Got some good frames--Throwing away!! IFR=%d Last=%d\r\n", ifr, ifrLastGood));
                // BG_CHK(FALSE);
        }
#endif

        if(fGotBad)
                ifr = ifrBAD;           // caller can send CRP if desired
        else
                ifr = ifrNULL;          // caller can repeat command & try again

        if(fCommand && fNoFlags) ifr = ifrTIMEOUT;      // hook for "Command Recvd?"

        // may not need this on TIMEOUT since AT-OK has already been
        // called in ModemDialog. Probably need it on ERROR

        if(uRet==RECV_ERROR)
        {
                BG_CHK(fResync);
                ModemSync(pTG, pTG->Params.hModem, RESYNC_TIMEOUT2);
        }
        // eliminate Flush--serves no purpose
        // else if(uRet==RECV_WRONGMODE)
        // {
        //      ModemFlush(pTG->Params.hModem);
        // }

        // ModemRecvMode() returns EOF then return ifrEOF immediately. RecvMode
        // returns RECV_EOF only if we pass it the ifrNODEFafterWRONGMODE hint
        // and it senses silence (i.e. we saw a V21 echo but missed it). In
        // this case we want to retry the high speed PIX recv again immediately
        if(fGotEofFromRecvMode) ifr=ifrEOFfromRECVMODE;

        BG_CHK(ifr==ifrBAD || ifr==ifrNULL || ifr==ifrTIMEOUT || ifr==ifrEOFfromRECVMODE);
        return ifr;

/*-----------------------------------------------------------------
 *      Don't want to return ifrERROR ever. Nobody wants to deal with it.
 *      Don't try to get the 200ms of silence, because it causes us to
 *      get badly out of sync, i.e. after a few bad frames we don't
 *      resync and we lose the call. Just do a local-resync (AT-OK)
 *      and try to recv again.
 * -----------------------------------------------------------------
 *
 *      if( !ModemSync(pTG->Params.hModem, RESYNC_TIMEOUT) ||
 *              !ModemRecvSilence(pTG->Params.hModem, 20, RESYNC_TIMEOUT))
 *      {
 *              (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Can't get silence after Response timeout--hanging up\r\n"));
 *              // ifr = ifrERROR;
 *              // caller must send DCN and hangup
 *      }
 *      action=pTG->Params.lpfnWhatNext(eventGOTFRAMES, pTG->T30.Nframes,
 *                                      (DWORD)lplpfr, (DWORD)((LPIFR)&ifr));
 *      BG_CHK(action == actionNULL);
 *
 * -----------------------------------------------------------------
 *      and don't want to regsiter garbage frame sets. Nobody does anything
 *  but retry on BAD/NULL/TIMEOUT returns anyway
 *-----------------------------------------------------------------*/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\main\t30main.c ===
#include "prep.h"


#include "oemint.h"

#include "t30.h"
#include "efaxcb.h"
#include "debug.h"

///RSL
#include "glbproto.h"


#       define MySleep(time) Sleep(time)

/**--------------------------- Debugging ------------------------**/
#define faxTlog(m)              DEBUGMSG(ZONE_MAIN, m);
#define FILEID                  FILEID_T30MAIN


#ifdef DEBUG
#       define  TIMESTAMP(str)  \
                faxTlog((SZMOD "TIMESTAMP %lu %s--\r\n", (unsigned long) GetTickCount(), (LPSTR) (str)));
#else  // !DEBUG
#       define  TIMESTAMP(str)
#endif // !DEBUG




BOOL
T30Cl1Rx (
    PThrdGlbl  pTG
    )

{
        BOOL           fOpen = 0,                     //CHKCHK - need to assign a value
                       fImmediate = 1;
        USHORT         uLine = 5,                     // LINE_NUM,
                       uModem = 5;                    // MODEM_NUM;
        USHORT         uRet1, uRet2, uFlags;
        HMODEM         hModem;
        HLINE          hLine;
        ET30ACTION     actionInitial = actionNULL;
        BOOL           RetCode = FALSE;

// #ifndef SHIP_BUILD
{
        SYSTEMTIME st;
        GetLocalTime(&st);
        RETAILMSG((SZMOD "------------- Answering at %02d:%02d:%02d on %02d/%02d/%02d ----------\r\n",
                                        st.wHour, st.wMinute, st.wSecond, st.wMonth, st.wDay, st.wYear));
}
// #endif
        TIMESTAMP("Answering")

        SignalStatusChange(pTG, FS_ANSWERED);


        // first get SEND_CAPS (before answering)
        if(!ProtGetBC(pTG, SEND_CAPS, TRUE)) // sleep until we get it
        {
                uRet1 = T30_CALLFAIL;
                uRet2 = 0;      // need err value here
                goto done;
        }


        uFlags = NCULINK_RX;
        if(fOpen || fImmediate)
        {
                uFlags |= NCULINK_IMMEDIATE;
        faxTlog((SZMOD "IMMEDIATE ANSWER\r\n"));
    }
        // when MDDI is not defined, hLine==uLine and hModem==uModem
        // when MDDI is defined, if fOpen is TRUE, then also hLine==uLine and hModem==uModem
        hLine = (HLINE)uLine;
        hModem = (HMODEM)uModem;





        if((uRet2 = NCULink(pTG, hLine, hModem, 0, uFlags)) != CONNECT_OK)
        {
                uRet1 = T30_ANSWERFAIL;
                goto done;
        }





#ifdef RICOHAI
                fUsingOEMProt = FALSE;
                BG_CHK(RICOHAI_MODE == RICOHAI_ENABLE);
                uRet2 = ModemConnectRx(pTG, hModem, (wOEMFlags & RICOHAI_ENABLE));
                if(uRet2 == CONNECT_ESCAPE)
                {
                        fUsingOEMProt = TRUE;
                        actionInitial = actionGONODE_F;
                }
                else if(uRet2 != CONNECT_OK)
                {
                        uRet1 = T30_ANSWERFAIL;
                        goto done;
                }
#else

#ifdef MDDI
        if((uRet2 = ModemConnectRx(pTG, hModem, 0)) != CONNECT_OK)
        {
                uRet1 = T30_ANSWERFAIL;
                goto done;
        }
#endif //MDDI
#endif //!RICOHAI


        // Protocol Dump
        RestartDump(pTG);

#ifdef IFK
        // Call counter
        IFNvramSetCounterValue(RXCALL_COUNTER, 1, 0,
                (COUNTER_ADDVALUE|COUNTER_TIMESTAMP|PROCESS_CONTEXT));
#endif

        uRet1 = T30MainBody(pTG, FALSE, actionInitial, hLine, hModem);
        BG_CHK(uRet1==T30_CALLDONE || uRet1==T30_CALLFAIL);
        uRet2 = 0;


        // Protocol Dump
        PrintDump(pTG);


done:
// #ifndef SHIP_BUILD
{
        SYSTEMTIME st;
        GetLocalTime(&st);
        if(uRet1==T30_CALLDONE) {
                SignalStatusChange(pTG, FS_COMPLETED);

                RetCode = TRUE;
                RETAILMSG((SZMOD "------------ SUCCESSFUL RECV at %02d:%02d:%02d on %02d/%02d/%02d ------------\r\n",
                                st.wHour, st.wMinute, st.wSecond, st.wMonth, st.wDay, st.wYear));
        }
        else if (pTG->StatusId == FS_NOT_FAX_CALL) {
            RetCode = FALSE;
            ERRMSG(("---------- DATA CALL attempt HANDOVER (0x%04x) at %02d:%02d:%02d on %02d/%02d/%02d -----------\r\n",
                    MAKEWORD(uRet1, uRet2), st.wHour, st.wMinute, st.wSecond, st.wMonth, st.wDay, st.wYear));

        }
        else {
                if (!pTG->fFatalErrorWasSignaled) {
                    pTG->fFatalErrorWasSignaled = 1;
                    SignalStatusChange(pTG, FS_FATAL_ERROR);
                }

                RetCode = FALSE;
                ERRMSG(("---------- FAILED RECV (0x%04x) at %02d:%02d:%02d on %02d/%02d/%02d -----------\r\n",
                        MAKEWORD(uRet1, uRet2), st.wHour, st.wMinute, st.wSecond, st.wMonth, st.wDay, st.wYear));
        }
}
// #endif

        ICommStatus(pTG, ((uRet1==T30_CALLDONE) ? T30STATR_SUCCESS : T30STATR_FAIL), 0, 0, 0);

// Dont do this!! The Modem driver queues up commands for later execution, so the
// DCN we just sent is probably in the queue. Doing a sync here causes that send
// to be aborted, so the recvr never gets a DCN and thinks teh recv failed. This
// is bug#6803
// #ifdef MDDI
//      // sometimes modem gets confused & doesnt want to hangup? Cleanup its state
//      // Class1 modem driver doesnt need this. Only Ricohs
//      ModemSync(hModem, RESYNC_TIMEOUT1);
// #endif
        NCULink(pTG, hLine, 0, 0, NCULINK_HANGUP);
        pTG->lEarliestDialTime = GetTickCount() + MIN_CALL_SEPERATION;

#ifdef MDDI
        ModemClose(pTG, hModem);
        NCUReleaseLine(pTG, hLine);
#endif //MDDI
        BG_CHK((uRet1 & 0xFF) == uRet1);
        BG_CHK((uRet2 & 0xFF) == uRet2);



        return (RetCode);
}







BOOL
T30Cl1Tx (
    PThrdGlbl  pTG,
    LPSTR      szPhone
    )



{
        BOOL    fOpen = 0;                     //CHKCHK - need to assign a value
        USHORT  uRet1, uRet2;
        ULONG   ulTimeout;
        USHORT         uLine = 5,              // LINE_NUM,
                       uModem = 5;             // MODEM_NUM;
        HLINE   hLine;
        HMODEM  hModem;
        ET30ACTION actionInitial;
        WORD    wFlags;
        BOOL           RetCode = FALSE;

// #ifndef SHIP_BUILD
{
        SYSTEMTIME st;
        GetLocalTime(&st);
        RETAILMSG((SZMOD "------------ Calling <%s> at %02d:%02d:%02d on %02d/%02d/%02d ------------\r\n",
                                (LPSTR)szPhone, st.wHour, st.wMinute, st.wSecond, st.wMonth, st.wDay, st.wYear));
}
// #endif

// Ricoh doesnt like this to go over 60secs, so give ourselves some buffer here
#define DIAL_TIMEOUT    58000L

        ulTimeout = DIAL_TIMEOUT;
/**
        if((uLen = _fstrlen(szPhone)) > 7)
                ulTimeout += (((ULONG)(uLen - 7)) << 12);       //mult by 4096
**/

        // when MDDI is not defined, hLine==uLine and hModem==uModem
        // when MDDI is defined, if fOpen is TRUE, then also hLine==uLine and hModem==uModem
        hLine = (HLINE)uLine;
        hModem = (HMODEM)uModem;

        actionInitial = actionNULL;
        wFlags = 0;


        // for non-manual calls only, wait until a min. time has elapsed
        // since the last hangup. Beware of wraparound
        if(!fOpen && szPhone)   //fOpen==on-hook-dial, szPhone=NULL: handset dial
        {
                DWORD   lNow, lSleep = -1;

                lNow = GetTickCount();
                if(lNow < pTG->lEarliestDialTime)
                        lSleep = pTG->lEarliestDialTime-lNow;

                faxTlog((SZMOD "Seperation: Now=%ld Earliest=%ld Seperation=%ld Sleep=%ld\r\n",
                        lNow, pTG->lEarliestDialTime, (DWORD)(MIN_CALL_SEPERATION), lSleep ));

                if(lSleep <= MIN_CALL_SEPERATION)
                        MySleep(lSleep);
        }


        SignalStatusChange(pTG, FS_DIALING);


        if(((uRet2 = NCULink(pTG, hLine, hModem, 0, NCULINK_TX)) != CONNECT_OK)
        || (szPhone ? ((uRet2 = NCUDial(pTG, hLine, szPhone)) != CONNECT_OK) : FALSE))
        {
                uRet1 = T30_DIALFAIL;
                goto done;
        }



        // Protocol Dump
        RestartDump(pTG);

        uRet1 = T30MainBody(pTG, TRUE, actionInitial, hLine, hModem);
        BG_CHK(uRet1==T30_CALLDONE || uRet1==T30_CALLFAIL);
        uRet2 = 0;


#ifdef RICOHAI
        RicohAIEnd();
#endif

        // Protocol Dump
        PrintDump(pTG);

done:
// #ifndef SHIP_BUILD
{
        SYSTEMTIME st;
        GetLocalTime(&st);
        if(uRet1==T30_CALLDONE) {
                SignalStatusChange(pTG, FS_COMPLETED);

                RetCode = TRUE;
                RETAILMSG((SZMOD "------------ SUCCESSFUL SEND at %02d:%02d:%02d on %02d/%02d/%02d ------------\r\n",
                                st.wHour, st.wMinute, st.wSecond, st.wMonth, st.wDay, st.wYear));
        }
        else {
            if (!pTG->fFatalErrorWasSignaled) {
                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_FATAL_ERROR);
            }

           RetCode = FALSE;
           ERRMSG(("---------- FAILED SEND (0x%04x) at %02d:%02d:%02d on %02d/%02d/%02d -----------\r\n",
                        MAKEWORD(uRet1, uRet2), st.wHour, st.wMinute, st.wSecond, st.wMonth, st.wDay, st.wYear));
        }
}
// #endif

        ICommStatus(pTG, ((uRet1==T30_CALLDONE) ? T30STATS_SUCCESS : T30STATS_FAIL), 0, 0, 0);

// Dont do this!! The Modem driver queues up commands for later execution, so the
// DCN we just sent is probably in the queue. Doing a sync here causes that send
// to be aborted, so the recvr never gets a DCN and thinks teh recv failed. This
// is bug#6803
// #ifdef MDDI
//      // sometimes modem gets confused & doesnt want to hangup? Cleanup its state
//      // Class1 modem driver doesnt need this. Only Ricohs
//      ModemSync(hModem, RESYNC_TIMEOUT1);
// #endif
        NCULink(pTG, hLine, 0, 0, NCULINK_HANGUP);
        pTG->lEarliestDialTime = GetTickCount() + MIN_CALL_SEPERATION;

#ifdef MDDI
        ModemClose(pTG, hModem);
        NCUReleaseLine(pTG, hLine);
#endif //MDDI
        BG_CHK((uRet1 & 0xFF) == uRet1);
        BG_CHK((uRet2 & 0xFF) == uRet2);


        return (RetCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\main\tx_thrd.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tx_thrd.c

Abstract:

    This module implements MMR->MR and MMR->MH conversion in a separate thread.

Author:

    Rafael Lisitsa (RafaelL) 14-Aug-1996

Revision History:

--*/

#include "prep.h"

#include "efaxcb.h"
#include "t30.h"
#include "hdlc.h"
#include "debug.h"

#include "tiff.h"

#include "glbproto.h"
#include "t30gl.h"

// 10 min.
#define WAIT_FOR_NEXT_STRIP_TX_TIMEOUT      600000


DWORD
TiffConvertThreadSafe(
    PThrdGlbl   pTG
    )

{
    DWORD   RetCode;


    if (glT30Safe) {

        __try {

            RetCode = TiffConvertThread(pTG);

        } __except (EXCEPTION_EXECUTE_HANDLER) {
            //
            // Signal to the Main T.30 Thread that we crashed
            //
            return (FALSE);

        }
    }
    else  {

        RetCode = TiffConvertThread(pTG);

    }


    return (RetCode);
}






DWORD
TiffConvertThread(
    PThrdGlbl   pTG
    )

{


    DWORD                  tiffCompression = pTG->TiffConvertThreadParams.tiffCompression;
    BOOL                   NegotHiRes = pTG->TiffConvertThreadParams.HiRes;
    BOOL                   SrcHiRes = pTG->SrcHiRes;
    char                   OutFileName[_MAX_FNAME];
    HANDLE                 OutFileHandle;
    DWORD                 *lpdwOutputBuffer;
    DWORD                  dwBytesWritten;
    DWORD                  dwSizeOutputBuffer = 500000;
    DWORD                  dwUsedSizeOutputBuffer;
    DWORD                  MaxNeedOutSize;
    DWORD                  StripDataSize;
    DWORD                  NumHandles=2;
    HANDLE                 HandlesArray[2];
    DWORD                  WaitResult;
    DWORD                  RetCode = FALSE;
    BOOL                   fOutFileNeedsBeClosed = 0;
    BOOL                   fOutBufferNeedsBeFreed = 0;

    HandlesArray[0] = pTG->AbortReqEvent;
    HandlesArray[1] = pTG->ThrdSignal;


    lpdwOutputBuffer = (DWORD *) VirtualAlloc(
        NULL,
        dwSizeOutputBuffer,
        MEM_COMMIT,
        PAGE_READWRITE
        );

    if (! lpdwOutputBuffer) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR TIFF_TX: lpdwOutputBuffer can'r VirtualAlloc \n");
        SignalHelperError(pTG);
        goto l_exit;
    }

    fOutBufferNeedsBeFreed = 1;


    //
    // Set the appropriate PRTY for this thread
    // I/O threads run at 15. TIFF - at 9...11
    //

    MyDebugPrint(pTG, LOG_ALL, "TIFF_TX: NegotHiRes=%d SrcHiRes=%d Started at %ld \n",
                                         NegotHiRes, SrcHiRes, GetTickCount() );


    if (! SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_HIGHEST) ) {
        MyDebugPrint(pTG, LOG_ERR, "ERROR TIFF_TX: SetThreadPriority HIGHEST failed le=%x \n", GetLastError() );
        SignalHelperError(pTG);
        goto l_exit;
    }


    // need test below to make sure that pTG is still valid
    if (pTG->ReqTerminate) {
        goto l_exit;
    }

    //
    // TIFF file was already opened in FaxDevSendA
    // in order to get the YResolution tag to negotiate resolution.
    //
    pTG->CurrentOut = 1;

    //
    //  loop thru all pages
    //

    do {

        pTG->fTiffPageDone = 0;

        _fmemcpy (OutFileName, gT30.TmpDirectory, gT30.dwLengthTmpDirectory);
        _fmemcpy (&OutFileName[gT30.dwLengthTmpDirectory], pTG->TiffConvertThreadParams.lpszLineID, 8);
        sprintf( &OutFileName[gT30.dwLengthTmpDirectory+8], ".%03d",  pTG->CurrentOut);

        if ( ( OutFileHandle = CreateFileA(OutFileName, GENERIC_WRITE, FILE_SHARE_READ,
                                           NULL, OPEN_ALWAYS, 0, NULL) ) == INVALID_HANDLE_VALUE ) {

            MyDebugPrint(pTG, LOG_ERR, "TIFF_TX: ERROR: %lx  CREATING file %s \n", GetLastError(), OutFileName);
            SignalHelperError(pTG);
            goto l_exit;
        }

        fOutFileNeedsBeClosed = 1;

        MyDebugPrint(pTG, LOG_ALL, "TIFF_TX: Page %d started at %ld\n", pTG->CurrentOut, GetTickCount() );

        if (! TiffSeekToPage( (HANDLE) pTG->Inst.hfile, pTG->CurrentOut, FILLORDER_LSB2MSB ) ) {
            MyDebugPrint(pTG, LOG_ERR, "ERROR: seeking to page \n");
            SignalHelperError(pTG);
            goto l_exit;
        }
        else {
            MyDebugPrint(pTG, LOG_ALL, "TIFF_TX: Tiff seeking to page -OK time=%ld\n", GetTickCount() );
        }




        __try {

#if 0
            if (glSimulateError && (glSimulateErrorType == SIMULATE_ERROR_TX_TIFF) ) {
                SimulateError( EXCEPTION_ACCESS_VIOLATION);
            }
#endif


            //
            // check the current page dimensions. Add memory if needed.
            //

            TiffGetCurrentPageData( (HANDLE) pTG->Inst.hfile,
                                     NULL,
                                     &StripDataSize,
                                     NULL,
                                     NULL
                                     );

            if ( (StripDataSize < 0) || (StripDataSize > 1500000) ) {
                MyDebugPrint(pTG, LOG_ERR, "ERROR: Tiff CONVERTING %d page StripSize = %d \n", pTG->CurrentOut, StripDataSize);
                SignalHelperError(pTG);
                goto l_exit;
            }


            if (tiffCompression == TIFF_COMPRESSION_MR) {
                MaxNeedOutSize = StripDataSize * 3 / 2;
            }
            else {
                MaxNeedOutSize = StripDataSize * 2;
            }


            if (MaxNeedOutSize > dwSizeOutputBuffer) {
                if (MaxNeedOutSize > 1000000) {
                    dwSizeOutputBuffer = 1500000;
                }
                else {
                    dwSizeOutputBuffer = 1000000;
                }

                VirtualFree(lpdwOutputBuffer, 0 , MEM_RELEASE);

                lpdwOutputBuffer = (DWORD *) VirtualAlloc(
                    NULL,
                    dwSizeOutputBuffer,
                    MEM_COMMIT,
                    PAGE_READWRITE
                    );

                if (! lpdwOutputBuffer) {
                    MyDebugPrint(pTG, LOG_ERR, "ERROR TIFF_TX: lpdwOutputBuffer can't VirtualAlloc %d \n", dwSizeOutputBuffer);
                    SignalHelperError(pTG);
                    goto l_exit;
                }

                fOutBufferNeedsBeFreed = 1;

            }


            dwUsedSizeOutputBuffer = dwSizeOutputBuffer;

            if (tiffCompression == TIFF_COMPRESSION_MR) {
                if (NegotHiRes == SrcHiRes) {
                    if (! ConvMmrPageToMrSameRes ( (HANDLE) pTG->Inst.hfile,
                                                    lpdwOutputBuffer,
                                                    &dwUsedSizeOutputBuffer,
                                                    NegotHiRes) ) {
                        MyDebugPrint(pTG, LOG_ERR, "ERROR: Tiff CONVERTING %d page \n", pTG->CurrentOut);
                        SignalHelperError(pTG);
                        goto l_exit;
                    }
                }
                else {
                    if (! ConvMmrPageHiResToMrLoRes ( (HANDLE) pTG->Inst.hfile,
                                                    lpdwOutputBuffer,
                                                    &dwUsedSizeOutputBuffer) ) {
                        MyDebugPrint(pTG, LOG_ERR, "ERROR: Tiff CONVERTING %d page \n", pTG->CurrentOut);
                        SignalHelperError(pTG);
                        goto l_exit;
                    }
                }
            }
            else {
                if (! ConvMmrPageToMh ( (HANDLE) pTG->Inst.hfile,
                                                lpdwOutputBuffer,
                                                &dwUsedSizeOutputBuffer,
                                                NegotHiRes,
                                                SrcHiRes) ) {
                    MyDebugPrint(pTG, LOG_ERR, "ERROR: Tiff CONVERTING %d page \n", pTG->CurrentOut);
                    SignalHelperError(pTG);
                    goto l_exit;
                }
            }

        } __except (EXCEPTION_EXECUTE_HANDLER) {
            //
            // Signal to the Main T.30 Thread that we crashed
            //

            if (fOutBufferNeedsBeFreed) {
                VirtualFree(lpdwOutputBuffer, 0 , MEM_RELEASE);
            }

            CloseHandle(OutFileHandle);

            return (FALSE);

        }


        if ( ( ! WriteFile(OutFileHandle, (BYTE *) lpdwOutputBuffer, dwUsedSizeOutputBuffer, &dwBytesWritten, NULL) ) ||
             (dwUsedSizeOutputBuffer != dwBytesWritten ) )  {

            MyDebugPrint(pTG, LOG_ERR, "ERROR: Tiff writing file %s \n", OutFileName);
            SignalHelperError(pTG);
            goto l_exit;
        }


        if ( ! CloseHandle(OutFileHandle) ) {
            fOutFileNeedsBeClosed = 0;
            MyDebugPrint(pTG, LOG_ERR, "ERROR: Tiff writing file %s \n", OutFileName);
            SignalHelperError(pTG);
            goto l_exit;
        }

        fOutFileNeedsBeClosed = 0;

        pTG->fTiffPageDone = 1;

        SetEvent(pTG->FirstPageReadyTxSignal);

        MyDebugPrint(pTG, LOG_ALL, "TIFF_TX: Done page %d size=%d at %ld \n", pTG->CurrentOut, dwUsedSizeOutputBuffer, GetTickCount() );


        if (!pTG->FirstOut) {
            pTG->FirstOut = 1;
        }

        pTG->LastOut++;

        //
        // check to see if we are done
        //
        if (pTG->LastOut >= pTG->TiffInfo.PageCount) {
            MyDebugPrint(pTG, LOG_ALL, "TIFF_TX: Done whole document Last page %d size=%d at %ld \n", pTG->CurrentOut, dwUsedSizeOutputBuffer, GetTickCount() );
            pTG->fTiffDocumentDone = 1;

            goto good_exit;
        }

        //
        // we want to maintain 2 pages ahead
        //

        if (pTG->LastOut - pTG->CurrentIn >= 2) {

            WaitResult = WaitForMultipleObjects(NumHandles, HandlesArray, FALSE, WAIT_FOR_NEXT_STRIP_TX_TIMEOUT);

            if (WaitResult == WAIT_TIMEOUT) {
                MyDebugPrint(pTG, LOG_ERR, "TIFF_TX: WaitForMultipleObjects TIMEOUT at %ld \n", GetTickCount() );
                goto l_exit;
            }

            if (WaitResult == WAIT_FAILED) {
                MyDebugPrint(pTG, LOG_ERR, "TIFF_TX: WaitForMultipleObjects FAILED le=%lx at %ld \n",
                                            GetLastError(), GetTickCount() );
            }

            if (pTG->ReqTerminate) {
                MyDebugPrint(pTG, LOG_ALL, "TIFF_TX: Received TERMINATE request at %ld \n",  GetTickCount() );
                goto good_exit;
            }
            else if (pTG->ReqStartNewPage)  {
                MyDebugPrint(pTG, LOG_ALL, "TIFF_TX: Received START NEW PAGE request at %ld \n",  GetTickCount() );
                pTG->AckStartNewPage = 1;
                pTG->ReqStartNewPage = 0;
            }
            else {
                MyDebugPrint(pTG, LOG_ALL, "ERROR: TIFF_TX: Received WRONG request at %ld \n",  GetTickCount() );
                WaitResult = WaitForMultipleObjects(NumHandles, HandlesArray, FALSE, WAIT_FOR_NEXT_STRIP_TX_TIMEOUT);

                if (WaitResult == WAIT_TIMEOUT) {
                    MyDebugPrint(pTG, LOG_ERR, "TIFF_TX: WaitForMultipleObjects TIMEOUT at %ld \n", GetTickCount() );
                    goto l_exit;
                }

                if (WaitResult == WAIT_FAILED) {
                    MyDebugPrint(pTG, LOG_ERR, "TIFF_TX: WaitForMultipleObjects FAILED le=%lx at %ld \n",
                                                GetLastError(), GetTickCount() );
                }

            }
        }


        pTG->CurrentOut++;
        MyDebugPrint(pTG, LOG_ALL, "TIFF_TX: Start page %d at %ld \n", pTG->CurrentOut, GetTickCount() );

    } while (1);





good_exit:
    if (pTG->fTiffOpenOrCreated) {
        TiffClose( (HANDLE) pTG->Inst.hfile);
        pTG->fTiffOpenOrCreated = 0;
    }

    RetCode = TRUE;




l_exit:

    if (fOutFileNeedsBeClosed) {
        CloseHandle(OutFileHandle);
    }

    if (fOutBufferNeedsBeFreed) {
        VirtualFree(lpdwOutputBuffer, 0 , MEM_RELEASE);
    }

    pTG->AckTerminate = 1;
    pTG->fOkToResetAbortReqEvent = 1;

    SetEvent(pTG->ThrdAckTerminateSignal);
    SetEvent(pTG->FirstPageReadyTxSignal);

    MyDebugPrint(pTG, LOG_ALL, "TIFF_TX: TiffConvertThread EXITs at %ld \n", GetTickCount() );

    return (RetCode);


}






VOID
SignalHelperError(
    PThrdGlbl   pTG
    )

{
    pTG->ThreadFatalError = 1;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\main\whatnext.c ===
/***************************************************************************
        Name      :     WHATNEXT.C
        Comment   :     T30 Decision-point Callback function

        Copyright (c) 1993 Microsoft Corp.

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
***************************************************************************/


#include "prep.h"



#include "efaxcb.h"
#include "protocol.h"


///RSL
#include "glbproto.h"



#define         faxTlog(m)              DEBUGMSG(ZONE_WHATNEXT, m)
#define         FILEID                  FILEID_WHATNEXT


// used in eventPOSTPAGERESPONSE
// first index got from ifrSend (MPS=0, EOM=1, EOP=2, EOMwithFastTurn=3)
// second index got from ifrRecv (MCF=0, RTP=1, RTNnoRetrans=2, RTNretrans=3)

ET30ACTION PostPageAction[4][4] =
{
 { actionGONODE_I,      actionGONODE_D, actionGONODE_D, actionGONODE_D },
 { actionGONODE_T,      actionGONODE_T, actionGONODE_T, actionGONODE_T /* or D? */ },
 { actionDCN,           actionDCN,              actionDCN,              actionGONODE_D },
 { actionGONODE_A,      actionGONODE_A, actionGONODE_A, actionGONODE_D /* or A? */ }
};







void CopyFrToRFS(PThrdGlbl pTG, NPRFS npRecvd, LPFR lpfr)
{
        USHORT uLen;

        BG_CHK(MAXFRAMES == (sizeof(npRecvd->rglpfr) / sizeof(LPFR)));
        if(npRecvd->uNumFrames >= (sizeof(npRecvd->rglpfr) / sizeof(LPFR)))
        {
                BG_CHK(FALSE);
                return;
        }
        uLen = sizeof(FRBASE) + lpfr->cb;
        if(npRecvd->uFreeSpaceOff + uLen >= sizeof(npRecvd->b))
        {
                BG_CHK(FALSE);
                return;
        }
        _fmemcpy(npRecvd->b + npRecvd->uFreeSpaceOff, lpfr, uLen);
        npRecvd->rglpfr[npRecvd->uNumFrames++] = (LPFR)(npRecvd->b + npRecvd->uFreeSpaceOff);
        npRecvd->uFreeSpaceOff += uLen;

        BG_CHK(npRecvd->uNumFrames <= MAXFRAMES);
        BG_CHK(npRecvd->uFreeSpaceOff <= MAXSPACE);
}



/***-------------- Warning. This is called as a Vararg function --------***/




ET30ACTION  __cdecl FAR
WhatNext    (
            PThrdGlbl pTG,
            ET30EVENT event,
            WORD wArg1,
            DWORD lArg2,
            DWORD lArg3
            )
{
        ET30ACTION              action = actionERROR;
        NPPROT                  npProt = &pTG->ProtInst;

        // program bug. failure will cause a GP fault
        BG_CHK(pTG->ProtInst.fInUse);

        if (pTG->fAbortRequested) {

            if (pTG->fOkToResetAbortReqEvent && (!pTG->fAbortReqEventWasReset)) {
                MyDebugPrint(pTG,  LOG_ALL,  "WhatNext RESETTING AbortReqEvent at %lx\n",GetTickCount() );
                pTG->fAbortReqEventWasReset = 1;
                ResetEvent(pTG->AbortReqEvent);
            }

            MyDebugPrint(pTG,  LOG_ALL,  "WhatNext ABORTing at %lx\n",GetTickCount() );
            return actionERROR;
        }


        if(npProt->fAbort)
        {
                ERRMSG((SZMOD "<<ERROR>> Aborting in WhatNext\r\n"));
                // ICommFailureCode already set
                return actionERROR;
        }

        switch(event)
        {
          case eventGOTFRAMES:
          {
                /* uCount=wArg1. This is the number of frames received.
                 *
                 * lplpfr=(LPLPET30FR)lArg2. Pointer to an array of pointers to
                 *                the received frames, each in an ET30FR structure whose
                 *                format is defined in ET30defs.H
                 *
                 * return must be actionNULL
                 */

                USHORT  uCount = wArg1;
                LPLPFR  lplpfr = (LPLPFR)lArg2;
                LPIFR   lpifr  = (LPIFR)lArg3; // pointer to IFR that the "Response Recvd"
                                                                 // routine will return to the main body
                                                                 // can be modified, for example, if a bad
                                                                 // franes is deciphered.
                LPFR    lpfr;
                USHORT  i;
                BOOL    fGotRecvCaps=0, fGotRecvParams=0, fGotPollReq=0;

                /***
                        Each time we enter here we have an entire block of frames
                        that were sent as one "command" or "response". For frames
                        that can be multiple (NSF/NSS/NSC), we want to be sure that
                        _iff_ we have new ones, we throw away the old ones. Therefore
                        on the _first_ occurence of NSF, NSC and NSS resp. in the
                        loop below, zap npProt->uNumRecvdNS?s to 0. This may hold
                        good for SEP/PWD/SUB also.
                ***/

                BOOL    fZappedNSxCount=0;
                // fZappedSEPPWDCount=0;
                // BOOL fWaitingForPWD=0;

                if(*lpifr == ifrBAD)
                {
                        ERRMSG((SZMOD "<<WARNING>> Callback on Bad Frame. Ignoring ALL\r\n"));
                        action = actionNULL;    // only allowed response to eventGOTFRAMES
                        break;
                }

                for(i=0; i<uCount; i++)
                {
                ///////////////////////////////////////////////////////////////
                // Prepare to get trash (upto 2 bytes) at end of every frame //
                ///////////////////////////////////////////////////////////////

                        lpfr = lplpfr[i];
                        switch(lpfr->ifr)
                        {
                        case ifrBAD:    ERRMSG((SZMOD "<<ERROR>> Bad Frame not caught\r\n"));
                                                        BG_CHK(FALSE);
                                                        // ignore it
                                                        break;

                        case ifrCSI:
                        case ifrTSI:
                        case ifrCIG:    CopyRevIDFrame(pTG, npProt->bRemoteID, lpfr);
                                                        // trailing-trash removed by length limit IDFIFSIZE
                                                        npProt->fRecvdID = TRUE;

                                                        // prepare CSID for logging by FaxSvc
                                                    
                                                        pTG->RemoteID = AnsiStringToUnicodeString(pTG->ProtInst.bRemoteID);
                                                        if (pTG->RemoteID) {
                                                            pTG->fRemoteIdAvail = 1;
                                                        }
                                                    

                                                        break;

                        case ifrDIS:    npProt->uRemoteDISlen = CopyFrame(pTG, (LPBYTE)(&npProt->RemoteDIS), lpfr, sizeof(DIS));
                                                        // trailing-trash removed in ParseDISDTCDCS
                                                        npProt->fRecvdDIS = TRUE;
                                                        fGotRecvCaps = TRUE;
                                                        break;

                        case ifrDCS:    npProt->uRemoteDCSlen = CopyFrame(pTG, (LPBYTE)(&npProt->RemoteDCS), lpfr, sizeof(DIS));
                                                        // trailing-trash removed in ParseDISDTCDCS
                                                        npProt->fRecvdDCS = TRUE;
                                                        fGotRecvParams = TRUE;
                                                        break;

                        case ifrDTC:    npProt->uRemoteDTClen = CopyFrame(pTG, (LPBYTE)(&npProt->RemoteDTC), lpfr, sizeof(DIS));
                                                        // trailing-trash removed in ParseDISDTCDCS
                                                        npProt->fRecvdDTC = TRUE;
                                                        fGotPollReq = TRUE;
                                                        break;

                        case ifrNSS:    fGotRecvParams = TRUE; //some OEMs send NSS w/o DCS
                                                        goto DoRecvNSx;
                        case ifrNSC:    fGotPollReq = TRUE;    //some OEMs send NSC w/o DTC
                                                        goto DoRecvNSx;

                        case ifrNSF:    goto DoRecvNSx;

                                        DoRecvNSx:
                                                        if(!fZappedNSxCount)
                                                        {
                                                                ZeroRFS(pTG, &npProt->RecvdNS);
                                                                fZappedNSxCount = TRUE;
                                                        }
                                                        CopyFrToRFS(pTG, &npProt->RecvdNS, lpfr);
                                                        break;

                        case ifrCFR:            case ifrFTT:
                        case ifrEOM:            case ifrMPS:            case ifrEOP:
                        case ifrPRI_EOM:        case ifrPRI_MPS:        case ifrPRI_EOP:
                        case ifrMCF:            case ifrRTP:            case ifrRTN:
                        case ifrPIP:            case ifrPIN:
                        case ifrDCN:
                        case ifrCRP:
                                                        /*** ECM frames below ***/
                        case ifrCTR:            case ifrERR:
                        case ifrRR:             case ifrRNR:
                        case ifrEOR_NULL:
                        case ifrEOR_MPS:        case ifrEOR_PRI_MPS:
                        case ifrEOR_EOM:        case ifrEOR_PRI_EOM:
                        case ifrEOR_EOP:        case ifrEOR_PRI_EOP:
                                                //      These have no FIF
                                                ERRMSG((SZMOD "<<WARNING>> These are not supposed to be signalled\r\n"));
                                                // bad frame. ignore it
                                                // BG_CHK(FALSE);
                                                break;

                        /********* New T.30 frames ******************************/

                        case ifrSUB:    CopyRevIDFrame(pTG, npProt->bRecipSubAddr, lpfr);
                                                        npProt->fRecvdSUB = TRUE;
                                                        break;


/**
                        case ifrSEP:
                        case ifrPWD:
                                if(!fZappedSEPPWDCount)
                                {
                                        ZeroRFS(pTG, &npProt->RecvdSEPPWD);
                                        fZappedSEPPWDCount = TRUE;
                                }
                                CopyFrToRFS(pTG, &npProt->RecvdSEPPWD, lpfr);
                                break;
**/




                        /********* ECM stuff starts here. T.30 section A.4 ******/

                        //      These have FIFs
                        case ifrPPR:    if(lpfr->cb < 32)
                                                        {
                                                                // bad frame. FORCE A RETRANSMIT!!
                                                                ERRMSG((SZMOD "<<ERROR>> Bad PPR length!!\r\n"));
                                                                *lpifr = ifrNULL;
                                                                break;
                                                        }
                                                        _fmemcpy(npProt->bRemotePPR, lpfr->fif, 32);
                                                        // trailing-trash removed by length limit 32
                                                        npProt->fRecvdPPR = TRUE;
                                                        break;

                        case ifrPPS_NULL:
                        case ifrPPS_EOM:
                        case ifrPPS_MPS:
                        case ifrPPS_EOP:
                        case ifrPPS_PRI_EOM:
                        case ifrPPS_PRI_MPS:
                        case ifrPPS_PRI_EOP:
                                                        if(lpfr->cb < 3)
                                                        {
                                                                // bad frame. FORCE A RETRANSMIT!!
                                                                ERRMSG((SZMOD "<<ERROR>> Bad PPS length!!\r\n"));
                                                                *lpifr = ifrNULL;
                                                                break;
                                                        }
                                                        _fmemset(npProt->bRemotePPS, 0, 4);
                                                        _fmemcpy(npProt->bRemotePPS, lpfr->fif, 3);
                                                        // trailing-trash removed by length limit 3
                                                        npProt->fRecvdPPS = TRUE;
                                                        // only set this on first PPS in a block
                                                        if(!npProt->uFramesInThisBlock)
                                                                npProt->uFramesInThisBlock = (USHORT)(npProt->bRemotePPS[2]) + 1; //3rd byte of fif
                                                        break;
                        case ifrCTC:
                                                BG_CHK(npProt->fllRecvParamsGot);
                                                if(lpfr->cb < 2)
                                                {
                                                        // bad frame. FORCE A RETRANSMIT!!
                                                        ERRMSG((SZMOD "<<ERROR>> Bad CTC length!!\r\n"));
                                                        *lpifr = ifrNULL;
                                                        break;
                                                }
                                                npProt->llRecvParams.Baud = ((LPDIS)(&(lpfr->fif)))->Baud;
                                                // trailing-trash removed by length limit 2
                                                break;
                        }
                }
                if(fGotRecvCaps)
                {
                        // program bug. Failure may cause some random (non fatal) results
                        BG_CHK(!fGotRecvParams && !fGotPollReq);
                        GotRecvCaps(pTG);
                }
                if(fGotRecvParams)
                {
                        // program bug. Failure may cause some random (non fatal) results
                        BG_CHK(!fGotRecvCaps && !fGotPollReq);
                        GotRecvParams(pTG);
                }
                if(fGotPollReq)
                {
                        // program bug. Failure may cause some random (non fatal) results
                        BG_CHK(!fGotRecvCaps && !fGotRecvParams);
                        GotPollReq(pTG);
                }
                action = actionNULL;    // only allowed response to eventGOTFRAMES
                break;
          }

        /****** Transmitter Phase B. Fig A-7/T.30 (sheet 1) ******/

          case eventNODE_T:     // do nothing. Hook for abort in T1 loop
                                                action=actionNULL; break;
          case eventNODE_R:     // do nothing. Hook for abort in T1 loop
                                                action=actionNULL; break;


          case eventNODE_A:
          {
                IFR ifrRecv = (IFR)wArg1;       // last received frame
                // lArg2 & lArg3 missing

                if(ifrRecv != ifrDIS && ifrRecv != ifrDTC)
                {
                        ERRMSG((SZMOD "<<ERROR>> Unknown frames at NodeA\r\n"));
                        ICommFailureCode(pTG, T30FAIL_NODEA_UNKNOWN);
                        action = actionHANGUP;          // G3 only
                }
                else if(npProt->fSendParamsInited)
                {
                        BG_CHK(npProt->SendParams.bctype == SEND_PARAMS);
                        action = actionGONODE_D;                // sends DCS/NSS (in response to DIS or DTC)
                }
                else if(npProt->fSendPollReqInited)
                {
                        BG_CHK(npProt->SendPollReq.bctype == SEND_POLLREQ);
                        // BG_CHK(ifrRecv == ifrDIS);   // no need. DTC can follow DTC for Stalling
                        action = actionGONODE_R2;               // sends DTC/NSC (in response to DIS only)
                }
                else
                {
                        ERRMSG((SZMOD "<<ERROR>> NodeA: No more work...!!\r\n"));
                        ICommFailureCode(pTG, T30FAILS_NODEA_NOWORK);
                        action = actionDCN;                     // hangs up (sends DCN)
                }
                break;
          }
          case eventSENDDCS:
          {
                // 0==1st DCS  1==after NoReply  2==afterFTT
                USHORT uWhichDCS = (UWORD)wArg1;

                // where to return the number of frames returned
                LPUWORD lpuwN = (LPUWORD)lArg2;
                // where to return a pointer to an array of pointers to
                // return frames
                LPLPLPFR lplplpfr = (LPLPLPFR)lArg3;
                USHORT   uSize = 0;

                if(uWhichDCS == 2)      // got FTT
                {
                        if(!DropSendSpeed(pTG))
                        {
                                ERRMSG((SZMOD "<<ERROR>> FTT: Can't Drop speed any lower\r\n"));
                                ICommFailureCode(pTG, T30FAILS_FTT_FALLBACK);
                                action = actionDCN;
                                break;
                        }
                }

                CreateNSSTSIDCS(pTG, npProt, &pTG->rfsSend, uWhichDCS);


                BG_CHK(npProt->fllNegotiated);
                if(npProt->llNegot.fECM)
                {
                        uSize = (1 << (ProtGetECMFrameSize(pTG)));
                        BG_CHK(uSize==64 || uSize==256);
                        ICommSetSendMode(pTG, TRUE, MY_ECMBUF_SIZE, uSize, TRUE);
                }
                else
                {
                        ICommSetSendMode(pTG, FALSE, MY_BIGBUF_SIZE, MY_BIGBUF_ACTUALSIZE-4, FALSE);
                }


                *lpuwN = pTG->rfsSend.uNumFrames;
                *lplplpfr = pTG->rfsSend.rglpfr;

                action = actionSENDDCSTCF;

#ifdef OEMNSF
                if(wOEMFlags && lpfnOEMNextAction)
                {
                        switch(lpfnOEMNextAction())
                        {
                        case OEMNSF_SENDDCN:    action = actionDCN; break;
                        case OEMNSF_SKIPTCF:    action = actionSKIPTCF; break;
                        }
                }
#endif

                break;

                // Could also return DCN if not compatible
                // or SKIPTCF for Ricoh hook
          }

          case eventGOTCFR:
          {
                // wArg1, lArg2 & lArg3 are all missing

                // Can return GONODE_D (Ricoh hook)
                // or GONODE_I (Non ECM) or GONODE_IV (ECM)

                BG_CHK(npProt->fllNegotiated);
                if(npProt->llNegot.fECM)
                        action = actionGONODE_IV;
                else
                        action = actionGONODE_I;
                break;
          }
        /****** Transmitter Phase C. Fig A-7/T.30 (sheet 1) ******/

        /***
          case eventSTARTSEND:
          {
                if(!StartNextSendPage(pTG))
                {
                        ERRMSG((SZMOD "<<ERROR>> PhaseC: No more pages\r\n"));
                        ICommFailureCode(T30FAILS_BUG3);
                        action = actionDCN;
                }
                else
                        action = actionCONTINUE;
                break;
          }
        ***/

        /****** Transmitter ECM and non-ECM Phase D1. Fig A-7/T.30 (sheet 2) ******/

          case eventECM_POSTPAGE:
          case eventPOSTPAGE:
          {
                USHORT uNextSend;

                // wArg1, lArg2 & lArg3 are all missing

                // Can turn Zero stuffing off here, or wait for next page....
                // ET30ExtFunction(npProt->het30, ET30_SET_ZEROPAD, 0);
                // Don't turn it off!! It is used only for Page Send
                // and is set only on sending a DCS, so it is set once
                // before a multi-page send.

                uNextSend = ICommNextSend(pTG);
                switch(uNextSend)
                {
                case NEXTSEND_MPS: action = actionSENDMPS; break;
                case NEXTSEND_EOM: action = actionSENDEOM; break;
                case NEXTSEND_EOP: action = actionSENDEOP; break;
                case NEXTSEND_ERROR:
                default:                   action = actionSENDEOP; break;
                }
                break;
                // also possible -- GOPRIEOP, PRIMPS or PRIEOM
          }

        /****** Transmitter Phase D2. Fig A-7/T.30 (sheet 2) ******/

          case eventGOTPOSTPAGERESP:
          {
                IFR ifrRecv = (IFR)wArg1;       // last received frame
                IFR ifrSent = (IFR)lArg2;
                        // the IFR was simply cast to DWORD and then to LPVOID
                        // lArg3 is missing
                USHORT i, j;

                // change PRI commands to ordinary ones
                if(ifrSent >= ifrPRI_FIRST && ifrSent <= ifrPRI_LAST)
                        ifrSent = (ifrSent + ifrMPS - ifrPRI_MPS);

                BG_CHK(ifrSent==ifrMPS || ifrSent==ifrEOM || ifrSent==ifrEOP);
                if(ifrRecv!=ifrMCF && ifrRecv!=ifrRTP && ifrRecv!=ifrRTN)
                {
                        // can't BG_CHK cause we can get any garbage response anytime
                        ERRMSG((SZMOD "<<ERROR>> Unexpected Response %d\r\n", ifrRecv));
                        ICommFailureCode(pTG, T30FAILS_POSTPAGE_UNKNOWN);
                        action = actionDCN;
                        break;
                }

                i = ifrSent - ifrMPS;   //i: 0=MPS, 1=EOM, 2=EOP
                j = ifrRecv - ifrMCF;   //j: 0=MCF, 1=RTP, 2=RTN

#               ifdef FASTTURN
                        if(ifrSent == ifrEOM)
                        {
                                BG_CHK(i==1);
                                i = 3;                  //i: 3==EOM with fast turn
                        }
#               endif

                if(ICommSendPageAck(pTG, ((ifrRecv==ifrRTN) ? FALSE : TRUE)))
                {
                        BG_CHK(j==2);
                        j = 3;                          //j: 3==RTN with retransmit
                }

                // no need at all to drop speed on RTP
                if(ifrRecv==ifrRTN)             // || ifrRecv==ifrRTP)  // drop on RTP also??
                {
                        if(pTG->ProtParams.RTNAction == 2)
                        {
                                ERRMSG((SZMOD "<<ERROR>> RTN: INI settings says HANGUP\r\n"));
                                ICommFailureCode(pTG, T30FAILS_RTN_FALLBACK);
                                action = actionDCN;
                                break;                  // set action to DCN and return
                        }
                        else if (pTG->ProtParams.RTNAction == 1)
                        {
                                ERRMSG((SZMOD "<<WARNING>> RTN: INI setting says don't drop speed\r\n"));
                        }
                        else
                        {
                                BG_CHK(pTG->ProtParams.RTNAction == 0);
                                // put >2 case here as well, so that we do the reasonable
                                // thing if this setting gets messed up

                                if(!DropSendSpeed(pTG))
                                {
                                        ERRMSG((SZMOD "<<ERROR>> RTN: Can't Drop speed any lower\r\n"));
                                        ICommFailureCode(pTG, T30FAILS_RTN_FALLBACK);
                                        action = actionDCN;
                                        break;                  // set action to DCN and return
                                }
                        }
                }

                action = PostPageAction[i][j];
                if(action == actionDCN)
                {
                        (MyDebugPrint(pTG,  LOG_ALL,  "PostPage --> Game over\r\n"));
                        ICommFailureCode(pTG, T30FAILS_POSTPAGE_OVER);
                }
                break;

                // Can also return GO_D, GO_R1, GO_R2. Only restriction is
                // that GO_I is the only valid response to MPS sent followed
                // by MCF
          }

        /****** Transmitter ECM Phase D2. Fig A-7/T.30 (sheet 2) ******/

          case eventGOT_ECM_PPS_RESP:
          {
                IFR ifrRecv = (IFR)wArg1;       // last received frame
                IFR ifrSent = (IFR)lArg2;
                        // the IFR was simply cast to DWORD
                        // lArg3 is missing

                // program bug. Failure may cause some random (non fatal) results
                BG_CHK(ifrRecv == ifrMCF);              // only valid response in ECM mode

                if(ifrSent != ifrPPS_NULL)                      // not end-of-block(i.e. midpage)
                        ICommSendPageAck(pTG, TRUE);

                switch(ifrSent)
                {
                  case ifrPPS_NULL:             action = actionGONODE_IV;       // Same page. New block
                                                                break;
                  case ifrPPS_MPS:
                  case ifrPPS_PRI_MPS:  action = actionGONODE_IV;       // New page
                                                                break;
                  case ifrPPS_EOM:
                  case ifrPPS_PRI_EOM:  // After sending EOM, Receiver always goes
                                                        // back to sending NSF etc so we have to go
                                                        // back to NodeT to receive all that junk.
                                                        action = actionGONODE_T;
                                                        break;
                  case ifrPPS_EOP:
                  case ifrPPS_PRI_EOP:
                                                        // action = actionSUCCESS;
                                                        (MyDebugPrint(pTG,  LOG_ALL,  "ECM -- Send Done\r\n"));
                                                        ICommFailureCode(pTG, T30FAILSE_ECM_NOPAGES);
                                                        action = actionDCN;
                                                        break;
                  default:
                                                        ERRMSG((SZMOD "<<ERROR>> Dunno what we sent %d\r\n", ifrSent));
                                                        // program bug. hangup
                                                        BG_CHK(FALSE);
                                                        ICommFailureCode(pTG, T30FAILSE_BUG4);
                                                        action = actionDCN;
                                                        break;
                }
                // Can also return GO_D, GO_R1, GO_R2. Only restriction is
                // that GO_I is the only valid response to MPS sent followed
                // by MCF

                break;
          }

        /****** Transmitter Phase D (PIN/PIN stuff). Fig A-7/T.30 (sheet 2) ******/

#ifdef PRI
          case eventGOTPINPIP:
          {
                IFR ifrRecv = (IFR)wArg1;       // last received frame
                IFR ifrSent = (IFR)lArg2;       // the IFR was simply cast to DWORD
                // lArg3 is missing

                ERRMSG((SZMOD "<<ERROR>> Can't deal with PIN PIP\r\n"));
                ICommFailureCode(pTG, T30FAIL_BUG5);
                action = actionDCN;
                break;

                // must alert operator, check that handset has been lifted
                // and then return actionGOVOICE. If handest is not lifted
                // within T3 must return GO_A (???) or maybe GO_DCN (???) or
                // GO_D. Not sure what.
          }
          case eventVOICELINE:
          {
                // All Args are missing

                ERRMSG((SZMOD "<<ERROR>> Can't deal with VOICELINE\r\n"));
                ICommFailureCode(pTG, T30FAIL_BUG6);
                action = actionDCN;
                break;
                // must connect handset to phone line, wait until operator
                // finishes talking. Then return HANGUP, GO_T, GO_R1 (??)
                // or GO_R2 (??)
          }
#endif

        /****** Receiver Phase B. Fig A-7/T.30 (sheet 1) ******/

          case eventSENDDIS:
          {
                // wArg1 is 0
                // where to return the number of frames returned
                LPUWORD lpuwN = (LPUWORD)lArg2;
                // where to return a pointer to an array of pointers to
                // return frames
                LPLPLPFR lplplpfr = (LPLPLPFR)lArg3;


                // CreateNSFCSIDIS(npProt, lpuwN, lplplpfr);
                BG_CHK(npProt->fSendCapsInited);
                BG_CHK(npProt->fllSendCapsInited);
                BG_CHK(npProt->fHWCapsInited);
                BCtoNSFCSIDIS(pTG, &pTG->rfsSend, (NPBC)&npProt->SendCaps, &npProt->llSendCaps);
                *lpuwN = pTG->rfsSend.uNumFrames;
                *lplplpfr = pTG->rfsSend.rglpfr;

                action = actionSEND_DIS;
                break;
          }
          case eventSENDDTC:
          {
                // wArg1 is 0
                // where to return the number of frames returned
                LPUWORD lpuwN = (LPUWORD)lArg2;
                // where to return a pointer to an array of pointers to
                // return frames
                LPLPLPFR lplplpfr = (LPLPLPFR)lArg3;


                // CreateNSCCIGDTC(npProt, lpuwN, lplplpfr);
                BG_CHK(npProt->fSendPollReqInited);
                BG_CHK(npProt->fllSendCapsInited);
                BG_CHK(npProt->fHWCapsInited);
                BCtoNSCCIGDTC(pTG, &pTG->rfsSend, (NPBC)&npProt->SendPollReq, &npProt->llSendCaps);
                *lpuwN = pTG->rfsSend.uNumFrames;
                *lplplpfr = pTG->rfsSend.rglpfr;

                action = actionSEND_DTC;
                break;
          }

#ifdef PRI
          case eventQUERYLOCALINT:
          {
                // all Args are missing
                // return actionTRUE if a local interrupt is pending, else actionFALSE
                action = actionFALSE;
                break;
          }
#endif // PRI

        /*** Receiver Phase B. Main Command Loop. Fig A-7/T.30 (sheet 1&2) ***/

          case eventRECVCMD:
          {
                IFR ifrRecv = (IFR)wArg1;       // last received frame
                // lArg2 & lArg3 missing

        switch(ifrRecv)
                {
          case ifrDTC:
                        // flow chart says Goto D, but actually we need to decide if we
                        // have anything to send. So goto NodeA first
                        // return GONODE_D;
                        action = actionGONODE_A;
                        break;

                  case ifrDIS:
                        action = actionGONODE_A;
                        break;
                  case ifrDCS:
                  {
                        // Check the received DCS for compatibility with us
                        // set Recv Baud rate--no need. TCF already recvd by this time
                        // ET30ExtFunction(npProt->het30, ET30_SET_RECVDATASPEED, npProt->RemoteDCS.Baud);
                        action = actionGETTCF;
                        // only other valid action is HANGUP
                        break;
                  }
                  case ifrNSS:
                  {
                        // Check the received NSS for compatibility with us
                        // set Recv Baud rate--no need. TCF already recvd by this time
                        // ET30ExtFunction(npProt->het30, ET30_SET_RECVDATASPEED, npProt->RemoteDCS.Baud);
                        action = actionGETTCF;
                        // only other valid action is HANGUP
                        break;
                  }
                  default:
                        // program bug. hangup
                        BG_CHK(FALSE);
                        ICommFailureCode(pTG, T30FAIL_BUG7);
                        action = actionHANGUP;
                        break;
                }
                break;
          }

          case eventGOTTCF:
          {
                SWORD swErr = (SWORD)wArg1;     // errors per 1000
                // lArg2 & lArg3 missing

                (MyDebugPrint(pTG,  LOG_ALL,  "GOTTCF num of errors = %d\r\n", swErr));

                if(swErr >= 0)
                {
                        // very important!! Re-init the fPageOK flag in case we miss
                        // the page entirely, and jump into PhaseD this must be FALSE
                        // npProt->fPageOK = FALSE;
                        // done at start of PhaseC by calling ProtResetRecvPageAck()

                        action = actionSENDCFR; // just going along
                }
                else
                        action = actionSENDFTT;
                break;
          }

        /****** Receiver Phase C. Fig A-7/T.30 (sheet 1) ******/

        /***
          case eventSTARTRECV:
          {
                if(!StartNextRecvPage())
                {
                        ICommFailureCode(T30FAILR_BUG8);
                        action = actionDCN;
                }
                else
                        action = actionCONTINUE;
                break;
          }
        ***/

        /****** Receiver Phase D. Fig A-7/T.30 (sheet 1) ******/

#ifdef PRI
          case eventPRIQ:
          {
                IFR ifrRecv = (IFR)wArg1;       // last received frame
                // lArg2 & lArg3 missing

                /**
                        ifrRecv can be PRI-Q, PPS-PRI-Q, EOR-PRI-Q
                        alert operator etc.
                        can return SENDPIP, SENDPIN, GONODE_F, GO_RECVPOSTPAGE
                        If PPS-PRIQ can send only PIP not PIN
                        If EOR-PRIQ can send only PIN not PIP
                        or HANGUP. Have to combine the stuff on Fig A-18/T.30
                        (RHS) and on LHS of FigA-7/T.30 (sheet 2) (below node III)
                **/

                // not implemented
                BG_CHK(FALSE);
                break;
          }
#endif
          case eventRECVPOSTPAGECMD:
          {
                // IFR  ifrRecv = (IFR)wArg1;   // last received frame
                // lArg2 & lArg3 missing

                GetRecvPageAck(pTG);
                if( ! pTG->fPageIsBad)
                  action = actionSENDMCF;       // quality fine
                else
                  action = actionSENDRTN;       // quality unacceptable

                // can also return actionSENDPIP or actionSENDPIN in a local
                // interrupt is pending
                break;
          }

        /**----------------------- Exclusively ECM ----------------------------**/

          case event4THPPR:
          {
                USHORT  uFramesInBlock = (USHORT)wArg1;
                USHORT  uFramesSent = (USHORT)lArg2;
                USHORT  uNumBad, i, j;

                // program bug. Failure may cause some random (non fatal) results
                BG_CHK(npProt->fRecvdPPR);

                for(uNumBad=0, i=0; i<=uFramesInBlock; i++)
                {
                        j = (1 << (i % 8));
                        if(npProt->bRemotePPR[i/8] & j)
                        uNumBad++;
                }
                (MyDebugPrint(pTG,  LOG_ALL,  "4thPPR: FrameCount=%d FramesSent=%d NumBad=%d\r\n",
                        uFramesInBlock, uFramesSent, uNumBad));

                if(pTG->ProtParams.CTCAction == 1)
                {
                        ERRMSG((SZMOD "<<ERROR>> PPR: Too many bad frames\r\n"));
                        ICommFailureCode(pTG, T30FAILS_4PPR_ERRORS);
                        action = actionSENDEOR_EOP;     // give up
                        // No need for EOR stuff. If we give up on a file, we can't
                        // transmit the next page. Doesn't make sense.
                }
                else
                {
                        // drop speed
                        if(DropSendSpeed(pTG) != TRUE)
                        {
                                ERRMSG((SZMOD "<<ERROR>> PPR: Can't Drop speed any lower\r\n"));
                                ICommFailureCode(pTG, T30FAILS_4PPR_FALLBACK);
                                action = actionSENDEOR_EOP;
                        }
                        else
                                action = actionGONODE_ECMRETRANSMIT;
                }
                break;
          }

          default:
          {
                ERRMSG((SZMOD "<<ERROR>> Unknown Event = %d\r\n", event));
                ICommFailureCode(pTG, T30FAIL_BUG9);
                break;
          }
        }

//done:
        (MyDebugPrint(pTG,  LOG_ALL,  "WhatNext event %d returned %d\r\n", event, action));
        return action;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\main\timeouts.h ===
#ifndef MDDI    // to include fcomapi.h
#       include "fcomapi.h"
#endif


#ifdef MDDI             // timeouts

typedef struct tagTO {
        ULONG   ulStart;
        ULONG   ulTimeout;
        ULONG   ulEnd;
} TO, near* NPTO;

/****************** begin prototypes from timeouts.c *****************/
void TstartTimeOut(PThrdGlbl pTG, NPTO npto, ULONG ulTimeOut);
BOOL TcheckTimeOut(PThrdGlbl pTG, NPTO npto);
/****************** end prototypes from timeouts.c *****************/

#else //MDDI

#define TstartTimeOut(pTG, lpto, ulTime)             startTimeOut(pTG, lpto, ulTime)
#define TcheckTimeOut(pTG, lpto)                     checkTimeOut(pTG, lpto)

#endif //MDDI


#define WAITFORBUF_TIMEOUT      60000L
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\broadcast\adoid.h ===
//--------------------------------------------------------------------
// Microsoft ADO
//
// (c) 1996 Microsoft Corporation.  All Rights Reserved.
//
// @doc
//
// @module	adoid.h | ADO Guids
//
// @devnote None
//--------------------------------------------------------------------
#ifndef _ADOID_H_
#define _ADOID_H_

// The following range of 255 guids has been reserved for the base objects.
// 	00000200-0000-0010-8000-00AA006D2EA4 - 000002FF-0000-0010-8000-00AA006D2EA4
// If you need more then please take a range from daoguid.txt and update that file in

#define DEFINE_DAOGUID(name, l) \
    DEFINE_GUID(name, l, 0, 0x10, 0x80,0,0,0xAA,0,0x6D,0x2E,0xA4)

#define ADO_MAJOR	2		// major version of the ADO type library
#define ADO_VERSION	1.5

// Type library
DEFINE_DAOGUID(LIBID_CADO10,			0x00000200);
DEFINE_DAOGUID(LIBID_CADOR10,			0x00000300);

// Error
DEFINE_DAOGUID(IID_IADOError,            0x00000500);
DEFINE_DAOGUID(IID_IADOErrors,           0x00000501);

// Property
DEFINE_DAOGUID(IID_IADOProperty,         0x00000503);
DEFINE_DAOGUID(IID_IADOProperties,       0x00000504);

// Field
DEFINE_DAOGUID(IID_IADOField,            0x00000505);
DEFINE_DAOGUID(IID_IADOFields,           0x00000506);

// Command
DEFINE_DAOGUID(CLSID_CADOCommand,		0x00000507);
DEFINE_DAOGUID(IID_IADOCommand,			0x00000508);
DEFINE_DAOGUID(IID_IADOCommands,        0x00000509);

// Parameter
DEFINE_DAOGUID(CLSID_CADOParameter,		0x0000050B);
DEFINE_DAOGUID(IID_IADOParameter,        0x0000050C);
DEFINE_DAOGUID(IID_IADOParameters,       0x0000050D);

//Recordset
DEFINE_DAOGUID(CLSID_CADORecordset, 	 0x00000535);
DEFINE_DAOGUID(IID_IADORecordset,		 0x0000050E);
DEFINE_DAOGUID(IID_IADORecordsets,		 0x0000050F);
DEFINE_DAOGUID(IID_IADORecordsetConstruction,     0x00000283);

// Collections
DEFINE_DAOGUID(IID_IADOCollection,       0x00000512);
DEFINE_DAOGUID(IID_IADODynaCollection,   0x00000513);

// Connection
DEFINE_DAOGUID(CLSID_CADOConnection,	   0x00000514);
DEFINE_DAOGUID(IID_IADOConnection,		   0x00000515);
DEFINE_DAOGUID(IID_IADOConnections,		   0x00000518);

// Enums 
DEFINE_DAOGUID(IID_EnumCursorType,			0x0000051B);
DEFINE_DAOGUID(IID_EnumCursorOption,		0x0000051C);
DEFINE_DAOGUID(IID_EnumLockType,			0x0000051D);
DEFINE_DAOGUID(IID_EnumExecuteOption,		0x0000051E);
DEFINE_DAOGUID(IID_EnumDataType,			0x0000051F);
DEFINE_DAOGUID(IID_EnumConnectPrompt,		0x00000520);
DEFINE_DAOGUID(IID_EnumConnectMode,			0x00000521);
DEFINE_DAOGUID(IID_EnumPrepareOption,		0x00000522);
DEFINE_DAOGUID(IID_EnumIsolationLevel,		0x00000523);
DEFINE_DAOGUID(IID_EnumXactAttribute,		0x00000524);
DEFINE_DAOGUID(IID_EnumFieldAttribute,		0x00000525);
DEFINE_DAOGUID(IID_EnumEditMode,			0x00000526);
DEFINE_DAOGUID(IID_EnumRecordStatus,		0x00000527);
DEFINE_DAOGUID(IID_EnumPosition,			0x00000528);
DEFINE_DAOGUID(IID_EnumPropertyAttributes,	0x00000529);
DEFINE_DAOGUID(IID_EnumErrorValue,			0x0000052A);
DEFINE_DAOGUID(IID_EnumParameterAttributes,	0x0000052B);
DEFINE_DAOGUID(IID_EnumParameterDirection,	0x0000052C);
DEFINE_DAOGUID(IID_EnumFilterCriteria,		0x0000052D);
DEFINE_DAOGUID(IID_EnumCommandType,			0x0000052E);
DEFINE_DAOGUID(IID_EnumCursorLocation,		0x0000052F);
DEFINE_DAOGUID(IID_EnumEventStatus,			0x00000530);
DEFINE_DAOGUID(IID_EnumEventReason,			0x00000531);
DEFINE_DAOGUID(IID_EnumObjectState,			0x00000532);
DEFINE_DAOGUID(IID_EnumSchema,				0x00000533);
DEFINE_DAOGUID(IID_EnumMarshalOptions,		0x00000540);

#endif // _ADOID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\provider\t30\util\t30log.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    t30log.c

Abstract:

    Decodes faxt30.log

Author:

    Rafael Lisitsa (RafaelL) 2-Dec-1996


Revision History:

--*/


#define BUFSIZE   200000

#define D_LEFT    1
#define D_RIGHT   2

#include <stdio.h>
#include <stdlib.h>

#include <windows.h>


int _cdecl
main(
    int argc,
    char *argv[]
    )

{


    char    FileName1[400];
    char    FileName2[400];

    HANDLE  hf1;
    HANDLE  hf2;


    char    buf1    [BUFSIZE];
    char    c;
    int     fEof1;
    DWORD   BytesRet1=0;
    DWORD   BytesWritten;
    DWORD   i;


    printf("\nEnter T30 LOG SOURCE filename=>");
    scanf ("%s", FileName1);

    printf("\nEnter DESTINATION filename=>");
    scanf ("%s", FileName2);


    hf1 = CreateFile(FileName1, GENERIC_READ,  FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
    if (hf1 == INVALID_HANDLE_VALUE) {
        printf("\nError opening Source file");
        exit (1);
    }

    hf2 = CreateFile(FileName2, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, 0, NULL);
    if (hf2 == INVALID_HANDLE_VALUE) {
        printf("\nError opening Destination file");
        exit (1);
    }

    fEof1 = 0;


    while ( ! fEof1 ) {

        if (! ReadFile(hf1, buf1, BUFSIZE, &BytesRet1, NULL) ) {
            printf("\nError reading Source file");
            exit (1);
        }

        if (BytesRet1 != BUFSIZE) {
            fEof1 = 1;
        }

        for (i=0; i<BytesRet1; i++) {
            c = buf1[i];
            buf1[i] = ( (c << 4 ) & 0xf0 ) | ( (c >> 4) & 0x0f );

        }

        if (!WriteFile(hf2, buf1, BytesRet1, &BytesWritten, NULL) ) {
            printf("\nError writing Dest. file");
            exit (1);
        }

    }

    printf("\nDone !");

    return (1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\broadcast\broadcst.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

   simple.c

Abstract:

    This module implements a command line broadcast fax utility 
    
--*/


#include <windows.h>
#include <winbase.h>
#include <stdio.h>
#include <stdlib.h>
#include <winfax.h>
#include <tchar.h>
#include <assert.h>
#include <shellapi.h>
#include <initguid.h>
#include "adoint.h"
#include "adoid.h"

//
// simple debug macro, get's compiled out in release version
//    
#ifdef DBG
   TCHAR   szDebugBuffer[128];
   #define DEBUG(parm1,parm2)\
            {\
                wsprintf(szDebugBuffer, TEXT(parm1), parm2);\
                OutputDebugString(szDebugBuffer);\
            }
#else   
   #define DEBUG(parm1,parm2)
#endif


//
// prototypes
//
VOID CALLBACK GetRecipientDataFromDb(ADORecordset*, DWORD, LPTSTR, LPTSTR );
BOOL CALLBACK FaxRecipientCallbackFunction( HANDLE FaxHandle,
                                   DWORD RecipientNumber,
                                   LPVOID Context,
                                   PFAX_JOB_PARAMW JobParams,
                                   PFAX_COVERPAGE_INFOW CoverpageInfo
                                 );

ADORecordset* InitializeDb(VOID);

//
// globals
//
ADORecordset* pRecordSet;
HANDLE hEvent;


void GiveUsage(
   LPTSTR AppName
   )
/*++

Routine Description:

    prints out usage

Arguments:

    AppName - string representing name of app


Return Value:

    none.                                             

--*/

{
   _tprintf( TEXT("Usage : %s /d <full path to doc> /n --send a fax to each user in database query\n"),AppName);
   _tprintf( TEXT("Usage : %s /? -- this message\n"),AppName);

}



int _cdecl
main(
   int argc,
   char *argvA[]
   ) 
/*++

Routine Description:

    Entry point to the setup program

Arguments:

    argc - Number of args.
    argvA - the commandline arguments.


Return Value:


--*/
{
   LPTSTR *argv;
   int argcount = 0;
   TCHAR Document[MAX_PATH] = {0};   
   HANDLE hFax;   
   DWORD FaxJobId;   
   BOOL bTerminate = FALSE;
   HANDLE hPort;
   

   //
   // do commandline stuff
   //
#ifdef UNICODE
   argv = CommandLineToArgvW( GetCommandLine(), &argc );
#else
   argv = argvA;
#endif

   DEBUG ("Number of arguments = %d\n",argc);
   for (argcount=0;argcount<argc;argcount++) {
      DEBUG ("Arg %d:",argcount);
      DEBUG (" %s\n",argv[argcount]);
   }

   // check for commandline switches
   for (argcount=0; argcount<argc; argcount++) {
      if ((argv[argcount][0] == L'/') || (argv[argcount][0] == L'-')) {
         switch (towlower(argv[argcount][1])) {
            case 'd':
               lstrcpy(Document, argv[argcount+1]);
               break;
            case '?':
               GiveUsage(argv[0]);
               return 0;
            default:
               break;
         }
      }
   }

   if (!Document[0]) {
      _tprintf( TEXT("Missing args.\n") );
      GiveUsage(argv[0]);
      return -1;
   }

   CoInitialize(NULL);

   hEvent = CreateEvent(NULL,FALSE,FALSE,NULL);

   //
   // initialize the db
   //
   pRecordSet = InitializeDb();
   if (!pRecordSet) {
      _tprintf( TEXT("Problems initializing Database, check data source\n") );
      CoUninitialize();
      return -1;
   }

   //
   // connect to fax service
   //
   if (!FaxConnectFaxServer(NULL,&hFax)) {
      _tprintf( TEXT("FaxConnectFaxServer failed, ec = %d\n"),GetLastError() );
      CoUninitialize();
      return -1;
   }

   assert (hFax != NULL);
                    
   //
   // start the broadcast
   //
   if (!FaxSendDocumentForBroadcast( hFax, 
                                     Document,
                                     &FaxJobId,
                                     FaxRecipientCallbackFunction,
                                     pRecordSet ) ) {
      _tprintf( TEXT("FaxSendDocumentforBroadcast failed, ec = %d \n"), GetLastError() );
      FaxClose( hFax );      
      pRecordSet->Release();
      CoUninitialize();
      return -1;
   }

   //
   // wait for the callback to complete
   //
   WaitForSingleObject( hEvent, INFINITE );

   _tprintf( TEXT("Queued document %s to all recipients\n"), Document);
   
   //
   // cleanup
   //
   FaxClose( hFax );
   pRecordSet->Release();
   CoUninitialize();

   return 1;
}


LPTSTR
StringDup(
   LPTSTR Source
   )
/*++

Routine Description:

    allocates memory off of the stack for a string and copies string to that memory

Arguments:

    Source - string to be copied


Return Value:

    NULL for error, else a copy of the string, alloced off of the stack

--*/

{
   LPTSTR dest;

   if (!Source) {
      return NULL;
   }

   dest = (LPTSTR) HeapAlloc( GetProcessHeap(),0, (lstrlen(Source) +1)*sizeof(TCHAR) );
   if (!dest) {
      return NULL;
   }

   lstrcpy( dest, Source );

   return dest;

}

BOOL CALLBACK
FaxRecipientCallbackFunction(
   HANDLE FaxHandle,
   DWORD RecipientNumber,
   LPVOID Context,
   PFAX_JOB_PARAMW JobParams,
   PFAX_COVERPAGE_INFOW CoverpageInfo OPTIONAL
   )
/*++

Routine Description:

    main faxback callback function

Arguments:

    FaxHandle - handle to fax service
    RecipientNumber - number of times this function has been called
    Context - context info (in our case, a ADORecordset pointer)
    JobParams - pointer to a FAX_JOB_PARAM structure to receive our information
    CoverpageInfo - pointer to a FAX_COVERPAGE_INFO structure to receive our information

Return Value:

    TRUE -- use the data we set, FALSE, done sending data back to fax service.                                             

--*/

{
   TCHAR RecipientNameBuf[128];
   TCHAR RecipientNumberBuf[64];   

   //
   // only send 3 faxes total (arbitrary number)
   //
   if (RecipientNumber > 3) {
      SetEvent( hEvent );
      return FALSE;
   }


   GetRecipientDataFromDb( (ADORecordset*)Context,
                           RecipientNumber,
                           RecipientNameBuf,
                           RecipientNumberBuf                    
                         );

   CoverpageInfo = NULL;
   JobParams->RecipientNumber = StringDup(RecipientNumberBuf);
   JobParams->RecipientName = StringDup(RecipientNameBuf);   

   return TRUE;
   
}
                             

ADORecordset* 
InitializeDb(
   VOID
   )
/*++

Routine Description:

    initailizes our database connection which holds the recipient data (uses ADO)

Arguments:

    none.

Return Value:

    NULL on error, else an initialized ADORecordSet object (ready to call GetRows).                                             

--*/

{
   ADORecordset* prs = NULL;
   ADOConnection* pc = NULL;   
   IDispatch *pdisp = NULL;
   HRESULT hr;
   VARIANT vSource, vCommand;   
   BSTR ConnectionString=NULL,
        UserID=NULL,
        Password=NULL,
        SqlStmt=NULL;

   //
   // get pointers to the required interfaces
   //
   hr = CoCreateInstance( CLSID_CADOConnection,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IADOConnection, 
                          (void **)&pc );
   if (FAILED(hr)) {
      _tprintf( TEXT("CoCreateInstance failed, ec = %x\n"), hr );
      return NULL;
   }

   hr = CoCreateInstance( CLSID_CADORecordset,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IADORecordset, 
                          (void **)&prs );
   if (FAILED(hr)) {
      _tprintf( TEXT("CoCreateInstance failed, ec = %x\n"), hr );
      return NULL;
   }

   assert(pc != NULL);
   assert(prs != NULL);

   ConnectionString = SysAllocString( TEXT("nwind_odbc") );
   UserID = SysAllocString( TEXT("") );
   Password = SysAllocString( TEXT("") );
   SqlStmt = SysAllocString( TEXT("SELECT LastName,FirstName FROM Employees") );
   
   hr = pc->QueryInterface(IID_IDispatch,(void**) &pdisp);
   if (FAILED(hr)) {
      _tprintf( TEXT("couldn't qi, ec = %x\n"), hr);
      goto error_exit;
   }

   //
   // open the connection
   //
   hr = pc->Open( ConnectionString, UserID, Password, -1 ) ;
   if (FAILED(hr)) {
      _tprintf( TEXT("Open failed, ec = %x\n"), hr );
      goto error_exit;
   }

   hr = prs->put_Source(SqlStmt);
   if (FAILED(hr)) {
      _tprintf( TEXT("put_Source failed, ec = %x\n"), hr );
      goto error_exit;
   }
 
   hr = prs->putref_ActiveConnection(pdisp);
   if (FAILED(hr)) {
      _tprintf( TEXT("putref_ActiveConnection failed, ec = %x\n"), hr );
      goto error_exit;
   }

   vCommand.vt = VT_BSTR;
   vCommand.bstrVal = SqlStmt;

   vSource.vt = VT_DISPATCH;
   
   //vSource.punkVal = pdisp;
   vSource.pdispVal = pdisp;

   //vNull.vt = VT_ERROR;
   //vNull.scode = DISP_E_PARAMNOTFOUND;

   //
   // open the recordset
   //
   hr = prs->Open( vCommand, //VARIANT
                   vSource, //VARIANT
                   adOpenForwardOnly, //CursorTypeEnum
                   adLockReadOnly, //LockTypeEnum
                   adCmdUnknown // LONG
                   );

   if (FAILED(hr)) {
      _tprintf( TEXT("Open failed, ec = %x\n"), hr);
      pdisp->Release();
      goto error_exit;
   }   

   pdisp->Release();
   //
   // cleanup and return
   //
   pc->Release();

   SysFreeString( ConnectionString );
   SysFreeString( UserID );          
   SysFreeString( Password );        
   SysFreeString( SqlStmt );         

   return prs;

error_exit:
   //
   // cleanup
   //
   if (ConnectionString) SysFreeString( ConnectionString );
   if (UserID)           SysFreeString( UserID );
   if (Password)         SysFreeString( Password );
   if (SqlStmt)          SysFreeString( SqlStmt );

   if (prs) prs->Release();
   if (pc)  pc->Release();
   
   return NULL;

}


VOID CALLBACK
GetRecipientDataFromDb(
   ADORecordset* pRecordSet,
   DWORD RowToRetreive,
   LPTSTR RecipientNameBuffer,
   LPTSTR RecipientNumberBuffer   
   )
/*++

Routine Description:

    retreives the appropriate data from the database (uses ADO)

Arguments:

    pRecordSet - ADORecordset pointer for our database
    RowToRetreive - which row should we retreive
    RecipientNameBuffer - buffer to receive recipient name
    RecipientNumberBuffer - buffer to receive recipient number

Return Value:

    none. on error the buffers are set to an empty string (NULL)

--*/

{
   static long CurrentRow = 0;
   static long TotalRows;
   VARIANT vBookmark, rgvFields;
   static VARIANT cRows;
   VARIANT varField, varNewField;
   long Index[2];
   HRESULT hr;

   //
   // the first we're called, let's retrieve the data and then just let it stick around after that point.
   //
   if (CurrentRow == 0) {
      //
      //Start from the current place
      //
      vBookmark.vt = VT_ERROR;
      vBookmark.scode = DISP_E_PARAMNOTFOUND;
      
      //
      // Get all columns
      //
      rgvFields.vt = VT_ERROR;
      rgvFields.scode = DISP_E_PARAMNOTFOUND;

      assert(pRecordSet != NULL);

      //
      // get the rows
      //
      hr = pRecordSet->GetRows(adGetRowsRest,
                               vBookmark,
                               rgvFields,
                               &cRows );
      if (FAILED(hr)) {
         _tprintf( TEXT("GetRows failed, ec = %x\n"), hr );
         *RecipientNameBuffer = 0;
         *RecipientNumberBuffer = 0;
         return;
      }

      //
      // find out the number of rows retreived
      //
      hr = SafeArrayGetUBound(cRows.parray, 2, &TotalRows);
      if (FAILED(hr)) {
         _tprintf( TEXT("SafeArrayGetUBound failed, ec=%x\n"), hr );
         *RecipientNameBuffer = 0;
         *RecipientNumberBuffer = 0;
         return;
      }

      _tprintf( TEXT("There are %d rows in our datasource\n"), TotalRows );

   }

   //
   // data is retrieved at this point. now, get the data and stick it into the caller's buffers
   //

   if ((LONG)RowToRetreive >TotalRows) {
      *RecipientNumberBuffer = 0;
      *RecipientNameBuffer = 0;
      return;
   }   

   //
   // column major order for a safearray
   //
   assert(RowToRetreive == CurrentRow);
   Index[1]=CurrentRow;

   for (int i = 0; i< 2; i++) {
       
       Index[0]=i;
       
       //
       // get element
       //
       hr = SafeArrayGetElement( cRows.parray, &Index[0], &varField );
       if (FAILED(hr)) {
          _tprintf( TEXT("SafeArrayGetElement failed, ec=hr\n"), hr );
          *RecipientNameBuffer = 0;
          *RecipientNumberBuffer = 0;
          return;
       }

       //
       // make sure it's a string
       //
       hr = VariantChangeType(&varNewField, &varField, 0, VT_BSTR);
       if (FAILED(hr)) {
          _tprintf( TEXT("VariantChangeType failed, ec=hr\n"), hr );
          *RecipientNameBuffer = 0;
          *RecipientNumberBuffer = 0;
          return;
       }

       //
       // copy the data
       //
       if (i == 0) {
          lstrcpy(RecipientNameBuffer, varNewField.bstrVal);
       } else {
          lstrcpy(RecipientNumberBuffer, varNewField.bstrVal);
       }
       
   }

   CurrentRow++;

   return;
   

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\broadcast\adoint.h ===
//--------------------------------------------------------------------
// Microsoft ADO
//
// (c) 1996 Microsoft Corporation.  All Rights Reserved.
//
// @doc
//
// @module	adoint.h | ADO Interface header
//
// @devnote None
//--------------------------------------------------------------------
#ifndef _ADOINT_H_
#define _ADOINT_H_

#ifndef _INC_TCHAR
#include <tchar.h>
#endif

#if _MSC_VER >= 1100
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif


/* this ALWAYS GENERATED file contains the definitions for the interfaces */
/* File created by MIDL compiler version 3.01.75 */
/* at Thu Dec 04 08:00:50 1997
 */
/* Compiler settings for m_bobj.odl:
    Os (OptLev=s), W4, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef __m_bobj_h__
#define __m_bobj_h__
#ifdef __cplusplus
extern "C"{
#endif 
/* Forward Declarations */ 
#ifndef ___ADOCollection_FWD_DEFINED__
#define ___ADOCollection_FWD_DEFINED__
typedef interface _ADOCollection _ADOCollection;
#endif 	/* ___ADOCollection_FWD_DEFINED__ */
#ifndef ___ADODynaCollection_FWD_DEFINED__
#define ___ADODynaCollection_FWD_DEFINED__
typedef interface _ADODynaCollection _ADODynaCollection;
#endif 	/* ___ADODynaCollection_FWD_DEFINED__ */
#ifndef ___ADO_FWD_DEFINED__
#define ___ADO_FWD_DEFINED__
typedef interface _ADO _ADO;
#endif 	/* ___ADO_FWD_DEFINED__ */
#ifndef __Error_FWD_DEFINED__
#define __Error_FWD_DEFINED__
typedef interface ADOError Error;
#endif 	/* __Error_FWD_DEFINED__ */
#ifndef __Errors_FWD_DEFINED__
#define __Errors_FWD_DEFINED__
typedef interface ADOErrors Errors;
#endif 	/* __Errors_FWD_DEFINED__ */
#ifndef ___Command_FWD_DEFINED__
#define ___Command_FWD_DEFINED__
typedef interface _ADOCommand _Command;
#endif 	/* ___Command_FWD_DEFINED__ */
#ifndef ___Connection_FWD_DEFINED__
#define ___Connection_FWD_DEFINED__
typedef interface _ADOConnection _Connection;
#endif 	/* ___Connection_FWD_DEFINED__ */
#ifndef __ADOConnectionConstruction_FWD_DEFINED__
#define __ADOConnectionConstruction_FWD_DEFINED__
typedef interface ADOConnectionConstruction ADOConnectionConstruction;
#endif 	/* __ADOConnectionConstruction_FWD_DEFINED__ */
#ifndef __Connection_FWD_DEFINED__
#define __Connection_FWD_DEFINED__
#ifdef __cplusplus
typedef class ADOConnection Connection;
#else
typedef struct ADOConnection Connection;
#endif /* __cplusplus */
#endif 	/* __Connection_FWD_DEFINED__ */
#ifndef __Command_FWD_DEFINED__
#define __Command_FWD_DEFINED__
#ifdef __cplusplus
typedef class ADOCommand Command;
#else
typedef struct ADOCommand Command;
#endif /* __cplusplus */
#endif 	/* __Command_FWD_DEFINED__ */
#ifndef ___Recordset_FWD_DEFINED__
#define ___Recordset_FWD_DEFINED__
typedef interface _ADORecordset _Recordset;
#endif 	/* ___Recordset_FWD_DEFINED__ */
#ifndef __Recordset_FWD_DEFINED__
#define __Recordset_FWD_DEFINED__
#ifdef __cplusplus
typedef class ADORecordset Recordset;
#else
typedef struct ADORecordset Recordset;
#endif /* __cplusplus */
#endif 	/* __Recordset_FWD_DEFINED__ */
#ifndef __ADORecordsetConstruction_FWD_DEFINED__
#define __ADORecordsetConstruction_FWD_DEFINED__
typedef interface ADORecordsetConstruction ADORecordsetConstruction;
#endif 	/* __ADORecordsetConstruction_FWD_DEFINED__ */
#ifndef __Field_FWD_DEFINED__
#define __Field_FWD_DEFINED__
typedef interface ADOField Field;
#endif 	/* __Field_FWD_DEFINED__ */
#ifndef __Fields_FWD_DEFINED__
#define __Fields_FWD_DEFINED__
typedef interface ADOFields Fields;
#endif 	/* __Fields_FWD_DEFINED__ */
#ifndef ___Parameter_FWD_DEFINED__
#define ___Parameter_FWD_DEFINED__
typedef interface _ADOParameter _Parameter;
#endif 	/* ___Parameter_FWD_DEFINED__ */
#ifndef __Parameter_FWD_DEFINED__
#define __Parameter_FWD_DEFINED__
#ifdef __cplusplus
typedef class ADOParameter Parameter;
#else
typedef struct ADOParameter Parameter;
#endif /* __cplusplus */
#endif 	/* __Parameter_FWD_DEFINED__ */
#ifndef __Parameters_FWD_DEFINED__
#define __Parameters_FWD_DEFINED__
typedef interface ADOParameters Parameters;
#endif 	/* __Parameters_FWD_DEFINED__ */
#ifndef __Property_FWD_DEFINED__
#define __Property_FWD_DEFINED__
typedef interface ADOProperty Property;
#endif 	/* __Property_FWD_DEFINED__ */
#ifndef __Properties_FWD_DEFINED__
#define __Properties_FWD_DEFINED__
typedef interface ADOProperties Properties;
#endif 	/* __Properties_FWD_DEFINED__ */
void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 
/****************************************
 * Generated header for interface: __MIDL_itf_m_bobj_0000
 * at Thu Dec 04 08:00:50 1997
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 
extern RPC_IF_HANDLE __MIDL_itf_m_bobj_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_m_bobj_0000_v0_0_s_ifspec;
#ifndef __ADODB_LIBRARY_DEFINED__
#define __ADODB_LIBRARY_DEFINED__
/****************************************
 * Generated header for library: ADODB
 * at Thu Dec 04 08:00:50 1997
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][helpcontext][version][helpfile][uuid] */ 
typedef /* [uuid][public] */ 
enum CursorTypeEnum
    {	adOpenUnspecified	= -1,
	adOpenForwardOnly	= 0,
	adOpenKeyset	= 1,
	adOpenDynamic	= 2,
	adOpenStatic	= 3
    }	CursorTypeEnum;
typedef /* [uuid] */ 
enum CursorOptionEnum
    {	adHoldRecords	= 0x100,
	adMovePrevious	= 0x200,
	adAddNew	= 0x1000400,
	adDelete	= 0x1000800,
	adUpdate	= 0x1008000,
	adBookmark	= 0x2000,
	adApproxPosition	= 0x4000,
	adUpdateBatch	= 0x10000,
	adResync	= 0x20000
    }	CursorOptionEnum;
typedef /* [uuid] */ 
enum LockTypeEnum
    {	adLockUnspecified	= -1,
	adLockReadOnly	= 1,
	adLockPessimistic	= 2,
	adLockOptimistic	= 3,
	adLockBatchOptimistic	= 4
    }	LockTypeEnum;
typedef /* [hidden][uuid] */ 
enum ExecuteOptionEnum
    {	adOptionUnspecified	= -1
    }	ExecuteOptionEnum;
typedef /* [uuid] */ 
enum ObjectStateEnum
    {	adStateClosed	= 0,
	adStateOpen	= 0x1
    }	ObjectStateEnum;
typedef /* [uuid] */ 
enum CursorLocationEnum
    {	adUseNone	= 1,
	adUseServer	= 2,
	adUseClient	= 3,
	adUseClientBatch	= 3
    }	CursorLocationEnum;
typedef /* [uuid] */ 
enum DataTypeEnum
    {	adEmpty	= 0,
	adTinyInt	= 16,
	adSmallInt	= 2,
	adInteger	= 3,
	adBigInt	= 20,
	adUnsignedTinyInt	= 17,
	adUnsignedSmallInt	= 18,
	adUnsignedInt	= 19,
	adUnsignedBigInt	= 21,
	adSingle	= 4,
	adDouble	= 5,
	adCurrency	= 6,
	adDecimal	= 14,
	adNumeric	= 131,
	adBoolean	= 11,
	adError	= 10,
	adUserDefined	= 132,
	adVariant	= 12,
	adIDispatch	= 9,
	adIUnknown	= 13,
	adGUID	= 72,
	adDate	= 7,
	adDBDate	= 133,
	adDBTime	= 134,
	adDBTimeStamp	= 135,
	adBSTR	= 8,
	adChar	= 129,
	adVarChar	= 200,
	adLongVarChar	= 201,
	adWChar	= 130,
	adVarWChar	= 202,
	adLongVarWChar	= 203,
	adBinary	= 128,
	adVarBinary	= 204,
	adLongVarBinary	= 205
    }	DataTypeEnum;
typedef /* [uuid] */ 
enum FieldAttributeEnum
    {	adFldMayDefer	= 0x2,
	adFldUpdatable	= 0x4,
	adFldUnknownUpdatable	= 0x8,
	adFldFixed	= 0x10,
	adFldIsNullable	= 0x20,
	adFldMayBeNull	= 0x40,
	adFldLong	= 0x80,
	adFldRowID	= 0x100,
	adFldRowVersion	= 0x200,
	adFldCacheDeferred	= 0x1000
    }	FieldAttributeEnum;
typedef /* [uuid] */ 
enum EditModeEnum
    {	adEditNone	= 0,
	adEditInProgress	= 0x1,
	adEditAdd	= 0x2,
	adEditDelete	= 0x4
    }	EditModeEnum;
typedef /* [uuid] */ 
enum RecordStatusEnum
    {	adRecOK	= 0,
	adRecNew	= 0x1,
	adRecModified	= 0x2,
	adRecDeleted	= 0x4,
	adRecUnmodified	= 0x8,
	adRecInvalid	= 0x10,
	adRecMultipleChanges	= 0x40,
	adRecPendingChanges	= 0x80,
	adRecCanceled	= 0x100,
	adRecCantRelease	= 0x400,
	adRecConcurrencyViolation	= 0x800,
	adRecIntegrityViolation	= 0x1000,
	adRecMaxChangesExceeded	= 0x2000,
	adRecObjectOpen	= 0x4000,
	adRecOutOfMemory	= 0x8000,
	adRecPermissionDenied	= 0x10000,
	adRecSchemaViolation	= 0x20000,
	adRecDBDeleted	= 0x40000
    }	RecordStatusEnum;
typedef 
enum GetRowsOptionEnum
    {	adGetRowsRest	= -1
    }	GetRowsOptionEnum;
typedef /* [uuid] */ 
enum PositionEnum
    {	adPosUnknown	= -1,
	adPosBOF	= -2,
	adPosEOF	= -3
    }	PositionEnum;
typedef 
enum BookmarkEnum
    {	adBookmarkCurrent	= 0,
	adBookmarkFirst	= 1,
	adBookmarkLast	= 2
    }	BookmarkEnum;
typedef /* [uuid] */ 
enum MarshalOptionsEnum
    {	adMarshalAll	= 0,
	adMarshalModifiedOnly	= 1
    }	MarshalOptionsEnum;
typedef 
enum AffectEnum
    {	adAffectCurrent	= 1,
	adAffectGroup	= 2,
	adAffectAll	= 3
    }	AffectEnum;
typedef 
enum FilterGroupEnum
    {	adFilterNone	= 0,
	adFilterPendingRecords	= 1,
	adFilterAffectedRecords	= 2,
	adFilterFetchedRecords	= 3,
	adFilterPredicate	= 4
    }	FilterGroupEnum;
typedef /* [hidden] */ 
enum SearchDirection
    {	adSearchForward	= 1,
	adSearchBackward	= -1
    }	SearchDirectionEnum;
typedef /* [uuid] */ 
enum ConnectPromptEnum
    {	adPromptAlways	= 1,
	adPromptComplete	= 2,
	adPromptCompleteRequired	= 3,
	adPromptNever	= 4
    }	ConnectPromptEnum;
typedef /* [uuid] */ 
enum ConnectModeEnum
    {	adModeUnknown	= 0,
	adModeRead	= 1,
	adModeWrite	= 2,
	adModeReadWrite	= 3,
	adModeShareDenyRead	= 4,
	adModeShareDenyWrite	= 8,
	adModeShareExclusive	= 0xc,
	adModeShareDenyNone	= 0x10
    }	ConnectModeEnum;
typedef /* [uuid] */ 
enum IsolationLevelEnum
    {	adXactUnspecified	= 0xffffffff,
	adXactChaos	= 0x10,
	adXactReadUncommitted	= 0x100,
	adXactBrowse	= 0x100,
	adXactCursorStability	= 0x1000,
	adXactReadCommitted	= 0x1000,
	adXactRepeatableRead	= 0x10000,
	adXactSerializable	= 0x100000,
	adXactIsolated	= 0x100000
    }	IsolationLevelEnum;
typedef /* [uuid] */ 
enum XactAttributeEnum
    {	adXactCommitRetaining	= 0x20000,
	adXactAbortRetaining	= 0x40000
    }	XactAttributeEnum;
typedef /* [uuid] */ 
enum PropertyAttributesEnum
    {	adPropNotSupported	= 0,
	adPropRequired	= 0x1,
	adPropOptional	= 0x2,
	adPropRead	= 0x200,
	adPropWrite	= 0x400
    }	PropertyAttributesEnum;
typedef /* [uuid] */ 
enum ErrorValueEnum
    {	adErrInvalidArgument	=     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CONTROL, 0xbb9),
	adErrNoCurrentRecord	=     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CONTROL, 0xbcd),
	adErrIllegalOperation	=     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CONTROL, 0xc93),
	adErrInTransaction	=     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CONTROL, 0xcae),
	adErrFeatureNotAvailable	=     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CONTROL, 0xcb3),
	adErrItemNotFound	=     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CONTROL, 0xcc1),
	adErrObjectInADOCollection	=     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CONTROL, 0xd27),
	adErrObjectNotSet	=     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CONTROL, 0xd5c),
	adErrDataConversion	=     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CONTROL, 0xd5d),
	adErrObjectClosed	=     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CONTROL, 0xe78),
	adErrObjectOpen	=     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CONTROL, 0xe79),
	adErrProviderNotFound	=     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CONTROL, 0xe7a),
	adErrBoundToCommand	=     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CONTROL, 0xe7b),
	adErrInvalidParamInfo	=     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CONTROL, 0xe7c),
	adErrInvalidConnection	=     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CONTROL, 0xe7d),
    }	ErrorValueEnum;
typedef /* [uuid] */ 
enum ParameterAttributesEnum
    {	adParamSigned	= 0x10,
	adParamNullable	= 0x40,
	adParamLong	= 0x80
    }	ParameterAttributesEnum;
typedef /* [uuid] */ 
enum ParameterDirectionEnum
    {	adParamUnknown	= 0,
	adParamInput	= 0x1,
	adParamOutput	= 0x2,
	adParamInputOutput	= 0x3,
	adParamReturnValue	= 0x4
    }	ParameterDirectionEnum;
typedef /* [uuid] */ 
enum CommandTypeEnum
    {	adCmdUnspecified	= -1,
	adCmdUnknown	= 0x8,
	adCmdText	= 0x1,
	adCmdTable	= 0x2,
	adCmdStoredProc	= 0x4
    }	CommandTypeEnum;
typedef /* [uuid] */ 
enum SchemaEnum
    {	adSchemaProviderSpecific	= -1,
	adSchemaAsserts	= 0,
	adSchemaCatalogs	= 1,
	adSchemaCharacterSets	= 2,
	adSchemaCollations	= 3,
	adSchemaColumns	= 4,
	adSchemaCheckConstraints	= 5,
	adSchemaConstraintColumnUsage	= 6,
	adSchemaConstraintTableUsage	= 7,
	adSchemaKeyColumnUsage	= 8,
	adSchemaReferentialContraints	= 9,
	adSchemaTableConstraints	= 10,
	adSchemaColumnsDomainUsage	= 11,
	adSchemaIndexes	= 12,
	adSchemaColumnPrivileges	= 13,
	adSchemaTablePrivileges	= 14,
	adSchemaUsagePrivileges	= 15,
	adSchemaProcedures	= 16,
	adSchemaSchemata	= 17,
	adSchemaSQLLanguages	= 18,
	adSchemaStatistics	= 19,
	adSchemaTables	= 20,
	adSchemaTranslations	= 21,
	adSchemaProviderTypes	= 22,
	adSchemaViews	= 23,
	adSchemaViewColumnUsage	= 24,
	adSchemaViewTableUsage	= 25,
	adSchemaProcedureParameters	= 26,
	adSchemaForeignKeys	= 27,
	adSchemaPrimaryKeys	= 28,
	adSchemaProcedureColumns	= 29
    }	SchemaEnum;
EXTERN_C const IID LIBID_ADODB;
#ifndef ___ADOCollection_INTERFACE_DEFINED__
#define ___ADOCollection_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: _ADOCollection
 * at Thu Dec 04 08:00:50 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][uuid][nonextensible][dual] */ 
EXTERN_C const IID IID__ADOCollection;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("00000512-0000-0010-8000-00AA006D2EA4")
    _ADOCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][helpcontext][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *c) = 0;
        
        virtual /* [id][restricted] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual /* [helpstring][helpcontext] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct _ADOCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _ADOCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _ADOCollection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _ADOCollection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _ADOCollection __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _ADOCollection __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _ADOCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _ADOCollection __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][helpcontext][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            _ADOCollection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *c);
        
        /* [id][restricted] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_NewEnum )( 
            _ADOCollection __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [helpstring][helpcontext] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            _ADOCollection __RPC_FAR * This);
        
        END_INTERFACE
    } _ADOCollectionVtbl;
    interface _ADOCollection
    {
        CONST_VTBL struct _ADOCollectionVtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define _ADOCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define _ADOCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define _ADOCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define _ADOCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)
#define _ADOCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define _ADOCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define _ADOCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define _Collection_get_Count(This,c)	\
    (This)->lpVtbl -> get_Count(This,c)
#define _ADOCollection__NewEnum(This,ppvObject)	\
    (This)->lpVtbl -> _NewEnum(This,ppvObject)
#define _ADOCollection_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [helpstring][helpcontext][propget] */ HRESULT STDMETHODCALLTYPE _Collection_get_Count_Proxy( 
    _ADOCollection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *c);
void __RPC_STUB _Collection_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][restricted] */ HRESULT STDMETHODCALLTYPE _ADOCollection__NewEnum_Proxy( 
    _ADOCollection __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);
void __RPC_STUB _ADOCollection__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext] */ HRESULT STDMETHODCALLTYPE _ADOCollection_Refresh_Proxy( 
    _ADOCollection __RPC_FAR * This);
void __RPC_STUB _ADOCollection_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* ___ADOCollection_INTERFACE_DEFINED__ */
#ifndef ___ADODynaCollection_INTERFACE_DEFINED__
#define ___ADODynaCollection_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: _ADODynaCollection
 * at Thu Dec 04 08:00:50 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][uuid][nonextensible][dual] */ 
EXTERN_C const IID IID__ADODynaCollection;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("00000513-0000-0010-8000-00AA006D2EA4")
_ADODynaCollection : public _ADOCollection
    {
    public:
        virtual /* [helpstring][helpcontext] */ HRESULT STDMETHODCALLTYPE Append( 
            /* [in] */ IDispatch __RPC_FAR *Object) = 0;
        
        virtual /* [helpstring][helpcontext] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ VARIANT Index) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct _ADODynaCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _ADODynaCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _ADODynaCollection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _ADODynaCollection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _ADODynaCollection __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _ADODynaCollection __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _ADODynaCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _ADODynaCollection __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][helpcontext][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            _ADODynaCollection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *c);
        
        /* [id][restricted] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_NewEnum )( 
            _ADODynaCollection __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [helpstring][helpcontext] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            _ADODynaCollection __RPC_FAR * This);
        
        /* [helpstring][helpcontext] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Append )( 
            _ADODynaCollection __RPC_FAR * This,
            /* [in] */ IDispatch __RPC_FAR *Object);
        
        /* [helpstring][helpcontext] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            _ADODynaCollection __RPC_FAR * This,
            /* [in] */ VARIANT Index);
        
        END_INTERFACE
    } _ADODynaCollectionVtbl;
    interface _ADODynaCollection
    {
        CONST_VTBL struct _ADODynaCollectionVtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define _ADODynaCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define _ADODynaCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define _ADODynaCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define _ADODynaCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)
#define _ADODynaCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define _ADODynaCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define _ADODynaCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define _DynaCollection_get_Count(This,c)	\
    (This)->lpVtbl -> get_Count(This,c)
#define _ADODynaCollection__NewEnum(This,ppvObject)	\
    (This)->lpVtbl -> _NewEnum(This,ppvObject)
#define _ADODynaCollection_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)
#define _ADODynaCollection_Append(This,Object)	\
    (This)->lpVtbl -> Append(This,Object)
#define _ADODynaCollection_Delete(This,Index)	\
    (This)->lpVtbl -> Delete(This,Index)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [helpstring][helpcontext] */ HRESULT STDMETHODCALLTYPE _ADODynaCollection_Append_Proxy( 
    _ADODynaCollection __RPC_FAR * This,
    /* [in] */ IDispatch __RPC_FAR *Object);
void __RPC_STUB _ADODynaCollection_Append_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext] */ HRESULT STDMETHODCALLTYPE _ADODynaCollection_Delete_Proxy( 
    _ADODynaCollection __RPC_FAR * This,
    /* [in] */ VARIANT Index);
void __RPC_STUB _ADODynaCollection_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* ___ADODynaCollection_INTERFACE_DEFINED__ */
#ifndef ___ADO_INTERFACE_DEFINED__
#define ___ADO_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: _ADO
 * at Thu Dec 04 08:00:50 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][uuid][nonextensible][dual] */ 
EXTERN_C const IID IID__ADO;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("00000534-0000-0010-8000-00AA006D2EA4")
    _ADO : public IDispatch
    {
    public:
        virtual /* [helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ ADOProperties __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct _ADOVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _ADO __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _ADO __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _ADO __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _ADO __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _ADO __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _ADO __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _ADO __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][helpcontext][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Properties )( 
            _ADO __RPC_FAR * This,
            /* [retval][out] */ ADOProperties __RPC_FAR *__RPC_FAR *ppvObject);
        
        END_INTERFACE
    } _ADOVtbl;
    interface _ADO
    {
        CONST_VTBL struct _ADOVtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define _ADO_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define _ADO_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define _ADO_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define _ADO_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)
#define _ADO_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define _ADO_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define _ADO_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define _ADO_get_Properties(This,ppvObject)	\
    (This)->lpVtbl -> get_Properties(This,ppvObject)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE _ADO_get_Properties_Proxy( 
    _ADO __RPC_FAR * This,
    /* [retval][out] */ ADOProperties __RPC_FAR *__RPC_FAR *ppvObject);
void __RPC_STUB _ADO_get_Properties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* ___ADO_INTERFACE_DEFINED__ */
#ifndef __Error_INTERFACE_DEFINED__
#define __Error_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: Error
 * at Thu Dec 04 08:00:50 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][helpstring][helpcontext][uuid][nonextensible][dual] */ 
EXTERN_C const IID IID_Error;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("00000500-0000-0010-8000-00AA006D2EA4")
    ADOError : public IDispatch
    {
    public:
        virtual /* [helpstring][helpcontext][propget] */ HRESULT STDMETHODCALLTYPE get_Number( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [helpstring][helpcontext][propget] */ HRESULT STDMETHODCALLTYPE get_Source( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [helpstring][helpcontext][propget] */ HRESULT STDMETHODCALLTYPE get_HelpFile( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [helpstring][helpcontext][propget] */ HRESULT STDMETHODCALLTYPE get_HelpContext( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [helpstring][helpcontext][propget] */ HRESULT STDMETHODCALLTYPE get_SQLState( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [helpstring][helpcontext][propget] */ HRESULT STDMETHODCALLTYPE get_NativeError( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct ErrorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ADOError __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ADOError __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ADOError __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ADOError __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ADOError __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ADOError __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ADOError __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][helpcontext][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Number )( 
            ADOError __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [helpstring][helpcontext][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Source )( 
            ADOError __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [helpstring][helpcontext][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Description )( 
            ADOError __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [helpstring][helpcontext][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HelpFile )( 
            ADOError __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [helpstring][helpcontext][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HelpContext )( 
            ADOError __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [helpstring][helpcontext][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SQLState )( 
            ADOError __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [helpstring][helpcontext][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NativeError )( 
            ADOError __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        END_INTERFACE
    } ErrorVtbl;
    interface Error
    {
        CONST_VTBL struct ErrorVtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define Error_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define Error_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define Error_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define Error_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)
#define Error_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define Error_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define Error_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define Error_get_Number(This,pl)	\
    (This)->lpVtbl -> get_Number(This,pl)
#define Error_get_Source(This,pbstr)	\
    (This)->lpVtbl -> get_Source(This,pbstr)
#define Error_get_Description(This,pbstr)	\
    (This)->lpVtbl -> get_Description(This,pbstr)
#define Error_get_HelpFile(This,pbstr)	\
    (This)->lpVtbl -> get_HelpFile(This,pbstr)
#define Error_get_HelpContext(This,pl)	\
    (This)->lpVtbl -> get_HelpContext(This,pl)
#define Error_get_SQLState(This,pbstr)	\
    (This)->lpVtbl -> get_SQLState(This,pbstr)
#define Error_get_NativeError(This,pl)	\
    (This)->lpVtbl -> get_NativeError(This,pl)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [helpstring][helpcontext][propget] */ HRESULT STDMETHODCALLTYPE Error_get_Number_Proxy( 
    ADOError __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);
void __RPC_STUB Error_get_Number_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][propget] */ HRESULT STDMETHODCALLTYPE Error_get_Source_Proxy( 
    ADOError __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);
void __RPC_STUB Error_get_Source_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE Error_get_Description_Proxy( 
    ADOError __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);
void __RPC_STUB Error_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][propget] */ HRESULT STDMETHODCALLTYPE Error_get_HelpFile_Proxy( 
    ADOError __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);
void __RPC_STUB Error_get_HelpFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][propget] */ HRESULT STDMETHODCALLTYPE Error_get_HelpContext_Proxy( 
    ADOError __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);
void __RPC_STUB Error_get_HelpContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][propget] */ HRESULT STDMETHODCALLTYPE Error_get_SQLState_Proxy( 
    ADOError __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);
void __RPC_STUB Error_get_SQLState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][propget] */ HRESULT STDMETHODCALLTYPE Error_get_NativeError_Proxy( 
    ADOError __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);
void __RPC_STUB Error_get_NativeError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* __Error_INTERFACE_DEFINED__ */
#ifndef __Errors_INTERFACE_DEFINED__
#define __Errors_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: Errors
 * at Thu Dec 04 08:00:50 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][uuid][helpstring][helpcontext][nonextensible][dual] */ 
EXTERN_C const IID IID_Errors;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("00000501-0000-0010-8000-00AA006D2EA4")
    ADOErrors : public _ADOCollection
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ ADOError __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct ErrorsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ADOErrors __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ADOErrors __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ADOErrors __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ADOErrors __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ADOErrors __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ADOErrors __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ADOErrors __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][helpcontext][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            ADOErrors __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *c);
        
        /* [id][restricted] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_NewEnum )( 
            ADOErrors __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [helpstring][helpcontext] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            ADOErrors __RPC_FAR * This);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            ADOErrors __RPC_FAR * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ ADOError __RPC_FAR *__RPC_FAR *ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clear )( 
            ADOErrors __RPC_FAR * This);
        
        END_INTERFACE
    } ErrorsVtbl;
    interface Errors
    {
        CONST_VTBL struct ErrorsVtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define Errors_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define Errors_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define Errors_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define Errors_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)
#define Errors_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define Errors_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define Errors_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define Errors_get_Count(This,c)	\
    (This)->lpVtbl -> get_Count(This,c)
#define Errors__NewEnum(This,ppvObject)	\
    (This)->lpVtbl -> _NewEnum(This,ppvObject)
#define Errors_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)
#define Errors_get_Item(This,Index,ppvObject)	\
    (This)->lpVtbl -> get_Item(This,Index,ppvObject)
#define Errors_Clear(This)	\
    (This)->lpVtbl -> Clear(This)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [id][propget] */ HRESULT STDMETHODCALLTYPE Errors_get_Item_Proxy( 
    ADOErrors __RPC_FAR * This,
    /* [in] */ VARIANT Index,
    /* [retval][out] */ ADOError __RPC_FAR *__RPC_FAR *ppvObject);
void __RPC_STUB Errors_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
HRESULT STDMETHODCALLTYPE Errors_Clear_Proxy( 
    ADOErrors __RPC_FAR * This);
void __RPC_STUB Errors_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* __Errors_INTERFACE_DEFINED__ */
#ifndef ___Command_INTERFACE_DEFINED__
#define ___Command_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: _Command
 * at Thu Dec 04 08:00:50 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][uuid][nonextensible][dual] */ 
EXTERN_C const IID IID__Command;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("00000508-0000-0010-8000-00AA006D2EA4")
    _ADOCommand : public _ADO
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ActiveConnection( 
            /* [retval][out] */ _ADOConnection __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual /* [propputref] */ HRESULT STDMETHODCALLTYPE putref_ActiveConnection( 
            /* [in] */ _ADOConnection __RPC_FAR *pCon) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ActiveConnection( 
            /* [in] */ VARIANT vConn) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CommandText( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CommandText( 
            /* [in] */ BSTR bstr) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CommandTimeout( 
            /* [retval][out] */ LONG __RPC_FAR *pl) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CommandTimeout( 
            /* [in] */ LONG Timeout) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Prepared( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfPrepared) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Prepared( 
            /* [in] */ VARIANT_BOOL fPrepared) = 0;
        
        virtual /* [helpstring][helpcontext] */ HRESULT STDMETHODCALLTYPE Execute( 
            /* [optional][out] */ VARIANT __RPC_FAR *RecordsAffected,
            /* [optional][in] */ VARIANT __RPC_FAR *Parameters,
            /* [defaultvalue][in] */ long Options,
            /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *ppirs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateParameter( 
            /* [defaultvalue][in] */ BSTR Name,
            /* [defaultvalue][in] */ DataTypeEnum Type,
            /* [defaultvalue][in] */ ParameterDirectionEnum Direction,
            /* [defaultvalue][in] */ long Size,
            /* [optional][in] */ VARIANT Value,
            /* [retval][out] */ _ADOParameter __RPC_FAR *__RPC_FAR *ppiprm) = 0;
        
        virtual /* [helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE get_Parameters( 
            /* [retval][out] */ ADOParameters __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CommandType( 
            /* [in] */ CommandTypeEnum lCmdType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CommandType( 
            /* [retval][out] */ CommandTypeEnum __RPC_FAR *plCmdType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR bstrName) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct _CommandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _ADOCommand __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _ADOCommand __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _ADOCommand __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _ADOCommand __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _ADOCommand __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _ADOCommand __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _ADOCommand __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][helpcontext][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Properties )( 
            _ADOCommand __RPC_FAR * This,
            /* [retval][out] */ ADOProperties __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ActiveConnection )( 
            _ADOCommand __RPC_FAR * This,
            /* [retval][out] */ _ADOConnection __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [propputref] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_ActiveADOConnection )( 
            _ADOCommand __RPC_FAR * This,
            /* [in] */ _ADOConnection __RPC_FAR *pCon);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ActiveConnection )( 
            _ADOCommand __RPC_FAR * This,
            /* [in] */ VARIANT vConn);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CommandText )( 
            _ADOCommand __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CommandText )( 
            _ADOCommand __RPC_FAR * This,
            /* [in] */ BSTR bstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CommandTimeout )( 
            _ADOCommand __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *pl);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CommandTimeout )( 
            _ADOCommand __RPC_FAR * This,
            /* [in] */ LONG Timeout);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Prepared )( 
            _ADOCommand __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfPrepared);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Prepared )( 
            _ADOCommand __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fPrepared);
        
        /* [helpstring][helpcontext] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Execute )( 
            _ADOCommand __RPC_FAR * This,
            /* [optional][out] */ VARIANT __RPC_FAR *RecordsAffected,
            /* [optional][in] */ VARIANT __RPC_FAR *Parameters,
            /* [defaultvalue][in] */ long Options,
            /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *ppirs);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateParameter )( 
            _ADOCommand __RPC_FAR * This,
            /* [defaultvalue][in] */ BSTR Name,
            /* [defaultvalue][in] */ DataTypeEnum Type,
            /* [defaultvalue][in] */ ParameterDirectionEnum Direction,
            /* [defaultvalue][in] */ long Size,
            /* [optional][in] */ VARIANT Value,
            /* [retval][out] */ _ADOParameter __RPC_FAR *__RPC_FAR *ppiprm);
        
        /* [helpstring][helpcontext][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parameters )( 
            _ADOCommand __RPC_FAR * This,
            /* [retval][out] */ ADOParameters __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CommandType )( 
            _ADOCommand __RPC_FAR * This,
            /* [in] */ CommandTypeEnum lCmdType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CommandType )( 
            _ADOCommand __RPC_FAR * This,
            /* [retval][out] */ CommandTypeEnum __RPC_FAR *plCmdType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            _ADOCommand __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            _ADOCommand __RPC_FAR * This,
            /* [in] */ BSTR bstrName);
        
        END_INTERFACE
    } _CommandVtbl;
    interface _Command
    {
        CONST_VTBL struct _CommandVtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define _Command_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define _Command_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define _Command_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define _Command_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)
#define _Command_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define _Command_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define _Command_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define _Command_get_Properties(This,ppvObject)	\
    (This)->lpVtbl -> get_Properties(This,ppvObject)
#define _Command_get_ActiveConnection(This,ppvObject)	\
    (This)->lpVtbl -> get_ActiveConnection(This,ppvObject)
#define _Command_putref_ActiveConnection(This,pCon)	\
    (This)->lpVtbl -> putref_ActiveConnection(This,pCon)
#define _Command_put_ActiveConnection(This,vConn)	\
    (This)->lpVtbl -> put_ActiveConnection(This,vConn)
#define _Command_get_CommandText(This,pbstr)	\
    (This)->lpVtbl -> get_CommandText(This,pbstr)
#define _Command_put_CommandText(This,bstr)	\
    (This)->lpVtbl -> put_CommandText(This,bstr)
#define _Command_get_CommandTimeout(This,pl)	\
    (This)->lpVtbl -> get_CommandTimeout(This,pl)
#define _Command_put_CommandTimeout(This,Timeout)	\
    (This)->lpVtbl -> put_CommandTimeout(This,Timeout)
#define _Command_get_Prepared(This,pfPrepared)	\
    (This)->lpVtbl -> get_Prepared(This,pfPrepared)
#define _Command_put_Prepared(This,fPrepared)	\
    (This)->lpVtbl -> put_Prepared(This,fPrepared)
#define _Command_Execute(This,RecordsAffected,Parameters,Options,ppirs)	\
    (This)->lpVtbl -> Execute(This,RecordsAffected,Parameters,Options,ppirs)
#define _Command_CreateParameter(This,Name,Type,Direction,Size,Value,ppiprm)	\
    (This)->lpVtbl -> CreateParameter(This,Name,Type,Direction,Size,Value,ppiprm)
#define _Command_get_Parameters(This,ppvObject)	\
    (This)->lpVtbl -> get_Parameters(This,ppvObject)
#define _Command_put_CommandType(This,lCmdType)	\
    (This)->lpVtbl -> put_CommandType(This,lCmdType)
#define _Command_get_CommandType(This,plCmdType)	\
    (This)->lpVtbl -> get_CommandType(This,plCmdType)
#define _Command_get_Name(This,pbstrName)	\
    (This)->lpVtbl -> get_Name(This,pbstrName)
#define _Command_put_Name(This,bstrName)	\
    (This)->lpVtbl -> put_Name(This,bstrName)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [propget] */ HRESULT STDMETHODCALLTYPE _Command_get_ActiveConnection_Proxy( 
    _ADOCommand __RPC_FAR * This,
    /* [retval][out] */ _ADOConnection __RPC_FAR *__RPC_FAR *ppvObject);
void __RPC_STUB _Command_get_ActiveConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propputref] */ HRESULT STDMETHODCALLTYPE _Command_putref_ActiveConnection_Proxy( 
    _ADOCommand __RPC_FAR * This,
    /* [in] */ _ADOConnection __RPC_FAR *pCon);
void __RPC_STUB _Command_putref_ActiveConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput] */ HRESULT STDMETHODCALLTYPE _Command_put_ActiveConnection_Proxy( 
    _ADOCommand __RPC_FAR * This,
    /* [in] */ VARIANT vConn);
void __RPC_STUB _Command_put_ActiveConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE _Command_get_CommandText_Proxy( 
    _ADOCommand __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);
void __RPC_STUB _Command_get_CommandText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput] */ HRESULT STDMETHODCALLTYPE _Command_put_CommandText_Proxy( 
    _ADOCommand __RPC_FAR * This,
    /* [in] */ BSTR bstr);
void __RPC_STUB _Command_put_CommandText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE _Command_get_CommandTimeout_Proxy( 
    _ADOCommand __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pl);
void __RPC_STUB _Command_get_CommandTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput] */ HRESULT STDMETHODCALLTYPE _Command_put_CommandTimeout_Proxy( 
    _ADOCommand __RPC_FAR * This,
    /* [in] */ LONG Timeout);
void __RPC_STUB _Command_put_CommandTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE _Command_get_Prepared_Proxy( 
    _ADOCommand __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfPrepared);
void __RPC_STUB _Command_get_Prepared_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput] */ HRESULT STDMETHODCALLTYPE _Command_put_Prepared_Proxy( 
    _ADOCommand __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fPrepared);
void __RPC_STUB _Command_put_Prepared_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext] */ HRESULT STDMETHODCALLTYPE _Command_Execute_Proxy( 
    _ADOCommand __RPC_FAR * This,
    /* [optional][out] */ VARIANT __RPC_FAR *RecordsAffected,
    /* [optional][in] */ VARIANT __RPC_FAR *Parameters,
    /* [defaultvalue][in] */ long Options,
    /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *ppirs);
void __RPC_STUB _Command_Execute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
HRESULT STDMETHODCALLTYPE _Command_CreateParameter_Proxy( 
    _ADOCommand __RPC_FAR * This,
    /* [defaultvalue][in] */ BSTR Name,
    /* [defaultvalue][in] */ DataTypeEnum Type,
    /* [defaultvalue][in] */ ParameterDirectionEnum Direction,
    /* [defaultvalue][in] */ long Size,
    /* [optional][in] */ VARIANT Value,
    /* [retval][out] */ _ADOParameter __RPC_FAR *__RPC_FAR *ppiprm);
void __RPC_STUB _Command_CreateParameter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE _Command_get_Parameters_Proxy( 
    _ADOCommand __RPC_FAR * This,
    /* [retval][out] */ ADOParameters __RPC_FAR *__RPC_FAR *ppvObject);
void __RPC_STUB _Command_get_Parameters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput] */ HRESULT STDMETHODCALLTYPE _Command_put_CommandType_Proxy( 
    _ADOCommand __RPC_FAR * This,
    /* [in] */ CommandTypeEnum lCmdType);
void __RPC_STUB _Command_put_CommandType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE _Command_get_CommandType_Proxy( 
    _ADOCommand __RPC_FAR * This,
    /* [retval][out] */ CommandTypeEnum __RPC_FAR *plCmdType);
void __RPC_STUB _Command_get_CommandType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE _Command_get_Name_Proxy( 
    _ADOCommand __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrName);
void __RPC_STUB _Command_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput] */ HRESULT STDMETHODCALLTYPE _Command_put_Name_Proxy( 
    _ADOCommand __RPC_FAR * This,
    /* [in] */ BSTR bstrName);
void __RPC_STUB _Command_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* ___Command_INTERFACE_DEFINED__ */
#ifndef ___Connection_INTERFACE_DEFINED__
#define ___Connection_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: _Connection
 * at Thu Dec 04 08:00:50 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][helpstring][helpcontext][uuid][dual] */ 
EXTERN_C const IID IID__Connection;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("00000515-0000-0010-8000-00AA006D2EA4")
    _ADOConnection : public _ADO
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectionString( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ConnectionString( 
            /* [in] */ BSTR bstr) = 0;
        
        virtual /* [helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE get_CommandTimeout( 
            /* [retval][out] */ LONG __RPC_FAR *plTimeout) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_CommandTimeout( 
            /* [in] */ LONG lTimeout) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectionTimeout( 
            /* [retval][out] */ LONG __RPC_FAR *plTimeout) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ConnectionTimeout( 
            /* [in] */ LONG lTimeout) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Version( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual /* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Execute( 
            /* [in] */ BSTR CommandText,
            /* [optional][out] */ VARIANT __RPC_FAR *RecordsAffected,
            /* [defaultvalue][in] */ long Options,
            /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *ppiRset) = 0;
        
        virtual /* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE BeginTrans( 
            /* [retval][out] */ long __RPC_FAR *TransactionLevel) = 0;
        
        virtual /* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE CommitTrans( void) = 0;
        
        virtual /* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE RollbackTrans( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Open( 
            /* [defaultvalue][in] */ BSTR ConnectionString,
            /* [defaultvalue][in] */ BSTR UserID,
            /* [defaultvalue][in] */ BSTR Password,
            /* [defaultvalue][in] */ long Options) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Errors( 
            /* [retval][out] */ ADOErrors __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultDatabase( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DefaultDatabase( 
            /* [in] */ BSTR bstr) = 0;
        
        virtual /* [helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsolationLevel( 
            /* [retval][out] */ IsolationLevelEnum __RPC_FAR *Level) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_IsolationLevel( 
            /* [in] */ IsolationLevelEnum Level) = 0;
        
        virtual /* [helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE get_Attributes( 
            /* [retval][out] */ long __RPC_FAR *plAttr) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Attributes( 
            /* [in] */ long lAttr) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_CursorLocation( 
            /* [retval][out] */ CursorLocationEnum __RPC_FAR *plCursorLoc) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_CursorLocation( 
            /* [in] */ CursorLocationEnum lCursorLoc) = 0;
        
        virtual /* [helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE get_Mode( 
            /* [retval][out] */ ConnectModeEnum __RPC_FAR *plMode) = 0;
        
        virtual /* [helpstring][helpcontext][id][propput] */ HRESULT STDMETHODCALLTYPE put_Mode( 
            /* [in] */ ConnectModeEnum lMode) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Provider( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Provider( 
            /* [in] */ BSTR Provider) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ LONG __RPC_FAR *plObjState) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE OpenSchema( 
            /* [in] */ SchemaEnum Schema,
            /* [optional][in] */ VARIANT Restrictions,
            /* [optional][in] */ VARIANT SchemaID,
            /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *pprset) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct _ConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _ADOConnection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _ADOConnection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _ADOConnection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _ADOConnection __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _ADOConnection __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _ADOConnection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _ADOConnection __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][helpcontext][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Properties )( 
            _ADOConnection __RPC_FAR * This,
            /* [retval][out] */ ADOProperties __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ConnectionString )( 
            _ADOConnection __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ConnectionString )( 
            _ADOConnection __RPC_FAR * This,
            /* [in] */ BSTR bstr);
        
        /* [helpstring][helpcontext][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CommandTimeout )( 
            _ADOConnection __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *plTimeout);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CommandTimeout )( 
            _ADOConnection __RPC_FAR * This,
            /* [in] */ LONG lTimeout);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ConnectionTimeout )( 
            _ADOConnection __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *plTimeout);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ConnectionTimeout )( 
            _ADOConnection __RPC_FAR * This,
            /* [in] */ LONG lTimeout);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Version )( 
            _ADOConnection __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            _ADOConnection __RPC_FAR * This);
        
        /* [helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Execute )( 
            _ADOConnection __RPC_FAR * This,
            /* [in] */ BSTR CommandText,
            /* [optional][out] */ VARIANT __RPC_FAR *RecordsAffected,
            /* [defaultvalue][in] */ long Options,
            /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *ppiRset);
        
        /* [helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginTrans )( 
            _ADOConnection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *TransactionLevel);
        
        /* [helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommitTrans )( 
            _ADOConnection __RPC_FAR * This);
        
        /* [helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RollbackTrans )( 
            _ADOConnection __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            _ADOConnection __RPC_FAR * This,
            /* [defaultvalue][in] */ BSTR ConnectionString,
            /* [defaultvalue][in] */ BSTR UserID,
            /* [defaultvalue][in] */ BSTR Password,
            /* [defaultvalue][in] */ long Options);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Errors )( 
            _ADOConnection __RPC_FAR * This,
            /* [retval][out] */ ADOErrors __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DefaultDatabase )( 
            _ADOConnection __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DefaultDatabase )( 
            _ADOConnection __RPC_FAR * This,
            /* [in] */ BSTR bstr);
        
        /* [helpstring][helpcontext][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsolationLevel )( 
            _ADOConnection __RPC_FAR * This,
            /* [retval][out] */ IsolationLevelEnum __RPC_FAR *Level);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_IsolationLevel )( 
            _ADOConnection __RPC_FAR * This,
            /* [in] */ IsolationLevelEnum Level);
        
        /* [helpstring][helpcontext][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Attributes )( 
            _ADOConnection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plAttr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Attributes )( 
            _ADOConnection __RPC_FAR * This,
            /* [in] */ long lAttr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CursorLocation )( 
            _ADOConnection __RPC_FAR * This,
            /* [retval][out] */ CursorLocationEnum __RPC_FAR *plCursorLoc);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CursorLocation )( 
            _ADOConnection __RPC_FAR * This,
            /* [in] */ CursorLocationEnum lCursorLoc);
        
        /* [helpstring][helpcontext][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Mode )( 
            _ADOConnection __RPC_FAR * This,
            /* [retval][out] */ ConnectModeEnum __RPC_FAR *plMode);
        
        /* [helpstring][helpcontext][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Mode )( 
            _ADOConnection __RPC_FAR * This,
            /* [in] */ ConnectModeEnum lMode);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Provider )( 
            _ADOConnection __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Provider )( 
            _ADOConnection __RPC_FAR * This,
            /* [in] */ BSTR Provider);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_State )( 
            _ADOConnection __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *plObjState);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenSchema )( 
            _ADOConnection __RPC_FAR * This,
            /* [in] */ SchemaEnum Schema,
            /* [optional][in] */ VARIANT Restrictions,
            /* [optional][in] */ VARIANT SchemaID,
            /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *pprset);
        
        END_INTERFACE
    } _ConnectionVtbl;
    interface _Connection
    {
        CONST_VTBL struct _ConnectionVtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define _Connection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define _Connection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define _Connection_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define _Connection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)
#define _Connection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define _Connection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define _Connection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define _Connection_get_Properties(This,ppvObject)	\
    (This)->lpVtbl -> get_Properties(This,ppvObject)
#define _Connection_get_ConnectionString(This,pbstr)	\
    (This)->lpVtbl -> get_ConnectionString(This,pbstr)
#define _Connection_put_ConnectionString(This,bstr)	\
    (This)->lpVtbl -> put_ConnectionString(This,bstr)
#define _Connection_get_CommandTimeout(This,plTimeout)	\
    (This)->lpVtbl -> get_CommandTimeout(This,plTimeout)
#define _Connection_put_CommandTimeout(This,lTimeout)	\
    (This)->lpVtbl -> put_CommandTimeout(This,lTimeout)
#define _Connection_get_ConnectionTimeout(This,plTimeout)	\
    (This)->lpVtbl -> get_ConnectionTimeout(This,plTimeout)
#define _Connection_put_ConnectionTimeout(This,lTimeout)	\
    (This)->lpVtbl -> put_ConnectionTimeout(This,lTimeout)
#define _Connection_get_Version(This,pbstr)	\
    (This)->lpVtbl -> get_Version(This,pbstr)
#define _Connection_Close(This)	\
    (This)->lpVtbl -> Close(This)
#define _Connection_Execute(This,CommandText,RecordsAffected,Options,ppiRset)	\
    (This)->lpVtbl -> Execute(This,CommandText,RecordsAffected,Options,ppiRset)
#define _Connection_BeginTrans(This,TransactionLevel)	\
    (This)->lpVtbl -> BeginTrans(This,TransactionLevel)
#define _Connection_CommitTrans(This)	\
    (This)->lpVtbl -> CommitTrans(This)
#define _Connection_RollbackTrans(This)	\
    (This)->lpVtbl -> RollbackTrans(This)
#define _Connection_Open(This,ConnectionString,UserID,Password,Options)	\
    (This)->lpVtbl -> Open(This,ConnectionString,UserID,Password,Options)
#define _Connection_get_Errors(This,ppvObject)	\
    (This)->lpVtbl -> get_Errors(This,ppvObject)
#define _Connection_get_DefaultDatabase(This,pbstr)	\
    (This)->lpVtbl -> get_DefaultDatabase(This,pbstr)
#define _Connection_put_DefaultDatabase(This,bstr)	\
    (This)->lpVtbl -> put_DefaultDatabase(This,bstr)
#define _Connection_get_IsolationLevel(This,Level)	\
    (This)->lpVtbl -> get_IsolationLevel(This,Level)
#define _Connection_put_IsolationLevel(This,Level)	\
    (This)->lpVtbl -> put_IsolationLevel(This,Level)
#define _Connection_get_Attributes(This,plAttr)	\
    (This)->lpVtbl -> get_Attributes(This,plAttr)
#define _Connection_put_Attributes(This,lAttr)	\
    (This)->lpVtbl -> put_Attributes(This,lAttr)
#define _Connection_get_CursorLocation(This,plCursorLoc)	\
    (This)->lpVtbl -> get_CursorLocation(This,plCursorLoc)
#define _Connection_put_CursorLocation(This,lCursorLoc)	\
    (This)->lpVtbl -> put_CursorLocation(This,lCursorLoc)
#define _Connection_get_Mode(This,plMode)	\
    (This)->lpVtbl -> get_Mode(This,plMode)
#define _Connection_put_Mode(This,lMode)	\
    (This)->lpVtbl -> put_Mode(This,lMode)
#define _Connection_get_Provider(This,pbstr)	\
    (This)->lpVtbl -> get_Provider(This,pbstr)
#define _Connection_put_Provider(This,Provider)	\
    (This)->lpVtbl -> put_Provider(This,Provider)
#define _Connection_get_State(This,plObjState)	\
    (This)->lpVtbl -> get_State(This,plObjState)
#define _Connection_OpenSchema(This,Schema,Restrictions,SchemaID,pprset)	\
    (This)->lpVtbl -> OpenSchema(This,Schema,Restrictions,SchemaID,pprset)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [id][propget] */ HRESULT STDMETHODCALLTYPE _Connection_get_ConnectionString_Proxy( 
    _ADOConnection __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);
void __RPC_STUB _Connection_get_ConnectionString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propput] */ HRESULT STDMETHODCALLTYPE _Connection_put_ConnectionString_Proxy( 
    _ADOConnection __RPC_FAR * This,
    /* [in] */ BSTR bstr);
void __RPC_STUB _Connection_put_ConnectionString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE _Connection_get_CommandTimeout_Proxy( 
    _ADOConnection __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *plTimeout);
void __RPC_STUB _Connection_get_CommandTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propput] */ HRESULT STDMETHODCALLTYPE _Connection_put_CommandTimeout_Proxy( 
    _ADOConnection __RPC_FAR * This,
    /* [in] */ LONG lTimeout);
void __RPC_STUB _Connection_put_CommandTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propget] */ HRESULT STDMETHODCALLTYPE _Connection_get_ConnectionTimeout_Proxy( 
    _ADOConnection __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *plTimeout);
void __RPC_STUB _Connection_get_ConnectionTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propput] */ HRESULT STDMETHODCALLTYPE _Connection_put_ConnectionTimeout_Proxy( 
    _ADOConnection __RPC_FAR * This,
    /* [in] */ LONG lTimeout);
void __RPC_STUB _Connection_put_ConnectionTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propget] */ HRESULT STDMETHODCALLTYPE _Connection_get_Version_Proxy( 
    _ADOConnection __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);
void __RPC_STUB _Connection_get_Version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE _Connection_Close_Proxy( 
    _ADOConnection __RPC_FAR * This);
void __RPC_STUB _Connection_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE _Connection_Execute_Proxy( 
    _ADOConnection __RPC_FAR * This,
    /* [in] */ BSTR CommandText,
    /* [optional][out] */ VARIANT __RPC_FAR *RecordsAffected,
    /* [defaultvalue][in] */ long Options,
    /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *ppiRset);
void __RPC_STUB _Connection_Execute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE _Connection_BeginTrans_Proxy( 
    _ADOConnection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *TransactionLevel);
void __RPC_STUB _Connection_BeginTrans_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE _Connection_CommitTrans_Proxy( 
    _ADOConnection __RPC_FAR * This);
void __RPC_STUB _Connection_CommitTrans_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE _Connection_RollbackTrans_Proxy( 
    _ADOConnection __RPC_FAR * This);
void __RPC_STUB _Connection_RollbackTrans_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Connection_Open_Proxy( 
    _ADOConnection __RPC_FAR * This,
    /* [defaultvalue][in] */ BSTR ConnectionString,
    /* [defaultvalue][in] */ BSTR UserID,
    /* [defaultvalue][in] */ BSTR Password,
    /* [defaultvalue][in] */ long Options);
void __RPC_STUB _Connection_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propget] */ HRESULT STDMETHODCALLTYPE _Connection_get_Errors_Proxy( 
    _ADOConnection __RPC_FAR * This,
    /* [retval][out] */ ADOErrors __RPC_FAR *__RPC_FAR *ppvObject);
void __RPC_STUB _Connection_get_Errors_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propget] */ HRESULT STDMETHODCALLTYPE _Connection_get_DefaultDatabase_Proxy( 
    _ADOConnection __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);
void __RPC_STUB _Connection_get_DefaultDatabase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propput] */ HRESULT STDMETHODCALLTYPE _Connection_put_DefaultDatabase_Proxy( 
    _ADOConnection __RPC_FAR * This,
    /* [in] */ BSTR bstr);
void __RPC_STUB _Connection_put_DefaultDatabase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE _Connection_get_IsolationLevel_Proxy( 
    _ADOConnection __RPC_FAR * This,
    /* [retval][out] */ IsolationLevelEnum __RPC_FAR *Level);
void __RPC_STUB _Connection_get_IsolationLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propput] */ HRESULT STDMETHODCALLTYPE _Connection_put_IsolationLevel_Proxy( 
    _ADOConnection __RPC_FAR * This,
    /* [in] */ IsolationLevelEnum Level);
void __RPC_STUB _Connection_put_IsolationLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE _Connection_get_Attributes_Proxy( 
    _ADOConnection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plAttr);
void __RPC_STUB _Connection_get_Attributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propput] */ HRESULT STDMETHODCALLTYPE _Connection_put_Attributes_Proxy( 
    _ADOConnection __RPC_FAR * This,
    /* [in] */ long lAttr);
void __RPC_STUB _Connection_put_Attributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Connection_get_CursorLocation_Proxy( 
    _ADOConnection __RPC_FAR * This,
    /* [retval][out] */ CursorLocationEnum __RPC_FAR *plCursorLoc);
void __RPC_STUB _Connection_get_CursorLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput][id] */ HRESULT STDMETHODCALLTYPE _Connection_put_CursorLocation_Proxy( 
    _ADOConnection __RPC_FAR * This,
    /* [in] */ CursorLocationEnum lCursorLoc);
void __RPC_STUB _Connection_put_CursorLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE _Connection_get_Mode_Proxy( 
    _ADOConnection __RPC_FAR * This,
    /* [retval][out] */ ConnectModeEnum __RPC_FAR *plMode);
void __RPC_STUB _Connection_get_Mode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][id][propput] */ HRESULT STDMETHODCALLTYPE _Connection_put_Mode_Proxy( 
    _ADOConnection __RPC_FAR * This,
    /* [in] */ ConnectModeEnum lMode);
void __RPC_STUB _Connection_put_Mode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propget] */ HRESULT STDMETHODCALLTYPE _Connection_get_Provider_Proxy( 
    _ADOConnection __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);
void __RPC_STUB _Connection_get_Provider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propput] */ HRESULT STDMETHODCALLTYPE _Connection_put_Provider_Proxy( 
    _ADOConnection __RPC_FAR * This,
    /* [in] */ BSTR Provider);
void __RPC_STUB _Connection_put_Provider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propget] */ HRESULT STDMETHODCALLTYPE _Connection_get_State_Proxy( 
    _ADOConnection __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *plObjState);
void __RPC_STUB _Connection_get_State_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Connection_OpenSchema_Proxy( 
    _ADOConnection __RPC_FAR * This,
    /* [in] */ SchemaEnum Schema,
    /* [optional][in] */ VARIANT Restrictions,
    /* [optional][in] */ VARIANT SchemaID,
    /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *pprset);
void __RPC_STUB _Connection_OpenSchema_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* ___Connection_INTERFACE_DEFINED__ */
#ifndef __ADOConnectionConstruction_INTERFACE_DEFINED__
#define __ADOConnectionConstruction_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: ADOConnectionConstruction
 * at Thu Dec 04 08:00:50 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][uuid][restricted] */ 
EXTERN_C const IID IID_ADOConnectionConstruction;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("00000516-0000-0010-8000-00AA006D2EA4")
    ADOConnectionConstruction : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DSO( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppDSO) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Session( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppSession) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct ADOConnectionConstructionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ADOConnectionConstruction __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ADOConnectionConstruction __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ADOConnectionConstruction __RPC_FAR * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DSO )( 
            ADOConnectionConstruction __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppDSO);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Session )( 
            ADOConnectionConstruction __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppSession);
        
        END_INTERFACE
    } ADOConnectionConstructionVtbl;
    interface ADOConnectionConstruction
    {
        CONST_VTBL struct ADOConnectionConstructionVtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define ADOConnectionConstruction_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define ADOConnectionConstruction_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define ADOConnectionConstruction_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define ADOConnectionConstruction_get_DSO(This,ppDSO)	\
    (This)->lpVtbl -> get_DSO(This,ppDSO)
#define ADOConnectionConstruction_get_Session(This,ppSession)	\
    (This)->lpVtbl -> get_Session(This,ppSession)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [propget] */ HRESULT STDMETHODCALLTYPE ADOConnectionConstruction_get_DSO_Proxy( 
    ADOConnectionConstruction __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppDSO);
void __RPC_STUB ADOConnectionConstruction_get_DSO_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE ADOConnectionConstruction_get_Session_Proxy( 
    ADOConnectionConstruction __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppSession);
void __RPC_STUB ADOConnectionConstruction_get_Session_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* __ADOConnectionConstruction_INTERFACE_DEFINED__ */
#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Connection;
Connection;
#endif
#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Command;
Command;
#endif
#ifndef ___Recordset_INTERFACE_DEFINED__
#define ___Recordset_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: _Recordset
 * at Thu Dec 04 08:00:50 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][helpstring][helpcontext][uuid][nonextensible][dual] */ 
EXTERN_C const IID IID__Recordset;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0000050E-0000-0010-8000-00AA006D2EA4")
    _ADORecordset : public _ADO
    {
    public:
        virtual /* [helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_AbsolutePosition( 
            /* [retval][out] */ PositionEnum __RPC_FAR *pl) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AbsolutePosition( 
            /* [in] */ PositionEnum Position) = 0;
        
        virtual /* [propputref][id] */ HRESULT STDMETHODCALLTYPE putref_ActiveConnection( 
            /* [in] */ IDispatch __RPC_FAR *pconn) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ActiveConnection( 
            /* [in] */ VARIANT vConn) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ActiveConnection( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_BOF( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Bookmark( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvBookmark) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Bookmark( 
            /* [in] */ VARIANT vBookmark) = 0;
        
        virtual /* [helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_CacheSize( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_CacheSize( 
            /* [in] */ long CacheSize) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_CursorType( 
            /* [retval][out] */ CursorTypeEnum __RPC_FAR *plCursorType) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_CursorType( 
            /* [in] */ CursorTypeEnum lCursorType) = 0;
        
        virtual /* [helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_EOF( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb) = 0;
        
        virtual /* [helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Fields( 
            /* [retval][out] */ ADOFields __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_LockType( 
            /* [retval][out] */ LockTypeEnum __RPC_FAR *plLockType) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_LockType( 
            /* [in] */ LockTypeEnum lLockType) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_MaxRecords( 
            /* [retval][out] */ long __RPC_FAR *plMaxRecords) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_MaxRecords( 
            /* [in] */ long lMaxRecords) = 0;
        
        virtual /* [helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_RecordCount( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Source( 
            /* [in] */ IDispatch __RPC_FAR *pcmd) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Source( 
            /* [in] */ BSTR bstrConn) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Source( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvSource) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AddNew( 
            /* [optional][in] */ VARIANT FieldList,
            /* [optional][in] */ VARIANT Values) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CancelUpdate( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [defaultvalue][in] */ AffectEnum AffectRecords) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetRows( 
            /* [defaultvalue][in] */ long Rows,
            /* [optional][in] */ VARIANT Start,
            /* [optional][in] */ VARIANT Fields,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Move( 
            /* [in] */ long NumRecords,
            /* [optional][in] */ VARIANT Start) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveNext( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MovePrevious( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveFirst( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveLast( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Open( 
            /* [optional][in] */ VARIANT Source,
            /* [optional][in] */ VARIANT ActiveConnection,
            /* [defaultvalue][in] */ CursorTypeEnum CursorType,
            /* [defaultvalue][in] */ LockTypeEnum LockType,
            /* [defaultvalue][in] */ LONG Options) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Requery( 
            /* [defaultvalue][in] */ LONG Options) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Resync( 
            /* [defaultvalue][in] */ AffectEnum AffectRecords) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Update( 
            /* [optional][in] */ VARIANT Fields,
            /* [optional][in] */ VARIANT Values) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AbsolutePage( 
            /* [retval][out] */ PositionEnum __RPC_FAR *pl) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AbsolutePage( 
            /* [in] */ PositionEnum Page) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_EditMode( 
            /* [retval][out] */ EditModeEnum __RPC_FAR *pl) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Filter( 
            /* [retval][out] */ VARIANT __RPC_FAR *Criteria) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Filter( 
            /* [in] */ VARIANT Criteria) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_PageCount( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_PageSize( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_PageSize( 
            /* [in] */ long PageSize) = 0;
        
        virtual /* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE get_Sort( 
            /* [retval][out] */ BSTR __RPC_FAR *Criteria) = 0;
        
        virtual /* [hidden][propput][id] */ HRESULT STDMETHODCALLTYPE put_Sort( 
            /* [in] */ BSTR Criteria) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ LONG __RPC_FAR *plObjState) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE UpdateBatch( 
            /* [defaultvalue][in] */ AffectEnum AffectRecords) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CancelBatch( 
            /* [defaultvalue][in] */ AffectEnum AffectRecords) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_CursorLocation( 
            /* [retval][out] */ CursorLocationEnum __RPC_FAR *plCursorLoc) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_CursorLocation( 
            /* [in] */ CursorLocationEnum lCursorLoc) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE NextRecordset( 
            /* [optional][out] */ VARIANT __RPC_FAR *RecordsAffected,
            /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *ppiRs) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Supports( 
            /* [in] */ CursorOptionEnum CursorOptions,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb) = 0;
        
        virtual /* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get_Collect( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [hidden][id][propput] */ HRESULT STDMETHODCALLTYPE put_Collect( 
            /* [in] */ VARIANT Index,
            /* [in] */ VARIANT value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_MarshalOptions( 
            /* [retval][out] */ MarshalOptionsEnum __RPC_FAR *peMarshal) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_MarshalOptions( 
            /* [in] */ MarshalOptionsEnum eMarshal) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE Find( 
            /* [in] */ BSTR Criteria,
            /* [defaultvalue][in] */ LONG SkipRecords,
            /* [defaultvalue][in] */ SearchDirectionEnum SearchDirection,
            /* [optional][in] */ VARIANT Start) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct _RecordsetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _ADORecordset __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _ADORecordset __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _ADORecordset __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][helpcontext][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Properties )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ ADOProperties __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AbsolutePosition )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ PositionEnum __RPC_FAR *pl);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AbsolutePosition )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ PositionEnum Position);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_ActiveADOConnection )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ IDispatch __RPC_FAR *pconn);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ActiveConnection )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ VARIANT vConn);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ActiveConnection )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BOF )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Bookmark )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvBookmark);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Bookmark )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ VARIANT vBookmark);
        
        /* [helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CacheSize )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CacheSize )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ long CacheSize);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CursorType )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ CursorTypeEnum __RPC_FAR *plCursorType);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CursorType )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ CursorTypeEnum lCursorType);
        
        /* [helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EOF )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);
        
        /* [helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Fields )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ ADOFields __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LockType )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ LockTypeEnum __RPC_FAR *plLockType);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LockType )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ LockTypeEnum lLockType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MaxRecords )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plMaxRecords);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MaxRecords )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ long lMaxRecords);
        
        /* [helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RecordCount )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Source )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ IDispatch __RPC_FAR *pcmd);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Source )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ BSTR bstrConn);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Source )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvSource);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddNew )( 
            _ADORecordset __RPC_FAR * This,
            /* [optional][in] */ VARIANT FieldList,
            /* [optional][in] */ VARIANT Values);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelUpdate )( 
            _ADORecordset __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            _ADORecordset __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            _ADORecordset __RPC_FAR * This,
            /* [defaultvalue][in] */ AffectEnum AffectRecords);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRows )( 
            _ADORecordset __RPC_FAR * This,
            /* [defaultvalue][in] */ long Rows,
            /* [optional][in] */ VARIANT Start,
            /* [optional][in] */ VARIANT Fields,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Move )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ long NumRecords,
            /* [optional][in] */ VARIANT Start);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveNext )( 
            _ADORecordset __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MovePrevious )( 
            _ADORecordset __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveFirst )( 
            _ADORecordset __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveLast )( 
            _ADORecordset __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            _ADORecordset __RPC_FAR * This,
            /* [optional][in] */ VARIANT Source,
            /* [optional][in] */ VARIANT ActiveConnection,
            /* [defaultvalue][in] */ CursorTypeEnum CursorType,
            /* [defaultvalue][in] */ LockTypeEnum LockType,
            /* [defaultvalue][in] */ LONG Options);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Requery )( 
            _ADORecordset __RPC_FAR * This,
            /* [defaultvalue][in] */ LONG Options);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Resync )( 
            _ADORecordset __RPC_FAR * This,
            /* [defaultvalue][in] */ AffectEnum AffectRecords);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Update )( 
            _ADORecordset __RPC_FAR * This,
            /* [optional][in] */ VARIANT Fields,
            /* [optional][in] */ VARIANT Values);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AbsolutePage )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ PositionEnum __RPC_FAR *pl);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AbsolutePage )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ PositionEnum Page);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EditMode )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ EditModeEnum __RPC_FAR *pl);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Filter )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *Criteria);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Filter )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ VARIANT Criteria);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PageCount )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PageSize )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_PageSize )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ long PageSize);
        
        /* [hidden][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Sort )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Criteria);
        
        /* [hidden][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Sort )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ BSTR Criteria);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Status )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_State )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *plObjState);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateBatch )( 
            _ADORecordset __RPC_FAR * This,
            /* [defaultvalue][in] */ AffectEnum AffectRecords);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelBatch )( 
            _ADORecordset __RPC_FAR * This,
            /* [defaultvalue][in] */ AffectEnum AffectRecords);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CursorLocation )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ CursorLocationEnum __RPC_FAR *plCursorLoc);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CursorLocation )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ CursorLocationEnum lCursorLoc);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NextADORecordset )( 
            _ADORecordset __RPC_FAR * This,
            /* [optional][out] */ VARIANT __RPC_FAR *RecordsAffected,
            /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *ppiRs);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Supports )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ CursorOptionEnum CursorOptions,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Collect )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [hidden][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Collect )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ VARIANT Index,
            /* [in] */ VARIANT value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MarshalOptions )( 
            _ADORecordset __RPC_FAR * This,
            /* [retval][out] */ MarshalOptionsEnum __RPC_FAR *peMarshal);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MarshalOptions )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ MarshalOptionsEnum eMarshal);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Find )( 
            _ADORecordset __RPC_FAR * This,
            /* [in] */ BSTR Criteria,
            /* [defaultvalue][in] */ LONG SkipRecords,
            /* [defaultvalue][in] */ SearchDirectionEnum SearchDirection,
            /* [optional][in] */ VARIANT Start);
        
        END_INTERFACE
    } _RecordsetVtbl;
    interface _Recordset
    {
        CONST_VTBL struct _RecordsetVtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define _Recordset_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define _Recordset_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define _Recordset_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define _Recordset_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)
#define _Recordset_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define _Recordset_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define _Recordset_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define _Recordset_get_Properties(This,ppvObject)	\
    (This)->lpVtbl -> get_Properties(This,ppvObject)
#define _Recordset_get_AbsolutePosition(This,pl)	\
    (This)->lpVtbl -> get_AbsolutePosition(This,pl)
#define _Recordset_put_AbsolutePosition(This,Position)	\
    (This)->lpVtbl -> put_AbsolutePosition(This,Position)
#define _Recordset_putref_ActiveConnection(This,pconn)	\
    (This)->lpVtbl -> putref_ActiveConnection(This,pconn)
#define _Recordset_put_ActiveConnection(This,vConn)	\
    (This)->lpVtbl -> put_ActiveConnection(This,vConn)
#define _Recordset_get_ActiveConnection(This,pvar)	\
    (This)->lpVtbl -> get_ActiveConnection(This,pvar)
#define _Recordset_get_BOF(This,pb)	\
    (This)->lpVtbl -> get_BOF(This,pb)
#define _Recordset_get_Bookmark(This,pvBookmark)	\
    (This)->lpVtbl -> get_Bookmark(This,pvBookmark)
#define _Recordset_put_Bookmark(This,vBookmark)	\
    (This)->lpVtbl -> put_Bookmark(This,vBookmark)
#define _Recordset_get_CacheSize(This,pl)	\
    (This)->lpVtbl -> get_CacheSize(This,pl)
#define _Recordset_put_CacheSize(This,CacheSize)	\
    (This)->lpVtbl -> put_CacheSize(This,CacheSize)
#define _Recordset_get_CursorType(This,plCursorType)	\
    (This)->lpVtbl -> get_CursorType(This,plCursorType)
#define _Recordset_put_CursorType(This,lCursorType)	\
    (This)->lpVtbl -> put_CursorType(This,lCursorType)
#define _Recordset_get_EOF(This,pb)	\
    (This)->lpVtbl -> get_EOF(This,pb)
#define _Recordset_get_Fields(This,ppvObject)	\
    (This)->lpVtbl -> get_Fields(This,ppvObject)
#define _Recordset_get_LockType(This,plLockType)	\
    (This)->lpVtbl -> get_LockType(This,plLockType)
#define _Recordset_put_LockType(This,lLockType)	\
    (This)->lpVtbl -> put_LockType(This,lLockType)
#define _Recordset_get_MaxRecords(This,plMaxRecords)	\
    (This)->lpVtbl -> get_MaxRecords(This,plMaxRecords)
#define _Recordset_put_MaxRecords(This,lMaxRecords)	\
    (This)->lpVtbl -> put_MaxRecords(This,lMaxRecords)
#define _Recordset_get_RecordCount(This,pl)	\
    (This)->lpVtbl -> get_RecordCount(This,pl)
#define _Recordset_putref_Source(This,pcmd)	\
    (This)->lpVtbl -> putref_Source(This,pcmd)
#define _Recordset_put_Source(This,bstrConn)	\
    (This)->lpVtbl -> put_Source(This,bstrConn)
#define _Recordset_get_Source(This,pvSource)	\
    (This)->lpVtbl -> get_Source(This,pvSource)
#define _Recordset_AddNew(This,FieldList,Values)	\
    (This)->lpVtbl -> AddNew(This,FieldList,Values)
#define _Recordset_CancelUpdate(This)	\
    (This)->lpVtbl -> CancelUpdate(This)
#define _Recordset_Close(This)	\
    (This)->lpVtbl -> Close(This)
#define _Recordset_Delete(This,AffectRecords)	\
    (This)->lpVtbl -> Delete(This,AffectRecords)
#define _Recordset_GetRows(This,Rows,Start,Fields,pvar)	\
    (This)->lpVtbl -> GetRows(This,Rows,Start,Fields,pvar)
#define _Recordset_Move(This,NumRecords,Start)	\
    (This)->lpVtbl -> Move(This,NumRecords,Start)
#define _Recordset_MoveNext(This)	\
    (This)->lpVtbl -> MoveNext(This)
#define _Recordset_MovePrevious(This)	\
    (This)->lpVtbl -> MovePrevious(This)
#define _Recordset_MoveFirst(This)	\
    (This)->lpVtbl -> MoveFirst(This)
#define _Recordset_MoveLast(This)	\
    (This)->lpVtbl -> MoveLast(This)
#define _Recordset_Open(This,Source,ActiveConnection,CursorType,LockType,Options)	\
    (This)->lpVtbl -> Open(This,Source,ActiveConnection,CursorType,LockType,Options)
#define _Recordset_Requery(This,Options)	\
    (This)->lpVtbl -> Requery(This,Options)
#define _Recordset_Resync(This,AffectRecords)	\
    (This)->lpVtbl -> Resync(This,AffectRecords)
#define _Recordset_Update(This,Fields,Values)	\
    (This)->lpVtbl -> Update(This,Fields,Values)
#define _Recordset_get_AbsolutePage(This,pl)	\
    (This)->lpVtbl -> get_AbsolutePage(This,pl)
#define _Recordset_put_AbsolutePage(This,Page)	\
    (This)->lpVtbl -> put_AbsolutePage(This,Page)
#define _Recordset_get_EditMode(This,pl)	\
    (This)->lpVtbl -> get_EditMode(This,pl)
#define _Recordset_get_Filter(This,Criteria)	\
    (This)->lpVtbl -> get_Filter(This,Criteria)
#define _Recordset_put_Filter(This,Criteria)	\
    (This)->lpVtbl -> put_Filter(This,Criteria)
#define _Recordset_get_PageCount(This,pl)	\
    (This)->lpVtbl -> get_PageCount(This,pl)
#define _Recordset_get_PageSize(This,pl)	\
    (This)->lpVtbl -> get_PageSize(This,pl)
#define _Recordset_put_PageSize(This,PageSize)	\
    (This)->lpVtbl -> put_PageSize(This,PageSize)
#define _Recordset_get_Sort(This,Criteria)	\
    (This)->lpVtbl -> get_Sort(This,Criteria)
#define _Recordset_put_Sort(This,Criteria)	\
    (This)->lpVtbl -> put_Sort(This,Criteria)
#define _Recordset_get_Status(This,pl)	\
    (This)->lpVtbl -> get_Status(This,pl)
#define _Recordset_get_State(This,plObjState)	\
    (This)->lpVtbl -> get_State(This,plObjState)
#define _Recordset_Clone(This,ppvObject)	\
    (This)->lpVtbl -> Clone(This,ppvObject)
#define _Recordset_UpdateBatch(This,AffectRecords)	\
    (This)->lpVtbl -> UpdateBatch(This,AffectRecords)
#define _Recordset_CancelBatch(This,AffectRecords)	\
    (This)->lpVtbl -> CancelBatch(This,AffectRecords)
#define _Recordset_get_CursorLocation(This,plCursorLoc)	\
    (This)->lpVtbl -> get_CursorLocation(This,plCursorLoc)
#define _Recordset_put_CursorLocation(This,lCursorLoc)	\
    (This)->lpVtbl -> put_CursorLocation(This,lCursorLoc)
#define _Recordset_NextRecordset(This,RecordsAffected,ppiRs)	\
    (This)->lpVtbl -> NextRecordset(This,RecordsAffected,ppiRs)
#define _Recordset_Supports(This,CursorOptions,pb)	\
    (This)->lpVtbl -> Supports(This,CursorOptions,pb)
#define _Recordset_get_Collect(This,Index,pvar)	\
    (This)->lpVtbl -> get_Collect(This,Index,pvar)
#define _Recordset_put_Collect(This,Index,value)	\
    (This)->lpVtbl -> put_Collect(This,Index,value)
#define _Recordset_get_MarshalOptions(This,peMarshal)	\
    (This)->lpVtbl -> get_MarshalOptions(This,peMarshal)
#define _Recordset_put_MarshalOptions(This,eMarshal)	\
    (This)->lpVtbl -> put_MarshalOptions(This,eMarshal)
#define _Recordset_Find(This,Criteria,SkipRecords,SearchDirection,Start)	\
    (This)->lpVtbl -> Find(This,Criteria,SkipRecords,SearchDirection,Start)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset_get_AbsolutePosition_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [retval][out] */ PositionEnum __RPC_FAR *pl);
void __RPC_STUB _Recordset_get_AbsolutePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput][id] */ HRESULT STDMETHODCALLTYPE _Recordset_put_AbsolutePosition_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [in] */ PositionEnum Position);
void __RPC_STUB _Recordset_put_AbsolutePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propputref][id] */ HRESULT STDMETHODCALLTYPE _Recordset_putref_ActiveConnection_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [in] */ IDispatch __RPC_FAR *pconn);
void __RPC_STUB _Recordset_putref_ActiveConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput][id] */ HRESULT STDMETHODCALLTYPE _Recordset_put_ActiveConnection_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [in] */ VARIANT vConn);
void __RPC_STUB _Recordset_put_ActiveConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset_get_ActiveConnection_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);
void __RPC_STUB _Recordset_get_ActiveConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset_get_BOF_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);
void __RPC_STUB _Recordset_get_BOF_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset_get_Bookmark_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvBookmark);
void __RPC_STUB _Recordset_get_Bookmark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput][id] */ HRESULT STDMETHODCALLTYPE _Recordset_put_Bookmark_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [in] */ VARIANT vBookmark);
void __RPC_STUB _Recordset_put_Bookmark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset_get_CacheSize_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);
void __RPC_STUB _Recordset_get_CacheSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput][id] */ HRESULT STDMETHODCALLTYPE _Recordset_put_CacheSize_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [in] */ long CacheSize);
void __RPC_STUB _Recordset_put_CacheSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset_get_CursorType_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [retval][out] */ CursorTypeEnum __RPC_FAR *plCursorType);
void __RPC_STUB _Recordset_get_CursorType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput][id] */ HRESULT STDMETHODCALLTYPE _Recordset_put_CursorType_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [in] */ CursorTypeEnum lCursorType);
void __RPC_STUB _Recordset_put_CursorType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset_get_EOF_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);
void __RPC_STUB _Recordset_get_EOF_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset_get_Fields_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [retval][out] */ ADOFields __RPC_FAR *__RPC_FAR *ppvObject);
void __RPC_STUB _Recordset_get_Fields_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset_get_LockType_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [retval][out] */ LockTypeEnum __RPC_FAR *plLockType);
void __RPC_STUB _Recordset_get_LockType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput][id] */ HRESULT STDMETHODCALLTYPE _Recordset_put_LockType_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [in] */ LockTypeEnum lLockType);
void __RPC_STUB _Recordset_put_LockType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset_get_MaxRecords_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plMaxRecords);
void __RPC_STUB _Recordset_get_MaxRecords_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput][id] */ HRESULT STDMETHODCALLTYPE _Recordset_put_MaxRecords_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [in] */ long lMaxRecords);
void __RPC_STUB _Recordset_put_MaxRecords_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset_get_RecordCount_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);
void __RPC_STUB _Recordset_get_RecordCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propputref][id] */ HRESULT STDMETHODCALLTYPE _Recordset_putref_Source_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [in] */ IDispatch __RPC_FAR *pcmd);
void __RPC_STUB _Recordset_putref_Source_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput][id] */ HRESULT STDMETHODCALLTYPE _Recordset_put_Source_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [in] */ BSTR bstrConn);
void __RPC_STUB _Recordset_put_Source_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset_get_Source_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvSource);
void __RPC_STUB _Recordset_get_Source_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset_AddNew_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [optional][in] */ VARIANT FieldList,
    /* [optional][in] */ VARIANT Values);
void __RPC_STUB _Recordset_AddNew_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset_CancelUpdate_Proxy( 
    _ADORecordset __RPC_FAR * This);
void __RPC_STUB _Recordset_CancelUpdate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset_Close_Proxy( 
    _ADORecordset __RPC_FAR * This);
void __RPC_STUB _Recordset_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset_Delete_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [defaultvalue][in] */ AffectEnum AffectRecords);
void __RPC_STUB _Recordset_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset_GetRows_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [defaultvalue][in] */ long Rows,
    /* [optional][in] */ VARIANT Start,
    /* [optional][in] */ VARIANT Fields,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);
void __RPC_STUB _Recordset_GetRows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset_Move_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [in] */ long NumRecords,
    /* [optional][in] */ VARIANT Start);
void __RPC_STUB _Recordset_Move_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset_MoveNext_Proxy( 
    _ADORecordset __RPC_FAR * This);
void __RPC_STUB _Recordset_MoveNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset_MovePrevious_Proxy( 
    _ADORecordset __RPC_FAR * This);
void __RPC_STUB _Recordset_MovePrevious_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset_MoveFirst_Proxy( 
    _ADORecordset __RPC_FAR * This);
void __RPC_STUB _Recordset_MoveFirst_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset_MoveLast_Proxy( 
    _ADORecordset __RPC_FAR * This);
void __RPC_STUB _Recordset_MoveLast_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset_Open_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [optional][in] */ VARIANT Source,
    /* [optional][in] */ VARIANT ActiveConnection,
    /* [defaultvalue][in] */ CursorTypeEnum CursorType,
    /* [defaultvalue][in] */ LockTypeEnum LockType,
    /* [defaultvalue][in] */ LONG Options);
void __RPC_STUB _Recordset_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset_Requery_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [defaultvalue][in] */ LONG Options);
void __RPC_STUB _Recordset_Requery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset_Resync_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [defaultvalue][in] */ AffectEnum AffectRecords);
void __RPC_STUB _Recordset_Resync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset_Update_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [optional][in] */ VARIANT Fields,
    /* [optional][in] */ VARIANT Values);
void __RPC_STUB _Recordset_Update_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset_get_AbsolutePage_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [retval][out] */ PositionEnum __RPC_FAR *pl);
void __RPC_STUB _Recordset_get_AbsolutePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput][id] */ HRESULT STDMETHODCALLTYPE _Recordset_put_AbsolutePage_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [in] */ PositionEnum Page);
void __RPC_STUB _Recordset_put_AbsolutePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset_get_EditMode_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [retval][out] */ EditModeEnum __RPC_FAR *pl);
void __RPC_STUB _Recordset_get_EditMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset_get_Filter_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *Criteria);
void __RPC_STUB _Recordset_get_Filter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput][id] */ HRESULT STDMETHODCALLTYPE _Recordset_put_Filter_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [in] */ VARIANT Criteria);
void __RPC_STUB _Recordset_put_Filter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset_get_PageCount_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);
void __RPC_STUB _Recordset_get_PageCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset_get_PageSize_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);
void __RPC_STUB _Recordset_get_PageSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput][id] */ HRESULT STDMETHODCALLTYPE _Recordset_put_PageSize_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [in] */ long PageSize);
void __RPC_STUB _Recordset_put_PageSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset_get_Sort_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *Criteria);
void __RPC_STUB _Recordset_get_Sort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [hidden][propput][id] */ HRESULT STDMETHODCALLTYPE _Recordset_put_Sort_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [in] */ BSTR Criteria);
void __RPC_STUB _Recordset_put_Sort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset_get_Status_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);
void __RPC_STUB _Recordset_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset_get_State_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *plObjState);
void __RPC_STUB _Recordset_get_State_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset_Clone_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *ppvObject);
void __RPC_STUB _Recordset_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset_UpdateBatch_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [defaultvalue][in] */ AffectEnum AffectRecords);
void __RPC_STUB _Recordset_UpdateBatch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset_CancelBatch_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [defaultvalue][in] */ AffectEnum AffectRecords);
void __RPC_STUB _Recordset_CancelBatch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset_get_CursorLocation_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [retval][out] */ CursorLocationEnum __RPC_FAR *plCursorLoc);
void __RPC_STUB _Recordset_get_CursorLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput][id] */ HRESULT STDMETHODCALLTYPE _Recordset_put_CursorLocation_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [in] */ CursorLocationEnum lCursorLoc);
void __RPC_STUB _Recordset_put_CursorLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset_NextRecordset_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [optional][out] */ VARIANT __RPC_FAR *RecordsAffected,
    /* [retval][out] */ _ADORecordset __RPC_FAR *__RPC_FAR *ppiRs);
void __RPC_STUB _Recordset_NextRecordset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id] */ HRESULT STDMETHODCALLTYPE _Recordset_Supports_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [in] */ CursorOptionEnum CursorOptions,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pb);
void __RPC_STUB _Recordset_Supports_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE _Recordset_get_Collect_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [in] */ VARIANT Index,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);
void __RPC_STUB _Recordset_get_Collect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [hidden][id][propput] */ HRESULT STDMETHODCALLTYPE _Recordset_put_Collect_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [in] */ VARIANT Index,
    /* [in] */ VARIANT value);
void __RPC_STUB _Recordset_put_Collect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE _Recordset_get_MarshalOptions_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [retval][out] */ MarshalOptionsEnum __RPC_FAR *peMarshal);
void __RPC_STUB _Recordset_get_MarshalOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput][id] */ HRESULT STDMETHODCALLTYPE _Recordset_put_MarshalOptions_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [in] */ MarshalOptionsEnum eMarshal);
void __RPC_STUB _Recordset_put_MarshalOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [hidden][id] */ HRESULT STDMETHODCALLTYPE _Recordset_Find_Proxy( 
    _ADORecordset __RPC_FAR * This,
    /* [in] */ BSTR Criteria,
    /* [defaultvalue][in] */ LONG SkipRecords,
    /* [defaultvalue][in] */ SearchDirectionEnum SearchDirection,
    /* [optional][in] */ VARIANT Start);
void __RPC_STUB _Recordset_Find_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* ___Recordset_INTERFACE_DEFINED__ */
#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Recordset;
Recordset;
#endif
#ifndef __ADORecordsetConstruction_INTERFACE_DEFINED__
#define __ADORecordsetConstruction_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: ADORecordsetConstruction
 * at Thu Dec 04 08:00:50 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][uuid][restricted] */ 
EXTERN_C const IID IID_ADORecordsetConstruction;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("00000283-0000-0010-8000-00AA006D2EA4")
    ADORecordsetConstruction : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Rowset( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppRowset) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Rowset( 
            /* [in] */ IUnknown __RPC_FAR *pRowset) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Chapter( 
            /* [retval][out] */ LONG __RPC_FAR *plChapter) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Chapter( 
            /* [in] */ LONG lChapter) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RowPosition( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppRowPos) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RowPosition( 
            /* [in] */ IUnknown __RPC_FAR *pRowPos) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct ADORecordsetConstructionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ADORecordsetConstruction __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ADORecordsetConstruction __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ADORecordsetConstruction __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ADORecordsetConstruction __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ADORecordsetConstruction __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ADORecordsetConstruction __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ADORecordsetConstruction __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Rowset )( 
            ADORecordsetConstruction __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppRowset);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Rowset )( 
            ADORecordsetConstruction __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pRowset);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Chapter )( 
            ADORecordsetConstruction __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *plChapter);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Chapter )( 
            ADORecordsetConstruction __RPC_FAR * This,
            /* [in] */ LONG lChapter);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RowPosition )( 
            ADORecordsetConstruction __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppRowPos);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_RowPosition )( 
            ADORecordsetConstruction __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pRowPos);
        
        END_INTERFACE
    } ADORecordsetConstructionVtbl;
    interface ADORecordsetConstruction
    {
        CONST_VTBL struct ADORecordsetConstructionVtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define ADORecordsetConstruction_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define ADORecordsetConstruction_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define ADORecordsetConstruction_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define ADORecordsetConstruction_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)
#define ADORecordsetConstruction_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define ADORecordsetConstruction_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define ADORecordsetConstruction_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define ADORecordsetConstruction_get_Rowset(This,ppRowset)	\
    (This)->lpVtbl -> get_Rowset(This,ppRowset)
#define ADORecordsetConstruction_put_Rowset(This,pRowset)	\
    (This)->lpVtbl -> put_Rowset(This,pRowset)
#define ADORecordsetConstruction_get_Chapter(This,plChapter)	\
    (This)->lpVtbl -> get_Chapter(This,plChapter)
#define ADORecordsetConstruction_put_Chapter(This,lChapter)	\
    (This)->lpVtbl -> put_Chapter(This,lChapter)
#define ADORecordsetConstruction_get_RowPosition(This,ppRowPos)	\
    (This)->lpVtbl -> get_RowPosition(This,ppRowPos)
#define ADORecordsetConstruction_put_RowPosition(This,pRowPos)	\
    (This)->lpVtbl -> put_RowPosition(This,pRowPos)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [propget] */ HRESULT STDMETHODCALLTYPE ADORecordsetConstruction_get_Rowset_Proxy( 
    ADORecordsetConstruction __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppRowset);
void __RPC_STUB ADORecordsetConstruction_get_Rowset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput] */ HRESULT STDMETHODCALLTYPE ADORecordsetConstruction_put_Rowset_Proxy( 
    ADORecordsetConstruction __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pRowset);
void __RPC_STUB ADORecordsetConstruction_put_Rowset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE ADORecordsetConstruction_get_Chapter_Proxy( 
    ADORecordsetConstruction __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *plChapter);
void __RPC_STUB ADORecordsetConstruction_get_Chapter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput] */ HRESULT STDMETHODCALLTYPE ADORecordsetConstruction_put_Chapter_Proxy( 
    ADORecordsetConstruction __RPC_FAR * This,
    /* [in] */ LONG lChapter);
void __RPC_STUB ADORecordsetConstruction_put_Chapter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE ADORecordsetConstruction_get_RowPosition_Proxy( 
    ADORecordsetConstruction __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppRowPos);
void __RPC_STUB ADORecordsetConstruction_get_RowPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput] */ HRESULT STDMETHODCALLTYPE ADORecordsetConstruction_put_RowPosition_Proxy( 
    ADORecordsetConstruction __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pRowPos);
void __RPC_STUB ADORecordsetConstruction_put_RowPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* __ADORecordsetConstruction_INTERFACE_DEFINED__ */
#ifndef __Field_INTERFACE_DEFINED__
#define __Field_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: Field
 * at Thu Dec 04 08:00:50 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][helpstring][helpcontext][uuid][nonextensible][dual] */ 
EXTERN_C const IID IID_Field;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("00000505-0000-0010-8000-00AA006D2EA4")
    ADOField : public _ADO
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ActualSize( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Attributes( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_DefinedSize( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ DataTypeEnum __RPC_FAR *pDataType) = 0;
        
        virtual /* [helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ VARIANT Val) = 0;
        
        virtual /* [helpstring][helpcontext][propget] */ HRESULT STDMETHODCALLTYPE get_Precision( 
            /* [retval][out] */ BYTE __RPC_FAR *pbPrecision) = 0;
        
        virtual /* [helpstring][helpcontext][propget] */ HRESULT STDMETHODCALLTYPE get_NumericScale( 
            /* [retval][out] */ BYTE __RPC_FAR *pbNumericScale) = 0;
        
        virtual /* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE AppendChunk( 
            /* [in] */ VARIANT Data) = 0;
        
        virtual /* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE GetChunk( 
            /* [in] */ long Length,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_OriginalValue( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_UnderlyingValue( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct FieldVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ADOField __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ADOField __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ADOField __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ADOField __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ADOField __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ADOField __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ADOField __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][helpcontext][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Properties )( 
            ADOField __RPC_FAR * This,
            /* [retval][out] */ ADOProperties __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ActualSize )( 
            ADOField __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Attributes )( 
            ADOField __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DefinedSize )( 
            ADOField __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        /* [helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            ADOField __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            ADOField __RPC_FAR * This,
            /* [retval][out] */ DataTypeEnum __RPC_FAR *pDataType);
        
        /* [helpstring][helpcontext][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            ADOField __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Value )( 
            ADOField __RPC_FAR * This,
            /* [in] */ VARIANT Val);
        
        /* [helpstring][helpcontext][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Precision )( 
            ADOField __RPC_FAR * This,
            /* [retval][out] */ BYTE __RPC_FAR *pbPrecision);
        
        /* [helpstring][helpcontext][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NumericScale )( 
            ADOField __RPC_FAR * This,
            /* [retval][out] */ BYTE __RPC_FAR *pbNumericScale);
        
        /* [helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppendChunk )( 
            ADOField __RPC_FAR * This,
            /* [in] */ VARIANT Data);
        
        /* [helpstring][helpcontext][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChunk )( 
            ADOField __RPC_FAR * This,
            /* [in] */ long Length,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_OriginalValue )( 
            ADOField __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_UnderlyingValue )( 
            ADOField __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        END_INTERFACE
    } FieldVtbl;
    interface Field
    {
        CONST_VTBL struct FieldVtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define Field_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define Field_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define Field_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define Field_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)
#define Field_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define Field_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define Field_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define Field_get_Properties(This,ppvObject)	\
    (This)->lpVtbl -> get_Properties(This,ppvObject)
#define Field_get_ActualSize(This,pl)	\
    (This)->lpVtbl -> get_ActualSize(This,pl)
#define Field_get_Attributes(This,pl)	\
    (This)->lpVtbl -> get_Attributes(This,pl)
#define Field_get_DefinedSize(This,pl)	\
    (This)->lpVtbl -> get_DefinedSize(This,pl)
#define Field_get_Name(This,pbstr)	\
    (This)->lpVtbl -> get_Name(This,pbstr)
#define Field_get_Type(This,pDataType)	\
    (This)->lpVtbl -> get_Type(This,pDataType)
#define Field_get_Value(This,pvar)	\
    (This)->lpVtbl -> get_Value(This,pvar)
#define Field_put_Value(This,Val)	\
    (This)->lpVtbl -> put_Value(This,Val)
#define Field_get_Precision(This,pbPrecision)	\
    (This)->lpVtbl -> get_Precision(This,pbPrecision)
#define Field_get_NumericScale(This,pbNumericScale)	\
    (This)->lpVtbl -> get_NumericScale(This,pbNumericScale)
#define Field_AppendChunk(This,Data)	\
    (This)->lpVtbl -> AppendChunk(This,Data)
#define Field_GetChunk(This,Length,pvar)	\
    (This)->lpVtbl -> GetChunk(This,Length,pvar)
#define Field_get_OriginalValue(This,pvar)	\
    (This)->lpVtbl -> get_OriginalValue(This,pvar)
#define Field_get_UnderlyingValue(This,pvar)	\
    (This)->lpVtbl -> get_UnderlyingValue(This,pvar)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [propget][id] */ HRESULT STDMETHODCALLTYPE Field_get_ActualSize_Proxy( 
    ADOField __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);
void __RPC_STUB Field_get_ActualSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE Field_get_Attributes_Proxy( 
    ADOField __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);
void __RPC_STUB Field_get_Attributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE Field_get_DefinedSize_Proxy( 
    ADOField __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);
void __RPC_STUB Field_get_DefinedSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE Field_get_Name_Proxy( 
    ADOField __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);
void __RPC_STUB Field_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE Field_get_Type_Proxy( 
    ADOField __RPC_FAR * This,
    /* [retval][out] */ DataTypeEnum __RPC_FAR *pDataType);
void __RPC_STUB Field_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][propget][id] */ HRESULT STDMETHODCALLTYPE Field_get_Value_Proxy( 
    ADOField __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);
void __RPC_STUB Field_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput][id] */ HRESULT STDMETHODCALLTYPE Field_put_Value_Proxy( 
    ADOField __RPC_FAR * This,
    /* [in] */ VARIANT Val);
void __RPC_STUB Field_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][propget] */ HRESULT STDMETHODCALLTYPE Field_get_Precision_Proxy( 
    ADOField __RPC_FAR * This,
    /* [retval][out] */ BYTE __RPC_FAR *pbPrecision);
void __RPC_STUB Field_get_Precision_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][propget] */ HRESULT STDMETHODCALLTYPE Field_get_NumericScale_Proxy( 
    ADOField __RPC_FAR * This,
    /* [retval][out] */ BYTE __RPC_FAR *pbNumericScale);
void __RPC_STUB Field_get_NumericScale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Field_AppendChunk_Proxy( 
    ADOField __RPC_FAR * This,
    /* [in] */ VARIANT Data);
void __RPC_STUB Field_AppendChunk_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][id] */ HRESULT STDMETHODCALLTYPE Field_GetChunk_Proxy( 
    ADOField __RPC_FAR * This,
    /* [in] */ long Length,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);
void __RPC_STUB Field_GetChunk_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE Field_get_OriginalValue_Proxy( 
    ADOField __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);
void __RPC_STUB Field_get_OriginalValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget][id] */ HRESULT STDMETHODCALLTYPE Field_get_UnderlyingValue_Proxy( 
    ADOField __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);
void __RPC_STUB Field_get_UnderlyingValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* __Field_INTERFACE_DEFINED__ */
#ifndef __Fields_INTERFACE_DEFINED__
#define __Fields_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: Fields
 * at Thu Dec 04 08:00:50 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][uuid][helpstring][helpcontext][nonextensible][dual] */ 
EXTERN_C const IID IID_Fields;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("00000506-0000-0010-8000-00AA006D2EA4")
    ADOFields : public _ADOCollection
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ ADOField __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct FieldsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ADOFields __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ADOFields __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ADOFields __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ADOFields __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ADOFields __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ADOFields __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ADOFields __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][helpcontext][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            ADOFields __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *c);
        
        /* [id][restricted] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_NewEnum )( 
            ADOFields __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [helpstring][helpcontext] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            ADOFields __RPC_FAR * This);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            ADOFields __RPC_FAR * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ ADOField __RPC_FAR *__RPC_FAR *ppvObject);
        
        END_INTERFACE
    } FieldsVtbl;
    interface Fields
    {
        CONST_VTBL struct FieldsVtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define Fields_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define Fields_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define Fields_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define Fields_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)
#define Fields_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define Fields_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define Fields_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define Fields_get_Count(This,c)	\
    (This)->lpVtbl -> get_Count(This,c)
#define Fields__NewEnum(This,ppvObject)	\
    (This)->lpVtbl -> _NewEnum(This,ppvObject)
#define Fields_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)
#define Fields_get_Item(This,Index,ppvObject)	\
    (This)->lpVtbl -> get_Item(This,Index,ppvObject)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [id][propget] */ HRESULT STDMETHODCALLTYPE Fields_get_Item_Proxy( 
    ADOFields __RPC_FAR * This,
    /* [in] */ VARIANT Index,
    /* [retval][out] */ ADOField __RPC_FAR *__RPC_FAR *ppvObject);
void __RPC_STUB Fields_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* __Fields_INTERFACE_DEFINED__ */
#ifndef ___Parameter_INTERFACE_DEFINED__
#define ___Parameter_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: _Parameter
 * at Thu Dec 04 08:00:50 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][helpstring][helpcontext][uuid][nonextensible][dual] */ 
EXTERN_C const IID IID__Parameter;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0000050C-0000-0010-8000-00AA006D2EA4")
    _ADOParameter : public _ADO
    {
    public:
        virtual /* [helpstring][helpcontext][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [helpstring][helpcontext][propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR bstr) = 0;
        
        virtual /* [helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ VARIANT val) = 0;
        
        virtual /* [helpstring][helpcontext][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ DataTypeEnum __RPC_FAR *psDataType) = 0;
        
        virtual /* [helpstring][helpcontext][propput] */ HRESULT STDMETHODCALLTYPE put_Type( 
            /* [in] */ DataTypeEnum sDataType) = 0;
        
        virtual /* [helpstring][helpcontext][propput] */ HRESULT STDMETHODCALLTYPE put_Direction( 
            /* [in] */ ParameterDirectionEnum lParmDirection) = 0;
        
        virtual /* [helpstring][helpcontext][propget] */ HRESULT STDMETHODCALLTYPE get_Direction( 
            /* [retval][out] */ ParameterDirectionEnum __RPC_FAR *plParmDirection) = 0;
        
        virtual /* [helpstring][helpcontext][propput] */ HRESULT STDMETHODCALLTYPE put_Precision( 
            /* [in] */ BYTE bPrecision) = 0;
        
        virtual /* [helpstring][helpcontext][propget] */ HRESULT STDMETHODCALLTYPE get_Precision( 
            /* [retval][out] */ BYTE __RPC_FAR *pbPrecision) = 0;
        
        virtual /* [helpstring][helpcontext][propput] */ HRESULT STDMETHODCALLTYPE put_NumericScale( 
            /* [in] */ BYTE bScale) = 0;
        
        virtual /* [helpstring][helpcontext][propget] */ HRESULT STDMETHODCALLTYPE get_NumericScale( 
            /* [retval][out] */ BYTE __RPC_FAR *pbScale) = 0;
        
        virtual /* [helpstring][helpcontext][propput] */ HRESULT STDMETHODCALLTYPE put_Size( 
            /* [in] */ long l) = 0;
        
        virtual /* [helpstring][helpcontext][propget] */ HRESULT STDMETHODCALLTYPE get_Size( 
            /* [retval][out] */ long __RPC_FAR *pl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AppendChunk( 
            /* [in] */ VARIANT Val) = 0;
        
        virtual /* [helpstring][helpcontext][propget] */ HRESULT STDMETHODCALLTYPE get_Attributes( 
            /* [retval][out] */ LONG __RPC_FAR *plParmAttribs) = 0;
        
        virtual /* [helpstring][helpcontext][propput] */ HRESULT STDMETHODCALLTYPE put_Attributes( 
            /* [in] */ LONG lParmAttribs) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct _ParameterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _ADOParameter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _ADOParameter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _ADOParameter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _ADOParameter __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _ADOParameter __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _ADOParameter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _ADOParameter __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][helpcontext][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Properties )( 
            _ADOParameter __RPC_FAR * This,
            /* [retval][out] */ ADOProperties __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [helpstring][helpcontext][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            _ADOParameter __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [helpstring][helpcontext][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            _ADOParameter __RPC_FAR * This,
            /* [in] */ BSTR bstr);
        
        /* [helpstring][helpcontext][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            _ADOParameter __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Value )( 
            _ADOParameter __RPC_FAR * This,
            /* [in] */ VARIANT val);
        
        /* [helpstring][helpcontext][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            _ADOParameter __RPC_FAR * This,
            /* [retval][out] */ DataTypeEnum __RPC_FAR *psDataType);
        
        /* [helpstring][helpcontext][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Type )( 
            _ADOParameter __RPC_FAR * This,
            /* [in] */ DataTypeEnum sDataType);
        
        /* [helpstring][helpcontext][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Direction )( 
            _ADOParameter __RPC_FAR * This,
            /* [in] */ ParameterDirectionEnum lParmDirection);
        
        /* [helpstring][helpcontext][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Direction )( 
            _ADOParameter __RPC_FAR * This,
            /* [retval][out] */ ParameterDirectionEnum __RPC_FAR *plParmDirection);
        
        /* [helpstring][helpcontext][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Precision )( 
            _ADOParameter __RPC_FAR * This,
            /* [in] */ BYTE bPrecision);
        
        /* [helpstring][helpcontext][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Precision )( 
            _ADOParameter __RPC_FAR * This,
            /* [retval][out] */ BYTE __RPC_FAR *pbPrecision);
        
        /* [helpstring][helpcontext][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_NumericScale )( 
            _ADOParameter __RPC_FAR * This,
            /* [in] */ BYTE bScale);
        
        /* [helpstring][helpcontext][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NumericScale )( 
            _ADOParameter __RPC_FAR * This,
            /* [retval][out] */ BYTE __RPC_FAR *pbScale);
        
        /* [helpstring][helpcontext][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Size )( 
            _ADOParameter __RPC_FAR * This,
            /* [in] */ long l);
        
        /* [helpstring][helpcontext][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Size )( 
            _ADOParameter __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppendChunk )( 
            _ADOParameter __RPC_FAR * This,
            /* [in] */ VARIANT Val);
        
        /* [helpstring][helpcontext][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Attributes )( 
            _ADOParameter __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *plParmAttribs);
        
        /* [helpstring][helpcontext][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Attributes )( 
            _ADOParameter __RPC_FAR * This,
            /* [in] */ LONG lParmAttribs);
        
        END_INTERFACE
    } _ParameterVtbl;
    interface _Parameter
    {
        CONST_VTBL struct _ParameterVtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define _Parameter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define _Parameter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define _Parameter_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define _Parameter_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)
#define _Parameter_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define _Parameter_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define _Parameter_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define _Parameter_get_Properties(This,ppvObject)	\
    (This)->lpVtbl -> get_Properties(This,ppvObject)
#define _Parameter_get_Name(This,pbstr)	\
    (This)->lpVtbl -> get_Name(This,pbstr)
#define _Parameter_put_Name(This,bstr)	\
    (This)->lpVtbl -> put_Name(This,bstr)
#define _Parameter_get_Value(This,pvar)	\
    (This)->lpVtbl -> get_Value(This,pvar)
#define _Parameter_put_Value(This,val)	\
    (This)->lpVtbl -> put_Value(This,val)
#define _Parameter_get_Type(This,psDataType)	\
    (This)->lpVtbl -> get_Type(This,psDataType)
#define _Parameter_put_Type(This,sDataType)	\
    (This)->lpVtbl -> put_Type(This,sDataType)
#define _Parameter_put_Direction(This,lParmDirection)	\
    (This)->lpVtbl -> put_Direction(This,lParmDirection)
#define _Parameter_get_Direction(This,plParmDirection)	\
    (This)->lpVtbl -> get_Direction(This,plParmDirection)
#define _Parameter_put_Precision(This,bPrecision)	\
    (This)->lpVtbl -> put_Precision(This,bPrecision)
#define _Parameter_get_Precision(This,pbPrecision)	\
    (This)->lpVtbl -> get_Precision(This,pbPrecision)
#define _Parameter_put_NumericScale(This,bScale)	\
    (This)->lpVtbl -> put_NumericScale(This,bScale)
#define _Parameter_get_NumericScale(This,pbScale)	\
    (This)->lpVtbl -> get_NumericScale(This,pbScale)
#define _Parameter_put_Size(This,l)	\
    (This)->lpVtbl -> put_Size(This,l)
#define _Parameter_get_Size(This,pl)	\
    (This)->lpVtbl -> get_Size(This,pl)
#define _Parameter_AppendChunk(This,Val)	\
    (This)->lpVtbl -> AppendChunk(This,Val)
#define _Parameter_get_Attributes(This,plParmAttribs)	\
    (This)->lpVtbl -> get_Attributes(This,plParmAttribs)
#define _Parameter_put_Attributes(This,lParmAttribs)	\
    (This)->lpVtbl -> put_Attributes(This,lParmAttribs)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [helpstring][helpcontext][propget] */ HRESULT STDMETHODCALLTYPE _Parameter_get_Name_Proxy( 
    _ADOParameter __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);
void __RPC_STUB _Parameter_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][propput] */ HRESULT STDMETHODCALLTYPE _Parameter_put_Name_Proxy( 
    _ADOParameter __RPC_FAR * This,
    /* [in] */ BSTR bstr);
void __RPC_STUB _Parameter_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][id][propget] */ HRESULT STDMETHODCALLTYPE _Parameter_get_Value_Proxy( 
    _ADOParameter __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);
void __RPC_STUB _Parameter_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propput] */ HRESULT STDMETHODCALLTYPE _Parameter_put_Value_Proxy( 
    _ADOParameter __RPC_FAR * This,
    /* [in] */ VARIANT val);
void __RPC_STUB _Parameter_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][propget] */ HRESULT STDMETHODCALLTYPE _Parameter_get_Type_Proxy( 
    _ADOParameter __RPC_FAR * This,
    /* [retval][out] */ DataTypeEnum __RPC_FAR *psDataType);
void __RPC_STUB _Parameter_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][propput] */ HRESULT STDMETHODCALLTYPE _Parameter_put_Type_Proxy( 
    _ADOParameter __RPC_FAR * This,
    /* [in] */ DataTypeEnum sDataType);
void __RPC_STUB _Parameter_put_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][propput] */ HRESULT STDMETHODCALLTYPE _Parameter_put_Direction_Proxy( 
    _ADOParameter __RPC_FAR * This,
    /* [in] */ ParameterDirectionEnum lParmDirection);
void __RPC_STUB _Parameter_put_Direction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][propget] */ HRESULT STDMETHODCALLTYPE _Parameter_get_Direction_Proxy( 
    _ADOParameter __RPC_FAR * This,
    /* [retval][out] */ ParameterDirectionEnum __RPC_FAR *plParmDirection);
void __RPC_STUB _Parameter_get_Direction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][propput] */ HRESULT STDMETHODCALLTYPE _Parameter_put_Precision_Proxy( 
    _ADOParameter __RPC_FAR * This,
    /* [in] */ BYTE bPrecision);
void __RPC_STUB _Parameter_put_Precision_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][propget] */ HRESULT STDMETHODCALLTYPE _Parameter_get_Precision_Proxy( 
    _ADOParameter __RPC_FAR * This,
    /* [retval][out] */ BYTE __RPC_FAR *pbPrecision);
void __RPC_STUB _Parameter_get_Precision_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][propput] */ HRESULT STDMETHODCALLTYPE _Parameter_put_NumericScale_Proxy( 
    _ADOParameter __RPC_FAR * This,
    /* [in] */ BYTE bScale);
void __RPC_STUB _Parameter_put_NumericScale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][propget] */ HRESULT STDMETHODCALLTYPE _Parameter_get_NumericScale_Proxy( 
    _ADOParameter __RPC_FAR * This,
    /* [retval][out] */ BYTE __RPC_FAR *pbScale);
void __RPC_STUB _Parameter_get_NumericScale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][propput] */ HRESULT STDMETHODCALLTYPE _Parameter_put_Size_Proxy( 
    _ADOParameter __RPC_FAR * This,
    /* [in] */ long l);
void __RPC_STUB _Parameter_put_Size_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][propget] */ HRESULT STDMETHODCALLTYPE _Parameter_get_Size_Proxy( 
    _ADOParameter __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pl);
void __RPC_STUB _Parameter_get_Size_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
HRESULT STDMETHODCALLTYPE _Parameter_AppendChunk_Proxy( 
    _ADOParameter __RPC_FAR * This,
    /* [in] */ VARIANT Val);
void __RPC_STUB _Parameter_AppendChunk_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][propget] */ HRESULT STDMETHODCALLTYPE _Parameter_get_Attributes_Proxy( 
    _ADOParameter __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *plParmAttribs);
void __RPC_STUB _Parameter_get_Attributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [helpstring][helpcontext][propput] */ HRESULT STDMETHODCALLTYPE _Parameter_put_Attributes_Proxy( 
    _ADOParameter __RPC_FAR * This,
    /* [in] */ LONG lParmAttribs);
void __RPC_STUB _Parameter_put_Attributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* ___Parameter_INTERFACE_DEFINED__ */
#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Parameter;
Parameter;
#endif
#ifndef __Parameters_INTERFACE_DEFINED__
#define __Parameters_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: Parameters
 * at Thu Dec 04 08:00:50 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][uuid][helpstring][helpcontext][nonextensible][dual] */ 
EXTERN_C const IID IID_Parameters;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0000050D-0000-0010-8000-00AA006D2EA4")
    ADOParameters : public _ADODynaCollection
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ _ADOParameter __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct ParametersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ADOParameters __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ADOParameters __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ADOParameters __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ADOParameters __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ADOParameters __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ADOParameters __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ADOParameters __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][helpcontext][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            ADOParameters __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *c);
        
        /* [id][restricted] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_NewEnum )( 
            ADOParameters __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [helpstring][helpcontext] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            ADOParameters __RPC_FAR * This);
        
        /* [helpstring][helpcontext] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Append )( 
            ADOParameters __RPC_FAR * This,
            /* [in] */ IDispatch __RPC_FAR *Object);
        
        /* [helpstring][helpcontext] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            ADOParameters __RPC_FAR * This,
            /* [in] */ VARIANT Index);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            ADOParameters __RPC_FAR * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ _ADOParameter __RPC_FAR *__RPC_FAR *ppvObject);
        
        END_INTERFACE
    } ParametersVtbl;
    interface Parameters
    {
        CONST_VTBL struct ParametersVtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define Parameters_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define Parameters_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define Parameters_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define Parameters_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)
#define Parameters_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define Parameters_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define Parameters_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define Parameters_get_Count(This,c)	\
    (This)->lpVtbl -> get_Count(This,c)
#define Parameters__NewEnum(This,ppvObject)	\
    (This)->lpVtbl -> _NewEnum(This,ppvObject)
#define Parameters_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)
#define Parameters_Append(This,Object)	\
    (This)->lpVtbl -> Append(This,Object)
#define Parameters_Delete(This,Index)	\
    (This)->lpVtbl -> Delete(This,Index)
#define Parameters_get_Item(This,Index,ppvObject)	\
    (This)->lpVtbl -> get_Item(This,Index,ppvObject)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [id][propget] */ HRESULT STDMETHODCALLTYPE Parameters_get_Item_Proxy( 
    ADOParameters __RPC_FAR * This,
    /* [in] */ VARIANT Index,
    /* [retval][out] */ _ADOParameter __RPC_FAR *__RPC_FAR *ppvObject);
void __RPC_STUB Parameters_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* __Parameters_INTERFACE_DEFINED__ */
#ifndef __Property_INTERFACE_DEFINED__
#define __Property_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: Property
 * at Thu Dec 04 08:00:50 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][helpstring][helpcontext][uuid][nonextensible][dual] */ 
EXTERN_C const IID IID_Property;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("00000503-0000-0010-8000-00AA006D2EA4")
    ADOProperty : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ VARIANT __RPC_FAR *pval) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ VARIANT val) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ DataTypeEnum __RPC_FAR *ptype) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Attributes( 
            /* [retval][out] */ long __RPC_FAR *plAttributes) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Attributes( 
            /* [in] */ long lAttributes) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct PropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ADOProperty __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ADOProperty __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ADOProperty __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ADOProperty __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ADOProperty __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ADOProperty __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ADOProperty __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            ADOProperty __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pval);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Value )( 
            ADOProperty __RPC_FAR * This,
            /* [in] */ VARIANT val);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            ADOProperty __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            ADOProperty __RPC_FAR * This,
            /* [retval][out] */ DataTypeEnum __RPC_FAR *ptype);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Attributes )( 
            ADOProperty __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plAttributes);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Attributes )( 
            ADOProperty __RPC_FAR * This,
            /* [in] */ long lAttributes);
        
        END_INTERFACE
    } PropertyVtbl;
    interface Property
    {
        CONST_VTBL struct PropertyVtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define Property_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define Property_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define Property_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define Property_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)
#define Property_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define Property_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define Property_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define Property_get_Value(This,pval)	\
    (This)->lpVtbl -> get_Value(This,pval)
#define Property_put_Value(This,val)	\
    (This)->lpVtbl -> put_Value(This,val)
#define Property_get_Name(This,pbstr)	\
    (This)->lpVtbl -> get_Name(This,pbstr)
#define Property_get_Type(This,ptype)	\
    (This)->lpVtbl -> get_Type(This,ptype)
#define Property_get_Attributes(This,plAttributes)	\
    (This)->lpVtbl -> get_Attributes(This,plAttributes)
#define Property_put_Attributes(This,lAttributes)	\
    (This)->lpVtbl -> put_Attributes(This,lAttributes)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [id][propget] */ HRESULT STDMETHODCALLTYPE Property_get_Value_Proxy( 
    ADOProperty __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pval);
void __RPC_STUB Property_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [id][propput] */ HRESULT STDMETHODCALLTYPE Property_put_Value_Proxy( 
    ADOProperty __RPC_FAR * This,
    /* [in] */ VARIANT val);
void __RPC_STUB Property_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE Property_get_Name_Proxy( 
    ADOProperty __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);
void __RPC_STUB Property_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE Property_get_Type_Proxy( 
    ADOProperty __RPC_FAR * This,
    /* [retval][out] */ DataTypeEnum __RPC_FAR *ptype);
void __RPC_STUB Property_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propget] */ HRESULT STDMETHODCALLTYPE Property_get_Attributes_Proxy( 
    ADOProperty __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plAttributes);
void __RPC_STUB Property_get_Attributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
/* [propput] */ HRESULT STDMETHODCALLTYPE Property_put_Attributes_Proxy( 
    ADOProperty __RPC_FAR * This,
    /* [in] */ long lAttributes);
void __RPC_STUB Property_put_Attributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* __Property_INTERFACE_DEFINED__ */
#ifndef __Properties_INTERFACE_DEFINED__
#define __Properties_INTERFACE_DEFINED__
/****************************************
 * Generated header for interface: Properties
 * at Thu Dec 04 08:00:50 1997
 * using MIDL 3.01.75
 ****************************************/
/* [object][uuid][helpstring][helpcontext][nonextensible][dual] */ 
EXTERN_C const IID IID_Properties;
#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("00000504-0000-0010-8000-00AA006D2EA4")
    ADOProperties : public _ADOCollection
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ ADOProperty __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
    };
    
#else 	/* C style interface */
    typedef struct PropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ADOProperties __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ADOProperties __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ADOProperties __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ADOProperties __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ADOProperties __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ADOProperties __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ADOProperties __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][helpcontext][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            ADOProperties __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *c);
        
        /* [id][restricted] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_NewEnum )( 
            ADOProperties __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);
        
        /* [helpstring][helpcontext] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            ADOProperties __RPC_FAR * This);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            ADOProperties __RPC_FAR * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ ADOProperty __RPC_FAR *__RPC_FAR *ppvObject);
        
        END_INTERFACE
    } PropertiesVtbl;
    interface Properties
    {
        CONST_VTBL struct PropertiesVtbl __RPC_FAR *lpVtbl;
    };
    
#ifdef COBJMACROS
#define Properties_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define Properties_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)
#define Properties_Release(This)	\
    (This)->lpVtbl -> Release(This)
#define Properties_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)
#define Properties_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)
#define Properties_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)
#define Properties_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)
#define Properties_get_Count(This,c)	\
    (This)->lpVtbl -> get_Count(This,c)
#define Properties__NewEnum(This,ppvObject)	\
    (This)->lpVtbl -> _NewEnum(This,ppvObject)
#define Properties_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)
#define Properties_get_Item(This,Index,ppvObject)	\
    (This)->lpVtbl -> get_Item(This,Index,ppvObject)
#endif /* COBJMACROS */
#endif 	/* C style interface */
/* [id][propget] */ HRESULT STDMETHODCALLTYPE Properties_get_Item_Proxy( 
    ADOProperties __RPC_FAR * This,
    /* [in] */ VARIANT Index,
    /* [retval][out] */ ADOProperty __RPC_FAR *__RPC_FAR *ppvObject);
void __RPC_STUB Properties_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);
#endif 	/* __Properties_INTERFACE_DEFINED__ */
#endif /* __ADODB_LIBRARY_DEFINED__ */
/* Additional Prototypes for ALL interfaces */
/* end of Additional Prototypes */
#ifdef __cplusplus
}
#endif
#endif
#define ADOCommand _ADOCommand
#define ADORecordset _ADORecordset
#define ADOParameter _ADOParameter
#define ADOConnection _ADOConnection
#define ADOCollection _ADOCollection
#define ADODynaCollection _ADODynaCollection


#endif // _ADOINT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\broadcast\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by simple.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\faxapi\faxapi.cpp ===
// FaxApi.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "FaxApi.h"

#include "MainFrm.h"
#include "FxApiDoc.h"
#include "function.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFaxApiApp

BEGIN_MESSAGE_MAP(CFaxApiApp, CWinApp)
	//{{AFX_MSG_MAP(CFaxApiApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFaxApiApp construction

CFaxApiApp::CFaxApiApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CFaxApiApp object

CFaxApiApp FaxApiBrowserApp;

CFaxApiApp *	pFaxApiBrowserApp;	// This pointer is declared external in
                                    // other modules where access to certain
                                    // member functions of the CFaxApiApp
                                    // object are needed.

/////////////////////////////////////////////////////////////////////////////
// CFaxApiApp initialization

BOOL CFaxApiApp::InitInstance()
{
   BOOL  fReturnValue;

	pFaxApiBrowserApp = &FaxApiBrowserApp;	// Initialize the pointer to the
	                                        // CFaxApiApp object.

   /* Initialize the array of pointers to CFaxApiFunctionInfo objects. */

   fReturnValue = InitFaxApiFunctionInfoPointerArray();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

#ifdef	NOT_NEEDED
	// Change the registry key under which our settings are stored.
	// You should modify this string to be something appropriate
	// such as the name of your company or organization.
	SetRegistryKey(_T("Local AppWizard-Generated Applications"));

	LoadStdProfileSettings();  // Load standard INI file options (including MRU)
#endif	// NOT_NEEDED

	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	CSingleDocTemplate* pDocTemplate;
	pDocTemplate = new CSingleDocTemplate(
		IDR_MAINFRAME,
		RUNTIME_CLASS(CFaxApiDoc),
		RUNTIME_CLASS(CMainFrame),       // main SDI frame window
		RUNTIME_CLASS(CFormView));
	AddDocTemplate(pDocTemplate);

	// Parse command line for standard shell commands, DDE, file open
	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);

	// Dispatch commands specified on the command line
	if (!ProcessShellCommand(cmdInfo))
		return FALSE;

	// The one and only window has been initialized, so show and update it.
	m_pMainWnd->ShowWindow(SW_SHOW);
	m_pMainWnd->UpdateWindow();

	return ( fReturnValue );
}

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CFaxApiApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CFaxApiApp commands




// There are five views derived from CFormView that populate the panes of the
// splitter windows that overlay the CMainFrame. Since each view object is
// constructed at the time that the associated CSplitterWnd::CreateView() call
// is made, it is necessary to record the HWND for each view so that a pointer
// the the view object may be obtained when it is necessary for the views to
// communicate.

// The HWND values for each view are recorded in private data members of the
// CFaxApiApp object.

// Each of the following set of functions stored the HWND for a view object in
// a private data member of the CFaxApiApp object.



void CFaxApiApp::StoreFunctionInfoFormViewHWND( HWND hView )
{
	m_hwndFunctionInfoFormView = hView;
}



void CFaxApiApp::StoreParameterInfoFormViewHWND( HWND hView )
{
	m_hwndParameterInfoFormView = hView;
}



void CFaxApiApp::StoreReturnValueOutputFormViewHWND( HWND hView )
{
	m_hwndReturnValueOutputFormView = hView;
}



void CFaxApiApp::StoreExecutionLogFormViewHWND( HWND hView )
{
	m_hwndExecutionLogFormView = hView;
}



void CFaxApiApp::StoreFaxApiFunctionSelectionFormViewHWND( HWND hView )
{
	m_hwndFaxApiFunctionSelectionFormView = hView;
}

// Each of the following set of functions returns a pointer to the view object.
// That pointer is obtained by CWnd::FromHandle() to which the HWND for the
// view object is passed.

CWnd * CFaxApiApp::GetFunctionInfoFormViewPointer()
{
	CWnd *	pFunctionInfoFormView;

	pFunctionInfoFormView = CWnd::FromHandle( m_hwndFunctionInfoFormView );

	return ( pFunctionInfoFormView );
}



CWnd * CFaxApiApp::GetParameterInfoFormViewPointer()
{
	CWnd *	pParameterInfoFormView;

	pParameterInfoFormView = CWnd::FromHandle( m_hwndParameterInfoFormView );

	return ( pParameterInfoFormView );
}



CWnd * CFaxApiApp::GetReturnValueOutputFormViewPointer()
{
	CWnd *	pReturnValueOutputFormView;

	pReturnValueOutputFormView = CWnd::FromHandle( m_hwndReturnValueOutputFormView );

	return ( pReturnValueOutputFormView );
}



CWnd * CFaxApiApp::GetExecutionLogFormViewPointer()
{
	CWnd *	pExecutionLogFormView;

	pExecutionLogFormView = CWnd::FromHandle( m_hwndExecutionLogFormView );

	return ( pExecutionLogFormView );
}



CWnd * CFaxApiApp::GetFaxApiFunctionSelectionFormViewPointer()
{
	CWnd *	pFaxApiFunctionSelectionFormView;

	pFaxApiFunctionSelectionFormView = CWnd::FromHandle( m_hwndFaxApiFunctionSelectionFormView );

	return ( pFaxApiFunctionSelectionFormView );
}



/*
 *  InitFaxApiFunctionInfoPointerArray
 *
 *  Purpose: 
 *          This function initializes the CObArray object whose elements are
 *          pointers to CFaxApiFunctionInfo objects. The individual
 *          CFaxApiFunctionInfo objects are allocated (via the new operator)
 *          and initialized using data that is read from the Fax API Browser
 *          initialization file.
 *
 *  Arguments:
 *          None
 *
 *  Returns:
 *          TRUE - indicates success
 *          FALSE - indicates failure
 *
 *  Note:
 *          The Fax API Browser initialization file consists of one section
 *          for each Fax API function.
 *
 */

BOOL CFaxApiApp::InitFaxApiFunctionInfoPointerArray()
{
   BOOL     fReturnValue = (BOOL) TRUE;

   /* Verify that the Fax API Browser initialization file is present. */

   CFile cfTempFile;
   CFileException cfeTemp;

   if ( cfTempFile.Open( TEXT(".\\faxapi.ini"), CFile::modeRead, &cfeTemp ) ==
        (BOOL) TRUE )
   {
      /* INI file is readable. */

      cfTempFile.Close();

      /* Get a list of the section names in the Fax API Browser initialization */
      /* file. The section names map into Fax API function names.              */

      TCHAR    tszSectionNames[5000];           // This is arbirtarily large.
                                                // As of 9/24/97 there are 47
                                                // Fax Api functions. The longest
                                                // function name at this time is
                                                // 26 characters.

      DWORD    dwGPPSNrv = (DWORD) 0;           // returned by GetPrivateProfileSectionNames


      /* Read the section names (Fax API function names) from the initialization */
      /* file into a NULL terminated list of section names delimited by NULLs.   */

      dwGPPSNrv = GetPrivateProfileSectionNames( (LPTSTR) &tszSectionNames,
                                                 (DWORD) sizeof( tszSectionNames ),
                                                 (LPCTSTR) TEXT(".\\faxapi.ini") );

      /* Were the section names read successfully ? */

      if ( dwGPPSNrv > 0 )
      {
         /* How many section names were read ? */

         TCHAR *   ptszSectionName;

         CStringArray   csaSectionNames;

         DWORD          dwErrorCode;


         ptszSectionName = tszSectionNames;

         while ( (*ptszSectionName != (TCHAR) L'\0') && (fReturnValue == (BOOL) TRUE) )
         {
            try
            {
               csaSectionNames.Add( (LPCTSTR) ptszSectionName );
            }

            catch ( ... )
            {
               dwErrorCode = GetLastError();

               if ( dwErrorCode == (DWORD) NO_ERROR )
               {
                  dwErrorCode = (DWORD) ERROR_NOT_ENOUGH_MEMORY;

                  fReturnValue = (BOOL) FALSE;
               }
            }

            if ( fReturnValue == (BOOL) TRUE )
            {
               /* Search for the next (TCHAR) null. */

               while ( *(ptszSectionName++) != (TCHAR) L'\0' );
            }
         }  // end of outer while loop

         /* Find out how many section names were extracted from the buffer. */

         int   xNumberOfSectionNames;

         xNumberOfSectionNames = csaSectionNames.GetSize();

         /* Initialize the size of the CObArray object. */

         m_coaFaxApiFunctionInfo.SetSize( xNumberOfSectionNames );

         /* Start adding elements to m_caoFaxApiFinctionInfo. The elements */
         /* are pointers to CFaxApiFunctionInfo objects.                   */

         CFaxApiFunctionInfo *   pcfafiElement;

         int   xElementIndex;

         CString  csFunctionName;
         CString  csFunctionPrototype;
         CString  csReturnType;
         CString  csReturnValueDescription;
         CString  csRemarks;

         DWORD    dwGPPSrv;                  // returned by GetPrivateProfileString

         TCHAR    tszProfileString[500];     // arbitrarily chosen size


         for ( xElementIndex = 0; xElementIndex < xNumberOfSectionNames; xElementIndex++ )
         {
            if ( fReturnValue == (BOOL) TRUE )
            {
               /* Gather the information necessary to create and initialize a */
               /* CFaxApiFunctionInfo object.                                 */


               csFunctionName = csaSectionNames.GetAt( xElementIndex );

               /* Read the rest of the info from the ini file. */

               // Read the "Function Prototype" from the ini file.

               dwGPPSrv = GetPrivateProfileString( (LPCTSTR) csFunctionName,
                                                   (LPCTSTR) TEXT("Prototype"),
                                                   (LPCTSTR) TEXT("NULL"),
                                                   (LPTSTR) tszProfileString,
                                                   (DWORD) sizeof( tszProfileString ),
                                                   (LPCTSTR) TEXT(".\\faxapi.ini") );

               /* Did GetPrivateProfileString return the string "NULL" ? */
      
               if ( _wcsicmp( tszProfileString, TEXT("NULL") ) != 0 )
               {
                  /* Did GetPrivateProfileString read an entry ? */
      
                  if ( dwGPPSrv > (DWORD) 0L )
                  {
                     csFunctionPrototype = (CString) tszProfileString;
                  }
                  else
                  {
                     csFunctionPrototype = (CString) TEXT("Error reading faxapi.ini");
                  }
               }
               else
               {
                  csFunctionPrototype = (CString) TEXT("Error reading faxapi.ini");
               }

               // Read the "Return Type" from the ini file.

               dwGPPSrv = GetPrivateProfileString( (LPCTSTR) csFunctionName,
                                                   (LPCTSTR) TEXT("ReturnType"),
                                                   (LPCTSTR) TEXT("NULL"),
                                                   (LPTSTR) tszProfileString,
                                                   (DWORD) sizeof( tszProfileString ),
                                                   (LPCTSTR) TEXT(".\\faxapi.ini") );

               /* Did GetPrivateProfileString return the string "NULL" ? */
      
               if ( _wcsicmp( tszProfileString, TEXT("NULL") ) != 0 )
               {
                  /* Did GetPrivateProfileString read an entry ? */
      
                  if ( dwGPPSrv > (DWORD) 0L )
                  {
                     csReturnType = (CString) tszProfileString;
                  }
                  else
                  {
                     csReturnType = (CString) TEXT("Error reading faxapi.ini");
                  }
               }
               else
               {
                  csReturnType = (CString) TEXT("Error reading faxapi.ini");
               }

               // Read the "Return Value Description" from the ini file.

               dwGPPSrv = GetPrivateProfileString( (LPCTSTR) csFunctionName,
                                                   (LPCTSTR) TEXT("ReturnValueDescription"),
                                                   (LPCTSTR) TEXT("NULL"),
                                                   (LPTSTR) tszProfileString,
                                                   (DWORD) sizeof( tszProfileString ),
                                                   (LPCTSTR) TEXT(".\\faxapi.ini") );

               /* Did GetPrivateProfileString return the string "NULL" ? */
      
               if ( _wcsicmp( tszProfileString, TEXT("NULL") ) != 0 )
               {
                  /* Did GetPrivateProfileString read an entry ? */
      
                  if ( dwGPPSrv > (DWORD) 0L )
                  {
                     csReturnValueDescription = (CString) tszProfileString;
                  }
                  else
                  {
                     csReturnValueDescription = (CString) TEXT("Error reading faxapi.ini");
                  }
               }
               else
               {
                  csReturnValueDescription = (CString) TEXT("Error reading faxapi.ini");
               }

               // Read the "Remarks" from the ini file.

               dwGPPSrv = GetPrivateProfileString( (LPCTSTR) csFunctionName,
                                                   (LPCTSTR) TEXT("Remarks"),
                                                   (LPCTSTR) TEXT("NULL"),
                                                   (LPTSTR) tszProfileString,
                                                   (DWORD) sizeof( tszProfileString ),
                                                   (LPCTSTR) TEXT(".\\faxapi.ini") );

               /* Did GetPrivateProfileString return the string "NULL" ? */
      
               if ( _wcsicmp( tszProfileString, TEXT("NULL") ) != 0 )
               {
                  /* Did GetPrivateProfileString read an entry ? */
      
                  if ( dwGPPSrv > (DWORD) 0L )
                  {
                     csRemarks = (CString) tszProfileString;
                  }
                  else
                  {
                     csRemarks = (CString) TEXT("Error reading faxapi.ini");
                  }
               }
               else
               {
                  csRemarks = (CString) TEXT("Error reading faxapi.ini");
               }

               /* Create a CFaxApiFunctionInfo object. */

               pcfafiElement = new CFaxApiFunctionInfo(
                                         (const CString &) csFunctionName,
                                         (const CString &) csFunctionPrototype,
                                         (const CString &) csReturnType,
                                         (const CString &) csReturnValueDescription,
                                         (const CString &) csRemarks );

               if ( pcfafiElement != (CFaxApiFunctionInfo *) NULL )
               {
                  /* Add the pointer to the CFaxApiFunctionInfo object to the array. */

                  try
                  {
                     m_coaFaxApiFunctionInfo.SetAtGrow( xElementIndex, pcfafiElement );
                  }

                  catch ( ... )
                  {
                     dwErrorCode = GetLastError();

                     if ( dwErrorCode == (DWORD) NO_ERROR )
                     {
                        dwErrorCode = (DWORD) ERROR_NOT_ENOUGH_MEMORY;

                        fReturnValue = (BOOL) FALSE;
                     }
                  }
               }
            }
            else
            {
               /* An error occured while attempting to add an element to */
               /* m_coaFaxApiFunctionInfo. Terminate !                   */

               break;
            }
         }     // end of for loop adding elements to m_coaFaxApiFunctionInfo

         m_coaFaxApiFunctionInfo.FreeExtra();

         fReturnValue = (BOOL) TRUE;
      }
      else
      {
         /* No section names were read from the Fax API Browser initialization file. */

         fReturnValue = (BOOL) FALSE;
      }
   }
   else
   {
      /* tha Fax API Browser initialization file could not be opened. */

      fReturnValue = (BOOL) FALSE;
   }

   return ( fReturnValue );
}



/*
 *  GetNumberOfFaxApiFunctions
 *
 *  Purpose: 
 *          This function returns the number of Fax API functions.
 *
 *  Arguments:
 *          None
 *
 *  Returns:
 *          The number of Fax API functions
 *
 */

int CFaxApiApp::GetNumberOfFaxApiFunctions()
{
   int   xNumberOfFaxApiFunctions;

   xNumberOfFaxApiFunctions = m_coaFaxApiFunctionInfo.GetSize();

   return ( xNumberOfFaxApiFunctions );
}



/*
 *  GetFaxApiFunctionInfoPointer
 *
 *  Purpose: 
 *          This function returns a pointer to a CFaxApiFunctionInfo object.
 *
 *  Arguments:
 *          xElementIndex is the index into the array of pointers to CFaxApiFunctionInfo
 *          objects to the desired pointer.
 *
 *  Returns:
 *          A pointer to a CFaxApiFunctionInfoObject
 *
 */

CFaxApiFunctionInfo * CFaxApiApp::GetFaxApiFunctionInfoPointer( int xElementIndex )
{
   CFaxApiFunctionInfo *   pcfafiFunctionInfo;

   pcfafiFunctionInfo = (CFaxApiFunctionInfo *) m_coaFaxApiFunctionInfo[xElementIndex];

   return ( pcfafiFunctionInfo );
}



/*
 *  DeleteCFaxApiFunctionInfoObjects
 *
 *  Purpose: 
 *          This function deletes any CFaxApiFunctionInfo objects that
 *          may have been created.
 *
 *  Arguments:
 *          None
 *
 *  Returns:
 *          None
 *
 */

void CFaxApiApp::DeleteCFaxApiFunctionInfoObjects()
{
   int   xNumberOfElements;

   xNumberOfElements = m_coaFaxApiFunctionInfo.GetSize();

   if ( xNumberOfElements > 0 )
   {
      int   xElementIndex;

      CFaxApiFunctionInfo *   pcfafiElement;

      for ( xElementIndex = 0; xElementIndex < xNumberOfElements; xElementIndex++ )
      {
         pcfafiElement = (CFaxApiFunctionInfo *) m_coaFaxApiFunctionInfo.GetAt( xElementIndex );

         if ( pcfafiElement != (CFaxApiFunctionInfo *) NULL )
         {
            delete pcfafiElement;
         }
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\faxapi\faxapi.h ===
// FaxApi.h : main header file for the FAXAPI application
//

#if !defined(AFX_FAXAPI_H__2E2118C4_2E1B_11D1_ACDA_00A0C908F98C__INCLUDED_)
#define AFX_FAXAPI_H__2E2118C4_2E1B_11D1_ACDA_00A0C908F98C__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols
#include "function.h"

/////////////////////////////////////////////////////////////////////////////
// CFaxApiApp:
// See FaxApi.cpp for the implementation of this class
//

class CFaxApiApp : public CWinApp
{
public:
	CFaxApiApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFaxApiApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

private:

   /* Data members */

   CObArray		m_coaFaxApiFunctionInfo;


	HWND		m_hwndFaxApiFunctionSelectionFormView;
	HWND		m_hwndFunctionInfoFormView;
	HWND		m_hwndParameterInfoFormView;
	HWND		m_hwndExecutionLogFormView;
	HWND		m_hwndReturnValueOutputFormView;


public:

	void StoreFunctionInfoFormViewHWND( HWND hView );
	void StoreParameterInfoFormViewHWND( HWND hView );
	void StoreReturnValueOutputFormViewHWND( HWND hView );
	void StoreExecutionLogFormViewHWND( HWND hView );
	void StoreFaxApiFunctionSelectionFormViewHWND( HWND hView );

	CWnd * GetFunctionInfoFormViewPointer();
	CWnd * GetParameterInfoFormViewPointer();
	CWnd * GetReturnValueOutputFormViewPointer();
	CWnd * GetExecutionLogFormViewPointer();
	CWnd * GetFaxApiFunctionSelectionFormViewPointer();

   int GetNumberOfFaxApiFunctions();
   CFaxApiFunctionInfo * GetFaxApiFunctionInfoPointer( int xElementIndex );
   void DeleteCFaxApiFunctionInfoObjects();

private:

   BOOL InitFaxApiFunctionInfoPointerArray();


	//{{AFX_MSG(CFaxApiApp)
	afx_msg void OnAppAbout();
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FAXAPI_H__2E2118C4_2E1B_11D1_ACDA_00A0C908F98C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\faxapi\exelogvw.h ===
#if !defined(AFX_EXELOGVW_H__A55ED773_2ED1_11D1_ACDA_00A0C908F98C__INCLUDED_)
#define AFX_EXELOGVW_H__A55ED773_2ED1_11D1_ACDA_00A0C908F98C__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// exelogvw.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CExecutionLogFormView form view

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

class CExecutionLogFormView : public CFormView
{
protected:
	CExecutionLogFormView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CExecutionLogFormView)

// Form Data
public:
	//{{AFX_DATA(CExecutionLogFormView)
	enum { IDD = IDD_EXECUTION_LOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CExecutionLogFormView)
	public:
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CExecutionLogFormView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

public:

   BOOL UpdateExecutionLogEditCtrl( CString & rcsExecutionLogString );
   void UpdateExecutionLogBeforeApiCall( CFaxApiFunctionInfo * pcfafiFunctionInfo );
   void UpdateExecutionLogAfterApiReturn( CFaxApiFunctionInfo * pcfafiFunctionInfo );
   void AddTextToEditControl( CEdit * pceEditControl, const CString & rcsText );

	// Generated message map functions
	//{{AFX_MSG(CExecutionLogFormView)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EXELOGVW_H__A55ED773_2ED1_11D1_ACDA_00A0C908F98C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\faxapi\exelogvw.cpp ===
// exelogvw.cpp : implementation file
//

#include "stdafx.h"
#include "FaxApi.h"
#include "exelogvw.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern CFaxApiApp *	pFaxApiBrowserApp;

/////////////////////////////////////////////////////////////////////////////
// CExecutionLogFormView

IMPLEMENT_DYNCREATE(CExecutionLogFormView, CFormView)

CExecutionLogFormView::CExecutionLogFormView()
	: CFormView(CExecutionLogFormView::IDD)
{
	//{{AFX_DATA_INIT(CExecutionLogFormView)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CExecutionLogFormView::~CExecutionLogFormView()
{
}

void CExecutionLogFormView::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CExecutionLogFormView)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CExecutionLogFormView, CFormView)
	//{{AFX_MSG_MAP(CExecutionLogFormView)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CExecutionLogFormView diagnostics

#ifdef _DEBUG
void CExecutionLogFormView::AssertValid() const
{
	CFormView::AssertValid();
}

void CExecutionLogFormView::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CExecutionLogFormView message handlers

BOOL CExecutionLogFormView::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext) 
{
	BOOL	fReturnValue;
	
	fReturnValue = CFormView::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);

	if ( fReturnValue != (BOOL) FALSE )
	{
		// Save the handle to this view in the CFaxApiApp object.

		pFaxApiBrowserApp->StoreExecutionLogFormViewHWND( m_hWnd );
	}

	return ( fReturnValue );
}



BOOL CExecutionLogFormView::UpdateExecutionLogEditCtrl( CString & rcsExecutionLogString )
{
	BOOL	fReturnValue;

	// Get a pointer to the Execution Log edit control.

	CEdit *	pceExecutionLogEditCtrl;

	pceExecutionLogEditCtrl = (CEdit *) ((CDialog *) this)->
		GetDlgItem( IDC_EDIT_EXECUTION_LOG );

	// Is the pointer valid ?

	if ( pceExecutionLogEditCtrl != (CEdit *) NULL )
	{
		pceExecutionLogEditCtrl->SetWindowText( rcsExecutionLogString );
	}
	else
	{
		fReturnValue = (BOOL) FALSE;
	}

	return ( fReturnValue );
}



/*
 *  UpdateExecutionLogBeforeApiCall
 *
 *  Purpose: 
 *          This function writes a block of text to the execution log edit control
 *          in preparation for executing the selected Fax Api function.
 *
 *  Arguments:
 *          pcfafiFunctionInfo - points to the CFaxApiFunctionInfo object for
 *                               the selected Fax Api function.
 *
 *  Returns:
 *          none
 *
 */

void CExecutionLogFormView::UpdateExecutionLogBeforeApiCall( CFaxApiFunctionInfo * pcfafiFunctionInfo )
{
   /* Get a pointer to the Output edit control. */

   CEdit *  pceEditControl;

   pceEditControl = (CEdit *) ((CDialog *) this)->GetDlgItem( IDC_EDIT_EXECUTION_LOG );

   if ( pceEditControl != (CEdit *) NULL )
   {
      CString  csFunctionName;
      CString  csText;
   
      csFunctionName = pcfafiFunctionInfo->GetFunctionName();
   
      csText.Format( TEXT("\r\nCalling %s\r\n"), csFunctionName );

      AddTextToEditControl( pceEditControl, (const CString &) csText );
   
      int      xNumberOfParameters;
   
      xNumberOfParameters = pcfafiFunctionInfo->GetNumberOfParameters();
   
      if ( xNumberOfParameters > 0 )
      {
         int      xParameterIndex;

         CString  csParameterName;
         CString  csParameterValue;

         for ( xParameterIndex = 0; xParameterIndex < xNumberOfParameters; xParameterIndex++ )
         {
            pcfafiFunctionInfo->GetParameterName( xParameterIndex,
                                                  (CString &) csParameterName );
   
            pcfafiFunctionInfo->FormatParameterValueForOutput( xParameterIndex,
                                                               (CString &) csParameterValue );
   
            csText.Format( TEXT("   %s = \t%s\r\n"), csParameterName, csParameterValue );

            AddTextToEditControl( pceEditControl, (const CString &) csText );
         }
      }
   }
}



/*
 *  UpdateExecutionLogAfterApiReturn
 *
 *  Purpose: 
 *          This function writes a block of text to the output exit control
 *          after execution of the selected Fax Api function.
 *
 *  Arguments:
 *          pcfafiFunctionInfo - points to the CFaxApiFunctionInfo object for
 *                               the selected Fax Api function.
 *
 *  Returns:
 *          none
 *
 */

void CExecutionLogFormView::UpdateExecutionLogAfterApiReturn( CFaxApiFunctionInfo * pcfafiFunctionInfo )
{
   /* Get a pointer to the Execution Log edit control. */

   CEdit *  pceEditControl;

   pceEditControl = (CEdit *) ((CDialog *) this)->GetDlgItem( IDC_EDIT_EXECUTION_LOG );

   if ( pceEditControl != (CEdit *) NULL )
   {
      CString  csFunctionName;
      CString  csText;
   
      csFunctionName = pcfafiFunctionInfo->GetFunctionName();
   
      csText.Format( TEXT("\r\n%s returned:\r\n"), csFunctionName );

      AddTextToEditControl( pceEditControl, (const CString &) csText );

      CString  csReturnValue;

      pcfafiFunctionInfo->FormatReturnValueForOutput( (CString &) csReturnValue );

      csText.Format( TEXT("   %s\r\n"), csReturnValue );

      AddTextToEditControl( pceEditControl, (const CString &) csText );
   
      int      xNumberOfParameters;
   
      xNumberOfParameters = pcfafiFunctionInfo->GetNumberOfParameters();
   
      if ( xNumberOfParameters > 0 )
      {
         int      xParameterIndex;

         CString  csParameterName;
         CString  csParameterValue;

         for ( xParameterIndex = 0; xParameterIndex < xNumberOfParameters; xParameterIndex++ )
         {
            pcfafiFunctionInfo->GetParameterName( xParameterIndex,
                                                  (CString &) csParameterName );
   
            pcfafiFunctionInfo->FormatParameterValueForOutput( xParameterIndex,
                                                               (CString &) csParameterValue );
   
            csText.Format( TEXT("   %s = \t%s\r\n"), csParameterName, csParameterValue );

            AddTextToEditControl( pceEditControl, (const CString &) csText );
         }
      }
   }
}



/*
 *  AddTextToEditControl
 *
 *  Purpose: 
 *          This function adds text to an edit control.
 *
 *  Arguments:
 *          pceEditControl - points to the CEdit object
 *          rcsText - a reference to  CString that contains the text
 *                    to be added to the edit control.
 *
 *          may want to add num chars parameter later !
 *
 *  Returns:
 *          None
 *
 */

void CExecutionLogFormView::AddTextToEditControl( CEdit * pceEditControl, const CString & rcsText )
{
   if ( pceEditControl != (CEdit *) NULL )
   {
      /* Set the insertion point at the end of the text. */
   
      pceEditControl->SetSel( -1, 50000 );      //  50000 is arbitrary !
   
      /* Turn off READ ONLY. */
   
      pceEditControl->SetReadOnly( (BOOL) FALSE );
   
      /* Write the string to the edit control. */
   
      pceEditControl->ReplaceSel( (LPCTSTR) rcsText );
   
      /* Turn on READ ONLY. */
   
      pceEditControl->SetReadOnly( (BOOL) TRUE );
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\faxapi\fcninfvw.h ===
#if !defined(AFX_FCNINFVW_H__A55ED775_2ED1_11D1_ACDA_00A0C908F98C__INCLUDED_)
#define AFX_FCNINFVW_H__A55ED775_2ED1_11D1_ACDA_00A0C908F98C__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// fcninfvw.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CFunctionInfoFormView form view

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

class CFunctionInfoFormView : public CFormView
{
protected:
	CFunctionInfoFormView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CFunctionInfoFormView)

// Form Data
public:
	//{{AFX_DATA(CFunctionInfoFormView)
	enum { IDD = IDD_FUNCTION_INFO };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

// Attributes
public:

// Operations
public:

	BOOL UpdateFunctionPrototypeEditCtrl( CString & rcsFunctionPrototype );
	BOOL UpdateReturnValueDescriptionEditCtrl( CString & rcsReturnValueDscription );


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFunctionInfoFormView)
	public:
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CFunctionInfoFormView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CFunctionInfoFormView)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FCNINFVW_H__A55ED775_2ED1_11D1_ACDA_00A0C908F98C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\faxapi\fxapidoc.cpp ===
// FxApiDoc.cpp : implementation of the CFaxApiDoc class
//

#include "stdafx.h"
#include "FaxApi.h"

#include "FxApiDoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFaxApiDoc

IMPLEMENT_DYNCREATE(CFaxApiDoc, CDocument)

BEGIN_MESSAGE_MAP(CFaxApiDoc, CDocument)
	//{{AFX_MSG_MAP(CFaxApiDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFaxApiDoc construction/destruction

CFaxApiDoc::CFaxApiDoc()
{
	// TODO: add one-time construction code here

}

CFaxApiDoc::~CFaxApiDoc()
{
}

BOOL CFaxApiDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;

	// TODO: add reinitialization code here
	// (SDI documents will reuse this document)

	return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// CFaxApiDoc serialization

void CFaxApiDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}

/////////////////////////////////////////////////////////////////////////////
// CFaxApiDoc diagnostics

#ifdef _DEBUG
void CFaxApiDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CFaxApiDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CFaxApiDoc commands
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\faxapi\fcninfvw.cpp ===
// fcninfvw.cpp : implementation file
//

#include "stdafx.h"
#include "FaxApi.h"
#include "fcninfvw.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern CFaxApiApp *	pFaxApiBrowserApp;

/////////////////////////////////////////////////////////////////////////////
// CFunctionInfoFormView

IMPLEMENT_DYNCREATE(CFunctionInfoFormView, CFormView)

CFunctionInfoFormView::CFunctionInfoFormView()
	: CFormView(CFunctionInfoFormView::IDD)
{
	//{{AFX_DATA_INIT(CFunctionInfoFormView)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CFunctionInfoFormView::~CFunctionInfoFormView()
{
}

void CFunctionInfoFormView::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFunctionInfoFormView)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFunctionInfoFormView, CFormView)
	//{{AFX_MSG_MAP(CFunctionInfoFormView)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFunctionInfoFormView diagnostics

#ifdef _DEBUG
void CFunctionInfoFormView::AssertValid() const
{
	CFormView::AssertValid();
}

void CFunctionInfoFormView::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CFunctionInfoFormView message handlers

BOOL CFunctionInfoFormView::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext) 
{
	BOOL	fReturnValue;
	
	fReturnValue = CFormView::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);

	if ( fReturnValue != (BOOL) FALSE )
	{
		// Save the handle to this view in the CFaxApiApp object.

		pFaxApiBrowserApp->StoreFunctionInfoFormViewHWND( m_hWnd );
	}

	return ( fReturnValue );
}



// Update the Function Paremeter edit control

BOOL CFunctionInfoFormView::UpdateFunctionPrototypeEditCtrl( CString & rcsFunctionPrototype )
{
	BOOL	fReturnValue;

	// Get a pointer to the Function Prototype edit control.

	CEdit *	pceFunctionPrototype;

	pceFunctionPrototype = (CEdit *) ((CDialog *) this)->
		GetDlgItem( IDC_EDIT_FUNCTION_PROTOTYPE );

	if ( pceFunctionPrototype != (CEdit *) NULL )
	{
		pceFunctionPrototype->SetWindowText( rcsFunctionPrototype );

		fReturnValue = (BOOL) TRUE;
	}
	else
	{
		fReturnValue = (BOOL) FALSE;
	}

	return ( fReturnValue );
}



// Update the Return Value Description edit control.

BOOL CFunctionInfoFormView::UpdateReturnValueDescriptionEditCtrl( CString & rcsReturnValueDescription )
{
	BOOL	fReturnValue;

	// Get a pointer to the Return Value Description edit control.

	CEdit *	pceReturnValueDescription;

	pceReturnValueDescription = (CEdit *) ((CDialog *) this)->
		GetDlgItem( IDC_EDIT_RETURN_VALUE_DESCRIPTION );

	if ( pceReturnValueDescription != (CEdit *) NULL )
	{
		pceReturnValueDescription->SetWindowText( rcsReturnValueDescription );

		fReturnValue = (BOOL) TRUE;
	}
	else
	{
		fReturnValue = (BOOL) FALSE;
	}


	return ( fReturnValue );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\faxapi\function.h ===
#ifndef _FUNCTION_H_
#define _FUNCTION_H_

/* CFaxApiFunctionInfo class definition file. */

#include "param.h"


/* Function index enumeration. */

/* Note that the function index enum is not related to the index into the */
/* Fax Api Function listbox. It is used by the Execute() member function  */
/* of the CFaxApiFunctionInfo class (and possibly others).                */

enum eFunctionIndex
{
   // symbol                  // Function Name

   eFaxAbort,                 // FaxAbort
   eFaxClose,                 // FaxClose
   eFaxConnectFaxServerA,     // FaxConnectFaxServerA
   eFaxConnectFaxServerW,     // FaxConnectFaxServerW
   eFaxEnableRoutingMethodA,  // FaxEnableRoutingMethodA
   eFaxEnableRoutingMethodW,  // FaxEnableRoutingMethodW
   eFaxEnumJobsA,             // FaxEnumJobsA
   eFaxEnumJobsW,             // FaxEnumJobsW
   eFaxEnumPortsA,            // FaxEnumPortsA
   eFaxEnumPortsW,            // FaxEnumPortsW
   eFaxEnumRoutingMethodsA,   // FaxEnumRoutingMethodsA
   eFaxEnumRoutingMethodsW,   // FaxEnumRoutingMethodsW
   eFaxFreeBuffer,            // FaxFreeBuffer
   eFaxGetConfigurationA,     // FaxGetConfigurationA
   eFaxGetConfigurationW,     // FaxGetConfigurationW
   eFaxGetDeviceStatusA,      // FaxGetDeviceStatusA
   eFaxGetDeviceStatusW,      // FaxGetDeviceStatusW
   eFaxGetJobA,               // FaxGetJobA
   eFaxGetJobW,               // FaxGetJobW
   eFaxGetLoggingCategoriesA, // FaxGetLoggingCategoriesA
   eFaxGetLoggingCategoriesW, // FaxGetLoggingCategoriesW
   eFaxGetPageData,           // FaxGetPageData
   eFaxGetPortA,              // FaxGetPortA
   eFaxGetPortW,              // FaxGetPortW
   eFaxGetRoutingInfoA,       // FaxGetRoutingInfoA
   eFaxGetRoutingInfoW,       // FaxGetRoutingInfoW
   eFaxInitializeEventQueue,  // FaxInitializeEventQueue
#ifdef   ELIMINATED_FROM_API
   eFaxOpenJob,               // FaxOpenJob
#endif   // ELIMINATED_FROM_API
   eFaxOpenPort,              // FaxOpenPort
   eFaxPrintCoverPageA,       // FaxPrintCoverPageA
   eFaxPrintCoverPageW,       // FaxPrintCoverPageW
   eFaxReceiveDocumentA,      // FaxReceiveDocumentA
   eFaxReceiveDocumentW,      // FaxReceiveDocumentW
   eFaxSendDocumentA,         // FaxSendDocumentA
   eFaxSendDocumentW,         // FaxSendDocumentW
   eFaxSetConfigurationA,     // FaxSetConfigurationA
   eFaxSetConfigurationW,     // FaxSetConfigurationW
   eFaxSetJobA,               // FaxSetJobA
   eFaxSetJobW,               // FaxSetJobW
   eFaxSetLoggingCategoriesA, // FaxSetLoggingCategoriesA
   eFaxSetLoggingCategoriesW, // FaxSetLoggingCategoriesW
   eFaxSetPortA,              // FaxSetPortA
   eFaxSetPortW,              // FaxSetPortW
   eFaxSetRoutingInfoA,       // FaxSetRoutingInfoA
   eFaxSetRoutingInfoW,       // FaxSetRoutingInfoW
   eFaxStartPrintJobA,        // FaxStartPrintJobA
   eFaxStartPrintJobW,        // FaxStartPrintJobW

   eIllegalFunctionIndex      // indicates that the function
                              // index is illegal
};



/* The CFaxApiFunctionInfo class is used to manage all of the information */
/* pertaining to a single Fax API function.                               */

class CFaxApiFunctionInfo : public CObject
{
public:
    CFaxApiFunctionInfo();      // constructor
    CFaxApiFunctionInfo( const CString & rcsFunctionName,
                         const CString & rcsFunctionPrototype,
                         const CString & rcsReturnType,
                         const CString & rcsReturnValueDescription,
                         const CString & rcsRemarks );

    ~CFaxApiFunctionInfo();     // destructor


    void SetFunctionName( CString & rcsFunctionName );

    CString & GetFunctionName();
    CString & GetFunctionPrototype();
    CString & GetReturnValueDescription();
    CString & GetRemarks();

    void GetParameterName( int xParameterIndex, CString & rcsParameterName );
    void FormatParameterValueForOutput( int xParameterIndex, CString & rcsParameterValue );

    void *  GetParameterValuePointer( int xParameterIndex );

    int GetNumberOfParameters();
    int GetMaxParamValueStringLength( int xParameterIndex );

    BOOL StoreParameterValue( int xParameterIndex, const CString & rcsParameterValue );

    eParamType GetParameterTypeEnum( int xParameterIndex );
    CString GetParameterTypeString( int xParameterIndex );
    CString GetParameterDescription( int xParameterIndex );


    void FormatReturnValueForOutput( CString & csReturnValue );
    void Execute();




private:
    void * AllocateStorageForReturnValue( const CString & rcsReturnType );

    eFunctionIndex GetFunctionIndexEnum( const CString & rcsFunctionName );

private:

   /* data members */
   
   CString                          m_csFunctionName;
   
   CString                          m_csFunctionPrototype;
   
   CString                          m_csReturnType;
   
   CString                          m_csReturnValueDescription;

   CString                          m_csRemarks;

   eFunctionIndex                   m_eFunctionIndex;
   
   /* Since we don't know what type the return value is (each API function */
   /* may be different) the storage must be allocated dynamically. The     */
   /* following data member is a pointer to the storage for the return     */
   /* value.                                                               */

   void *                           m_pvReturnValue;
   
   CFaxApiFunctionParameterInfo     m_cParameterInfo;
};
#endif   // _FUNCTION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\faxapi\fxapidoc.h ===
// FxApiDoc.h : interface of the CFaxApiDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_FXAPIDOC_H__2E2118CA_2E1B_11D1_ACDA_00A0C908F98C__INCLUDED_)
#define AFX_FXAPIDOC_H__2E2118CA_2E1B_11D1_ACDA_00A0C908F98C__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


class CFaxApiDoc : public CDocument
{
protected: // create from serialization only
	CFaxApiDoc();
	DECLARE_DYNCREATE(CFaxApiDoc)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFaxApiDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CFaxApiDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CFaxApiDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FXAPIDOC_H__2E2118CA_2E1B_11D1_ACDA_00A0C908F98C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\faxapi\fcnselvw.h ===
#if !defined(AFX_FCNSELVW_H__A55ED774_2ED1_11D1_ACDA_00A0C908F98C__INCLUDED_)
#define AFX_FCNSELVW_H__A55ED774_2ED1_11D1_ACDA_00A0C908F98C__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// fcnselvw.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CFaxApiFunctionSelectionFormView form view

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

class CFaxApiFunctionSelectionFormView : public CFormView
{
protected:
	CFaxApiFunctionSelectionFormView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CFaxApiFunctionSelectionFormView)

// Form Data
public:
	//{{AFX_DATA(CFaxApiFunctionSelectionFormView)
	enum { IDD = IDD_FUNCTION_SELECTION };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFaxApiFunctionSelectionFormView)
	public:
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CFaxApiFunctionSelectionFormView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

private:

	BOOL ExecuteFaxApiFunction( void );
   BOOL DisableExecuteButton( void );

public:

   CFaxApiFunctionInfo * GetSelectedFaxApiFunctionInfoPointer();


	// Generated message map functions
	//{{AFX_MSG(CFaxApiFunctionSelectionFormView)
	afx_msg void OnDblclkListboxFaxApiFunctions();
	afx_msg void OnSelchangeListboxFaxApiFunctions();
	afx_msg void OnButtonExecuteApiFunction();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FCNSELVW_H__A55ED774_2ED1_11D1_ACDA_00A0C908F98C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\faxapi\function.cpp ===
/* CFaxApiFunctionInfo class implementation file. */

#include "StdAfx.h"
#include "function.h"
#include "param.h"

extern "C" {
#include "winfax.h"
}



/*
 *  CFaxApiFunctionInfo
 *
 *  Purpose: 
 *          This function constructs a CFaxApiFunctionInfo object.
 *
 *  Arguments:
 *          None
 *
 *  Returns:
 *          None
 *
 */

CFaxApiFunctionInfo::CFaxApiFunctionInfo()
{
   m_pvReturnValue = (void *) NULL;
}



/*
 *  CFaxApiFunctionInfo
 *
 *  Purpose: 
 *          This function constructs a CFaxApiFunctionInfo object and
 *          inititalzes the function name member.
 *
 *  Arguments:
 *          rcsFunctionName - a reference to a CString that contains the
 *                            Fax API Function name.
 *          rcsFunctionPrototype - a reference to a CString that contains
 *                                 the function prototype
 *          rcsReturnType - a reference to a CString that contains the
 *                          type of the return value
 *          rcsReturnValueDescription - a reference to a CString that contains
 *                                      a textual description of the return value
 *
 *  Returns:
 *          None
 *
 */

CFaxApiFunctionInfo::CFaxApiFunctionInfo( const CString & rcsFunctionName,
                                          const CString & rcsFunctionPrototype,
                                          const CString & rcsReturnType,
                                          const CString & rcsReturnValueDescription,
                                          const CString & rcsRemarks )
{
   m_csFunctionName = rcsFunctionName;

   m_eFunctionIndex = GetFunctionIndexEnum( rcsFunctionName );

   m_csFunctionPrototype = rcsFunctionPrototype;

   m_csReturnType = rcsReturnType;

   m_csReturnValueDescription = rcsReturnValueDescription;

   m_csRemarks = rcsRemarks;

   m_pvReturnValue = AllocateStorageForReturnValue( rcsReturnType );

   /* Initialize the CFaxApiFunctionParameterInfo object member. */

   m_cParameterInfo.InitParameterInfoMember( rcsFunctionName );
}



/*
 *  ~CFaxApiFunctionInfo
 *
 *  Purpose: 
 *          This function destroys a CFaxApiFunctionInfo object.
 *
 *  Arguments:
 *          None
 *
 *  Returns:
 *          None
 *
 */

CFaxApiFunctionInfo::~CFaxApiFunctionInfo()
{
   if ( m_pvReturnValue != (void *) NULL )
   {
      delete m_pvReturnValue;
   }
}



/*
 *  AllocateStorageForReturnValue
 *
 *  Purpose: 
 *          This function allocates (via the new operator) storage for
 *          The Fax API function's return value.
 *
 *  Arguments:
 *          rcsReturnType - a reference to a CString that contains the
 *                          type of the return value.
 *
 *  Returns:
 *          a pointer to the storage for the Fax API function return value.
 *
 */

void * CFaxApiFunctionInfo::AllocateStorageForReturnValue( const CString & rcsReturnType )
{
   void *   pvReturnValue;

   /* At this time (6/03/97) there are two return types for all Fax API */
   /* functions: BOOL and VOID.                                         */

   if ( rcsReturnType.Compare( (LPCTSTR) TEXT("BOOL") ) == 0 )
   {
      /* The return type is BOOL. */

      pvReturnValue = (void *) new BOOL;
   }
   else
   {
      if ( rcsReturnType.CompareNoCase( (LPCTSTR) TEXT("VOID") ) == 0 )
      {
         /* The return type is VOID. */
   
         pvReturnValue = (void *) NULL;
      }
      else
      {
         /* The return type is not recognized. */

         CString  csMessage;

         csMessage.Format( TEXT("%s is an unrecognized datatype in AllocateStorageForReturnValue"),
                           rcsReturnType );

         AfxMessageBox( csMessage );
      }
   }

   return ( pvReturnValue );
}



/*
 *  SetFunctionName
 *
 *  Purpose: 
 *          This function sets the m_csFunctionName member of a
 *          CFaxApiFunctionInfo object.
 *
 *  Arguments:
 *          rcsFunctionName - a reference to a CString that contains the
 *                            function name.
 *
 *  Returns:
 *          None
 *
 */

void CFaxApiFunctionInfo::SetFunctionName( CString & rcsFunctionName )
{
   m_csFunctionName = rcsFunctionName;
}



/*
 *  GetFunctionName
 *
 *  Purpose: 
 *          This function retrieves the contents of the m_csFunctionName
 *          member of a CFaxApiFunctionInfo object.
 *
 *  Arguments:
 *          None
 *
 *  Returns:
 *          A reference to a CString which contains the function name
 *
 */

CString & CFaxApiFunctionInfo::GetFunctionName()
{
   return ( (CString &) m_csFunctionName );
}



/*
 *  GetFunctionPrototype
 *
 *  Purpose: 
 *          This function retrieves the contents of the m_csFunctionPrototype
 *          member of a CFaxApiFunctionInfo object.
 *
 *  Arguments:
 *          None
 *
 *  Returns:
 *          A reference to a CString which contains the function prototype
 *
 */

CString & CFaxApiFunctionInfo::GetFunctionPrototype()
{
   return ( (CString &) m_csFunctionPrototype );
}



/*
 *  GetFunctionReturnValueDescription
 *
 *  Purpose: 
 *          This function retrieves the contents of the m_csReturnValueDescription
 *          member of a CFaxApiFunctionInfo object.
 *
 *  Arguments:
 *          None
 *
 *  Returns:
 *          A reference to a CString which contains the textual description
 *          of the value returned by a Fax API function.
 *
 */

CString & CFaxApiFunctionInfo::GetReturnValueDescription()
{
   return ( (CString &) m_csReturnValueDescription );
}



/*
 *  GetRemarks
 *
 *  Purpose: 
 *          This function retrieves the contents of the m_csRemarks member of
 *          the CFaxApiFunctionInfo object.
 *
 *  Arguments:
 *          None
 *
 *  Returns:
 *          A reference to a CString which contains the "remarks" for a Fax API
 *          function.
 *
 */

CString & CFaxApiFunctionInfo::GetRemarks()
{
   return ( (CString &) m_csRemarks );
}



/*
 *  GetParameterName
 *
 *  Purpose: 
 *          This function retrieves the name of a parameter for a Fax API function.
 *
 *  Arguments:
 *          xParameterIndex = the index to the parameter name
 *          rcsParameterName - a reference to a CString to receive the parameter
 *                             name.
 *
 *  Returns:
 *          None
 *
 */

void CFaxApiFunctionInfo::GetParameterName( int xParameterIndex, CString & rcsParameterName )
{
   rcsParameterName = m_cParameterInfo.GetParameterName( xParameterIndex );
}



/*
 *  GetNumberOfParameters
 *
 *  Purpose: 
 *          This functions retrieves the number of parameters listed int the
 *          m_cParameterInfo member of the CFaxApiFuntionInfo object.
 *
 *  Arguments:
 *          None
 *
 *  Returns:
 *          The number of parameters
 *
 */

int CFaxApiFunctionInfo::GetNumberOfParameters()
{
   int   xNumberOfParameters;

   xNumberOfParameters = m_cParameterInfo.GetNumberOfParameters();

   return ( xNumberOfParameters );
}



/*
 *  GetParameterValuePointer
 *
 *  Purpose: 
 *          This function retrieves a pointer to the storage for the parameter
 *          value member of the CFaxApiFunctionParameterInfo obmect member of
 *          the CFaxApiFunctionInfo object.
 *
 *  Arguments:
 *          xParameterIndex = the index into the CPtrArray object to the element
 *                            that points to the storage for the parameerd value.
 *
 *  Returns:
 *          a pointer to the storage for the parameter value.
 *
 */

void * CFaxApiFunctionInfo::GetParameterValuePointer( int xParameterIndex )
{
   void *   pvParameterValue;

   pvParameterValue = m_cParameterInfo.GetParameterValuePointer( xParameterIndex );

   return ( pvParameterValue );
}



/*
 *  FormatParameterValueForOutput
 *
 *  Purpose: 
 *          This function prepares a CString representation of the parameter
 *          value whose index is xParameterIndex.
 *
 *  Arguments:
 *          xParameterIndex = the index to the parameter value to be output.
 *          rcsParameterValue - a reference to the CString to receive the string
 *                              representation of th parameter value.
 *
 *  Returns:
 *          None
 *
 */

void CFaxApiFunctionInfo::FormatParameterValueForOutput( int xParameterIndex, CString & rcsParameterValue )
{
   m_cParameterInfo.FormatParameterValueForOutput( xParameterIndex, rcsParameterValue );
}



/*
 *  StoreParameterValue
 *
 *  Purpose: 
 *          This function stores the value contained in a CSting in the storage
 *          location for the parameter value indexed by xParameterIndex.
 *
 *  Arguments:
 *          xParameterIndex - the index to the pointer to the storage for a
 *                            parameer value.
 *          rcsParameterValue - a reference to a CString that contains a
 *                              representation of the value to be stored.
 *
 *  Returns:
 *          TRUE - indicates success
 *          FALSE - indicates failure
 *
 */

BOOL CFaxApiFunctionInfo::StoreParameterValue( int xParameterIndex, const CString & rcsParameterValue )
{
   BOOL  fReturnValue;

   fReturnValue = m_cParameterInfo.StoreParameterValue( xParameterIndex,
                                                        (CString &) rcsParameterValue );

   return ( fReturnValue );
}



/*
 *  GetMaxParamValueStringLength
 *
 *  Purpose: 
 *          This function computer the maximum number of characters that
 *          may be required to represent a data entity.
 *
 *  Arguments:
 *          xParameterIndex = the index into the m_cParameterInfo data member
 *
 *  Returns:
 *          The maximum number of characters that may be required to represent
 *          the parameter whose index is xParameterIndex.
 *
 *  Note:
 *          Two characters are required to represent a byte.
 *
 */

int CFaxApiFunctionInfo::GetMaxParamValueStringLength( int xParameterIndex )
{
   int   xMaxParamValueStringLength;

   eParamType  eParameterType;

   eParameterType = m_cParameterInfo.GetParameterTypeEnum( xParameterIndex );

   switch ( eParameterType )
   {
      case eBOOL:

         xMaxParamValueStringLength = 2 * (int) sizeof( BOOL );

         break;

      case eDWORD:

         xMaxParamValueStringLength = 2 * (int) sizeof( DWORD );

         break;

      case eHANDLE:

         xMaxParamValueStringLength = 2 * (int) sizeof( HANDLE );

         break;

      case eHDC:

         xMaxParamValueStringLength = 2 * (int) sizeof( HDC );

         break;

      case ePHDC:

         xMaxParamValueStringLength = 2 * (int) sizeof( HDC * );

         break;

      case eLPBYTE:

         xMaxParamValueStringLength = 2 * (int) sizeof( LPBYTE );

         break;

      case ePLPBYTE:

         xMaxParamValueStringLength = 2 * (int) sizeof( LPBYTE * );

         break;

      case eLPDWORD:

         xMaxParamValueStringLength = 2 * (int) sizeof( LPDWORD );

         break;

      case eLPHANDLE:

         xMaxParamValueStringLength = 2 * (int) sizeof( LPHANDLE );

         break;

      case eLPSTR:

         /* Strings are a special case defined by MAX_PARAM_VALUE_STRING_LENGTH. */

         xMaxParamValueStringLength = MAX_PARAM_VALUE_STRING_LENGTH;

         break;

      case eLPVOID:

         xMaxParamValueStringLength = 2 * (int) sizeof( LPVOID );

         break;

      case eLPWSTR:

         /* Strings are a special case defined by MAX_PARAM_VALUE_STRING_LENGTH. */

         xMaxParamValueStringLength = MAX_PARAM_VALUE_STRING_LENGTH;

         break;

      case ePFAX_CONFIGURATIONA:

         xMaxParamValueStringLength = 2 * (int) sizeof( PFAX_CONFIGURATIONA );

         break;

      case ePPFAX_CONFIGURATIONA:

         xMaxParamValueStringLength = 2 * (int) sizeof( PFAX_CONFIGURATIONA * );

         break;

      case ePFAX_CONFIGURATIONW:

         xMaxParamValueStringLength = 2 * (int) sizeof( PFAX_CONFIGURATIONW );

         break;

      case ePPFAX_CONFIGURATIONW:

         xMaxParamValueStringLength = 2 * (int) sizeof( PFAX_CONFIGURATIONW * );

         break;

      case ePFAX_COVERPAGE_INFOA:

         xMaxParamValueStringLength = 2 * (int) sizeof( PFAX_COVERPAGE_INFOA );

         break;

      case ePFAX_COVERPAGE_INFOW:

         xMaxParamValueStringLength = 2 * (int) sizeof( PFAX_COVERPAGE_INFOW );

         break;

      case ePFAX_JOB_PARAMA:

         xMaxParamValueStringLength = 2 * (int) sizeof( PFAX_JOB_PARAMA );

         break;

      case ePFAX_JOB_PARAMW:

         xMaxParamValueStringLength = 2 * (int) sizeof( PFAX_JOB_PARAMW );

         break;

      case ePFAX_PRINT_INFOA:

         xMaxParamValueStringLength = 2 * (int) sizeof( PFAX_PRINT_INFOA );

         break;

      case ePFAX_PRINT_INFOW:

         xMaxParamValueStringLength = 2 * (int) sizeof( PFAX_PRINT_INFOW );

         break;

      default:

         xMaxParamValueStringLength = 0;
   }

   return ( xMaxParamValueStringLength );
}



/*
 *  GetParameterTypeEnum
 *
 *  Purpose: 
 *          This function retrieves the enum that indicates the type of the
 *          parameter.
 *
 *  Arguments:
 *          xParameter index - the index to the parameter
 *
 *  Returns:
 *          the enum that indicates the data type of the paraameter indexed
 *          by xParameterIndex.
 *
 */

eParamType CFaxApiFunctionInfo::GetParameterTypeEnum( int xParameterIndex )
{
   eParamType  eParameterType;

   eParameterType = m_cParameterInfo.GetParameterTypeEnum( xParameterIndex );

   return ( eParameterType );
}



/*
 *  GetParameterTypeString
 *
 *  Purpose: 
 *          This functio retrieves a string that indicates the type of the
 *          parameter.
 *
 *  Arguments:
 *          xParameter index - the index to the parameter
 *
 *  Returns:
 *          the CString that indicates the data type of the paraameter indexed
 *          by xParameterIndex.
 *
 */

CString CFaxApiFunctionInfo::GetParameterTypeString( int xParameterIndex )
{
   CString  csParameterType;

   csParameterType = m_cParameterInfo.GetParameterTypeString( xParameterIndex );

   return ( csParameterType );
}



/*
 *  GetParameterDescription
 *
 *  Purpose: 
 *          This function retrieves the description of a parameter to a
 *          Fax API function.
 *
 *  Arguments:
 *          xParameter index - the index to the parameter
 *
 *  Returns:
 *          A CString that contains the description of a parameter to a
 *          Fax API function.
 *
 */

CString CFaxApiFunctionInfo::GetParameterDescription( int xParameterIndex )
{
   CString  csParameterDescription;

   csParameterDescription = m_cParameterInfo.GetParameterDescription( xParameterIndex );

   return ( csParameterDescription );
}



/*
 *  FormatReturnValueForOutput
 *
 *  Purpose: 
 *          This function formats the return value for the selected function
 *          for output.
 *
 *  Arguments:
 *          rcsReturnValue - a reference to a CString to receive the formatted
 *                           representation of the return value.
 *
 *  Returns:
 *          None
 *
 */

void CFaxApiFunctionInfo::FormatReturnValueForOutput( CString & rcsReturnValue )
{
   /* At this time (6/03/97) there are two return types for all Fax API */
   /* functions: BOOL and VOID.                                         */

   if ( m_csReturnType.Compare( (LPCTSTR) TEXT("BOOL") ) == 0 )
   {
      /* The return type is BOOL. */

      BOOL *   pfReturnValue;

      pfReturnValue = (BOOL *) m_pvReturnValue;

      if ( *pfReturnValue == (BOOL) FALSE )
      {
         rcsReturnValue = (CString) TEXT("FALSE");
      }
      else
      {
         rcsReturnValue = (CString) TEXT("TRUE");
      }
   }
   else
   {
      if ( m_csReturnType.CompareNoCase( (LPCTSTR) TEXT("VOID") ) == 0 )
      {
         /* The return type is VOID. */
   
         rcsReturnValue = (CString) TEXT("void");
      }
      else
      {
         /* The return type is not recognized. */

         CString  csMessage;

         csMessage.Format( TEXT("%s is an unrecognized datatype in FormatReturnTypeForOutput"),
                           m_csReturnType );

         AfxMessageBox( csMessage );
      }
   }
}



/*
 *  Execute
 *
 *  Purpose: 
 *          This function executes the selected Fax API function and updates
 *          output edit control and the return value edit control.
 *
 *  Arguments:
 *          None
 *
 *  Returns:
 *          None
 *
 */

void CFaxApiFunctionInfo::Execute()
{
   switch ( m_eFunctionIndex )
   {
      case eFaxAbort:
         {
            void *   pvParameterValue1; 
            void *   pvParameterValue2; 

            pvParameterValue1 = GetParameterValuePointer( 0 );
            pvParameterValue2 = GetParameterValuePointer( 1 );

            BOOL     fReturnValue;

            fReturnValue = FaxAbort( (HANDLE) *((HANDLE *)pvParameterValue1),
                                     (DWORD) *((DWORD * )pvParameterValue2) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxClose:
         {
            void *   pvParameterValue;

            pvParameterValue = GetParameterValuePointer( 0 );

            BOOL     fReturnValue;

            fReturnValue = FaxClose( (HANDLE) *((HANDLE *)pvParameterValue) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxConnectFaxServerA:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );

            BOOL     fReturnValue;

            fReturnValue = FaxConnectFaxServerA( (LPSTR) *((LPSTR *) pvParameterValue0),
                                                 (LPHANDLE) *((LPHANDLE *) pvParameterValue1) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxConnectFaxServerW:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );

            BOOL     fReturnValue;

            fReturnValue = FaxConnectFaxServerW( (LPWSTR) *((LPWSTR *) pvParameterValue0),
                                                 (LPHANDLE) *((LPHANDLE *) pvParameterValue1) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxEnableRoutingMethodA:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;
            void *   pvParameterValue2;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );
            pvParameterValue2 = GetParameterValuePointer ( 2 );

            BOOL     fReturnValue;

            fReturnValue = FaxEnableRoutingMethodA( (HANDLE) *((HANDLE *) pvParameterValue0),
                                                    (LPSTR) *((LPSTR *) pvParameterValue1),
                                                    (BOOL) *((BOOL *) pvParameterValue2) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxEnableRoutingMethodW:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;
            void *   pvParameterValue2;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );
            pvParameterValue2 = GetParameterValuePointer ( 2 );

            BOOL     fReturnValue;

            fReturnValue = FaxEnableRoutingMethodW( (HANDLE) *((HANDLE *) pvParameterValue0),
                                                    (LPWSTR) *((LPWSTR *) pvParameterValue1),
                                                    (BOOL) *((BOOL *) pvParameterValue2) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxEnumJobsA:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;
            void *   pvParameterValue2;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );
            pvParameterValue2 = GetParameterValuePointer ( 2 );

            BOOL     fReturnValue;

            fReturnValue = FaxEnumJobsA( (HANDLE) *((HANDLE *) pvParameterValue0),
                                         (PFAX_JOB_ENTRYA *) *((PFAX_JOB_ENTRYA * *) pvParameterValue1),
                                         (LPDWORD) *((LPDWORD *) pvParameterValue2) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxEnumJobsW:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;
            void *   pvParameterValue2;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );
            pvParameterValue2 = GetParameterValuePointer ( 2 );

            BOOL     fReturnValue;

            fReturnValue = FaxEnumJobsW( (HANDLE) *((HANDLE *) pvParameterValue0),
                                         (PFAX_JOB_ENTRYW *) *((PFAX_JOB_ENTRYW * *) pvParameterValue1),
                                         (LPDWORD) *((LPDWORD *) pvParameterValue2) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxEnumPortsA:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;
            void *   pvParameterValue2;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );
            pvParameterValue2 = GetParameterValuePointer ( 2 );

            BOOL     fReturnValue;

            fReturnValue = FaxEnumPortsA( (HANDLE) *((HANDLE *) pvParameterValue0),
                                          (PFAX_PORT_INFOA *) *((PFAX_PORT_INFOA * *) pvParameterValue1),
                                          (LPDWORD) *((LPDWORD *) pvParameterValue2) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxEnumPortsW:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;
            void *   pvParameterValue2;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );
            pvParameterValue2 = GetParameterValuePointer ( 2 );

            BOOL     fReturnValue;

            fReturnValue = FaxEnumPortsW( (HANDLE) *((HANDLE *) pvParameterValue0),
                                          (PFAX_PORT_INFOW *) *((PFAX_PORT_INFOW * *) pvParameterValue1),
                                          (LPDWORD) *((LPDWORD *) pvParameterValue2) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxEnumRoutingMethodsA:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;
            void *   pvParameterValue2;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );
            pvParameterValue2 = GetParameterValuePointer ( 2 );

            BOOL     fReturnValue;

            fReturnValue = FaxEnumRoutingMethodsA( (HANDLE) *((HANDLE *) pvParameterValue0),
                                                   (PFAX_ROUTING_METHODA *) *((PFAX_ROUTING_METHODA * *) pvParameterValue1),
                                                   (LPDWORD) *((LPDWORD *) pvParameterValue2) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxEnumRoutingMethodsW:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;
            void *   pvParameterValue2;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );
            pvParameterValue2 = GetParameterValuePointer ( 2 );

            BOOL     fReturnValue;

            fReturnValue = FaxEnumRoutingMethodsW( (HANDLE) *((HANDLE *) pvParameterValue0),
                                                   (PFAX_ROUTING_METHODW *) *((PFAX_ROUTING_METHODW * *) pvParameterValue1),
                                                   (LPDWORD) *((LPDWORD *) pvParameterValue2) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxFreeBuffer:
         {
            void *   pvParameterValue;

            pvParameterValue = GetParameterValuePointer( 0 );

            FaxFreeBuffer( (LPVOID) *((LPVOID *)pvParameterValue) );
         }

         break;

      case eFaxGetConfigurationA:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );

            BOOL     fReturnValue;

            fReturnValue = FaxGetConfigurationA( (HANDLE) *((HANDLE *) pvParameterValue0),
                                                 (PFAX_CONFIGURATIONA *) *((PFAX_CONFIGURATIONA * *) pvParameterValue1) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxGetConfigurationW:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );

            BOOL     fReturnValue;

            fReturnValue = FaxGetConfigurationW( (HANDLE) *((HANDLE *) pvParameterValue0),
                                                 (PFAX_CONFIGURATIONW *) *((PFAX_CONFIGURATIONW * *) pvParameterValue1) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxGetDeviceStatusA:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );

            BOOL     fReturnValue;

            fReturnValue = FaxGetDeviceStatusA( (HANDLE) *((HANDLE *) pvParameterValue0),
                                                (PFAX_DEVICE_STATUSA *) *((PFAX_DEVICE_STATUSA * *) pvParameterValue1) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxGetDeviceStatusW:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );

            BOOL     fReturnValue;

            fReturnValue = FaxGetDeviceStatusW( (HANDLE) *((HANDLE *) pvParameterValue0),
                                                (PFAX_DEVICE_STATUSW *) *((PFAX_DEVICE_STATUSW * *) pvParameterValue1) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxGetJobA:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;
            void *   pvParameterValue2;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );
            pvParameterValue2 = GetParameterValuePointer ( 2 );

            BOOL     fReturnValue;

            fReturnValue = FaxGetJobA( (HANDLE) *((HANDLE *) pvParameterValue0),
                                       (DWORD) *((DWORD *) pvParameterValue1),
                                       (PFAX_JOB_ENTRYA *) *((PFAX_JOB_ENTRYA * *) pvParameterValue2) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxGetJobW:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;
            void *   pvParameterValue2;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );
            pvParameterValue2 = GetParameterValuePointer ( 2 );

            BOOL     fReturnValue;

            fReturnValue = FaxGetJobW( (HANDLE) *((HANDLE *) pvParameterValue0),
                                       (DWORD) *((DWORD *) pvParameterValue1),
                                       (PFAX_JOB_ENTRYW *) *((PFAX_JOB_ENTRYW * *) pvParameterValue2) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxGetLoggingCategoriesA:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;
            void *   pvParameterValue2;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );
            pvParameterValue2 = GetParameterValuePointer ( 2 );

            BOOL     fReturnValue;

            fReturnValue = FaxGetLoggingCategoriesA( (HANDLE) *((HANDLE *) pvParameterValue0),
                                 (PFAX_LOG_CATEGORY *) *((PFAX_LOG_CATEGORY * *) pvParameterValue1),
                                 (LPDWORD) *((LPDWORD *) pvParameterValue2) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxGetLoggingCategoriesW:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;
            void *   pvParameterValue2;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );
            pvParameterValue2 = GetParameterValuePointer ( 2 );

            BOOL     fReturnValue;

            fReturnValue = FaxGetLoggingCategoriesW( (HANDLE) *((HANDLE *) pvParameterValue0),
                                 (PFAX_LOG_CATEGORY *) *((PFAX_LOG_CATEGORY * *) pvParameterValue1),
                                 (LPDWORD) *((LPDWORD *) pvParameterValue2) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxGetPageData:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;
            void *   pvParameterValue2;
            void *   pvParameterValue3;
            void *   pvParameterValue4;
            void *   pvParameterValue5;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );
            pvParameterValue2 = GetParameterValuePointer ( 2 );
            pvParameterValue3 = GetParameterValuePointer ( 3 );
            pvParameterValue4 = GetParameterValuePointer ( 4 );
            pvParameterValue5 = GetParameterValuePointer ( 5 );

            BOOL     fReturnValue;

            fReturnValue = FaxGetPageData( (HANDLE) *((HANDLE *) pvParameterValue0),
                                 (DWORD) *((DWORD *) pvParameterValue1),
                                 (LPBYTE *) *((LPBYTE * *) pvParameterValue2),
                                 (LPDWORD) *((LPDWORD *) pvParameterValue3),
                                 (LPDWORD) *((LPDWORD *) pvParameterValue4),
                                 (LPDWORD) *((LPDWORD *) pvParameterValue5) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxGetPortA:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );

            BOOL     fReturnValue;

            fReturnValue = FaxGetPortA( (HANDLE) *((HANDLE *) pvParameterValue0),
                                        (PFAX_PORT_INFOA *) *((PFAX_PORT_INFOA * *) pvParameterValue1) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;

         }

         break;

      case eFaxGetPortW:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );

            BOOL     fReturnValue;

            fReturnValue = FaxGetPortW( (HANDLE) *((HANDLE *) pvParameterValue0),
                                        (PFAX_PORT_INFOW *) *((PFAX_PORT_INFOW * *) pvParameterValue1) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;

         }

         break;

      case eFaxGetRoutingInfoA:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;
            void *   pvParameterValue2;
            void *   pvParameterValue3;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );
            pvParameterValue2 = GetParameterValuePointer ( 2 );
            pvParameterValue3 = GetParameterValuePointer ( 3 );

            BOOL     fReturnValue;

            fReturnValue = FaxGetRoutingInfoA( (HANDLE) *((HANDLE *) pvParameterValue0),
                                               (LPSTR) *((LPSTR *) pvParameterValue1),
                                               (LPBYTE *) *((LPDWORD *) pvParameterValue2),
                                               (LPDWORD) *((LPDWORD *) pvParameterValue3) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxGetRoutingInfoW:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;
            void *   pvParameterValue2;
            void *   pvParameterValue3;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );
            pvParameterValue2 = GetParameterValuePointer ( 2 );
            pvParameterValue3 = GetParameterValuePointer ( 3 );

            BOOL     fReturnValue;

            fReturnValue = FaxGetRoutingInfoW( (HANDLE) *((HANDLE *) pvParameterValue0),
                                               (LPWSTR) *((LPWSTR *) pvParameterValue1),
                                               (LPBYTE *) *((LPDWORD *) pvParameterValue2),
                                               (LPDWORD) *((LPDWORD *) pvParameterValue3) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxInitializeEventQueue:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;
            void *   pvParameterValue2;
            void *   pvParameterValue3;
            void *   pvParameterValue4;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );
            pvParameterValue2 = GetParameterValuePointer ( 2 );
            pvParameterValue3 = GetParameterValuePointer ( 3 );
            pvParameterValue4 = GetParameterValuePointer ( 4 );

            BOOL     fReturnValue;

            fReturnValue = FaxInitializeEventQueue( (HANDLE) *((HANDLE *) pvParameterValue0),
                                                    (HANDLE) *((HANDLE *) pvParameterValue1),
                                                    (DWORD)  *((DWORD *)  pvParameterValue2),
                                                    (HWND)   *((HWND *)   pvParameterValue3),
                                                    (ULONG_PTR) *((ULONG_PTR *) pvParameterValue4) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxOpenPort:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;
            void *   pvParameterValue2;
            void *   pvParameterValue3;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );
            pvParameterValue2 = GetParameterValuePointer ( 2 );
            pvParameterValue3 = GetParameterValuePointer ( 3 );

            BOOL     fReturnValue;

            fReturnValue = FaxOpenPort( (HANDLE) *((HANDLE *) pvParameterValue0),
                                        (DWORD) *((DWORD *) pvParameterValue1),
                                        (DWORD) *((DWORD *) pvParameterValue2),
                                        (LPHANDLE) *((LPHANDLE *) pvParameterValue3) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxPrintCoverPageA:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );

            BOOL     fReturnValue;

            fReturnValue = FaxPrintCoverPageA( (PFAX_CONTEXT_INFOA) *((PFAX_CONTEXT_INFOA *) pvParameterValue0),
                                               (PFAX_COVERPAGE_INFOA) *((PFAX_COVERPAGE_INFOA *) pvParameterValue1) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxPrintCoverPageW:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );

            BOOL     fReturnValue;

            fReturnValue = FaxPrintCoverPageW( (PFAX_CONTEXT_INFOW) *((PFAX_CONTEXT_INFOW *) pvParameterValue0),
                                               (PFAX_COVERPAGE_INFOW) *((PFAX_COVERPAGE_INFOW *) pvParameterValue1) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxSendDocumentA:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;
            void *   pvParameterValue2;
            void *   pvParameterValue3;
            void *   pvParameterValue4;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );
            pvParameterValue2 = GetParameterValuePointer ( 2 );
            pvParameterValue3 = GetParameterValuePointer ( 3 );
            pvParameterValue4 = GetParameterValuePointer ( 4 );

            BOOL     fReturnValue;

            fReturnValue = FaxSendDocumentA( (HANDLE) *((HANDLE *) pvParameterValue0),
                                             (LPSTR) *((LPSTR *) pvParameterValue1),
                                             (PFAX_JOB_PARAMA) *((PFAX_JOB_PARAMA *) pvParameterValue2),
                                             ( PFAX_COVERPAGE_INFOA) *(( PFAX_COVERPAGE_INFOA *) pvParameterValue3),
                                             (LPDWORD) *((LPDWORD *) pvParameterValue4) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxSendDocumentW:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;
            void *   pvParameterValue2;
            void *   pvParameterValue3;
            void *   pvParameterValue4;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );
            pvParameterValue2 = GetParameterValuePointer ( 2 );
            pvParameterValue3 = GetParameterValuePointer ( 3 );
            pvParameterValue4 = GetParameterValuePointer ( 4 );

            BOOL     fReturnValue;

            fReturnValue = FaxSendDocumentW( (HANDLE) *((HANDLE *) pvParameterValue0),
                                             (LPWSTR) *((LPWSTR *) pvParameterValue1),
                                             (PFAX_JOB_PARAMW) *((PFAX_JOB_PARAMW *) pvParameterValue2),
                                             (PFAX_COVERPAGE_INFOW) *(( PFAX_COVERPAGE_INFOW *) pvParameterValue3),
                                             (LPDWORD) *((LPDWORD *) pvParameterValue4) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxSetConfigurationA:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );

            BOOL     fReturnValue;

            fReturnValue = FaxSetConfigurationA( (HANDLE) *((HANDLE *) pvParameterValue0),
                                                 (PFAX_CONFIGURATIONA) *((PFAX_CONFIGURATIONA *) pvParameterValue1) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxSetConfigurationW:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );

            BOOL     fReturnValue;

            fReturnValue = FaxSetConfigurationW( (HANDLE) *((HANDLE *) pvParameterValue0),
                                                 (PFAX_CONFIGURATIONW) *((PFAX_CONFIGURATIONW *) pvParameterValue1) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxSetJobA:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;
            void *   pvParameterValue2;
            void *   pvParameterValue3;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );
            pvParameterValue2 = GetParameterValuePointer ( 2 );
            pvParameterValue3 = GetParameterValuePointer ( 3 );

            BOOL     fReturnValue;

            fReturnValue = FaxSetJobA( (HANDLE) *((HANDLE *) pvParameterValue0),
                                       (DWORD) *((DWORD *) pvParameterValue1),
                                       (DWORD) *((DWORD *) pvParameterValue2),
                                       (PFAX_JOB_ENTRYA) *((PFAX_JOB_ENTRYA *) pvParameterValue3) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxSetJobW:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;
            void *   pvParameterValue2;
            void *   pvParameterValue3;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );
            pvParameterValue2 = GetParameterValuePointer ( 2 );
            pvParameterValue3 = GetParameterValuePointer ( 3 );

            BOOL     fReturnValue;

            fReturnValue = FaxSetJobW( (HANDLE) *((HANDLE *) pvParameterValue0),
                                       (DWORD) *((DWORD *) pvParameterValue1),
                                       (DWORD) *((DWORD *) pvParameterValue2),
                                       (PFAX_JOB_ENTRYW) *((PFAX_JOB_ENTRYW *) pvParameterValue3) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxSetLoggingCategoriesA:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;
            void *   pvParameterValue2;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );
            pvParameterValue2 = GetParameterValuePointer ( 2 );

            BOOL     fReturnValue;

            fReturnValue = FaxSetLoggingCategoriesA( (HANDLE) *((HANDLE *) pvParameterValue0),
                                       (PFAX_LOG_CATEGORY) *((PFAX_LOG_CATEGORY *) pvParameterValue1),
                                       (DWORD) *((DWORD *) pvParameterValue2) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxSetLoggingCategoriesW:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;
            void *   pvParameterValue2;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );
            pvParameterValue2 = GetParameterValuePointer ( 2 );

            BOOL     fReturnValue;

            fReturnValue = FaxSetLoggingCategoriesW( (HANDLE) *((HANDLE *) pvParameterValue0),
                                       (PFAX_LOG_CATEGORY) *((PFAX_LOG_CATEGORY *) pvParameterValue1),
                                       (DWORD) *((DWORD *) pvParameterValue2) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxSetPortA:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );

            BOOL     fReturnValue;

            fReturnValue = FaxSetPortA( (HANDLE) *((HANDLE *) pvParameterValue0),
                                        (PFAX_PORT_INFOA) *((PFAX_PORT_INFOA *) pvParameterValue1) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxSetPortW:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );

            BOOL     fReturnValue;

            fReturnValue = FaxSetPortW( (HANDLE) *((HANDLE *) pvParameterValue0),
                                        (PFAX_PORT_INFOW) *((PFAX_PORT_INFOW *) pvParameterValue1) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxSetRoutingInfoA:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;
            void *   pvParameterValue2;
            void *   pvParameterValue3;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );
            pvParameterValue2 = GetParameterValuePointer ( 2 );
            pvParameterValue3 = GetParameterValuePointer ( 3 );

            BOOL     fReturnValue;

            fReturnValue = FaxSetRoutingInfoA( (HANDLE) *((HANDLE *) pvParameterValue0),
                                               (LPSTR) *((LPSTR *) pvParameterValue1),
                                               (LPBYTE) *((LPBYTE *) pvParameterValue2),
                                               (DWORD) *((DWORD *) pvParameterValue3) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxSetRoutingInfoW:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;
            void *   pvParameterValue2;
            void *   pvParameterValue3;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );
            pvParameterValue2 = GetParameterValuePointer ( 2 );
            pvParameterValue3 = GetParameterValuePointer ( 3 );

            BOOL     fReturnValue;

            fReturnValue = FaxSetRoutingInfoW( (HANDLE) *((HANDLE *) pvParameterValue0),
                                               (LPWSTR) *((LPWSTR *) pvParameterValue1),
                                               (LPBYTE) *((LPBYTE *) pvParameterValue2),
                                               (DWORD) *((DWORD *) pvParameterValue3) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxStartPrintJobA:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;
            void *   pvParameterValue2;
            void *   pvParameterValue3;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );
            pvParameterValue2 = GetParameterValuePointer ( 2 );
            pvParameterValue3 = GetParameterValuePointer ( 3 );

            BOOL     fReturnValue;

            fReturnValue = FaxStartPrintJobA( (LPSTR) *((LPSTR *) pvParameterValue0),
                                              (PFAX_PRINT_INFOA) *((PFAX_PRINT_INFOA *) pvParameterValue1),
                                              (LPDWORD) *((LPDWORD *) pvParameterValue2),
                                              (PFAX_CONTEXT_INFOA ) *((PFAX_CONTEXT_INFOA  *) pvParameterValue3) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;

      case eFaxStartPrintJobW:
         {
            void *   pvParameterValue0;
            void *   pvParameterValue1;
            void *   pvParameterValue2;
            void *   pvParameterValue3;

            pvParameterValue0 = GetParameterValuePointer ( 0 );
            pvParameterValue1 = GetParameterValuePointer ( 1 );
            pvParameterValue2 = GetParameterValuePointer ( 2 );
            pvParameterValue3 = GetParameterValuePointer ( 3 );

            BOOL     fReturnValue;

            fReturnValue = FaxStartPrintJobW( (LPWSTR) *((LPWSTR *) pvParameterValue0),
                                              (PFAX_PRINT_INFOW) *((PFAX_PRINT_INFOW *) pvParameterValue1),
                                              (LPDWORD) *((LPDWORD *) pvParameterValue2),
                                              (PFAX_CONTEXT_INFOW) *((PFAX_CONTEXT_INFOW *) pvParameterValue3) );

            *((BOOL *) m_pvReturnValue) = fReturnValue;
         }

         break;
   }
}



/*
 *  GetFunctionIndexEnum
 *
 *  Purpose: 
 *          This function returns the eFunctionIndex value that represents the
 *          Fax Api function whose name is in rcsFunctionName.
 *
 *  Arguments:
 *          rcsFunctionName - a reference to a CString that contains the name
 *                            of a Fax Api function.
 *
 *  Returns:
 *          The eFunctionIndex value that represents a Fax Api function.
 *
 *  Note:
 *          This function uses "goto" statements to preclude execution of comparisons
 *          that are guaranteed to fail.
 *
 */

eFunctionIndex CFaxApiFunctionInfo::GetFunctionIndexEnum( const CString & rcsFunctionName )
{
   eFunctionIndex eReturnValue;

   /* Note: a "switch" statement cannot be used here because rcsFunctionName */
   /*       is not an integral type and is an illegal switch expression.     */

   if ( rcsFunctionName.Compare( TEXT("FaxAbort") ) == 0 )
   {
      eReturnValue = eFaxAbort;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxClose") ) == 0 )
   {
      eReturnValue = eFaxClose;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxConnectFaxServerA") ) == 0 )
   {
      eReturnValue = eFaxConnectFaxServerA;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxConnectFaxServerW") ) == 0 )
   {
      eReturnValue = eFaxConnectFaxServerW;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxEnableRoutingMethodA") ) == 0 )
   {
      eReturnValue = eFaxEnableRoutingMethodA;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxEnableRoutingMethodW") ) == 0 )
   {
      eReturnValue = eFaxEnableRoutingMethodW;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxEnumJobsA") ) == 0 )
   {
      eReturnValue = eFaxEnumJobsA;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxEnumJobsW") ) == 0 )
   {
      eReturnValue = eFaxEnumJobsW;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxEnumPortsA") ) == 0 )
   {
      eReturnValue = eFaxEnumPortsA;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxEnumPortsW") ) == 0 )
   {
      eReturnValue = eFaxEnumPortsW;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxEnumRoutingMethodsA") ) == 0 )
   {
      eReturnValue = eFaxEnumRoutingMethodsA;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxEnumRoutingMethodsW") ) == 0 )
   {
      eReturnValue = eFaxEnumRoutingMethodsW;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxFreeBuffer") ) == 0 )
   {
      eReturnValue = eFaxFreeBuffer;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxGetConfigurationA") ) == 0 )
   {
      eReturnValue = eFaxGetConfigurationA;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxGetConfigurationW") ) == 0 )
   {
      eReturnValue = eFaxGetConfigurationW;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxGetDeviceStatusA") ) == 0 )
   {
      eReturnValue = eFaxGetDeviceStatusA;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxGetDeviceStatusW") ) == 0 )
   {
      eReturnValue = eFaxGetDeviceStatusW;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxGetJobA") ) == 0 )
   {
      eReturnValue = eFaxGetJobA;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxGetJobW") ) == 0 )
   {
      eReturnValue = eFaxGetJobW;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxGetLoggingCategoriesA") ) == 0 )
   {
      eReturnValue = eFaxGetLoggingCategoriesA;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxGetLoggingCategoriesW") ) == 0 )
   {
      eReturnValue = eFaxGetLoggingCategoriesW;

      goto ExitGetFunctionIndexEnum;
   }

#ifdef   ELIMINATED_FROM_API
   if ( rcsFunctionName.Compare( TEXT("FaxGetPageData") ) == 0 )
   {
      eReturnValue = eFaxGetPageData;

      goto ExitGetFunctionIndexEnum;
   }
#endif   // ELIMINATED_FROM_API

   if ( rcsFunctionName.Compare( TEXT("FaxGetPortA") ) == 0 )
   {
      eReturnValue = eFaxGetPortA;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxGetPortW") ) == 0 )
   {
      eReturnValue = eFaxGetPortW;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxGetRoutingInfoA") ) == 0 )
   {
      eReturnValue = eFaxGetRoutingInfoA;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxGetRoutingInfoW") ) == 0 )
   {
      eReturnValue = eFaxGetRoutingInfoW;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxInitializeEventQueue") ) == 0 )
   {
      eReturnValue = eFaxInitializeEventQueue;

      goto ExitGetFunctionIndexEnum;
   }

#ifdef   ELIMINATED_FROM_API
   if ( rcsFunctionName.Compare( TEXT("FaxOpenJob") ) == 0 )
   {
      eReturnValue = eFaxOpenJob;

      goto ExitGetFunctionIndexEnum;
   }
#endif   // ELIMINATED_FROM_API

   if ( rcsFunctionName.Compare( TEXT("FaxOpenPort") ) == 0 )
   {
      eReturnValue = eFaxOpenPort;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxPrintCoverPageA") ) == 0 )
   {
      eReturnValue = eFaxPrintCoverPageA;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxPrintCoverPageW") ) == 0 )
   {
      eReturnValue = eFaxPrintCoverPageW;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxReceiveDocumentA") ) == 0 )
   {
      eReturnValue = eFaxReceiveDocumentA;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxReceiveDocumentW") ) == 0 )
   {
      eReturnValue = eFaxReceiveDocumentW;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxSendDocumentA") ) == 0 )
   {
      eReturnValue = eFaxSendDocumentA;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxSendDocumentW") ) == 0 )
   {
      eReturnValue = eFaxSendDocumentW;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxSetConfigurationA") ) == 0 )
   {
      eReturnValue = eFaxSetConfigurationA;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxSetConfigurationW") ) == 0 )
   {
      eReturnValue = eFaxSetConfigurationW;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxSetJobA") ) == 0 )
   {
      eReturnValue = eFaxSetJobA;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxSetJobW") ) == 0 )
   {
      eReturnValue = eFaxSetJobW;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxSetLoggingCategoriesA") ) == 0 )
   {
      eReturnValue = eFaxSetLoggingCategoriesA;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxSetLoggingCategoriesW") ) == 0 )
   {
      eReturnValue = eFaxSetLoggingCategoriesW;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxSetPortA") ) == 0 )
   {
      eReturnValue = eFaxSetPortA;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxSetPortW") ) == 0 )
   {
      eReturnValue = eFaxSetPortW;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxSetRoutingInfoA") ) == 0 )
   {
      eReturnValue = eFaxSetRoutingInfoA;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxSetRoutingInfoW") ) == 0 )
   {
      eReturnValue = eFaxSetRoutingInfoW;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxStartPrintJobA") ) == 0 )
   {
      eReturnValue = eFaxStartPrintJobA;

      goto ExitGetFunctionIndexEnum;
   }

   if ( rcsFunctionName.Compare( TEXT("FaxStartPrintJobW") ) == 0 )
   {
      eReturnValue = eFaxStartPrintJobW;

      goto ExitGetFunctionIndexEnum;
   }
   else
   {
      eReturnValue = eIllegalFunctionIndex;     // The function name was not
                                                // in the list above
   }

ExitGetFunctionIndexEnum:

   return ( eReturnValue );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\faxapi\fcnselvw.cpp ===
// fcnvw.cpp : implementation file
//

#include "stdafx.h"
#include "FaxApi.h"
#include "fcnselvw.h"

#include "fcninfvw.h"
#include "exelogvw.h"
#include "rvoutvw.h"
#include "paramvw.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern CFaxApiApp *	pFaxApiBrowserApp;

/////////////////////////////////////////////////////////////////////////////
// CFaxApiFunctionSelectionFormView

IMPLEMENT_DYNCREATE(CFaxApiFunctionSelectionFormView, CFormView)

CFaxApiFunctionSelectionFormView::CFaxApiFunctionSelectionFormView()
	: CFormView(CFaxApiFunctionSelectionFormView::IDD)
{
	//{{AFX_DATA_INIT(CFaxApiFunctionSelectionFormView)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CFaxApiFunctionSelectionFormView::~CFaxApiFunctionSelectionFormView()
{
}

void CFaxApiFunctionSelectionFormView::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFaxApiFunctionSelectionFormView)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFaxApiFunctionSelectionFormView, CFormView)
	//{{AFX_MSG_MAP(CFaxApiFunctionSelectionFormView)
	ON_LBN_DBLCLK(IDC_LISTBOX_FAX_API_FUNCTIONS, OnDblclkListboxFaxApiFunctions)
	ON_LBN_SELCHANGE(IDC_LISTBOX_FAX_API_FUNCTIONS, OnSelchangeListboxFaxApiFunctions)
	ON_BN_CLICKED(IDC_BUTTON_EXECUTE_API_FUNCTION, OnButtonExecuteApiFunction)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFaxApiFunctionSelectionFormView diagnostics

#ifdef _DEBUG
void CFaxApiFunctionSelectionFormView::AssertValid() const
{
	CFormView::AssertValid();
}

void CFaxApiFunctionSelectionFormView::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CFaxApiFunctionSelectionFormView message handlers

BOOL CFaxApiFunctionSelectionFormView::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext) 
{
   BOOL  fReturnValue;

   fReturnValue = CFormView::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);

   if ( fReturnValue != (BOOL) FALSE )
   {
      // Save the handle to this view in the CFaxApiApp object.

      pFaxApiBrowserApp->StoreFaxApiFunctionSelectionFormViewHWND( m_hWnd );

      int      xItemIndex;
      int      xNumApiFunctions;

      // Get a pointer to the Fax Api Function list.

      CString  csFunctionName;

      CListBox *  pclbFaxApiFunctionList;

      pclbFaxApiFunctionList = (CListBox *) ( (CDialog *) this)->
                               GetDlgItem( IDC_LISTBOX_FAX_API_FUNCTIONS );

      // Is the pointer valid ?

      if ( pclbFaxApiFunctionList != (CListBox *) NULL )
      {
         /* Empty the listbox. */

         pclbFaxApiFunctionList->ResetContent();

         int xRV;

         xNumApiFunctions = pFaxApiBrowserApp->GetNumberOfFaxApiFunctions();

         if ( xNumApiFunctions > 0 )
         {
            CFaxApiFunctionInfo *   pcfafiFunctionInfo;

            for ( xItemIndex = 0; xItemIndex < xNumApiFunctions; xItemIndex++ )
            {
               pcfafiFunctionInfo = pFaxApiBrowserApp->GetFaxApiFunctionInfoPointer( xItemIndex );

               csFunctionName = pcfafiFunctionInfo->GetFunctionName();

               xRV = pclbFaxApiFunctionList->InsertString( xItemIndex,
                                                           (LPCTSTR) csFunctionName );

               if ( (xRV == LB_ERR) || (xRV == LB_ERRSPACE) )
               {
                  fReturnValue = (BOOL) FALSE;

                  break;      // terminate the loop on error !
               }
            }  // end of for loop
         }

         /* Disable the "Execute API Function" button. A selection must be made */
         /* before the Execute Fax API function button gets enabled.            */

         DisableExecuteButton();

         fReturnValue = (BOOL) TRUE;
      }
      else
      {
         fReturnValue = (BOOL) FALSE;
      }
   }

   return ( fReturnValue );
}



/*
 *  OnSelchangeListboxFaxApiFunctions
 *
 *  Purpose: 
 *          This function handles the LBN_SELCHANGE messages from the
 *          Fax API function listbox.
 *
 *  Arguments:
 *          None
 *
 *  Returns:
 *          None
 *
 */

void CFaxApiFunctionSelectionFormView::OnSelchangeListboxFaxApiFunctions() 
{
   // Get a pointer to the Fax API Function Information object.

   CFaxApiFunctionInfo *   pcfafiFunctionInfo;

   pcfafiFunctionInfo = GetSelectedFaxApiFunctionInfoPointer();

   // Is the pointer to the Fax API Function Info object valid ?

   if ( pcfafiFunctionInfo != (CFaxApiFunctionInfo *) NULL )
   {
      /*************************************/
      /* Update the controls on this view. */
      /*************************************/

      // Get the name of the selected Fax API function.

      CString  csFaxApiFunctionName;

      csFaxApiFunctionName = pcfafiFunctionInfo->GetFunctionName();

      // Update the text of the "execute" button. Start by getting a 
      // pointer to the button.

      CWnd *   pcwndExecuteButton;

      pcwndExecuteButton = ((CDialog *) this)->
         GetDlgItem( IDC_BUTTON_EXECUTE_API_FUNCTION );

      // Is the pointer valid ?

      if ( pcwndExecuteButton != (CWnd *) NULL )
      {
         /* Enable the "Execute API Function" button. */

         pcwndExecuteButton->EnableWindow( (BOOL) TRUE );

         /* Update the text on the button face. */

         CString  csButtonFace;


         // Note: this needs to be smart enough to determine whether the
         //       string created by the following statement will fit on
         //       the button face. Call GetTextMetrics 

         csButtonFace.Format( TEXT("Execute %s"), csFaxApiFunctionName );

         pcwndExecuteButton->SetWindowText( csButtonFace );
      }

      // Update the Remarks edit control. Start by getting a pointer to
      // the Remarks edit control.

      CEdit *   pceRemarksEditCtrl;

      pceRemarksEditCtrl = (CEdit *) ((CDialog *) this)->GetDlgItem( IDC_EDIT_REMARKS );

      // Is the pointer valid ?

      if ( pceRemarksEditCtrl != (CEdit *) NULL )
      {
         // Update the Remarks edit control.

         CString  csRemarks;

         csRemarks = pcfafiFunctionInfo->GetRemarks();

         pceRemarksEditCtrl->SetWindowText( csRemarks );
      }

      /***************************/
      /* Update the other views. */
      /***************************/

      // Update the CFunctionInfoFormView.

      CFunctionInfoFormView * pcFunctionInfoFormView;

      // Get a pointer to the CFunctionInfoFormView object.

      pcFunctionInfoFormView = (CFunctionInfoFormView *) pFaxApiBrowserApp->
                               GetFunctionInfoFormViewPointer();

      // Is the pointer valid ?

      if ( pcFunctionInfoFormView != (CFunctionInfoFormView *) NULL )
      {
         // Update the Function Prototype edit control.

         CString  csFaxApiFunctionPrototype;

         csFaxApiFunctionPrototype = pcfafiFunctionInfo->GetFunctionPrototype();

         pcFunctionInfoFormView->
            UpdateFunctionPrototypeEditCtrl( (CString &) csFaxApiFunctionPrototype );

         // Update the Return Value Description edit control.

         CString  csReturnValueDescription;

         csReturnValueDescription = pcfafiFunctionInfo->GetReturnValueDescription();

         pcFunctionInfoFormView->
            UpdateReturnValueDescriptionEditCtrl( (CString &) csReturnValueDescription );
      }

      // Update the CParameterInfoFormView.

      CParameterInfoFormView *   pcParameterInfoFormView;

      // Get a pointer to the CParameterInfoFormView object.

      pcParameterInfoFormView = (CParameterInfoFormView *) pFaxApiBrowserApp->
         GetParameterInfoFormViewPointer();

      // Is the pointer valid ?

      if ( pcParameterInfoFormView != (CParameterInfoFormView *) NULL )
      {
         // Update the Parameter List.

         pcParameterInfoFormView->UpdateParameterListbox( pcfafiFunctionInfo );

         // Clear the remainder of the CParameterInfoFormView because
         // unless the same Fax Api function has been reselected in the list,
         // no parameter can be selected.
         // Note: this does NOT clear the parameter list !

         pcParameterInfoFormView->ClearParameterEditControlFamily();
      }

      // Clear the Return Value Output view because selection of a Fax API
      // function in this view means that whatever is in the Return Value Output
      // Form View is invalid.

      CReturnValueOutputFormView *  pcReturnValueOutputFormView;

      // Get a pointer to the CReturnValueOutputFormView object.

      pcReturnValueOutputFormView = (CReturnValueOutputFormView *) pFaxApiBrowserApp->
         GetReturnValueOutputFormViewPointer();

      // Is the pointer valid ?

      if ( pcReturnValueOutputFormView != (CReturnValueOutputFormView *) NULL )
      {
         pcReturnValueOutputFormView->ClearReturnValueOutputEditCtrl();
      }
   }
   else
   {
      /* Disable the "Execute API Function" button. */

      DisableExecuteButton();
   }
}



/*
 *  DisableExecuteButton
 *
 *  Purpose: 
 *          This function disables the Execute Fax API function button.
 *
 *  Arguments:
 *          None
 *
 *  Returns:
 *          TRUE - indicates that the button was disabled succesfully.
 *          FALSE - indicates that some error occured.
 *
 */

BOOL CFaxApiFunctionSelectionFormView::DisableExecuteButton( void )
{
   BOOL  fReturnValue;

   // Get a pointer to the Execute Fax API function button.

   CWnd *   pcwndExecuteButton;

   pcwndExecuteButton = ((CDialog *) this)->
      GetDlgItem( IDC_BUTTON_EXECUTE_API_FUNCTION );

   // Is the pointer valid ?

   if ( pcwndExecuteButton != (CWnd *) NULL )
   {
      /* Update the text on the button face. */

      CString  csButtonFace;

      csButtonFace = (CString) TEXT("Execute Fax API Function");

      pcwndExecuteButton->SetWindowText( csButtonFace );

      /* Disable the "Execute API Function" button. */

      pcwndExecuteButton->EnableWindow( (BOOL) FALSE );

      fReturnValue = (BOOL) TRUE;
   }
   else
      fReturnValue = (BOOL) FALSE;

   return ( fReturnValue );
}



void CFaxApiFunctionSelectionFormView::OnDblclkListboxFaxApiFunctions() 
{
	ExecuteFaxApiFunction();
}



void CFaxApiFunctionSelectionFormView::OnButtonExecuteApiFunction() 
{
	ExecuteFaxApiFunction();	
}



BOOL CFaxApiFunctionSelectionFormView::ExecuteFaxApiFunction( void )
{
   BOOL  fReturnValue;

   // Get a pointer to the seleted CFaxApiFunctionInfo object.

   CFaxApiFunctionInfo *   pcfafiFunctionInfo;

   pcfafiFunctionInfo = GetSelectedFaxApiFunctionInfoPointer();

   // Is the pointer to the Fax API Function Info object valid ?

   if ( pcfafiFunctionInfo != (CFaxApiFunctionInfo *) NULL )
   {
      /* Update the Output Log view prior to executing the API function. */

      // Get a pointer to the CExecutionLogFormView object.

      CExecutionLogFormView * pcExecutionLogFormView;

      pcExecutionLogFormView = (CExecutionLogFormView *) pFaxApiBrowserApp->
         GetExecutionLogFormViewPointer();

      // Is the pointer to the CExecutionLogFormView object valid ?

      if ( pcExecutionLogFormView != (CExecutionLogFormView *) NULL )
      {
         pcExecutionLogFormView->UpdateExecutionLogBeforeApiCall( pcfafiFunctionInfo );

         /*******************************************/
         /* EXECUTE THE SELECTED FAX API FUNCTION ! */
         /*******************************************/

//#ifdef   TEST
         pcfafiFunctionInfo->Execute();
//#endif   // TEST

         /* Update the Return Value Output view. */

         // Get a pointer to the CReturnValueOutputFormView object.

         CReturnValueOutputFormView * pcReturnValueOutputFormView;

         pcReturnValueOutputFormView = (CReturnValueOutputFormView *) pFaxApiBrowserApp->
                                       GetReturnValueOutputFormViewPointer();

         // Is the pointer valid ?

         if ( pcReturnValueOutputFormView != (CReturnValueOutputFormView *) NULL )
         {
            CString  csReturnValue;
            CString  csText;

            pcfafiFunctionInfo->FormatReturnValueForOutput( (CString &) csReturnValue );

            csText.Format( TEXT("%s"), csReturnValue );

            pcReturnValueOutputFormView->
            UpdateReturnValueOutputEditCtrl( (CString &) csText );

            /* Update the Output Log view with the results of having */
            /* called the Fax API function.                          */

            pcExecutionLogFormView->
               UpdateExecutionLogAfterApiReturn( pcfafiFunctionInfo );
         }
         else
         {
            // Couldn't get a pointer to the CReturnValueOutputFormView object.

            fReturnValue = (BOOL) FALSE;
         }
      }
      else
      {
         // Couldn't get a pointer to the CExecutionLogFormView object.

         fReturnValue = (BOOL) FALSE;
      }
   }
   else
   {
      // Couldn't get a pointer to the CFaxApiFunctionInfo object for the
      // selected Fax API function.

      fReturnValue = (BOOL) FALSE;
   }

   return ( fReturnValue );
}

void CFaxApiFunctionSelectionFormView::OnInitialUpdate() 
{
	CFormView::OnInitialUpdate();
	
	// TODO: Add your specialized code here and/or call the base class
	
}



/*
 *  GetSelectedFaxApiFunctionInfoPointer
 *
 *  Purpose: 
 *          This function returns a pointer to the CFaxApiFunctionInfo object
 *          that corresponds to the Fax API function that is selected in the
 *          Fax API function listbox.
 *
 *  Arguments:
 *          None
 *
 *  Returns:
 *          A pointer to the CFaxApiFunctionInfo object that corresponds to
 *          the current selection in the Fax API function listbox.
 *
 *          If no function is selected in the listbox or any other error
 *          occurs, this function returns (CFaxApiFunctionInfo) NULL.
 *
 */

CFaxApiFunctionInfo * CFaxApiFunctionSelectionFormView::GetSelectedFaxApiFunctionInfoPointer()
{
   CFaxApiFunctionInfo *  pcfafiFunctionInfo;

   // Get a pointer to the Fax API function listbox.

   CListBox *	pclbFaxApiFunctionList;

   pclbFaxApiFunctionList = (CListBox *) ((CDialog *) this)->
                            GetDlgItem( IDC_LISTBOX_FAX_API_FUNCTIONS );

   // Is the pointer to the listbox valid ?

   if ( pclbFaxApiFunctionList != (CListBox *) NULL )
   {
      int   xItemIndex;

      xItemIndex = pclbFaxApiFunctionList->GetCurSel();

      /* Is the item index valid */

      if ( xItemIndex != (int) LB_ERR )
      {
         // Get a pointer to the Fax API Function Information object.
   
         pcfafiFunctionInfo = pFaxApiBrowserApp->GetFaxApiFunctionInfoPointer( xItemIndex );
      }
      else
      {
         pcfafiFunctionInfo = (CFaxApiFunctionInfo *) NULL;
      }
   }
   else
   {
      pcfafiFunctionInfo = (CFaxApiFunctionInfo *) NULL;
   }

   return ( pcfafiFunctionInfo );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\faxapi\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by FaxApi.rc
//
#define IDD_ABOUTBOX                    100
#define IDR_MAINFRAME                   128
#define IDR_FAXAPITYPE                  129
#define IDD_FUNCTION_SELECTION          130
#define IDD_PARAMETER_INFO              131
#define IDD_FUNCTION_INFO               132
#define IDD_RETURN_VALUE_OUTPUT         136
#define IDD_EXECUTION_LOG               137
#define IDC_LISTBOX_FAX_API_FUNCTIONS   1000
#define IDC_BUTTON_EXECUTE_API_FUNCTION 1001
#define IDC_STATIC_PARAMETERS           1002
#define IDC_STATIC_API_FUNCTIONS        1003
#define IDC_STATIC_PARAMETER_VALUE      1004
#define IDC_STATIC_PARAMETER_RANGE      1005
#define IDC_LISTBOX_PARAMETERS          1006
#define IDC_EDIT_PARAMETER_VALUE        1007
#define IDC_EDIT_PARAM_HI_LIMIT         1008
#define IDC_EDIT_PARAM_LOW_LIMIT        1009
#define IDC_STATIC_FUNCTION_PROTOTYPE   1010
#define IDC_EDIT_FUNCTION_PROTOTYPE     1011
#define IDC_STATIC_REMARKS              1012
#define IDC_EDIT_REMARKS                1013
#define IDC_STATIC_PARAMETER_NAME       1015
#define IDC_EDIT_PARAMETER_DESCRIPTION  1016
#define IDC_EDIT_RETURN_VALUE           1017
#define IDC_STATIC_RETURN_VALUE_DESCRIPTION 1018
#define IDC_EDIT_RETURN_VALUE_DESCRIPTION 1019
#define IDC_STATIC_EXECUTION_LOG        1020
#define IDC_EDIT_EXECUTION_LOG          1021

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        138
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1022
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\faxapi\rvoutvw.cpp ===
// rvoutvw.cpp : implementation file
//

#include "stdafx.h"
#include "FaxApi.h"
#include "rvoutvw.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern CFaxApiApp *	pFaxApiBrowserApp;

/////////////////////////////////////////////////////////////////////////////
// CReturnValueOutputFormView

IMPLEMENT_DYNCREATE(CReturnValueOutputFormView, CFormView)

CReturnValueOutputFormView::CReturnValueOutputFormView()
	: CFormView(CReturnValueOutputFormView::IDD)
{
	//{{AFX_DATA_INIT(CReturnValueOutputFormView)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CReturnValueOutputFormView::~CReturnValueOutputFormView()
{
}

void CReturnValueOutputFormView::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CReturnValueOutputFormView)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CReturnValueOutputFormView, CFormView)
	//{{AFX_MSG_MAP(CReturnValueOutputFormView)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CReturnValueOutputFormView diagnostics

#ifdef _DEBUG
void CReturnValueOutputFormView::AssertValid() const
{
	CFormView::AssertValid();
}

void CReturnValueOutputFormView::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CReturnValueOutputFormView message handlers

BOOL CReturnValueOutputFormView::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext) 
{
	BOOL	fReturnValue;
	
	fReturnValue = CFormView::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);

	if ( fReturnValue != (BOOL) FALSE )
	{
		// Save the handle to this view in the CFaxApiApp object.

		pFaxApiBrowserApp->StoreReturnValueOutputFormViewHWND( m_hWnd );
	}

	return ( fReturnValue );
}



BOOL CReturnValueOutputFormView::UpdateReturnValueOutputEditCtrl( CString & rcsReturnValueOutputString )
{
	BOOL	fReturnValue;

	// Get a pointer to the Return Value Output edit control;

	CEdit *	pceReturnValueOutputEditCtrl;

	pceReturnValueOutputEditCtrl = (CEdit *) ((CDialog *) this)->
		GetDlgItem( IDC_EDIT_RETURN_VALUE );

	// Is the pointer valid ?

	if ( pceReturnValueOutputEditCtrl != (CEdit *) NULL )
	{
		pceReturnValueOutputEditCtrl->SetWindowText( rcsReturnValueOutputString );

		fReturnValue = (BOOL) TRUE;
	}
	else
	{
		fReturnValue = (BOOL) FALSE;
	}

	return ( fReturnValue );
}



/*
 *  CReturnValueOutputFormView
 *
 *  Purpose: 
 *          This function cleard the Return Value Output edit control.
 *
 *  Arguments:
 *          None
 *
 *  Returns:
 *          TRUE - indicates that the edit control was cleared.
 *          FALSE - indicates that some error occured.
 *
 */

BOOL CReturnValueOutputFormView::ClearReturnValueOutputEditCtrl()
{
   BOOL fReturnValue;

   CEdit *	pceEditControl;

   pceEditControl = (CEdit *) ((CDialog *) this)->
      GetDlgItem( IDC_EDIT_RETURN_VALUE );

   if ( pceEditControl != (CEdit *) NULL )
   {
      pceEditControl->SetReadOnly( (BOOL) FALSE );

      pceEditControl->SetSel( 0, -1, (BOOL) TRUE );
      pceEditControl->Clear();

      pceEditControl->SetReadOnly( (BOOL) TRUE );
      
      fReturnValue = (BOOL) TRUE;
   }
   else
      fReturnValue = (BOOL) FALSE;

   return ( fReturnValue );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\faxapi\mainfrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__2E2118C8_2E1B_11D1_ACDA_00A0C908F98C__INCLUDED_)
#define AFX_MAINFRM_H__2E2118C8_2E1B_11D1_ACDA_00A0C908F98C__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CMainFrame : public CFrameWnd
{
protected: // create from serialization only
	CMainFrame();
	DECLARE_DYNCREATE(CMainFrame)

// Attributes
protected:
	CSplitterWnd m_wndSplitterMainFrame;		// Note that the main frame
                                                // is overlaid with a splitter
	CSplitterWnd m_wndSplitterInfoPane;         // window with three panes. 
                                                // Additional splitter windows
	CSplitterWnd m_wndSplitterOutputPane;       // are nested in
	                                            // m_wndSplitterMainFrame.
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	public:
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg void OnClose();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__2E2118C8_2E1B_11D1_ACDA_00A0C908F98C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\faxapi\paramvw.h ===
#if !defined(AFX_PARAMVW_H__2E2118D5_2E1B_11D1_ACDA_00A0C908F98C__INCLUDED_)
#define AFX_PARAMVW_H__2E2118D5_2E1B_11D1_ACDA_00A0C908F98C__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// paramvw.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CParameterInfoFormView form view

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

class CParameterInfoFormView : public CFormView
{
protected:
	CParameterInfoFormView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CParameterInfoFormView)

// Form Data
public:
	//{{AFX_DATA(CParameterInfoFormView)
	enum { IDD = IDD_PARAMETER_INFO };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CParameterInfoFormView)
	public:
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CParameterInfoFormView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

public:

   BOOL ClearParameterEditControlFamily();
   BOOL UpdateParameterListbox( CFaxApiFunctionInfo * pcfafiFunctionInfo );

private:

   void SetLimitTextParameterValueEditControl( CFaxApiFunctionInfo * pcfafiFunctionInfo,
                                               int xParameterIndex );


	// Generated message map functions
	//{{AFX_MSG(CParameterInfoFormView)
	afx_msg void OnSelchangeListboxParameters();
	afx_msg void OnKillfocusEditParameterValue();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PARAMVW_H__2E2118D5_2E1B_11D1_ACDA_00A0C908F98C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\faxapi\mainfrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "FaxApi.h"

#include "MainFrm.h"

#include "fcnselvw.h"
#include "paramvw.h"
#include "fcninfvw.h"
#include "rvoutvw.h"
#include "exelogvw.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern CFaxApiApp *	pFaxApiBrowserApp;

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_CLOSE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
	// TODO: add member initialization code here
	
}

CMainFrame::~CMainFrame()
{
}

BOOL CMainFrame::OnCreateClient( LPCREATESTRUCT lpcs,
	CCreateContext* pContext)
{
	BOOL	fReturnValue;

	// Note: The main frame window for the FaxApi browser is overlaid with
	//       a splitter window in which two additional splitter windows are
	//       nested. The top level splitter window consists of one row and
	//       three columns. The first column of the top level splitter window
	//       contains the list of Fax API functions. The second column, in 
	//       which an additional splitter window is nested, is used to display
	//       information about the Fax API function that is selected in the
	//       function list. The third column of the top level splitter window
	//       also contains a nested splitter window, and is used to display
	//       "output" generated by the execution of the selected Fax API function.

	// Create the top level splitter window.

	fReturnValue = m_wndSplitterMainFrame.CreateStatic( this, 1, 3 );

	if ( fReturnValue != (BOOL) FALSE )
	{
		// Create the view that manages the list of Fax API functions.

		m_wndSplitterMainFrame.CreateView( 0, 0, RUNTIME_CLASS( CFaxApiFunctionSelectionFormView ),
			CSize( 205, 320 ), pContext );

        // Add the second splitter window - which is a nested splitter - 
		// in column 1 of m_wndSplitterMainFrame. This is the "info pane".

        if (!m_wndSplitterInfoPane.CreateStatic(
                &m_wndSplitterMainFrame,     // our parent window is the first splitter
                2, 1,                        // the new splitter is 2 rows, 1 column
                WS_CHILD | WS_VISIBLE | WS_BORDER,  // style, WS_BORDER is needed
                m_wndSplitterMainFrame.IdFromRowCol(0, 1) ) )
        {
                TRACE0("Failed to create nested splitter for Info pane.\n");
                return FALSE;
        }

        // Set the initial width of the second column in m_wndSplitterMainFrame.
        // (determined experimentally)

        m_wndSplitterMainFrame.SetColumnInfo( 1, 320, 25 );

        // Create the two views which display information about the
		// selected Fax API function inside the nested splitter

		// Create the Function Info view.

        if (!m_wndSplitterInfoPane.CreateView(0, 0,
                RUNTIME_CLASS(CFunctionInfoFormView), CSize(320, 195), pContext))

        {
                TRACE0("Failed to create function prototype view in nested splitter\n");
                return FALSE;
        }

		// Create the view that handles information pertaining to the parameter
		// list for the selected Fax API function.

        if (!m_wndSplitterInfoPane.CreateView(1, 0,
                RUNTIME_CLASS(CParameterInfoFormView), CSize(320, 300), pContext))
        {
                TRACE0("Failed to create return value description view.\n");
                return FALSE;
        }

		// Create the third splitter, nested in the third column of the top
		// level splitter. The third column of the top level splitter is the
		// "output pane".

        if (!m_wndSplitterOutputPane.CreateStatic(
                &m_wndSplitterMainFrame,     // our parent window is the first splitter
                2, 1,                        // the new splitter is 2 rows, 1 column
                WS_CHILD | WS_VISIBLE | WS_BORDER,  // style, WS_BORDER is needed
                m_wndSplitterMainFrame.IdFromRowCol(0, 2) ) )
        {
                TRACE0("Failed to create nested splitter for Output pane.\n");
                return FALSE;
        }

		// Create the Return Value Output view in the "output pane".

		m_wndSplitterOutputPane.CreateView( 0, 0,
			RUNTIME_CLASS( CReturnValueOutputFormView ), CSize( 205, 90 ), pContext );

		m_wndSplitterOutputPane.CreateView( 1, 0,
			RUNTIME_CLASS( CExecutionLogFormView ), CSize( 205, 40 ), pContext );
	}

	return ( fReturnValue );
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CFrameWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

void CMainFrame::OnClose() 
{
	pFaxApiBrowserApp->DeleteCFaxApiFunctionInfoObjects();
	
	CFrameWnd::OnClose();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\faxapi\param.h ===
#ifndef _PARAM_H_
#define _PARAM_H_

/* CFaxApiFinctionParameterInfo class definition file. */


#define MAX_PARAM_VALUE_STRING_LENGTH 500

/* Parameter type enumeration */

enum eParamType
{
   // symbol                     // datatype

   eBOOL,                        // BOOL
   eDWORD,                       // DWORD
   eHANDLE,                      // HANDLE
   eHDC,                         // HDC
   ePHDC,                        // HDC *
   eLPBYTE,                      // LPBYTE
   ePLPBYTE,                     // LPBYTE *
   eLPDWORD,                     // LPDWORD
   eLPHANDLE,                    // LPHANDLE
   eLPSTR,                       // LPSTR
   eLPVOID,                      // LPVOID
   eLPWSTR,                      // LPWSTR
   ePFAX_CONFIGURATIONA,         // PFAX_CONFIGURATIONA
   ePPFAX_CONFIGURATIONA,        // PFAX_CONFIGURATIONA *
   ePFAX_CONFIGURATIONW,         // PFAX_CONFIGURATIONW
   ePPFAX_CONFIGURATIONW,        // PFAX_CONFIGURATIONW *
   ePFAX_COVERPAGE_INFOA,        // PFAX_COVERPAGE_INFOA
   ePFAX_COVERPAGE_INFOW,        // PFAX_COVERPAGE_INFOW
   ePPFAX_DEVICE_STATUSA,        // PFAX_DEVICE_STATUSA *
   ePPFAX_DEVICE_STATUSW,        // PFAX_DEVICE_STATUSW *
   ePFAX_JOB_ENTRYA,             // PFAX_JOB_ENTRYA
   ePPFAX_JOB_ENTRYA,            // PFAX_JOB_ENTRYA *
   ePFAX_JOB_ENTRYW,             // PFAX_JOB_ENTRYW
   ePPFAX_JOB_ENTRYW,            // PFAX_JOB_ENTRYW *
   ePFAX_JOB_PARAMA,             // PFAX_JOB_PARAMA
   ePFAX_JOB_PARAMW,             // PFAX_JOB_PARAMW
   ePFAX_LOG_CATEGORY,           // PFAX_LOG_CATEGORY
   ePPFAX_LOG_CATEGORY,          // PFAX_LOG_CATEGORY *
   ePFAX_PORT_INFOA,             // PFAX_PORT_INFOA
   ePPFAX_PORT_INFOA,            // PFAX_PORT_INFOA *
   ePFAX_PORT_INFOW,             // PFAX_PORT_INFOW
   ePPFAX_PORT_INFOW,            // PFAX_PORT_INFOW *
   ePFAX_PRINT_INFOA,            // PFAX_PRINT_INFOA
   ePFAX_PRINT_INFOW,            // PFAX_PRINT_INFOW
   ePPFAX_ROUTING_METHODA,       // PFAX_ROUTING_METHODA *
   ePPFAX_ROUTING_METHODW,       // PFAX_ROUTING_METHODW *

   eUnknownParamType,            // indicates that the parameter type is
                                 // not recognized;
};

/* The CFaxApiFunctionParameterInfo class manages all of the information */
/* pertaining to the parameter list for a Fax API function.              */

class CFaxApiFunctionParameterInfo : public CObject
{
public:
    CFaxApiFunctionParameterInfo();     // constructor

    ~CFaxApiFunctionParameterInfo();    // destructor

   /* member functions */

   void InitParameterInfoMember( const CString & rcsFunctionName );
   void FormatParameterValueForOutput( int xParameterIndex, CString & rcsParameterValue );

   void *   GetParameterValuePointer( int xParameterIndex );

   int GetNumberOfParameters();

   CString GetParameterName( int xParameterIndex );
   CString GetParameterTypeString( int xParameterIndex );
   CString GetParameterDescription( int xParameterIndex );

   BOOL StoreParameterValue( int xParameterIndex, CString & rcsParameterValue );

   eParamType GetParameterTypeEnum( int xParameterIndex );

private:
   void * AllocateStorageForParameterEntity( eParamType eParameterType );
   eParamType GetParameterTypeEnum( const CString & rcsParameterType );
   CString PreProcessParameterValueString( const CString & rcsParameterValue );

private:

   /* data members */

   int               m_xNumberOfParameters;

   CStringArray      m_csaParameterName;

   CStringArray      m_csaParameterDescription;

   CUIntArray        m_cuiaParameterTypeEnum;

   /* Since the type of each parameter is probably different, the storage     */
   /* for each parameter and the associated range variables must be allocated */
   /* dynamically. The following members are arrays of pointers to the        */
   /* actual storage locations.                                               */

   CPtrArray         m_cpaParameterValue;

   CPtrArray         m_cpaParameterRange1;

   CPtrArray         m_cpaParameterRange2;
};
#endif   // _PARAM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\faxapi\param.cpp ===
/* CFaxApiFunctionParameterInfo class implementation file. */

#include "StdAfx.h"
#include "param.h"

extern "C" {
#include "winfax.h"
}
//#include "winfax.h"



/*
 *  CFaxApiFunctionParameterInfo
 *
 *  Purpose: 
 *          This function constructs a CFaxApiFunctionParameterInfo object.
 *
 *  Arguments:
 *          None
 *
 *  Returns:
 *          None
 *
 */

CFaxApiFunctionParameterInfo::CFaxApiFunctionParameterInfo()
{
   m_cpaParameterValue.RemoveAll();
   
   m_cpaParameterRange1.RemoveAll();
   
   m_cpaParameterRange2.RemoveAll();

   m_xNumberOfParameters = 0;
}



/*
 *  ~CFaxApiFunctionParameterInfo
 *
 *  Purpose: 
 *          This function destroys a CFaxApiFunctionParameterInfo object.
 *
 *  Arguments:
 *          None
 *
 *  Returns:
 *          None
 *
 */

CFaxApiFunctionParameterInfo::~CFaxApiFunctionParameterInfo()
{
   int   xNumberOfElements;
   int   xItemIndex;
   
   xNumberOfElements = m_cpaParameterValue.GetSize();
   
   if ( xNumberOfElements > 0 )
   {
      for ( xItemIndex = 0; xItemIndex < xNumberOfElements; xItemIndex++ )
      {
         if ( m_cpaParameterValue[xItemIndex] != (void *) NULL )
         {
            delete m_cpaParameterValue[xItemIndex];
         }
      }
   }
   
   xNumberOfElements = m_cpaParameterRange1.GetSize();
   
   if ( xNumberOfElements > 0 )
   {
      for ( xItemIndex = 0; xItemIndex < xNumberOfElements; xItemIndex++ )
      {
         if ( m_cpaParameterRange1[xItemIndex] != (void *) NULL )
         {
            delete m_cpaParameterRange1[xItemIndex];
         }
      }
   }
   
   xNumberOfElements = m_cpaParameterRange2.GetSize();
   
   if ( xNumberOfElements > 0 )
   {
      for ( xItemIndex = 0; xItemIndex < xNumberOfElements; xItemIndex++ )
      {
         if ( m_cpaParameterRange2[xItemIndex] != (void *) NULL )
         {
            delete m_cpaParameterRange2[xItemIndex];
         }
      }
   }
}



/*
 *  InitParameterInfoMember
 *
 *  Purpose: 
 *          This function constructs a CFaxApiFunctionParameterInfo object.
 *
 *  Arguments:
 *          rcsFunctionName - a reference to a CString tha contains the
 *                            name of a Fax API function.
 *
 *  Returns:
 *          None
 *
 */

void CFaxApiFunctionParameterInfo::InitParameterInfoMember( const CString & rcsFunctionName )
{
   m_cpaParameterValue.RemoveAll();
   
   m_cpaParameterRange1.RemoveAll();
   
   m_cpaParameterRange2.RemoveAll();

   /* Get the number of parameters from the initialization file. */

   int      xNumberOfParameters;

   xNumberOfParameters = (int) GetPrivateProfileInt(
                                            (LPCTSTR) rcsFunctionName,
                                            (LPCTSTR) TEXT("NumberOfParameters"),
                                            -1,       // default return value
                                            (LPCTSTR) TEXT(".\\faxapi.ini") );

   if ( xNumberOfParameters > 0 )
   {
      m_xNumberOfParameters = xNumberOfParameters;

      /* Initialize the sizes of the CStringArray data members. */

      m_csaParameterName.SetSize( m_xNumberOfParameters );
      m_csaParameterDescription.SetSize( m_xNumberOfParameters );

      /* Initialize the size of the CUIntArray data member. */

      m_cuiaParameterTypeEnum.SetSize( m_xNumberOfParameters );

      /* Initialize the sizes of the CPtrArray data members. */

      m_cpaParameterValue.SetSize( m_xNumberOfParameters );
      m_cpaParameterRange1.SetSize( m_xNumberOfParameters );
      m_cpaParameterRange2.SetSize( m_xNumberOfParameters );

      /************************************************************************/
      /* Read the parameter names, types, and descriptions from the ini file. */
      /************************************************************************/

      CString  csParameterName;
      CString  csParameterType;
      CString  csParameterDescription;

      eParamType  eParameterType;

      CString  csKeyName;

      int      xParameterIndex;

      DWORD    dwGPPSrv;                  // returned by GetPrivateProfileString

      TCHAR    tszProfileString[MAX_PARAM_VALUE_STRING_LENGTH];     // arbitrarily set size

      DWORD    dwErrorCode;

      for ( xParameterIndex = 0; xParameterIndex < xNumberOfParameters; xParameterIndex++ )
      {
         /* Make the key for the parameter name. */

         csKeyName.Format( TEXT("ParameterName%d"), xParameterIndex );

         /* Read the parameter name. */

         dwGPPSrv = GetPrivateProfileString( (LPCTSTR) rcsFunctionName,
                                             (LPCTSTR) csKeyName,
                                             (LPCTSTR) TEXT("NULL"),
                                             (LPTSTR) tszProfileString,
                                             (DWORD) sizeof( tszProfileString ),
                                             (LPCTSTR) TEXT(".\\faxapi.ini") );

         /* Did GetPrivateProfileString return the string "NULL" ? */

         if ( _wcsicmp( tszProfileString, TEXT("NULL") ) != 0 )
         {
            /* Did GetPrivateProfileString read an entry ? */

            if ( dwGPPSrv > (DWORD) 0L )
            {
               csParameterName = (CString) tszProfileString;

               try
               {
                  m_csaParameterName.SetAt( xParameterIndex, csParameterName );
               }

               catch ( ... )
               {
                  dwErrorCode = GetLastError();

                  if ( dwErrorCode == (DWORD) NO_ERROR )
                  {
                     dwErrorCode = (DWORD) ERROR_NOT_ENOUGH_MEMORY;
                  }
               }
            }
         }

         /* Make the key for the parameter type. */

         csKeyName.Format( TEXT("ParameterType%d"), xParameterIndex );

         /* Read the parameter name. */

         dwGPPSrv = GetPrivateProfileString( (LPCTSTR) rcsFunctionName,
                                             (LPCTSTR) csKeyName,
                                             (LPCTSTR) TEXT("NULL"),
                                             (LPTSTR) tszProfileString,
                                             (DWORD) sizeof( tszProfileString ),
                                             (LPCTSTR) TEXT(".\\faxapi.ini") );

         /* Did GetPrivateProfileString return the string "NULL" ? */

         if ( _wcsicmp( tszProfileString, TEXT("NULL") ) != 0 )
         {
            /* Did GetPrivateProfileString read an entry ? */

            if ( dwGPPSrv > (DWORD) 0L )
            {
               csParameterType = (CString) tszProfileString;

               eParameterType = GetParameterTypeEnum( (CString &) csParameterType );

               try
               {
                  m_cuiaParameterTypeEnum.SetAt( xParameterIndex, (UINT) eParameterType );
               }

               catch ( ... )
               {
                  dwErrorCode = GetLastError();

                  if ( dwErrorCode == (DWORD) NO_ERROR )
                  {
                     dwErrorCode = (DWORD) ERROR_NOT_ENOUGH_MEMORY;
                  }
               }

               // Terminate the for loop on error ?

               /* Allocate Storage for the parameter value. */

               m_cpaParameterValue[xParameterIndex] =
                     AllocateStorageForParameterEntity( eParameterType );
            }
         }

         /* Make the key for the parameter description. */

         csKeyName.Format( TEXT("ParameterDescr%d"), xParameterIndex );

         /* Read the parameter name. */

         dwGPPSrv = GetPrivateProfileString( (LPCTSTR) rcsFunctionName,
                                             (LPCTSTR) csKeyName,
                                             (LPCTSTR) TEXT("NULL"),
                                             (LPTSTR) tszProfileString,
                                             (DWORD) sizeof( tszProfileString ),
                                             (LPCTSTR) TEXT(".\\faxapi.ini") );

         /* Did GetPrivateProfileString return the string "NULL" ? */

         if ( _wcsicmp( tszProfileString, TEXT("NULL") ) != 0 )
         {
            /* Did GetPrivateProfileString read an entry ? */

            if ( dwGPPSrv > (DWORD) 0L )
            {
               csParameterDescription = (CString) tszProfileString;

               try
               {
                  m_csaParameterDescription.SetAt( xParameterIndex, csParameterDescription );
               }

               catch ( ... )
               {
                  dwErrorCode = GetLastError();

                  if ( dwErrorCode == (DWORD) NO_ERROR )
                  {
                     dwErrorCode = (DWORD) ERROR_NOT_ENOUGH_MEMORY;
                  }
               }
            }
         }

         // Will need to handle the parameter range(s) later !

      }     // end of for loop
   }
   else
   {
      m_xNumberOfParameters = 0;
   }
}



/*
 *  AllocateStorageForParameterEntity
 *
 *  Purpose: 
 *          This function allocates (via the new operator) storage for either
 *          a parameter value or range entity.
 *
 *  Arguments:
 *          eParameterType - indicates the type of the parameter
 *
 *  Returns:
 *          a pointer to the storage that was allocated.
 *
 */

void * CFaxApiFunctionParameterInfo::AllocateStorageForParameterEntity( eParamType eParameterType )
{
   void *   pvParameterStorage;

   CString  csMessage;

   /* As of 6/11/97, there are 22 types of parameters. */

   switch ( eParameterType )
   {
      case eBOOL:

         /* The parameter type is BOOL. */
   
         pvParameterStorage = (void *) new BOOL;
   
         *((BOOL *) pvParameterStorage) = (BOOL) FALSE;

         break;

      case eDWORD:

         /* The parameter type is DWORD. */
   
         pvParameterStorage = (void *) new DWORD;
   
         *((DWORD *) pvParameterStorage) = (DWORD) 0L;

         break;

      case eHANDLE:

         /* The parameter type is HANDLE. */
   
         pvParameterStorage = (void *) new HANDLE;
   
         *((HANDLE *) pvParameterStorage) = (HANDLE) INVALID_HANDLE_VALUE;

         break;

      case eHDC:

         /* The parameter type is HDC. */
   
         pvParameterStorage = (void *) new HDC;
   
         *((HDC *) pvParameterStorage) = (HDC) INVALID_HANDLE_VALUE;

         break;

      case ePHDC:

         /* The parameter type is HDC *. */
   
         pvParameterStorage = (void *) new HDC *;
   
         *((HDC * *) pvParameterStorage) = (HDC *) NULL;

         break;

      case eLPBYTE:

         /* The parameter type is LPBYTE. */
   
         pvParameterStorage = (void *) new LPBYTE;
   
         *((LPBYTE *) pvParameterStorage) = (LPBYTE) NULL;

         break;

      case ePLPBYTE:

         /* The parameter type is LPBYTE *. */
   
         pvParameterStorage = (void *) new LPBYTE *;
   
         *((LPBYTE * *) pvParameterStorage) = (LPBYTE *) NULL;

         break;

      case eLPDWORD:

         /* The parameter type is LPDWORD. */
   
         pvParameterStorage = (void *) new LPDWORD;
   
         *((LPDWORD *) pvParameterStorage) = (LPDWORD) NULL;

         break;

      case eLPHANDLE:

         /* The parameter type is LPHANDLE. */

         pvParameterStorage = (void *) new LPHANDLE;

         *((LPHANDLE *) pvParameterStorage) = (LPHANDLE) NULL;

         break;

      case eLPSTR:

         /* The parameter type is LPSTR. */
   
         pvParameterStorage = (void *) new char[MAX_PARAM_VALUE_STRING_LENGTH];    // arbitrary size !
   
         /* Intialize it to an empty string. */
   
         *((char *) pvParameterStorage) = (char) '\0';

         break;

      case eLPVOID:

         /* The parameter type is LPVOID. */
   
         pvParameterStorage = (void *) new LPVOID;
   
         *((LPVOID *) pvParameterStorage) = (LPVOID) NULL;

         break;

      case eLPWSTR:

         /* The parameter type is LPWSTR. */
   
         pvParameterStorage = (void *) new wchar_t[MAX_PARAM_VALUE_STRING_LENGTH]; // arbitrary size
   
         /* Initialize it to an empty string. */
   
         *((wchar_t *) pvParameterStorage) = (wchar_t) L'\0';

         break;

      case ePFAX_CONFIGURATIONA:

         /* The parameter type is PFAX_CONFIGURATIONA. */
   
         pvParameterStorage = (void *) new PFAX_CONFIGURATIONA;
   
         *((PFAX_CONFIGURATIONA *) pvParameterStorage) = (PFAX_CONFIGURATIONA) NULL;

         break;

      case ePPFAX_CONFIGURATIONA:

         /* The parameter type is PFAX_CONFIGURATIONA *. */
   
         pvParameterStorage = (void *) new PFAX_CONFIGURATIONA *;
   
         *((PFAX_CONFIGURATIONA * *) pvParameterStorage) = (PFAX_CONFIGURATIONA *) NULL;

         break;

      case ePFAX_CONFIGURATIONW:

         /* The parameter type is PFAX_CONFIGURATIONW. */
   
         pvParameterStorage = (void *) new PFAX_CONFIGURATIONW;
   
         *((PFAX_CONFIGURATIONW *) pvParameterStorage) = (PFAX_CONFIGURATIONW) NULL;

         break;

      case ePPFAX_CONFIGURATIONW:

         /* The parameter type is PFAX_CONFIGURATIONW *. */
   
         pvParameterStorage = (void *) new PFAX_CONFIGURATIONW *;
   
         *((PFAX_CONFIGURATIONW * *) pvParameterStorage) = (PFAX_CONFIGURATIONW *) NULL;

         break;

      case ePFAX_COVERPAGE_INFOA:

         /* The parameter type is PFAX_COVERPAGE_INFOA. */
   
         pvParameterStorage = (void *) new PFAX_COVERPAGE_INFOA;
   
         *((PFAX_COVERPAGE_INFOA *) pvParameterStorage) = (PFAX_COVERPAGE_INFOA) NULL;

         break;

      case ePFAX_COVERPAGE_INFOW:

         /* The parameter type is PFAX_COVERPAGE_INFOW. */
   
         pvParameterStorage = (void *) new PFAX_COVERPAGE_INFOW;
   
         *((PFAX_COVERPAGE_INFOW *) pvParameterStorage) = (PFAX_COVERPAGE_INFOW) NULL;

         break;

      case ePPFAX_DEVICE_STATUSA:

         /* The parameter type is PFAX_DEVICE_STATUSA *. */

         pvParameterStorage = (void *) new PFAX_DEVICE_STATUSA *;

         *((PFAX_DEVICE_STATUSA * *) pvParameterStorage) = (PFAX_DEVICE_STATUSA *) NULL;

         break;

      case ePPFAX_DEVICE_STATUSW:

         /* The parameter type is PFAX_DEVICE_STATUSW *. */

         pvParameterStorage = (void *) new PFAX_DEVICE_STATUSW *;

         *((PFAX_DEVICE_STATUSW * *) pvParameterStorage) = (PFAX_DEVICE_STATUSW *) NULL;

         break;

      case ePFAX_JOB_ENTRYA:

         /* The parameter type is PFAX_JOB_ENTRYA. */

         pvParameterStorage = (void *) new PFAX_JOB_ENTRYA;

         *((PFAX_JOB_ENTRYA *) pvParameterStorage) = (PFAX_JOB_ENTRYA) NULL;

         break;

      case ePPFAX_JOB_ENTRYA:

         /* The parameter type is PFAX_JOB_ENTRYA *. */

         pvParameterStorage = (void *) new PFAX_JOB_ENTRYA *;

         *((PFAX_JOB_ENTRYA * *) pvParameterStorage) = (PFAX_JOB_ENTRYA *) NULL;

         break;

      case ePFAX_JOB_ENTRYW:

         /* The parameter type is PFAX_JOB_ENTRYW. */

         pvParameterStorage = (void *) new PFAX_JOB_ENTRYW;

         *((PFAX_JOB_ENTRYW *) pvParameterStorage) = (PFAX_JOB_ENTRYW) NULL;

         break;

      case ePPFAX_JOB_ENTRYW:

         /* The parameter type is PFAX_JOB_ENTRYW *. */

         pvParameterStorage = (void *) new PFAX_JOB_ENTRYW *;

         *((PFAX_JOB_ENTRYW * *) pvParameterStorage) = (PFAX_JOB_ENTRYW *) NULL;

         break;

      case ePFAX_JOB_PARAMA:

         /* The parameter type is PFAX_JOB_PARAMA. */
   
         pvParameterStorage = (void *) new PFAX_JOB_PARAMA;
   
         *((PFAX_JOB_PARAMA *) pvParameterStorage) = (PFAX_JOB_PARAMA) NULL;

         break;

      case ePFAX_JOB_PARAMW:

         /* The parameter type is PFAX_JOB_PARAMW. */
   
         pvParameterStorage = (void *) new PFAX_JOB_PARAMW;
   
         *((PFAX_JOB_PARAMW *) pvParameterStorage) = (PFAX_JOB_PARAMW) NULL;

         break;

      case ePFAX_LOG_CATEGORY:

         /* The parameter type is PFAX_LOG_CATEGORY. */

         pvParameterStorage = (void *) new PFAX_LOG_CATEGORY;

         *((PFAX_LOG_CATEGORY *) pvParameterStorage) = (PFAX_LOG_CATEGORY) NULL;

         break;

      case ePPFAX_LOG_CATEGORY:

         /* The parameter type is PFAX_LOG_CATEGORY *. */

         pvParameterStorage = (void *) new PFAX_LOG_CATEGORY *;

         *((PFAX_LOG_CATEGORY * *) pvParameterStorage) = (PFAX_LOG_CATEGORY *) NULL;

         break;

      case ePFAX_PORT_INFOA:

         /* The parameter type is PFAX_PORT_INFOA. */

         pvParameterStorage = (void *) new PFAX_PORT_INFOA;

         *((PFAX_PORT_INFOA *) pvParameterStorage) = (PFAX_PORT_INFOA) NULL;

         break;

      case ePPFAX_PORT_INFOA:

         /* The parameter type is PFAX_PORT_INFOA *. */

         pvParameterStorage = (void *) new PFAX_PORT_INFOA *;

         *((PFAX_PORT_INFOA * *) pvParameterStorage) = (PFAX_PORT_INFOA *) NULL;

         break;

      case ePFAX_PORT_INFOW:

         /* The parameter type is PFAX_PORT_INFOW. */

         pvParameterStorage = (void *) new PFAX_PORT_INFOW;

         *((PFAX_PORT_INFOW *) pvParameterStorage) = (PFAX_PORT_INFOW) NULL;

         break;

      case ePPFAX_PORT_INFOW:

         /* The parameter type is PFAX_PORT_INFOW *. */

         pvParameterStorage = (void *) new PFAX_PORT_INFOW *;

         *((PFAX_PORT_INFOW * *) pvParameterStorage) = (PFAX_PORT_INFOW *) NULL;

         break;

      case ePFAX_PRINT_INFOA:

         /* The parameter type is PFAX_PRINT_INFOA. */
   
         pvParameterStorage = (void *) new PFAX_PRINT_INFOA;
   
         *((PFAX_PRINT_INFOA *) pvParameterStorage) = (PFAX_PRINT_INFOA) NULL;

         break;

      case ePFAX_PRINT_INFOW:

         /* The parameter type is PFAX_PRINT_INFOW. */
   
         pvParameterStorage = (void *) new PFAX_PRINT_INFOW;
   
         *((PFAX_PRINT_INFOW *) pvParameterStorage) = (PFAX_PRINT_INFOW) NULL;

         break;

      case ePPFAX_ROUTING_METHODA:

         /* The parameter type is PFAX_ROUTING_METHODA *. */

         pvParameterStorage = (void *) new PFAX_ROUTING_METHODA *;

         *((PFAX_ROUTING_METHODA * *) pvParameterStorage) = (PFAX_ROUTING_METHODA *) NULL;

         break;

      case ePPFAX_ROUTING_METHODW:

         /* The parameter type is PFAX_ROUTING_METHODW *. */

         pvParameterStorage = (void *) new PFAX_ROUTING_METHODW *;

         *((PFAX_ROUTING_METHODW * *) pvParameterStorage) = (PFAX_ROUTING_METHODW *) NULL;

         break;

      default:

         /* The parameter type was not one of the cases above. */

         csMessage.Format( TEXT("Unrecognized type in AllocateStorageForParameterEntity") );

         AfxMessageBox( csMessage );

         pvParameterStorage = (void *) NULL;
   }

   return ( pvParameterStorage );
}



/*
 *  GetNumberOfParameters
 *
 *  Purpose: 
 *          This function retrieves the m_xNumberOfParameters member of the
 *          CFaxApiFunctionParameterInfo object.
 *
 *  Arguments:
 *          None
 *
 *  Returns:
 *          The number of parameters
 *
 */

int CFaxApiFunctionParameterInfo::GetNumberOfParameters()
{
   return ( m_xNumberOfParameters );
}



 /*
  *  GetParameterName
  *
  *  Purpose: 
  *          This function retrieves the Name of a parameter from the
  *          CFaxApiFunctionParameterInfo object.
  *
  *  Arguments:
  *          xParameterIndex - the index to the parameter
  *
  *  Returns:
  *          A CString that contains the parameter name.
  *
  */
 
CString CFaxApiFunctionParameterInfo::GetParameterName( int xParameterIndex )
{
   return ( (CString) m_csaParameterName.GetAt( xParameterIndex ) );
}



/*
 *  GetParameterValuePointer
 *
 *  Purpose: 
 *          This function retrieves the pointer to the storage for the
 *          parameter value.
 *
 *  Arguments:
 *          xParameterIndex = the index into the CPtrArray object to the
 *                            element that points to the parameter value.
 *
 *  Returns:
 *          a pointer to the storage for the parameter value.
 *
 */

void * CFaxApiFunctionParameterInfo::GetParameterValuePointer( int xParameterIndex )
{
   void *   pvParameterValue;

   pvParameterValue = m_cpaParameterValue[xParameterIndex];

   return ( pvParameterValue );
}



/*
 *  FormatParameterValueForOutput
 *
 *  Purpose: 
 *          This function prepares a CString representation of the parameter
 *          value whose index is xParameterIndex.
 *
 *  Arguments:
 *          xParameterIndex = the index to the parameter value to be output.
 *          rcsParameterValue - a reference to the CString to receive the string
 *                              representation of the parameter value.
 *
 *  Returns:
 *          None
 *
 */

void CFaxApiFunctionParameterInfo::FormatParameterValueForOutput( int xParameterIndex, CString & rcsParameterValue )
{
   /* Get the parameter type. */

   eParamType  eParameterType;

   eParameterType = GetParameterTypeEnum( xParameterIndex );

   /* Get a pointer to the storage for the parameter. */

   void *   pvParameterValue;

   pvParameterValue = GetParameterValuePointer( xParameterIndex );

   /* As of 6/11/97, there are 22 types of parameters. */

   switch ( eParameterType )
   {
      case eBOOL:
         {
            /* The parameter type is BOOL. */

            if ( (BOOL) *((BOOL *) pvParameterValue) == (BOOL) FALSE )
            {
               rcsParameterValue = (CString) TEXT("FALSE");
            }
            else
            {
               rcsParameterValue = (CString) TEXT("TRUE");
            }
         }

         break;

      case eDWORD:
         {
            /* The parameter type is DWORD. */
      
            rcsParameterValue.Format( TEXT("0x%x"),
                                      (DWORD) *((DWORD *) pvParameterValue) );
         }

         break;

      case eHANDLE:
         {
            /* The parameter type is HANDLE. */
      
            rcsParameterValue.Format( TEXT("0x%x"),
                                      (HANDLE) *((HANDLE *) pvParameterValue) );
         }

         break;

      case eHDC:
         {
            /* The parameter type is HDC. */
      
            rcsParameterValue.Format( TEXT("0x%x"),
                                      (HDC) *((HDC *) pvParameterValue) );
         }

         break;

      case ePHDC:
         {
            /* The parameter type is HDC *. */
      
            rcsParameterValue.Format( TEXT("0x%x"), (HDC *) *((HDC * *) pvParameterValue) );
         }

         break;

      case eLPBYTE:
         {
            /* The parameter type is LPBYTE. */
      
            rcsParameterValue.Format( TEXT("0x%x"), (LPBYTE) *((LPBYTE) pvParameterValue) );
         }

         break;

      case ePLPBYTE:
         {
            /* The parameter type is LPBYTE *. */
      
            rcsParameterValue.Format( TEXT("0x%x"),
                                      (LPBYTE *)
                                      *((LPBYTE * *) pvParameterValue) );
         }

         break;

      case eLPDWORD:
         {
            /* The parameter type is LPDWORD. */
      
            rcsParameterValue.Format( TEXT("0x%x"),
                                      (LPDWORD)
                                      *((LPDWORD *) pvParameterValue) );
         }

         break;

      case eLPHANDLE:
         {
            /* The parameter type is LPHANDLE. */

            rcsParameterValue.Format( TEXT("0x%x"),
                                      (LPHANDLE)
                                      *((LPHANDLE *) pvParameterValue) );
         }

         break;

      case eLPSTR:
         {
            /* The parameter type is LPSTR. */
      
            LPSTR pszParameterValue;
      
            pszParameterValue = (LPSTR) pvParameterValue;
      
            /* Convert the ANSI string to UNICODE. */
      
            size_t   t_AnsiStringLength;
      
            t_AnsiStringLength = strlen( pszParameterValue );
      
            LPWSTR   pwszParameterValue;
      
            pwszParameterValue = new wchar_t[t_AnsiStringLength+1];  // reserve space for the terminator
      
            if ( pwszParameterValue != (LPWSTR) NULL )
            {
               int   xNumberOfCharsConverted;
      
               xNumberOfCharsConverted = mbstowcs( pwszParameterValue,
                                                   pszParameterValue,
                                                   t_AnsiStringLength );
         
               /* Terminate the wide character string. */
      
               pwszParameterValue[xNumberOfCharsConverted] = (wchar_t) L'\0';
      
               rcsParameterValue.Format( TEXT("%s"), (LPTSTR) pwszParameterValue );
      
               delete pwszParameterValue;
            }
         }

         break;

      case eLPVOID:
         {
            /* The parameter type is LPVOID. */
      
            rcsParameterValue.Format( TEXT("0x%x"),
                                      (LPVOID) *((LPVOID *) pvParameterValue) );
         }

         break;

      case eLPWSTR:
         {
            /* The parameter type is LPWSTR. */
      
            rcsParameterValue.Format( TEXT("%s"),
                                      (LPTSTR) (LPWSTR) pvParameterValue );
         }

         break;

      case ePFAX_CONFIGURATIONA:
         {
            /* The parameter type is PFAX_CONFIGURATIONA. */
      
            rcsParameterValue.Format( TEXT("0x%x"),
                                      (PFAX_CONFIGURATIONA)
                                      *((PFAX_CONFIGURATIONA *) pvParameterValue) );
         }

         break;

      case ePPFAX_CONFIGURATIONA:
         {
            /* The parameter type is PFAX_CONFIGURATIONA *. */
      
            rcsParameterValue.Format( TEXT("0x%x"),
                                      (PFAX_CONFIGURATIONA *)
                                      *((PFAX_CONFIGURATIONA * *) pvParameterValue) );
         }

         break;

      case ePFAX_CONFIGURATIONW:
         {
            /* The parameter type is PFAX_CONFIGURATIONW. */
      
            rcsParameterValue.Format( TEXT("0x%x"),
                                      (PFAX_CONFIGURATIONW) 
                                      *((PFAX_CONFIGURATIONW *) pvParameterValue) );
         }

         break;

      case ePPFAX_CONFIGURATIONW:
         {
            /* The parameter type is PFAX_CONFIGURATIONW *. */
      
            rcsParameterValue.Format( TEXT("0x%x"),
                                      (PFAX_CONFIGURATIONW *)
                                      *((PFAX_CONFIGURATIONW * *) pvParameterValue) );
         }

         break;

      case ePFAX_COVERPAGE_INFOA:
         {
            /* The parameter type is PFAX_COVERPAGE_INFOA. */
      
            rcsParameterValue.Format( TEXT("0x%x"),
                                      (PFAX_COVERPAGE_INFOA)
                                      *((PFAX_COVERPAGE_INFOA *) pvParameterValue) );
         }

         break;

      case ePFAX_COVERPAGE_INFOW:
         {
            /* The parameter type is PFAX_COVERPAGE_INFOW. */
      
            rcsParameterValue.Format( TEXT("0x%x"),
                                      (PFAX_COVERPAGE_INFOW)
                                      *((PFAX_COVERPAGE_INFOW *) pvParameterValue) );
         }

         break;

      case ePPFAX_DEVICE_STATUSA:
         {
            /* The parameter type is PFAX_DEVICE_STATUSA *. */

            rcsParameterValue.Format( TEXT("0x%x"),
                                      (PFAX_DEVICE_STATUSA *)
                                      *((PFAX_DEVICE_STATUSA * *) pvParameterValue) );
         }

         break;

      case ePPFAX_DEVICE_STATUSW:
         {
            /* The parameter type is PFAX_DEVICE_STATUSW *. */

            rcsParameterValue.Format( TEXT("0x%x"),
                                      (PFAX_DEVICE_STATUSW *)
                                      *((PFAX_DEVICE_STATUSW * *) pvParameterValue) );
         }

         break;

      case ePFAX_JOB_ENTRYA:
         {
            /* The parameter type is PFAX_JOB_ENTRYA. */
      
            rcsParameterValue.Format( TEXT("0x%x"),
                                      (PFAX_JOB_ENTRYA)
                                      *((PFAX_JOB_ENTRYA *) pvParameterValue) );
         }

         break;

      case ePPFAX_JOB_ENTRYA:
         {
            /* The parameter type is PFAX_JOB_ENTRYA *. */

            rcsParameterValue.Format( TEXT("0x%x"),
                                      (PFAX_JOB_ENTRYA *)
                                      *((PFAX_JOB_ENTRYA * *) pvParameterValue) );
         }

         break;

      case ePFAX_JOB_ENTRYW:
         {
            /* The parameter type is PFAX_JOB_ENTRYW. */
      
            rcsParameterValue.Format( TEXT("0x%x"),
                                      (PFAX_JOB_ENTRYW)
                                      *((PFAX_JOB_ENTRYW *) pvParameterValue) );
         }

         break;

      case ePPFAX_JOB_ENTRYW:
         {
            /* The parameter type is PFAX_JOB_ENTRYW *. */

            rcsParameterValue.Format( TEXT("0x%x"),
                                      (PFAX_JOB_ENTRYW *)
                                      *((PFAX_JOB_ENTRYW * *) pvParameterValue) );
         }

         break;

      case ePFAX_JOB_PARAMA:
         {
            /* The parameter type is PFAX_JOB_PARAMA. */
      
            rcsParameterValue.Format( TEXT("0x%x"),
                                      (PFAX_JOB_PARAMA)
                                      *((PFAX_JOB_PARAMA *) pvParameterValue) );
         }

         break;

      case ePFAX_JOB_PARAMW:
         {
            /* The parameter type is PFAX_JOB_PARAMW. */
      
            rcsParameterValue.Format( TEXT("0x%x"),
                                      (PFAX_JOB_PARAMW)
                                      *((PFAX_JOB_PARAMW *) pvParameterValue) );
         }

         break;

      case ePFAX_LOG_CATEGORY:
         {
            /* The parameter type is PFAX_LOG_CATEGORY. */
      
            rcsParameterValue.Format( TEXT("0x%x"),
                                      (PFAX_LOG_CATEGORY)
                                      *((PFAX_LOG_CATEGORY *) pvParameterValue) );
         }

         break;

      case ePPFAX_LOG_CATEGORY:
         {
            /* The parameter type is PFAX_LOG_CATEGORY *. */

            rcsParameterValue.Format( TEXT("0x%x"),
                                      (PFAX_LOG_CATEGORY *)
                                      *((PFAX_LOG_CATEGORY * *) pvParameterValue) );
         }

         break;

      case ePFAX_PORT_INFOA:
         {
            /* The parameter type is PFAX_PORT_INFOA. */
      
            rcsParameterValue.Format( TEXT("0x%x"),
                                      (PFAX_PORT_INFOA)
                                      *((PFAX_PORT_INFOA *) pvParameterValue) );
         }

         break;

      case ePPFAX_PORT_INFOA:
         {
            /* The parameter type is PFAX_PORT_INFOA *. */

            rcsParameterValue.Format( TEXT("0x%x"),
                                      (PFAX_PORT_INFOA *)
                                      *((PFAX_PORT_INFOA * *) pvParameterValue) );
         }

         break;

      case ePFAX_PORT_INFOW:
         {
            /* The parameter type is PFAX_PORT_INFOW. */
      
            rcsParameterValue.Format( TEXT("0x%x"),
                                      (PFAX_PORT_INFOW)
                                      *((PFAX_PORT_INFOW *) pvParameterValue) );
         }

         break;

      case ePPFAX_PORT_INFOW:
         {
            /* The parameter type is PFAX_PORT_INFOW *. */

            rcsParameterValue.Format( TEXT("0x%x"),
                                      (PFAX_PORT_INFOW *)
                                      *((PFAX_PORT_INFOW * *) pvParameterValue) );
         }

         break;

      case ePFAX_PRINT_INFOA:
         {
            /* The parameter type is PFAX_PRINT_INFOA. */
      
            rcsParameterValue.Format( TEXT("0x%x"),
                                      (PFAX_PRINT_INFOA)
                                      *((PFAX_PRINT_INFOA *) pvParameterValue) );
         }

         break;

      case ePFAX_PRINT_INFOW:
         {
            /* The parameter type is PFAX_PRINT_INFOW. */
      
            rcsParameterValue.Format( TEXT("0x%x"),
                                      (PFAX_PRINT_INFOW)
                                      *((PFAX_PRINT_INFOW *) pvParameterValue) );
         }

         break;

      case ePPFAX_ROUTING_METHODA:
         {
            /* The parameter type is PFAX_ROUTING_METHODA *. */

            rcsParameterValue.Format( TEXT("0x%x"),
                                      (PFAX_ROUTING_METHODA *)
                                      *((PFAX_ROUTING_METHODA * *) pvParameterValue) );
         }

         break;

      case ePPFAX_ROUTING_METHODW:
         {
            /* The parameter type is PFAX_ROUTING_METHODW *. */

            rcsParameterValue.Format( TEXT("0x%x"),
                                      (PFAX_ROUTING_METHODW *)
                                      *((PFAX_ROUTING_METHODW * *) pvParameterValue) );
         }

         break;

      default:
         {
            /* The parameter type was not one of the cases above. */
         
            CString  csMessage;
         
            csMessage.Format( TEXT("Unrecognized type in FormatParameterValueForOutput") );
         
            AfxMessageBox( csMessage );
         
            rcsParameterValue.Empty();
         }
   }
}



/*
 *  GetParameterTypeString
 *
 *  Purpose: 
 *          This function retrieves the parameter type for the parameter whose
 *          index is xParameterIndex.
 *
 *  Arguments:
 *          xParameterIndex = the index into the CPtrArray to the pointer
 *                            to the CFaxApiFunctionParameterInfo object.
 *
 *  Returns:
 *          A CString that contains the parameter type.
 *
 */

CString CFaxApiFunctionParameterInfo::GetParameterTypeString( int xParameterIndex )
{
   CString  csParameterType;

   eParamType  eParameterType;

   eParameterType = (eParamType) m_cuiaParameterTypeEnum.GetAt( xParameterIndex );

   switch ( eParameterType )
   {
      case eBOOL:

         /* The parameter type is BOOL. */
   
         csParameterType = (CString) TEXT("BOOL");
   
         break;

      case eDWORD:

         /* The parameter type is DWORD. */
   
         csParameterType = (CString) TEXT("DWORD");
   
         break;

      case eHANDLE:

         /* The parameter type is HANDLE. */
   
         csParameterType = (CString) TEXT("HANDLE");
   
         break;

      case eHDC:

         /* The parameter type is HDC. */
   
         csParameterType = (CString) TEXT("HDC");
   
         break;

      case ePHDC:

         /* The parameter type is HDC *. */
   
         csParameterType = (CString) TEXT("HDC *");
   
         break;

      case eLPBYTE:

         /* The parameter type is LPBYTE. */
   
         csParameterType = (CString) TEXT("LPBYTE");
   
         break;

      case ePLPBYTE:

         /* The parameter type is LPBYTE *. */
   
         csParameterType = (CString) TEXT("LPBYTE *");
   
         break;

      case eLPDWORD:

         /* The parameter type is LPDWORD. */
   
         csParameterType = (CString) TEXT("LPDWORD");
   
         break;

      case eLPHANDLE:

         /* The parameter type is LPHANDLE. */

         csParameterType = (CString) TEXT("LPHANDLE");

         break;

      case eLPSTR:

         /* The parameter type is LPSTR. */
   
         csParameterType = (CString) TEXT("LPSTR");
   
         break;

      case eLPVOID:

         /* The parameter type is LPVOID. */
   
         csParameterType = (CString) TEXT("LPVOID");
   
         break;

      case eLPWSTR:

         /* The parameter type is LPWSTR. */
   
         csParameterType = (CString) TEXT("LPWSTR");
   
         break;

      case ePFAX_CONFIGURATIONA:

         /* The parameter type is PFAX_CONFIGURATIONA. */
   
         csParameterType = (CString) TEXT("PFAX_CONFIGURATIONA");
   
         break;

      case ePPFAX_CONFIGURATIONA:

         /* The parameter type is PFAX_CONFIGURATIONA *. */
   
         csParameterType = (CString) TEXT("PFAX_CONFIGURATIONA *");
   
         break;

      case ePFAX_CONFIGURATIONW:

         /* The parameter type is PFAX_CONFIGURATIONW. */
   
         csParameterType = (CString) TEXT("PFAX_CONFIGURATIONW");
   
         break;

      case ePPFAX_CONFIGURATIONW:

         /* The parameter type is PFAX_CONFIGURATIONW *. */
   
         csParameterType = (CString) TEXT("PFAX_CONFIGURATIONW *");
   
         break;

      case ePFAX_COVERPAGE_INFOA:

         /* The parameter type is PFAX_COVERPAGE_INFOA. */
   
         csParameterType = (CString) TEXT("PFAX_COVERPAGE_INFOA");
   
         break;

      case ePFAX_COVERPAGE_INFOW:

         /* The parameter type is PFAX_COVERPAGE_INFOW. */
   
         csParameterType = (CString) TEXT("PFAX_COVERPAGE_INFOW");
   
         break;

      case ePPFAX_DEVICE_STATUSA:

         /* The parameter type is PFAX_DEVICE_STATUSA *. */
   
         csParameterType = (CString) TEXT("PFAX_DEVICE_STATUSA *");
   
         break;

      case ePPFAX_DEVICE_STATUSW:

         /* The parameter type is PFAX_DEVICE_STATUSW *. */
   
         csParameterType = (CString) TEXT("PFAX_DEVICE_STATUSW *");
   
         break;

      case ePFAX_JOB_ENTRYA:

         /* The parameter type is PFAX_JOB_ENTRYA. */
   
         csParameterType = (CString) TEXT("PFAX_JOB_ENTRYA");
   
         break;

      case ePPFAX_JOB_ENTRYA:

         /* The parameter type is PFAX_JOB_ENTRYA *. */
   
         csParameterType = (CString) TEXT("PFAX_JOB_ENTRYA *");
   
         break;

      case ePFAX_JOB_ENTRYW:

         /* The parameter type is PFAX_JOB_ENTRYW. */
   
         csParameterType = (CString) TEXT("PFAX_JOB_ENTRYW");
   
         break;

      case ePPFAX_JOB_ENTRYW:

         /* The parameter type is PFAX_JOB_ENTRYW *. */
   
         csParameterType = (CString) TEXT("PFAX_JOB_ENTRYW *");
   
         break;

      case ePFAX_JOB_PARAMA:

         /* The parameter type is PFAX_JOB_PARAMA. */
   
         csParameterType = (CString) TEXT("PFAX_JOB_PARAMA");
   
         break;

      case ePFAX_JOB_PARAMW:

         /* The parameter type is PFAX_JOB_PARAMW. */
   
         csParameterType = (CString) TEXT("PFAX_JOB_PARAMW");
   
         break;

      case ePFAX_PORT_INFOA:

         /* The parameter type is PFAX_PORT_INFOA. */
   
         csParameterType = (CString) TEXT("PFAX_PORT_INFOA");
   
         break;

      case ePPFAX_PORT_INFOA:

         /* The parameter type is PFAX_PORT_INFOA *. */
   
         csParameterType = (CString) TEXT("PFAX_PORT_INFOA *");
   
         break;

      case ePFAX_PORT_INFOW:

         /* The parameter type is PFAX_PORT_INFOW. */
   
         csParameterType = (CString) TEXT("PFAX_PORT_INFOW");
   
         break;

      case ePPFAX_PORT_INFOW:

         /* The parameter type is PFAX_PORT_INFOW *. */
   
         csParameterType = (CString) TEXT("PFAX_PORT_INFOW *");
   
         break;

      case ePFAX_PRINT_INFOA:

         /* The parameter type is PFAX_PRINT_INFOA. */
   
         csParameterType = (CString) TEXT("PFAX_PRINT_INFOA");
   
         break;

      case ePFAX_PRINT_INFOW:

         /* The parameter type is PFAX_PRINT_INFOW. */
   
         csParameterType = (CString) TEXT("PFAX_PRINT_INFOW");
   
         break;

      case ePPFAX_ROUTING_METHODA:

         /* The parameter type is PFAX_ROUTING_METHODA *. */
   
         csParameterType = (CString) TEXT("PFAX_ROUTING_METHODA *");
   
         break;

      case ePPFAX_ROUTING_METHODW:

         /* The parameter type is PFAX_ROUTING_METHODW *. */
   
         csParameterType = (CString) TEXT("PFAX_ROUTING_METHODW *");
   
         break;

      default:

         csParameterType.Empty();

         break;
   }

   return ( csParameterType );
}



/*
 *  GetParameterTypeEnum
 *
 *  Purpose: 
 *          This function returns the eParamType value thet represents the
 *          data type of the parameter whose index is xParameterIndex.
 *
 *  Arguments:
 *          xParameterIndex = the index into the CPtrArray to the pointer
 *                            to the CFaxApiFunctionParameterInfo object.
 *
 *  Returns:
 *          The eParamType value that represents the data type of the parameter.
 *
 *  Note:
 *          GetParameterTypeEnum is overloaded to accept either a integer or
 *          a reference to a CString as a parameter.
 *
 */

eParamType CFaxApiFunctionParameterInfo::GetParameterTypeEnum( int xParameterIndex )
{
   return ( (eParamType) m_cuiaParameterTypeEnum.GetAt( xParameterIndex ) );
}



/*
 *  GetParameterTypeEnum
 *
 *  Purpose: 
 *          This function returns the eParamType value that represents the
 *          data type specified in rcsParameterType.
 *
 *  Arguments:
 *          rcsParameterType - a reference to a CString that contains the data
 *                             type of the parameter.
 *
 *  Returns:
 *          The eParamType value that represents the data type of the parameter.
 *
 *  Note:
 *          GetParameterTypeEnum is overloaded to accept either a integer or
 *          a reference to a CString as a parameter.
 *
 *          As much as I hate to use a "goto" statement in a structured language
 *          in this case I feel it is justified in order to avoid executing the
 *          comparisons that will fail.
 *
 */

eParamType CFaxApiFunctionParameterInfo::GetParameterTypeEnum( const CString & rcsParameterType )
{
   eParamType  eReturnValue;

   /* As of 6/11/97, there are 22 types of parameters. */

   /* Note: a "switch" statement cannot be used here because rcsParameterType */
   /*       is not an integral type and is an illegal switch expression.      */

   if ( rcsParameterType.Compare( TEXT("BOOL") ) == 0 )
   {
      /* Note: "BOOL" is typedefed, in windef.h, as type int. It is not the */
      /*       the same as the native data type "bool".                     */

      eReturnValue = eBOOL;

      goto ExitGetParameterTypeEnum;
   }

   if ( rcsParameterType.Compare( TEXT("DWORD") ) == 0 )
   {
      eReturnValue = eDWORD;

      goto ExitGetParameterTypeEnum;
   }

   if ( rcsParameterType.Compare( TEXT("HANDLE") ) == 0 )
   {
      eReturnValue = eHANDLE;

      goto ExitGetParameterTypeEnum;
   }

   if ( rcsParameterType.Compare( TEXT("HDC") ) == 0 )
   {
      eReturnValue = eHDC;

      goto ExitGetParameterTypeEnum;
   }

   if ( rcsParameterType.Compare( TEXT("HDC *") ) == 0 )
   {
      eReturnValue = ePHDC;

      goto ExitGetParameterTypeEnum;
   }

   if ( rcsParameterType.Compare( TEXT("LPBYTE") ) == 0 )
   {
      eReturnValue = eLPBYTE;

      goto ExitGetParameterTypeEnum;
   }

   if ( rcsParameterType.Compare( TEXT("LPBYTE *") ) == 0 )
   {
      eReturnValue = ePLPBYTE;

      goto ExitGetParameterTypeEnum;
   }

   if ( rcsParameterType.Compare( TEXT("LPDWORD") ) == 0 )
   {
      eReturnValue = eLPDWORD;

      goto ExitGetParameterTypeEnum;
   }

   if ( rcsParameterType.Compare( TEXT("LPHANDLE") ) == 0 )
   {
      eReturnValue = eLPHANDLE;

      goto ExitGetParameterTypeEnum;
   }

   if ( rcsParameterType.Compare( TEXT("LPSTR") ) == 0 )
   {
      eReturnValue = eLPSTR;

      goto ExitGetParameterTypeEnum;
   }

   if ( rcsParameterType.Compare( TEXT("LPVOID") ) == 0 )
   {
      eReturnValue = eLPVOID;

      goto ExitGetParameterTypeEnum;
   }

   if ( rcsParameterType.Compare( TEXT("LPWSTR") ) == 0 )
   {
      eReturnValue = eLPWSTR;

      goto ExitGetParameterTypeEnum;
   }

   if ( rcsParameterType.Compare( TEXT("PFAX_CONFIGURATIONA") ) == 0 )
   {
      eReturnValue = ePFAX_CONFIGURATIONA;

      goto ExitGetParameterTypeEnum;
   }

   if ( rcsParameterType.Compare( TEXT("PFAX_CONFIGURATIONA *") ) == 0 )
   {
      eReturnValue = ePPFAX_CONFIGURATIONA;

      goto ExitGetParameterTypeEnum;
   }

   if ( rcsParameterType.Compare( TEXT("PFAX_CONFIGURATIONW") ) == 0 )
   {
      eReturnValue = ePFAX_CONFIGURATIONW;

      goto ExitGetParameterTypeEnum;
   }

   if ( rcsParameterType.Compare( TEXT("PFAX_CONFIGURATIONW *") ) == 0 )
   {
      eReturnValue = ePPFAX_CONFIGURATIONW;

      goto ExitGetParameterTypeEnum;
   }

   if ( rcsParameterType.Compare( TEXT("PFAX_COVERPAGE_INFOA") ) == 0 )
   {
      eReturnValue = ePFAX_COVERPAGE_INFOA;

      goto ExitGetParameterTypeEnum;
   }
   
   if ( rcsParameterType.Compare( TEXT("PFAX_COVERPAGE_INFOW") ) == 0 )
   {
      eReturnValue = ePFAX_COVERPAGE_INFOW;

      goto ExitGetParameterTypeEnum;
   }

   if ( rcsParameterType.Compare( TEXT("PFAX_DEVICE_STATUSA *") ) == 0 )
   {
      eReturnValue = ePPFAX_DEVICE_STATUSA;

      goto ExitGetParameterTypeEnum;
   }

   if ( rcsParameterType.Compare( TEXT("PFAX_DEVICE_STATUSW *") ) == 0 )
   {
      eReturnValue = ePPFAX_DEVICE_STATUSW;

      goto ExitGetParameterTypeEnum;
   }

   if ( rcsParameterType.Compare( TEXT("PFAX_JOB_ENTRYA") ) == 0 )
   {
      eReturnValue = ePFAX_JOB_ENTRYA;

      goto ExitGetParameterTypeEnum;
   }

   if ( rcsParameterType.Compare( TEXT("PFAX_JOB_ENTRYA *") ) == 0 )
   {
      eReturnValue = ePPFAX_JOB_ENTRYA;

      goto ExitGetParameterTypeEnum;
   }

   if ( rcsParameterType.Compare( TEXT("PFAX_JOB_ENTRYW") ) == 0 )
   {
      eReturnValue = ePFAX_JOB_ENTRYW;

      goto ExitGetParameterTypeEnum;
   }

   if ( rcsParameterType.Compare( TEXT("PFAX_JOB_ENTRYW *") ) == 0 )
   {
      eReturnValue = ePPFAX_JOB_ENTRYW;

      goto ExitGetParameterTypeEnum;
   }

   if ( rcsParameterType.Compare( TEXT("PFAX_JOB_PARAMA") ) == 0 )
   {
      eReturnValue = ePFAX_JOB_PARAMA;

      goto ExitGetParameterTypeEnum;
   }

   if ( rcsParameterType.Compare( TEXT("PFAX_JOB_PARAMW") ) == 0 )
   {
      eReturnValue = ePFAX_JOB_PARAMW;

      goto ExitGetParameterTypeEnum;
   }

   if ( rcsParameterType.Compare( TEXT("PFAX_LOG_CATEGORY") ) == 0 )
   {
      eReturnValue = ePFAX_LOG_CATEGORY;

      goto ExitGetParameterTypeEnum;
   }

   if ( rcsParameterType.Compare( TEXT("PFAX_LOG_CATEGORY *") ) == 0 )
   {
      eReturnValue = ePPFAX_LOG_CATEGORY;

      goto ExitGetParameterTypeEnum;
   }

   if ( rcsParameterType.Compare( TEXT("PFAX_PORT_INFOA") ) == 0 )
   {
      eReturnValue = ePFAX_PORT_INFOA;

      goto ExitGetParameterTypeEnum;
   }

   if ( rcsParameterType.Compare( TEXT("PFAX_PORT_INFOA *") ) == 0 )
   {
      eReturnValue = ePPFAX_PORT_INFOA;

      goto ExitGetParameterTypeEnum;
   }

   if ( rcsParameterType.Compare( TEXT("PFAX_PORT_INFOW") ) == 0 )
   {
      eReturnValue = ePFAX_PORT_INFOW;

      goto ExitGetParameterTypeEnum;
   }

   if ( rcsParameterType.Compare( TEXT("PFAX_PORT_INFOW *") ) == 0 )
   {
      eReturnValue = ePPFAX_PORT_INFOW;

      goto ExitGetParameterTypeEnum;
   }

   if ( rcsParameterType.Compare( TEXT("PFAX_PRINT_INFOA") ) == 0 )
   {
      eReturnValue = ePFAX_PRINT_INFOA;

      goto ExitGetParameterTypeEnum;
   }

   if ( rcsParameterType.Compare( TEXT("PFAX_PRINT_INFOW") ) == 0 )
   {
      eReturnValue = ePFAX_PRINT_INFOW;

      goto ExitGetParameterTypeEnum;
   }

   if ( rcsParameterType.Compare( TEXT("PFAX_ROUTING_METHODA *") ) == 0 )
   {
      eReturnValue = ePPFAX_ROUTING_METHODA;

      goto ExitGetParameterTypeEnum;
   }

   if ( rcsParameterType.Compare( TEXT("PFAX_ROUTING_METHODW *") ) == 0 )
   {
      eReturnValue = ePPFAX_ROUTING_METHODW;

      goto ExitGetParameterTypeEnum;
   }
   else
   {
      eReturnValue = eUnknownParamType;    // the parameter type wasn't
                                          // in the list above !
   }

ExitGetParameterTypeEnum:

   return ( eReturnValue );
}



/*
 *  GetParameterDescription
 *
 *  Purpose: 
 *          This function retrieves the description for a parameter to a
 *          Fax API function.
 *
 *  Arguments:
 *          xParameterIndex = the index into the CPtrArray to the pointer
 *                            to the CFaxApiFunctionParameterInfo object.
 *
 *  Returns:
 *          A CString that contains the description of the parameter.
 *
 */

CString CFaxApiFunctionParameterInfo::GetParameterDescription( int xParameterIndex )
{
   return ( m_csaParameterDescription.GetAt( xParameterIndex ) );
}



/*
 *  StoreParameterValue
 *
 *  Purpose: 
 *          This function stores the value contained in a CSting in the storage
 *          location for the parameter value indexed by xParameterIndex.
 *
 *  Arguments:
 *          xParameterIndex - the index to the pointer to the storage for a
 *                            parameer value.
 *          rcsParameterValue - a reference to a CString that contains a
 *                              representation of the value to be stored.
 *
 *  Returns:
 *          TRUE - indicates success
 *          FALSE - indicates failure
 *
 */

BOOL CFaxApiFunctionParameterInfo::StoreParameterValue( int xParameterIndex, CString & rcsParameterValue )
{
   BOOL  fReturnValue = (BOOL) TRUE;

   CString  csParameterValue;

   /* Get the parameter type. */

   eParamType  eParameterType;

   eParameterType = GetParameterTypeEnum( xParameterIndex );

   if ( (eParameterType != eLPSTR) && (eParameterType != eLPWSTR) )
   {
      /* rcsParameterValue may begin with "0x", "0X", "x" or "X". */
      /* The first two will be scanned properly, but the second   */
      /* two will not. The following code segment eliminates the  */
      /* second two prefixes if they exist.                       */

      csParameterValue = PreProcessParameterValueString( (const CString &) rcsParameterValue );
   }
   else
   {
      csParameterValue = rcsParameterValue;
   }

   /* Get a pointer to the string representation of the parameter value. */

   LPTSTR   ptszParameterValue;

   ptszParameterValue = (LPTSTR) csParameterValue.GetBuffer( MAX_PARAM_VALUE_STRING_LENGTH );      // arbitrary size

   /* Get a pointer to the storage for the parameter. */

   void *   pvParameterValue;

   pvParameterValue = GetParameterValuePointer( xParameterIndex );

   /* As of 6/11/97, there are 22 types of parameters. */

   switch ( eParameterType )
   {
      case eBOOL:
         {
            /* The parameter type is BOOL. */

            BOOL     fParameterValue = (BOOL) FALSE;  // set default value

            if ( csParameterValue.CompareNoCase( TEXT("FALSE") ) == 0 )
            {
               *((BOOL *) pvParameterValue) = (BOOL) FALSE;
            }
            else
            {
               if ( csParameterValue.CompareNoCase( TEXT("TRUE") ) == 0 )
               {
                  *((BOOL *) pvParameterValue) = (BOOL) TRUE;
               }
               else
               {
                  swscanf( (const wchar_t *) ptszParameterValue,
                           (const wchar_t *) TEXT("%x"),
                           &fParameterValue );

                  *((BOOL *) pvParameterValue) = fParameterValue;
               }
            }
         }

         break;

      case eDWORD:
         {
            /* The parameter type is DWORD. */

            DWORD    dwParameterValue = (DWORD) 0L;   // set default value

            swscanf( (const wchar_t *) ptszParameterValue, (const wchar_t *) TEXT("%x"), &dwParameterValue );

            *((DWORD *) pvParameterValue) = (DWORD) dwParameterValue;
         }

         break;

      case eHANDLE:
         {
            /* The parameter type is HANDLE. */

            HANDLE      hParameterValue = (HANDLE) INVALID_HANDLE_VALUE;

            swscanf( (const wchar_t *) ptszParameterValue, (const wchar_t *) TEXT("%x"), &hParameterValue );

            *((HANDLE *) pvParameterValue) = hParameterValue;
         }

         break;

      case eHDC:
         {
            /* The parameter type is HDC. */

            HDC      hdcParameterValue = (HDC) INVALID_HANDLE_VALUE;

            swscanf( (const wchar_t *) ptszParameterValue, (const wchar_t *) TEXT("%x"), &hdcParameterValue );

            *((HDC *) pvParameterValue) = hdcParameterValue;
         }

         break;

      case ePHDC:
         {
            /* The parameter type is HDC *. */

            HDC *    phdcParameterValue = (HDC *) NULL;

            swscanf( (const wchar_t *) ptszParameterValue, (const wchar_t *) TEXT("%x"), &phdcParameterValue );

            *((HDC * *) pvParameterValue) = phdcParameterValue;
         }

         break;

      case eLPBYTE:
         {
            /* The parameter type is LPBYTE. */

            LPBYTE      pbParameterValue = (LPBYTE) NULL;

            swscanf( (const wchar_t *) ptszParameterValue, (const wchar_t *) TEXT("%x"), &pbParameterValue );

            *((LPBYTE *) pvParameterValue) = pbParameterValue;
         }

         break;

      case ePLPBYTE:
         {
            /* The parameter type is LPBYTE *. */

            LPBYTE *    ppbParameterValue = (LPBYTE *) NULL;

            swscanf( (const wchar_t *) ptszParameterValue, (const wchar_t *) TEXT("%x"), &ppbParameterValue );

            *((LPBYTE * *) pvParameterValue) = ppbParameterValue;
         }

         break;

      case eLPDWORD:
         {
            /* The parameter type is LPDWORD. */

            LPDWORD     pdwParameterValue = (LPDWORD) NULL;

            swscanf( (const wchar_t *) ptszParameterValue, (const wchar_t *) TEXT("%x"), &pdwParameterValue );

            *((LPDWORD *) pvParameterValue) = pdwParameterValue;
         }

         break;

      case eLPHANDLE:
         {
            /* The parameter type is LPHANDLE. */

            LPHANDLE    phParameterValue = (LPHANDLE) NULL;

            swscanf( (const wchar_t *) ptszParameterValue, (const wchar_t *) TEXT("%x"), &phParameterValue );

            *((LPHANDLE *) pvParameterValue) = phParameterValue;
         }

         break;

      case eLPSTR:
         {
            /* The parameter type is LPSTR. */

            /* Convert ptszParameterValue to ANSI !! */

            size_t   t_WideStringLength;

            t_WideStringLength = wcslen( ptszParameterValue );

            LPSTR pszAnsiString;

            pszAnsiString = new char[t_WideStringLength+1];    // reserve a character for the NULL

            LPSTR *  ppszParameterValue;

            ppszParameterValue = (LPSTR *) pvParameterValue;

            if ( pszAnsiString != (LPSTR) NULL )
            {
               int   xNumberOfCharsConverted;

               xNumberOfCharsConverted = wcstombs( pszAnsiString, ptszParameterValue, t_WideStringLength );

               /* Terminate the Ansi string. */

               pszAnsiString[xNumberOfCharsConverted] = (char) '\0';

               strcpy( (char *) ppszParameterValue, (const char *) pszAnsiString );

               delete [] pszAnsiString;
            }
            else
            {
               **ppszParameterValue = (char) '\0';
            }
         }

         break;

      case eLPVOID:
         {
            /* The parameter type is LPVOID. */

            LPVOID      pvDataValue = (LPVOID) NULL;

            swscanf( (const wchar_t *) ptszParameterValue, (const wchar_t *) TEXT("%x"), &pvDataValue );

            *((LPVOID *) pvParameterValue) = pvDataValue;
         }

         break;

      case eLPWSTR:
         {
            /* The parameter type is LPWSTR. */

            LPWSTR *    ppwszParameterValue;

            ppwszParameterValue = (LPWSTR *) pvParameterValue;

            wcscpy( (wchar_t *) ppwszParameterValue, (const wchar_t *) ptszParameterValue );
         }

         break;

      case ePFAX_CONFIGURATIONA:
         {
            /* The parameter type is PFAX_CONFIGURATIONA. */

            PFAX_CONFIGURATIONA     pfcaParameterValue = (PFAX_CONFIGURATIONA) NULL;

            swscanf( (const wchar_t *) ptszParameterValue, (const wchar_t *) TEXT("%x"), &pfcaParameterValue );

            *((PFAX_CONFIGURATIONA *) pvParameterValue) = pfcaParameterValue;
         }

         break;

      case ePPFAX_CONFIGURATIONA:
         {
            /* The parameter type is PFAX_CONFIGURATIONA *. */

            PFAX_CONFIGURATIONA *   ppfcaParameterValue = (PFAX_CONFIGURATIONA *) NULL;

            swscanf( (const wchar_t *) ptszParameterValue, (const wchar_t *) TEXT("%x"), &ppfcaParameterValue );

            *((PFAX_CONFIGURATIONA * *) pvParameterValue) = ppfcaParameterValue;
         }

         break;

      case ePFAX_CONFIGURATIONW:
         {
            /* The parameter type is PFAX_CONFIGURATIONW. */

            PFAX_CONFIGURATIONW     pfcwParameterValue = (PFAX_CONFIGURATIONW) NULL;

            swscanf( (const wchar_t *) ptszParameterValue, (const wchar_t *) TEXT("%x"), &pfcwParameterValue );

            *((PFAX_CONFIGURATIONW *) pvParameterValue) = pfcwParameterValue;
         }

         break;

      case ePPFAX_CONFIGURATIONW:
         {
            /* The parameter type is PFAX_CONFIGURATIONW *. */

            PFAX_CONFIGURATIONW *   ppfcwParameterValue = (PFAX_CONFIGURATIONW *) NULL;

            swscanf( (const wchar_t *) ptszParameterValue, (const wchar_t *) TEXT("%x"), &ppfcwParameterValue );

            *((PFAX_CONFIGURATIONW * *) pvParameterValue) = ppfcwParameterValue;
         }

         break;

      case ePFAX_COVERPAGE_INFOA:
         {
            /* The parameter type is PFAX_COVERPAGE_INFOA. */

            PFAX_COVERPAGE_INFOA    pfciaParameterValue = (PFAX_COVERPAGE_INFOA) NULL;

            swscanf( (const wchar_t *) ptszParameterValue, (const wchar_t *) TEXT("%x"), &pfciaParameterValue );

            *((PFAX_COVERPAGE_INFOA *) pvParameterValue) = pfciaParameterValue;
         }

         break;

      case ePFAX_COVERPAGE_INFOW:
         {
            /* The parameter type is PFAX_COVERPAGE_INFOW. */

            PFAX_COVERPAGE_INFOW    pfciwParameterValue = (PFAX_COVERPAGE_INFOW) NULL;

            swscanf( (const wchar_t *) ptszParameterValue, (const wchar_t *) TEXT("%x"), &pfciwParameterValue );

            *((PFAX_COVERPAGE_INFOW *) pvParameterValue) = pfciwParameterValue;
         }

         break;

      case ePPFAX_DEVICE_STATUSA:
         {
            /* The parameter type is PFAX_DEVICE_STATUSA *. */

            PFAX_DEVICE_STATUSA *   ppfcwParameterValue = (PFAX_DEVICE_STATUSA *) NULL;

            swscanf( (const wchar_t *) ptszParameterValue, (const wchar_t *) TEXT("%x"), &ppfcwParameterValue );

            *((PFAX_DEVICE_STATUSA * *) pvParameterValue) = ppfcwParameterValue;
         }

         break;

      case ePPFAX_DEVICE_STATUSW:
         {
            /* The parameter type is PFAX_DEVICE_STATUSW *. */

            PFAX_DEVICE_STATUSW *   ppfcwParameterValue = (PFAX_DEVICE_STATUSW *) NULL;

            swscanf( (const wchar_t *) ptszParameterValue, (const wchar_t *) TEXT("%x"), &ppfcwParameterValue );

            *((PFAX_DEVICE_STATUSW * *) pvParameterValue) = ppfcwParameterValue;
         }

         break;

      case ePFAX_JOB_ENTRYA:
         {
            /* The parameter type is PFAX_JOB_ENTRYA. */

            PFAX_JOB_ENTRYA     pfcwParameterValue = (PFAX_JOB_ENTRYA) NULL;

            swscanf( (const wchar_t *) ptszParameterValue, (const wchar_t *) TEXT("%x"), &pfcwParameterValue );

            *((PFAX_JOB_ENTRYA *) pvParameterValue) = pfcwParameterValue;
         }

         break;

      case ePPFAX_JOB_ENTRYA:
         {
            /* The parameter type is PFAX_JOB_ENTRYA *. */

            PFAX_JOB_ENTRYA *   ppfcwParameterValue = (PFAX_JOB_ENTRYA *) NULL;

            swscanf( (const wchar_t *) ptszParameterValue, (const wchar_t *) TEXT("%x"), &ppfcwParameterValue );

            *((PFAX_JOB_ENTRYA * *) pvParameterValue) = ppfcwParameterValue;
         }

         break;

      case ePFAX_JOB_ENTRYW:
         {
            /* The parameter type is PFAX_JOB_ENTRYW. */

            PFAX_JOB_ENTRYW     pfcwParameterValue = (PFAX_JOB_ENTRYW) NULL;

            swscanf( (const wchar_t *) ptszParameterValue, (const wchar_t *) TEXT("%x"), &pfcwParameterValue );

            *((PFAX_JOB_ENTRYW *) pvParameterValue) = pfcwParameterValue;
         }

         break;

      case ePPFAX_JOB_ENTRYW:
         {
            /* The parameter type is PFAX_JOB_ENTRYW *. */

            PFAX_JOB_ENTRYW *   ppfcwParameterValue = (PFAX_JOB_ENTRYW *) NULL;

            swscanf( (const wchar_t *) ptszParameterValue, (const wchar_t *) TEXT("%x"), &ppfcwParameterValue );

            *((PFAX_JOB_ENTRYW * *) pvParameterValue) = ppfcwParameterValue;
         }

         break;

      case ePFAX_JOB_PARAMA:
         {
            /* The parameter type is PFAX_JOB_PARAMA. */

            PFAX_JOB_PARAMA   pfjpaParameterValue = (PFAX_JOB_PARAMA) NULL;

            swscanf( (const wchar_t *) ptszParameterValue, (const wchar_t *) TEXT("%x"), &pfjpaParameterValue );

            *((PFAX_JOB_PARAMA *) pvParameterValue) = pfjpaParameterValue;
         }

         break;

      case ePFAX_JOB_PARAMW:
         {
            /* The parameter type is PFAX_JOB_PARAMW. */

            PFAX_JOB_PARAMW   pfjpwParameterValue = (PFAX_JOB_PARAMW) NULL;

            swscanf( (const wchar_t *) ptszParameterValue, (const wchar_t *) TEXT("%x"), &pfjpwParameterValue );

            *((PFAX_JOB_PARAMW *) pvParameterValue) = pfjpwParameterValue;
         }

         break;

      case ePFAX_LOG_CATEGORY:
         {
            /* The parameter type is PFAX_LOG_CATEGORY. */

            PFAX_LOG_CATEGORY     pfcwParameterValue = (PFAX_LOG_CATEGORY) NULL;

            swscanf( (const wchar_t *) ptszParameterValue, (const wchar_t *) TEXT("%x"), &pfcwParameterValue );

            *((PFAX_LOG_CATEGORY *) pvParameterValue) = pfcwParameterValue;
         }

         break;

      case ePPFAX_LOG_CATEGORY:
         {
            /* The parameter type is PFAX_LOG_CATEGORY *. */

            PFAX_LOG_CATEGORY *   ppfcwParameterValue = (PFAX_LOG_CATEGORY *) NULL;

            swscanf( (const wchar_t *) ptszParameterValue, (const wchar_t *) TEXT("%x"), &ppfcwParameterValue );

            *((PFAX_LOG_CATEGORY * *) pvParameterValue) = ppfcwParameterValue;
         }

         break;

      case ePFAX_PORT_INFOA:
         {
            /* The parameter type is PFAX_PORT_INFOA. */

            PFAX_PORT_INFOA     pfcwParameterValue = (PFAX_PORT_INFOA) NULL;

            swscanf( (const wchar_t *) ptszParameterValue, (const wchar_t *) TEXT("%x"), &pfcwParameterValue );

            *((PFAX_PORT_INFOA *) pvParameterValue) = pfcwParameterValue;
         }

         break;

      case ePPFAX_PORT_INFOA:
         {
            /* The parameter type is PFAX_PORT_INFOA *. */

            PFAX_PORT_INFOA *   ppfcwParameterValue = (PFAX_PORT_INFOA *) NULL;

            swscanf( (const wchar_t *) ptszParameterValue, (const wchar_t *) TEXT("%x"), &ppfcwParameterValue );

            *((PFAX_PORT_INFOA * *) pvParameterValue) = ppfcwParameterValue;
         }

         break;

      case ePFAX_PORT_INFOW:
         {
            /* The parameter type is PFAX_PORT_INFOW. */

            PFAX_PORT_INFOW     pfcwParameterValue = (PFAX_PORT_INFOW) NULL;

            swscanf( (const wchar_t *) ptszParameterValue, (const wchar_t *) TEXT("%x"), &pfcwParameterValue );

            *((PFAX_PORT_INFOW *) pvParameterValue) = pfcwParameterValue;
         }

         break;

      case ePPFAX_PORT_INFOW:
         {
            /* The parameter type is PFAX_PORT_INFOW *. */

            PFAX_PORT_INFOW *   ppfcwParameterValue = (PFAX_PORT_INFOW *) NULL;

            swscanf( (const wchar_t *) ptszParameterValue, (const wchar_t *) TEXT("%x"), &ppfcwParameterValue );

            *((PFAX_PORT_INFOW * *) pvParameterValue) = ppfcwParameterValue;
         }

         break;

      case ePFAX_PRINT_INFOA:
         {
            /* The parameter type is PFAX_PRINT_INFOA. */

            PFAX_PRINT_INFOA     pfpiaParameterValue = (PFAX_PRINT_INFOA) NULL;

            swscanf( (const wchar_t *) ptszParameterValue, (const wchar_t *) TEXT("%x"), &pfpiaParameterValue );

            *((PFAX_PRINT_INFOA *) pvParameterValue) = pfpiaParameterValue;
         }

         break;

      case ePFAX_PRINT_INFOW:
         {
            /* The parameter type is PFAX_PRINT_INFOW. */

            PFAX_PRINT_INFOW     pfpiwParameterValue = (PFAX_PRINT_INFOW) NULL;

            swscanf( (const wchar_t *) ptszParameterValue, (const wchar_t *) TEXT("%x"), &pfpiwParameterValue );

            *((PFAX_PRINT_INFOW *) pvParameterValue) = pfpiwParameterValue;
         }

         break;

      case ePPFAX_ROUTING_METHODA:
         {
            /* The parameter type is PFAX_ROUTING_METHODA *. */

            PFAX_ROUTING_METHODA *   ppfcwParameterValue = (PFAX_ROUTING_METHODA *) NULL;

            swscanf( (const wchar_t *) ptszParameterValue, (const wchar_t *) TEXT("%x"), &ppfcwParameterValue );

            *((PFAX_ROUTING_METHODA * *) pvParameterValue) = ppfcwParameterValue;
         }

         break;

      case ePPFAX_ROUTING_METHODW:
         {
            /* The parameter type is PFAX_ROUTING_METHODW *. */

            PFAX_ROUTING_METHODW *   ppfcwParameterValue = (PFAX_ROUTING_METHODW *) NULL;

            swscanf( (const wchar_t *) ptszParameterValue, (const wchar_t *) TEXT("%x"), &ppfcwParameterValue );

            *((PFAX_ROUTING_METHODW * *) pvParameterValue) = ppfcwParameterValue;
         }

         break;

      default:
         {
            /* The parameter type was not recognized by the "if" statements above. */

            CString  csMessage;

            csMessage.Format( TEXT("Unrecognized type in StoreParameterValue.") );

            AfxMessageBox( csMessage );

            fReturnValue = (BOOL) FALSE;
         }

         break;
   }

   csParameterValue.ReleaseBuffer();

   return ( fReturnValue );
}



/*
 *  PreProcessParameterValueString
 *
 *  Purpose: 
 *          This function prepares a CString object to be scanned as a
 *          hexadecimal number by removing the characters "x" ot "X" if
 *          they appear as a prefix.
 *
 *  Arguments:
 *          rcsParameterValue - a reference to a CString that contains the
 *                              parameter value.
 *
 *  Returns:
 *          a CString that has been formatted to be properly scanned as a
 *          hexadecimal value.
 *
 */

CString CFaxApiFunctionParameterInfo::PreProcessParameterValueString( const CString & rcsParameterValue )
{
   CString  csParameterValue;

   if ( rcsParameterValue.FindOneOf( TEXT("xX") ) == 0 )
   {
      int   xStringLength;

      xStringLength = rcsParameterValue.GetLength();

      /* Remove the "x" ot "X" prefix. */

      csParameterValue = rcsParameterValue.Right( xStringLength - 1 );
   }
   else
   {
      csParameterValue = rcsParameterValue;
   }

   return ( csParameterValue );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\faxapi\paramvw.cpp ===
// paramvw.cpp : implementation file
//

#include "stdafx.h"
#include "FaxApi.h"
#include "paramvw.h"
#include "fcnselvw.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern CFaxApiApp *	pFaxApiBrowserApp;

/////////////////////////////////////////////////////////////////////////////
// CParameterInfoFormView

IMPLEMENT_DYNCREATE(CParameterInfoFormView, CFormView)

CParameterInfoFormView::CParameterInfoFormView()
	: CFormView(CParameterInfoFormView::IDD)
{
	//{{AFX_DATA_INIT(CParameterInfoFormView)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CParameterInfoFormView::~CParameterInfoFormView()
{
}

void CParameterInfoFormView::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CParameterInfoFormView)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CParameterInfoFormView, CFormView)
	//{{AFX_MSG_MAP(CParameterInfoFormView)
	ON_LBN_SELCHANGE(IDC_LISTBOX_PARAMETERS, OnSelchangeListboxParameters)
	ON_EN_KILLFOCUS(IDC_EDIT_PARAMETER_VALUE, OnKillfocusEditParameterValue)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CParameterInfoFormView diagnostics

#ifdef _DEBUG
void CParameterInfoFormView::AssertValid() const
{
	CFormView::AssertValid();
}

void CParameterInfoFormView::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CParameterInfoFormView message handlers

BOOL CParameterInfoFormView::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext) 
{
	BOOL	fReturnValue;
	
	fReturnValue = CFormView::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);

	if ( fReturnValue != (BOOL) FALSE )
	{
		// Save the handle to this view in the CFaxApiApp object.

		pFaxApiBrowserApp->StoreParameterInfoFormViewHWND( m_hWnd );
	}

	return ( fReturnValue );
}



/*
 *  OnSelchangeListboxParameters
 *
 *  Purpose: 
 *          This function handles the LBN_SELCHANGE messages from the
 *          Parameter listbox.
 *
 *  Arguments:
 *          None
 *
 *  Returns:
 *          None
 *
 */

void CParameterInfoFormView::OnSelchangeListboxParameters() 
{
   // Get a pointer to the Parameter listbox.

   CListBox *  pclbParameterList;

   pclbParameterList = (CListBox *) ((CDialog *) this)->
                       GetDlgItem( IDC_LISTBOX_PARAMETERS );

   if ( pclbParameterList != (CListBox *) NULL )
   {
      // What item is selected ?

      int   xParameterIndex;

      xParameterIndex = pclbParameterList->GetCurSel();

      /* Is the item index valid */

      if ( xParameterIndex != (int) LB_ERR )
      {
         // xParameterIndex tells us which parameter is selected, but at this
         // point we don't know which Fax API function is selected.

         // Get a pointer to the CFaxApiFunctionSelectionFormViewObject.

         CFaxApiFunctionSelectionFormView *  pcFaxApiFunctionSelectionFormView;

         pcFaxApiFunctionSelectionFormView = (CFaxApiFunctionSelectionFormView *)
            pFaxApiBrowserApp->GetFaxApiFunctionSelectionFormViewPointer();

         // Is the pointer valid ?

         if ( pcFaxApiFunctionSelectionFormView !=
            (CFaxApiFunctionSelectionFormView *) NULL )
         {
            // Get a pointer to the CFaxApiFunctionInfo object for the selected
            // Fax API function.

            CFaxApiFunctionInfo *   pcfafiFunctionInfo;

            pcfafiFunctionInfo = pcFaxApiFunctionSelectionFormView->
               GetSelectedFaxApiFunctionInfoPointer();

            // Is the pointer to the CFaxApiFunctionInfo object valid ?

            if ( pcfafiFunctionInfo != (CFaxApiFunctionInfo *) NULL )
            {
               /* Format the parameter value for output. */

               CString  csParameterValue;

               pcfafiFunctionInfo->FormatParameterValueForOutput( xParameterIndex,
                                                                  (CString &) csParameterValue );

               /* Update the Parameter Value edit control. */
      
               CEdit *  pceEditControl;
      
               pceEditControl = (CEdit *) ((CDialog *) this)->
                                GetDlgItem( IDC_EDIT_PARAMETER_VALUE );
      
               if ( pceEditControl != (CEdit *) NULL )
               {
                  pceEditControl->SetWindowText( csParameterValue );
               }

               /* Limit the amount of text the user may enter. */

               SetLimitTextParameterValueEditControl( pcfafiFunctionInfo,
                                                      xParameterIndex );

               // Update the static text control that displays the parameter name.

               CString  csParameterName;

               pcfafiFunctionInfo->GetParameterName( xParameterIndex,
                                                     (CString &) csParameterName );

               // Get a pointer to the static text control.

               CWnd *   pcwndStaticText;

               pcwndStaticText = ((CDialog *) this)->
                  GetDlgItem( IDC_STATIC_PARAMETER_NAME );

               if ( pcwndStaticText != (CWnd *) NULL )
               {
                  CString  csParameterType;

                  csParameterType = pcfafiFunctionInfo->
					      GetParameterTypeString( xParameterIndex );

                  CString  csText;

                  csText.Format( TEXT("%s %s"),csParameterType, csParameterName );

                  pcwndStaticText->SetWindowText( csText );
               }

               // Update the parameter upper limit edit control.

               // THE FOLLOWING IS JUST DUMMIED UP !!!

               CString	csEditControlString;		// temporary junk
      
               pceEditControl = (CEdit *) ((CDialog *) this)->
                                GetDlgItem( IDC_EDIT_PARAM_HI_LIMIT );
      
               if ( pceEditControl != (CEdit *) NULL )
               {
                  csEditControlString.Format( TEXT("Upper limit for %s"), csParameterName );
      
                  pceEditControl->SetWindowText( csEditControlString );
               }
      
               // Update the parameter lower limit edit control
      
               pceEditControl = (CEdit *) ((CDialog *) this)->
                                GetDlgItem( IDC_EDIT_PARAM_LOW_LIMIT );
      
               if ( pceEditControl != (CEdit *) NULL )
               {
                  csEditControlString.Format( TEXT("Lower limit for %s"), csParameterName );
      
                  pceEditControl->SetWindowText( csEditControlString );
               }
      
               // Update the parameter description edit control.
      
               pceEditControl = (CEdit *) ((CDialog *) this)->
                                GetDlgItem( IDC_EDIT_PARAMETER_DESCRIPTION );
      
               if ( pceEditControl != (CEdit *) NULL )
               {
                  csEditControlString = pcfafiFunctionInfo->
					      GetParameterDescription( xParameterIndex );
      
                  pceEditControl->SetWindowText( csEditControlString );
               }
            }
         }
      }
   }
}



/*
 *  ClearParameterEditControlFamily
 *
 *  Purpose: 
 *          This function clears the family of edit controls that is
 *          associated with the Fax API Function parameter list.
 *
 *  Arguments:
 *          None
 *
 *  Returns:
 *          TRUE - indicates success
 *          FALSE - indicates failure
 *
 */

BOOL CParameterInfoFormView::ClearParameterEditControlFamily()
{
   BOOL  fReturnValue = (BOOL) TRUE;

   /* Reset the parameter value edit control. */

   CEdit *  pceEditControl;

   pceEditControl = (CEdit *) ((CDialog *) this)->
      GetDlgItem( IDC_EDIT_PARAMETER_VALUE );

   if ( pceEditControl != (CEdit *) NULL )
   {
      /* Clear the parameter value edit control. */

      pceEditControl->SetSel( 0, -1, (BOOL) TRUE );
      pceEditControl->Clear();
   }
   else
      fReturnValue = (BOOL) FALSE;

   /* Clear the parameter range edit controls. */

   pceEditControl = (CEdit *) ((CDialog *) this)->
      GetDlgItem( IDC_EDIT_PARAM_HI_LIMIT );

   if ( pceEditControl != (CEdit *) NULL )
   {
      pceEditControl->SetReadOnly( (BOOL) FALSE );

      pceEditControl->SetSel( 0, -1, (BOOL) TRUE );
      pceEditControl->Clear();

      pceEditControl->SetReadOnly( (BOOL) TRUE );
   }
   else
      fReturnValue = (BOOL) FALSE;

   pceEditControl = (CEdit *) ((CDialog *) this)->
      GetDlgItem( IDC_EDIT_PARAM_LOW_LIMIT );

   if ( pceEditControl != (CEdit *) NULL )
   {
      pceEditControl->SetReadOnly( (BOOL) FALSE );

      pceEditControl->SetSel( 0, -1, (BOOL) TRUE );
      pceEditControl->Clear();

      pceEditControl->SetReadOnly( (BOOL) TRUE );
   }
   else
      fReturnValue = (BOOL) FALSE;

   /* Clear the parameter meaning edit control. */

   pceEditControl = (CEdit *) ((CDialog *) this)->
      GetDlgItem( IDC_EDIT_PARAMETER_DESCRIPTION );

   if ( pceEditControl != (CEdit *) NULL )
   {
      pceEditControl->SetReadOnly( (BOOL) FALSE );

      pceEditControl->SetSel( 0, -1, (BOOL) TRUE );
      pceEditControl->Clear();

      pceEditControl->SetReadOnly( (BOOL) TRUE );
   }
   else
      fReturnValue = (BOOL) FALSE;

   /* Clear the static text control. */

   // Get a pointer to the static text control.

   CWnd *   pcwndStaticText;

   pcwndStaticText = ((CDialog *) this)->
      GetDlgItem( IDC_STATIC_PARAMETER_NAME );

   if ( pcwndStaticText != (CWnd *) NULL )
   {
      pcwndStaticText->SetWindowText( TEXT("") );
   }
   else
      fReturnValue = (BOOL) FALSE;

   return ( fReturnValue );
}



/*
 *  UpdateParameterListbox
 *
 *  Purpose: 
 *          This function fills the parameter listbox with the names of the
 *          parameters for the selected Fax Api function.
 *
 *  Arguments:
 *          pcfafiFunctionInfo - points to the CFaxApiFunctionInfo object for
 *                               the selected Fax API function.
 *
 *  Returns:
 *          TRUE - indicates that the listbox was updated successfully.
 *          FALSE - indicates that some error occured.
 *
 */

BOOL CParameterInfoFormView::UpdateParameterListbox( CFaxApiFunctionInfo * pcfafiFunctionInfo )
{
   BOOL  fReturnValue;

   CListBox *  pclbParameterList;

   /* Get a pointer to the Parameter listbox. */

   pclbParameterList = (CListBox *) ((CDialog *) this)->
      GetDlgItem( IDC_LISTBOX_PARAMETERS );

   /* Is the pointer valid ? */

   if ( pclbParameterList != (CListBox *) NULL )
   {
      /* Empty the listbox. */

      pclbParameterList->ResetContent();

      /* Add entries to the parameter listbox. */

      int   xNumberOfParameters;

      xNumberOfParameters = pcfafiFunctionInfo->GetNumberOfParameters();

      CString  csEntry;

      int   xParameterIndex;

      for ( xParameterIndex = 0; xParameterIndex < xNumberOfParameters; xParameterIndex++)
      {
         pcfafiFunctionInfo->GetParameterName( xParameterIndex, (CString &) csEntry );

         if ( csEntry.IsEmpty() == (BOOL) FALSE )
         {
            pclbParameterList->InsertString( xParameterIndex, (LPCTSTR) csEntry );
         }
      }

      fReturnValue = (BOOL) TRUE;
   }
   else
      fReturnValue = (BOOL) FALSE;

   return ( fReturnValue );
}



/*
 *  SetLimitTextParameterValueEditControl
 *
 *  Purpose: 
 *          This function limits the amount of text that can be entered
 *          into the parameter value edit control.
 *
 *  Arguments:
 *          pcfafiFunctionInfo - points to the CFaxApiFunctionInfo object for
 *                               function selected in the function list.
 *          xParameterIndex = the index into the CFaxApiFunctionParameterInfo
 *                            object array member of the CFaxApiFunction object for
 *                            the function selected in the function list to the
 *                            CFaxApiFunctionParameterInfo object for the parameter
 *                            selected in the parameter list.
 *
 *  Returns:
 *          None
 *
 */

void CParameterInfoFormView::SetLimitTextParameterValueEditControl( CFaxApiFunctionInfo * pcfafiFunctionInfo,
                                                                    int xParameterIndex )
{
   int   xParameterValueEditControlTextLimit;

   xParameterValueEditControlTextLimit =
      pcfafiFunctionInfo->GetMaxParamValueStringLength( xParameterIndex );

   CEdit *  pceEditControl;

   /* Set the text limit. */

   pceEditControl = (CEdit *) ((CDialog *) this)->GetDlgItem( IDC_EDIT_PARAMETER_VALUE );

   if ( pceEditControl != (CEdit *) NULL )
   {
      pceEditControl->SetLimitText( xParameterValueEditControlTextLimit );
   }
}



/*
 *  OnKillfocusEditParameterValue
 *
 *  Purpose: 
 *          This function processes the EN_KILLFOCUS messages from the
 *          parameter value edit control. It reads the content of the
 *          edit control and stores it in the memory allocated by the
 *          CFaxApiFunctionInfo object for parameter values.
 *
 *  Arguments:
 *          None
 *
 *  Returns:
 *          None
 *
 */

void CParameterInfoFormView::OnKillfocusEditParameterValue() 
{
   CEdit *  pceEditControl;

   // Get a pointer to the Parameter Value edit control.

   pceEditControl = (CEdit *) ((CDialog *) this)->
      GetDlgItem( IDC_EDIT_PARAMETER_VALUE );

   // Is the pointer valid ?

   if ( pceEditControl != (CEdit *) NULL )
   {
      /* Read the parameter value edit control. */

      CString  csParameterValue;

      pceEditControl->GetWindowText( (CString &) csParameterValue );

      /* Get the index into the parameter list. */

      CListBox *  pclbParameterList;

      pclbParameterList = (CListBox *) GetDlgItem( IDC_LISTBOX_PARAMETERS );

      /* Is the pointer valid ? */

      if ( pclbParameterList != (CListBox *) NULL )
      {
         int   xParameterIndex;

         xParameterIndex = pclbParameterList->GetCurSel();

         /* Is the index valid ? */

         if ( xParameterIndex != (int) LB_ERR )
         {
            // xParameterIndex tells us which parameter is selected, but at this
            // point we don't know which Fax API function is selected.
   
            // Get a pointer to the CFaxApiFunctionSelectionFormViewObject.
   
            CFaxApiFunctionSelectionFormView *  pcFaxApiFunctionSelectionFormView;
   
            pcFaxApiFunctionSelectionFormView = (CFaxApiFunctionSelectionFormView *)
               pFaxApiBrowserApp->GetFaxApiFunctionSelectionFormViewPointer();
   
            // Is the pointer valid ?
   
            if ( pcFaxApiFunctionSelectionFormView !=
               (CFaxApiFunctionSelectionFormView *) NULL )
            {
               // Get a pointer to the CFaxApiFunctionInfo object for the selected
               // Fax API function.
   
               CFaxApiFunctionInfo *   pcfafiFunctionInfo;
   
               pcfafiFunctionInfo = pcFaxApiFunctionSelectionFormView->
                  GetSelectedFaxApiFunctionInfoPointer();
   
               // Is the pointer to the CFaxApiFunctionInfo object valid ?
   
               if ( pcfafiFunctionInfo != (CFaxApiFunctionInfo *) NULL )
               {
                  /* Store the new parameter value. */

                  pcfafiFunctionInfo->StoreParameterValue( xParameterIndex,
                                                           (const CString &) csParameterValue );
               }
            }
         }
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\faxapi\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\faxapi\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	faxapi.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\faxsiren\faxsiren.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    faxsiren.cpp

Abstract:

    sample routing extension.  Sets an event when a fax is received, writes routing data into a log file.
    
--*/

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <faxroute.h>
#include <winfax.h>

//
// macros
//
#define ValidString( String ) ((String) ? (String) : L"" )

#ifdef DBG
#define MYDEBUG( parm ) DebugPrint parm
#else
#define MYDEBUG( parm )
#endif 

//
// constants
//
#define ROUTEITGUID           L"{5797dee0-e738-11d0-83c0-00c04fb6e984}"
#define FAXSIREN              L"FaxSirenEvent"
#define LOGNAME               L"%temp%\\ReceiveLog.txt"
#define ININAME               L"%temp%\\FaxRoute.ini"
#define SIRENDIR              L"FaxSirenFolder"

#define EXTENSIONNAME         L"FaxSiren Routing Extension"
#define EXTENSIONFRIENDLYNAME L"Fax Siren"
#define EXTENSIONPATH         L"%systemroot%\\system32\\faxsiren.dll"

#define FAXSIRENMETHOD        L"Siren"
#define FAXSIRENFRIENDLYNAME  L"Routing Siren"
#define FAXSIRENFUNCTION      L"RouteIt"


//
// forward declarations
//
BOOL
WriteRoutingInfoIntoIniFile(
    LPWSTR TiffFileName,
    PFAX_ROUTE FaxRoute
    );

BOOL
AppendFileNametoLogFile(
    LPWSTR TiffFileName,
    PFAX_ROUTE FaxRoute
    );

void 
DebugPrint(
    LPWSTR,
    ...
    );

BOOL WINAPI
ExtensionCallback(
    IN HANDLE FaxHandle,
    IN LPVOID Context,
    IN OUT LPWSTR MethodName,
    IN OUT LPWSTR FriendlyName,
    IN OUT LPWSTR FunctionName,
    IN OUT LPWSTR Guid
    );


//
// globals
//
PFAXROUTEADDFILE    FaxRouteAddFile;
PFAXROUTEDELETEFILE FaxRouteDeleteFile;
PFAXROUTEGETFILE    FaxRouteGetFile;  
PFAXROUTEENUMFILES  FaxRouteEnumFiles;
PFAXROUTEMODIFYROUTINGDATA  FaxRouteModifyRoutingData;

HANDLE              hHeap;
HANDLE              hReceiveEvent;
CRITICAL_SECTION    csRoute;
LPWSTR              IniFile = NULL;
LPWSTR              LogFile = NULL;
HINSTANCE           MyhInstance;

extern "C"
DWORD
DllEntry(
    HINSTANCE hInstance,
    DWORD     Reason,
    LPVOID    Context
    )

/*++

Routine Description:

    dll entrypoint 

Arguments:

    hInstance   - Module handle
    Reason      - Reason for being called
    Context     - Register context

Return Value:

    TRUE for success, otherwise FALSE.

--*/

{
    switch (Reason) {
    case DLL_PROCESS_ATTACH:
      MyhInstance = hInstance;
      DisableThreadLibraryCalls(hInstance);
      break;
    case DLL_PROCESS_DETACH:

       //
       // cleanup
       //
       if (hReceiveEvent) CloseHandle(hReceiveEvent);
       break;
    }

    return TRUE;
}


STDAPI 
DllRegisterServer(
    VOID
    )
/*++

Routine Description:

  Function for the in-process server to create its registry entries

Return Value:

  S_OK on success
  
Notes:
  We leverage the DllRegisterServer entrypoint as an easy way to configure
  our routing extension for use on the system.  Note that the extension doesn't
  have any COM code in it per se, but this makes installation much simpler since
  the setup code doesn't have to use custom code to setup the routing extension.

--*/
{
   HRESULT RetCode;
   HMODULE hWinFax;
   PFAXREGISTERROUTINGEXTENSION pFaxRegisterRoutingExtension;
   PFAXCONNECTFAXSERVER pFaxConnectFaxServer;
   PFAXCLOSE pFaxClose;
   HANDLE hFax;
   DWORD ExtensionCount = 0;
   
   //
   // we assume that the routing extension has already been installed into the 
   // proper location by the setup code.
   //
   hWinFax = LoadLibrary( L"winfax.dll" );
   if (!hWinFax) {
       MYDEBUG(( L"LoadLibrary failed, ec = %d\n", GetLastError() ));
       RetCode = E_UNEXPECTED;
       goto e0;
   }

   pFaxRegisterRoutingExtension = (PFAXREGISTERROUTINGEXTENSION) GetProcAddress( 
                                                                    hWinFax, 
                                                                    "FaxRegisterRoutingExtensionW" );
   pFaxConnectFaxServer = (PFAXCONNECTFAXSERVER) GetProcAddress( 
                                                    hWinFax, 
                                                    "FaxConnectFaxServerW" );
   pFaxClose = (PFAXCLOSE) GetProcAddress( 
                                    hWinFax, 
                                    "FaxClose" );

   if (!pFaxRegisterRoutingExtension || !pFaxConnectFaxServer || !pFaxClose) {
       MYDEBUG(( L"GetProcAddress failed, ec = %d\n", GetLastError() ));
       RetCode = E_UNEXPECTED;
       goto e1;       
   }

   if (!pFaxConnectFaxServer( NULL, &hFax )) {
       MYDEBUG(( L"FaxConnectFaxServer failed, ec = %d\n", GetLastError() ));
       RetCode = HRESULT_FROM_WIN32( GetLastError() );
       goto e1;
   }

   if (!pFaxRegisterRoutingExtension(
                            hFax,
                            EXTENSIONNAME,
                            EXTENSIONFRIENDLYNAME,
                            EXTENSIONPATH,
                            ExtensionCallback,
                            (LPVOID) &ExtensionCount
                            )) {
       MYDEBUG(( L"FaxRegisterRoutingExtension failed, ec = %d\n", GetLastError() ));
       RetCode = HRESULT_FROM_WIN32( GetLastError() );
       goto e2;
   } 

   RetCode = S_OK;

e2:
   pFaxClose( hFax );
e1:
   FreeLibrary( hWinFax );
e0:
   return RetCode;
}


BOOL WINAPI
ExtensionCallback(
    IN HANDLE FaxHandle,
    IN LPVOID Context,
    IN OUT LPWSTR MethodName,
    IN OUT LPWSTR FriendlyName,
    IN OUT LPWSTR FunctionName,
    IN OUT LPWSTR Guid
    )
/*++

Routine Description:

  Callback function for adding our routing extensions

Return Value:

  TRUE if we added another extension, FALSE if we're done adding extensions
  
--*/
{
    PDWORD ExtensionCount = (PDWORD) Context;

    //
    // since we only have one extension, this is a really simple function
    // --we don't really need the context data above, it's just here to 
    //   illustrate what you might use the context data for.
    //

    if (ExtensionCount) {
        MYDEBUG(( L"ExtensionCallback called for extension %d\n", *ExtensionCount ));
    } else {
        MYDEBUG(( L"context data is NULL, can't continue\n", *ExtensionCount ));
        return FALSE;
    }

    if (*ExtensionCount != 0) {
        //
        // we've added all of our methods, return FALSE to signify that we're done
        // 
        return FALSE;
    }
    
    wcscpy(MethodName,   FAXSIRENMETHOD );
    wcscpy(FriendlyName, FAXSIRENFRIENDLYNAME );
    wcscpy(FunctionName, FAXSIRENFUNCTION );
    wcscpy(Guid,         ROUTEITGUID );

    *ExtensionCount += 1;

    return TRUE;

}




//
// required exports
//


BOOL WINAPI
FaxRouteInitialize(
    IN HANDLE HeapHandle,
    IN PFAX_ROUTE_CALLBACKROUTINES FaxRouteCallbackRoutines
    )
/*++

Routine Description:

    This functions is called by the fax service to initialize the routing extension.  This function
    should only be called once per instantiation of the fax service

Arguments:

    HeapHandle               - Heap handle for memory all allocations
    FaxRouteCallbackRoutines - structure containing callback functions    

Return Value:

    TRUE for success, otherwise FALSE.

--*/

{
    DWORD dwNeeded;
    SECURITY_DESCRIPTOR sd;
    SECURITY_ATTRIBUTES sa;

    //
    // make sure we can understand the structure
    //
    if ( FaxRouteCallbackRoutines->SizeOfStruct < sizeof(FAX_ROUTE_CALLBACKROUTINES) ) {
        MYDEBUG ((L"The passed in SizeOfStruct (%d) is smaller than expected (%d) ", 
                  FaxRouteCallbackRoutines->SizeOfStruct,
                  sizeof(FAX_ROUTE_CALLBACKROUTINES) ));
        return FALSE;
    }

    hHeap = HeapHandle;
    FaxRouteAddFile = FaxRouteCallbackRoutines->FaxRouteAddFile;
    FaxRouteDeleteFile = FaxRouteCallbackRoutines->FaxRouteDeleteFile;
    FaxRouteGetFile = FaxRouteCallbackRoutines->FaxRouteGetFile;
    FaxRouteEnumFiles = FaxRouteCallbackRoutines->FaxRouteEnumFiles;
    FaxRouteModifyRoutingData = FaxRouteCallbackRoutines->FaxRouteModifyRoutingData;
    
    InitializeCriticalSection( &csRoute );

    //
    // create a named event
    //
    // note that we need to create a security descriptor with a NULL DACL (all access) because we want the named
    // event to be opened by programs that might not be running in same context as the fax service
    //
    if ( !InitializeSecurityDescriptor(&sd,SECURITY_DESCRIPTOR_REVISION) ) {
        MYDEBUG(( L"InitializeSecurityDecriptor failed, ec = %d\n", GetLastError() ));
        return FALSE;
    }

    if ( !SetSecurityDescriptorDacl(&sd, TRUE, NULL, FALSE) ) {
        MYDEBUG(( L"SetSecurityDescriptorDacl failed, ec = %d\n", GetLastError() ));
        return FALSE;
    }

    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = &sd;
    sa.bInheritHandle = FALSE;
    hReceiveEvent = CreateEvent(&sa,FALSE,FALSE,FAXSIREN);

    if (!hReceiveEvent) {
       if (GetLastError() != ERROR_ALREADY_EXISTS) {
          MYDEBUG (( L"CreateEvent failed, ec = %d\n", GetLastError() ));
          return FALSE;
       }
    }

    //
    // get path to files for logging, etc.
    //
    dwNeeded = ExpandEnvironmentStrings(ININAME,IniFile,0);    
    IniFile  = (LPWSTR) HeapAlloc(hHeap,HEAP_ZERO_MEMORY,(dwNeeded)*sizeof(WCHAR));
    if (!IniFile) {
       MYDEBUG((L"HeapAlloc failed, ec = %d\n", GetLastError() ));
       return FALSE;
    }
    DWORD dwSuccess = ExpandEnvironmentStrings(ININAME,IniFile,dwNeeded);

    if (dwSuccess == 0) {
       return FALSE;
    }

    dwNeeded = ExpandEnvironmentStrings(LOGNAME,LogFile,0);
    LogFile  = (LPWSTR) HeapAlloc(hHeap,HEAP_ZERO_MEMORY,sizeof(WCHAR)*(dwNeeded));
    if (!LogFile) {
       MYDEBUG(( L"HeapAlloc failed, ec = %d\n", GetLastError() ));
       return FALSE;
    }
    dwSuccess = ExpandEnvironmentStrings(LOGNAME,LogFile,dwNeeded);

    if (dwSuccess == 0) {
       return FALSE;
    }

    MYDEBUG (( L"Logfile : %s\n", LogFile ));
    MYDEBUG (( L"Inifile : %s\n", IniFile ));
    
    return TRUE;

}

BOOL WINAPI
FaxRouteGetRoutingInfo(
    IN  LPWSTR RoutingGuid,
    IN  DWORD DeviceId,
    IN  LPBYTE RoutingInfo,
    OUT LPDWORD RoutingInfoSize
    )

/*++

Routine Description:

    This functions is called by the fax service to
    get routing configuration data.

Arguments:

    RoutingGuid         - Unique identifier for the requested routing method
    DeviceId            - Device that is being configured
    RoutingInfo         - Routing info buffer
    RoutingInfoSize     - Size of the buffer (in bytes)

Return Value:

    TRUE for success, otherwise FALSE.

--*/

{
    //
    // the sample doesn't have any per device routing data, so this function is
    // just stubbed out -- if you have per device routing data, it would be
    // retrieved here.
    //
    if (RoutingInfoSize) {
        *RoutingInfoSize = 0;
    }
    return TRUE;
}


BOOL WINAPI
FaxRouteSetRoutingInfo(
    IN  LPWSTR RoutingGuid,
    IN  DWORD DeviceId,
    IN  LPBYTE RoutingInfo,
    IN  DWORD RoutingInfoSize
    )
/*++

Routine Description:

    This functions is called by the fax service to
    set routing configuration data.

Arguments:

    RoutingGuid         - Unique identifier for the requested routing method
    DeviceId            - Device that is being configured
    RoutingInfo         - Routing info buffer
    RoutingInfoSize     - Size of the buffer (in bytes)

Return Value:

    TRUE for success, otherwise FALSE.

--*/
{
    //
    // the sample doesn't have any per device routing data, so this function is
    // just stubbed out -- if you have per device routing data, it would be
    // commited to storage here.
    //
    return TRUE;
}

BOOL WINAPI
FaxRouteDeviceEnable(
    IN  LPWSTR RoutingGuid,
    IN  DWORD DeviceId,
    IN  LONG Enabled
    )
/*++

Routine Description:

    This functions is called by the fax service to determine if a routing extension is enabled or
    to enable a routing extension

Arguments:

    RoutingGuid         - Unique identifier for the requested routing method
    DeviceId            - Device that is being configured
    Enabled             - meaning differs based on context (see FAXROUTE_ENABLE enumerated type)

Return Value:

    depends on context.

--*/
{
    //
    // -note that we make the assumption that there are never more than 4 devices in this sample
    // -also note that this isn't thread safe
    // -a real routing extension wouldn't make these assumptions, and would probably have some 
    //  persistent store which kept track of the enabled state of an extension per-routing method
    //
    static long MyEnabled[4] = {STATUS_ENABLE,STATUS_ENABLE,STATUS_ENABLE,STATUS_ENABLE};
    static DWORD DeviceIdIndex[4] = {0,0,0,0};
    DWORD count;

    //
    // make sure that we're dealing with our routing method
    // 
    if (wcscmp(RoutingGuid,ROUTEITGUID) != 0) {
        MYDEBUG (( L"Passed a GUID (%s) for a method not in this extension!\n", RoutingGuid ));
        return FALSE;
    }
    
    for (count = 0 ; count <4; count ++) {
        if (DeviceIdIndex[count] == DeviceId) {
            break;
        } else if (DeviceIdIndex[count] == 0) {
            DeviceIdIndex[count] = DeviceId;
        }
    }

    if (Enabled == QUERY_STATUS) {
        return MyEnabled[count];
    }

    MYDEBUG (( L"Setting enabled state to %s\n", 
               (Enabled == STATUS_DISABLE) ? L"STATUS_DISABLE" : L"STATUS_ENABLE" 
            ));

    MyEnabled[count] = Enabled;

    return TRUE;
}


BOOL WINAPI
FaxRouteDeviceChangeNotification(
    IN  DWORD DeviceId,
    IN  BOOL  NewDevice
    )

/*++

Routine Description:

    This functions is called by the fax service to alert the routing extension that a device 
    has changed

Arguments:

    DeviceId            - Device that has changed 
    NewDevice           - TRUE means device was added, FALSE means a device was removed 

Return Value:

    TRUE for success

--*/
{
   //
   // We don't have any per device routing data, so this is just stubbed out
   //
   return TRUE;
}


//
// routing method(s)
//


BOOL WINAPI
RouteIt(
    PFAX_ROUTE FaxRoute,
    PVOID *FailureData,
    LPDWORD FailureDataSize
    )

/*++

Routine Description:

    This functions is called by the fax service to
    route a received fax.

Arguments:

    FaxRoute            - Routing information
    FailureData         - Failure data buffer
    FailureDataSize     - Size of failure data buffer

Return Value:

    TRUE for success, otherwise FALSE.

--*/

{
    WCHAR TiffFileName[MAX_PATH];
    WCHAR Dir[MAX_PATH],Drive[10],File[MAX_PATH],Ext[10];
    WCHAR CopyOfTiff[MAX_PATH];
    
    DWORD Size = sizeof(TiffFileName);

    //
    // serialize access to this function so that data is written into the logfile accurately
    //
    EnterCriticalSection( &csRoute );
    
    if (!FaxRouteGetFile(
        FaxRoute->JobId,
        0,
        TiffFileName,
        &Size))
    {
       MYDEBUG(( L"Couldn't FaxRouteGetFile, ec = %d", GetLastError() ));
       LeaveCriticalSection( &csRoute );
       return FALSE;
    }

    MYDEBUG ((L"Received fax %s\n\tCSID :%s\n\t Name : %s\n\t #: %s\n\tDevice: %s\n", 
              TiffFileName,
              ValidString ( FaxRoute->Csid ),
              ValidString ( FaxRoute->ReceiverName),
              ValidString ( FaxRoute->ReceiverNumber),
              ValidString ( FaxRoute->DeviceName ) 
              ));
 
    _wsplitpath(TiffFileName, Drive, Dir, File, Ext );
    wsprintf(CopyOfTiff,L"%s\\%s\\%s%s",Drive,SIRENDIR,File,Ext);

    //
    // copy the tiff so it persists after this routine exits
    //
    CopyFile(TiffFileName,CopyOfTiff,FALSE);

    //
    // write some logging data
    // 
    WriteRoutingInfoIntoIniFile(CopyOfTiff,FaxRoute);
    AppendFileNametoLogFile(TiffFileName, FaxRoute);

    //
    // signal event -- another application could use this named event to do something 
    // with the file that was just copied into this directory 
    // (note that the INI file isn't thread-safe accross applications, we could have the routing data overwritten by
    //  another fax being received)
    //
    SetEvent(hReceiveEvent);

    //
    // service needs to be able to interact with the current desktop for this to work
    //
    MessageBeep(MB_ICONEXCLAMATION);

    LeaveCriticalSection( &csRoute );

    return TRUE;
}


//
// utility fcn's
//

BOOL WriteRoutingInfoIntoIniFile(LPWSTR TiffFileName,PFAX_ROUTE FaxRoute) 
{
   WCHAR Buffer[MAX_PATH*2];


   //
   // write each routing info member into ini file
   // 
   
   //filename
   ZeroMemory(Buffer,MAX_PATH*2);
   wsprintf(Buffer, L"%s",ValidString (TiffFileName) );
   WritePrivateProfileString( L"RoutingInfo",// pointer to section name 
                              L"FileName",// pointer to key name 
                              Buffer,   // pointer to string to add 
                              IniFile // pointer to initialization filename 
                            );


   //jobid
   ZeroMemory(Buffer,MAX_PATH*2);
   wsprintf(Buffer, L"%u",FaxRoute->JobId);
   WritePrivateProfileString( L"RoutingInfo",// pointer to section name 
                                   L"JobId",// pointer to key name 
                                   Buffer,   // pointer to string to add 
                                   IniFile // pointer to initialization filename 
                                 );

   //elapsedtime
   ZeroMemory(Buffer,MAX_PATH*2);
   wsprintf(Buffer, L"%u",FaxRoute->ElapsedTime);
   WritePrivateProfileString( L"RoutingInfo",// pointer to section name 
                                   L"ElapsedTime",// pointer to key name 
                                   Buffer,   // pointer to string to add 
                                   IniFile // pointer to initialization filename 
                                 );

   //receivetime
   ZeroMemory(Buffer,MAX_PATH*2);
   wsprintf(Buffer, L"%u",FaxRoute->ReceiveTime);
   WritePrivateProfileString( L"RoutingInfo",// pointer to section name 
                                   L"ReceiveTime",// pointer to key name 
                                   Buffer,   // pointer to string to add 
                                   IniFile // pointer to initialization filename 
                                 );
   //pagecount
   ZeroMemory(Buffer,MAX_PATH*2);
   wsprintf(Buffer, L"%u",FaxRoute->PageCount);
   WritePrivateProfileString( L"RoutingInfo",// pointer to section name 
                                   L"PageCount",// pointer to key name 
                                   Buffer,   // pointer to string to add 
                                   IniFile // pointer to initialization filename 
                                 );

   //Csid
   ZeroMemory(Buffer,MAX_PATH*2);
   wsprintf(Buffer, L"%s",ValidString (FaxRoute->Csid ));
   WritePrivateProfileString( L"RoutingInfo",// pointer to section name 
                                   L"Csid",// pointer to key name 
                                   Buffer,   // pointer to string to add 
                                   IniFile // pointer to initialization filename 
                                 );

   //CallerId
   ZeroMemory(Buffer,MAX_PATH*2);
   wsprintf(Buffer, L"%s",ValidString (FaxRoute->CallerId ));
   WritePrivateProfileString( L"RoutingInfo",// pointer to section name 
                                   L"CallerId",// pointer to key name 
                                   Buffer,   // pointer to string to add 
                                   IniFile // pointer to initialization filename 
                                 );

   //RoutingInfo
   ZeroMemory(Buffer,MAX_PATH*2);
   wsprintf(Buffer, L"%s",ValidString (FaxRoute->RoutingInfo ));
   WritePrivateProfileString( L"RoutingInfo",// pointer to section name 
                                   L"RoutingInfo",// pointer to key name 
                                   Buffer,   // pointer to string to add 
                                   IniFile // pointer to initialization filename 
                                 );

   //ReceiverName
   ZeroMemory(Buffer,MAX_PATH*2);
   wsprintf(Buffer, L"%s",ValidString (FaxRoute->ReceiverName ));
   WritePrivateProfileString( L"RoutingInfo",// pointer to section name 
                                   L"ReceiverName",// pointer to key name 
                                   Buffer,   // pointer to string to add 
                                   IniFile // pointer to initialization filename 
                                 );

   //ReceiverNumber
   ZeroMemory(Buffer,MAX_PATH*2);
   wsprintf(Buffer, L"%s",ValidString (FaxRoute->ReceiverNumber ));
   WritePrivateProfileString( L"RoutingInfo",// pointer to section name 
                                   L"ReceiverNumber",// pointer to key name 
                                   Buffer,   // pointer to string to add 
                                   IniFile // pointer to initialization filename 
                                 );

   //DeviceName
   ZeroMemory(Buffer,MAX_PATH*2);
   wsprintf(Buffer, L"%s",ValidString (FaxRoute->DeviceName ));
   WritePrivateProfileString( L"RoutingInfo",// pointer to section name 
                                   L"DeviceName",// pointer to key name 
                                   Buffer,   // pointer to string to add 
                                   IniFile // pointer to initialization filename 
                                 );

   //DeviceId
   ZeroMemory(Buffer,MAX_PATH*2);
   wsprintf(Buffer, L"%u",FaxRoute->DeviceId );
   WritePrivateProfileString( L"RoutingInfo",// pointer to section name 
                                   L"DeviceId",// pointer to key name 
                                   Buffer,   // pointer to string to add 
                                   IniFile // pointer to initialization filename 
                                 );

   return TRUE;
}

BOOL AppendFileNametoLogFile (LPWSTR TiffFileName,PFAX_ROUTE FaxRoute) 
{
   HANDLE hFile = INVALID_HANDLE_VALUE;
   WCHAR Buffer[MAX_PATH];
   WCHAR szDateTime[104];
   WCHAR lpDate[50];
   WCHAR lpTime[50];

   DWORD dwWrote = 0;
   
   hFile = CreateFile(LogFile,
                      GENERIC_WRITE,
                      FILE_SHARE_WRITE,
                      NULL,
                      OPEN_ALWAYS,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL);

   if (hFile == INVALID_HANDLE_VALUE) {
      MYDEBUG (( L"CreateFile failed, ec = %d\n", GetLastError() ));
      return FALSE;
   }

   if ( !GetDateFormat( LOCALE_SYSTEM_DEFAULT,
                        DATE_SHORTDATE,
                        NULL,                // use system date
                        NULL,                // use locale format
                        lpDate,
                        sizeof(lpDate) ) ) {
      MYDEBUG(( L"GetDateFormat failed, ec = %d\n", GetLastError() ));
      return FALSE;
   }
    

   if ( !GetTimeFormat( LOCALE_SYSTEM_DEFAULT,
                        TIME_NOSECONDS,
                        NULL,                // use system time
                        NULL,                // use locale format
                        lpTime,
                        sizeof(lpTime) ) ) {
      MYDEBUG(( L"GetTimeFormat failed, ec = %d\n", GetLastError() ));
      return FALSE;
   }

   wsprintf( szDateTime, TEXT("%-8s %-8s"), lpDate, lpTime);

   wsprintf(Buffer, L"%s :Received %s\r\n",ValidString(szDateTime),ValidString(TiffFileName));

   SetFilePointer(hFile,0,0,FILE_END);

   if (!WriteFile(hFile,Buffer,lstrlen(Buffer)*sizeof(WCHAR),&dwWrote,NULL)) {
      MYDEBUG (( L"WriteFile() failed, ec = %d\n", GetLastError() ));
      CloseHandle(hFile);
      return FALSE;
   }

   CloseHandle(hFile);
   
   return TRUE;
}

void
DebugPrint(
    LPTSTR Format,
    ...
    )

/*++

Routine Description:

    Prints a debug string

Arguments:

    format      - wsprintf() format string
    ...         - Variable data

Return Value:

    None.

--*/

{
   TCHAR Buffer[1024];
   TCHAR AppName[MAX_PATH];
   TCHAR ShortName[MAX_PATH];
   SYSTEMTIME CurrentTime;
   int len=0;

   va_list marker;

   ZeroMemory(AppName,MAX_PATH);
   ZeroMemory(ShortName,MAX_PATH);

   if (  GetModuleFileName(NULL, // handle to module to find filename for 
                           AppName,
                           MAX_PATH) ) {
      _tsplitpath(AppName,NULL,NULL,ShortName,NULL);
   }

   ZeroMemory(&CurrentTime,sizeof(SYSTEMTIME));

   GetLocalTime(&CurrentTime);

   wsprintf(Buffer, TEXT ("%02d.%02d.%02d.%03d %s: "),CurrentTime.wHour,
                                                      CurrentTime.wMinute,
                                                      CurrentTime.wSecond,
                                                      CurrentTime.wMilliseconds,
                                                      ShortName );

   // init arg list
   va_start(marker,Format);

   // point to rest of blank buffer
   len = lstrlen(Buffer);

   _vsntprintf(&Buffer[len], // don't want to overwrite the start of the string!
               sizeof(Buffer)-len, //size of the rest of the buffer
               Format,
               marker);
   
   len = lstrlen(Buffer);

   if (Buffer[len-1] == L'\n' ) {   
      Buffer[len-1] = L'\r';
      Buffer[len] = L'\n';
      Buffer[len+1] = 0;
   }
   else {
      Buffer[len] = L'\r';
      Buffer[len+1] = L'\n';
      Buffer[len+2] = 0;
   }

   OutputDebugString(Buffer);
   
   va_end(marker);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\faxapi\rvoutvw.h ===
#if !defined(AFX_RVOUTVW_H__A55ED772_2ED1_11D1_ACDA_00A0C908F98C__INCLUDED_)
#define AFX_RVOUTVW_H__A55ED772_2ED1_11D1_ACDA_00A0C908F98C__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// rvoutvw.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CReturnValueOutputFormView form view

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

class CReturnValueOutputFormView : public CFormView
{
protected:
	CReturnValueOutputFormView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CReturnValueOutputFormView)

// Form Data
public:
	//{{AFX_DATA(CReturnValueOutputFormView)
	enum { IDD = IDD_RETURN_VALUE_OUTPUT };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CReturnValueOutputFormView)
	public:
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CReturnValueOutputFormView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

public:

BOOL UpdateReturnValueOutputEditCtrl( CString & rcsReturnValueOutputString );
BOOL ClearReturnValueOutputEditCtrl();

	// Generated message map functions
	//{{AFX_MSG(CReturnValueOutputFormView)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_RVOUTVW_H__A55ED772_2ED1_11D1_ACDA_00A0C908F98C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\faxsiren\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by faxsiren.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\ncfsp\cfgtest.c ===
#include <windows.h>
#include <tapi.h>
#include <faxdev.h>

int __cdecl wmain( int argc, LPWSTR argv[])
{
    HPROPSHEETPAGE   hPropSheet;
    PFAXDEVCONFIGURE pFaxDevConfigure;
    HMODULE hMod;
    PROPSHEETHEADER psh;


    InitCommonControls();

    hMod = LoadLibrary( L"obj\\i386\\netcntrc.dll");
    if (!hMod) {
        return -1;
    }

    pFaxDevConfigure = (PFAXDEVCONFIGURE) GetProcAddress( hMod, "FaxDevConfigure" );
    if (!pFaxDevConfigure) {
        return -1;
    }

    if (!pFaxDevConfigure( &hPropSheet )) {
        return -1;
    }

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = 0;
    psh.hwndParent = NULL;
    psh.hInstance = GetModuleHandle( NULL );
    psh.pszIcon = NULL;
    psh.pszCaption = TEXT("NetCentric Internet Fax Configuration");
    psh.nPages = 1;
    psh.nStartPage = 0;
    psh.phpage = &hPropSheet;
    psh.pfnCallback = NULL;

    return PropertySheet( &psh );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\ncfsp\acctwiz.cpp ===
#include "nc.h"
#pragma hdrstop


typedef struct _NCACCTINFO NCACCTINFO, *LPNCACCTINFO;

typedef BOOL (CALLBACK* NCDLGPROC)(HWND, UINT, WPARAM, LPARAM, LPNCACCTINFO);

typedef HPROPSHEETPAGE *LPHPROPSHEETPAGE;

typedef struct _NCACCTINFO {
    CNcConnectionInfo connInfo;
    CNcAccountInfo accountInfo;
    CNcUser accountOwner;
    CNcUser billingOwner;
    const AccountInfoServer *pServer;
    const AccountInfoPlan *pPlan;
    CHAR ServerName[LT_SERVER_NAME+1];
    CHAR FirstName[LT_FIRST_NAME+1];
    CHAR LastName[LT_LAST_NAME+1];
    CHAR Email[LT_EMAIL+1];
    CHAR PhoneNumber[LT_PHONE_NUMBER+1];
    CHAR AreaCode[LT_AREA_CODE+1];
    CHAR Address[LT_ADDRESS+1];
    CHAR City[LT_CITY+1];
    CHAR State[LT_STATE+1];
    CHAR Zip[LT_ZIP+1];
    CHAR AccountName[LT_ACCOUNT_NAME+1];
    CHAR Password[LT_PASSWORD+1];
    CHAR CreditCard[LT_CREDIT_CARD+1];
    CHAR ExpiryMM[LT_EXPIRY_MM+1];
    CHAR ExpiryYY[LT_EXPIRY_YY+1];
    CHAR CCName[LT_CC_NAME+1];
    CHAR CCType[32];
} NCACCTINFO, *LPNCACCTINFO;

typedef struct _WIZPAGE {
    UINT            ButtonState;
    UINT            HelpContextId;
    LPTSTR          Title;
    DWORD           PageId;
    NCDLGPROC       DlgProc;
    PROPSHEETPAGE   Page;
    LPNCACCTINFO    NcAcctInfo;
} WIZPAGE, *PWIZPAGE;


typedef enum {
    WizPageServerName,
    WizPageIsp,
    WizPagePlans,
    WizPageInfo,
    WizPageInfo2,
    WizPageAccount,
    WizPageBilling,
    WizPageFinish,
    WizPageCreate,
    WizPageMaximum
} WizPage;


BOOL CALLBACK
CommonDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL CALLBACK
ServerNameDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LPNCACCTINFO NcAcctInfo
    );

BOOL CALLBACK
Info2DlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LPNCACCTINFO NcAcctInfo
    );

BOOL CALLBACK
InfoDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LPNCACCTINFO NcAcctInfo
    );

BOOL CALLBACK
AccountDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LPNCACCTINFO NcAcctInfo
    );

BOOL CALLBACK
BillingDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LPNCACCTINFO NcAcctInfo
    );

BOOL CALLBACK
IspDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LPNCACCTINFO NcAcctInfo
    );

BOOL CALLBACK
PlansDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LPNCACCTINFO NcAcctInfo
    );

BOOL CALLBACK
CreateDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LPNCACCTINFO NcAcctInfo
    );

BOOL CALLBACK
FinishDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LPNCACCTINFO NcAcctInfo
    );

WIZPAGE WizardPages[WizPageMaximum] =
{
    //
    // server name page
    //
    {
       PSWIZB_NEXT,                                    // valid buttons
       0,                                              // help id
       NULL,                                           // title
       WizPageServerName,                              // page id
       ServerNameDlgProc,                              // dlg proc
     { sizeof(PROPSHEETPAGE),                          // size of struct
       0,                                              // flags
       NULL,                                           // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_SERVER_NAME_PAGE),          // dlg template
       NULL,                                           // icon
       NULL,                                           // title
       (DLGPROC)CommonDlgProc,                         // dlg proc
       0,                                              // lparam
       NULL,                                           // callback
       NULL                                            // ref count
    }},

    //
    // isp page
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,                      // valid buttons
       0,                                              // help id
       NULL,                                           // title
       WizPageIsp,                                     // page id
       IspDlgProc,                                     // dlg proc
     { sizeof(PROPSHEETPAGE),                          // size of struct
       0,                                              // flags
       NULL,                                           // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_ISP_PAGE),                  // dlg template
       NULL,                                           // icon
       NULL,                                           // title
       (DLGPROC)CommonDlgProc,                         // dlg proc
       0,                                              // lparam
       NULL,                                           // callback
       NULL                                            // ref count
    }},

    //
    // plans page
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,                      // valid buttons
       0,                                              // help id
       NULL,                                           // title
       WizPagePlans,                                   // page id
       PlansDlgProc,                                   // dlg proc
     { sizeof(PROPSHEETPAGE),                          // size of struct
       0,                                              // flags
       NULL,                                           // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_PLANS_PAGE),                // dlg template
       NULL,                                           // icon
       NULL,                                           // title
       (DLGPROC)CommonDlgProc,                         // dlg proc
       0,                                              // lparam
       NULL,                                           // callback
       NULL                                            // ref count
    }},

    //
    // info page
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,                      // valid buttons
       0,                                              // help id
       NULL,                                           // title
       WizPageInfo,                                    // page id
       InfoDlgProc,                                    // dlg proc
     { sizeof(PROPSHEETPAGE),                          // size of struct
       0,                                              // flags
       NULL,                                           // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_INFO_PAGE),                 // dlg template
       NULL,                                           // icon
       NULL,                                           // title
       (DLGPROC)CommonDlgProc,                         // dlg proc
       0,                                              // lparam
       NULL,                                           // callback
       NULL                                            // ref count
    }},

    //
    // info2 page
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,                      // valid buttons
       0,                                              // help id
       NULL,                                           // title
       WizPageInfo2,                                   // page id
       Info2DlgProc,                                   // dlg proc
     { sizeof(PROPSHEETPAGE),                          // size of struct
       0,                                              // flags
       NULL,                                           // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_INFO2_PAGE),                // dlg template
       NULL,                                           // icon
       NULL,                                           // title
       (DLGPROC)CommonDlgProc,                         // dlg proc
       0,                                              // lparam
       NULL,                                           // callback
       NULL                                            // ref count
    }},

    //
    // account page
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,                      // valid buttons
       0,                                              // help id
       NULL,                                           // title
       WizPageAccount,                                 // page id
       AccountDlgProc,                                 // dlg proc
     { sizeof(PROPSHEETPAGE),                          // size of struct
       0,                                              // flags
       NULL,                                           // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_ACCT_PAGE),                 // dlg template
       NULL,                                           // icon
       NULL,                                           // title
       (DLGPROC)CommonDlgProc,                         // dlg proc
       0,                                              // lparam
       NULL,                                           // callback
       NULL                                            // ref count
    }},

    //
    // billing page
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,                      // valid buttons
       0,                                              // help id
       NULL,                                           // title
       WizPageBilling,                                 // page id
       BillingDlgProc,                                 // dlg proc
     { sizeof(PROPSHEETPAGE),                          // size of struct
       0,                                              // flags
       NULL,                                           // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_BILLING_PAGE),              // dlg template
       NULL,                                           // icon
       NULL,                                           // title
       (DLGPROC)CommonDlgProc,                         // dlg proc
       0,                                              // lparam
       NULL,                                           // callback
       NULL                                            // ref count
    }},

    //
    // account creation page
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,                      // valid buttons
       0,                                              // help id
       NULL,                                           // title
       WizPageCreate,                                  // page id
       CreateDlgProc,                                  // dlg proc
     { sizeof(PROPSHEETPAGE),                          // size of struct
       0,                                              // flags
       NULL,                                           // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_CREATE_PAGE),               // dlg template
       NULL,                                           // icon
       NULL,                                           // title
       (DLGPROC)CommonDlgProc,                         // dlg proc
       0,                                              // lparam
       NULL,                                           // callback
       NULL                                            // ref count
    }},

    //
    // finish page
    //
    {
       PSWIZB_FINISH | PSWIZB_BACK,                    // valid buttons
       0,                                              // help id
       NULL,                                           // title
       WizPageFinish,                                  // page id
       FinishDlgProc,                                  // dlg proc
     { sizeof(PROPSHEETPAGE),                          // size of struct
       0,                                              // flags
       NULL,                                           // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_FINISH_PAGE),               // dlg template
       NULL,                                           // icon
       NULL,                                           // title
       (DLGPROC)CommonDlgProc,                         // dlg proc
       0,                                              // lparam
       NULL,                                           // callback
       NULL                                            // ref count
    }}
};





LPHPROPSHEETPAGE
CreateWizardPages(
    LPNCACCTINFO NcAcctInfo
    )
{
    LPHPROPSHEETPAGE WizardPageHandles;
    DWORD i;


    //
    // allocate the page handle array
    //

    WizardPageHandles = (HPROPSHEETPAGE*) MemAlloc(
        sizeof(HPROPSHEETPAGE) * WizPageMaximum
        );

    if (!WizardPageHandles) {
        return NULL;
    }

    //
    // Create each page.
    //

    for(i=0; i<WizPageMaximum; i++) {

        WizardPages[i].Page.hInstance = MyhInstance;
        WizardPages[i].Page.dwFlags  |= PSP_USETITLE;
        WizardPages[i].NcAcctInfo     = NcAcctInfo;
        WizardPages[i].Page.lParam    = (LPARAM) &WizardPages[i];

        WizardPageHandles[i] = CreatePropertySheetPage( &WizardPages[i].Page );

        if (!WizardPageHandles[i]) {
            MemFree( WizardPageHandles );
            return NULL;
        }

    }

    return WizardPageHandles;
}


int
CALLBACK
WizardCallback(
    IN HWND   hdlg,
    IN UINT   code,
    IN LPARAM lParam
    )
{
    DLGTEMPLATE *DlgTemplate;


    //
    // Get rid of context sensitive help control on title bar
    //
    if(code == PSCB_PRECREATE) {
        DlgTemplate = (DLGTEMPLATE *)lParam;
        DlgTemplate->style &= ~DS_CONTEXTHELP;
    }

    return 0;
}


BOOL
CreateNewAccount(
    HWND hDlg
    )
{
    PROPSHEETHEADER psh;
    LPHPROPSHEETPAGE WizPages;
    NCACCTINFO NcAcctInfo;


    WizPages = CreateWizardPages( &NcAcctInfo );
    if (!WizPages) {
        return FALSE;
    }

    //
    // create the property sheet
    //

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_WIZARD | PSH_USECALLBACK;
    psh.hwndParent = hDlg;
    psh.hInstance = MyhInstance;
    psh.pszIcon = NULL;
    psh.pszCaption = TEXT("NetCentric Internet Fax Account Wizard");
    psh.nPages = WizPageMaximum;
    psh.nStartPage = 0;
    psh.phpage = WizPages;
    psh.pfnCallback = WizardCallback;

    if (PropertySheet( &psh ) == -1) {
        return FALSE;
    }

    return TRUE;
}


BOOL CALLBACK
CommonDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PWIZPAGE WizPage;


    WizPage = (PWIZPAGE) GetWindowLong( hwnd, DWL_USER );

    switch( msg ) {
        case WM_INITDIALOG:
            SetWindowLong( hwnd, DWL_USER, (LONG) ((LPPROPSHEETPAGE) lParam)->lParam );
            WizPage = (PWIZPAGE) ((LPPROPSHEETPAGE) lParam)->lParam;
            SetWindowText( GetParent( hwnd ), TEXT("NetCentric Internet Fax Account Wizard") );
            break;

        case WM_NOTIFY:
            switch( ((LPNMHDR)lParam)->code ) {
                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(
                        GetParent(hwnd),
                        WizPage->ButtonState
                        );
                    SetWindowLong( hwnd, DWL_MSGRESULT, 0 );
                    break;
            }
            break;
    }

    if (WizPage && WizPage->DlgProc) {
        return WizPage->DlgProc( hwnd,  msg, wParam, lParam, WizPage->NcAcctInfo );
    }

    return FALSE;
}


BOOL CALLBACK
ServerNameDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LPNCACCTINFO NcAcctInfo
    )
{
    HCURSOR Hourglass;
    HCURSOR OldCursor;


    switch( message ) {
        case WM_INITDIALOG:
            SendDlgItemMessage( hDlg, IDC_SERVER_NAME, EM_SETLIMITTEXT, LT_SERVER_NAME, 0 );
            break;

        case WM_NOTIFY:
            switch( ((LPNMHDR)lParam)->code ) {
                case PSN_SETACTIVE:
                    break;

                case PSN_WIZNEXT:
                    if (!GetDlgItemTextA( hDlg, IDC_SERVER_NAME, NcAcctInfo->ServerName, LT_SERVER_NAME )) {
                        SetWindowLong( hDlg, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    //
                    // Get the POPserver name from the user (e.g., spop.server.net).  This
                    // will be used as the "initial" server for obtaining the list
                    // of Service Providers who offer the faxing service.
                    //
                    if (!NcAcctInfo->connInfo.SetHostName(NcAcctInfo->ServerName)) {
                        PopUpMsg( hDlg, IDS_BAD_SERVER, TRUE, 0 );
                        SetWindowLong( hDlg, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }

                    NcAcctInfo->connInfo.SetPortNumber( 80, FALSE );

                    //
                    // Tell the accountInfo about the connection object.  This
                    // CNcConnectionInfo object contains hostname/port/proxy/account
                    // information.
                    //
                    if (!NcAcctInfo->accountInfo.SetConnectionInfo(&NcAcctInfo->connInfo)) {
                        PopUpMsg( hDlg, IDS_BAD_SERVER, TRUE, 0 );
                        SetWindowLong( hDlg, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }

                    //
                    // get the isp list
                    //
                    Hourglass = LoadCursor( NULL, IDC_WAIT );
                    OldCursor = SetCursor( Hourglass );
                    if (!NcAcctInfo->accountInfo.GetAccountServers()) {
                        SetCursor( OldCursor );
                        PopUpMsg( hDlg, IDS_BAD_SERVER, TRUE, 0 );
                        SetWindowLong( hDlg, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    SetCursor( OldCursor );
                    break;

            }
            break;
    }

    return FALSE;
}

BOOL CALLBACK
IspDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LPNCACCTINFO NcAcctInfo
    )
{
    static HWND hwndList;
    static int SelectedIsp;
    const AccountInfoServer *pServer;
    AccountServerIndex serverLoopIndex;
    HIMAGELIST himlState;
    LV_ITEMA lvi;
    LV_COLUMN lvc = {0};
    int index;
    HCURSOR Hourglass;
    HCURSOR OldCursor;


    switch( message ) {
        case WM_INITDIALOG:
            hwndList = GetDlgItem( hDlg, IDC_ISP_LIST );

            SelectedIsp = 0;

            //
            // set/initialize the image list(s)
            //
            himlState = ImageList_Create( 16, 16, TRUE, 2, 0 );

            ImageList_AddMasked(
                himlState,
                LoadBitmap( MyhInstance, MAKEINTRESOURCE(IDB_CHECKSTATES) ),
                RGB (255,0,0)
                );

            ListView_SetImageList( hwndList, himlState, LVSIL_STATE );

            //
            // set/initialize the columns
            //
            lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
            lvc.fmt = LVCFMT_LEFT;
            lvc.cx = 250;
            lvc.pszText = L"Service Provider";
            lvc.iSubItem = 0;
            ListView_InsertColumn( hwndList, lvc.iSubItem, &lvc );
            break;

        case WM_NOTIFY:
            switch( ((LPNMHDR)lParam)->code ) {
                case PSN_SETACTIVE:
                    ListView_DeleteAllItems( hwndList );
                    serverLoopIndex = 0;
                    ZeroMemory( &lvi, sizeof(lvi) );
                    pServer = NcAcctInfo->accountInfo.GetFirstAccountServer(&serverLoopIndex);
                    while (pServer) {
                        lvi.pszText = pServer->description;
                        lvi.iItem += 1;
                        lvi.iSubItem = 0;
                        lvi.iImage = 0;
                        lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
                        lvi.state = lvi.iItem-1 == SelectedIsp ? LVIS_GCCHECK : LVIS_GCNOCHECK;
                        lvi.stateMask = LVIS_STATEIMAGEMASK;
                        SendMessageA( hwndList, LVM_INSERTITEMA, 0, (LPARAM) &lvi );
                        pServer = NcAcctInfo->accountInfo.GetNextAccountServer(&serverLoopIndex);
                    }
                    break;

                case PSN_WIZNEXT:
                    serverLoopIndex = 0;
                    index = 0;
                    pServer = NcAcctInfo->accountInfo.GetFirstAccountServer(&serverLoopIndex);
                    while (pServer && index != SelectedIsp) {
                        pServer = NcAcctInfo->accountInfo.GetNextAccountServer(&serverLoopIndex);
                        index += 1;
                    }
                    if (!pServer) {
                        PopUpMsg( hDlg, IDS_BAD_SERVER, TRUE, 0 );
                        SetWindowLong( hDlg, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    NcAcctInfo->pServer = pServer;

                    //
                    // Now use the selected server for our connectionInfo object.  This
                    // will be the server we use to create the actual account, for the
                    // selected ISP.  Once set in the CNcConnectionInfo object, set that
                    // connInfo object in the accountInfo.
                    //
                    if (!NcAcctInfo->connInfo.SetHostName( pServer->name )) {
                        PopUpMsg( hDlg, IDS_BAD_ISP, TRUE, 0 );
                        SetWindowLong( hDlg, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    if (!NcAcctInfo->accountInfo.SetConnectionInfo(&NcAcctInfo->connInfo)) {
                        PopUpMsg( hDlg, IDS_BAD_ISP, TRUE, 0 );
                        SetWindowLong( hDlg, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    //
                    // get the plan list
                    //
                    Hourglass = LoadCursor( NULL, IDC_WAIT );
                    OldCursor = SetCursor( Hourglass );
                    if (!NcAcctInfo->accountInfo.GetPlanInformation()) {
                        SetCursor( OldCursor );
                        PopUpMsg( hDlg, IDS_BAD_ISP, TRUE, 0 );
                        SetWindowLong( hDlg, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    SetCursor( OldCursor );
                    break;

                case NM_CLICK:
                    {
                        DWORD           dwpos;
                        LV_HITTESTINFO  lvhti;
                        int             iItemClicked;
                        UINT            state;

                        //
                        // Find out where the cursor was
                        //
                        dwpos = GetMessagePos();
                        lvhti.pt.x = LOWORD(dwpos);
                        lvhti.pt.y = HIWORD(dwpos);

                        MapWindowPoints( HWND_DESKTOP, hwndList, &lvhti.pt, 1 );

                        //
                        // Now do a hittest with this point.
                        //
                        iItemClicked = ListView_HitTest( hwndList, &lvhti );

                        if (lvhti.flags & LVHT_ONITEMSTATEICON) {

                            //
                            // Now lets get the state from the item and toggle it.
                            //

                            state = ListView_GetItemState(
                                hwndList,
                                iItemClicked,
                                LVIS_STATEIMAGEMASK
                                );

                            if (state == LVIS_GCCHECK) {
                                MessageBeep(0);
                                break;
                            }

                            state = (state == LVIS_GCNOCHECK) ? LVIS_GCCHECK : LVIS_GCNOCHECK;

                            ListView_SetItemState(
                                hwndList,
                                SelectedIsp,
                                LVIS_GCNOCHECK,
                                LVIS_STATEIMAGEMASK
                                );

                            ListView_SetItemState(
                                hwndList,
                                iItemClicked,
                                state,
                                LVIS_STATEIMAGEMASK
                                );

                            SelectedIsp = iItemClicked;
                        }


                    }

            }
            break;
    }

    return FALSE;
}

BOOL CALLBACK
PlansDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LPNCACCTINFO NcAcctInfo
    )
{
    static HWND hwndList;
    static int SelectedPlan;
    const AccountInfoPlan *pPlan;
    AccountPlanIndex planLoopIndex;
    HIMAGELIST himlState;
    LV_ITEMA lvi;
    LV_COLUMN lvc = {0};
    int index;


    switch( message ) {
        case WM_INITDIALOG:
            hwndList = GetDlgItem( hDlg, IDC_PLAN_LIST );

            SelectedPlan = 0;

            //
            // set/initialize the image list(s)
            //
            himlState = ImageList_Create( 16, 16, TRUE, 2, 0 );

            ImageList_AddMasked(
                himlState,
                LoadBitmap( MyhInstance, MAKEINTRESOURCE(IDB_CHECKSTATES) ),
                RGB (255,0,0)
                );

            ListView_SetImageList( hwndList, himlState, LVSIL_STATE );

            //
            // set/initialize the columns
            //
            lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
            lvc.fmt = LVCFMT_LEFT;
            lvc.cx = 250;
            lvc.pszText = L"Plans";
            lvc.iSubItem = 0;
            ListView_InsertColumn( hwndList, lvc.iSubItem, &lvc );
            break;

        case WM_NOTIFY:
            switch( ((LPNMHDR)lParam)->code ) {
                case PSN_SETACTIVE:
                    ListView_DeleteAllItems( hwndList );
                    planLoopIndex = 0;
                    ZeroMemory( &lvi, sizeof(lvi) );
                    pPlan = NcAcctInfo->accountInfo.GetFirstPlan(&planLoopIndex);
                    while (pPlan) {
                        lvi.pszText = pPlan->planDescription;
                        lvi.iItem += 1;
                        lvi.iSubItem = 0;
                        lvi.iImage = 0;
                        lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
                        lvi.state = lvi.iItem-1 == SelectedPlan ? LVIS_GCCHECK : LVIS_GCNOCHECK;
                        lvi.stateMask = LVIS_STATEIMAGEMASK;
                        SendMessageA( hwndList, LVM_INSERTITEMA, 0, (LPARAM) &lvi );
                        pPlan = NcAcctInfo->accountInfo.GetNextPlan(&planLoopIndex);
                    }
                    break;

                case PSN_WIZNEXT:
                    planLoopIndex = 0;
                    index = 0;
                    pPlan = NcAcctInfo->accountInfo.GetFirstPlan(&planLoopIndex);
                    while (pPlan && index != SelectedPlan) {
                        pPlan = NcAcctInfo->accountInfo.GetNextPlan(&planLoopIndex);
                        index += 1;
                    }
                    if (!pPlan) {
                        PopUpMsg( hDlg, IDS_BAD_SERVER, TRUE, 0 );
                        SetWindowLong( hDlg, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    NcAcctInfo->pPlan = pPlan;
                    break;

                case NM_CLICK:
                    {
                        DWORD           dwpos;
                        LV_HITTESTINFO  lvhti;
                        int             iItemClicked;
                        UINT            state;

                        //
                        // Find out where the cursor was
                        //
                        dwpos = GetMessagePos();
                        lvhti.pt.x = LOWORD(dwpos);
                        lvhti.pt.y = HIWORD(dwpos);

                        MapWindowPoints( HWND_DESKTOP, hwndList, &lvhti.pt, 1 );

                        //
                        // Now do a hittest with this point.
                        //
                        iItemClicked = ListView_HitTest( hwndList, &lvhti );

                        if (lvhti.flags & LVHT_ONITEMSTATEICON) {

                            //
                            // Now lets get the state from the item and toggle it.
                            //

                            state = ListView_GetItemState(
                                hwndList,
                                iItemClicked,
                                LVIS_STATEIMAGEMASK
                                );

                            if (state == LVIS_GCCHECK) {
                                MessageBeep(0);
                                break;
                            }

                            state = (state == LVIS_GCNOCHECK) ? LVIS_GCCHECK : LVIS_GCNOCHECK;

                            ListView_SetItemState(
                                hwndList,
                                SelectedPlan,
                                LVIS_GCNOCHECK,
                                LVIS_STATEIMAGEMASK
                                );

                            ListView_SetItemState(
                                hwndList,
                                iItemClicked,
                                state,
                                LVIS_STATEIMAGEMASK
                                );

                            SelectedPlan = iItemClicked;
                        }


                    }

            }
            break;
    }

    return FALSE;
}

BOOL CALLBACK
InfoDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LPNCACCTINFO NcAcctInfo
    )
{


    switch( message ) {
        case WM_INITDIALOG:
            SendDlgItemMessage( hDlg, IDC_FIRST_NAME,   EM_SETLIMITTEXT, LT_FIRST_NAME,   0 );
            SendDlgItemMessage( hDlg, IDC_LAST_NAME,    EM_SETLIMITTEXT, LT_LAST_NAME,    0 );
            SendDlgItemMessage( hDlg, IDC_ADDRESS,      EM_SETLIMITTEXT, LT_ADDRESS,      0 );
            SendDlgItemMessage( hDlg, IDC_CITY,         EM_SETLIMITTEXT, LT_CITY,         0 );
            SendDlgItemMessage( hDlg, IDC_STATE,        EM_SETLIMITTEXT, LT_STATE,        0 );
            SendDlgItemMessage( hDlg, IDC_ZIP,          EM_SETLIMITTEXT, LT_ZIP,          0 );
            break;

        case WM_NOTIFY:
            switch( ((LPNMHDR)lParam)->code ) {
                case PSN_SETACTIVE:
                    break;

                case PSN_WIZNEXT:
                    GetDlgItemTextA( hDlg, IDC_FIRST_NAME,   NcAcctInfo->FirstName,   LT_FIRST_NAME   );
                    GetDlgItemTextA( hDlg, IDC_LAST_NAME,    NcAcctInfo->LastName,    LT_LAST_NAME    );
                    GetDlgItemTextA( hDlg, IDC_ADDRESS,      NcAcctInfo->Address,     LT_ADDRESS      );
                    GetDlgItemTextA( hDlg, IDC_CITY,         NcAcctInfo->City,        LT_CITY         );
                    GetDlgItemTextA( hDlg, IDC_STATE,        NcAcctInfo->State,       LT_STATE        );
                    GetDlgItemTextA( hDlg, IDC_ZIP,          NcAcctInfo->Zip,         LT_ZIP          );

                    if (NcAcctInfo->FirstName[0] == 0 ||
                        NcAcctInfo->LastName[0] == 0 ||
                        NcAcctInfo->Address[0] == 0 ||
                        NcAcctInfo->City[0] == 0 ||
                        NcAcctInfo->State[0] == 0 ||
                        NcAcctInfo->Zip[0] == 0)
                    {
                        //
                        // all fields are required
                        // if we get here then the user forgot to
                        // enter data into one of the fields
                        //
                        PopUpMsg( hDlg, IDS_MISSING_INFO, TRUE, 0 );
                        SetWindowLong( hDlg, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
            }
            break;
    }

    return FALSE;
}


BOOL CALLBACK
Info2DlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LPNCACCTINFO NcAcctInfo
    )
{


    switch( message ) {
        case WM_INITDIALOG:
            SendDlgItemMessage( hDlg, IDC_EMAIL,        EM_SETLIMITTEXT, LT_EMAIL,        0 );
            SendDlgItemMessage( hDlg, IDC_PHONE_NUMBER, EM_SETLIMITTEXT, LT_PHONE_NUMBER, 0 );
            SendDlgItemMessage( hDlg, IDC_AREA_CODE,    EM_SETLIMITTEXT, LT_AREA_CODE,    0 );
            break;

        case WM_NOTIFY:
            switch( ((LPNMHDR)lParam)->code ) {
                case PSN_SETACTIVE:
                    break;

                case PSN_WIZNEXT:
                    GetDlgItemTextA( hDlg, IDC_EMAIL,        NcAcctInfo->Email,       LT_EMAIL        );
                    GetDlgItemTextA( hDlg, IDC_PHONE_NUMBER, NcAcctInfo->PhoneNumber, LT_PHONE_NUMBER );
                    GetDlgItemTextA( hDlg, IDC_AREA_CODE,    NcAcctInfo->AreaCode,    LT_AREA_CODE    );

                    if (NcAcctInfo->Email[0] == 0 ||
                        NcAcctInfo->PhoneNumber[0] == 0 ||
                        NcAcctInfo->AreaCode[0] == 0)
                    {
                        //
                        // all fields are required
                        // if we get here then the user forgot to
                        // enter data into one of the fields
                        //
                        PopUpMsg( hDlg, IDS_MISSING_INFO, TRUE, 0 );
                        SetWindowLong( hDlg, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }

                    if (!NcAcctInfo->accountOwner.SetFirstName( NcAcctInfo->FirstName ) ||
                        !NcAcctInfo->accountOwner.SetLastName( NcAcctInfo->LastName ) ||
                        !NcAcctInfo->accountOwner.SetEmail( NcAcctInfo->Email ) ||
                        !NcAcctInfo->accountOwner.SetFirstAddress( NcAcctInfo->Address ) ||
                        !NcAcctInfo->accountOwner.SetAddressZipcode( NcAcctInfo->Zip ) ||
                        !NcAcctInfo->accountOwner.SetPhoneNumber( "1", NcAcctInfo->AreaCode, NcAcctInfo->PhoneNumber, NULL ))
                    {
                        PopUpMsg( hDlg, IDS_MISSING_INFO, TRUE, 0 );
                        SetWindowLong( hDlg, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    break;

            }
            break;
    }

    return FALSE;
}


BOOL CALLBACK
AccountDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LPNCACCTINFO NcAcctInfo
    )
{
    switch( message ) {
        case WM_INITDIALOG:
            SendDlgItemMessage( hDlg, IDC_ACCOUNT_NAME, EM_SETLIMITTEXT, LT_ACCOUNT_NAME, 0 );
            SendDlgItemMessage( hDlg, IDC_PASSWORD,     EM_SETLIMITTEXT, LT_PASSWORD,     0 );
            break;

        case WM_NOTIFY:
            switch( ((LPNMHDR)lParam)->code ) {
                case PSN_SETACTIVE:
                    if (!NcAcctInfo->pPlan->passwordRequired) {
                        EnableWindow( GetDlgItem( hDlg, IDC_PASSWORD ), FALSE );
                    } else {
                        EnableWindow( GetDlgItem( hDlg, IDC_PASSWORD ), TRUE );
                    }
                    break;

                case PSN_WIZNEXT:
                    GetDlgItemTextA( hDlg, IDC_ACCOUNT_NAME, NcAcctInfo->AccountName, LT_ACCOUNT_NAME );
                    GetDlgItemTextA( hDlg, IDC_PASSWORD,     NcAcctInfo->Password,    LT_PASSWORD     );

                    if (NcAcctInfo->AccountName[0] == 0 ||
                        (NcAcctInfo->pPlan->passwordRequired && NcAcctInfo->Password[0] == 0))
                    {
                        PopUpMsg( hDlg, IDS_MISSING_ACCNT, TRUE, 0 );
                        SetWindowLong( hDlg, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    if (!NcAcctInfo->accountInfo.SetPassword( NcAcctInfo->Password )) {
                        PopUpMsg( hDlg, IDS_MISSING_ACCNT, TRUE, 0 );
                        SetWindowLong( hDlg, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    break;

            }
            break;
    }

    return FALSE;
}

BOOL CALLBACK
BillingDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LPNCACCTINFO NcAcctInfo
    )
{
    int i;


    switch( message ) {
        case WM_INITDIALOG:
            SendDlgItemMessage( hDlg, IDC_CREDIT_CARD, EM_SETLIMITTEXT, LT_CREDIT_CARD, 0 );
            SendDlgItemMessage( hDlg, IDC_EXPIRY_MM,   EM_SETLIMITTEXT, LT_EXPIRY_MM,   0 );
            SendDlgItemMessage( hDlg, IDC_EXPIRY_YY,   EM_SETLIMITTEXT, LT_EXPIRY_YY,   0 );
            SendDlgItemMessage( hDlg, IDC_CC_NAME,     EM_SETLIMITTEXT, LT_CC_NAME,     0 );

            for (i=IDS_CC_FIRST; i<IDS_CC_LAST; i++) {
                SendDlgItemMessage( hDlg, IDC_CC_LIST, CB_ADDSTRING, 0, (LPARAM) GetString( i ) );
                if (i == IDS_CC_VISA) {
                    SendDlgItemMessage( hDlg, IDC_CC_LIST, CB_SETCURSEL, i-IDS_CC_FIRST, 0 );
                }
            }

            break;

        case WM_NOTIFY:
            switch( ((LPNMHDR)lParam)->code ) {
                case PSN_SETACTIVE:
                    if (!NcAcctInfo->pPlan->paymentRequired) {
                        SetWindowLong( hDlg, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    break;

                case PSN_WIZNEXT:
                    GetDlgItemTextA( hDlg, IDC_CREDIT_CARD, NcAcctInfo->CreditCard, LT_CREDIT_CARD );
                    GetDlgItemTextA( hDlg, IDC_EXPIRY_MM,   NcAcctInfo->ExpiryMM,   LT_EXPIRY_MM   );
                    GetDlgItemTextA( hDlg, IDC_EXPIRY_YY,   NcAcctInfo->ExpiryYY,   LT_EXPIRY_YY   );
                    GetDlgItemTextA( hDlg, IDC_CC_NAME,     NcAcctInfo->CCName,     LT_CC_NAME     );
                    switch( SendDlgItemMessage( hDlg, IDC_CC_LIST, CB_GETCURSEL, 0, 0 )) {
                        case 0:
                            strcpy( NcAcctInfo->CCType, AMERICAN_EXPRESS );
                            break;

                        case 1:
                            strcpy( NcAcctInfo->CCType, DINERS_CLUB );
                            break;

                        case 2:
                            strcpy( NcAcctInfo->CCType, DISCOVER );
                            break;

                        case 3:
                            strcpy( NcAcctInfo->CCType, MASTER_CARD );
                            break;

                        case 4:
                            strcpy( NcAcctInfo->CCType, VISA );
                            break;
                    }
                    if (NcAcctInfo->CreditCard[0] == 0 ||
                        NcAcctInfo->ExpiryMM[0] == 0 ||
                        NcAcctInfo->ExpiryYY[0] == 0 ||
                        NcAcctInfo->CCName[0] == 0)
                    {
                        PopUpMsg( hDlg, IDS_MISSING_BILLING, TRUE, 0 );
                        SetWindowLong( hDlg, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    if (!NcAcctInfo->accountInfo.SetBillingUser(&NcAcctInfo->billingOwner) ||
                        !NcAcctInfo->accountInfo.SetCreditCardType( NcAcctInfo->CCType ) ||
                        !NcAcctInfo->accountInfo.SetCreditCardNumber( NcAcctInfo->CreditCard ) ||
                        !NcAcctInfo->accountInfo.SetCreditCardExpirationMM( NcAcctInfo->ExpiryMM ) ||
                        !NcAcctInfo->accountInfo.SetCreditCardExpirationYY( NcAcctInfo->ExpiryYY ) ||
                        !NcAcctInfo->accountInfo.SetCreditCardOwner( NcAcctInfo->CCName ))
                    {
                        PopUpMsg( hDlg, IDS_MISSING_BILLING, TRUE, 0 );
                        SetWindowLong( hDlg, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    break;

            }
            break;
    }

    return FALSE;
}


BOOL CALLBACK
CreateDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LPNCACCTINFO NcAcctInfo
    )
{
    HCURSOR Hourglass;
    HCURSOR OldCursor;

    switch( message ) {
        case WM_INITDIALOG:
            break;

        case WM_NOTIFY:
            switch( ((LPNMHDR)lParam)->code ) {
                case PSN_SETACTIVE:
                    break;

                case PSN_WIZNEXT:
                    Hourglass = LoadCursor( NULL, IDC_WAIT );
                    OldCursor = SetCursor( Hourglass );

                    if (!NcAcctInfo->accountInfo.SetOwner(&NcAcctInfo->accountOwner) ||
                        !NcAcctInfo->accountInfo.SetPlan(NcAcctInfo->pPlan) ||
                        !NcAcctInfo->accountInfo.SetAccountName( NcAcctInfo->AccountName ))
                    {
                        SetCursor( OldCursor );
                        PopUpMsg( hDlg, IDS_MISSING_BILLING, TRUE, 0 );
                        SetWindowLong( hDlg, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }

                    //
                    // Submit the new account information to the server.  If the server
                    // can create the account, the SubmitAccountInfo() function will
                    // return TRUE.  If the server rejects the information, FALSE will
                    // be returned.  The error printed out will describe what went
                    // wrong, from unable to communicate with server to invalid
                    // account information.  For example, the server would tell
                    // the calling application that the accountName has already been
                    // taken.
                    //

                    if (!NcAcctInfo->accountInfo.SubmitAccountInfo()) {
                        CHAR buffer[256]; UINT size=sizeof(buffer);
                        SetCursor( OldCursor );
                        NcAcctInfo->accountInfo.GetLastErrorString(buffer, &size);
                        PopUpMsgString( hDlg, buffer, TRUE, 0 );
                        SetWindowLong( hDlg, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }

                    SetCursor( OldCursor );
                    break;

            }
            break;
    }

    return FALSE;
}


BOOL CALLBACK
FinishDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LPNCACCTINFO NcAcctInfo
    )
{
    switch( message ) {
        case WM_INITDIALOG:
            break;

        case WM_NOTIFY:
            switch( ((LPNMHDR)lParam)->code ) {
                case PSN_SETACTIVE:
                    break;

                case PSN_WIZNEXT:
                    break;

            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\ncfsp\config.cpp ===
#include "nc.h"
#pragma hdrstop


BOOL
CreateNewAccount(
    HWND hDlg
    );



extern "C"
LRESULT CALLBACK
FaxDevDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static BOOL IgnoreChange = FALSE;
    LPNMHDR pNMHdr;
    WCHAR Buffer[4096];


    switch( message ) {
        case WM_INITDIALOG:
            break;

        case WM_COMMAND:
            if (HIWORD(wParam) == EN_CHANGE && !IgnoreChange) {
                PropSheet_Changed( GetParent(hwnd), hwnd );
            }
            if (HIWORD(wParam) == BN_CLICKED) {
                CreateNewAccount( hwnd );
            }
            break;

        case WM_NOTIFY:
            pNMHdr = (LPNMHDR) lParam;
            switch (pNMHdr->code) {
                case PSN_SETACTIVE:
                    IgnoreChange = TRUE;
                    SetDlgItemText( hwnd, IDC_SERVER,   ConfigData.ServerName );
                    SetDlgItemText( hwnd, IDC_USERNAME, ConfigData.UserName   );
                    SetDlgItemText( hwnd, IDC_PASSWORD, ConfigData.Password   );
                    IgnoreChange = FALSE;
                    break;

                case PSN_APPLY:
                    GetDlgItemText( hwnd, IDC_SERVER, Buffer, sizeof(Buffer)/sizeof(WCHAR) );
                    MemFree( ConfigData.ServerName );
                    ConfigData.ServerName = StringDup( Buffer );

                    GetDlgItemText( hwnd, IDC_USERNAME, Buffer, sizeof(Buffer)/sizeof(WCHAR) );
                    MemFree( ConfigData.UserName );
                    ConfigData.UserName = StringDup( Buffer );

                    GetDlgItemText( hwnd, IDC_PASSWORD, Buffer, sizeof(Buffer)/sizeof(WCHAR) );
                    MemFree( ConfigData.Password );
                    ConfigData.Password = StringDup( Buffer );

                    SetNcConfig( &ConfigData );

                    PropSheet_UnChanged( GetParent(hwnd), hwnd );

                    break;
            }
            break;

        case WM_HELP:
        case WM_CONTEXTMENU:
            break;
    }

    return FALSE;
}


BOOL WINAPI
FaxDevConfigure(
    OUT HPROPSHEETPAGE *PropSheetPage
    )
{
    PROPSHEETPAGE psp;


    if (MyHeapHandle == NULL) {
        MyHeapHandle = GetProcessHeap();
        HeapInitialize( MyHeapHandle, NULL, NULL, 0 );
        InitCommonControls();
        InitializeStringTable();
        GetNcConfig( &ConfigData );
    }

    psp.dwSize      = sizeof(PROPSHEETPAGE);
    psp.dwFlags     = PSP_DEFAULT;
    psp.hInstance   = MyhInstance;
    psp.pszTemplate = MAKEINTRESOURCE( IDD_CONFIG );
    psp.hIcon       = NULL;
    psp.pszTitle    = NULL;
    psp.pfnDlgProc  = (DLGPROC) FaxDevDlgProc;
    psp.lParam      = 0;
    psp.pfnCallback = NULL;
    psp.pcRefParent = NULL;

    *PropSheetPage = CreatePropertySheetPage( &psp );

    return *PropSheetPage != NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\ncfsp\mem.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    mem.c

Abstract:

    This file implements memory allocation functions for fax.

Author:

    Wesley Witt (wesw) 23-Jan-1995

Environment:

    User Mode

--*/

#include "nc.h"



HANDLE hHeap;
DWORD HeapFlags;
PMEMALLOC pMemAllocUser;
PMEMFREE pMemFreeUser;


#ifdef FAX_HEAP_DEBUG
LIST_ENTRY HeapHeader;
ULONG TotalMemory;
ULONG MaxTotalMemory;
ULONG MaxTotalAllocs;
VOID PrintAllocations(VOID);
ULONG TotalAllocs;
CRITICAL_SECTION CsHeap;
#endif



BOOL
HeapExistingInitialize(
    HANDLE hExistHeap
    )
{

#ifdef FAX_HEAP_DEBUG
    InitializeListHead( &HeapHeader );
    MaxTotalMemory = 0;
    MaxTotalAllocs = 0;
    InitializeCriticalSection( &CsHeap );
#endif

    if (!hExistHeap) {
        return FALSE;
    }
    else {
        hHeap = hExistHeap;
        return TRUE;
    }

}


HANDLE
HeapInitialize(
    HANDLE hHeapUser,
    PMEMALLOC pMemAlloc,
    PMEMFREE pMemFree,
    DWORD Flags
    )
{

#ifdef FAX_HEAP_DEBUG
    InitializeListHead( &HeapHeader );
    MaxTotalMemory = 0;
    MaxTotalAllocs = 0;
    InitializeCriticalSection( &CsHeap );
#endif

    HeapFlags = Flags;

    if (pMemAlloc && pMemFree) {
        pMemAllocUser = pMemAlloc;
        pMemFreeUser = pMemFree;
    } else {
        if (hHeapUser) {
            hHeap = hHeapUser;
        } else {
            hHeap = HeapCreate( 0, HEAP_SIZE, 0 );
        }
        if (!hHeap) {
            return NULL;
        }
    }

    return hHeap;
}

BOOL
HeapCleanup(
    VOID
    )
{
#ifdef FAX_HEAP_DEBUG
    PrintAllocations();
#endif
    HeapDestroy( hHeap );
    return TRUE;
}

#ifdef FAX_HEAP_DEBUG
VOID
pCheckHeap(
    PVOID MemPtr,
    ULONG Line,
    LPSTR File
    )
{
    HeapValidate( hHeap, 0, MemPtr );
}
#endif

PVOID
pMemAlloc(
    ULONG AllocSize
#ifdef FAX_HEAP_DEBUG
    , ULONG Line,
    LPSTR File
#endif
    )
{
    PVOID MemPtr;
#ifdef FAX_HEAP_DEBUG
    PHEAP_BLOCK hb;
#ifdef UNICODE
    WCHAR fname[MAX_PATH];
#endif
    LPWSTR p = NULL;
    if (pMemAllocUser) {
        hb = (PHEAP_BLOCK) pMemAllocUser( AllocSize + sizeof(HEAP_BLOCK) );
    } else {
        hb = (PHEAP_BLOCK) HeapAlloc( hHeap, HEAP_ZERO_MEMORY, AllocSize + sizeof(HEAP_BLOCK) );
    }
    if (hb) {
        TotalAllocs += 1;
        TotalMemory += AllocSize;
        if (TotalMemory > MaxTotalMemory) {
            MaxTotalMemory = TotalMemory;
        }
        if (TotalAllocs > MaxTotalAllocs) {
            MaxTotalAllocs = TotalAllocs;
        }
        EnterCriticalSection( &CsHeap );
        InsertTailList( &HeapHeader, &hb->ListEntry );
        hb->Signature = HEAP_SIG;
        hb->Size = AllocSize;
        hb->Line = Line;
#ifdef UNICODE
        MultiByteToWideChar(
            CP_ACP,
            MB_PRECOMPOSED,
            File,
            -1,
            fname,
            sizeof(fname)/sizeof(WCHAR)
            );
        p = wcsrchr( fname, L'\\' );
        if (p) {
            wcscpy( hb->File, p+1 );
        }
#else
        p = strrchr( File, '\\' );
        if (p) {
            strcpy( hb->File, p+1 );
        }
#endif
        MemPtr = (PVOID) ((PUCHAR)hb + sizeof(HEAP_BLOCK));
        LeaveCriticalSection( &CsHeap );
    } else {
        MemPtr = NULL;
    }
#else
    if (pMemAllocUser) {
        MemPtr = (PVOID) pMemAllocUser( AllocSize );
    } else {
        MemPtr = (PVOID) HeapAlloc( hHeap, HEAP_ZERO_MEMORY, AllocSize );
    }
#endif

    if (!MemPtr) {
        DebugPrint(( L"MemAlloc() failed, size=%d", AllocSize ));
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
    }

    return MemPtr;
}

VOID
pMemFreeForHeap(
    HANDLE hHeap,
    PVOID MemPtr
#ifdef FAX_HEAP_DEBUG
    , ULONG Line,
    LPSTR File
#endif
    )
{
#ifdef FAX_HEAP_DEBUG
    PHEAP_BLOCK hb;
    if (!MemPtr) {
        return;
    }
    hb = (PHEAP_BLOCK) ((PUCHAR)MemPtr - sizeof(HEAP_BLOCK));
    if (hb->Signature == HEAP_SIG) {
        EnterCriticalSection( &CsHeap );
        RemoveEntryList( &hb->ListEntry );
        TotalMemory -= hb->Size;
        TotalAllocs -= 1;
    } else {
        if (HeapFlags & HEAPINIT_NO_VALIDATION) {
            hb = (PHEAP_BLOCK) MemPtr;
            EnterCriticalSection( &CsHeap );
        } else {
            dprintf( L"MemFree(): Corrupt heap block" );
            PrintAllocations();
            __try {
                DebugBreak();
            } __except (UnhandledExceptionFilter(GetExceptionInformation())) {
                // Nothing to do in here.
            }
        }
    }
    if (pMemFreeUser) {
        pMemFreeUser( (PVOID) hb );
    } else {
        HeapFree( hHeap, 0, (PVOID) hb );
    }
    LeaveCriticalSection( &CsHeap );
#else
    if (!MemPtr) {
        return;
    }
    if (pMemFreeUser) {
        pMemFreeUser( (PVOID) MemPtr );
    } else {
        HeapFree( hHeap, 0, (PVOID) MemPtr );
    }
#endif
}

VOID
pMemFree(
    PVOID MemPtr
#ifdef FAX_HEAP_DEBUG
    , ULONG Line,
    LPSTR File
#endif
    )
{
#ifdef FAX_HEAP_DEBUG
    pMemFreeForHeap( hHeap, MemPtr, Line, File );
#else
    pMemFreeForHeap( hHeap, MemPtr );
#endif
}

#ifdef FAX_HEAP_DEBUG
VOID
PrintAllocations(
    VOID
    )
{
    PLIST_ENTRY                 Next;
    PHEAP_BLOCK                 hb;
    LPWSTR                      s;


    dprintf( L"-------------------------------------------------------------------------------------------------------" );
    dprintf( L"Memory Allocations for Heap 0x%08x, Allocs=%d, MaxAllocs=%d, TotalMem=%d, MaxTotalMem=%d",\
                 hHeap, TotalAllocs, MaxTotalAllocs, TotalMemory, MaxTotalMemory );
    dprintf( L"-------------------------------------------------------------------------------------------------------" );

    Next = HeapHeader.Flink;
    if (Next == NULL || TotalAllocs == 0) {
        return;
    }

    while ((ULONG)Next != (ULONG)&HeapHeader) {
        hb = CONTAINING_RECORD( Next, HEAP_BLOCK, ListEntry );
        Next = hb->ListEntry.Flink;
        s = (LPWSTR) ((PUCHAR)hb + sizeof(HEAP_BLOCK));
        dprintf( L"%8d %16s @ %5d    0x%08x", hb->Size, hb->File, hb->Line, s );
        if (!(HeapFlags & HEAPINIT_NO_STRINGS)) {
            dprintf( L" \"%s\"", s );
        }
    }

    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\ncfsp\nc.h ===
#include <windows.h>
#include <commctrl.h>
#include <tapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#include <faxdev.h>
//#include <faxutil.h>
#include "resource.h"

#include <ncfiles.h>
#include <ncutils.h>
#include <user.hpp>
#include <conn.hpp>
#include <ncstatus.h>
#include <ncmsg.h>
#include <fax.hpp>
#include <acct.hpp>


#define StringSize(_s)      (( _s ) ? (_tcslen( _s ) + 1) * sizeof(TCHAR) : 0)

#define REGKEY_PROVIDER     L"Software\\Microsoft\\Fax\\Device Providers\\NetCentric"
#define   REGVAL_SERVER     L"Server"
#define   REGVAL_USERNAME   L"UserName"
#define   REGVAL_PASSWORD   L"Password"

#define JobInfo(_fh)        ((PJOB_INFO)(_fh))

#define NCFAX_ID            "Micsosoft Personal Fax for Windows"
#define NCFAX_CLIENTID      0
#define NCFAX_MAJOR         0
#define NCFAX_MINOR         9
#define NCFAX_RELEASE       1
#define NCFAX_PATCH         13
#define PRODUCTION_KEY      "Microsoft"

#define TAPI_VERSION        0x00020000

#define LT_SERVER_NAME      64
#define LT_FIRST_NAME       64
#define LT_LAST_NAME        64
#define LT_EMAIL            64
#define LT_AREA_CODE        64
#define LT_PHONE_NUMBER     64
#define LT_ADDRESS          64
#define LT_CITY             64
#define LT_STATE             2
#define LT_ZIP              11
#define LT_ACCOUNT_NAME     64
#define LT_PASSWORD         64
#define LT_CREDIT_CARD      64
#define LT_EXPIRY_MM        64
#define LT_EXPIRY_YY        64
#define LT_CC_NAME          64


#define LVIS_GCNOCHECK      0x1000
#define LVIS_GCCHECK        0x2000




#define IS_DONE_STATUS(code) \
    (((code) != ST_STATUS_QUEUED) && \
     ((code) != ST_STATUS_PENDING) && \
     ((code) != ST_STATUS_ACTIVE))

typedef struct _JOB_INFO {
    CNcFaxJob           *faxJob;
    CNcConnectionInfo   *connInfo;
    CNcUser             *sender;
    CNcUser             *recipient;
    HLINE               LineHandle;
    DWORD               DeviceId;
    HANDLE              CompletionPortHandle;
    DWORD               CompletionKey;
    LONG                ServerId;
    LONG                JobId;
} JOB_INFO, *PJOB_INFO;

typedef struct _CONFIG_DATA {
    LPWSTR              ServerName;
    LPWSTR              UserName;
    LPWSTR              Password;
} CONFIG_DATA, *PCONFIG_DATA;



extern HANDLE      MyHeapHandle;
extern HINSTANCE   MyhInstance;
extern CONFIG_DATA ConfigData;



BOOL
GetNcConfig(
    PCONFIG_DATA ConfigData
    );

BOOL
SetNcConfig(
    PCONFIG_DATA ConfigData
    );

VOID
InitializeStringTable(
    VOID
    );

LPWSTR
GetString(
    DWORD ResourceId
    );

int
PopUpMsg(
    HWND hwnd,
    DWORD ResourceId,
    BOOL Error,
    DWORD Type
    );

BOOL
ParsePhoneNumber(
    LPWSTR PhoneNumber,
    LPSTR *CountryCode,
    LPSTR *AreaCode,
    LPSTR *SubscriberNumber
    );

int
PopUpMsgString(
    HWND hwnd,
    LPSTR String,
    BOOL Error,
    DWORD Type
    );

LPWSTR
AnsiStringToUnicodeString(
    LPSTR AnsiString
    );

LPSTR
UnicodeStringToAnsiString(
    LPWSTR UnicodeString
    );

LPWSTR
StringDup(
    LPWSTR String
    );

//
// debugging information
//

#if DBG
#define Assert(exp)         if(!(exp)) {AssertError(TEXT(#exp),TEXT(__FILE__),__LINE__);}
#define DebugPrint(_x_)     dprintf _x_
#else
#define Assert(exp)
#define DebugPrint(_x_)
#endif

extern BOOL ConsoleDebugOutput;

void
dprintf(
    LPTSTR Format,
    ...
    );

VOID
AssertError(
    LPTSTR Expression,
    LPTSTR File,
    ULONG  LineNumber
    );

//
// memory allocation
//

#define HEAP_SIZE   (1024*1024)

#ifdef FAX_HEAP_DEBUG
#define HEAP_SIG 0x69696969
typedef struct _HEAP_BLOCK {
    LIST_ENTRY  ListEntry;
    ULONG       Signature;
    ULONG       Size;
    ULONG       Line;
#ifdef UNICODE
    WCHAR       File[22];
#else
    CHAR        File[20];
#endif
} HEAP_BLOCK, *PHEAP_BLOCK;

#define MemAlloc(s)          pMemAlloc(s,__LINE__,__FILE__)
#define MemFree(p)           pMemFree(p,__LINE__,__FILE__)
#define MemFreeForHeap(h,p)  pMemFreeForHeap(h,p,__LINE__,__FILE__)
#define CheckHeap(p)         pCheckHeap(p,__LINE__,__FILE__)
#else
#define MemAlloc(s)          pMemAlloc(s)
#define MemFree(p)           pMemFree(p)
#define MemFreeForHeap(h,p)  pMemFreeForHeap(h,p)
#define CheckHeap(p)
#endif

typedef LPVOID (WINAPI *PMEMALLOC) (DWORD);
typedef VOID   (WINAPI *PMEMFREE)  (LPVOID);

#define HEAPINIT_NO_VALIDATION      0x00000001
#define HEAPINIT_NO_STRINGS         0x00000002


HANDLE
HeapInitialize(
    HANDLE hHeap,
    PMEMALLOC pMemAlloc,
    PMEMFREE pMemFree,
    DWORD Flags
    );

BOOL
HeapExistingInitialize(
    HANDLE hExistHeap
    );

BOOL
HeapCleanup(
    VOID
    );

#ifdef FAX_HEAP_DEBUG
VOID
pCheckHeap(
    PVOID MemPtr,
    ULONG Line,
    LPSTR File
    );

VOID
PrintAllocations(
    VOID
    );

#else

#define PrintAllocations()

#endif

PVOID
pMemAlloc(
    ULONG AllocSize
#ifdef FAX_HEAP_DEBUG
    ,ULONG Line
    ,LPSTR File
#endif
    );

VOID
pMemFree(
    PVOID MemPtr
#ifdef FAX_HEAP_DEBUG
    ,ULONG Line
    ,LPSTR File
#endif
    );

VOID
pMemFreeForHeap(
    HANDLE hHeap,
    PVOID MemPtr
#ifdef FAX_HEAP_DEBUG
    ,ULONG Line
    ,LPSTR File
#endif
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\ncfsp\registry.cpp ===
#include "nc.h"
#pragma hdrstop






BOOL
GetNcConfig(
    PCONFIG_DATA ConfigData
    )
{
    HKEY hKey;
    LONG rVal;
    DWORD RegType;
    DWORD RegSize;
    WCHAR Buffer[4096];


    rVal = RegCreateKey(
        HKEY_LOCAL_MACHINE,
        REGKEY_PROVIDER,
        &hKey
        );
    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( TEXT("could not create/open registry key") ));
        return FALSE;
    }

    RegSize = sizeof(Buffer);

    rVal = RegQueryValueEx(
        hKey,
        REGVAL_SERVER,
        0,
        &RegType,
        (LPBYTE) Buffer,
        &RegSize
        );
    if (rVal == ERROR_SUCCESS) {
        ConfigData->ServerName = StringDup( Buffer );
    } else {
        ConfigData->ServerName = NULL;
    }

    RegSize = sizeof(Buffer);

    rVal = RegQueryValueEx(
        hKey,
        REGVAL_USERNAME,
        0,
        &RegType,
        (LPBYTE) Buffer,
        &RegSize
        );
    if (rVal == ERROR_SUCCESS) {
        ConfigData->UserName = StringDup( Buffer );
    } else {
        ConfigData->UserName = NULL;
    }

    RegSize = sizeof(Buffer);

    rVal = RegQueryValueEx(
        hKey,
        REGVAL_PASSWORD,
        0,
        &RegType,
        (LPBYTE) Buffer,
        &RegSize
        );
    if (rVal == ERROR_SUCCESS) {
        ConfigData->Password = StringDup( Buffer );
    } else {
        ConfigData->Password = NULL;
    }

    RegCloseKey( hKey );

    return TRUE;
}


BOOL
SetNcConfig(
    PCONFIG_DATA ConfigData
    )
{
    HKEY hKey;
    LONG rVal;


    rVal = RegCreateKey(
        HKEY_LOCAL_MACHINE,
        REGKEY_PROVIDER,
        &hKey
        );
    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( TEXT("could not create/open registry key") ));
        return FALSE;
    }

    rVal = RegSetValueEx(
        hKey,
        REGVAL_SERVER,
        0,
        REG_SZ,
        (LPBYTE) ConfigData->ServerName,
        StringSize( ConfigData->ServerName )
        );

    rVal = RegSetValueEx(
        hKey,
        REGVAL_USERNAME,
        0,
        REG_SZ,
        (LPBYTE) ConfigData->UserName,
        StringSize( ConfigData->UserName )
        );

    rVal = RegSetValueEx(
        hKey,
        REGVAL_PASSWORD,
        0,
        REG_SZ,
        (LPBYTE) ConfigData->Password,
        StringSize( ConfigData->Password )
        );

    RegCloseKey( hKey );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\ncfsp\resource.h ===
//
// misc
//

#define WIZARD_WIDTH           276
#define WIZARD_HEIGTH          140

#define IDC_STATIC              -1

//
// icons
//

#define IDI_NETCENTRIC          501

//
// bitmaps
//

#define IDB_INET                701
#define IDB_WORLD               702
#define IDB_INETWRLD            703
#define IDB_CHECKSTATES         704

//
// dialogs
//

#define IDD_CONFIG              601
#define IDD_SERVER_NAME_PAGE    602
#define IDD_INFO_PAGE           603
#define IDD_ACCT_PAGE           604
#define IDD_BILLING_PAGE        605
#define IDD_ISP_PAGE            606
#define IDD_PLANS_PAGE          607
#define IDD_FINISH_PAGE         608
#define IDD_CREATE_PAGE         609
#define IDD_INFO2_PAGE          610

//
// controls
//

#define IDC_SERVER              101
#define IDC_USERNAME            102
#define IDC_PASSWORD            103
#define IDC_NEW_ACCOUNT         104
#define IDC_FIRST_NAME          105
#define IDC_LAST_NAME           106
#define IDC_EMAIL               107
#define IDC_PHONE_NUMBER        108
#define IDC_ADDRESS             109
#define IDC_CITY                110
#define IDC_ACCOUNT_NAME        111
#define IDC_CREDIT_CARD         112
#define IDC_EXPIRY_MM           113
#define IDC_CC_NAME             114
#define IDC_SERVER_NAME         115
#define IDC_WORLDBMP            116
#define IDC_INETBMP             117
#define IDC_INETWRLDBMP         118
#define IDC_ISP_LIST            119
#define IDC_PLAN_LIST           120
#define IDC_EXPIRY_YY           121
#define IDC_CC_LIST             122
#define IDC_STATE               123
#define IDC_ZIP                 124
#define IDC_AREA_CODE           125

//
// strings
//

#define IDS_TITLE               201
#define IDS_ERR_TITLE           202
#define IDS_WRN_TITLE           203
#define IDS_BAD_SERVER          204
#define IDS_BAD_ISP             205
#define IDS_MISSING_INFO        206
#define IDS_MISSING_ACCNT       207
#define IDS_MISSING_BILLING     208
#define IDS_CC_FIRST            209
#define IDS_CC_AMEX             209
#define IDS_CC_DINERS           210
#define IDS_CC_DISCOVER         211
#define IDS_CC_MASTERCARD       212
#define IDS_CC_VISA             213
#define IDS_CC_LAST             214
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\ncfsp\util.cpp ===
#include "nc.h"
#pragma hdrstop

typedef struct _STRING_TABLE {
    DWORD   ResourceId;
    BOOL    UseTitle;
    LPWSTR  String;
} STRING_TABLE, *PSTRING_TABLE;


static STRING_TABLE StringTable[] =
{
    { IDS_TITLE,                             FALSE,      NULL },
    { IDS_ERR_TITLE,                         TRUE,       NULL },
    { IDS_WRN_TITLE,                         TRUE,       NULL },
    { IDS_BAD_SERVER,                        FALSE,      NULL },
    { IDS_MISSING_INFO,                      FALSE,      NULL },
    { IDS_MISSING_ACCNT,                     FALSE,      NULL },
    { IDS_MISSING_BILLING,                   FALSE,      NULL },
    { IDS_CC_AMEX,                           FALSE,      NULL },
    { IDS_CC_DINERS,                         FALSE,      NULL },
    { IDS_CC_DISCOVER,                       FALSE,      NULL },
    { IDS_CC_MASTERCARD,                     FALSE,      NULL },
    { IDS_CC_VISA,                           FALSE,      NULL },
    { IDS_BAD_ISP,                           FALSE,      NULL }
};

#define CountStringTable (sizeof(StringTable)/sizeof(STRING_TABLE))


VOID
InitializeStringTable(
    VOID
    )
{
    DWORD i;
    WCHAR Buffer[512];


    for (i=0; i<CountStringTable; i++) {

        if (LoadString(
            MyhInstance,
            StringTable[i].ResourceId,
            Buffer,
            sizeof(Buffer)/sizeof(WCHAR)
            )) {

            StringTable[i].String = (LPWSTR) MemAlloc( StringSize( Buffer ) + 256 );
            if (!StringTable[i].String) {
                StringTable[i].String = L"";
            } else {
                if (StringTable[i].UseTitle) {
                    swprintf( StringTable[i].String, Buffer, StringTable[0].String );
                } else {
                    wcscpy( StringTable[i].String, Buffer );
                }
            }

        } else {

            StringTable[i].String = L"";

        }
    }
}


LPWSTR
GetString(
    DWORD ResourceId
    )
{
    DWORD i;

    for (i=0; i<CountStringTable; i++) {
        if (StringTable[i].ResourceId == ResourceId) {
            return StringTable[i].String;
        }
    }

    return NULL;
}


int
PopUpMsg(
    HWND hwnd,
    DWORD ResourceId,
    BOOL Error,
    DWORD Type
    )
{
    return MessageBox(
        hwnd,
        GetString( ResourceId ),
        GetString( Error ? IDS_ERR_TITLE : IDS_WRN_TITLE ),
        MB_SETFOREGROUND | (Error ? MB_ICONEXCLAMATION : MB_ICONINFORMATION) | (Type == 0 ? MB_OK : Type)
        );
}


int
PopUpMsgString(
    HWND hwnd,
    LPSTR String,
    BOOL Error,
    DWORD Type
    )
{
    int Rslt = 0;

    LPWSTR StringW = AnsiStringToUnicodeString( String );
    if (!StringW) {
        return 0;
    }

    Rslt = MessageBox(
        hwnd,
        StringW,
        GetString( Error ? IDS_ERR_TITLE : IDS_WRN_TITLE ),
        MB_SETFOREGROUND | (Error ? MB_ICONEXCLAMATION : MB_ICONINFORMATION) | (Type == 0 ? MB_OK : Type)
        );

    MemFree( StringW );

    return Rslt;
}


LPTSTR
StringDup(
    LPTSTR String
    )
{
    LPTSTR NewString;

    if (!String) {
        return NULL;
    }

    NewString = (LPTSTR) MemAlloc( (_tcslen( String ) + 1) * sizeof(TCHAR) );
    if (!NewString) {
        return NULL;
    }

    _tcscpy( NewString, String );

    return NewString;
}


LPSTR
UnicodeStringToAnsiString(
    LPWSTR UnicodeString
    )
{
    DWORD Count;
    LPSTR AnsiString;


    //
    // first see how big the buffer needs to be
    //
    Count = WideCharToMultiByte(
        CP_ACP,
        0,
        UnicodeString,
        -1,
        NULL,
        0,
        NULL,
        NULL
        );

    //
    // i guess the input string is empty
    //
    if (!Count) {
        return NULL;
    }

    //
    // allocate a buffer for the unicode string
    //
    Count += 1;
    AnsiString = (LPSTR) MemAlloc( Count );
    if (!AnsiString) {
        return NULL;
    }

    //
    // convert the string
    //
    Count = WideCharToMultiByte(
        CP_ACP,
        0,
        UnicodeString,
        -1,
        AnsiString,
        Count,
        NULL,
        NULL
        );

    //
    // the conversion failed
    //
    if (!Count) {
        MemFree( AnsiString );
        return NULL;
    }

    return AnsiString;
}


LPWSTR
AnsiStringToUnicodeString(
    LPSTR AnsiString
    )
{
    DWORD Count;
    LPWSTR UnicodeString;


    //
    // first see how big the buffer needs to be
    //
    Count = MultiByteToWideChar(
        CP_ACP,
        MB_PRECOMPOSED,
        AnsiString,
        -1,
        NULL,
        0
        );

    //
    // i guess the input string is empty
    //
    if (!Count) {
        return NULL;
    }

    //
    // allocate a buffer for the unicode string
    //
    Count += 1;
    UnicodeString = (LPWSTR) MemAlloc( Count * sizeof(UNICODE_NULL) );
    if (!UnicodeString) {
        return NULL;
    }

    //
    // convert the string
    //
    Count = MultiByteToWideChar(
        CP_ACP,
        MB_PRECOMPOSED,
        AnsiString,
        -1,
        UnicodeString,
        Count
        );

    //
    // the conversion failed
    //
    if (!Count) {
        MemFree( UnicodeString );
        return NULL;
    }

    return UnicodeString;
}


void
dprintf(
    LPTSTR Format,
    ...
    )

/*++

Routine Description:

    Prints a debug string

Arguments:

    format      - printf() format string
    ...         - Variable data

Return Value:

    None.

--*/

{
    TCHAR buf[1024];
    DWORD len;
    static TCHAR AppName[16];
    va_list arg_ptr;
    SYSTEMTIME CurrentTime;


    if (AppName[0] == 0) {
        if (GetModuleFileName( NULL, buf, sizeof(buf) )) {
            _tsplitpath( buf, NULL, NULL, AppName, NULL );
        }
    }

    va_start(arg_ptr, Format);

    GetLocalTime( &CurrentTime );
    _stprintf( buf, TEXT("%x   %02d:%02d:%02d.%03d  %s: "),
        GetCurrentThreadId(),
        CurrentTime.wHour,
        CurrentTime.wMinute,
        CurrentTime.wSecond,
        CurrentTime.wMilliseconds,
        AppName[0] ? AppName : TEXT("")
        );
    len = _tcslen( buf );

    _vsntprintf(&buf[len], sizeof(buf)-len, Format, arg_ptr);

    len = _tcslen( buf );
    if (buf[len-1] != TEXT('\n')) {
        buf[len] = TEXT('\r');
        buf[len+1] = TEXT('\n');
        buf[len+2] = 0;
    }

    OutputDebugString( buf );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\newfsp\macros.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  macros.h

Abstract:

  This module contains the global macros

--*/

#ifndef _MACROS_H
#define _MACROS_H

HANDLE  g_HeapHandle;  // g_HeapHandle is the global handle to the heap

// MemInitializeMacro is a macro to get the handle to the heap
#define MemInitializeMacro(hHeap) (g_HeapHandle = hHeap)

// MemAllocMacro is a macro to allocate dwBytes bytes of memory from the heap
#define MemAllocMacro(dwBytes) (HeapAlloc(g_HeapHandle, HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, dwBytes))

// MemReAllocMacro is a macro to reallocate dwBytes bytes of memory from the heap
#define MemReAllocMacro(lpMem, dwBytes) (HeapReAlloc(g_HeapHandle, HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, lpMem, dwBytes))

// MemFreeMacro is a macro to free a memory block allocated from the heap
#define MemFreeMacro(lpMem) (HeapFree(g_HeapHandle, 0, lpMem))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\ncfsp\netcntrc.cpp ===
#include "nc.h"
#pragma hdrstop

HANDLE      MyHeapHandle;
HINSTANCE   MyhInstance;
HLINEAPP    MyLineAppHandle;
CONFIG_DATA ConfigData;



void
FaxDevPrintErrorMsg(
    HANDLE FaxHandle,
    LPTSTR Format,
    ...
    )
{
#if DBG
    NcSTHandle status = NULL;
    ULONG statusCode;
    CHAR errorString[256];
    size_t Size;
    LPWSTR p;
    TCHAR buf[1024];
    va_list arg_ptr;



    status = STCreateFaxStatusObject( JobInfo(FaxHandle)->ServerId, JobInfo(FaxHandle)->JobId );
    STSetConnectionInfo( status, JobInfo(FaxHandle)->connInfo );
    statusCode = STGetLastError( status );
    STGetLastErrorString( status, errorString, &Size );
    p = AnsiStringToUnicodeString( errorString );

    va_start( arg_ptr, Format );
    _vsnwprintf( buf, sizeof(buf), Format, arg_ptr );
    va_end( arg_ptr );

    DebugPrint(( L"%s: %s", buf, p ));

    STDestroyFaxStatusObject( status );
#endif
}


extern "C"
DWORD CALLBACK
FaxDevDllInit(
    HINSTANCE hInstance,
    DWORD     Reason,
    LPVOID    Context
    )
{
    if (Reason == DLL_PROCESS_ATTACH) {
        MyhInstance = hInstance;
        DisableThreadLibraryCalls( hInstance );
    }

    return TRUE;
}


void CALLBACK
MyLineCallback(
    IN HANDLE FaxHandle,
    IN DWORD hDevice,
    IN DWORD dwMessage,
    IN DWORD dwInstance,
    IN DWORD dwParam1,
    IN DWORD dwParam2,
    IN DWORD dwParam3
    )
{
    return;
}


BOOL WINAPI
FaxDevInitialize(
    IN  HLINEAPP LineAppHandle,
    IN  HANDLE HeapHandle,
    OUT PFAX_LINECALLBACK *LineCallbackFunction,
    IN  PFAX_SERVICE_CALLBACK FaxServiceCallback
    )
{
    MyHeapHandle = HeapHandle;
    MyLineAppHandle = LineAppHandle;
    *LineCallbackFunction = MyLineCallback;
    HeapInitialize( MyHeapHandle, NULL, NULL, 0 );
    InitCommonControls();
    GetNcConfig( &ConfigData );
    return TRUE;
}


BOOL WINAPI
FaxDevVirtualDeviceCreation(
    OUT LPDWORD DeviceCount,
    OUT LPWSTR  DeviceNamePrefix,
    OUT LPDWORD DeviceIdPrefix,
    IN  HANDLE CompletionPort,
    IN  DWORD CompletionKey
    )
{
    *DeviceCount = 1;
    wcscpy( DeviceNamePrefix, L"NetCentric" );
    *DeviceIdPrefix = 69000;
    return TRUE;
}


BOOL WINAPI
FaxDevStartJob(
    IN  HLINE LineHandle,
    IN  DWORD DeviceId,
    OUT PHANDLE FaxHandle,
    IN  HANDLE CompletionPortHandle,
    IN  DWORD CompletionKey
    )
{
    LPSTR s;


    *FaxHandle = (PHANDLE) MemAlloc( sizeof(JOB_INFO) );
    if (!*FaxHandle) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    JobInfo(*FaxHandle)->LineHandle            = LineHandle;
    JobInfo(*FaxHandle)->DeviceId              = DeviceId;
    JobInfo(*FaxHandle)->CompletionPortHandle  = CompletionPortHandle;
    JobInfo(*FaxHandle)->CompletionKey         = CompletionKey;

    JobInfo(*FaxHandle)->faxJob                = new CNcFaxJob;
    JobInfo(*FaxHandle)->connInfo              = new CNcConnectionInfo;
    JobInfo(*FaxHandle)->sender                = new CNcUser;
    JobInfo(*FaxHandle)->recipient             = new CNcUser;

    s = UnicodeStringToAnsiString( ConfigData.ServerName );
    JobInfo(*FaxHandle)->connInfo->SetHostName( s );
    MemFree( s );

    s = UnicodeStringToAnsiString( ConfigData.UserName );
    JobInfo(*FaxHandle)->connInfo->SetAccountName( s );
    MemFree( s );

    s = UnicodeStringToAnsiString( ConfigData.Password );
    JobInfo(*FaxHandle)->connInfo->SetPassword( s );
    MemFree( s );

    JobInfo(*FaxHandle)->connInfo->SetClientIdentification(
        PRODUCTION_KEY,
        NCFAX_ID,
        NCFAX_CLIENTID,
        NCFAX_MAJOR,
        NCFAX_MINOR,
        NCFAX_RELEASE,
        NCFAX_PATCH
        );

    return TRUE;
}


BOOL WINAPI
FaxDevEndJob(
    IN  HANDLE FaxHandle
    )
{
    delete JobInfo(FaxHandle)->faxJob;
    delete JobInfo(FaxHandle)->connInfo;
    delete JobInfo(FaxHandle)->sender;
    delete JobInfo(FaxHandle)->recipient;

    MemFree( FaxHandle );

    return TRUE;
}


VOID
SetStatusValues(
    PFAX_DEV_STATUS FaxStatus,
    ULONG StatusCode,
    ULONG ExtStatusCode
    )
{
    FaxStatus->ErrorCode = 0;

    switch( StatusCode ) {
        case ST_STATUS_PENDING:
            switch( ExtStatusCode ) {
                case ST_EXT_BUSY:
                    FaxStatus->StatusId = FS_BUSY;
                    break;

                case ST_EXT_NO_ANSWER:
                    FaxStatus->StatusId = FS_NO_ANSWER;
                    break;

                case ST_EXT_NO_RINGBACK:
                    FaxStatus->StatusId = FS_NO_DIAL_TONE;
                    break;

                case ST_EXT_DEST_FAX_REFUSED:
                    FaxStatus->StatusId = FS_BAD_ADDRESS;
                    break;

//              case ST_EXT_COMMUNICATION_ERROR:
//                  FaxStatus->StatusId = FS_INITIALIZING;
//                  break;
            }
            break;

        case ST_STATUS_ACTIVE:
            switch( ExtStatusCode ) {
                case ST_EXT_ACTIVE_DIALING:
                    FaxStatus->StatusId = FS_DIALING;
                    break;

                case ST_EXT_ACTIVE_CONNECTING:
                    FaxStatus->StatusId = FS_TRANSMITTING;
                    break;

                case ST_EXT_ACTIVE_TRANSMISSION_BEGIN:
                    FaxStatus->StatusId = FS_TRANSMITTING;
                    break;

                case ST_EXT_ACTIVE_PAGE_SENT:
                    FaxStatus->StatusId = FS_TRANSMITTING;
                    break;
            }
            break;

        case ST_STATUS_FAILED:
            FaxStatus->StatusId = FS_FATAL_ERROR;
            FaxStatus->ErrorCode = ExtStatusCode;
            break;
    }

    FaxStatus->SizeOfStruct  = sizeof(FAX_DEV_STATUS);
    FaxStatus->StringId      = 0;
    FaxStatus->PageCount     = 0;
    FaxStatus->CSI           = NULL;
    FaxStatus->CallerId      = NULL;
    FaxStatus->RoutingInfo   = NULL;
    FaxStatus->Reserved[0]   = 0;
    FaxStatus->Reserved[1]   = 0;
    FaxStatus->Reserved[2]   = 0;
}


BOOL
FaxDevPostStatus(
    ULONG StatusCode,
    ULONG ExtStatusCode,
    HANDLE CompletionPort,
    DWORD CompletionKey
    )
{
    DWORD FaxDevStatusSize = 4096;
    PFAX_DEV_STATUS FaxStatus;


    FaxStatus = (PFAX_DEV_STATUS) HeapAlloc( MyHeapHandle, HEAP_ZERO_MEMORY, FaxDevStatusSize );
    if (!FaxStatus) {
        return FALSE;
    }

    SetStatusValues( FaxStatus, StatusCode, ExtStatusCode );

    PostQueuedCompletionStatus(
        CompletionPort,
        FaxDevStatusSize,
        CompletionKey,
        (LPOVERLAPPED) FaxStatus
        );

    return TRUE;
}


BOOL
ParsePhoneNumber(
    LPWSTR PhoneNumber,
    LPSTR *CountryCode,
    LPSTR *AreaCode,
    LPSTR *SubscriberNumber
    )
{
    BOOL rVal = FALSE;
    LPWSTR p;
    LPWSTR h;


    *CountryCode = NULL;
    *AreaCode = NULL;
    *SubscriberNumber = NULL;

    if (*PhoneNumber == L'+') {

        //
        // canonical address
        //

        p = PhoneNumber;

        h = p + 1;
        while( *p != L' ') p++;
        *p = 0;

        *CountryCode = UnicodeStringToAnsiString( h );
        if (!*CountryCode) {
            goto exit;
        }

        p += 1;
        while( *p == L' ') p++;

        if (*p == L'(') {
            h = p + 1;
            while( *p != L')') p++;
            *p = 0;
            *AreaCode = UnicodeStringToAnsiString( h );
            if (!*AreaCode) {
                goto exit;
            }
            p += 1;
            while( *p == L' ') p++;
        }

        *SubscriberNumber = UnicodeStringToAnsiString( p );
        if (!*SubscriberNumber) {
            goto exit;
        }

    } else {

        //
        // non-canonical address
        //

        p = wcschr( PhoneNumber, L'-' );
        if (!p) {
            //
            // malformed address
            //
            goto exit;
        }

        if (!wcschr( PhoneNumber, L'-' )) {

            //
            // the address does not contain an area code
            //

            *SubscriberNumber = UnicodeStringToAnsiString( PhoneNumber );
            if (!*SubscriberNumber) {
                goto exit;
            }

            *CountryCode = UnicodeStringToAnsiString( L"" );
            if (!*CountryCode) {
                goto exit;
            }

            *AreaCode = UnicodeStringToAnsiString( L"" );
            if (!*AreaCode) {
                goto exit;
            }

        } else {

            *SubscriberNumber = UnicodeStringToAnsiString( p+1 );
            if (!*SubscriberNumber) {
                goto exit;
            }

            *CountryCode = UnicodeStringToAnsiString( L"" );
            if (!*CountryCode) {
                goto exit;
            }

            *p = 0;

            *AreaCode = UnicodeStringToAnsiString( PhoneNumber );
            if (!*AreaCode) {
                goto exit;
            }

            *p = L'-';

        }


    }

    rVal = TRUE;

exit:

    if (!rVal) {
        MemFree( *CountryCode );
        MemFree( *AreaCode );
        MemFree( *SubscriberNumber );
    }

    return rVal;
}


BOOL WINAPI
FaxDevSend(
    IN  HANDLE FaxHandle,
    IN  PFAX_SEND FaxSend,
    IN  PFAX_SEND_CALLBACK FaxSendCallback
    )
{
    #define BUFFER_SIZE 4096
    BOOL rVal = FALSE;
    LPSTR s;
    LPSTR CountryCode = NULL;
    LPSTR AreaCode = NULL;
    LPSTR SubscriberNumber = NULL;
    NcSTHandle status = NULL;
    ULONG statusCode;
    ULONG extCode;
    CHAR errorString[256];
    CHAR extStatusVal[256];
    LPWSTR ErrorStringW = NULL;
    size_t Size;
    NcFileType_t fileType;
    PhoneNumberStruct PhoneNumber = {0};
    DWORD PollInterval = 15000;


    errorString[0] = 0;

    //
    // parse the receiver's fax number
    //

    if (!ParsePhoneNumber(
        FaxSend->ReceiverNumber,
        &CountryCode,
        &AreaCode,
        &SubscriberNumber ))
    {
        DebugPrint(( L"FaxDevSend: bad phone number, %s", FaxSend->ReceiverNumber ));
        goto exit;
    }

    //
    // set the connection information
    //

    if (!JobInfo(FaxHandle)->faxJob->SetConnectionInfo( JobInfo(FaxHandle)->connInfo )) {
        Size = sizeof(errorString);
        JobInfo(FaxHandle)->faxJob->GetLastErrorString( errorString, &Size );
        DebugPrint(( L"FaxDevSend: SetConnectionInfo failed, %s", ErrorStringW = AnsiStringToUnicodeString(errorString) ));
        goto exit;
    }

    //
    // set the sender information
    //

    s = UnicodeStringToAnsiString( FaxSend->CallerName );
    if (!JobInfo(FaxHandle)->sender->SetFirstName( s )) {
        MemFree( s );
        Size = sizeof(errorString);
        JobInfo(FaxHandle)->faxJob->GetLastErrorString( errorString, &Size );
        DebugPrint(( L"FaxDevSend: SetFirstName failed, %s", ErrorStringW = AnsiStringToUnicodeString(errorString) ));
        goto exit;
    }
    MemFree( s );

    if (!ParsePhoneNumber(
        FaxSend->CallerNumber,
        &PhoneNumber.CC,
        &PhoneNumber.AC,
        &PhoneNumber.EX ))
    {
        goto exit;
    }

    if (!JobInfo(FaxHandle)->sender->SetPhoneNumber( &PhoneNumber )) {
        Size = sizeof(errorString);
        JobInfo(FaxHandle)->faxJob->GetLastErrorString( errorString, &Size );
        DebugPrint(( L"FaxDevSend: SetPhoneNumber failed, %s", ErrorStringW = AnsiStringToUnicodeString(errorString) ));
        goto exit;
    }

    //
    // set the recipient information
    //

    s = UnicodeStringToAnsiString( FaxSend->ReceiverName );
    if (!JobInfo(FaxHandle)->recipient->SetFirstName( s )) {
        MemFree( s );
        Size = sizeof(errorString);
        JobInfo(FaxHandle)->faxJob->GetLastErrorString( errorString, &Size );
        DebugPrint(( L"FaxDevSend: SetFirstName failed, %s", ErrorStringW = AnsiStringToUnicodeString(errorString) ));
        goto exit;
    }
    MemFree( s );

    if (!JobInfo(FaxHandle)->recipient->SetFaxNumber( CountryCode, AreaCode, SubscriberNumber )) {
        Size = sizeof(errorString);
        JobInfo(FaxHandle)->faxJob->GetLastErrorString( errorString, &Size );
        DebugPrint(( L"FaxDevSend: SetFaxNumber failed, %s", ErrorStringW = AnsiStringToUnicodeString(errorString) ));
        goto exit;
    }

    CHAR TempPath[256];
    GetTempPathA( sizeof(TempPath), TempPath );

    if (!JobInfo(FaxHandle)->faxJob->SetWorkingDirectory( TempPath, "NcFax", TRUE )) {
        Size = sizeof(errorString);
        JobInfo(FaxHandle)->faxJob->GetLastErrorString( errorString, &Size );
        DebugPrint(( L"FaxDevSend: SetWorkingDirectory failed, %s", ErrorStringW = AnsiStringToUnicodeString(errorString) ));
        LPCSTR cwd = JobInfo(FaxHandle)->faxJob->GetWorkingDirectory();
        goto exit;
    }

    if (!JobInfo(FaxHandle)->faxJob->SetSender( JobInfo(FaxHandle)->sender )) {
        Size = sizeof(errorString);
        JobInfo(FaxHandle)->faxJob->GetLastErrorString( errorString, &Size );
        DebugPrint(( L"FaxDevSend: SetSender failed, %s", ErrorStringW = AnsiStringToUnicodeString(errorString) ));
        goto exit;
    }

    if (!JobInfo(FaxHandle)->faxJob->SetRecipient( JobInfo(FaxHandle)->recipient)) {
        Size = sizeof(errorString);
        JobInfo(FaxHandle)->faxJob->GetLastErrorString( errorString, &Size );
        DebugPrint(( L"FaxDevSend: SetRecipient failed, %s", ErrorStringW = AnsiStringToUnicodeString(errorString) ));
        goto exit;
    }

    if (!JobInfo(FaxHandle)->faxJob->SetSubject( "" )) {
        Size = sizeof(errorString);
        JobInfo(FaxHandle)->faxJob->GetLastErrorString( errorString, &Size );
        DebugPrint(( L"FaxDevSend: SetSubject failed, %s", ErrorStringW = AnsiStringToUnicodeString(errorString) ));
        goto exit;
    }

    s = UnicodeStringToAnsiString( FaxSend->FileName );

    if (!NcGetFileTypeFromFileData( s, &fileType )) {
        MemFree( s );
        DebugPrint(( L"FaxDevSend: NcGetFileTypeFromFileData" ));
        goto exit;
    }

    if (!JobInfo(FaxHandle)->faxJob->AddFile( s, fileType )) {
        Size = sizeof(errorString);
        JobInfo(FaxHandle)->faxJob->GetLastErrorString( errorString, &Size );
        DebugPrint(( L"FaxDevSend: AddFile failed, %s", ErrorStringW = AnsiStringToUnicodeString(errorString) ));
        MemFree( s );
        goto  exit;
    }
    MemFree( s );

    JobInfo(FaxHandle)->faxJob->SetNotifyByEmail( FALSE );

    if (!JobInfo(FaxHandle)->faxJob->SendJob( &JobInfo(FaxHandle)->ServerId, &JobInfo(FaxHandle)->JobId )) {
        Size = sizeof(errorString);
        JobInfo(FaxHandle)->faxJob->GetLastErrorString( errorString, &Size );
        DebugPrint(( L"FaxDevSend: SendJob failed, %s", ErrorStringW = AnsiStringToUnicodeString(errorString) ));
        goto exit;
    }

    //
    // poll the netcentric fax server for status
    // information.  we sit in this loop until the
    // fax is sent.
    //

    status = STCreateFaxStatusObject( JobInfo(FaxHandle)->ServerId, JobInfo(FaxHandle)->JobId );

    STSetConnectionInfo( status, JobInfo(FaxHandle)->connInfo );

    while( TRUE ) {

        if (!STFaxUpdate( status )) {
            statusCode = STGetLastError( status );
            if (statusCode == ST_MIN_POLL_NOT_EXCEEDED) {
                Sleep( PollInterval );
                continue;
            }
            FaxDevPrintErrorMsg( FaxHandle, L"STFaxUpdate() failed" );
            break;
        }

        statusCode = STGetStatusCode( status );

        Size = sizeof( extStatusVal );
        STGetExtendedStatus( status, &extCode, extStatusVal, &Size );

        DebugPrint(( L"statusCode=%04x, extCode=%04x", statusCode, extCode ));

        FaxDevPostStatus(
            statusCode,
            extCode,
            JobInfo(FaxHandle)->CompletionPortHandle,
            JobInfo(FaxHandle)->CompletionKey
            );

        if (IS_DONE_STATUS(statusCode)) {
            DebugPrint(( L"Job finished, returning from FaxDevSend()" ));
            break;
        }

//      PollInterval = STGetNextRecommendedUpdate(status) * 1000;

        DebugPrint(( L"Next poll in %dms", PollInterval ));
        Sleep( PollInterval );
    }

    rVal = TRUE;

exit:

    if (status) {
        STDestroyFaxStatusObject( status );
    }

    MemFree( CountryCode );
    MemFree( AreaCode );
    MemFree( SubscriberNumber );

    MemFree( PhoneNumber.CC );
    MemFree( PhoneNumber.AC );
    MemFree( PhoneNumber.EX );

    MemFree( ErrorStringW );

    if (!rVal && errorString[0]) {
    }

    return rVal;
}


BOOL WINAPI
FaxDevReceive(
    IN  HANDLE FaxHandle,
    IN  HCALL CallHandle,
    IN OUT PFAX_RECEIVE FaxReceive
    )
{
    return TRUE;
}


BOOL WINAPI
FaxDevReportStatus(
    IN  HANDLE FaxHandle OPTIONAL,
    OUT PFAX_DEV_STATUS FaxStatus,
    IN  DWORD FaxStatusSize,
    OUT LPDWORD FaxStatusSizeRequired
    )
{
    NcSTHandle status;
    ULONG statusCode;
    ULONG extCode;
    CHAR extStatusVal[256];
    size_t Size;



    if (FaxStatus == NULL && FaxStatusSize == 0) {
        //
        // caller wants to know how big to allocate
        //
        if (FaxStatusSizeRequired) {
            *FaxStatusSizeRequired = 4096;
        }
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
    }

    if (FaxStatus == NULL || FaxStatusSize == 0) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    status = STCreateFaxStatusObject( JobInfo(FaxHandle)->ServerId, JobInfo(FaxHandle)->JobId );

    STSetConnectionInfo( status, JobInfo(FaxHandle)->connInfo );

    if (!STFaxUpdate( status )) {
        STDestroyFaxStatusObject( status );
        return FALSE;
    }

    statusCode = STGetStatusCode( status );

    Size = sizeof( extStatusVal );
    STGetExtendedStatus( status, &extCode, extStatusVal, &Size );

    SetStatusValues( FaxStatus, statusCode, extCode );

    STDestroyFaxStatusObject( status );

    return TRUE;
}


BOOL WINAPI
FaxDevAbortOperation(
    IN  HANDLE FaxHandle
    )
{
    if (!JobInfo(FaxHandle)->faxJob->StopJob(
        JobInfo(FaxHandle)->connInfo,
        JobInfo(FaxHandle)->ServerId,
        JobInfo(FaxHandle)->JobId
        ))
    {
        FaxDevPrintErrorMsg( FaxHandle, L"CNcFaxJob::StopJob() failed" );
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\newfsp\newfsp.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  newfsp.c

Abstract:

  This module implements a sample Windows NT Fax Service Provider

--*/

#include "newfsp.h"

// DeviceReceiveThread() is a thread to watch for an incoming fax transmission
DWORD WINAPI DeviceReceiveThread(LPDWORD pdwDeviceId);

BOOL WINAPI
DllEntryPoint(
    HINSTANCE  hInstance,
    DWORD      dwReason,
    LPVOID     pContext
)
/*++

Routine Description:

  DLL entry-point function

Arguments:

  hInstance - handle to the DLL
  dwReason - specifies a flag indicating why the DLL entry-point function is being called

Return Value:

  TRUE on success

--*/
{
    // pDeviceInfo is a pointer to the virtual fax devices
    PDEVICE_INFO  pDeviceInfo;
    // pCurrentDeviceInfo is a pointer to the current virtual fax device
    PDEVICE_INFO  pCurrentDeviceInfo;

    if (dwReason == DLL_PROCESS_ATTACH) {
        // Set g_hInstance
        g_hInstance = hInstance;

        // Disable the DLL_THREAD_ATTACH and DLL_THREAD_DETACH notifications for the DLL
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH) {
        if (g_pDeviceInfo != NULL) {
            // Enumerate the virtual fax devices
            for (pCurrentDeviceInfo = g_pDeviceInfo[0]; pCurrentDeviceInfo; pCurrentDeviceInfo = pDeviceInfo) {
                pDeviceInfo = pCurrentDeviceInfo->pNextDeviceInfo;

                if (pCurrentDeviceInfo->ExitEvent) {
                    // Set the event to indicate the thread to watch for an incoming fax transmission is to exit
                    SetEvent(pCurrentDeviceInfo->ExitEvent);
                }

                // Delete the critical section
                DeleteCriticalSection(&pCurrentDeviceInfo->cs);
                // Delete the virtual fax device data
                MemFreeMacro(pCurrentDeviceInfo);
            }

            g_pDeviceInfo = NULL;
        }

        // Close the log file
        CloseLogFile();
    }

    return TRUE;
}

BOOL WINAPI
FaxDevVirtualDeviceCreation(
    OUT LPDWORD    DeviceCount,
    OUT LPWSTR     DeviceNamePrefix,
    OUT LPDWORD    DeviceIdPrefix,
    IN  HANDLE     CompletionPort,
    IN  ULONG_PTR  CompletionKey
)
/*++

Routine Description:

  The fax service calls the FaxDevVirtualDeviceCreation function during initialization to allow the fax service provider to present virtual fax devices

Arguments:

  DeviceCount - pointer to a variable that receives the number of virtual fax devices the fax service must create for the fax service provider
  DeviceNamePrefix - pointer to a variable that receives a string of the name prefix for the virtual fax devices
  DeviceIdPrefix - pointer to a variable that receives a unique numeric value that identifies the virtual fax devices
  CompletionPort - specifies a handle to an I/O completion port that the fax service provider must use to post I/O completion port packets to the fax service for asynchronous line status events
  CompletionKey - specifies a completion port key value

Return Value:

  TRUE on success

--*/
{
    BOOL  bReturnValue;

    WriteDebugString(L"---NewFsp: FaxDevVirtualDeviceCreation Enter---\n");

    // Initialize the parameters
    *DeviceCount = 0;
    ZeroMemory(DeviceNamePrefix, 128 * sizeof(WCHAR));
    *DeviceIdPrefix = 0;

    // Copy the handle to the completion port
    g_CompletionPort = CompletionPort;
    g_CompletionKey = CompletionKey;

    // Get the registry data for the newfsp service provider
    bReturnValue = GetNewFspRegistryData(NULL, NULL, NULL, DeviceCount);

    if (bReturnValue == FALSE) {
        WriteDebugString(L"   ERROR: GetNewFspRegistryData Failed: 0x%08x\n", GetLastError());
        WriteDebugString(L"   ERROR: FaxDevVirtualDeviceCreation Failed\n");
        WriteDebugString(L"---NewFsp: FaxDevVirtualDeviceCreation Exit---\n");

        return FALSE;
    }

    if (*DeviceCount == 0) {
        WriteDebugString(L"   ERROR: No Virtual Fax Devices Installed\n");
        WriteDebugString(L"   ERROR: FaxDevVirtualDeviceCreation Failed\n");
        WriteDebugString(L"---NewFsp: FaxDevVirtualDeviceCreation Exit---\n");

        return FALSE;
    }

    // Copy the name prefix for the virtual fax devices, limited to 128 WCHARs including the termininating null character
    lstrcpyn(DeviceNamePrefix, NEWFSP_DEVICE_NAME_PREFIX, 128);
    // Copy the values that identifies the virtual fax devices
    *DeviceIdPrefix = NEWFSP_DEVICE_ID_PREFIX;

    WriteDebugString(L"---NewFsp: FaxDevVirtualDeviceCreation Exit---\n");

    return TRUE;
}

VOID CALLBACK
FaxLineCallback(
    IN HANDLE     FaxHandle,
    IN DWORD      hDevice,
    IN DWORD      dwMessage,
    IN DWORD_PTR  dwInstance,
    IN DWORD_PTR  dwParam1,
    IN DWORD_PTR  dwParam2,
    IN DWORD_PTR  dwParam3
)
/*++

Routine Description:

  An application-defined callback function that the fax service calls to deliver TAPI events to the fax service provider

Arguments:

  FaxHandle - specifies a fax handle returned by the FaxDevStartJob function
  hDevice - specifies a handle to either a line device or a call device
  dwMessage - specifies a line device or a call device message
  dwInstance - specifies job-specific instance data passed back to the application
  dwParam1 - specifies a parameter for this message
  dwParam2 - specifies a parameter for this message
  dwParam3 - specifies a parameter for this message

Return Value:

  TRUE on success

--*/
{
    // pdwDeviceId is the pointer to the virtual fax device identifier
    LPDWORD   pdwDeviceId;
    // hThread is a handle to the thread to watch for an incoming fax transmission
    HANDLE    hThread;

    WriteDebugString(L"---NewFsp: fnFaxLineCallback Enter---\n");

    // Wait for access to this virtual fax device
    EnterCriticalSection(&g_pDeviceInfo[hDevice - NEWFSP_DEVICE_ID_PREFIX]->cs);

    if ((dwParam1 == 0) && (g_pDeviceInfo[hDevice - NEWFSP_DEVICE_ID_PREFIX]->ExitEvent)) {
        // Receive has been disabled for this virtual fax device so set the event to indicate the thread to watch for an incoming fax transmission is to exit
        SetEvent(g_pDeviceInfo[hDevice - NEWFSP_DEVICE_ID_PREFIX]->ExitEvent);
        g_pDeviceInfo[hDevice - NEWFSP_DEVICE_ID_PREFIX]->ExitEvent = NULL;
    }
    else if ((dwParam1 != 0) && (g_pDeviceInfo[hDevice - NEWFSP_DEVICE_ID_PREFIX]->ExitEvent == NULL)) {
        // Allocate a block of memory for the virtual fax device identifier
        pdwDeviceId = MemAllocMacro(sizeof(DWORD));
        if (pdwDeviceId != NULL) {
            // Copy the virtual fax device identifier
            *pdwDeviceId = (hDevice - NEWFSP_DEVICE_ID_PREFIX);

            // Receive has been enabled for this virtual fax device so create the thread to watch for an incoming fax transmission
            g_pDeviceInfo[hDevice - NEWFSP_DEVICE_ID_PREFIX]->ExitEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
            if (g_pDeviceInfo[hDevice - NEWFSP_DEVICE_ID_PREFIX]->ExitEvent != NULL) {
                hThread = CreateThread(NULL, 0, DeviceReceiveThread, pdwDeviceId, 0, NULL);
                if (hThread != NULL) {
                    // Close the handle to the thread
                    CloseHandle(hThread);
                }
                else {
                    // Close the handle to the exit event
                    CloseHandle(g_pDeviceInfo[hDevice - NEWFSP_DEVICE_ID_PREFIX]->ExitEvent);
                    g_pDeviceInfo[hDevice - NEWFSP_DEVICE_ID_PREFIX]->ExitEvent = NULL;
                }
            }
        }
    }

    // Release access to this virtual fax device
    LeaveCriticalSection(&g_pDeviceInfo[hDevice - NEWFSP_DEVICE_ID_PREFIX]->cs);

    WriteDebugString(L"---NewFsp: fnFaxLineCallback Exit---\n");

    return;
}

BOOL WINAPI
FaxDevInitialize(
    IN  HLINEAPP               LineAppHandle,
    IN  HANDLE                 HeapHandle,
    OUT PFAX_LINECALLBACK      *LineCallbackFunction,
    IN  PFAX_SERVICE_CALLBACK  FaxServiceCallback
)
/*++

Routine Description:

  The fax service calls the FaxDevInitialize function each time the service starts to initialize communication between the fax service and the fax service provider DLL

Arguments:

  LineAppHandle - specifies a handle to the fax service's registration with TAPI
  HeapHandle - specifies a handle to a heap that the fax service provider must use for all memory allocations
  LineCallbackFunction - pointer to a variable that receives a pointer to a TAPI line callback function
  FaxServiceCallback - pointer to a service callback function

Return Value:

  TRUE on success

--*/
{
    // bLoggingEnabled indicates if logging is enabled
    BOOL          bLoggingEnabled;
    // szLoggingDirectory indicates the logging directory
    WCHAR         szLoggingDirectory[MAX_PATH_LEN];
    // pDeviceInfo is a pointer to the virtual fax devices
    PDEVICE_INFO  pDeviceInfo;
    // pCurrentDeviceInfo is a pointer to the current virtual fax device
    PDEVICE_INFO  pCurrentDeviceInfo;
    // dwNumDevices is the number of virtual fax devices
    DWORD         dwNumDevices;
    // dwIndex is a counter to enumerate each virtual fax device
    DWORD         dwIndex;
    // bReturnValue is the value to return to the fax service
    BOOL          bReturnValue;

    WriteDebugString(L"---NewFsp: FaxDevInitialize Enter---\n");

    // Set g_hLineApp
    g_LineAppHandle = LineAppHandle;

    // Set g_hHeap
    MemInitializeMacro(HeapHandle);

    // Set LineCallbackFunction
    *LineCallbackFunction = FaxLineCallback;

    // Get the registry data for the newfsp service provider
    bLoggingEnabled = FALSE;
    ZeroMemory(szLoggingDirectory, sizeof(szLoggingDirectory));
    pDeviceInfo = NULL;
    dwNumDevices = 0;
    bReturnValue = GetNewFspRegistryData(&bLoggingEnabled, szLoggingDirectory, &pDeviceInfo, &dwNumDevices);

    if (bReturnValue == FALSE) {
        WriteDebugString(L"   ERROR: GetNewFspRegistryData Failed: 0x%08x\n", GetLastError());
        WriteDebugString(L"   ERROR: FaxDevInitialize Failed\n");
        WriteDebugString(L"---NewFsp: FaxDevInitialize Exit---\n");

        return FALSE;
    }

    if (dwNumDevices == 0) {
        WriteDebugString(L"   ERROR: No Virtual Fax Devices Installed\n");
        WriteDebugString(L"   ERROR: FaxDevInitialize Failed\n");
        WriteDebugString(L"---NewFsp: FaxDevInitialize Exit---\n");

        return FALSE;
    }

    // Open the log file
    bReturnValue = OpenLogFile(bLoggingEnabled, szLoggingDirectory);

    if (dwNumDevices > 0) {
        // Allocate a block of memory for the virtual fax device data
        g_pDeviceInfo = MemAllocMacro(sizeof(PDEVICE_INFO) * dwNumDevices);
        if (g_pDeviceInfo == NULL) {
            // Set the error code
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);

            // Enumerate the virtual fax devices
            for (pCurrentDeviceInfo = pDeviceInfo; pCurrentDeviceInfo; pCurrentDeviceInfo = pDeviceInfo) {
                // Delete the virtual fax device data
                pDeviceInfo = pCurrentDeviceInfo->pNextDeviceInfo;
                MemFreeMacro(pCurrentDeviceInfo);
            }

            WriteDebugString(L"   ERROR: FaxDevInitialize Failed: ERROR_NOT_ENOUGH_MEMORY\n");
            WriteDebugString(L"---NewFsp: FaxDevInitialize Exit---\n");

            return FALSE;
        }
    }
    else {
        g_pDeviceInfo = NULL;
    }

    // Marshall the virtual fax devices
    for (pCurrentDeviceInfo = pDeviceInfo, dwIndex = 0; pCurrentDeviceInfo; pCurrentDeviceInfo = pCurrentDeviceInfo->pNextDeviceInfo, dwIndex++) {
        g_pDeviceInfo[dwIndex] = pCurrentDeviceInfo;

        // Initialize the virtual fax device's critical section
        InitializeCriticalSection(&g_pDeviceInfo[dwIndex]->cs);
        // Initialize the virtual fax device's status to idle
        g_pDeviceInfo[dwIndex]->Status = DEVICE_IDLE;
        // Initialize the virtual fax device's handle to the exit event
        g_pDeviceInfo[dwIndex]->ExitEvent = NULL;
        // Initialize the virtual fax device's associated fax job
        g_pDeviceInfo[dwIndex]->pJobInfo = NULL;
    }

    WriteDebugString(L"---NewFsp: FaxDevInitialize Exit---\n");

    return TRUE;
}

BOOL WINAPI
FaxDevStartJob(
    IN  HLINE      LineHandle,
    IN  DWORD      DeviceId,
    OUT PHANDLE    FaxHandle,
    IN  HANDLE     CompletionPortHandle,
    IN  ULONG_PTR  CompletionKey
)
/*++

Routine Description:

  The fax service calls the FaxDevStartJob function to initialize a new fax job

Arguments:

  LineHandle - specifies a handle to the open line device associated with the fax job
  DeviceId - specifies the TAPI line device identifier associated with the fax job
  FaxHandle - pointer to a variable that receives a fax handle associated with the fax job
  CompltionPortHandle - specifies a handle to an I/O completion port
  CompletionKey - specifies a completion port key value

Return Value:

  TRUE on success

--*/
{
    // pJobInfo is a pointer to the fax job data
    PJOB_INFO  pJobInfo;

    WriteDebugString(L"---NewFsp: FaxDevStartJob Enter---\n");

    // Initialize the parameters
    *FaxHandle = NULL;

    // Allocate a block of memory for the fax job instance data
    pJobInfo = MemAllocMacro(sizeof(JOB_INFO));
    if (pJobInfo == NULL) {
        // Set the error code
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);

        WriteDebugString(L"   ERROR: FaxDevStartJob Failed: ERROR_NOT_ENOUGH_MEMORY\n");
        WriteDebugString(L"---NewFsp: FaxDevStartJob Exit---\n");
        return FALSE;
    }

    // Set the FaxHandle
    *FaxHandle = (PHANDLE) pJobInfo;

    // Wait for access to this virtual fax device
    EnterCriticalSection(&g_pDeviceInfo[DeviceId]->cs);

    // Initialize the fax job data
    // Set the fax job's associated virtual fax device
    pJobInfo->pDeviceInfo = g_pDeviceInfo[DeviceId];
    // Copy the handle to the I/O completion port
    pJobInfo->CompletionPortHandle = CompletionPortHandle;
    // Copy the completion port key value
    pJobInfo->CompletionKey = CompletionKey;
    // Initialize the fax job type
    pJobInfo->JobType = JOB_UNKNOWN;
    // Set the fax job status to FS_INITIALIZING
    pJobInfo->Status = FS_INITIALIZING;
    // Copy the handle to the open line device associated with the fax job
    pJobInfo->LineHandle = LineHandle;
    // Initialize the handle to the active call associated with the fax job
    pJobInfo->CallHandle = (HCALL) 0;
    // Initialize the full path to the file that contains the data stream for the fax document
    pJobInfo->FileName = NULL;
    // Initialize the name of the calling device
    pJobInfo->CallerName = NULL;
    // Initialize the telephone number of the calling device
    pJobInfo->CallerNumber = NULL;
    // Initialize name of the receiving device
    pJobInfo->ReceiverName = NULL;
    // Initialize telephone number of the receiving device
    pJobInfo->ReceiverNumber = NULL;
    // Initialize number of retries associated with the fax job
    pJobInfo->RetryCount = 0;
    // Initialize whether the fax service provider should generate a brand at the top of the fax transmission
    pJobInfo->Branding = FALSE;
    // Initialize the number of pages associated with the fax job
    pJobInfo->PageCount = 0;
    // Initialize the identifier of the remote fax device
    pJobInfo->CSI = NULL;
    // Initialize the identifier of the calling fax device
    pJobInfo->CallerId = NULL;
    // Initialize the routing string associated with the fax job
    pJobInfo->RoutingInfo = NULL;

    // Set the virtual fax device status
    g_pDeviceInfo[DeviceId]->Status = DEVICE_START;
    // Set the virtual fax device's associated fax job
    g_pDeviceInfo[DeviceId]->pJobInfo = pJobInfo;

    // Release access to this virtual fax device
    LeaveCriticalSection(&g_pDeviceInfo[DeviceId]->cs);

    WriteDebugString(L"---NewFsp: FaxDevStartJob Exit---\n");

    return TRUE;
}

BOOL WINAPI
FaxDevEndJob(
    IN HANDLE  FaxHandle
)
/*++

Routine Description:

  The fax service calls the FaxDevEndJob function after the last operation in a fax job

Arguments:

  FaxHandle - specifies a fax handle returned by the FaxDevStartJob function

Return Value:

  TRUE on success

--*/
{
    // pJobInfo is a pointer to the fax job data
    PJOB_INFO     pJobInfo;
    // pDeviceInfo is a pointer to the virtual fax device data
    PDEVICE_INFO  pDeviceInfo;

    WriteDebugString(L"---NewFsp: FaxDevEndJob Enter---\n");

    if (FaxHandle == NULL) {
        // Set the error code
        SetLastError(ERROR_INVALID_HANDLE);

        WriteDebugString(L"   ERROR: FaxDevEndJob Failed: ERROR_INVALID_HANDLE\n");
        WriteDebugString(L"---NewFsp: FaxDevEndJob Exit---\n");
        return FALSE;
    }

    // Get the fax job data from FaxHandle
    pJobInfo = (PJOB_INFO) FaxHandle;
    // Get the virtual fax device data from the fax job data
    pDeviceInfo = (PDEVICE_INFO) pJobInfo->pDeviceInfo;

    // Wait for access to this virtual fax device
    EnterCriticalSection(&pDeviceInfo->cs);

    // Free the fax job data
    // Free the full path to the file that contains the data stream for the fax document
    if (pJobInfo->FileName != NULL) {
        MemFreeMacro(pJobInfo->FileName);
    }
    // Free the name of the calling device
    if (pJobInfo->CallerName != NULL) {
        MemFreeMacro(pJobInfo->CallerName);
    }
    // Free the telephone number of the calling device
    if (pJobInfo->CallerNumber != NULL) {
        MemFreeMacro(pJobInfo->CallerNumber);
    }
    // Free name of the receiving device
    if (pJobInfo->ReceiverName != NULL) {
        MemFreeMacro(pJobInfo->ReceiverName);
    }
    // Free telephone number of the receiving device
    if (pJobInfo->ReceiverNumber != NULL) {
        MemFreeMacro(pJobInfo->ReceiverNumber);
    }
    // Free the identifier of the remote fax device
    if (pJobInfo->CSI != NULL) {
        MemFreeMacro(pJobInfo->CSI);
    }
    // Free the identifier of the calling fax device
    if (pJobInfo->CallerId != NULL) {
        MemFreeMacro(pJobInfo->CallerId);
    }
    // Free the routing string associated with the fax job
    if (pJobInfo->RoutingInfo != NULL) {
        MemFreeMacro(pJobInfo->RoutingInfo);
    }
    // Free the fax job data
    MemFreeMacro(pJobInfo);

    // Set the virtual fax device status
    pDeviceInfo->Status = DEVICE_IDLE;
    // Initialize the virtual fax device's associated fax job
    pDeviceInfo->pJobInfo = NULL;

    // Release access to this virtual fax device
    LeaveCriticalSection(&pDeviceInfo->cs);

    WriteDebugString(L"---NewFsp: FaxDevEndJob Exit---\n");

    return TRUE;
}

BOOL WINAPI
FaxDevSend(
    IN HANDLE              FaxHandle,
    IN PFAX_SEND           FaxSend,
    IN PFAX_SEND_CALLBACK  FaxSendCallback
)
/*++

Routine Description:

  The fax service calls the FaxDevSend function to signal a fax service provider that it must initiate an outgoing fax transmission

Arguments:

  FaxHandle - specifies a fax handle returned by the FaxDevStartJob function
  FaxSend - pointer to a FAX_SEND structure that contains the sending information
  FaxSendCallback - pointer to a callback function that notifies the fax service of the call handle that TAPI assigns

Return Value:

  TRUE on success

--*/
{
    // pJobInfo is a pointer to the fax job data
    PJOB_INFO     pJobInfo;
    // pDeviceInfo is a pointer to the virtual fax device data
    PDEVICE_INFO  pDeviceInfo;

    // dwReceiverNumberAttributes is the file attributes of the directory specified in the telephone number of the receiving device
    DWORD         dwReceiverNumberAttributes;

    // hSourceFile is the handle to the source file
    HANDLE        hSourceFile = INVALID_HANDLE_VALUE;
    // szSourceName is the source filename name
    WCHAR         szSourceName[_MAX_FNAME];
    // szSourceExt is the source filename extension
    WCHAR         szSourceExt[_MAX_EXT];

    // hDestinationFile is the handle to the destination file
    HANDLE        hDestinationFile = INVALID_HANDLE_VALUE;
    // szDestinationFilename is the destination filename
    WCHAR         szDestinationFilename[MAX_PATH];

    // FileBytes is the bytes to be copied from the source file to the destination file
    BYTE          FileBytes[1024];
    // dwBytes is the number of bytes read from the source file
    DWORD         dwBytes;

    WriteDebugString(L"---NewFsp: FaxDevSend Enter---\n");

    if (FaxHandle == NULL) {
        // Set the error code
        SetLastError(ERROR_INVALID_HANDLE);

        WriteDebugString(L"   ERROR: FaxDevSend Failed: ERROR_INVALID_HANDLE\n");
        WriteDebugString(L"---NewFsp: FaxDevSend Exit---\n");
        return FALSE;
    }

    // Get the fax job data from FaxHandle
    pJobInfo = (PJOB_INFO) FaxHandle;
    // Get the virtual fax device data from the fax job data
    pDeviceInfo = (PDEVICE_INFO) pJobInfo->pDeviceInfo;

    // Wait for access to this virtual fax device
    EnterCriticalSection(&pDeviceInfo->cs);

    if (pDeviceInfo->Status == DEVICE_ABORTING) {
        goto ExitUserAbort;
    }

    // Set the virtual fax device status
    pDeviceInfo->Status = DEVICE_SEND;

    // Set the fax job type
    pJobInfo->JobType = JOB_SEND;
    // Copy the handle to the active call associated with the fax job
    pJobInfo->CallHandle = FaxSend->CallHandle;
    // Copy the full path to the file that contains the data stream for the fax document
    if (FaxSend->FileName != NULL) {
        pJobInfo->FileName = MemAllocMacro((lstrlen(FaxSend->FileName) + 1) * sizeof(WCHAR));
        if (pJobInfo->FileName) {
            lstrcpy(pJobInfo->FileName, FaxSend->FileName);
        }
    }
    // Copy the name of the calling device
    if (FaxSend->CallerName != NULL) {
        pJobInfo->CallerName = MemAllocMacro((lstrlen(FaxSend->CallerName) + 1) * sizeof(WCHAR));
        if (pJobInfo->CallerName) {
            lstrcpy(pJobInfo->CallerName, FaxSend->CallerName);
        }
    }
    // Copy the telephone number of the calling device
    if (FaxSend->CallerNumber != NULL) {
        pJobInfo->CallerNumber = MemAllocMacro((lstrlen(FaxSend->CallerNumber) + 1) * sizeof(WCHAR));
        if (pJobInfo->CallerNumber) {
            lstrcpy(pJobInfo->CallerNumber, FaxSend->CallerNumber);
        }
    }
    // Copy the name of the receiving device
    if (FaxSend->ReceiverName != NULL) {
        pJobInfo->ReceiverName = MemAllocMacro((lstrlen(FaxSend->ReceiverName) + 1) * sizeof(WCHAR));
        if (pJobInfo->ReceiverName) {
            lstrcpy(pJobInfo->ReceiverName, FaxSend->ReceiverName);
        }
    }
    // Copy the telephone number of the receiving device
    if (FaxSend->ReceiverNumber != NULL) {
        pJobInfo->ReceiverNumber = MemAllocMacro((lstrlen(FaxSend->ReceiverNumber) + 1) * sizeof(WCHAR));
        if (pJobInfo->ReceiverNumber) {
            lstrcpy(pJobInfo->ReceiverNumber, FaxSend->ReceiverNumber);
        }
    }
    // Copy whether the fax service provider should generate a brand at the top of the fax transmission
    pJobInfo->Branding = FaxSend->Branding;

    // Release access to this virtual fax device
    LeaveCriticalSection(&pDeviceInfo->cs);

    WriteDebugString(L"   FaxSend->SizeOfStruct   : 0x%08x\n", FaxSend->SizeOfStruct);
    WriteDebugString(L"   FaxSend->FileName       : %s\n", FaxSend->FileName);
    WriteDebugString(L"   FaxSend->CallerName     : %s\n", FaxSend->CallerName);
    WriteDebugString(L"   FaxSend->CallerNumber   : %s\n", FaxSend->CallerNumber);
    WriteDebugString(L"   FaxSend->ReceiverName   : %s\n", FaxSend->ReceiverName);
    WriteDebugString(L"   FaxSend->ReceiverNumber : %s\n", FaxSend->ReceiverNumber);
    WriteDebugString(L"   FaxSend->Branding       : %s\n", FaxSend->Branding ? L"TRUE" : L"FALSE");
    WriteDebugString(L"   FaxSend->CallHandle     : 0x%08x\n", FaxSend->CallHandle);

    // Wait for access to this virtual fax device
    EnterCriticalSection(&pDeviceInfo->cs);

    if (pDeviceInfo->Status == DEVICE_ABORTING) {
        goto ExitUserAbort;
    }

    // Set the fax job status
    pJobInfo->Status = FS_INITIALIZING;
    // Post the FS_INITIALIZING line status event to the fax service
    PostJobStatus(pJobInfo->CompletionPortHandle, pJobInfo->CompletionKey, FS_INITIALIZING, ERROR_SUCCESS);

    // Validate the telephone number of the receive device
    dwReceiverNumberAttributes = GetFileAttributes(FaxSend->ReceiverNumber);
    if ((dwReceiverNumberAttributes == 0xFFFFFFFF) || ((dwReceiverNumberAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)) {
        // The telephone number of the receive device is invalid
        goto ExitFatalError;
    }

    // Open the source file
    hSourceFile = CreateFile(FaxSend->FileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hSourceFile == INVALID_HANDLE_VALUE) {
        // The source file failed to be opened
        goto ExitFatalError;
    }

    // Split the full path of the file that contains the data stream for the fax document
    _wsplitpath(FaxSend->FileName, NULL, NULL, szSourceName, szSourceExt);

    // Set the destination filename
    lstrcpy(szDestinationFilename, FaxSend->ReceiverNumber);
    lstrcat(szDestinationFilename, L"\\");
    lstrcat(szDestinationFilename, szSourceName);
    lstrcat(szDestinationFilename, szSourceExt);

    // Create the destination file
    hDestinationFile = CreateFile(szDestinationFilename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hDestinationFile == INVALID_HANDLE_VALUE) {
        // The destination file failed to be created
        goto ExitFatalError;
    }

    // Release access to this virtual fax device
    LeaveCriticalSection(&pDeviceInfo->cs);

    // Wait for access to this virtual fax device
    EnterCriticalSection(&pDeviceInfo->cs);

    if (pDeviceInfo->Status == DEVICE_ABORTING) {
        goto ExitUserAbort;
    }

    // Set the fax job status
    pJobInfo->Status = FS_TRANSMITTING;
    // Post the FS_TRANSMITTING line status event to the fax service
    PostJobStatus(pJobInfo->CompletionPortHandle, pJobInfo->CompletionKey, FS_TRANSMITTING, ERROR_SUCCESS);

    // Release access to this virtual fax device
    LeaveCriticalSection(&pDeviceInfo->cs);

    while (TRUE) {
        // The following sleep statement slows the bit copy to a reasonable speed so that a FaxDevAbortOperation() call is possible
        Sleep(250);

        // Wait for access to this virtual fax device
        EnterCriticalSection(&pDeviceInfo->cs);

        if (pDeviceInfo->Status == DEVICE_ABORTING) {
            goto ExitUserAbort;
        }

        // Read the bytes from the source file
        if (ReadFile(hSourceFile, &FileBytes, sizeof(FileBytes), &dwBytes, NULL) == FALSE) {
            // Failed to read the bytes from the source file
            goto ExitFatalError;
        }

        if (dwBytes == 0) {
            // The file pointer has reached the end of the source file
            // Release access to this virtual fax device
            LeaveCriticalSection(&pDeviceInfo->cs);
            break;
        }

        // Write the bytes to the destination file
        if (WriteFile(hDestinationFile, &FileBytes, dwBytes, &dwBytes, NULL) == FALSE) {
            // Failed to write the bytes to the destination file
            goto ExitFatalError;
        }

        // Release access to this virtual fax device
        LeaveCriticalSection(&pDeviceInfo->cs);
    }

    // Wait for access to this virtual fax device
    EnterCriticalSection(&pDeviceInfo->cs);

    if (pDeviceInfo->Status == DEVICE_ABORTING) {
        goto ExitUserAbort;
    }

    // Close the destination file
    CloseHandle(hDestinationFile);

    // Close the source file
    CloseHandle(hSourceFile);

    // Set the fax job status
    pJobInfo->Status = FS_COMPLETED;
    // Post the FS_COMPLETED line status event to the fax service
    PostJobStatus(pJobInfo->CompletionPortHandle, pJobInfo->CompletionKey, FS_COMPLETED, ERROR_SUCCESS);

    // Release access to this virtual fax device
    LeaveCriticalSection(&pDeviceInfo->cs);

    WriteDebugString(L"---NewFsp: FaxDevSend Exit---\n");

    return TRUE;

ExitFatalError:
    // Set the fax job status
    pJobInfo->Status = FS_FATAL_ERROR;
    goto Exit;

ExitUserAbort:
    // Set the fax job status
    pJobInfo->Status = FS_USER_ABORT;
    goto Exit;

Exit:
    // Close and delete the destination file
    if (hDestinationFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hDestinationFile);

        DeleteFile(szDestinationFilename);
    }

    // Close the source file
    if (hSourceFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hSourceFile);
    }

    // Post the line status event to the fax service
    PostJobStatus(pJobInfo->CompletionPortHandle, pJobInfo->CompletionKey, pJobInfo->Status, ERROR_SUCCESS);

    // Release access to this virtual fax device
    LeaveCriticalSection(&pDeviceInfo->cs);

    WriteDebugString(L"---NewFsp: FaxDevSend Exit---\n");

    return FALSE;
}

BOOL WINAPI
FaxDevReceive(
    IN     HANDLE        FaxHandle,
    IN     HCALL         CallHandle,
    IN OUT PFAX_RECEIVE  FaxReceive
)
/*++

Routine Description:

  The fax service calls the FaxDevReceive function to signal an incoming fax transmission to the fax service provider

Arguments:

  FaxHandle - specifies a fax handle returned by the FaxDevStartJob function
  CallHandle - specifies a TAPI call handle
  FaxReceive - pointer to a FAX_RECEIVE stucture that contains information about an incoming fax document

Return Value:

  TRUE on success

--*/
{
    // pJobInfo is a pointer to the fax job data
    PJOB_INFO        pJobInfo;
    // pDeviceInfo is a pointer to the virtual fax device data
    PDEVICE_INFO     pDeviceInfo;

    // hSourceFile is the handle to the source file
    HANDLE           hSourceFile = INVALID_HANDLE_VALUE;
    // szSourceFilename is the source filename
    WCHAR            szSourceFilename[MAX_PATH];

    // hFindFile is a find file handle
    HANDLE           hFindFile = INVALID_HANDLE_VALUE;
    // FindData is a WIN32_FIND_DATA structure
    WIN32_FIND_DATA  FindData;
    // szSearchPath is the search path
    WCHAR            szSearchPath[MAX_PATH];

    // hDestinationFile is the handle to the destination file
    HANDLE           hDestinationFile = INVALID_HANDLE_VALUE;

    // FileBytes is the bytes to be copied from the source file to the destination file
    BYTE             FileBytes[1024];
    // dwBytes is the number of bytes read from the source file
    DWORD            dwBytes;

    WriteDebugString(L"---NewFsp: FaxDevReceive Enter---\n");

    if (FaxHandle == NULL) {
        // Set the error code
        SetLastError(ERROR_INVALID_HANDLE);

        WriteDebugString(L"   ERROR: FaxDevReceive Failed: ERROR_INVALID_HANDLE\n");
        WriteDebugString(L"---NewFsp: FaxDevReceive Exit---\n");
        return FALSE;
    }

    // Get the fax job data from FaxHandle
    pJobInfo = (PJOB_INFO) FaxHandle;
    // Get the virtual fax device data from the fax job data
    pDeviceInfo = (PDEVICE_INFO) pJobInfo->pDeviceInfo;

    // Wait for access to this virtual fax device
    EnterCriticalSection(&pDeviceInfo->cs);

    if (pDeviceInfo->Status == DEVICE_ABORTING) {
        goto ExitUserAbort;
    }

    // Set the virtual fax device status
    pDeviceInfo->Status = DEVICE_RECEIVE;

    // Set the fax job type
    pJobInfo->JobType = JOB_RECEIVE;
    // Copy the handle to the active call associated with the fax job
    pJobInfo->CallHandle = CallHandle;
    // Copy the full path to the file that contains the data stream for the fax document
    if (FaxReceive->FileName != NULL) {
        pJobInfo->FileName = MemAllocMacro((lstrlen(FaxReceive->FileName) + 1) * sizeof(WCHAR));
        if (pJobInfo->FileName != NULL) {
            lstrcpy(pJobInfo->FileName, FaxReceive->FileName);
        }
    }

    // Release access to this virtual fax device
    LeaveCriticalSection(&pDeviceInfo->cs);

    WriteDebugString(L"   CallHandle                 : 0x%08x\n", CallHandle);
    WriteDebugString(L"   FaxReceive->SizeOfStruct   : 0x%08x\n", FaxReceive->SizeOfStruct);
    WriteDebugString(L"   FaxReceive->FileName       : %s\n", FaxReceive->FileName);
    WriteDebugString(L"   FaxReceive->ReceiverName   : %s\n", FaxReceive->ReceiverName);
    WriteDebugString(L"   FaxReceive->ReceiverNumber : %s\n", FaxReceive->ReceiverNumber);

    // Wait for access to this virtual fax device
    EnterCriticalSection(&pDeviceInfo->cs);

    if (pDeviceInfo->Status == DEVICE_ABORTING) {
        goto ExitUserAbort;
    }

    // Set the fax job status
    pJobInfo->Status = FS_ANSWERED;
    // Post the FS_ANSWERED line status event to the fax service
    PostJobStatus(pJobInfo->CompletionPortHandle, pJobInfo->CompletionKey, FS_ANSWERED, ERROR_SUCCESS);

    // Set the search path
    lstrcpy(szSearchPath, pDeviceInfo->Directory);
    lstrcat(szSearchPath, L"\\*.tif");

    // Initialize the find file data
    ZeroMemory(&FindData, sizeof(FindData));
    FindData.dwFileAttributes |= FILE_ATTRIBUTE_DIRECTORY;

    // Find the incoming fax file
    hFindFile = FindFirstFile(szSearchPath, &FindData);
    if (hFindFile == INVALID_HANDLE_VALUE) {
        // The incoming fax file was not found
        goto ExitFatalError;
    }

    // Close the find file handle
    FindClose(hFindFile);
    hFindFile = INVALID_HANDLE_VALUE;

    // Set the source filename
    lstrcpy(szSourceFilename, pDeviceInfo->Directory);
    lstrcat(szSourceFilename, L"\\");
    lstrcat(szSourceFilename, FindData.cFileName);

    // Open the source file
    hSourceFile = CreateFile(szSourceFilename, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hSourceFile == INVALID_HANDLE_VALUE) {
        // The source file failed to be opened
        goto ExitFatalError;
    }

    // Open the destination file
    hDestinationFile = CreateFile(FaxReceive->FileName, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hDestinationFile == INVALID_HANDLE_VALUE) {
        // The destination file failed to be created
        goto ExitFatalError;
    }

    // Release access to this virtual fax device
    LeaveCriticalSection(&pDeviceInfo->cs);

    // Wait for access to this virtual fax device
    EnterCriticalSection(&pDeviceInfo->cs);

    if (pDeviceInfo->Status == DEVICE_ABORTING) {
        goto ExitUserAbort;
    }

    // Set the fax job status
    pJobInfo->Status = FS_RECEIVING;
    // Post the FS_RECEIVING line status event to the fax service
    PostJobStatus(pJobInfo->CompletionPortHandle, pJobInfo->CompletionKey, FS_RECEIVING, ERROR_SUCCESS);

    // Release access to this virtual fax device
    LeaveCriticalSection(&pDeviceInfo->cs);

    while (TRUE) {
        // The following sleep statement slows the bit copy to a reasonable speed so that a FaxDevAbortOperation() call is possible
        Sleep(250);

        // Wait for access to this virtual fax device
        EnterCriticalSection(&pDeviceInfo->cs);

        if (pDeviceInfo->Status == DEVICE_ABORTING) {
            goto ExitUserAbort;
        }

        // Read the bytes from the source file
        if (ReadFile(hSourceFile, &FileBytes, sizeof(FileBytes), &dwBytes, NULL) == FALSE) {
            // Failed to read the bytes from the source file
            goto ExitFatalError;
        }

        if (dwBytes == 0) {
            // The file pointer has reached the end of the source file
            // Release access to this virtual fax device
            LeaveCriticalSection(&pDeviceInfo->cs);
            break;
        }

        // Write the bytes to the destination file
        if (WriteFile(hDestinationFile, &FileBytes, dwBytes, &dwBytes, NULL) == TRUE) {
            // Failed to write the bytes to the destination file
            goto ExitFatalError;
        }

        // Release access to this virtual fax device
        LeaveCriticalSection(&pDeviceInfo->cs);
    }

    // Wait for access to this virtual fax device
    EnterCriticalSection(&pDeviceInfo->cs);

    if (pDeviceInfo->Status == DEVICE_ABORTING) {
        goto ExitUserAbort;
    }

    // Close the destination file
    CloseHandle(hDestinationFile);

    // Close the source file
    CloseHandle(hSourceFile);

    // Set the fax job status
    pJobInfo->Status = FS_COMPLETED;
    // Post the FS_COMPLETED line status event to the fax service
    PostJobStatus(pJobInfo->CompletionPortHandle, pJobInfo->CompletionKey, FS_COMPLETED, ERROR_SUCCESS);

    // Release access to this virtual fax device
    LeaveCriticalSection(&pDeviceInfo->cs);

    WriteDebugString(L"---NewFsp: FaxDevReceive Exit---\n");

    return TRUE;

ExitFatalError:
    // Set the fax job status
    pJobInfo->Status = FS_FATAL_ERROR;
    goto Exit;

ExitUserAbort:
    // Set the fax job status
    pJobInfo->Status = FS_USER_ABORT;
    goto Exit;

Exit:
    // Close the destination file
    if (hDestinationFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hDestinationFile);
    }

    // Close the source file
    if (hSourceFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hSourceFile);
    }

    // Post the line status event to the fax service
    PostJobStatus(pJobInfo->CompletionPortHandle, pJobInfo->CompletionKey, pJobInfo->Status, ERROR_SUCCESS);

    // Release access to this virtual fax device
    LeaveCriticalSection(&pDeviceInfo->cs);

    WriteDebugString(L"---NewFsp: FaxDevReceive Exit---\n");

    return FALSE;
}

BOOL WINAPI
FaxDevReportStatus(
    IN  HANDLE           FaxHandle OPTIONAL,
    OUT PFAX_DEV_STATUS  FaxStatus,
    IN  DWORD            FaxStatusSize,
    OUT LPDWORD          FaxStatusSizeRequired
)
/*++

Routine Description:

  The fax service calls the FaxDevReportStatus function to query a fax service provider for status information about an individual active fax operation or for status information after a failed fax operation

Arguments:

  FaxHandle - specifies a fax handle returned by the FaxDevStartJob function
  FaxStatus - pointer to a FAX_DEV_STATUS structure that receives status and identification information
  FaxStatusSize - specifies the size, in bytes, of the buffer pointer to by the FaxStatus parameter
  FaxStatusSizeRequired - pointer to a variable that receives the calculated size, in bytes, of the buffer required to hold the FAX_DEV_STATUS structure

Return Value:

  TRUE on success

--*/
{
    // pJobInfo is a pointer to the fax job data
    PJOB_INFO     pJobInfo;
    // pDeviceInfo is a pointer to the virtual fax device data
    PDEVICE_INFO  pDeviceInfo;
    // dwSize is the size of the completion packet
    DWORD         dwSize;
    // upString is the offset of the strings within the completion packet
    UINT_PTR      upStringOffset;

    WriteDebugString(L"---NewFsp: FaxDevReportStatus Enter---\n");

    if (FaxHandle == NULL) {
        // Set the error code
        SetLastError(ERROR_INVALID_HANDLE);

        WriteDebugString(L"   ERROR: FaxDevReportStatus Failed: ERROR_INVALID_HANDLE\n");
        WriteDebugString(L"---NewFsp: FaxDevReportStatus Exit---\n");
        return FALSE;
    }

    if (FaxStatusSizeRequired == NULL) {
        // Set the error code
        SetLastError(ERROR_INVALID_PARAMETER);

        WriteDebugString(L"   ERROR: FaxDevReportStatus Failed: ERROR_INVALID_PARAMETER\n");
        WriteDebugString(L"---NewFsp: FaxDevReportStatus Exit---\n");
        return FALSE;
    }

    if ((FaxStatus == NULL) && (FaxStatusSize != 0)) {
        // Set the error code
        SetLastError(ERROR_INVALID_PARAMETER);

        WriteDebugString(L"   ERROR: FaxDevReportStatus Failed: ERROR_INVALID_PARAMETER\n");
        WriteDebugString(L"---NewFsp: FaxDevReportStatus Exit---\n");
        return FALSE;
    }

    // Get the fax job data from FaxHandle
    pJobInfo = (PJOB_INFO) FaxHandle;
    // Get the virtual fax device data from the fax job data
    pDeviceInfo = (PDEVICE_INFO) pJobInfo->pDeviceInfo;

    // Wait for access to this virtual fax device
    EnterCriticalSection(&pDeviceInfo->cs);

    // Initialize the size of the completion packet
    dwSize = sizeof(FAX_DEV_STATUS);
    if (pJobInfo->CSI != NULL) {
        // Increase the size of the completion packet for the remote fax device indentifier
        dwSize += (lstrlen(pJobInfo->CSI) + 1) * sizeof(WCHAR);
    }
    if (pJobInfo->CallerId != NULL) {
        // Increase the size of the completion packet for the calling fax device identifier
        dwSize += (lstrlen(pJobInfo->CallerId) + 1) * sizeof(WCHAR);
    }
    if (pJobInfo->RoutingInfo != NULL) {
        // Increase the size of the completion packet for the routing string
        dwSize += (lstrlen(pJobInfo->RoutingInfo) + 1) * sizeof(WCHAR);
    }

    // Set the calculated size of the buffer required to hold the completion packet
    *FaxStatusSizeRequired = dwSize;

    if ((FaxStatus == NULL) && (FaxStatusSize == 0)) {
        // Release access to this virtual fax device
        LeaveCriticalSection(&pDeviceInfo->cs);

        WriteDebugString(L"---NewFsp: FaxDevReportStatus Exit---\n");
        return TRUE;
    }

    if (FaxStatusSize < dwSize) {
        // Set the error code
        SetLastError(ERROR_INSUFFICIENT_BUFFER);

        // Release access to this virtual fax device
        LeaveCriticalSection(&pDeviceInfo->cs);

        WriteDebugString(L"   ERROR: FaxDevReportStatus Failed: ERROR_INSUFFICIENT_BUFFER\n");
        WriteDebugString(L"---NewFsp: FaxDevReportStatus Exit---\n");
        return FALSE;
    }

    // Initialize upStringOffset
    upStringOffset = sizeof(FAX_DEV_STATUS);

    // Set the completion packet's structure size
    FaxStatus->SizeOfStruct = sizeof(FAX_DEV_STATUS);
    // Copy the completion packet's fax status identifier
    FaxStatus->StatusId = pJobInfo->Status;
    // Set the completion packet's string resource identifier to 0
    FaxStatus->StringId = 0;
    // Copy the completion packet's current page number
    FaxStatus->PageCount = pJobInfo->PageCount;
    // Copy the completion packet's remote fax device identifier
    if (pJobInfo->CSI != NULL) {
        FaxStatus->CSI = (LPWSTR) ((UINT_PTR) FaxStatus + upStringOffset);
        lstrcpy(FaxStatus->CSI, pJobInfo->CSI);
        upStringOffset += (lstrlen(pJobInfo->CSI) + 1) * sizeof(WCHAR);
    }
    // Set the completion packet's calling fax device identifier to NULL
    FaxStatus->CallerId = NULL;
    if (pJobInfo->CallerId != NULL) {
        FaxStatus->CallerId = (LPWSTR) ((UINT_PTR) FaxStatus + upStringOffset);
        lstrcpy(FaxStatus->CallerId, pJobInfo->CallerId);
        upStringOffset += (lstrlen(pJobInfo->CallerId) + 1) * sizeof(WCHAR);
    }
    // Set the completion packet's routing string to NULL
    FaxStatus->RoutingInfo = NULL;
    if (pJobInfo->RoutingInfo != NULL) {
        FaxStatus->RoutingInfo = (LPWSTR) ((UINT_PTR) FaxStatus + upStringOffset);
        lstrcpy(FaxStatus->RoutingInfo, pJobInfo->RoutingInfo);
        upStringOffset += (lstrlen(pJobInfo->RoutingInfo) + 1) * sizeof(WCHAR);
    }
    // Copy the completion packet's Win32 error code
    FaxStatus->ErrorCode = ERROR_SUCCESS;

    // Release access to this virtual fax device
    LeaveCriticalSection(&pDeviceInfo->cs);

    WriteDebugString(L"---NewFsp: FaxDevReportStatus Exit---\n");

    return TRUE;
}

BOOL WINAPI
FaxDevAbortOperation(
    IN HANDLE  FaxHandle
)
/*++

Routine Description:

  The fax service calls the FaxDevAbortOperation function to request that the fax service provider terminate the active fax operation for the fax job specified by the FaxHandle parameter

Arguments:

  FaxHandle - specifies a fax handle returned by the FaxDevStartJob function

Return Value:

  TRUE on success

--*/
{
    // pJobInfo is a pointer to the fax job data
    PJOB_INFO     pJobInfo;
    // pDeviceInfo is a pointer to the virtual fax device data
    PDEVICE_INFO  pDeviceInfo;

    WriteDebugString(L"---NewFsp: FaxDevAbortOperation Enter---\n");

    if (FaxHandle == NULL) {
        // Set the error code
        SetLastError(ERROR_INVALID_HANDLE);

        WriteDebugString(L"   ERROR: FaxDevAbortOperation Failed: ERROR_INVALID_HANDLE\n");
        WriteDebugString(L"---NewFsp: FaxDevAbortOperation Exit---\n");
        return FALSE;
    }

    // Get the fax job data from FaxHandle
    pJobInfo = (PJOB_INFO) FaxHandle;
    // Get the virtual fax device data from the fax job data
    pDeviceInfo = (PDEVICE_INFO) pJobInfo->pDeviceInfo;

    // Wait for access to this virtual fax device
    EnterCriticalSection(&pDeviceInfo->cs);

    // Set the virtual fax device status
    pDeviceInfo->Status = DEVICE_ABORTING;

    // Release access to this virtual fax device
    LeaveCriticalSection(&pDeviceInfo->cs);

    WriteDebugString(L"---NewFsp: FaxDevAbortOperation Exit---\n");

    return TRUE;
}

DWORD WINAPI DeviceReceiveThread(LPDWORD pdwDeviceId)
/*++

Routine Description:

  Thread to watch for an incoming fax transmission

Arguments:

  pdwDeviceId - pointer to the virtual fax device identifier

Return Value:

  DWORD

--*/
{
    // hChangeNotification is a handle to a notification change in a directory
    HANDLE         hChangeNotification;
    // hWaitObjects are the handles to the wait objects
    HANDLE         hWaitObjects[2];
    // dwDeviceId is the virtual fax device identifier
    DWORD          dwDeviceId;
    // pLineMessage is a pointer to LINEMESSAGE structure to signal an incoming fax transmission to the fax service
    LPLINEMESSAGE  pLineMessage;

    WriteDebugString(L"---NewFsp: DeviceReceiveThread Enter---\n");

    // Copy the virtual fax device identifier
    dwDeviceId = *pdwDeviceId;
    MemFreeMacro(pdwDeviceId);

    // Create the change notification handle
    hChangeNotification = FindFirstChangeNotification(g_pDeviceInfo[dwDeviceId]->Directory, FALSE, FILE_NOTIFY_CHANGE_ATTRIBUTES);
    if (hChangeNotification == INVALID_HANDLE_VALUE) {
        goto Exit;
    }

    // Wait for access to this virtual fax device
    EnterCriticalSection(&g_pDeviceInfo[dwDeviceId]->cs);

    // Set hWaitObjects
    hWaitObjects[0] = g_pDeviceInfo[dwDeviceId]->ExitEvent;
    hWaitObjects[1] = hChangeNotification;

    // Release access to this virtual fax device
    LeaveCriticalSection(&g_pDeviceInfo[dwDeviceId]->cs);

    while (TRUE) {
        // Wait for the exit event or notification change to be signaled
        if (WaitForMultipleObjects(2, hWaitObjects, FALSE, INFINITE) == WAIT_OBJECT_0) {
            break;
        }

        // Wait for access to this virtual fax device
        EnterCriticalSection(&g_pDeviceInfo[dwDeviceId]->cs);

        if (g_pDeviceInfo[dwDeviceId]->Status == DEVICE_IDLE) {
            // Allocate a block of memory for the completion packet
            pLineMessage = LocalAlloc(LPTR, sizeof(LINEMESSAGE));
            if (pLineMessage != NULL) {
                // Initialize the completion packet
                // Set the completion packet's handle to the virtual fax device
                pLineMessage->hDevice = dwDeviceId + NEWFSP_DEVICE_ID_PREFIX;
                // Set the completion packet's virtual fax device message
                pLineMessage->dwMessageID = 0;
                // Set the completion packet's instance data
                pLineMessage->dwCallbackInstance = 0;
                // Set the completion packet's first parameter
                pLineMessage->dwParam1 = LINEDEVSTATE_RINGING;
                // Set the completion packet's second parameter
                pLineMessage->dwParam2 = 0;
                // Set the completion packet's third parameter
                pLineMessage->dwParam3 = 0;

                WriteDebugString(L"---NewFsp: DeviceReceiveThread Signaling Fax Service...---\n");

                // Post the completion packet
                PostQueuedCompletionStatus(g_CompletionPort, sizeof(LINEMESSAGE), g_CompletionKey, (LPOVERLAPPED) pLineMessage);
            }
        }

        // Release access to this virtual fax device
        LeaveCriticalSection(&g_pDeviceInfo[dwDeviceId]->cs);

        // Find the next notification change
        FindNextChangeNotification(hChangeNotification);
    }

Exit:
    if (hChangeNotification != INVALID_HANDLE_VALUE) {
        // Close the handle to the change notification
        FindCloseChangeNotification(hChangeNotification);
    }

    // Close the handle to the exit event
    CloseHandle(hWaitObjects[0]);

    WriteDebugString(L"---NewFsp: DeviceReceiveThread Exit---\n");

    return 0;
}

STDAPI DllRegisterServer()
/*++

Routine Description:

  Function for the in-process server to create its registry entries

Return Value:

  S_OK on success

--*/
{
    // hModWinfax is the handle to the winfax module
    HANDLE                       hModWinfax;

    // szCurrentDirectory is the name of the current directory
    WCHAR                        szCurrentDirectory[MAX_PATH_LEN];
    // szCurrentFilename is the name of the current filename
    WCHAR                        szCurrentFilename[MAX_PATH];
    // szDestinationFilename is the name of the destination filename
    WCHAR                        szDestinationFilename[MAX_PATH];

    // pFaxRegisterServiceProvider is a pointer to the FaxRegisterServiceProvider() winfax api
    PFAXREGISTERSERVICEPROVIDER  pFaxRegisterServiceProvider;

    // pDeviceInfo is a pointer to the virtual fax devices
    PDEVICE_INFO                 pDeviceInfo;
    // pCurrentDeviceInfo is a pointer to the current virtual fax device
    PDEVICE_INFO                 pCurrentDeviceInfo;
    // dwIndex is a counter to enumerate each virtual fax device
    DWORD                        dwIndex;

    // Open the log file
    OpenLogFile(FALSE, NULL);

    WriteDebugString(L"---NewFsp: DllRegisterServer Enter---\n");

    // Get the current directory
    if (GetCurrentDirectory(MAX_PATH_LEN, szCurrentDirectory) == 0) {
        WriteDebugString(L"   ERROR: GetCurrentDirectory Failed: 0x%08x\n", GetLastError());
        WriteDebugString(L"   ERROR: DllRegisterServer Failed\n");
        WriteDebugString(L"---NewFsp: DllRegisterServer Exit---\n");

        // Close the log file
        CloseLogFile();

        return E_UNEXPECTED;
    }
    // Set the current filename
    lstrcpy(szCurrentFilename, szCurrentDirectory);
    lstrcat(szCurrentFilename, L"\\newfsp.dll");

    // Get the destination filename
    if (ExpandEnvironmentStrings(NEWFSP_PROVIDER_IMAGENAME, szDestinationFilename, MAX_PATH) == 0) {
        WriteDebugString(L"   ERROR: ExpandEnvironmentStrings Failed: 0x%08x\n", GetLastError());
        WriteDebugString(L"   ERROR: DllRegisterServer Failed\n");
        WriteDebugString(L"---NewFsp: DllRegisterServer Exit---\n");

        // Close the log file
        CloseLogFile();

        return E_UNEXPECTED;
    }

    if (lstrcmpi(szDestinationFilename, szCurrentFilename) != 0) {
        // Copy the current filename to the destination filename
        if (CopyFile(L"newfsp.dll", szDestinationFilename, FALSE) == FALSE) {
            WriteDebugString(L"   ERROR: CopyFile Failed: 0x%08x\n", GetLastError());
            WriteDebugString(L"   ERROR: DllRegisterServer Failed\n");
            WriteDebugString(L"---NewFsp: DllRegisterServer Exit---\n");

            // Close the log file
            CloseLogFile();

            return E_UNEXPECTED;
        }
    }

    // Load the winfax dll
    hModWinfax = LoadLibrary( L"winfax.dll" );
    if (hModWinfax == NULL) {
        WriteDebugString(L"   ERROR: LoadLibrary Failed: 0x%08x\n", GetLastError());
        WriteDebugString(L"   ERROR: DllRegisterServer Failed\n");
        WriteDebugString(L"---NewFsp: DllRegisterServer Exit---\n");

        // Close the log file
        CloseLogFile();

        return E_UNEXPECTED;
    }

    pFaxRegisterServiceProvider = (PFAXREGISTERSERVICEPROVIDER) GetProcAddress(hModWinfax, "FaxRegisterServiceProviderW");
    if (pFaxRegisterServiceProvider == NULL) {
        WriteDebugString(L"   ERROR: GetProcAddress Failed: 0x%08x\n", GetLastError());
        WriteDebugString(L"   ERROR: DllRegisterServer Failed\n");

        FreeLibrary(hModWinfax);

        WriteDebugString(L"---NewFsp: DllRegisterServer Exit---\n");

        // Close the log file
        CloseLogFile();

        return E_UNEXPECTED;
    }

    // Register the fax service provider
    if (pFaxRegisterServiceProvider(NEWFSP_PROVIDER, NEWFSP_PROVIDER_FRIENDLYNAME, NEWFSP_PROVIDER_IMAGENAME, NEWFSP_PROVIDER_PROVIDERNAME) == FALSE) {
        WriteDebugString(L"   ERROR: FaxRegisterServiceProvider Failed: 0x%08x\n", GetLastError());
        WriteDebugString(L"   ERROR: DllRegisterServer Failed\n");

        FreeLibrary(hModWinfax);

        WriteDebugString(L"---NewFsp: DllRegisterServer Exit---\n");

        // Close the log file
        CloseLogFile();

        return E_UNEXPECTED;
    }

    FreeLibrary(hModWinfax);

    // Set g_hHeap
    MemInitializeMacro(GetProcessHeap());

    // Create the virtual fax devices
    for (dwIndex = 0, pCurrentDeviceInfo = NULL, pDeviceInfo = NULL; dwIndex < NEWFSP_DEVICE_LIMIT; dwIndex++) {
        // Allocate a block of memory for the virtual fax device data
        if (pCurrentDeviceInfo == NULL) {
            pCurrentDeviceInfo = MemAllocMacro(sizeof(DEVICE_INFO));
            if (pCurrentDeviceInfo == NULL) {
                continue;
            }
        }
        else {
            pCurrentDeviceInfo->pNextDeviceInfo = MemAllocMacro(sizeof(DEVICE_INFO));
            if (pCurrentDeviceInfo->pNextDeviceInfo == NULL) {
                continue;
            }

            // Set the pointer to the current virtual fax device
            pCurrentDeviceInfo = pCurrentDeviceInfo->pNextDeviceInfo;
        }

        // Set the indentifier of the virtual fax device
        pCurrentDeviceInfo->DeviceId = dwIndex;
        // Set the virtual fax device's incoming fax directory to the current directory
        lstrcpy(pCurrentDeviceInfo->Directory, szCurrentDirectory);

        if (pDeviceInfo == NULL) {
            // Set the pointer to the virtual fax devices
            pDeviceInfo = pCurrentDeviceInfo;
        }
    }

    // Set the registry data for the newfsp service provider
    SetNewFspRegistryData(FALSE, szCurrentDirectory, pDeviceInfo);

    // Enumerate the virtual fax devices
    for (pCurrentDeviceInfo = pDeviceInfo; pCurrentDeviceInfo; pCurrentDeviceInfo = pDeviceInfo) {
        // Delete the virtual fax device data
        pDeviceInfo = pCurrentDeviceInfo->pNextDeviceInfo;
        MemFreeMacro(pCurrentDeviceInfo);
    }

    WriteDebugString(L"---NewFsp: DllRegisterServer Exit---\n");

    // Close the log file
    CloseLogFile();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\newfsp\newfsp.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  newfsp.h

Abstract:

  This module contains the newfsp definitions

--*/

#include <windows.h>
#include <stdio.h>
#include <tapi.h>
#include <faxdev.h>
#include <winfax.h>

#include "macros.h"
#include "reg.h"

// RESOURCE_STRING_LEN is the maximum length of a resource string
#define RESOURCE_STRING_LEN        256
// MAX_PATH_LEN is the maximum length of a fully-qualified path without the filename
#define MAX_PATH_LEN               MAX_PATH - 16

// NEWFSP_DEVICE_LIMIT is the virtual fax device limit of the newfsp service provider
#define NEWFSP_DEVICE_LIMIT        4

// NEWFSP_LOG_FILE is the name of the log file
#define NEWFSP_LOG_FILE            L"newfsp.log"

// DEVICE_NAME_PREFIX is the name prefix for the virtual fax devices
#define NEWFSP_DEVICE_NAME_PREFIX  L"NewFsp Device "
// DEVICE_ID_PREFIX is the value that identifies the virtual fax devices
#define NEWFSP_DEVICE_ID_PREFIX    0x10000

// DEVICE_IDLE indicates the virtual fax device is idle
#define DEVICE_IDLE                1
// DEVICE_START indicates the virtual fax device is pending a fax job
#define DEVICE_START               2
// DEVICE_SEND indicates the virtual fax device is sending
#define DEVICE_SEND                3
// DEVICE_RECEIVE indicates the virtual fax device is receiving
#define DEVICE_RECEIVE             4
// DEVICE_ABORTING indicates the virtual fax device is aborting
#define DEVICE_ABORTING            5

// JOB_UNKNOWN indicates the fax job is pending
#define JOB_UNKNOWN                1
// JOB_SEND indicates the fax job is a send
#define JOB_SEND                   2
// JOB_RECEIVE indicates the fax job is a receive
#define JOB_RECEIVE                3

typedef struct _DEVICE_INFO {
    CRITICAL_SECTION     cs;                      // object to serialize access to the virtual fax device
    DWORD                DeviceId;                // specifies the identifier of the virtual fax device
    WCHAR                Directory[MAX_PATH_LEN]; // specifies the virtual fax device's incoming fax directory
    DWORD                Status;                  // specifies the current status of the virtual fax device
    HANDLE               ExitEvent;               // specifies the handle to the event to indicate the thread to watch for an incoming fax transmission is to exit
    struct _DEVICE_INFO  *pNextDeviceInfo;        // pointer to the next virtual fax device
    struct _JOB_INFO     *pJobInfo;               // pointer to the fax job associated with the virtual fax device
} DEVICE_INFO, *PDEVICE_INFO;

typedef struct _JOB_INFO {
    PDEVICE_INFO         pDeviceInfo;             // pointer to the virtual fax device data associated with the fax job
    HANDLE               CompletionPortHandle;    // specifies a handle to an I/O completion port
    ULONG_PTR            CompletionKey;           // specifies a completion port key value
    DWORD                JobType;                 // specifies the fax job type
    DWORD                Status;                  // specifies the current status of the fax job
    HLINE                LineHandle;              // specifies a handle to the open line device associated with the fax job
    HCALL                CallHandle;              // specifies a handle to the active call associated with the fax job
    LPWSTR               FileName;                // specifies the full path to the file that contains the data stream for the fax document
    LPWSTR               CallerName;              // specifies the name of the calling device
    LPWSTR               CallerNumber;            // specifies the telephone number of the calling device
    LPWSTR               ReceiverName;            // specifies the name of the receiving device
    LPWSTR               ReceiverNumber;          // specifies the telephone number of the receiving device
    DWORD                RetryCount;              // specifies the number of retries associated with the fax job
    BOOL                 Branding;                // specifies whether the fax service provider should generate a brand at the top of the fax transmission
    DWORD                PageCount;               // specifies the number of pages associated with the fax job
    LPWSTR               CSI;                     // specifies the identifier of the remote fax device
    LPWSTR               CallerId;                // specifies the identifier of the calling fax device
    LPWSTR               RoutingInfo;             // specifies the routing string associated with the fax job
} JOB_INFO, *PJOB_INFO;

HANDLE        g_hInstance;       // g_hInstance is the global handle to the module
HLINEAPP      g_LineAppHandle;   // g_LineAppHandle is the global handle to the fax service's registration with TAPI
HANDLE        g_CompletionPort;  // g_CompletionPort is the global handle to an I/O completion port that the fax service provider must use to post I/O completion port packets to the fax service for asynchronous line status events
ULONG_PTR     g_CompletionKey;   // g_CompletionKey is the global completion port key value

HANDLE        g_hLogFile;        // g_hLogFile is the global handle to the log file
PDEVICE_INFO  *g_pDeviceInfo;    // g_pDeviceInfo is the global pointer to the virtual fax device data

// Function definitions:

BOOL
GetNewFspRegistryData(
    BOOL          *bLoggingEnabled,
    LPWSTR        lpszLoggingDirectory,
    PDEVICE_INFO  *pDeviceInfo,
    LPDWORD       pdwNumDevices
);

VOID
SetNewFspRegistryData(
    BOOL          bLoggingEnabled,
    LPWSTR        lpszLoggingDirectory,
    PDEVICE_INFO  pDeviceInfo
);

BOOL
OpenLogFile(
    BOOL    bLoggingEnabled,
    LPWSTR  lpszLoggingDirectory
);

VOID
CloseLogFile(
);

VOID
WriteDebugString(
    LPWSTR  lpszFormatString,
    ...
);

VOID
PostJobStatus(
    HANDLE     CompletionPort,
    ULONG_PTR  CompletionKey,
    DWORD      StatusId,
    DWORD      ErrorCode
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\newfsp\reg.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  reg.c

Abstract:

  This module implements registry functions for the newfsp service provider

--*/

#include "newfsp.h"

BOOL
GetNewFspRegistryData(
    BOOL          *bLoggingEnabled,
    LPWSTR        lpszLoggingDirectory,
    PDEVICE_INFO  *pDeviceInfo,
    LPDWORD       pdwNumDevices
)
/*++

Routine Description:

  Get the registry data for the newfsp service provider

Arguments:

  bLoggingEnabled - indicates if logging is enabled
  lpszLoggingDirectory - indicates the logging directory
  pDeviceInfo - pointer to the virtual fax devices
  pdwNumDevice - pointer to the number of virtual fax devices

Return Value:

  TRUE on success

--*/
{
    // hServiceProvidersKey is the handle to the fax service providers registry key
    HKEY          hServiceProvidersKey;
    // hNewFspKey is the handle to the newfsp service provider registry key
    HKEY          hNewFspKey;
    // hDevicesKey is the handle to the virtual fax devices registry key
    HKEY          hDevicesKey;
    // dwSubkeys is the number of virtual fax device registry subkeys
    DWORD         dwSubkeys;
    // dwIndex is a counter to enumerate each virtual fax device registry subkey
    DWORD         dwIndex;
    // szDeviceSubkey is the name of a virtual fax device registry subkey
    WCHAR         szDeviceSubkey[MAX_PATH];
    // hDeviceSubkey is the handle to a virtual fax device registry subkey
    HKEY          hDeviceSubkey;
    DWORD         dwType;

    // pCurrentDeviceInfo is a pointer to the current virtual fax device
    PDEVICE_INFO  pCurrentDeviceInfo;

    DWORD         dwLoggingEnabledSize;
    DWORD         dwLoggingDirectorySize;
    DWORD         dwDirectorySize;

    if (bLoggingEnabled != NULL) {
        *bLoggingEnabled = FALSE;
    }

    if (lpszLoggingDirectory != NULL) {
        ZeroMemory(lpszLoggingDirectory, sizeof(WCHAR) * MAX_PATH_LEN);
    }

    if (pDeviceInfo != NULL) {
        *pDeviceInfo = NULL;
    }

    if (pdwNumDevices != NULL) {
        *pdwNumDevices = 0;
    }


    // Open the fax service providers registry key
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, FAX_PROVIDERS_REGKEY, 0, KEY_ALL_ACCESS, &hServiceProvidersKey) != ERROR_SUCCESS) {
        return FALSE;
    }

    // Open the newfsp service provider registry key
    if (RegOpenKeyEx(hServiceProvidersKey, NEWFSP_PROVIDER, 0, KEY_ALL_ACCESS, &hNewFspKey) != ERROR_SUCCESS) {
        RegCloseKey(hServiceProvidersKey);
        return FALSE;
    }

    if (bLoggingEnabled != NULL) {
        // Get the logging enabled
        dwLoggingEnabledSize = sizeof(BOOL);
        RegQueryValueEx(hNewFspKey, NEWFSP_LOGGING_ENABLED, NULL, &dwType, (LPBYTE) bLoggingEnabled, &dwLoggingEnabledSize);
    }

    if (lpszLoggingDirectory != NULL) {
        // Get the logging directory
        dwLoggingDirectorySize = sizeof(WCHAR) * MAX_PATH_LEN;
        RegQueryValueEx(hNewFspKey, NEWFSP_LOGGING_DIRECTORY, NULL, &dwType, (LPBYTE) lpszLoggingDirectory, &dwLoggingDirectorySize);
    }

    if ((pDeviceInfo != NULL) || (pdwNumDevices != NULL)) {
        // Open the virtual fax devices registry key
        if (RegOpenKeyEx(hNewFspKey, NEWFSP_DEVICES, 0, KEY_ALL_ACCESS, &hDevicesKey) != ERROR_SUCCESS) {
            RegCloseKey(hNewFspKey);
            RegCloseKey(hServiceProvidersKey);
            return FALSE;
        }

        // Determine the number of virtual fax device registry subkeys
        if (RegQueryInfoKey(hDevicesKey, NULL, NULL, NULL, &dwSubkeys, NULL, NULL, NULL, NULL, NULL, NULL, NULL) != ERROR_SUCCESS) {
            RegCloseKey(hDevicesKey);
            RegCloseKey(hNewFspKey);
            RegCloseKey(hServiceProvidersKey);
            return FALSE;
        }
    }

    if (pdwNumDevices != NULL) {
        if (dwSubkeys < NEWFSP_DEVICE_LIMIT) {
            *pdwNumDevices = dwSubkeys;
        }
        else {
            *pdwNumDevices = NEWFSP_DEVICE_LIMIT;
        }
    }

    if (pDeviceInfo != NULL) {
        if (dwSubkeys > 0) {
            // Allocate a block of memory for the first virtual fax device data
            *pDeviceInfo = MemAllocMacro(sizeof(DEVICE_INFO));
        }

        // Enumerate the virtual fax device registry subkeys
        for (pCurrentDeviceInfo = *pDeviceInfo, dwIndex = 0; (dwIndex < dwSubkeys) && (dwIndex < NEWFSP_DEVICE_LIMIT); pCurrentDeviceInfo = pCurrentDeviceInfo->pNextDeviceInfo, dwIndex++) {
            if (pCurrentDeviceInfo == NULL) {
                // A memory allocation for virtual fax device data failed, so go with what we have so far
                *pdwNumDevices = dwIndex;

                break;
            }

            // Set the name of the virtual fax device registry subkey
            wsprintf(szDeviceSubkey, L"%d", dwIndex);
            // Set the identifier of the virtual fax device
            pCurrentDeviceInfo->DeviceId = dwIndex;

            if (RegOpenKeyEx(hDevicesKey, szDeviceSubkey, 0, KEY_ALL_ACCESS, &hDeviceSubkey) == ERROR_SUCCESS) {
                // Get the incoming fax directory for the virtual fax device
                dwDirectorySize = sizeof(WCHAR) * MAX_PATH_LEN;
                RegQueryValueEx(hDeviceSubkey, NEWFSP_DEVICE_DIRECTORY, NULL, &dwType, (LPBYTE) pCurrentDeviceInfo->Directory, &dwDirectorySize);

                RegCloseKey(hDeviceSubkey);
            }

            // Allocate a block of memory for the next virtual fax device data
            if ((dwIndex < (dwSubkeys - 1)) && (dwIndex < (NEWFSP_DEVICE_LIMIT - 1))) {
                pCurrentDeviceInfo->pNextDeviceInfo = MemAllocMacro(sizeof(DEVICE_INFO));
            }
            else {
                pCurrentDeviceInfo->pNextDeviceInfo = NULL;
            }
        }
    }

    if ((pDeviceInfo != NULL) || (pdwNumDevices != NULL)) {
        RegCloseKey(hDevicesKey);
    }

    RegCloseKey(hNewFspKey);
    RegCloseKey(hServiceProvidersKey);

    return TRUE;
}

VOID
SetNewFspRegistryData(
    BOOL          bLoggingEnabled,
    LPWSTR        lpszLoggingDirectory,
    PDEVICE_INFO  pDeviceInfo
)
/*++

Routine Description:

  Set the registry data for the newfsp service provider

Arguments:

  bLoggingEnabled - indicates if logging is enabled
  lpszLoggingDirectory - indicates the logging directory
  pDeviceInfo - pointer to the virtual fax devices

Return Value:

  None

--*/
{
    // hServiceProvidersKey is the handle to the fax service providers registry key
    HKEY          hServiceProvidersKey;
    // hNewFspKey is the handle to the newfsp service provider registry key
    HKEY          hNewFspKey;
    // hDevicesKey is the handle to the virtual fax devices registry key
    HKEY          hDevicesKey;
    // dwSubkeys is the number of virtual fax device registry subkeys
    DWORD         dwSubkeys;
    // dwIndex is a counter to enumerate each virtual fax device registry subkey
    DWORD         dwIndex;
    // szDeviceSubkey is the name of a virtual fax device registry subkey
    WCHAR         szDeviceSubkey[MAX_PATH];
    // hDeviceSubkey is the handle to a virtual fax device registry subkey
    HKEY          hDeviceSubkey;
    DWORD         dwDisposition;

    // pCurrentDeviceInfo is a pointer to the current virtual fax device
    PDEVICE_INFO  pCurrentDeviceInfo;

    // Open the fax service providers registry key
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, FAX_PROVIDERS_REGKEY, 0, KEY_ALL_ACCESS, &hServiceProvidersKey) != ERROR_SUCCESS) {
        return;
    }

    // Open the newfsp service provider registry key
    if (RegCreateKeyEx(hServiceProvidersKey, NEWFSP_PROVIDER, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hNewFspKey, &dwDisposition) != ERROR_SUCCESS) {
        RegCloseKey(hServiceProvidersKey);
        return;
    }

    // Set the logging enabled
    RegSetValueEx(hNewFspKey, NEWFSP_LOGGING_ENABLED, 0, REG_DWORD, (LPBYTE) &bLoggingEnabled, sizeof(bLoggingEnabled));

    // Set the logging directory
    if (lpszLoggingDirectory != NULL) {
        RegSetValueEx(hNewFspKey, NEWFSP_LOGGING_DIRECTORY, 0, REG_SZ, (LPBYTE) lpszLoggingDirectory, (lstrlen(lpszLoggingDirectory) + 1) * sizeof(WCHAR));
    }

    // Open the virtual fax devices registry key
    if (RegCreateKeyEx(hNewFspKey, NEWFSP_DEVICES, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hDevicesKey, &dwDisposition) != ERROR_SUCCESS) {
        RegCloseKey(hNewFspKey);
        RegCloseKey(hServiceProvidersKey);
        return;
    }

    // Determine the number of virtual fax device registry subkeys
    if (RegQueryInfoKey(hDevicesKey, NULL, NULL, NULL, &dwSubkeys, NULL, NULL, NULL, NULL, NULL, NULL, NULL) != ERROR_SUCCESS) {
        RegCloseKey(hDevicesKey);
        RegCloseKey(hNewFspKey);
        RegCloseKey(hServiceProvidersKey);
        return;
    }

    // Enumerate the virtual fax device registry subkeys
    for (pCurrentDeviceInfo = pDeviceInfo, dwIndex = 0; pCurrentDeviceInfo; pCurrentDeviceInfo = pCurrentDeviceInfo->pNextDeviceInfo, dwIndex++) {
        // Set the name of the virtual fax device registry subkey
        wsprintf(szDeviceSubkey, L"%d", pCurrentDeviceInfo->DeviceId);
        if (RegCreateKeyEx(hDevicesKey, szDeviceSubkey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hDeviceSubkey, &dwDisposition) == ERROR_SUCCESS) {
            // Set the incoming fax directory for the virtual fax device
            RegSetValueEx(hDeviceSubkey, NEWFSP_DEVICE_DIRECTORY, 0, REG_SZ, (LPBYTE) pCurrentDeviceInfo->Directory, (lstrlen(pCurrentDeviceInfo->Directory) + 1) * sizeof(WCHAR));

            RegCloseKey(hDeviceSubkey);
        }
    }

    // Delete any removed virtual fax device registry subkeys
    for ( ; dwIndex < dwSubkeys; dwIndex++) {
        // Set the name of the virtual fax device registry subkey
        wsprintf(szDeviceSubkey, L"%d", dwIndex);
        RegDeleteKey(hDevicesKey, szDeviceSubkey);
    }

    RegCloseKey(hDevicesKey);
    RegCloseKey(hNewFspKey);
    RegCloseKey(hServiceProvidersKey);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\newfsp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by newfsp.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\newfsp\reg.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  reg.h

Abstract:

  This module contains the registry definitions

--*/

#ifndef _REG_H
#define _REG_H

// FAX_PROVIDERS_REGKEY is the providers registry key under the fax registry key
#define FAX_PROVIDERS_REGKEY           L"Software\\Microsoft\\Fax\\Device Providers"

// NEWFSP_PROVIDER is the newfsp registry key under the providers registry key
#define NEWFSP_PROVIDER                L"NewFsp: Sample Windows NT Fax Service Provider"
// NEWFSP_PROVIDER_FRIENDLYNAME is the friendly name of the newfsp service provider
#define NEWFSP_PROVIDER_FRIENDLYNAME   L"NewFsp: Sample Windows NT Fax Service Provider"
// NEWFSP_PROVIDER_IMAGENAME is the image name of the newfsp service provider
#define NEWFSP_PROVIDER_IMAGENAME      L"%SystemRoot%\\system32\\newfsp.dll"
// NEWFSP_PROVIDER_PROVIDERNAME is the provider name of the newfsp service provider
#define NEWFSP_PROVIDER_PROVIDERNAME   L"NewFsp: Sample Windows NT Fax Service Provider"

// NEWFSP_LOGGING_ENABLED is the registry value indicating if logging is enabled
#define NEWFSP_LOGGING_ENABLED         L"LoggingEnabled"
// NEWFSP_LOGGING_DIRECTORY is the registry value indicating the logging directory
#define NEWFSP_LOGGING_DIRECTORY       L"LoggingDirectory"

// NEWFSP_DEVICES is the virtual fax devices registry key under the newfsp registry key
#define NEWFSP_DEVICES                 L"Devices"

// NEWFSP_DEVICE_DIRECTORY is the registry value indicating the incoming fax directory for the virtual fax device
#define NEWFSP_DEVICE_DIRECTORY        L"IncomingFaxDirectory"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\newfsp\util.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  util.c

Abstract:

  This module implements utility functions for the fax service provider

--*/

#include "newfsp.h"

BOOL
OpenLogFile(
    BOOL    bLoggingEnabled,
    LPWSTR  lpszLoggingDirectory
)
/*++

Routine Description:

  Open the log file

Arguments:

  bLoggingEnabled - indicates if logging is enabled
  lpszLoggingDirectory - indicates the logging directory
  pDeviceInfo - pointer to the virtual fax devices

Return Value:

  TRUE on success

--*/
{
    // szLoggingFilename is the logging file name
    WCHAR  szLoggingFilename[MAX_PATH];
    // cUnicodeBOM is the Unicode BOM
    WCHAR  cUnicodeBOM = 0xFEFF;
    DWORD  dwSize;

    if (bLoggingEnabled == TRUE) {
        // Set the logging file name
        lstrcpy(szLoggingFilename, lpszLoggingDirectory);
        lstrcat(szLoggingFilename, L"\\");
        lstrcat(szLoggingFilename, NEWFSP_LOG_FILE);

        // Create the new log file
        g_hLogFile = CreateFile(szLoggingFilename, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (g_hLogFile == INVALID_HANDLE_VALUE) {
            return FALSE;
        }

        // Write the Unicode BOM to the log file
        WriteFile(g_hLogFile, &cUnicodeBOM, sizeof(WCHAR), &dwSize, NULL);
    }
    else {
        g_hLogFile = INVALID_HANDLE_VALUE;
    }

    return TRUE;
}

VOID
CloseLogFile(
)
/*++

Routine Description:

  Close the log file

Return Value:

  None

--*/
{
    if (g_hLogFile != INVALID_HANDLE_VALUE) {
        CloseHandle(g_hLogFile);
        g_hLogFile = INVALID_HANDLE_VALUE;
    }
}

VOID
WriteDebugString(
    LPWSTR  lpszFormatString,
    ...
)
/*++

Routine Description:

  Write a debug string to the debugger and log file

Arguments:

  lpszFormatString - pointer to the string

Return Value:

  None

--*/
{
    va_list     varg_ptr;
    SYSTEMTIME  SystemTime;
    // szOutputString is the output string
    WCHAR       szOutputString[1024];
    DWORD       cb;

    // Initialize the buffer
    ZeroMemory(szOutputString, sizeof(szOutputString));

    // Get the current time
    GetLocalTime(&SystemTime);
    wsprintf(szOutputString, L"%02d.%02d.%04d@%02d:%02d:%02d.%03d:\n", SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear, SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond, SystemTime.wMilliseconds);
    cb = lstrlen(szOutputString);

    va_start(varg_ptr, lpszFormatString);
    _vsnwprintf(&szOutputString[cb], sizeof(szOutputString) - cb, lpszFormatString, varg_ptr);

    // Write the string to the debugger
    OutputDebugString(szOutputString);
    if (g_hLogFile != INVALID_HANDLE_VALUE) {
        // Write the string to the log file
        WriteFile(g_hLogFile, szOutputString, lstrlen(szOutputString) * sizeof(WCHAR), &cb, NULL);
    }
}

VOID
PostJobStatus(
    HANDLE     CompletionPort,
    ULONG_PTR  CompletionKey,
    DWORD      StatusId,
    DWORD      ErrorCode
)
/*++

Routine Description:

  Post a completion packet for a fax service provider fax job status change

Arguments:

  CompletionPort - specifies a handle to an I/O completion port
  CompletionKey - specifies a completion port key value
  StatusId - specifies a fax status code
  ErrorCode - specifies one of the Win32 error codes that the fax service provider should use to report an error that occurs

Return Value:

  TRUE on success

--*/
{
    // pFaxDevStatus is a pointer to the completion packet
    PFAX_DEV_STATUS  pFaxDevStatus;

    // Allocate a block of memory for the completion packet
    pFaxDevStatus = MemAllocMacro(sizeof(FAX_DEV_STATUS));
    if (pFaxDevStatus != NULL) {
        // Set the completion packet's structure size
        pFaxDevStatus->SizeOfStruct = sizeof(FAX_DEV_STATUS);
        // Copy the completion packet's fax status identifier
        pFaxDevStatus->StatusId = StatusId;
        // Set the completion packet's string resource identifier to 0
        pFaxDevStatus->StringId = 0;
        // Set the completion packet's current page number to 0
        pFaxDevStatus->PageCount = 0;
        // Set the completion packet's remote fax device identifier to NULL
        pFaxDevStatus->CSI = NULL;
        // Set the completion packet's calling fax device identifier to NULL
        pFaxDevStatus->CallerId = NULL;
        // Set the completion packet's routing string to NULL
        pFaxDevStatus->RoutingInfo = NULL;
        // Copy the completion packet's Win32 error code
        pFaxDevStatus->ErrorCode = ErrorCode;

        // Post the completion packet
        PostQueuedCompletionStatus(CompletionPort, sizeof(FAX_DEV_STATUS), CompletionKey, (LPOVERLAPPED) pFaxDevStatus);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\printsdi\faxdlg.cpp ===
// FaxDlg.cpp : implementation file
//

#include "stdafx.h"
#include "PrintSDI.h"
#include "FaxDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// FaxDlg dialog


FaxDlg::FaxDlg(CWnd* pParent /*=NULL*/)
	: CDialog(FaxDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(FaxDlg)
	m_FaxNumber = _T("");
	m_RecipientName = _T("");
	//}}AFX_DATA_INIT
}


void FaxDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(FaxDlg)
	DDX_Text(pDX, IDC_EDIT1, m_FaxNumber);
	DDV_MaxChars(pDX, m_FaxNumber, 30);
	DDX_Text(pDX, IDC_EDIT2, m_RecipientName);
	DDV_MaxChars(pDX, m_RecipientName, 64);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(FaxDlg, CDialog)
	//{{AFX_MSG_MAP(FaxDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// FaxDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\printsdi\faxdlg.h ===
#if !defined(AFX_FAXDLG_H__55689554_8B6C_11D1_B7AE_000000000000__INCLUDED_)
#define AFX_FAXDLG_H__55689554_8B6C_11D1_B7AE_000000000000__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// FaxDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// FaxDlg dialog

class FaxDlg : public CDialog
{
// Construction
public:
	FaxDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(FaxDlg)
	enum { IDD = IDD_FAX };
	CString	m_FaxNumber;
	CString	m_RecipientName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(FaxDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(FaxDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FAXDLG_H__55689554_8B6C_11D1_B7AE_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\printsdi\mainfrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "PrintSDI.h"

#include "MainFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
	// TODO: add member initialization code here
	
}

CMainFrame::~CMainFrame()
{
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CFrameWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\printsdi\newdocdlg.cpp ===
// NewDocDlg.cpp : implementation file
//

#include "stdafx.h"
#include "PrintSDI.h"
#include "NewDocDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// NewDocDlg dialog


NewDocDlg::NewDocDlg(CWnd* pParent /*=NULL*/)
	: CDialog(NewDocDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(NewDocDlg)
	m_szText = _T("");
	m_polytype = -1;
	//}}AFX_DATA_INIT
}


void NewDocDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(NewDocDlg)
	DDX_Text(pDX, IDC_EDIT1, m_szText);
	DDX_Radio(pDX, IDC_CIRCLE, m_polytype);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(NewDocDlg, CDialog)
	//{{AFX_MSG_MAP(NewDocDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// NewDocDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\printsdi\mainfrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__55689547_8B6C_11D1_B7AE_000000000000__INCLUDED_)
#define AFX_MAINFRM_H__55689547_8B6C_11D1_B7AE_000000000000__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CMainFrame : public CFrameWnd
{
protected: // create from serialization only
	CMainFrame();
	DECLARE_DYNCREATE(CMainFrame)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__55689547_8B6C_11D1_B7AE_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\printsdi\newdocdlg.h ===
#if !defined(AFX_NEWDOCDLG_H__55689553_8B6C_11D1_B7AE_000000000000__INCLUDED_)
#define AFX_NEWDOCDLG_H__55689553_8B6C_11D1_B7AE_000000000000__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// NewDocDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// NewDocDlg dialog

class NewDocDlg : public CDialog
{
// Construction
public:
	NewDocDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(NewDocDlg)
	enum { IDD = IDD_NEWDIALOG };
	CString	m_szText;
	int		m_polytype;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(NewDocDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(NewDocDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NEWDOCDLG_H__55689553_8B6C_11D1_B7AE_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\printsdi\printsdi.cpp ===
// PrintSDI.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "PrintSDI.h"

#include "MainFrm.h"
#include "PrintSDIDoc.h"
#include "PrintSDIView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPrintSDIApp

BEGIN_MESSAGE_MAP(CPrintSDIApp, CWinApp)
	//{{AFX_MSG_MAP(CPrintSDIApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
	// Standard print setup command
	ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPrintSDIApp construction

CPrintSDIApp::CPrintSDIApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CPrintSDIApp object

CPrintSDIApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CPrintSDIApp initialization

BOOL CPrintSDIApp::InitInstance()
{
	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	// Change the registry key under which our settings are stored.
	// You should modify this string to be something appropriate
	// such as the name of your company or organization.
	SetRegistryKey(_T("Local AppWizard-Generated Applications"));

	LoadStdProfileSettings();  // Load standard INI file options (including MRU)

	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	CSingleDocTemplate* pDocTemplate;
	pDocTemplate = new CSingleDocTemplate(
		IDR_MAINFRAME,
		RUNTIME_CLASS(CPrintSDIDoc),
		RUNTIME_CLASS(CMainFrame),       // main SDI frame window
		RUNTIME_CLASS(CPrintSDIView));
	AddDocTemplate(pDocTemplate);

	// Enable DDE Execute open
	EnableShellOpen();
	RegisterShellFileTypes(TRUE);

	// Parse command line for standard shell commands, DDE, file open
	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);

	// Dispatch commands specified on the command line
	if (!ProcessShellCommand(cmdInfo))
		return FALSE;

	// The one and only window has been initialized, so show and update it.
	m_pMainWnd->ShowWindow(SW_SHOW);
	m_pMainWnd->UpdateWindow();

	// Enable drag/drop open
	//m_pMainWnd->DragAcceptFiles();

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CPrintSDIApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CPrintSDIApp commands
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\printsdi\printsdi.h ===
// PrintSDI.h : main header file for the PRINTSDI application
//

#if !defined(AFX_PRINTSDI_H__55689543_8B6C_11D1_B7AE_000000000000__INCLUDED_)
#define AFX_PRINTSDI_H__55689543_8B6C_11D1_B7AE_000000000000__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CPrintSDIApp:
// See PrintSDI.cpp for the implementation of this class
//

class CPrintSDIApp : public CWinApp
{
public:
	CPrintSDIApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPrintSDIApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CPrintSDIApp)
	afx_msg void OnAppAbout();
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PRINTSDI_H__55689543_8B6C_11D1_B7AE_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\printsdi\printsdidoc.h ===
// PrintSDIDoc.h : interface of the CPrintSDIDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_PRINTSDIDOC_H__55689549_8B6C_11D1_B7AE_000000000000__INCLUDED_)
#define AFX_PRINTSDIDOC_H__55689549_8B6C_11D1_B7AE_000000000000__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


class CPrintSDIDoc : public CDocument
{
protected: // create from serialization only
	CPrintSDIDoc();
	DECLARE_DYNCREATE(CPrintSDIDoc)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPrintSDIDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	//}}AFX_VIRTUAL

// Implementation
public:
	int m_polytype;
	CString m_szText;
	virtual ~CPrintSDIDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CPrintSDIDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PRINTSDIDOC_H__55689549_8B6C_11D1_B7AE_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\printsdi\printsdiview.h ===
// PrintSDIView.h : interface of the CPrintSDIView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_PRINTSDIVIEW_H__5568954B_8B6C_11D1_B7AE_000000000000__INCLUDED_)
#define AFX_PRINTSDIVIEW_H__5568954B_8B6C_11D1_B7AE_000000000000__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CPrintSDIView : public CView
{
protected: // create from serialization only
	CPrintSDIView();
	DECLARE_DYNCREATE(CPrintSDIView)

// Attributes
public:
	CPrintSDIDoc* GetDocument();

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPrintSDIView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CPrintSDIView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CPrintSDIView)
	afx_msg void OnFileFax();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in PrintSDIView.cpp
inline CPrintSDIDoc* CPrintSDIView::GetDocument()
   { return (CPrintSDIDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PRINTSDIVIEW_H__5568954B_8B6C_11D1_B7AE_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\printsdi\printsdivw.cpp ===
// PrintSDIView.cpp : implementation of the CPrintSDIView class
//

#include "stdafx.h"
#include "PrintSDI.h"

#include "PrintSDIDoc.h"
#include "PrintSDIView.h"
#include "faxdlg.h"
#include <winfax.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPrintSDIView

IMPLEMENT_DYNCREATE(CPrintSDIView, CView)

BEGIN_MESSAGE_MAP(CPrintSDIView, CView)
	//{{AFX_MSG_MAP(CPrintSDIView)
	ON_COMMAND(ID_FILE_FAX, OnFileFax)
	//}}AFX_MSG_MAP
	// Standard printing commands
	ON_COMMAND(ID_FILE_PRINT, CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_DIRECT, CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, CView::OnFilePrintPreview)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPrintSDIView construction/destruction

CPrintSDIView::CPrintSDIView()
{
	// TODO: add construction code here

}

CPrintSDIView::~CPrintSDIView()
{
}

BOOL CPrintSDIView::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CPrintSDIView drawing

void CPrintSDIView::OnDraw(CDC* pDC)
{
	CPrintSDIDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	CRect rect;
	GetClientRect(rect);
    
	pDC->SetTextAlign(TA_BASELINE | TA_CENTER);
	pDC->SetTextColor(::GetSysColor(COLOR_WINDOWTEXT));
	pDC->SetBkMode(TRANSPARENT);
	pDC->TextOut(rect.right/2, 3*rect.bottom/4,pDoc->m_szText);

	CRect rect2( (rect.right-rect.left)/4 ,
				 (rect.top),
				 3*(rect.right-rect.left)/4,
				 (rect.bottom)/2);
	
	POINT pnt = {rect2.right/2,rect2.top};
	switch (pDoc->m_polytype) {
	case 0:
		//circle
		pDC->Arc(rect2,pnt,pnt);
		break;
	case 1:
		//sqare
		pDC->MoveTo(rect2.left,rect2.top);
		pDC->LineTo(rect2.right,rect2.top);
		pDC->LineTo(rect2.right,rect2.bottom);
		pDC->LineTo(rect2.left,rect2.bottom);
		pDC->LineTo(rect2.left,rect2.top);
		break;
	case 2:
		//triangle
		pDC->MoveTo(rect.right/2,rect2.top);
		pDC->LineTo(rect2.left,rect2.bottom);
		pDC->LineTo(rect2.right,rect2.bottom);
		pDC->LineTo(rect.right/2,rect2.top);
		break;
	default:		
		pDC->Arc(rect2,pnt,pnt);
	}

	CString dbg;
	dbg.Format(TEXT("%d %d %d %d\n"),rect2.left, rect2.top, rect2.right, rect2.bottom);
	OutputDebugString(dbg);
}

/////////////////////////////////////////////////////////////////////////////
// CPrintSDIView printing

BOOL CPrintSDIView::OnPreparePrinting(CPrintInfo* pInfo)
{
	// default preparation
	return DoPreparePrinting(pInfo);
}

void CPrintSDIView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add extra initialization before printing
}

void CPrintSDIView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add cleanup after printing
}

/////////////////////////////////////////////////////////////////////////////
// CPrintSDIView diagnostics

#ifdef _DEBUG
void CPrintSDIView::AssertValid() const
{
	CView::AssertValid();
}

void CPrintSDIView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}

CPrintSDIDoc* CPrintSDIView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CPrintSDIDoc)));
	return (CPrintSDIDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CPrintSDIView message handlers

void CPrintSDIView::OnFileFax() 
{
	FaxDlg dlg;
	dlg.DoModal();
	
	FAX_CONTEXT_INFO FaxContextInfo;
    FAX_PRINT_INFO FaxPrintInfo = {0};
	DWORD JobId;

	FaxContextInfo.SizeOfStruct = sizeof(FAX_CONTEXT_INFO);

	FaxPrintInfo.SizeOfStruct = sizeof(FAX_PRINT_INFO);
    FaxPrintInfo.RecipientNumber = dlg.m_FaxNumber.GetBuffer(MAX_PATH);
	FaxPrintInfo.RecipientName   = dlg.m_RecipientName.GetBuffer(MAX_PATH);
	
	// use the default FAX printer 
	if (!FaxStartPrintJob(NULL,&FaxPrintInfo,&JobId,&FaxContextInfo) ) {
		CString dbg;
		dbg.Format(_T("FaxStartPrintJob failed, ec = %d\n"),GetLastError() );
		AfxMessageBox(dbg);
		return;
	}

	// print the document
	CDC dc;
	dc.Attach(FaxContextInfo.hDC);
	OnDraw(&dc);	

	dc.EndDoc();
		
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\simple\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by simple.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\printsdi\sdidoc.cpp ===
// PrintSDIDoc.cpp : implementation of the CPrintSDIDoc class
//

#include "stdafx.h"
#include "PrintSDI.h"

#include "PrintSDIDoc.h"
#include "newdocdlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPrintSDIDoc

IMPLEMENT_DYNCREATE(CPrintSDIDoc, CDocument)

BEGIN_MESSAGE_MAP(CPrintSDIDoc, CDocument)
	//{{AFX_MSG_MAP(CPrintSDIDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPrintSDIDoc construction/destruction

CPrintSDIDoc::CPrintSDIDoc()
{
	m_szText.Empty();
	m_polytype = 0;

}

CPrintSDIDoc::~CPrintSDIDoc()
{
}

BOOL CPrintSDIDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;

	NewDocDlg newdlg;
	newdlg.DoModal();
	m_szText = newdlg.m_szText;

	m_polytype = newdlg.m_polytype;	

	return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// CPrintSDIDoc serialization

void CPrintSDIDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		ar << m_szText;
        ar << m_polytype;
	}
	else
	{
		ar >> m_szText;
        ar >> m_polytype;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CPrintSDIDoc diagnostics

#ifdef _DEBUG
void CPrintSDIDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CPrintSDIDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CPrintSDIDoc commands
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\printsdi\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	PrintSDI.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\printsdi\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by PrintSDI.rc
//
#define IDD_ABOUTBOX                    100
#define IDR_MAINFRAME                   128
#define IDR_PRINTSTYPE                  129
#define IDD_NEWDIALOG                   130
#define IDD_FAX                         131
#define IDC_EDIT1                       1000
#define IDC_CIRCLE                      1001
#define IDC_SQUARE                      1002
#define IDC_TRIANGLE                    1003
#define IDC_EDIT2                       1004
#define ID_FILE_FAX                     32771

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        132
#define _APS_NEXT_COMMAND_VALUE         32772
#define _APS_NEXT_CONTROL_VALUE         1005
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\printsdi\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__55689545_8B6C_11D1_B7AE_000000000000__INCLUDED_)
#define AFX_STDAFX_H__55689545_8B6C_11D1_B7AE_000000000000__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__55689545_8B6C_11D1_B7AE_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\samples\simple\simple.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

   simple.c

Abstract:

    This module implements a simple command line fax-send utility 
    
--*/


#include <windows.h>
#include <winbase.h>
#include <stdio.h>
#include <stdlib.h>
#include <winfax.h>
#include <tchar.h>
#include <assert.h>
#include <shellapi.h>


#ifdef DBG
   char    szDebugBuffer[80];
   #define DEBUG(parm1,parm2)\
            {\
                wsprintf(szDebugBuffer, parm1, parm2);\
                OutputDebugString(szDebugBuffer);\
            }
#else   
   #define DEBUG(parm1,parm2)
#endif


void GiveUsage(
              LPTSTR AppName
              )
{
   _tprintf( TEXT("Usage : %s /d <full path to doc> /n <number>\n --send a fax\n"),AppName);
   _tprintf( TEXT("Usage : %s /? -- this message\n"),AppName);

}

void PrintDeviceStatus(
                      PFAX_DEVICE_STATUS fds
                      )
{
   TCHAR SubmitBuffer[100];
   TCHAR StartBuffer[100];
   SYSTEMTIME SystemTime;

   if (!fds) {
      return;
   }

   _tprintf(TEXT("Device Id:\t\t%d\n"),fds->DeviceId );
   _tprintf(TEXT("Device Name:\t\t%s\n"),fds->DeviceName );
   _tprintf(TEXT("CallerId:\t\t%s\n"),fds->CallerId );
   _tprintf(TEXT("CSID:\t\t\t%s\n"),fds->Csid );
   _tprintf(TEXT("TSID:\t\t\t%s\n"),fds->Tsid );
   _tprintf(TEXT("Page:\t\t\t%d of %d\n"),fds->CurrentPage,fds->TotalPages );
   _tprintf(TEXT("DocumentName:\t\t%s\n"),fds->DocumentName);
   _tprintf(TEXT("JobType:\t\t%d\n"),fds->JobType);
   _tprintf(TEXT("PhoneNumber:\t\t%s\n"),fds->PhoneNumber);
   _tprintf(TEXT("SenderName:\t\t%s\n"),fds->SenderName);
   _tprintf(TEXT("RecipientName:\t\t%s\n"),fds->RecipientName);
   _tprintf(TEXT("Size (in bytes):\t%d\n"),fds->Size);
   _tprintf(TEXT("Status (see FPS flags):\t%x\n"),fds->Status);

   FileTimeToSystemTime(&fds->StartTime,&SystemTime);

   GetTimeFormat(LOCALE_SYSTEM_DEFAULT,
                 LOCALE_NOUSEROVERRIDE,
                 &SystemTime,
                 NULL,
                 StartBuffer,
                 sizeof(StartBuffer)
                );

   FileTimeToSystemTime(&fds->SubmittedTime,&SystemTime);
   SystemTimeToTzSpecificLocalTime(NULL,&SystemTime,&SystemTime);

   GetTimeFormat(LOCALE_SYSTEM_DEFAULT,
                 LOCALE_NOUSEROVERRIDE,
                 &SystemTime,
                 NULL,
                 SubmitBuffer,
                 sizeof(SubmitBuffer)
                );

   _tprintf(TEXT("Job Submited at %s\n"),SubmitBuffer);
   _tprintf(TEXT("Job transmission started at %s\n\n"),StartBuffer);

}

int _cdecl
main(
    int argc,
    char *argvA[]
    ) 
/*++

Routine Description:

    Entry point to the setup program

Arguments:

    argc - Number of args.
    argvA - the commandline arguments.


Return Value:


--*/
{
   LPTSTR *argv;
   int argcount = 0;
   TCHAR Document[MAX_PATH] = {0};
   TCHAR Number[64] = {0};
   HANDLE hFax;
   HANDLE hCompletionPort = INVALID_HANDLE_VALUE;
   PFAX_JOB_PARAM JobParam;
   PFAX_COVERPAGE_INFO CoverpageInfo;
   DWORD JobId;
   DWORD dwBytes, CompletionKey;
   PFAX_EVENT FaxEvent;
   BOOL bTerminate = FALSE;
   HANDLE hPort;
   PFAX_DEVICE_STATUS DeviceStatus;

   //
   // do commandline stuff
   //
#ifdef UNICODE
   argv = CommandLineToArgvW( GetCommandLine(), &argc );
#else
   argv = argvA;
#endif

   DEBUG ("Number of arguments = %d\n",argc);
   for (argcount=0;argcount<argc;argcount++) {
      DEBUG ("Arg %d:",argcount);
      DEBUG (" %s\n",argv[argcount]);
   }

   // check for commandline switches
   for (argcount=0; argcount<argc; argcount++) {
      if ((argv[argcount][0] == L'/') || (argv[argcount][0] == L'-')) {
         switch (towlower(argv[argcount][1])) {
            case 'n':
               lstrcpy(Number, argv[argcount+1]);
               break;
            case 'd':
               lstrcpy(Document, argv[argcount+1]);
               break;
            case '?':
               GiveUsage(argv[0]);
               return 0;
            default:
               break;
         }
      }
   }

   if (!Number[0] || !Document[0]) {
      _tprintf( TEXT("Missing args.\n") );
      GiveUsage(argv[0]);
      return -1;
   }

   //
   // connect to fax service
   //
   if (!FaxConnectFaxServer(NULL,&hFax)) {
      _tprintf( TEXT("FaxConnectFaxServer failed, ec = %d\n"),GetLastError() );
      return -1;
   }

   assert (hFax != NULL);

   hCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE,NULL,0,0);

   if (!hCompletionPort) {
      _tprintf( TEXT("CreateIoCompletionPort failed, ec = %d\n"), GetLastError() );
      FaxClose( hFax );
      return -1;
   }

   if (!FaxInitializeEventQueue(hFax,
                                hCompletionPort,
                                0,
                                NULL, 
                                0 ) ) {
      _tprintf( TEXT("FaxInitializeEventQueue failed, ec = %d\n"), GetLastError() );
      FaxClose( hFax );
      return -1;
   }

   FaxCompleteJobParams(&JobParam,&CoverpageInfo);

   JobParam->RecipientNumber = Number;

   if (!FaxSendDocument( hFax, Document, JobParam, NULL , &JobId) ) {
      _tprintf( TEXT("FaxSendDocument failed, ec = %d \n"), GetLastError() );
      FaxClose( hFax );
      CloseHandle( hCompletionPort );
      FaxFreeBuffer(JobParam);
      FaxFreeBuffer(CoverpageInfo);
      return -1;
   }

   _tprintf( TEXT("Queued document %s for transmition to %s, JobID = %d\n"),
             Document,
             Number,
             JobId );

   FaxFreeBuffer( JobParam );
   FaxFreeBuffer( CoverpageInfo );

   while (!bTerminate && GetQueuedCompletionStatus(hCompletionPort,
                                    &dwBytes,
                                    &CompletionKey,
                                    (LPOVERLAPPED *)&FaxEvent,
                                    INFINITE) ) {

      _tprintf( TEXT("Received event %x\n"),FaxEvent->EventId);

      switch (FaxEvent->EventId) {
         case FEI_IDLE:
         case FEI_COMPLETED:
         case FEI_MODEM_POWERED_ON: 
         case FEI_MODEM_POWERED_OFF:
         case FEI_FAXSVC_ENDED:     
            bTerminate = TRUE;
            break;

         case FEI_JOB_QUEUED:
            _tprintf( TEXT("JobId %d queued\n"),FaxEvent->JobId );
            break;

         case FEI_DIALING:          
         case FEI_SENDING:          
         case FEI_RECEIVING:              
         case FEI_BUSY:             
         case FEI_NO_ANSWER:        
         case FEI_BAD_ADDRESS:      
         case FEI_NO_DIAL_TONE:     
         case FEI_DISCONNECTED:           
         case FEI_FATAL_ERROR:      
            if (FaxOpenPort( hFax, FaxEvent->DeviceId,PORT_OPEN_QUERY, &hPort) ) {
               if (FaxGetDeviceStatus(hPort,&DeviceStatus) ) {
                  PrintDeviceStatus(DeviceStatus);
                  FaxFreeBuffer( DeviceStatus );
               }
               FaxClose( hPort );
            }

            break;

      }
   }

   FaxClose( hFax );
   CloseHandle( hCompletionPort );

   return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\addsvc\addsvc.c ===
#include <windows.h>
#include <stdio.h>
#include <tchar.h>


BOOL
AddService(
    LPTSTR ServiceName,
    LPTSTR ImageName
    )
{
    SC_HANDLE      hService;
    SC_HANDLE      hOldService;
    SERVICE_STATUS ServStat;


    if( !( hService = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS ) ) ) {
        return FALSE;
    }
    if( hOldService = OpenService( hService, ServiceName, SERVICE_ALL_ACCESS ) ) {
        if( ! ControlService( hOldService, SERVICE_CONTROL_STOP, & ServStat ) ) {
            int fError = GetLastError();
            if( ( fError != ERROR_SERVICE_NOT_ACTIVE ) && ( fError != ERROR_INVALID_SERVICE_CONTROL ) ) {
                return FALSE;
            }
        }
        if( ! DeleteService( hOldService ) ) {
            return FALSE;
        }
        if( ! CloseServiceHandle( hOldService ) ) {
            return FALSE;
        }
    }
    if( ! CreateService( hService, ServiceName, ServiceName, SERVICE_ALL_ACCESS,
                         SERVICE_WIN32_OWN_PROCESS, SERVICE_DEMAND_START,
                         SERVICE_ERROR_NORMAL, ImageName, NULL, NULL, NULL, NULL, NULL ) ) {
        int fError = GetLastError();
        if( fError != ERROR_SERVICE_EXISTS ) {
            return FALSE;
        }
    }

    return TRUE;
}


int _cdecl
main(
    int argc,
    char *argvA[]
    )
{
    if (!AddService( TEXT("Fax"), TEXT("faxsvc.exe") )) {
        _tprintf( TEXT("could not add service\n") );
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\client\handle.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    handle.c

Abstract:

    This module contains the handle table mgmt routines.

Author:

    Wesley Witt (wesw) 12-Nov-1996


Revision History:

--*/

#include "faxapi.h"
#pragma hdrstop




PHANDLE_ENTRY
CreateNewHandle(
    PFAX_HANDLE_DATA    FaxData,
    DWORD               Type,
    DWORD               Flags,
    HANDLE              FaxPortHandle
    )
{
    PHANDLE_ENTRY HandleEntry;


    HandleEntry = (PHANDLE_ENTRY) MemAlloc( sizeof(HANDLE_ENTRY) );
    if (!HandleEntry) {
        return NULL;
    }

    EnterCriticalSection( &FaxData->CsHandleTable );

    InsertTailList( &FaxData->HandleTableListHead, &HandleEntry->ListEntry );

    HandleEntry->Type           = Type;
    HandleEntry->Flags          = Flags;
    HandleEntry->FaxData        = FaxData;
    HandleEntry->FaxPortHandle  = FaxPortHandle;
    HandleEntry->DeviceId       = 0;
    HandleEntry->FaxContextHandle = NULL;

    LeaveCriticalSection( &FaxData->CsHandleTable );

    return HandleEntry;
}


PHANDLE_ENTRY
CreateNewServiceHandle(
    PFAX_HANDLE_DATA    FaxData
    )
{
    return CreateNewHandle(
        FaxData,
        FHT_SERVICE,
        0,
        NULL
        );
}


PHANDLE_ENTRY
CreateNewPortHandle(
    PFAX_HANDLE_DATA    FaxData,
    DWORD               Flags,
    HANDLE              FaxPortHandle
    )
{
    return CreateNewHandle(
        FaxData,
        FHT_PORT,
        Flags,
        FaxPortHandle       
        );
}


VOID
CloseFaxHandle(
    PFAX_HANDLE_DATA    FaxData,
    PHANDLE_ENTRY       HandleEntry
    )
{
    EnterCriticalSection( &FaxData->CsHandleTable );
    RemoveEntryList( &HandleEntry->ListEntry );
    HandleEntry->Type = 0;
    //
    // zero out this memory so we can't use it anymore
    //
    ZeroMemory(HandleEntry,sizeof(HANDLE_ENTRY));
    MemFree( HandleEntry );
    LeaveCriticalSection( &FaxData->CsHandleTable );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\client\config.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    print.c

Abstract:

    This module contains the configuration
    specific WINFAX API functions.

Author:

    Wesley Witt (wesw) 29-Nov-1996


Revision History:

--*/

#include "faxapi.h"
#pragma hdrstop



BOOL
WINAPI
FaxGetConfigurationW(
    IN HANDLE FaxHandle,
    OUT PFAX_CONFIGURATIONW *FaxConfig
    )

/*++

Routine Description:

    Retrieves the FAX configuration from the FAX server.
    The SizeOfStruct in the FaxConfig argument MUST be
    set to a value=>= sizeof(FAX_CONFIGURATION).

Arguments:

    FaxHandle   - FAX handle obtained from FaxConnectFaxServer.
    FaxConfig   - Pointer to a FAX_CONFIGURATION structure.

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    error_status_t ec;
    DWORD FaxConfigSize = 0;

    if (!ValidateFaxHandle(FaxHandle,FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       return FALSE;
    }

    if (!FaxConfig) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    *FaxConfig = NULL;

    ec = FAX_GetConfiguration(
        FH_FAX_HANDLE(FaxHandle),
        (LPBYTE*)FaxConfig,
        &FaxConfigSize
        );

    if (ec) {
        SetLastError( ec );
        return FALSE;
    }

    FixupStringPtr( FaxConfig, (*FaxConfig)->ArchiveDirectory );
    FixupStringPtr( FaxConfig, (*FaxConfig)->InboundProfile );

    return TRUE;
}


BOOL
WINAPI
FaxGetConfigurationA(
    IN HANDLE FaxHandle,
    OUT PFAX_CONFIGURATIONA *FaxConfigA
    )

/*++

Routine Description:

    Retrieves the FAX configuration from the FAX server.
    The SizeOfStruct in the FaxConfig argument MUST be
    set to a value=>= sizeof(FAX_CONFIGURATION).

Arguments:

    FaxHandle   - FAX handle obtained from FaxConnectFaxServer.
    FaxConfig   - Pointer to a FAX_CONFIGURATION structure.

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    if (!FaxGetConfigurationW(
            FaxHandle,
            (PFAX_CONFIGURATIONW*) FaxConfigA
            ))
    {
        return FALSE;
    }

    ConvertUnicodeStringInPlace( (LPWSTR) (*FaxConfigA)->ArchiveDirectory );
    ConvertUnicodeStringInPlace( (LPWSTR) (*FaxConfigA)->InboundProfile );

    return TRUE;
}


BOOL
WINAPI
FaxSetConfigurationW(
    IN HANDLE FaxHandle,
    IN const FAX_CONFIGURATIONW *FaxConfig
    )

/*++

Routine Description:

    Changes the FAX configuration on the FAX server.
    The SizeOfStruct in the FaxConfig argument MUST be
    set to a value == sizeof(FAX_CONFIGURATION).

Arguments:

    FaxHandle   - FAX handle obtained from FaxConnectFaxServer.
    FaxConfig   - Pointer to a FAX_CONFIGURATION structure.

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    error_status_t ec;

    if (!ValidateFaxHandle(FaxHandle,FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       return FALSE;
    }

    if (!FaxConfig) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    ec = FAX_SetConfiguration( FH_FAX_HANDLE(FaxHandle), FaxConfig );
    if (ec) {
        SetLastError( ec );
        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
FaxSetConfigurationA(
    IN HANDLE FaxHandle,
    IN const FAX_CONFIGURATIONA *FaxConfig
    )
{
    error_status_t ec;
    FAX_CONFIGURATIONW FaxConfigW;

    if (!ValidateFaxHandle(FaxHandle,FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       return FALSE;
    }

    if (!FaxConfig) {
       SetLastError(ERROR_INVALID_PARAMETER);
       return FALSE;
    }

    //
    // ansi structure is same size as unicode structure, so we can just copy it, then 
    // cast the string pointers correctly
    //
    CopyMemory(&FaxConfigW,FaxConfig,sizeof(FAX_CONFIGURATIONA));    

    if (FaxConfig->ArchiveDirectory) {
       FaxConfigW.ArchiveDirectory = AnsiStringToUnicodeString(FaxConfig->ArchiveDirectory);
    }

    if (FaxConfig->InboundProfile) {
        FaxConfigW.InboundProfile = AnsiStringToUnicodeString(FaxConfig->InboundProfile);        
    }

    ec = FAX_SetConfiguration( FH_FAX_HANDLE(FaxHandle), (PFAX_CONFIGURATIONW)&FaxConfigW );

    if (FaxConfigW.ArchiveDirectory) {
       MemFree((PVOID)FaxConfigW.ArchiveDirectory);
    }
    if (FaxConfigW.InboundProfile) {
       MemFree((PVOID)FaxConfigW.InboundProfile);
    }

    if (ec != ERROR_SUCCESS) {
        SetLastError(ec);
        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
FaxGetLoggingCategoriesA(
    IN  HANDLE FaxHandle,
    OUT PFAX_LOG_CATEGORYA *Categories,
    OUT LPDWORD NumberCategories
    )
{
    BOOL retval;
    DWORD i;

    if (!ValidateFaxHandle(FaxHandle,FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       return FALSE;
    }

    if (!Categories || !NumberCategories) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    retval = FaxGetLoggingCategoriesW(FaxHandle,(PFAX_LOG_CATEGORYW *)Categories , NumberCategories);
    if (!retval) {
        return FALSE;
    }

    for (i=0; i<*NumberCategories; i++) {
        ConvertUnicodeStringInPlace( (LPWSTR)(*Categories)[i].Name );
    }

    return TRUE;

}

BOOL
WINAPI
FaxGetLoggingCategoriesW(
    IN  HANDLE FaxHandle,
    OUT PFAX_LOG_CATEGORYW *Categories,
    OUT LPDWORD NumberCategories
    )
{
    error_status_t ec;
    DWORD BufferSize = 0;
    DWORD i;

    if (!ValidateFaxHandle(FaxHandle,FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       return FALSE;
    }

    if (!Categories || !NumberCategories) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *Categories = NULL;
    *NumberCategories = 0;

    ec = FAX_GetLoggingCategories(
        FH_FAX_HANDLE(FaxHandle),
        (LPBYTE*)Categories,
        &BufferSize,
        NumberCategories
        );
    if (ec != ERROR_SUCCESS) {
        SetLastError(ec);
        return FALSE;
    }

    for (i=0; i<*NumberCategories; i++) {
        FixupStringPtr( Categories, (*Categories)[i].Name );
    }

    return TRUE;
}


BOOL
WINAPI
FaxSetLoggingCategoriesA(
    IN  HANDLE FaxHandle,
    IN  const FAX_LOG_CATEGORYA *Categories,
    IN  DWORD NumberCategories
    )
{
    DWORD i;
    PFAX_LOG_CATEGORYW CategoryW;
    BOOL retval;

    if (!ValidateFaxHandle(FaxHandle,FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       return FALSE;
    }
    
    if (!Categories || !NumberCategories) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    CategoryW = MemAlloc( sizeof(FAX_LOG_CATEGORYW) * NumberCategories ); 
    if (!CategoryW) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    for (i = 0; i< NumberCategories; i++) {
        CategoryW[i].Category = Categories[i].Category;
        CategoryW[i].Level = Categories[i].Level;
        CategoryW[i].Name = (LPCWSTR) AnsiStringToUnicodeString(Categories[i].Name);
        if (!CategoryW[i].Name && Categories[i].Name) {
            goto error_exit;
        }
    }

    retval = FaxSetLoggingCategoriesW(FaxHandle, CategoryW, NumberCategories);

    for (i = 0; i< NumberCategories; i++) {
        if (CategoryW[i].Name) MemFree((LPBYTE)CategoryW[i].Name);
    }
    
    MemFree(CategoryW);

    return retval;

error_exit:

    for (i = 0; i< NumberCategories; i++) {
        if (CategoryW[i].Name) MemFree((LPBYTE)CategoryW[i].Name);
    }
    
    MemFree(CategoryW);

    SetLastError(ERROR_NOT_ENOUGH_MEMORY);

    return FALSE;

}


BOOL
WINAPI
FaxSetLoggingCategoriesW(
    IN  HANDLE FaxHandle,
    IN  const FAX_LOG_CATEGORY *Categories,
    IN  DWORD NumberCategories
    )
{
    error_status_t ec;
    DWORD BufferSize;
    DWORD i;
    LPBYTE Buffer;
    ULONG_PTR Offset;
    PFAX_LOG_CATEGORY LogCat;

    if (!ValidateFaxHandle(FaxHandle,FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       return FALSE;
    }

    if (!Categories || !NumberCategories) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    Offset = BufferSize = sizeof(FAX_LOG_CATEGORY) * NumberCategories;

    for (i=0; i<NumberCategories; i++) {
        BufferSize += StringSize( Categories[i].Name );
    }

    Buffer = (LPBYTE) MemAlloc( BufferSize );
    if (Buffer == NULL) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    LogCat = (PFAX_LOG_CATEGORY) Buffer;

    for (i=0; i<NumberCategories; i++) {
        LogCat[i].Category = Categories[i].Category;
        LogCat[i].Level = Categories[i].Level;

        StoreString(
            Categories[i].Name,
            (PULONG_PTR) &LogCat[i].Name,
            Buffer,
            &Offset
            );
    }

    ec = FAX_SetLoggingCategories(
        FH_FAX_HANDLE(FaxHandle),
        Buffer,
        BufferSize,
        NumberCategories
        );

    MemFree( Buffer );

    if (ec != ERROR_SUCCESS) {
        SetLastError(ec);
        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
FaxGetTapiLocationsW(
    IN HANDLE FaxHandle,
    OUT PFAX_TAPI_LOCATION_INFOW *TapiLocationInfo
    )

/*++

Routine Description:

    Gets the tapi location information from the fax server.

Arguments:

    FaxHandle           - FAX handle obtained from FaxConnectFaxServer.
    LocationSize,       - Size of the TapiLocationInfo buffer.
    TapiLocationInfo    - Buffer to receive the data.
    BytesNeeded         - Required size.

Return Value:

    ERROR_SUCCESS for success, otherwise a WIN32 error code.

--*/

{
    error_status_t ec;
    DWORD i;
    DWORD LocationSize = 0;

    if (!FaxHandle || !TapiLocationInfo) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    ec = FAX_GetTapiLocations(
        FH_FAX_HANDLE(FaxHandle),
        (LPBYTE*) TapiLocationInfo,
        &LocationSize
        );
    if (ec) {
        SetLastError( ec );
        return FALSE;
    }

    (*TapiLocationInfo)->TapiLocations =
        (PFAX_TAPI_LOCATIONS) ((LPBYTE)*TapiLocationInfo + (ULONG_PTR)(*TapiLocationInfo)->TapiLocations);

    for (i=0; i<(*TapiLocationInfo)->NumLocations; i++) {
        if ((*TapiLocationInfo)->TapiLocations[i].LocationName) {
            (*TapiLocationInfo)->TapiLocations[i].LocationName =
                (LPWSTR) ((LPBYTE)*TapiLocationInfo + (ULONG_PTR)(*TapiLocationInfo)->TapiLocations[i].LocationName);
        }
        if ((*TapiLocationInfo)->TapiLocations[i].TollPrefixes) {
            (*TapiLocationInfo)->TapiLocations[i].TollPrefixes =
                (LPWSTR) ((LPBYTE)*TapiLocationInfo + (ULONG_PTR)(*TapiLocationInfo)->TapiLocations[i].TollPrefixes);
        }
    }

    return TRUE;
}


BOOL
WINAPI
FaxGetTapiLocationsA(
    IN HANDLE FaxHandle,
    OUT PFAX_TAPI_LOCATION_INFOA *TapiLocationInfo
    )

/*++

Routine Description:

    Gets the tapi location information from the fax server.

Arguments:

    FaxHandle           - FAX handle obtained from FaxConnectFaxServer.
    LocationSize,       - Size of the TapiLocationInfo buffer.
    TapiLocationInfo    - Buffer to receive the data.
    BytesNeeded         - Required size.

Return Value:

    ERROR_SUCCESS for success, otherwise a WIN32 error code.

--*/

{
    DWORD i;


    if (!FaxGetTapiLocationsW( FaxHandle, (PFAX_TAPI_LOCATION_INFOW*) TapiLocationInfo )) {
        return FALSE;
    }

    for (i=0; i<(*TapiLocationInfo)->NumLocations; i++) {
        ConvertUnicodeStringInPlace( (LPWSTR) (*TapiLocationInfo)->TapiLocations[i].LocationName );
        ConvertUnicodeStringInPlace( (LPWSTR) (*TapiLocationInfo)->TapiLocations[i].TollPrefixes );
    }

    return TRUE;
}


BOOL
WINAPI
FaxSetTapiLocationsW(
    IN HANDLE FaxHandle,
    IN PFAX_TAPI_LOCATION_INFOW TapiLocationInfo
    )

/*++

Routine Description:

    Changes the tapi location information on the fax server.

Arguments:

    FaxHandle           - FAX handle obtained from FaxConnectFaxServer.
    TapiLocationInfo    - Buffer containing the data.

Return Value:

    ERROR_SUCCESS for success, otherwise a WIN32 error code.

--*/

{
    error_status_t ec;
    PFAX_TAPI_LOCATION_INFOW Tmp;
    DWORD Size;
    DWORD i,j;
    ULONG_PTR Offset;
    LPWSTR p,s;


    //
    // do some parameter validation
    //

    if (!FaxHandle || !TapiLocationInfo) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    for (i=0; i<TapiLocationInfo->NumLocations; i++) {
        if (TapiLocationInfo->TapiLocations[i].TollPrefixes) {
            s = (LPTSTR)TapiLocationInfo->TapiLocations[i].TollPrefixes;
            while( s && *s ) {
                p = wcschr( s, L',' );
                if (p) {
                    *p = 0;
                }
                for (j=0; j<wcslen(s); j++) {
                    if (!iswdigit(s[j])) {
                        SetLastError( ERROR_INVALID_PARAMETER );
                        return FALSE;
                    }
                }
                j = _wtoi( s );
                if ((j < 200) || (j > 999)) {
                    SetLastError( ERROR_INVALID_PARAMETER );
                    return FALSE;
                }
                if (p) {
                    *p = L',';
                    s = p + 1;
                } else {
                    s += wcslen( s );
                }
            }
        }
    }

    //
    // calculate the required size
    //

    Size = sizeof(FAX_TAPI_LOCATION_INFOW) + (TapiLocationInfo->NumLocations * sizeof(FAX_TAPI_LOCATIONSW));
    for (i=0; i<TapiLocationInfo->NumLocations; i++) {
        Size += StringSize( TapiLocationInfo->TapiLocations[i].TollPrefixes );
        Size += StringSize( TapiLocationInfo->TapiLocations[i].LocationName );
    }

    //
    // allocate the memory
    //

    Tmp = (PFAX_TAPI_LOCATION_INFOW) MemAlloc( Size );
    if (!Tmp) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    //
    // fill in the temporary FAX_TAPI_LOCATION_INFO structure
    //

    Tmp->CurrentLocationID = TapiLocationInfo->CurrentLocationID;
    Tmp->NumLocations = TapiLocationInfo->NumLocations;

    Offset = sizeof(FAX_TAPI_LOCATION_INFOW);
    Tmp->TapiLocations = (PFAX_TAPI_LOCATIONSW) ((LPBYTE)Tmp + Offset);

    Offset += (TapiLocationInfo->NumLocations * sizeof(FAX_TAPI_LOCATIONSW));

    for (i=0; i<TapiLocationInfo->NumLocations; i++) {

        Tmp->TapiLocations[i].PermanentLocationID = TapiLocationInfo->TapiLocations[i].PermanentLocationID;
        Tmp->TapiLocations[i].CountryCode = TapiLocationInfo->TapiLocations[i].CountryCode;
        Tmp->TapiLocations[i].AreaCode = TapiLocationInfo->TapiLocations[i].AreaCode;
        Tmp->TapiLocations[i].NumTollPrefixes = TapiLocationInfo->TapiLocations[i].NumTollPrefixes;

        StoreString(
            TapiLocationInfo->TapiLocations[i].LocationName,
            (PULONG_PTR) &Tmp->TapiLocations[i].LocationName,
            (LPBYTE) Tmp,
            &Offset
            );

        StoreString(
            TapiLocationInfo->TapiLocations[i].TollPrefixes,
            (PULONG_PTR) &Tmp->TapiLocations[i].TollPrefixes,
            (LPBYTE) Tmp,
            &Offset
            );

    }

    Tmp->TapiLocations = (PFAX_TAPI_LOCATIONSW) ((LPBYTE)Tmp->TapiLocations - (ULONG_PTR)Tmp);

    //
    // call the server to change the tapi locations
    //

    ec = FAX_SetTapiLocations(
        FH_FAX_HANDLE(FaxHandle),
        (LPBYTE) Tmp,
        Size
        );

    //
    // free the temporary FAX_TAPI_LOCATION_INFO structure
    //

    MemFree( Tmp );

    //
    // return
    //

    if (ec) {
        SetLastError( ec );
        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
FaxSetTapiLocationsA(
    IN HANDLE FaxHandle,
    IN PFAX_TAPI_LOCATION_INFOA TapiLocationInfo
    )

/*++

Routine Description:

    Changes the tapi location information on the fax server.

Arguments:

    FaxHandle           - FAX handle obtained from FaxConnectFaxServer.
    TapiLocationInfo    - Buffer containing the data.

Return Value:

    ERROR_SUCCESS for success, otherwise a WIN32 error code.

--*/

{
    error_status_t ec;
    PFAX_TAPI_LOCATION_INFOA Tmp;
    DWORD Size;
    DWORD i,j;
    ULONG_PTR Offset;
    LPSTR p,s;


    //
    // do some parameter validation
    //

    if (!FaxHandle || !TapiLocationInfo) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    for (i=0; i<TapiLocationInfo->NumLocations; i++) {
        if (TapiLocationInfo->TapiLocations[i].TollPrefixes) {
            s = (LPSTR)TapiLocationInfo->TapiLocations[i].TollPrefixes;
            while( s && *s ) {
                p = strchr( s, ',' );
                if (p) {
                    *p = 0;
                }
                for (j=0; j<strlen(s); j++) {
                    if (!isdigit(s[j])) {
                        SetLastError( ERROR_INVALID_PARAMETER );
                        return FALSE;
                    }
                }
                j = atoi( s );
                if ((j < 200) || (j > 999)) {
                    SetLastError( ERROR_INVALID_PARAMETER );
                    return FALSE;
                }
                if (p) {
                    *p = ',';
                    s = p + 1;
                } else {
                    s += strlen( s );
                }
            }
        }
    }

    //
    // calculate the required size
    //

    Size = sizeof(FAX_TAPI_LOCATION_INFOA) + (TapiLocationInfo->NumLocations * sizeof(FAX_TAPI_LOCATIONSA));
    for (i=0; i<TapiLocationInfo->NumLocations; i++) {
        Size += ((strlen(TapiLocationInfo->TapiLocations[i].TollPrefixes) + 1) * sizeof(WCHAR));
        Size += ((strlen(TapiLocationInfo->TapiLocations[i].LocationName) + 1) * sizeof(WCHAR));
    }

    //
    // allocate the memory
    //

    Tmp = (PFAX_TAPI_LOCATION_INFOA) MemAlloc( Size );
    if (!Tmp) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    //
    // fill in the temporary FAX_TAPI_LOCATION_INFO structure
    //

    Tmp->CurrentLocationID = TapiLocationInfo->CurrentLocationID;
    Tmp->NumLocations = TapiLocationInfo->NumLocations;

    Offset = sizeof(FAX_TAPI_LOCATION_INFOA);
    Tmp->TapiLocations = (PFAX_TAPI_LOCATIONSA) ((LPBYTE)Tmp + Offset);

    Offset += (TapiLocationInfo->NumLocations * sizeof(FAX_TAPI_LOCATIONSA));

    for (i=0; i<TapiLocationInfo->NumLocations; i++) {

        Tmp->TapiLocations[i].PermanentLocationID = TapiLocationInfo->TapiLocations[i].PermanentLocationID;
        Tmp->TapiLocations[i].CountryCode = TapiLocationInfo->TapiLocations[i].CountryCode;
        Tmp->TapiLocations[i].AreaCode = TapiLocationInfo->TapiLocations[i].AreaCode;
        Tmp->TapiLocations[i].NumTollPrefixes = TapiLocationInfo->TapiLocations[i].NumTollPrefixes;

        StoreStringA(
            TapiLocationInfo->TapiLocations[i].LocationName,
            (PULONG_PTR) &Tmp->TapiLocations[i].LocationName,
            (LPBYTE) Tmp,
            &Offset
            );

        StoreStringA(
            TapiLocationInfo->TapiLocations[i].TollPrefixes,
            (PULONG_PTR) &Tmp->TapiLocations[i].TollPrefixes,
            (LPBYTE) Tmp,
            &Offset
            );

    }

    Tmp->TapiLocations = (PFAX_TAPI_LOCATIONSA) ((LPBYTE)Tmp->TapiLocations - (ULONG_PTR)Tmp);

    //
    // call the server to change the tapi locations
    //

    ec = FAX_SetTapiLocations(
        FH_FAX_HANDLE(FaxHandle),
        (LPBYTE) Tmp,
        Size
        );

    //
    // free the temporary FAX_TAPI_LOCATION_INFO structure
    //

    MemFree( Tmp );

    //
    // return
    //

    if (ec) {
        SetLastError( ec );
        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
FaxGetMapiProfilesA(
    IN HANDLE FaxHandle,
    OUT LPBYTE *MapiProfiles
    )

/*++

Routine Description:

    Queries the server for the MAPI profiles.

Arguments:

    FaxHandle           - FAX handle obtained from FaxConnectFaxServer.
    MapiProfiles        - Multi-SZ string containing all MAPI profiles
    ProfileSize         - Size of the MapiProfiles array

Return Value:

    ERROR_SUCCESS for success, otherwise a WIN32 error code.

--*/

{
    error_status_t ec;
    DWORD ProfileSize = 0;

    if (!FaxHandle || !MapiProfiles) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    ec = FAX_GetMapiProfiles(
        FH_FAX_HANDLE(FaxHandle),
        MapiProfiles,
        &ProfileSize
        );

    if (ec) {
        SetLastError(ec);
        return FALSE;
    }

    if (!ConvertUnicodeMultiSZInPlace( (LPWSTR) *MapiProfiles, ProfileSize )) {
        SetLastError(ERROR_NOT_ENOUGH_SERVER_MEMORY);
        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
FaxGetMapiProfilesW(
    IN HANDLE FaxHandle,
    OUT LPBYTE *MapiProfiles
    )

/*++

Routine Description:

    Queries the server for the MAPI profiles.

Arguments:

    FaxHandle           - FAX handle obtained from FaxConnectFaxServer.
    MapiProfiles        - Multi-SZ string containing all MAPI profiles
    ProfileSize         - Size of the MapiProfiles array

Return Value:

    ERROR_SUCCESS for success, otherwise a WIN32 error code.

--*/

{
    error_status_t ec;
    DWORD ProfileSize = 0;

    if (!FaxHandle || !MapiProfiles) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    ec = FAX_GetMapiProfiles(
        FH_FAX_HANDLE(FaxHandle),
        MapiProfiles,
        &ProfileSize
        );
    if (ec) {
        SetLastError(ec);
        return FALSE;
    }
    return TRUE;
}



FaxEnumGlobalRoutingInfoW(
    IN  HANDLE FaxHandle,
    OUT PFAX_GLOBAL_ROUTING_INFOW *RoutingInfoBuffer,
    OUT LPDWORD MethodsReturned
    )
{
    PFAX_GLOBAL_ROUTING_INFOW FaxRoutingInfo = NULL;
    error_status_t ec;
    DWORD i;
    DWORD RoutingInfoBufferSize = 0;

    if (!ValidateFaxHandle(FaxHandle,FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       return FALSE;
    }
        
    if (!RoutingInfoBuffer || !MethodsReturned) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *RoutingInfoBuffer = NULL;

    ec = FAX_EnumGlobalRoutingInfo(
        FH_FAX_HANDLE(FaxHandle),
        (LPBYTE*)RoutingInfoBuffer,
        &RoutingInfoBufferSize,
        MethodsReturned
        );
    if (ec) {
        SetLastError( ec );
        return FALSE;
    }

    FaxRoutingInfo = (PFAX_GLOBAL_ROUTING_INFOW) *RoutingInfoBuffer;

    for (i=0; i<*MethodsReturned; i++) {
        FixupStringPtr( RoutingInfoBuffer, FaxRoutingInfo[i].Guid );
        FixupStringPtr( RoutingInfoBuffer, FaxRoutingInfo[i].FunctionName );
        FixupStringPtr( RoutingInfoBuffer, FaxRoutingInfo[i].FriendlyName );
        FixupStringPtr( RoutingInfoBuffer, FaxRoutingInfo[i].ExtensionImageName );
        FixupStringPtr( RoutingInfoBuffer, FaxRoutingInfo[i].ExtensionFriendlyName );
    }

    return TRUE;
}


BOOL
WINAPI
FaxEnumGlobalRoutingInfoA(
    IN  HANDLE FaxHandle,
    OUT PFAX_GLOBAL_ROUTING_INFOA *RoutingInfoBuffer,
    OUT LPDWORD MethodsReturned
    )
{
    PFAX_GLOBAL_ROUTING_INFOW FaxRoutingMethod = NULL;
    DWORD i;


    if (!FaxEnumGlobalRoutingInfoW(
        FaxHandle,
        (PFAX_GLOBAL_ROUTING_INFOW *)RoutingInfoBuffer,
        MethodsReturned
        ))
    {
        return FALSE;
    }

    FaxRoutingMethod = (PFAX_GLOBAL_ROUTING_INFOW) *RoutingInfoBuffer;

    for (i=0; i<*MethodsReturned; i++) {        
        ConvertUnicodeStringInPlace( (LPWSTR)FaxRoutingMethod[i].Guid );
        ConvertUnicodeStringInPlace( (LPWSTR)FaxRoutingMethod[i].FunctionName );
        ConvertUnicodeStringInPlace( (LPWSTR)FaxRoutingMethod[i].FriendlyName );
        ConvertUnicodeStringInPlace( (LPWSTR)FaxRoutingMethod[i].ExtensionImageName );
        ConvertUnicodeStringInPlace( (LPWSTR)FaxRoutingMethod[i].ExtensionFriendlyName );
    }

    return TRUE;
}


BOOL
WINAPI
FaxSetGlobalRoutingInfoW(
    IN  HANDLE FaxHandle,
    IN  const FAX_GLOBAL_ROUTING_INFOW *RoutingInfo
    )
{
    error_status_t ec;

    if (!ValidateFaxHandle(FaxHandle,FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       return FALSE;
    }

    if (!RoutingInfo) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (RoutingInfo->SizeOfStruct != sizeof(FAX_GLOBAL_ROUTING_INFOW)) {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    ec = FAX_SetGlobalRoutingInfo( FH_FAX_HANDLE(FaxHandle), RoutingInfo );
    if (ec) {
        SetLastError( ec );
        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
FaxSetGlobalRoutingInfoA(
    IN  HANDLE FaxHandle,
    IN  const FAX_GLOBAL_ROUTING_INFOA *RoutingInfo
    )
{
    BOOL Rval;

    FAX_GLOBAL_ROUTING_INFOW RoutingInfoW;

    if (!ValidateFaxHandle(FaxHandle,FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       return FALSE;
    }

    if (!RoutingInfo || RoutingInfo->SizeOfStruct != sizeof(FAX_GLOBAL_ROUTING_INFOA)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    RoutingInfoW.SizeOfStruct = sizeof(FAX_GLOBAL_ROUTING_INFOW);
    RoutingInfoW.Priority = RoutingInfo->Priority;

    RoutingInfoW.Guid                  = AnsiStringToUnicodeString( RoutingInfo->Guid                  );
    RoutingInfoW.FriendlyName          = AnsiStringToUnicodeString( RoutingInfo->FriendlyName          );
    RoutingInfoW.FunctionName          = AnsiStringToUnicodeString( RoutingInfo->FunctionName          );
    RoutingInfoW.ExtensionImageName    = AnsiStringToUnicodeString( RoutingInfo->ExtensionImageName    );
    RoutingInfoW.ExtensionFriendlyName = AnsiStringToUnicodeString( RoutingInfo->ExtensionFriendlyName );
      
    Rval = FaxSetGlobalRoutingInfoW( FaxHandle, &RoutingInfoW);

    
    if (RoutingInfoW.Guid)                  MemFree( (LPBYTE) RoutingInfoW.Guid ) ;                 
    if (RoutingInfoW.FriendlyName)          MemFree( (LPBYTE) RoutingInfoW.FriendlyName ) ;         
    if (RoutingInfoW.FunctionName)          MemFree( (LPBYTE) RoutingInfoW.FunctionName ) ;         
    if (RoutingInfoW.ExtensionImageName)    MemFree( (LPBYTE) RoutingInfoW.ExtensionImageName ) ;   
    if (RoutingInfoW.ExtensionFriendlyName) MemFree( (LPBYTE) RoutingInfoW.ExtensionFriendlyName ) ;

    return Rval;
}


BOOL
WINAPI
FaxAccessCheck(
    IN HANDLE FaxHandle,
    IN DWORD AccessMask
    )
{
    BOOL fPermission = FALSE;
    error_status_t ec;

    if (!ValidateFaxHandle(FaxHandle,FHT_SERVICE)) {
        SetLastError( ERROR_INVALID_HANDLE );
    }
    
    ec = FAX_AccessCheck( FH_FAX_HANDLE( FaxHandle ), AccessMask, &fPermission );

    if (ec) {
        SetLastError( ec );        
    } else {
        SetLastError( ERROR_SUCCESS ) ;
    }

    return fPermission;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\client\install.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    install.c

Abstract:

    This module contains installation functions.

Author:

    Andrew Ritz (andrewr) 9-Dec-1997


Revision History:

--*/

#include "faxapi.h"
#pragma hdrstop

extern HINSTANCE MyhInstance;

BOOL CreatePrinterandGroups();
BOOL CreateLocalFaxPrinter(LPWSTR FaxPrinterName,LPWSTR SourceRoot);
VOID CreateGroupItems(LPWSTR ServerName);

BOOL AddMethodKey(
    HKEY hKey,
    LPCWSTR MethodName,
    LPCWSTR FriendlyName,
    LPCWSTR FunctionName,
    LPCWSTR Guid,
    DWORD Priority
    ) ;


WINFAXAPI
BOOL
WINAPI
FaxRegisterServiceProviderW(
    IN LPCWSTR DeviceProvider,
    IN LPCWSTR FriendlyName,
    IN LPCWSTR ImageName,
    IN LPCWSTR TspName
    )
{
    HKEY hKey;
    BOOL RetVal = TRUE;
    WCHAR KeyName[256];

    if (!DeviceProvider || !FriendlyName || !ImageName ||!TspName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    wsprintf(KeyName,L"%s\\%s\\%s",REGKEY_SOFTWARE,REGKEY_DEVICE_PROVIDERS,DeviceProvider);
    hKey = OpenRegistryKey(HKEY_LOCAL_MACHINE,
                           KeyName,
                           TRUE,
                           0);
    
    if (!hKey) {
        return FALSE;
    }


    //
    // add values
    //

    if (! (SetRegistryString(hKey,REGVAL_FRIENDLY_NAME,FriendlyName) &&
           SetRegistryStringExpand(hKey,REGVAL_IMAGE_NAME,ImageName) &&
           SetRegistryString(hKey,REGVAL_PROVIDER_NAME,TspName) )) {
        goto error_exit;
    }

    RegCloseKey(hKey);

    
    //
    // create printer, program group, etc.
    //
    if (!CreatePrinterandGroups()) {        
        return FALSE;
    }


    return TRUE;

error_exit:
    //
    // delete the subkey on failure
    //
    wsprintf(KeyName,L"%s\\%s",REGKEY_SOFTWARE,REGKEY_DEVICE_PROVIDERS);
    hKey = OpenRegistryKey(HKEY_LOCAL_MACHINE,KeyName,FALSE,0);
    RegDeleteKey(hKey, DeviceProvider ); 

    RegCloseKey(hKey);
    return FALSE;
}



WINFAXAPI
BOOL
WINAPI
FaxRegisterRoutingExtensionW(
    IN HANDLE  FaxHandle,
    IN LPCWSTR ExtensionName,
    IN LPCWSTR FriendlyName,
    IN LPCWSTR ImageName,
    IN PFAX_ROUTING_INSTALLATION_CALLBACKW CallBack,
    IN LPVOID Context
    )
{
    HKEY hKey = NULL;
    BOOL RetVal = FALSE;
    WCHAR KeyName[256];

    PFAX_GLOBAL_ROUTING_INFO RoutingInfo;
    DWORD dwMethods;

    WCHAR  MethodName[64];
    WCHAR  MethodFriendlyName[64];
    WCHAR  MethodFunctionName[64];
    WCHAR  MethodGuid[64];
    
    if (!ValidateFaxHandle(FaxHandle, FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       return FALSE;
    }

    if (!ExtensionName || !FriendlyName || !ImageName ||!CallBack) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    //
    // local installation only
    //
    if (!IsLocalFaxConnection(FaxHandle) ) {
          SetLastError(ERROR_INVALID_FUNCTION);
          return FALSE;
    }
    

    //
    // get the number of current methods for priority
    //
    if (!FaxEnumGlobalRoutingInfo(FaxHandle,&RoutingInfo,&dwMethods) ){
        DebugPrint((TEXT("FaxEnumGlobalRoutingInfo() failed, ec = %d\n"),GetLastError() ));
        return FALSE;
    }

    FaxFreeBuffer(RoutingInfo);    


    wsprintf(KeyName,L"%s\\%s\\%s",REGKEY_SOFTWARE,REGKEY_ROUTING_EXTENSIONS,ExtensionName);
    hKey = OpenRegistryKey(HKEY_LOCAL_MACHINE,
                           KeyName,
                           TRUE,
                           0);
    
    if (!hKey) {
        return FALSE;
    }
    
    
    //
    // add values
    //
    
    if (! (SetRegistryString(hKey,REGVAL_FRIENDLY_NAME,FriendlyName) &&
           SetRegistryStringExpand(hKey,REGVAL_IMAGE_NAME,ImageName) )) {
        RetVal = FALSE;
        goto error_exit;
    }
    
    RegCloseKey (hKey);
    
    wcscat(KeyName, L"\\");
    wcscat(KeyName, REGKEY_ROUTING_METHODS);
    hKey = OpenRegistryKey(HKEY_LOCAL_MACHINE,
                           KeyName,
                           TRUE,
                           0);
    
    if (!hKey) {
        goto error_exit;
    }

    while (TRUE) {
        ZeroMemory( MethodName,         sizeof(MethodName) );
        ZeroMemory( MethodFriendlyName, sizeof(MethodFriendlyName) );
        ZeroMemory( MethodFunctionName, sizeof(MethodFunctionName) );
        ZeroMemory( MethodGuid,         sizeof(MethodGuid) );
        
        __try {
           RetVal = CallBack(FaxHandle,
                             Context,
                             MethodName,
                             MethodFriendlyName,
                             MethodFunctionName,
                             MethodGuid
                             );

           if (!RetVal) {
               break;
           }

           dwMethods++;
           if (!AddMethodKey(hKey,MethodName,MethodFriendlyName,MethodFunctionName,MethodGuid,dwMethods) ) {
               goto error_exit;
           }

        }  __except (EXCEPTION_EXECUTE_HANDLER) {
              goto error_exit;
        }

        

    }

    RegCloseKey( hKey );
    return TRUE;

error_exit:

    if (hKey) {
        RegCloseKey( hKey );
    }

    //
    // delete the subkey on failure
    //
    wsprintf(KeyName,L"%s\\%s",REGKEY_SOFTWARE,REGKEY_ROUTING_METHODS);
    hKey = OpenRegistryKey(HKEY_LOCAL_MACHINE,KeyName,FALSE,0);
    RegDeleteKey(hKey, ExtensionName ); 
    
    RegCloseKey(hKey);
    return FALSE;



}
 
BOOL AddMethodKey(
    HKEY hKey,
    LPCWSTR MethodName,
    LPCWSTR FriendlyName,
    LPCWSTR FunctionName,
    LPCWSTR Guid,
    DWORD  Priority
    ) 
{
    HKEY hKeyNew;

    hKeyNew = OpenRegistryKey(hKey,
                              MethodName,
                              TRUE,
                              0);    
    if (!hKeyNew) {
        return FALSE;
    }
        
    //
    // add values
    //
    
    if (! (SetRegistryString(hKeyNew, REGVAL_FRIENDLY_NAME,FriendlyName) &&
           SetRegistryString(hKeyNew, REGVAL_FUNCTION_NAME,FunctionName) &&
           SetRegistryString(hKeyNew, REGVAL_GUID,Guid) &&
           SetRegistryDword(hKeyNew, REGVAL_PRIORITY,Priority) )) {

        goto error_exit;
    }
    
    RegCloseKey(hKeyNew);
    return TRUE;

error_exit:
    RegCloseKey(hKeyNew);
    RegDeleteKey(hKey, MethodName);

    return FALSE;
}

BOOL CreatePrinterandGroups()
{
    WCHAR PrinterName[64];
    HKEY hKeySource;
    LPWSTR SourcePath;    
    HMODULE hModSetup;
    LPWSTR FaxPrinter;
    FARPROC CreateLocalFaxPrinter;
    FARPROC CreateGroupItems;               

    //
    // check if we have a fax printer installed, add one if we don't have one.
    //
    if ((FaxPrinter = GetFaxPrinterName())) {
        MemFree(FaxPrinter);
        //return EnsureFaxServiceIsStarted(NULL);
        return TRUE;
    } 
    else {
        //
        // printer installation routines in faxocm.dll module.
        //
        hModSetup = LoadLibrary(L"faxocm.dll");
        if (!hModSetup) {
            return FALSE;
        }
    
        CreateLocalFaxPrinter = GetProcAddress(hModSetup, "CreateLocalFaxPrinter");
        CreateGroupItems = GetProcAddress(hModSetup, "CreateGroupItems");
    
        if (!CreateLocalFaxPrinter || !CreateGroupItems) {
            FreeLibrary(hModSetup);
            return FALSE;
        }
        
        //
        // create a fax printer
        //
                
        LoadString( MyhInstance, IDS_DEFAULT_PRINTER_NAME, PrinterName, sizeof(PrinterName)/sizeof(WCHAR) );
        
        hKeySource = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_WINDOWSNT_CURRVER, FALSE, KEY_READ );
        if (hKeySource) {
            SourcePath = GetRegistryString( hKeySource, REGVAL_SOURCE_PATH, EMPTY_STRING );
            RegCloseKey( hKeySource );
        } else {
            SourcePath = StringDup( EMPTY_STRING );
        }
        
        
        if (SourcePath) {
            if (!CreateLocalFaxPrinter( PrinterName, SourcePath )) {
                DebugPrint(( L"CreateLocalFaxPrinter() failed" ));
            }
            MemFree( SourcePath );
        }
        
        
        //
        // add program group items
        //
    
        CreateGroupItems( NULL );

        FreeLibrary(hModSetup);

        //
        // start the fax service, which should add new devices
        //
    
        //return EnsureFaxServiceIsStarted(NULL);
        return TRUE;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\client\clirpc.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    clirpc.c

Abstract:

    This module contains the client side RPC
    functions.  These functions are used when the
    WINFAX client runs as an RPC server too.  These
    functions are the ones available for the RPC
    clients to call.  Currently the only client
    of these functions is the fax service.

Author:

    Wesley Witt (wesw) 29-Nov-1996


Revision History:

--*/

#include "faxapi.h"
#pragma hdrstop

BOOL RpcServerStarted;



VOID
WINAPI
FaxFreeBuffer(
    LPVOID Buffer
    )
{
    MemFree( Buffer );
}


void *
MIDL_user_allocate(
    IN size_t NumBytes
    )
{
    return MemAlloc( NumBytes );
}


void
MIDL_user_free(
    IN void *MemPointer
    )
{
    MemFree( MemPointer );
}


DWORD
FaxServerThread(
    LPVOID UnUsed
    )

/*++

Routine Description:

    Thread to process RPC messages from the various fax servers.

Arguments:

    AsyncInfo       - Packet of data necessary for processing this thread

Return Value:

    Always zero.

--*/

{
    error_status_t ec;

    ec = RpcMgmtWaitServerListen();
    if (ec != 0) {
        return ec;
    }

    return 0;
}


BOOL
WINAPI
FaxInitializeEventQueue(
    IN HANDLE FaxHandle,
    IN HANDLE CompletionPort,
    IN ULONG_PTR CompletionKey,
    IN HWND hWnd,
    IN UINT MessageStart
    )

/*++

Routine Description:

    Initializes the client side event queue.  There can be one event
    queue initialized for each fax server that the client app is
    connected to.

Arguments:

    FaxHandle       - FAX handle obtained from FaxConnectFaxServer.
    CompletionPort  - Handle of an existing completion port opened using CreateIoCompletionPort.
    CompletionKey   - A value that will be returned through the lpCompletionKey parameter of GetQueuedCompletionStatus.
    hWnd            - Window handle to post events to
    MessageStart    - Starting message number, message range used is MessageStart + FEI_NEVENTS

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    DWORD ThreadId;
    HANDLE hThread;
    PASYNC_EVENT_INFO AsyncInfo;
    DWORD Size;
    error_status_t ec;
    TCHAR ComputerName[64];
    TCHAR ClientName[64];
    DWORD FaxSvcProcessId;

    if (CompletionPort && hWnd) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if (!ValidateFaxHandle(FaxHandle, FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       return FALSE;
    }        

    if (hWnd && !IsLocalFaxConnection(FaxHandle)) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if (hWnd) {
        if (MessageStart < WM_USER) {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }
        if (CompletionKey == (ULONG_PTR)-1) {
            //
            // this means that we want the fax service to close it's token so we can logoff
            // 
            ec = FAX_RegisterEventWindow( FH_FAX_HANDLE(FaxHandle), (ULONG64)hWnd, 0, NULL , NULL , &FaxSvcProcessId );
        } else {
            //
            // normal registration of event window
            // 
            HWINSTA hWinStation;
            HDESK hDesktop;
            WCHAR StationName[100];
            WCHAR DesktopName[100];
            DWORD dwNeeded;

            if (!IsWindow(hWnd)) {
                SetLastError( ERROR_INVALID_PARAMETER );
                return FALSE;
            }
            
            hWinStation = GetProcessWindowStation();
            if (!GetUserObjectInformation(hWinStation,
                                          UOI_NAME,
                                          StationName,
                                          sizeof(StationName),
                                          &dwNeeded) ) {
               return FALSE;
            }
            hDesktop = GetThreadDesktop( GetCurrentThreadId() );
            if (! GetUserObjectInformation(hDesktop,
                                           UOI_NAME,
                                           DesktopName,
                                           sizeof(DesktopName),
                                           &dwNeeded) ) {
               return FALSE;
            }

            ec = FAX_RegisterEventWindow( FH_FAX_HANDLE(FaxHandle), 
                                          (ULONG64)hWnd, 
                                          MessageStart,
                                          StationName,
                                          DesktopName,
                                          &FaxSvcProcessId );
        }
        if (ec) {
            SetLastError( ec );
            return FALSE;
        }
        return FaxSvcProcessId;
    } else if (!CompletionPort) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    AsyncInfo = (PASYNC_EVENT_INFO) MemAlloc( sizeof(ASYNC_EVENT_INFO) );
    if (!AsyncInfo) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    AsyncInfo->FaxData        = FH_DATA(FaxHandle);
    AsyncInfo->CompletionPort = CompletionPort;
    AsyncInfo->CompletionKey  = CompletionKey;


    Size = sizeof(ComputerName) / sizeof(TCHAR);
    if (!GetComputerName( ComputerName, &Size )) {
        goto error_exit;
    }

    _stprintf( ClientName, TEXT("FaxClient$%d"), GetCurrentProcessId() );

    //
    // timing: get the server thread up and running before
    // registering with the fax service (our client)
    // 
    ec = RpcpStartRpcServer( ClientName, faxclient_ServerIfHandle );
    if (ec != 0) {
        SetLastError( ec );
        goto error_exit;        
    }

    FH_DATA(FaxHandle)->EventInit = TRUE;

    if (!RpcServerStarted) {
        hThread = CreateThread(
            NULL,
            1024*100,
            FaxServerThread,
            NULL,
            0,
            &ThreadId
            );

        if (!hThread) {
            goto error_exit;            
        } else {
            RpcServerStarted = TRUE;
            CloseHandle(hThread);            
        }
    }

    ec = FAX_StartClientServer( FH_FAX_HANDLE(FaxHandle), ComputerName, ClientName, (ULONG64) AsyncInfo );
    if (ec) {
        SetLastError( ec );
        goto error_exit;
    }

    

    return TRUE;

error_exit:
    if (AsyncInfo) {
        MemFree(AsyncInfo);
    }
   
    if (RpcServerStarted) {
        FH_DATA(FaxHandle)->EventInit = FALSE;
        // this should also terminate FaxServerThread
        RpcpStopRpcServer( faxclient_ServerIfHandle );
        RpcServerStarted = FALSE;
    }

    return FALSE;
}


error_status_t
FAX_OpenConnection(
   IN handle_t hBinding,
   IN ULONG64 Context,
   OUT LPHANDLE FaxHandle
   )
{
    *FaxHandle = (HANDLE) Context;
    return 0;
}


error_status_t
FAX_CloseConnection(
   OUT LPHANDLE FaxHandle
   )
{
    *FaxHandle = NULL;
    return 0;
}


error_status_t
FAX_ClientEventQueue(
    IN HANDLE FaxHandle,
    IN FAX_EVENT FaxEvent
    )

/*++

Routine Description:

    This function is called when the a fax server wants
    to deliver a fax event to this client.

Arguments:

    FaxHandle       - FAX handle obtained from FaxConnectFaxServer.
    FaxEvent        - FAX event structure.
    Context         - Context token, really a ASYNC_EVENT_INFO structure pointer

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    PASYNC_EVENT_INFO AsyncInfo = (PASYNC_EVENT_INFO) FaxHandle;
    PFAX_EVENT FaxEventPost = NULL;


    FaxEventPost = (PFAX_EVENT) LocalAlloc( LMEM_FIXED, sizeof(FAX_EVENT) );
    if (!FaxEventPost) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    CopyMemory( FaxEventPost, &FaxEvent, sizeof(FAX_EVENT) );

    PostQueuedCompletionStatus(
        AsyncInfo->CompletionPort,
        sizeof(FAX_EVENT),
        AsyncInfo->CompletionKey,
        (LPOVERLAPPED) FaxEventPost
        );

    return ERROR_SUCCESS;
}


VOID
RPC_FAX_HANDLE_rundown(
    IN HANDLE FaxHandle
    )
{
    PASYNC_EVENT_INFO AsyncInfo = (PASYNC_EVENT_INFO) FaxHandle;
    PFAX_EVENT FaxEvent;


    FaxEvent = (PFAX_EVENT) LocalAlloc( LMEM_FIXED, sizeof(FAX_EVENT) );
    if (!FaxEvent) {
        goto exit;        
    }

    FaxEvent->SizeOfStruct      = sizeof(ASYNC_EVENT_INFO);
    GetSystemTimeAsFileTime( &FaxEvent->TimeStamp );
    FaxEvent->DeviceId = 0;
    FaxEvent->EventId  = FEI_FAXSVC_ENDED;
    FaxEvent->JobId    = 0;

    PostQueuedCompletionStatus(
        AsyncInfo->CompletionPort,
        sizeof(FAX_EVENT),
        AsyncInfo->CompletionKey,
        (LPOVERLAPPED) FaxEvent
        );

exit:
    RpcpStopRpcServer( faxclient_ServerIfHandle );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\client\faxapi.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxapi.c

Abstract:

    This module contains the Win32 FAX APIs.
    The function implemented here are simply very
    thin wrappers around the RPC stubs.  The wrappers
    are necessary so that the last error value
    is set properly.

Author:

    Wesley Witt (wesw) 16-Jan-1996


Revision History:

--*/

#include "faxapi.h"
#pragma hdrstop



BOOL
EnsureFaxServiceIsStarted(
    LPCWSTR MachineName
    )
{
    BOOL Rval = FALSE;
    SC_HANDLE hSvcMgr = NULL;
    SC_HANDLE hService = NULL;
    SERVICE_STATUS Status;
    DWORD i = 0;

#if DBG
    if (GetEnvironmentVariable( L"DontLookForFaxService", (LPWSTR)&i, sizeof(DWORD) )) {
        return TRUE;
    }
#endif

    hSvcMgr = OpenSCManager(
        MachineName,
        NULL,
        SC_MANAGER_CONNECT
        );
    if (!hSvcMgr) {
        DebugPrint(( L"could not open service manager: error code = %u", GetLastError() ));
        goto exit;
    }

    hService = OpenService(
        hSvcMgr,
        L"Fax",
        SERVICE_START | SERVICE_QUERY_STATUS
        );
    if (!hService) {
        DebugPrint(( L"could not open the FAX service: error code = %u", GetLastError() ));
        goto exit;
    }

    if (!QueryServiceStatus( hService, &Status )) {
        DebugPrint(( L"could not query status for the FAX service: error code = %u", GetLastError() ));
        goto exit;
    }

    if (Status.dwCurrentState == SERVICE_RUNNING) {
        Rval = TRUE;
        goto exit;
    }

    if (!StartService( hService, 0, NULL )) {
        DebugPrint(( L"could not start the FAX service: error code = %u", GetLastError() ));
        goto exit;
    }

    do {
        if (!QueryServiceStatus( hService, &Status )) {
            DebugPrint(( L"could not query status for the FAX service: error code = %u", GetLastError() ));
            goto exit;
        }
        i += 1;
        if (i > 60) {
            break;
        }
        Sleep( 500 );
    } while (Status.dwCurrentState != SERVICE_RUNNING);

    if (Status.dwCurrentState != SERVICE_RUNNING) {
        DebugPrint(( L"could not start the FAX service: error code = %u", GetLastError() ));
        goto exit;
    }

    Rval = TRUE;

exit:

    if (hService) {
        CloseServiceHandle( hService );
    }
    if (hSvcMgr) {
        CloseServiceHandle( hSvcMgr );
    }

    return Rval;
}


BOOL
WINAPI
FaxConnectFaxServerW(
    IN LPCWSTR lpMachineName OPTIONAL,
    OUT LPHANDLE FaxHandle
    )

/*++

Routine Description:

    Creates a connection to a FAX server.  The binding handle that is
    returned is used for all subsequent FAX API calls.

Arguments:

    MachineName - Machine name, NULL, or "."
    FaxHandle   - Pointer to a FAX handle



Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    error_status_t ec;
    LONG Error;
    PFAX_HANDLE_DATA FaxData;
    PHANDLE_ENTRY HandleEntry;
    DWORD CanShare;

    if (!FaxHandle) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!EnsureFaxServiceIsStarted( lpMachineName )) {
        return FALSE;
    }

    FaxData = MemAlloc( sizeof(FAX_HANDLE_DATA) );
    if (!FaxData) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    Error = RpcpBindRpc( lpMachineName, TEXT("FaxSvc"), NULL, &FaxData->FaxHandle );
    if (Error) {
        MemFree ( FaxData );
        SetLastError( Error );
        return FALSE;
    }

    InitializeCriticalSection( &FaxData->CsHandleTable );
    InitializeListHead( &FaxData->HandleTableListHead );

    HandleEntry = CreateNewServiceHandle( FaxData );
    if (!HandleEntry) {
        MemFree( FaxData );
        return FALSE;
    }

    if (lpMachineName) {
        FaxData->MachineName = StringDup( lpMachineName );
        if (!FaxData->MachineName) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            MemFree( FaxData );
            return FALSE;
        }
    }

    *FaxHandle = (LPHANDLE) HandleEntry;
    
    ec = FAX_ConnectionRefCount( FH_FAX_HANDLE(*FaxHandle), &FH_CONTEXT_HANDLE(*FaxHandle), 1, &CanShare );
    
    if (ec) {
        FaxClose( *FaxHandle );
        SetLastError( ec );
        return FALSE;
    }

    if (IsLocalFaxConnection(*FaxHandle) || CanShare) {
        return TRUE;
    }
        
    FaxClose( *FaxHandle );
    
    *FaxHandle = NULL;
    
    SetLastError( ERROR_ACCESS_DENIED );
    
    return FALSE;
    
}


BOOL
WINAPI
FaxConnectFaxServerA(
    IN LPCSTR lpMachineName OPTIONAL,
    OUT LPHANDLE FaxHandle
    )

/*++

Routine Description:

    Creates a connection to a FAX server.  The binding handle that is
    returned is used for all subsequent FAX API calls.

Arguments:

    MachineName - Machine name, NULL, or "."
    FaxHandle   - Pointer to a FAX handle



Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    LONG Error;
    PWCHAR MachineName = NULL;
    PFAX_HANDLE_DATA FaxData;
    PHANDLE_ENTRY HandleEntry;
    LPWSTR NetworkOptions;
    error_status_t ec;
    DWORD CanShare;

    if (!FaxHandle) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (lpMachineName) {
        MachineName = AnsiStringToUnicodeString( lpMachineName );
        if (!MachineName) {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }
    }

    if (!EnsureFaxServiceIsStarted( MachineName )) {
        return FALSE;
    }

    FaxData = MemAlloc( sizeof(FAX_HANDLE_DATA) );
    if (!FaxData) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        if (MachineName) MemFree( MachineName );
        return FALSE;
    }

    if (OsVersion.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) {
        NetworkOptions = NULL;
    } else {
        NetworkOptions = L"Security=Impersonation Dynamic False";
    }

    Error = RpcpBindRpc( MachineName, TEXT("FaxSvc"), NetworkOptions, &FaxData->FaxHandle );
    if (Error) {
        if (MachineName) MemFree( MachineName );
        MemFree( FaxData );
        SetLastError( Error );
        return FALSE;
    }    

    InitializeCriticalSection( &FaxData->CsHandleTable );
    InitializeListHead( &FaxData->HandleTableListHead );

    HandleEntry = CreateNewServiceHandle( FaxData );
    if (!HandleEntry) {
        if (MachineName) MemFree( MachineName );
        MemFree( FaxData );
        return FALSE;
    }

    FaxData->MachineName = MachineName;        

    *FaxHandle = (LPHANDLE) HandleEntry;
    
    ec = FAX_ConnectionRefCount( FH_FAX_HANDLE(*FaxHandle), &FH_CONTEXT_HANDLE(*FaxHandle), 1, &CanShare );
    
    if (ec) {
        FaxClose( *FaxHandle );
        *FaxHandle = NULL;
        SetLastError( ec );
        return FALSE;
    }

    if (IsLocalFaxConnection(*FaxHandle) || CanShare) {
        return TRUE;
    }
            
    FaxClose( FaxHandle );
    
    *FaxHandle = NULL;
    
    SetLastError( ERROR_ACCESS_DENIED );
    
    return FALSE;        
}


BOOL
WINAPI
FaxGetVersion(
    IN  HANDLE FaxHandle,
    OUT LPDWORD Version
    )
{
    error_status_t ec;

    if (!FaxHandle || !Version) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    ec = FAX_GetVersion(
        (handle_t) ((PHANDLE_ENTRY)FaxHandle)->FaxData->FaxHandle,
        Version
        );
    if (ec) {
        SetLastError( ec );
        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
FaxGetDeviceStatusW(
    IN  const HANDLE FaxHandle,
    OUT PFAX_DEVICE_STATUSW *DeviceStatus
    )

/*++

Routine Description:

    Obtains a status report for the FAX devices being
    used by the FAX server.

Arguments:

    FaxHandle       - FAX handle obtained from FaxConnectFaxServer.
    StatusBuffer    - Buffer for the status data
    BufferSize      - Size of the StatusBuffer

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    #define FixupString(_s) FixupStringPtr(DeviceStatus,_s) 
    error_status_t ec;
    DWORD BufferSize = 0;


    if (!ValidateFaxHandle(FaxHandle, FHT_PORT)) {
       SetLastError(ERROR_INVALID_HANDLE);
       return FALSE;
    }
              
    if (!DeviceStatus) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *DeviceStatus = NULL;

    ec = FAX_GetDeviceStatus(
        FH_PORT_HANDLE(FaxHandle),
        (LPBYTE*)DeviceStatus,
        &BufferSize
        );
    if (ec) {
        SetLastError( ec );
        return FALSE;
    }

    FixupString( (*DeviceStatus)->CallerId       );
    FixupString( (*DeviceStatus)->Csid           );
    FixupString( (*DeviceStatus)->DeviceName     );
    FixupString( (*DeviceStatus)->DocumentName   );
    FixupString( (*DeviceStatus)->PhoneNumber    );
    FixupString( (*DeviceStatus)->RoutingString  );
    FixupString( (*DeviceStatus)->SenderName     );
    FixupString( (*DeviceStatus)->RecipientName  );
    FixupString( (*DeviceStatus)->StatusString   );
    FixupString( (*DeviceStatus)->Tsid           );
    FixupString( (*DeviceStatus)->UserName       );

    return TRUE;
}


BOOL
WINAPI
FaxGetDeviceStatusA(
    IN  const HANDLE FaxHandle,
    OUT PFAX_DEVICE_STATUSA *DeviceStatus
    )

/*++

Routine Description:

    Obtains a status report for the FAX devices being
    used by the FAX server.

Arguments:

    FaxHandle       - FAX handle obtained from FaxConnectFaxServer.
    StatusBuffer    - Buffer for the status data
    BufferSize      - Size of the StatusBuffer

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    if (!FaxGetDeviceStatusW( FaxHandle, (PFAX_DEVICE_STATUSW *)DeviceStatus )) {
        return FALSE;
    }

    ConvertUnicodeStringInPlace( (LPWSTR) (*DeviceStatus)->CallerId       );
    ConvertUnicodeStringInPlace( (LPWSTR) (*DeviceStatus)->Csid           );
    ConvertUnicodeStringInPlace( (LPWSTR) (*DeviceStatus)->DeviceName     );
    ConvertUnicodeStringInPlace( (LPWSTR) (*DeviceStatus)->DocumentName   );
    ConvertUnicodeStringInPlace( (LPWSTR) (*DeviceStatus)->PhoneNumber    );
    ConvertUnicodeStringInPlace( (LPWSTR) (*DeviceStatus)->RoutingString  );
    ConvertUnicodeStringInPlace( (LPWSTR) (*DeviceStatus)->SenderName     );
    ConvertUnicodeStringInPlace( (LPWSTR) (*DeviceStatus)->RecipientName  );
    ConvertUnicodeStringInPlace( (LPWSTR) (*DeviceStatus)->StatusString   );
    ConvertUnicodeStringInPlace( (LPWSTR) (*DeviceStatus)->Tsid           );
    ConvertUnicodeStringInPlace( (LPWSTR) (*DeviceStatus)->UserName       );

    return TRUE;
}


BOOL
WINAPI
FaxGetInstallType(
    IN HANDLE FaxHandle,
    OUT LPDWORD InstallType,
    OUT LPDWORD InstalledPlatforms,
    OUT LPDWORD ProductType
    )

/*++

Routine Description:

    Obtains a status report for the FAX devices being
    used by the FAX server.

Arguments:

    FaxHandle       - FAX handle obtained from FaxConnectFaxServer.
    StatusBuffer    - Buffer for the status data
    BufferSize      - Size of the StatusBuffer

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    error_status_t ec;

    if (!FaxHandle || !InstallType || !InstalledPlatforms || !ProductType) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    ec = FAX_GetInstallType(
        FH_FAX_HANDLE(FaxHandle),
        InstallType,
        InstalledPlatforms,
        ProductType
        );
    if (ec) {
        SetLastError( ec );
        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
FaxClose(
    IN const HANDLE FaxHandle
    )
{
    error_status_t ec;
    PHANDLE_ENTRY HandleEntry = (PHANDLE_ENTRY) FaxHandle;    
    HANDLE TmpFaxPortHandle;
    PFAX_HANDLE_DATA FaxData;
    DWORD CanShare;
    
    if (!FaxHandle || !*(LPDWORD)FaxHandle) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    switch (HandleEntry->Type) {
        case FHT_SERVICE:
            
            ec = FAX_ConnectionRefCount( FH_FAX_HANDLE(FaxHandle), &FH_CONTEXT_HANDLE(FaxHandle), 0, &CanShare );
            
            __try {
                ec = RpcpUnbindRpc( (RPC_BINDING_HANDLE *) HandleEntry->FaxData->FaxHandle );
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                ec = GetExceptionCode();
            }
            FaxData = HandleEntry->FaxData;
            CloseFaxHandle( HandleEntry->FaxData, HandleEntry );
            //
            // zero out the memory before we return it to the heap
            //
            ZeroMemory( FaxData, sizeof(FAX_HANDLE_DATA) );
            MemFree( FaxData );
            return TRUE;

        case FHT_PORT:
            TmpFaxPortHandle = HandleEntry->FaxPortHandle;
            CloseFaxHandle( HandleEntry->FaxData, HandleEntry );
            ec = FAX_ClosePort( &TmpFaxPortHandle );
            if (ec) {
                SetLastError( ec );
                return FALSE;
            }
            break;

        default:
            SetLastError( ERROR_INVALID_HANDLE );
            return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
FaxGetSecurityDescriptorCount(
    IN HANDLE FaxHandle,
    OUT LPDWORD Count
    )
{
   
    error_status_t ec;

    if (!FaxHandle || !Count) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    ec = FAX_GetSecurityDescriptorCount(
        FH_FAX_HANDLE(FaxHandle),
        Count
        );
    
    if (ec) {
        SetLastError(ec);
        return FALSE;
    }

    return TRUE;    
}

BOOL
WINAPI
FaxGetSecurityDescriptor(
    IN HANDLE FaxHandle,
    IN DWORD Id,
    OUT PFAX_SECURITY_DESCRIPTOR * FaxSecurityDescriptor
    )
{
   
    error_status_t ec;
    DWORD BufferSize = 0;
    PFAX_SECURITY_DESCRIPTOR SecDesc;

    if (!FaxHandle || !FaxSecurityDescriptor) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    ec = FAX_GetSecurityDescriptor(
        FH_FAX_HANDLE(FaxHandle),
        Id,
        (LPBYTE *)FaxSecurityDescriptor,
        &BufferSize
        );
    
    if (ec) {
        SetLastError(ec);
        return FALSE;
    }


    SecDesc = *FaxSecurityDescriptor;

    if(SecDesc->FriendlyName){
        FixupStringPtr(&SecDesc,SecDesc->FriendlyName);
    }

    if (SecDesc->SecurityDescriptor) {
        FixupStringPtr(&SecDesc,SecDesc->SecurityDescriptor);
    }

    return TRUE;    
}

    
BOOL
WINAPI
FaxSetSecurityDescriptor(
    IN HANDLE FaxHandle,
    IN PFAX_SECURITY_DESCRIPTOR FaxSecurityDescriptor
    )        
{
    error_status_t ec;

    LPBYTE Buffer;
    DWORD BufferSize;
    DWORD SecLength;
    PFAX_SECURITY_DESCRIPTOR SD;
    DWORD Offset = sizeof(FAX_SECURITY_DESCRIPTOR);

    if (!FaxHandle || !FaxSecurityDescriptor) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    if (!IsValidSecurityDescriptor( (PSECURITY_DESCRIPTOR) FaxSecurityDescriptor->SecurityDescriptor )){
        SetLastError( ERROR_INVALID_DATA ); 
        return FALSE;
    }

    SecLength = GetSecurityDescriptorLength( (PSECURITY_DESCRIPTOR) FaxSecurityDescriptor->SecurityDescriptor );
    
    BufferSize = sizeof(FAX_SECURITY_DESCRIPTOR) + SecLength;
    
    Buffer = (LPBYTE) MemAlloc( BufferSize );
    if (Buffer == NULL) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    SD = (PFAX_SECURITY_DESCRIPTOR) Buffer;

    SD->Id = FaxSecurityDescriptor->Id;
    
    // Can't set the friendly name

    SD->FriendlyName = (LPWSTR) Offset;

    CopyMemory( 
        Buffer + Offset,
        FaxSecurityDescriptor->SecurityDescriptor,
        SecLength
        );

    SD->SecurityDescriptor = (LPBYTE) Offset;
    
    ec = FAX_SetSecurityDescriptor(
            FH_FAX_HANDLE(FaxHandle),
            Buffer,
            BufferSize
            );

    MemFree( Buffer );

    if (ec != ERROR_SUCCESS) {
        SetLastError(ec);
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\client\faxapip.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    faxapi.h

Abstract:

    This module contains all includes to the FAX client DLL.  All
    objects in this DLL should include this header only.

Author:

    Wesley Witt (wesw) 12-Jan-1996

--*/

#define _WINFAX_

#include <windows.h>
#include <shellapi.h>
#include <winspool.h>

#include <rpc.h>
#include <tapi.h>
#include <tapi3if.h>

#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <shlobj.h>

#include "jobtag.h"
#include "faxreg.h"
#include "prtcovpg.h"
#include "faxutil.h"
#include "faxrpc.h"
#include "faxcli.h"
#include "faxsvcrg.h"
#include "rpcutil.h"
#include "tiff.h"
#include "tifflib.h"

#include "winfax.h"
#include "winfaxp.h"
#include "devmode.h"

#define IDS_DEFAULT_PRINTER_NAME             100


#define FHT_SERVICE                          1
#define FHT_PORT                             2

#define FAX_DRIVER_NAME                      TEXT("Windows NT Fax Driver")
#define TAPI_LIBRARY                         TEXT("%systemroot%\\system32\\tapi32.dll")
#define CP_FILENAME_EXT                      L".cov"
#define CP_SHORTCUT_EXT                      L".lnk"
#define ARGUMENT_PRESENT(ArgumentPointer)    ((CHAR *)(ArgumentPointer) != (CHAR *)(NULL))
#define FixupStringPtr(_buf,_str)            if (_str) (LPWSTR)_str = (LPWSTR) ((LPBYTE)(*_buf) + (ULONG_PTR)_str)

//
// typedefs
//
typedef int (*FaxConnFunction)(LPTSTR,handle_t*);

#define FH_PORT_HANDLE(_phe)     (((PHANDLE_ENTRY)(_phe))->FaxPortHandle)
#define FH_FAX_HANDLE(_phe)      (((PHANDLE_ENTRY)(_phe))->FaxData->FaxHandle)
#define FH_CONTEXT_HANDLE(_phe)  (((PHANDLE_ENTRY)(_phe))->FaxContextHandle)
#define FH_DATA(_phe)            (((PHANDLE_ENTRY)(_phe))->FaxData)
#define ValidateFaxHandle(_phe,_type)   ((_phe && \
                                          *(LPDWORD)_phe && \
                                          (((PHANDLE_ENTRY)_phe)->Type == _type)) ? TRUE : FALSE)

typedef struct _FAX_HANDLE_DATA {
    HANDLE              FaxHandle;                       // Fax handle obtained from FaxConnectFaxServer()
    BOOL                EventInit;                       //
    LIST_ENTRY          HandleTableListHead;             //
    CRITICAL_SECTION    CsHandleTable;                   //
    LPWSTR              MachineName;                     //
} FAX_HANDLE_DATA, *PFAX_HANDLE_DATA;

typedef struct _HANDLE_ENTRY {
    LIST_ENTRY          ListEntry;                       // linked list pointers
    DWORD               Type;                            // handle type, see FHT defines
    DWORD               Flags;                           // open flags
    DWORD               DeviceId;                        // device id    
    PFAX_HANDLE_DATA    FaxData;                         // pointer to connection data
    HANDLE              FaxPortHandle;                   // open fax port handle
    HANDLE              FaxContextHandle;                // context handle for refcounting
} HANDLE_ENTRY, *PHANDLE_ENTRY;

typedef struct _ASYNC_EVENT_INFO {
    PFAX_HANDLE_DATA    FaxData;                         // Pointer to connection data
    HANDLE              CompletionPort;                  // Completion port handle
    ULONG_PTR           CompletionKey;                   // Completion key
} ASYNC_EVENT_INFO, *PASYNC_EVENT_INFO;


extern OSVERSIONINFOA OsVersion;


//
// prototypes
//

VOID
CloseFaxHandle(
    PFAX_HANDLE_DATA    FaxData,
    PHANDLE_ENTRY       HandleEntry
    );

PHANDLE_ENTRY
CreateNewServiceHandle(
    PFAX_HANDLE_DATA    FaxData
    );

PHANDLE_ENTRY
CreateNewPortHandle(
    PFAX_HANDLE_DATA    FaxData,
    DWORD               Flags,
    HANDLE              FaxPortHandle
    );

BOOL
ConvertUnicodeMultiSZInPlace(
    LPCWSTR UnicodeString,
    DWORD ByteCount
    );

VOID
ConvertUnicodeStringInPlace(
    LPCWSTR UnicodeString
    );

VOID
ConvertAnsiiStringInPlace(
    LPCSTR AnsiiString
    );

VOID
StoreString(
    LPCWSTR String,
    PULONG_PTR DestString,
    LPBYTE Buffer,
    PULONG_PTR Offset
    );

VOID
StoreStringA(
    LPCSTR String,
    PULONG_PTR DestString,
    LPBYTE Buffer,
    PULONG_PTR Offset
    );

BOOL
ValidateCoverpage(
    LPCWSTR  CoverPageName,
    LPCWSTR  ServerName,
    BOOL     ServerCoverpage,
    LPWSTR   ResolvedName
    );

BOOL EnsureFaxServiceIsStarted(LPCWSTR ServerName);
LPWSTR GetFaxPrinterName();

BOOL
IsLocalFaxConnection(
    HANDLE FaxHandle
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\client\port.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    print.c

Abstract:

    This module contains the port
    specific WINFAX API functions.

Author:

    Wesley Witt (wesw) 29-Nov-1996


Revision History:

--*/

#include "faxapi.h"
#pragma hdrstop



int
__cdecl
PortPriorityCompare(
    const void *arg1,
    const void *arg2
    )
{
    if (((PFAX_PORT_INFOW)arg1)->Priority < ((PFAX_PORT_INFOW)arg2)->Priority) {
        return -1;
    }
    if (((PFAX_PORT_INFOW)arg1)->Priority > ((PFAX_PORT_INFOW)arg2)->Priority) {
        return 1;
    }
    return 0;
}


BOOL
WINAPI
FaxEnumPortsW(
    IN  HANDLE FaxHandle,
    OUT PFAX_PORT_INFOW *PortInfoBuffer,
    OUT LPDWORD PortsReturned
    )

/*++

Routine Description:

    Enumerates all of the FAX devices attached to the
    FAX server.  The port state information is returned
    for each device.

Arguments:

    FaxHandle           - FAX handle obtained from FaxConnectFaxServer
    PortInfoBuffer      - Buffer to hold the port information
    PortInfoBufferSize  - Total size of the port info buffer
    PortsReturned       - The number of ports in the buffer

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    error_status_t ec;
    DWORD i;
    PFAX_PORT_INFOW PortInfo;
    DWORD PortInfoBufferSize = 0;

    if (!ValidateFaxHandle(FaxHandle, FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       return FALSE;
    }

    if (!PortInfoBuffer || !PortsReturned) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *PortInfoBuffer = NULL;

    ec = FAX_EnumPorts(
        FH_FAX_HANDLE(FaxHandle),
        (LPBYTE*)PortInfoBuffer,
        &PortInfoBufferSize,
        PortsReturned
        );
    if (ec) {
        SetLastError( ec );
        return FALSE;
    }

    PortInfo = (PFAX_PORT_INFOW) *PortInfoBuffer;

    for (i=0; i<*PortsReturned; i++) {
        FixupStringPtr( PortInfoBuffer, PortInfo[i].DeviceName );
        FixupStringPtr( PortInfoBuffer, PortInfo[i].Tsid );
        FixupStringPtr( PortInfoBuffer, PortInfo[i].Csid );
    }

    //
    // sort the ports by priority
    //

    qsort(
        (PVOID) *PortInfoBuffer,
        (int) (*PortsReturned),
        sizeof(FAX_PORT_INFOW),
        PortPriorityCompare
        );

    return TRUE;
}


BOOL
WINAPI
FaxEnumPortsA(
    IN  HANDLE FaxHandle,
    OUT PFAX_PORT_INFOA *PortInfoBuffer,
    OUT LPDWORD PortsReturned
    )

/*++

Routine Description:

    Enumerates all of the FAX devices attached to the
    FAX server.  The port state information is returned
    for each device.

Arguments:

    FaxHandle           - FAX handle obtained from FaxConnectFaxServer
    PortInfoBuffer      - Buffer to hold the port information
    PortInfoBufferSize  - Total size of the port info buffer
    BytesNeeded         - Total bytes needed for buffer
    PortsReturned       - The number of ports in the buffer

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    DWORD i;
    PFAX_PORT_INFOW PortInfo;


    if (!FaxEnumPortsW(
            FaxHandle,
            (PFAX_PORT_INFOW *)PortInfoBuffer,
            PortsReturned
            )) {
        return FALSE;
    }

    //
    // convert the strings from unicode to ascii
    //

    PortInfo = (PFAX_PORT_INFOW) *PortInfoBuffer;

    for (i=0; i<*PortsReturned; i++) {

        ConvertUnicodeStringInPlace( (LPWSTR) PortInfo[i].DeviceName );
        ConvertUnicodeStringInPlace( (LPWSTR) PortInfo[i].Tsid );
        ConvertUnicodeStringInPlace( (LPWSTR) PortInfo[i].Csid );

    }

    return TRUE;
}


BOOL
WINAPI
FaxGetPortW(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_PORT_INFOW *PortInfoBuffer
    )

/*++

Routine Description:

    Returns port status information for a requested port.
    The device id passed in should be optained from FAXEnumPorts.

Arguments:

    FaxHandle           - FAX handle obtained from FaxConnectFaxServer
    DeviceId            - TAPI device id
    PortInfoBuffer      - Buffer to hold the port information
    PortInfoBufferSize  - Total size of the port info buffer

Return Value:

    ERROR_SUCCESS for success, otherwise a WIN32 error code.

--*/

{
    error_status_t ec;
    PFAX_PORT_INFOW PortInfo;
    DWORD PortInfoBufferSize = 0;

    if (!ValidateFaxHandle(FaxPortHandle, FHT_PORT)) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if (!PortInfoBuffer) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    *PortInfoBuffer = NULL;

    ec = FAX_GetPort(
        FH_PORT_HANDLE(FaxPortHandle),
        (LPBYTE*)PortInfoBuffer,
        &PortInfoBufferSize
        );
    if (ec) {
        SetLastError( ec );
        return FALSE;
    }

    PortInfo = (PFAX_PORT_INFOW) *PortInfoBuffer;

    FixupStringPtr( PortInfoBuffer, PortInfo->DeviceName );
    FixupStringPtr( PortInfoBuffer, PortInfo->Tsid );
    FixupStringPtr( PortInfoBuffer, PortInfo->Csid );

    return TRUE;
}


BOOL
WINAPI
FaxGetPortA(
    IN HANDLE FaxPortHandle,
    OUT PFAX_PORT_INFOA *PortInfoBuffer
    )

/*++

Routine Description:

    Returns port status information for a requested port.
    The device id passed in should be optained from FAXEnumPorts.

Arguments:

    FaxHandle           - FAX handle obtained from FaxConnectFaxServer
    DeviceId            - TAPI device id
    PortInfoBuffer      - Buffer to hold the port information
    PortInfoBufferSize  - Total size of the port info buffer
    BytesNeeded         - Total bytes needed for buffer

Return Value:

    ERROR_SUCCESS for success, otherwise a WIN32 error code.

--*/

{
    BOOL Rval = FALSE;
    PFAX_PORT_INFOW PortInfo;


    if (!FaxGetPortW( FaxPortHandle, (PFAX_PORT_INFOW *)PortInfoBuffer)) {
        goto exit;
    }

    PortInfo = (PFAX_PORT_INFOW) *PortInfoBuffer;

    ConvertUnicodeStringInPlace( (LPWSTR)PortInfo->DeviceName );
    ConvertUnicodeStringInPlace( (LPWSTR)PortInfo->Tsid );
    ConvertUnicodeStringInPlace( (LPWSTR) PortInfo->Csid );

    Rval = TRUE;

exit:
    return Rval;
}


BOOL
FaxSetPortW(
    IN HANDLE FaxPortHandle,
    IN const FAX_PORT_INFOW *PortInfoBuffer
    )

/*++

Routine Description:

    Changes the port capability mask.  This allows the caller to
    enable or disable sending & receiving on a port basis.

Arguments:

    FaxHandle   - FAX handle obtained from FaxConnectFaxServer.
    PortInfo    - PortInfo structure

Return Value:

    ERROR_SUCCESS for success, otherwise a WIN32 error code.

--*/

{
    error_status_t ec;
    PHANDLE_ENTRY HandleEntry = (PHANDLE_ENTRY) FaxPortHandle;

    if (!ValidateFaxHandle(FaxPortHandle, FHT_PORT)) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }
    
    if (!PortInfoBuffer) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    __try {
        if (PortInfoBuffer->SizeOfStruct != sizeof(FAX_PORT_INFOW)) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(GetExceptionCode());
        return FALSE;
    }

    if (!(HandleEntry->Flags & PORT_OPEN_MODIFY)) {
        SetLastError(ERROR_ACCESS_DENIED);
        return FALSE;
    }

    ec = FAX_SetPort(
        FH_PORT_HANDLE(FaxPortHandle),
        (PFAX_PORT_INFOW)PortInfoBuffer
        );
    if (ec) {
        SetLastError( ec );
        return FALSE;
    }

    return TRUE;
}


BOOL
FaxSetPortA(
    IN HANDLE FaxPortHandle,
    IN const FAX_PORT_INFOA *PortInfoBuffer
    )

/*++

Routine Description:

    Changes the port capability mask.  This allows the caller to
    enable or disable sending & receiving on a port basis.

Arguments:

    FaxHandle   - FAX handle obtained from FaxConnectFaxServer.
    PortInfo    - PortInfo structure

Return Value:

    ERROR_SUCCESS for success, otherwise a WIN32 error code.

--*/

{
    LPBYTE TempBuf = NULL;
    DWORD Size;
    DWORD SizeA;
    PFAX_PORT_INFOW PortInfo;

    if (!PortInfoBuffer || PortInfoBuffer->SizeOfStruct != sizeof(FAX_PORT_INFOA)) {
       SetLastError(ERROR_INVALID_PARAMETER);
       return FALSE;
    }

    PortInfo = (PFAX_PORT_INFOW) PortInfoBuffer;
    Size = sizeof(FAX_PORT_INFOA) +
           ((strlen((LPSTR)PortInfo->DeviceName ) + 1) * sizeof(WCHAR)) +
           ((strlen((LPSTR)PortInfo->Csid ) + 1) * sizeof(WCHAR)) +
           ((strlen((LPSTR)PortInfo->Tsid ) + 1) * sizeof(WCHAR));

    TempBuf = MemAlloc( Size );
    if (!TempBuf) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }
    SizeA = sizeof(FAX_PORT_INFOA) +
           (strlen((LPSTR)PortInfo->DeviceName ) + 1) +
           (strlen((LPSTR)PortInfo->Csid ) + 1) +
           (strlen((LPSTR)PortInfo->Tsid ) + 1);
    CopyMemory( TempBuf, PortInfoBuffer, SizeA );
    PortInfo = (PFAX_PORT_INFOW) TempBuf;
    PortInfo->SizeOfStruct = sizeof(FAX_PORT_INFOW);
    PortInfo->DeviceName = AnsiStringToUnicodeString( (LPSTR) PortInfo->DeviceName );
    PortInfo->Csid = AnsiStringToUnicodeString( (LPSTR) PortInfo->Csid );
    PortInfo->Tsid = AnsiStringToUnicodeString( (LPSTR) PortInfo->Tsid );

    if (!FaxSetPortW( FaxPortHandle, PortInfo )) {
        MemFree( TempBuf );
        return FALSE;
    }

    MemFree( (PBYTE) PortInfo->DeviceName );
    MemFree( (PBYTE) PortInfo->Csid );
    MemFree( (PBYTE) PortInfo->Tsid );

    MemFree( TempBuf );
    return TRUE;
}


BOOL
WINAPI
FaxOpenPort(
    IN HANDLE FaxHandle,
    IN DWORD DeviceId,
    IN DWORD Flags,
    OUT LPHANDLE FaxPortHandle
    )

/*++

Routine Description:

    Opens a fax port for subsequent use in other fax APIs.

Arguments:

    FaxHandle       - FAX handle obtained from FaxConnectFaxServer.
    DeviceId        - Requested device id
    FaxPortHandle   - The resulting FAX port handle.


Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    error_status_t ec;
    PHANDLE_ENTRY HandleEntry;

    if (!ValidateFaxHandle(FaxHandle, FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       return FALSE;
    }

    if ( !FaxPortHandle || 
         (!(Flags & (PORT_OPEN_QUERY | PORT_OPEN_MODIFY) ))) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    ec = FAX_OpenPort( FH_FAX_HANDLE(FaxHandle), DeviceId, Flags, FaxPortHandle );
    if (ec) {
        SetLastError( ec );
        return FALSE;
    }

    HandleEntry = CreateNewPortHandle( FH_DATA(FaxHandle), Flags, *FaxPortHandle );
    if (HandleEntry) {
        HandleEntry->DeviceId = DeviceId;        
    }

    *FaxPortHandle = HandleEntry;

    return *FaxPortHandle != NULL;
}


BOOL
WINAPI
FaxEnumRoutingMethodsW(
    IN HANDLE FaxPortHandle,
    OUT PFAX_ROUTING_METHODW *RoutingInfoBuffer,
    OUT LPDWORD MethodsReturned
    )
{
    PFAX_ROUTING_METHODW FaxRoutingMethod = NULL;
    error_status_t ec;
    DWORD i;
    DWORD RoutingInfoBufferSize = 0;

    if (!ValidateFaxHandle(FaxPortHandle, FHT_PORT)) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if (!RoutingInfoBuffer || !MethodsReturned) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *RoutingInfoBuffer = NULL;
    *MethodsReturned = 0;

    ec = FAX_EnumRoutingMethods(
        FH_PORT_HANDLE(FaxPortHandle),
        (LPBYTE*)RoutingInfoBuffer,
        &RoutingInfoBufferSize,
        MethodsReturned
        );
    if (ec) {
        SetLastError( ec );
        return FALSE;
    }

    FaxRoutingMethod = (PFAX_ROUTING_METHOD) *RoutingInfoBuffer;

    for (i=0; i<*MethodsReturned; i++) {
        FixupStringPtr( RoutingInfoBuffer, FaxRoutingMethod[i].DeviceName );
        FixupStringPtr( RoutingInfoBuffer, FaxRoutingMethod[i].Guid );
        FixupStringPtr( RoutingInfoBuffer, FaxRoutingMethod[i].FunctionName );
        FixupStringPtr( RoutingInfoBuffer, FaxRoutingMethod[i].FriendlyName );
        FixupStringPtr( RoutingInfoBuffer, FaxRoutingMethod[i].ExtensionImageName );
        FixupStringPtr( RoutingInfoBuffer, FaxRoutingMethod[i].ExtensionFriendlyName );
    }

    return TRUE;
}


BOOL
WINAPI
FaxEnumRoutingMethodsA(
    IN HANDLE FaxPortHandle,
    OUT PFAX_ROUTING_METHODA *RoutingInfoBuffer,
    OUT LPDWORD MethodsReturned
    )
{
    PFAX_ROUTING_METHODW FaxRoutingMethod = NULL;
    DWORD i;


    if (!FaxEnumRoutingMethodsW(
        FaxPortHandle,
        (PFAX_ROUTING_METHODW *)RoutingInfoBuffer,
        MethodsReturned
        ))
    {
        return FALSE;
    }

    FaxRoutingMethod = (PFAX_ROUTING_METHOD) *RoutingInfoBuffer;

    for (i=0; i<*MethodsReturned; i++) {
        ConvertUnicodeStringInPlace( (LPWSTR)FaxRoutingMethod[i].DeviceName );
        ConvertUnicodeStringInPlace( (LPWSTR)FaxRoutingMethod[i].Guid );
        ConvertUnicodeStringInPlace( (LPWSTR)FaxRoutingMethod[i].FunctionName );
        ConvertUnicodeStringInPlace( (LPWSTR)FaxRoutingMethod[i].FriendlyName );
        ConvertUnicodeStringInPlace( (LPWSTR)FaxRoutingMethod[i].ExtensionImageName );
        ConvertUnicodeStringInPlace( (LPWSTR)FaxRoutingMethod[i].ExtensionFriendlyName );
    }

    return TRUE;
}


BOOL
WINAPI
FaxEnableRoutingMethodW(
    IN HANDLE FaxPortHandle,
    IN LPCWSTR RoutingGuid,
    IN BOOL Enabled
    )
{
    error_status_t ec;

    if (!ValidateFaxHandle(FaxPortHandle, FHT_PORT)) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if (!RoutingGuid) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    ec = FAX_EnableRoutingMethod( FH_PORT_HANDLE(FaxPortHandle), (LPWSTR)RoutingGuid, Enabled);
    if (ec) {
        SetLastError( ec );
        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
FaxEnableRoutingMethodA(
    IN HANDLE FaxPortHandle,
    IN LPCSTR RoutingGuid,
    IN BOOL Enabled
    )
{
    BOOL Rval;


    LPWSTR RoutingGuidW = AnsiStringToUnicodeString( RoutingGuid );
    if (!RoutingGuidW) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    Rval = FaxEnableRoutingMethodW( FaxPortHandle, RoutingGuidW, Enabled );

    MemFree( RoutingGuidW );

    return Rval;
}


BOOL
WINAPI
FaxGetRoutingInfoW(
    IN const HANDLE FaxPortHandle,
    IN LPCWSTR RoutingGuid,
    OUT LPBYTE *RoutingInfoBuffer,
    OUT LPDWORD RoutingInfoBufferSize
    )
{
    error_status_t ec;

    if (!ValidateFaxHandle(FaxPortHandle, FHT_PORT)) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if (!RoutingGuid || !RoutingInfoBuffer || !RoutingInfoBufferSize) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *RoutingInfoBuffer = NULL;
    *RoutingInfoBufferSize = 0;

    ec = FAX_GetRoutingInfo(
        FH_PORT_HANDLE(FaxPortHandle),
        (LPWSTR)RoutingGuid,
        RoutingInfoBuffer,
        RoutingInfoBufferSize
        );
    if (ec) {
        SetLastError( ec );
        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
FaxGetRoutingInfoA(
    IN HANDLE FaxPortHandle,
    IN LPCSTR RoutingGuid,
    OUT LPBYTE *RoutingInfoBuffer,
    OUT LPDWORD RoutingInfoBufferSize
    )
{
    BOOL Rval;


    LPWSTR RoutingGuidW = AnsiStringToUnicodeString( RoutingGuid );
    if (!RoutingGuidW) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    Rval = FaxGetRoutingInfoW(
        FaxPortHandle,
        RoutingGuidW,
        RoutingInfoBuffer,
        RoutingInfoBufferSize
        );

    MemFree( RoutingGuidW );

    return Rval;
}


BOOL
WINAPI
FaxSetRoutingInfoW(
    IN HANDLE FaxPortHandle,
    IN LPCWSTR RoutingGuid,
    IN const BYTE *RoutingInfoBuffer,
    IN DWORD RoutingInfoBufferSize
    )
{
    error_status_t ec;

    if (!ValidateFaxHandle(FaxPortHandle, FHT_PORT)) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if (!RoutingGuid || !RoutingInfoBuffer || !RoutingInfoBufferSize) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    ec = FAX_SetRoutingInfo(
        FH_PORT_HANDLE(FaxPortHandle),
        (LPWSTR)RoutingGuid,
        RoutingInfoBuffer,
        RoutingInfoBufferSize
        );
    if (ec) {
        SetLastError( ec );
        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
FaxSetRoutingInfoA(
    IN HANDLE FaxPortHandle,
    IN LPCSTR RoutingGuid,
    IN const BYTE *RoutingInfoBuffer,
    IN DWORD RoutingInfoBufferSize
    )
{
    BOOL Rval;


    LPWSTR RoutingGuidW = AnsiStringToUnicodeString( RoutingGuid );
    if (!RoutingGuidW) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    Rval = FaxSetRoutingInfoW(
        FaxPortHandle,
        RoutingGuidW,
        RoutingInfoBuffer,
        RoutingInfoBufferSize
        );

    MemFree( RoutingGuidW );

    return Rval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\client\job.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    print.c

Abstract:

    This module contains the job
    specific WINFAX API functions.

Author:

    Wesley Witt (wesw) 29-Nov-1996


Revision History:

--*/

#include "faxapi.h"
#pragma hdrstop


#define InchesToCM(_x)                      (((_x) * 254L + 50) / 100)
#define CMToInches(_x)                      (((_x) * 100L + 127) / 254)

#define LEFT_MARGIN                         1  // ---|
#define RIGHT_MARGIN                        1  //    |
#define TOP_MARGIN                          1  //    |---> in inches
#define BOTTOM_MARGIN                       1  // ---|

#define FAX_DISPLAY_NAME            TEXT("Fax Service")



static int TiffDataWidth[] = {
    0,  // nothing
    1,  // TIFF_BYTE
    1,  // TIFF_ASCII
    2,  // TIFF_SHORT
    4,  // TIFF_LONG
    8,  // TIFF_RATIONAL
    1,  // TIFF_SBYTE
    1,  // TIFF_UNDEFINED
    2,  // TIFF_SSHORT
    4,  // TIFF_SLONG
    8,  // TIFF_SRATIONAL
    4,  // TIFF_FLOAT
    8,  // TIFF_DOUBLE
};


VOID
LocalSystemTimeToSystemTime(
    LPSYSTEMTIME LocalSystemTime,
    LPSYSTEMTIME SystemTime
    )
{
    FILETIME LocalFileTime;
    FILETIME UtcFileTime;

    SystemTimeToFileTime( LocalSystemTime, &LocalFileTime );
    LocalFileTimeToFileTime( &LocalFileTime, &UtcFileTime );
    FileTimeToSystemTime( &UtcFileTime, SystemTime );
}


LPWSTR
GetFaxPrinterName(
    VOID
    )
{
    PPRINTER_INFO_2 PrinterInfo;
    DWORD i;
    DWORD Count;


    PrinterInfo = (PPRINTER_INFO_2) MyEnumPrinters( NULL, 2, &Count, PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS );
    if (PrinterInfo == NULL) {
        return NULL;
    }

    for (i=0; i<Count; i++) {
        if (_wcsicmp( PrinterInfo[i].pDriverName, FAX_DRIVER_NAME ) == 0 &&
            _wcsicmp( PrinterInfo[i].pPortName, FAX_PORT_NAME ) == 0)
        {
            LPWSTR p = (LPWSTR) StringDup( PrinterInfo[i].pPrinterName );
            MemFree( PrinterInfo );
            return p;
        }
    }

    MemFree( PrinterInfo );
    return NULL;
}


BOOL
PrintTextFile(
    HDC hDC,
    LPWSTR FileName
    )

/*++

Routine Description:

    Prints a file of plain text into the printer DC provided.
    Note: this code was stolen from notepad.

Arguments:

    hDC         - Printer DC
    FileName    - Text file name

Return Value:

    TRUE for success.
    FALSE for failure.

--*/

{
    FILE_MAPPING fmText;
    LPSTR BodyText = NULL;
    LPSTR lpLine;
    LPSTR pLineEOL;
    LPSTR pNextLine;
    HFONT hFont = NULL;
    LOGFONT logFont;
    BOOL PreferredFont = TRUE;
    HFONT hPrevFont = NULL;
    TEXTMETRIC tm;
    BOOL rVal = TRUE;
    INT nLinesPerPage;
    INT dyTop;              // width of top border (pixels)
    INT dyBottom;           // width of bottom border
    INT dxLeft;             // width of left border
    INT dxRight;            // width of right border
    INT yPrintChar;         // height of a character
    INT tabSize;            // Size of a tab for print device in device units
    INT yCurpos = 0;
    INT xCurpos = 0;
    INT nPixelsLeft = 0;
    INT guess = 0;
    SIZE Size;                 // to see if text will fit in space left
    INT nPrintedLines = 0;
    BOOL fPageStarted = FALSE;
    INT iPageNum = 0;
    INT xPrintRes;          // printer resolution in x direction
    INT yPrintRes;          // printer resolution in y direction
    INT yPixInch;           // pixels/inch
    INT xPixInch;           // pixels/inch
    INT xPixUnit;           // pixels/local measurement unit
    INT yPixUnit;           // pixels/local measurement unit
    BOOL fEnglish;
    INT Chars;
    INT PrevBkMode = 0;


    if (!MapFileOpen( FileName, TRUE, 0, &fmText )) {
        return FALSE;
    }

    Chars = fmText.fSize;
    BodyText = fmText.fPtr;
    lpLine = BodyText;

    fEnglish = GetProfileInt( L"intl", L"iMeasure", 1 );

    xPrintRes = GetDeviceCaps( hDC, HORZRES );
    yPrintRes = GetDeviceCaps( hDC, VERTRES );
    xPixInch  = GetDeviceCaps( hDC, LOGPIXELSX );
    yPixInch  = GetDeviceCaps( hDC, LOGPIXELSY );
    //
    // compute x and y pixels per local measurement unit
    //
    if (fEnglish) {
        xPixUnit= xPixInch;
        yPixUnit= yPixInch;
    } else {
        xPixUnit= CMToInches( xPixInch );
        yPixUnit= CMToInches( yPixInch );
    }

    SetMapMode( hDC, MM_TEXT );

    ZeroMemory(&logFont, sizeof(logFont));
    logFont.lfHeight = -22; // scan lines
    logFont.lfWeight = FW_NORMAL;
    logFont.lfCharSet = DEFAULT_CHARSET;
    logFont.lfOutPrecision = OUT_DEFAULT_PRECIS;
    logFont.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    logFont.lfQuality = DEFAULT_QUALITY;
    logFont.lfPitchAndFamily = FIXED_PITCH | FF_DONTCARE;

    hFont = CreateFontIndirect(&logFont);
    if (!hFont) {
        hFont = GetStockObject( SYSTEM_FIXED_FONT );
    }

    hPrevFont = (HFONT) SelectObject( hDC, hFont );
    SetBkMode( hDC, TRANSPARENT );
    if (!GetTextMetrics( hDC, &tm )) {
        rVal = FALSE;
        goto exit;
    }

    yPrintChar = tm.tmHeight + tm.tmExternalLeading;
    tabSize = tm.tmAveCharWidth * 8;

    //
    // compute margins in pixels
    //
    dxLeft     = LEFT_MARGIN    *  xPixUnit;
    dxRight    = RIGHT_MARGIN   *  xPixUnit;
    dyTop      = TOP_MARGIN     *  yPixUnit;
    dyBottom   = BOTTOM_MARGIN  *  yPixUnit;

    //
    // Number of lines on a page with margins
    //
    nLinesPerPage = ((yPrintRes - dyTop - dyBottom) / yPrintChar);

    while (*lpLine) {

        if (*lpLine == '\r') {
            lpLine += 2;
            yCurpos += yPrintChar;
            nPrintedLines++;
            xCurpos= 0;
            continue;
        }

        pLineEOL = lpLine;
        while (*pLineEOL && *pLineEOL != '\r') pLineEOL++;

        do {
            if ((nPrintedLines == 0) && (!fPageStarted)) {

                StartPage( hDC );
                fPageStarted = TRUE;
                yCurpos = 0;
                xCurpos = 0;

            }

            if (*lpLine == '\t') {

                //
                // round up to the next tab stop
                // if the current position is on the tabstop, goto next one
                //
                xCurpos = ((xCurpos + tabSize) / tabSize ) * tabSize;
                lpLine++;

            } else {

                //
                // find end of line or tab
                //
                pNextLine = lpLine;
                while ((pNextLine != pLineEOL) && *pNextLine != '\t') pNextLine++;

                //
                // find out how many characters will fit on line
                //
                Chars = (INT)(pNextLine - lpLine);
                nPixelsLeft = xPrintRes - dxRight - dxLeft - xCurpos;
                GetTextExtentExPointA( hDC, lpLine, Chars, nPixelsLeft, &guess, NULL, &Size );


                if (guess) {
                    //
                    // at least one character fits - print
                    //

                    TextOutA( hDC, dxLeft+xCurpos, yCurpos+dyTop, lpLine, guess );

                    xCurpos += Size.cx;   // account for printing
                    lpLine  += guess;     // printed characters

                } else {

                    //
                    // no characters fit what's left
                    // no characters will fit in space left
                    // if none ever will, just print one
                    // character to keep progressing through
                    // input file.
                    //
                    if (xCurpos == 0) {
                        if( lpLine != pNextLine ) {
                            //
                            // print something if not null line
                            // could use exttextout here to clip
                            //
                            TextOutA( hDC, dxLeft+xCurpos, yCurpos+dyTop, lpLine, 1 );
                            lpLine++;
                        }
                    } else {
                        //
                        // perhaps the next line will get it
                        //
                        xCurpos = xPrintRes;  // force to next line
                    }
                }

                //
                // move printhead in y-direction
                //
                if ((xCurpos >= (xPrintRes - dxRight - dxLeft) ) || (lpLine == pLineEOL)) {
                   yCurpos += yPrintChar;
                   nPrintedLines++;
                   xCurpos = 0;
                }

                if (nPrintedLines >= nLinesPerPage) {
                   EndPage( hDC );
                   fPageStarted = FALSE;
                   nPrintedLines = 0;
                   xCurpos = 0;
                   yCurpos = 0;
                   iPageNum++;
                }

            }

        } while( lpLine != pLineEOL );

        if (*lpLine == '\r') {
            lpLine += 1;
        }
        if (*lpLine == '\n') {
            lpLine += 1;
        }

    }

    if (fPageStarted) {
        EndPage( hDC );
    }

exit:
    if (fmText.fPtr) {
        MapFileClose( &fmText, 0 );
    }
    if (hPrevFont) {
        SelectObject( hDC, hPrevFont );
        DeleteObject( hFont );
    }
    if (PrevBkMode) {
        SetBkMode( hDC, PrevBkMode );
    }
    return rVal;
}

BOOL
PrintRandomDocument(
    LPCWSTR FaxPrinterName,
    LPCWSTR DocName,
    LPWSTR OutputFile
    )

/*++

Routine Description:

    Prints a document that is attached to a message

Arguments:

    FaxPrinterName  - name of the printer to print the attachment on
    DocName         - name of the attachment document

Return Value:

    Print job id or zero for failure.

--*/

{
    SHELLEXECUTEINFO sei;
    WCHAR Args[MAX_PATH];
    WCHAR TempPath[MAX_PATH];
    HANDLE hMap = NULL;
    HANDLE hEvent = NULL;
    HANDLE hMutex = NULL;
    HANDLE hMutexAttach = NULL;
    LPDWORD pJobId = NULL;
    DWORD JobId = 0;
    BOOL bSuccess = FALSE;

    SECURITY_ATTRIBUTES memsa,mutsa,synsa,eventsa;
    SECURITY_DESCRIPTOR memsd,mutsd,synsd,eventsd;

    //
    // get the temp path name and use it for the
    // working dir of the launched app
    //

    if (!GetTempPath( sizeof(TempPath)/sizeof(WCHAR), TempPath )) {
        return FALSE;
    }

    //
    // serialize access to this function.
    // this is necessary because we have to
    // control access to the global shared memory region and mutex
    //

        //
    // serialize access to this function.
    // this is necessary because we can't have more than one
    // app accessing our shared memory region and mutex
    //

    hMutexAttach = OpenMutex(MUTEX_ALL_ACCESS,FALSE,FAXRENDER_MUTEX);
    if (!hMutexAttach) {
        //
        // we need to open this mutex with a NULL dacl so that everyone can access this
        //
        synsa.nLength = sizeof(SECURITY_ATTRIBUTES);
        synsa.bInheritHandle = TRUE;
        synsa.lpSecurityDescriptor = &synsd;

        if(!InitializeSecurityDescriptor(&synsd, SECURITY_DESCRIPTOR_REVISION)) {
            goto exit;
        }

        if(!SetSecurityDescriptorDacl(&synsd, TRUE, (PACL)NULL, FALSE)) {
            goto exit;
        }

        hMutexAttach = CreateMutex(
                         &synsa,
                         TRUE,
                         FAXRENDER_MUTEX
                        );

        if (!hMutexAttach) {
            goto exit;
        }
    } else {
        if (WaitForSingleObject( hMutexAttach, 1000* 60 * 5) != WAIT_OBJECT_0) {
            //
            // something went wrong
            //
            CloseHandle( hMutexAttach );
            goto exit;
        }
    }

    //
    // note that this is serialized inside of a critical section.
    // we can only have one application setting this at a time or
    // we'll stomp on ourselves.
    //

    //
    //  since mapispooler might be running under a different security context,
    //  we must setup a NULL security descriptor
    //

    memsa.nLength = sizeof(SECURITY_ATTRIBUTES);
    memsa.bInheritHandle = TRUE;
    memsa.lpSecurityDescriptor = &memsd;

    if(!InitializeSecurityDescriptor(&memsd, SECURITY_DESCRIPTOR_REVISION)) {
        goto exit;
    }

    if(!SetSecurityDescriptorDacl(&memsd, TRUE, (PACL)NULL, FALSE)) {
        goto exit;
    }

    mutsa.nLength = sizeof(SECURITY_ATTRIBUTES);
    mutsa.bInheritHandle = TRUE;
    mutsa.lpSecurityDescriptor = &mutsd;

    if(!InitializeSecurityDescriptor(&mutsd, SECURITY_DESCRIPTOR_REVISION)) {
        goto exit;
    }

    if(!SetSecurityDescriptorDacl(&mutsd, TRUE, (PACL)NULL, FALSE)) {
        goto exit;
    }

    eventsa.nLength = sizeof(SECURITY_ATTRIBUTES);
    eventsa.bInheritHandle = TRUE;
    eventsa.lpSecurityDescriptor = &eventsd;

    if(!InitializeSecurityDescriptor(&eventsd, SECURITY_DESCRIPTOR_REVISION)) {
        goto exit;
    }

    if(!SetSecurityDescriptorDacl(&eventsd, TRUE, (PACL)NULL, FALSE)) {
        goto exit;
    }

    //
    // create the shared memory region for the print jobid
    // the jobid is filled in by the fax printer driver
    //

    hMap = CreateFileMapping(
        INVALID_HANDLE_VALUE,
        &memsa,
        PAGE_READWRITE | SEC_COMMIT,
        0,
        4096,
        FAXXP_MEM_NAME
        );
    if (!hMap) {
        goto exit;
    }

    pJobId = (LPDWORD) MapViewOfFile(
        hMap,
        FILE_MAP_WRITE,
        0,
        0,
        0
        );
    if (!pJobId) {
        goto exit;
    }


    wcscpy((LPTSTR) pJobId, OutputFile);


    //
    // set the arguments to the app.
    // these arguments are either passed on
    // the command line with the /pt switch or
    // use as variables for substitution in the
    // ddeexec value in the registry.
    //
    // the values are as follows:
    //      %1 = file name
    //      %2 = printer name
    //      %3 = driver name
    //      %4 = port name
    //
    // the first argument does not need to be
    // supplied in the args array because it is implied,
    // shellexecuteex gets it from the lpFile field.
    // arguments 3 & 4 are left blank because they
    // are win31 artifacts that are not necessary
    // any more.  each argument must be enclosed
    // in double quotes.
    //

    wsprintf( Args, L"\"%s\" \"\" \"\"", FaxPrinterName );

    //
    // fill in the SHELLEXECUTEINFO structure
    //

    sei.cbSize       = sizeof(sei);
    sei.fMask        = SEE_MASK_FLAG_NO_UI | SEE_MASK_NOCLOSEPROCESS | SEE_MASK_FLAG_DDEWAIT;
    sei.hwnd         = NULL;
    sei.lpVerb       = L"printto";
    sei.lpFile       = DocName;
    sei.lpParameters = Args;
    sei.lpDirectory  = TempPath;
    sei.nShow        = SW_SHOWMINNOACTIVE;
    sei.hInstApp     = NULL;
    sei.lpIDList     = NULL;
    sei.lpClass      = NULL;
    sei.hkeyClass    = NULL;
    sei.dwHotKey     = 0;
    sei.hIcon        = NULL;
    sei.hProcess     = NULL;


    //
    // create the named mutex for the print driver.
    // this is initially unclaimed, and is claimed by the first instance
    // of the print driver invoked after this. We do this last in order to
    // avoid a situation where we catch the incorrect instance of the print driver
    // printing
    //
    hMutex = CreateMutex(
                         &mutsa,
                         FALSE,
                         FAXXP_MUTEX_NAME
                        );
    if (!hMutex) {
        goto exit;
    }

    //
    // create the named event for the print driver.
    // this event is signaled when the print driver is finished rendering the document
    //
    hEvent = CreateEvent(
                         &eventsa,
                         FALSE,
                         FALSE,
                         FAXXP_EVENT_NAME
                        );
    if (!hEvent) {
        goto exit;
    }

    //
    // launch the app
    //

    if (!ShellExecuteEx( &sei )) {
        goto exit;
    }

    //
    // wait for the print driver to finish rendering the document
    //
    if (WaitForSingleObject( hEvent, 1000 * 60 * 5 ) != WAIT_OBJECT_0) {
        //
        // something went wrong...
        //
        goto exit;
    }

    //
    // wait for the print driver to exit so we can get the document
    //
    if (WaitForSingleObject( hMutex, 1000 * 60 * 5) != WAIT_OBJECT_0) {
        //
        // something went wrong
        //
        goto exit;
    }

    ReleaseMutex(hMutex);

    //
    // save the print jobid
    //

    JobId = *pJobId;

    bSuccess = TRUE;

exit:
    //
    // clean up and leave...
    //

    if (sei.hProcess) CloseHandle( sei.hProcess );
    if (hEvent) CloseHandle( hEvent );
    if (hMutex) CloseHandle( hMutex );
    if (pJobId) UnmapViewOfFile( pJobId );
    if (hMap) CloseHandle( hMap );

    if (hMutexAttach) {
        ReleaseMutex( hMutexAttach );
        CloseHandle( hMutexAttach );
    }

    if (!bSuccess) {
        SetLastError(ERROR_INVALID_DATA);
    }

    return bSuccess;
}


BOOL
CreateCoverpageTiffFile(
    IN const FAX_COVERPAGE_INFOW *CoverpageInfo,
    OUT LPWSTR CovTiffFile
    )
{
    WCHAR TempPath[MAX_PATH];
    WCHAR TempFile[MAX_PATH];
    LPWSTR FaxPrinter;
    FAX_PRINT_INFOW PrintInfo;
    FAX_CONTEXT_INFOW ContextInfo;
    DWORD TmpFaxJobId;
    BOOL Rslt;


    TempFile[0] = 0;

    FaxPrinter = GetFaxPrinterName();
    if (FaxPrinter == NULL) {
        return FALSE;
    }

    if (!GetTempPath( sizeof(TempPath)/sizeof(WCHAR), TempPath ) ||
        !GetTempFileName( TempPath, L"fax", 0, TempFile ))
    {
        return FALSE;
    }

    ZeroMemory( &PrintInfo, sizeof(FAX_PRINT_INFO) );

    PrintInfo.SizeOfStruct = sizeof(FAX_PRINT_INFO);
    PrintInfo.OutputFileName = TempFile;

    ZeroMemory( &ContextInfo, sizeof(FAX_CONTEXT_INFOW) );
    ContextInfo.SizeOfStruct = sizeof(FAX_CONTEXT_INFOW);

    if (!FaxStartPrintJobW( FaxPrinter, &PrintInfo, &TmpFaxJobId, &ContextInfo )) {
        DeleteFile( TempFile );
        return FALSE;
    }

    Rslt = FaxPrintCoverPageW( &ContextInfo, CoverpageInfo );

    EndDoc( ContextInfo.hDC );
    DeleteDC( ContextInfo.hDC );

    if (!Rslt) {
        DeleteFile( TempFile );
        return FALSE;
    }

    wcscpy( CovTiffFile, TempFile );

    return TRUE;
}


BOOL
CreateFinalTiffFile(
    IN LPWSTR FileName,
    OUT LPWSTR FinalTiffFile,
    IN const FAX_COVERPAGE_INFOW *CoverpageInfo
    )
{
    WCHAR TempPath[MAX_PATH];
    WCHAR FullPath[MAX_PATH];
    WCHAR TempFile[MAX_PATH];
    WCHAR TiffFile[MAX_PATH];
    LPWSTR FaxPrinter = NULL;
    FAX_PRINT_INFOW PrintInfo;
    DWORD TmpFaxJobId;
    FAX_CONTEXT_INFOW ContextInfo;
    LPWSTR p;
    DWORD Flags = 0;
    BOOL Rslt;

    //
    // make sure that the tiff file passed in is a valid tiff file
    //

    if (!GetTempPath( sizeof(TempPath)/sizeof(WCHAR), TempPath )) {
        return FALSE;
    }

    if (GetTempFileName( TempPath, L"fax", 0, TempFile ) == 0 ||
        GetFullPathName( TempFile, sizeof(FullPath)/sizeof(WCHAR), FullPath, &p ) == 0)
    {
        return FALSE;
    }

    if (!ConvertTiffFileToValidFaxFormat( FileName, FullPath, &Flags )) {
        if ((Flags & TIFFCF_NOT_TIFF_FILE) == 0) {
            Flags = TIFFCF_NOT_TIFF_FILE;
        }
    }

    if (Flags & TIFFCF_NOT_TIFF_FILE) {
        //
        // try to output the source file into a tiff file,
        // by printing to the fax printer in "file" mode
        //

        FaxPrinter = GetFaxPrinterName();
        if (FaxPrinter == NULL) {
            DeleteFile( FullPath );
            SetLastError( ERROR_INVALID_FUNCTION );
            return FALSE;
        }

        if (!PrintRandomDocument( FaxPrinter, FileName, FullPath )) {
            DeleteFile( FullPath );
            SetLastError( ERROR_INVALID_FUNCTION );
            return FALSE;
        }
        wcscpy( TiffFile, FullPath );

    } else if (Flags & TIFFCF_UNCOMPRESSED_BITS) {

        if (FaxPrinter == NULL) {
            FaxPrinter = GetFaxPrinterName();
            if (FaxPrinter == NULL) {
                DeleteFile( FullPath );
                SetLastError( ERROR_INVALID_FUNCTION );
                return FALSE;
            }
        }

        if (Flags & TIFFCF_ORIGINAL_FILE_GOOD) {
            //
            // nothing at fullpath, just delete it and use the original source
            //
            DeleteFile( FullPath );
            wcscpy( TiffFile, FileName );
        } else {
            wcscpy( TiffFile, FullPath );
        }

        if (GetTempFileName( TempPath, L"fax", 0, TempFile ) == 0 ||
            GetFullPathName( TempFile, sizeof(FullPath)/sizeof(WCHAR), FullPath, &p ) == 0)
        {
            DeleteFile( TiffFile );
            return FALSE;
        }

        ZeroMemory( &PrintInfo, sizeof(FAX_PRINT_INFOW) );

        PrintInfo.SizeOfStruct = sizeof(FAX_PRINT_INFOW);
        PrintInfo.OutputFileName = FullPath;

        ZeroMemory( &ContextInfo, sizeof(FAX_CONTEXT_INFOW) );
        ContextInfo.SizeOfStruct = sizeof(FAX_CONTEXT_INFOW);

        if (!FaxStartPrintJobW( FaxPrinter, &PrintInfo, &TmpFaxJobId, &ContextInfo )) {
            if ((Flags & TIFFCF_ORIGINAL_FILE_GOOD) == 0) DeleteFile( TiffFile );
            DeleteFile( FullPath );
            SetLastError( ERROR_INVALID_FUNCTION );
            return FALSE;
        }

        Rslt = PrintTiffFile( ContextInfo.hDC, TiffFile );

        EndDoc( ContextInfo.hDC );
        DeleteDC( ContextInfo.hDC );

        if ((Flags & TIFFCF_ORIGINAL_FILE_GOOD) == 0) {
            DeleteFile( TiffFile );
        }

        if (!Rslt) {
            DeleteFile( FullPath );
            SetLastError( ERROR_INVALID_FUNCTION );
            return FALSE;
        }

        wcscpy( TiffFile, FullPath );

    } else if (Flags & TIFFCF_ORIGINAL_FILE_GOOD) {

        //
        // we didn't create anything at FullPath, just use FileName
        //
        DeleteFile( FullPath );
        wcscpy( TiffFile, FileName );

    } else {
        //
        // should never hit this case
        //
        DeleteFile( FullPath );
        SetLastError( ERROR_INVALID_FUNCTION );
        return FALSE;
    }

    //
    // if a coverpage is specified then print the coverpage first
    //

    if (CoverpageInfo && CoverpageInfo->CoverPageName) {

        if (!CreateCoverpageTiffFile( CoverpageInfo, TempFile )) {
            if (wcscmp(FileName,TiffFile) != 0) DeleteFile( TiffFile );
            DeleteFile( TempFile );
            return FALSE;
        }

        if (!MergeTiffFiles( TempFile, TiffFile )) {
            if (wcscmp(FileName,TiffFile) != 0) DeleteFile( TiffFile );
            DeleteFile( TempFile );
            return FALSE;
        }

        FileName = TempFile;

    } else {

        FileName = TiffFile;

    }

    wcscpy( FinalTiffFile, FileName );

    return TRUE;
}


BOOL
CopyFileToServerQueue(
    IN const HANDLE FaxHandle,
    IN LPCWSTR TiffFile,
    IN LPWSTR QueueFileName
    )
{
    error_status_t ec;
    WCHAR FullPath[MAX_PATH];


    //
    // get a file name from the fax server
    //

    ec = FAX_GetQueueFileName( FH_FAX_HANDLE(FaxHandle), QueueFileName, MAX_PATH );
    if (ec) {
        SetLastError( ec );
        return FALSE;
    }

    //
    // create the full path to the new file
    //

    if (!IsLocalFaxConnection(FaxHandle)) {
        //
        // remote file
        //
        swprintf( FullPath, FAX_QUEUE_PATH, FH_DATA(FaxHandle)->MachineName, QueueFileName );
    } else {
        //
        // local file
        //
        if (!GetSpecialPath( CSIDL_COMMON_APPDATA, FullPath )) {
           return FALSE;
        }
        ConcatenatePaths( FullPath, FAX_QUEUE_DIR );
        ConcatenatePaths( FullPath, QueueFileName );
    }

    //
    // copy the file to the fax server queue dir
    //

    if (!CopyFile( TiffFile, FullPath, FALSE )) {
        return FALSE;
    }

    SetFileAttributes( FullPath, (GetFileAttributes( FullPath ) & (0xFFFFFFFF^FILE_ATTRIBUTE_READONLY)) | FILE_ATTRIBUTE_NORMAL );

    return TRUE;
}

DWORD
GetLineId(
   FARPROC LineGetId,
   HCALL CallHandle
   )
{

   LPVARSTRING DeviceId;

   long rslt = 0;
   DWORD LineId;


   //
   // get the deviceID associated with the call handle
   //
   DeviceId = MemAlloc(sizeof(VARSTRING)+1000);
   if (!DeviceId) {
       SetLastError(ERROR_NOT_ENOUGH_MEMORY);
       return 0;
   }
   DeviceId->dwTotalSize=sizeof(VARSTRING) +1000;

   rslt = (DWORD)LineGetId(NULL,0,(HCALL) CallHandle,LINECALLSELECT_CALL,DeviceId,L"tapi/line");
   if (rslt < 0) {
       DebugPrint((TEXT("LineGetId() failed, ec = %x\n"),rslt));
       MemFree(DeviceId);
       SetLastError(ERROR_INVALID_PARAMETER);
       return 0;
   }

   if (DeviceId->dwStringFormat != STRINGFORMAT_BINARY ) {
       MemFree(DeviceId);
       SetLastError(ERROR_INVALID_PARAMETER);
       return 0;
   }

   LineId = (DWORD) *((LPBYTE)DeviceId + DeviceId->dwStringOffset);

   MemFree(DeviceId);

   return LineId;
}


BOOL
WINAPI
FaxSendDocumentW(
    IN HANDLE FaxHandle,
    IN LPCWSTR FileName,
    IN FAX_JOB_PARAMW *JobParams,
    IN const FAX_COVERPAGE_INFOW *CoverpageInfo,
    OUT LPDWORD FaxJobId
    )

/*++

Routine Description:

    Sends a FAX document to the specified recipient.
    This is an asychronous operation.  Use FaxReportStatus
    to determine when the send is completed.

Arguments:

    FaxHandle       - FAX handle obtained from FaxConnectFaxServer.
    FileName        - File containing the TIFF-F FAX document.
    JobParams       - pointer to FAX_JOB_PARAM structure with transmission params
    CoverpageInfo   - optional pointer to FAX_COVERPAGE_INFO structure
    FaxJobId        - receives the Fax JobId for the job.


Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    error_status_t ec;
    WCHAR QueueFileName[MAX_PATH];
    WCHAR ExistingFile[MAX_PATH];
    DWORD rc;
    LPWSTR p;
    WCHAR TiffFile[MAX_PATH];

    HINSTANCE hTapiLib = NULL;
    WCHAR TapiPath[MAX_PATH];
    WCHAR MutexName[64];
    HANDLE hLineMutex = NULL;

    FARPROC LineHandoff;
    FARPROC LineGetId;

    IUnknown* pDisp=NULL;
    ITBasicCallControl* pCallControl;
    ITCallInfo* pCallInfo;
    ITAddress* pAddressInfo;
    ITAddressCapabilities* pAddressCaps;
    CALL_STATE CallState;
    BSTR FaxSvcName;
    HRESULT hr;
    DWORD LineId;
    DWORD _JobId;

    DWORD Event = 0;
    long rslt = 0;



    //
    // argument validation
    //
    if (!ValidateFaxHandle(FaxHandle, FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       return FALSE;
    }

    if (!FileName || !JobParams || JobParams->SizeOfStruct != sizeof(FAX_JOB_PARAMW)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (JobParams->ScheduleAction != JSA_NOW &&
        JobParams->ScheduleAction != JSA_SPECIFIC_TIME &&
        JobParams->ScheduleAction != JSA_DISCOUNT_PERIOD) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (JobParams->DeliveryReportType != DRT_NONE &&
        JobParams->DeliveryReportType != DRT_EMAIL &&
        JobParams->DeliveryReportType != DRT_INBOX ) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }



    //
    // make sure the file is there
    //
    rc = GetFullPathName(FileName,sizeof(ExistingFile)/sizeof(WCHAR),ExistingFile,&p);

    if (rc > MAX_PATH || rc == 0) {
        DebugPrint(( TEXT("GetFullPathName failed, ec= %d\n"),GetLastError() ));
        SetLastError( (rc > MAX_PATH)
                      ? ERROR_BUFFER_OVERFLOW
                      : GetLastError() );
        return FALSE;
    }

    if (GetFileAttributes(ExistingFile)==0xFFFFFFFF) {
            SetLastError(ERROR_FILE_NOT_FOUND);
            return FALSE;
    }

    //
    // if they want a coverpage, try to validate it
    //
    if (CoverpageInfo  &&
        !ValidateCoverpage(CoverpageInfo->CoverPageName,
                           IsLocalFaxConnection(FaxHandle) ? NULL : FH_DATA(FaxHandle)->MachineName,
                           CoverpageInfo->UseServerCoverPage,
                           NULL)) {
            SetLastError(ERROR_FILE_NOT_FOUND);
            return FALSE;
    }


    if (JobParams->CallHandle != 0 || JobParams->Reserved[0]==0xFFFF1234) {
       //
       // we don't support call handoff if it's a remote server connection
       //
       if (!IsLocalFaxConnection(FaxHandle)) {
          SetLastError(ERROR_INVALID_FUNCTION);
          return FALSE;
       }


       if (JobParams->CallHandle) {
           //
           // tapi is dynamic
           //
           ExpandEnvironmentStrings(TAPI_LIBRARY,TapiPath,MAX_PATH);
           hTapiLib = LoadLibrary(TapiPath);
           if (!hTapiLib) {
              SetLastError(ERROR_INVALID_LIBRARY);
              return FALSE;
           }

           LineHandoff =  GetProcAddress(hTapiLib,"lineHandoffW");
           LineGetId = GetProcAddress(hTapiLib,"lineGetIDW");

           if (!LineHandoff || !LineGetId) {
              FreeLibrary(hTapiLib);
              SetLastError(ERROR_INVALID_FUNCTION);
              return FALSE;
           }

           //
           // get the line ID
           //
           LineId = GetLineId(LineGetId,JobParams->CallHandle);
           if (LineId) {
              JobParams->Reserved[2] = LineId;
           }  else {
              FreeLibrary(hTapiLib);
              SetLastError(ERROR_INVALID_FUNCTION);
              return FALSE;
           }
       } else if (JobParams->Reserved[1]) {

          //
          // GetDeviceId from tapi3 dispinterface
          //
          pDisp = (IUnknown*) JobParams->Reserved[1];
          hr = pDisp->lpVtbl->QueryInterface( pDisp, &IID_ITCallInfo, (void**)&pCallInfo );
          if (FAILED(hr)) {
             SetLastError(ERROR_INVALID_PARAMETER);
             return FALSE;
          }

          if (FAILED(pCallInfo->lpVtbl->get_CallState(pCallInfo,&CallState))) {
             pCallInfo->lpVtbl->Release(pCallInfo);
             SetLastError(ERROR_INVALID_PARAMETER);
             return FALSE;
          }

          if (CallState != CS_CONNECTED) {
             DebugPrint(( TEXT("callstate(%d) is invalid, cannot handoff job\n"),CallState ));
             pCallInfo->lpVtbl->Release(pCallInfo);
             SetLastError(ERROR_INVALID_PARAMETER);
             return FALSE;
          }

          if (FAILED(pCallInfo->lpVtbl->get_Address(pCallInfo,&pAddressInfo))) {
             pCallInfo->lpVtbl->Release(pCallInfo);
             SetLastError(ERROR_INVALID_PARAMETER);
             return FALSE;
          }

          if (FAILED(pAddressInfo->lpVtbl->QueryInterface(pAddressInfo, &IID_ITAddressCapabilities, (void**)&pAddressCaps))) {
             pCallInfo->lpVtbl->Release(pCallInfo);
             pAddressInfo->lpVtbl->Release(pAddressInfo);
             SetLastError(ERROR_INVALID_PARAMETER);
             return FALSE;
          }

          if (FAILED(pAddressCaps->lpVtbl->get_AddressCapability( pAddressCaps, AC_LINEID, &LineId ))) {
             pCallInfo->lpVtbl->Release(pCallInfo);
             pAddressInfo->lpVtbl->Release(pAddressInfo);
             pAddressCaps->lpVtbl->Release(pAddressCaps);
             SetLastError(ERROR_INVALID_PARAMETER);
             return FALSE;
          }

          if (LineId == 0) {
             pCallInfo->lpVtbl->Release(pCallInfo);
             pAddressInfo->lpVtbl->Release(pAddressInfo);
             pAddressCaps->lpVtbl->Release(pAddressCaps);
             SetLastError(ERROR_INVALID_PARAMETER);
             return FALSE;
          }

          JobParams->Reserved[2] = LineId;

          pCallInfo->lpVtbl->Release(pCallInfo);
          pAddressInfo->lpVtbl->Release(pAddressInfo);
          pAddressCaps->lpVtbl->Release(pAddressCaps);

       } else {
          SetLastError(ERROR_INVALID_PARAMETER);
          return FALSE;
       }

      DebugPrint((TEXT("device ID = %d\n"),JobParams->Reserved[2]));

      //
      // we need a mutex to ensure fax service owns the line before calling lineHandoff
      //
      wsprintf(MutexName,L"FaxLineHandoff%d",JobParams->Reserved[2]);
      hLineMutex = CreateMutex(NULL,FALSE,MutexName);
      if (!hLineMutex) {
         FreeLibrary(hTapiLib);
         return FALSE;
      }

    } else {
        //
        // this is a normal fax...validate the fax number.
        //
        if (!JobParams->RecipientNumber) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
    }


    //
    // make sure that the tiff file passed in is a valid tiff file
    //

    ZeroMemory(TiffFile,sizeof(TiffFile));
    if (!CreateFinalTiffFile( (LPWSTR) ExistingFile, TiffFile, CoverpageInfo )) {
        DeleteFile( TiffFile );
        if (hTapiLib) {
           FreeLibrary(hTapiLib);
        }
        if (hLineMutex) {
            CloseHandle(hLineMutex);
        }

        SetLastError(ERROR_INVALID_DATA);

        return FALSE;
    }

    //
    // copy the file to the server's queue dir
    //

    if (!CopyFileToServerQueue( FaxHandle, TiffFile, QueueFileName )) {
        if (hTapiLib) {
           FreeLibrary(hTapiLib);
        }
        if (hLineMutex) {
            CloseHandle(hLineMutex);
        }
        return FALSE;
    }

    //
    // the passed in file should be treated as read-only
    // if we created a temp file then delete it
    //
    if (wcscmp(ExistingFile,TiffFile) != 0) {
        DeleteFile( TiffFile );
    }

    //
    // queue the fax to be sent
    //

    if (JobParams->Reserved[0] != 0xffffffff)
    {
        JobParams->Reserved[0] = 0;
        JobParams->Reserved[1] = 0;
    }

    if (JobParams->ScheduleAction == JSA_SPECIFIC_TIME) {
        //
        // convert the system time from local to utc
        //
        LocalSystemTimeToSystemTime( &JobParams->ScheduleTime, &JobParams->ScheduleTime );
    }

    ec = FAX_SendDocument( FH_FAX_HANDLE(FaxHandle), QueueFileName, JobParams, &_JobId );
    if (ec) {
        SetLastError( ec );
        if (hTapiLib) {
           FreeLibrary(hTapiLib);
        }
        if (hLineMutex) {
            CloseHandle(hLineMutex);
        }
        return FALSE;
    }

    if (FaxJobId) {
        *FaxJobId = _JobId;
    }

    //
    // we're done if it's a normal call
    //
    if (JobParams->CallHandle == 0 && !pDisp) {
        return TRUE;
    }

    //
    // wait for Mutex to get signalled
    //
    DebugPrint((TEXT("Waiting for mutex \"FaxLineHandoff%d\""),JobParams->Reserved[2]));
    Event = WaitForSingleObject(hLineMutex,INFINITE);

    if (Event != WAIT_OBJECT_0 ) {
       //
       // bail out, we couldn't open the line?
       //
    }

    //
    // handoff the call to the fax service, FSP must change media mode appropriately
    //
    if (JobParams->CallHandle) {

        //
        // TAPI 2.0 handoff
        //
        DebugPrint((TEXT("Handing off call %x to faxsvc"),JobParams->CallHandle));
        rslt = (long)LineHandoff(JobParams->CallHandle, FAX_DISPLAY_NAME , 0 );

        FreeLibrary(hTapiLib);
        CloseHandle(hLineMutex);

        if (rslt != 0) {
           SetLastError(rslt);
           return FALSE;
        }
    } else {
       //
       // TAPI 3.0 handoff
       //
       pDisp->lpVtbl->QueryInterface( pDisp, &IID_ITBasicCallControl, (void**)&pCallControl );
       if (FAILED(hr)) {
          SetLastError(ERROR_INVALID_FUNCTION);
          return FALSE;
       }

       FaxSvcName = SysAllocString( FAX_DISPLAY_NAME );
       hr = pCallControl->lpVtbl->HandoffDirect(pCallControl,FaxSvcName);
       pCallControl->lpVtbl->Release(pCallControl);
       SysFreeString( FaxSvcName );

       if (FAILED(hr)) {
          DebugPrint((TEXT("call handoff failed, ec = %x"),hr));
          return FALSE;
       }

    }

    return TRUE;
}


WINFAXAPI
BOOL
WINAPI
FaxSendDocumentForBroadcastW(
    IN HANDLE FaxHandle,
    IN LPCWSTR FileName,
    OUT LPDWORD FaxJobId,
    IN PFAX_RECIPIENT_CALLBACKW FaxRecipientCallback,
    IN LPVOID Context
    )
{
    error_status_t ec;
    WCHAR TempFile[MAX_PATH];
    WCHAR TiffFile[MAX_PATH];
    WCHAR CovFileName[MAX_PATH];
    WCHAR BodyFileName[MAX_PATH];
    WCHAR ExistingFile[MAX_PATH];
    DWORD rc;
    LPWSTR p;
    FAX_JOB_PARAMW JobParams;
    FAX_COVERPAGE_INFOW CoverpageInfo;
    DWORD TmpFaxJobId;
    DWORD BcFaxJobId = 0;
    DWORD i = 1;
    HANDLE hTiff = NULL;
    TIFF_INFO TiffInfo;
    DWORD PageCount;

    if (!ValidateFaxHandle(FaxHandle, FHT_SERVICE)) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if (!FileName || !FaxRecipientCallback) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // make sure the file is there
    //
    rc = GetFullPathName(FileName,sizeof(ExistingFile)/sizeof(WCHAR),ExistingFile,&p);

    if (rc > MAX_PATH || rc == 0) {
        DebugPrint(( TEXT("GetFullPathName failed, ec= %d\n"),GetLastError() ));
        SetLastError( (rc > MAX_PATH)
                      ? ERROR_BUFFER_OVERFLOW
                      : GetLastError() );
        return FALSE;
    }

    if (GetFileAttributes(ExistingFile)==0xFFFFFFFF) {
            SetLastError(ERROR_FILE_NOT_FOUND);
            return FALSE;
    }

    ZeroMemory(TiffFile,sizeof(TiffFile));
    if (!CreateFinalTiffFile( (LPWSTR) ExistingFile, TiffFile, NULL)) {
        DeleteFile( TiffFile );
        SetLastError(ERROR_INVALID_DATA);
        return FALSE;
    }

    hTiff = TiffOpen( TiffFile, &TiffInfo, TRUE, FILLORDER_MSB2LSB );
    if (hTiff == NULL) {
        DeleteFile( TiffFile );
        SetLastError(ERROR_INVALID_DATA);
        return FALSE;
    }

    PageCount = TiffInfo.PageCount;

    TiffClose( hTiff );

    if (!CopyFileToServerQueue( FaxHandle, TiffFile, BodyFileName )) {
        DeleteFile( TiffFile );
        return FALSE;
    }

    //
    // the passed in file should be treated as read-only
    // if we created a temp file then delete it
    //
    if (wcscmp(ExistingFile,TiffFile) != 0) {
        DeleteFile( TiffFile );
    }

    ZeroMemory( &JobParams, sizeof(JobParams) );
    JobParams.SizeOfStruct = sizeof(JobParams);
    JobParams.Reserved[0] = 0xfffffffe;
    JobParams.Reserved[1] = 1;
    JobParams.Reserved[2] = 0;

    ec = FAX_SendDocument( FH_FAX_HANDLE(FaxHandle), BodyFileName, &JobParams, &BcFaxJobId );
    if (ec) {
        SetLastError( ec );
        return FALSE;
    }

    if (FaxJobId) {
        *FaxJobId = BcFaxJobId;
    }

    while (TRUE) {

        ZeroMemory( &JobParams, sizeof(JobParams) );
        JobParams.SizeOfStruct = sizeof(JobParams);

        ZeroMemory( &CoverpageInfo, sizeof(CoverpageInfo) );
        CoverpageInfo.SizeOfStruct = sizeof(CoverpageInfo);

        if (!FaxRecipientCallback( FaxHandle, i, Context, &JobParams, &CoverpageInfo )) {
            break;
        }

        if (JobParams.RecipientNumber == NULL) {
            continue;
        }

        JobParams.Reserved[0] = 0xfffffffe;
        JobParams.Reserved[1] = 2;
        JobParams.Reserved[2] = BcFaxJobId;

        CoverpageInfo.PageCount = PageCount + 1;
        GetLocalTime( &CoverpageInfo.TimeSent );

        if (CreateCoverpageTiffFile( &CoverpageInfo, TempFile )) {
            if (CopyFileToServerQueue( FaxHandle, TempFile, CovFileName )) {
                ec = FAX_SendDocument( FH_FAX_HANDLE(FaxHandle), CovFileName, &JobParams, &TmpFaxJobId );
                if (ec) {
                    DeleteFile( TempFile );
                    SetLastError( ec );
                    return FALSE;
                }
            }
            DeleteFile( TempFile );
        } else {
            ec = FAX_SendDocument( FH_FAX_HANDLE(FaxHandle), NULL, &JobParams, &TmpFaxJobId );
            if (ec) {
                SetLastError( ec );
                return FALSE;
            }
        }

        i += 1;
    }

    return TRUE;
}


BOOL
ConvertCoverpageAndJobInfo(PFAX_JOB_PARAMW JobParams,PFAX_COVERPAGE_INFOW CoverpageInfo)
{

#define MyConvertString(TargetString) if (TargetString) { \
        TargetString = AnsiStringToUnicodeString((LPCSTR) TargetString); \
        }

  MyConvertString(JobParams->RecipientNumber);
  MyConvertString(JobParams->RecipientName);
  MyConvertString(JobParams->Tsid);
  MyConvertString(JobParams->SenderName);
  MyConvertString(JobParams->SenderDept);
  MyConvertString(JobParams->SenderCompany);
  MyConvertString(JobParams->BillingCode);
  MyConvertString(JobParams->DeliveryReportAddress);
  MyConvertString(JobParams->DocumentName);
  MyConvertString(CoverpageInfo->CoverPageName);
  MyConvertString(CoverpageInfo->RecName);
  MyConvertString(CoverpageInfo->RecFaxNumber);
  MyConvertString(CoverpageInfo->RecCompany);
  MyConvertString(CoverpageInfo->RecStreetAddress);
  MyConvertString(CoverpageInfo->RecCity);
  MyConvertString(CoverpageInfo->RecState);
  MyConvertString(CoverpageInfo->RecZip);
  MyConvertString(CoverpageInfo->RecCountry);
  MyConvertString(CoverpageInfo->RecTitle);
  MyConvertString(CoverpageInfo->RecDepartment);
  MyConvertString(CoverpageInfo->RecOfficeLocation);
  MyConvertString(CoverpageInfo->RecHomePhone);
  MyConvertString(CoverpageInfo->RecOfficePhone);
  MyConvertString(CoverpageInfo->SdrName);
  MyConvertString(CoverpageInfo->SdrFaxNumber);
  MyConvertString(CoverpageInfo->SdrCompany);
  MyConvertString(CoverpageInfo->SdrAddress);
  MyConvertString(CoverpageInfo->SdrTitle);
  MyConvertString(CoverpageInfo->SdrDepartment);
  MyConvertString(CoverpageInfo->SdrOfficeLocation);
  MyConvertString(CoverpageInfo->SdrHomePhone);
  MyConvertString(CoverpageInfo->SdrOfficePhone);
  MyConvertString(CoverpageInfo->Note);
  MyConvertString(CoverpageInfo->Subject);

  return TRUE;
}



BOOL
FreeCoverpageAndJobInfo(PFAX_JOB_PARAMW JobParams,PFAX_COVERPAGE_INFOW CoverpageInfo) {


#define MyFreeString(TargetString) if (TargetString) { \
        MemFree( (LPBYTE) TargetString); \
        }

  MyFreeString(JobParams->RecipientNumber);
  MyFreeString(JobParams->RecipientName);
  MyFreeString(JobParams->Tsid);
  MyFreeString(JobParams->SenderName);
  MyFreeString(JobParams->SenderDept);
  MyFreeString(JobParams->SenderCompany);
  MyFreeString(JobParams->BillingCode);
  MyFreeString(JobParams->DeliveryReportAddress);
  MyFreeString(JobParams->DocumentName);

  MyFreeString(CoverpageInfo->CoverPageName);
  MyFreeString(CoverpageInfo->RecName);
  MyFreeString(CoverpageInfo->RecFaxNumber);
  MyFreeString(CoverpageInfo->RecCompany);
  MyFreeString(CoverpageInfo->RecStreetAddress);
  MyFreeString(CoverpageInfo->RecCity);
  MyFreeString(CoverpageInfo->RecState);
  MyFreeString(CoverpageInfo->RecZip);
  MyFreeString(CoverpageInfo->RecCountry);
  MyFreeString(CoverpageInfo->RecTitle);
  MyFreeString(CoverpageInfo->RecDepartment);
  MyFreeString(CoverpageInfo->RecOfficeLocation);
  MyFreeString(CoverpageInfo->RecHomePhone);
  MyFreeString(CoverpageInfo->RecOfficePhone);
  MyFreeString(CoverpageInfo->SdrName);
  MyFreeString(CoverpageInfo->SdrFaxNumber);
  MyFreeString(CoverpageInfo->SdrCompany);
  MyFreeString(CoverpageInfo->SdrAddress);
  MyFreeString(CoverpageInfo->SdrTitle);
  MyFreeString(CoverpageInfo->SdrDepartment);
  MyFreeString(CoverpageInfo->SdrOfficeLocation);
  MyFreeString(CoverpageInfo->SdrHomePhone);
  MyFreeString(CoverpageInfo->SdrOfficePhone);
  MyFreeString(CoverpageInfo->Note);
  MyFreeString(CoverpageInfo->Subject);

  return TRUE;
}

WINFAXAPI
BOOL
WINAPI
FaxSendDocumentForBroadcastA(
    IN HANDLE FaxHandle,
    IN LPCSTR FileNameA,
    OUT LPDWORD FaxJobId,
    IN PFAX_RECIPIENT_CALLBACKA FaxRecipientCallbackA,
    IN LPVOID Context
    )
{
    error_status_t ec;
    WCHAR TempFile[MAX_PATH];
    WCHAR TiffFile[MAX_PATH];
    WCHAR CovFileName[MAX_PATH];
    WCHAR BodyFileName[MAX_PATH];
    FAX_JOB_PARAMW JobParams;
    FAX_COVERPAGE_INFOW CoverpageInfo;
    DWORD TmpFaxJobId;
    DWORD BcFaxJobId = 0;
    DWORD i = 1;
    HANDLE hTiff = NULL;
    TIFF_INFO TiffInfo;
    DWORD PageCount;
    LPWSTR FileName;

    if (!ValidateFaxHandle(FaxHandle, FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       return FALSE;
    }

    if (!FileNameA || !FaxRecipientCallbackA) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    FileName = AnsiStringToUnicodeString(FileNameA);

    if (!CreateFinalTiffFile( FileName, TiffFile, NULL )) {
        DeleteFile( TiffFile );
        SetLastError(ERROR_INVALID_DATA);
        return FALSE;
    }

    hTiff = TiffOpen( TiffFile, &TiffInfo, TRUE, FILLORDER_MSB2LSB );
    if (hTiff == NULL) {
        DeleteFile( TiffFile );
        return FALSE;
    }

    PageCount = TiffInfo.PageCount;

    TiffClose( hTiff );

    if (!CopyFileToServerQueue( FaxHandle, TiffFile, BodyFileName )) {
        DeleteFile( TiffFile );
        return FALSE;
    }

    //
    // the passed in file should be treated as read-only
    // if we created a temp file then delete it
    //
    if (wcscmp(FileName,TiffFile) != 0) {
        DeleteFile( TiffFile );
    }

    ZeroMemory( &JobParams, sizeof(JobParams) );
    JobParams.SizeOfStruct = sizeof(JobParams);
    JobParams.Reserved[0] = 0xfffffffe;
    JobParams.Reserved[1] = 1;
    JobParams.Reserved[2] = 0;

    ec = FAX_SendDocument( FH_FAX_HANDLE(FaxHandle), BodyFileName, &JobParams, &BcFaxJobId );
    if (ec) {
        SetLastError( ec );
        return FALSE;
    }

    if (FaxJobId) {
        *FaxJobId = BcFaxJobId;
    }

    while (TRUE) {

        ZeroMemory( &JobParams, sizeof(JobParams) );
        JobParams.SizeOfStruct = sizeof(JobParams);

        ZeroMemory( &CoverpageInfo, sizeof(CoverpageInfo) );
        CoverpageInfo.SizeOfStruct = sizeof(CoverpageInfo);

        if (!FaxRecipientCallbackA( FaxHandle, i, Context, (PFAX_JOB_PARAMA)&JobParams,(PFAX_COVERPAGE_INFOA) &CoverpageInfo )) {
            break;
        }

        if (JobParams.RecipientNumber == NULL) {
            continue;
        }

        ConvertCoverpageAndJobInfo(&JobParams,&CoverpageInfo);

        JobParams.Reserved[0] = 0xfffffffe;
        JobParams.Reserved[1] = 2;
        JobParams.Reserved[2] = BcFaxJobId;

        CoverpageInfo.PageCount = PageCount + 1;
        GetLocalTime( &CoverpageInfo.TimeSent );

        if (CreateCoverpageTiffFile( &CoverpageInfo, TempFile )) {
            if (CopyFileToServerQueue( FaxHandle, TempFile, CovFileName )) {
                ec = FAX_SendDocument( FH_FAX_HANDLE(FaxHandle), CovFileName, &JobParams, &TmpFaxJobId );
                if (ec) {
                    DeleteFile( TempFile );
                    SetLastError( ec );
                    return FALSE;
                }
            }
            DeleteFile( TempFile );
        } else {
            ec = FAX_SendDocument( FH_FAX_HANDLE(FaxHandle), NULL, &JobParams, &TmpFaxJobId );
            if (ec) {
                SetLastError( ec );
                return FALSE;
            }
        }

        i += 1;

        FreeCoverpageAndJobInfo(&JobParams,&CoverpageInfo);
    }

    return TRUE;
}


BOOL
WINAPI
FaxSendDocumentA(
    IN HANDLE FaxHandle,
    IN LPCSTR FileName,
    IN FAX_JOB_PARAMA *JobParamsA,
    IN const FAX_COVERPAGE_INFOA *CoverpageInfoA,
    OUT LPDWORD FaxJobId
    )

/*++

Routine Description:

    Sends a FAX document to the specified recipient.
    This is an asychronous operation.  Use FaxReportStatus
    to determine when the send is completed.

Arguments:

    FaxHandle       - FAX handle obtained from FaxConnectFaxServer.
    FileName        - File containing the TIFF-F FAX document.
    JobParams       - pointer to FAX_JOB_PARAM structure with transmission params
    CoverpageInfo   - optional pointer to FAX_COVERPAGE_INFO structure
    FaxJobId        - receives the Fax JobId for the job.


Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    error_status_t ec;
    LPWSTR FileNameW;
    FAX_JOB_PARAMW JobParamsW;
    FAX_COVERPAGE_INFOW CoverpageInfoW;

    if (!FileName || !JobParamsA || JobParamsA->SizeOfStruct != sizeof(FAX_JOB_PARAMA)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (CoverpageInfoA && CoverpageInfoA->SizeOfStruct != sizeof(FAX_COVERPAGE_INFOA)) {
        SetLastError(ERROR_INVALID_DATA);
        return FALSE;
    }

    FileNameW = AnsiStringToUnicodeString( FileName );
    if (FileNameW == NULL) {
        goto exit;
    }

    CopyMemory(&JobParamsW, JobParamsA, sizeof(FAX_JOB_PARAMA));
    JobParamsW.SizeOfStruct = sizeof(FAX_JOB_PARAMW);
    JobParamsW.RecipientNumber = AnsiStringToUnicodeString(JobParamsA->RecipientNumber);
    JobParamsW.RecipientName = AnsiStringToUnicodeString(JobParamsA->RecipientName);
    JobParamsW.Tsid = AnsiStringToUnicodeString(JobParamsA->Tsid);
    JobParamsW.SenderName = AnsiStringToUnicodeString(JobParamsA->SenderName);
    JobParamsW.SenderCompany = AnsiStringToUnicodeString(JobParamsA->SenderCompany);
    JobParamsW.SenderDept = AnsiStringToUnicodeString(JobParamsA->SenderDept);
    JobParamsW.BillingCode = AnsiStringToUnicodeString(JobParamsA->BillingCode);
    JobParamsW.DeliveryReportAddress = AnsiStringToUnicodeString(JobParamsA->DeliveryReportAddress);
    JobParamsW.DocumentName = AnsiStringToUnicodeString(JobParamsA->DocumentName);

    if (CoverpageInfoA) {
        CoverpageInfoW.SizeOfStruct = sizeof(FAX_COVERPAGE_INFOW);
        CoverpageInfoW.UseServerCoverPage = CoverpageInfoA->UseServerCoverPage;
        CoverpageInfoW.PageCount = CoverpageInfoA->PageCount;
        CoverpageInfoW.TimeSent = CoverpageInfoA->TimeSent;
        CoverpageInfoW.CoverPageName = AnsiStringToUnicodeString( CoverpageInfoA->CoverPageName );
        CoverpageInfoW.RecName = AnsiStringToUnicodeString( CoverpageInfoA->RecName );
        CoverpageInfoW.RecFaxNumber = AnsiStringToUnicodeString( CoverpageInfoA->RecFaxNumber );
        CoverpageInfoW.RecCompany = AnsiStringToUnicodeString( CoverpageInfoA->RecCompany );
        CoverpageInfoW.RecStreetAddress = AnsiStringToUnicodeString( CoverpageInfoA->RecStreetAddress );
        CoverpageInfoW.RecCity = AnsiStringToUnicodeString( CoverpageInfoA->RecCity );
        CoverpageInfoW.RecState = AnsiStringToUnicodeString( CoverpageInfoA->RecState );
        CoverpageInfoW.RecZip = AnsiStringToUnicodeString( CoverpageInfoA->RecZip );
        CoverpageInfoW.RecCountry = AnsiStringToUnicodeString( CoverpageInfoA->RecCountry );
        CoverpageInfoW.RecTitle = AnsiStringToUnicodeString( CoverpageInfoA->RecTitle );
        CoverpageInfoW.RecDepartment = AnsiStringToUnicodeString( CoverpageInfoA->RecDepartment );
        CoverpageInfoW.RecOfficeLocation = AnsiStringToUnicodeString( CoverpageInfoA->RecOfficeLocation );
        CoverpageInfoW.RecHomePhone = AnsiStringToUnicodeString( CoverpageInfoA->RecHomePhone );
        CoverpageInfoW.RecOfficePhone = AnsiStringToUnicodeString( CoverpageInfoA->RecOfficePhone );
        CoverpageInfoW.SdrName = AnsiStringToUnicodeString( CoverpageInfoA->SdrName );
        CoverpageInfoW.SdrFaxNumber = AnsiStringToUnicodeString( CoverpageInfoA->SdrFaxNumber );
        CoverpageInfoW.SdrCompany = AnsiStringToUnicodeString( CoverpageInfoA->SdrCompany );
        CoverpageInfoW.SdrAddress = AnsiStringToUnicodeString( CoverpageInfoA->SdrAddress );
        CoverpageInfoW.SdrTitle = AnsiStringToUnicodeString( CoverpageInfoA->SdrTitle );
        CoverpageInfoW.SdrDepartment = AnsiStringToUnicodeString( CoverpageInfoA->SdrDepartment );
        CoverpageInfoW.SdrOfficeLocation = AnsiStringToUnicodeString( CoverpageInfoA->SdrOfficeLocation );
        CoverpageInfoW.SdrHomePhone = AnsiStringToUnicodeString( CoverpageInfoA->SdrHomePhone );
        CoverpageInfoW.SdrOfficePhone = AnsiStringToUnicodeString( CoverpageInfoA->SdrOfficePhone );
        CoverpageInfoW.Note = AnsiStringToUnicodeString( CoverpageInfoA->Note );
        CoverpageInfoW.Subject = AnsiStringToUnicodeString( CoverpageInfoA->Subject );
    }


    if (FaxSendDocumentW( FaxHandle,
                          FileNameW,
                          &JobParamsW,
                          CoverpageInfoA ? &CoverpageInfoW : NULL,
                          FaxJobId )) {
        ec = 0;
    } else {
        ec = GetLastError();
    }

exit:
    MemFree( (LPBYTE) FileNameW );
    MemFree( (LPBYTE) JobParamsW.RecipientNumber );
    MemFree( (LPBYTE) JobParamsW.RecipientName );
    MemFree( (LPBYTE) JobParamsW.Tsid );
    MemFree( (LPBYTE) JobParamsW.SenderName );
    MemFree( (LPBYTE) JobParamsW.SenderDept );
    MemFree( (LPBYTE) JobParamsW.SenderCompany );
    MemFree( (LPBYTE) JobParamsW.BillingCode );
    MemFree( (LPBYTE) JobParamsW.DeliveryReportAddress );
    MemFree( (LPBYTE) JobParamsW.DocumentName );
    if (CoverpageInfoA) {
        MemFree( (LPBYTE) CoverpageInfoW.CoverPageName );
        MemFree( (LPBYTE) CoverpageInfoW.RecName );
        MemFree( (LPBYTE) CoverpageInfoW.RecFaxNumber );
        MemFree( (LPBYTE) CoverpageInfoW.RecCompany );
        MemFree( (LPBYTE) CoverpageInfoW.RecStreetAddress );
        MemFree( (LPBYTE) CoverpageInfoW.RecCity );
        MemFree( (LPBYTE) CoverpageInfoW.RecState );
        MemFree( (LPBYTE) CoverpageInfoW.RecZip );
        MemFree( (LPBYTE) CoverpageInfoW.RecCountry );
        MemFree( (LPBYTE) CoverpageInfoW.RecTitle );
        MemFree( (LPBYTE) CoverpageInfoW.RecDepartment );
        MemFree( (LPBYTE) CoverpageInfoW.RecOfficeLocation );
        MemFree( (LPBYTE) CoverpageInfoW.RecHomePhone );
        MemFree( (LPBYTE) CoverpageInfoW.RecOfficePhone );
        MemFree( (LPBYTE) CoverpageInfoW.SdrName );
        MemFree( (LPBYTE) CoverpageInfoW.SdrFaxNumber );
        MemFree( (LPBYTE) CoverpageInfoW.SdrCompany );
        MemFree( (LPBYTE) CoverpageInfoW.SdrAddress );
        MemFree( (LPBYTE) CoverpageInfoW.SdrTitle );
        MemFree( (LPBYTE) CoverpageInfoW.SdrDepartment );
        MemFree( (LPBYTE) CoverpageInfoW.SdrOfficeLocation );
        MemFree( (LPBYTE) CoverpageInfoW.SdrHomePhone );
        MemFree( (LPBYTE) CoverpageInfoW.SdrOfficePhone );
        MemFree( (LPBYTE) CoverpageInfoW.Note );
        MemFree( (LPBYTE) CoverpageInfoW.Subject );
    }

    if (ec) {
        SetLastError( ec );
        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
FaxAbort(
    IN HANDLE FaxHandle,
    IN DWORD JobId
    )
/*++

Routine Description:

    Abort the specified FAX job.  All outstanding FAX
    operations are terminated.

Arguments:

    FaxHandle       - FAX Server handle obtained from FaxConnectFaxServer.
    JobId           - job id.

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    error_status_t ec;

    //
    // argument validation
    //
    if (!ValidateFaxHandle(FaxHandle, FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       return FALSE;
    }

    ec = FAX_Abort( (handle_t) FH_FAX_HANDLE(FaxHandle),(DWORD) JobId );
    if (ec) {
        SetLastError( ec );
        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
FaxEnumJobsW(
   IN  HANDLE FaxHandle,
   OUT PFAX_JOB_ENTRYW *JobEntryBuffer,
   OUT LPDWORD JobsReturned
   )
{
    PFAX_JOB_ENTRYW JobEntry;
    error_status_t ec;
    DWORD BufferSize = 0;
    DWORD i;
    DWORD Size;

    if (!ValidateFaxHandle(FaxHandle, FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       return FALSE;
    }

    if (!JobEntryBuffer || !JobsReturned) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *JobEntryBuffer = NULL;
    *JobsReturned = 0;
    Size = 0;

    ec = FAX_EnumJobs( FH_FAX_HANDLE(FaxHandle), (LPBYTE*)JobEntryBuffer, &Size, JobsReturned );
    if (ec) {
        SetLastError( ec );
        return FALSE;
    }

    JobEntry = (PFAX_JOB_ENTRYW) *JobEntryBuffer;

    for (i=0; i<*JobsReturned; i++) {
        FixupStringPtr( JobEntryBuffer, JobEntry[i].UserName );
        FixupStringPtr( JobEntryBuffer, JobEntry[i].RecipientNumber );
        FixupStringPtr( JobEntryBuffer, JobEntry[i].RecipientName );
        FixupStringPtr( JobEntryBuffer, JobEntry[i].DocumentName );
        FixupStringPtr( JobEntryBuffer, JobEntry[i].Tsid );
        FixupStringPtr( JobEntryBuffer, JobEntry[i].SenderName );
        FixupStringPtr( JobEntryBuffer, JobEntry[i].SenderCompany );
        FixupStringPtr( JobEntryBuffer, JobEntry[i].SenderDept );
        FixupStringPtr( JobEntryBuffer, JobEntry[i].BillingCode );
        FixupStringPtr( JobEntryBuffer, JobEntry[i].DeliveryReportAddress );
    }

    return TRUE;
}


BOOL
WINAPI
FaxEnumJobsA(
   IN HANDLE FaxHandle,
   OUT PFAX_JOB_ENTRYA *JobEntryBuffer,
   OUT LPDWORD JobsReturned
   )
{
    PFAX_JOB_ENTRYW JobEntry;
    DWORD i;


    if (!FaxEnumJobsW( FaxHandle, (PFAX_JOB_ENTRYW *)JobEntryBuffer, JobsReturned)) {
        return FALSE;
    }

    JobEntry = (PFAX_JOB_ENTRYW) *JobEntryBuffer;

    for (i=0; i<*JobsReturned; i++) {
        ConvertUnicodeStringInPlace( (LPCWSTR) JobEntry[i].UserName );
        ConvertUnicodeStringInPlace( (LPCWSTR) JobEntry[i].RecipientNumber );
        ConvertUnicodeStringInPlace( (LPCWSTR) JobEntry[i].RecipientName );
        ConvertUnicodeStringInPlace( (LPCWSTR) JobEntry[i].DocumentName );
        ConvertUnicodeStringInPlace( (LPCWSTR) JobEntry[i].Tsid );
        ConvertUnicodeStringInPlace( (LPCWSTR) JobEntry[i].SenderName );
        ConvertUnicodeStringInPlace( (LPCWSTR) JobEntry[i].SenderCompany );
        ConvertUnicodeStringInPlace( (LPCWSTR) JobEntry[i].SenderDept );
        ConvertUnicodeStringInPlace( (LPCWSTR) JobEntry[i].BillingCode );
        ConvertUnicodeStringInPlace( (LPCWSTR) JobEntry[i].DeliveryReportAddress );
    }

    return TRUE;
}


BOOL
WINAPI
FaxSetJobW(
   IN HANDLE FaxHandle,
   IN DWORD JobId,
   IN DWORD Command,
   IN const FAX_JOB_ENTRYW *JobEntry
   )

/*++

Routine Description:

    set job status information for a requested JobId
    Note that this is the fax server JobId, not a spooler job ID.

Arguments:

    FaxHandle           - FAX handle obtained from FaxConnectFaxServer
    JobId               - Fax service Job ID
    Command        - JC_* constant for controlling the job
    JobEntry            - pointer to Buffer holding the job information

Return Value:

    ERROR_SUCCESS for success, otherwise a WIN32 error code.

--*/
{
    error_status_t ec;

    //
    // argument validation
    //
    //if (!FaxHandle || !JobEntry  || Command > JC_RESTART  || Command == JC_UNKNOWN || JobId != JobEntry->JobId) {

    if (!ValidateFaxHandle(FaxHandle, FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       return FALSE;
    }

    if (!JobEntry  || Command > JC_RESTART  || Command == JC_UNKNOWN) {
       SetLastError (ERROR_INVALID_PARAMETER);
       return FALSE;
    }


    ec = FAX_SetJob( FH_FAX_HANDLE(FaxHandle), JobId, Command, JobEntry );
    if (ec) {
        SetLastError( ec );
        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
FaxSetJobA(
   IN HANDLE FaxHandle,
   IN DWORD JobId,
   IN DWORD Command,
   IN const FAX_JOB_ENTRYA *JobEntryA
   )
/*++

Routine Description:

    set job status information for a requested JobId
    Note that this is the fax server JobId, not a spooler job ID.

Arguments:

    FaxHandle           - FAX handle obtained from FaxConnectFaxServer
    JobId               - Fax service Job ID
    Command        - JC_* constant for controlling the job
    JobEntryA           - pointer to Buffer holding the job information

Return Value:

    ERROR_SUCCESS for success, otherwise a WIN32 error code.

--*/
{
    FAX_JOB_ENTRYW JobEntryW;
    error_status_t ec = 0;

    if (!JobEntryA) {
       SetLastError(ERROR_INVALID_PARAMETER);
       return FALSE;
    }

    JobEntryW.SizeOfStruct = sizeof(FAX_JOB_ENTRYW);
    JobEntryW.JobId = JobEntryA->JobId;
    JobEntryW.UserName = AnsiStringToUnicodeString(JobEntryA->UserName);
    JobEntryW.JobType = JobEntryA->JobType;
    JobEntryW.QueueStatus = JobEntryA->QueueStatus;
    JobEntryW.Status = JobEntryA->Status;
    JobEntryW.PageCount = JobEntryA->PageCount;
    JobEntryW.RecipientNumber = AnsiStringToUnicodeString(JobEntryA->RecipientNumber);
    JobEntryW.RecipientName = AnsiStringToUnicodeString(JobEntryA->RecipientName);
    JobEntryW.Tsid = AnsiStringToUnicodeString(JobEntryA->Tsid);
    JobEntryW.SenderName = AnsiStringToUnicodeString(JobEntryA->SenderName);
    JobEntryW.SenderCompany = AnsiStringToUnicodeString(JobEntryA->SenderCompany);
    JobEntryW.SenderDept = AnsiStringToUnicodeString(JobEntryA->SenderDept);
    JobEntryW.BillingCode = AnsiStringToUnicodeString(JobEntryA->BillingCode);
    JobEntryW.ScheduleAction = JobEntryA->ScheduleAction;
    JobEntryW.ScheduleTime = JobEntryA->ScheduleTime;
    JobEntryW.DeliveryReportType = JobEntryA->DeliveryReportType;
    JobEntryW.DeliveryReportAddress = AnsiStringToUnicodeString(JobEntryA->DeliveryReportAddress);
    JobEntryW.DocumentName = AnsiStringToUnicodeString(JobEntryA->DocumentName);

    if (!FaxSetJobW( FaxHandle, JobId, Command, &JobEntryW) ) {
       ec = GetLastError();
    }

    MemFree( (LPBYTE) JobEntryW.UserName);
    MemFree( (LPBYTE) JobEntryW.RecipientNumber );
    MemFree( (LPBYTE) JobEntryW.RecipientName );
    MemFree( (LPBYTE) JobEntryW.Tsid );
    MemFree( (LPBYTE) JobEntryW.SenderName );
    MemFree( (LPBYTE) JobEntryW.SenderDept );
    MemFree( (LPBYTE) JobEntryW.SenderCompany );
    MemFree( (LPBYTE) JobEntryW.BillingCode );
    MemFree( (LPBYTE) JobEntryW.DeliveryReportAddress );
    MemFree( (LPBYTE) JobEntryW.DocumentName );

    if (ec != 0) {
       SetLastError(ec);
       return FALSE;
    }

    return TRUE;
}

BOOL
WINAPI
FaxGetJobW(
   IN HANDLE FaxHandle,
   IN DWORD JobId,
   IN PFAX_JOB_ENTRYW *JobEntryBuffer
   )
/*++

Routine Description:

    Returns job status information for a requested JobId
    Note that this is the fax server JobId, not a spooler job ID.

Arguments:

    FaxHandle           - FAX handle obtained from FaxConnectFaxServer
    JobId               - Fax service Job ID
    JobEntryBuffer      - Buffer to hold the job information

Return Value:

    ERROR_SUCCESS for success, otherwise a WIN32 error code.

--*/
{
    error_status_t ec = 0;
    PFAX_JOB_ENTRY JobEntry;
    DWORD JobEntrySize = 0;

    //
    // parameter validation
    //
    if (!ValidateFaxHandle(FaxHandle, FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       return FALSE;
    }

    if (!JobEntryBuffer) {
       SetLastError(ERROR_INVALID_PARAMETER);
       return FALSE;
    }

    *JobEntryBuffer = NULL;

    ec = FAX_GetJob( FH_FAX_HANDLE(FaxHandle), JobId, (char **) JobEntryBuffer , &JobEntrySize );
    if (ec) {
        SetLastError( ec );
        return FALSE;
    }

    JobEntry = (PFAX_JOB_ENTRY) *JobEntryBuffer;

    FixupStringPtr (JobEntryBuffer, (LPCWSTR) JobEntry->UserName);
    FixupStringPtr (JobEntryBuffer, (LPCWSTR) JobEntry->RecipientNumber );
    FixupStringPtr (JobEntryBuffer, (LPCWSTR) JobEntry->RecipientName );
    FixupStringPtr (JobEntryBuffer, (LPCWSTR) JobEntry->Tsid );
    FixupStringPtr (JobEntryBuffer, (LPCWSTR) JobEntry->SenderName );
    FixupStringPtr (JobEntryBuffer, (LPCWSTR) JobEntry->SenderDept );
    FixupStringPtr (JobEntryBuffer, (LPCWSTR) JobEntry->SenderCompany );
    FixupStringPtr (JobEntryBuffer, (LPCWSTR) JobEntry->BillingCode );
    FixupStringPtr (JobEntryBuffer, (LPCWSTR) JobEntry->DeliveryReportAddress );
    FixupStringPtr (JobEntryBuffer, (LPCWSTR) JobEntry->DocumentName );

    return TRUE;
}


BOOL
WINAPI
FaxGetJobA(
   IN HANDLE FaxHandle,
   IN DWORD JobId,
   IN PFAX_JOB_ENTRYA *JobEntryBuffer
   )
/*++

Routine Description:

    Returns job status information for a requested JobId
    Note that this is the fax server JobId, not a spooler job ID.

Arguments:

    FaxHandle           - FAX handle obtained from FaxConnectFaxServer
    JobId               - Fax service Job ID
    JobEntryBuffer      - Buffer to hold the job information

Return Value:

    ERROR_SUCCESS for success, otherwise a WIN32 error code.

--*/
{
    PFAX_JOB_ENTRYW JobEntryW;
    DWORD JobEntrySize = 0;
    error_status_t ec = 0;

    if (!ValidateFaxHandle(FaxHandle, FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       return FALSE;
    }

    if (!JobEntryBuffer) {
       SetLastError(ERROR_INVALID_PARAMETER);
       return FALSE;
    }

    *JobEntryBuffer = NULL;

    ec = FAX_GetJob( FH_FAX_HANDLE(FaxHandle), JobId, (char **) JobEntryBuffer,&JobEntrySize );

    if (ec) {
       JobEntryBuffer = NULL;
       SetLastError(ec);
       return FALSE;
    }

    //
    // convert to Ansi
    //
    JobEntryW = (PFAX_JOB_ENTRYW) *JobEntryBuffer;
    FixupStringPtr (JobEntryBuffer, (LPCWSTR) JobEntryW->UserName);
    FixupStringPtr (JobEntryBuffer, (LPCWSTR) JobEntryW->RecipientNumber );
    FixupStringPtr (JobEntryBuffer, (LPCWSTR) JobEntryW->RecipientName );
    FixupStringPtr (JobEntryBuffer, (LPCWSTR) JobEntryW->Tsid );
    FixupStringPtr (JobEntryBuffer, (LPCWSTR) JobEntryW->SenderName );
    FixupStringPtr (JobEntryBuffer, (LPCWSTR) JobEntryW->SenderDept );
    FixupStringPtr (JobEntryBuffer, (LPCWSTR) JobEntryW->SenderCompany );
    FixupStringPtr (JobEntryBuffer, (LPCWSTR) JobEntryW->BillingCode );
    FixupStringPtr (JobEntryBuffer, (LPCWSTR) JobEntryW->DeliveryReportAddress );
    FixupStringPtr (JobEntryBuffer, (LPCWSTR) JobEntryW->DocumentName );
    ConvertUnicodeStringInPlace( (LPCWSTR)JobEntryW->UserName);
    ConvertUnicodeStringInPlace( (LPCWSTR)JobEntryW->RecipientNumber );
    ConvertUnicodeStringInPlace( (LPCWSTR)JobEntryW->RecipientName );
    ConvertUnicodeStringInPlace( (LPCWSTR)JobEntryW->Tsid );
    ConvertUnicodeStringInPlace( (LPCWSTR)JobEntryW->SenderName );
    ConvertUnicodeStringInPlace( (LPCWSTR)JobEntryW->SenderDept );
    ConvertUnicodeStringInPlace( (LPCWSTR)JobEntryW->SenderCompany );
    ConvertUnicodeStringInPlace( (LPCWSTR)JobEntryW->BillingCode );
    ConvertUnicodeStringInPlace( (LPCWSTR)JobEntryW->DeliveryReportAddress );
    ConvertUnicodeStringInPlace( (LPCWSTR)JobEntryW->DocumentName );

    return TRUE;
}


BOOL
WINAPI
FaxGetPageData(
   IN HANDLE FaxHandle,
   IN DWORD JobId,
   OUT LPBYTE *Buffer,
   OUT LPDWORD BufferSize,
   OUT LPDWORD ImageWidth,
   OUT LPDWORD ImageHeight
   )
{
    error_status_t ec;

    if (!ValidateFaxHandle(FaxHandle, FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       return FALSE;
    }

    if (!Buffer || !BufferSize || !ImageWidth || !ImageHeight) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *Buffer = NULL;
    *BufferSize = 0;
    *ImageWidth = 0;
    *ImageHeight = 0;


    ec = FAX_GetPageData( FH_FAX_HANDLE(FaxHandle), JobId, Buffer, BufferSize, ImageWidth, ImageHeight );
    if (ec) {
        SetLastError( ec );
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\client\print.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    print.c

Abstract:

    This module contains the print specific WINFAX API functions.

Author:

    Wesley Witt (wesw) 29-Nov-1996


Revision History:

--*/

#include "faxapi.h"
#pragma hdrstop


LPWSTR Platforms[] =
{
    L"Windows NT x86",
    L"Windows NT R4000",
    L"Windows NT Alpha_AXP",
    L"Windows NT PowerPC"
};



LPWSTR
AddFaxTag(
    LPWSTR TagStr,
    LPCWSTR FaxTag,
    LPCWSTR Value
    )
{
    if (!Value) {
        return TagStr;
    }
    wcscat( TagStr, FaxTag );
    wcscat( TagStr, Value );
    return TagStr;
}


BOOL
IsPrinterFaxPrinter(
    LPWSTR PrinterName
    )
{
    HANDLE hPrinter = NULL;
    PRINTER_DEFAULTS PrinterDefaults;
    SYSTEM_INFO SystemInfo;
    DWORD Size;
    DWORD Rval = FALSE;
    LPDRIVER_INFO_2 DriverInfo = NULL;


    PrinterDefaults.pDatatype     = NULL;
    PrinterDefaults.pDevMode      = NULL;
    PrinterDefaults.DesiredAccess = PRINTER_READ;

    if (!OpenPrinter( PrinterName, &hPrinter, &PrinterDefaults )) {

        DebugPrint(( L"OpenPrinter() failed, ec=%d", GetLastError() ));
        return FALSE;

    }

    GetSystemInfo( &SystemInfo );

    Size = 4096;

    DriverInfo = (LPDRIVER_INFO_2) MemAlloc( Size );
    if (!DriverInfo) {
        DebugPrint(( L"Memory allocation failed, size=%d", Size ));
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    Rval = GetPrinterDriver(
        hPrinter,
        Platforms[SystemInfo.wProcessorArchitecture],
        2,
        (LPBYTE) DriverInfo,
        Size,
        &Size
        );
    if (!Rval) {
        DebugPrint(( L"GetPrinterDriver() failed, ec=%d", GetLastError() ));
        goto exit;
    }

    if (_tcscmp( DriverInfo->pName, FAX_DRIVER_NAME ) == 0) {
        Rval = TRUE;
    } else {
        Rval = FALSE;
    }

exit:

    MemFree( DriverInfo );
    ClosePrinter( hPrinter );
    return Rval;
}


PVOID
MyGetJob(
    HANDLE  hPrinter,
    DWORD   level,
    DWORD   jobId
    )

/*++

Routine Description:

    Wrapper function for spooler API GetJob

Arguments:

    hPrinter - Handle to the printer object
    level - Level of JOB_INFO structure interested
    jobId - Specifies the job ID

Return Value:

    Pointer to a JOB_INFO structure, NULL if there is an error

--*/

{
    PBYTE   pJobInfo = NULL;
    DWORD   cbNeeded;

    if (!GetJob(hPrinter, jobId, level, NULL, 0, &cbNeeded) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pJobInfo = MemAlloc(cbNeeded)) &&
        GetJob(hPrinter, jobId, level, pJobInfo, cbNeeded, &cbNeeded))
    {
        return pJobInfo;
    }

    MemFree(pJobInfo);
    return NULL;
}


LPWSTR
GetCpField(
    HKEY hKey,
    LPWSTR SubKey
    )

/*++

Routine Description:

    Retrieves the data for a coverpage field from
    the registry.

Arguments:

    hKey    - Registry handle
    SubKey  - Subkey name

Return Value:

    Pointer to the coverpage field data.

--*/

{
    LONG rVal;
    DWORD RegSize;
    DWORD RegType;
    LPBYTE Buffer;


    rVal = RegQueryValueEx( hKey, SubKey, 0, &RegType, NULL, &RegSize );
    if (rVal != ERROR_SUCCESS) {
        return NULL;
    }

    Buffer = (LPBYTE) MemAlloc( RegSize );
    if (!Buffer) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    rVal = RegQueryValueEx( hKey, SubKey, 0, &RegType, Buffer, &RegSize );
    if (rVal != ERROR_SUCCESS) {
        MemFree( Buffer );
        return NULL;
    }

    return (LPWSTR) Buffer;
}

BOOL
GetCpFields(
    PCOVERPAGEFIELDS CpFields
    )

/*++

Routine Description:

    Initializes the coverpage field structure and
    fills in the sender information from the registry.

Arguments:

    CpFields    - Pointer to a coverpage field structure.

Return Value:

    TRUE for success.
    FALSE for failure.

--*/

{
    HKEY hKey;
    LONG rVal;


    rVal = RegOpenKey(
        HKEY_CURRENT_USER,
        REGKEY_FAX_USERINFO,
        &hKey
        );
    if (rVal != ERROR_SUCCESS) {
        return FALSE;
    }

    ZeroMemory( CpFields, sizeof(COVERPAGEFIELDS) );
    CpFields->ThisStructSize = sizeof(COVERPAGEFIELDS);

    //
    // sender fields
    //

    CpFields->SdrName           = GetCpField( hKey, REGVAL_FULLNAME     );
    CpFields->SdrFaxNumber      = GetCpField( hKey, REGVAL_FAX_NUMBER   );
    CpFields->SdrCompany        = GetCpField( hKey, REGVAL_COMPANY      );
    CpFields->SdrAddress        = GetCpField( hKey, REGVAL_ADDRESS      );
    CpFields->SdrTitle          = GetCpField( hKey, REGVAL_TITLE        );
    CpFields->SdrDepartment     = GetCpField( hKey, REGVAL_DEPT         );
    CpFields->SdrOfficeLocation = GetCpField( hKey, REGVAL_OFFICE       );
    CpFields->SdrHomePhone      = GetCpField( hKey, REGVAL_HOME_PHONE   );
    CpFields->SdrOfficePhone    = GetCpField( hKey, REGVAL_OFFICE_PHONE );

    RegCloseKey( hKey );

    return TRUE;
}


VOID
FreeCpFields(
    PCOVERPAGEFIELDS CpFields
    )

/*++

Routine Description:

    Frees all memory associated with a coverpage field structure.


Arguments:

    CpFields    - Pointer to a coverpage field structure.

Return Value:

    None.

--*/

{
    DWORD i;
    LPBYTE *p;

    for (i = 0; i < NUM_INSERTION_TAGS; i++) {
        p = (LPBYTE *) ((ULONG_PTR)CpFields + sizeof(LPTSTR)*(i+1));
        if (p && *p) MemFree( *p );
    }   
}


BOOL
WINAPI
FaxPrintCoverPageW(
    IN const FAX_CONTEXT_INFO    *FaxContextInfo,
    IN const FAX_COVERPAGE_INFOW *CoverPageInfo
    )

/*++

Routine Description:

    Prints a coverpage into the printer DC provided.

Arguments:

    FaxContextInfo  - contains servername, Printer DC    
    CoverPageInfo   - Cover page information

Return Value:

    TRUE for success.
    FALSE for failure.

--*/

{
    WCHAR CpName[MAX_PATH];
    WCHAR Buffer[MAX_PATH];
    LPWSTR p;
    COVERPAGEFIELDS CpFields = {0};
    COVDOCINFO CovDocInfo;
    DWORD DateTimeLen;
    DWORD cch;
    LPWSTR s;
    DWORD ec = 0;
    LPCWSTR *src;
    LPCWSTR *dst;
    DWORD i;



    //
    // do a little argument validation
    //

    if (CoverPageInfo == NULL || CoverPageInfo->SizeOfStruct != sizeof(FAX_COVERPAGE_INFOW) ||
        FaxContextInfo == NULL || FaxContextInfo->hDC == NULL || 
        FaxContextInfo->SizeOfStruct != sizeof (FAX_CONTEXT_INFOW) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if (!ValidateCoverpage(CoverPageInfo->CoverPageName,
                           FaxContextInfo->ServerName,
                           CoverPageInfo->UseServerCoverPage,
                           CpName)) {
        return FALSE;
    }

    //
    // get the coverpage fields
    //

    GetCpFields( &CpFields );

    //
    // fixup the recipient name
    //

    if (CoverPageInfo->RecName) {
        if (CoverPageInfo->RecName[0] == '\'') {
            wcscpy( Buffer, &CoverPageInfo->RecName[1] );
            Buffer[wcslen(Buffer)-1] = 0;
        } else {
            wcscpy( Buffer, CoverPageInfo->RecName );
        }
    } else {
        Buffer[0] = 0;
    }

    //
    // fill in the coverpage fields with the
    // data that the caller passed in
    //

    CpFields.RecName      = StringDup( Buffer );
    CpFields.RecFaxNumber = StringDup( CoverPageInfo->RecFaxNumber );
    if (CpFields.RecFaxNumber) {
        p = wcsrchr( (LPWSTR) CpFields.RecFaxNumber, L'@' );
        if (p) {
            wcscpy( (LPWSTR) CpFields.RecFaxNumber, p+1 );
        }
    }
    CpFields.Subject = StringDup( CoverPageInfo->Subject );
    CpFields.Note = StringDup( CoverPageInfo->Note ? CoverPageInfo->Note : L"" );
    CpFields.NumberOfPages = StringDup( _itow( CoverPageInfo->PageCount, Buffer, 10 ) );

    for (i = 0; 
         i <= ((LPBYTE)&CoverPageInfo->SdrOfficePhone-(LPBYTE)&CoverPageInfo->RecCompany)/sizeof(LPCWSTR);
         i++) {
        src = (LPCWSTR *) ((LPBYTE)&CoverPageInfo->RecCompany + (i*sizeof(LPCWSTR)));
        dst = (LPCWSTR *) ((LPBYTE)&CpFields.RecCompany + (i*sizeof(LPCWSTR)));

        if (*dst) { 
            MemFree ( (LPBYTE) *dst ) ;
        }

        *dst = (LPCWSTR) StringDup( *src ); 

    }
    
    //
    // the time the fax was sent
    //

    GetLocalTime((LPSYSTEMTIME)&CoverPageInfo->TimeSent);

    DateTimeLen = sizeof(Buffer);
    s = Buffer;

    GetDateFormat( LOCALE_USER_DEFAULT, 0, &CoverPageInfo->TimeSent, NULL, s, DateTimeLen );

    cch = wcslen( s );
    s += cch;

    if (++cch < DateTimeLen) {

        *s++ = ' ';
        DateTimeLen -= cch;

        GetTimeFormat( LOCALE_USER_DEFAULT, 0, &CoverPageInfo->TimeSent, NULL, s, DateTimeLen );
    }

    CpFields.TimeSent = StringDup( Buffer );

    //
    // start the coverpage on a new page
    //

    StartPage( FaxContextInfo->hDC );

    //
    // print the cover page
    //

    ec = PrintCoverPage(
        FaxContextInfo->hDC,
        &CpFields,
        CpName,
        &CovDocInfo
        );

    //
    // end the page
    //

    EndPage( FaxContextInfo->hDC );

    FreeCpFields( &CpFields );

    if (ec != 0) {
        SetLastError( ec );
        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
FaxPrintCoverPageA(
    IN const FAX_CONTEXT_INFOA   *FaxContextInfo,
    IN const FAX_COVERPAGE_INFOA *CoverPageInfo
    )

/*++

Routine Description:

    Prints a coverpage into the printer DC provided.

Arguments:

    FaxContextInfo  - fax Printer context info (hdc, etc.)
    CoverPageInfo   - Cover page information

Return Value:

    TRUE for success.
    FALSE for failure.

--*/

{
    //
    // assume all fields between Subject and RecName are LPCTSTR's
    //
    #define COUNT_CP_FIELDS ((LPBYTE) &CoverPageInfoW.Subject - (LPBYTE)&CoverPageInfoW.RecName)/sizeof(LPCTSTR)
    BOOL Rval;
    FAX_COVERPAGE_INFOW CoverPageInfoW = {0};
    FAX_CONTEXT_INFOW ContextInfoW = {0};
    LPWSTR ServerName = NULL;
    LPWSTR *d;
    LPSTR *s;
    DWORD i;

    if (!FaxContextInfo || !CoverPageInfo ||
        FaxContextInfo->SizeOfStruct != sizeof(FAX_CONTEXT_INFOA) ||
        CoverPageInfo->SizeOfStruct != sizeof(FAX_COVERPAGE_INFOA)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    ContextInfoW.SizeOfStruct         = sizeof(FAX_CONTEXT_INFOW);
    ContextInfoW.hDC                  = FaxContextInfo->hDC;
    if (FaxContextInfo->ServerName[0] != (CHAR)'\0') {
        ServerName                        = AnsiStringToUnicodeString( FaxContextInfo->ServerName );
        wcscpy(ContextInfoW.ServerName,ServerName);
    }

    CoverPageInfoW.SizeOfStruct       = sizeof(FAX_COVERPAGE_INFOW);
    CoverPageInfoW.UseServerCoverPage = CoverPageInfo->UseServerCoverPage;
    CoverPageInfoW.PageCount          = CoverPageInfo->PageCount;
    CoverPageInfoW.CoverPageName      = AnsiStringToUnicodeString( CoverPageInfo->CoverPageName );
    
    for (i=0;i<=COUNT_CP_FIELDS;i++) {
        d = (LPWSTR*) ((ULONG_PTR)&CoverPageInfoW.RecName + i*sizeof(LPCWSTR));
        s = (LPSTR *) ((LPBYTE)&CoverPageInfo->RecName + i*sizeof(LPSTR));        
        DebugPrint(( TEXT(" source: 0x%08x  --> dest: 0x%08x \n"), s, d));
        *d = AnsiStringToUnicodeString( *s );
    }

    CoverPageInfoW.TimeSent       = CoverPageInfo->TimeSent;
    CoverPageInfoW.PageCount      = CoverPageInfo->PageCount;

    Rval = FaxPrintCoverPageW(
        &ContextInfoW,
        &CoverPageInfoW
        );

    if (CoverPageInfoW.CoverPageName) {
        MemFree( (LPBYTE) CoverPageInfoW.CoverPageName );
    }

    if (ServerName) {
        MemFree( (LPBYTE) ServerName );
    }

    for (i = 0; i < COUNT_CP_FIELDS; i++) {
        d = (LPWSTR *)((ULONG_PTR)&CoverPageInfoW.RecName + i*sizeof(LPWSTR));        
        if (d && *d)MemFree( (LPBYTE)*d );
    }    
        
    return Rval;
}


BOOL
WINAPI
FaxStartPrintJobW(
    IN  LPCWSTR                   PrinterName,
    IN  const FAX_PRINT_INFOW     *PrintInfo,
    OUT LPDWORD                   FaxJobId,
    OUT PFAX_CONTEXT_INFO         FaxContextInfo
    )

/*++

Routine Description:

    Starts a print job for the specified printer.  This
    function provides functionality beyond what the caller
    can provide by using StartDoc().  This function disables
    the display of the fax send wizard and also passes along
    the information that would otherwise be gathered by the
    fax wizard ui.

Arguments:

    PrinterName         - Fax printer name (must be a fax printer)
    PrintInfo           - Fax print information
    FaxJobId            - Job id of the resulting print job
    FaxContextInfo      - context information including hdc

Return Value:

    TRUE for success.
    FALSE for failure.

--*/

{
    HANDLE hPrinter = NULL;
    PDEVMODE DevMode = NULL;
    PDMPRIVATE DevModePrivate = NULL;
    DOCINFO DocInfo;
    PJOB_INFO_2 JobInfo = NULL;
    PPRINTER_INFO_2 PrinterInfo = NULL;
    DWORD dwNeeded = 0;
    HDC hDC = NULL;
    INT JobId = 0;
    LPWSTR FaxTags = NULL;
    LONG Size;
    LPWSTR FaxPrinterName;

    //
    // do a little argument validation
    //

    if (PrintInfo == NULL || PrintInfo->SizeOfStruct != sizeof(FAX_PRINT_INFOW) ||
        !FaxJobId || !FaxContextInfo)
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if (PrintInfo->OutputFileName == NULL &&
        (PrintInfo->RecipientNumber == NULL || PrintInfo->RecipientNumber[0] == 0))
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if (PrintInfo->DrProfileName && PrintInfo->DrEmailAddress) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    //  if no printer specified, assume they want a local fax printer
    //
    if (!PrinterName) {
        FaxPrinterName = GetFaxPrinterName();
        if (!FaxPrinterName) {
            SetLastError(ERROR_INVALID_PRINTER_NAME);
            return FALSE;
        }
    } else {
        FaxPrinterName = (LPWSTR) PrinterName;
    }
    //
    // verify that the printer is a fax printer, the only type allowed
    //

    if (!IsPrinterFaxPrinter( FaxPrinterName )) {
        SetLastError( ERROR_INVALID_PRINTER_NAME );
        return FALSE;
    }


    //
    // open the printer for normal access (this should always work)
    //

    if (!OpenPrinter( FaxPrinterName, &hPrinter, NULL )) {
        goto error_exit;
    }

    //
    // get the fax server's name if the fax printer isn't local
    //
    if (!GetPrinter(hPrinter,2,(LPBYTE)PrinterInfo,0,&dwNeeded)) {
        PrinterInfo = MemAlloc( dwNeeded );
        if (!PrinterInfo) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto error_exit;
        }
    }

    if (!GetPrinter(hPrinter,2,(LPBYTE)PrinterInfo,dwNeeded,&dwNeeded)) {
        goto error_exit;
    }

    if (PrinterInfo->pServerName)
        wcscpy(FaxContextInfo->ServerName,PrinterInfo->pServerName);
    else
        FaxContextInfo->ServerName[0] = 0;


    //
    // get the required size for the DEVMODE
    //

    Size = DocumentProperties( NULL, hPrinter, NULL, NULL, NULL, 0 );
    if (Size <= 0) {
        goto error_exit;
    }

    //
    // allocate memory for the DEVMODE
    //

    DevMode = (PDEVMODE) MemAlloc( Size );
    if (!DevMode) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        goto error_exit;
    }

    //
    // get the default document properties
    //

    if (DocumentProperties( NULL, hPrinter, NULL, DevMode, NULL, DM_OUT_BUFFER ) != IDOK) {
        goto error_exit;
    }

    //
    // be sure we are dealing with the correct DEVMODE
    //

    if (DevMode->dmDriverExtra < sizeof(DMPRIVATE)) {
        goto error_exit;
    }

    //
    // set the private DEVMODE pointer
    //

    DevModePrivate = (PDMPRIVATE) ((LPBYTE) DevMode + DevMode->dmSize);

    //
    // set the necessary stuff in the DEVMODE
    //

    DevModePrivate->sendCoverPage     = FALSE;
    DevModePrivate->flags            |= FAXDM_NO_WIZARD;
    DevModePrivate->flags            &= ~FAXDM_DRIVER_DEFAULT;

    //
    // create the device context
    //

    hDC = CreateDC( L"WINSPOOL", FaxPrinterName, NULL, DevMode );
    if (!hDC) {
        goto error_exit;
    }

    //
    // set the document information
    //

    DocInfo.cbSize = sizeof(DOCINFO);
    DocInfo.lpszDocName = PrintInfo->DocName;
    DocInfo.lpszOutput = PrintInfo->OutputFileName;
    DocInfo.lpszDatatype = NULL;
    DocInfo.fwType = 0;

    //
    // start the print job
    //

    JobId = StartDoc( hDC, &DocInfo );
    if (JobId <= 0) {
        goto error_exit;
    }

    if (PrintInfo->OutputFileName == NULL) {

        //
        // HACK HACK -> pause the print job
        //

        if (FaxJobId && *FaxJobId == 0xffffffff) {
            SetJob( hPrinter, JobId, 0, NULL, JOB_CONTROL_PAUSE );
        }

        //
        // allocate memory for the fax tags
        //
    
        FaxTags = (LPWSTR) MemAlloc( 4096 );
        if (!FaxTags) {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return FALSE;
        }

        //
        // set the job tags
        // this is how we communicate the information to
        // the print driver that would otherwise be
        // provided by the fax print wizard
        //

        JobInfo = MyGetJob( hPrinter, 2, JobId );
        if (!JobInfo) {
            goto error_exit;
        }

        AddFaxTag( FaxTags, FAXTAG_RECIPIENT_NUMBER,  PrintInfo->RecipientNumber   );
        AddFaxTag( FaxTags, FAXTAG_RECIPIENT_NAME,    PrintInfo->RecipientName     );
        AddFaxTag( FaxTags, FAXTAG_SENDER_NAME,       PrintInfo->SenderName        );
        AddFaxTag( FaxTags, FAXTAG_SENDER_NAME,       PrintInfo->SenderName        );
        AddFaxTag( FaxTags, FAXTAG_SENDER_COMPANY,    PrintInfo->SenderCompany     );
        AddFaxTag( FaxTags, FAXTAG_SENDER_DEPT,       PrintInfo->SenderDept        );
        AddFaxTag( FaxTags, FAXTAG_BILLING_CODE,      PrintInfo->SenderBillingCode );

        if (PrintInfo->DrProfileName) {
           AddFaxTag( FaxTags, FAXTAG_PROFILE_NAME,   PrintInfo->DrProfileName     );
           AddFaxTag( FaxTags, FAXTAG_EMAIL_NAME,     L"inbox"    );

        } else if (PrintInfo->DrEmailAddress) {
           AddFaxTag( FaxTags, FAXTAG_PROFILE_NAME,   PrintInfo->DrEmailAddress     );
           AddFaxTag( FaxTags, FAXTAG_EMAIL_NAME,     L"email"    );
        }

        //
        // set these fields or the spooler will
        // return ACCESS_DENIED for a non-admin client
        //

        JobInfo->Position    = JOB_POSITION_UNSPECIFIED;
        JobInfo->pDevMode    = NULL;

        //
        // set our new fax tags
        //

        JobInfo->pParameters = FaxTags;

        if (!SetJob( hPrinter, JobId, 2, (LPBYTE) JobInfo, 0 )) {
            goto error_exit;
        }
    }

    //
    // clean up and return to the caller
    //

    ClosePrinter( hPrinter);
    MemFree( PrinterInfo);
    MemFree( DevMode );
    MemFree( FaxTags );
    MemFree( JobInfo );

    if (!PrinterName) {
        MemFree (FaxPrinterName);
    }

    if (FaxJobId) {
        *FaxJobId = JobId;
    }
    FaxContextInfo->hDC = hDC;

    return TRUE;

error_exit:
    if (hPrinter) {
        ClosePrinter( hPrinter);
    }
    if (PrinterInfo) {
        MemFree( PrinterInfo);
    }
    if (JobId) {
        EndDoc( hDC );
    }
    if (hDC) {
        DeleteDC( hDC );
    }
    if (DevMode) {
        MemFree( DevMode );
    }
    if (FaxTags) {
        MemFree( FaxTags );
    }
    if (JobInfo) {
        MemFree( JobInfo );
    }

    if (!PrinterName) {
        MemFree (FaxPrinterName);
    }

    return FALSE;
}


BOOL
WINAPI
FaxStartPrintJobA(
    IN  LPCSTR                    PrinterName,
    IN  const FAX_PRINT_INFOA     *PrintInfo,
    OUT LPDWORD                   JobId,
    OUT FAX_CONTEXT_INFOA         *FaxContextInfo
    )

/*++

Routine Description:

    Starts a print job for the specified printer.  This
    function provides functionality beyond what the caller
    can provide by using StartDoc().  This function disables
    the display of the fax send wizard and also passes along
    the information that would otherwise be gathered by the
    fax wizard ui.

Arguments:

    PrinterName         - Fax printer name (must be a fax printer)
    PrintInfo           - Fax print information
    FaxJobId            - Job id of the resulting print job
    FaxContextInfo      - device context information (hdc, etc.)

Return Value:

    TRUE for success.
    FALSE for failure.

--*/

{
    BOOL Rval;
    FAX_PRINT_INFOW PrintInfoW;
    FAX_CONTEXT_INFOW ContextInfoW;
    LPSTR ServerName;
    LPWSTR PrinterNameW = NULL;

    if (!PrintInfo || !JobId || !FaxContextInfo || 
        (PrintInfo->SizeOfStruct != sizeof(FAX_PRINT_INFOA))) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (PrinterName) {
        PrinterNameW = AnsiStringToUnicodeString( PrinterName );
    }

    ZeroMemory( &ContextInfoW, sizeof(FAX_CONTEXT_INFOW) );
    ContextInfoW.SizeOfStruct = sizeof(FAX_CONTEXT_INFOW) ;

    ZeroMemory( &PrintInfoW, sizeof(FAX_PRINT_INFOW) );

    PrintInfoW.SizeOfStruct      = sizeof(FAX_PRINT_INFOW);
    PrintInfoW.DocName           = AnsiStringToUnicodeString( PrintInfo->DocName           );
    PrintInfoW.RecipientName     = AnsiStringToUnicodeString( PrintInfo->RecipientName     );
    PrintInfoW.RecipientNumber   = AnsiStringToUnicodeString( PrintInfo->RecipientNumber   );
    PrintInfoW.SenderName        = AnsiStringToUnicodeString( PrintInfo->SenderName        );
    PrintInfoW.SenderCompany     = AnsiStringToUnicodeString( PrintInfo->SenderCompany     );
    PrintInfoW.SenderDept        = AnsiStringToUnicodeString( PrintInfo->SenderDept        );
    PrintInfoW.SenderBillingCode = AnsiStringToUnicodeString( PrintInfo->SenderBillingCode );
    PrintInfoW.DrProfileName     = AnsiStringToUnicodeString( PrintInfo->DrProfileName     );
    PrintInfoW.DrEmailAddress    = AnsiStringToUnicodeString( PrintInfo->DrEmailAddress    );
    PrintInfoW.OutputFileName    = AnsiStringToUnicodeString( PrintInfo->OutputFileName    );

    Rval = FaxStartPrintJobW(
        (LPWSTR) PrinterNameW,
        &PrintInfoW,
        JobId,
        &ContextInfoW
        );

    MemFree( (LPBYTE) PrinterNameW );
    MemFree( (LPBYTE) PrintInfoW.DocName           );
    MemFree( (LPBYTE) PrintInfoW.RecipientName     );
    MemFree( (LPBYTE) PrintInfoW.RecipientNumber   );
    MemFree( (LPBYTE) PrintInfoW.SenderName        );
    MemFree( (LPBYTE) PrintInfoW.SenderCompany     );
    MemFree( (LPBYTE) PrintInfoW.SenderDept        );
    MemFree( (LPBYTE) PrintInfoW.SenderBillingCode );

    ServerName = UnicodeStringToAnsiString( ContextInfoW.ServerName);
    if (ServerName) {
        strcpy(FaxContextInfo->ServerName,ServerName);
    }
    else
        FaxContextInfo->ServerName[0] = 0;

    FaxContextInfo->SizeOfStruct = sizeof(FAX_CONTEXT_INFOA);
    FaxContextInfo->hDC = ContextInfoW.hDC;

    MemFree( (LPBYTE) ServerName );
    
    return Rval;
}

BOOL
ValidateCoverpage(
    LPCWSTR  CoverPageName,
    LPCWSTR  ServerName,
    BOOL     ServerCoverpage,
    LPWSTR   ResolvedName
    )
/*++

Routine Description:

    This routine tries to validate that that coverpage specified by the user actually exists where
    they say it does, and that it is indeed a coverpage (or a resolvable link to one)

    Please see the SDK for documentation on the rules for how server coverpages work, etc.                          
Arguments:

    CoverpageName   - contains name of coverpage
    ServerName      - name of the server, if any (can be null)
    ServerCoverpage - indicates if this coverpage is on the server, or in the server location for
                      coverpages locally
    ResolvedName    - a pointer to buffer (should be MAX_PATH large at least) to receive the
                      resolved coverpage name.  If NULL, then this param is ignored
                   

Return Value:

    TRUE if coverpage can be used.
    FALSE if the coverpage is invalid or cannot be used.

--*/

{
    LPWSTR p;
    DWORD ec = 0;
    WCHAR CpDir[MAX_PATH];
    WCHAR Buffer[MAX_PATH];

    if (!CoverPageName) {
        ec = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    wcsncpy(CpDir,CoverPageName,MAX_PATH);
    p = wcschr(CpDir, L'\\' );
    if (p) {

        //
        // the coverpage file name contains a path so just use it.
        //

        if (GetFileAttributes( CpDir ) == 0xffffffff) {
            ec = ERROR_FILE_NOT_FOUND;
            goto exit;
        }

    } else {

        //
        // the coverpage file name does not contain
        // a path so we must construct a full path name
        //

        if (ServerCoverpage) {
            if (!ServerName || ServerName[0] == 0) 
                ec = GetServerCpDir( NULL, CpDir, sizeof(CpDir) );
            else 
                ec = GetServerCpDir( ServerName, CpDir, sizeof(CpDir) );
        } else {
            ec = GetClientCpDir( CpDir, sizeof(CpDir) );
        }

        if (!ec) {
            ec = ERROR_FILE_NOT_FOUND;
            goto exit;
        }
        
        ec = 0;
        ConcatenatePaths(CpDir, CoverPageName);
        
        if (wcschr( CpDir, '.' ) == NULL) {
            wcscat( CpDir, CP_FILENAME_EXT );
        }

        if (GetFileAttributes( CpDir ) == 0xffffffff) {
            p = wcschr( CpDir, '.' );
            if (p) {
                wcscpy( p, CP_SHORTCUT_EXT );
                if (GetFileAttributes( CpDir ) == 0xffffffff) {
                    ec = ERROR_FILE_NOT_FOUND;
                    goto exit;
                }
            } else {
                ec = ERROR_FILE_NOT_FOUND;
                goto exit;
            }
        }
    }

    //
    // if the file is really a shortcut, then resolve it
    //

    if (IsCoverPageShortcut( CpDir )) {
        if (!ResolveShortcut( CpDir, Buffer )) {            
            DebugPrint(( TEXT("Cover page file is really a link, but resolution is not possible") ));
            ec = ERROR_FILE_NOT_FOUND;
            goto exit;
        } else {
            if (ResolvedName) {
                wcscpy(ResolvedName,Buffer);
            }
        }
    } else {
        if (ResolvedName) {
            wcscpy( ResolvedName, CpDir );
        }
    }

exit:
    if (ec) {
        SetLastError(ec);
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\client\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

Author:

    Wesley Witt (wesw)

!ENDIF

!ifndef FAXROOT
FAXROOT=$(PROJECT_ROOT)\fax
!endif

!include $(FAXROOT)\faxsrc.inc

TARGETTYPE=DYNLINK

UMTYPE=windows
DLLDEF=$O\winfax.def
DLLENTRY=WinFaxDllEntry

USE_MSVCRT=1

INCLUDES=\
  $(INCLUDES);  \
  $(FAXROOT)\print\faxprint\inc; \
  $(FAXROOT)\faxcover\renderer;  \
  ..\..\..\tiff\inc; \
  ..\..\inc;    \
  ..\..\registry

TARGETLIBS=\
  $(SDK_LIB_PATH)\rpcrt4.lib      \
  $(SDK_LIB_PATH)\rpcndr.lib      \
  $(SDK_LIB_PATH)\kernel32.lib    \
  $(SDK_LIB_PATH)\shell32.lib     \
  $(SDK_LIB_PATH)\advapi32.lib    \
  $(SDK_LIB_PATH)\winspool.lib    \
  $(SDK_LIB_PATH)\gdi32.lib       \
  $(SDK_LIB_PATH)\user32.lib      \
  $(SDK_LIB_PATH)\ole32.lib       \
  $(SDK_LIB_PATH)\uuid.lib        \
  $(SDK_LIB_PATH)\oleaut32.lib    \
  $(FAXROOT)\service\registry\$O\faxreg.lib   \
  $(FAXROOT)\service\rpc\stubs\faxcli\$O\clistub.lib \
  $(FAXLIB)\*\faxtiffp.lib                    \
  $(FAXLIB)\*\faxrend.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\client\public\faxapi.h ===
#include "..\faxapip.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\client\winfax.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    winfax.c

Abstract:

    This module contains routines for the winfax dllinit.

Author:

    Wesley Witt (wesw) 22-Jan-1996

--*/

#include "faxapi.h"
#pragma hdrstop

OSVERSIONINFOA OsVersion;
HINSTANCE MyhInstance;


DWORD
WinFaxDllEntry(
    HINSTANCE hInstance,
    DWORD     Reason,
    LPVOID    Context
    )

/*++

Routine Description:

    DLL initialization function.

Arguments:

    hInstance   - Instance handle
    Reason      - Reason for the entrypoint being called
    Context     - Context record

Return Value:

    TRUE        - Initialization succeeded
    FALSE       - Initialization failed

--*/

{

    if (Reason == DLL_PROCESS_ATTACH) {
        MyhInstance = hInstance;
        RpcpInitRpcServer();
        DisableThreadLibraryCalls( hInstance );
        HeapInitialize(NULL,NULL,NULL,0);
        OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
        GetVersionExA( &OsVersion );        
    }

    if (Reason == DLL_PROCESS_DETACH) {
        HeapCleanup();
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\client\rpcutil.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    rpcutil.c

Abstract:

    This module contains high level rpc wrapper apis.
    This code is here because the code in the rpcutil
    project uses NT apis and the WINFAX dll but load
    and run on win95.

Author:

    Wesley Witt (wesw) 13-Aug-1997


Revision History:

--*/

#include "faxapi.h"
#pragma hdrstop


#define NT_PIPE_PREFIX_W    L"\\PIPE\\"
#define WCSSIZE(s)          ((wcslen(s)+1) * sizeof(WCHAR))


static CRITICAL_SECTION RpcpCriticalSection;
static DWORD RpcpNumInstances;



DWORD
RpcpInitRpcServer(
    VOID
    )

/*++

Routine Description:

    This function initializes the critical section used to protect the
    global server handle and instance count.

Arguments:

    none

Return Value:

    none

--*/
{
    InitializeCriticalSection(&RpcpCriticalSection);
    RpcpNumInstances = 0;

    return(0);
}



DWORD
RpcpAddInterface(
    IN  LPWSTR              InterfaceName,
    IN  RPC_IF_HANDLE       InterfaceSpecification
    )

/*++

Routine Description:

    Starts an RPC Server, adds the address (or port/pipe), and adds the
    interface (dispatch table).

Arguments:

    InterfaceName - points to the name of the interface.

    InterfaceSpecification - Supplies the interface handle for the
        interface which we wish to add.

Return Value:

    NT_SUCCESS - Indicates the server was successfully started.

    STATUS_NO_MEMORY - An attempt to allocate memory has failed.

    Other - Status values that may be returned by:

                 RpcServerRegisterIf()
                 RpcServerUseProtseqEp()

    , or any RPC error codes, or any windows error codes that
    can be returned by LocalAlloc.

--*/
{
    RPC_STATUS          RpcStatus;
    LPWSTR              Endpoint = NULL;
    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;


    // We need to concatenate \pipe\ to the front of the interface name.

    Endpoint = (LPWSTR)LocalAlloc(LMEM_FIXED, sizeof(NT_PIPE_PREFIX_W) + WCSSIZE(InterfaceName));
    if (Endpoint == 0) {
       return(STATUS_NO_MEMORY);
    }
    wcscpy(Endpoint, NT_PIPE_PREFIX_W );
    wcscat(Endpoint,InterfaceName);

    // Ignore the second argument for now.

    RpcStatus = RpcServerUseProtseqEpW(L"ncacn_np", 10, Endpoint, SecurityDescriptor);

    // If RpcpStartRpcServer and then RpcpStopRpcServer have already
    // been called, the endpoint will have already been added but not
    // removed (because there is no way to do it).  If the endpoint is
    // already there, it is ok.

    if ((RpcStatus != RPC_S_OK) && (RpcStatus != RPC_S_DUPLICATE_ENDPOINT)) {
        goto CleanExit;
    }

    RpcStatus = RpcServerRegisterIf(InterfaceSpecification, 0, 0);

CleanExit:
    if ( Endpoint != NULL ) {
        LocalFree(Endpoint);
    }
    if ( SecurityDescriptor != NULL) {
        LocalFree(SecurityDescriptor);
    }

    return( I_RpcMapWin32Status(RpcStatus) );
}



DWORD
RpcpStartRpcServer(
    IN  LPWSTR              InterfaceName,
    IN  RPC_IF_HANDLE       InterfaceSpecification
    )

/*++

Routine Description:

    Starts an RPC Server, adds the address (or port/pipe), and adds the
    interface (dispatch table).

Arguments:

    InterfaceName - points to the name of the interface.

    InterfaceSpecification - Supplies the interface handle for the
        interface which we wish to add.

Return Value:

    NT_SUCCESS - Indicates the server was successfully started.

    STATUS_NO_MEMORY - An attempt to allocate memory has failed.

    Other - Status values that may be returned by:

                 RpcServerRegisterIf()
                 RpcServerUseProtseqEp()

    , or any RPC error codes, or any windows error codes that
    can be returned by LocalAlloc.

--*/
{
    RPC_STATUS          RpcStatus;

    EnterCriticalSection(&RpcpCriticalSection);

    RpcStatus = RpcpAddInterface( InterfaceName,
                                  InterfaceSpecification );

    if ( RpcStatus != RPC_S_OK ) {
        LeaveCriticalSection(&RpcpCriticalSection);
        return( I_RpcMapWin32Status(RpcStatus) );
    }

    RpcpNumInstances++;

    if (RpcpNumInstances == 1) {


       // The first argument specifies the minimum number of threads to
       // be created to handle calls; the second argument specifies the
       // maximum number of concurrent calls allowed.  The last argument
       // indicates not to wait.

       RpcStatus = RpcServerListen(1,12345, 1);
       if ( RpcStatus == RPC_S_ALREADY_LISTENING ) {
           RpcStatus = RPC_S_OK;
           }
    }

    LeaveCriticalSection(&RpcpCriticalSection);
    return( I_RpcMapWin32Status(RpcStatus) );
}



DWORD
RpcpStopRpcServer(
    IN  RPC_IF_HANDLE      InterfaceSpecification
    )

/*++

Routine Description:

    Deletes the interface.  This is likely
    to be caused by an invalid handle.  If an attempt to add the same
    interface or address again, then an error will be generated at that
    time.

Arguments:

    InterfaceSpecification - A handle for the interface that is to be removed.

Return Value:

    NERR_Success, or any RPC error codes that can be returned from
    RpcServerUnregisterIf.

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = RpcServerUnregisterIf(InterfaceSpecification, 0, 1);
    EnterCriticalSection(&RpcpCriticalSection);

    RpcpNumInstances--;
    if (RpcpNumInstances == 0) {
       RpcMgmtStopServerListening(0);
       RpcMgmtWaitServerListen();
    }

    LeaveCriticalSection(&RpcpCriticalSection);

    return( I_RpcMapWin32Status(RpcStatus) );
}



DWORD
RpcpBindRpc(
    IN  LPCWSTR               ServerName,
    IN  LPCWSTR               ServiceName,
    IN  LPCWSTR               NetworkOptions,
    OUT RPC_BINDING_HANDLE   * pBindingHandle
    )

/*++

Routine Description:

    Binds to the RPC server if possible.

Arguments:

    ServerName - Name of server to bind with.

    ServiceName - Name of service to bind with.

    pBindingHandle - Location where binding handle is to be placed

Return Value:

    STATUS_SUCCESS - The binding has been successfully completed.

    STATUS_INVALID_COMPUTER_NAME - The ServerName syntax is invalid.

    STATUS_NO_MEMORY - There is not sufficient memory available to the
        caller to perform the binding.

--*/

{
    RPC_STATUS        RpcStatus;
    LPWSTR            StringBinding;
    LPWSTR            Endpoint;
    WCHAR             ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    LPWSTR            NewServerName = NULL;
    DWORD             bufLen = MAX_COMPUTERNAME_LENGTH + 1;

    *pBindingHandle = NULL;

    if (ServerName != NULL) {
        if (GetComputerNameW(ComputerName,&bufLen)) {
            if ((_wcsicmp(ComputerName,ServerName) == 0) ||
                ((ServerName[0] == '\\') &&
                 (ServerName[1] == '\\') &&
                 (_wcsicmp(ComputerName,&(ServerName[2]))==0))) {
                NewServerName = NULL;
            }
            else {
                NewServerName = (LPWSTR)ServerName;
            }
        } else {
            NewServerName = (LPWSTR)ServerName;
        }
    }

    // We need to concatenate \pipe\ to the front of the service
    // name.

    Endpoint = (LPWSTR)LocalAlloc(
                    0,
                    sizeof(NT_PIPE_PREFIX_W) + WCSSIZE(ServiceName));
    if (Endpoint == 0) {
       return(STATUS_NO_MEMORY);
    }
    wcscpy(Endpoint,NT_PIPE_PREFIX_W);
    wcscat(Endpoint,ServiceName);

    RpcStatus = RpcStringBindingComposeW(0, L"ncacn_np", NewServerName,
                    Endpoint, (LPWSTR)NetworkOptions, &StringBinding);
    LocalFree(Endpoint);

    if ( RpcStatus != RPC_S_OK ) {
        return( STATUS_NO_MEMORY );
    }

    RpcStatus = RpcBindingFromStringBindingW(StringBinding, pBindingHandle);
    RpcStringFreeW(&StringBinding);
    if ( RpcStatus != RPC_S_OK ) {
        *pBindingHandle = NULL;
        if (   (RpcStatus == RPC_S_INVALID_ENDPOINT_FORMAT)
            || (RpcStatus == RPC_S_INVALID_NET_ADDR) ) {

            return( ERROR_INVALID_COMPUTERNAME );
        }
        return(STATUS_NO_MEMORY);
    }
    return(ERROR_SUCCESS);
}



DWORD
RpcpUnbindRpc(
    IN RPC_BINDING_HANDLE  BindingHandle
    )

/*++

Routine Description:

    Unbinds from the RPC interface.
    If we decide to cache bindings, this routine will do something more
    interesting.

Arguments:

    BindingHandle - This points to the binding handle that is to be closed.


Return Value:


    STATUS_SUCCESS - the unbinding was successful.

--*/
{
    RPC_STATUS       RpcStatus;

    if (BindingHandle != NULL) {
        RpcStatus = RpcBindingFree(&BindingHandle);
    }

    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\client\util.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    print.c

Abstract:

    This module contains utilitarian functions.

Author:

    Wesley Witt (wesw) 29-Nov-1996


Revision History:

--*/

#include "faxapi.h"
#pragma hdrstop


BOOL
ConvertUnicodeMultiSZInPlace(
    LPCWSTR UnicodeString,
    DWORD ByteCount
    )
{
    LPWSTR StrW;
    LPWSTR From;
    LPSTR To;
    LPSTR StrA;

    StrW = MemAlloc( ByteCount );
    if (StrW == NULL) {
        return FALSE;
    }

    CopyMemory( StrW, UnicodeString, ByteCount );

    From = StrW;
    To = (LPSTR) UnicodeString;

    while (From && *From) {

        StrA = UnicodeStringToAnsiString( From );

        if (StrA == NULL) {
            MemFree( StrW );
            return FALSE;
        }

        strcpy( To, StrA );

        To += strlen( To ) + 1;

        From += wcslen( From ) + 1;

        MemFree( StrA );
    }

    MemFree( StrW );

    return TRUE;
}

VOID
ConvertUnicodeStringInPlace(
    LPCWSTR UnicodeString
    )
{
    LPSTR AnsiString = UnicodeStringToAnsiString( UnicodeString );
    if (AnsiString) {
        strcpy( (LPSTR)UnicodeString, AnsiString );
        MemFree( AnsiString );
    }
}


VOID
ConvertAnsiiStringInPlace(
    LPCSTR AnsiiString
    )
{
    LPWSTR UnicodeString = AnsiStringToUnicodeString( AnsiiString );
    if (UnicodeString) {
        wcscpy( (LPWSTR)AnsiiString, UnicodeString );
        MemFree( UnicodeString );
    }
}


VOID
StoreString(
    LPCWSTR String,
    PULONG_PTR DestString,
    LPBYTE Buffer,
    PULONG_PTR Offset
    )
{
    wcscpy( (LPWSTR) (Buffer+*Offset), String );
    *DestString = *Offset;
    *Offset += StringSize( String );
}


VOID
StoreStringA(
    LPCSTR String,
    PULONG_PTR DestString,
    LPBYTE Buffer,
    PULONG_PTR Offset
    )
{
    strcpy( (LPSTR) (Buffer+*Offset), String );
    ConvertAnsiiStringInPlace( (LPSTR) (Buffer+*Offset) );
    *DestString = *Offset;
    *Offset += StringSize( (LPWSTR) String );
}


BOOL
WINAPI
FaxCompleteJobParamsA(
    IN OUT PFAX_JOB_PARAMA *JobParamsBuffer,
    IN OUT PFAX_COVERPAGE_INFOA *CoverpageInfoBuffer
    )

{
   PFAX_JOB_PARAMA JobParams;
   PFAX_COVERPAGE_INFOA CoverpageInfo;

   if (!JobParamsBuffer || !CoverpageInfoBuffer) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
   }

   *JobParamsBuffer = NULL;
   *CoverpageInfoBuffer = NULL;

    if (! FaxCompleteJobParamsW((PFAX_JOB_PARAMW *)JobParamsBuffer,(PFAX_COVERPAGE_INFOW *)CoverpageInfoBuffer) ) {
        return FALSE;
    }

   JobParams = *JobParamsBuffer;
   CoverpageInfo  = *CoverpageInfoBuffer;

    if (JobParams->Tsid)
        ConvertUnicodeStringInPlace( (LPWSTR) JobParams->Tsid);
    if (JobParams->SenderName)
        ConvertUnicodeStringInPlace( (LPWSTR) JobParams->SenderName);
    if (JobParams->SenderCompany)
        ConvertUnicodeStringInPlace( (LPWSTR) JobParams->SenderCompany);
    if (JobParams->SenderDept)
        ConvertUnicodeStringInPlace( (LPWSTR) JobParams->SenderDept);
    if (JobParams->BillingCode)
        ConvertUnicodeStringInPlace( (LPWSTR) JobParams->BillingCode);
    if (JobParams->DeliveryReportAddress)
        ConvertUnicodeStringInPlace( (LPWSTR) JobParams->DeliveryReportAddress);


    if (CoverpageInfo->SdrName)
        ConvertUnicodeStringInPlace( (LPWSTR) CoverpageInfo->SdrName);
    if (CoverpageInfo->SdrFaxNumber)
        ConvertUnicodeStringInPlace( (LPWSTR) CoverpageInfo->SdrFaxNumber);
    if (CoverpageInfo->SdrCompany)
        ConvertUnicodeStringInPlace( (LPWSTR) CoverpageInfo->SdrCompany);
    if (CoverpageInfo->SdrAddress)
        ConvertUnicodeStringInPlace( (LPWSTR) CoverpageInfo->SdrAddress);
    if (CoverpageInfo->SdrTitle)
        ConvertUnicodeStringInPlace( (LPWSTR) CoverpageInfo->SdrTitle);
    if (CoverpageInfo->SdrDepartment)
        ConvertUnicodeStringInPlace( (LPWSTR) CoverpageInfo->SdrDepartment);
    if (CoverpageInfo->SdrOfficeLocation)
        ConvertUnicodeStringInPlace( (LPWSTR) CoverpageInfo->SdrOfficeLocation);
    if (CoverpageInfo->SdrHomePhone)
        ConvertUnicodeStringInPlace( (LPWSTR) CoverpageInfo->SdrHomePhone);
    if (CoverpageInfo->SdrOfficePhone)
        ConvertUnicodeStringInPlace( (LPWSTR) CoverpageInfo->SdrOfficePhone);

    return TRUE;
}

BOOL
WINAPI
FaxCompleteJobParamsW(
    IN OUT PFAX_JOB_PARAMW *JobParamsBuffer,
    IN OUT PFAX_COVERPAGE_INFOW *CoverpageInfoBuffer
    )

{


#define RegStrLen(pValueName,lpdwNeeded) \
        RegQueryValueEx(hKey,pValueName,NULL,NULL,NULL,lpdwNeeded)        


#define RegStrCpy(pValueName, szPointer, Offset) \
        dwNeeded = 256*sizeof(WCHAR); \
        rslt = RegQueryValueEx(hKey,pValueName,NULL,NULL,(LPBYTE)TempBuffer,&dwNeeded);\
        if (rslt == ERROR_SUCCESS) { \
         szPointer = Offset; \
         lstrcpy(Offset,TempBuffer); \
         Offset = Offset + lstrlen(Offset) +1; \
        } 

    PFAX_JOB_PARAM JobParams = NULL;
    PFAX_COVERPAGE_INFO CoverpageInfo = NULL;
    HKEY hKey;
    BOOL fSuccess=FALSE;
    long rslt = ERROR_SUCCESS;
    DWORD dwJobNeeded = sizeof (FAX_JOB_PARAMW);
    DWORD dwCoverNeeded = sizeof (FAX_COVERPAGE_INFOW);
    DWORD dwNeeded = 0;
    WCHAR *CPOffset = NULL, *JobOffset = NULL;
    WCHAR TempBuffer[256];
    
    if (!JobParamsBuffer || !CoverpageInfoBuffer) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    *JobParamsBuffer = NULL;
    *CoverpageInfoBuffer = NULL;

    //
    // open the key holding our data
    //
    rslt = RegOpenKeyEx(HKEY_CURRENT_USER,REGKEY_FAX_USERINFO,0,KEY_READ,&hKey);

    if (rslt != ERROR_SUCCESS) {
       return FALSE;
    }

    //
    // find out how much space we need
    //
    
    RegStrLen(REGVAL_FULLNAME,&dwNeeded);
    dwCoverNeeded += dwNeeded+1;
    dwJobNeeded +=dwNeeded+1;

    RegStrLen(REGVAL_COMPANY,&dwNeeded);
    dwCoverNeeded += dwNeeded+1;
    dwJobNeeded +=dwNeeded+1;

    RegStrLen(REGVAL_DEPT,&dwNeeded);
    dwCoverNeeded += dwNeeded+1;
    dwJobNeeded +=dwNeeded+1;

    RegStrLen(REGVAL_FAX_NUMBER,&dwNeeded);
    dwCoverNeeded += dwNeeded+1;
    dwJobNeeded +=dwNeeded+1;

    RegStrLen(REGVAL_ADDRESS,&dwNeeded);
    dwCoverNeeded += dwNeeded+1;
    
    RegStrLen(REGVAL_TITLE,&dwNeeded);
    dwCoverNeeded += dwNeeded+1;
    
    RegStrLen(REGVAL_OFFICE,&dwNeeded);
    dwCoverNeeded += dwNeeded+1;

    RegStrLen(REGVAL_HOME_PHONE,&dwNeeded);
    dwCoverNeeded += dwNeeded+1;
    
    RegStrLen(REGVAL_OFFICE_PHONE,&dwNeeded);
    dwCoverNeeded += dwNeeded+1;
    
    RegStrLen(REGVAL_BILLING_CODE,&dwNeeded);
    dwJobNeeded +=dwNeeded+1;

    RegStrLen(REGVAL_MAILBOX,&dwNeeded);
    // one for email address, one for DR address
    dwJobNeeded +=dwNeeded+1;
    dwJobNeeded +=dwNeeded+1;
    
    //
    // alloc the space
    //
    JobParams = MemAlloc(dwJobNeeded*sizeof(WCHAR));
    CoverpageInfo = MemAlloc(dwCoverNeeded*sizeof(WCHAR));

    if (!JobParams || !CoverpageInfo ) {
       RegCloseKey(hKey);

       if (JobParams) {
           MemFree( JobParams );
       }

       if (CoverpageInfo) {
           MemFree( CoverpageInfo );
       }

       SetLastError (ERROR_NOT_ENOUGH_MEMORY);
       return FALSE;
    }

    //
    // fill in the data
    //

    ZeroMemory(JobParams,sizeof(FAX_JOB_PARAMW) );
    JobParams->SizeOfStruct = sizeof(FAX_JOB_PARAMW);
    JobParams->ScheduleAction = JSA_NOW;
    JobParams->DeliveryReportType = DRT_NONE;

    ZeroMemory(CoverpageInfo,sizeof(FAX_COVERPAGE_INFOW));
    CoverpageInfo->SizeOfStruct = sizeof(FAX_COVERPAGE_INFOW);    

    CPOffset = (WCHAR *) (  (LPBYTE) CoverpageInfo + sizeof(FAX_COVERPAGE_INFOW));
    JobOffset = (WCHAR *)(  (LPBYTE) JobParams + sizeof(FAX_JOB_PARAMW));              

    RegStrCpy(REGVAL_FULLNAME,CoverpageInfo->SdrName,CPOffset);                                                    
    RegStrCpy(REGVAL_FULLNAME,JobParams->SenderName,JobOffset);                                                   

    RegStrCpy(REGVAL_COMPANY,CoverpageInfo->SdrCompany,CPOffset);                                                    
    RegStrCpy(REGVAL_COMPANY,JobParams->SenderCompany,JobOffset);                                                   

    RegStrCpy(REGVAL_DEPT,CoverpageInfo->SdrDepartment,CPOffset);                                                    
    RegStrCpy(REGVAL_DEPT,JobParams->SenderDept,JobOffset);                                                   
    
    RegStrCpy(REGVAL_FAX_NUMBER,CoverpageInfo->SdrFaxNumber,CPOffset);                                                    
    RegStrCpy(REGVAL_FAX_NUMBER,JobParams->Tsid,JobOffset);                                                   

    RegStrCpy(REGVAL_ADDRESS,CoverpageInfo->SdrAddress,CPOffset);                                                    
    RegStrCpy(REGVAL_TITLE,CoverpageInfo->SdrTitle,CPOffset);
    RegStrCpy(REGVAL_OFFICE,CoverpageInfo->SdrOfficeLocation,CPOffset);
    RegStrCpy(REGVAL_HOME_PHONE,CoverpageInfo->SdrHomePhone,CPOffset);
    RegStrCpy(REGVAL_OFFICE_PHONE,CoverpageInfo->SdrOfficePhone,CPOffset);
    
    RegStrCpy(REGVAL_BILLING_CODE,JobParams->BillingCode,CPOffset);
    RegStrCpy(REGVAL_MAILBOX,JobParams->DeliveryReportAddress,CPOffset);

    *JobParamsBuffer = (PFAX_JOB_PARAM)JobParams;
    *CoverpageInfoBuffer = (PFAX_COVERPAGE_INFO) CoverpageInfo;
    fSuccess = TRUE;

    RegCloseKey(hKey);
    return fSuccess;
}

BOOL
IsLocalFaxConnection( 
    HANDLE FaxHandle
    ) 
{
    WCHAR ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD Size = MAX_COMPUTERNAME_LENGTH + 1;
    PWSTR lpMachineName;

    if (!FaxHandle) {
        SetLastError( ERROR_INVALID_HANDLE );
        return FALSE;
    }

    if (FH_DATA(FaxHandle)->MachineName == NULL) {
        return TRUE;
    }

    lpMachineName = FH_DATA(FaxHandle)->MachineName;

    if (wcscmp( lpMachineName, L"." ) == 0) {
        return TRUE;
    }

    if (GetComputerName( ComputerName, &Size )) {
        if (_wcsicmp( lpMachineName, ComputerName ) == 0) {
            return TRUE;
        }
    
        if (lpMachineName[0] == '\\' &&
            lpMachineName[1] == '\\' &&
            _wcsicmp( &lpMachineName[2], ComputerName ) == 0
            ) {
            return TRUE;
        }
    }
    
    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\faxmapi\email.cpp ===
#include "faxmapip.h"
#pragma hdrstop

LIST_ENTRY          ProfileListHead;
CRITICAL_SECTION    CsProfile;
DWORD               MapiServiceThreadId;

VOID
MapiServiceThread(
    LPVOID EventHandle
    );

BOOL
MyInitializeMapi(
);

BOOL
InitializeEmail(
    VOID
    )
{
    HANDLE MapiThreadHandle;
    HANDLE MapiInitEvent;


    InitializeListHead( &ProfileListHead );
    InitializeCriticalSection( &CsProfile );

    //
    // create an event for the service thread to set after it has initialized mapi
    //

    MapiInitEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

    if (!MapiInitEvent) {
        DebugPrint(( TEXT("InitializeEmailRouting(): CreateEvent() failed: err = %d\n"), GetLastError ));
        return FALSE;
    }

    MapiThreadHandle = CreateThread(
        NULL,
        1024*100,
        (LPTHREAD_START_ROUTINE) MapiServiceThread,
        (LPVOID) MapiInitEvent,
        0,
        &MapiServiceThreadId
        );

    if (MapiThreadHandle == NULL) {
        DebugPrint(( TEXT("InitializeEmailRouting(): Cannot create MapiServiceThread thread") ));
        return FALSE;
    }

    CloseHandle( MapiThreadHandle );

    //
    // wait for MAPI to initialize
    //

    if (WaitForSingleObject( MapiInitEvent, MILLISECONDS_PER_SECOND * 60) != WAIT_OBJECT_0) {
        DebugPrint(( TEXT("InitializeEmailRouting(): WaitForSingleObject failed - ec = %d"), GetLastError() ));
        return FALSE;
    }

    CloseHandle( MapiInitEvent);

    return TRUE;
}


PPROFILE_INFO
FindProfileByName(
    LPCTSTR ProfileName
    )
{
    PLIST_ENTRY Next;
    PPROFILE_INFO ProfileInfo = NULL;


    if (ProfileName == NULL) {
        return NULL;
    }

    EnterCriticalSection( &CsProfile );

    Next = ProfileListHead.Flink;
    if (Next) {
        while (Next != &ProfileListHead) {
            ProfileInfo = CONTAINING_RECORD( Next, PROFILE_INFO, ListEntry );
            Next = ProfileInfo->ListEntry.Flink;
            if (_tcscmp( ProfileInfo->ProfileName, ProfileName ) == 0) {
                LeaveCriticalSection( &CsProfile );
                return ProfileInfo;
            }
        }
    }

    LeaveCriticalSection( &CsProfile );
    return NULL;
}


extern "C"
LPCWSTR WINAPI
GetProfileName(
    IN LPVOID ProfileInfo
    )
{
    return ((PPROFILE_INFO)ProfileInfo)->ProfileName;
}


extern "C"
LPVOID WINAPI
AddNewMapiProfile(
    LPCTSTR ProfileName,
    BOOL UseMail,
    BOOL ShowPopUp
    )
{
    PPROFILE_INFO ProfileInfo = NULL;

    if (!MapiIsInitialized) {
        return NULL;
    }

    if (ProfileName == NULL) {
        return NULL;
    }

    ProfileInfo = FindProfileByName( ProfileName );
    if (ProfileInfo) {
        return ProfileInfo;
    }

    EnterCriticalSection( &CsProfile );

    ProfileInfo = (PPROFILE_INFO) MemAlloc( sizeof(PROFILE_INFO) );
    if (ProfileInfo) {

        // put the profile name into ProfileInfo and create an event for
        // DoMapiLogon to set when its call to MapiLogonEx has completed

        _tcscpy( ProfileInfo->ProfileName, ProfileName );

        ProfileInfo->EventHandle = CreateEvent( NULL, FALSE, FALSE, NULL );
        ProfileInfo->UseMail = UseMail;

        if(ProfileInfo->EventHandle != NULL) {

            // post a message to the mapi service thread

            PostThreadMessage( MapiServiceThreadId, WM_MAPILOGON, 0, (LPARAM) ProfileInfo );

            // wait for the logon to complete

            if (WaitForSingleObject( ProfileInfo->EventHandle, INFINITE) != WAIT_OBJECT_0) {
                DebugPrint(( TEXT("AddNewMapiProfile - WaitForSingleObject failed - ec = %d"), GetLastError() ));
                ProfileInfo->Session = NULL;
            }

            CloseHandle( ProfileInfo->EventHandle );

            if (!ProfileInfo->Session) {
                DebugPrint(( TEXT("DoMapiLogon() failed: [%s] 0x%08x"), ProfileName, GetLastError() ));
                MemFree( ProfileInfo );
                ProfileInfo = NULL;
                if (ShowPopUp) {
                    ServiceMessageBox(
                        GetString( IDS_NO_MAPI_LOGON ),
                        MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND,
                        TRUE,
                        NULL,
                        ProfileName[0] ? ProfileName : GetString( IDS_DEFAULT )
                        );
                }
            } else {
                InsertTailList( &ProfileListHead, &ProfileInfo->ListEntry );
            }
        }
    }

    LeaveCriticalSection( &CsProfile );

    return ProfileInfo;
}


VOID
MapiServiceThread(
    LPVOID EventHandle
    )
/*++

Routine Description:

    Initializes MAPI and services messages.  MAPI/OLE create windows under the
    covers.

Arguments:

    EventHandle -   Event to set once MAPI is initialized.

Return Value:

    NONE

--*/

{
    BOOL Result;

    Result = MyInitializeMapi();

    SetEvent((HANDLE) EventHandle);

    if (!Result) {
        return;
    }

    while (TRUE) {
        MSG msg;

        Result = GetMessage( &msg, NULL, 0, 0 );

        if (Result == (BOOL) -1) {
            DebugPrint(( TEXT("GetMessage returned an error - ec = %d"), GetLastError() ));
            return;
        }

        if (Result) {
            if (msg.message == WM_MAPILOGON) {
                DoMapiLogon( (PPROFILE_INFO) msg.lParam );
            } else {
                DispatchMessage( &msg );
            }
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\faxmapi\faxmapip.h ===
#include <windows.h>
#include <mapi.h>
#include <mapix.h>
#include <tchar.h>

#include "faxmapi.h"
#include "faxutil.h"
#include "winfax.h"
#include "faxreg.h"
#include "profinfo.h"
#include "resource.h"


#define WM_MAPILOGON                (WM_USER + 100)

extern BOOL                MapiIsInitialized;
extern PSERVICEMESSAGEBOX  ServiceMessageBox;
extern BOOL                ServiceDebug;
extern HINSTANCE           MyhInstance;


//
// mapi.cpp
//

BOOL
InitializeMapi(
    VOID
    );

VOID
DoMapiLogon(
    PPROFILE_INFO ProfileInfo
    );

//
// util.cpp
//

VOID
InitializeStringTable(
    VOID
    );

LPTSTR
GetString(
    DWORD InternalId
    );

LPTSTR
GetLastErrorText(
    DWORD ErrorCode
    );

//
// email.cpp
//

BOOL
InitializeEmail(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\faxmapi\faxmapi.cpp ===
#include "faxmapip.h"
#pragma hdrstop


HINSTANCE           MyhInstance;
BOOL                ServiceDebug;
PSERVICEMESSAGEBOX  ServiceMessageBox;



extern "C"
DWORD
FaxMapiDllInit(
    IN HINSTANCE hInstance,
    IN DWORD     Reason,
    IN LPVOID    Context
    )
{
    if (Reason == DLL_PROCESS_ATTACH) {
        MyhInstance = hInstance;
        DisableThreadLibraryCalls( hInstance );
    }

    return TRUE;
}


extern "C"
BOOL WINAPI
FaxMapiInitialize(
    IN HANDLE HeapHandle,
    IN PSERVICEMESSAGEBOX pServiceMessageBox,
    IN BOOL DebugService
    )
{
    ServiceMessageBox = pServiceMessageBox;
    ServiceDebug = DebugService;

    HeapInitialize(HeapHandle,NULL,NULL,0);

    InitializeStringTable();
    InitializeEmail();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\faxevent\faxevent.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    eventlog.c

Abstract:

    This file contains all functions that access the application event log.

Author:

    Wesley Witt (wesw) 19-Mar-1996

Environment:

    User Mode

--*/

#include <windows.h>
#include <tapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#include "winfax.h"
#include "faxutil.h"
#include "faxreg.h"
#include "faxsvcrg.h"
#include "faxdev.h"
#include "faxevent.h"
#include "messages.h"



#define MAX_STRINGS                   64
#define FAX_SVC_EVENT                 TEXT("Fax Service")


HINSTANCE            MyhInstance;
HANDLE               hEventSrc;
DWORD                FaxCategoryCount;
CRITICAL_SECTION     CsEvent;

#ifdef   OLD_WAY
FAX_LOG_CATEGORY     FaxCategory[16];
#else    // OLD_WAY
PFAX_LOG_CATEGORY     FaxCategory;
#endif   // OLD_WAY


DWORD
FaxEventDllInit(
    HINSTANCE hInstance,
    DWORD     Reason,
    LPVOID    Context
    )
{
    if (Reason == DLL_PROCESS_ATTACH) {
        MyhInstance = hInstance;
        DisableThreadLibraryCalls( hInstance );        
    }

    return TRUE;
}



BOOL
InitializeEventLog(
    IN HANDLE HeapHandle,
    IN PREG_FAX_SERVICE FaxReg,
    PFAX_LOG_CATEGORY DefaultCategories,
    int DefaultCategoryCount
    )

/*++

Routine Description:

    Initializes the event log for the FAX service to
    record event entries.

Arguments:
    HeapHandle - 
    FaxReg - 
    DefaultCategories - points to the array of FAX_LOG_CATEGORY structures
    DefaultCategoryCount - the number of elements in DefaultCategories


Return Value:

    TRUE for success, FALSE for failure

--*/

{
    DWORD i;


    HeapInitialize(HeapHandle,NULL,NULL,0);
    InitializeCriticalSection( &CsEvent );

    //
    // create the event source, if it does not already exist
    //

    if ( CreateFaxEventSource( FaxReg,
                               DefaultCategories,
                               DefaultCategoryCount ) == (BOOL) FALSE )
    {
       return FALSE;
    }

    Assert( FaxReg->Logging );

    //
    // allocate memory for the logging category info
    //

    EnterCriticalSection( &CsEvent );

    FaxCategory = (PFAX_LOG_CATEGORY) MemAlloc( sizeof(FAX_LOG_CATEGORY) * FaxReg->LoggingCount );
    if (!FaxCategory) {
        LeaveCriticalSection( &CsEvent );
        return FALSE;
    }

    //
    // capture the event categories from the registry
    //

    for (i=0; i<FaxReg->LoggingCount; i++) {

        FaxCategory[i].Name      = StringDup( FaxReg->Logging[i].CategoryName );
        FaxCategory[i].Category  = FaxReg->Logging[i].Number;
        FaxCategory[i].Level     = FaxReg->Logging[i].Level;

    }

    FaxCategoryCount = FaxReg->LoggingCount;

    LeaveCriticalSection( &CsEvent );

    //
    // get a handle to the event log
    //

    hEventSrc = RegisterEventSource(
        NULL,
        FAX_SVC_EVENT
        );

    if (!hEventSrc) {
        return FALSE;
    }

    return TRUE;
}



VOID
RefreshEventLog(
    PREG_FAX_LOGGING FaxReg
    )

/*++

Routine Description:

    Refreshes the event log for the FAX service to
    record event entries.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DWORD i;

    EnterCriticalSection( &CsEvent );

    //
    // capture the event categories from the registry
    //

    for (i=0; i<FaxReg->LoggingCount; i++) {
        if (FaxCategory[i].Name) {
            MemFree( (LPVOID)FaxCategory[i].Name );
        }
        FaxCategory[i].Name = StringDup( FaxReg->Logging[i].CategoryName );
        FaxCategory[i].Category = FaxReg->Logging[i].Number;
        FaxCategory[i].Level = FaxReg->Logging[i].Level;
    }

    FaxCategoryCount = FaxReg->LoggingCount;

    LeaveCriticalSection( &CsEvent );

}


BOOL
FaxLog(
    DWORD Category,
    DWORD Level,
    DWORD StringCount,
    DWORD FormatId,
    ...
    )

/*++

Routine Description:

    Writes a log file entry to the event log.

Arguments:

    Level       - Severity of the log record
    StringCount - Number of strings included in the varargs
    FormatId    - Message file id

Return Value:

    TRUE for success, FALSE for failure

--*/

{
    LPTSTR Strings[MAX_STRINGS];
    DWORD i;
    va_list args;
    WORD Type;


    //
    // look for the category
    //

    EnterCriticalSection( &CsEvent );

    for (i=0; i<FaxCategoryCount; i++) {
        if (FaxCategory[i].Category == Category) {
            if (Level > FaxCategory[i].Level) {
                LeaveCriticalSection( &CsEvent );
                return FALSE;
            }
        }
    }

    LeaveCriticalSection( &CsEvent );

    va_start( args, FormatId );

    //
    // capture the strings
    //
    for (i=0; i<StringCount; i++) {
        Strings[i] = va_arg( args, LPTSTR );
        if(Strings[i] == NULL) {
            Strings[i] = TEXT("");
        }
    }

    switch (FormatId >> 30) {

        case STATUS_SEVERITY_WARNING:

            Type = EVENTLOG_WARNING_TYPE;
            break;

        case STATUS_SEVERITY_ERROR:

            Type = EVENTLOG_ERROR_TYPE;
            break;

        case STATUS_SEVERITY_INFORMATIONAL:
        case STATUS_SEVERITY_SUCCESS:

            Type = EVENTLOG_INFORMATION_TYPE;

    }

    //
    // record the event
    //

    ReportEvent(
        hEventSrc,                       // event log handle
        Type,                            // type
        (WORD) Category,                 // category
        FormatId,                        // event id
        NULL,                            // security id
        (WORD) StringCount,              // string count
        0,                               // data buffer size
        Strings,                         // strings
        NULL                             // data buffer
        );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\faxmapi\mapi.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mapi.c

Abstract:

    This file implements wrappers for all mapi apis.
    The wrappers are necessary because mapi does not
    implement unicode and this code must be non-unicode.

Author:

    Wesley Witt (wesw) 13-Sept-1996

Revision History:

--*/

#undef UNICODE
#undef _UNICODE

#include <windows.h>
#include <mapiwin.h>
#include <mapix.h>
#include <mapiutil.h>
#include <stdio.h>

#include "profinfo.h"
#include "faxutil.h"



typedef ULONG (STDAPIVCALLTYPE*ULRELEASE)(LPVOID);
typedef VOID  (STDAPIVCALLTYPE*FREEPADRLIST)(LPADRLIST);
typedef ULONG (STDAPIVCALLTYPE*HRQUERYALLROWS)(LPMAPITABLE,LPSPropTagArray,LPSRestriction,LPSSortOrderSet,LONG,LPSRowSet*);
typedef SCODE (STDAPIVCALLTYPE*SCDUPPROPSET)(int, LPSPropValue,LPALLOCATEBUFFER, LPSPropValue*);



static LPMAPIINITIALIZE     MapiInitialize;
static LPMAPIUNINITIALIZE   MapiUnInitialize;
static LPMAPILOGONEX        MapiLogonEx;
static LPMAPIFREEBUFFER     MapiFreeBuffer;
static LPMAPIALLOCATEBUFFER MapiAllocateBuffer;
static LPMAPIADMINPROFILES  MapiAdminProfiles;
static ULRELEASE            pUlRelease;
static FREEPADRLIST         pFreePadrlist;
static HRQUERYALLROWS       pHrQueryAllRows;
static SCDUPPROPSET         pScDupPropset;


static MAPIINIT_0           MapiInit;

BOOL MapiIsInitialized = FALSE;
extern ServiceDebug;

PROC
WINAPI
MyGetProcAddress(
    HMODULE hModule,
    LPCSTR lpProcName
    );


extern "C"
LPSTR
UnicodeStringToAnsiString(
    LPCWSTR UnicodeString
    );

extern "C"
VOID
FreeString(
    LPVOID String
    );


BOOL
InitializeMapi(
    VOID
    )

/*++

Routine Description:

    Initializes MAPI.

Arguments:

    NONE

Return Value:

    TRUE if successful, FALSE if not

--*/

{

    HMODULE MapiMod = NULL;
    HRESULT Result;

    //
    // load the mapi dll
    //

    MapiMod = LoadLibrary( "mapi32.dll" );
    if (!MapiMod) {
        return FALSE;
    }

    //
    // get the addresses of the mapi functions that we need
    //

    MapiInitialize = (LPMAPIINITIALIZE) MyGetProcAddress( MapiMod, "MAPIInitialize" );
    MapiUnInitialize = (LPMAPIUNINITIALIZE) MyGetProcAddress( MapiMod, "MAPIUninitialize" );
    MapiLogonEx = (LPMAPILOGONEX) MyGetProcAddress( MapiMod, "MAPILogonEx" );
    MapiFreeBuffer = (LPMAPIFREEBUFFER) MyGetProcAddress( MapiMod, "MAPIFreeBuffer" );
    MapiAllocateBuffer = (LPMAPIALLOCATEBUFFER) MyGetProcAddress( MapiMod, "MAPIAllocateBuffer" );
    MapiAdminProfiles = (LPMAPIADMINPROFILES) MyGetProcAddress( MapiMod, "MAPIAdminProfiles" );
    pUlRelease = (ULRELEASE) MyGetProcAddress( MapiMod, "UlRelease@4" );
    pFreePadrlist = (FREEPADRLIST) MyGetProcAddress( MapiMod, "FreePadrlist@4" );
    pHrQueryAllRows = (HRQUERYALLROWS) MyGetProcAddress( MapiMod, "HrQueryAllRows@24" );
    pScDupPropset = (SCDUPPROPSET) MyGetProcAddress( MapiMod, "ScDupPropset@16" );

    if ((!MapiInitialize) || (!MapiUnInitialize) ||
        (!MapiLogonEx) || (!MapiAllocateBuffer) ||
        (!MapiFreeBuffer) || (!MapiAdminProfiles) ||
        (!pUlRelease) || (!pFreePadrlist) ||
        (!pHrQueryAllRows) || (!pScDupPropset)) {
        return FALSE;
    }

    MapiInit.ulFlags = MAPI_MULTITHREAD_NOTIFICATIONS;

    if (!ServiceDebug) {
        MapiInit.ulFlags |= MAPI_NT_SERVICE;
    }

    Result = MapiInitialize(&MapiInit);

    if (Result != S_OK) {
        return FALSE;
    }

    return MapiIsInitialized = TRUE;
}


VOID
FreeProws(
    LPSRowSet prows
    )

/*++

Routine Description:

    Destroy SRowSet structure.  Copied from MAPI.

Arguments:

    hFile      - Pointer to SRowSet

Return value:

    NONE

--*/

{
    ULONG irow;

    if (!prows) {
        return;
    }

    for (irow = 0; irow < prows->cRows; ++irow) {
        MapiFreeBuffer(prows->aRow[irow].lpProps);
    }

    MapiFreeBuffer( prows );
}


HRESULT
HrMAPIFindInbox(
    IN LPMDB lpMdb,
    OUT ULONG *lpcbeid,
    OUT LPENTRYID *lppeid
    )

/*++

Routine Description:

    Find IPM inbox folder.  Copied from Exchange SDK.

Arguments:

    lpMdb            - pointer to message store
    lpcbeid          - count of bytes in entry ID
    lppeid           - entry ID of IPM inbox

Return value:

    HRESULT (see MAPI docs)

--*/

{
    HRESULT hr = NOERROR;
    SCODE sc = 0;


    *lpcbeid = 0;
    *lppeid  = NULL;

    //
    // Get the entry ID of the Inbox from the message store
    //
    hr = lpMdb->GetReceiveFolder(
        NULL,
        0,
        lpcbeid,
        lppeid,
        NULL
        );

    return hr;
}

HRESULT
HrMAPIFindOutbox(
    IN LPMDB lpMdb,
    OUT ULONG *lpcbeid,
    OUT LPENTRYID *lppeid
    )
/*++

Routine Description:

    Find IPM outbox folder.  Copied from Exchange SDK.

Arguments:

    lpMdb            - pointer to message store
    lpcbeid          - count of bytes in entry ID
    lppeid           - entry ID of IPM inbox

Return value:

    HRESULT (see MAPI docs)

--*/
{
    HRESULT       hr          = NOERROR;
    SCODE         sc          = 0;
    ULONG         cValues     = 0;
    LPSPropValue  lpPropValue = NULL;
    ULONG         cbeid       = 0;
    SPropTagArray rgPropTag   = { 1, { PR_IPM_OUTBOX_ENTRYID } };


    *lpcbeid = 0;
    *lppeid  = NULL;

    //
    // Get the outbox entry ID property.
    //
    hr = lpMdb->GetProps(
        &rgPropTag,
        0,
        &cValues,
        &lpPropValue
        );

    if (hr == MAPI_W_ERRORS_RETURNED) {
        goto cleanup;
    }

    if (FAILED(hr)) {
        lpPropValue = NULL;
        goto cleanup;
    }

    //
    // Check to make sure we got the right property.
    //
    if (lpPropValue->ulPropTag != PR_IPM_OUTBOX_ENTRYID) {
        goto cleanup;
    }

    cbeid = lpPropValue->Value.bin.cb;

    sc = MapiAllocateBuffer( cbeid, (void **)lppeid );

    if(FAILED(sc)) {
        goto cleanup;
    }

    //
    // Copy outbox Entry ID
    //
    CopyMemory(
        *lppeid,
        lpPropValue->Value.bin.lpb,
        cbeid
        );

    *lpcbeid = cbeid;

cleanup:

    MapiFreeBuffer( lpPropValue );

    return hr;
}


HRESULT
HrMAPIFindDefaultMsgStore(
    IN LPMAPISESSION lplhSession,
    OUT ULONG *lpcbeid,
    OUT LPENTRYID *lppeid
    )

/*++

Routine Description:

    Get the entry ID of the default message store.  Copied from Exchange SDK.

Arguments:

       lplhSession      - session pointer
       lpcbeid          - count of bytes in entry ID
       lppeid           - entry ID default store

Return value:

    HRESULT (see MAPI docs)

--*/

{
    HRESULT     hr      = NOERROR;
    SCODE       sc      = 0;
    LPMAPITABLE lpTable = NULL;
    LPSRowSet   lpRows  = NULL;
    LPENTRYID   lpeid   = NULL;
    ULONG       cbeid   = 0;
    ULONG       cRows   = 0;
    ULONG       i       = 0;

    SizedSPropTagArray(2, rgPropTagArray) =
    {
        2,
        {
            PR_DEFAULT_STORE,
            PR_ENTRYID
        }
    };

    //
    // Get the list of available message stores from MAPI
    //
    hr = lplhSession->GetMsgStoresTable( 0, &lpTable );
    if (FAILED(hr)) {
        goto cleanup;
    }

    //
    // Get the row count for the message recipient table
    //
    hr = lpTable->GetRowCount( 0, &cRows );
    if (FAILED(hr)) {
        goto cleanup;
    }

    //
    // Set the columns to return
    //
    hr = lpTable->SetColumns( (LPSPropTagArray)&rgPropTagArray, 0 );
    if (FAILED(hr)) {
        goto cleanup;
    }

    //
    // Go to the beginning of the recipient table for the envelope
    //
    hr = lpTable->SeekRow( BOOKMARK_BEGINNING, 0, NULL );
    if (FAILED(hr)) {
        goto cleanup;
    }

    //
    // Read all the rows of the table
    //
    hr = lpTable->QueryRows( cRows, 0, &lpRows );
    if (SUCCEEDED(hr) && (lpRows != NULL) && (lpRows->cRows == 0)) {
        FreeProws( lpRows );
        hr = MAPI_E_NOT_FOUND;
    }

    if (FAILED(hr) || (lpRows == NULL)) {
        goto cleanup;
    }

    for (i = 0; i < cRows; i++) {
        if(lpRows->aRow[i].lpProps[0].Value.b == TRUE) {
            cbeid = lpRows->aRow[i].lpProps[1].Value.bin.cb;

            sc = MapiAllocateBuffer( cbeid, (void **)&lpeid );

            if(FAILED(sc)) {
                cbeid = 0;
                lpeid = NULL;
                goto cleanup;
            }

            //
            // Copy entry ID of message store
            //
            CopyMemory(
                lpeid,
                lpRows->aRow[i].lpProps[1].Value.bin.lpb,
                cbeid
                );

            break;
        }
    }

cleanup:

    if(!lpRows) {
        FreeProws( lpRows );
    }

    lpTable->Release();

    *lpcbeid = cbeid;
    *lppeid = lpeid;

    return hr;
}


HRESULT
HrMAPIWriteFileToStream(
    IN HANDLE hFile,
    OUT LPSTREAM lpStream
    )

/*++

Routine Description:

    Write file to a stream given a stream pointer.  Copied from Exchange SDK.

Arguments:

       hFile      - Handle to file
       lpStream   - Pointer to stream

Return value:

    HRESULT (see MAPI docs)

--*/
{
    HRESULT hr              = NOERROR;
    DWORD   cBytesRead      = 0;
    ULONG   cBytesWritten   = 0;
    BYTE    byteBuffer[128] = {0};
    BOOL    fReadOk         = FALSE;

    for(;;) {
        fReadOk = ReadFile(
            hFile,
            byteBuffer,
            sizeof(byteBuffer),
            &cBytesRead,
            NULL
            );

        if (!fReadOk) {
            break;
        }

        if (!cBytesRead) {
            hr = NOERROR;
            break;
        }

        hr = lpStream->Write(
            byteBuffer,
            cBytesRead,
            &cBytesWritten
            );
        if (FAILED(hr)) {
            break;
        }

        if(cBytesWritten != cBytesRead) {
            break;
        }
    }

    return hr;
}


VOID
DoMapiLogon(
    PPROFILE_INFO ProfileInfo
    )
{
    HRESULT HResult = 0;
    FLAGS MAPILogonFlags = MAPI_NEW_SESSION | MAPI_EXTENDED | MAPI_NO_MAIL;
    LPSTR ProfileName;
    LPMAPISESSION Session = NULL;


    if (!MapiIsInitialized) {
        ProfileInfo->Session = NULL;
        SetEvent( ProfileInfo->EventHandle );
        return;

    }

    if (!ServiceDebug) {
        MAPILogonFlags |= MAPI_NT_SERVICE;
    }

    if (ProfileInfo->UseMail) {
        MAPILogonFlags &= ~MAPI_NO_MAIL;
    }

    if (ProfileInfo->ProfileName[0] == 0) {
        MAPILogonFlags |= MAPI_USE_DEFAULT;
    }

    ProfileName = UnicodeStringToAnsiString( ProfileInfo->ProfileName );

    __try {
        HResult = MapiLogonEx(
            0,
            ProfileName,
            NULL,
            MAPILogonFlags,
            &Session
            );
    } __except (EXCEPTION_EXECUTE_HANDLER) {

        HResult = GetExceptionCode();
    }

    if (HR_FAILED(HResult)) {
        SetLastError( HResult );
        ProfileInfo->Session = NULL;
    } else {
        InitializeCriticalSection( &ProfileInfo->CsSession );
        ProfileInfo->Session = Session;
    }

    FreeString( ProfileName );

    SetEvent( ProfileInfo->EventHandle );
}


BOOL
DoMapiLogoff(
    LPMAPISESSION Session
    )
{
    HRESULT HResult = Session->Logoff( 0, 0, 0 );
    if (HR_FAILED(HResult)) {
        return FALSE;
    }
    return TRUE;
}


extern "C"
BOOL WINAPI
StoreMapiMessage(
    LPVOID          ProfileInfo,
    LPWSTR          MsgSenderNameW,
    LPWSTR          MsgSubjectW,
    LPWSTR          MsgBodyW,
    LPWSTR          MsgAttachmentFileNameW,
    LPWSTR          MsgAttachmentTitleW,
    DWORD           MsgImportance,
    LPFILETIME      MsgTime,
    PULONG          ResultCode
    )

/*++

Routine Description:

    Mails a TIFF file to the inbox in the specified profile.

Arguments:

    TiffFileName            - Name of TIFF file to mail
    ProfileName             - Profile name to use
    ResultCode              - The result of the failed API call

Return Value:

    TRUE for success, FALSE on error

--*/

{
    LPATTACH            Attach = NULL;
    ULONG               AttachmentNum;
    CHAR                FileExt[_MAX_EXT];
    CHAR                FileName[MAX_PATH];
    HRESULT             HResult = 0;
    LPMAPIFOLDER        Inbox = NULL;
    LPMESSAGE           Message = NULL;
    LPSTR               MsgAttachmentFileName = NULL;
    LPSTR               MsgAttachmentTitle = NULL;
    LPSTR               MsgBody = NULL;
    LPSTR               MsgSenderName = NULL;
    LPSTR               MsgSubject = NULL;
    DWORD               RenderingPosition = 0;
    LPMDB               Store = NULL;
    LPSTREAM            Stream = NULL;
    ULONG               cbInEntryID = 0;
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    LPENTRYID           lpInEntryID = NULL;
    LPSPropProblemArray lppProblems;
    ULONG               lpulObjType;
    SPropValue          spvAttachProps[5] = { 0 };
    SPropValue          spvMsgProps[9] = { 0 };
    FILETIME            CurrentTime;
    LPMAPISESSION       Session = ((PPROFILE_INFO)ProfileInfo)->Session;


    _try {

        //
        // get the time if the caller wants us to
        //

        if (!MsgTime) {
            MsgTime = &CurrentTime;
            GetSystemTimeAsFileTime( MsgTime );
        }

        //
        // find the default message store
        //

        HResult = HrMAPIFindDefaultMsgStore( (LPMAPISESSION) Session, &cbInEntryID, &lpInEntryID );
        if(HR_FAILED(HResult)) {
            _leave;
        }

        //
        // open the message store
        //

        HResult = ((LPMAPISESSION)Session)->OpenMsgStore(
            0,
            cbInEntryID,
            lpInEntryID,
            NULL,
            MDB_NO_DIALOG | MDB_WRITE,
            &Store
            );
        if (HR_FAILED(HResult)) {
            _leave;
        }

        MapiFreeBuffer( lpInEntryID );

        //
        // find the inbox
        //

        HResult= HrMAPIFindInbox( Store, &cbInEntryID, &lpInEntryID );
        if(HR_FAILED(HResult)) {
            _leave;
        }

        //
        // open the inbox
        //

        HResult = ((LPMAPISESSION)Session)->OpenEntry(
            cbInEntryID,
            lpInEntryID,
            NULL,
            MAPI_MODIFY,
            &lpulObjType,
            (LPUNKNOWN *) &Inbox
            );
        if (HR_FAILED(HResult)) {
            _leave;
        }

        //
        // Create a message
        //

        HResult = Inbox->CreateMessage(
            NULL,
            0,
            &Message
            );
        if (HR_FAILED(HResult)) {
            _leave;
        }

        //
        // convert all of the strings to ansi strings
        //

        MsgSenderName = UnicodeStringToAnsiString( MsgSenderNameW );
        MsgSubject = UnicodeStringToAnsiString( MsgSubjectW );
        MsgBody = UnicodeStringToAnsiString( MsgBodyW );
        MsgAttachmentFileName = UnicodeStringToAnsiString( MsgAttachmentFileNameW );
        MsgAttachmentTitle = UnicodeStringToAnsiString( MsgAttachmentTitleW );

        //
        // Fill in message properties and set them
        //

        spvMsgProps[0].ulPropTag     = PR_SENDER_NAME;
        spvMsgProps[1].ulPropTag     = PR_SENT_REPRESENTING_NAME;
        spvMsgProps[2].ulPropTag     = PR_SUBJECT;
        spvMsgProps[3].ulPropTag     = PR_MESSAGE_CLASS;
        spvMsgProps[4].ulPropTag     = PR_BODY;
        spvMsgProps[5].ulPropTag     = PR_MESSAGE_DELIVERY_TIME;
        spvMsgProps[6].ulPropTag     = PR_CLIENT_SUBMIT_TIME;
        spvMsgProps[7].ulPropTag     = PR_MESSAGE_FLAGS;
        spvMsgProps[8].ulPropTag     = PR_IMPORTANCE;
        spvMsgProps[0].Value.lpszA   = MsgSenderName;
        spvMsgProps[1].Value.lpszA   = MsgSenderName;
        spvMsgProps[2].Value.lpszA   = MsgSubject;
        spvMsgProps[3].Value.lpszA   = "IPM.Note";
        spvMsgProps[4].Value.lpszA   = MsgBody;
        spvMsgProps[5].Value.ft      = *MsgTime;
        spvMsgProps[6].Value.ft      = *MsgTime;
        spvMsgProps[7].Value.ul      = 0;
        spvMsgProps[8].Value.ul      = MsgImportance;

        HResult = Message->SetProps(
            sizeof(spvMsgProps)/sizeof(SPropValue),
            (LPSPropValue) spvMsgProps,
            &lppProblems
            );
        if (HR_FAILED(HResult)) {
            _leave;
        }

        MapiFreeBuffer( lppProblems );

        if (MsgAttachmentFileName) {

            //
            // Create an attachment
            //

            HResult = Message->CreateAttach(
                NULL,
                0,
                &AttachmentNum,
                &Attach
                );
            if (HR_FAILED(HResult)) {
                _leave;
            }

            _splitpath( MsgAttachmentFileName, NULL, NULL, FileName, FileExt );
            strcat( FileName, FileExt );

            //
            // Fill in attachment properties and set them
            //

            if (!MsgAttachmentTitle) {
                MsgAttachmentTitle = FileName;
            }

            RenderingPosition = strlen(MsgBody);

            spvAttachProps[0].ulPropTag     = PR_RENDERING_POSITION;
            spvAttachProps[1].ulPropTag     = PR_ATTACH_METHOD;
            spvAttachProps[2].ulPropTag     = PR_ATTACH_LONG_FILENAME;
            spvAttachProps[3].ulPropTag     = PR_DISPLAY_NAME;
            spvAttachProps[4].ulPropTag     = PR_ATTACH_EXTENSION;
            spvAttachProps[0].Value.ul      = RenderingPosition;
            spvAttachProps[1].Value.ul      = ATTACH_BY_VALUE;
            spvAttachProps[2].Value.lpszA   = MsgAttachmentTitle;
            spvAttachProps[3].Value.lpszA   = MsgAttachmentTitle;
            spvAttachProps[4].Value.lpszA   = FileExt;

            HResult = Attach->SetProps(
                sizeof(spvAttachProps)/sizeof(SPropValue),
                (LPSPropValue) spvAttachProps,
                &lppProblems
                );
            if (HR_FAILED(HResult)) {
                _leave;
            }

            MapiFreeBuffer( lppProblems );

            //
            // Attach a data property to the attachment
            //

            HResult = Attach->OpenProperty(
                PR_ATTACH_DATA_BIN,
                &IID_IStream,
                0,
                MAPI_CREATE | MAPI_MODIFY,
                (LPUNKNOWN *) &Stream
                );
            if (HR_FAILED(HResult)) {
                _leave;
            }

            //
            // open the message attachment file
            //

            hFile = CreateFile(
                MsgAttachmentFileName,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );
            if (hFile == INVALID_HANDLE_VALUE) {
                _leave;
            }

            //
            // Write the file to the data property
            //

            HResult = HrMAPIWriteFileToStream( hFile, Stream );
            if (HR_FAILED(HResult)) {
                _leave;
            }
        }

        //
        // Save the changes and logoff
        //

        HResult = Attach->SaveChanges(
            FORCE_SAVE
            );
        if (HR_FAILED(HResult)) {
            _leave;
        }

        HResult = Message->SaveChanges(
            FORCE_SAVE
            );
        if (HR_FAILED(HResult)) {
            _leave;
        }

    }
    _finally {

        MapiFreeBuffer( lpInEntryID );

        if (Store) {
            Store->Release();
        }
        if (Inbox) {
            Inbox->Release();
        }
        if (Message) {
            Message->Release();
        }
        if (Attach) {
            Attach->Release();
        }
        if (Stream) {
            Stream->Release();
        }

        FreeString( MsgSenderName );
        FreeString( MsgSubject );
        FreeString( MsgBody );
        FreeString( MsgAttachmentFileName );
        if (MsgAttachmentTitleW && MsgAttachmentTitle) {
            FreeString( MsgAttachmentTitle );
        }

        CloseHandle( hFile );

    }

    *ResultCode = HResult;
    return HResult == 0;
}


extern "C"
LONG WINAPI
GetMapiProfiles(
    LPWSTR *OutBuffer,
    LPDWORD OutBufferSize
    )
{
    HMODULE MapiMod = NULL;
    LPMAPITABLE pmt = NULL;
    LPSRowSet prws = NULL;
    LPSPropValue pval;
    LPPROFADMIN lpProfAdmin;
    DWORD i;
    HRESULT hr;
    DWORD Count;
    LPWSTR Buffer;
    DWORD BytesNeeded;
    DWORD Offset = 0;


    if (!MapiIsInitialized) {
        return MAPI_E_NO_SUPPORT;
    }

    if (hr = MapiAdminProfiles( 0, &lpProfAdmin )) {
        return hr;
    }

    //
    // get the mapi table object
    //

    if (hr = lpProfAdmin->GetProfileTable( 0, &pmt )) {
        goto exit;
    }

    //
    // get the actual profile data, FINALLY
    //

    if (hr = pmt->QueryRows( 4000, 0, &prws )) {
        goto exit;
    }

    //
    // enumerate the profiles and put the name
    // of each profile in the combo box
    //

    BytesNeeded = 0;

    for (i=0; i<prws->cRows; i++) {

        pval = prws->aRow[i].lpProps;


        Count = MultiByteToWideChar(
            CP_ACP,
            MB_PRECOMPOSED,
            pval[0].Value.lpszA,
            -1,
            NULL,
            0
            );

        if (Count == 0) {

            hr = GetLastError();

            goto exit;

        } else {

            BytesNeeded += Count * sizeof(WCHAR);

        }
    }

    BytesNeeded += sizeof(UNICODE_NULL);

    Buffer = (LPWSTR) MemAlloc( BytesNeeded );
    if (Buffer == NULL) {
        hr = ERROR_INSUFFICIENT_BUFFER;
        goto exit;
    }

    for (i=0; i<prws->cRows; i++) {

        pval = prws->aRow[i].lpProps;

        Count = MultiByteToWideChar(
            CP_ACP,
            MB_PRECOMPOSED,
            pval[0].Value.lpszA,
            -1,
            &Buffer[Offset],
            BytesNeeded - (Offset * sizeof(WCHAR))
            );

        if (Count == 0) {

            hr = GetLastError();

            goto exit;

        } else {

            Offset += Count;
        }

    }

    Buffer[Offset] = 0;

    *OutBuffer = Buffer;
    *OutBufferSize = BytesNeeded;

    hr = ERROR_SUCCESS;

exit:
    FreeProws( prws );

    if (pmt) {
        pmt->Release();
    }

    if (lpProfAdmin) {
        lpProfAdmin->Release();
    }

    return hr;
}

BOOL
GetDefaultMapiProfile(
    LPWSTR ProfileName
    )
{
    BOOL rVal = FALSE;
    LPMAPITABLE pmt = NULL;
    LPSRowSet prws = NULL;
    LPSPropValue pval;
    LPPROFADMIN lpProfAdmin;
    DWORD i;
    DWORD j;

    if (!MapiIsInitialized) {
        goto exit;
    }

    if (MapiAdminProfiles( 0, &lpProfAdmin )) {
        goto exit;
    }

    //
    // get the mapi profile table object
    //

    if (lpProfAdmin->GetProfileTable( 0, &pmt )) {
        goto exit;
    }

    //
    // get the actual profile data, FINALLY
    //

    if (pmt->QueryRows( 4000, 0, &prws )) {
        goto exit;
    }

    //
    // enumerate the profiles looking for the default profile
    //

    for (i=0; i<prws->cRows; i++) {
        pval = prws->aRow[i].lpProps;
        for (j = 0; j < 2; j++) {
            if (pval[j].ulPropTag == PR_DEFAULT_PROFILE && pval[j].Value.b) {
                //
                // this is the default profile
                //
                MultiByteToWideChar(
                    CP_ACP,
                    MB_PRECOMPOSED,
                    pval[0].Value.lpszA,
                    -1,
                    ProfileName,
                    (cchProfileNameMax + 1) * sizeof(WCHAR)
                    );
                rVal = TRUE;
                break;
            }
        }
    }

exit:
    FreeProws( prws );

    if (pmt) {
        pmt->Release();
    }

    return rVal;
}


#define IADDRTYPE  0
#define IEMAILADDR 1
#define IMAPIRECIP 2
#define IPROXYADDR 3
#define PR_EMS_AB_CONTAINERID  PROP_TAG(PT_LONG, 0xFFFD)
#define PR_EMS_AB_PROXY_ADDRESSES_A PROP_TAG(PT_MV_STRING8, 0x800F)
#define MUIDEMSAB {0xDC, 0xA7, 0x40, 0xC8, 0xC0, 0x42, 0x10, 0x1A, 0xB4, 0xB9, 0x08, 0x00, 0x2B, 0x2F, 0xE1, 0x82}
#define CbNewFlagList(_cflag) (offsetof(FlagList,ulFlag) + (_cflag)*sizeof(ULONG))


HRESULT
HrMAPICreateSizedAddressList(        // RETURNS: return code
    IN ULONG cEntries,               // count of entries in address list
    OUT LPADRLIST *lppAdrList        // pointer to address list pointer
    )
{
    HRESULT         hr              = NOERROR;
    SCODE           sc              = 0;
    ULONG           cBytes          = 0;


    *lppAdrList = NULL;

    cBytes = CbNewADRLIST(cEntries);

    sc = MapiAllocateBuffer(cBytes, (PVOID*) lppAdrList);
    if(FAILED(sc))
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    // Initialize ADRLIST structure
    ZeroMemory(*lppAdrList, cBytes);

    (*lppAdrList)->cEntries = cEntries;

cleanup:

    return hr;
}


HRESULT
HrMAPISetAddressList(                // RETURNS: return code
    IN ULONG iEntry,                 // index of address list entry
    IN ULONG cProps,                 // count of values in address list entry
    IN LPSPropValue lpPropValues,    // pointer to address list entry
    IN OUT LPADRLIST lpAdrList       // pointer to address list pointer
    )
{
    HRESULT         hr              = NOERROR;
    SCODE           sc              = 0;
    LPSPropValue    lpNewPropValues = NULL;
    ULONG           cBytes          = 0;


    if(iEntry >= lpAdrList->cEntries)
    {
        hr = E_FAIL;
        goto cleanup;
    }

    sc = pScDupPropset(
        cProps,
        lpPropValues,
        MapiAllocateBuffer,
        &lpNewPropValues
        );

    if(FAILED(sc))
    {
        hr = E_FAIL;
        goto cleanup;
    }

    if(lpAdrList->aEntries[iEntry].rgPropVals != NULL)
    {
        MapiFreeBuffer(lpAdrList->aEntries[iEntry].rgPropVals);
    }

    lpAdrList->aEntries[iEntry].cValues = cProps;
    lpAdrList->aEntries[iEntry].rgPropVals = lpNewPropValues;

cleanup:

    return hr;
}


HRESULT
HrCheckForTypeA(                // RETURNS: return code
    IN  LPCSTR lpszAddrType,    // pointer to address type
    IN  LPCSTR lpszProxy,       // pointer to proxy address
    OUT LPSTR * lppszAddress    // pointer to address pointer
    )
{
    HRESULT hr              = E_FAIL;
    LPCSTR  lpszProxyAddr   = NULL;
    ULONG   cbAddress       = 0;
    SCODE   sc              = 0;
    ULONG   cchProxy        = 0;
    ULONG   cchProxyType    = 0;


    // Initialize output parameter

    *lppszAddress = NULL;

    // find the ':' separator.

    cchProxy     = lstrlenA(lpszProxy);
    cchProxyType = strcspn(lpszProxy, ":");

    if((cchProxyType == 0) || (cchProxyType >= cchProxy))
    {
        hr = E_FAIL;
        goto cleanup;
    }

    hr = MAPI_E_NOT_FOUND;

    // does the address type match?
    if((cchProxyType == (ULONG)lstrlenA(lpszAddrType)) &&
       (_strnicmp(lpszProxy, lpszAddrType, cchProxyType) == 0))
    {
        // specified address type found
        lpszProxyAddr = lpszProxy + cchProxyType + 1;

        cbAddress = strlen(lpszProxyAddr);

        // make a buffer to hold it.
        sc = MapiAllocateBuffer(cbAddress, (void **)lppszAddress);

        if(FAILED(sc))
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            CopyMemory(*lppszAddress, lpszProxyAddr, cbAddress);

            hr = NOERROR;
        }
    }

cleanup:

    return hr;
}


HRESULT
HrFindExchangeGlobalAddressList(
    IN  LPADRBOOK  lpAdrBook,
    OUT ULONG      *lpcbeid,
    OUT LPENTRYID  *lppeid
    )
{
    HRESULT         hr                  = NOERROR;
    ULONG           ulObjType           = 0;
    ULONG           i                   = 0;
    LPMAPIPROP      lpRootContainer     = NULL;
    LPMAPIPROP      lpContainer         = NULL;
    LPMAPITABLE     lpContainerTable    = NULL;
    LPSRowSet       lpRows              = NULL;
    ULONG           cbContainerEntryId  = 0;
    LPENTRYID       lpContainerEntryId  = NULL;
    LPSPropValue    lpCurrProp          = NULL;
    SRestriction    SRestrictAnd[2]     = {0};
    SRestriction    SRestrictGAL        = {0};
    SPropValue      SPropID             = {0};
    SPropValue      SPropProvider       = {0};
    BYTE            muid[]              = MUIDEMSAB;

    SizedSPropTagArray(1, rgPropTags) =
    {
        1,
        {
            PR_ENTRYID,
        }
    };


    *lpcbeid = 0;
    *lppeid  = NULL;

    // Open the root container of the address book
    hr = lpAdrBook->OpenEntry(
        0,
        NULL,
        NULL,
        MAPI_DEFERRED_ERRORS,
        &ulObjType,
        (LPUNKNOWN FAR *)&lpRootContainer
        );

    if(FAILED(hr))
    {
        goto cleanup;
    }

    if(ulObjType != MAPI_ABCONT)
    {
        hr = E_FAIL;
        goto cleanup;
    }

    // Get the hierarchy table of the root container
    hr = ((LPABCONT)lpRootContainer)->GetHierarchyTable(
        MAPI_DEFERRED_ERRORS|CONVENIENT_DEPTH,
        &lpContainerTable
        );

    if(FAILED(hr))
    {
        goto cleanup;
    }

    // Restrict the table to the global address list (GAL)
    // ---------------------------------------------------

    // Initialize provider restriction to only Exchange providers

    SRestrictAnd[0].rt                          = RES_PROPERTY;
    SRestrictAnd[0].res.resProperty.relop       = RELOP_EQ;
    SRestrictAnd[0].res.resProperty.ulPropTag   = PR_AB_PROVIDER_ID;
    SPropProvider.ulPropTag                     = PR_AB_PROVIDER_ID;

    SPropProvider.Value.bin.cb                  = 16;
    SPropProvider.Value.bin.lpb                 = (LPBYTE)muid;
    SRestrictAnd[0].res.resProperty.lpProp      = &SPropProvider;

    // Initialize container ID restriction to only GAL container

    SRestrictAnd[1].rt                          = RES_PROPERTY;
    SRestrictAnd[1].res.resProperty.relop       = RELOP_EQ;
    SRestrictAnd[1].res.resProperty.ulPropTag   = PR_EMS_AB_CONTAINERID;
    SPropID.ulPropTag                           = PR_EMS_AB_CONTAINERID;
    SPropID.Value.l                             = 0;
    SRestrictAnd[1].res.resProperty.lpProp      = &SPropID;

    // Initialize AND restriction

    SRestrictGAL.rt                             = RES_AND;
    SRestrictGAL.res.resAnd.cRes                = 2;
    SRestrictGAL.res.resAnd.lpRes               = &SRestrictAnd[0];

    // Restrict the table to the GAL - only a single row should remain

    // Get the row corresponding to the GAL

        //
        //  Query all the rows
        //

        hr = pHrQueryAllRows(
            lpContainerTable,
                (LPSPropTagArray)&rgPropTags,
                &SRestrictGAL,
                NULL,
                0,
                &lpRows
                );

    if(FAILED(hr) || (lpRows == NULL) || (lpRows->cRows != 1))
    {
        hr = E_FAIL;
        goto cleanup;
    }

    // Get the entry ID for the GAL

    lpCurrProp = &(lpRows->aRow[0].lpProps[0]);

    if(lpCurrProp->ulPropTag == PR_ENTRYID)
    {
        cbContainerEntryId = lpCurrProp->Value.bin.cb;
        lpContainerEntryId = (LPENTRYID)lpCurrProp->Value.bin.lpb;
    }
    else
    {
        hr = E_FAIL;
        goto cleanup;
    }

    hr = MapiAllocateBuffer( cbContainerEntryId, (LPVOID *)lppeid );

    if(FAILED(hr))
    {
        *lpcbeid = 0;
        *lppeid = NULL;
    }
    else
    {
        CopyMemory(
            *lppeid,
            lpContainerEntryId,
            cbContainerEntryId);

        *lpcbeid = cbContainerEntryId;
    }

cleanup:

    pUlRelease(lpRootContainer);
    pUlRelease(lpContainerTable);
    pUlRelease(lpContainer);
    FreeProws( lpRows );

    if(FAILED(hr)) {
        MapiFreeBuffer( *lppeid );
        *lpcbeid = 0;
        *lppeid = NULL;
    }

    return hr;
}


HRESULT
HrGWResolveProxy(
    IN  LPADRBOOK   lpAdrBook,      // pointer to address book
    IN  ULONG       cbeid,          // count of bytes in the entry ID
    IN  LPENTRYID   lpeid,          // pointer to the entry ID
    IN  LPCSTR      lpszAddrType,   // pointer to the address type
    OUT BOOL        *lpfMapiRecip,  // MAPI recipient
    OUT LPSTR       *lppszAddress   // pointer to the address pointer
    )
{
    HRESULT         hr              = E_FAIL;
    HRESULT         hrT             = 0;
    SCODE           sc              = 0;
    ULONG           i               = 0;
    ULONG           cbAddress       = 0;
    ULONG           cProxy          = 0;
    LPSPropValue    lpProps         = NULL;
    LPADRLIST       lpAdrList       = NULL;
    SPropValue      prop[2]         = {0};

    SizedSPropTagArray(4, rgPropTags) =
    {
        4,
        {
            PR_ADDRTYPE_A,
            PR_EMAIL_ADDRESS_A,
            PR_SEND_RICH_INFO,
            PR_EMS_AB_PROXY_ADDRESSES_A
        }
    };


    // Initialize output parameters

    *lpfMapiRecip = FALSE;
    *lppszAddress = NULL;

    hr = HrMAPICreateSizedAddressList(1, &lpAdrList);

    if(FAILED(hr))
    {
        goto cleanup;
    }

    prop[0].ulPropTag       = PR_ENTRYID;
    prop[0].Value.bin.cb    = cbeid;
    prop[0].Value.bin.lpb   = (LPBYTE)lpeid;
    prop[1].ulPropTag       = PR_RECIPIENT_TYPE;
    prop[1].Value.ul        = MAPI_TO;

    hr = HrMAPISetAddressList(
        0,
        2,
        prop,
        lpAdrList
        );

    if(FAILED(hr))
    {
        goto cleanup;
    }

    hrT = lpAdrBook->PrepareRecips(
        0,
        (LPSPropTagArray)&rgPropTags,
        lpAdrList
        );

    if(FAILED(hrT))
    {
        goto cleanup;
    }

    lpProps = lpAdrList->aEntries[0].rgPropVals;

    //
    //  Hack:  detect the case where prepare recips doesn't work correctly.
    //      This happens when trying to look up a recipient that is in
    //      a replicated directory but not in the local directory.
    //
    if (lpAdrList->aEntries[0].cValues == 3)
    {
        hr = E_FAIL;
        goto cleanup;
    }

    // If the given address type matches the PR_ADDRTYPE value,
    // return the PR_EMAIL_ADDRESS value

    if((PROP_TYPE(lpProps[IADDRTYPE].ulPropTag) != PT_ERROR) &&
       (PROP_TYPE(lpProps[IEMAILADDR].ulPropTag) != PT_ERROR) &&
       (_strcmpi(lpProps[IADDRTYPE].Value.lpszA, lpszAddrType) == 0))
    {
        cbAddress = strlen(lpProps[IEMAILADDR].Value.lpszA);

        sc = MapiAllocateBuffer(cbAddress, (void **)lppszAddress);

        if(FAILED(sc))
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            CopyMemory(*lppszAddress, lpProps[IEMAILADDR].Value.lpszW, cbAddress);
            hr = NOERROR;
        }

        goto cleanup;
    }

    // Search for a PR_EMS_AB_PROXY_ADDRESSES of the given type if present.

    else if(PROP_TYPE(lpProps[IPROXYADDR].ulPropTag) != PT_ERROR)
    {
        // count of proxy addresses
        cProxy = lpAdrList->aEntries[0].rgPropVals[IPROXYADDR].Value.MVszA.cValues;

        for(i = 0; i < cProxy; i++)
        {
            hr = HrCheckForTypeA(
                lpszAddrType,
                lpProps[IPROXYADDR].Value.MVszA.lppszA[i],
                lppszAddress
                );

            if(hr == MAPI_E_NOT_FOUND)
            {
                continue;
            }
            else if(FAILED(hr))
            {
                goto cleanup;
            }
            else
            {
                //
                // Found a matching proxy address.
                //

                goto cleanup;
            }
        }
    }
    else
    {
        hr = E_FAIL;
        goto cleanup;
    }

cleanup:

    if(SUCCEEDED(hr))
    {
        *lpfMapiRecip = lpAdrList->aEntries[0].rgPropVals[IMAPIRECIP].Value.b;
    }

    pFreePadrlist(lpAdrList);

    return hr;
}


HRESULT
HrGWResolveAddress(
    IN LPABCONT lpGalABCont,        // pointer to GAL container
    IN LPCSTR lpszAddress,          // pointer to proxy address
    OUT BOOL *lpfMapiRecip,         // MAPI recipient
    OUT ULONG *lpcbEntryID,         // count of bytes in entry ID
    OUT LPENTRYID *lppEntryID,      // pointer to entry ID
    OUT LPADRLIST *lpAdrList        // address list
    )
{
    HRESULT     hr          = NOERROR;
    HRESULT     hrT         = 0;
    SCODE       sc          = 0;
    LPFlagList  lpFlagList  = NULL;
    SPropValue  prop[2]     = {0};
    ULONG       cbEntryID   = 0;
    LPENTRYID   lpEntryID   = NULL;

    static const SizedSPropTagArray(2, rgPropTags) =
    { 2,
        {
            PR_ENTRYID,
            PR_SEND_RICH_INFO
        }
    };

    *lpfMapiRecip = FALSE;
    *lpcbEntryID  = 0;
    *lppEntryID   = NULL;
    *lpAdrList    = NULL;

    sc = MapiAllocateBuffer( CbNewFlagList(1), (LPVOID*)&lpFlagList);

    if(FAILED(sc))
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    lpFlagList->cFlags    = 1;
    lpFlagList->ulFlag[0] = MAPI_UNRESOLVED;

    hr = HrMAPICreateSizedAddressList(
        1,
        lpAdrList
        );
    if(FAILED(hr)) {
        goto cleanup;
    }

    prop[0].ulPropTag = PR_DISPLAY_NAME_A;
    prop[0].Value.lpszA = (LPSTR)lpszAddress;
    prop[1].ulPropTag = PR_RECIPIENT_TYPE;
    prop[1].Value.ul = MAPI_TO;

    hr = HrMAPISetAddressList(
        0,
        2,
        prop,
        *lpAdrList
        );
    if(FAILED(hr)) {
        goto cleanup;
    }

    hrT = lpGalABCont->ResolveNames(
        (LPSPropTagArray)&rgPropTags,
        0,
        *lpAdrList,
        lpFlagList
        );

    if(lpFlagList->ulFlag[0] != MAPI_RESOLVED)
    {
        if(lpFlagList->ulFlag[0] == MAPI_AMBIGUOUS)
        {
            hrT = MAPI_E_AMBIGUOUS_RECIP;
        }
        else
        {
            hrT = MAPI_E_NOT_FOUND;
        }
    }

    if(FAILED(hrT))
    {
        if(hrT == MAPI_E_NOT_FOUND)
        {
            hr = MAPI_E_NOT_FOUND;
        }
        else
        {
            hr = E_FAIL;
        }

        goto cleanup;
    }

    cbEntryID = (*lpAdrList)->aEntries[0].rgPropVals[0].Value.bin.cb;
    lpEntryID = (LPENTRYID)(*lpAdrList)->aEntries[0].rgPropVals[0].Value.bin.lpb;

    sc = MapiAllocateBuffer( cbEntryID, (LPVOID*)lppEntryID);

    if(FAILED(sc))
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    CopyMemory(*lppEntryID, lpEntryID, cbEntryID);
    *lpcbEntryID  = cbEntryID;
    *lpfMapiRecip = (*lpAdrList)->aEntries[0].rgPropVals[1].Value.b;

cleanup:

    MapiFreeBuffer(lpFlagList);

    return hr;
}


extern "C"
BOOL WINAPI
MailMapiMessage(
    LPVOID          ProfileInfo,
    LPWSTR          RecipientNameW,
    LPWSTR          MsgSubjectW,
    LPWSTR          MsgBodyW,
    LPWSTR          MsgAttachmentFileNameW,
    LPWSTR          MsgAttachmentTitleW,
    DWORD           MsgImportance,
    PULONG          ResultCode
    )

/*++

Routine Description:

    Mails a TIFF file to the addressbook recipient in the specified profile.

Arguments:

    TiffFileName            - Name of TIFF file to mail
    ProfileName             - Profile name to use
    ResultCode              - The result of the failed API call

Return Value:

    TRUE for success, FALSE on error

--*/

{
    ULONG               cbInEntryID = 0;
    LPENTRYID           lpInEntryID = NULL;
    LPMDB               Store       = NULL;
    ULONG               lpulObjType;
    LPMAPIFOLDER        Inbox       = NULL;
    LPMAPIFOLDER        Outbox      = NULL;
    LPMESSAGE           Message     = NULL;
    LPATTACH            Attach      = NULL;
    LPSTREAM            Stream      = NULL;
    ULONG               AttachmentNum;
    HRESULT             HResult     = 0;
    LPSTR               MsgAttachmentFileName = NULL;
    LPSTR               MsgAttachmentTitle = NULL;
    LPSTR               MsgBody = NULL;
    LPSTR               MsgSubject = NULL;
    LPSTR               BodyStrA = NULL;
    LPSTR               SubjectStrA = NULL;
    LPSTR               SenderStrA = NULL;
    LPSTR               LongFileNameA = NULL;
    LPSTR               RecipientName = NULL;
    DWORD               RenderingPosition = 0;
    LPADRBOOK           AddrBook;
    LPADRLIST           lpAddrList = NULL;
    ULONG               ulFlags = LOGOFF_PURGE;
    LPSPropProblemArray lppProblems;
    ULONG               cbGalEid = 0;
    LPENTRYID           lpGalEid = NULL;
    LPSTR               lpszProxyAddr = NULL;
    BOOL                fMapiRecip = FALSE;
    ULONG               ulObjType = 0;
    LPABCONT            lpGalABCont = NULL;
    ULONG               cbEntryID = 0;
    LPENTRYID           lpEntryID = NULL;
    SPropValue          spvAttachProps[5] = { 0 };
    SPropValue          spvMsgProps[5] = { 0 };
    CHAR                FileExt[_MAX_EXT];
    CHAR                FileName[MAX_PATH];
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    LPMAPISESSION       Session = ((PPROFILE_INFO)ProfileInfo)->Session;



    _try {

        //
        // convert all of the strings to ansi strings
        //

        RecipientName = UnicodeStringToAnsiString( RecipientNameW );
        MsgSubject = UnicodeStringToAnsiString( MsgSubjectW );
        MsgBody = UnicodeStringToAnsiString( MsgBodyW );
        MsgAttachmentFileName = UnicodeStringToAnsiString( MsgAttachmentFileNameW );
        MsgAttachmentTitle = UnicodeStringToAnsiString( MsgAttachmentTitleW );


        HResult = ((LPMAPISESSION)Session)->OpenAddressBook(
            0,
            NULL,
            AB_NO_DIALOG,
            &AddrBook
            );
        if(HR_FAILED(HResult)) {
            _leave;
        }

        HResult = HrFindExchangeGlobalAddressList(
            AddrBook,
            &cbGalEid,
            &lpGalEid
            );
        if(HR_FAILED(HResult)) {
            _leave;
        }

        HResult = AddrBook->OpenEntry(
            cbGalEid,
            lpGalEid,
            NULL,
            MAPI_DEFERRED_ERRORS,
            &ulObjType,
            (LPUNKNOWN FAR *)&lpGalABCont
            );
        if(HR_FAILED(HResult)) {
            _leave;
        }

        HResult = HrGWResolveAddress(
            lpGalABCont,
            RecipientName,
            &fMapiRecip,
            &cbEntryID,
            &lpEntryID,
            &lpAddrList
            );
        if(HR_FAILED(HResult)) {
            _leave;
        }

        //
        // Find the default message store
        //
        HResult = HrMAPIFindDefaultMsgStore(
            (LPMAPISESSION)Session,
            &cbInEntryID,
            &lpInEntryID
            );
        if(HR_FAILED(HResult)) {
            _leave;
        }

        //
        // Open it
        //
        HResult = ((LPMAPISESSION)Session)->OpenMsgStore(
            (ULONG)0,
            cbInEntryID,
            lpInEntryID,
            NULL,
            MDB_NO_DIALOG | MDB_WRITE,
            &Store
            );
        if(HR_FAILED(HResult)) {
            _leave;
        }

        MapiFreeBuffer(lpInEntryID);

        //
        // Find the outbox
        //
        HResult= HrMAPIFindOutbox(
            Store,
            &cbInEntryID,
            &lpInEntryID
            );
        if(HR_FAILED(HResult)) {
            _leave;
        }

        //
        // Open it
        //
        HResult = Store->OpenEntry(
            cbInEntryID,
            lpInEntryID,
            NULL,
            MAPI_MODIFY | MAPI_DEFERRED_ERRORS,
            &lpulObjType,
            (LPUNKNOWN *) &Outbox
            );
        if(HR_FAILED(HResult)) {
            _leave;
        }

        //
        // Create a message
        //
        HResult = Outbox->CreateMessage(
            NULL,
            0,
            &Message
            );
        if(HR_FAILED(HResult)) {
            _leave;
        }

        HResult = Message->ModifyRecipients(
            0,
            lpAddrList
            );

        if(HR_FAILED(HResult)) {
            _leave;
        }

        //
        // Fill in message properties and set them
        //

        spvMsgProps[0].ulPropTag     = PR_SUBJECT;
        spvMsgProps[1].ulPropTag     = PR_MESSAGE_CLASS;
        spvMsgProps[2].ulPropTag     = PR_BODY;
        spvMsgProps[3].ulPropTag     = PR_IMPORTANCE;
        spvMsgProps[4].ulPropTag     = PR_DELETE_AFTER_SUBMIT;

        spvMsgProps[0].Value.lpszA   = MsgSubject;
        spvMsgProps[1].Value.lpszA   = "IPM.Note";
        spvMsgProps[2].Value.lpszA   = MsgBody;
        spvMsgProps[3].Value.ul      = MsgImportance;
        spvMsgProps[4].Value.ul      = TRUE;

        HResult = Message->SetProps(
            sizeof(spvMsgProps)/sizeof(SPropValue),
            (LPSPropValue) spvMsgProps,
            &lppProblems
            );
        if (HR_FAILED(HResult)) {
            _leave;
        }

        MapiFreeBuffer( lppProblems );

        if (MsgAttachmentFileName) {

            //
            // Create an attachment
            //

            HResult = Message->CreateAttach(
                NULL,
                0,
                &AttachmentNum,
                &Attach
                );
            if (HR_FAILED(HResult)) {
                _leave;
            }

            _splitpath( MsgAttachmentFileName, NULL, NULL, FileName, FileExt );
            strcat( FileName, FileExt );

            //
            // Fill in attachment properties and set them
            //

            if (!MsgAttachmentTitle) {
                MsgAttachmentTitle = FileName;
            }

            RenderingPosition = strlen(MsgBody);

            spvAttachProps[0].ulPropTag     = PR_RENDERING_POSITION;
            spvAttachProps[1].ulPropTag     = PR_ATTACH_METHOD;
            spvAttachProps[2].ulPropTag     = PR_ATTACH_LONG_FILENAME;
            spvAttachProps[3].ulPropTag     = PR_DISPLAY_NAME;
            spvAttachProps[4].ulPropTag     = PR_ATTACH_EXTENSION;

            spvAttachProps[0].Value.ul      = RenderingPosition;
            spvAttachProps[1].Value.ul      = ATTACH_BY_VALUE;
            spvAttachProps[2].Value.lpszA   = MsgAttachmentTitle;
            spvAttachProps[3].Value.lpszA   = MsgAttachmentTitle;
            spvAttachProps[4].Value.lpszA   = FileExt;

            HResult = Attach->SetProps(
                sizeof(spvAttachProps)/sizeof(SPropValue),
                (LPSPropValue) spvAttachProps,
                &lppProblems
                );
            if (HR_FAILED(HResult)) {
                _leave;
            }

            MapiFreeBuffer( lppProblems );

            //
            // Attach a data property to the attachment
            //

            HResult = Attach->OpenProperty(
                PR_ATTACH_DATA_BIN,
                &IID_IStream,
                0,
                MAPI_CREATE | MAPI_MODIFY,
                (LPUNKNOWN *) &Stream
                );
            if (HR_FAILED(HResult)) {
                _leave;
            }

            //
            // open the message attachment file
            //

            hFile = CreateFile(
                MsgAttachmentFileName,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );
            if (hFile == INVALID_HANDLE_VALUE) {
                _leave;
            }

            //
            // Write the file to the data property
            //

            HResult = HrMAPIWriteFileToStream( hFile, Stream );
            if (HR_FAILED(HResult)) {
                _leave;
            }

            HResult = Attach->SaveChanges(
                FORCE_SAVE
                );
            if (HR_FAILED(HResult)) {
                _leave;
            }
        }

        //
        // mail the message
        //
        HResult = Message->SubmitMessage(
            0
            );
        if(HR_FAILED(HResult)) {
            _leave;
        }

        HResult = Store->StoreLogoff(
            &ulFlags
            );
        if(HR_FAILED(HResult)) {
            _leave;
        }

    }
    _finally {

        if (Store) {
            Store->Release();
        }
        if (Inbox) {
            Inbox->Release();
        }
        if (Message) {
            Message->Release();
        }
        if (Attach) {
            Attach->Release();
        }
        if (Stream) {
            Stream->Release();
        }
        if (AddrBook) {
            AddrBook->Release();
        }
        if (lpAddrList) {
            pFreePadrlist( lpAddrList );
        }

        if (lpEntryID) {
            MapiFreeBuffer( lpEntryID );
        }
        if (lpszProxyAddr) {
            MapiFreeBuffer( lpszProxyAddr );
        }
        if (lpInEntryID) {
            MapiFreeBuffer( lpInEntryID );
        }

        FreeString( MsgSubject );
        FreeString( MsgBody );
        FreeString( MsgAttachmentFileName );
        if (MsgAttachmentTitleW && MsgAttachmentTitle) {
            FreeString( MsgAttachmentTitle );
        }

        CloseHandle( hFile );
    }
    *ResultCode = HResult;
    return HResult == 0;
}

PROC
WINAPI
MyGetProcAddress(
    HMODULE hModule,
    LPCSTR lpProcName
    )
{
    FARPROC Proc;

    Proc = GetProcAddress( hModule, lpProcName );

    if (Proc) {
        return Proc;

    } else {
        char *c = strrchr( lpProcName, '@' );

        //
        // remove name decoration
        //

        if (c) {
            char * lpAltProcName = (char *) MemAlloc( strlen( lpProcName ) );

            if (!lpAltProcName) {
                return NULL;
            }

            strncpy( lpAltProcName, lpProcName, (int)(c - lpProcName) );

            Proc = GetProcAddress( hModule, lpAltProcName );

            MemFree( lpAltProcName );

            return Proc;
        } else {

            return NULL;

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\faxmapi\profinfo.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    profinfo.h

Abstract:

    This header file declares the structure used to do mapi logon's

Author:

    George Jenkins (georgeje) 10-8-1996


Revision History:

--*/

typedef struct _PROFILE_INFO {
    LIST_ENTRY          ListEntry;                  // linked list pointers
    WCHAR               ProfileName[64];            // mapi profile name
    LPMAPISESSION       Session;                    // opened session handle
    CRITICAL_SECTION    CsSession;                  // synchronization object for this session handle
    HANDLE              EventHandle;                // event to set after logging on
    BOOL                UseMail;
} PROFILE_INFO, *PPROFILE_INFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\faxmapi\resource.h ===
#define IDS_NO_MAPI_LOGON   101
#define IDS_DEFAULT         102
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\faxroute\resource.h ===
#define IDS_NO_MAPI_LOGON   101
#define IDS_DEFAULT         102
#define IDS_SERVICE_NAME    103
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\faxroute\print.cpp ===
#include "faxrtp.h"
#pragma hdrstop



LPCTSTR PrintPlatforms[] =
{
    TEXT("Windows NT x86"),
    TEXT("Windows NT R4000"),
    TEXT("Windows NT Alpha_AXP"),
    TEXT("Windows NT PowerPC")
};



BOOL
IsPrinterFaxPrinter(
    LPCTSTR PrinterName
    )

/*++

Routine Description:

    Determines if a printer is a fax printer.

Arguments:

    PrinterName - Name of the printer

Return Value:

    TRUE for success.
    FALSE for failure.

--*/

{
    HANDLE hPrinter = NULL;
    PRINTER_DEFAULTS PrinterDefaults;
    SYSTEM_INFO SystemInfo;
    DWORD Size;
    DWORD Rval = FALSE;
    LPDRIVER_INFO_2 DriverInfo = NULL;


    PrinterDefaults.pDatatype     = NULL;
    PrinterDefaults.pDevMode      = NULL;
    PrinterDefaults.DesiredAccess = PRINTER_READ;

    if (!OpenPrinter( (LPWSTR) PrinterName, &hPrinter, &PrinterDefaults )) {

        DebugPrint(( TEXT("OpenPrinter(%d) failed, ec=%d"), __LINE__, GetLastError() ));
        return FALSE;

    }

    GetSystemInfo( &SystemInfo );

    Size = 4096;

    DriverInfo = (LPDRIVER_INFO_2) MemAlloc( Size );
    if (!DriverInfo) {
        DebugPrint(( TEXT("Memory allocation failed, size=%d"), Size ));
        goto exit;
    }

    Rval = GetPrinterDriver(
        hPrinter,
        (LPWSTR) PrintPlatforms[SystemInfo.wProcessorArchitecture],
        2,
        (LPBYTE) DriverInfo,
        Size,
        &Size
        );
    if (!Rval) {
        DebugPrint(( TEXT("GetPrinterDriver() failed, ec=%d"), GetLastError() ));
        goto exit;
    }

    if (_tcscmp( DriverInfo->pName, FAX_DRIVER_NAME ) == 0) {
        Rval = TRUE;
    } else {
        Rval = FALSE;
    }

exit:

    MemFree( DriverInfo );
    ClosePrinter( hPrinter );
    return Rval;
}


BOOL
ReadTiffData(
    HANDLE  hTiff,
    LPBYTE  *TiffData,
    DWORD   Width,
    LPDWORD TiffDataLinesAlloc,
    DWORD   PageNumber
    )
{
    DWORD Lines = 0;


    TiffSeekToPage( hTiff, PageNumber, FILLORDER_LSB2MSB );

    TiffUncompressMmrPage( hTiff, (LPDWORD) *TiffData, &Lines );

    if (Lines > *TiffDataLinesAlloc) {

        *TiffDataLinesAlloc = Lines;

        VirtualFree( *TiffData, 0, MEM_RELEASE );

        *TiffData = (LPBYTE) VirtualAlloc(
            NULL,
            Lines * (Width / 8),
            MEM_COMMIT,
            PAGE_READWRITE
            );
        if (!*TiffData) {
            return FALSE;
        }
    }

    if (!TiffUncompressMmrPage( hTiff, (LPDWORD) *TiffData, &Lines )) {
        return FALSE;
    }

    return TRUE;
}


BOOL
TiffPrint(
    LPCTSTR  TiffFileName,
    PTCHAR  Printer
    )

/*++

Routine Description:

    Prints TIFF file.

Arguments:

    TiffFileName            - Name of TIFF file to print
    Printer                 - Printer to print to

Return Value:

    TRUE for success, FALSE on error

--*/

{
    TIFF_INFO   TiffInfo;
    HANDLE      hTiff;
    LPBYTE      TiffData = NULL;
    DWORD       i;
    PTCHAR      Device;
    HDC         PrinterDC = NULL;
    INT         HorzRes;
    INT         VertRes;
    INT         PrintJobId = 0;
    DOCINFO     DocInfo;
    BOOL        Result = FALSE;
    BOOL        IsFaxPrinter = FALSE;
    DWORD       VertResFactor = 1;

    struct {

        BITMAPINFOHEADER bmiHeader;
        RGBQUAD bmiColors[2];

    } SrcBitmapInfo = {

        {
            sizeof(BITMAPINFOHEADER),                        //  biSize
            0,                                               //  biWidth
            0,                                               //  biHeight
            1,                                               //  biPlanes
            1,                                               //  biBitCount
            BI_RGB,                                          //  biCompression
            0,                                               //  biSizeImage
            7874,                                            //  biXPelsPerMeter     - 200dpi
            7874,                                            //  biYPelsPerMeter
            0,                                               //  biClrUsed
            0,                                               //  biClrImportant
        },
        {
            {
              255,                                           //  rgbBlue
              255,                                           //  rgbGreen
              255,                                           //  rgbRed
              0                                              //  rgbReserved
            },
            {
              0,                                             //  rgbBlue
              0,                                             //  rgbGreen
              0,                                             //  rgbRed
              0                                              //  rgbReserved
            }
        }
    };


    DocInfo.cbSize = sizeof(DOCINFO);
    DocInfo.lpszDocName = TiffFileName;
    DocInfo.lpszOutput = NULL;
    DocInfo.lpszDatatype = NULL;
    DocInfo.fwType = 0;

    hTiff = TiffOpen(
        (LPWSTR) TiffFileName,
        &TiffInfo,
        TRUE,
        FILLORDER_LSB2MSB
        );

    if ( !hTiff ) {
        goto exit;
    }

    TiffData = (LPBYTE) VirtualAlloc(
        NULL,
        MAXVERTBITS * (MAXHORZBITS / 8),
        MEM_COMMIT,
        PAGE_READWRITE
        );

    if ( !TiffData ) {
        goto exit;
    }

    if( (Device = _tcstok( Printer, TEXT(","))) ) {

        if (IsFaxPrinter = IsPrinterFaxPrinter( Device )) {

            // return TRUE here so we don't try to route it to this printer again

            goto exit;

        } else {

            PrinterDC = CreateDC( TEXT("WINSPOOL"), Device, NULL, NULL );

        }

    }

    if ( !PrinterDC ) {
        goto exit;
    }

    HorzRes = GetDeviceCaps( PrinterDC, HORZRES );
    VertRes = GetDeviceCaps( PrinterDC, VERTRES );

    PrintJobId = StartDoc( PrinterDC, &DocInfo );

    if (PrintJobId <= 0) {
        goto exit;
    }

    if (TiffInfo.YResolution <= 100) {
        SrcBitmapInfo.bmiHeader.biYPelsPerMeter /= 2;
        VertResFactor = 2;
    }

    for (i = 0; i < TiffInfo.PageCount; i++)
    {
        BOOL ReadOk;
        DWORD Lines;
        DWORD StripDataSize;
        DWORD ImageWidth = TiffInfo.ImageWidth;
        DWORD ImageHeight = TiffInfo.ImageHeight;
        DWORD LinesAllocated = MAXVERTBITS;
        INT DestWidth;
        INT DestHeight;
        FLOAT       ScaleX;
        FLOAT       ScaleY;
        FLOAT       Scale;

        ReadOk = ReadTiffData(
                    hTiff,
                    &TiffData,
                    ImageWidth,
                    &LinesAllocated,
                    i + 1
                    );

        if (!ReadOk) {
            goto exit;
        }

        TiffGetCurrentPageData(
            hTiff,
            &Lines,
            &StripDataSize,
            &ImageWidth,
            &ImageHeight
            );

        ScaleX = (FLOAT) ImageWidth / (FLOAT) HorzRes;
        ScaleY = ((FLOAT) ImageHeight * VertResFactor) / (FLOAT) VertRes;

        Scale = ScaleX > ScaleY ? ScaleX : ScaleY;

        DestWidth = (int) ((FLOAT) ImageWidth / Scale);
        DestHeight = (int) (((FLOAT) ImageHeight * VertResFactor) / Scale);

        SrcBitmapInfo.bmiHeader.biWidth          = ImageWidth;
        // build a top-down DIB
        SrcBitmapInfo.bmiHeader.biHeight         = - (INT) ImageHeight;

        StartPage( PrinterDC );

        StretchDIBits(
            PrinterDC,
            0,
            0,
            DestWidth,
            DestHeight,
            0,
            0,
            ImageWidth,
            ImageHeight,
            TiffData,
            (BITMAPINFO *) &SrcBitmapInfo,
            DIB_RGB_COLORS,
            SRCCOPY
            );
        EndPage ( PrinterDC ) ;
    }

    EndDoc( PrinterDC );
    Result = TRUE;

exit:
    if (hTiff) {
        TiffClose( hTiff );
    }

    if (TiffData) {
        VirtualFree( TiffData, 0 , MEM_RELEASE );
    }

    if (PrinterDC && PrintJobId > 0) {
        EndDoc( PrinterDC );
    }

    if (PrinterDC) {
        DeleteDC( PrinterDC );
    }

    if (Result) {

        if (IsFaxPrinter) {

            FaxLog(
                FAXLOG_CATEGORY_INBOUND,
                FAXLOG_LEVEL_MIN,
                2,
                MSG_FAX_PRINT_TO_FAX,
                TiffFileName,
                Device
                );

        } else {

            FaxLog(
                FAXLOG_CATEGORY_INBOUND,
                FAXLOG_LEVEL_MAX,
                2,
                MSG_FAX_PRINT_SUCCESS,
                TiffFileName,
                Printer
                );
        }

    } else {

        FaxLog(
            FAXLOG_CATEGORY_INBOUND,
            FAXLOG_LEVEL_MIN,
            3,
            MSG_FAX_PRINT_FAILED,
            TiffFileName,
            Printer,
            GetLastErrorText(GetLastError())
            );
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\faxmapi\util.cpp ===
#include "faxmapip.h"
#pragma hdrstop



typedef struct _STRING_TABLE {
    DWORD   ResourceId;
    DWORD   InternalId;
    LPTSTR  String;
} STRING_TABLE, *PSTRING_TABLE;


static STRING_TABLE StringTable[] =
{
    { IDS_NO_MAPI_LOGON,        IDS_NO_MAPI_LOGON,       NULL },
    { IDS_DEFAULT,              IDS_DEFAULT,             NULL }
};

#define CountStringTable (sizeof(StringTable)/sizeof(STRING_TABLE))




LPTSTR
GetLastErrorText(
    DWORD ErrorCode
    )

/*++

Routine Description:

    Gets a string for a given WIN32 error code.

Arguments:

    ErrorCode   - WIN32 error code.

Return Value:

    Pointer to a string representing the ErrorCode.

--*/

{
    static TCHAR ErrorBuf[256];
    DWORD Count;

    Count = FormatMessage(
        FORMAT_MESSAGE_FROM_SYSTEM |FORMAT_MESSAGE_ARGUMENT_ARRAY,
        NULL,
        ErrorCode,
        LANG_NEUTRAL,
        ErrorBuf,
        sizeof(ErrorBuf),
        NULL
        );

    if (Count) {
        if (ErrorBuf[Count-1] == TEXT('\n')) {
            ErrorBuf[Count-1] = 0;
        }
        if ((Count>1) && (ErrorBuf[Count-2] == TEXT('\r'))) {
            ErrorBuf[Count-2] = 0;
        }
    }

    return ErrorBuf;
}


VOID
InitializeStringTable(
    VOID
    )
{
    DWORD i;
    TCHAR Buffer[256];



    for (i=0; i<CountStringTable; i++) {

        if (LoadString(
            MyhInstance,
            StringTable[i].ResourceId,
            Buffer,
            sizeof(Buffer)/sizeof(TCHAR)
            )) {

            StringTable[i].String = (LPTSTR) MemAlloc( StringSize( Buffer ) );
            if (!StringTable[i].String) {
                StringTable[i].String = TEXT("");
            } else {
                _tcscpy( StringTable[i].String, Buffer );
            }

        } else {

            StringTable[i].String = TEXT("");

        }
    }
}


LPTSTR
GetString(
    DWORD InternalId
    )

/*++

Routine Description:

    Loads a resource string and returns a pointer to the string.
    The caller must free the memory.

Arguments:

    ResourceId      - resource string id

Return Value:

    pointer to the string

--*/

{
    DWORD i;

    for (i=0; i<CountStringTable; i++) {
        if (StringTable[i].InternalId == InternalId) {
            return StringTable[i].String;
        }
    }

    return NULL;
}

BOOL
MyInitializeMapi(
)
{
    HKEY    hKey = NULL;
    LPTSTR  szNoMailClient = NULL;
    LPTSTR  szPreFirstRun = NULL;
    BOOL    bRslt = FALSE;

    hKey = OpenRegistryKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Clients\\Mail"), FALSE, KEY_ALL_ACCESS);
    if (hKey != NULL) {
        szNoMailClient = GetRegistryString(hKey, TEXT("NoMailClient"), TEXT(""));

        if (_tcscmp(szNoMailClient, TEXT("")) == 0) {
            MemFree(szNoMailClient);
            szNoMailClient = NULL;
        }
        else {
            RegDeleteValue(hKey, TEXT("NoMailClient"));
        }

        szPreFirstRun = GetRegistryString(hKey, TEXT("PreFirstRun"), TEXT(""));

        if (_tcscmp(szPreFirstRun, TEXT("")) == 0) {
            MemFree(szPreFirstRun);
            szPreFirstRun = NULL;
        }
        else {
            RegDeleteValue(hKey, TEXT("PreFirstRun"));
        }

    }

    bRslt = InitializeMapi();

    if (szNoMailClient != NULL) {
        SetRegistryString(hKey, TEXT("NoMailClient"), szNoMailClient);

        MemFree(szNoMailClient);
    }

    if (szPreFirstRun != NULL) {
        SetRegistryString(hKey, TEXT("PreFirstRun"), szPreFirstRun);

        MemFree(szPreFirstRun);
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return bRslt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\faxroute\routing.cpp ===
#include "faxrtp.h"
#pragma hdrstop


LIST_ENTRY          RoutingListHead;
CRITICAL_SECTION    CsRouting;
LPCWSTR             InboundProfileName;


DWORD
GetMaskBit(
    LPCWSTR RoutingGuid
    )
{
    if (_tcsicmp( RoutingGuid, REGVAL_RM_EMAIL_GUID ) == 0) {
        return LR_EMAIL;
    } else if (_tcsicmp( RoutingGuid, REGVAL_RM_FOLDER_GUID ) == 0) {
        return LR_STORE;
    } else if (_tcsicmp( RoutingGuid, REGVAL_RM_INBOX_GUID ) == 0) {
        return LR_INBOX;
    } else if (_tcsicmp( RoutingGuid, REGVAL_RM_PRINTING_GUID ) == 0) {
        return LR_PRINT;
    }
    return 0;
}


BOOL
AddNewDeviceToRoutingTable(
    DWORD DeviceId,
    LPCWSTR DeviceName,
    LPCWSTR Csid,
    LPCWSTR Tsid,
    LPCWSTR PrinterName,
    LPCWSTR StoreDir,
    LPCWSTR ProfileName,
    DWORD Mask
    )
{
    PROUTING_TABLE RoutingEntry = (PROUTING_TABLE) MemAlloc( sizeof(ROUTING_TABLE) );
    if (!RoutingEntry) {
        return FALSE;
    }

    RoutingEntry->DeviceId    = DeviceId;
    RoutingEntry->DeviceName  = DeviceName;
    RoutingEntry->Csid        = Csid;
    RoutingEntry->Tsid        = Tsid;
    RoutingEntry->PrinterName = PrinterName;
    RoutingEntry->StoreDir    = StoreDir;
    RoutingEntry->ProfileName = ProfileName;
    RoutingEntry->Mask        = Mask;

    InsertTailList( &RoutingListHead, &RoutingEntry->ListEntry );

    return TRUE;
}


BOOL
FaxDeviceEnumerator(
    HKEY hSubKey,
    LPWSTR SubKeyName,
    DWORD Index,
    PVOID Context
    )
{
    if (!SubKeyName) {
        return TRUE;
    }

    //
    // try to enumerate the routing information under a device node.
    // NOTE: if we fail to enumerate the routing information, we return TRUE, instead of 
    // FALSE, as would be expected.  This means that we will still initialize our routing
    // extension correctly, but we just won't be able to route to certain (probably bogus)
    // devices


    HKEY hKeyRouting = OpenRegistryKey( hSubKey, REGKEY_ROUTING, FALSE, KEY_READ );
    if (!hKeyRouting) {
        DebugPrint(( TEXT("InitializeRoutingTable(): could not open routing registry key") ));
        return TRUE;
    }

    AddNewDeviceToRoutingTable(
        GetRegistryDword ( hSubKey, REGVAL_PERMANENT_LINEID ),
        GetRegistryString( hSubKey, REGVAL_DEVICE_NAME,  EMPTY_STRING ),
        GetRegistryString( hSubKey, REGVAL_ROUTING_CSID, EMPTY_STRING ),
        GetRegistryString( hSubKey, REGVAL_ROUTING_TSID, EMPTY_STRING ),
        GetRegistryString( hKeyRouting, REGVAL_ROUTING_PRINTER, EMPTY_STRING ),
        GetRegistryString( hKeyRouting, REGVAL_ROUTING_DIR,     EMPTY_STRING ),
        GetRegistryString( hKeyRouting, REGVAL_ROUTING_PROFILE, EMPTY_STRING ),
        GetRegistryDword ( hKeyRouting, REGVAL_ROUTING_MASK )
        );

    RegCloseKey( hKeyRouting );

    return TRUE;
}


BOOL
InitializeRoutingTable(
    VOID
    )
{
    InitializeListHead( &RoutingListHead );
    InitializeCriticalSection( &CsRouting );

    HKEY hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_FAXSERVER, FALSE, KEY_READ );
    if (!hKey) {
        DebugPrint(( TEXT("InitializeRoutingTable(): could not open registry key") ));
        return FALSE;
    }

    InboundProfileName = GetRegistryString( hKey, REGVAL_INBOUND_PROFILE, EMPTY_STRING );
    if (!InboundProfileName) {
        DebugPrint(( TEXT("InitializeRoutingTable(): could not read inbound profile name") ));
    }

    RegCloseKey( hKey );

    if (!EnumerateRegistryKeys( HKEY_LOCAL_MACHINE, REGKEY_FAX_DEVICES, FALSE, FaxDeviceEnumerator, NULL )) {
        DebugPrint(( TEXT("InitializeRoutingTable(): could not enumerate fax devices") ));
        return FALSE;
    }

    return TRUE;
}


BOOL
UpdateRoutingInfoRegistry(
    PROUTING_TABLE RoutingEntry
    )
{
    WCHAR KeyName[256];


    swprintf( KeyName, L"%s\\%08d\\%s", REGKEY_FAX_DEVICES, RoutingEntry->DeviceId, REGKEY_ROUTING );

    HKEY hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, KeyName, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        Assert(( ! TEXT("InitializeRoutingTable(): could not open registry key") ));
        return FALSE;
    }

    SetRegistryString( hKey, REGVAL_ROUTING_PRINTER, RoutingEntry->PrinterName );
    SetRegistryString( hKey, REGVAL_ROUTING_DIR,     RoutingEntry->StoreDir    );
    SetRegistryString( hKey, REGVAL_ROUTING_PROFILE, RoutingEntry->ProfileName );

    SetRegistryDword( hKey, REGVAL_ROUTING_MASK, RoutingEntry->Mask );

    RegCloseKey( hKey );

    return TRUE;
}


PROUTING_TABLE
GetRoutingEntry(
    DWORD DeviceId
    )
{
    PLIST_ENTRY Next;
    PROUTING_TABLE RoutingEntry;


    Next = RoutingListHead.Flink;
    if (Next) {
        while (Next != &RoutingListHead) {
            RoutingEntry = CONTAINING_RECORD( Next, ROUTING_TABLE, ListEntry );
            Next = RoutingEntry->ListEntry.Flink;
            if (RoutingEntry->DeviceId == DeviceId) {
                return RoutingEntry;
            }
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\faxroute\faxroute.cpp ===
#include "faxrtp.h"
#pragma hdrstop


HINSTANCE           MyhInstance;
BOOL                ServiceDebug;
WCHAR               FaxReceiveDir[MAX_PATH];
PSID                ServiceSid;

PFAXROUTEADDFILE    FaxRouteAddFile;
PFAXROUTEDELETEFILE FaxRouteDeleteFile;
PFAXROUTEGETFILE    FaxRouteGetFile;
PFAXROUTEENUMFILES  FaxRouteEnumFiles;



BOOL
MakeServiceSid(
    VOID
    )
{
    SID_IDENTIFIER_AUTHORITY    NtAuthority = SECURITY_NT_AUTHORITY;
    BOOL Result;

    //
    // Output allocated via RtlAllocateHeap, free with FreeHeap?
    //

    Result = AllocateAndInitializeSid(
        &NtAuthority,
        1,
        SECURITY_SERVICE_RID,
        0, 0, 0, 0, 0, 0, 0,
        &ServiceSid
        );
    if (!Result) {
        ServiceSid = NULL;
    }

    return Result;
}



extern "C"
DWORD
FaxRouteDllInit(
    HINSTANCE hInstance,
    DWORD     Reason,
    LPVOID    Context
    )
{
    if (Reason == DLL_PROCESS_ATTACH) {
        MyhInstance = hInstance;
        DisableThreadLibraryCalls( hInstance );
        MakeServiceSid();
    }

    return TRUE;
}


BOOL
IsUserService(
    VOID
    )
{
    BOOL Result,UserService = FALSE;
    
    Result = CheckTokenMembership( NULL, ServiceSid, &UserService );

    if (!Result) {
        DebugPrint(( TEXT("Couldn't CheckTokenMembership, ec = %d\n"), GetLastError() ));
   
    }                

    return UserService;
}


BOOL WINAPI
FaxRouteInitialize(
    IN HANDLE HeapHandle,
    IN PFAX_ROUTE_CALLBACKROUTINES FaxRouteCallbackRoutines
    )
{
    HeapInitialize(HeapHandle,NULL,NULL,0);

    FaxRouteAddFile    = FaxRouteCallbackRoutines->FaxRouteAddFile;
    FaxRouteDeleteFile = FaxRouteCallbackRoutines->FaxRouteDeleteFile;
    FaxRouteGetFile    = FaxRouteCallbackRoutines->FaxRouteGetFile;
    FaxRouteEnumFiles  = FaxRouteCallbackRoutines->FaxRouteEnumFiles;

    ServiceDebug = !IsUserService();

    if (!GetSpecialPath(CSIDL_COMMON_APPDATA, FaxReceiveDir)) {
       DebugPrint(( TEXT("Couldn't GetSpecialPath, ec = %d\n"), GetLastError() ));
       return FALSE;
    }

    ConcatenatePaths( FaxReceiveDir, FAX_RECEIVE_DIR );
    
    InitializeStringTable();
    InitializeRoutingTable();
    InitializeEmailRouting();

    return TRUE;
}


BOOL WINAPI
FaxRouteGetRoutingInfo(
    IN  LPCWSTR RoutingGuid,
    IN  DWORD DeviceId,
    IN  LPBYTE RoutingInfo,
    OUT LPDWORD RoutingInfoSize
    )
{
    if (RoutingInfoSize == NULL) {
        return FALSE;
    }

    PROUTING_TABLE RoutingEntry = GetRoutingEntry( DeviceId );
    if (!RoutingEntry) {
        return FALSE;
    }

    DWORD Size;

    switch( GetMaskBit( RoutingGuid )) {
        case 0:
            return FALSE;

        case LR_PRINT:
            Size = sizeof(DWORD) + StringSize( RoutingEntry->PrinterName );
            if (RoutingInfo == NULL) {
                *RoutingInfoSize = Size;
                return TRUE;
            }
            if (Size > *RoutingInfoSize) {
                return FALSE;
            }
            *((LPDWORD)RoutingInfo) = (RoutingEntry->Mask & LR_PRINT) > 0;
            RoutingInfo += sizeof(DWORD);
            wcscpy( (LPWSTR)RoutingInfo, RoutingEntry->PrinterName );
            return TRUE;

        case LR_STORE:
            Size = sizeof(DWORD) + StringSize( RoutingEntry->StoreDir );
            if (RoutingInfo == NULL) {
                *RoutingInfoSize = Size;
                return TRUE;
            }
            if (Size > *RoutingInfoSize) {
                return FALSE;
            }
            *((LPDWORD)RoutingInfo) = (RoutingEntry->Mask & LR_STORE) > 0;
            RoutingInfo += sizeof(DWORD);
            wcscpy( (LPWSTR)RoutingInfo, RoutingEntry->StoreDir );
            return TRUE;

        case LR_INBOX:
            Size = sizeof(DWORD) + StringSize( RoutingEntry->ProfileName );
            if (RoutingInfo == NULL) {
                *RoutingInfoSize = Size;
                return TRUE;
            }
            if (Size > *RoutingInfoSize) {
                return FALSE;
            }
            *((LPDWORD)RoutingInfo) = (RoutingEntry->Mask & LR_INBOX) > 0;
            RoutingInfo += sizeof(DWORD);
            wcscpy( (LPWSTR)RoutingInfo, RoutingEntry->ProfileName );
            return TRUE;

        case LR_EMAIL:
            Size = sizeof(DWORD) + StringSize( RoutingEntry->ProfileName );
            if (RoutingInfo == NULL) {
                *RoutingInfoSize = Size;
                return TRUE;
            }
            if (Size > *RoutingInfoSize) {
                return FALSE;
            }
            *((LPDWORD)RoutingInfo) = (RoutingEntry->Mask & LR_EMAIL) > 0;
            RoutingInfo += sizeof(DWORD);
            wcscpy( (LPWSTR)RoutingInfo, RoutingEntry->ProfileName );
            return TRUE;
    }

    return FALSE;
}


BOOL WINAPI
FaxRouteSetRoutingInfo(
    IN  LPCWSTR RoutingGuid,
    IN  DWORD DeviceId,
    IN  const BYTE *RoutingInfo,
    IN  DWORD RoutingInfoSize
    )
{
    if (RoutingInfoSize == 0 || RoutingInfo == NULL) {
        return FALSE;
    }

    PROUTING_TABLE RoutingEntry = GetRoutingEntry( DeviceId );
    if (!RoutingEntry) {
        return FALSE;
    }

    switch( GetMaskBit( RoutingGuid ) ) {
        case 0:
            return FALSE;

        case LR_PRINT:
            if (*((LPDWORD)RoutingInfo)) {
                RoutingEntry->Mask |= LR_PRINT;
                MemFree( (LPBYTE) RoutingEntry->PrinterName );
                RoutingInfo += sizeof(DWORD);
                RoutingEntry->PrinterName = StringDup( (LPWSTR)RoutingInfo );
            } else {
                RoutingEntry->Mask &= ~LR_PRINT;
            }
            UpdateRoutingInfoRegistry( RoutingEntry );
            return TRUE;

        case LR_STORE:
            if (*((LPDWORD)RoutingInfo)) {
                RoutingEntry->Mask |= LR_STORE;
                MemFree( (LPBYTE) RoutingEntry->StoreDir );
                RoutingInfo += sizeof(DWORD);
                RoutingEntry->StoreDir = StringDup( (LPWSTR)RoutingInfo );
            } else {
                RoutingEntry->Mask &= ~LR_STORE;
            }
            UpdateRoutingInfoRegistry( RoutingEntry );
            return TRUE;

        case LR_INBOX:
            if (*((LPDWORD)RoutingInfo)) {
                RoutingEntry->Mask |= LR_INBOX;
                MemFree( (LPBYTE) RoutingEntry->ProfileName );
                RoutingInfo += sizeof(DWORD);
                RoutingEntry->ProfileName = StringDup( (LPWSTR)RoutingInfo );
                RoutingEntry->ProfileInfo = AddNewMapiProfile( RoutingEntry->ProfileName, FALSE, TRUE );
            } else {
                RoutingEntry->Mask &= ~LR_INBOX;
            }
            UpdateRoutingInfoRegistry( RoutingEntry );
            return TRUE;

        case LR_EMAIL:
            if (*((LPDWORD)RoutingInfo)) {
                RoutingEntry->Mask |= LR_EMAIL;
                MemFree( (LPBYTE) RoutingEntry->ProfileName );
                RoutingInfo += sizeof(DWORD);
                RoutingEntry->ProfileName = StringDup( (LPWSTR)RoutingInfo );
            } else {
                RoutingEntry->Mask &= ~LR_EMAIL;
            }
            UpdateRoutingInfoRegistry( RoutingEntry );
            return TRUE;
    }

    return FALSE;
}


BOOL WINAPI
FaxRoutePrint(
    const FAX_ROUTE *FaxRoute,
    PVOID *FailureData,
    LPDWORD FailureDataSize
    )
{
    PROUTING_TABLE RoutingEntry;
    WCHAR NameBuffer[MAX_PATH];
    LPCWSTR FBaseName;
    WCHAR TiffFileName[MAX_PATH];
    DWORD Size;



    RoutingEntry = GetRoutingEntry( FaxRoute->DeviceId );
    if (!RoutingEntry) {
        return FALSE;
    }

    if (!(RoutingEntry->Mask & LR_PRINT)) {
        return TRUE;
    }

    Size = sizeof(TiffFileName);
    if (!FaxRouteGetFile(
        FaxRoute->JobId,
        1,
        TiffFileName,
        &Size))
    {
        return FALSE;
    }

    //
    // print the fax in requested to do so
    //

    if (!RoutingEntry->PrinterName[0]) {
        GetProfileString( L"windows",
            L"device",
            L",,,",
            (LPWSTR) &NameBuffer,
            MAX_PATH
            );
        FBaseName = NameBuffer;
    } else {
        FBaseName = RoutingEntry->PrinterName;
    }

    return TiffPrint( TiffFileName, (LPTSTR)FBaseName );
}


BOOL WINAPI
FaxRouteStore(
    const FAX_ROUTE *FaxRoute,
    PVOID *FailureData,
    LPDWORD FailureDataSize
    )
{
    PROUTING_TABLE RoutingEntry;
    WCHAR TiffFileName[MAX_PATH];
    DWORD Size;
    LPTSTR FullPath = NULL;
    DWORD StrCount;


    RoutingEntry = GetRoutingEntry( FaxRoute->DeviceId );
    if (!RoutingEntry) {
        return FALSE;
    }

    if (((RoutingEntry->Mask & LR_STORE) == 0) || (RoutingEntry->StoreDir[0] == 0)) {
        return TRUE;
    }

    Size = sizeof(TiffFileName);
    if (!FaxRouteGetFile(
        FaxRoute->JobId,
        1,
        TiffFileName,
        &Size))
    {
        return FALSE;
    }

    StrCount = ExpandEnvironmentStrings( RoutingEntry->StoreDir, FullPath, 0 );
    FullPath = (LPWSTR) MemAlloc( StrCount * sizeof(WCHAR) );
    if (!FullPath) {
        return FALSE;
    }

    
    ExpandEnvironmentStrings( RoutingEntry->StoreDir, FullPath, StrCount );

    // if we are moving the fax to the directory that is was received into, do nothing to the file

    if (_wcsicmp( FullPath, FaxReceiveDir ) == 0) {
        FaxLog(
            FAXLOG_CATEGORY_INBOUND,
            FAXLOG_LEVEL_MAX,
            2,
            MSG_FAX_SAVE_SUCCESS,
            TiffFileName,
            TiffFileName
            );
    } else if (!FaxMoveFile ( TiffFileName, FullPath )) {
        MemFree( FullPath );
        return FALSE;
    }

    MemFree( FullPath );   

    return TRUE;
}


BOOL WINAPI
FaxRouteInBox(
    const FAX_ROUTE *FaxRoute,
    PVOID *FailureData,
    LPDWORD FailureDataSize
    )
{
    PROUTING_TABLE RoutingEntry;
    WCHAR TiffFileName[MAX_PATH];
    DWORD Size;
    LPTSTR FullPath = NULL;


    RoutingEntry = GetRoutingEntry( FaxRoute->DeviceId );
    if (!RoutingEntry) {
        return FALSE;
    }

    if (((RoutingEntry->Mask & LR_INBOX) == 0) || (RoutingEntry->ProfileName[0] == 0)) {
        return TRUE;
    }

    Size = sizeof(TiffFileName);
    if (!FaxRouteGetFile(
        FaxRoute->JobId,
        1,
        TiffFileName,
        &Size))
    {
        return FALSE;
    }

    if (TiffMailDefault( FaxRoute, RoutingEntry, TiffFileName )) {
        FaxLog(
            FAXLOG_CATEGORY_INBOUND,
            FAXLOG_LEVEL_MAX,
            2,
            MSG_FAX_INBOX_SUCCESS,
            TiffFileName,
            GetProfileName( RoutingEntry->ProfileInfo )
            );

    } else {

        FaxLog(
            FAXLOG_CATEGORY_INBOUND,
            FAXLOG_LEVEL_MIN,
            2,
            MSG_FAX_INBOX_FAILED,
            TiffFileName,
            GetProfileName( RoutingEntry->ProfileInfo )
            );

        return FALSE;
    }

    return TRUE;
}


BOOL WINAPI
FaxRouteEmail(
    const FAX_ROUTE *FaxRoute,
    PVOID *FailureData,
    LPDWORD FailureDataSize
    )
{
    PROUTING_TABLE RoutingEntry;
    WCHAR TiffFileName[MAX_PATH];
    DWORD Size;
    LPTSTR FullPath = NULL;


    RoutingEntry = GetRoutingEntry( FaxRoute->DeviceId );
    if (!RoutingEntry) {
        return FALSE;
    }

    if (((RoutingEntry->Mask & LR_EMAIL) == 0) || (RoutingEntry->ProfileName[0] == 0)) {
        return TRUE;
    }

    Size = sizeof(TiffFileName);
    if (!FaxRouteGetFile(
        FaxRoute->JobId,
        1,
        TiffFileName,
        &Size))
    {
        return FALSE;
    }

    if (TiffRouteEMail( FaxRoute, RoutingEntry, TiffFileName )) {

        FaxLog(
            FAXLOG_CATEGORY_INBOUND,
            FAXLOG_LEVEL_MAX,
            2,
            MSG_FAX_INBOX_SUCCESS,
            TiffFileName,
            GetProfileName( InboundProfileInfo )
            );

    } else {

        FaxLog(
            FAXLOG_CATEGORY_INBOUND,
            FAXLOG_LEVEL_MIN,
            2,
            MSG_FAX_INBOX_FAILED,
            TiffFileName,
            GetProfileName( InboundProfileInfo )
            );

        return FALSE;
    }

    return TRUE;
}


BOOL WINAPI
FaxRouteConfigure(
    OUT HPROPSHEETPAGE *PropSheetPage
    )
{
    return TRUE;
}


BOOL WINAPI
FaxRouteDeviceEnable(
    IN  LPCWSTR RoutingGuid,
    IN  DWORD DeviceId,
    IN  LONG Enabled
    )
{
    PROUTING_TABLE RoutingEntry = GetRoutingEntry( DeviceId );
    if (!RoutingEntry) {
        return FALSE;
    }

    DWORD MaskBit = GetMaskBit( RoutingGuid );
    if (MaskBit == 0) {
        return FALSE;
    }

    BOOL DeviceEnabled = (RoutingEntry->Mask & MaskBit) > 0;
    if (Enabled == -1) {
        return DeviceEnabled;
    }
    RoutingEntry->Mask &= ~MaskBit;
    if (Enabled) {
        RoutingEntry->Mask |= MaskBit;
    }
    UpdateRoutingInfoRegistry( RoutingEntry );
    return TRUE;
}


BOOL WINAPI
FaxRouteDeviceChangeNotification(
    IN  DWORD DeviceId,
    IN  BOOL  NewDevice
    )
{
    HKEY hKey;
    HKEY hKeyRouting;
    WCHAR SubKeyName[128];


    if (!NewDevice) {
        return TRUE;
    }

    PROUTING_TABLE RoutingEntry = GetRoutingEntry( DeviceId );
    if (RoutingEntry) {
        return TRUE;
    }

    wsprintf( SubKeyName, L"%s\\%08d", REGKEY_FAX_DEVICES, DeviceId );

    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, SubKeyName, FALSE, KEY_READ );
    if (!hKey) {
        return FALSE;
    }

    hKeyRouting = OpenRegistryKey( hKey, REGKEY_ROUTING, FALSE, KEY_READ );
    if (!hKeyRouting) {
        RegCloseKey( hKey );
        return FALSE;
    }

    AddNewDeviceToRoutingTable(
        GetRegistryDword ( hKey, REGVAL_PERMANENT_LINEID ),
        GetRegistryString( hKey, REGVAL_DEVICE_NAME,  EMPTY_STRING ),
        GetRegistryString( hKey, REGVAL_ROUTING_CSID, EMPTY_STRING ),
        GetRegistryString( hKey, REGVAL_ROUTING_TSID, EMPTY_STRING ),
        GetRegistryString( hKeyRouting, REGVAL_ROUTING_PRINTER, EMPTY_STRING ),
        GetRegistryString( hKeyRouting, REGVAL_ROUTING_DIR,     EMPTY_STRING ),
        GetRegistryString( hKeyRouting, REGVAL_ROUTING_PROFILE, EMPTY_STRING ),
        GetRegistryDword ( hKeyRouting, REGVAL_ROUTING_MASK )
        );

    RegCloseKey( hKeyRouting );
    RegCloseKey( hKey );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\faxroute\email.cpp ===
#include "faxrtp.h"
#pragma hdrstop

LPVOID              InboundProfileInfo;




BOOL
InitializeEmailRouting(
    VOID
    )
{
    PLIST_ENTRY Next;
    PROUTING_TABLE RoutingEntry;


    //
    // initialize the profiles
    //

    EnterCriticalSection( &CsRouting );

    if (InboundProfileName && InboundProfileName[0]) {
        InboundProfileInfo = AddNewMapiProfile( InboundProfileName, TRUE, TRUE );
        if (!InboundProfileInfo) {
            DebugPrint(( TEXT("Could not initialize inbound mapi profile [%s]"), InboundProfileName ));
        }
    }

    Next = RoutingListHead.Flink;
    if (Next) {
        while ((ULONG)Next != (ULONG)&RoutingListHead) {
            RoutingEntry = CONTAINING_RECORD( Next, ROUTING_TABLE, ListEntry );
            Next = RoutingEntry->ListEntry.Flink;
            if (RoutingEntry->Mask & LR_INBOX && RoutingEntry->ProfileName && RoutingEntry->ProfileName[0]) {
                RoutingEntry->ProfileInfo = AddNewMapiProfile( RoutingEntry->ProfileName, FALSE, TRUE );
            }
        }
    }

    LeaveCriticalSection( &CsRouting );

    return TRUE;
}


BOOL
TiffMailDefault(
    PFAX_ROUTE FaxRoute,
    PROUTING_TABLE RoutingEntry
    )

/*++

Routine Description:

    Mails a TIFF file to the inbox in the specified profile.

Arguments:

    TiffFileName            - Name of TIFF file to mail
    ProfileName             - Profile name to use
    ResultCode              - The result of the failed API call

Return Value:

    TRUE for success, FALSE on error

--*/

{
    LPTSTR          BodyStr = NULL;
    BOOL            Failed = FALSE;
    DWORD           MsgCount;
    LPDWORD         MsgPtr[6];
    TCHAR           MsgStr[2048];
    TCHAR           PageCountStr[64];
    LPTSTR          SenderStr = NULL;
    LPTSTR          SubjectStr = NULL;
    LPTSTR          RecipStr = NULL;
    TCHAR           TimeStr[128];
    ULONG           ResultCode;


    if (!RoutingEntry->ProfileInfo) {
        ResultCode = ERROR_NO_SUCH_LOGON_SESSION;
        return FALSE;
    }

    ResultCode = ERROR_SUCCESS;

    FormatElapsedTimeStr(
        (FILETIME*)&FaxRoute->ElapsedTime,
        TimeStr,
        sizeof(TimeStr)
        );

    _ltot( (LONG) FaxRoute->PageCount, PageCountStr, 10 );

    MsgPtr[0] = (LPDWORD) FaxRoute->Csid;
    MsgPtr[1] = (LPDWORD) FaxRoute->CallerId;

    if (!FaxRoute->RoutingInfo || !FaxRoute->RoutingInfo[0]) {
        RecipStr = FaxRoute->Csid ? FaxRoute->Csid : TEXT("");
    } else {
        RecipStr = FaxRoute->RoutingInfo;
    }

    MsgPtr[2] = (LPDWORD) RecipStr;
    MsgPtr[3] = (LPDWORD) PageCountStr;
    MsgPtr[4] = (LPDWORD) TimeStr;
    MsgPtr[5] = (LPDWORD) FaxRoute->DeviceName;

    MsgCount = FormatMessage(
        FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
        NULL,
        MSG_MAIL_MSG_BODY,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
        MsgStr,
        sizeof(MsgStr),
        (va_list *) MsgPtr
        );

    BodyStr = StringDup( MsgStr );

    if (FaxRoute->Csid != NULL && FaxRoute->Csid[0] != 0) {
        SenderStr = StringDup( FaxRoute->Csid );
    } else {
        MsgCount = FormatMessage(
            FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
            NULL,
            MSG_WHO_AM_I,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
            MsgStr,
            sizeof(MsgStr),
            NULL
            );
        if (MsgCount != 0) {
            SenderStr = StringDup(MsgStr);
        }
    }

    MsgCount = FormatMessage(
        FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
        NULL,
        MSG_SUBJECT_LINE,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
        MsgStr,
        sizeof(MsgStr),
        NULL
        );
    if (MsgCount != 0) {
        SubjectStr = StringDup( MsgStr );
    }

    Failed = StoreMapiMessage(
        RoutingEntry->ProfileInfo,
        SenderStr,
        SubjectStr,
        BodyStr,
        FaxRoute->FileName,
        NULL,
        IMPORTANCE_NORMAL,
        NULL,
        &ResultCode
        );

    MemFree( BodyStr );
    MemFree( SubjectStr );
    MemFree( SenderStr );

    return Failed;
}


BOOL
TiffRouteEMail(
    PFAX_ROUTE FaxRoute,
    PROUTING_TABLE RoutingEntry
    )

/*++

Routine Description:

    Mails a TIFF file to the inbox in the specified profile.

Arguments:

    TiffFileName            - Name of TIFF file to mail
    ProfileName             - Profile name to use
    ResultCode              - The result of the failed API call

Return Value:

    TRUE for success, FALSE on error

--*/

{
    LPWSTR          BodyStr = NULL;
    BOOL            Failed = FALSE;
    DWORD           MsgCount;
    LPDWORD         MsgPtr[6];
    WCHAR           MsgStr[2048];
    WCHAR           PageCountStr[64];
    LPWSTR          SenderStr = NULL;
    LPWSTR          SubjectStr = NULL;
    WCHAR           TimeStr[128];
    LPWSTR          RecipientName = NULL;
    LPWSTR          ProxyAddress = NULL;
    ULONG           ResultCode;


    if (!InboundProfileInfo) {
        ResultCode = ERROR_NO_SUCH_LOGON_SESSION;
        return FALSE;
    }

    if (FaxRoute->RoutingInfo && FaxRoute->RoutingInfo[0]) {
        RecipientName = FaxRoute->RoutingInfo;
    } else if (FaxRoute->Csid && FaxRoute->Csid[0]) {
        RecipientName = FaxRoute->Csid;
    }

    if (!RecipientName) {
        return FALSE;
    }

    ProxyAddress = (LPTSTR) MemAlloc( StringSize( RecipientName ) + 32 );
    if (!ProxyAddress) {
        return FALSE;
    }

    _stprintf( ProxyAddress, TEXT("FAX:FAX[%s]"), RecipientName );

    ResultCode = ERROR_SUCCESS;

    FormatElapsedTimeStr(
        (FILETIME*)&FaxRoute->ElapsedTime,
        TimeStr,
        sizeof(TimeStr)
        );

    _ltot( (LONG) FaxRoute->PageCount, PageCountStr, 10 );

    MsgPtr[0] = (LPDWORD) FaxRoute->Csid;
    MsgPtr[1] = (LPDWORD) FaxRoute->CallerId;
    MsgPtr[2] = (LPDWORD) (FaxRoute->RoutingInfo ? FaxRoute->RoutingInfo : TEXT(""));
    MsgPtr[3] = (LPDWORD) PageCountStr;
    MsgPtr[4] = (LPDWORD) TimeStr;
    MsgPtr[5] = (LPDWORD) FaxRoute->DeviceName;

    MsgCount = FormatMessage(
        FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
        NULL,
        MSG_MAIL_MSG_BODY,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
        MsgStr,
        sizeof(MsgStr),
        (va_list *) MsgPtr
        );

    BodyStr = StringDup( MsgStr );

    if (FaxRoute->Csid != NULL && FaxRoute->Csid[0] != 0) {
        SenderStr = StringDup( FaxRoute->Csid );
    } else {
        MsgCount = FormatMessage(
            FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
            NULL,
            MSG_WHO_AM_I,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
            MsgStr,
            sizeof(MsgStr),
            NULL
            );
        if (MsgCount != 0) {
            SenderStr = StringDup(MsgStr);
        }
    }

    MsgCount = FormatMessage(
        FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
        NULL,
        MSG_SUBJECT_LINE,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
        MsgStr,
        sizeof(MsgStr),
        NULL
        );
    if (MsgCount != 0) {
        SubjectStr = StringDup( MsgStr );
    }

    Failed = MailMapiMessage(
        InboundProfileInfo,
        ProxyAddress,
        SubjectStr,
        BodyStr,
        FaxRoute->FileName,
        NULL,
        IMPORTANCE_NORMAL,
        &ResultCode
        );

    MemFree( BodyStr );
    MemFree( SubjectStr );
    MemFree( SenderStr );
    MemFree( ProxyAddress );

    return Failed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\faxroute\faxrtp.h ===
#include <windows.h>
#include <winspool.h>
#include <mapi.h>
#include <mapix.h>
#include <tchar.h>
#include <shlobj.h>
#include <faxroute.h>
#include "tifflib.h"
#include "tiff.h"
#include "faxutil.h"
#include "messages.h"
#include "faxrtmsg.h"
#include "winfax.h"
#include "resource.h"
#include "faxreg.h"
#include "faxsvcrg.h"
#include "faxmapi.h"
#include "faxevent.h"


#define FAX_DRIVER_NAME             TEXT("Windows NT Fax Driver")
#define WM_MAPILOGON                (WM_USER + 100)
#define MAXMAPIPROFILENAME          65


typedef struct _ROUTING_TABLE {
    LIST_ENTRY      ListEntry;
    DWORD           DeviceId;
    LPCWSTR         DeviceName;
    LPCWSTR         PrinterName;
    LPCWSTR         ProfileName;
    LPCWSTR         StoreDir;
    LPCWSTR         Csid;
    LPCWSTR         Tsid;
    LPVOID          ProfileInfo;
    DWORD           Mask;
} ROUTING_TABLE, *PROUTING_TABLE;


typedef struct _MESSAGEBOX_DATA {
    LPCTSTR              Text;                      //
    LPDWORD             Response;                   //
    DWORD               Type;                       //
} MESSAGEBOX_DATA, *PMESSAGEBOX_DATA;


extern HINSTANCE           MyhInstance;
extern BOOL                ServiceDebug;
extern LPCWSTR             InboundProfileName;
extern LPVOID              InboundProfileInfo;
extern LIST_ENTRY          RoutingListHead;
extern CRITICAL_SECTION    CsRouting;




VOID
InitializeStringTable(
    VOID
    );

BOOL
InitializeEmailRouting(
    VOID
    );

LPTSTR
GetLastErrorText(
    DWORD ErrorCode
    );

BOOL
TiffPrint(
    LPCTSTR TiffFileName,
    PTCHAR  Printer
    );

BOOL
FaxMoveFile(
    LPCTSTR  TiffFileName,
    LPCTSTR  DestDir
    );

LPCTSTR
GetString(
    DWORD InternalId
    );

BOOL
TiffMailDefault(
    const FAX_ROUTE *FaxRoute,
    PROUTING_TABLE RoutingEntry,
    LPCWSTR TiffFileName
    );

BOOL
TiffRouteEMail(
    const FAX_ROUTE *FaxRoute,
    PROUTING_TABLE RoutingEntry,
    LPCWSTR TiffFileName
    );

BOOL
InitializeRoutingTable(
    VOID
    );

PROUTING_TABLE
GetRoutingEntry(
    DWORD DeviceId
    );

BOOL
ServiceMessageBox(
    IN LPCTSTR MsgString,
    IN DWORD Type,
    IN BOOL UseThread,
    IN LPDWORD Response,
    IN ...
    );

DWORD
GetMaskBit(
    LPCWSTR RoutingGuid
    );

BOOL
UpdateRoutingInfoRegistry(
    PROUTING_TABLE RoutingEntry
    );

BOOL
AddNewDeviceToRoutingTable(
    DWORD DeviceId,
    LPCWSTR DeviceName,
    LPCWSTR Csid,
    LPCWSTR Tsid,
    LPCWSTR PrinterName,
    LPCWSTR StoreDir,
    LPCWSTR ProfileName,
    DWORD Mask
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\faxroute\rtemail.cpp ===
#include "faxrtp.h"
#pragma hdrstop

LPVOID              InboundProfileInfo;




BOOL
InitializeEmailRouting(
    VOID
    )
{
    PLIST_ENTRY Next;
    PROUTING_TABLE RoutingEntry;


    //
    // initialize the profiles
    //

    EnterCriticalSection( &CsRouting );

    if (InboundProfileName && InboundProfileName[0]) {
        InboundProfileInfo = AddNewMapiProfile( InboundProfileName, TRUE, TRUE );
        if (!InboundProfileInfo) {
            DebugPrint(( TEXT("Could not initialize inbound mapi profile [%s]"), InboundProfileName ));
        }
    }

    Next = RoutingListHead.Flink;
    if (Next) {
        while (Next != &RoutingListHead) {
            RoutingEntry = CONTAINING_RECORD( Next, ROUTING_TABLE, ListEntry );
            Next = RoutingEntry->ListEntry.Flink;
            if (RoutingEntry->ProfileName && RoutingEntry->ProfileName[0]) {
                RoutingEntry->ProfileInfo = AddNewMapiProfile( RoutingEntry->ProfileName, FALSE, TRUE );
            }
        }
    }

    LeaveCriticalSection( &CsRouting );

    return TRUE;
}


BOOL
TiffMailDefault(
    const FAX_ROUTE *FaxRoute,
    PROUTING_TABLE RoutingEntry,
    LPCWSTR TiffFileName
    )

/*++

Routine Description:

    Mails a TIFF file to the inbox in the specified profile.

Arguments:

    TiffFileName            - Name of TIFF file to mail
    ProfileName             - Profile name to use
    ResultCode              - The result of the failed API call

Return Value:

    TRUE for success, FALSE on error

--*/

{
    LPCTSTR          BodyStr = NULL;
    BOOL            Rslt = FALSE;
    DWORD           MsgCount;
    LPDWORD         MsgPtr[6];
    TCHAR           MsgStr[2048];
    TCHAR           PageCountStr[64];
    LPCTSTR          SenderStr = NULL;
    LPCTSTR          SubjectStr = NULL;
    LPCTSTR          RecipStr = NULL;
    TCHAR           TimeStr[128];
    ULONG           ResultCode;


    if (!RoutingEntry->ProfileInfo) {
        ResultCode = ERROR_NO_SUCH_LOGON_SESSION;
        return FALSE;
    }

    ResultCode = ERROR_SUCCESS;

    FormatElapsedTimeStr(
        (FILETIME*)&FaxRoute->ElapsedTime,
        TimeStr,
        sizeof(TimeStr)
        );

    _ltot( (LONG) FaxRoute->PageCount, PageCountStr, 10 );

    if (!FaxRoute->RoutingInfo || !FaxRoute->RoutingInfo[0]) {
        RecipStr = FaxRoute->Csid ? FaxRoute->Csid : TEXT("");
    } else {
        RecipStr = FaxRoute->RoutingInfo;
    }

    MsgPtr[0] = (LPDWORD) FaxRoute->Tsid;
    MsgPtr[1] = (LPDWORD) FaxRoute->CallerId;
    MsgPtr[2] = (LPDWORD) RecipStr;
    MsgPtr[3] = (LPDWORD) PageCountStr;
    MsgPtr[4] = (LPDWORD) TimeStr;
    MsgPtr[5] = (LPDWORD) FaxRoute->DeviceName;

    MsgCount = FormatMessage(
        FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
        MyhInstance,
        MSG_MAIL_MSG_BODY,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
        MsgStr,
        sizeof(MsgStr),
        (va_list *) MsgPtr
        );
    if (MsgCount) {
        BodyStr = StringDup( MsgStr );
    } else {
        BodyStr = StringDup( TEXT("") );
    }

    if (FaxRoute->Tsid != NULL && FaxRoute->Tsid[0] != 0) {
        SenderStr = StringDup( FaxRoute->Tsid );
    } else {
        MsgCount = FormatMessage(
            FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
            MyhInstance,
            MSG_WHO_AM_I,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
            MsgStr,
            sizeof(MsgStr),
            NULL
            );
        if (MsgCount) {
            SenderStr = StringDup( MsgStr );
        } else {
            SenderStr = StringDup( TEXT("") );
        }
    }

    MsgCount = FormatMessage(
        FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
        MyhInstance,
        MSG_SUBJECT_LINE,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
        MsgStr,
        sizeof(MsgStr),
        NULL
        );
    if (MsgCount) {
        SubjectStr = StringDup( MsgStr );
    } else {
        SubjectStr = StringDup( TEXT("") );
    }

    Rslt = StoreMapiMessage(
        RoutingEntry->ProfileInfo,
        SenderStr,
        SubjectStr,
        BodyStr,
        TiffFileName,
        NULL,
        IMPORTANCE_NORMAL,
        NULL,
        &ResultCode
        );

    MemFree( (LPBYTE) BodyStr );
    MemFree( (LPBYTE) SubjectStr );
    MemFree( (LPBYTE) SenderStr );

    return Rslt;
}


BOOL
TiffRouteEMail(
    const FAX_ROUTE *FaxRoute,
    PROUTING_TABLE RoutingEntry,
    LPCWSTR TiffFileName
    )

/*++

Routine Description:

    Mails a TIFF file to the inbox in the specified profile.

Arguments:

    TiffFileName            - Name of TIFF file to mail
    ProfileName             - Profile name to use
    ResultCode              - The result of the failed API call

Return Value:

    TRUE for success, FALSE on error

--*/

{
    LPCWSTR         BodyStr = NULL;
    BOOL            Failed = FALSE;
    DWORD           MsgCount;
    LPDWORD         MsgPtr[6];
    WCHAR           MsgStr[2048];
    WCHAR           PageCountStr[64];
    LPCWSTR         SenderStr = NULL;
    LPCWSTR         SubjectStr = NULL;
    WCHAR           TimeStr[128];
    LPCWSTR         RecipientName = NULL;
    LPWSTR          ProxyAddress = NULL;
    ULONG           ResultCode;


    if (!InboundProfileInfo) {
        ResultCode = ERROR_NO_SUCH_LOGON_SESSION;
        return FALSE;
    }

    if (FaxRoute->RoutingInfo && FaxRoute->RoutingInfo[0]) {
        RecipientName = FaxRoute->RoutingInfo;
    } else if (FaxRoute->Csid && FaxRoute->Csid[0]) {
        RecipientName = FaxRoute->Csid;
    }

    if (!RecipientName) {
        return FALSE;
    }

    ProxyAddress = (LPTSTR) MemAlloc( StringSize( RecipientName ) + 32 );
    if (!ProxyAddress) {
        return FALSE;
    }

    _stprintf( ProxyAddress, TEXT("FAX:FAX[%s]"), RecipientName );

    ResultCode = ERROR_SUCCESS;

    FormatElapsedTimeStr(
        (FILETIME*)&FaxRoute->ElapsedTime,
        TimeStr,
        sizeof(TimeStr)
        );

    _ltot( (LONG) FaxRoute->PageCount, PageCountStr, 10 );

    MsgPtr[0] = (LPDWORD) FaxRoute->Tsid;
    MsgPtr[1] = (LPDWORD) FaxRoute->CallerId;
    MsgPtr[2] = (LPDWORD) RecipientName;
    MsgPtr[3] = (LPDWORD) PageCountStr;
    MsgPtr[4] = (LPDWORD) TimeStr;
    MsgPtr[5] = (LPDWORD) FaxRoute->DeviceName;

    MsgCount = FormatMessage(
        FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
        NULL,
        MSG_MAIL_MSG_BODY,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
        MsgStr,
        sizeof(MsgStr),
        (va_list *) MsgPtr
        );

    BodyStr = StringDup( MsgStr );

    if (FaxRoute->Tsid != NULL && FaxRoute->Tsid[0] != 0) {
        SenderStr = StringDup( FaxRoute->Tsid );
    } else {
        MsgCount = FormatMessage(
            FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
            NULL,
            MSG_WHO_AM_I,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
            MsgStr,
            sizeof(MsgStr),
            NULL
            );
        if (MsgCount != 0) {
            SenderStr = StringDup(MsgStr);
        }
    }

    MsgCount = FormatMessage(
        FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
        NULL,
        MSG_SUBJECT_LINE,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
        MsgStr,
        sizeof(MsgStr),
        NULL
        );
    if (MsgCount != 0) {
        SubjectStr = StringDup( MsgStr );
    }

    Failed = MailMapiMessage(
        InboundProfileInfo,
        ProxyAddress,
        SubjectStr,
        BodyStr,
        TiffFileName,
        NULL,
        IMPORTANCE_NORMAL,
        &ResultCode
        );

    MemFree( (LPBYTE) BodyStr );
    MemFree( (LPBYTE) SubjectStr );
    MemFree( (LPBYTE) SenderStr );
    MemFree( (LPBYTE) ProxyAddress );

    return Failed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\faxroute\store.cpp ===
#include "faxrtp.h"
#pragma hdrstop




BOOL
IsExistingConnection(
    LPCTSTR RemoteName
    )
/*++

Routine Description:

    Checks to see if we are connected already.

Arguments:

    RemoteName              - UNC name of remote host

Return Value:

    TRUE for success, FALSE on error

--*/

{
    DWORD        rc;
    HANDLE       hEnum;
    DWORD        Entries;
    NETRESOURCE  *nrr = NULL;
    DWORD        cb;
    DWORD        i;
    DWORD        ss;
    BOOL         rval = FALSE;


    rc = WNetOpenEnum( RESOURCE_CONNECTED, RESOURCETYPE_ANY, 0, NULL, &hEnum );
    if (rc != NO_ERROR) {
        return FALSE;
    }

    ss = 0;
    cb = 64 * 1024;
    nrr = (NETRESOURCE*) MemAlloc( cb );
    if (!nrr) {
        WNetCloseEnum( hEnum );
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }
    ZeroMemory( nrr, cb );

    while( TRUE ) {
        Entries = (DWORD)-1;
        rc = WNetEnumResource( hEnum, &Entries, nrr, &cb );
        if (rc == ERROR_NO_MORE_ITEMS) {
            break;
        } else if (rc == ERROR_MORE_DATA) {
            cb += 16;
            MemFree( nrr );
            nrr = (NETRESOURCE*) MemAlloc( cb );
            if (!nrr) {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                break;
            }
            ZeroMemory( nrr, cb );
            continue;
        } else if (rc != NO_ERROR) {
            break;
        }
        for (i=0; i<Entries; i++) {
            if (_tcsicmp( nrr[i].lpRemoteName, RemoteName ) == 0) {
                rval = TRUE;
                break;
            }
        }
    }

    if (nrr) MemFree( nrr );
    WNetCloseEnum( hEnum );

    return rval;
}


BOOL
EstablishConnection(
    LPCTSTR FileName
    )
/*++

Routine Description:

    Tries to establish a network connection if file is remote.

Arguments:

    FileName                - Name of file

Return Value:

    TRUE for success, FALSE on error

--*/

{
    NETRESOURCE  nr;
    DWORD        rc;
    DWORD        i;
    LPTSTR      RemoteName;
    LPTSTR      p;

    if (!FileName) {
        return FALSE;
    }

    if (!(  (FileName[0] == TEXT('\\')) && 
            (FileName[1] == TEXT('\\')) )) {
        return FALSE;
    }

    p = _tcschr( &FileName[2], TEXT('\\') );
    if (!p) {
        //
        // malformed name
        //
        return FALSE;
    }
    p = _tcschr( p+1, TEXT('\\') );
    if (!p) {
        p = (LPTSTR) &FileName[_tcsclen(FileName)];
    }
    i = (DWORD)(p - FileName);
    RemoteName = (LPTSTR) MemAlloc( (i + 1) * sizeof(TCHAR) );
    if (!RemoteName) {
        return FALSE;
    }
    _tcsnccpy( RemoteName, FileName, i );
    RemoteName[i] = 0;

    if (IsExistingConnection( RemoteName )) {
        MemFree( RemoteName );
        return TRUE;
    }

    nr.dwScope        = 0;
    nr.dwType         = RESOURCETYPE_DISK;
    nr.dwDisplayType  = 0;
    nr.dwUsage        = 0;
    nr.lpLocalName    = NULL;
    nr.lpRemoteName   = RemoteName;
    nr.lpComment      = NULL;
    nr.lpProvider     = NULL;

    rc = WNetAddConnection2( &nr, NULL, NULL, 0 );
    if (rc != NO_ERROR) {
        MemFree( RemoteName );
        return FALSE;
    }

    MemFree( RemoteName );
    return TRUE;
}


BOOL
FaxMoveFile(
    LPCTSTR  TiffFileName,
    LPCTSTR  DestDir
    )

/*++

Routine Description:

    Stores a FAX in the specified directory.  This routine will also
    cached network connections and attemp to create the destination directory
    if it does not exist.

Arguments:

    TiffFileName            - Name of TIFF file to store
    DestDir                 - Name of directory to store it in

Return Value:

    TRUE for success, FALSE on error

--*/

{
    LPTSTR  NameBuffer = NULL;
    LPTSTR  DstFName = NULL;
    LPTSTR  FBaseName;
    DWORD   StrSize;
    BOOL    RVal = FALSE;
    LPTSTR  pStr;

    StrSize = GetFullPathName (
        (LPTSTR)TiffFileName,
        0,
        DstFName,
        &FBaseName
        );
    DstFName = (LPTSTR) MemAlloc( (StrSize + 1) * sizeof(TCHAR));
    if (!DstFName) {
        goto exit;
    }
    GetFullPathName (
        TiffFileName,
        StrSize,
        DstFName,
        &FBaseName
        );

    StrSize = StringSize( DestDir );

    NameBuffer = (LPTSTR) MemAlloc( StrSize + 4 + StringSize( FBaseName ) );
    if (!NameBuffer) {
        goto exit;
    }

    _tcscpy( NameBuffer, DestDir );

    pStr = &NameBuffer[(StrSize/sizeof(TCHAR)) - 2];

    if (*pStr != TEXT( '\\' )) {
        *++pStr = TEXT( '\\' );
    }

    pStr++;

    _tcscpy( pStr, FBaseName );

    EstablishConnection (NameBuffer);

    if (CopyFile (TiffFileName, NameBuffer, TRUE)) {
        RVal = TRUE;
        goto exit;
    }

    //
    // try to create the directory
    //
    if (GetLastError() == ERROR_PATH_NOT_FOUND) {
        // if the pathname is too long, return a more descriptive error
        if (StringSize( NameBuffer ) >= MAX_PATH) {
            SetLastError( ERROR_BUFFER_OVERFLOW );
            RVal = FALSE;
        }
        else {
            MakeDirectory(DestDir);
            RVal = CopyFile( TiffFileName, NameBuffer, TRUE );
        }
    }

exit:
    if (RVal) {
        FaxLog(
            FAXLOG_CATEGORY_INBOUND,
            FAXLOG_LEVEL_MAX,
            2,
            MSG_FAX_SAVE_SUCCESS,
            TiffFileName,
            NameBuffer
            );
    } else {
        FaxLog(
            FAXLOG_CATEGORY_INBOUND,
            FAXLOG_LEVEL_MIN,
            3,
            MSG_FAX_SAVE_FAILED,
            TiffFileName,
            NameBuffer,
            GetLastErrorText(GetLastError())
            );
    }

    if (DstFName) {
        MemFree( DstFName );
    }

    if (NameBuffer) {
        MemFree( NameBuffer );
    }

    return RVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\faxroute\util.cpp ===
#include "faxrtp.h"
#pragma hdrstop



typedef struct _STRING_TABLE {
    DWORD   ResourceId;
    DWORD   InternalId;
    LPCTSTR String;
} STRING_TABLE, *PSTRING_TABLE;


static STRING_TABLE StringTable[] =
{
    { IDS_NO_MAPI_LOGON,        IDS_NO_MAPI_LOGON,       NULL },
    { IDS_SERVICE_NAME,         IDS_SERVICE_NAME,        NULL },
    { IDS_DEFAULT,              IDS_DEFAULT,             NULL }
};

#define CountStringTable (sizeof(StringTable)/sizeof(STRING_TABLE))




LPTSTR
GetLastErrorText(
    DWORD ErrorCode
    )

/*++

Routine Description:

    Gets a string for a given WIN32 error code.

Arguments:

    ErrorCode   - WIN32 error code.

Return Value:

    Pointer to a string representing the ErrorCode.

--*/

{
    static TCHAR ErrorBuf[256];
    DWORD Count;

    Count = FormatMessage(
        FORMAT_MESSAGE_FROM_SYSTEM |FORMAT_MESSAGE_ARGUMENT_ARRAY,
        NULL,
        ErrorCode,
        LANG_NEUTRAL,
        ErrorBuf,
        sizeof(ErrorBuf),
        NULL
        );

    if (Count) {
        if (ErrorBuf[Count-1] == TEXT('\n')) {
            ErrorBuf[Count-1] = 0;
        }
        if ((Count>1) && (ErrorBuf[Count-2] == TEXT('\r'))) {
            ErrorBuf[Count-2] = 0;
        }
    }

    return ErrorBuf;
}


VOID
InitializeStringTable(
    VOID
    )
{
    DWORD i;
    HINSTANCE hInstance;
    TCHAR Buffer[256];


    hInstance = GetModuleHandle(NULL);

    for (i=0; i<CountStringTable; i++) {

        if (LoadString(
            hInstance,
            StringTable[i].ResourceId,
            Buffer,
            sizeof(Buffer)/sizeof(TCHAR)
            )) {

            StringTable[i].String = (LPCTSTR) MemAlloc( StringSize( Buffer ) );
            if (!StringTable[i].String) {
                StringTable[i].String = TEXT("");
            } else {
                _tcscpy( (LPTSTR)StringTable[i].String, Buffer );
            }

        } else {

            StringTable[i].String = TEXT("");

        }
    }
}


LPCTSTR
GetString(
    DWORD InternalId
    )

/*++

Routine Description:

    Loads a resource string and returns a pointer to the string.
    The caller must free the memory.

Arguments:

    ResourceId      - resource string id

Return Value:

    pointer to the string

--*/

{
    DWORD i;

    for (i=0; i<CountStringTable; i++) {
        if (StringTable[i].InternalId == InternalId) {
            return StringTable[i].String;
        }
    }

    return NULL;
}


DWORD
MessageBoxThread(
    IN PMESSAGEBOX_DATA MsgBox
    )
{
    DWORD Answer = (DWORD) MessageBox(
        NULL,
        MsgBox->Text,
        GetString( IDS_SERVICE_NAME ),
        MsgBox->Type | MB_SERVICE_NOTIFICATION
        );

    if (MsgBox->Response) {
        *MsgBox->Response = Answer;
    }

    MemFree( (LPBYTE) MsgBox->Text );
    MemFree( MsgBox );

    return 0;
}


BOOL
ServiceMessageBox(
    IN LPCTSTR MsgString,
    IN DWORD Type,
    IN BOOL UseThread,
    IN LPDWORD Response,
    IN ...
    )
{
    #define BUFSIZE 1024
    PMESSAGEBOX_DATA MsgBox;
    DWORD ThreadId;
    HANDLE hThread;
    DWORD Answer;
    LPTSTR buf;
    va_list arg_ptr;



    buf = (LPTSTR) MemAlloc( BUFSIZE );
    if (!buf) {
        return FALSE;
    }

    va_start( arg_ptr, Response );
    _vsntprintf( buf, BUFSIZE, MsgString, arg_ptr );
    va_end( arg_ptr );

    if (UseThread) {

        MsgBox = (PMESSAGEBOX_DATA) MemAlloc( sizeof(MESSAGEBOX_DATA) );
        if (!MsgBox) {
            return FALSE;
        }

        MsgBox->Text       = buf;
        MsgBox->Response   = Response;
        MsgBox->Type       = Type;

        hThread = CreateThread(
            NULL,
            0,
            (LPTHREAD_START_ROUTINE) MessageBoxThread,
            (LPVOID) MsgBox,
            0,
            &ThreadId
            );

        if (!hThread) {
            return FALSE;
        }

        return TRUE;
    }

    Answer = MessageBox(
        NULL,
        buf,
        GetString( IDS_SERVICE_NAME ),
        Type | MB_SERVICE_NOTIFICATION
        );
    if (Response) {
        *Response = Answer;
    }

    MemFree( buf );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\inc\faxevent.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxevent.h

Abstract:

    This is the main fax service header file.  All
    source modules should include this file ONLY.

Author:

    Wesley Witt (wesw) 16-Jan-1996


Revision History:

--*/

#ifndef _FAXEVENT_
#define _FAXEVENT_

#ifdef __cplusplus
extern "C" {
#endif


BOOL WINAPI
InitializeEventLog(
    IN HANDLE HeapHandle,
    IN PREG_FAX_SERVICE FaxReg,
    IN PFAX_LOG_CATEGORY DefaultCategories,
    IN int DefaultCategoryCount
    );

VOID WINAPI
RefreshEventLog(
    PREG_FAX_LOGGING FaxEvent
    );

BOOL WINAPI
FaxLog(
    DWORD Category,
    DWORD Level,
    DWORD StringCount,
    DWORD FormatId,
    ...
    );


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\faxstat\faxstat.c ===
#include <windows.h>
#include <commctrl.h>
#include <shellapi.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <tchar.h>
#include <winfax.h>
#include <faxutil.h>
#include <mmsystem.h>
#include <winspool.h>

#include "resource.h"
#include "faxstat.h"
#include "faxreg.h"
#include "faxcfg.h"
#include "faxhelp.h"

#define ValidString( String ) ((String) ? (String) : TEXT( "" ))

// global variables

BOOL            IsShowing = FALSE;
BOOL            IsOnTaskBar = FALSE;

NOTIFYICONDATA  IconData;                           // icon data

DWORD           Seconds;

LPTSTR          TimeSeparator = NULL;

LIST_ENTRY      EventListHead;
DWORD           EventCount;

// configuration options and their defaults

CONFIG_OPTIONS Config = {
    BST_CHECKED,        // OnTop
    BST_CHECKED,        // TaskBar
    BST_CHECKED,        // VisualNotification
    BST_UNCHECKED,      // SoundNotification
    BST_UNCHECKED,      // AnswerNextCall
    BST_UNCHECKED       // ManualAnswerEnabled
};

extern HANDLE FaxPortHandle;
extern HANDLE hFax;

INSTANCE_DATA FaxStat;

int
WINAPI
#ifdef UNICODE
wWinMain(
#else
WinMain(
#endif
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPTSTR    lpCmdLine,
    int       nShowCmd
    )
{

    //
    // szAppname must match the window class in the resource file
    //
    static TCHAR szAppName[] = FAXSTAT_WINCLASS;

    MSG         msg;
    WNDCLASSEX  wndclass;
    HWND        hWnd;
    HACCEL      hAccel;

    //
    // if we are already running, then activate the window and exit
    //

    hWnd = FindWindow( szAppName, NULL );

    if (hWnd) {
        PostMessage( hWnd, ACTIVATE, 0, 0 );
        ExitProcess( 1 );
    }

    FaxStat.hInstance = hInstance;

    InitCommonControls();

    HeapInitialize(NULL,NULL,NULL,0);

    InitializeEventList();

    hAccel = LoadAccelerators( hInstance, TEXT( "MyAccelerators" ) );

    wndclass.cbSize         = sizeof(wndclass);
    wndclass.style          = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc    = WndProc;
    wndclass.cbClsExtra     = 0;
    wndclass.cbWndExtra     = DLGWINDOWEXTRA;
    wndclass.hInstance      = hInstance;
    wndclass.hIcon          = LoadIcon( hInstance, MAKEINTRESOURCE( IDI_ICON1 ) );
    wndclass.hCursor        = LoadCursor( NULL, IDC_ARROW );
    wndclass.hbrBackground  = (HBRUSH) (COLOR_WINDOW);
    wndclass.lpszMenuName   = NULL;
    wndclass.lpszClassName  = szAppName;
    wndclass.hIconSm        = LoadIcon( hInstance, MAKEINTRESOURCE( IDI_ICON1 ) );


    RegisterClassEx( &wndclass );

    hWnd = FaxStat.hWnd = CreateDialog( hInstance, MAKEINTRESOURCE( IDD_FAXSTATUS ), 0, NULL);

    MyShowWindow( hWnd, FALSE );

    SetWindowLong( hWnd, GWL_USERDATA, (LONG) &FaxStat );

    FaxStat.ServerName = lpCmdLine[0] ? lpCmdLine : NULL;

    WorkerThreadInitialize( &FaxStat );

    PostMessage( hWnd, CONFIGUPDATE, 0, 0 );

    PostMessage( hWnd, INITANIMATION, 0, 0 );

    while (GetMessage( &msg, NULL, 0, 0 )) {

        if (!TranslateAccelerator( hWnd, hAccel, &msg )) {

            TranslateMessage( &msg );

            DispatchMessage(&msg);
        }
    }

    return msg.wParam;
}

VOID
CALLBACK
TimerProc(
    HWND hWnd,
    UINT iMsg,
    UINT iTimerID,
    DWORD dwTime
    )
{
    TCHAR StrBuf[STR_SIZE];

    Seconds++;

    _stprintf(
        StrBuf,
        TEXT( "%d%s%02d" ),
        Seconds / 60,
        TimeSeparator,
        Seconds % 60
        );

    SetDlgItemText( hWnd, IDC_TIME, StrBuf );
}

VOID
StatusUpdate(
    HWND hWnd,
    DWORD EventId,
    DWORD LastEventId,
    PFAX_DEVICE_STATUS fds
    )
{

    TCHAR FormatBuf[STR_SIZE];
    TCHAR StrBuf[STR_SIZE];
    INT FromTo = -1;
    static int CurrentPage;
    static BOOL FaxActive = FALSE;      // this is TRUE when sending or receiving
    PEVENT_RECORD NewEvent;
    PINSTANCE_DATA pInst = (PINSTANCE_DATA) GetWindowLong( hWnd, GWL_USERDATA );

    if (EventId == FEI_ABORTING && LastEventId == FEI_ABORTING) {
        return;
    }

    if (TimeSeparator == NULL) {
        INT BytesNeeded;

        BytesNeeded = GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_STIME, NULL, 0 );
        TimeSeparator = MemAlloc( BytesNeeded + 4);
        BytesNeeded = GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_STIME, TimeSeparator, BytesNeeded );
    }

    LoadString( pInst->hInstance, EventId, FormatBuf, STR_SIZE );

    if (fds && EventId != LastEventId) {

        CurrentPage = fds->CurrentPage;
        //pInst->JobId = fds->JobId;

    } else {
        CurrentPage++;
    }

    if (EventId == FEI_DIALING) {

        _stprintf( StrBuf, FormatBuf, ValidString( fds->PhoneNumber ) );

        EnableWindow( GetDlgItem( hWnd, IDC_FAXEND ), TRUE );

    } else if (EventId == FEI_SENDING || EventId == FEI_RECEIVING) {

        FromTo = EventId == FEI_SENDING ? IDS_TO : IDS_FROM;

        _stprintf( StrBuf, FormatBuf, CurrentPage );

        EnableWindow( GetDlgItem( hWnd, IDC_FAXEND ), TRUE );

    } else {

        _tcscpy( StrBuf, FormatBuf );

        EnableWindow( GetDlgItem( hWnd, IDC_FAXEND ), FALSE );

    }

    NewEvent = InsertEventRecord( EventId, StrBuf );

    if (pInst->hEventDlg != NULL) {

        InsertEventDialog( pInst->hEventDlg, NewEvent );

    }

    SetDlgItemText( pInst->hWnd, IDC_STATUS, StrBuf );

    if (IsOnTaskBar) {

        IconData.uFlags                  = NIF_TIP;

        _tcscpy( IconData.szTip, StrBuf );

        Shell_NotifyIcon( NIM_MODIFY, &IconData );
    }

    switch(FromTo) {
        case IDS_FROM:
        case IDS_TO:

            if (!FaxActive) {

                PlayAnimation( GetDlgItem( pInst->hWnd, IDC_ANIMATE1 ), FromTo == IDS_FROM ? IDR_RECEIVE : IDR_SEND );

                LoadString( pInst->hInstance, FromTo, StrBuf, STR_SIZE );

                _tcscat( StrBuf, ValidString( fds->Tsid ) );

                SetDlgItemText( pInst->hWnd, IDC_FROMTO, StrBuf );

                LoadString( pInst->hInstance, IDS_ETIME, StrBuf, STR_SIZE );

                SetDlgItemText( pInst->hWnd, IDC_STATICTIME, StrBuf );

                Seconds = 0;

                _stprintf(
                    StrBuf,
                    TEXT( "%d%s%02d" ),
                    0,
                    TimeSeparator,
                    0
                    );

                SetDlgItemText( pInst->hWnd, IDC_TIME, StrBuf );

                SetTimer( pInst->hWnd, ID_TIMER, 1000, (TIMERPROC) TimerProc );

                FaxActive = TRUE;
            }

            break;

        default:

            SetDlgItemText( pInst->hWnd, IDC_FROMTO, TEXT( "" ) );

            SetDlgItemText( pInst->hWnd, IDC_STATICTIME, TEXT( "" ) );

            SetDlgItemText( pInst->hWnd, IDC_TIME, TEXT( "" ) );

            StrBuf[0] = 0;

            if (FaxActive) {

                PlayAnimation( GetDlgItem( pInst->hWnd, IDC_ANIMATE1 ), IDR_IDLE );

                KillTimer( pInst->hWnd, ID_TIMER );

                FaxActive = FALSE;
            }
    }

    if (EventId == FEI_DIALING || (EventId == FEI_RINGING && LastEventId != FEI_RINGING)) {
        if (IsOptionOn( Config.VisualNotification )) {
            MyShowWindow( pInst->hWnd, TRUE );
        }

        if (IsOptionOn( Config.SoundNotification )) {
            PlaySound( TEXT( "Incoming-Fax" ), NULL, SND_ASYNC | SND_APPLICATION );
        }

        if (EventId == FEI_RINGING && IsOptionOn( Config.ManualAnswerEnabled )) {
            HANDLE FaxJobHandle;
            TCHAR FileName[256];
            DWORD rVal;

            if (IsOptionOn( Config.AnswerNextCall )) {

                rVal = IDYES;

            } else {
                rVal = DialogBoxParam(
                    FaxStat.hInstance,
                    MAKEINTRESOURCE( IDD_ANSWER ),
                    hWnd,
                    AnswerDlgProc,
                    (LPARAM) &FaxStat
                    );
            }

            if ( rVal == IDYES ) {

                FaxReceiveDocument( hFax, FileName, 256, &FaxJobHandle );

                CheckDlgButton( hWnd, IDC_ANSWER_NEXT_CALL, BST_UNCHECKED );

                Config.AnswerNextCall = BST_UNCHECKED;
            }
        }
    }

    if (pInst->hAnswerDlg && EventId != FEI_RINGING) {

        PostMessage( pInst->hAnswerDlg, WM_COMMAND, IDNO, 0 );
    }
}

BOOL
CALLBACK
AnswerDlgProc(
    HWND hDlg,
    UINT iMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static PINSTANCE_DATA pInst;

    switch(iMsg) {

        case WM_INITDIALOG:

            pInst = (PINSTANCE_DATA) lParam;

            pInst->hAnswerDlg = hDlg;

            return TRUE;

        case WM_COMMAND:

            switch(LOWORD( wParam )) {
                case IDYES:
                case IDNO:

                    EndDialog( hDlg, LOWORD( wParam ) );

                    pInst->hAnswerDlg = NULL;

                    return TRUE;
            }
            break;
    }
    return FALSE;
}

BOOL
CALLBACK
EventDlgProc(
    HWND hDlg,
    UINT iMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    LV_COLUMN lvc = {0};
    HWND hWndCtrl = GetDlgItem( hDlg, IDC_LIST1 );
    PLIST_ENTRY Next;
    TCHAR StrBuf[STR_SIZE];
    static PINSTANCE_DATA pInst;

    switch(iMsg) {

        case WM_INITDIALOG:
            lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;

            pInst = (PINSTANCE_DATA) lParam;

            LoadString( pInst->hInstance, IDS_TIMELABEL, StrBuf, STR_SIZE );

            lvc.pszText = StrBuf;
            lvc.iSubItem = 0;
            lvc.cx = 70;
            lvc.fmt = LVCFMT_LEFT;
            ListView_InsertColumn( hWndCtrl, 0, &lvc );

            LoadString( pInst->hInstance, IDS_EVENTLABEL, StrBuf, STR_SIZE );

            lvc.pszText = StrBuf;
            lvc.iSubItem = 1;
            lvc.cx = 180;
            lvc.fmt = LVCFMT_LEFT;
            ListView_InsertColumn( hWndCtrl, 1, &lvc );

            if (!IsListEmpty( &EventListHead )) {
                PEVENT_RECORD EventRecord;

                for (Next = EventListHead.Flink; Next != &EventListHead; Next = Next->Flink) {

                    EventRecord = CONTAINING_RECORD( Next, EVENT_RECORD, ListEntry );

                    InsertEventDialog( hDlg, EventRecord );
                }
            }

            pInst->hEventDlg = hDlg;

            return TRUE;

        case WM_COMMAND:

            switch(LOWORD( wParam )) {
                case IDOK:
                case IDCANCEL:

                    EndDialog( hDlg, 0 );

                    pInst->hEventDlg = NULL;

                    return TRUE;
            }
            break;
    }
    return FALSE;
}

VOID
InsertEventDialog(
    HWND hDlg,
    PEVENT_RECORD pEventRecord
    )
{
    LV_ITEM lvi = {0};
    HWND hWndCtrl = GetDlgItem( hDlg, IDC_LIST1 );
    INT iItem;
    TCHAR TimeBuf[STR_SIZE];

    GetTimeFormat(
        LOCALE_USER_DEFAULT,
        0,
        &pEventRecord->Time,
        NULL,
        TimeBuf,
        STR_SIZE
        );

    lvi.pszText = TimeBuf;
    lvi.iItem = ListView_GetItemCount( hWndCtrl );
    lvi.iSubItem = 0;
    lvi.mask = LVIF_TEXT;
    iItem = ListView_InsertItem( hWndCtrl, &lvi );

    lvi.pszText = pEventRecord->StrBuf;
    lvi.iItem = iItem;
    lvi.iSubItem = 1;
    lvi.mask = LVIF_TEXT;
    ListView_SetItem( hWndCtrl, &lvi );

    ListView_Scroll( hWndCtrl, 0, iItem );
}


LRESULT
CALLBACK
WndProc(
    HWND hWnd,
    UINT iMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static DWORD EventId;
    static DWORD LastEventId = 0;
    static const DWORD monitorHelpIDs[] = {

        IDC_FAXEND,                 IDH_FAXMONITOR_END_CALL,
        IDC_DETAILS,                IDH_FAXMONITOR_DETAILS,
        IDC_STATUS,                 IDH_FAXMONITOR_STATUS,
        IDC_ANSWER_NEXT_CALL,       IDH_FAXMONITOR_ANSWER_NEXT_CALL,
        0,                          0
    };
    PFAX_DEVICE_STATUS FaxDeviceStatus;

    switch(iMsg)
    {


        case WM_CREATE:

            CenterWindow( hWnd, GetDesktopWindow() );

            return 0;

        case TRAYCALLBACK:

            switch (lParam) {
                case WM_LBUTTONDOWN:
                    MyShowWindow( hWnd, TRUE );

                    return 0;

                case WM_RBUTTONDOWN:
                    //
                    // execute the control panel applet
                    // if the property page number ever changes, it must be changed
                    // here also
                    //
                    ShellExecute(
                        hWnd,
                        TEXT( "open" ),
                        TEXT( "rundll32" ),
                        TEXT( "shell32.dll,Control_RunDLL faxcfg.cpl,Fax,7" ),
                        TEXT( "." ),
                        SW_SHOWNORMAL
                        );
                    return 0;
            }

            break;

        case CONFIGUPDATE:

            GetConfiguration();

            if (IsOptionOn( Config.ManualAnswerEnabled )) {

                EnableWindow( GetDlgItem( hWnd, IDC_ANSWER_NEXT_CALL ), TRUE );

            } else {

                CheckDlgButton( hWnd, IDC_ANSWER_NEXT_CALL, BST_UNCHECKED );

                EnableWindow( GetDlgItem( hWnd, IDC_ANSWER_NEXT_CALL ), FALSE );
            }

            MyShowWindow( hWnd, IsShowing );

            return 0;


        case ACTIVATE:

            MyShowWindow( hWnd, TRUE );

            return 0;

        case INITANIMATION:

            PlayAnimation( GetDlgItem( hWnd, IDC_ANIMATE1 ), IDR_IDLE );

            return 0;

        case STATUSUPDATE:

            LastEventId = EventId;

            EventId = wParam;

            FaxDeviceStatus = (PFAX_DEVICE_STATUS) lParam;

            StatusUpdate( hWnd, EventId, LastEventId, FaxDeviceStatus );

            return 0;

        case WM_SYSCOMMAND:

            if (wParam == SC_CLOSE) {

                MyShowWindow( hWnd, FALSE );

                return 0;

            } else {
                break;
            }

        case WM_COMMAND:

            SetFocus( hWnd );

            switch (LOWORD(wParam)) {
                BOOL rVal;
                HANDLE PrinterHandle;
                HWND hButton;

                case IDC_FAXEND:

                    hButton = GetDlgItem( hWnd, LOWORD(wParam));

                    if (IsWindowEnabled( hButton )) {

                        if (HIWORD(wParam)) {   // accelerator key

                            SendMessage( hButton, BM_SETSTATE, 1, 0 );

                            SendMessage( hButton, BM_SETSTATE, 0, 0 );
                        }

                        rVal = OpenPrinter( FaxStat.PrinterName, &PrinterHandle, NULL );

                        rVal = SetJob( PrinterHandle, FaxStat.JobId, 0, NULL, JOB_CONTROL_CANCEL );

                        ClosePrinter( PrinterHandle );

                        EnableWindow( hButton, FALSE);

                        SendMessage( hWnd, STATUSUPDATE, FEI_ABORTING, 0 );
                    }

                    break;

                case IDC_DETAILS:

                    if (HIWORD(wParam)) {   // accelerator key

                        SendMessage( GetDlgItem( hWnd, LOWORD(wParam)), BM_SETSTATE, 1, 0 );

                        SendMessage( GetDlgItem( hWnd, LOWORD(wParam)), BM_SETSTATE, 0, 0 );
                    }

                    DialogBoxParam(
                        FaxStat.hInstance,
                        MAKEINTRESOURCE( IDD_DETAILS ),
                        hWnd,
                        EventDlgProc,
                        (LPARAM) &FaxStat
                        );

                    break;

                case IDC_EXIT:

                    if (IsOnTaskBar) {
                        Shell_NotifyIcon( NIM_DELETE, &IconData );
                    }
                    Disconnect();
                    PostQuitMessage( 0 );
                    break;

                case IDC_ANSWER_NEXT_CALL:

                    if (IsWindowEnabled( GetDlgItem( hWnd, IDC_ANSWER_NEXT_CALL ))) {

                        CheckDlgButton(
                            hWnd,
                            IDC_ANSWER_NEXT_CALL,
                            IsDlgButtonChecked( hWnd, IDC_ANSWER_NEXT_CALL ) == BST_CHECKED ? BST_UNCHECKED : BST_CHECKED
                            );

                        Config.AnswerNextCall = IsDlgButtonChecked( hWnd, IDC_ANSWER_NEXT_CALL );
                    }
                    break;

            }

            return 0;

        case WM_DESTROY:
            PostQuitMessage( 0 );
            return 0;

        case WM_HELP:
        case WM_CONTEXTMENU:

            FAXWINHELP( iMsg, wParam, lParam, monitorHelpIDs );

            return 0;
    }

    return DefWindowProc( hWnd, iMsg, wParam, lParam );
}


VOID
InitializeEventList(
    VOID
    )
{
    InitializeListHead( &EventListHead );
    EventCount = 0;
}

PEVENT_RECORD
InsertEventRecord(
    DWORD EventId,
    LPTSTR String
    )
{
    PEVENT_RECORD NewEvent;
    PLIST_ENTRY pListEntry;

    if (EventCount == MAX_EVENTS) {

        pListEntry = RemoveHeadList( &EventListHead );
        NewEvent = CONTAINING_RECORD( pListEntry, EVENT_RECORD, ListEntry );

    } else {
        NewEvent = MemAlloc( sizeof(EVENT_RECORD) );
        EventCount++;
    }

    GetLocalTime( &NewEvent->Time );

    NewEvent->EventId= EventId;

    _tcscpy( NewEvent->StrBuf, String );

    InsertTailList( &EventListHead, &NewEvent->ListEntry );

    return NewEvent;
}

DWORD
MapStatusIdToEventId(
    DWORD StatusId
    )
{
    DWORD EventId = 0;

    if (StatusId & FPS_AVAILABLE) {
        StatusId &= FPS_AVAILABLE;
    }

    switch( StatusId ) {
        case FPS_DIALING:
            EventId = FEI_DIALING;
            break;

        case FPS_SENDING:
            EventId = FEI_SENDING;
            break;

        case FPS_RECEIVING:
            EventId = FEI_RECEIVING;
            break;

        case FPS_COMPLETED:
            EventId = FEI_COMPLETED;
            break;

        case FPS_BUSY:
            EventId = FEI_BUSY;
            break;

        case FPS_NO_ANSWER:
            EventId = FEI_NO_ANSWER;
            break;

        case FPS_BAD_ADDRESS:
            EventId = FEI_BAD_ADDRESS;
            break;

        case FPS_NO_DIAL_TONE:
            EventId = FEI_NO_DIAL_TONE;
            break;

        case FPS_DISCONNECTED:
            EventId = FEI_DISCONNECTED;
            break;

        case FPS_FATAL_ERROR:
            EventId = FEI_FATAL_ERROR;
            break;

        case FPS_NOT_FAX_CALL:
            EventId = FEI_NOT_FAX_CALL;
            break;

        case FPS_CALL_DELAYED:
            EventId = FEI_CALL_DELAYED;
            break;

        case FPS_CALL_BLACKLISTED:
            EventId = FEI_CALL_BLACKLISTED;
            break;

        case FPS_RINGING:
            EventId = FEI_RINGING;
            break;

        case FPS_ABORTING:
            EventId = FEI_ABORTING;
            break;

        case FPS_ROUTING:
            EventId = FEI_ROUTING;
            break;

        case FPS_AVAILABLE:
            EventId = FEI_IDLE;
            break;

        case FPS_ANSWERED:
            EventId = FEI_ANSWERED;
            break;
    }

    return EventId;
}

VOID
FitRectToScreen(
    PRECT prc
    )
{
    INT cxScreen;
    INT cyScreen;
    INT delta;

    cxScreen = GetSystemMetrics(SM_CXSCREEN);
    cyScreen = GetSystemMetrics(SM_CYSCREEN);

    if (prc->right > cxScreen) {
        delta = prc->right - prc->left;
        prc->right = cxScreen;
        prc->left = prc->right - delta;
    }

    if (prc->left < 0) {
        delta = prc->right - prc->left;
        prc->left = 0;
        prc->right = prc->left + delta;
    }

    if (prc->bottom > cyScreen) {
        delta = prc->bottom - prc->top;
        prc->bottom = cyScreen;
        prc->top = prc->bottom - delta;
    }

    if (prc->top < 0) {
        delta = prc->bottom - prc->top;
        prc->top = 0;
        prc->bottom = prc->top + delta;
    }
}

VOID
CenterWindow(
    HWND hWnd,
    HWND hwndToCenterOver
    )
{
    RECT rc;
    RECT rcOwner;
    RECT rcCenter;
    HWND hwndOwner;

    GetWindowRect( hWnd, &rc );

    if (hwndToCenterOver) {
        hwndOwner = hwndToCenterOver;
        GetClientRect( hwndOwner, &rcOwner );
    } else {
        hwndOwner = GetWindow( hWnd, GW_OWNER );
        if (!hwndOwner) {
            hwndOwner = GetDesktopWindow();
        }
        GetWindowRect( hwndOwner, &rcOwner );
    }

    //
    //  Calculate the starting x,y for the new
    //  window so that it would be centered.
    //
    rcCenter.left = rcOwner.left +
            (((rcOwner.right - rcOwner.left) -
            (rc.right - rc.left))
            / 2);

    rcCenter.top = rcOwner.top +
            (((rcOwner.bottom - rcOwner.top) -
            (rc.bottom - rc.top))
            / 2);

    rcCenter.right = rcCenter.left + (rc.right - rc.left);
    rcCenter.bottom = rcCenter.top + (rc.bottom - rc.top);

    FitRectToScreen( &rcCenter );

    SetWindowPos(hWnd, NULL, rcCenter.left, rcCenter.top, 0, 0,
            SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);
}

VOID
MyShowWindow(
    HWND hWnd,
    BOOL visible
    )
{
    HWND hWndInsertAfter;
    DWORD Flags;

    Flags = SWP_NOSIZE | SWP_NOMOVE;

    hWndInsertAfter = IsOptionOn( Config.OnTop ) ? HWND_TOPMOST : HWND_NOTOPMOST;

    Flags |= visible ? SWP_SHOWWINDOW : SWP_HIDEWINDOW;

    SetWindowPos( hWnd, hWndInsertAfter, 0, 0, 0, 0, Flags );

    if (visible) {
        SetForegroundWindow( hWnd );
    } else {
        SetProcessWorkingSetSize( GetCurrentProcess(), 0xffffffff, 0xffffffff );
    }

    IsShowing = visible;

    if (IsOptionOn( Config.TaskBar ) && !IsOnTaskBar) {

        IconData.uID                = (UINT) IDI_ICON1;
        IconData.cbSize             = sizeof(NOTIFYICONDATA);
        IconData.hWnd               = FaxStat.hWnd;
        IconData.uCallbackMessage   = TRAYCALLBACK;
        IconData.hIcon              = LoadIcon( FaxStat.hInstance, MAKEINTRESOURCE( IDI_ICON1 ) );
        IconData.uFlags                  = NIF_ICON | NIF_MESSAGE;

        Shell_NotifyIcon( NIM_ADD, &IconData );
        IsOnTaskBar = TRUE;

    } else if (!IsOptionOn( Config.TaskBar ) && IsOnTaskBar) {

        Shell_NotifyIcon( NIM_DELETE, &IconData );
        IsOnTaskBar = FALSE;
    }


}

VOID
GetConfiguration(
    VOID
    )
{
    HKEY HKey;

    HKey = OpenRegistryKey( HKEY_CURRENT_USER, REGKEY_FAX_USERINFO, FALSE, 