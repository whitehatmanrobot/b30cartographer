R, "GetWinMetaFileBits: invalid data");

//    ASSERTGDI(pmf->pmrmf->iType == EMR_HEADER, "GetWinMetaFileBits: invalid data");

#ifndef DO_NOT_USE_EMBEDDED_WINDOWS_METAFILE
// See if the this was originally an old style metafile and if it has
// an encapsulated original

    pemrWinMF = (PEMRGDICOMMENT_WINDOWS_METAFILE)
            ((PBYTE) pmfh + ((PENHMETAHEADER) pmfh)->nSize);

    if (((PMRGDICOMMENT) pemrWinMF)->bIsWindowsMetaFile())
    {
        // Make sure that this is what we want and verify checksum

        if (iMapMode != MM_ANISOTROPIC)
        {
            PUTS("GetWinMetaFileBits: Requested and embedded metafile mapmodes mismatch\n");
        }
        else if ((pemrWinMF->nVersion != METAVERSION300 &&
                  pemrWinMF->nVersion != METAVERSION100)
              || pemrWinMF->fFlags != 0)
        {
            // In this release, we can only handle the given metafile
            // versions.  If we return a version that we don't recognize,
            // the app will not be able to play that metafile later on!

            //VERIFYGDI(FALSE, "GetWinMetaFileBits: Unrecognized Windows metafile\n");
        }
        else if (GetDWordCheckSum((UINT) pmfh->nBytes, (PDWORD) pmfh))
        {
            PUTS("GetWinMetaFileBits: Metafile has been modified\n");
        }
        else
        {
            PUTS("GetWinMetaFileBits: Returning embedded Windows metafile\n");

            if (pData16)
            {
                if (cbData16 < pemrWinMF->cbWinMetaFile)
                {
                    ERROR_ASSERT(FALSE, "GetWinMetaFileBits: insufficient buffer");
                    //GdiSetLastError(ERROR_INSUFFICIENT_BUFFER);
                    goto Cleanup ;
                }

                RtlCopyMemory(pData16,
                          (PBYTE) &pemrWinMF[1],
                          pemrWinMF->cbWinMetaFile);
            }
            returnVal = pemrWinMF->cbWinMetaFile ;
            goto Cleanup ;
        }

        // Either the enhanced metafile containing an embedded Windows
        // metafile has been modified or the embedded Windows metafile
        // is not what we want.  Since the original format is Windows
        // format, we will not embed the enhanced metafile in the
        // returned Windows metafile.

        PUTS("GetWinMetaFileBits: Skipping embedded windows metafile\n");

        fConverter &= ~MF3216_INCLUDE_WIN32MF;
    }
#endif // DO_NOT_USE_EMBEDDED_WINDOWS_METAFILE

// Tell the converter to emit the Enhanced metafile as a comment only if
// this metafile is not previously a Windows metafile

    if (fConverter & MF3216_INCLUDE_WIN32MF)
    {
        PUTS("GetWinMetaFileBits: Embedding enhanced metafile\n");
    }
    else
    {
        PUTS("GetWinMetaFileBits: No embedding of enhanced metafile\n");
    }

    uiHeaderSize = GetEnhMetaFileBits(hemf, 0, NULL);

    // Allocate the memory to receive the enhance MetaFile
    pemfb = (PBYTE) GlobalAlloc(GMEM_FIXED, uiHeaderSize);
    if( pemfb == NULL )
    {
        goto Cleanup;
    }

    uiHeaderSize = GetEnhMetaFileBits(hemf, uiHeaderSize, pemfb);

#if DBG
    // This in only here for debugging... Save the initial EMF file to be
    // able to compare later
    // We need the ASCII version for it to work with Win98
    if (g_outputEMF)
    {
        ::DeleteEnhMetaFile(::CopyEnhMetaFileA(hemf, "C:\\emf.emf" ));
    }
#endif

    returnVal = (GdipConvertEmfToWmf((PBYTE) pemfb, cbData16, pData16,
                                     iMapMode, NULL,
                                     fConverter));

    if(!returnVal && bXorPass)
    {
        // If we fail then call without the XOR PASS
        returnVal = (GdipConvertEmfToWmf((PBYTE) pemfb, cbData16, pData16,
                                         iMapMode, NULL,
                                         fConverter & ~GPMF3216_INCLUDE_XORPATH));
#if DBG
        if( !returnVal )
        {
            // The Win32API version needs an hdcRef, get the screen DC and
            // do it
            HDC newhdc = ::GetDC(NULL);
            // If we fail again then go back to Windows
            ASSERT(::GetWinMetaFileBits(hemf, cbData16, pData16,
                                        iMapMode, newhdc) == 0);
            ::ReleaseDC(NULL, newhdc);
        }
#endif
    }

Cleanup:
    if(pmfh != NULL)
    {
        GlobalFree(pmfh);
    }
    if(pemfb != NULL)
    {
        GlobalFree(pemfb);
    }

    return returnVal;
}


extern "C"
UINT ConvertEmfToPlaceableWmf
(
    HENHMETAFILE hemf,
    UINT         cbData16,
    LPBYTE       pData16,
    INT          iMapMode,
    INT          eFlags
)
{

    UINT uiRet ;
    ENHMETAHEADER l_emetaHeader ;

    BOOL placeable = (eFlags & EmfToWmfBitsFlagsIncludePlaceable) == EmfToWmfBitsFlagsIncludePlaceable;
    // Call the GdipGetWinMetaFileBits
    // And add the header information afterwards
    // If we have a buffer then leave room for the header

    uiRet = GdipGetWinMetaFileBitsEx(hemf,
        cbData16,
        pData16?pData16+(placeable?22:0):pData16,
        iMapMode,
        eFlags);

    // If the client only wants the size of the buffer, then we return the size
    // of the buffer plus the size of the header
    if(uiRet != 0 && placeable)
    {
        // If the previous call succeeded then we will append the size of the
        // header to the return value
        uiRet += 22;

        if(pData16 != NULL)
        {
            BYTE *rgb = pData16;
            PvmsoFromU(rgb   , WMF_KEY);
            PvmsoFromW(rgb+ 4, 0);
            PvmsoFromU(rgb+16, 0);

            if(GetEnhMetaFileHeader(hemf, sizeof(l_emetaHeader), &l_emetaHeader))
            {
                FLOAT pp01mm = ((((FLOAT)l_emetaHeader.szlDevice.cx)/l_emetaHeader.szlMillimeters.cx/100.0f +
                                 (FLOAT)l_emetaHeader.szlDevice.cy)/l_emetaHeader.szlMillimeters.cy/100.0f)/2.0f;
                PvmsoFromW(rgb+ 6, SHORT((FLOAT)l_emetaHeader.rclFrame.left*pp01mm));
                PvmsoFromW(rgb+ 8, SHORT((FLOAT)l_emetaHeader.rclFrame.top*pp01mm));
                PvmsoFromW(rgb+10, SHORT((FLOAT)l_emetaHeader.rclFrame.right*pp01mm));
                PvmsoFromW(rgb+12, SHORT((FLOAT)l_emetaHeader.rclFrame.bottom*pp01mm));
                PvmsoFromW(rgb+14, SHORT(pp01mm*2540.0f));
            }
            else
            {
                // If we cant get the information from the EMF then default
                PvmsoFromW(rgb+ 6, SHORT(0));
                PvmsoFromW(rgb+ 8, SHORT(0));
                PvmsoFromW(rgb+10, SHORT(2000));
                PvmsoFromW(rgb+12, SHORT(2000));
                PvmsoFromW(rgb+14, 96);
            }
            /* Checksum.  This works on any byte order machine because the data is swapped
                consistently. */
            USHORT *pu = (USHORT*)rgb;
            USHORT u = 0;
            /* The checksum is even parity. */
            while (pu < (USHORT*)(rgb+20))
                u ^= *pu++;
            *pu = u;
        }
    }

    return uiRet ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\gpmf3216\lines.c ===
/*****************************************************************************
 *
 * lines - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************
 *  PolylineTo  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoPolylineTo
(
PLOCALDC pLocalDC,
PPOINTL pptl,
DWORD   cptl
)
{
BOOL    b ;

    // Handle path.

    if (pLocalDC->flags & RECORDING_PATH)
    {
        if (pfnSetVirtualResolution == NULL)
        {
            bXformWorkhorse((PPOINTL) pptl, cptl, &pLocalDC->xformRWorldToRDev);
        }
        return(PolylineTo(pLocalDC->hdcHelper, (LPPOINT) pptl, (DWORD) cptl));
    }

    // Handle the trivial case.

    if (cptl == 0)
        return(TRUE);

    // This can be done by using a LineTo, PolyLine, & MoveTo.

    if (!DoLineTo(pLocalDC, pptl[0].x, pptl[0].y))
        return(FALSE);

    // If there is only one point, we are done.

    if (cptl == 1)
        return(TRUE);

    if (!DoPoly(pLocalDC, pptl, cptl, EMR_POLYLINE, TRUE))
        return(FALSE);

    b = DoMoveTo(pLocalDC, pptl[cptl-1].x, pptl[cptl-1].y) ;
    return (b) ;
}


/***************************************************************************
 *  PolyPolyline  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoPolyPolyline
(
PLOCALDC pLocalDC,
PPOINTL pptl,                       // -> to PolyPolyline points.
PDWORD  pcptl,                      // -> to PolyCounts
DWORD   ccptl,                      // # of PolyCounts.
BOOL    transform                   // do we want to transform the points
)
{
BOOL    b ;
UINT    i,
        iStart,
        nCount ;

    b = TRUE;       // just in case if there is no poly

    // Let polyline do the work.

    iStart = 0 ;
    for (i = 0 ; i < ccptl ; i++)
    {
        nCount = pcptl[i] ;
        b = DoPoly(pLocalDC, &pptl[iStart], nCount, EMR_POLYLINE, transform) ;
        if (b == FALSE)
            break ;
        iStart += nCount ;
    }

    return(b) ;
}


/***************************************************************************
 *  LineTo  - Win32 to Win16 Metafile Converter Entry Point
 *
 *  See DoMoveTo() in misc.c for notes on the current position.
 **************************************************************************/
BOOL WINAPI DoLineTo
(
PLOCALDC  pLocalDC,
LONG    x,
LONG    y
)
{
BOOL    b ;
POINT   pt ;
POINT   ptCP;

    // Whether we are recording for a path or acutally emitting
    // a drawing order we must pass the drawing order to the helper DC
    // so the helper can maintain the current positon.
    // If we're recording the drawing orders for a path
    // then just pass the drawing order to the helper DC.
    // Do not emit any Win16 drawing orders.

    POINTL p = {x, y};
    if (pfnSetVirtualResolution == NULL)
    {
        bXformWorkhorse(&p, 1, &pLocalDC->xformRWorldToRDev);
    }

    if (pLocalDC->flags & RECORDING_PATH)
    {
        return(LineTo(pLocalDC->hdcHelper, (INT) p.x, (INT) p.y));
    }

    // Update the current position in the converted metafile if
    // it is different from that of the helper DC.  See notes
    // in DoMoveTo().

    if (!GetCurrentPositionEx(pLocalDC->hdcHelper, &ptCP))
        return(FALSE);

    if (pfnSetVirtualResolution == NULL)
    {
        // On Win9x we need to convert from Device Units in the Helper DC
        // to WorldUnits
        if (!bXformWorkhorse((PPOINTL) &ptCP, 1, &pLocalDC->xformRDevToRWorld))
            return(FALSE);
    }

    // Make sure that the converted metafile has the same CP as the
    // helper DC.

    if (!bValidateMetaFileCP(pLocalDC, ptCP.x, ptCP.y))
        return(FALSE);

    // Update the helper DC.
    // Update the helper DC.  (We only need to update the CP so there's no
    // reason to actually call LineTo.)

    if (!MoveToEx(pLocalDC->hdcHelper, (INT) p.x, (INT) p.y, 0))
        return(FALSE);

    // Compute the new current position.

    pt.x = x ;
    pt.y = y ;
    if (!bXformRWorldToPPage(pLocalDC, (PPOINTL) &pt, 1L))
        return(FALSE);

    // Update the mf16 current position to what it will be when this call
    // is finished.

    pLocalDC->ptCP = pt ;

    // Call the Win16 routine to emit the line to the metafile.

    b = bEmitWin16LineTo(pLocalDC, LOWORD(pt.x), LOWORD(pt.y)) ;
    return(b) ;
}

/***************************************************************************
 *  Polyline/Polygon  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoPoly
(
PLOCALDC pLocalDC,
PPOINTL  pptl,
DWORD    cptl,
INT      mrType,
BOOL     transform
)
{
BOOL    b ;
PPOINTL pptlBuff ;

    // If we're recording the drawing orders for a path
    // then just pass the drawing order to the helper DC.
    // Do not emit any Win16 drawing orders.

    if (pLocalDC->flags & RECORDING_PATH)
    {
        if (pfnSetVirtualResolution == NULL)
        {
            bXformWorkhorse(pptl, cptl, &pLocalDC->xformRWorldToRDev);
        }
        switch(mrType)
        {
            case EMR_POLYLINE:
                b = Polyline(pLocalDC->hdcHelper, (LPPOINT) pptl, (INT) cptl) ;
                break;
            case EMR_POLYGON:
                b = Polygon(pLocalDC->hdcHelper, (LPPOINT) pptl, (INT) cptl) ;
                break;
        }
        return(b) ;
    }

    // The Win16 poly record is limited to 64K points.
    // Need to check this limit.

    if (cptl > (DWORD) (WORD) MAXWORD)
    {
        b = FALSE;
        PUTS("MF3216: DoPoly, Too many point in poly array\n") ;
        SetLastError(ERROR_NOT_ENOUGH_MEMORY) ;
        goto exit1 ;
    }

    // Allocate a buffer to do the transformation in.
    // Then copy the points to this buffer.

    pptlBuff = (PPOINTL) LocalAlloc(LMEM_FIXED, cptl * sizeof(POINTL)) ;
    if (!pptlBuff)
    {
        b = FALSE;
        PUTS("MF3216: DoPoly, LocalAlloc failed\n") ;
        goto exit1 ;
    }

    RtlCopyMemory(pptlBuff, pptl, cptl * sizeof(POINTL)) ;

    // Do the transformations.
    if (transform)
    {
        b = bXformRWorldToPPage(pLocalDC, pptlBuff, cptl) ;
        if (b == FALSE)
            goto exit2 ;
    }


    // Compress the POINTLs to POINTSs

    vCompressPoints(pptlBuff, cptl) ;

    // Call the Win16 routine to emit the poly to the metafile.
    b = bEmitWin16Poly(pLocalDC, (LPPOINTS) pptlBuff, (SHORT) cptl,
        (WORD) (mrType == EMR_POLYLINE ? META_POLYLINE : META_POLYGON)) ;

    // Free the memory used as the transform buffer.
exit2:
    if (LocalFree(pptlBuff))
    ASSERTGDI(FALSE, "MF3216: DoPoly, LocalFree failed");
exit1:
    return(b) ;
}


/***************************************************************************
 * vCompressPoints - Utility routine to compress the POINTLs to POINTSs.
 **************************************************************************/
VOID vCompressPoints(PVOID pBuff, LONG nCount)
{
PPOINTL pPointl ;
PPOINTS pPoints ;
INT     i ;

    pPointl = (PPOINTL) pBuff ;
    pPoints = (PPOINTS) pBuff ;

    for (i = 0 ; i < nCount ; i++)
    {
        pPoints[i].x = LOWORD(pPointl[i].x) ;
        pPoints[i].y = LOWORD(pPointl[i].y) ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\gpmf3216\handlers.c ===
/****************************************************************************
*  Handlers.c - Handlers for the Win32 metafile  records
*
*  DATE:   11-Dec-1991
*  Author: Jeffrey Newman (c-jeffn)
*
*  Copyright (c) Microsoft Inc. 1991
****************************************************************************/


#include "precomp.h"
#include <wtypes.h>
#pragma hdrstop

extern fnSetVirtualResolution pfnSetVirtualResolution;

// Max number of pointl's allowed on stack before explicit memory allocation.

#define MAX_STACK_POINTL    128

// Convert array of POINTSs to POINTLs.

#define POINTS_TO_POINTL(pptl, ppts, cpt)           \
    {                               \
    DWORD i;                        \
    for (i = 0; i < (cpt); i++)             \
    {                           \
    (pptl)[i].x = (LONG) (ppts)[i].x;           \
    (pptl)[i].y = (LONG) (ppts)[i].y;           \
    }                           \
    }

DWORD GetCodePage(HDC hdc);

/**************************************************************************
* Handler - NotImplemented
*
* The following 32-bit records have no equivalent 16-bit metafile records:
*      SETBRUSHORGEX
*
*************************************************************************/
BOOL bHandleNotImplemented(PVOID pVoid, PLOCALDC pLocalDC)
{
    PENHMETARECORD pemr ;
    INT            iType ;

    NOTUSED(pLocalDC) ;

    pemr = (PENHMETARECORD) pVoid ;
    iType = pemr->iType ;

    if (iType != EMR_SETBRUSHORGEX
        && iType != EMR_SETCOLORADJUSTMENT
        && iType != EMR_SETMITERLIMIT
        && iType != EMR_SETICMMODE
        && iType != EMR_CREATECOLORSPACE
        && iType != EMR_SETCOLORSPACE
        && iType != EMR_DELETECOLORSPACE
        && iType != EMR_GLSRECORD
        && iType != EMR_GLSBOUNDEDRECORD
        && iType != EMR_PIXELFORMAT)
    {
        PUTS1("MF3216: bHandleNotImplemented - record not supported: %d\n", iType) ;
    }
    return(TRUE) ;
}


/**************************************************************************
* Handler - GdiComment
*************************************************************************/
BOOL bHandleGdiComment(PVOID pVoid, PLOCALDC pLocalDC)
{
    return(DoGdiComment(pLocalDC, (PEMR) pVoid));
}


/**************************************************************************
* Handler - SetPaletteEntries
*************************************************************************/
BOOL bHandleSetPaletteEntries(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL     b ;
    PEMRSETPALETTEENTRIES pMfSetPaletteEntries ;
    DWORD    ihPal, iStart, cEntries ;
    PPALETTEENTRY   pPalEntry ;

    pMfSetPaletteEntries = (PEMRSETPALETTEENTRIES) pVoid ;

    // Now do the translation.

    ihPal     = pMfSetPaletteEntries->ihPal ;
    iStart    = pMfSetPaletteEntries->iStart ;
    cEntries  = pMfSetPaletteEntries->cEntries ;
    pPalEntry = pMfSetPaletteEntries->aPalEntries ;

    b = DoSetPaletteEntries(pLocalDC, ihPal, iStart, cEntries, pPalEntry) ;

    return (b) ;
}


/**************************************************************************
* Handler - CreatePalette
*************************************************************************/
BOOL bHandleCreatePalette(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRCREATEPALETTE pMfCreatePalette ;
    LPLOGPALETTE     lpLogPal ;
    DWORD   ihPal ;

    pMfCreatePalette = (PEMRCREATEPALETTE) pVoid ;

    // Now do the translation.

    ihPal    = pMfCreatePalette->ihPal ;
    lpLogPal = &pMfCreatePalette->lgpl ;

    b = DoCreatePalette(pLocalDC, ihPal, lpLogPal) ;

    return (b) ;
}


/**************************************************************************
* Handler - RealizePalette
*************************************************************************/
BOOL bHandleRealizePalette(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL     b ;

    NOTUSED(pVoid);

    // Now do the translation.

    b = DoRealizePalette(pLocalDC) ;

    return (b) ;
}


/**************************************************************************
* Handler - ResizePalette
*************************************************************************/
BOOL bHandleResizePalette(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL     b ;
    PEMRRESIZEPALETTE pMfResizePalette ;
    DWORD    ihPal, cEntries ;

    pMfResizePalette = (PEMRRESIZEPALETTE) pVoid ;

    // Now do the translation.

    ihPal    = pMfResizePalette->ihPal ;
    cEntries = pMfResizePalette->cEntries ;

    b = DoResizePalette(pLocalDC, ihPal, cEntries) ;

    return (b) ;
}


/**************************************************************************
* Handler - SelectPalette
*************************************************************************/
BOOL bHandleSelectPalette(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL     b ;
    PEMRSELECTPALETTE pMfSelectPalette ;
    DWORD    ihPal ;

    pMfSelectPalette = (PEMRSELECTPALETTE) pVoid ;

    // Now do the translation.

    ihPal = pMfSelectPalette->ihPal ;

    b = DoSelectPalette(pLocalDC, ihPal) ;

    return (b) ;
}

/**************************************************************************
* Handler - OffsetClipRgn
*************************************************************************/
BOOL bHandleOffsetClipRgn(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL        b ;
    PEMROFFSETCLIPRGN pMfOffsetClipRgn ;
    INT      x, y ;

    pMfOffsetClipRgn = (PEMROFFSETCLIPRGN) pVoid ;

    // Now do the translation.

    x = pMfOffsetClipRgn->ptlOffset.x ;
    y = pMfOffsetClipRgn->ptlOffset.y ;

    b = DoOffsetClipRgn(pLocalDC, x, y) ;

    return (b) ;
}

/**************************************************************************
* Handler - ExtSelectClipRgn
*************************************************************************/
BOOL bHandleExtSelectClipRgn(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL        b ;
    PEMREXTSELECTCLIPRGN pMfExtSelectClipRgn ;
    INT        cbRgnData, iMode ;
    LPRGNDATA  pRgnData ;

    pMfExtSelectClipRgn = (PEMREXTSELECTCLIPRGN) pVoid ;

    // Now do the translation.

    cbRgnData = pMfExtSelectClipRgn->cbRgnData ;
    pRgnData = (LPRGNDATA) pMfExtSelectClipRgn->RgnData;
    iMode    = pMfExtSelectClipRgn->iMode ;

    b = DoExtSelectClipRgn(pLocalDC, cbRgnData, pRgnData, iMode) ;

    return (b) ;
}


/**************************************************************************
* Handler - SetMetaRgn
*************************************************************************/
BOOL bHandleSetMetaRgn(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;

    NOTUSED(pVoid) ;

    b = DoSetMetaRgn(pLocalDC) ;

    return(b) ;
}


/**************************************************************************
* Handler - PaintRgn
*************************************************************************/
BOOL bHandlePaintRgn(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL        b ;
    PEMRPAINTRGN pMfPaintRgn ;
    INT      cbRgnData;
    LPRGNDATA    pRgnData ;

    pMfPaintRgn = (PEMRPAINTRGN) pVoid ;

    // Now do the translation.

    cbRgnData  = pMfPaintRgn->cbRgnData ;
    pRgnData   = (LPRGNDATA) pMfPaintRgn->RgnData;

    b = DoDrawRgn(pLocalDC, 0, 0, 0, cbRgnData, pRgnData, EMR_PAINTRGN);

    return (b) ;
}

/**************************************************************************
* Handler - InvertRgn
*************************************************************************/
BOOL bHandleInvertRgn(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL        b ;
    PEMRINVERTRGN pMfInvertRgn ;
    INT      cbRgnData;
    LPRGNDATA    pRgnData ;

    pMfInvertRgn = (PEMRINVERTRGN) pVoid ;

    // Now do the translation.

    cbRgnData  = pMfInvertRgn->cbRgnData ;
    pRgnData   = (LPRGNDATA) pMfInvertRgn->RgnData;

    b = DoDrawRgn(pLocalDC, 0, 0, 0, cbRgnData, pRgnData, EMR_INVERTRGN);

    return (b) ;
}


/**************************************************************************
* Handler - FrameRgn
*************************************************************************/
BOOL bHandleFrameRgn(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL        b ;
    PEMRFRAMERGN pMfFrameRgn ;
    INT     ihBrush,
        cbRgnData,
        nWidth,
        nHeight ;
    LPRGNDATA   pRgnData ;

    pMfFrameRgn = (PEMRFRAMERGN) pVoid ;

    // Now do the translation.

    ihBrush    = pMfFrameRgn->ihBrush ;
    nWidth     = pMfFrameRgn->szlStroke.cx ;
    nHeight    = pMfFrameRgn->szlStroke.cy ;
    cbRgnData  = pMfFrameRgn->cbRgnData ;
    pRgnData   = (LPRGNDATA) pMfFrameRgn->RgnData;

    b = DoDrawRgn(pLocalDC, ihBrush, nWidth, nHeight, cbRgnData, pRgnData, EMR_FRAMERGN);

    return (b) ;
}

/**************************************************************************
* Handler - FillRgn
*************************************************************************/
BOOL bHandleFillRgn(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL        b ;
    PEMRFILLRGN pMfFillRgn ;
    INT    ihBrush,
        cbRgnData;
    LPRGNDATA  pRgnData ;


    // Set up the pointer the Doer uses to reference the
    // the Win32 drawing order.  Also setup the drawing order specific
    // pointer.

    pMfFillRgn = (PEMRFILLRGN) pVoid ;

    // Now do the translation.

    ihBrush    = pMfFillRgn->ihBrush ;
    cbRgnData  = pMfFillRgn->cbRgnData ;
    pRgnData   = (LPRGNDATA) pMfFillRgn->RgnData;

    b = DoDrawRgn(pLocalDC, ihBrush, 0, 0, cbRgnData, pRgnData, EMR_FILLRGN);

    return (b) ;
}


/**************************************************************************
* Handler - IntersectClipRect
*************************************************************************/
BOOL bHandleIntersectClipRect(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL        b ;
    PEMRINTERSECTCLIPRECT pMfIntersectClipRect ;
    INT xLeft, yTop, xRight, yBottom ;


    pMfIntersectClipRect = (PEMRINTERSECTCLIPRECT) pVoid ;

    // Now do the translation.
    xLeft   = pMfIntersectClipRect->rclClip.left ;
    yTop    = pMfIntersectClipRect->rclClip.top ;
    xRight  = pMfIntersectClipRect->rclClip.right ;
    yBottom = pMfIntersectClipRect->rclClip.bottom ;

    b = DoClipRect(pLocalDC, xLeft, yTop, xRight, yBottom, EMR_INTERSECTCLIPRECT) ;

    return (b) ;

}

/**************************************************************************
* Handler - ExcludeClipRect
*************************************************************************/
BOOL bHandleExcludeClipRect(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL        b ;
    PEMREXCLUDECLIPRECT pMfExcludeClipRect ;
    INT xLeft, yTop, xRight, yBottom ;


    pMfExcludeClipRect = (PEMREXCLUDECLIPRECT) pVoid ;

    // Now do the translation.
    xLeft   = pMfExcludeClipRect->rclClip.left ;
    yTop    = pMfExcludeClipRect->rclClip.top ;
    xRight  = pMfExcludeClipRect->rclClip.right ;
    yBottom = pMfExcludeClipRect->rclClip.bottom ;

    b = DoClipRect(pLocalDC, xLeft, yTop, xRight, yBottom, EMR_EXCLUDECLIPRECT) ;

    return (b) ;

}


/**************************************************************************
* Handler - SetPixel
*************************************************************************/
BOOL bHandleSetPixel(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL        b ;
    PEMRSETPIXELV pMfSetPixel ;
    INT     x, y ;
    COLORREF    crColor ;

    pMfSetPixel = (PEMRSETPIXELV) pVoid ;

    // Now do the translation.

    x   = (INT) pMfSetPixel->ptlPixel.x ;
    y   = (INT) pMfSetPixel->ptlPixel.y ;
    crColor = pMfSetPixel->crColor ;

    b = DoSetPixel(pLocalDC, x, y, crColor) ;

    return (b) ;
}


/**************************************************************************
* Handler - ExtFloodFill
*************************************************************************/
BOOL bHandleExtFloodFill(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL            b ;
    PEMREXTFLOODFILL pMfExtFloodFill ;
    INT         x, y ;
    COLORREF        crColor ;
    DWORD           iMode ;

    pMfExtFloodFill = (PEMREXTFLOODFILL) pVoid ;

    // Now do the translation.

    x   = (INT) pMfExtFloodFill->ptlStart.x ;
    y   = (INT) pMfExtFloodFill->ptlStart.y ;
    crColor = pMfExtFloodFill->crColor ;
    iMode   = pMfExtFloodFill->iMode ;

    b = DoExtFloodFill(pLocalDC, x, y, crColor, iMode) ;

    return (b) ;
}


/**************************************************************************
* Handler - ModifyWorldTransform
*************************************************************************/
BOOL bHandleModifyWorldTransform(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRMODIFYWORLDTRANSFORM pMfModifyWorldTransform ;
    PXFORM  pxform ;
    DWORD   iMode ;


    pMfModifyWorldTransform = (PEMRMODIFYWORLDTRANSFORM) pVoid ;

    // get a pointer to the xform matrix

    pxform = &pMfModifyWorldTransform->xform ;
    iMode  = pMfModifyWorldTransform->iMode ;

    // Now do the translation.

    b = DoModifyWorldTransform(pLocalDC, pxform, iMode) ;

    return (b) ;
}


/**************************************************************************
* Handler - SetWorldTransform
*************************************************************************/
BOOL bHandleSetWorldTransform(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRSETWORLDTRANSFORM pMfSetWorldTransform ;
    PXFORM  pxform ;


    pMfSetWorldTransform = (PEMRSETWORLDTRANSFORM) pVoid ;

    // get a pointer to the xform matrix

    pxform = &pMfSetWorldTransform->xform ;

    // Now do the translation.

    b = DoSetWorldTransform(pLocalDC, pxform) ;

    return (b) ;
}


/**************************************************************************
* Handler - PolyBezierTo
*************************************************************************/
BOOL bHandlePolyBezierTo(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRPOLYBEZIERTO pMfPolyBezierTo ;
    DWORD   nCount ;
    PPOINTL pptl ;

    pMfPolyBezierTo = (PEMRPOLYBEZIERTO) pVoid ;

    // Copy the BezierTo count and the polyBezierTo verticies to
    // the record.

    nCount = pMfPolyBezierTo->cptl ;
    pptl   = pMfPolyBezierTo->aptl ;

    // Now do the translation.

    b = DoPolyBezierTo(pLocalDC, (LPPOINT) pptl, nCount) ;

    return (b) ;
}


/**************************************************************************
* Handler - PolyDraw
*************************************************************************/
BOOL bHandlePolyDraw(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRPOLYDRAW pMfPolyDraw ;
    DWORD   nCount ;
    PPOINTL pptl ;
    PBYTE   pb ;

    pMfPolyDraw = (PEMRPOLYDRAW) pVoid ;

    // Copy the Draw count and the polyDraw verticies to
    // the record.

    nCount = pMfPolyDraw->cptl ;
    pptl   = pMfPolyDraw->aptl ;
    pb     = (PBYTE) &pMfPolyDraw->aptl[nCount];

    // Now do the translation.

    b = DoPolyDraw(pLocalDC, (LPPOINT) pptl, pb, nCount) ;

    return (b) ;
}


/**************************************************************************
* Handler - PolyBezier
*************************************************************************/
BOOL bHandlePolyBezier(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRPOLYBEZIER pMfPolyBezier ;
    DWORD   nCount ;
    PPOINTL pptl ;

    pMfPolyBezier = (PEMRPOLYBEZIER) pVoid ;

    // Copy the Bezier count and the polyBezier verticies to
    // the record.

    nCount = pMfPolyBezier->cptl ;
    pptl   = pMfPolyBezier->aptl ;

    // Now do the translation.

    b = DoPolyBezier(pLocalDC, (LPPOINT) pptl, nCount) ;

    return (b) ;
}


/**************************************************************************
* Handler - Begin Path
*************************************************************************/
BOOL bHandleBeginPath(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;

    NOTUSED(pVoid) ;

    b = DoBeginPath(pLocalDC) ;

    return (b) ;
}

/**************************************************************************
* Handler - End Path
*************************************************************************/
BOOL bHandleEndPath(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;

    NOTUSED(pVoid) ;

    b = DoEndPath(pLocalDC) ;

    return (b) ;
}

/**************************************************************************
* Handler - Flatten Path
*************************************************************************/
BOOL bHandleFlattenPath(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;

    NOTUSED(pVoid) ;

    b = DoFlattenPath(pLocalDC) ;

    return (b) ;
}

/**************************************************************************
* Handler - CloseFigure
*************************************************************************/
BOOL bHandleCloseFigure(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;

    NOTUSED(pVoid) ;

    b = DoCloseFigure(pLocalDC) ;

    return (b) ;
}

/**************************************************************************
* Handler - Abort Path
*************************************************************************/
BOOL bHandleAbortPath(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;

    NOTUSED(pVoid) ;

    b = DoAbortPath(pLocalDC) ;

    return (b) ;
}

/**************************************************************************
* Handler - Stroke Path
*************************************************************************/
BOOL bHandleStrokePath(PVOID pVoid, PLOCALDC pLocalDC)
{
    NOTUSED(pVoid) ;

    return(DoRenderPath(pLocalDC, EMR_STROKEPATH, FALSE));
}

/**************************************************************************
* Handler - Fill Path
*************************************************************************/
BOOL bHandleFillPath(PVOID pVoid, PLOCALDC pLocalDC)
{
    NOTUSED(pVoid) ;

    return(DoRenderPath(pLocalDC, EMR_FILLPATH, FALSE));
}

/**************************************************************************
* Handler - Stroke and Fill Path
*************************************************************************/
BOOL bHandleStrokeAndFillPath(PVOID pVoid, PLOCALDC pLocalDC)
{
    NOTUSED(pVoid) ;

    return(DoRenderPath(pLocalDC, EMR_STROKEANDFILLPATH, FALSE));
}

/**************************************************************************
* Handler - Widen Path
*************************************************************************/
BOOL bHandleWidenPath(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;

    NOTUSED(pVoid) ;

    b = DoWidenPath(pLocalDC) ;

    return(b) ;
}

/**************************************************************************
* Handler - Select Clip Path
*************************************************************************/
BOOL bHandleSelectClipPath(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRSELECTCLIPPATH   pMfSelectClipPath ;
    INT     iMode ;

    pMfSelectClipPath = (PEMRSELECTCLIPPATH) pVoid ;

    iMode = (INT) pMfSelectClipPath->iMode ;

    b = DoSelectClipPath(pLocalDC, iMode) ;

    return(b) ;
}

/**************************************************************************
* Handler - StretchDIBits
*************************************************************************/
BOOL bHandleStretchDIBits(PVOID pVoid, PLOCALDC pLocalDC)
{
    PEMRSTRETCHDIBITS pMfStretchDIBits ;

    BOOL    b ;
    LONG    xDest ;
    LONG    yDest ;
    LONG    xSrc ;
    LONG    ySrc ;
    LONG    cxSrc ;
    LONG    cySrc ;
    DWORD   offBmiSrc ;
    DWORD   cbBmiSrc ;
    DWORD   offBitsSrc ;
    DWORD   cbBitsSrc ;
    DWORD   iUsageSrc ;
    DWORD   dwRop ;
    LONG    cxDest ;
    LONG    cyDest ;

    LPBITMAPINFO    lpBitmapInfo ;
    LPBYTE          lpBits ;

    pMfStretchDIBits = (PEMRSTRETCHDIBITS) pVoid ;

    xDest      = pMfStretchDIBits->xDest ;
    yDest      = pMfStretchDIBits->yDest ;
    xSrc       = pMfStretchDIBits->xSrc ;
    ySrc       = pMfStretchDIBits->ySrc ;
    cxSrc      = pMfStretchDIBits->cxSrc ;
    cySrc      = pMfStretchDIBits->cySrc ;
    offBmiSrc  = pMfStretchDIBits->offBmiSrc ;
    cbBmiSrc   = pMfStretchDIBits->cbBmiSrc ;
    offBitsSrc = pMfStretchDIBits->offBitsSrc ;
    cbBitsSrc  = pMfStretchDIBits->cbBitsSrc ;
    iUsageSrc  = pMfStretchDIBits->iUsageSrc ;
    dwRop      = pMfStretchDIBits->dwRop;
    cxDest     = pMfStretchDIBits->cxDest ;
    cyDest     = pMfStretchDIBits->cyDest ;

    lpBitmapInfo = (LPBITMAPINFO) ((PBYTE) pMfStretchDIBits + offBmiSrc) ;
    lpBits = (PBYTE) pMfStretchDIBits + offBitsSrc ;

    b = DoStretchDIBits(pLocalDC,
        xDest,
        yDest,
        cxDest,
        cyDest,
        dwRop,
        xSrc,
        ySrc,
        cxSrc,
        cySrc,
        iUsageSrc,
        lpBitmapInfo,
        cbBmiSrc,
        lpBits,
        cbBitsSrc ) ;
    return(b) ;
}

/**************************************************************************
* Handler - SetDIBitsToDevice
*************************************************************************/
BOOL bHandleSetDIBitsToDevice(PVOID pVoid, PLOCALDC pLocalDC)
{
    PEMRSETDIBITSTODEVICE pMfSetDIBitsToDevice ;

    BOOL    b ;
    LONG    xDest ;
    LONG    yDest ;
    LONG    xSrc ;
    LONG    ySrc ;
    LONG    cxSrc ;
    LONG    cySrc ;
    DWORD   offBmiSrc ;
    DWORD   cbBmiSrc ;
    DWORD   offBitsSrc ;
    DWORD   cbBitsSrc ;
    DWORD   iUsageSrc ;
    DWORD   iStartScan ;
    DWORD   cScans ;

    LPBITMAPINFO    lpBitmapInfo ;
    LPBYTE          lpBits ;

    pMfSetDIBitsToDevice = (PEMRSETDIBITSTODEVICE) pVoid ;

    xDest       = pMfSetDIBitsToDevice->xDest ;
    yDest       = pMfSetDIBitsToDevice->yDest ;
    xSrc        = pMfSetDIBitsToDevice->xSrc ;
    ySrc        = pMfSetDIBitsToDevice->ySrc ;
    cxSrc       = pMfSetDIBitsToDevice->cxSrc ;
    cySrc       = pMfSetDIBitsToDevice->cySrc ;
    offBmiSrc   = pMfSetDIBitsToDevice->offBmiSrc ;
    cbBmiSrc    = pMfSetDIBitsToDevice->cbBmiSrc ;
    offBitsSrc  = pMfSetDIBitsToDevice->offBitsSrc ;
    cbBitsSrc   = pMfSetDIBitsToDevice->cbBitsSrc ;
    iUsageSrc   = pMfSetDIBitsToDevice->iUsageSrc ;
    iStartScan  = pMfSetDIBitsToDevice->iStartScan ;
    cScans      = pMfSetDIBitsToDevice->cScans ;

    lpBitmapInfo = (LPBITMAPINFO) ((PBYTE) pMfSetDIBitsToDevice + offBmiSrc) ;
    lpBits = (PBYTE) pMfSetDIBitsToDevice + offBitsSrc ;

    b = DoSetDIBitsToDevice(pLocalDC,
        xDest,
        yDest,
        xSrc,
        ySrc,
        cxSrc,
        cySrc,
        iUsageSrc,
        iStartScan,
        cScans,
        lpBitmapInfo,
        cbBmiSrc,
        lpBits,
        cbBitsSrc ) ;

    return(b) ;
}


/**************************************************************************
* Handler - BitBlt
*************************************************************************/
BOOL bHandleBitBlt(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL        b ;
    PEMRBITBLT  pMfBitBlt ;
    LONG        xDest ;
    LONG        yDest ;
    LONG        cxDest ;
    LONG        cyDest ;
    DWORD       dwRop ;
    LONG        xSrc ;
    LONG        ySrc ;
    PXFORM      pxformSrc ;
    COLORREF    crBkColorSrc ;
    DWORD       iUsageSrc ;
    DWORD       offBmiSrc ;
    DWORD       cbBmiSrc ;
    DWORD       offBitsSrc ;
    DWORD       cbBitsSrc ;
    PBITMAPINFO pbmi ;
    LPBYTE      lpBits ;

    pMfBitBlt = (PEMRBITBLT) pVoid ;

    xDest        = pMfBitBlt->xDest ;
    yDest        = pMfBitBlt->yDest ;
    cxDest       = pMfBitBlt->cxDest ;
    cyDest       = pMfBitBlt->cyDest ;
    dwRop        = pMfBitBlt->dwRop ;
    xSrc         = pMfBitBlt->xSrc ;
    ySrc         = pMfBitBlt->ySrc ;
    pxformSrc    =&(pMfBitBlt->xformSrc) ;
    crBkColorSrc = pMfBitBlt->crBkColorSrc ;        // not used

    iUsageSrc    = pMfBitBlt->iUsageSrc ;
    offBmiSrc    = pMfBitBlt->offBmiSrc ;
    cbBmiSrc     = pMfBitBlt->cbBmiSrc ;
    offBitsSrc   = pMfBitBlt->offBitsSrc ;
    cbBitsSrc    = pMfBitBlt->cbBitsSrc ;

    lpBits = (PBYTE) pMfBitBlt + offBitsSrc ;
    pbmi   = (PBITMAPINFO) ((PBYTE) pMfBitBlt + offBmiSrc) ;

    b = DoStretchBlt(pLocalDC,
        xDest,
        yDest,
        cxDest,
        cyDest,
        dwRop,
        xSrc,
        ySrc,
        cxDest,
        cyDest,
        pxformSrc,
        iUsageSrc,
        pbmi,
        cbBmiSrc,
        lpBits,
        cbBitsSrc);
    return(b) ;
}


/**************************************************************************
* Handler - StretchBlt
*************************************************************************/
BOOL bHandleStretchBlt(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL        b ;
    PEMRSTRETCHBLT   pMfStretchBlt ;
    LONG        xDest ;
    LONG        yDest ;
    LONG        cxDest ;
    LONG        cyDest ;
    DWORD       dwRop ;
    LONG        xSrc ;
    LONG        ySrc ;
    LONG        cxSrc ;
    LONG        cySrc ;
    PXFORM      pxformSrc ;
    COLORREF    crBkColorSrc ;
    DWORD       iUsageSrc ;
    DWORD       offBmiSrc ;
    DWORD       cbBmiSrc ;
    DWORD       offBitsSrc ;
    DWORD       cbBitsSrc ;
    PBITMAPINFO pbmi ;
    LPBYTE      lpBits ;

    pMfStretchBlt = (PEMRSTRETCHBLT) pVoid ;

    xDest          = pMfStretchBlt->xDest ;
    yDest          = pMfStretchBlt->yDest ;
    cxDest         = pMfStretchBlt->cxDest ;
    cyDest         = pMfStretchBlt->cyDest ;
    dwRop          = pMfStretchBlt->dwRop ;
    xSrc           = pMfStretchBlt->xSrc ;
    ySrc           = pMfStretchBlt->ySrc ;
    pxformSrc      =&(pMfStretchBlt->xformSrc) ;
    crBkColorSrc   = pMfStretchBlt->crBkColorSrc ;  // not used

    iUsageSrc      = pMfStretchBlt->iUsageSrc ;
    offBmiSrc      = pMfStretchBlt->offBmiSrc ;
    cbBmiSrc       = pMfStretchBlt->cbBmiSrc ;
    offBitsSrc     = pMfStretchBlt->offBitsSrc ;
    cbBitsSrc      = pMfStretchBlt->cbBitsSrc ;

    lpBits = (PBYTE) pMfStretchBlt + offBitsSrc ;
    pbmi   = (PBITMAPINFO) ((PBYTE) pMfStretchBlt + offBmiSrc) ;

    cxSrc          = pMfStretchBlt->cxSrc ;
    cySrc          = pMfStretchBlt->cySrc ;


    b = DoStretchBlt(pLocalDC,
        xDest,
        yDest,
        cxDest,
        cyDest,
        dwRop,
        xSrc,
        ySrc,
        cxSrc,
        cySrc,
        pxformSrc,
        iUsageSrc,
        pbmi,
        cbBmiSrc,
        lpBits,
        cbBitsSrc);
    return(b) ;
}


/**************************************************************************
* Handler - MaskBlt
*************************************************************************/
BOOL bHandleMaskBlt(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL        b ;
    PEMRMASKBLT  pMfMaskBlt ;
    LONG        xDest ;
    LONG        yDest ;
    LONG        cxDest ;
    LONG        cyDest ;
    DWORD       dwRop ;
    LONG        xSrc ;
    LONG        ySrc ;
    PXFORM      pxformSrc ;
    COLORREF    crBkColorSrc ;
    DWORD       iUsageSrc ;
    DWORD       offBmiSrc ;
    DWORD       cbBmiSrc ;
    DWORD       offBitsSrc ;
    DWORD       cbBitsSrc ;
    PBITMAPINFO pbmi ;
    LPBYTE      lpBits ;
    LONG        xMask ;
    LONG        yMask ;
    DWORD       iUsageMask ;
    DWORD       offBmiMask ;
    DWORD       cbBmiMask ;
    DWORD       offBitsMask ;
    DWORD       cbBitsMask ;
    PBITMAPINFO pbmiMask ;
    LPBYTE      lpMaskBits ;

    pMfMaskBlt   = (PEMRMASKBLT) pVoid ;

    xDest        = pMfMaskBlt->xDest ;
    yDest        = pMfMaskBlt->yDest ;
    cxDest       = pMfMaskBlt->cxDest ;
    cyDest       = pMfMaskBlt->cyDest ;
    dwRop        = pMfMaskBlt->dwRop ;
    xSrc         = pMfMaskBlt->xSrc ;
    ySrc         = pMfMaskBlt->ySrc ;
    pxformSrc    =&(pMfMaskBlt->xformSrc) ;
    crBkColorSrc = pMfMaskBlt->crBkColorSrc ;       // not used

    iUsageSrc    = pMfMaskBlt->iUsageSrc ;
    offBmiSrc    = pMfMaskBlt->offBmiSrc ;
    cbBmiSrc     = pMfMaskBlt->cbBmiSrc ;
    offBitsSrc   = pMfMaskBlt->offBitsSrc ;
    cbBitsSrc    = pMfMaskBlt->cbBitsSrc ;

    lpBits = (PBYTE) pMfMaskBlt + offBitsSrc ;
    pbmi   = (PBITMAPINFO) ((PBYTE) pMfMaskBlt + offBmiSrc) ;

    xMask        = pMfMaskBlt->xMask ;
    yMask        = pMfMaskBlt->yMask ;
    iUsageMask   = pMfMaskBlt->iUsageMask ;
    offBmiMask   = pMfMaskBlt->offBmiMask ;
    cbBmiMask    = pMfMaskBlt->cbBmiMask ;
    offBitsMask  = pMfMaskBlt->offBitsMask ;
    cbBitsMask   = pMfMaskBlt->cbBitsMask ;

    lpMaskBits = (PBYTE) pMfMaskBlt + offBitsMask ;
    pbmiMask   = (PBITMAPINFO) ((PBYTE) pMfMaskBlt + offBmiMask) ;

    b = DoMaskBlt(pLocalDC,
        xDest,
        yDest,
        cxDest,
        cyDest,
        dwRop,
        xSrc,
        ySrc,
        pxformSrc,
        iUsageSrc,
        pbmi,
        cbBmiSrc,
        lpBits,
        cbBitsSrc,
        xMask,
        yMask,
        iUsageMask,
        pbmiMask,
        cbBmiMask,
        lpMaskBits,
        cbBitsMask);

    return(b) ;
}


/**************************************************************************
* Handler - PlgBlt
*************************************************************************/
BOOL bHandlePlgBlt(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL        b ;
    PEMRPLGBLT   pMfPlgBlt ;
    PPOINTL     pptlDest ;
    LONG        xSrc ;
    LONG        ySrc ;
    LONG        cxSrc ;
    LONG        cySrc ;
    PXFORM      pxformSrc ;
    COLORREF    crBkColorSrc ;
    DWORD       iUsageSrc ;
    DWORD       offBmiSrc ;
    DWORD       cbBmiSrc ;
    DWORD       offBitsSrc ;
    DWORD       cbBitsSrc ;
    PBITMAPINFO pbmi ;
    LPBYTE      lpBits ;
    LONG        xMask ;
    LONG        yMask ;
    DWORD       iUsageMask ;
    DWORD       offBmiMask ;
    DWORD       cbBmiMask ;
    DWORD       offBitsMask ;
    DWORD       cbBitsMask ;
    PBITMAPINFO pbmiMask ;
    LPBYTE      lpMaskBits ;

    pMfPlgBlt    = (PEMRPLGBLT) pVoid ;

    pptlDest     = pMfPlgBlt->aptlDest ;
    xSrc         = pMfPlgBlt->xSrc ;
    ySrc         = pMfPlgBlt->ySrc ;
    cxSrc        = pMfPlgBlt->cxSrc ;
    cySrc        = pMfPlgBlt->cySrc ;
    pxformSrc    =&(pMfPlgBlt->xformSrc) ;
    crBkColorSrc = pMfPlgBlt->crBkColorSrc ;        // not used

    iUsageSrc    = pMfPlgBlt->iUsageSrc ;
    offBmiSrc    = pMfPlgBlt->offBmiSrc ;
    cbBmiSrc     = pMfPlgBlt->cbBmiSrc ;
    offBitsSrc   = pMfPlgBlt->offBitsSrc ;
    cbBitsSrc    = pMfPlgBlt->cbBitsSrc ;

    lpBits = (PBYTE) pMfPlgBlt + offBitsSrc ;
    pbmi   = (PBITMAPINFO) ((PBYTE) pMfPlgBlt + offBmiSrc) ;

    xMask        = pMfPlgBlt->xMask ;
    yMask        = pMfPlgBlt->yMask ;
    iUsageMask   = pMfPlgBlt->iUsageMask ;
    offBmiMask   = pMfPlgBlt->offBmiMask ;
    cbBmiMask    = pMfPlgBlt->cbBmiMask ;
    offBitsMask  = pMfPlgBlt->offBitsMask ;
    cbBitsMask   = pMfPlgBlt->cbBitsMask ;

    lpMaskBits = (PBYTE) pMfPlgBlt + offBitsMask ;
    pbmiMask   = (PBITMAPINFO) ((PBYTE) pMfPlgBlt + offBmiMask) ;

    b = DoPlgBlt(pLocalDC,
        pptlDest,
        xSrc,
        ySrc,
        cxSrc,
        cySrc,
        pxformSrc,
        iUsageSrc,
        pbmi,
        cbBmiSrc,
        lpBits,
        cbBitsSrc,
        xMask,
        yMask,
        iUsageMask,
        pbmiMask,
        cbBmiMask,
        lpMaskBits,
        cbBitsMask);

    return(b) ;
}


/**************************************************************************
* Handler - Save DC
*************************************************************************/
BOOL bHandleSaveDC(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL        b ;

    NOTUSED(pVoid) ;

    b = DoSaveDC(pLocalDC) ;

    return(b) ;
}


/**************************************************************************
* Handler - Restore DC
*************************************************************************/
BOOL bHandleRestoreDC(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL            b ;
    PEMRRESTOREDC   pMfRestoreDc ;
    INT             nSavedDC ;

    pMfRestoreDc = (PEMRRESTOREDC) pVoid ;

    nSavedDC = (INT) pMfRestoreDc->iRelative ;

    b = DoRestoreDC(pLocalDC, nSavedDC) ;

    return(b) ;
}


/**************************************************************************
* Handler - End of File
*************************************************************************/
BOOL bHandleEOF(PVOID pVoid, PLOCALDC pLocalDC)
{

    NOTUSED(pVoid) ;

    DoEOF(pLocalDC) ;

    return (TRUE) ;
}

/**************************************************************************
* Handler - Header
*************************************************************************/
BOOL bHandleHeader(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PENHMETAHEADER pemfheader ;

    pemfheader = (PENHMETAHEADER) pVoid ;

    b = DoHeader(pLocalDC, pemfheader) ;

    return (b) ;
}

/**************************************************************************
* Handler - ScaleWindowExtEx
*************************************************************************/
BOOL bHandleScaleWindowExt(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRSCALEWINDOWEXTEX pMfScaleWindowExt ;
    INT     Xnum,
        Xdenom,
        Ynum,
        Ydenom ;


    pMfScaleWindowExt = (PEMRSCALEWINDOWEXTEX) pVoid ;

    // Scale the MapMode Mode

    Xnum   = (INT) pMfScaleWindowExt->xNum ;
    Xdenom = (INT) pMfScaleWindowExt->xDenom ;
    Ynum   = (INT) pMfScaleWindowExt->yNum ;
    Ydenom = (INT) pMfScaleWindowExt->yDenom ;

    // Do the translation.

    b = DoScaleWindowExt(pLocalDC, Xnum, Xdenom, Ynum, Ydenom) ;

    return (b) ;
}


/**************************************************************************
* Handler - ScaleViewportExtEx
*************************************************************************/
BOOL bHandleScaleViewportExt(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRSCALEVIEWPORTEXTEX pMfScaleViewportExt ;
    INT     Xnum,
        Xdenom,
        Ynum,
        Ydenom ;


    pMfScaleViewportExt = (PEMRSCALEVIEWPORTEXTEX) pVoid ;

    // Scale the MapMode Mode

    Xnum   = (INT) pMfScaleViewportExt->xNum ;
    Xdenom = (INT) pMfScaleViewportExt->xDenom ;
    Ynum   = (INT) pMfScaleViewportExt->yNum ;
    Ydenom = (INT) pMfScaleViewportExt->yDenom ;

    // Do the translation.

    b = DoScaleViewportExt(pLocalDC, Xnum, Xdenom, Ynum, Ydenom) ;

    return (b) ;
}


/**************************************************************************
* Handler - SetViewportExtEx
*************************************************************************/
BOOL bHandleSetViewportExt(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRSETVIEWPORTEXTEX pMfSetViewportExt ;
    LONG    x, y ;

    pMfSetViewportExt = (PEMRSETVIEWPORTEXTEX) pVoid ;

    // Set the MapMode Mode

    x = pMfSetViewportExt->szlExtent.cx ;
    y = pMfSetViewportExt->szlExtent.cy ;

    // Do the translation.

    b = DoSetViewportExt(pLocalDC, (INT) x, (INT) y) ;

    return (b) ;
}


/**************************************************************************
* Handler - SetViewportOrgEx
*************************************************************************/
BOOL bHandleSetViewportOrg(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRSETVIEWPORTORGEX pMfSetViewportOrg ;
    LONG    x, y ;

    pMfSetViewportOrg = (PEMRSETVIEWPORTORGEX) pVoid ;

    // Set the MapMode Mode

    x = pMfSetViewportOrg->ptlOrigin.x ;
    y = pMfSetViewportOrg->ptlOrigin.y ;

    // Do the translation.

    b = DoSetViewportOrg(pLocalDC, (INT) x, (INT) y) ;

    return (b) ;
}


/**************************************************************************
* Handler - SetWindowExtEx
*************************************************************************/
BOOL bHandleSetWindowExt(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRSETWINDOWEXTEX pMfSetWindowExt ;
    LONG    x, y ;

    pMfSetWindowExt = (PEMRSETWINDOWEXTEX) pVoid ;

    // Set the MapMode Mode

    x = pMfSetWindowExt->szlExtent.cx ;
    y = pMfSetWindowExt->szlExtent.cy ;

    // Do the translation.

    b = DoSetWindowExt(pLocalDC, (INT) x, (INT) y) ;

    return (b) ;
}


/**************************************************************************
* Handler - SetWindowOrgEx
*************************************************************************/
BOOL bHandleSetWindowOrg(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRSETWINDOWORGEX pMfSetWindowOrg ;
    LONG    x, y ;

    pMfSetWindowOrg = (PEMRSETWINDOWORGEX) pVoid ;

    // Set the MapMode Mode

    x = pMfSetWindowOrg->ptlOrigin.x ;
    y = pMfSetWindowOrg->ptlOrigin.y ;

    // Do the translation.

    b = DoSetWindowOrg(pLocalDC, (INT) x, (INT) y) ;

    return (b) ;
}

/**************************************************************************
* Handler - SetMapMode
*************************************************************************/
BOOL bHandleSetMapMode(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    DWORD   iMapMode ;
    PEMRSETMAPMODE pMfSetMapMode ;

    pMfSetMapMode = (PEMRSETMAPMODE) pVoid ;

    // Set the MapMode Mode

    iMapMode = pMfSetMapMode->iMode ;

    // Do the translation.

    b = DoSetMapMode(pLocalDC, iMapMode) ;

    return (b) ;

}

/**************************************************************************
* Handler - SetArcDirection
*************************************************************************/
BOOL bHandleSetArcDirection(PVOID pVoid, PLOCALDC pLocalDC)
{
    PEMRSETARCDIRECTION pMfSetArcDirection ;
    INT             iArcDirection ;
    BOOL            b ;


    pMfSetArcDirection = (PEMRSETARCDIRECTION) pVoid ;

    iArcDirection = (INT) pMfSetArcDirection->iArcDirection ;

    b = DoSetArcDirection(pLocalDC, iArcDirection) ;

    return (b) ;
}


/**************************************************************************
* Handler - AngleArc
*************************************************************************/
BOOL bHandleAngleArc(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRANGLEARC  pMfAngleArc ;
    int     x, y;
    DWORD   nRadius ;
    FLOAT   eStartAngle,
        eSweepAngle ;

    pMfAngleArc = (PEMRANGLEARC) pVoid ;

    // Set the Arc center

    x  = (int) pMfAngleArc->ptlCenter.x ;
    y  = (int) pMfAngleArc->ptlCenter.y ;

    // Get the radius of the Arc

    nRadius = (INT) pMfAngleArc->nRadius ;

    // Set the start & sweep angles

    eStartAngle = pMfAngleArc->eStartAngle ;
    eSweepAngle = pMfAngleArc->eSweepAngle ;

    b = DoAngleArc(pLocalDC, x, y, nRadius, eStartAngle, eSweepAngle) ;

    return (b) ;
}


/**************************************************************************
* Handler - ArcTo
*************************************************************************/
BOOL bHandleArcTo(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRARCTO  pMfArcTo ;
    INT     x1, x2, x3, x4,
        y1, y2, y3, y4 ;

    pMfArcTo = (PEMRARCTO) pVoid ;

    // Set up the ellipse box, this will be the same as the bounding
    // rectangle.

    x1 = (INT) pMfArcTo->rclBox.left ;
    y1 = (INT) pMfArcTo->rclBox.top ;
    x2 = (INT) pMfArcTo->rclBox.right ;
    y2 = (INT) pMfArcTo->rclBox.bottom ;

    // Set the start point.

    x3 = (INT) pMfArcTo->ptlStart.x ;
    y3 = (INT) pMfArcTo->ptlStart.y ;

    // Set the end point.

    x4 = (INT) pMfArcTo->ptlEnd.x ;
    y4 = (INT) pMfArcTo->ptlEnd.y ;

    b = DoArcTo(pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4) ;

    return (b) ;
}


/**************************************************************************
* Handler - Arc
*************************************************************************/
BOOL bHandleArc(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRARC  pMfArc ;
    INT     x1, x2, x3, x4,
        y1, y2, y3, y4 ;

    pMfArc = (PEMRARC) pVoid ;

    // Set up the ellipse box, this will be the same as the bounding
    // rectangle.

    x1 = (INT) pMfArc->rclBox.left ;
    y1 = (INT) pMfArc->rclBox.top ;
    x2 = (INT) pMfArc->rclBox.right ;
    y2 = (INT) pMfArc->rclBox.bottom ;

    // Set the start point.

    x3 = (INT) pMfArc->ptlStart.x ;
    y3 = (INT) pMfArc->ptlStart.y ;

    // Set the end point.

    x4 = (INT) pMfArc->ptlEnd.x ;
    y4 = (INT) pMfArc->ptlEnd.y ;

    b = DoArc(pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4) ;

    return (b) ;
}


/**************************************************************************
* Handler - Ellipse
*************************************************************************/
BOOL bHandleEllipse(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    INT     x1, y1, x2, y2 ;
    PEMRELLIPSE  pMfEllipse ;

    pMfEllipse = (PEMRELLIPSE) pVoid ;

    // Set up the ellipse box, this will be the same as the bounding
    // rectangle.

    x1 = (INT) pMfEllipse->rclBox.left ;
    y1 = (INT) pMfEllipse->rclBox.top ;
    x2 = (INT) pMfEllipse->rclBox.right ;
    y2 = (INT) pMfEllipse->rclBox.bottom ;

    // Do the Ellipse translation.

    b = DoEllipse(pLocalDC, x1, y1, x2, y2) ;

    return (b) ;
}


/**************************************************************************
* Handler - SelectObject
*************************************************************************/
BOOL bHandleSelectObject(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRSELECTOBJECT pMfSelectObject ;
    INT     ihObject ;

    pMfSelectObject = (PEMRSELECTOBJECT) pVoid ;

    // Get the Object (it's really a Long)

    ihObject = (INT) pMfSelectObject->ihObject ;

    // Do the translation

    b = DoSelectObject(pLocalDC, ihObject) ;

    return (b) ;
}


/**************************************************************************
* Handler - DeleteObject
*************************************************************************/
BOOL bHandleDeleteObject(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRDELETEOBJECT pMfDeleteObject ;
    INT     ihObject ;


    pMfDeleteObject = (PEMRDELETEOBJECT) pVoid ;
    ihObject = (INT) pMfDeleteObject->ihObject ;
    b = DoDeleteObject(pLocalDC, ihObject) ;

    return(b) ;
}


/**************************************************************************
* Handler - CreateBrushIndirect
*************************************************************************/
BOOL bHandleCreateBrushIndirect(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRCREATEBRUSHINDIRECT  pMfCreateBrushIndirect ;
    LOGBRUSH LogBrush ;
    INT     ihBrush ;

    pMfCreateBrushIndirect = (PEMRCREATEBRUSHINDIRECT) pVoid ;

    // Get the Brush parameters.

    LogBrush.lbStyle = pMfCreateBrushIndirect->lb.lbStyle;
    LogBrush.lbColor = pMfCreateBrushIndirect->lb.lbColor;
    LogBrush.lbHatch = (ULONG_PTR)pMfCreateBrushIndirect->lb.lbHatch;

    ihBrush   = pMfCreateBrushIndirect->ihBrush ;

    // Do the translation.

    b = DoCreateBrushIndirect(pLocalDC, ihBrush, &LogBrush) ;

    return (b) ;
}

/**************************************************************************
* Handler - CreateMonoBrush
*************************************************************************/
BOOL bHandleCreateMonoBrush(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRCREATEMONOBRUSH  pMfCreateMonoBrush ;
    DWORD   ihBrush ;
    DWORD   iUsage ;
    DWORD   offBmi ;
    DWORD   cbBmi ;
    DWORD   offBits ;
    DWORD   cbBits ;

    PBITMAPINFO pBmi ;
    PBYTE       pBits ;

    pMfCreateMonoBrush = (PEMRCREATEMONOBRUSH) pVoid ;

    ihBrush     =    pMfCreateMonoBrush->ihBrush ;
    iUsage      =    pMfCreateMonoBrush->iUsage ;
    offBmi      =    pMfCreateMonoBrush->offBmi ;
    cbBmi       =    pMfCreateMonoBrush->cbBmi ;
    offBits     =    pMfCreateMonoBrush->offBits ;
    cbBits      =    pMfCreateMonoBrush->cbBits ;

    pBmi        = (PBITMAPINFO) ((PBYTE) pVoid + offBmi) ;
    pBits       = (PBYTE) pVoid + offBits ;

    b = DoCreateMonoBrush(pLocalDC, ihBrush,
        pBmi, cbBmi,
        pBits, cbBits,
        iUsage) ;
    return (b) ;
}

/**************************************************************************
* Handler - CreateDIBPatternBrush
*************************************************************************/
BOOL bHandleCreateDIBPatternBrush(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRCREATEDIBPATTERNBRUSHPT  pMfCreateDIBPatternBrush ;
    DWORD   ihBrush ;
    DWORD   iUsage ;
    DWORD   offBmi ;
    DWORD   cbBmi ;
    DWORD   offBits ;
    DWORD   cbBits ;

    PBITMAPINFO pBmi ;
    PBYTE       pBits ;

    pMfCreateDIBPatternBrush = (PEMRCREATEDIBPATTERNBRUSHPT) pVoid ;

    ihBrush     =    pMfCreateDIBPatternBrush->ihBrush ;
    iUsage      =    pMfCreateDIBPatternBrush->iUsage ;
    offBmi      =    pMfCreateDIBPatternBrush->offBmi ;
    cbBmi       =    pMfCreateDIBPatternBrush->cbBmi ;
    offBits     =    pMfCreateDIBPatternBrush->offBits ;
    cbBits      =    pMfCreateDIBPatternBrush->cbBits ;

    pBmi        = (PBITMAPINFO) ((PBYTE) pVoid + offBmi) ;
    pBits       = (PBYTE) pVoid + offBits ;

    b = DoCreateDIBPatternBrush(pLocalDC, ihBrush,
        pBmi, cbBmi,
        pBits, cbBits,
        iUsage) ;
    return (b) ;
}


/**************************************************************************
* Handler - CreatePen
*************************************************************************/
BOOL bHandleCreatePen(PVOID pVoid, PLOCALDC pLocalDC)
{
    PEMRCREATEPEN pMfCreatePen ;
    INT          ihPen ;
    PLOGPEN      pLogPen ;
    BOOL         b ;

    pMfCreatePen = (PEMRCREATEPEN) pVoid ;

    ihPen   = pMfCreatePen->ihPen ;
    pLogPen = &pMfCreatePen->lopn ;

    b = DoCreatePen(pLocalDC, ihPen, pLogPen) ;

    return(b) ;
}


/**************************************************************************
* Handler - ExtCreatePen
*************************************************************************/
BOOL bHandleExtCreatePen(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMREXTCREATEPEN     pMfExtCreatePen ;
    PEXTLOGPEN          pExtLogPen ;
    INT                 ihPen ;

    pMfExtCreatePen = (PEMREXTCREATEPEN) pVoid ;

    pExtLogPen = &pMfExtCreatePen->elp ;
    ihPen      = pMfExtCreatePen->ihPen ;

    b = DoExtCreatePen(pLocalDC, ihPen, pExtLogPen) ;

    return (b) ;
}


/**************************************************************************
* Handler - MoveToEx
*************************************************************************/
BOOL bHandleMoveTo(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRMOVETOEX pMfMoveTo ;
    INT     x, y ;

    pMfMoveTo = (PEMRMOVETOEX) pVoid ;

    // Get the position.

    x = (INT) pMfMoveTo->ptl.x ;
    y = (INT) pMfMoveTo->ptl.y ;

    // Do the translation.

    b = DoMoveTo(pLocalDC, x, y) ;

    return (b) ;
}


/**************************************************************************
* Handler - LineTo
*************************************************************************/
BOOL bHandleLineTo(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRLINETO   pMfLineTo ;
    INT     x, y ;

    pMfLineTo = (PEMRLINETO) pVoid ;

    // Get the new point.

    x = (INT) pMfLineTo->ptl.x ;
    y = (INT) pMfLineTo->ptl.y ;

    // Do the translation.

    b = DoLineTo(pLocalDC, x, y) ;

    return (b) ;
}


/**************************************************************************
* Handler - Chord
*************************************************************************/
BOOL bHandleChord(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRCHORD  pMfChord ;
    INT     x1, x2, x3, x4,
        y1, y2, y3, y4 ;

    pMfChord = (PEMRCHORD) pVoid ;

    // Set the rectangle

    x1 = (INT) pMfChord->rclBox.left   ;
    y1 = (INT) pMfChord->rclBox.top    ;
    x2 = (INT) pMfChord->rclBox.right  ;
    y2 = (INT) pMfChord->rclBox.bottom ;

    // Set the start point.

    x3 = (INT) pMfChord->ptlStart.x ;
    y3 = (INT) pMfChord->ptlStart.y ;

    // Set the end point.

    x4 = (INT) pMfChord->ptlEnd.x ;
    y4 = (INT) pMfChord->ptlEnd.y ;

    // Do the translation

    b = DoChord(pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4) ;

    return (b) ;
}


/**************************************************************************
* Handler - Pie
*************************************************************************/
BOOL bHandlePie(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRPIE  pMfPie ;
    INT     x1, x2, x3, x4,
        y1, y2, y3, y4 ;

    pMfPie = (PEMRPIE) pVoid ;

    // Set up the ellipse box

    x1 = (INT) pMfPie->rclBox.left   ;
    y1 = (INT) pMfPie->rclBox.top    ;
    x2 = (INT) pMfPie->rclBox.right  ;
    y2 = (INT) pMfPie->rclBox.bottom ;

    // Set the start point.

    x3 = (INT) pMfPie->ptlStart.x ;
    y3 = (INT) pMfPie->ptlStart.y ;

    // Set the end point.

    x4 = (INT) pMfPie->ptlEnd.x ;
    y4 = (INT) pMfPie->ptlEnd.y ;

    // Do the Pie translation.

    b = DoPie(pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4) ;

    return (b) ;
}


/**************************************************************************
* Handler - Polyline
*************************************************************************/
BOOL bHandlePolyline(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRPOLYLINE pMfPolyline ;
    INT     nCount ;
    PPOINTL pptl ;

    pMfPolyline = (PEMRPOLYLINE) pVoid ;

    // Copy the line count and the polyline verticies to
    // the record.

    nCount = (INT) pMfPolyline->cptl ;
    pptl = pMfPolyline->aptl ;

    // Now do the translation.

    b = DoPoly(pLocalDC, pptl, nCount, EMR_POLYLINE, TRUE) ;

    return (b) ;
}


/**************************************************************************
* Handler - PolylineTo
*************************************************************************/
BOOL bHandlePolylineTo (PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRPOLYLINETO pMfPolylineTo ;
    INT     nCount ;
    PPOINTL pptl ;

    pMfPolylineTo = (PEMRPOLYLINETO) pVoid ;

    // Copy the line count and the polyline verticies to
    // the record.

    nCount = (INT) pMfPolylineTo->cptl ;
    pptl = pMfPolylineTo->aptl ;

    // Now do the translation.

    b = DoPolylineTo(pLocalDC, pptl, nCount) ;

    return (b) ;
}


/**************************************************************************
* Handler - PolyBezier16,Polygon16,Polyline16,PolyBezierTo16,PolylineTo16
*           PolyDraw16
*************************************************************************/
BOOL bHandlePoly16 (PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL        b = FALSE;
    PEMRPOLYLINE16 pMfPoly16 ;  // common structure for the poly16 records
    PEMRPOLYDRAW16 pMfPolyDraw16 ;
    POINTL      aptl[MAX_STACK_POINTL];
    PPOINTL     pptl ;
    INT         nCount ;
    PBYTE       pb ;

    // PolyDraw16 contains the structure of Poly16 followed by the byte array.

    pMfPoly16 = (PEMRPOLYLINE16) pVoid ;

    nCount = (INT) pMfPoly16->cpts ;

    if (nCount <= MAX_STACK_POINTL)
        pptl = aptl;
    else if (!(pptl = (PPOINTL) LocalAlloc(LMEM_FIXED, nCount * sizeof(POINTL))))
        return(b);

    POINTS_TO_POINTL(pptl, pMfPoly16->apts, (DWORD) nCount);

    // Now do the translation.

    switch (pMfPoly16->emr.iType)
    {
    case EMR_POLYBEZIER16:
        b = DoPolyBezier(pLocalDC, (LPPOINT) pptl, nCount) ;
        break;

    case EMR_POLYGON16:
        b = DoPoly(pLocalDC, pptl, nCount, EMR_POLYGON, TRUE) ;
        break;

    case EMR_POLYLINE16:
        b = DoPoly(pLocalDC, pptl, nCount, EMR_POLYLINE, TRUE) ;
        break;

    case EMR_POLYBEZIERTO16:
        b = DoPolyBezierTo(pLocalDC, (LPPOINT) pptl, nCount) ;
        break;

    case EMR_POLYLINETO16:
        b = DoPolylineTo(pLocalDC, pptl, nCount) ;
        break;

    case EMR_POLYDRAW16:
        if (pfnSetVirtualResolution != NULL)
        {
            pMfPolyDraw16 = (PEMRPOLYDRAW16) pVoid ;
            pb = (PBYTE) &pMfPolyDraw16->apts[nCount];
            b = DoPolyDraw(pLocalDC, (LPPOINT) pptl, pb, nCount);
            break;
        }
        // Fall through for win9x

    default:
        ASSERTGDI(FALSE, "Bad record type");
        break;
    }

    if (nCount > MAX_STACK_POINTL)
        if (LocalFree(pptl))
            ASSERTGDI(FALSE, "bHandlePoly16: LocalFree failed");

        return (b) ;
}


/**************************************************************************
* Handler - PolyPolyline
*************************************************************************/
BOOL bHandlePolyPolyline(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRPOLYPOLYLINE pMfPolyPolyline ;
    PDWORD  pPolyCount ;
    PPOINTL pptl ;
    INT     nPolys ;

    pMfPolyPolyline = (PEMRPOLYPOLYLINE) pVoid ;

    // Copy the  Polycount count, the polycount array
    // and the polyline verticies to
    // the record.

    nPolys = (INT) pMfPolyPolyline->nPolys ;
    pPolyCount = pMfPolyPolyline->aPolyCounts ;
    pptl = (PPOINTL) &pMfPolyPolyline->aPolyCounts[nPolys] ;

    // Now do the translation.

    b = DoPolyPolyline(pLocalDC, pptl, pPolyCount, nPolys, TRUE) ;

    return (b) ;
}


/**************************************************************************
* Handler - PolyPolyline16,PolyPolygon16
*************************************************************************/
BOOL bHandlePolyPoly16 (PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b = FALSE;
    PEMRPOLYPOLYLINE16 pMfPolyPoly16 ;  // common structure for polypoly16 records
    PDWORD  pPolyCount ;
    POINTL  aptl[MAX_STACK_POINTL];
    PPOINTL pptl ;
    INT     nCount;
    DWORD   cpts ;

    pMfPolyPoly16 = (PEMRPOLYPOLYLINE16) pVoid ;

    nCount = (INT) pMfPolyPoly16->nPolys ;
    cpts   = pMfPolyPoly16->cpts;
    pPolyCount = pMfPolyPoly16->aPolyCounts ;

    if (cpts <= MAX_STACK_POINTL)
        pptl = aptl;
    else if (!(pptl = (PPOINTL) LocalAlloc(LMEM_FIXED, cpts * sizeof(POINTL))))
        return(b);

    POINTS_TO_POINTL(pptl, (PPOINTS) &pMfPolyPoly16->aPolyCounts[nCount], cpts);

    // Now do the translation.

    switch (pMfPolyPoly16->emr.iType)
    {
    case EMR_POLYPOLYLINE16:
        b = DoPolyPolyline(pLocalDC, pptl, pPolyCount, nCount, TRUE) ;
        break;
    case EMR_POLYPOLYGON16:
        b = DoPolyPolygon(pLocalDC, pptl, pPolyCount, cpts, nCount, TRUE) ;
        break;
    default:
        ASSERTGDI(FALSE, "Bad record type");
        break;
    }

    if (cpts > MAX_STACK_POINTL)
        if (LocalFree(pptl))
            ASSERTGDI(FALSE, "bHandlePolyPoly16: LocalFree failed");

        return (b) ;
}


/**************************************************************************
* Handler - Polygon
*************************************************************************/
BOOL bHandlePolygon (PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRPOLYGON pMfPolygon ;
    PPOINTL pptl ;
    INT     nCount ;

    pMfPolygon = (PEMRPOLYGON) pVoid ;

    // Copy the line count and the Polygon verticies to
    // the record.

    nCount = (INT) pMfPolygon->cptl ;
    pptl = pMfPolygon->aptl ;

    // Now do the translation.

    b = DoPoly(pLocalDC, pptl, nCount, EMR_POLYGON, TRUE) ;

    return (b) ;
}


/**************************************************************************
* Handler - PolyPolygon
*************************************************************************/
BOOL bHandlePolyPolygon(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRPOLYPOLYGON pMfPolyPolygon ;
    PDWORD  pPolyCount ;
    PPOINTL pptl ;
    DWORD   cptl ;
    INT     nPolys ;

    pMfPolyPolygon = (PEMRPOLYPOLYGON) pVoid ;

    // Copy the  Polycount count, the polycount array
    // and the polygon verticies to
    // the record.

    nPolys = (INT) pMfPolyPolygon->nPolys ;
    pPolyCount = pMfPolyPolygon->aPolyCounts ;
    pptl = (PPOINTL) &pMfPolyPolygon->aPolyCounts[nPolys] ;
    cptl = pMfPolyPolygon->cptl ;

    // Now do the translation.

    b = DoPolyPolygon(pLocalDC, pptl, pPolyCount, cptl, nPolys, TRUE) ;

    return (b) ;
}


/**************************************************************************
* Handler - Rectangle
*************************************************************************/
BOOL bHandleRectangle(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRRECTANGLE  pMfRectangle ;
    INT     x1, y1, x2, y2 ;

    pMfRectangle = (PEMRRECTANGLE) pVoid ;

    // Set up the Rectangle box, this will be the same as the bounding
    // rectangle.

    x1 = (INT) pMfRectangle->rclBox.left   ;
    y1 = (INT) pMfRectangle->rclBox.top    ;
    x2 = (INT) pMfRectangle->rclBox.right  ;
    y2 = (INT) pMfRectangle->rclBox.bottom ;

    // Do the Rectangle translation.

    b = DoRectangle(pLocalDC, x1, y1, x2, y2) ;

    return (b) ;
}


/**************************************************************************
* Handler - RoundRect
*************************************************************************/
BOOL bHandleRoundRect (PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMRROUNDRECT  pMfRoundRect ;
    INT     x1, y1, x2, y2, x3, y3 ;

    pMfRoundRect = (PEMRROUNDRECT) pVoid ;

    // Set up the RoundRect box, this will be the same as the bounding
    // RoundRect.

    x1 = (INT) pMfRoundRect->rclBox.left   ;
    y1 = (INT) pMfRoundRect->rclBox.top    ;
    x2 = (INT) pMfRoundRect->rclBox.right  ;
    y2 = (INT) pMfRoundRect->rclBox.bottom ;
    x3 = (INT) pMfRoundRect->szlCorner.cx ;
    y3 = (INT) pMfRoundRect->szlCorner.cy ;

    // Do the RoundRect translation.

    b = DoRoundRect(pLocalDC, x1, y1, x2, y2, x3, y3) ;

    return (b) ;
}


/**************************************************************************
* Handler - ExtTextOut for both ANSI and UNICODE characters.
**************************************************************************/
BOOL bHandleExtTextOut(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    PEMREXTTEXTOUTA  pMfExtTextOut ;    // same for both ansi and unicode
    INT     x, y, nCount ;
    DWORD   flOptions ;
    PRECTL  pRectl ;
    PLONG   pDx ;
    PWCH    pwchar ;
    DWORD   iGraphicsMode;

    pMfExtTextOut = (PEMREXTTEXTOUTA) pVoid ;

    ASSERTGDI(pMfExtTextOut->emr.iType == EMR_EXTTEXTOUTA
           || pMfExtTextOut->emr.iType == EMR_EXTTEXTOUTW,
           "MF3216: bHandleExtTextOut: bad record type");

    // Copy over the start position for the string.

    x = (INT) pMfExtTextOut->emrtext.ptlReference.x ;
    y = (INT) pMfExtTextOut->emrtext.ptlReference.y ;

    // Now copy over the Options flag, character count,
    // the clip/opaque rectangle, and the Ansi/Unicode string.

    flOptions = pMfExtTextOut->emrtext.fOptions  ;
    nCount    = (INT) pMfExtTextOut->emrtext.nChars ;
    pRectl    = &pMfExtTextOut->emrtext.rcl ;
    pwchar    = (PWCH) ((PBYTE) pMfExtTextOut + pMfExtTextOut->emrtext.offString);
    iGraphicsMode = pMfExtTextOut->iGraphicsMode;

    // Set up the spacing vector

    pDx = (PLONG) ((PBYTE) pMfExtTextOut + pMfExtTextOut->emrtext.offDx);

    // Now do the conversion.

    b = DoExtTextOut(pLocalDC, x, y, flOptions,
        pRectl, pwchar, nCount, pDx, iGraphicsMode,
        pMfExtTextOut->emr.iType);

    return (b) ;
}


/**************************************************************************
* Handler - PolyTextOut for both ANSI and UNICODE characters.
**************************************************************************/
BOOL bHandlePolyTextOut(PVOID pVoid, PLOCALDC pLocalDC)
{
    PEMRPOLYTEXTOUTA pMfPolyTextOut;    // same for both ansi and unicode
    PWCH    pwchar;
    LONG    i;
    DWORD   iType;
    LONG    cStrings;
    PEMRTEXT pemrtext;
    PLONG   pDx ;
    DWORD   iGraphicsMode;

    pMfPolyTextOut = (PEMRPOLYTEXTOUTA) pVoid ;

    ASSERTGDI(pMfPolyTextOut->emr.iType == EMR_POLYTEXTOUTA
           || pMfPolyTextOut->emr.iType == EMR_POLYTEXTOUTW,
           "MF3216: bHandlePolyTextOut: bad record type");

    iType  = pMfPolyTextOut->emr.iType == EMR_POLYTEXTOUTA
        ? EMR_EXTTEXTOUTA
        : EMR_EXTTEXTOUTW;
    cStrings = pMfPolyTextOut->cStrings;
    iGraphicsMode = pMfPolyTextOut->iGraphicsMode;

    // Convert to ExtTextOut

    for (i = 0; i < cStrings; i++)
    {
        pemrtext = &pMfPolyTextOut->aemrtext[i];
        pwchar = (PWCH) ((PBYTE) pMfPolyTextOut + pemrtext->offString);
        pDx    = (PLONG) ((PBYTE) pMfPolyTextOut + pemrtext->offDx);

        if (!DoExtTextOut(pLocalDC, pemrtext->ptlReference.x, pemrtext->ptlReference.y,
            pemrtext->fOptions, &pemrtext->rcl,
            pwchar, pemrtext->nChars, pDx, iGraphicsMode, iType))
            return(FALSE);
    }

    return(TRUE);
}


/**************************************************************************
* Handler - ExtCreateFont
*************************************************************************/
BOOL bHandleExtCreateFont(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b;
    PEMREXTCREATEFONTINDIRECTW pMfExtCreateFontW;
    LOGFONTA  lfa = {0};
    INT       ihFont;
    int       iRet = 0;

    pMfExtCreateFontW = (PEMREXTCREATEFONTINDIRECTW) pVoid ;

    // Get the font parameters.

    ihFont               = (INT) pMfExtCreateFontW->ihFont ;
    lfa.lfHeight         = pMfExtCreateFontW->elfw.elfLogFont.lfHeight;
    lfa.lfWidth          = pMfExtCreateFontW->elfw.elfLogFont.lfWidth;
    lfa.lfEscapement     = pMfExtCreateFontW->elfw.elfLogFont.lfEscapement;
    lfa.lfOrientation    = pMfExtCreateFontW->elfw.elfLogFont.lfOrientation;
    lfa.lfWeight         = pMfExtCreateFontW->elfw.elfLogFont.lfWeight;
    lfa.lfItalic         = pMfExtCreateFontW->elfw.elfLogFont.lfItalic;
    lfa.lfUnderline      = pMfExtCreateFontW->elfw.elfLogFont.lfUnderline;
    lfa.lfStrikeOut      = pMfExtCreateFontW->elfw.elfLogFont.lfStrikeOut;
    lfa.lfCharSet        = pMfExtCreateFontW->elfw.elfLogFont.lfCharSet;
    lfa.lfOutPrecision   = pMfExtCreateFontW->elfw.elfLogFont.lfOutPrecision;
    lfa.lfClipPrecision  = pMfExtCreateFontW->elfw.elfLogFont.lfClipPrecision;
    lfa.lfQuality        = pMfExtCreateFontW->elfw.elfLogFont.lfQuality;
    lfa.lfPitchAndFamily = pMfExtCreateFontW->elfw.elfLogFont.lfPitchAndFamily;

    iRet = WideCharToMultiByte(CP_ACP,
                        0,
                        pMfExtCreateFontW->elfw.elfLogFont.lfFaceName,
                        -1,
                        lfa.lfFaceName,
                        sizeof(lfa.lfFaceName),
                        NULL, NULL);
    if (iRet == 0)
    {
        ASSERTGDI(FALSE, "WideCharToMultByte failed to convert lfFaceName");
        return FALSE;
    }

    // Do the translation.

    b = DoExtCreateFont(pLocalDC, ihFont, &lfa);

    return (b) ;
}


/**************************************************************************
* Handler - SetBkColor
*************************************************************************/
BOOL bHandleSetBkColor(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL        b ;
    PEMRSETBKCOLOR pMfSetBkColor ;

    pMfSetBkColor = (PEMRSETBKCOLOR) pVoid ;

    // Do the translation.

    b = DoSetBkColor(pLocalDC, pMfSetBkColor->crColor) ;

    return (b) ;
}


/**************************************************************************
* Handler - SetBkMode
*************************************************************************/
BOOL bHandleSetBkMode(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    DWORD   iBkMode ;
    PEMRSETBKMODE pMfSetBkMode ;

    pMfSetBkMode = (PEMRSETBKMODE) pVoid ;

    // Set the Background Mode variable

    iBkMode = pMfSetBkMode->iMode ;

    // Do the translation.

    b = DoSetBkMode(pLocalDC, iBkMode) ;

    return (b) ;
}


/**************************************************************************
* Handler - SetMapperFlags
*************************************************************************/
BOOL bHandleSetMapperFlags(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    DWORD   f ;
    PEMRSETMAPPERFLAGS pMfSetMapperFlags ;

    pMfSetMapperFlags = (PEMRSETMAPPERFLAGS) pVoid ;

    f = pMfSetMapperFlags->dwFlags ;

    // Do the translation.

    b = DoSetMapperFlags(pLocalDC, f) ;

    return (b) ;
}


/**************************************************************************
* Handler - SetPolyFillMode
*************************************************************************/
BOOL bHandleSetPolyFillMode(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    INT     iPolyFillMode ;
    PEMRSETPOLYFILLMODE pMfSetPolyFillMode ;

    pMfSetPolyFillMode = (PEMRSETPOLYFILLMODE) pVoid ;

    // Set the PolyFill Mode

    iPolyFillMode = (INT) pMfSetPolyFillMode->iMode ;

    // Do the translation.

    b = DoSetPolyFillMode(pLocalDC, iPolyFillMode) ;

    return (b) ;
}


/**************************************************************************
* Handler - SetRop2
*************************************************************************/
BOOL bHandleSetRop2(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    DWORD   iDrawMode ;
    PEMRSETROP2 pMfSetROP2 ;

    pMfSetROP2 = (PEMRSETROP2) pVoid ;

    // Set the Draw Mode

    iDrawMode = pMfSetROP2->iMode ;

    // Do the translation.

    b = DoSetRop2(pLocalDC, iDrawMode) ;

    return (b) ;
}


/**************************************************************************
* Handler - SetStretchBltMode
*************************************************************************/
BOOL bHandleSetStretchBltMode(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    DWORD   iStretchMode ;
    PEMRSETSTRETCHBLTMODE pMfSetStretchBltMode ;

    pMfSetStretchBltMode = (PEMRSETSTRETCHBLTMODE) pVoid ;

    // Set the StretchBlt Mode

    iStretchMode = pMfSetStretchBltMode->iMode ;

    // Do the translation.

    b = DoSetStretchBltMode(pLocalDC, iStretchMode) ;

    return (b) ;
}


/**************************************************************************
* Handler - SetTextAlign
*************************************************************************/
BOOL bHandleSetTextAlign(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL    b ;
    DWORD   fMode ;
    PEMRSETTEXTALIGN pMfSetTextAlign ;

    pMfSetTextAlign = (PEMRSETTEXTALIGN) pVoid ;

    // Set the TextAlign Mode

    fMode = pMfSetTextAlign->iMode ;

    // Do the translation.

    b = DoSetTextAlign(pLocalDC, fMode) ;

    return (b) ;
}


/**************************************************************************
* Handler - SetTextColor
*************************************************************************/
BOOL bHandleSetTextColor(PVOID pVoid, PLOCALDC pLocalDC)
{
    BOOL        b ;
    PEMRSETTEXTCOLOR pMfSetTextColor ;

    pMfSetTextColor = (PEMRSETTEXTCOLOR) pVoid ;

    // Do the translation.

    b = DoSetTextColor(pLocalDC, pMfSetTextColor->crColor) ;

    return (b) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\gpmf3216\mf3216.h ===
/*****************************************************************************
 *
 *  MF3216.h - The include file for MF3216.  This will contain all
 *             the miscellaneous includes.
 *
 *  Author: Jeffrey Newman (c-jeffn)
 *
 *  Creation Date: 31-Jan-1992
 *
 ****************************************************************************/

//////////////////////////////////////////////////////////////////////////////
// GillesK: April 2000
// This is a full copy of the MF3216 source code for use with GDI+...
// Whatever gets fixed in the real MF3216 should be reflected here. in order
// to keep the bugs consistent.
//////////////////////////////////////////////////////////////////////////////


#ifndef _MF3216_
#define _MF3216_

#define NOTUSED(x) {}

#define NOTXORPASS       0
#define DRAWXORPASS      1
#define OBJECTRECREATION 2
#define ERASEXORPASS     3

#define STARTPSIGNORE    1
#define ENDPSIGNORE      0

/* Types for postscript written to metafiles */
#define CLIP_SAVE       0
#define CLIP_RESTORE    1
#define CLIP_INCLUSIVE  2
#define CLIP_EXCLUSIVE  3

typedef struct _w16objhndlslotstatus {
    INT     use ;
    HANDLE  w32Handle ;
    INT     iXORPassCreation ;  // In which XOR pass the object was created
    PBYTE   pbCreatRec;         // Which EMF record created the object
} W16OBJHNDLSLOTSTATUS ;

typedef W16OBJHNDLSLOTSTATUS *PW16OBJHNDLSLOTSTATUS ;

typedef struct _w16recreationslot {
    INT     slot ;              // The slot that we need to create the object in
    PBYTE   pbCreatRec ;        // The record that will create the object
    struct _w16recreationslot* pNext ;
} W16RECREATIONSLOT ;

typedef W16RECREATIONSLOT *PW16RECREATIONSLOT ;

// This structure contains the current metafile information to gather the
// proper transforms
typedef struct tagMAPPING {    // The Page transform in its less
    INT     iMapMode;
    INT     iWox;
    INT     iWoy;
    INT     iVox;
    INT     iVoy;
    INT     iWex;
    INT     iWey;
    INT     iVex;
    INT     iVey;
} MAPPING, *PMAPPING;


typedef struct _localDC {
    UINT    nSize ;                     // Size of this Local DC structure.
    DWORD   flags ;                     // Boolean controls.
    PBYTE   pMf32Bits ;                 // ptr to W32 metafile bits.
    UINT    cMf32Bits ;                 // count of W32 metafile size.
    PBYTE   pMf16Bits ;                 // ptr to user supplied out buffer
    UINT    cMf16Dest ;                 // length of user supplied buffer
    HDC     hdcHelper ;                 // Our helper DC.
    HDC     hdcRef ;                    // Reference DC.
    HBITMAP hbmpMem;                    // A Memory Bitmap for Win9x
    INT     iMapMode ;                  // User requested map mode.
    INT     cxPlayDevMM,
            cyPlayDevMM,
            cxPlayDevPels,
            cyPlayDevPels ;
    XFORM   xformRWorldToRDev,          // aka Metafile-World to Metafile-Device
            xformRDevToRWorld,          // aka Metafile-Device to Metafile-World
            xformRDevToPDev,            // aka Metafile-Device to Reference-Device
            xformPDevToPPage,           // aka Reference-Device to Reference-Logical
            xformPPageToPDev,           // aka Reference-Logical to Reference-Device
            xformRDevToPPage,           // aka Metafile-Device to Reference-Logical
            xformRWorldToPPage ;
    XFORM   xformW ;                    // The World Transform for Win9x
    XFORM   xformP ;                    // The Page Transform for Win9x
    XFORM   xformDC ;                   // The DC Transform for Win9x
    MAPPING map ;                       // The mapping info for Win9x
    POINT   ptCP ;                      // Current position
    PBYTE   pbEnd ;                     // End of W32 metafile bits.
    METAHEADER  mf16Header ;            // The W16 metafile header.
    PINT    piW32ToW16ObjectMap ;
    UINT    cW16ObjHndlSlotStatus ;     // used in slot search
    UINT    cW32ToW16ObjectMap ;        // used in Normalize handle.
    PW16OBJHNDLSLOTSTATUS   pW16ObjHndlSlotStatus ;
    COLORREF crTextColor ;              // current text color - used by
                                        // ExtCreatePen.
    COLORREF crBkColor ;                // Current background color
    INT     iArcDirection ;             // Current arc direction in W32 metafile
    LONG    lhpn32;                     // Currently selected pen.  Used in path and text
    LONG    lhbr32;                     // Currently selected brush.  Used in text
    DWORD   ihpal32;                    // Currently selected (i32) palette.
    DWORD   ihpal16;                    // Currently selected (i16) palette.
    UINT    iLevel;                     // Current DC save level.
    INT     iSavePSClipPath;            // Number of times we save the PSclipPath

    struct _localDC *pLocalDCSaved;     // Point to the saved DCs



// The following fields are not restored by RestoreDC!

    // Information for the XOR ClipPath rendering
    INT     iROP;           // Current ROP Mode
    POINT   pOldPosition ;
    INT     iXORPass ;
    INT     iXORPassDCLevel ;

    UINT    ulBytesEmitted ;            // Total bytes emitted so far.
    UINT    ulMaxRecord ;               // Max W16 record size.
    INT     nObjectHighWaterMark;       // Max slot index used so far.

    PBYTE   pbRecord ;                  // Current record in W32 metafile bits.
    PBYTE   pbCurrent;                  // Next record in W32 metafile bits.
    DWORD   cW32hPal;                   // Size of private W32 palette table.

    PBYTE   pbChange ;                  // Old position in the metafile
    PBYTE   pbLastSelectClip ;          // Old position in the metafile for path drawing
    LONG    lholdp32 ;
    LONG    lholdbr32;

    HPALETTE *pW32hPal;                 // Private W32 palette table.
    PW16RECREATIONSLOT pW16RecreationSlot ;    // Used to recreate objects deleted in XOR Pass

} LOCALDC ;

typedef LOCALDC *PLOCALDC ;

// Routines in apientry.c

BOOL bHandleWin32Comment(PLOCALDC pLocalDC);

// Routines in misc.c

BOOL bValidateMetaFileCP(PLOCALDC pLocalDC, LONG x, LONG y);

// Following are the bit definitions for the flags.

#define SIZE_ONLY               0x00000001
#define INCLUDE_W32MF_COMMENT   0x00000002
#define STRANGE_XFORM           0x00000004
#define RECORDING_PATH          0x00000008
#define INCLUDE_W32MF_XORPATH   0x00000010
#define ERR_BUFFER_OVERFLOW     0x80000000
#define ERR_XORCLIPPATH         0x40000000

// Make this big in case more flags are added to MF3216
#define GPMF3216_INCLUDE_XORPATH    0x1000



// This define sets the size of each Win32 metafile comment record.
// The reason we do not just use a 64K record is due to a caution given
// to use about large escape records in Win3.0 by the GBU (MS Palo Alto).

#define MAX_WIN32_COMMENT_REC_SIZE  0x2000


// Function(s) used in parser.c

extern BOOL  bParseWin32Metafile(PBYTE pMetafileBits, PLOCALDC pLocalDC) ;

// Function definitions for preamble.

extern BOOL bUpdateMf16Header(PLOCALDC pLocalDC) ;

// Function definitions for the emitter.

extern BOOL bEmit(PLOCALDC pLocalDC, PVOID pBuffer, DWORD nCount) ;
extern VOID vUpdateMaxRecord(PLOCALDC pLocalDC, PMETARECORD pmr);

// Defines used in objects.c

#define OPEN_AVAILABLE_SLOT         1
#define REALIZED_BRUSH              2
#define REALIZED_PEN                3
#define REALIZED_BITMAP             4
#define REALIZED_PALETTE            5
#define REALIZED_REGION             6
#define REALIZED_FONT               7
#define REALIZED_OBJECT             8  // used by multiformats record
#define REALIZED_DUMMY              9  // used by multiformats record

#define UNMAPPED                    -1

// Routines in objects.c

extern BOOL bInitHandleTableManager(PLOCALDC pLocalDC, PENHMETAHEADER pmf32header) ;
extern INT  iGetW16ObjectHandleSlot(PLOCALDC pLocalDC, INT iIntendedUse) ;
extern INT  iValidateHandle(PLOCALDC pLocalDC, INT ihW32) ;
extern INT  iAllocateW16Handle(PLOCALDC pLocalDC, INT ihW32, INT iIntendedUse) ;
extern BOOL bDeleteW16Object(PLOCALDC pLocalDC, INT ihW16) ;
extern INT  iNormalizeHandle(PLOCALDC pLocalDC, INT ihW32) ;

// Routines in text.c

VOID vUnicodeToAnsi(HDC hdc, PCHAR pAnsi, PWCH pUnicode, DWORD cch) ;

// Routines in regions.c

BOOL bNoDCRgn(PLOCALDC pLocalDC, INT iType);
BOOL bDumpDCClipping(PLOCALDC pLocalDC);

// Defines used in bNoDCRgn().

#define DCRGN_CLIP     1
#define DCRGN_META     2

// Defines used in xforms.c

#define     CX_MAG  1
#define     CY_MAG  2

typedef struct
{
    FLOAT x;
    FLOAT y;
} POINTFL;
typedef POINTFL *PPOINTFL;

// Function definitions from xform

extern BOOL bInitXformMatrices(PLOCALDC pLocalDC, PENHMETAHEADER pmf32header, RECTL* frameBounds) ;

extern BOOL bXformRWorldToPPage(PLOCALDC pLocalDC, PPOINTL aptl, DWORD nCount) ;
extern BOOL bXformRWorldToRDev(PLOCALDC pLocalDC, PPOINTL aptl, INT nCount) ;
extern BOOL bXformPDevToPPage(PLOCALDC pLocalDC, PPOINTL aptl, INT nCount) ;
extern BOOL bXformPPageToPDev(PLOCALDC pLocalDC, PPOINTL aptl, INT nCount) ;
extern BOOL bXformRDevToRWorld(PLOCALDC pLocalDC, PPOINTL aptl, INT nCount) ;

extern INT  iMagnitudeXform (PLOCALDC pLocalDC, INT value, INT iType) ;

extern XFORM xformIdentity ;
extern BOOL  bRotationTest(PXFORM pxform) ;
extern INT   iMagXformWorkhorse (INT value, PXFORM pxform, INT iType) ;
extern BOOL  bXformWorkhorse(PPOINTL aptl, DWORD nCount, PXFORM pXform) ;
extern VOID  vXformWorkhorseFloat(PPOINTFL aptfl, UINT nCount, PXFORM pXform);
extern BOOL  bCoordinateOverflowTest(PLONG pCoordinates, INT nCount) ;

BOOL bCombineTransform(
  LPXFORM lpxformResult,  // combined transformation
  CONST XFORM *lpxform1,  // first transformation
  CONST XFORM *lpxform2   // second transformation
);



// Defines used in Conics

#define SWAP(x,y,t)        {t = x; x = y; y = t;}

#define ePI ((FLOAT)(((FLOAT) 22.0 / (FLOAT) 7.0 )))

// Exported support functions and defines for Conics & rectangles.

extern BOOL bConicCommon (PLOCALDC pLocalDC, INT x1, INT y1, INT x2, INT y2,
                                             INT x3, INT y3, INT x4, INT y4,
                                             DWORD mrType) ;

extern BOOL bRenderCurveWithPath
(
    PLOCALDC pLocalDC,
    LPPOINT  pptl,
    PBYTE    pb,
    DWORD    cptl,
    INT      x1,
    INT      y1,
    INT      x2,
    INT      y2,
    INT      x3,
    INT      y3,
    INT      x4,
    INT      y4,
    DWORD    nRadius,
    FLOAT    eStartAngle,
    FLOAT    eSweepAngle,
    DWORD    mrType
);

// Exported functions from lines.c

extern VOID vCompressPoints(PVOID pBuff, LONG nCount) ;


// Defines (macros) used in bitmaps.

// Check if a source is needed in a 3-way bitblt operation.
// This works on both rop and rop3.  We assume that a rop contains zero
// in the high byte.
//
// This is tested by comparing the rop result bits with source (column A
// below) vs. those without source (column B).  If the two cases are
// identical, then the effect of the rop does not depend on the source
// and we don't need a source device.  Recall the rop construction from
// input (pattern, source, target --> result):
//
//  P S T | R   A B     mask for A = 0CCh
//  ------+--------     mask for B =  33h
//  0 0 0 | x   0 x
//  0 0 1 | x   0 x
//  0 1 0 | x   x 0
//  0 1 1 | x   x 0
//  1 0 0 | x   0 x
//  1 0 1 | x   0 x
//  1 1 0 | x   x 0
//  1 1 1 | x   x 0

#define ISSOURCEINROP3(rop3)    \
    (((rop3) & 0xCCCC0000) != (((rop3) << 2) & 0xCCCC0000))


#define CJSCAN(width,planes,bits) ((((width)*(planes)*(bits)+31) & ~31) / 8)

#define MAX4(a, b, c, d)    max(max(max(a,b),c),d)
#define MIN4(a, b, c, d)    min(min(min(a,b),c),d)

// GillesK: Mar 2000
// This is needed because GetTransform is not in GDI32.lib but is in GDI32.dll
typedef BOOL (*fnGetTransform)(HDC,DWORD,LPXFORM);
typedef BOOL (*fnSetVirtualResolution)(HDC,
                                   int,
                                   int,
                                   int,
                                   int);




#endif  //_MF3216_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\gpmf3216\mftypes.hpp ===
#include "precomp.h"

/*********************************Class************************************\
* class MF
*
* Metafile MF structure.
*
* There is no constructor or destructor for this object.  We do the
* initialization in pmfAllocMF and cleanup in vFreeMF.
*
* History:
*  Wed Jul 17 17:10:28 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

class MF
{
private:
    ULONG        ident;         // Identifier 'MF'
    HANDLE       hFile;         // Handle to the disk metafile.
    HANDLE       hFileMap;      // Handle to the disk file mapping object.
public:
    PENHMETAHEADER pmrmf;       // Pointer to MRMETAFILE record
    EMFSpoolData *pEMFSpool;    // handle to extra EMF spool information
private:
    ULONG        iMem;          // Current memory index pointer.
    ERECTL       erclClipBox;   // Incl-incl clip box in source device units.
    WCHAR        wszPathname[MAX_PATH+1];
                                // Full pathname of the disk metafile.
public:
    ULONG        fl;            // Flags.
    PHANDLETABLE pht;           // Pointer to the object handle table.
    BOOL         bBeginGroup;   // Is begin group comment emitted?
                                // Init to FALSE before play or enum.
    ULONG        cLevel;        // Saved level.  Init to 1 before play or enum.
    XFORM        xformBase;     // Base playback transform for target.
                                // This happens to be the same as cliprgn xform.
    HDC          hdcXform;      // Virtual DC for use in transform computation.

public:
// bIsDiskFile -- Is this a disk or memory metafile?

    BOOL bIsDiskFile()  { return(fl & MF_DISKFILE); }

// bIsEMFSpool -- During EMF spooling?

    BOOL bIsEMFSpool()  { return (pEMFSpool != NULL); }

// bSetTransform -- Set up the transform in the target DC.

    BOOL bSetTransform(HDC hdc)
    {
        return(FALSE);
    }

// bClipped -- Returns TRUE if erclBounds does not intersect the clip box,
//             otherwise FALSE.  Both rectangles are assumed to be incl-incl
//             in source device units.  The clip box must not be empty.
//
// If erclBounds is empty, we will return FALSE to force playback of the
// record.  The reason is that at record (or embed) time, the scale transform
// at the time may cause the bounds to be empty due to rounding error.  At
// playback time, this bounds may not be empty anymore.

    BOOL bClipped(ERECTL &erclBounds)
    {
        if (erclBounds.bEmpty())
            return(FALSE);
        else
            return(erclClipBox.bNoIntersect(erclBounds));
    }
};

typedef MF *PMF;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\gpmf3216\misc.c ===
/*****************************************************************************
*
* misc - Entry points for Win32 to Win 16 converter
*
* Date: 7/1/91
* Author: Jeffrey Newman (c-jeffn)
*
* Copyright 1991 Microsoft Corp
*****************************************************************************/

#include "precomp.h"
#pragma hdrstop

extern fnGetTransform pfnGetTransform;

typedef struct EMROFFICECOMMENT
{
    EMR     emr;
    DWORD   cbData;             // Size of following fields and data
    DWORD   ident;              // GDICOMMENT_IDENTIFIER
    DWORD   iComment;           // Comment type e.g. GDICOMMENT_WINDOWS_METAFILE
} EMROFFICECOMMENT, *PEMROFFICECOMMENT;

BOOL WINAPI DoGdiCommentMultiFormats
(
 PLOCALDC pLocalDC,
 PEMRGDICOMMENT_MULTIFORMATS pemr
 );

 /***************************************************************************
 *  ExtFloodFill  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoExtFloodFill
(
 PLOCALDC    pLocalDC,
 int         x,
 int         y,
 COLORREF    crColor,
 DWORD       iMode
 )
{
    POINTL  ptl ;
    BOOL    b ;

    ptl.x = (LONG) x ;
    ptl.y = (LONG) y ;

    b = bXformRWorldToPPage(pLocalDC, &ptl, 1) ;
    if (b == FALSE)
        goto exit1 ;

    b = bEmitWin16ExtFloodFill(pLocalDC, LOWORD(ptl.x), LOWORD(ptl.y), crColor, LOWORD(iMode)) ;
exit1:
    return(b) ;

}

/***************************************************************************
*  MoveToEx  - Win32 to Win16 Metafile Converter Entry Point
*
*  NOTE ON CURRENT POSITION
*  ------------------------
*  There are only three Win16 functions that use and update the
*  current position (CP).  They are:
*
*      MoveTo
*      LineTo
*      (Ext)TextOut with TA_UPDATECP text alignment option
*
*  In Win32, CP is used in many more functions and has two
*  interpretations based on the state of the current path.
*  As a result, it is easier and more robust to rely on the
*  helper DC to keep track of the CP than doing it in the
*  converter.  To do this, we need to do the following:
*
*  1. The converter will update the CP in the helper DC in all
*     records that modify the CP.
*
*  2. The converter will keep track of the CP in the converted
*     metafile at all time.
*
*  3. In LineTo and (Ext)TextOut, the metafile CP is compared to
*     that of the helper DC.  If they are different, a MoveTo record
*     is emitted.  This is done in bValidateMetaFileCP().
*
*  4. The converter should emit a MoveTo record the first time the
*     CP is used in the converted metafile.
*
*  - HockL  July 2, 1992
**************************************************************************/
BOOL WINAPI DoMoveTo
(
 PLOCALDC  pLocalDC,
 LONG    x,
 LONG    y
 )
{
    BOOL    b ;
    POINTL  ptl ;

    // Whether we are recording for a path or acutally emitting
    // a drawing order we must pass the drawing order to the helper DC
    // so the helper can maintain the current positon.
    // If we're recording the drawing orders for a path
    // then just pass the drawing order to the helper DC.
    // Do not emit any Win16 drawing orders.
    POINTL p = {x, y};
    if (pfnSetVirtualResolution == NULL)
    {
        if (!bXformWorkhorse(&p, 1, &pLocalDC->xformRWorldToRDev))
        {
            return FALSE;
        }
    }
    b = MoveToEx(pLocalDC->hdcHelper, (INT) p.x, (INT) p.y, (LPPOINT) &ptl) ;
    if (pLocalDC->flags & RECORDING_PATH)
        return(b) ;

    // Update the CP in the converted metafile.
    b = bValidateMetaFileCP(pLocalDC, x, y) ;

    return(b) ;
}


/***************************************************************************
*  bValidateMetaFiloeCP  - Update the current position in the converted
*                          metafile.
*
*  x and y are assumed to be in the record time world coordinates.
*
**************************************************************************/
BOOL bValidateMetaFileCP(PLOCALDC pLocalDC, LONG x, LONG y)
{
    BOOL    b ;
    POINT   pt ;

    // Compute the new current position in the play time page coord.

    pt.x = x ;
    pt.y = y ;
    if (!bXformRWorldToPPage(pLocalDC, (PPOINTL) &pt, 1L))
        return(FALSE);

    // No need to emit the record if the converted metafile has
    // the same CP.

    if (pLocalDC->ptCP.x == pt.x && pLocalDC->ptCP.y == pt.y)
        return(TRUE);

    // Call the Win16 routine to emit the move to the metafile.

    b = bEmitWin16MoveTo(pLocalDC, LOWORD(pt.x), LOWORD(pt.y)) ;

    // Update the mf16 current position.

    pLocalDC->ptCP = pt ;

    return(b) ;
}

/***************************************************************************
*  SaveDC  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoSaveDC
(
 PLOCALDC pLocalDC
 )
{
    BOOL    b;
    PLOCALDC pLocalDCNew;

    b = FALSE;

    // Save the helper DC's state first

    if (!SaveDC(pLocalDC->hdcHelper))
    {
        RIPS("MF3216: DoSaveDC, SaveDC failed\n");
        return(b);
    }

    // Allocate some memory for the LocalDC.

    pLocalDCNew = (PLOCALDC) LocalAlloc(LMEM_FIXED, sizeof(LOCALDC));
    if (pLocalDCNew == (PLOCALDC) NULL)
    {
        RIPS("MF3216: DoSaveDC, LocalAlloc failed\n");
        return(b);
    }

    // Copy the data from the current LocalDC to the new one just allocated.

    *pLocalDCNew = *pLocalDC;

    // Link in the new level.

    pLocalDC->pLocalDCSaved = pLocalDCNew;
    pLocalDC->iLevel++;
    
    // We don't want to restore a PS clip path unless we are doing it at the
    // same level
    pLocalDC->iSavePSClipPath = 0;

    // Emit Win16 drawing order.

    b = bEmitWin16SaveDC(pLocalDC);

    return(b);
}

/***************************************************************************
*  RestoreDC  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoRestoreDC
(
 PLOCALDC pLocalDC,
 int nSavedDC
 )
{
    BOOL     b;
    INT      iLevel;
    PLOCALDC pLocalDCNext;
    PLOCALDC pLocalDCTmp;
    BOOL     bRet;
    WORD     wEscape ;

    b = FALSE;

    // First check to make sure this is a relative save level.

    if (nSavedDC > 0)
        return(b);

    // Compute an absolute level.

    iLevel = pLocalDC->iLevel + nSavedDC;

    // The helper DC should have caught bogus levels.

    ASSERTGDI((iLevel >= 0) && ((UINT) iLevel < pLocalDC->iLevel),
        "MF3216: DoRestoreDC, Bogus RestoreDC");

    // Before restoring the DC level.. If we are in an XOR pass and we want to
    // restore the DC level to a level that is less than the Level that we started
    // the pass at, we simply treat this as the end of the pass and to the start over
    if( pLocalDC->iXORPass == DRAWXORPASS && iLevel <= pLocalDC->iXORPassDCLevel )
    {

        pLocalDC->iXORPass = OBJECTRECREATION ;
        if(!DoRemoveObjects( pLocalDC ))
            return FALSE ;

        bRet = DoMoveTo(pLocalDC, pLocalDC->pOldPosition.x, pLocalDC->pOldPosition.y) ;

        wEscape = ENDPSIGNORE;
        if(!bEmitWin16Escape(pLocalDC, POSTSCRIPT_IGNORE, sizeof(wEscape), (LPSTR)&wEscape, NULL))
            return FALSE ;

        wEscape = CLIP_SAVE ;
        if(!bEmitWin16Escape(pLocalDC, CLIP_TO_PATH, sizeof(wEscape), (LPSTR)&wEscape, NULL))
            return FALSE ;
        return TRUE ;

    }
    else if(pLocalDC->iXORPass == ERASEXORPASS && iLevel <= pLocalDC->iXORPassDCLevel )
    {
        pLocalDC->iXORPass = NOTXORPASS ;
        pLocalDC->pbChange = NULL ;

        DoSetRop2(pLocalDC, pLocalDC->iROP);

        if(!DoRestoreDC(pLocalDC, -1))
            return FALSE ;

        wEscape = CLIP_RESTORE ;
        if(!bEmitWin16Escape(pLocalDC, CLIP_TO_PATH, sizeof(wEscape), (LPSTR)&wEscape, NULL))
            return FALSE ;

        if (!bEmitWin16EmitSrcCopyComment(pLocalDC, msocommentEndSrcCopy))
        {
            return FALSE;
        }

        pLocalDC->iXORPassDCLevel = -1 ;
    }

    // We can't restore the DC if we are in an XOR pass
    // Restore the helper DC's state first
    // If we can restore the helper DC, we know that it is a balanced restore.
    // Otherwise, we return an error.

    if (!RestoreDC(pLocalDC->hdcHelper, nSavedDC))
        return(b);



    // Restore down to the level we want.
    wEscape = CLIP_RESTORE ;
    while(pLocalDC->iSavePSClipPath > 0)
    {
        bEmitWin16Escape(pLocalDC, CLIP_TO_PATH, sizeof(wEscape), (LPSTR)&wEscape, NULL);
        // Ignore failure in this case...
        pLocalDC->iSavePSClipPath--;
    }

    pLocalDCNext = pLocalDC->pLocalDCSaved;
    while ((UINT) iLevel < pLocalDCNext->iLevel)
    {
        pLocalDCTmp = pLocalDCNext;
        pLocalDCNext = pLocalDCNext->pLocalDCSaved;

        // For each DC that has the PSClipPath set, we need to restore a PSClipPath
        while(pLocalDCTmp->iSavePSClipPath > 0)
        {
            bEmitWin16Escape(pLocalDC, CLIP_TO_PATH, sizeof(wEscape), (LPSTR)&wEscape, NULL);
            // Ignore failure in this case...
            pLocalDCTmp->iSavePSClipPath--;
        }
        if (LocalFree(pLocalDCTmp))
            ASSERTGDI(FALSE, "MF3216: DoRestoreDC, LocalFree failed");
    }

    // Restore the state of our local DC to that level.

    // keep some of the attributes in the current DC

    pLocalDCNext->ulBytesEmitted        = pLocalDC->ulBytesEmitted;
    pLocalDCNext->ulMaxRecord           = pLocalDC->ulMaxRecord;
    pLocalDCNext->nObjectHighWaterMark  = pLocalDC->nObjectHighWaterMark;
    pLocalDCNext->pbCurrent             = pLocalDC->pbCurrent;
    pLocalDCNext->pbRecord              = pLocalDC->pbRecord;
    pLocalDCNext->pbChange              = pLocalDC->pbChange;
    pLocalDCNext->cW16ObjHndlSlotStatus = pLocalDC->cW16ObjHndlSlotStatus;
    pLocalDCNext->pW16ObjHndlSlotStatus = pLocalDC->pW16ObjHndlSlotStatus;
    pLocalDCNext->iROP                  = pLocalDC->iROP;
    pLocalDCNext->pOldPosition          = pLocalDC->pOldPosition;
    pLocalDCNext->iXORPass              = pLocalDC->iXORPass;
    pLocalDCNext->iXORPassDCLevel       = pLocalDC->iXORPassDCLevel;
    pLocalDCNext->pW16RecreationSlot    = pLocalDC->pW16RecreationSlot;

    // now restore the other attributes

    *pLocalDC = *pLocalDCNext;

    // Free the local copy of the DC.

    if (LocalFree(pLocalDCNext))
        ASSERTGDI(FALSE, "MF3216: DoRestoreDC, LocalFree failed");

    // Emit the record to the Win16 metafile.

    b = bEmitWin16RestoreDC(pLocalDC, LOWORD(nSavedDC)) ;

    return (b) ;
}

/***************************************************************************
*  SetRop2  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoSetRop2
(
 PLOCALDC  pLocalDC,
 DWORD   rop
 )
{
    BOOL    b ;

    if (pLocalDC->iXORPass == DRAWXORPASS)
    {
        // If we are drawing during an XOR pass then the only ROP we support is
        // SRCCOPY and then we set it to XOR
        if (rop == R2_COPYPEN)
        {
            rop = R2_XORPEN;
        }
        else
        {
            pLocalDC->flags |= ERR_XORCLIPPATH;
            return FALSE;
        }
    }
    // Do it to the helper DC.
    SetROP2(pLocalDC->hdcHelper, rop);

    // Emit the Win16 metafile drawing order.

    b = bEmitWin16SetROP2(pLocalDC, LOWORD(rop)) ;

    return(b) ;
}

/***************************************************************************
*  SetBkMode  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoSetBkMode
(
 PLOCALDC  pLocalDC,
 DWORD   iBkMode
 )
{
    BOOL    b ;

    // Do it to the helper DC.  It needs this in a path bracket
    // if a text string is drawn.

    SetBkMode(pLocalDC->hdcHelper, (int) iBkMode);

    // Emit the Win16 metafile drawing order.

    b = bEmitWin16SetBkMode(pLocalDC, LOWORD(iBkMode)) ;

    return(b) ;
}

/***************************************************************************
*  SetBkColor  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL APIENTRY DoSetBkColor
(
 PLOCALDC    pLocalDC,
 COLORREF    crColor
 )
{
    BOOL    b ;

    pLocalDC->crBkColor = crColor;  // used by brushes

    // Emit the Win16 metafile drawing order.

    b = bEmitWin16SetBkColor(pLocalDC, crColor) ;

    return(b) ;
}

/***************************************************************************
*  GdiComment  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoGdiComment
(
 PLOCALDC   pLocalDC,
 PEMR       pemr
 )
{
    BOOL    b;
    PEMRGDICOMMENT_PUBLIC pemrComment = (PEMRGDICOMMENT_PUBLIC) pemr;

    PEMROFFICECOMMENT pemrOffice = (PEMROFFICECOMMENT) pemr;

    if (pemrOffice->emr.nSize == sizeof(EMROFFICECOMMENT)
        && pemrOffice->ident == msosignature)
    {
        // This is not necessarily a SrcCopy comment, but an Office Comment
        return (bEmitWin16EmitSrcCopyComment(pLocalDC, LOWORD(pemrOffice->iComment)));
    }

    // If it's not a public comment, just return TRUE.
    if (pemrComment->emr.nSize < sizeof(EMRGDICOMMENT_PUBLIC)
        || pemrComment->ident != GDICOMMENT_IDENTIFIER)
        return(TRUE);

    // Handle public comments.
    // A public comment consists of a public comment identifier,
    // a comment type, plus any accompanying data.

    switch (pemrComment->iComment)
    {
    case GDICOMMENT_MULTIFORMATS:
        b = DoGdiCommentMultiFormats(pLocalDC, (PEMRGDICOMMENT_MULTIFORMATS) pemr);
        break;
    case GDICOMMENT_BEGINGROUP:
    case GDICOMMENT_ENDGROUP:
    case GDICOMMENT_WINDOWS_METAFILE:
    default:
        b = TRUE;
        break;
    }

    return(b) ;
}

BOOL WINAPI DoGdiCommentMultiFormats
(
 PLOCALDC pLocalDC,
 PEMRGDICOMMENT_MULTIFORMATS pemrcmf
 )
{
    DWORD  i;
    DWORD  cSizeOld;
    int    iBase;
    XFORM  xformNew, xformScale;
    POINTL aptlFrame[4];
    RECTL  rclFrame;
    UINT   cbwmfNew;
    SIZEL  szlDeviceNew, szlMillimetersNew;
    BOOL   bRet      = FALSE;
    PBYTE  pbwmfNew  = (PBYTE) NULL;
    HDC    hdcemfNew = (HDC) 0;
    HENHMETAFILE   hemf    = (HENHMETAFILE) 0;
    HENHMETAFILE   hemfNew = (HENHMETAFILE) 0;
    PENHMETAHEADER pemfh;
    WIN16LOGBRUSH  Win16LogBrush;
    PMETARECORD    pmr;
#if DBG
    int    iSWO = 0;
    int    iSWE = 0;
#endif

    // We will convert the enhanced metafile format only.
    // Find the enhanced metafile data.

    for (i = 0; i < pemrcmf->nFormats; i++)
    {
        if (pemrcmf->aemrformat[i].dSignature == ENHMETA_SIGNATURE
            && pemrcmf->aemrformat[i].nVersion   <= META_FORMAT_ENHANCED)
            break;
    }

    // If we cannot find a recognized format, return failure.

    if (i >= pemrcmf->nFormats)
    {
        PUTS("MF3216: DoGdiCommentMultiFormats - no recognized format found\n");
        goto dgcmf_exit;
    }

    // Get the embedded enhanced metafile.

    hemf = SetEnhMetaFileBits((UINT) pemrcmf->aemrformat[i].cbData,
        &((PBYTE) &pemrcmf->ident)[pemrcmf->aemrformat[i].offData]);
    if (!hemf)
        goto dgcmf_exit;

    // Now the fun begins - we have to convert the enhanced metafile to
    // Windows metafile.
    // Since the multiformats record takes a logical rectangle, we have to
    // set up a proper transform for the enhanced metafile.  We do it by
    // creating a new enhanced metafile and playing the embedded metafile
    // into the new metafile with the proper transform setup.
    // In addition, the new metafile may have a different resolution than the
    // metafile.  We need to take this into account when setting up
    // the transform.

    // Get the world to device transform for the logical rectangle.

    if( pfnGetTransform != NULL )
    {
        if (!(pfnGetTransform)(pLocalDC->hdcHelper, XFORM_WORLD_TO_DEVICE, &xformNew))
            goto dgcmf_exit;
    }
    else
    {
        xformNew = xformIdentity ;
    }

    // Compute the device scales.

    szlDeviceNew.cx      = GetDeviceCaps(pLocalDC->hdcRef, HORZRES);
    szlDeviceNew.cy      = GetDeviceCaps(pLocalDC->hdcRef, VERTRES);
    szlMillimetersNew.cx = GetDeviceCaps(pLocalDC->hdcRef, HORZSIZE);
    szlMillimetersNew.cy = GetDeviceCaps(pLocalDC->hdcRef, VERTSIZE);
    pemfh = (PENHMETAHEADER) pLocalDC->pMf32Bits;

    xformScale.eM11 = ((FLOAT) szlDeviceNew.cx / (FLOAT) szlMillimetersNew.cx)
        / ((FLOAT) pemfh->szlDevice.cx / (FLOAT) pemfh->szlMillimeters.cx);
    xformScale.eM12 = 0.0f;
    xformScale.eM21 = 0.0f;
    xformScale.eM22 = ((FLOAT) szlDeviceNew.cy / (FLOAT) szlMillimetersNew.cy)
        / ((FLOAT) pemfh->szlDevice.cy / (FLOAT) pemfh->szlMillimeters.cy);
    xformScale.eDx  = 0.0f;
    xformScale.eDy  = 0.0f;

    // Compute the resulting transform to apply to the new metafile.

    if (!bCombineTransform(&xformNew, &xformNew, &xformScale))
        goto dgcmf_exit;

    // Create the new enhanced metafile.

    // Compute the new metafile frame.

    aptlFrame[0].x = pemrcmf->rclOutput.left;
    aptlFrame[0].y = pemrcmf->rclOutput.top;
    aptlFrame[1].x = pemrcmf->rclOutput.right;
    aptlFrame[1].y = pemrcmf->rclOutput.top;
    aptlFrame[2].x = pemrcmf->rclOutput.right;
    aptlFrame[2].y = pemrcmf->rclOutput.bottom;
    aptlFrame[3].x = pemrcmf->rclOutput.left;
    aptlFrame[3].y = pemrcmf->rclOutput.bottom;
    if (!bXformWorkhorse(aptlFrame, 4, &xformNew))
        goto dgcmf_exit;
    rclFrame.left   = MulDiv(100 * MIN4(aptlFrame[0].x, aptlFrame[1].x,
        aptlFrame[2].x, aptlFrame[3].x),
                 szlMillimetersNew.cx,
                 szlDeviceNew.cx);
    rclFrame.right  = MulDiv(100 * MAX4(aptlFrame[0].x, aptlFrame[1].x,
        aptlFrame[2].x, aptlFrame[3].x),
                 szlMillimetersNew.cx,
                 szlDeviceNew.cx);
    rclFrame.top    = MulDiv(100 * MIN4(aptlFrame[0].y, aptlFrame[1].y,
        aptlFrame[2].y, aptlFrame[3].y),
                 szlMillimetersNew.cy,
                 szlDeviceNew.cy);
    rclFrame.bottom = MulDiv(100 * MAX4(aptlFrame[0].y, aptlFrame[1].y,
        aptlFrame[2].y, aptlFrame[3].y),
                 szlMillimetersNew.cy,
                 szlDeviceNew.cy);

    hdcemfNew = CreateEnhMetaFileA(pLocalDC->hdcRef, (LPCSTR) NULL,
        (CONST RECT *) &rclFrame, (LPCSTR) NULL);
    if (!hdcemfNew)
        goto dgcmf_exit;

    if (!SetGraphicsMode(hdcemfNew, GM_ADVANCED))
        goto dgcmf_exit;

    // Set up the transform in the new metafile.

    if (!SetWorldTransform(hdcemfNew, &xformNew))
        goto dgcmf_exit;

    // Play the embedded metafile into the new metafile.
    // This call ensures balanced level etc.

    (void) PlayEnhMetaFile(hdcemfNew, hemf, (LPRECT) &pemrcmf->rclOutput);

    // Close the new metafile.

    hemfNew = CloseEnhMetaFile(hdcemfNew);
    hdcemfNew = (HDC) 0;        // used by clean up code below

    // Convert the new enhanced metafile to windows metafile.

    if (!(cbwmfNew = GetWinMetaFileBits(hemfNew, 0, (LPBYTE) NULL,
        MM_ANISOTROPIC, pLocalDC->hdcRef)))
        goto dgcmf_exit;

    if (!(pbwmfNew = (PBYTE) LocalAlloc(LMEM_FIXED, cbwmfNew)))
        goto dgcmf_exit;

    if (cbwmfNew != GetWinMetaFileBits(hemfNew, cbwmfNew, pbwmfNew,
        MM_ANISOTROPIC, pLocalDC->hdcRef))
        goto dgcmf_exit;

    // We now have the converted windows metafile.  We need to include it into
    // our current data stream.  There are a few things to be aware of:
    //
    // 1. Expand the object handle slot table.  The converted metafile may
    //    contain some undeleted objects.  These objects are likely
    //    the "stock" objects in the converter.  As a result, we need to
    //    expand the slot table by the number of object handles in the
    //    converted metafile.
    // 2. The object index must be changed to the current object index.
    //    We are going to do this by the lazy method, i.e. we will elevate
    //    the current object index base to one higher than the current max
    //    object index in the current data stream.  This is because Windows uses
    //    some an insane scheme for object index and this is the cheapest
    //    method.  We elevate the object index base by filling up the empty
    //    indexes with dummy objects that are freed when we are done.
    // 3. Remove the now useless comments.
    // 4. Skip header and eof.
    // 5. Set up the transform to place the embedded metafile into the data
    //    stream.  We know that the metafile bits returned by the converter
    //    contains only a SetWindowOrg and a SetWindowExt record.
    //    By implementation, we can simply remove both the SetWindowOrg and
    //    SetWindowExt records from the data stream.  The window origin and
    //    extents have been set up when we begin converting this enhanced
    //    metafile.

    // Expand the object handle slot table.

    if (((PMETAHEADER) pbwmfNew)->mtNoObjects)
    {
        cSizeOld = (DWORD) pLocalDC->cW16ObjHndlSlotStatus;
        if (cSizeOld + ((PMETAHEADER)pbwmfNew)->mtNoObjects > (UINT) (WORD) MAXWORD)
            goto dgcmf_exit;        // w16 handle index is only 16-bit

        pLocalDC->cW16ObjHndlSlotStatus += ((PMETAHEADER)pbwmfNew)->mtNoObjects;
        i = pLocalDC->cW16ObjHndlSlotStatus * sizeof(W16OBJHNDLSLOTSTATUS);
        pLocalDC->pW16ObjHndlSlotStatus = (PW16OBJHNDLSLOTSTATUS)
            LocalReAlloc(pLocalDC->pW16ObjHndlSlotStatus, i, LMEM_MOVEABLE);
        if (pLocalDC->pW16ObjHndlSlotStatus == NULL)
            goto dgcmf_exit;

        for (i = cSizeOld; i < pLocalDC->cW16ObjHndlSlotStatus; i++)
        {
            pLocalDC->pW16ObjHndlSlotStatus[i].use       = OPEN_AVAILABLE_SLOT;
            pLocalDC->pW16ObjHndlSlotStatus[i].w32Handle = 0 ;
        }
    }

    // Find the new base for the object index.

    for (iBase = pLocalDC->cW16ObjHndlSlotStatus - 1; iBase >= 0; iBase--)
    {
        if (pLocalDC->pW16ObjHndlSlotStatus[iBase].use != OPEN_AVAILABLE_SLOT)
            break;
    }
    iBase++;

    // Fill up the object index table with dummy objects.

    Win16LogBrush.lbStyle = BS_SOLID;
    Win16LogBrush.lbColor = 0;
    Win16LogBrush.lbHatch = 0;

    for (i = 0; i < (DWORD) iBase; i++)
    {
        if (pLocalDC->pW16ObjHndlSlotStatus[i].use == OPEN_AVAILABLE_SLOT)
        {
            if (!bEmitWin16CreateBrushIndirect(pLocalDC, &Win16LogBrush))
                goto dgcmf_exit;
            pLocalDC->pW16ObjHndlSlotStatus[i].use = REALIZED_DUMMY;
        }
    }

    // Update the high water mark.

    if (iBase + ((PMETAHEADER) pbwmfNew)->mtNoObjects - 1 > pLocalDC->nObjectHighWaterMark)
        pLocalDC->nObjectHighWaterMark = iBase + ((PMETAHEADER) pbwmfNew)->mtNoObjects - 1;

    // Save DC states.

    if (!bEmitWin16SaveDC(pLocalDC))
        goto dgcmf_exit;

    // Enumerate the records and fix them up as necessary.

    for (pmr = (PMETARECORD) (pbwmfNew + sizeof(METAHEADER));
    pmr->rdFunction != 0;
    pmr = (PMETARECORD) ((PWORD) pmr + pmr->rdSize))
    {
        switch (pmr->rdFunction)
        {
        case META_SETWINDOWORG:
            ASSERTGDI(++iSWO <= 1,
                "MF3216: DoGdiCommentMultiFormats - unexpected SWO record\n");
            break;
        case META_SETWINDOWEXT:
            ASSERTGDI(++iSWE <= 1,
                "MF3216: DoGdiCommentMultiFormats - unexpected SWE record\n");
            break;

        case META_ESCAPE:
            if (!IS_META_ESCAPE_ENHANCED_METAFILE((PMETA_ESCAPE_ENHANCED_METAFILE) pmr))
                goto default_alt;
            break;

        case META_RESTOREDC:
            ASSERTGDI((int)(SHORT)pmr->rdParm[0] < 0,
                "MF3216: DoGdiCommentMultiFormats - bogus RestoreDC record\n");
            goto default_alt;

        case META_SELECTCLIPREGION:
            if (pmr->rdParm[0] != 0)    // allow for default clipping!
            {
                pmr->rdParm[0] += (WORD)iBase;
                pLocalDC->pW16ObjHndlSlotStatus[pmr->rdParm[0]].use = REALIZED_OBJECT;
            }
            goto default_alt;

        case META_FRAMEREGION:
        case META_FILLREGION:
            pmr->rdParm[1] += (WORD)iBase;
            pLocalDC->pW16ObjHndlSlotStatus[pmr->rdParm[1]].use = REALIZED_OBJECT;
            // fall through
        case META_PAINTREGION:
        case META_INVERTREGION:
        case META_DELETEOBJECT:
        case META_SELECTPALETTE:
        case META_SELECTOBJECT:
            pmr->rdParm[0] += (WORD)iBase;
            if (pmr->rdFunction != META_DELETEOBJECT)
                pLocalDC->pW16ObjHndlSlotStatus[pmr->rdParm[0]].use = REALIZED_OBJECT;
            else
                pLocalDC->pW16ObjHndlSlotStatus[pmr->rdParm[0]].use = OPEN_AVAILABLE_SLOT;
            // fall through
        default:
default_alt:
            if (!bEmit(pLocalDC, (PVOID) pmr, pmr->rdSize * sizeof(WORD)))
                goto dgcmf_exit;
            vUpdateMaxRecord(pLocalDC, pmr);
            break;
        }
    }

    // Restore DC states.

    if (!bEmitWin16RestoreDC(pLocalDC, (WORD) -1))
        goto dgcmf_exit;

    // Remove the dummy objects from the handle table.

    for (i = 0; i < (DWORD) iBase; i++)
    {
        if (pLocalDC->pW16ObjHndlSlotStatus[i].use == REALIZED_DUMMY)
        {
            if (!bEmitWin16DeleteObject(pLocalDC, (WORD) i))
                goto dgcmf_exit;
            pLocalDC->pW16ObjHndlSlotStatus[i].use = OPEN_AVAILABLE_SLOT;
        }
    }

    // Shrink the object handle slot table.

    if (((PMETAHEADER) pbwmfNew)->mtNoObjects)
    {
        DWORD cUndel = 0;       // number of objects not deleted
        DWORD iUndelMax = iBase - 1;    // the max undeleted object index

        for (i = iBase; i < pLocalDC->cW16ObjHndlSlotStatus; i++)
        {
            if (pLocalDC->pW16ObjHndlSlotStatus[i].use != OPEN_AVAILABLE_SLOT)
            {
                cUndel++;
                iUndelMax = i;
            }
        }

        pLocalDC->cW16ObjHndlSlotStatus = max(cSizeOld + cUndel, iUndelMax + 1);
    }

    // Everything is golden.

    bRet = TRUE;

dgcmf_exit:

    if (pbwmfNew)
        if (LocalFree(pbwmfNew))
            ASSERTGDI(FALSE, "MF3216: DoGdiCommentMultiFormats - LocalFree failed\n");

        if (hemf)
            DeleteEnhMetaFile(hemf);

        if (hdcemfNew)
            hemfNew = CloseEnhMetaFile(hdcemfNew);  // hemfNew will be deleted next

        if (hemfNew)
            DeleteEnhMetaFile(hemfNew);

        return(bRet);
}

/***************************************************************************
*  EOF  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL APIENTRY DoEOF
(
 PLOCALDC  pLocalDC
 )
{
    BOOL    b ;

    b = bEmitWin16EOF(pLocalDC) ;

    return(b) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\gpmf3216\parser.c ===
/*****************************************************************************
 *
 * parser.cxx - Parser for the Win32 to Win16 metafile converter.
 *
 * Date: 8/13/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/


#include "precomp.h"
#pragma hdrstop

#define EMR_LAST_MF3216_SUPPORTED 97

BOOL bGetNextRecord(PLOCALDC pLocalDC, PENHMETARECORD *pemr) ;

// Call table for the translation entry points.

PDOFN pdofnDrawingOrders[] = {
        (PDOFN) NULL,
        bHandleHeader,                  // EMR_HEADER                       1
        bHandlePolyBezier,              // EMR_POLYBEZIER                   2
        bHandlePolygon,                 // EMR_POLYGON                      3
        bHandlePolyline,                // EMR_POLYLINE                     4
        bHandlePolyBezierTo,            // EMR_POLYBEZIERTO                 5
        bHandlePolylineTo,              // EMR_POLYLINETO                   6
        bHandlePolyPolyline,            // EMR_POLYPOLYLINE                 7
        bHandlePolyPolygon,             // EMR_POLYPOLYGON                  8
        bHandleSetWindowExt,            // EMR_SETWINDOWEXTEX               9
        bHandleSetWindowOrg,            // EMR_SETWINDOWORGEX               10
        bHandleSetViewportExt,          // EMR_SETVIEWPORTEXTEX             11
        bHandleSetViewportOrg,          // EMR_SETVIEWPORTORGEX             12
        bHandleNotImplemented,          // EMR_SETBRUSHORGEX                13
        bHandleEOF,                     // EMR_EOF                          14
        bHandleSetPixel,                // EMR_SETPIXELV                    15
        bHandleSetMapperFlags,          // EMR_SETMAPPERFLAGS               16
        bHandleSetMapMode,              // EMR_SETMAPMODE                   17
        bHandleSetBkMode,               // EMR_SETBKMODE                    18
        bHandleSetPolyFillMode,         // EMR_SETPOLYFILLMODE              19
        bHandleSetRop2,                 // EMR_SETROP2                      20
        bHandleSetStretchBltMode,       // EMR_SETSTRETCHBLTMODE            21
        bHandleSetTextAlign,            // EMR_SETTEXTALIGN                 22
        bHandleNotImplemented,          // EMR_SETCOLORADJUSTMENT           23
        bHandleSetTextColor,            // EMR_SETTEXTCOLOR                 24
        bHandleSetBkColor,              // EMR_SETBKCOLOR                   25
        bHandleOffsetClipRgn,           // EMR_OFFSETCLIPRGN                26
        bHandleMoveTo,                  // EMR_MOVETOEX                     27
        bHandleSetMetaRgn,              // EMR_SETMETARGN                   28
        bHandleExcludeClipRect,         // EMR_EXCLUDECLIPRECT              29
        bHandleIntersectClipRect,       // EMR_INTERSECTCLIPRECT            30
        bHandleScaleViewportExt,        // EMR_SCALEVIEWPORTEXTEX           31
        bHandleScaleWindowExt,          // EMR_SCALEWINDOWEXTEX             32
        bHandleSaveDC,                  // EMR_SAVEDC                       33
        bHandleRestoreDC,               // EMR_RESTOREDC                    34
        bHandleSetWorldTransform,       // EMR_SETWORLDTRANSFORM            35
        bHandleModifyWorldTransform,    // EMR_MODIFYWORLDTRANSFORM         36
        bHandleSelectObject,            // EMR_SELECTOBJECT                 37
        bHandleCreatePen,               // EMR_CREATEPEN                    38
        bHandleCreateBrushIndirect,     // EMR_CREATEBRUSHINDIRECT          39
        bHandleDeleteObject,            // EMR_DELETEOBJECT                 40
        bHandleAngleArc,                // EMR_ANGLEARC                     41
        bHandleEllipse,                 // EMR_ELLIPSE                      42
        bHandleRectangle,               // EMR_RECTANGLE                    43
        bHandleRoundRect,               // EMR_ROUNDRECT                    44
        bHandleArc,                     // EMR_ARC                          45
        bHandleChord,                   // EMR_CHORD                        46
        bHandlePie,                     // EMR_PIE                          47
        bHandleSelectPalette,           // EMR_SELECTPALETTE                48
        bHandleCreatePalette,           // EMR_CREATEPALETTE                49
        bHandleSetPaletteEntries,       // EMR_SETPALETTEENTRIES            50
        bHandleResizePalette,           // EMR_RESIZEPALETTE                51
        bHandleRealizePalette,          // EMR_REALIZEPALETTE               52
        bHandleExtFloodFill,            // EMR_EXTFLOODFILL                 53
        bHandleLineTo,                  // EMR_LINETO                       54
        bHandleArcTo,                   // EMR_ARCTO                        55
        bHandlePolyDraw,                // EMR_POLYDRAW                     56
        bHandleSetArcDirection,         // EMR_SETARCDIRECTION              57
        bHandleNotImplemented,          // EMR_SETMITERLIMIT                58
        bHandleBeginPath,               // EMR_BEGINPATH                    59
        bHandleEndPath,                 // EMR_ENDPATH                      60
        bHandleCloseFigure,             // EMR_CLOSEFIGURE                  61
        bHandleFillPath,                // EMR_FILLPATH                     62
        bHandleStrokeAndFillPath,       // EMR_STROKEANDFILLPATH            63
        bHandleStrokePath,              // EMR_STROKEPATH                   64
        bHandleFlattenPath,             // EMR_FLATTENPATH                  65
        bHandleWidenPath,               // EMR_WIDENPATH                    66
        bHandleSelectClipPath,          // EMR_SELECTCLIPPATH               67
        bHandleAbortPath,               // EMR_ABORTPATH                    68
        bHandleNotImplemented,          //                                  69
        bHandleGdiComment,              // EMR_GDICOMMENT                   70
        bHandleFillRgn,                 // EMR_FILLRGN                      71
        bHandleFrameRgn,                // EMR_FRAMERGN                     72
        bHandleInvertRgn,               // EMR_INVERTRGN                    73
        bHandlePaintRgn,                // EMR_PAINTRGN                     74
        bHandleExtSelectClipRgn,        // EMR_EXTSELECTCLIPRGN             75
        bHandleBitBlt,                  // EMR_BITBLT                       76
        bHandleStretchBlt,              // EMR_STRETCHBLT                   77
        bHandleMaskBlt,                 // EMR_MASKBLT                      78
        bHandlePlgBlt,                  // EMR_PLGBLT                       79
        bHandleSetDIBitsToDevice,       // EMR_SETDIBITSTODEVICE            80
        bHandleStretchDIBits,           // EMR_STRETCHDIBITS                81
        bHandleExtCreateFont,           // EMR_EXTCREATEFONTINDIRECTW       82
        bHandleExtTextOut,              // EMR_EXTTEXTOUTA                  83
        bHandleExtTextOut,              // EMR_EXTTEXTOUTW                  84
        bHandlePoly16,                  // EMR_POLYBEZIER16                 85
        bHandlePoly16,                  // EMR_POLYGON16                    86
        bHandlePoly16,                  // EMR_POLYLINE16                   87
        bHandlePoly16,                  // EMR_POLYBEZIERTO16               88
        bHandlePoly16,                  // EMR_POLYLINETO16                 89
        bHandlePolyPoly16,              // EMR_POLYPOLYLINE16               90
        bHandlePolyPoly16,              // EMR_POLYPOLYGON16                91
        bHandlePoly16,                  // EMR_POLYDRAW16                   92
        bHandleCreateMonoBrush,         // EMR_CREATEMONOBRUSH              93
        bHandleCreateDIBPatternBrush,   // EMR_CREATEDIBPATTERNBRUSHPT      94
        bHandleExtCreatePen,            // EMR_EXTCREATEPEN                 95
        bHandlePolyTextOut,             // EMR_POLYTEXTOUTA                 96
        bHandlePolyTextOut,             // EMR_POLYTEXTOUTW                 97
        bHandleNotImplemented,          // EMR_SETICMMODE                   98
        bHandleNotImplemented,          // EMR_CREATECOLORSPACE             99
        bHandleNotImplemented,          // EMR_SETCOLORSPACE               100
        bHandleNotImplemented,          // EMR_DELETECOLORSPACE            101
        bHandleNotImplemented,          // EMR_GLSRECORD                   102
        bHandleNotImplemented,          // EMR_GLSBOUNDEDRECORD            103
        bHandleNotImplemented,          // EMR_PIXELFORMAT                 104
        bHandleNotImplemented,          //                                 105
        bHandleNotImplemented,          //                                 106
        bHandleNotImplemented,          //                                 107
        bHandleNotImplemented,          //                                 108
        bHandleNotImplemented,          //                                 109
        bHandleNotImplemented,          //                                 110
        bHandleNotImplemented,          // EMR_COLORCORRECTPALETTE         111
        bHandleNotImplemented,          // EMR_ALPHABLEND                  112
        bHandleNotImplemented,          // EMR_ALPHADIBBLEND               113
        bHandleNotImplemented,          // EMR_TRANSPARENTIMAGE            114
        bHandleNotImplemented,          // EMR_TRANSPARENTDIBIMAGE         115
        bHandleNotImplemented           // EMR_GRADIENTFILL                116

} ;

#if DBG

PSZ         pszMfRecords[] = {
                        "NULL RECORD               ",
                        "EMR_HEADER                ",
                        "EMR_POLYBEZIER            ",
                        "EMR_POLYGON               ",
                        "EMR_POLYLINE              ",
                        "EMR_POLYBEZIERTO          ",
                        "EMR_POLYLINETO            ",
                        "EMR_POLYPOLYLINE          ",
                        "EMR_POLYPOLYGON           ",
                        "EMR_SETWINDOWEXTEX        ",
                        "EMR_SETWINDOWORGEX        ",
                        "EMR_SETVIEWPORTEXTEX      ",
                        "EMR_SETVIEWPORTORGEX      ",
                        "EMR_SETBRUSHORGEX         ",
                        "EMR_EOF                   ",
                        "EMR_SETPIXELV             ",
                        "EMR_SETMAPPERFLAGS        ",
                        "EMR_SETMAPMODE            ",
                        "EMR_SETBKMODE             ",
                        "EMR_SETPOLYFILLMODE       ",
                        "EMR_SETROP2               ",
                        "EMR_SETSTRETCHBLTMODE     ",
                        "EMR_SETTEXTALIGN          ",
                        "EMR_SETCOLORADJUSTMENT    ",
                        "EMR_SETTEXTCOLOR          ",
                        "EMR_SETBKCOLOR            ",
                        "EMR_OFFSETCLIPRGN         ",
                        "EMR_MOVETOEX              ",
                        "EMR_SETMETARGN            ",
                        "EMR_EXCLUDECLIPRECT       ",
                        "EMR_INTERSECTCLIPRECT     ",
                        "EMR_SCALEVIEWPORTEXTEX    ",
                        "EMR_SCALEWINDOWEXTEX      ",
                        "EMR_SAVEDC                ",
                        "EMR_RESTOREDC             ",
                        "EMR_SETWORLDTRANSFORM     ",
                        "EMR_MODIFYWORLDTRANSFORM  ",
                        "EMR_SELECTOBJECT          ",
                        "EMR_CREATEPEN             ",
                        "EMR_CREATEBRUSHINDIRECT   ",
                        "EMR_DELETEOBJECT          ",
                        "EMR_ANGLEARC              ",
                        "EMR_ELLIPSE               ",
                        "EMR_RECTANGLE             ",
                        "EMR_ROUNDRECT             ",
                        "EMR_ARC                   ",
                        "EMR_CHORD                 ",
                        "EMR_PIE                   ",
                        "EMR_SELECTPALETTE         ",
                        "EMR_CREATEPALETTE         ",
                        "EMR_SETPALETTEENTRIES     ",
                        "EMR_RESIZEPALETTE         ",
                        "EMR_REALIZEPALETTE        ",
                        "EMR_EXTFLOODFILL          ",
                        "EMR_LINETO                ",
                        "EMR_ARCTO                 ",
                        "EMR_POLYDRAW              ",
                        "EMR_SETARCDIRECTION       ",
                        "EMR_SETMITERLIMIT         ",
                        "EMR_BEGINPATH             ",
                        "EMR_ENDPATH               ",
                        "EMR_CLOSEFIGURE           ",
                        "EMR_FILLPATH              ",
                        "EMR_STROKEANDFILLPATH     ",
                        "EMR_STROKEPATH            ",
                        "EMR_FLATTENPATH           ",
                        "EMR_WIDENPATH             ",
                        "EMR_SELECTCLIPPATH        ",
                        "EMR_ABORTPATH             ",
                        "unknown record            ",
                        "EMR_GDICOMMENT            ",
                        "EMR_FILLRGN               ",
                        "EMR_FRAMERGN              ",
                        "EMR_INVERTRGN             ",
                        "EMR_PAINTRGN              ",
                        "EMR_EXTSELECTCLIPRGN      ",
                        "EMR_BITBLT                ",
                        "EMR_STRETCHBLT            ",
                        "EMR_MASKBLT               ",
                        "EMR_PLGBLT                ",
                        "EMR_SETDIBITSTODEVICE     ",
                        "EMR_STRETCHDIBITS         ",
                        "EMR_EXTCREATEFONTINDIRECTW",
                        "EMR_EXTTEXTOUTA           ",
                        "EMR_EXTTEXTOUTW           ",
                        "EMR_POLYBEZIER16          ",
                        "EMR_POLYGON16             ",
                        "EMR_POLYLINE16            ",
                        "EMR_POLYBEZIERTO16        ",
                        "EMR_POLYLINETO16          ",
                        "EMR_POLYPOLYLINE16        ",
                        "EMR_POLYPOLYGON16         ",
                        "EMR_POLYDRAW16            ",
                        "EMR_CREATEMONOBRUSH       ",
                        "EMR_CREATEDIBPATTERNBRUSHP",
                        "EMR_EXTCREATEPEN          ",
                        "EMR_POLYTEXTOUTA          ",
                        "EMR_POLYTEXTOUTW          ",
                        "EMR_SETICMMODE            ",
                        "EMR_CREATECOLORSPACE      ",
                        "EMR_SETCOLORSPACE         ",
                        "EMR_DELETECOLORSPACE      ",
                        "EMR_GLSRECORD             ",
                        "EMR_GLSBOUNDEDRECORD      ",
                        "EMR_PIXELFORMAT           ",
                        "105                       ",
                        "106                       ",
                        "107                       ",
                        "108                       ",
                        "109                       ",
                        "110                       ",
                        "EMR_COLORCORRECTPALETTE   ",
                        "EMR_ALPHABLEND            ",
                        "EMR_ALPHADIBBLEND         ",
                        "EMR_TRANSPARENTIMAGE      ",
                        "EMR_TRANSPARENTDIBIMAGE   ",
                        "EMR_GRADIENTFILL          "
};

#endif

/*****************************************************************************
 *  Parse the Win32 metafile.
 *
 *  The Win32 metafile is represented by the metafile bits pointed to
 *  by pMetafileBits.  The metafile bits may be obtained from a memory mapped
 *  file, or from some shared memory (from the clipboard).
 *****************************************************************************/
BOOL bParseWin32Metafile(PBYTE pMetafileBits, PLOCALDC pLocalDC)
{
INT         iType ;
PVOID       pVoid ;
PENHMETARECORD pemr ;
PENHMETAHEADER pMf32Header ;
DWORD       nFileSize ;
BOOL        bRet ;
INT         iRecordCount,
            iLastError ;

        bRet = TRUE ;

        // Get the file length from the header.
        // Test to make sure the first record is a Win32 Metafile header.

        pMf32Header = (PENHMETAHEADER) pMetafileBits ;
        if (   (pMf32Header->iType      != EMR_HEADER)
            || (pMf32Header->dSignature != ENHMETA_SIGNATURE)
           )
        {
            RIPS("MF3216: bParseWin32Metafile, First Record not a Win32 Metafile Header\n") ;
            return(FALSE) ;
        }

        // Record a pointer to the beginning of the Win32 metafile and
        // it's length incase we need to emit the Win32 metafile  as  a comment
        // record(s).

        pLocalDC->pMf32Bits = (PBYTE) pMf32Header ;
        pLocalDC->cMf32Bits = pMf32Header->nBytes ;

        // Get the file size for the parser.

        nFileSize = pMf32Header->nBytes ;

        // Initialize pbCurrent, & pbEnd pointers into the
        // metafile bits.

        pLocalDC->pbCurrent = pMetafileBits ;
        pLocalDC->pbEnd   = pLocalDC->pbCurrent + nFileSize ;

        // Init the record count.

        iRecordCount = 0 ;

        // Go through the metafile bits.  Handle each record based on
        // it's type.  bGetNextRecord returns TRUE if pemr contains
        // a pointer to a record.

        while (bGetNextRecord(pLocalDC, &pemr))
        {

            iRecordCount++ ;

            // Set up a convienent point to the record.

            pVoid = (PVOID) pemr ;

            // Handle the record based on it's type.

            iType = (INT) pemr->iType ;

            // Check if the record type falls within the range of the
            // call table.  Eventually, all the record handlers  should
            // be in the call table.

            if (iType <= EMR_LAST_MF3216_SUPPORTED)
            {
                bRet = pdofnDrawingOrders[iType](pVoid, pLocalDC) ;
#if DBG
                if (bRet == FALSE)
                {
                    iLastError = GetLastError() ;
                    PUTS1("MF3216: Error on Win32 Metafile record #: %d\n", iRecordCount) ;
                    PUTS1("\tRecord type: %s\n", pszMfRecords[iType]) ;
                    PUTS1("\tLast Error Code: %08.8X\n", iLastError) ;
                }
#endif
#if 0
                if (bRet == FALSE)
                    break ;
#else
                // In ancient times (i.e., before NT4.0), someone explicitly
                // removed the code above which exits the loop if the handler
                // fails.  Possibly this was a compatibility fix in which
                // the app depended on the metafile conversion to continue
                // even in the event of a failure.
                //
                // Unfortunately, this fix also allows the parser to continue
                // even if the output buffer has run out of space.  To
                // minimize the change, we will explicitly look for this case
                // and break out of the loop if it happens.  (Refer to bEmit()
                // in emit.c to see where ERROR_BUFFER_OVERFLOW is set).

                if (pLocalDC->flags & ( ERR_BUFFER_OVERFLOW | ERR_XORCLIPPATH ) )
                    break ;
#endif
            }
            else
            {
                PUTS1("MF3216: bParseWin32Metafile - record not supported: %d\n", iType) ;
            }
        }
#if 0
        // Display some statictics

        if (bRet == TRUE)
        {
            PUTS1("MF3216: %d Win32 Metafile records processed\n",
                   iRecordCount) ;
        }
#endif
        return(bRet) ;
}

/*****************************************************************************
 * Get next record
 *
 *  This is a support routine for bParseWin32Metafile.
 *  It is assumed that pbCurrent, & pbEnd are initialized
 *  the first time this routine is called.
 *
 *  It returns TRUE if a valid pointer to record is returned in
 *  pemr.  If there are not more records FALSE is returned.
 *
 *  We now need to take into consideration 
 *****************************************************************************/
BOOL bGetNextRecord(PLOCALDC pLocalDC, PENHMETARECORD *ppemr)
{
DWORD   nSize ;

        // if we are recreating the objects then go through our list of objects
        if (pLocalDC->iXORPass == OBJECTRECREATION)
        {
            if (pLocalDC->pW16RecreationSlot == NULL)
            {
                // All our objects are created... Set the next record to be the start
                // of the second pass
                pLocalDC->pbRecord = pLocalDC->pbChange ;
                pLocalDC->pbCurrent = pLocalDC->pbRecord ;
                *ppemr = (PENHMETARECORD) pLocalDC->pbCurrent ;

                nSize = ((PENHMETARECORD) pLocalDC->pbCurrent)->nSize ;
                pLocalDC->pbCurrent += nSize ;

                pLocalDC->iXORPass = ERASEXORPASS ;

                DoSelectObject(pLocalDC, pLocalDC->lholdp32);
                DoSelectObject(pLocalDC, pLocalDC->lholdbr32);

                return TRUE ;
            }
            else
            {
                PW16RECREATIONSLOT pW16RecreationSlot = pLocalDC->pW16RecreationSlot ;
                pLocalDC->pW16RecreationSlot = pW16RecreationSlot->pNext ;
                pLocalDC->pbRecord = (PBYTE) pW16RecreationSlot->pbCreatRec ;
                pLocalDC->pbCurrent = (PBYTE) pW16RecreationSlot->pbCreatRec ;
                *ppemr = (PENHMETARECORD) pLocalDC->pbCurrent ;
                nSize = ((PENHMETARECORD) pLocalDC->pbCurrent)->nSize ;
                pLocalDC->pbCurrent += nSize ;

                LocalFree(pW16RecreationSlot);

                return TRUE ;
            }
        }


        // Check for the end of buffer.
        // If this is the end return FALSE and set *ppemr to 0.

        if (pLocalDC->pbCurrent == pLocalDC->pbEnd)
        {
            *ppemr = (PENHMETARECORD) NULL ;
            pLocalDC->pbRecord = NULL ;
            return (FALSE) ;
        }

        // Well it's not the end of the buffer.
        // So, return a pointer to this record, update pbCurrent, and
        // return TRUE ;

        *ppemr = (PENHMETARECORD) pLocalDC->pbCurrent ;
        pLocalDC->pbRecord = pLocalDC->pbCurrent ;

        nSize = ((PENHMETARECORD) pLocalDC->pbCurrent)->nSize ;
        pLocalDC->pbCurrent += nSize ;

        return(TRUE) ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\gpmf3216\paths.c ===
/*****************************************************************************
 *
 * paths - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop

#pragma pack(2)

typedef struct PathInfo16
{
    WORD       RenderMode;
    BYTE       FillMode;
    BYTE       BkMode;
    LOGPEN16   Pen;
    LOGBRUSH16 Brush;
    DWORD      BkColor;
} PathInfo16;

#pragma pack()

BOOL GdipFlattenGdiPath(PLOCALDC, LPVOID*, INT*);


/****************************************************************************
*   GillesK 2001/02/12
*   Convert a PolyPolygon call to multiple Polygons calls.
*   PolyPolygons cannot be used for Postscript paths. So we need to convert
*   them to Polygon calls and wrap a Postscipt BeginPath/EndPath sequence
*   around each polygon
****************************************************************************/

BOOL ConvertPolyPolygonToPolygons(
PLOCALDC pLocalDC,
PPOINTL pptl,
PDWORD  pcptl,
DWORD   cptl,
DWORD   ccptl,
BOOL    transform
)
{
    PathInfo16 pathInfo16 = { 0, 1, TRANSPARENT,
    { PS_NULL, {0,0}, RGB(0, 0, 0)},
    {BS_HOLLOW, RGB(0, 0, 0), 0},
    RGB(0, 0, 0) } ;
    DWORD   polyCount;
    BOOL    b = TRUE; // In case there are 0 polygons
    PPOINTL buffer = NULL; 
    PPOINTS shortBuffer = NULL;
    WORD    wEscape;

    // Convert the points from POINTL to POINTS
    buffer = (PPOINTL) LocalAlloc(LMEM_FIXED, cptl * sizeof(POINTL));
    if (buffer == NULL)
    {
        return FALSE;
    }                      
    RtlCopyMemory(buffer, pptl, cptl*sizeof(POINTL));
    if (transform)
    {
        b = bXformRWorldToPPage(pLocalDC, buffer, cptl);
        if (b == FALSE)
            goto exitFreeMem;
    }

    vCompressPoints(buffer, cptl) ;
        shortBuffer = (PPOINTS) buffer;

                             
    // For each polygon in the polycount, we do a BeginPath, and EndPath
    for (polyCount = 0; polyCount < ccptl; shortBuffer += pcptl[polyCount], polyCount++)
    {
        // Emit the Postscript escape to End the Path
        if(!bEmitWin16Escape(pLocalDC, BEGIN_PATH, 0, NULL, NULL))
            goto exitFreeMem;

        // Call the Win16 routine to emit the poly to the metafile.
        b = bEmitWin16Poly(pLocalDC, (LPPOINTS) shortBuffer, (SHORT) pcptl[polyCount],
            META_POLYGON) ;

        // Emit the Postscript escape to End the Path
        if(!bEmitWin16Escape(pLocalDC, END_PATH, sizeof(pathInfo16), (LPSTR)&pathInfo16, NULL))
            goto exitFreeMem;

        // If the bEmitWin16Poly has failed, we at least want to end the path
        if (!b)
        {
            goto exitFreeMem;
        }

    }

exitFreeMem:
    if (buffer != NULL)
    {
        LocalFree((HLOCAL) buffer);
    }

    return b;

}

BOOL ConvertPathToPSClipPath(PLOCALDC pLocalDC, BOOL psOnly)
{
    INT   ihW32Br;
    LONG  lhpn32 = pLocalDC->lhpn32;
    LONG  lhbr32 = pLocalDC->lhbr32;
    WORD  wEscape;

    if( pLocalDC->iROP == R2_NOTCOPYPEN )
    {
        ihW32Br = WHITE_BRUSH | ENHMETA_STOCK_OBJECT ;
    }
    else
    {
        ihW32Br = BLACK_BRUSH | ENHMETA_STOCK_OBJECT ;
    }

    // Emit the Postscript escape to ignore the pen change
    wEscape = STARTPSIGNORE ;
    if(!bEmitWin16Escape(pLocalDC, POSTSCRIPT_IGNORE, sizeof(wEscape), (LPSTR)&wEscape, NULL))
        return FALSE ;

    if (DoSelectObject(pLocalDC, ihW32Br))
    {
        // Do it to the helper DC.
        DWORD oldRop = SetROP2(pLocalDC->hdcHelper, R2_COPYPEN);
        // Emit the Win16 metafile drawing order.
        if (!bEmitWin16SetROP2(pLocalDC, LOWORD(R2_COPYPEN)))
            return FALSE;

        wEscape = ENDPSIGNORE ;
        if(!bEmitWin16Escape(pLocalDC, POSTSCRIPT_IGNORE, sizeof(wEscape), (LPSTR)&wEscape, NULL))
            return FALSE ;

        // If we only want the path in PS then we need to save the previous one
        if (psOnly)
        {
            wEscape = CLIP_SAVE ;
            if(!bEmitWin16Escape(pLocalDC, CLIP_TO_PATH, sizeof(wEscape), (LPSTR)&wEscape, NULL))
                return FALSE ;
        }

        if(!DoRenderPath(pLocalDC, EMR_FILLPATH, psOnly))   // We need to fill the path with black
            return FALSE;

        if(pLocalDC->pbLastSelectClip == pLocalDC->pbRecord || psOnly)
        {
            wEscape = CLIP_INCLUSIVE;
            if(!bEmitWin16Escape(pLocalDC, CLIP_TO_PATH, sizeof(wEscape), (LPSTR)&wEscape, NULL))
                return FALSE;
        }

        // Emit the Postscript escape to ignore the pen change
        wEscape = STARTPSIGNORE ;
        if(!bEmitWin16Escape(pLocalDC, POSTSCRIPT_IGNORE, sizeof(wEscape), (LPSTR)&wEscape, NULL))
            return FALSE ;

        if(!DoSelectObject(pLocalDC, lhbr32))
            return FALSE;

        // Do it to the helper DC.
        SetROP2(pLocalDC->hdcHelper, oldRop);
        // Emit the Win16 metafile drawing order.
        if (!bEmitWin16SetROP2(pLocalDC, LOWORD(oldRop)))
            return FALSE;

        wEscape = ENDPSIGNORE ;
        if(!bEmitWin16Escape(pLocalDC, POSTSCRIPT_IGNORE, sizeof(wEscape), (LPSTR)&wEscape, NULL))
            return FALSE ;

    }
    return TRUE ;

}

/***************************************************************************
*  BeginPath  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoBeginPath
(
 PLOCALDC pLocalDC
 )
{
    BOOL    b ;

    // Set the global flag telling all all the geometric
    // rendering routines that we are accumulating drawing orders
    // for the path.

    pLocalDC->flags |= RECORDING_PATH ;

    // Tell the helper DC we are begining the path accumulation.

    b = BeginPath(pLocalDC->hdcHelper) ;

    // Save the position of the path if we haven't started the XOR passes
    if (pLocalDC->flags & INCLUDE_W32MF_XORPATH)
    {
        if(pLocalDC->iXORPass == NOTXORPASS)
        {
            pLocalDC->pbChange = (PBYTE) pLocalDC->pbRecord ;
            pLocalDC->lholdp32 = pLocalDC->lhpn32 ;
            pLocalDC->lholdbr32 = pLocalDC->lhbr32;
        }
    }
    ASSERTGDI((b == TRUE), "MF3216: DoBeginPath, BeginPath failed\n") ;

    return (b) ;
}

/***************************************************************************
*  EndPath  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoEndPath
(
 PLOCALDC pLocalDC
 )
{
    BOOL    b ;

    // Reset the global flag, turning off the path accumulation.

    pLocalDC->flags &= ~RECORDING_PATH ;

    b = EndPath(pLocalDC->hdcHelper) ;

    ASSERTGDI((b == TRUE), "MF3216: DoEndPath, EndPath failed\n") ;

    return (b) ;
}

/***************************************************************************
*  WidenPath  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoWidenPath
(
 PLOCALDC pLocalDC
 )
{
    BOOL    b ;

    b = WidenPath(pLocalDC->hdcHelper) ;

    ASSERTGDI((b == TRUE), "MF3216: DoWidenPath, WidenPath failed\n") ;

    return (b) ;
}

/***************************************************************************
*  SelectClipPath  - Win32 to Win16 Metafile Converter Entry Point
*
* History:
*  Tue Apr 07 17:05:37 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
**************************************************************************/

BOOL WINAPI DoSelectClipPath(PLOCALDC pLocalDC, INT iMode)
{
    INT    iROP2 ;
    BOOL   bRet = TRUE;
    WORD   wEscape;
    PathInfo16 pathInfo16 = { 0, 1, 1,
    { PS_NULL, {0,0}, 0},
    {BS_NULL, 0, 0},
    0 } ;

    BOOL   bNoClipping = bNoDCRgn(pLocalDC, DCRGN_CLIP);
    BOOL   bIgnorePS = FALSE;

    // Since we cannot do any other operations then an OR with multiple clipping regions
    // Only do the XOR if we are with a RGN_OR
    if ((iMode == RGN_COPY || iMode == RGN_AND ||
         (iMode == RGN_OR && bNoClipping)) &&
         (pLocalDC->flags & INCLUDE_W32MF_XORPATH))
    {
        if (pLocalDC->iXORPass == NOTXORPASS )
        {
            pLocalDC->iXORPass = DRAWXORPASS ;
            pLocalDC->iXORPassDCLevel = pLocalDC->iLevel ;
            iROP2 = GetROP2( pLocalDC->hdcHelper ) ;
            if( iROP2 == R2_COPYPEN || iROP2 == R2_NOTCOPYPEN )
            {
                if(!DoSaveDC(pLocalDC))
                    return FALSE;
                pLocalDC->iROP = iROP2;

                // Emit the Postscript escape to ignore the XOR
                wEscape = STARTPSIGNORE ;
                if(!bEmitWin16Escape(pLocalDC, POSTSCRIPT_IGNORE, sizeof(wEscape), (LPSTR)&wEscape, NULL))
                    return FALSE ;

                // Do it to the helper DC.
                SetROP2(pLocalDC->hdcHelper, R2_XORPEN);
                // Emit the Win16 metafile drawing order.
                if (!bEmitWin16SetROP2(pLocalDC, LOWORD(R2_XORPEN)))
                    return FALSE;

                MoveToEx( pLocalDC->hdcHelper, 0, 0, &(pLocalDC->pOldPosition ) ) ;
                MoveToEx( pLocalDC->hdcHelper, pLocalDC->pOldPosition.x, pLocalDC->pOldPosition.y, NULL );

                // Save this record number. When we pass again the last one will be the one that send the
                // Postscript clip path.
                pLocalDC->pbLastSelectClip = pLocalDC->pbRecord ;
                
                return bRet ;
            }
            pLocalDC->flags |= ERR_XORCLIPPATH;

            return FALSE;
        }
        else if(pLocalDC->iXORPass == DRAWXORPASS )
        {
            // Save this record number. When we pass again the last one will be the one that send the
            // Postscript clip path.
            pLocalDC->pbLastSelectClip = pLocalDC->pbRecord ;
            return TRUE;
        }
        else if( pLocalDC->iXORPass == ERASEXORPASS )
        {
            if (!ConvertPathToPSClipPath(pLocalDC, FALSE) ||
                !bEmitWin16EmitSrcCopyComment(pLocalDC, msocommentBeginSrcCopy))
            {
                return FALSE;
            }
            return TRUE;
        }
        else
        {
            ASSERT(FALSE);
        }
    }
    
    // Convert the clippath to a PS clippath
    if (ConvertPathToPSClipPath(pLocalDC, TRUE))
    {
        bIgnorePS = TRUE;
        pLocalDC->iSavePSClipPath++;
        // Emit the Postscript escape to ignore the pen change
        wEscape = STARTPSIGNORE ;
        if(!bEmitWin16Escape(pLocalDC, POSTSCRIPT_IGNORE, sizeof(wEscape), (LPSTR)&wEscape, NULL))
            return FALSE ;
    }

    // If there is no initial clip region and we are going to operate
    // on the initial clip region, we have to
    // create one.  Otherwise, GDI will create some random default
    // clipping region for us!

    if ((iMode == RGN_DIFF || iMode == RGN_XOR || iMode == RGN_OR)
        && bNoClipping)
    {
        HRGN hrgnDefault;

        if (!(hrgnDefault = CreateRectRgn((int) (SHORT) MINSHORT,
            (int) (SHORT) MINSHORT,
            (int) (SHORT) MAXSHORT,
            (int) (SHORT) MAXSHORT)))
        {
            ASSERTGDI(FALSE, "MF3216: CreateRectRgn failed");
            return(FALSE);
        }

        bRet = (ExtSelectClipRgn(pLocalDC->hdcHelper, hrgnDefault, RGN_COPY)
            != ERROR);
        ASSERTGDI(bRet, "MF3216: ExtSelectClipRgn failed");

        if (!DeleteObject(hrgnDefault))
            ASSERTGDI(FALSE, "MF3216: DeleteObject failed");

        if (!bRet)
            return(FALSE);
    }
    // Do it to the helper DC.
    // When we do this. It clears the path so it has to be
    // done when we are not using the path
    if(!SelectClipPath(pLocalDC->hdcHelper, iMode))
        return(FALSE);

    // Dump the clip region data.
    bRet = bDumpDCClipping(pLocalDC);

    if (bIgnorePS)
    {
        // Emit the Postscript escape to ignore the pen change
        wEscape = ENDPSIGNORE ;
        if(!bEmitWin16Escape(pLocalDC, POSTSCRIPT_IGNORE, sizeof(wEscape), (LPSTR)&wEscape, NULL))
            return FALSE ;
    }

    return(bRet);
}


/***************************************************************************
*  FlattenPath  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoFlattenPath
(
 PLOCALDC pLocalDC
 )
{
    BOOL    b;
    b = FlattenPath(pLocalDC->hdcHelper) ;
    ASSERTGDI((b == TRUE), "MF3216: DoFlattenPath, FlattenPath failed\n") ;

    return (b) ;
}

/***************************************************************************
*  AbortPath  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoAbortPath
(
 PLOCALDC pLocalDC
 )
{
    BOOL    b ;

    // Reset the global flag, turning off the path accumulation.

    pLocalDC->flags &= ~RECORDING_PATH ;

    b = AbortPath(pLocalDC->hdcHelper) ;

    // We cannot abort a path if we have a XORPass so return FALSE
    if (pLocalDC->flags & INCLUDE_W32MF_XORPATH)
        return FALSE ;

    ASSERTGDI((b == TRUE), "MF3216: DoAbortPath, AbortPath failed\n") ;

    return (b) ;
}

/***************************************************************************
*  CloseFigure  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoCloseFigure
(
 PLOCALDC pLocalDC
 )
{
    BOOL    b ;

    b = CloseFigure(pLocalDC->hdcHelper) ;

    ASSERTGDI((b == TRUE), "MF3216: DoCloseFigure, CloseFigure failed\n") ;

    return (b) ;
}

/***************************************************************************
*  DoRenderPath  - Common code for StrokePath, FillPath and StrokeAndFillPath.
**************************************************************************/

// Macro for copy a point in the path data.

#define MOVE_A_POINT(iDst, pjTypeDst, pptDst, iSrc, pjTypeSrc, pptSrc)  \
{                               \
    pjTypeDst[iDst] = pjTypeSrc[iSrc];              \
    pptDst[iDst]    = pptSrc[iSrc];             \
}

BOOL WINAPI DoRenderPath(PLOCALDC pLocalDC, INT mrType, BOOL psOnly)
{
    BOOL    b;
    PBYTE   pb    = (PBYTE) NULL;
    PBYTE   pbNew = (PBYTE) NULL;
    LPPOINT ppt, pptNew;
    LPBYTE  pjType, pjTypeNew;
    PDWORD  pPolyCount;
    INT     cpt, cptNew, cPolyCount;
    INT     i, j, jStart;
    LONG    lhpn32;
    LPVOID  pGdipFlatten = NULL;
    INT     count = 0;
    BOOL    transform = TRUE;
    WORD    wEscape;

    b = FALSE;              // assume failure
    ppt = NULL;
    pjType = NULL;

    // Flatten the path, to convert all the beziers into polylines.

    // Try to use GDIPlus and transform the points before hand, if we fail then
    // go back and try to do it with GDI

    if (GdipFlattenGdiPath(pLocalDC, &pGdipFlatten, &count))
    {
        ASSERT(pGdipFlatten != NULL);
        ppt    = (LPPOINT)pGdipFlatten;
        pjType = (PBYTE) (ppt + count);
        cpt = count;
        transform = FALSE;
    }
    else
    {
        if (!DoFlattenPath(pLocalDC))
        {
            RIPS("MF3216: DoRenderPath, FlattenPath failed\n");
            goto exit_DoRenderPath;
        }

        // Get the path data.

        // First get a count of the number of points.

        cpt = GetPath(pLocalDC->hdcHelper, (LPPOINT) NULL, (LPBYTE) NULL, 0);
        if (cpt == -1)
        {
            RIPS("MF3216: DoRenderPath, GetPath failed\n");
            goto exit_DoRenderPath;
        }

        // Check for empty path.

        if (cpt == 0)
        {
            b = TRUE;
            goto exit_DoRenderPath;
        }

        // Allocate memory for the path data.

        if (!(pb = (PBYTE) LocalAlloc
            (
            LMEM_FIXED,
            cpt * (sizeof(POINT) + sizeof(BYTE))
            )
            )
            )
        {
            RIPS("MF3216: DoRenderPath, LocalAlloc failed\n");
            goto exit_DoRenderPath;
        }

        // Order of assignment is important for dword alignment.

        ppt    = (LPPOINT) pb;
        pjType = (LPBYTE) (ppt + cpt);

        // Finally, get the path data.

        if (GetPath(pLocalDC->hdcHelper, ppt, pjType, cpt) != cpt)
        {
            RIPS("MF3216: DoRenderPath, GetPath failed\n");
            goto exit_DoRenderPath;
        }
    }
    // The path data is in record-time world coordinates.  They are the
    // coordinates we will use in the PolyPoly rendering functions below.
    //
    // Since we have flattened the path, the path data should only contain
    // the following types:
    //
    //   PT_MOVETO
    //   PT_LINETO
    //   (PT_LINETO | PT_CLOSEFIGURE)
    //
    // To simplify, we will close the figure explicitly by inserting points
    // and removing the (PT_LINETO | PT_CLOSEFIGURE) type from the path data.
    // At the same time, we will create the PolyPoly structure to prepare for
    // the PolyPolygon or PolyPolyline call.
    //
    // Note that there cannot be more than one half (PT_LINETO | PT_CLOSEFIGURE)
    // points since they are followed by the PT_MOVETO points (except for the
    // last point).  In addition, the first point must be a PT_MOVETO.
    //
    // We will also remove the empty figure, i.e. consecutive PT_MOVETO, from
    // the new path data in the process.

    // First, allocate memory for the new path data.

    cptNew = cpt + cpt / 2;
    if (!(pbNew = (PBYTE) LocalAlloc
        (
        LMEM_FIXED,
        cptNew * (sizeof(POINT) + sizeof(DWORD) + sizeof(BYTE))
        )
        )
        )
    {
        RIPS("MF3216: DoRenderPath, LocalAlloc failed\n");
        goto exit_DoRenderPath;
    }

    // Order of assignment is important for dword alignment.

    pptNew     = (LPPOINT) pbNew;
    pPolyCount = (PDWORD) (pptNew + cptNew);
    pjTypeNew  = (LPBYTE) (pPolyCount + cptNew);

    // Close the path explicitly.

    i = 0;
    j = 0;
    cPolyCount = 0;         // number of entries in PolyCount array
    while (i < cpt)
    {
        ASSERTGDI(pjType[i] == PT_MOVETO, "MF3216: DoRenderPath, bad pjType[]");

        // Copy everything upto the next closefigure or moveto.

        jStart = j;

        // copy the moveto
        MOVE_A_POINT(j, pjTypeNew, pptNew, i, pjType, ppt);
        i++; j++;

        if (i >= cpt)           // stop if the last point is a moveto
        {
            j--;            // don't include the last moveto
            break;
        }

        while (i < cpt)
        {
            MOVE_A_POINT(j, pjTypeNew, pptNew, i, pjType, ppt);
            i++; j++;

            // look for closefigure and moveto
            if (pjTypeNew[j - 1] != PT_LINETO)
                break;
        }

        if (pjTypeNew[j - 1] == PT_MOVETO)
        {
            i--; j--;           // restart the next figure from moveto
            if (j - jStart == 1)    // don't include consecutive moveto's
                j = jStart;     // ignore the first moveto
            else
                pPolyCount[cPolyCount++] = j - jStart;  // add one poly
        }
        else if (pjTypeNew[j - 1] == PT_LINETO)
        {               // we have reached the end of path data
            pPolyCount[cPolyCount++] = j - jStart;  // add one poly
            break;
        }
        else if (pjTypeNew[j - 1] == (PT_LINETO | PT_CLOSEFIGURE))
        {
            pjTypeNew[j - 1] = PT_LINETO;

            // Insert a PT_LINETO to close the figure.

            pjTypeNew[j] = PT_LINETO;
            pptNew[j]    = pptNew[jStart];
            j++;
            pPolyCount[cPolyCount++] = j - jStart;  // add one poly
        }
        else
        {
            ASSERTGDI(FALSE, "MF3216: DoRenderPath, unknown pjType[]");
        }
    } // while

    ASSERTGDI(j <= cptNew && cPolyCount <= cptNew,
        "MF3216: DoRenderPath, path data overrun");

    cptNew = j;

    // Check for empty path.

    if (cptNew == 0)
    {
        b = TRUE;
        goto exit_DoRenderPath;
    }

    // Now we have a path data that consists of only PT_MOVETO and PT_LINETO.
    // Furthermore, there is no "empty" figure, i.e. consecutive PT_MOVETO, in
    // the path.  We can finally render the picture with PolyPolyline or
    // PolyPolygon.

    if (mrType == EMR_STROKEPATH && !psOnly)
    {
        // Do StrokePath.

        b = DoPolyPolyline(pLocalDC, (PPOINTL) pptNew, (PDWORD) pPolyCount,
            (DWORD) cPolyCount, transform);
    }
    else // FILLPATH or PSOnly
    {
        // Setup our PS clippath
        if (pLocalDC->iXORPass == ERASEXORPASS || psOnly)
        {
            LONG lhpn32 = pLocalDC->lhpn32;
            LONG lhbr32 = pLocalDC->lhbr32;

            // Do it to the helper DC.
            DWORD oldRop = SetROP2(pLocalDC->hdcHelper, R2_NOP);
            // Emit the Win16 metafile drawing order.
            if (!bEmitWin16SetROP2(pLocalDC, LOWORD(R2_NOP)))
                goto exit_DoRenderPath;

            b = ConvertPolyPolygonToPolygons(pLocalDC, (PPOINTL) pptNew, 
                (PDWORD) pPolyCount, (DWORD) cptNew, (DWORD) cPolyCount, transform);

            if (!b)
            {
                ASSERTGDI(FALSE, "GPMF3216: DoRenderPath, PolyPolygon conversion failed");
                goto exit_DoRenderPath;
            }

            // Do it to the helper DC.
            SetROP2(pLocalDC->hdcHelper, oldRop);
            // Emit the Win16 metafile drawing order.
            if (!bEmitWin16SetROP2(pLocalDC, LOWORD(oldRop)))
                goto exit_DoRenderPath;

            wEscape = STARTPSIGNORE ;
            if(!bEmitWin16Escape(pLocalDC, POSTSCRIPT_IGNORE, sizeof(wEscape), (LPSTR)&wEscape, NULL))
                goto exit_DoRenderPath;
        }
        
        if (!psOnly)
        {
            // Do FillPath and StrokeAndFillPath.

            // If we are doing fill only, we need to select in a NULL pen.

            if (mrType == EMR_FILLPATH)
            {
                lhpn32 = pLocalDC->lhpn32;  // remember the previous pen
                if (!DoSelectObject(pLocalDC, ENHMETA_STOCK_OBJECT | NULL_PEN))
                {
                    ASSERTGDI(FALSE, "MF3216: DoRenderPath, DoSelectObject failed");
                    goto exit_DoRenderPath;
                }
            }

            // Do the PolyPolygon.

            b = DoPolyPolygon(pLocalDC, (PPOINTL) pptNew, (PDWORD) pPolyCount,
                (DWORD) cptNew, (DWORD) cPolyCount, transform);

            // Restore the previous pen.

            if (mrType == EMR_FILLPATH)
                if (!DoSelectObject(pLocalDC, lhpn32))
                    ASSERTGDI(FALSE, "MF3216: DoRenderPath, DoSelectObject failed");
        }

        if (pLocalDC->iXORPass == ERASEXORPASS || psOnly)
        {
            // End the PS ignore sequence
            wEscape = ENDPSIGNORE ;
            if(!bEmitWin16Escape(pLocalDC, POSTSCRIPT_IGNORE, sizeof(wEscape), (LPSTR)&wEscape, NULL))
                goto exit_DoRenderPath;
        }
    }


exit_DoRenderPath:

    
    // If we are doing a PSOnly path, then don't abort because we are gonna
    // use the path as a clipping region later
    if (!psOnly)
    {
        // Clear the path by calling AbortPath
        AbortPath(pLocalDC->hdcHelper);
    }
    if (pbNew)
        if (LocalFree((HANDLE) pbNew))
            RIPS("MF3216: DoRenderPath, LocalFree failed\n");
    if (pb)
        if (LocalFree((HANDLE) pb))
            RIPS("MF3216: DoRenderPath, LocalFree failed\n");

    if (pGdipFlatten)
    {
        if (LocalFree((HANDLE) pGdipFlatten))
            RIPS("MF3216: DoRenderPath, LocalFree failed\n");
    }
    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\gpmf3216\polygons.c ===
/*****************************************************************************
 *
 * polygons - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************
 *  PolyPolygon  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoPolyPolygon
(
PLOCALDC pLocalDC,
PPOINTL pptl,
PDWORD  pcptl,
DWORD   cptl,
DWORD   ccptl,
BOOL    transform
)
{
BOOL    b;
PWORD   pcptlBuff = (PWORD) NULL;
PPOINTL pptlBuff  = (PPOINTL) NULL;
PPOINTL pptlSrc, pptlDst;
DWORD   i, cptlMax, cptlNeed, cptli;

    // If we're recording the drawing orders for a path
    // then just pass the drawing order to the helper DC.
    // Do not emit any Win16 drawing orders.

    if (pLocalDC->flags & RECORDING_PATH)
    {
        if (pfnSetVirtualResolution == NULL)
        {
            bXformWorkhorse(pptl, cptl, &pLocalDC->xformRWorldToRDev);
        }
        return(PolyPolygon(pLocalDC->hdcHelper, (LPPOINT) pptl, (LPINT) pcptl, (INT) ccptl));
    }

    // NOTE: There is a semantic between the Win32 PolyPolygon and
    // the Win16 PolyPolygon.  Win32 will close each polygon, Win16
    // will not.  As a result, we have to insert points as necessary
    // to make the polygons closed.  We cannot use multiple polygons
    // to replace a single PolyPolygon because they are different if
    // the polygons overlap and the polyfill mode is winding.

    // If there are not verrics just return TRUE.

    if (ccptl == 0)
        return(TRUE) ;

    b = FALSE;          // assume failure

    // Compute the maximum size of the temporary point array required
    // to create closed PolyPolygon in win16.

    cptlMax = cptl + ccptl;

    // Allocate a buffer for the temporary point array.

    pptlBuff = (PPOINTL) LocalAlloc(LMEM_FIXED, cptlMax * sizeof(POINTL)) ;
    if (!pptlBuff)
    {
        PUTS("MF3216: DoPolyPolygon, LocalAlloc failed\n") ;
        goto exit;
    }

    // Allocate a buffer for the new polycount array and make a copy
    // of the old array.

    pcptlBuff = (PWORD) LocalAlloc(LMEM_FIXED, ccptl * sizeof(WORD)) ;
    if (!pcptlBuff)
    {
        PUTS("MF3216: DoPolyPolygon, LocalAlloc failed\n") ;
        goto exit;
    }

    for (i = 0; i < ccptl; i++)
        pcptlBuff[i] = (WORD) pcptl[i];

    // Insert the points and update the polycount as necessary.

    pptlDst = pptlBuff;
    pptlSrc = pptl;
    cptlNeed = cptl;
    for (i = 0; i < ccptl; i++)
    {
        cptli = pcptl[i];

        if (cptli < 2)
        goto exit;

        RtlCopyMemory(pptlDst, pptlSrc, cptli * sizeof(POINTL)) ;
        if (pptlDst[0].x != pptlDst[cptli - 1].x
         || pptlDst[0].y != pptlDst[cptli - 1].y)
        {
        pptlDst[cptli] = pptlDst[0];
        pptlDst++;
        cptlNeed++;
        pcptlBuff[i]++;
        }
        pptlSrc += cptli;
        pptlDst += cptli;
    }

    // The Win16 poly record is limited to 64K points.
    // Need to check this limit.

    if (cptlNeed > (DWORD) (WORD) MAXWORD)
    {
            PUTS("MF3216: DoPolyPolygon, Too many point in poly array\n") ;
            SetLastError(ERROR_NOT_ENOUGH_MEMORY) ;
            goto exit ;
    }

    // Do the transformations.
    if (transform)
    {
        if (!bXformRWorldToPPage(pLocalDC, pptlBuff, cptlNeed))
            goto exit;
    }

    // Compress the POINTLs to POINTSs

    vCompressPoints(pptlBuff, cptlNeed) ;

    // Call the Win16 routine to emit the PolyPolygon to the metafile.

	if (ccptl == 1)
	{
		b = bEmitWin16Poly(pLocalDC, (PPOINTS) pptlBuff, (WORD)cptlNeed, META_POLYGON);
	}
	else
	{
		b = bEmitWin16PolyPolygon(pLocalDC, (PPOINTS) pptlBuff,
			pcptlBuff, (WORD) cptlNeed, (WORD) ccptl);
	}

exit:
    // Free the memory.

    if (pptlBuff)
        if (LocalFree(pptlBuff))
        ASSERTGDI(FALSE, "MF3216: DoPolyPolygon, LocalFree failed");

    if (pcptlBuff)
        if (LocalFree(pcptlBuff))
        ASSERTGDI(FALSE, "MF3216: DoPolyPolygon, LocalFree failed");

    return(b) ;
}

/***************************************************************************
 *  SetPolyFillMode  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSetPolyFillMode
(
PLOCALDC  pLocalDC,
DWORD   iPolyFillMode
)
{
BOOL    b ;

    // Emit the Win16 metafile drawing order.

    b = bEmitWin16SetPolyFillMode(pLocalDC, LOWORD(iPolyFillMode)) ;

    return(b) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\gpmf3216\preamble.c ===
/*****************************************************************************
*
* Preamble - Preamble routines for MF3216
*
* Date: 7/18/91
* Author: Jeffrey Newman (c-jeffn)
*
* Copyright 1991 Microsoft Corp
*****************************************************************************/


#include "precomp.h"
#pragma hdrstop

BOOL bSetWindowOrgAndExtToFrame(PLOCALDC pLocalDC, RECTL frame);
extern fnSetVirtualResolution pfnSetVirtualResolution;

BOOL GetFrameBounds(PLOCALDC pLocalDC, PENHMETAHEADER pmf32header, RECTL *frameOut)
{

    FLOAT ecxPpmmPlay,        // cx pixels per millimeter play
          ecyPpmmPlay,        // cy pixels per millimeter play
          ecx01PpmmPlay,      // cx pixels per .01 millimeter play
          ecy01PpmmPlay,      // cy pixels per .01 millimeter play
          ecxPelsFrame,       // cx play-time frame in device units
          ecyPelsFrame,       // cy play-time frame in device units
          exPelsFrame,        // x play-time frame in device units
          eyPelsFrame ;       // y play-time frame in device units

    INT cxFrame,            // cx Picture Frame
        cyFrame,            // cy Picture Frame
        xFrame,             // x Picture Frame
        yFrame ;            // y Picture Frame

    SIZEL   szlFrame ;
    POINTL  ptlFrame ;

    ASSERT(frameOut != NULL);
    // Calculate the play-time (reference) pixels per millimeter.

    ecxPpmmPlay = (FLOAT) pLocalDC->cxPlayDevPels / (FLOAT) pLocalDC->cxPlayDevMM ;
    ecyPpmmPlay = (FLOAT) pLocalDC->cyPlayDevPels / (FLOAT) pLocalDC->cyPlayDevMM ;

    // Scale the pixels per millimeter to pixels per .01 millimeters.

    ecx01PpmmPlay = ecxPpmmPlay / 100.0f ;
    ecy01PpmmPlay = ecyPpmmPlay / 100.0f ;

    // Pickup the fram origin

    xFrame = pmf32header->rclFrame.left ;
    yFrame = pmf32header->rclFrame.top ;

    // Translate the frame origin to play-time-device units.

    exPelsFrame = ecx01PpmmPlay * (FLOAT) xFrame ;
    eyPelsFrame = ecy01PpmmPlay * (FLOAT) yFrame ;

    // Convert the Frame origin to play-time-page units.
    // (aka reference-logical units.)

    ptlFrame.x = (LONG) (exPelsFrame * pLocalDC->xformPDevToPPage.eM11 + 0.5f);
    ptlFrame.y = (LONG) (eyPelsFrame * pLocalDC->xformPDevToPPage.eM22 + 0.5f);

    if (!bCoordinateOverflowTest((PLONG) &ptlFrame, 2))
        return(FALSE);

    // Calculate the Frame width and height.

    cxFrame = pmf32header->rclFrame.right - pmf32header->rclFrame.left ;
    cyFrame = pmf32header->rclFrame.bottom - pmf32header->rclFrame.top ;

    if (cxFrame < 0)
    {
        ptlFrame.x += cxFrame;
        cxFrame = -cxFrame;
    }
    if (cyFrame < 0)
    {
        ptlFrame.y += cyFrame;
        cyFrame = -cyFrame;
    }

    // Convert the frame width and height into play-time-device units.
    // (aka reference-device units.)

    ecxPelsFrame = ecx01PpmmPlay * (FLOAT) cxFrame ;
    ecyPelsFrame = ecy01PpmmPlay * (FLOAT) cyFrame ;

    // Translate the play-time device units into play-time-page units.
    // (aka reference-device to reference-logical units.)
    // This is an identity transform for MM_ANISOTROPIC mode.  For other
    // fixed mapping modes, the SetWindowExt record has no effect.
    // The Frame is Inclusive-Inclusive so add 1 to make the WindowExt
    // Inclusive-Exclusive

    szlFrame.cx = (LONG) (ecxPelsFrame + 1.5f);
    szlFrame.cy = (LONG) (ecyPelsFrame + 1.5f);
    if (!bCoordinateOverflowTest((PLONG) &szlFrame, 2))
        return(FALSE);


    frameOut->left   = ptlFrame.x;
    frameOut->top    = ptlFrame.y;
    frameOut->right  = szlFrame.cx + ptlFrame.x;
    frameOut->bottom = szlFrame.cy + ptlFrame.y;
    return(TRUE);
}

/*----------------------------------------------------------------------------
*  DoHeader -  Emit the Win16 metafile header
*---------------------------------------------------------------------------*/
BOOL APIENTRY DoHeader(PLOCALDC pLocalDC, PENHMETAHEADER pemfheader)
{
    BOOL        b ;

    RECTL frameBounds;
    b = bInitHandleTableManager(pLocalDC, pemfheader) ;
    if (b == FALSE)
        goto error_exit ;

    b = bInitXformMatrices(pLocalDC, pemfheader, &frameBounds) ;
    if (b == FALSE)
        goto error_exit ;

    if (pfnSetVirtualResolution == NULL)
    {
        INT swap;
        // On Win9x create the helper DC here
        pLocalDC->hdcHelper = CreateCompatibleDC (NULL);
        if (pLocalDC->hdcHelper == (HDC) 0)
        {
            return FALSE;
        }

        pLocalDC->hbmpMem = CreateCompatibleBitmap(pLocalDC->hdcHelper,
            frameBounds.right - frameBounds.left,
            frameBounds.bottom - frameBounds.top);
        if (pLocalDC->hbmpMem == (HBITMAP) 0)
        {
            return FALSE;
        }

        SelectObject(pLocalDC->hdcHelper, pLocalDC->hbmpMem);
        frameBounds.right -= frameBounds.left;
        frameBounds.bottom -= frameBounds.top;
        frameBounds.left = frameBounds.top = 0;
    }

    // The metafile will always be memory based.

    pLocalDC->mf16Header.mtType    = MEMORYMETAFILE ;
    pLocalDC->mf16Header.mtVersion = 0x300 ;    // magic number for Win3.0
    pLocalDC->mf16Header.mtHeaderSize = sizeof (METAHEADER) / 2 ;

    // Init fields to 0.  They will be updated at the end of translation.

    pLocalDC->mf16Header.mtSize      = 0 ;
    pLocalDC->mf16Header.mtNoObjects = 0 ;
    pLocalDC->mf16Header.mtMaxRecord = 0 ;      // NOTE: We need a max record size.
    pLocalDC->mf16Header.mtNoParameters = 0 ;

    // Emit the MF16 metafile header to the metafile.

    b = bEmit(pLocalDC, &pLocalDC->mf16Header, sizeof(METAHEADER)) ;
    if (b == FALSE)
        goto error_exit ;

    if (pLocalDC->flags & INCLUDE_W32MF_COMMENT)
    {
        b = bHandleWin32Comment(pLocalDC) ;
        if (b == FALSE)
            goto error_exit ;
    }

    // Prepare the transform for the 16-bit metafile.  See comments in
    // xforms.c.

    // Emit the Win16 MapMode record

    b = bEmitWin16SetMapMode(pLocalDC, LOWORD(pLocalDC->iMapMode)) ;
    if (b == FALSE)
        goto error_exit ;

    // Set the Win16 metafile WindowExt to the size of the frame
    // in play-time device units.

    b = bSetWindowOrgAndExtToFrame(pLocalDC, frameBounds) ;
    if (b == FALSE)
    {
        RIPS("MF3216: DoHeader, bSetWindowOrgAndExtToFrame failure\n") ;
        goto error_exit ;
    }

error_exit:
    return(b) ;
}



/*----------------------------------------------------------------------------
* Calculate and Emit into the Win16 metafile a Window origin
* and extent drawing order
* that will set the Window Origin and Extent to the size of the picture  frame in
* play-time-page (reference-logical) units.
*---------------------------------------------------------------------------*/
BOOL bSetWindowOrgAndExtToFrame(PLOCALDC pLocalDC, RECTL frame)
{
    // Set the Window origin.

    if (!bEmitWin16SetWindowOrg(pLocalDC,
        (SHORT) frame.left,
        (SHORT) frame.top))
    {
        RIPS("MF3216: bEmitWin16SetWindowOrg failed\n") ;
        return(FALSE);
    }

    if (!bEmitWin16SetWindowExt(pLocalDC,
        (SHORT) (frame.right - frame.left),
        (SHORT) (frame.bottom - frame.top)))
    {
        RIPS("MF3216: bEmitWin16SetWindowExt failed\n") ;
        return(FALSE);
    }
    return(TRUE);
}


/*----------------------------------------------------------------------------
*  UpdateMf16Header - Update the metafile header with the:
*             metafile size,
*             number of objects,
*             the max record size.
*---------------------------------------------------------------------------*/
BOOL bUpdateMf16Header(PLOCALDC pLocalDC)
{
    BOOL    b ;
    INT     iCpTemp ;

    // Fill in the missing info in the Win16 metafile header.

    pLocalDC->mf16Header.mtSize      = pLocalDC->ulBytesEmitted / 2 ;
    pLocalDC->mf16Header.mtNoObjects = (WORD) (pLocalDC->nObjectHighWaterMark + 1) ;
    pLocalDC->mf16Header.mtMaxRecord = pLocalDC->ulMaxRecord ;

    // Reset the output buffer index to the beginning of the buffer.

    iCpTemp = pLocalDC->ulBytesEmitted ;
    pLocalDC->ulBytesEmitted = 0 ;

    // re-emit the Win16 metafile header.

    b = bEmit(pLocalDC, &pLocalDC->mf16Header, (DWORD) sizeof (pLocalDC->mf16Header)) ;

    pLocalDC->ulBytesEmitted = iCpTemp ;

    return (b) ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\gpmf3216\precomp.h ===
#include "stddef.h"
#include <windows.h>
#include "..\runtime\debug.h"
#include "mf3216Debug.h"
#include "mf3216.h"
#include "wingdip.h"
#include "entry.h"
#include "win16api.h"
#include "..\..\..\..\Core\ntgdi\client\mf16.h"
#include "..\..\..\..\Core\ntgdi\client\metadef.h"
#include <math.h>
#include "handlers.h"
#include <stdio.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\gpmf3216\rects.c ===
/*****************************************************************************
 *
 * rects - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop

extern fnSetVirtualResolution pfnSetVirtualResolution;

/***************************************************************************
 *  Rectangle  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoRectangle
(
PLOCALDC pLocalDC,
int    x1,
int    y1,
int    x2,
int    y2
)
{
BOOL    b ;

        b = bConicCommon (pLocalDC, x1, y1, x2, y2, 0, 0, 0, 0, EMR_RECTANGLE) ;

        return(b) ;
}


/***************************************************************************
 *  RoundRect  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoRoundRect
(
PLOCALDC pLocalDC,
int x1,
int y1,
int x2,
int y2,
int x3,
int y3
)
{
BOOL    b ;

        b = bConicCommon (pLocalDC, x1, y1, x2, y2, x3, y3, 0, 0, EMR_ROUNDRECT);

        return(b) ;
}


void FixOverflow (int * value)
{
    if (*value > 32767)
    {
        *value = 32767;
    }
    else if (*value < -32768)
    {
        *value = -32768;
    }
}

/***************************************************************************
 *  IntersectClipRect/ExcludeClipRect - Win32 to Win16 Metafile Converter
 *  Entry Point
 **************************************************************************/

BOOL WINAPI DoClipRect
(
PLOCALDC pLocalDC,
INT xLeft,
INT yTop,
INT xRight,
INT yBottom,
INT mrType
)
{
    BOOL    bNoClipRgn ;
    POINTL  aptl[2] ;
    INT temp;

    // Do it to the helper DC.

    // If there is no initial clip region, we have to
    // create one.  Otherwise, GDI will create some random default
    // clipping region for us!

    bNoClipRgn = bNoDCRgn(pLocalDC, DCRGN_CLIP);

    if (bNoClipRgn)
    {
        BOOL bRet;
        HRGN hrgnDefault;

        if (!(hrgnDefault = CreateRectRgn((int) (SHORT) MINSHORT,
                          (int) (SHORT) MINSHORT,
                          (int) (SHORT) MAXSHORT,
                          (int) (SHORT) MAXSHORT)))
        {
        ASSERTGDI(FALSE, "MF3216: CreateRectRgn failed");
            return(FALSE);
        }

        bRet = (ExtSelectClipRgn(pLocalDC->hdcHelper, hrgnDefault, RGN_COPY)
            != ERROR);
        ASSERTGDI(bRet, "MF3216: ExtSelectClipRgn failed");

        if (!DeleteObject(hrgnDefault))
        ASSERTGDI(FALSE, "MF3216: DeleteObject failed");

        if (!bRet)
        return(FALSE);
    }

    // Do the simple case.
    // Are they inclusive-exclusive?!
    // Make it inclusive-inclusive, and then transform
    // then make it back to inclusive-exclusive

    aptl[0].x = xLeft;
    aptl[0].y = yTop ;
    aptl[1].x = xRight;
    aptl[1].y = yBottom;

    if (aptl[0].x > aptl[1].x)
    {
        temp = aptl[0].x;
        aptl[0].x = aptl[1].x;
        aptl[1].x = temp;
    }

    if (aptl[0].y > aptl[1].y)
    {
        temp = aptl[0].y;
        aptl[0].y = aptl[1].y;
        aptl[1].y = temp;
    }

    aptl[1].x--;
    aptl[1].y--;

    {
        POINTL ppts[2] = {aptl[0].x, aptl[0].y, aptl[1].x, aptl[1].y};
        if (pfnSetVirtualResolution == NULL)
        {
            if (!bXformWorkhorse(ppts, 2, &pLocalDC->xformRWorldToRDev))
            {
                return FALSE;
            }
            // Verify rectangle ordering and check off-by-1 error!
            if (ppts[0].x > ppts[1].x)
            {
                temp = ppts[0].x;
                ppts[0].x = ppts[1].x;
                ppts[1].x = temp;
            }

            if (ppts[0].y > ppts[1].y)
            {
                temp = ppts[0].y;
                ppts[0].y = ppts[1].y;
                ppts[1].y = temp;
            }
        }

        ppts[1].x++;
        ppts[1].y++;

        switch(mrType)
        {
        case EMR_INTERSECTCLIPRECT:
            if (!IntersectClipRect(pLocalDC->hdcHelper, ppts[0].x, ppts[0].y, ppts[1].x, ppts[1].y))
                return(FALSE);
            break;

        case EMR_EXCLUDECLIPRECT:
            if (!ExcludeClipRect(pLocalDC->hdcHelper, ppts[0].x, ppts[0].y, ppts[1].x, ppts[1].y))
                return(FALSE);
            break;

        default:
            ASSERTGDI(FALSE, "MF3216: DoClipRect, bad mrType\n");
            break;
        }
    }


    // Dump the clip region data if there is a strange xform.
    // Even if there is a clipping region, when playing back the WMF, we
    // will already have a clip rect and we will simply want to intersect
    // or exclude the new region.

    if (pLocalDC->flags & STRANGE_XFORM)
        return(bDumpDCClipping(pLocalDC));

    if (!bXformRWorldToPPage(pLocalDC, (PPOINTL) aptl, 2))
        return(FALSE);


    if (!bCoordinateOverflowTest((PLONG) aptl, 4))
    {
        RIPS("MF3216: coord overflow");
        FixOverflow (&(aptl[0].x));
        FixOverflow (&(aptl[0].y));
        FixOverflow (&(aptl[1].x));
        FixOverflow (&(aptl[1].y));
    }

    // Verify rectangle ordering and check off-by-1 error!
    if (aptl[0].x > aptl[1].x)
    {
        temp = aptl[0].x;
        aptl[0].x = aptl[1].x;
        aptl[1].x = temp;
    }

    if (aptl[0].y > aptl[1].y)
    {
        temp = aptl[0].y;
        aptl[0].y = aptl[1].y;
        aptl[1].y = temp;
    }

    aptl[1].x++;
    aptl[1].y++;


    if (mrType == EMR_INTERSECTCLIPRECT)
        return(bEmitWin16IntersectClipRect(pLocalDC,
                                           (SHORT) aptl[0].x,
                                           (SHORT) aptl[0].y,
                                           (SHORT) aptl[1].x,
                                           (SHORT) aptl[1].y));
    else
        return(bEmitWin16ExcludeClipRect(pLocalDC,
                                           (SHORT) aptl[0].x,
                                           (SHORT) aptl[0].y,
                                           (SHORT) aptl[1].x,
                                           (SHORT) aptl[1].y));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\gpmf3216\regions.c ===
/*****************************************************************************
 *
 * regions - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *
 * NOTES:
 *
        When there are no embedded metafiles we need to do the following:

            1]  Read the metafile data from the Win32 metafile.  This
                is done by the handler routines that in turn call these
                routines.

            2]  Translate the Win32 metafile data into Win16 metafile data.

                The region data for FillRgn, FrameRgn, InvertRgn, and PaintRgn
                are in record-time world coordinates. The region data for
                these region API's will have to be translated from record-time
                -world coordinates to play-time-page coordinates
                (XFORM_WORLD_TO_PAGE). The helperDC will be used for
                this transformation.

                The region data for SelectClipRgn and OffsetClipRgn are in
                record-time device coordinates.  The region data for these
                APIs will be translated from record-time-device coordinates
                to play-time-device coordinates.

            3]  Emit a Win16 create region metafile record.

            4]  Select the newly created region into the metafile.

            5]  Do the region function (FillRegion, FrameRegion, ...).
                This means emit a FillRegion or FrameRegion drawing order
                into the Win16 metafile.

            6]  Emit a Delete Region drawing order.

            7]  Clean up all the memory resources used.

        When there are embedded metafiles things get a little more  complicated.
        Most of the complications are hidden in PlayMetafile record processing.
        Items 1 thru 3 will be handled by the PlayMetafile Doer.

            1]  We need to keep the region from the previous DC level.
                This can be done by the helper DC (SaveDC).  We will have to
                do a GetClipRgn and a SelectMetaRgn.  A MetaRgn is the clip
                region from the previous level.

            2]  We will have to intersect any clip regions from the current
                level with any clip regions from the previous level. This can
                be done by the helper DC (using the hrgnMeta & ExtCombineRegion)

            3]  When we pop out from this level we will have to restore the
                previous saved region. This can be done by the helper DC.
                (RestoreDC).

        Since we do not know whether or not there will be an embedded metafile
        in the metafile we are currently processing we will always shadow
        the Clip Region call into the helper DC.


 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop




BOOL bEmitWin3Region(PLOCALDC pLocalDC, HRGN hrgn);

extern fnSetVirtualResolution pfnSetVirtualResolution;

#define MIN_RGN_COORD16 -30000
#define MAX_RGN_COORD16  30000

/***************************************************************************
* DoDrawRgn
*
*  CR1: This routine was added as part of the handle manager change.
*       I noticed that almost all of the Region Rendering code was
*       the same.
**************************************************************************/
BOOL APIENTRY DoDrawRgn
(
 PLOCALDC  pLocalDC,
 INT       ihBrush,
 INT       nWidth,
 INT       nHeight,
 INT       cRgnData,
 LPRGNDATA pRgnData,
 INT       mrType
 )
{
    BOOL    b ;
    HRGN    hrgn = (HRGN) 0;
    INT     ihW16Rgn = -1,
        ihW16Brush = -1;

    b = FALSE ;

    // Translate the Win32 region data from Metafile-World to
    // Referencd-Page space.
    // This is done by ExtCreateRegion's xform.  The returned region
    // is transformed.

    hrgn = ExtCreateRegion(&pLocalDC->xformRWorldToPPage, cRgnData,
        (LPRGNDATA) pRgnData);
    if (!hrgn)
    {
        RIPS("MF3216: DoDrawRgn, ExtCreateRegion failed\n") ;
        goto error_exit ;
    }

    // Allocate a handle for the region.
    // This is different from a normal handle allocation, because
    // there is no region handle in Win32.  We are using one of our
    // extra slots here.

    ihW16Rgn = iGetW16ObjectHandleSlot(pLocalDC, REALIZED_REGION) ;
    if (ihW16Rgn == -1)
        goto error_exit ;

    // Emit a Win16 create region record for the region.

    if (!bEmitWin3Region(pLocalDC, hrgn))
    {
        RIPS("MF3216: DoDrawRgn, bEmitWin3Region failed\n") ;
        goto error_exit ;
    }

    // Translate the W32 Brush object index to a W16 Brush object index.

    if (ihBrush)
    {
        // Make sure that the W16 object exists.  Stock brushes may not
        // have been created and iValidateHandle will take care of creating
        // them.

        ihW16Brush = iValidateHandle(pLocalDC, ihBrush) ;
        if (ihW16Brush == -1)
            goto error_exit ;
    }

    // Emit the Region Record depending upon the function type.

    switch (mrType)
    {
    case EMR_FILLRGN:
        if(ihW16Brush == -1)
            goto error_exit;
        b = bEmitWin16FillRgn(pLocalDC,
            LOWORD(ihW16Rgn),
            LOWORD(ihW16Brush)) ;
        break ;

    case EMR_FRAMERGN:
        nWidth  = iMagnitudeXform (pLocalDC, nWidth, CX_MAG) ;
        nHeight = iMagnitudeXform (pLocalDC, nHeight, CY_MAG) ;
        if(ihW16Brush == -1)
            goto error_exit;

        b = bEmitWin16FrameRgn(pLocalDC,
            LOWORD(ihW16Rgn),
            LOWORD(ihW16Brush),
            LOWORD(nWidth),
            LOWORD(nHeight)) ;
        break ;

    case EMR_INVERTRGN:
        b = bEmitWin16InvertRgn(pLocalDC,
            LOWORD(ihW16Rgn)) ;
        break ;

    case EMR_PAINTRGN:
        b = bEmitWin16PaintRgn(pLocalDC,
            LOWORD(ihW16Rgn)) ;
        break ;

    default:
        RIPS("MF3216: DoDrawRgn, unknown type\n") ;
        break ;
    }

error_exit:
    // Delete the W16 Region Object.

    if (ihW16Rgn != -1)
        bDeleteW16Object(pLocalDC, ihW16Rgn) ;

    if (hrgn)
        DeleteObject(hrgn) ;

    return(b) ;
}


/***************************************************************************
*  ExtSelectClipRgn  - Win32 to Win16 Metafile Converter Entry Point
*
* History:
*  Tue Apr 07 17:05:37 1992    -by-    Hock San Lee    [hockl]
* Wrote it.
**************************************************************************/

BOOL WINAPI DoExtSelectClipRgn
(
 PLOCALDC  pLocalDC,
 INT       cRgnData,
 LPRGNDATA pRgnData,
 INT       iMode
 )
{
    HANDLE hrgn;
    BOOL   bRet;
    BOOL   bNoClipRgn ;
    WORD   wEscape ;

    if(pLocalDC->iXORPass == DRAWXORPASS)
    {
        pLocalDC->iXORPass = OBJECTRECREATION ;
        bRet = DoRemoveObjects( pLocalDC ) ;
        if( !bRet )
            return bRet ;

        //Restore the DC to the same level that it was in when we started the
        //XOR pass

        bRet = DoRestoreDC(pLocalDC, pLocalDC->iXORPassDCLevel - pLocalDC->iLevel);

        bRet = DoMoveTo(pLocalDC, pLocalDC->pOldPosition.x, pLocalDC->pOldPosition.y) ;

        wEscape = ENDPSIGNORE;
        if(!bEmitWin16Escape(pLocalDC, POSTSCRIPT_IGNORE, sizeof(wEscape), (LPSTR)&wEscape, NULL))
            return FALSE ;

        wEscape = CLIP_SAVE ;
        if(!bEmitWin16Escape(pLocalDC, CLIP_TO_PATH, sizeof(wEscape), (LPSTR)&wEscape, NULL))
            return FALSE ;

        return bRet;
    }
    else if(pLocalDC->iXORPass == ERASEXORPASS)
    {
        pLocalDC->iXORPass = NOTXORPASS ;
        pLocalDC->pbChange = NULL ;
        bRet = DoSetRop2(pLocalDC, pLocalDC->iROP);

        //bRet = DoRestoreDC(pLocalDC, -1);

        wEscape = CLIP_RESTORE ;
        if(!bEmitWin16Escape(pLocalDC, CLIP_TO_PATH, sizeof(wEscape), (LPSTR)&wEscape, NULL))
            return FALSE ;

        if (!bEmitWin16EmitSrcCopyComment(pLocalDC, msocommentEndSrcCopy))
        {
            return FALSE;
        }
        return bRet ;
    }


    bNoClipRgn = bNoDCRgn(pLocalDC, DCRGN_CLIP);

    // Do it to the helper DC.

    // Restore the PS clippath
    wEscape = CLIP_RESTORE ;
    while(pLocalDC->iSavePSClipPath > 0)
    {
        bEmitWin16Escape(pLocalDC, CLIP_TO_PATH, sizeof(wEscape), (LPSTR)&wEscape, NULL);
        pLocalDC->iSavePSClipPath--;
    }

    if (cRgnData == 0)      // default clipping
    {
        ASSERTGDI(iMode == RGN_COPY, "MF3216: DoExtSelectClipRgn: bad iMode\n");

        // No work if no previous clip region.

        if (bNoClipRgn)
            return(TRUE);

        bRet = (ExtSelectClipRgn(pLocalDC->hdcHelper, (HRGN)0, iMode) != ERROR);

        return(bW16Emit1(pLocalDC, META_SELECTCLIPREGION, 0));
    }
    else
    {
        // If there is no initial clip region and we are going to operate
        // on the initial clip region, we have to
        // create one.  Otherwise, GDI will create some random default
        // clipping region for us!

        if (bNoClipRgn
            && (iMode == RGN_DIFF || iMode == RGN_XOR || iMode == RGN_OR))
        {
            HRGN hrgnDefault;

            if (!(hrgnDefault = CreateRectRgn((int) (SHORT) MINSHORT,
                (int) (SHORT) MINSHORT,
                (int) (SHORT) MAXSHORT,
                (int) (SHORT) MAXSHORT)))
            {
                ASSERTGDI(FALSE, "MF3216: CreateRectRgn failed");
                return(FALSE);
            }

            bRet = (ExtSelectClipRgn(pLocalDC->hdcHelper, hrgnDefault, RGN_COPY)
                != ERROR);
            ASSERTGDI(bRet, "MF3216: ExtSelectClipRgn failed");

            if (!DeleteObject(hrgnDefault))
                ASSERTGDI(FALSE, "MF3216: DeleteObject failed");

            if (!bRet)
                return(FALSE);
        }

        // Create a region from the region data passed in.

        if (pfnSetVirtualResolution != NULL)
        {
            if (!(hrgn = ExtCreateRegion((LPXFORM) NULL, cRgnData, pRgnData)))
            {
                RIPS("MF3216: DoExtSelectClipRgn, Create region failed\n");
                return(FALSE);
            }
        }
        else
        {
            if (pRgnData->rdh.rcBound.left > pRgnData->rdh.rcBound.right ||
                pRgnData->rdh.rcBound.top > pRgnData->rdh.rcBound.bottom )
            {
                RIPS("MF3216: DoExtSelectClipRgn, Create region failed\n");
                return(FALSE);
            }
            // We need to create the region in Device Units for the helper DC
            // therefore add the xformDC to the transform
            if (!(hrgn = ExtCreateRegion(&pLocalDC->xformDC, cRgnData, pRgnData)))
            {
                RIPS("MF3216: DoExtSelectClipRgn, Create region failed\n");
                return(FALSE);
            }
        }

        bRet = (ExtSelectClipRgn(pLocalDC->hdcHelper, hrgn, iMode) != ERROR);

        ASSERTGDI(bRet, "MF3216: ExtSelectClipRgn failed\n");

        if (!DeleteObject(hrgn))
            RIPS("MF3216: DeleteObject failed\n");
    }

    // dump the clip region data.

    if (bRet)
        return(bDumpDCClipping(pLocalDC));
    else
        return(FALSE);
}


/***************************************************************************
*  SetMetaRgn  - Win32 to Win16 Metafile Converter Entry Point
*
* History:
*  Tue Apr 07 17:05:37 1992    -by-    Hock San Lee    [hockl]
* Wrote it.
**************************************************************************/

BOOL WINAPI DoSetMetaRgn(PLOCALDC pLocalDC)
{
    // No work if the clip region does not exist.

    if (bNoDCRgn(pLocalDC, DCRGN_CLIP))
        return(TRUE);

    // Do it to the helper DC.

    if (!SetMetaRgn(pLocalDC->hdcHelper))
        return(FALSE);

    // Dump the clip region data.

    return(bDumpDCClipping(pLocalDC));
}


/***************************************************************************
*  OffsetClipRgn  - Win32 to Win16 Metafile Converter Entry Point
*
* History:
*  Tue Apr 07 17:05:37 1992    -by-    Hock San Lee    [hockl]
* Wrote it.
**************************************************************************/

BOOL WINAPI DoOffsetClipRgn(PLOCALDC pLocalDC, INT x, INT y)
{
    POINTL aptl[2];
    BOOL   b;

    // Do it to the helper DC.
    POINTL p[2] = {0, 0, x, y};
    if (pfnSetVirtualResolution == NULL)
    {
        if (!bXformWorkhorse(p, 2, &pLocalDC->xformRWorldToRDev))
        {
            return FALSE;
        }
        // We just want the scale factor of the WorldToDevice Transform
        p[1].x -= p[0].x;
        p[1].y -= p[0].y;
    }

    if (!OffsetClipRgn(pLocalDC->hdcHelper, p[1].x, p[1].y))
        return(FALSE);

    // Dump region if the meta region exists.
    // We don't offset the meta region!

    if (!bNoDCRgn(pLocalDC, DCRGN_META))
        return(bDumpDCClipping(pLocalDC));

    // Translate the record-time world offsets to play-time page offsets.

    aptl[0].x = 0;
    aptl[0].y = 0;
    aptl[1].x = x;
    aptl[1].y = y;

    if (!bXformRWorldToPPage(pLocalDC, aptl, 2))
        return(FALSE);

    aptl[1].x -= aptl[0].x;
    aptl[1].y -= aptl[0].y;

    b = bEmitWin16OffsetClipRgn(pLocalDC, (SHORT) aptl[1].x, (SHORT) aptl[1].y);
    ASSERTGDI(b, "MF3216: DoOffsetClipRgn, bEmitWin16OffsetClipRgn failed\n");

    return(b) ;
}


/***************************************************************************
*  bNoDCRgn  - Return TRUE if the dc clip region does not exist.
*                Otherwise, return FALSE.
*  This is TEMPORARY only.  Get gdi to provide this functionality.
**************************************************************************/

BOOL bNoDCRgn(PLOCALDC pLocalDC, INT iType)
{
    BOOL  bRet = FALSE;     // assume the dc region exists
    HRGN  hrgnTmp;

    ASSERTGDI(iType == DCRGN_CLIP || iType == DCRGN_META,
        "MF3216: bNoDCRgn, bad iType\n");

    if (!(hrgnTmp = CreateRectRgn(0, 0, 0, 0)))
    {
        ASSERTGDI(FALSE, "MF3216: bNoDCRgn, CreateRectRgn failed\n");
        return(bRet);
    }

    switch (GetRandomRgn(pLocalDC->hdcHelper,
        hrgnTmp,
        iType == DCRGN_CLIP ? 1 : 2
        )
        )
    {
    case -1:    // error
        ASSERTGDI(FALSE, "GetRandomRgn failed");
        break;
    case 0: // no dc region
        bRet = TRUE;
        break;
    case 1: // has dc region
        break;
    }

    if (!DeleteObject(hrgnTmp))
        ASSERTGDI(FALSE, "DeleteObject failed");

    return(bRet);
}

/***************************************************************************
*  bDumpDCClipping - Dump the DC clipping regions.
*
* History:
*  Tue Apr 07 17:05:37 1992    -by-    Hock San Lee    [hockl]
* Wrote it.
**************************************************************************/

BOOL bDumpDCClipping(PLOCALDC pLocalDC)
{
    BOOL      bRet            = FALSE;      // assume failure
    HRGN      hrgnRDev        = (HRGN) 0;
    HRGN      hrgnPPage       = (HRGN) 0;
    HRGN      hrgnPPageBounds = (HRGN) 0;
    LPRGNDATA lprgnRDev       = (LPRGNDATA) NULL;
    LPRGNDATA lprgnPPage      = (LPRGNDATA) NULL;
    DWORD     cRgnData;
    INT       i;
    INT       nrcl;
    PRECTL    prcl;
    RECTL     rclPPage;
    XFORM       xform;

    // Since clipping region is not scalable in Win30, we do not emit
    // SelectClipRgn record.  Instead, we set the clipping to the default, i.e.
    // no clipping, and then emit the scalable IntersectClipRect/ExcludeClipRect
    // records to exclude clipping region.  This will allow the win30 metafiles
    // to be scalable.

    // First, emit a default clipping region.

    // On Win3.x, the META_SELECTCLIPREGION record only works if it has
    // a NULL handle.  The Win3x metafile driver does not translate the
    // region handle at playback time!

    if (!bW16Emit1(pLocalDC, META_SELECTCLIPREGION, 0))
        goto ddcc_exit;

    // Now find the clip and meta regions to be excluded from the default
    // clipping region.

    if (!(hrgnRDev = CreateRectRgn(0, 0, 0, 0)))
        goto ddcc_exit;

    switch (GetRandomRgn(pLocalDC->hdcHelper, hrgnRDev, 3)) // meta and clip
    {
    case -1:    // error
        ASSERTGDI(FALSE, "GetRandomRgn failed");
        goto ddcc_exit;
    case 0: // no clip region, we are done
        bRet = TRUE;
        goto ddcc_exit;
    case 1: // has clip region
        break;
    }

    // Get the clip region data.
    // First query the size of the buffer required to hold the clip region data.

    if (!(cRgnData = GetRegionData(hrgnRDev, 0, (LPRGNDATA) NULL)))
        goto ddcc_exit;

    // Allocate the memory for the clip region data buffer.

    if (!(lprgnRDev = (LPRGNDATA) LocalAlloc(LMEM_FIXED, cRgnData)))
        goto ddcc_exit;

    // Get clip region data.

    if (GetRegionData(hrgnRDev, cRgnData, lprgnRDev) != cRgnData)
        goto ddcc_exit;

    // Create the clip region in the playtime page space.
    if (!(hrgnPPage = ExtCreateRegion(&pLocalDC->xformRDevToPPage, cRgnData, lprgnRDev)))
        goto ddcc_exit;

    // Get the bounding box for the playtime clip region in page space.

    if (GetRgnBox(hrgnPPage, (LPRECT) &rclPPage) == ERROR)
        goto ddcc_exit;

    // Bound it to 16-bit.

    rclPPage.left   = max(MIN_RGN_COORD16,rclPPage.left);
    rclPPage.top    = max(MIN_RGN_COORD16,rclPPage.top);
    rclPPage.right  = min(MAX_RGN_COORD16,rclPPage.right);
    rclPPage.bottom = min(MAX_RGN_COORD16,rclPPage.bottom);

    // Set the bounding box as the bounds for the clipping.

    if (!bEmitWin16IntersectClipRect(pLocalDC,
        (SHORT) rclPPage.left,
        (SHORT) rclPPage.top,
        (SHORT) rclPPage.right,
        (SHORT) rclPPage.bottom))
        goto ddcc_exit;

    // Create the bounding region.

    if (!(hrgnPPageBounds = CreateRectRgn(rclPPage.left,
        rclPPage.top,
        rclPPage.right,
        rclPPage.bottom)))
        goto ddcc_exit;

    // Exclude the regions in playtime page space.

    if (CombineRgn(hrgnPPage, hrgnPPageBounds, hrgnPPage, RGN_DIFF) == ERROR)
        goto ddcc_exit;

    // Finally, exclude the rectangles from the bounding box.

    if (!(cRgnData = GetRegionData(hrgnPPage, 0, (LPRGNDATA) NULL)))
        goto ddcc_exit;

    if (!(lprgnPPage = (LPRGNDATA) LocalAlloc(LMEM_FIXED, cRgnData)))
        goto ddcc_exit;

    if (GetRegionData(hrgnPPage, cRgnData, lprgnPPage) != cRgnData)
        goto ddcc_exit;

    // Get the number of rectangles in the transformed region.

    nrcl = lprgnPPage->rdh.nCount;
    prcl = (PRECTL) lprgnPPage->Buffer;

    // Emit a series of Exclude Clip Rectangle Metafile records.

    for (i = 0 ; i < nrcl; i++)
    {
        ASSERTGDI(prcl[i].left   >= MIN_RGN_COORD16
            && prcl[i].top    >= MIN_RGN_COORD16
            && prcl[i].right  <= MAX_RGN_COORD16
            && prcl[i].bottom <= MAX_RGN_COORD16,
            "MF3216: bad coord");

        if (!bEmitWin16ExcludeClipRect(pLocalDC,
            (SHORT) prcl[i].left,
            (SHORT) prcl[i].top,
            (SHORT) prcl[i].right,
            (SHORT) prcl[i].bottom))
            goto ddcc_exit;
    }

    bRet = TRUE;            // we are golden!

    // Cleanup all the resources used.

ddcc_exit:

    if (hrgnRDev)
        DeleteObject(hrgnRDev);

    if (hrgnPPage)
        DeleteObject(hrgnPPage);

    if (hrgnPPageBounds)
        DeleteObject(hrgnPPageBounds);

    if (lprgnRDev)
        LocalFree(lprgnRDev);

    if (lprgnPPage)
        LocalFree(lprgnPPage);

    return(bRet) ;
}

/***************************************************************************
* Emit a 16-bit CreateRegion record for the given region.
*
* This code is copied from the 16-bit metafile driver in gdi.
*
**************************************************************************/

WIN3REGION w3rgnEmpty =
{
    0,              // nextInChain
        6,              // ObjType
        0x2F6,          // ObjCount
        sizeof(WIN3REGION) - sizeof(SCAN) + 2,
        // cbRegion
        0,              // cScans
        0,              // maxScan
    {0,0,0,0},      // rcBounding
    {0,0,0,{0,0},0} // aScans[]
};

BOOL bEmitWin3Region(PLOCALDC pLocalDC, HRGN hrgn)
{
/*
* in win2, METACREATEREGION records contained an entire region object,
* including the full header.  this header changed in win3.
*
* to remain compatible, the region records will be saved with the
* win2 header.  here we save our region with a win2 header.
    */
    PWIN3REGION lpw3rgn;
    DWORD       cbNTRgnData;
    DWORD       curRectl;
    WORD        cScans;
    WORD        maxScanEntry;
    WORD        curScanEntry;
    DWORD       cbw3data;
    PRGNDATA    lprgn;
    LPRECT      lprc;
    PSCAN       lpScan;
    BOOL    bRet;

    ASSERTGDI(hrgn, "MF3216: bEmitWin3Region, hrgn is NULL");

    // Get the NT Region Data
    cbNTRgnData = GetRegionData(hrgn, 0, NULL);
    if (cbNTRgnData == 0)
        return(FALSE);

    lprgn = (PRGNDATA) LocalAlloc(LMEM_FIXED, cbNTRgnData);
    if (!lprgn)
        return(FALSE);

    cbNTRgnData = GetRegionData(hrgn, cbNTRgnData, lprgn);
    if (cbNTRgnData == 0)
    {
        LocalFree((HANDLE) lprgn);
        return(FALSE);
    }

    // Handle the empty region.

    if (!lprgn->rdh.nCount)
    {
        bRet = bEmitWin16CreateRegion(pLocalDC, sizeof(WIN3REGION) - sizeof(SCAN), (PVOID) &w3rgnEmpty);

        LocalFree((HANDLE)lprgn);
        return(bRet);
    }

    lprc = (LPRECT)lprgn->Buffer;

    // Create the Windows 3.x equivalent

    // worst case is one scan for each rect
    cbw3data = 2*sizeof(WIN3REGION) + (WORD)lprgn->rdh.nCount*sizeof(SCAN);

    lpw3rgn = (PWIN3REGION)LocalAlloc(LMEM_FIXED, cbw3data);
    if (!lpw3rgn)
    {
        LocalFree((HANDLE) lprgn);
        return(FALSE);
    }

    // Grab the bounding rect.
    lpw3rgn->rcBounding.left   = (SHORT)lprgn->rdh.rcBound.left;
    lpw3rgn->rcBounding.right  = (SHORT)lprgn->rdh.rcBound.right;
    lpw3rgn->rcBounding.top    = (SHORT)lprgn->rdh.rcBound.top;
    lpw3rgn->rcBounding.bottom = (SHORT)lprgn->rdh.rcBound.bottom;

    cbw3data = sizeof(WIN3REGION) - sizeof(SCAN) + 2;

    // visit all the rects
    curRectl     = 0;
    cScans       = 0;
    maxScanEntry = 0;
    lpScan       = lpw3rgn->aScans;

    while(curRectl < lprgn->rdh.nCount)
    {
        LPWORD  lpXEntry;
        DWORD   cbScan;

        curScanEntry = 0;       // Current X pair in this scan

        lpScan->scnPntTop    = (WORD)lprc[curRectl].top;
        lpScan->scnPntBottom = (WORD)lprc[curRectl].bottom;

        lpXEntry = (LPWORD) lpScan->scnPntsX;

        // handle rects on this scan
        do
        {
            lpXEntry[curScanEntry + 0] = (WORD)lprc[curRectl].left;
            lpXEntry[curScanEntry + 1] = (WORD)lprc[curRectl].right;
            curScanEntry += 2;
            curRectl++;
        } while ((curRectl < lprgn->rdh.nCount)
            && (lprc[curRectl-1].top    == lprc[curRectl].top)
            && (lprc[curRectl-1].bottom == lprc[curRectl].bottom)
            );

        lpScan->scnPntCnt      = curScanEntry;
        lpXEntry[curScanEntry] = curScanEntry;  // Count also follows Xs
        cScans++;

        if (curScanEntry > maxScanEntry)
            maxScanEntry = curScanEntry;

        // account for each new scan + each X1 X2 Entry but the first
        cbScan = sizeof(SCAN)-(sizeof(WORD)*2) + (curScanEntry*sizeof(WORD));
        cbw3data += cbScan;
        lpScan = (PSCAN)(((LPBYTE)lpScan) + cbScan);
    }

    // Initialize the header
    lpw3rgn->nextInChain = 0;
    lpw3rgn->ObjType = 6;           // old Windows OBJ_RGN identifier
    lpw3rgn->ObjCount= 0x2F6;       // any non-zero number
    lpw3rgn->cbRegion = (WORD)cbw3data;   // don't count type and next
    lpw3rgn->cScans = cScans;
    lpw3rgn->maxScan = maxScanEntry;

    bRet = bEmitWin16CreateRegion(pLocalDC, cbw3data-2, (PVOID) lpw3rgn);

    if (LocalFree((HANDLE)lprgn))
        ASSERTGDI(FALSE, "bEmitWin3Region: LocalFree(lprgn) Failed\n");
    if (LocalFree((HANDLE)lpw3rgn))
        ASSERTGDI(FALSE, "bEmitWin3Region: LocalFree(lpw3rgn) Failed\n");

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\gpmf3216\text.c ===
/*****************************************************************************
 *
 * text - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop

// GillesK, We don't have access to RtlUnicodeToMultiByteN so this call
// has been converted to a MultiByteToWideChar... We don't need to import
// anymore
/*
__declspec(dllimport)
ULONG
__stdcall
RtlUnicodeToMultiByteN(
    PCHAR MultiByteString,
    ULONG MaxBytesInMultiByteString,
    PULONG BytesInMultiByteString,
    PWSTR UnicodeString,
    ULONG BytesInUnicodeString
    );


ULONG
__stdcall
RtlUnicodeToMultiByteSize(
    PULONG BytesInMultiByteString,
    PWSTR UnicodeString,
    ULONG BytesInUnicodeString
    );

*/

extern fnSetVirtualResolution pfnSetVirtualResolution;

DWORD GetCodePage(HDC hdc)
{
  DWORD FAR *lpSrc = (DWORD FAR *)UIntToPtr(GetTextCharsetInfo(hdc, 0, 0));
  CHARSETINFO csi;

  TranslateCharsetInfo(lpSrc, &csi, TCI_SRCCHARSET);

  return csi.ciACP;
}


/***************************************************************************
 *  ExtTextOut  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoExtTextOut
(
PLOCALDC pLocalDC,
INT     x,                  // Initial x position
INT     y,                  // Initial y position
DWORD   flOpts,             // Options
PRECTL  prcl,               // Clipping rectangle
PWCH    pwch,               // Character array
DWORD   cch,                // Character count
PLONG   pDx,                // Inter-Character spacing
DWORD   iGraphicsMode,      // Graphics mode
INT     mrType              // Either EMR_EXTTEXTOUTW (Unicode)
                //     or EMR_EXTTEXTOUTA (Ansi)
)
{
    INT     i;
    BOOL    b;
    RECTS   rcs;
    POINTL  ptlRef;
    UINT    fTextAlign;
    WORD    fsOpts;
    PCHAR   pch, pchAlloc;
    PPOINTL pptl;
    POINTL  ptlAdjust;
    BOOL    bAdjustAlignment;
    ULONG   nANSIChars;
    PCHAR   pDBCSBuffer = NULL;
    POINTL  p = {x, y};

    pptl     = (PPOINTL) NULL;
    fsOpts   = (WORD) flOpts;
    pchAlloc = (PCHAR) NULL;
    bAdjustAlignment = FALSE;
    b        = FALSE;       // assume failure

    ASSERTGDI(mrType == EMR_EXTTEXTOUTA || mrType == EMR_EXTTEXTOUTW,
    "MF3216: DoExtTextOut: bad record type");

// We do not handle the advanced graphics mode here except when
// we are in a path!

// If we're recording the drawing orders for a path
// then just pass the drawing order to the helper DC.
// Do not emit any Win16 drawing orders.

    if (pLocalDC->flags & RECORDING_PATH)
    {
    // The helper DC is in the advanced graphics mode.  We need to set
    // it to the compatible graphics mode temporarily if necessary.

    if (iGraphicsMode != GM_ADVANCED)
        SetGraphicsMode(pLocalDC->hdcHelper, iGraphicsMode);

    if (pfnSetVirtualResolution == NULL)
    {
        if (!bXformRWorldToRDev(pLocalDC, &p, 1))
        {
            return FALSE;
        }
    }

    if (mrType == EMR_EXTTEXTOUTA)
        b = ExtTextOutA
        (
            pLocalDC->hdcHelper,
            (int)    p.x,
            (int)    p.y,
            (UINT)   flOpts,
            (LPRECT) prcl,
            (LPSTR)  pwch,
            (int)    cch,
            (LPINT)  pDx
        );
    else
        b = ExtTextOutW
        (
            pLocalDC->hdcHelper,
            (int)    p.x,
            (int)    p.y,
            (UINT)   flOpts,
            (LPRECT) prcl,
            (LPWSTR) pwch,
            (int)    cch,
            (LPINT)  pDx
        );

    // Restore the graphics mode.

    if (iGraphicsMode != GM_ADVANCED)
        SetGraphicsMode(pLocalDC->hdcHelper, GM_ADVANCED);

    return(b);
    }

// If the string uses the current position, make sure that the metafile
// has the same current position as that of the helper DC.

    fTextAlign = GetTextAlign(pLocalDC->hdcHelper);

    if (fTextAlign & TA_UPDATECP)
    {
    POINT   ptCP;

    // Update the current position in the converted metafile if
    // it is different from that of the helper DC.  See notes
    // in DoMoveTo().

    if (!GetCurrentPositionEx(pLocalDC->hdcHelper, &ptCP))
        goto exit_DoExtTextOut;

    // We don't need to update to change the clip region on the helper
    // DC in Win9x anymore because we are using a bitmap and not the
    // screen anymore. What we do need to do, is get the current position
    // of the cursor and convert it back to Logical Units... Make the
    // call on the helper DC and the convert the position back to
    // device units and save it.

    if (pfnSetVirtualResolution == NULL)
    {
       if (!bXformRDevToRWorld(pLocalDC, (PPOINTL) &ptCP, 1))
           return(b);
    }

    // Make sure that the converted metafile has the same CP as the
    // helper DC.

    if (!bValidateMetaFileCP(pLocalDC, ptCP.x, ptCP.y))
        goto exit_DoExtTextOut;

    // Initialize the XY start position.

    x = ptCP.x;
    y = ptCP.y;
    }

// Transform the XY start position.

    ptlRef.x = x;
    ptlRef.y = y;

    if (!bXformRWorldToPPage(pLocalDC, (PPOINTL) &ptlRef, 1))
    goto exit_DoExtTextOut;

// If we have an opaque/clipping rectangle, transform it.
// If we have a strange transform, we will do the rectangle at this time.

    if (fsOpts & (ETO_OPAQUE | ETO_CLIPPED))
    {
    RECTL rcl;

    rcl = *prcl ;

    if (!(pLocalDC->flags & STRANGE_XFORM))
    {
        if (!bXformRWorldToPPage(pLocalDC, (PPOINTL) &rcl, 2))
        goto exit_DoExtTextOut;

        // The overflow test has been done in the xform.

        rcs.left   = (SHORT) rcl.left;
        rcs.top    = (SHORT) rcl.top;
        rcs.right  = (SHORT) rcl.right;
        rcs.bottom = (SHORT) rcl.bottom;
    }
    else
    {
        if (fsOpts & ETO_OPAQUE)
        {
        LONG     lhpn32;
        LONG     lhbr32;
        INT  ihW32Br;
        LOGBRUSH lbBkColor;

        // Remember the previous pen and brush

        lhpn32 = pLocalDC->lhpn32;
        lhbr32 = pLocalDC->lhbr32;

        if (DoSelectObject(pLocalDC, ENHMETA_STOCK_OBJECT | NULL_PEN))
        {
            lbBkColor.lbStyle = BS_SOLID;
            lbBkColor.lbColor = pLocalDC->crBkColor;
            lbBkColor.lbHatch = 0;

            // Get an unused W32 object index.

            ihW32Br = pLocalDC->cW32ToW16ObjectMap - (STOCK_LAST + 1) - 1;

                    if (DoCreateBrushIndirect(pLocalDC, ihW32Br, &lbBkColor))
            {
            if (DoSelectObject(pLocalDC, ihW32Br))
            {
                if (DoRectangle(pLocalDC, rcl.left, rcl.top, rcl.right, rcl.bottom))
                fsOpts &= ~ETO_OPAQUE;

                // Restore the previous brush.

                if (!DoSelectObject(pLocalDC, lhbr32))
                ASSERTGDI(FALSE,
                 "MF3216: DoExtTextOut, DoSelectObject failed");
            }
            if (!DoDeleteObject(pLocalDC, ihW32Br))
                ASSERTGDI(FALSE,
                "MF3216: DoExtTextOut, DoDeleteObject failed");
            }

            // Restore the previous pen.

            if (!DoSelectObject(pLocalDC, lhpn32))
            ASSERTGDI(FALSE,
                "MF3216: DoExtTextOut, DoSelectObject failed");
        }

        // Check if the rectangle is drawn.

        if (fsOpts & ETO_OPAQUE)
            goto exit_DoExtTextOut;
            }

            if (fsOpts & ETO_CLIPPED)
            {
        // Save the DC so that we can restore it when we are done

        if (!DoSaveDC(pLocalDC))
            goto exit_DoExtTextOut;

                fsOpts &= ~ETO_CLIPPED;     // need to restore dc

                if (!DoClipRect(pLocalDC, rcl.left, rcl.top,
                           rcl.right, rcl.bottom, EMR_INTERSECTCLIPRECT))
            goto exit_DoExtTextOut;
            }
    }
    }

// Convert the Unicode to Ansi.

    if (mrType == EMR_EXTTEXTOUTW)
    {
        // Get the codepage from the helperDC since the proper font and code page should have been selected.
        DWORD dwCP = GetCodePage(pLocalDC->hdcHelper);
        nANSIChars = WideCharToMultiByte(dwCP, 0, pwch, cch, NULL, 0, NULL, NULL);

        if (nANSIChars == cch)
        {
            pch = pchAlloc = (PCHAR) LocalAlloc(LMEM_FIXED, cch * sizeof(BYTE)) ;

            if (pch == (PCHAR) NULL)
            {
                RIPS("MF3216: ExtTextOut, pch LocalAlloc failed\n") ;
                goto exit_DoExtTextOut;
            }

            WideCharToMultiByte(dwCP, 0, pwch, cch, pch, cch, NULL, NULL);
        }
        else
        {
        // DBCS char string

            UINT    cjBufferSize;

            // we want DX array on a DWORD boundary

            cjBufferSize = ((nANSIChars+3)/4) * 4 * (sizeof(char) + sizeof(LONG));
            pchAlloc = pDBCSBuffer = LocalAlloc(LMEM_FIXED, cjBufferSize);

            if (pDBCSBuffer)
            {
            // start munging passed in parameters

                mrType = EMR_EXTTEXTOUTA;

                WideCharToMultiByte(dwCP, 0, pwch, cch, pDBCSBuffer, nANSIChars, NULL, NULL);

                pwch = (PWCH) pDBCSBuffer;
                pch = (PCHAR) pwch;
                cch = nANSIChars;

                if (pDx)
                {
                    ULONG ii, jj;

                    PULONG pDxTmp = (PLONG) &pDBCSBuffer[((nANSIChars+3)/4)*4];
                    for(ii=jj=0; ii < nANSIChars; ii++, jj++)
                    {
                        pDxTmp[ii] = pDx[jj];

                        // Use IsDBCSLeadByteEx to be able to specify the codepage
                        if(IsDBCSLeadByteEx(dwCP, pDBCSBuffer[ii]))
                        {
                            pDxTmp[++ii] = 0;
                        }
                    }

                    pDx = pDxTmp;
                }
            }
            else
            {
                goto exit_DoExtTextOut;
            }
        }
    }
    else
    {
        pch = (PCHAR) pwch ;
    }

// Transform the intercharacter spacing information.
// Allocate an array of (cch + 1) points to transform the points in,
// and copy the points to the array.
// ATTENTION: The following will not work if the current font has a vertical default
// baseline

    pptl = (PPOINTL) LocalAlloc(LMEM_FIXED, (cch + 1) * sizeof(POINTL));
    if (pptl == (PPOINTL) NULL)
    {
        RIPS("MF3216: ExtTextOut, pptl LocalAlloc failed\n") ;
    goto exit_DoExtTextOut;
    }

    pptl[0].x = x;
    pptl[0].y = y;
    for (i = 1; i < (INT) cch + 1; i++)
    {
    pptl[i].x = pptl[i-1].x + pDx[i-1];
    pptl[i].y = y;
    }

// If there is no rotation or shear then we can
// output the characters as a string.
// On the other hand, if there is rotation or shear then we
// have to output each character independently.

    if (!(pLocalDC->flags & STRANGE_XFORM))
    {
    // Win31 does not do text alignment correctly in some transforms.
    // It performs alignment in device space but win32 does it in the
    // notional space.  As a result, a win32 TextOut call may produce
    // different output than a similar call in win31.  We cannot
    // convert this correctly since if we make it works on win31,
    // it will not work on wow!

    PSHORT pDx16;

    if (!bXformRWorldToPPage(pLocalDC, (PPOINTL) pptl, (INT) cch + 1))
        goto exit_DoExtTextOut;

        // Convert it to the Dx array.  We do not need to compute it
    // as a vector since we have a scaling transform here.

    pDx16 = (PSHORT) pptl;
        for (i = 0; i < (INT) cch; i++)
            pDx16[i] = (SHORT) (pptl[i+1].x - pptl[i].x);

        // Emit the Win16 ExtTextOut metafile record.

        if (!bEmitWin16ExtTextOut(pLocalDC,
                                  (SHORT) ptlRef.x, (SHORT) ptlRef.y,
                                  fsOpts, &rcs, (PSTR) pch, (SHORT) cch,
                  (PWORD) pDx16))
        goto exit_DoExtTextOut;
    }
    else
    {
    // Deal with alignment in the world space.  We should really
    // do it in the notional space but with escapement and angles,
    // things gets complicated pretty easily.  We will try
    // our best to make it work in the common case.  We will not
    // worry about escapement and angles.

    ptlAdjust.x = 0;
    ptlAdjust.y = 0;

    switch (fTextAlign & (TA_LEFT | TA_RIGHT | TA_CENTER))
    {
    case TA_LEFT:           // default, no need to adjust x's
        break;
    case TA_RIGHT:          // shift the string by the string length
        bAdjustAlignment = TRUE;
        ptlAdjust.x = pptl[0].x - pptl[cch+1].x;
        break;
    case TA_CENTER:         // shift the string to the center
        bAdjustAlignment = TRUE;
        ptlAdjust.x = (pptl[0].x - pptl[cch+1].x) / 2;
        break;
    }

    // We will not adjust for the vertical alignment in the strange
    // transform case.  We cannot rotate the glyphs in any case.
#if 0
    switch (fTextAlign & (TA_TOP | TA_BOTTOM | TA_BASELINE))
    {
    case TA_TOP:            // default, no need to adjust y's
        break;
    case TA_BOTTOM:
        ptlAdjust.y = -logfont.height;
        break;
    case TA_BASELINE:
        ptlAdjust.y = -(logfont.height - logfont.baseline);
        break;
    }
#endif // 0

    // Adjust the character positions taking into account the alignment.

        for (i = 0; i < (INT) cch + 1; i++)
    {
        pptl[i].x += ptlAdjust.x;
        pptl[i].y += ptlAdjust.y;
    }

    if (!bXformRWorldToPPage(pLocalDC, (PPOINTL) pptl, (INT) cch + 1))
        goto exit_DoExtTextOut;

    // Reset the alignment since it has been accounted for.

    if (bAdjustAlignment)
            if (!bEmitWin16SetTextAlign(pLocalDC,
                (WORD) ((fTextAlign & ~(TA_LEFT | TA_RIGHT | TA_CENTER)) | TA_LEFT)))
        goto exit_DoExtTextOut;

    // Output the characters one at a time.

        for (i = 0 ; i < (INT) cch ; i++)
        {
        ASSERTGDI(!(fsOpts & (ETO_OPAQUE | ETO_CLIPPED)),
        "mf3216: DoExtTextOut: rectangle not expected");

            if (!bEmitWin16ExtTextOut(pLocalDC,
                                      (SHORT) pptl[i].x, (SHORT) pptl[i].y,
                                      fsOpts, (PRECTS) NULL,
                                      (PSTR) &pch[i], 1, (PWORD) NULL))
            goto exit_DoExtTextOut;
        }
    }

// Everything is golden.

    b = TRUE;

// Cleanup and return.

exit_DoExtTextOut:

    // Restore the alignment.

    if (bAdjustAlignment)
        (void) bEmitWin16SetTextAlign(pLocalDC, (WORD) fTextAlign);

    if ((flOpts & ETO_CLIPPED) && !(fsOpts & ETO_CLIPPED))
        (void) DoRestoreDC(pLocalDC, -1);

    if (pchAlloc)
        LocalFree((HANDLE) pchAlloc);

    if (pptl)
        LocalFree((HANDLE) pptl);

// Update the current position if the call succeeds.

    if (b)
    {
        if (fTextAlign & TA_UPDATECP)
        {
            // Update the helper DC.
             INT   iRet;
             POINTL pos;

             // We don't need to update to change the clip region on the helper
             // DC in Win9x anymore because we are using a bitmap and not the
             // screen anymore. What we do need to do, is get the current position
             // of the cursor and convert it back to Logical Units... Make the
             // call on the helper DC and the convert the position back to
             // device units and save it.

             if (pfnSetVirtualResolution == NULL)
             {
                 if (GetCurrentPositionEx(pLocalDC->hdcHelper, (LPPOINT) &pos))
                 {
                    b = bXformRDevToRWorld(pLocalDC, &pos, 1);
                    if (!b)
                    {
                        return(b);
                    }
                    MoveToEx(pLocalDC->hdcHelper, pos.x, pos.y, NULL);
                 }
             }

             // Finally, update the CP.
            if (mrType == EMR_EXTTEXTOUTA)
                ExtTextOutA
                (
                    pLocalDC->hdcHelper,
                    (int)    x,
                    (int)    y,
                    (UINT)   flOpts,
                    (LPRECT) prcl,
                    (LPSTR)  pwch,
                    (int)    cch,
                    (LPINT)  pDx
                );
            else
                ExtTextOutW
                (
                    pLocalDC->hdcHelper,
                    (int)    x,
                    (int)    y,
                    (UINT)   flOpts,
                    (LPRECT) prcl,
                    (LPWSTR) pwch,
                    (int)    cch,
                    (LPINT)  pDx
                );

            // Make the metafile CP invalid to force update
            // when it is used next time

            pLocalDC->ptCP.x = MAXLONG ;
            pLocalDC->ptCP.y = MAXLONG ;


            // Set the position in the helperDC back to Device units
            if (pfnSetVirtualResolution == NULL)
            {
                if (GetCurrentPositionEx(pLocalDC->hdcHelper, (LPPOINT) &pos))
                {
                   b = bXformRWorldToRDev(pLocalDC, &pos, 1);
                   if (!b)
                   {
                       return(b);
                   }
                   MoveToEx(pLocalDC->hdcHelper, pos.x, pos.y, NULL);
                }
            }
        }
    }

    return(b);
}


/***************************************************************************
 *  SetTextAlign  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSetTextAlign
(
PLOCALDC pLocalDC,
DWORD   fMode
)
{
BOOL    b ;

    // Do it to the helper DC.  It needs this in a path bracket
    // and to update current position correctly.

    SetTextAlign(pLocalDC->hdcHelper, (UINT) fMode);

        // Emit the Win16 metafile drawing order.

        b = bEmitWin16SetTextAlign(pLocalDC, LOWORD(fMode)) ;

        return(b) ;
}


/***************************************************************************
 *  SetTextColor  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoSetTextColor
(
PLOCALDC pLocalDC,
COLORREF    crColor
)
{
BOOL    b ;

        pLocalDC->crTextColor = crColor ;   // used by ExtCreatePen

        // Emit the Win16 metafile drawing order.

        b = bEmitWin16SetTextColor(pLocalDC, crColor) ;

        return(b) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\gpmf3216\win16api.h ===
/****************************************************************************
 *
 *  Win16 Emitter Routines header file
 *
 *  Date:   7/18/91
 *  Author: Jeffrey Newman (c-jeffn)
 *
 ***************************************************************************/

#ifndef _WIN16_MF3216_
#define _WIN16_MF3216_

#pragma pack(1)

#define msosignature            0x50504E54 // Office/Escher signature
#define msocommentBeginSrcCopy  0x0106
#define msocommentEndSrcCopy    0x0107

typedef struct tagRECTS {
    SHORT 	left;
    SHORT 	top;
    SHORT 	right;
    SHORT 	bottom;
} RECTS, *PRECTS;

typedef struct tagWIN16LOGPEN {
    WORD     lopnStyle;
    POINTS   lopnWidth;
    COLORREF lopnColor;
} WIN16LOGPEN, *LPWIN16LOGPEN;

typedef struct tagWIN16LOGBRUSH
  {
    WORD	lbStyle;
    DWORD	lbColor;
    SHORT       lbHatch;
  } WIN16LOGBRUSH, *LPWIN16LOGBRUSH;

typedef struct tagWIN16LOGFONT
{
    SHORT     lfHeight;
    SHORT     lfWidth;
    SHORT     lfEscapement;
    SHORT     lfOrientation;
    SHORT     lfWeight;
    BYTE      lfItalic;
    BYTE      lfUnderline;
    BYTE      lfStrikeOut;
    BYTE      lfCharSet;
    BYTE      lfOutPrecision;
    BYTE      lfClipPrecision;
    BYTE      lfQuality;
    BYTE      lfPitchAndFamily;
    BYTE      lfFaceName[LF_FACESIZE];
} WIN16LOGFONT, *LPWIN16LOGFONT;

typedef struct tagMETARECORD0 {
    DWORD rdSize;
    WORD  rdFunction;
} METARECORD0;

// Define METARECORD1 through METARECORD9.

#define METARECORD_(n)				\
	typedef struct tagMETARECORD##n {	\
	    DWORD rdSize;			\
	    WORD  rdFunction;			\
	    WORD  rdParm[n];			\
	} METARECORD##n

METARECORD_(1);
METARECORD_(2);
METARECORD_(3);
METARECORD_(4);
METARECORD_(5);
METARECORD_(6);
METARECORD_(7);
METARECORD_(8);
METARECORD_(9);

typedef struct tagMETARECORD_CREATEFONTINDIRECT {
    DWORD rdSize;
    WORD  rdFunction;
    WIN16LOGFONT lf16;
} METARECORD_CREATEFONTINDIRECT;

typedef struct tagMETARECORD_CREATEPENINDIRECT {
    DWORD rdSize;
    WORD  rdFunction;
    WIN16LOGPEN lopn16;
} METARECORD_CREATEPENINDIRECT;

typedef struct tagMETARECORD_CREATEBRUSHINDIRECT {
    DWORD rdSize;
    WORD  rdFunction;
    WIN16LOGBRUSH lb16;
} METARECORD_CREATEBRUSHINDIRECT;

typedef struct tagMETARECORD_DIBCREATEPATTERNBRUSH {
    DWORD rdSize;
    WORD  rdFunction;
    WORD  iType;
    WORD  iUsage;
} METARECORD_DIBCREATEPATTERNBRUSH;

typedef struct tagMETARECORD_POLY {
    DWORD rdSize;
    WORD  rdFunction;
    WORD  cpt;
} METARECORD_POLY;

typedef struct tagMETARECORD_POLYPOLYGON {
    DWORD rdSize;
    WORD  rdFunction;
    WORD  ccpt;
} METARECORD_POLYPOLYGON;

typedef struct tagMETARECORD_DIBSTRETCHBLT {
    DWORD rdSize;
    WORD  rdFunction;
    DWORD rop;
    SHORT cySrc;
    SHORT cxSrc;
    SHORT ySrc;
    SHORT xSrc;
    SHORT cy;
    SHORT cx;
    SHORT y;
    SHORT x;
} METARECORD_DIBSTRETCHBLT;

typedef struct tagMETARECORD_SETPALENTRIES {
    DWORD rdSize;
    WORD  rdFunction;
    WORD  iStart;
    WORD  cEntries;
} METARECORD_SETPALENTRIES;

typedef struct tagMETARECORD_ESCAPE {
    DWORD rdSize;
    WORD  rdFunction;
    WORD  wEscape;
    WORD  wCount;
} METARECORD_ESCAPE, *PMETARECORD_ESCAPE;

#pragma pack()

#define bEmitWin16EOF(pLocalDC)                                            \
                   bW16Emit0(pLocalDC, 0)

#define bEmitWin16RealizePalette(pLocalDC)                                 \
                   bW16Emit0(pLocalDC, META_REALIZEPALETTE)

#define bEmitWin16SaveDC(pLocalDC)                                         \
                   bW16Emit0(pLocalDC, META_SAVEDC)

#define bEmitWin16SetTextAlign(pLocalDC, wFlags)                           \
                   bW16Emit1(pLocalDC, META_SETTEXTALIGN, wFlags)

#define bEmitWin16SetStretchBltMode(pLocalDC, iStretchMode)                \
                   bW16Emit1(pLocalDC, META_SETSTRETCHBLTMODE, iStretchMode)

#define bEmitWin16SetROP2(pLocalDC, nDrawMode)                             \
                   bW16Emit1(pLocalDC, META_SETROP2, nDrawMode)

#define bEmitWin16SetPolyFillMode(pLocalDC, iPolyFillMode)                 \
                   bW16Emit1(pLocalDC, META_SETPOLYFILLMODE, iPolyFillMode)

#define bEmitWin16SetBkMode(pLocalDC, iBkMode)                             \
                   bW16Emit1(pLocalDC, META_SETBKMODE, iBkMode)

#define bEmitWin16SelectPalette(pLocalDC, ihObject)                        \
                   bW16Emit1(pLocalDC, META_SELECTPALETTE, ihObject)

#define bEmitWin16SelectObject(pLocalDC, ihObject)                         \
                   bW16Emit1(pLocalDC, META_SELECTOBJECT, ihObject)

#define bEmitWin16DeleteObject(pLocalDC, ihObject)                         \
                   bW16Emit1(pLocalDC, META_DELETEOBJECT, ihObject)

#define bEmitWin16SetMapMode(pLocalDC, iMapMode)                           \
                   bW16Emit1(pLocalDC, META_SETMAPMODE, iMapMode)

#define bEmitWin16PaintRgn(pLocalDC, ihRgn)                                \
                   bW16Emit1(pLocalDC, META_PAINTREGION, ihRgn)

#define bEmitWin16InvertRgn(pLocalDC, ihRgn)                               \
                   bW16Emit1(pLocalDC, META_INVERTREGION, ihRgn)

#define bEmitWin16RestoreDC(pLocalDC, nSavedDC)                            \
                   bW16Emit1(pLocalDC, META_RESTOREDC, nSavedDC)

#define bEmitWin16ResizePalette(pLocalDC, cEntries) 	                   \
                   bW16Emit1(pLocalDC, META_RESIZEPALETTE, cEntries)

#define bEmitWin16SetTextColor(pLocalDC, crColor)                          \
                   bW16Emit2(pLocalDC, META_SETTEXTCOLOR,                  \
                             HIWORD(crColor), LOWORD(crColor))

#define bEmitWin16SetMapperFlags(pLocalDC, dwFlags)                        \
                   bW16Emit2(pLocalDC, META_SETMAPPERFLAGS,                \
                             HIWORD(dwFlags), LOWORD(dwFlags))

#define bEmitWin16SetBkColor(pLocalDC, crColor)                            \
                   bW16Emit2(pLocalDC, META_SETBKCOLOR,                    \
                             HIWORD(crColor), LOWORD(crColor))

#define bEmitWin16SetWindowOrg(pLocalDC, x, y)                             \
                   bW16Emit2(pLocalDC, META_SETWINDOWORG, x, y)

#define bEmitWin16SetWindowExt(pLocalDC, x, y)                             \
                   bW16Emit2(pLocalDC, META_SETWINDOWEXT, x, y)

#define bEmitWin16SetViewportOrg(pLocalDC, x, y)                           \
                   bW16Emit2(pLocalDC, META_SETVIEWPORTORG, x, y)

#define bEmitWin16SetViewportExt(pLocalDC, x, y)                           \
                   bW16Emit2(pLocalDC, META_SETVIEWPORTEXT, x, y)

#define bEmitWin16OffsetClipRgn(pLocalDC, x, y)                            \
                   bW16Emit2(pLocalDC, META_OFFSETCLIPRGN, x, y)

#define bEmitWin16FillRgn(pLocalDC, ihRgn, ihBrush)                        \
                   bW16Emit2(pLocalDC, META_FILLREGION, ihBrush, ihRgn)

#define bEmitWin16MoveTo(pLocalDC, x, y)                                   \
                   bW16Emit2(pLocalDC, META_MOVETO, x, y)

#define bEmitWin16LineTo(pLocalDC, x, y)                                   \
                   bW16Emit2(pLocalDC, META_LINETO, x, y)

#define bEmitWin16FrameRgn(pLocalDC, ihRgn, ihBrush, nWidth, nHeight)      \
                   bW16Emit4(pLocalDC, META_FRAMEREGION,                   \
                             nWidth, nHeight, ihBrush, ihRgn)

#define bEmitWin16ExcludeClipRect(pLocalDC, xLeft, yTop, xRight, yBottom)  \
                   bW16Emit4(pLocalDC, META_EXCLUDECLIPRECT,               \
                             xLeft, yTop, xRight, yBottom)

#define bEmitWin16IntersectClipRect(pLocalDC, xLeft, yTop, xRight, yBottom)\
                   bW16Emit4(pLocalDC, META_INTERSECTCLIPRECT,             \
                             xLeft, yTop, xRight, yBottom)

#define bEmitWin16SetPixel(pLocalDC, x, y, crColor)                        \
                   bW16Emit4(pLocalDC, META_SETPIXEL, x, y,                \
                             HIWORD(crColor), LOWORD(crColor))

#define bEmitWin16ExtFloodFill(pLocalDC, x, y, crColor, iMode)             \
                   bW16Emit5(pLocalDC, META_EXTFLOODFILL, x, y,            \
                             HIWORD(crColor), LOWORD(crColor), iMode)

#define bEmitWin16Rectangle(pLocalDC, x1, y1, x2, y2)                      \
                   bW16Emit4(pLocalDC, META_RECTANGLE, x1, y1, x2, y2)

#define bEmitWin16Ellipse(pLocalDC, x1, y1, x2, y2)                        \
                   bW16Emit4(pLocalDC, META_ELLIPSE, x1, y1, x2, y2)

#define bEmitWin16RoundRect(pLocalDC, x1, y1, x2, y2, x3, y3)              \
                   bW16Emit6(pLocalDC, META_ROUNDRECT, x1, y1, x2, y2, x3, y3)

#define bEmitWin16Arc(pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4)            \
                   bW16Emit8(pLocalDC, META_ARC,                           \
                             x1, y1, x2, y2, x3, y3, x4, y4)

#define bEmitWin16Chord(pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4)          \
                   bW16Emit8(pLocalDC, META_CHORD,                         \
                             x1, y1, x2, y2, x3, y3, x4, y4)

#define bEmitWin16Pie(pLocalDC, x1, y1, x2, y2, x3, y3, x4, y4)            \
                   bW16Emit8(pLocalDC, META_PIE,                           \
                             x1, y1, x2, y2, x3, y3, x4, y4)

#define bEmitWin16BitBltNoSrc(pLocalDC, x, y, cx, cy, rop)		   \
                   bW16Emit9(pLocalDC, META_DIBBITBLT,                     \
                             x, y, cx, cy, 0, 0, 0, HIWORD(rop), LOWORD(rop))
                             
#define bEmitWin16EmitSrcCopyComment(pLocalDC, code)                \
                    bW16Emit5(pLocalDC, META_ESCAPE, code, HIWORD(msosignature),\
                    LOWORD(msosignature), 0x0006, MFCOMMENT)

BOOL bW16Emit0
(
PLOCALDC pLocalDC,
WORD     RecordID
) ;

BOOL bW16Emit1
(
PLOCALDC pLocalDC,
WORD     RecordID,
WORD     x1
) ;

BOOL bW16Emit2
(
PLOCALDC pLocalDC,
WORD     RecordID,
WORD     x1,
WORD     x2
) ;

BOOL bW16Emit4
(
PLOCALDC pLocalDC,
WORD     RecordID,
WORD     x1,
WORD     x2,
WORD     x3,
WORD     x4
) ;

BOOL bW16Emit5
(
PLOCALDC pLocalDC,
WORD     RecordID,
WORD     x1,
WORD     x2,
WORD     x3,
WORD     x4,
WORD     x5
) ;

BOOL bW16Emit6
(
PLOCALDC pLocalDC,
WORD     RecordID,
WORD     x1,
WORD     x2,
WORD     x3,
WORD     x4,
WORD     x5,
WORD     x6
) ;

BOOL bW16Emit8
(
PLOCALDC pLocalDC,
WORD     RecordID,
WORD     x1,
WORD     x2,
WORD     x3,
WORD     x4,
WORD     x5,
WORD     x6,
WORD     x7,
WORD     x8
) ;

BOOL bW16Emit9
(
PLOCALDC pLocalDC,
WORD     RecordID,
WORD     x1,
WORD     x2,
WORD     x3,
WORD     x4,
WORD     x5,
WORD     x6,
WORD     x7,
WORD     x8,
WORD     x9
) ;

BOOL bEmitWin16CreateFontIndirect
(
  PLOCALDC pLocalDC,
  LPWIN16LOGFONT lpWin16LogFont
) ;

BOOL bEmitWin16Poly
(
  PLOCALDC pLocalDC,
  LPPOINTS ppt,
  SHORT    cpt,
  WORD     metaType
) ;

BOOL bEmitWin16PolyPolygon
(
  PLOCALDC pLocalDC,
  PPOINTS  ppt,
  PWORD    pcpt,
  WORD     cpt,
  WORD     ccpt
) ;

BOOL bEmitWin16StretchBlt
(
  PLOCALDC pLocalDC,
  SHORT    x,
  SHORT    y,
  SHORT    cx,
  SHORT    cy,
  SHORT    xSrc,
  SHORT    ySrc,
  SHORT    cxSrc,
  SHORT    cySrc,
  DWORD    rop,
  PBITMAPINFO lpbmi,
  DWORD       cbbmi,
  PBYTE    lpBits,
  DWORD    cbBits
) ;

BOOL bEmitWin16ExtTextOut
(
  PLOCALDC pLocalDC,
  SHORT    x,
  SHORT    y,
  WORD     fwOpts,
  PRECTS   prcts,
  PSTR     ach,
  SHORT    nCount,
  PWORD    lpDx
) ;

BOOL bEmitWin16CreateRegion
(
PLOCALDC pLocalDC,
DWORD    cbRgn,
PVOID    pRgn
) ;

BOOL bEmitWin16SetPaletteEntries
(
PLOCALDC        pLocalDC,
DWORD           iStart,
DWORD           cEntries,
LPPALETTEENTRY  pPalEntries
) ;

BOOL bEmitWin16CreatePalette
(
PLOCALDC     pLocalDC,
LPLOGPALETTE lpLogPal
) ;

BOOL bEmitWin16CreateBrushIndirect
(
  PLOCALDC        pLocalDC,
  LPWIN16LOGBRUSH lpLogBrush16
) ;

BOOL bEmitWin16CreateDIBPatternBrush
(
  PLOCALDC    pLocalDC,
  PBITMAPINFO pBitmapInfo,
  DWORD       cbBitmapInfo,
  PBYTE       pBits,
  DWORD       cbBits,
  WORD        iUsage,
  WORD        iType
) ;

BOOL bEmitWin16CreatePen
(
  PLOCALDC pLocalDC,
  WORD     iPenStyle,
  PPOINTS  pptsWidth,
  COLORREF crColor
) ;

BOOL bEmitWin16Escape
(
PLOCALDC pLocalDC,
SHORT    wEscape,
SHORT    wCount,
LPSTR    lpInData,
LPSTR    lpOutData
) ;

BOOL bEmitWin16EscapeEnhMetaFile
(
  PLOCALDC pLocalDC,
  PMETARECORD_ESCAPE pmfeEnhMF,
  LPBYTE   lpEmfData
) ;
#endif // _WIN16_MF3216_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\gpmf3216\xforms.c ===
/*****************************************************************************
*
* xforms - Entry points for Win32 to Win 16 converter
*
* Date: 7/1/91
* Author: Jeffrey Newman (c-jeffn)
*
* Copyright 1991 Microsoft Corp
*----------------------------------------------------------------------------
*
*   September 21, 1991
*   Updated [20-Dec-1991]
*
*   Transformations in the Win32 to Win16 translator.
*
*   We are now supporting coordinate transformations from any
*   map mode to any map mode.
*
*   Where:
*        W    is the record-time-world to record-time-device xform.
*             (aka metafile-world to metafile-device.)
*        D    is the record-time device to play-time-device xform.
*             (aka metafile-device to reference-device.)
*        P    is the play-time-device to play-time-page xform.
*             (aka reference-device to reference-logical (or page).)
*
*   W is the transformation defined by the world xform, map mode, window org,
*   window extent, viewport org, and viewport extent in the
*   Win32 metafile. This transform is also known as the world to
*   device xform.
*
*   The normal composite xform is:
*
*         W D P
*        ^ ^ ^ ^
*        | | | +-  coordinate recorded in the win16 metafile.
*        | | |     play-time-page coordinates (aka reference-logical)
*        | | +---- play-time-device (reference-device) coordinates.
*        | +------ record-time device (metafile-device) coordinates.
*        +-------- world coordinates, recorded in Win32 metafile
*
*  The following comment is from Hockl's mail about transforms.
*
*   Message 11:
*   From hockl Thu Dec 19 11:50:54 1991
*   To: c-jeffn
*   Cc: johnc
*   Subject: Transform hints for the 32-16 converter
*   Date: Thu Dec 19 11:46:40 1991
*
*   Here are some transform hints for the converter:
*
*   A. Issue the following records immediately following the 16-bit header
*      record:
*
*      1. SetMapMode - use the given mapping mode, it is MM_ANISOTROPIC
*         in most cases.
*
*      2. SetWindowOrg - use the upper left coordinates of the rclFrame.
*         The coordinates are in the logical units of the reference DC.  So
*         you have to convert .01mm to the reference device coordinates, then
*         to the logical coordinates.  You can use the third transform
*         defined in B.4 below to convert device coordinates to the logical
*         coordinates of the reference device.  (Note the conversion formula
*         for LPtoDP is defined as Dx = (Lx - xWO) * xVE/xWE + xVO and so on).
*         This record is required to translate the converted picture to the
*         origin (see comments in GetMetaFileBitsEx).
*
*      3. SetWindowExt - use the extents of the rclFrame.
*      xExt = rclFrame.right - rclFrame.left;
*      yExt = rclFrame.bottom - rclFrame.top;
*         The extents are in the device units of the reference DC.  So
*         you have to convert .01mm to the reference device units.
*
*      These three records should always be generated.  Note that
*      SetWindowExt has no effect in all fixed mapping modes (e.g.
*      MM_LOENGLISH and MM_TEXT) and will have no effect when the converted
*      metafile is played.
*
*   B. Once you have issued the records, you need to use a xform helper DC
*      to convert the coordinates of all drawing orders.  To do this, you
*      need to do the following:
*
*      1. Create a xform helper DC.  This is a display info DC.
*
*      2. Call SetVirtualResolution to set the xform helper DC to that of
*         the metafile.  Use the metafile header's szlDevice and
*         szlMillimeters values to set the resolution.  This is to ensure
*         that the help DC maps the logical coordinates to the device
*         coordinates of the original metafile device.  If you reuse this
*         helper DC in conversion, make sure you initialize the transforms
*         using SetMapMode, ModifyWorldTransform, SetWindowOrgEx and
*         SetViewportOrgEx.  You can use the same code in the
*         CreateMetaFileEx function.
*
*      3. Once you have set up the xform helper DC, you should play all
*         32-bit xform calls into the helper DC.  But never emit any
*         xform records in the converter.  Everytime the xform is changed
*         in the helper DC, you need to get the world to device xform
*         (xformWDHelper) from the helper DC.  The xformWDHelper is used to
*         convert the coordinates of the drawing orders subsequently.
*         You can get it using the GetTransform(hdcHelper,XFORM_WORLD_TO_DEVICE)
*         private API.
*
*      4. To convert drawing order coordinates, you pass them through three
*         transforms.  The first is the xformWDHelper as computed above.  It
*         converts all logical coordiates into the device coordinates of
*         the original metafile device.  Note that this coordinates may
*         be different from the conversion's reference device.  For example,
*         the metafile may be created for a printer but the conversion is
*         requested for the display.  The second transform therefore scales
*         the coordinates from the metafile device to the reference device.
*         The scaled coordinates are in MM_TEXT units.  So we need the third
*         transform to convert the coordinates into the requested mapmode
*         units.  For MM_TEXT, MM_ANISOTROPIC and MM_ISOTROPIC mapmode, this
*         is the identity transform.  For the other mapmodes, this is a scale
*         transform.  The scale transform maps the device units of the
*         reference device to the logical units and can be computed using
*         szlDevice, szlMillimeters of the reference device (not the metafile
*         device!) and some predefined constants (to map millimeter to
*         english, for example).  Note that in these fixed mapping modes, the
*         y-axis goes in the opposite direction.  So make sure that the eM22
*         component of the third transform is negative.  As you can see, the
*         second and third transform never change in the duration of the
*         conversion.  So you can combine them into one to optimize computation
*         of the composite transform.  The composite transfom makes up of the
*         three transforms and is used to convert drawing order coordinates
*         into coordinates for the converted metafile.
*
*   C. To display a converted metafile in Windows 3.0, do the following before
*      calling PlayMetaFile:
*
*      1. If the mapmode is MM_ANISOTROPIC, which is 99.9% of the time, call
*         SetMapMode(MM_ANISOTROPIC), SetViewportOrigin and SetViewportExt.
*         The viewport origin defines the upper left corner of the display area
*         and the viewport origin defines the extent of the display area.  Both
*         are in device units.
*
*      2. If the mapmode is MM_ISOTROPIC, which is strange, call
*         SetMapMode(MM_ISOTROPIC), SetViewportOrigin and SetViewportExt.
*         This is almost the same as C.1 above.
*
*      3. If the mapmode is others, the metafile has a fixed physical size
*         and cannot be scaled easily without a lot of heck in the application.
*         Call SetViewportOrigin to define the upper left corner of the display
*         area.  The origin is in device coordinates.
*
*   I hope these steps are clear.  If you have any questions, feel free to
*   give me a call.
*
*       HockL
*
*
* Additions for Win9x support: GillesK 01/22/01
* To properly support Win9x, since it doesn't have a SetVirtualResolution
* function. We will create a bitmap HDC of the size of the metafile, and that
* will be our helperDC. Since the DC will start at 0,0 we translate it's origin
* to be the origin of the metafile, this is what xformDC is used for. We don't
* want to change anything in that transform and we don't support
* SetWorldTransform calls on Win9x, so to get around that we keep track of the
* current WorldToPage transform in xformW and the current PageToDevice transform
* in xformP. Everytime we use the helperDC we need to convert the logical units
* of the metafile into device units so that we don't overflow the helperDC
* bounds. And everytime we grab something from the helperDC we need to convert
* from DeviceUnits back into logical units or into WMF units. The helperDC on
* Win9x will always be in MM_TEXT and deviceUnits. The WMF that get created will
* always start at the origin to match with the origin of the helperDC. So the
* transforms that occur to convert from EMF to WMF are the following:
*
* xformW*xformP*xformDC*xformRDevToPDev*xformPDevToPPage
* \____________________/
*  xformRWorldToRDev
*
******************************************************************************/


#include "precomp.h"
#pragma hdrstop

extern fnGetTransform pfnGetTransform;
extern fnSetVirtualResolution pfnSetVirtualResolution;
extern BOOL GetFrameBounds(PLOCALDC pLocalDC, PENHMETAHEADER pmf32header, RECTL *frameOut);

#define ABS(x) (((x) >= 0) ? (x) : (-x))

BOOL bComputeCompositeXform(PLOCALDC pLocalDC) ;
VOID vInitRecDevToPlayDevXform(PLOCALDC pLocalDC, PENHMETAHEADER pmf32header) ;
VOID vMakeIso(PLOCALDC pLocalDC);
BOOL bInvertxform(PXFORM pxformSrc, PXFORM pxformDest);
BOOL bCalcPagexform(PMAPPING pMapping, PXFORM pxformDest);
/*
[19-Dec-1991]
A note about transformations.

  We will map into any map mode (when the converter is complete).

    We will use a helper DC to compute our transformation matrices.

      All the Win32 APIs that effect transformations or map modes
      will be sent to a helper DC.  The helper DC will return a transform
      matrix that converts from World Coordinates to Device Coordinates.
      This transformation matrix is: xformRWorldToRDev.

        xformRWorldToRDev is combined with the xformRDevToPPage matrix to produce
        the xformRWorldToPPage matrix.  All coordinates are mapped through the
        xformRWorldToPPage matrix.
*/


XFORM   xformIdentity = {(FLOAT) 1.0,
(FLOAT) 0.0,
(FLOAT) 0.0,
(FLOAT) 1.0,
(FLOAT) 0.0,
(FLOAT) 0.0 } ;


/****************************************************************************
*  Initialize all the matrices.
****************************************************************************/

// Units per millimeter array.  It must be in the order of MM_LOMETRIC,
// MM_HIMETRIC, MM_LOENGLISH, MM_HIENGLISH, MM_TWIPS.

FLOAT aeUnitsPerMM[5] = { 10.0f, 100.0f, 3.937f, 39.37f, 56.6928f };

BOOL bInitXformMatrices(PLOCALDC pLocalDC, PENHMETAHEADER pmf32header, RECTL* frameBounds)
{
    // Init xformRDevToPDev.

    vInitRecDevToPlayDevXform(pLocalDC, pmf32header) ;

    // Init xformPDevToPPage and xformPPageToPDev.
    // (aka reference-device to reference-logical) transform.

    switch(pLocalDC->iMapMode)
    {
    case MM_TEXT:
    case MM_ANISOTROPIC:
    case MM_ISOTROPIC:
        pLocalDC->xformPDevToPPage = xformIdentity ;
        pLocalDC->xformPPageToPDev = xformIdentity ;
        break ;

    case MM_LOMETRIC:
    case MM_HIMETRIC:
    case MM_LOENGLISH:
    case MM_HIENGLISH:
    case MM_TWIPS:
        {
            FLOAT exUnitsPerPel;
            FLOAT eyUnitsPerPel;

            // Compute units per pixel.

            exUnitsPerPel = (FLOAT) pLocalDC->cxPlayDevMM
                / (FLOAT) pLocalDC->cxPlayDevPels
                * aeUnitsPerMM[pLocalDC->iMapMode - MM_LOMETRIC];

            eyUnitsPerPel = (FLOAT) pLocalDC->cyPlayDevMM
                / (FLOAT) pLocalDC-> cyPlayDevPels
                * aeUnitsPerMM[pLocalDC->iMapMode - MM_LOMETRIC];

            pLocalDC->xformPDevToPPage.eM11 = exUnitsPerPel;
            pLocalDC->xformPDevToPPage.eM12 = 0.0f;
            pLocalDC->xformPDevToPPage.eM21 = 0.0f;
            pLocalDC->xformPDevToPPage.eM22 = -eyUnitsPerPel;
            pLocalDC->xformPDevToPPage.eDx  = 0.0f;
            pLocalDC->xformPDevToPPage.eDy  = 0.0f;

            pLocalDC->xformPPageToPDev.eM11 = 1.0f / exUnitsPerPel;
            pLocalDC->xformPPageToPDev.eM12 = 0.0f;
            pLocalDC->xformPPageToPDev.eM21 = 0.0f;
            pLocalDC->xformPPageToPDev.eM22 = -1.0f / eyUnitsPerPel;
            pLocalDC->xformPPageToPDev.eDx  = 0.0f;
            pLocalDC->xformPPageToPDev.eDy  = 0.0f;
        }
        break ;
    }

    // Init xformRDevToPPage.
    // This xform is used in the SelectClipRegion code.

    if (!bCombineTransform(&pLocalDC->xformRDevToPPage,
        &pLocalDC->xformRDevToPDev,
        &pLocalDC->xformPDevToPPage))
    {
        RIPS("MF3216: InitXformMatrices, bCombineTransform failed\n");
        return(FALSE);
    }

    if (!GetFrameBounds(pLocalDC, pmf32header, frameBounds))
    {
        return FALSE;
    }

    // We are going to use the helper DC to compute the
    // Record-time-World to Record-time-Device transform.

    // Set the Helper DC virtual resolution to the Metafiles
    // resolution.
    if (pfnSetVirtualResolution != NULL)
    {
        if (!pfnSetVirtualResolution(pLocalDC->hdcHelper,
            (INT) pmf32header->szlDevice.cx,
            (INT) pmf32header->szlDevice.cy,
            (INT) pmf32header->szlMillimeters.cx,
            (INT) pmf32header->szlMillimeters.cy))
        {
            RIPS("MF3216: InitXformMatrices, SetVirtualResolution failed \n") ;
            return(FALSE);
        }
    }
    else
    {
        // We should be in an OS that doesn't support SetVirtualResolution
        // such as Win9x... Compute what is necessary...
        // From the mf3216 from Win98

        pLocalDC->xformRWorldToRDev = xformIdentity ;
        pLocalDC->xformRDevToRWorld = xformIdentity ;
        pLocalDC->xformW = xformIdentity ;
        pLocalDC->xformP = xformIdentity ;
        pLocalDC->xformDC = xformIdentity;
        pLocalDC->xformDC.eDx = (float) -frameBounds->left;
        pLocalDC->xformDC.eDy = (float) -frameBounds->top;
        pLocalDC->map.iMapMode = MM_TEXT;
        pLocalDC->map.iWex = 1;
        pLocalDC->map.iWey = 1;
        pLocalDC->map.iVex = 1;
        pLocalDC->map.iVey = 1;

        // pLocalDC->map.iWox = 0; // LocalDC is zero-initialized.
        // pLocalDC->map.iWoy = 0;
        // pLocalDC->map.iVox = 0;
        // pLocalDC->map.iVoy = 0;
    }
    // Init other matrices.

    return(bComputeCompositeXform(pLocalDC));
}

/****************************************************************************
*  Initialize the Record-time to Play-time scalers. (xformRDevToPDev)
****************************************************************************/
VOID vInitRecDevToPlayDevXform(PLOCALDC pLocalDC, PENHMETAHEADER pmf32header)
{
    FLOAT   ecxRecDevPels,
        ecyRecDevPels,
        ecxRecDevMM,
        ecyRecDevMM,
        ecxPlayDevPels,
        ecyPlayDevPels,
        ecxPlayDevMM,
        ecyPlayDevMM,
        exMillsPerPelRec,
        eyMillsPerPelRec,
        exMillsPerPelPlay,
        eyMillsPerPelPlay ;


    // Pickup the physical dimensions of the record-time
    // device, both in pels and millimeters.
    // Converts them to floats

    ecxRecDevPels = (FLOAT) pmf32header->szlDevice.cx ;
    ecyRecDevPels = (FLOAT) pmf32header->szlDevice.cy ;
    ecxRecDevMM   = (FLOAT) pmf32header->szlMillimeters.cx ;
    ecyRecDevMM   = (FLOAT) pmf32header->szlMillimeters.cy ;


    // convert the Play-time device dimensions to floats.
    if (pLocalDC->hdcRef == NULL)
    {
        pLocalDC->cxPlayDevPels = pmf32header->szlDevice.cx ;
        pLocalDC->cyPlayDevPels = pmf32header->szlDevice.cy ;
        pLocalDC->cxPlayDevMM   = pmf32header->szlMillimeters.cx ;
        pLocalDC->cyPlayDevMM   = pmf32header->szlMillimeters.cy ;
    }

    ecxPlayDevPels = (FLOAT) pLocalDC->cxPlayDevPels ;
    ecyPlayDevPels = (FLOAT) pLocalDC->cyPlayDevPels ;
    ecxPlayDevMM   = (FLOAT) pLocalDC->cxPlayDevMM ;
    ecyPlayDevMM   = (FLOAT) pLocalDC->cyPlayDevMM ;

    // Calucalte the pels per millimeter for both the record-time
    // and play-time devices.

    exMillsPerPelRec = ecxRecDevMM / ecxRecDevPels ;
    eyMillsPerPelRec = ecyRecDevMM / ecyRecDevPels ;

    exMillsPerPelPlay = ecxPlayDevMM / ecxPlayDevPels ;
    eyMillsPerPelPlay = ecyPlayDevMM / ecyPlayDevPels ;

    // Init the Record-time-device to the Play-time-device transform.
    // aka  the Metafile-device to the Reference-device transform.

    pLocalDC->xformRDevToPDev.eM11 = exMillsPerPelRec / exMillsPerPelPlay ;
    pLocalDC->xformRDevToPDev.eM12 = (FLOAT) 0.0 ;
    pLocalDC->xformRDevToPDev.eDx  = (FLOAT) 0.0 ;
    pLocalDC->xformRDevToPDev.eM21 = (FLOAT) 0.0 ;
    pLocalDC->xformRDevToPDev.eM22 = eyMillsPerPelRec / eyMillsPerPelPlay ;
    pLocalDC->xformRDevToPDev.eDy  = (FLOAT) 0.0 ;

    return;
}


#if 0
/***************************************************************************
* vInvertMatrix - Invert a matrix
**************************************************************************/
VOID vInvertMatrix(PXFORM pxformSrc, PINVERSMATRIX pinvxfm)
{
    FLOAT   eM11, eM12, eM21, eM22, eDx, eDy,
        detA ;

    // dereference the matrix elements, just to make the rest of this
    // routine more readable.

    eM11 = pxformSrc->eM11 ;
    eM12 = pxformSrc->eM12 ;
    eM21 = pxformSrc->eM21 ;
    eM22 = pxformSrc->eM22 ;
    eDx  = pxformSrc->eDx ;
    eDy  = pxformSrc->eDy ;

    // First determine the determinant of the source matrix.

    detA = (eM11 * eM22) - (eM11 * eDy) ;

    pinvxfm->a1 = eM22 / detA ;
    pinvxfm->a2 = -(eM21 / detA) ;
    pinvxfm->a3 = ((eM21 * eDy) - (eDx * eM22)) / detA ;
    pinvxfm->b1 = -(eM12 / detA) ;
    pinvxfm->b2 = eM11 / detA ;
    pinvxfm->b3 = -(((eM11 * eDy) - (eDx * eM12)) / detA) ;
    pinvxfm->c1 = (FLOAT) 0.0 ;
    pinvxfm->c2 = (FLOAT) 0.0 ;
    pinvxfm->c3 = ((eM11 * eM22) - (eM21 * eM12)) / detA ;

    // This is just for testing.

    pinvxfm->a1 = pxformSrc->eM11 ;
    pinvxfm->a2 = pxformSrc->eM12 ;
    pinvxfm->a3 = (FLOAT) 0.0 ;
    pinvxfm->b1 = pxformSrc->eM21 ;
    pinvxfm->b2 = pxformSrc->eM22 ;
    pinvxfm->b3 = (FLOAT) 0.0 ;
    pinvxfm->c1 = pxformSrc->eDx ;
    pinvxfm->c2 = pxformSrc->eDy ;
    pinvxfm->c3 = (FLOAT) 1.0 ;

    return ;

}
#endif // 0


/***************************************************************************
* XformPDevToPPage  - Do a transform on the array of points passed in.
*
*                     This does the play-time (reference) device to
*                     play-time (reference) page (logical) transformation.
**************************************************************************/
BOOL bXformPDevToPPage(PLOCALDC pLocalDC, PPOINTL aptl, INT nCount)
{
    BOOL    b ;

    b = bXformWorkhorse(aptl, nCount, &pLocalDC->xformPDevToPPage) ;

    return (b) ;
}


/***************************************************************************
* XformPPageToPDev  - Do a transform on the array of points passed in.
*
*                     This does the play-time (reference) page (logical) to
*                     play-time (reference) device transformation.
**************************************************************************/
BOOL bXformPPageToPDev(PLOCALDC pLocalDC, PPOINTL aptl, INT nCount)
{
    BOOL    b ;

    b = bXformWorkhorse(aptl, nCount, &pLocalDC->xformPPageToPDev) ;

    return (b) ;
}


/***************************************************************************
* XformRWorldToRDev  - Do a transform on the array of points passed in.
*
*                      This does the Record-time (metafile) world to
*                      record-time device translation.
**************************************************************************/
BOOL bXformRWorldToRDev(PLOCALDC pLocalDC, PPOINTL aptl, INT nCount)
{
    BOOL    b ;

    b = bXformWorkhorse(aptl, nCount, &pLocalDC->xformRWorldToRDev) ;

    return (b) ;
}


/***************************************************************************
* XformRDevToRWorld  - Do a transform on the array of points passed in.
*
*                      This does the Record-device (metafile) world to
*                      record-time world translation.
**************************************************************************/
BOOL bXformRDevToRWorld(PLOCALDC pLocalDC, PPOINTL aptl, INT nCount)
{
    BOOL    b ;

    b = bXformWorkhorse(aptl, nCount, &pLocalDC->xformRDevToRWorld) ;

    return (b) ;
}


/***************************************************************************
* XformRWorldToPPage - Do a transform on the array of points passed in.
*
*            This is the workhorse translation routine.
*            This translates from record-time-world (aka metafile-world)
*            to record-time-device (aka metafile-device)  then from
*            record-time-device (aka metafile-device) to play-time-device
*            (aka reference-device) then from play-time-device
*            (aka reference-device) to play-time-page (reference-logical)
*            space.
**************************************************************************/
BOOL bXformRWorldToPPage(PLOCALDC pLocalDC, PPOINTL aptl, DWORD nCount)
{
    BOOL    b ;

    b = bXformWorkhorse(aptl, nCount, &pLocalDC->xformRWorldToPPage) ;

    return (b) ;
}


/***************************************************************************
* bXformWorkhorse - Transformation Workhorse.
**************************************************************************/
BOOL bXformWorkhorse(PPOINTL aptl, DWORD nCount, PXFORM pXform)
{
    INT     i ;
    FLOAT   x, y, fx, fy ;
    BOOL    b ;

    for (i = 0 ; i < (INT) nCount ; i++)
    {
        x = (FLOAT) aptl[i].x ;
        y = (FLOAT) aptl[i].y ;
        fx = (x * pXform->eM11 + y * pXform->eM21 + pXform->eDx) ;
        fy = (x * pXform->eM12 + y * pXform->eM22 + pXform->eDy) ;
        aptl[i].x = (LONG) (fx + ((fx < 0.0) ? -0.5f : 0.5f)) ;
        aptl[i].y = (LONG) (fy + ((fy < 0.0) ? -0.5f : 0.5f)) ;
    }

    // Do the coordinate overflow detection.

    b = bCoordinateOverflowTest((PLONG) aptl, nCount * 2) ;

    return (b) ;

}

/***************************************************************************
* vXformWorkhorseFloat - Transformation Workhorse.
**************************************************************************/
VOID vXformWorkhorseFloat(PPOINTFL aptfl, UINT nCount, PXFORM pXform)
{
    UINT    i ;
    FLOAT   x, y ;

    for (i = 0 ; i < nCount ; i++)
    {
        x = aptfl[i].x ;
        y = aptfl[i].y ;
        aptfl[i].x = x * pXform->eM11 + y * pXform->eM21 + pXform->eDx;
        aptfl[i].y = x * pXform->eM12 + y * pXform->eM22 + pXform->eDy;
    }
}

/*****************************************************************************
* iMagnitudeXform - Transform the magnitude of a number from
*                   Record-time-World to Play-time-Page coordinate space.
*****************************************************************************/
INT iMagnitudeXform (PLOCALDC pLocalDC, INT value, INT iType)
{
    PXFORM  pxform ;
    INT     iRet ;

    pxform = &(pLocalDC->xformRWorldToPPage) ;

    iRet = iMagXformWorkhorse (value, pxform, iType) ;

    return (iRet) ;
}

/*****************************************************************************
* iMagXformWorkhorse - get the magnitude component of a translated vector
*****************************************************************************/
INT iMagXformWorkhorse (INT value, PXFORM pxform, INT iType)
{
    POINTFL aptfl[2] ;
    FLOAT   x1, y1, x2, y2;
    double  emag ;

    // Create a vector, from (0,0) to the point.

    aptfl[0].x = 0.0f ;
    aptfl[0].y = 0.0f ;

    if (iType == CX_MAG)
    {
        aptfl[1].x = (FLOAT) value ;
        aptfl[1].y = 0.0f ;
    }
    else
    {
        aptfl[1].x = 0.0f ;
        aptfl[1].y = (FLOAT) value ;
    }

    vXformWorkhorseFloat(aptfl, 2, pxform);

    // Now get the magnitude

    x1 = aptfl[0].x ;
    y1 = aptfl[0].y ;
    x2 = aptfl[1].x ;
    y2 = aptfl[1].y ;

    emag = sqrt((double) ((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1))) ;

    return((INT) (emag + (double) 0.5f));
}


/*****************************************************************************
* bRotationTest -
*        return -  TRUE if there is a rotation or shear in this xform
*                  FALSE if there is none.
*****************************************************************************/
BOOL bRotationTest(PXFORM pxform)
{
    BOOL    b ;

    if (   (pxform->eM12 != (FLOAT) 0.0)
        || (pxform->eM21 != (FLOAT) 0.0)
        )
    {
        b = TRUE ;
    }
    else
    {
        b = FALSE ;
    }

    return(b) ;
}

/***************************************************************************
*  SetMapMode  - Win32 to Win16 Metafile Converter Entry Point
*
*  All the map mode translations are done by the helper DC.
*  The Helper DC always transforms to device, then we combine the
*  MetafileWorldToDevice with the DeviceToPage transform.
*  This becomes the Win32 to Win16 transform.
*
*  Some of the metafiles converted from Win16 to Win32 do not
*  define a Viewport extent.  Since the Isotropic and AnIsotropic
*  map modes are undefined if either the Viewport Extent or the Window
*  Extent are undefined we will default the Viewport extent to the
*  device extent in the Win32 metafile header.
*
*  Since we might not have set a Virtual Resolution... We might have
*  to calcultate the MapMode information ourselves. (GillesK)
**************************************************************************/
BOOL WINAPI DoSetMapMode
(
PLOCALDC pLocalDC,
DWORD    ulMapMode
)
{
    BOOL    b ;
    INT iMapMode = (INT) ulMapMode;

    if (iMapMode < MM_MIN || iMapMode > MM_MAX)
    {
        RIPS("MF3216: DoSetMapMode() - invalid map mode.");
        return FALSE;
    }

    if (pfnSetVirtualResolution != NULL)
    {
        if (!SetMapMode(pLocalDC->hdcHelper, ulMapMode))
        {
            ASSERTGDI(FALSE, "MF3216: DoSetMapMode failed\n");
            return(FALSE);
        }
    }
    else
    {
        PENHMETAHEADER pEmfHeader = (PENHMETAHEADER) pLocalDC->pMf32Bits;
        if (iMapMode == pLocalDC->map.iMapMode && iMapMode != MM_ISOTROPIC)
            return TRUE;

        switch (iMapMode) {
        case MM_TEXT:
            pLocalDC->map.iWex = 1;
            pLocalDC->map.iWey = 1;
            pLocalDC->map.iVex = 1;
            pLocalDC->map.iVey = 1;
            break;
        case MM_ISOTROPIC:
        case MM_LOMETRIC:
            pLocalDC->map.iWex = 10 * pEmfHeader->szlMillimeters.cx;
            pLocalDC->map.iWey = 10 * pEmfHeader->szlMillimeters.cy;
            pLocalDC->map.iVex =  pEmfHeader->szlDevice.cx;
            pLocalDC->map.iVey = -pEmfHeader->szlDevice.cy;
            break;
        case MM_HIMETRIC:
            pLocalDC->map.iWex = 100 * pEmfHeader->szlMillimeters.cx;
            pLocalDC->map.iWey = 100 * pEmfHeader->szlMillimeters.cy;
            pLocalDC->map.iVex =  pEmfHeader->szlDevice.cx;
            pLocalDC->map.iVey = -pEmfHeader->szlDevice.cy;
            break;
        case MM_LOENGLISH:
            pLocalDC->map.iWex = 1000 * pEmfHeader->szlMillimeters.cx;
            pLocalDC->map.iWey = 1000 * pEmfHeader->szlMillimeters.cy;
            pLocalDC->map.iVex =  254 * pEmfHeader->szlDevice.cx;
            pLocalDC->map.iVey = -254 * pEmfHeader->szlDevice.cy;
            break;
        case MM_HIENGLISH:
            pLocalDC->map.iWex = 10000 * pEmfHeader->szlMillimeters.cx;
            pLocalDC->map.iWey = 10000 * pEmfHeader->szlMillimeters.cy;
            pLocalDC->map.iVex =  254 * pEmfHeader->szlDevice.cx;
            pLocalDC->map.iVey = -254 * pEmfHeader->szlDevice.cy;
            break;
        case MM_TWIPS:
            pLocalDC->map.iWex = 14400 * pEmfHeader->szlMillimeters.cx;
            pLocalDC->map.iWey = 14400 * pEmfHeader->szlMillimeters.cy;
            pLocalDC->map.iVex =  254 * pEmfHeader->szlDevice.cx;
            pLocalDC->map.iVey = -254 * pEmfHeader->szlDevice.cy;
            break;
        case MM_ANISOTROPIC:
            break;
        default:
            break;
        }
    }
    pLocalDC->map.iMapMode = iMapMode;

    b = bComputeCompositeXform(pLocalDC) ;

    return (b) ;
}


/***************************************************************************
*  ScaleWindowsExtEx  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoScaleWindowExt
(
 PLOCALDC pLocalDC,
 INT      Xnum,
 INT      Xdenom,
 INT      Ynum,
 INT      Ydenom
 )
{
    BOOL    b ;
    INT   xOrg, yOrg;

    // Set the Windows extent
    if (pfnSetVirtualResolution != NULL)
    {
        if (!ScaleWindowExtEx(pLocalDC->hdcHelper,
            Xnum, Xdenom,
            Ynum, Ydenom,
            (LPSIZE) 0))
        {
            ASSERTGDI(FALSE, "MF3216: DoScaleWindowExt failed\n");
            return(FALSE);
        }
    }
    else
    {
        if (pLocalDC->map.iMapMode <= MM_MAX_FIXEDSCALE)
            return FALSE;


        // Get the window or viewport extents.
        xOrg = pLocalDC->map.iWex;
        yOrg = pLocalDC->map.iWey;

        xOrg = MulDiv(xOrg, Xnum, Xdenom);
        yOrg = MulDiv(yOrg, Ynum, Ydenom);
        if (!xOrg || !yOrg)
            return FALSE;

        // Set the window or viewport extents.
        pLocalDC->map.iWex = xOrg;
        pLocalDC->map.iWey = yOrg;
    }

    b = bComputeCompositeXform(pLocalDC) ;

    return (b) ;
}

/***************************************************************************
*  ScaleViewportExtEx  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoScaleViewportExt
(
 PLOCALDC pLocalDC,
 INT      Xnum,
 INT      Xdenom,
 INT      Ynum,
 INT      Ydenom
 )
{
    BOOL    b ;
    INT   xOrg, yOrg;

    if (pfnSetVirtualResolution != NULL)
    {
        // Set the viewport extent
        if (!ScaleViewportExtEx(pLocalDC->hdcHelper,
            Xnum, Xdenom,
            Ynum, Ydenom,
            (LPSIZE) 0))
        {
            ASSERTGDI(FALSE, "MF3216: DoScaleViewportExt failed\n");
            return(FALSE);
        }
    }
    else
    {
        if (pLocalDC->map.iMapMode <= MM_MAX_FIXEDSCALE)
            return FALSE;

        // Set the viewport extent
        xOrg = pLocalDC->map.iVex;
        yOrg = pLocalDC->map.iVey;

        xOrg = MulDiv(xOrg, Xnum, Xdenom);
        yOrg = MulDiv(yOrg, Ynum, Ydenom);
        if (!xOrg || !yOrg)
            return FALSE;

        // Set the window or viewport extents.
        pLocalDC->map.iVex = xOrg;
        pLocalDC->map.iVey = yOrg;
    }

    b = bComputeCompositeXform(pLocalDC) ;

    return (b) ;
}

/***************************************************************************
*  SetViewportExtEx  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoSetViewportExt
(
 PLOCALDC pLocalDC,
 int     x,
 int     y
 )
{
    BOOL    b ;

    if (pfnSetVirtualResolution != NULL)
    {
        // Set the viewport extent
        if (!SetViewportExtEx(pLocalDC->hdcHelper, x, y, (LPSIZE) 0))
        {
            ASSERTGDI(FALSE, "MF3216: DoSetViewportExt failed\n");
            return(FALSE);
        }
    }
    else
    {
        if (pLocalDC->map.iMapMode <= MM_MAX_FIXEDSCALE)
            return FALSE;

        if (!x || !y)
            return FALSE;

        // Set the window or viewport extents
        pLocalDC->map.iVex = x;
        pLocalDC->map.iVey = y;
    }

    b = bComputeCompositeXform(pLocalDC) ;

    return (b) ;
}

/***************************************************************************
*  SetViewportOrgEx  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoSetViewportOrg
(
 PLOCALDC pLocalDC,
 int     x,
 int     y
 )
{
    BOOL    b ;

    // Set the viewport origin

    if (pfnSetVirtualResolution != NULL)
    {
        if (!SetViewportOrgEx(pLocalDC->hdcHelper, x, y, (LPPOINT) 0))
        {
            ASSERTGDI(FALSE, "MF3216: DoSetViewportOrg failed\n");
            return(FALSE);
        }
    }
    else
    {
        pLocalDC->map.iVox = x;
        pLocalDC->map.iVoy = y;
    }

    b = bComputeCompositeXform(pLocalDC) ;

    return (b) ;
}

/***************************************************************************
*  SetWindowExtEx  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoSetWindowExt
(
 PLOCALDC pLocalDC,
 int     x,
 int     y
 )
{
    BOOL    b ;

    // Set the window extent

    if (pfnSetVirtualResolution != NULL)
    {
        if (!SetWindowExtEx(pLocalDC->hdcHelper, x, y, (LPSIZE) 0))
        {
            ASSERTGDI(FALSE, "MF3216: DoSetWindowExt failed\n");
            return(FALSE);
        }
    }
    else
    {
        if (pLocalDC->map.iMapMode <= MM_MAX_FIXEDSCALE)
            return FALSE;

        if (!x || !y)
            return FALSE;

        // Set the window or viewport extents
        pLocalDC->map.iWex = x;
        pLocalDC->map.iWey = y;
    }
    b = bComputeCompositeXform(pLocalDC) ;

    return (b) ;
}

/***************************************************************************
*  SetWindowOrgEx  - Win32 to Win16 Metafile Converter Entry Point
*
*  Since we will always record TWIPS in the Win16 metafile,
*  we will transform the WindowOrg from the current MapMode to
*  TWIPS. Then we will set the Dx and Dy elements of the Viewport
*  transformation matrix.
*
**************************************************************************/
BOOL WINAPI DoSetWindowOrg
(
 PLOCALDC pLocalDC,
 int     x,
 int     y
 )
{
    BOOL    b ;

    if (pfnSetVirtualResolution != NULL)
    {
        // Set the window origin

        if (!SetWindowOrgEx(pLocalDC->hdcHelper, x, y, (LPPOINT) 0))
        {
            ASSERTGDI(FALSE, "MF3216: DoSetWindowOrg failed\n");
            return(FALSE);
        }
    }
    else
    {
        // Set the window origin
        pLocalDC->map.iWox = x;
        pLocalDC->map.iWoy = y;
    }

    b = bComputeCompositeXform(pLocalDC) ;

    return (b) ;
}

/***************************************************************************
*  SetWorldTransform  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoSetWorldTransform
(
 PLOCALDC  pLocalDC,
 PXFORM  pxf
 )
{
    BOOL    b ;


    if (pfnSetVirtualResolution != NULL)
    {
        // Set the world xform in the helper DC.

        if (!SetWorldTransform(pLocalDC->hdcHelper, pxf))
        {
            ASSERTGDI(FALSE, "MF3216: DoSetWorldTransform failed\n");
            return(FALSE);
        }
    }
    else
    {
#ifdef DEBUG
        if (bRotationTest(pxf))
            WARNING("MF3216: DoSetWorldTransform() - World transform not simple.");
#endif // DEBUG
        pLocalDC->xformW = *pxf ;
    }

    b = bComputeCompositeXform(pLocalDC) ;

    return (b) ;
}

/***************************************************************************
*  ModifyWorldTransform  - Win32 to Win16 Metafile Converter Entry Point
**************************************************************************/
BOOL WINAPI DoModifyWorldTransform
(
 PLOCALDC pLocalDC,
 PXFORM   pxf,
 DWORD    imode
 )
{
    BOOL    b = TRUE;

    if (pfnSetVirtualResolution != NULL)
    {
        // Set the world xform in the helper DC.

        if (!ModifyWorldTransform(pLocalDC->hdcHelper, pxf, imode))
        {
            ASSERTGDI(FALSE, "MF3216: DoModifyWorldTransform failed\n");
            return(FALSE);
        }
    }
    else
    {
        switch (imode)
        {
        case MWT_IDENTITY:
            pLocalDC->xformW = xformIdentity;
            break;

        case MWT_LEFTMULTIPLY:
        case MWT_RIGHTMULTIPLY:
#ifdef DEBUG
            if (bRotationTest(pxf))
                WARNING("MF3216: DoSetWorldTransform() - World transform not simple.");
#endif // DEBUG

            if (imode == MWT_LEFTMULTIPLY)
                b &= bCombineTransform(&pLocalDC->xformW,
                pxf,
                &pLocalDC->xformW);
            else
                b &= bCombineTransform(&pLocalDC->xformW,
                &pLocalDC->xformW,
                pxf);
            break;

        default:
            break;
        }
    }

    b &= bComputeCompositeXform(pLocalDC) ;

    return (b) ;
}


/****************************************************************************
* bComputeCompositeXform - Compute the composite Xforms.
*
* The following transforms are re-computed:
*
*  xformRWorldToRDev
*  xformRDevToRWorld
*  xformRWorldToPPage
*
****************************************************************************/
BOOL bComputeCompositeXform(PLOCALDC pLocalDC)
{
    BOOL    b ;

    // Recompute xformRWorldToRDev.
    // Get the record-time world to record-time device xform
    // from the helper DC

    if(pfnSetVirtualResolution != NULL)
    {
        ASSERTGDI(pfnGetTransform != NULL, "gpmf3216: bComputeCompositeXform, missing function pointer") ;

        b = (pfnGetTransform)(pLocalDC->hdcHelper,
            XFORM_WORLD_TO_DEVICE,
            &pLocalDC->xformRWorldToRDev) ;
        if (b == FALSE)
        {
            RIPS("MF3216: bComputeCompositeXform - GetTransform (RWorld to RDev) failed \n") ;
               goto error_exit ;
        }

        // Recompute xformRDevToRWorld.
        // Get the record-time-device to record-time-world xform

        b = (pfnGetTransform)(pLocalDC->hdcHelper,
            XFORM_DEVICE_TO_WORLD,
            &pLocalDC->xformRDevToRWorld) ;
        if (b == FALSE)
        {
            RIPS("MF3216: bComputeCompositeXform - GetTransform (RDev To RWorld) failed \n") ;
            goto error_exit ;
        }
    }
    else
    {
        if (pLocalDC->map.iMapMode == MM_ISOTROPIC)
        {
            vMakeIso(pLocalDC);
        }
        b = bCalcPagexform(&pLocalDC->map, &pLocalDC->xformP);
        if (!b)
        {
            ASSERTGDI(0, "MF3216: bComputeCompositeExform() - bCalcPageExform() failed.");
            goto error_exit;
        }
        b = bCombineTransform(&pLocalDC->xformRWorldToRDev,
            &pLocalDC->xformW,
            &pLocalDC->xformP);
        if (!b)
        {
            ASSERTGDI(0, "MF3216: bComputeCompositeExform() - bCombineExform() failed.");
            goto error_exit;
        }

        b = bCombineTransform(&pLocalDC->xformRWorldToRDev,
            &pLocalDC->xformRWorldToRDev,
            &pLocalDC->xformDC);
        if (!b)
        {
            ASSERTGDI(0, "MF3216: bComputeCompositeExform() - bCombineExform() failed.");
            goto error_exit;
        }

        b = bInvertxform(&pLocalDC->xformRWorldToRDev,
            &pLocalDC->xformRDevToRWorld);
        if (!b)
        {
            ASSERTGDI(0, "MF3216: bComputeCompositeExform() - bInvertExform() failed.");
            goto error_exit;
        }
    }


    // Recompute xformRWorldToPPage.
    b = bCombineTransform(&pLocalDC->xformRWorldToPPage,
        &pLocalDC->xformRWorldToRDev,
        &pLocalDC->xformRDevToPPage);
    if (b == FALSE)
    {
        RIPS("MF3216: bComputeCompositeXform - bCombineTransform failed\n");
        goto error_exit ;
    }

    // Recompute transform flags.

    if (pLocalDC->xformRWorldToRDev.eM12 != (FLOAT) 0.0
        || pLocalDC->xformRWorldToRDev.eM21 != (FLOAT) 0.0)
    {
        ASSERTGDI(pfnGetTransform != NULL, "gpmf3216: bComputeCompositeXform - Win95 has strange XForm" ) ;
        pLocalDC->flags |= STRANGE_XFORM ;
    }
    else
        pLocalDC->flags &= ~STRANGE_XFORM ;

error_exit:
    return(b) ;
}

/***************************************************************************
*  bCoordinateOverflowTest - Test for 1 16 bit coordinate overflow
*
*  RETURNS:    FALSE if there is a coordinate overflow
*              TRUE   if  there is no overflow.
**************************************************************************/
BOOL bCoordinateOverflowTest(PLONG pCoordinates, INT nCount)
{
    BOOL    b ;
    INT     i, j ;

    b = TRUE ;
    for (i = 0 ; i < nCount ; i++)
    {

        j = pCoordinates[i] ;
        if (j < -32768 || j > 32767)
        {
            b = FALSE ;
            SetLastError(ERROR_ARITHMETIC_OVERFLOW);
            WARNING(("MF3216: bCoordinateOverflowTest, coordinate overflow\n"));
            break ;
        }
    }

    return(b) ;
}


/***************************************************************************
* vMakeIso
*
* !!! We don't know the aspect ratio of the record device.  It's not
* stored in the EMF.  NT's SetVirtualResolution() doesn't take an aspect
* ratio as a parameter so it either ignores it or leaves it the display
* aspect ratio.  We'll ignore it.
**************************************************************************/

void vMakeIso(PLOCALDC pLocalDC)
{
    int iScaledVex, iScaledVey, iAbsVey;

    iScaledVex = MulDiv(pLocalDC->map.iVex, pLocalDC->map.iWey,
        pLocalDC->map.iWex);
    iScaledVex = ABS(iScaledVex);
    iAbsVey = ABS(pLocalDC->map.iVey);

    if (iAbsVey >= iScaledVex)
    {
        if (pLocalDC->map.iVey > 0)
            pLocalDC->map.iVey =  iScaledVex;
        else
            pLocalDC->map.iVey = -iScaledVex;
    }
    else
    {
        iScaledVey = MulDiv(pLocalDC->map.iVey, pLocalDC->map.iWex,
            pLocalDC->map.iWey);
        iScaledVey = ABS(iScaledVey);
        if (pLocalDC->map.iVex > 0)
            pLocalDC->map.iVex =  iScaledVey;
        else
            pLocalDC->map.iVex = -iScaledVey;
    }
}

/***************************************************************************
* bInvertxform - Invert an XFORM
*
*    Assumes:    M = [m11  0    0]  so M' = [1/m11     0         0]
*                    [0    m22  0]          [0         1/m22     0]
*                    [m31  m32  1]          [-m31/m11  -m32/m22  1]
*
**************************************************************************/

BOOL bInvertxform(PXFORM pxformSrc, PXFORM pxformDest)
{
    FLOAT    fOne, f;
    BOOL     bRet;

    if( pxformSrc->eM11 == 0.0 || pxformSrc->eM22 == 0.0 )
    {
        return FALSE ;
    }

    pxformDest->eM11 = 1.0f / pxformSrc->eM11 ;
    pxformDest->eM22 = 1.0f / pxformSrc->eM22 ;
    pxformDest->eDx = -pxformSrc->eDx / pxformSrc->eM11 ;
    pxformDest->eDy = -pxformSrc->eDy / pxformSrc->eM22 ;

    return TRUE ;
}


/*---------------------------Public-Routine------------------------------*
* bCalcPageExform
*
*   Calculates the page transform given a mapping structure.
*
*               p11 = Vex / Wex
*               p22 = Vey / Wey
*               p31 = Vox - Wox * Vex / Wex
*               p32 = Voy - Woy * Vey / Wey
*
* Arguments:
*       IN      pmap    the MAPPING structure
*       OUT     pex     the destination EXFORM
* Returns:
*       EAX = 1 if success
* Error Returns:
*       EAX = 0 if overflow
* Calls:
*       ltoef, divff, mulff, eftofx
* History:
*       1 January 1994  -by-    Raymond E. Endres [rayen]
* Wrote it.
*-----------------------------------------------------------------------*/
BOOL bCalcPagexform(PMAPPING pMapping, PXFORM pxformDest)
{
    if(pMapping->iWex == 0 || pMapping->iWey == 0)
        return FALSE;

    pxformDest->eM11 = (FLOAT) pMapping->iVex / pMapping->iWex ;
    pxformDest->eM22 = (FLOAT) pMapping->iVey / pMapping->iWey ;
    pxformDest->eDx = (FLOAT) pMapping->iVox - pMapping->iWox * pxformDest->eM11 ;
    pxformDest->eDy = (FLOAT) pMapping->iVoy - pMapping->iWoy * pxformDest->eM22 ;

    return TRUE ;
}


BOOL bCombineTransform(
  LPXFORM lpxformResult,  // combined transformation
  CONST XFORM *lpxform1,  // first transformation
  CONST XFORM *lpxform2   // second transformation
)
{
    if (pfnSetVirtualResolution != NULL)
    {
        return CombineTransform(lpxformResult, lpxform1, lpxform2);
    }
    else
    {
        lpxformResult->eDx = lpxform1->eDx*lpxform2->eM11 + lpxform2->eDx ;
        lpxformResult->eDy = lpxform1->eDy*lpxform2->eM22 + lpxform2->eDy ;
        lpxformResult->eM11 = lpxform1->eM11 * lpxform2->eM11 ;
        lpxformResult->eM22 = lpxform1->eM22 * lpxform2->eM22 ;
    }

    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\gpmf3216\objects.c ===
/*****************************************************************************
 *
 * objects - Entry points for Win32 to Win 16 converter
 *
 * Date: 7/1/91
 * Author: Jeffrey Newman (c-jeffn)
 *
 * Copyright 1991 Microsoft Corp
 *
 *
 *  14-Jan-1992
 *  Jeffrey Newman
 *
 *  CR1:    14-Jan-1992 -   this entire comment and the design that it
 *                          specifies.
 *
 *  The Object system in mf3216.
 *
 *  Overview
 *
 *      The Win32 objects (represented by object handle indicies) must be
 *      mapped to Win16 objects (also represented by object handle indices).
 *      Win32 uses stock objects, Win16 does not.  MF3216 uses a scheme
 *      for lazy stock object creation.  Through lazy stock object creation
 *      no unused objects will be emitted into the Win16 metafile.
 *
 *      Objects in a Win16 metafile are maintained in an Object Table. The
 *      object table is not recorded in the Win16 metafile.  It is created at
 *      play-time. Each entry in the Win16-Object-Table is called a slot.
 *      Slots are allocated one per object.  If an object is deleted then the
 *      slot becomes available for the next object created.  The first object-
 *      slot, starting from 0, in a linear search, that is available will be
 *      used to hold the next create object request.
 *
 *      Objects in either a Win32 or a Win16 metafile are represented as an
 *      index into the Object Table.  Every object created must occupy
 *      the same slot at play-time that it would have occupied at record-time.
 *
 *      Win32 objects have an object ID (index in the handle table) recorded
 *      with them.  Win16 objects do not.
 *
 *  Data Structures
 *
 *      There are two primary data structures used in the translation of
 *      Win32 objects to Win16 objects.  Both of them are dynamically
 *      allocated arrays.  The size of these arrays are determined by
 *      estimating the number of objects required in the Win16 metafile from
 *      the size of the handle table used in the Win32 metafile.  The size of
 *      the handle table is recorded in the Win32 metafile header.
 *
 *      The data structure piW16ObjectHandleSlotStatus is used to represent
 *      the status of the Win16 handle table as it would appear at any point
 *      during the Win16 metafile playback process.  A slot is either in
 *      use or free.
 *
 *      The data structure piW32ToW16ObjectMap is a translation table
 *      from the Win32 object indicies to the Win16 object indicies.
 *      The position in the array (aka the index into the array) is the
 *      Win32 handle.  The value in this entry is the Win16 slot number
 *      for the handle.
 *
 *      The first 16 entries in piW32ToW16ObjectMap array are used for the
 *      stock objects.
 *
 *  Support Routines
 *
 *          bInitHandleTableManager
 *
 *              1]  Allocate memory for pW16ObjHndlSlotStatus and
 *                  piW32ToW16ObjectMap arrays.
 *
 *              2]  Initialize pW16ObjHndlSlotStatus and
 *                  piW32ToW16ObjectMap to empty and UNMAPPED respectively.
 *
 *              3]  Returns a TRUE if there were no problems with the
 *                  initialization, FALSE if anything went wrong.
 *
 *              4]  It is expected that this routie will be called once from
 *                  the entry level routine when translation is first started.
 *
 *          iNormalizeHandle
 *
 *              1]  The idea behind this routine is to isolate the handling
 *                  of stock object handles to one place.
 *
 *              2]  Input will be a Win32 handle index, either stock or a
 *                  standard object.
 *
 *              3]  Output will be the index of the entry in the
 *                  piW32ToW16ObjectMap table that corresponds to the W32
 *                  handle.  If an error is detected -1 is returned.
 *
 *              4]  All the stock objects will be between the range of 0
 *                  and LAST_STOCK, and all the non-stock objects will be
 *                  greater than LAST_STOCK.
 *
 *          iGetW16ObjectHandleSlot
 *
 *              1]  This routine searches the pW16ObjHndlSlotStatus array
 *                  looking for the first available open slot.
 *
 *              2]  Mark the slot found as to its intended use.
 *
 *              3]  Returns the first open slot if found, else return -1.
 *
 *              4]  In essence this routine mimics the actions of the
 *                  Win16 play-time handle allocation system, in either
 *                  Win3.0 or Win3.1
 *
 *              5]  We also keep track of the max object count here.
 *
 *          iAllocateW16Handle
 *
 *              1]  This routine actually does the handle allocation.
 *
 *              2]  It sets the entry in pW16ObjHndlSlotStatus array
 *                  for the slot allocated by iGetW16ObjectHandleSlot to
 *                  an "in-use" status (for the intended use).
 *
 *              3]  It returns a ihW16 (an index handle to the Win16 handle
 *                  table, aka the Win16 handle slot number).
 *
 *          iValidateHandle
 *
 *              1]  This routine does a lot more than validate a Win32 handle.
 *                  It does some limited error checking on the Win32 handle,
 *                  to make sure its within a reasonable range.  Then if a
 *                  Win16 handle table slot has already been allocated for
 *                  this Win32 handle it will return the Win16 handle that
 *                  was previously allocated.  Alternatively, if a Win16
 *                  handle has not been previously allocated for a Win32
 *                  STOCK handle it will allocate a W16 handle and return the
 *                  Win16 handle.  This function is called by FillRgn, FrameRgn
 *                  and SelectObject to allow lazy allocation of stock objects.
 *
 *              2]  Input is a Win32 handle, either a stock or a non-stock
 *                  handle.
 *
 *              3]  Output is a Win16 handle, this is the value in the
 *                  Win32-index of the piW32ToW16ObjectMap.  If a stock object
 *                  does not exist, it will create one.
 *
 *              4]  If there is an error a -1 is returned.
 *
 *      Doer Routines
 *
 *              All the Doers return a bool.  TRUE if everything went OK.
 *              FALSE if there were any problems.
 *
 *              NOTE: The Doers that create an object actually must do
 *              quite a bit of work to translate the object's prameters.
 *              This is in addition to managing the handle table.  The
 *              work outlined below just deals with the management of the
 *              handle table.
 *
 *          DoSelectObject
 *
 *              1]  For stock objects this is the workhorse routine.
 *
 *              2]  For normal, non-stock, objects this routine will verify
 *                  that an object has been created for this Win32 object-index.
 *                  Then it will emit a Win16SelectObject metafile record.
 *
 *              3]  For stock objects things get a little more complicated.
 *                  First this routine must make sure a Win16 object has been
 *                  created for this stock object.  If a Win16 object has not
 *                  been created yet, then it will be. After a Win16 object
 *                  is created a Win16SelectObject record will be emitted for
 *                  the object.
 *
 *          DoDeleteObject
 *
 *              1]  The object handle is checked for reasonable limits.
 *                  We will also make sure that the Win16 slot has a handle
 *                  allocated to it.  If it does not then we will return an
 *                  error.
 *
 *              2]  If this is a stock object we fail and return an error.
 *
 *              3]  If this is a non-stock object we emit a Win16DeleteObject
 *                  record.  Then we set pW16ObjHndlSlotStatus to
 *                  indicate that this slot is available.  We also set
 *                  piW32ToW16ObjectMap to -1 (UNMAPPED).
 *
 *          DoCreatePen
 *          DoExtCreatePen
 *          DoCreateBrushIndirect
 *          DoCreateMonoBrush
 *          DoCreateDIBPatternBrush
 *          DoExtCreateFont
 *
 *              1]  Make sure the Win32 handle is not already being used
 *                  for something else.  If it is return an error.
 *
 *              2]  Validate the handle for this Object.  This will return
 *                  a Win16 object table index (actually a slot number).
 *                  We really don't care what the slot number is as long
 *                  as we got one.  DoDeleteObject and DoSelectObject always
 *                  refer to handles by their Win32 object indicies, and there
 *                  is no place else where used.
 *
 *              3]  Emit a Win16CreateObject metafile record.
 *
 *
 *      Special Routines
 *
 *          bCommonRegionCode
 *          Need to list the bitblt routines that use handles also
 *
 *              1]  These routines just need to create objects in the Win16
 *                  metafile.  There are no corresponding objects in the Win32
 *                  metafile.
 *
 *              2]  Allocate a Win16 handle.
 *
 *              3]  Use the object as needed.  This includes emitting a
 *                  region or bitmap object into the Win16 metafile.
 *
 *              4]  De-allocate the object.  This include emitting a
 *                  DeleteObject record.
 *
 * CR1
 * Paths require the current pen to selected into the helperDC.
 * In order to keep track of create, select, & delete of the pen
 * object we will add an extra field to the W16ObjectHandleSlotStatus
 * array entries.  This new field will contain either a NULL handle
 * or a valid Win32 handle.  Currently only pens need to be selected
 * into the helper DC for paths, so they are the only objects whose
 * W32 handle field is not NULL.
 *
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define ABS(A)      ((A) < 0 ? (-(A)) : (A))

//  Stock objects                          Name              Stock
//                                                           Object
//                                                             ID

LOGBRUSH    albStock[] = {
    {BS_SOLID, 0x0FFFFFF, 0},           // White Brush          0
    {BS_SOLID, 0x0C0C0C0, 0},           // Ligh Grey Brush      1
    {BS_SOLID, 0x0808080, 0},           // Grey Brush           2
    {BS_SOLID, 0x0404040, 0},           // Dark Grey Brush      3
    {BS_SOLID, 0x0000000, 0},           // Black Brush          4
    {BS_HOLLOW, 0x0000000, 0}           // Hollow Brush         5
} ;

LOGPEN      alpnStock[] = {
    {PS_SOLID,  0, 0, 0x0FFFFFF},       // White Pen            6
    {PS_SOLID,  0, 0, 0x0000000},       // Black Pen            7
    {PS_NULL,   0, 0, 0x0FFFFFF}        // Null Pen             8
} ;

// Internal function prototypes.

BOOL bCreateStockObject(PLOCALDC pLocalDC, INT ihw32Norm) ;
BOOL bCreateStockFont(PLOCALDC pLocalDC, INT ihW32) ;

/***************************************************************************
 * bInitHandleTableManager - Init the Handle Table Manager.
 *
 *      1]  Allocate memory for pW16ObjHndlSlotStatus and
 *          piW32ToW16ObjectMap arrays.
 *
 *      2]  Initialize pW16ObjHndlSlotStatus and
 *          piW32ToW16ObjectMap to empty and UNMAPPED respectively.
 *
 *      3]  Returns a TRUE if there were no problems with the
 *          initialization, FALSE if anything went wrong.
 *
 *      4]  It is expected that this routie will be called once from
 *          the entry level routine when translation is first started.
 *
 **************************************************************************/
BOOL bInitHandleTableManager(PLOCALDC pLocalDC, PENHMETAHEADER pmf32header)
{
BOOL    b ;
UINT    i ;

        b = FALSE ;

        // The total number of handles required will be the stock handles
        // plus the handles used by the Win32 metafile plus one extra
        // for temporary brush used in opaque rectangle in textout.

        pLocalDC->cW32ToW16ObjectMap = pmf32header->nHandles + (STOCK_LAST + 1) + 1;

        // Allocate storage for the translation map.

        i = pLocalDC->cW32ToW16ObjectMap * sizeof(INT) ;
        pLocalDC->piW32ToW16ObjectMap = (PINT) LocalAlloc(LMEM_FIXED, i) ;
        if (pLocalDC->piW32ToW16ObjectMap == NULL)
            goto error_exit ;

        // Initialize the W32 to W16 object map to UNMAPPED (-1).
        // Since we never will have mapping to -1 we can test for
        // -1 in the map to make sure we are not double allocating a slot.

        for (i = 0 ; i < pLocalDC->cW32ToW16ObjectMap ; i++)
            pLocalDC->piW32ToW16ObjectMap[i] = UNMAPPED ;

        // Allocate storage for the slot status tables.
        // The number of Win16 object table slot may expand during conversion
        // due to temporary bitmaps and regions.  It is my educated guess
        // that we will never need more than 5 extra slots, because we
        // only use a slot for a very short time, then free it.  We are
        // allocating 256 extra slots in the name of robustness.
    // Note that the multi-format comment record may take up some
    // of these slots and increase the high water mark for object index.
    // We need to expand the table when required.

        pLocalDC->cW16ObjHndlSlotStatus = pLocalDC->cW32ToW16ObjectMap + 256 ;
        if (pLocalDC->cW16ObjHndlSlotStatus > (UINT) (WORD) MAXWORD)
            goto error_exit ;       // w16 handle index is only 16-bit

        i = pLocalDC->cW16ObjHndlSlotStatus * sizeof(W16OBJHNDLSLOTSTATUS) ;
        pLocalDC->pW16ObjHndlSlotStatus
        = (PW16OBJHNDLSLOTSTATUS) LocalAlloc(LMEM_FIXED, i) ;
        if (pLocalDC->pW16ObjHndlSlotStatus == NULL)
            goto error_exit ;

        // Initialize the W16ObjectHandleSlotStatus to a state where every
        // handle is available.

        for (i = 0 ; i < pLocalDC->cW16ObjHndlSlotStatus ; i++)
        {
            pLocalDC->pW16ObjHndlSlotStatus[i].use       = OPEN_AVAILABLE_SLOT ;
            pLocalDC->pW16ObjHndlSlotStatus[i].w32Handle = 0 ;
            pLocalDC->pW16ObjHndlSlotStatus[i].iXORPassCreation = NOTXORPASS ;
            pLocalDC->pW16ObjHndlSlotStatus[i].pbCreatRec = NULL ;
        }

    // Initialize the pW32hPal palette handle table.
    // This table is used to store the W32 palette handles created during
    // the conversion.

        pLocalDC->cW32hPal = pmf32header->nHandles;
    i = pLocalDC->cW32hPal * sizeof(HPALETTE);
        pLocalDC->pW32hPal = (HPALETTE *) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, i) ;
    if (pLocalDC->pW32hPal == NULL)
            goto error_exit ;

    b = TRUE;

error_exit:
    if (!b)
    {
            if (pLocalDC->piW32ToW16ObjectMap)
        {
        if (LocalFree(pLocalDC->piW32ToW16ObjectMap))
            ASSERTGDI(FALSE, "MF3216: LocalFree failed");
                pLocalDC->piW32ToW16ObjectMap = (PINT) NULL;
        }

        if (pLocalDC->pW16ObjHndlSlotStatus)
        {
            if (LocalFree(pLocalDC->pW16ObjHndlSlotStatus))
                ASSERTGDI(FALSE, "MF3216: LocalFree failed");
            pLocalDC->pW16ObjHndlSlotStatus = NULL;
        }
    }

    return(b) ;
}


/***************************************************************************
 * bDeleteW16Object - Delete a W16 Object.
 *
 *  This is the routine that is called to Delete a W16 Object that has
 *  no corresponding W32 object.  Region and Bitmaps are two examples.
 **************************************************************************/
BOOL bDeleteW16Object(PLOCALDC pLocalDC, INT ihW16)
{
BOOL    b ;

    ASSERTGDI
    (
            pLocalDC->pW16ObjHndlSlotStatus[ihW16].use != OPEN_AVAILABLE_SLOT,
        "MF3216: bDeleteW16Object, bad use value"
    );

        // Mark the W16 Slot just freed as available.

        pLocalDC->pW16ObjHndlSlotStatus[ihW16].use = OPEN_AVAILABLE_SLOT ;

        // Emit a Win16 DeleteOject record for the Object

        b = bEmitWin16DeleteObject(pLocalDC, LOWORD(ihW16)) ;

        return (b) ;
}


/***************************************************************************
 * iGetW16ObjectHandleSlot - return the first W16 open slot in the handle
 *                           table.
 *
 *      1]  This routine searches the pW16ObjHndlSlotStatus array
 *          looking for the first available open slot.
 *
 *      2]  Mark the slot found as to its intended use.
 *
 *      3]  Returns the first open slot if found, else return -1.
 *
 *      4]  In essence this routine mimics the actions of the
 *          Win16 play-time handle allocation system, in either
 *          Win3.0 or Win3.1
 *
 *      5]  We also keep track of the max object count here.
 *
 **************************************************************************/
INT iGetW16ObjectHandleSlot(PLOCALDC pLocalDC, INT iIntendedUse)
{
BOOL    b ;
UINT    i ;

        b = FALSE ;

        // Search for an available slot.

        for (i = 0 ; i < pLocalDC->cW16ObjHndlSlotStatus ; i++)
        {
            if (pLocalDC->pW16ObjHndlSlotStatus[i].use == OPEN_AVAILABLE_SLOT)
            {
                b = TRUE ;
                break ;
            }
        }

        // If a slot was found then mark its intended use.
        // Also set the W32 handle that may be associated with this
        // W16 handle to NULL. (Meaning no association at this time.)

        if (b)
        {
            ASSERTGDI(pLocalDC->pW16ObjHndlSlotStatus[i].w32Handle == 0,
            "MF3216: iGetW16ObjectHandleSlot: w32Handle is not 0");

            pLocalDC->pW16ObjHndlSlotStatus[i].use       = iIntendedUse ;
            pLocalDC->pW16ObjHndlSlotStatus[i].w32Handle = 0 ;
            pLocalDC->pW16ObjHndlSlotStatus[i].iXORPassCreation = pLocalDC->iXORPass ;
            pLocalDC->pW16ObjHndlSlotStatus[i].pbCreatRec = pLocalDC->pbRecord ;

        // Update the number of object counts.  This will be used
        // when we update the metafile header.

            if ((INT) i >= pLocalDC->nObjectHighWaterMark)
                pLocalDC->nObjectHighWaterMark = (INT) i;

            return((INT) i);
        }
        else
        {
            RIPS("MF3216: iGetW16ObjectHandleSlot, Slot not found\n") ;
            return(-1) ;
        }
}


/***************************************************************************
 * iNormalizeHandle
 *
 *  CR1 - this entire routine is part of the handle system redesign.
 *
 *     1]  The idea behind this routine is to isolate the handling
 *         of stock object handles to one place.
 *
 *     2]  Input will be a Win32 handle index, either stock or a
 *         standard object.
 *
 *     3]  Output will be the index of the entry in the
 *         piW32ToW16ObjectMap table that corresponds to the W32
 *         handle.  If an error is detected -1 is returned.
 *
 *     4]  All the stock objects will be between the range of 0
 *         and LAST_STOCK, and all the non-stock objects will be
 *         greater than LAST_STOCK.
 *
 **************************************************************************/
INT iNormalizeHandle(PLOCALDC pLocalDC, INT ihW32)
{
INT     ihW32Norm ;

        if (ihW32 & ENHMETA_STOCK_OBJECT)
        {
            ihW32Norm = ihW32 & ~ENHMETA_STOCK_OBJECT ;
            if ((UINT) ihW32Norm > STOCK_LAST)
            {
                RIPS("MF3216: iNormalizeHandle, bad stock object\n") ;
                ihW32Norm = -1 ;
            }
        }
        else
        {
            ihW32Norm = ihW32 + STOCK_LAST + 1 ;
            if ((UINT) ihW32Norm >= pLocalDC->cW32ToW16ObjectMap)
            {
                RIPS("MF3216: iNormalizeHandle, bad standard object\n") ;
                ihW32Norm = -1 ;
            }
        }

        return(ihW32Norm) ;
}


/***************************************************************************
 * iAllocateW16Handle
 *
 *  CR1 - this entire routine is part of the handle system redesign.
 *        It is to be called from the object creation routines.
 *
 *     1]  This routine actually does the handle allocation.
 *
 *     2]  It sets the entry in pW16ObjHndlSlotStatus array
 *         for the slot allocated by iGetW16ObjectHandleSlot to
 *         an "in-use" status (for the intended use).
 *
 *     3]  It returns a ihW16 (an index handle to the Win16 handle
 *         table, aka the Win16 handle slot number).
 *
 **************************************************************************/
INT iAllocateW16Handle(PLOCALDC pLocalDC, INT ihW32, INT iIntendedUse)
{
INT     ihW32Norm,
        ihW16 ;

        // Assume the worst, set up for a failed return code.

        ihW16 = -1 ;

        // Normalize the handle.

        ihW32Norm = iNormalizeHandle(pLocalDC, ihW32) ;
        if (ihW32Norm == -1)
            goto error_exit ;

        // Check for double allocation of a Win32 handle index.
        // If we find a double allocation, this would indicate an error
        // in the Win32 metafile.
        // Error out on this due to the possibility of
        // a brush being used for a bitmap, or some other wrong use of a handle.

        if (pLocalDC->piW32ToW16ObjectMap[ihW32Norm] != UNMAPPED)
        {
            RIPS("MF3216: iAllocateW16Handle, Double W32 handle allocation detected\n") ;
            goto error_exit ;
        }

        // Get a slot in the Win16 handle table.

        ihW16 = iGetW16ObjectHandleSlot(pLocalDC, iIntendedUse) ;
        if (ihW16 == -1)
            goto error_exit ;

        // Set the W32 to W16 slot mapping

        pLocalDC->piW32ToW16ObjectMap[ihW32Norm] = ihW16 ;

error_exit:
        return(ihW16) ;
}

/***************************************************************************
 * iValidateHandle
 *
 *  CR1 - this entire routine is part of the handle system redesign.
 *
 *     1]  This routine does a lot more than validate a Win32 handle.
 *         It does some limited error checking on the Win32 handle,
 *         to make sure its within a reasonable range.  Then if a
 *         Win16 handle table slot has already been allocated for
 *         this Win32 handle it will return the Win16 handle that
 *         was previously allocated.  Alternatively, if a Win16
 *         handle has not been previously allocated for a Win32
 *         STOCK handle it will allocate a W16 handle and return the
 *         Win16 handle.  This function is called by FillRgn, FrameRgn
 *         and SelectObject to allow lazy allocation of stock objects.
 *
 *     2]  Input is a Win32 handle, either a stock or a non-stock
 *         handle.
 *
 *     3]  Output is a Win16 handle, this is the value in the
 *         Win32-index of the piW32ToW16ObjectMap.  If a stock object
 *         does not exist, it will create one.
 *
 *     4]  If there is an error a -1 is returned.
 **************************************************************************/
INT iValidateHandle(PLOCALDC pLocalDC, INT ihW32)
{
INT     ihW32Norm,
        ihW16 ;

        // Assume the worst.

        ihW16 = -1 ;

        // NOTE: Normalizing the W32 handles takes care of checking
        // for a reasonable W32 handle value.

        ihW32Norm = iNormalizeHandle(pLocalDC, ihW32) ;
        if (ihW32Norm == -1)
            goto error_exit ;

        // Check the W32ToW16 map, to determine if this W32 handle has
        // already been allocated a W16 slot.

        ihW16 = pLocalDC->piW32ToW16ObjectMap[ihW32Norm] ;
        if (ihW16 == UNMAPPED)
        {
            // There is no mapping from W32 to W16.  This implies
            // that the object in question does not exist.  If this is
            // a stock object, then we will create the object at this time.
            // Alternatively, if this is a non-stock object then we have an
            // error condition.

            if ((DWORD) ihW32Norm <= STOCK_LAST)
            {
                if (bCreateStockObject(pLocalDC, ihW32))
                    ihW16 = pLocalDC->piW32ToW16ObjectMap[ihW32Norm] ;
        else
            ihW16 = -1 ;
            }
            else
            {
                RIPS("MF3216: iValidateHandle - Unmapped Standard Object\n") ;
            ihW16 = -1 ;
            }
        }

error_exit:
        return (ihW16) ;
}


/***************************************************************************
 *  DoDeleteObject  - Win32 to Win16 Metafile Converter Entry Point
 *
 *  CR1 - Most of this routine was rewritten to conform to the new
 *        objects management system.
 *
 *      1]  The object handle is checked for reasonable limits.
 *          We will also make sure that the Win16 slot has a handle
 *          allocated to it.  If it does not then we will return an
 *          error.
 *
 *      2]  If this is a stock object we fail and return an error.
 *
 *      3]  If this is a non-stock object we emit a Win16DeleteObject
 *          record.  Then we set pW16ObjHndlSlotStatus to
 *          indicate that this slot is available.  We also set
 *          piW32ToW16ObjectMap to -1 (UNMAPPED).
 *
 *      4]  If we are in the first pass of an XOR-ClipPath rendering
 *          then we verify if this object was created during this pass
 *          If the object wasn't created during this pass, we will need
 *          to recreate the object when we start the second pass so that
 *          any call to SelectObject will return with the proper object
 *          selected (GillesK)
 **************************************************************************/
BOOL WINAPI DoDeleteObject
(
PLOCALDC pLocalDC,
INT    ihObject
)
{
BOOL    b ;
INT     ihW16,
        ihW32Norm;

        // Assume the worst.

        b = FALSE ;

        // Normalize the W32 handle.

        ihW32Norm = iNormalizeHandle(pLocalDC, ihObject) ;
        if (ihW32Norm == -1)
            goto error_exit ;

        // Make sure we're not deleting a stock object.

        if ((DWORD) ihW32Norm <= STOCK_LAST)
        {
            PUTS("MF3216: DoDeleteObject, attempt to delete a stock object\n") ;
            return(TRUE);
        }

        // If this is a palette, then we do not delete the win16 object.
        // We do delete our local version of the palette.

    if (pLocalDC->pW32hPal && pLocalDC->pW32hPal[ihObject])
        {
        b = DeleteObject(pLocalDC->pW32hPal[ihObject]);
        pLocalDC->pW32hPal[ihObject] = 0;

            if (b == FALSE)
                RIPS("MF3216: DoDeleteObject - DeleteObject (hPalette) failed\n") ;
            return (b) ;
        }

        // Map the ihW32 to a ihW16 (object handle table slot).

        ihW16 = pLocalDC->piW32ToW16ObjectMap[ihW32Norm] ;
        if (ihW16 == UNMAPPED)
        {
            RIPS("MF3216: DoDeleteObject, attempt to delete a non-existent object\n");
            goto error_exit ;
        }

        // Make sure the object is one that we expect.
        // There is no region object or bitmap object in the enhanced metafiles.

        ASSERTGDI(pLocalDC->pW16ObjHndlSlotStatus[ihW16].use == REALIZED_BRUSH
           || pLocalDC->pW16ObjHndlSlotStatus[ihW16].use == REALIZED_PEN
           || pLocalDC->pW16ObjHndlSlotStatus[ihW16].use == REALIZED_FONT,
                 "MF3216: DoDeleteObject, Invalid Object Deletion\n") ;

        // If there was a Win32 handle associated with this Win16 handle
        // then the w32Handle field of the W16ObjHndlSlotStatus[ihW16]
        // entry in the handle slot status array will be non-null. If
        // it is non-null then we should delete the Win32 handle at this time.

        if (pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle != 0)
        {
            if (!DeleteObject(pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle))
            {
                ASSERTGDI(FALSE, "MF3216: DoDeleteObject, DeleteObject failed");
            }
            pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle = 0 ;
        }

        if( pLocalDC->iXORPass == DRAWXORPASS && pLocalDC->pW16ObjHndlSlotStatus[ihW16].iXORPassCreation != DRAWXORPASS )
        {
            // If we delete an object that was created before this pass
            // the we need to save the object creation record so that
            // we can recreate the object once this pass is over
            // We create a linked list of objects that we have to recreate.

            PW16RECREATIONSLOT pW16RecreationSlot = (PW16RECREATIONSLOT) LocalAlloc( LMEM_FIXED, sizeof( W16RECREATIONSLOT ) ) ;
            if( pW16RecreationSlot == NULL )
                goto error_exit ;

            pW16RecreationSlot->slot = ihW16 ;
            pW16RecreationSlot->pbCreatRec = pLocalDC->pW16ObjHndlSlotStatus[ihW16].pbCreatRec ;
            pW16RecreationSlot->pNext = pLocalDC->pW16RecreationSlot ;
            pLocalDC->pW16RecreationSlot = pW16RecreationSlot ;
        }

        // Mark the slot as available.
        // And set the map entry for the W32ToW16 map to unmapped.

        pLocalDC->pW16ObjHndlSlotStatus[ihW16].use = OPEN_AVAILABLE_SLOT ;
        pLocalDC->pW16ObjHndlSlotStatus[ihW16].pbCreatRec = NULL ;
        pLocalDC->piW32ToW16ObjectMap[ihW32Norm]   = UNMAPPED ;

        // Emit the delete drawing order.

        b = bEmitWin16DeleteObject(pLocalDC, LOWORD(ihW16)) ;

error_exit:
        return (b) ;
}

/***************************************************************************
 *  DoSelectObject  - Win32 to Win16 Metafile Converter Entry Point
 *
 *  CR1 - Major rewrite due to handle system redesign.
 *
 *  DoSelectObject
 *
 *      1]  For stock objects this is the workhorse routine.
 *
 *      2]  For normal, non-stock, objects this routine will verify
 *          that an object has been created for this Win32 object-index.
 *          Then it will emit a Win16SelectObject metafile record.
 *
 *      3]  For stock objects things get a little more complicated.
 *          First this routine must make sure a Win16 object has been
 *          created for this stock object.  If a Win16 object has not
 *          been created yet, then it will be. After a Win16 object
 *          is created a Win16SelectObject record will be emitted for
 *          the object.
 **************************************************************************/
BOOL WINAPI DoSelectObject
(
PLOCALDC pLocalDC,
LONG   ihObject
)
{
BOOL    b ;
INT     ihW16;

    // Assume the worst.

    b = FALSE ;

    // Make sure that the W16 object exists before we emit the
    // SelectObject record.  Stock objects may not have been created
    // and iValidateHandle will take care of creating them.

    ihW16 = iValidateHandle(pLocalDC, ihObject) ;
    if (ihW16 == -1)
        goto error_exit ;

    // Make sure the object is one that we expect.
    // There is no region object or bitmap object in the enhanced metafiles.

    ASSERTGDI(pLocalDC->pW16ObjHndlSlotStatus[ihW16].use == REALIZED_BRUSH
       || pLocalDC->pW16ObjHndlSlotStatus[ihW16].use == REALIZED_PEN
       || pLocalDC->pW16ObjHndlSlotStatus[ihW16].use == REALIZED_FONT,
             "MF3216: DoSelectObject, Invalid Object Deletion\n") ;

    // Remember the currently selected pen.  This is used in path and text.

    if (pLocalDC->pW16ObjHndlSlotStatus[ihW16].use == REALIZED_PEN)
        pLocalDC->lhpn32 = ihObject;

    // Remember the currently selected brush.  This is used in text.

    if (pLocalDC->pW16ObjHndlSlotStatus[ihW16].use == REALIZED_BRUSH)
        pLocalDC->lhbr32 = ihObject;

    // If there was a Win32 handle associated with this Win16 handle
    // then the w32Handle field of the W16ObjHndlSlotStatus[ihW16]
    // entry in the handle slot status array will be non-null. If
    // it is non-null then we should select the W32 object into the
    // helper DC at this time.

    if (pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle != 0)
        SelectObject(pLocalDC->hdcHelper,
         pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle) ;

    b = bEmitWin16SelectObject(pLocalDC, LOWORD(ihW16)) ;

error_exit:
    return(b) ;
}


/***************************************************************************
 * bCreateStockObject
 **************************************************************************/
BOOL bCreateStockObject(PLOCALDC pLocalDC, INT ihW32)
{
BOOL        b ;
INT         i ;

        ASSERTGDI((ihW32 & ENHMETA_STOCK_OBJECT) != 0,
        "MF3216: bCreateStockObject, invalid stock handle");

        switch (ihW32 & ~ENHMETA_STOCK_OBJECT)
        {
            case WHITE_BRUSH:
            case LTGRAY_BRUSH:
            case GRAY_BRUSH:
            case DKGRAY_BRUSH:
            case BLACK_BRUSH:
            case NULL_BRUSH:
                b = DoCreateBrushIndirect(pLocalDC, ihW32, &albStock[ihW32 & ~ENHMETA_STOCK_OBJECT]) ;
                break ;

            case WHITE_PEN:
            case BLACK_PEN:
            case NULL_PEN:
                i = (ihW32 & ~ENHMETA_STOCK_OBJECT) - WHITE_PEN ;
                b = DoCreatePen(pLocalDC, ihW32, (PLOGPEN) &alpnStock[i]) ;
                break ;


            case OEM_FIXED_FONT:
            case ANSI_FIXED_FONT:
            case ANSI_VAR_FONT:
            case SYSTEM_FONT:
            case DEVICE_DEFAULT_FONT:
            case SYSTEM_FIXED_FONT:
            case DEFAULT_GUI_FONT:
                b = bCreateStockFont(pLocalDC, ihW32) ;
                break ;

            case DEFAULT_PALETTE:
            default:
        // Logical palettes are handled in DoSelectPalette and should
        // not get here.

                RIPS("MF3216: bCreateStockObject - Invalid Stock Object\n") ;
                b =FALSE ;
                break ;
        }

        return (b) ;
}


/***************************************************************************
* bCreateStockFont
**************************************************************************/
BOOL bCreateStockFont(PLOCALDC pLocalDC, INT ihW32)
{
    BOOL     b ;
    INT      i ;
    LOGFONTA LogFontA ;
    HANDLE   hFont ;

    b = FALSE ;

    ASSERTGDI((ihW32 & ENHMETA_STOCK_OBJECT) != 0,
        "MF3216: bCreateStockObject, invalid stock handle");

    // Get a handle to this logfont.

    hFont = GetStockObject(ihW32 & ~ENHMETA_STOCK_OBJECT) ;
    if (hFont == (HANDLE) 0)
    {
        RIPS("MF3216: bCreateStockFont, GetStockObject (font) failed\n") ;
        goto error_exit ;
    }

    // Get the logfont data.  Assume we get at least one char in the
    // facename string.

    i = GetObjectA(hFont, sizeof(LOGFONTA), &LogFontA) ;
    if (i <= (INT) offsetof(LOGFONTA,lfFaceName[0]))
    {
        PUTS("MF3216: bCreateStockFont - GetObjectW failed\n") ;
        goto error_exit ;
    }

    // Zero out the remaining logfont structure.

    for ( ; i < sizeof(LOGFONTA); i++)
        ((PBYTE) &LogFontA)[i] = 0;

    // Create a LogFont for this stock font in the Win16 metafile.

    b = DoExtCreateFont(pLocalDC,
        ihW32,
        &LogFontA);
error_exit:
    return (b) ;
}


/***************************************************************************
 *  CreateBrushIndirect  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoCreateBrushIndirect
(
PLOCALDC    pLocalDC,
INT         ihBrush,
LPLOGBRUSH  lpLogBrush
)
{
WIN16LOGBRUSH Win16LogBrush ;
BOOL          b ;
INT           ihW16 ;
LOGBRUSH      LogBrush ;

        b = FALSE ;

// Only 3 brush styles are allowed.

    if (lpLogBrush->lbStyle != BS_SOLID
     && lpLogBrush->lbStyle != BS_HATCHED
     && lpLogBrush->lbStyle != BS_HOLLOW)
            goto error_exit ;

// Make a copy of the logical brush.

        LogBrush = *lpLogBrush;

// The first 6 hatched styles map directly from Win32 to Win16.
// The remaining hatched brushes are simulated using DIB pattern
// brushes.  Note that the background color of a hatched brush
// is the current background color but that of a DIB pattern brush
// is given at create time!  We will use the current background color
// in the DIB pattern brush when it is created.  As a result, the
// output of these brushes may look different!

        if (LogBrush.lbStyle == BS_HATCHED)
        {
        switch (LogBrush.lbHatch)
        {
        case HS_HORIZONTAL:
        case HS_VERTICAL:
        case HS_FDIAGONAL:
        case HS_BDIAGONAL:
        case HS_CROSS:
        case HS_DIAGCROSS:
                break;

        default:
                RIPS("MF3216: Unknown hatched pattern\n");
        LogBrush.lbStyle = BS_SOLID;
        break;
        }
        }

// Allocate the W16 handle.

        ihW16 = iAllocateW16Handle(pLocalDC, ihBrush, REALIZED_BRUSH);
        if (ihW16 == -1)
            goto error_exit ;

// Create the w32 brush and store it in the w16 slot table.
// This brush is needed by the helper DC for BitBlt simulations.

        pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle
        = CreateBrushIndirect(lpLogBrush) ;

        ASSERTGDI(pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle != 0,
        "MF3216: CreateBrushIndirect failed");

// Assign all the Win32 brush attributes to Win16 brush attributes.

        Win16LogBrush.lbStyle = (WORD) LogBrush.lbStyle ;
        Win16LogBrush.lbColor = LogBrush.lbColor ;
        Win16LogBrush.lbHatch = (SHORT) LogBrush.lbHatch ;

// Call the Win16 routine to emit the brush to the metafile.

        b = bEmitWin16CreateBrushIndirect(pLocalDC, &Win16LogBrush) ;

error_exit:
        return(b) ;
}


/******************************Public*Routine******************************\
* CreateMonoDib
*
* This is the same as CreateBitmap except that the bits are assumed
* to be DWORD aligned and that the scans start from the bottom of the bitmap.
*
* This routine is temporary until CreateDIBitmap supports monochrome bitmaps
*
* History:
*  Wed Jul 01 11:02:24 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

HBITMAP CreateMonoDib
(
    LPBITMAPINFO pbmi,
    CONST BYTE * pjBits,
    UINT     iUsage
)
{
    HBITMAP hbm;

    ASSERTGDI(pbmi->bmiHeader.biPlanes == 1, "CreateMonoDib: bad biPlanes value");
    ASSERTGDI(pbmi->bmiHeader.biBitCount == 1, "CreateMonoDib: bad biBitCount value");

    hbm = CreateBitmap((int)  pbmi->bmiHeader.biWidth,
               (int)  pbmi->bmiHeader.biHeight,
               (UINT) 1,
               (UINT) 1,
               (CONST VOID *) NULL);
    if (!hbm)
    return(hbm);

    SetDIBits((HDC) 0, hbm, 0, (UINT) pbmi->bmiHeader.biHeight,
          (CONST VOID *) pjBits, pbmi, iUsage);

    return(hbm);
}


/***************************************************************************
 *  CreateMonoBrush  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoCreateMonoBrush
(
PLOCALDC    pLocalDC,
DWORD       ihBrush,
PBITMAPINFO pBitmapInfo,
DWORD       cbBitmapInfo,
PBYTE       pBits,
DWORD       cbBits,
DWORD       iUsage
)
{
BOOL        b ;
INT         ihW16;
DWORD       ul ;
BYTE        pbmi[sizeof(BITMAPINFOHEADER) + 2 * sizeof(RGBQUAD)];
HBITMAP     hbm;

        b = FALSE ;

// Need to make a copy of the bitmap info header,  for a few reasons
//  1] the memory mapped file is write protected.
//  2] the iUsage may be (is) use palatte indicies, and we need
//     use RGB colors.

        ((PBITMAPINFO) pbmi)->bmiHeader = pBitmapInfo->bmiHeader;

// Need to make sure the iUsage is DIB_RGB_COLORS
// and the palette is initialized to Black and White.

        ul = 0 ;
        ((PBITMAPINFO) pbmi)->bmiColors[0] = (*((RGBQUAD *) &(ul))) ;

        ul = 0x00ffffff ;
        ((PBITMAPINFO) pbmi)->bmiColors[1] = (*((RGBQUAD *) &(ul))) ;

// Allocate the W16 handle.

        ihW16 = iAllocateW16Handle(pLocalDC, ihBrush, REALIZED_BRUSH);
        if (ihW16 == -1)
            goto error_exit ;

// Create the w32 brush and store it in the w16 slot table.
// This brush is needed by the helper DC for BitBlt simulations.

    if ((hbm = CreateMonoDib
           (
               pBitmapInfo,
               (CONST BYTE *) pBits,
               (UINT) iUsage
           )
        )
       )
    {
        pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle
        = CreatePatternBrush(hbm);

        if (!DeleteObject(hbm))
        ASSERTGDI(FALSE, "MF3216: DoCreateMonoBrush, DeleteObject failed");
    }

        ASSERTGDI(pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle != 0,
        "MF3216: CreatePatternBrush failed");

// Call the Win16 routine to emit the brush to the metafile.

        b = bEmitWin16CreateDIBPatternBrush(pLocalDC,
                                        (PBITMAPINFO) pbmi,
                                        sizeof(pbmi),
                                        pBits,
                                        cbBits,
                                        (WORD) DIB_RGB_COLORS,
                                        (WORD) BS_PATTERN  // Mono brush!
                       ) ;
error_exit:
        return(b) ;
}

/***************************************************************************
 *  CreateDIPatternBrush  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoCreateDIBPatternBrush
(
PLOCALDC    pLocalDC,
DWORD       ihBrush,
PBITMAPINFO pBitmapInfo,
DWORD       cbBitmapInfo,
PBYTE       pBits,
DWORD       cbBits,
DWORD       iUsage
)
{
BOOL    b;
INT     ihW16;
HBITMAP hbm;
PBYTE   pBits24;
DWORD   cbBits24;
BITMAPINFOHEADER bmih;

    hbm = (HBITMAP) 0;
    pBits24 = (PBYTE) NULL;
        b = FALSE ;

// Allocate the W16 handle.

        ihW16 = iAllocateW16Handle(pLocalDC, ihBrush, REALIZED_BRUSH);
        if (ihW16 == -1)
            goto error_exit ;

// Create the w32 brush and store it in the w16 slot table.
// We assume that the bitmap info is followed by the bits immediately,
// i.e. it is a packed dib.
// This brush is needed by the helper DC for BitBlt simulations.

        pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle
        = CreateDIBPatternBrushPt((LPVOID) pBitmapInfo, (UINT) iUsage);

        ASSERTGDI(pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle != 0,
        "MF3216: CreateDIBPatternBrushPt failed");

// We need to convert new bitmap info formats to the win3 formats.

    if (pBitmapInfo->bmiHeader.biPlanes != 1
     || pBitmapInfo->bmiHeader.biBitCount == 16
     || pBitmapInfo->bmiHeader.biBitCount == 32)
    {
        if (!(hbm = CreateDIBitmap(pLocalDC->hdcHelper,
                (LPBITMAPINFOHEADER) pBitmapInfo,
                CBM_INIT | CBM_CREATEDIB,
                pBits,
                (LPBITMAPINFO) pBitmapInfo,
                (UINT) iUsage)))
                goto error_exit ;

        bmih = *(PBITMAPINFOHEADER) pBitmapInfo;
        bmih.biPlanes       = 1;
        bmih.biBitCount     = 24;
        bmih.biCompression  = BI_RGB;
        bmih.biSizeImage    = 0;
        bmih.biClrUsed      = 0;
        bmih.biClrImportant = 0;

            cbBits24 = CJSCAN(bmih.biWidth,bmih.biPlanes,bmih.biBitCount)
                * ABS(bmih.biHeight);

        pBits24 = (LPBYTE) LocalAlloc(LMEM_FIXED, cbBits24);
        if (pBits24 == (LPBYTE) NULL)
            goto error_exit;

        // Get bitmap info and bits in 24bpp.

        if (!GetDIBits(pLocalDC->hdcHelper,
               hbm,
               0,
               (UINT) bmih.biHeight,
               pBits24,
               (LPBITMAPINFO) &bmih,
               DIB_RGB_COLORS))
            goto error_exit;

            b = bEmitWin16CreateDIBPatternBrush(pLocalDC,
                                        (PBITMAPINFO) &bmih,
                                        sizeof(bmih),
                                        pBits24,
                                        cbBits24,
                                        (WORD) DIB_RGB_COLORS,
                                        (WORD) BS_DIBPATTERN
                       ) ;
    }
    else
    {

// Call the Win16 routine to emit the brush to the metafile.

            b = bEmitWin16CreateDIBPatternBrush(pLocalDC,
                                        pBitmapInfo,
                                        cbBitmapInfo,
                                        pBits,
                                        cbBits,
                                        (WORD) iUsage,
                                        (WORD) BS_DIBPATTERN
                       ) ;
    }

error_exit:
    if (hbm)
        DeleteObject(hbm);
    if (pBits24)
        LocalFree((HANDLE) pBits24);
        return(b) ;
}


/***************************************************************************
 * CreatePen  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoCreatePen
(
PLOCALDC    pLocalDC,
INT         ihPen,
PLOGPEN     pLogPen
)
{
EXTLOGPEN   ExtLogPen ;
BOOL        b ;

        ExtLogPen.elpPenStyle   = PS_GEOMETRIC | pLogPen->lopnStyle ;
        ExtLogPen.elpWidth      = (UINT) pLogPen->lopnWidth.x ;
        ExtLogPen.elpBrushStyle = BS_SOLID ;
        ExtLogPen.elpColor      = pLogPen->lopnColor ;
        ExtLogPen.elpNumEntries = 0 ;
        // ExtLogPen.elpHatch   = 0 ;
        // ExtLogPen.elpStyleEntry[0] = 0;

        b = DoExtCreatePen(pLocalDC, ihPen, &ExtLogPen) ;

        return (b) ;
}

/***************************************************************************
 *  ExtCreatePen  - Win32 to Win16 Metafile Converter Entry Point
 **************************************************************************/
BOOL WINAPI DoExtCreatePen
(
PLOCALDC    pLocalDC,
INT         ihPen,
PEXTLOGPEN  pExtLogPen
)
{
BOOL        b ;
WORD        iStyle ;
POINTS      ptsWidth ;
INT         ihW16 ;
UINT        iPenStyle ;
POINTL      ptlWidth ;
COLORREF    crColor ;

    b = FALSE;

    // Get pen style.

    iPenStyle = pExtLogPen->elpPenStyle & PS_STYLE_MASK ;
    switch(iPenStyle)
    {
        case PS_SOLID:
        case PS_DASH:
        case PS_DOT:
        case PS_DASHDOT:
        case PS_DASHDOTDOT:
        case PS_NULL:
        case PS_INSIDEFRAME:
            break ;

        case PS_ALTERNATE:
            iPenStyle = PS_DOT ;
            break ;

        case PS_USERSTYLE:
        default:
            // CR1: default to solid.
            iPenStyle = PS_SOLID ;
            break ;
    }

    // Get pen color.

    switch (pExtLogPen->elpBrushStyle)
    {
    case BS_SOLID:
    case BS_HATCHED:
        crColor   = pExtLogPen->elpColor ;
    break;

    // If the extended pen contains a hollow brush, then
    // we will emit a NULL pen.
    case BS_NULL:    // BS_HOLLOW is the same as BS_NULL
        iPenStyle = PS_NULL ;
        crColor   = 0 ;
    break;

    // Win3.x does not support pens with bitmap patterns.
    // So we will just use solid pens here.  Since we do not
    // know what pen color to use, we choose the text color.
    case BS_PATTERN:
    case BS_DIBPATTERN:
    case BS_DIBPATTERNPT:
        default:
        crColor   =  pLocalDC->crTextColor ;
    break;
    }

    // Get pen width.
    // If this is a cosmetic pen then the width is 0.

    ptlWidth.y = 0 ;
    if ((pExtLogPen->elpPenStyle & PS_TYPE_MASK) == PS_COSMETIC)
        ptlWidth.x = 0 ;
    else
        ptlWidth.x = pExtLogPen->elpWidth ;

    // Allocate the W16 handle.

    ihW16 = iAllocateW16Handle(pLocalDC, ihPen, REALIZED_PEN);
    if (ihW16 == -1)
        goto error_exit ;

    // This is where we need to create a pen for helper DC.
    // We do not select it into the helper DC at this time.

    pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle
    = CreatePen((int) iPenStyle, ptlWidth.x, crColor) ;

    ASSERTGDI(pLocalDC->pW16ObjHndlSlotStatus[ihW16].w32Handle != 0,
    "MF3216: DoExtCreatePen, CreatePen failed");

    // Get pen width in play time page units.

    ptlWidth.x = (LONG) iMagnitudeXform(pLocalDC, (INT) ptlWidth.x, CX_MAG);

    // Set the Win16 pen attributes

    iStyle     = (WORD) iPenStyle  ;
    ptsWidth.x = (WORD) ptlWidth.x ;
    ptsWidth.y = (WORD) ptlWidth.y ;

    // Call the Win16 routine to emit the pen to the metafile.

    b = bEmitWin16CreatePen(pLocalDC, iStyle, &ptsWidth, crColor) ;

error_exit:
    return(b) ;
}


/***************************************************************************
 *  DoRemoveObjects  - Remove the objects that were created in the first
 *                     XOR pass
 **************************************************************************/

BOOL WINAPI DoRemoveObjects(
PLOCALDC pLocalDC
)
{
    BOOL b = TRUE ;
    UINT  i;
    INT   iNorm ;
    INT   ihW32Norm ;

    ASSERTGDI( pLocalDC->iXORPass == OBJECTRECREATION,
        "DoRemoveObject used with the wrong XOR Pass" ) ;

    // GillesK

    // We have to go through the list of 16-bit handles and delete
    // every single object that was created during this pass. This
    // is necessary to make sure that we have the exact same state
    // of objects when we restart the second pass so that no object
    // creation will fail and give wrong results.

    // Don't touch the stock objects
    for( i = STOCK_LAST + 1 ; i < pLocalDC->cW32ToW16ObjectMap ; i++ )
    {
        iNorm = pLocalDC->piW32ToW16ObjectMap[i] ;
        if( iNorm != UNMAPPED && pLocalDC->pW16ObjHndlSlotStatus[iNorm].iXORPassCreation == DRAWXORPASS )
        {

            // If there was a Win32 handle associated with this Win16 handle
            // then the w32Handle field of the W16ObjHndlSlotStatus[ihW16]
            // entry in the handle slot status array will be non-null. If
            // it is non-null then we should delete the Win32 handle at this time.

            b = DoDeleteObject( pLocalDC, i- ( STOCK_LAST + 1 ) ) ;
            if( !b )
                break ;
        }
    }

    return b ;
}


/***************************************************************************
 *  DoDeleteRecreationSlots  - Remove the recreation object slots because
 *                             they will not be used.
 **************************************************************************/

BOOL WINAPI DoDeleteRecreationSlots(
PLOCALDC pLocalDC
)
{
    BOOL b = TRUE ;

    while(pLocalDC->pW16RecreationSlot != NULL)
    {
        PW16RECREATIONSLOT l_pSlot = pLocalDC->pW16RecreationSlot ;
        pLocalDC->pW16RecreationSlot = pLocalDC->pW16RecreationSlot->pNext ;
        LocalFree(l_pSlot) ;
    }

    return b ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\precomp.hpp ===
#include <stddef.h>
#include <math.h>
#include <stdio.h>
#include <limits.h>
#include <stdlib.h>

#include <windows.h>

#include <objbase.h>
#include <ddraw.h>
#include <icm.h>

#include "..\Runtime\Runtime.hpp"

#include "imaging.h"
#include "comutils.hpp"
#include "imgutils.hpp"
#include "memstream.hpp"
#include "filestream.hpp"
#include "mmx.hpp"
#include "colorpal.hpp"
#include "decodedimg.hpp"
#include "bitmap.hpp"
#include "recolor.hpp"
#include "..\Render\FormatConverter.hpp"
#include "imgfactory.hpp"
#include "codecmgr.hpp"
#include "resample.hpp"
#include "imgrsrc.h"
#include "icmdll.hpp"

#include "..\common\monitors.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\gpmf3216\win16api.c ===
/****************************************************************************
 *
 *  Win16 Metafile emitter routines
 *
 *  Date:   7/19/91
 *  Author: Jeffrey Newman (c-jeffn)
 *
 ***************************************************************************/

#include "precomp.h"
#pragma hdrstop

WORD GetSizeOfColorTable (LPBITMAPINFOHEADER lpDIBInfo);

/****************************************************************************
 * bW16Emit0 - This is the base routine to emit a Win16 drawing order
 *             with 0 parameters.
 ***************************************************************************/
BOOL bW16Emit0
(
PLOCALDC   pLocalDC,
WORD       RecordID
)
{
BOOL        b;
METARECORD0 mr;

    mr.rdSize     = sizeof(mr) / sizeof(WORD);
    mr.rdFunction = RecordID;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * bW16Emit1 - This is the base routine to emit a Win16 drawing order
 *             with 1 parameter.
 ***************************************************************************/
BOOL bW16Emit1
(
PLOCALDC   pLocalDC,
WORD       RecordID,
WORD       x1
)
{
BOOL        b;
METARECORD1 mr;

    mr.rdSize     = sizeof(mr) / sizeof(WORD);
    mr.rdFunction = RecordID;
    mr.rdParm[0]  = x1;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * bW16Emit2 - This is the base routine to emit a Win16 drawing order
 *             with 2 parameters.
 ***************************************************************************/
BOOL bW16Emit2
(
PLOCALDC   pLocalDC,
WORD       RecordID,
WORD       x1,
WORD       x2
)
{
BOOL        b;
METARECORD2 mr;

    mr.rdSize     = sizeof(mr) / sizeof(WORD);
    mr.rdFunction = RecordID;
    mr.rdParm[0]  = x2;
    mr.rdParm[1]  = x1;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * bW16Emit4 - This is the base routine to emit a Win16 drawing order
 *             with 4 parameters.
 ***************************************************************************/
BOOL bW16Emit4
(
PLOCALDC   pLocalDC,
WORD       RecordID,
WORD       x1,
WORD       x2,
WORD       x3,
WORD       x4
)
{
BOOL        b;
METARECORD4 mr;

    mr.rdSize     = sizeof(mr) / sizeof(WORD);
    mr.rdFunction = RecordID;
    mr.rdParm[0]  = x4;
    mr.rdParm[1]  = x3;
    mr.rdParm[2]  = x2;
    mr.rdParm[3]  = x1;

    b = bEmit(pLocalDC, &mr, sizeof(mr));

    // Update the global max record size.

    vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

    return(b);
}

/****************************************************************************
 * bW16Emit5 - This is the base routine to emit a Win16 drawing order
 *             with 5 parameters.
 ***************************************************************************/
BOOL bW16Emit5
(
PLOCALDC   pLocalDC,
WORD       RecordID,
WORD       x1,
WORD       x2,
WORD       x3,
WORD       x4,
WORD       x5
)
{
BOOL        b;
METARECORD5 mr;

    mr.rdSize     = sizeof(mr) / sizeof(WORD);
    mr.rdFunction = RecordID;
    mr.rdParm[0]  = x5;
    mr.rdParm[1]  = x4;
    mr.rdParm[2]  = x3;
    mr.rdParm[3]  = x2;
    mr.rdParm[4]  = x1;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * bW16Emit6 - This is the base routine to emit a Win16 drawing order
 *             with 6 parameters.
 ***************************************************************************/
BOOL bW16Emit6
(
PLOCALDC   pLocalDC,
WORD       RecordID,
WORD       x1,
WORD       x2,
WORD       x3,
WORD       x4,
WORD       x5,
WORD       x6
)
{
BOOL        b;
METARECORD6 mr;

    mr.rdSize     = sizeof(mr) / sizeof(WORD);
    mr.rdFunction = RecordID;
    mr.rdParm[0]  = x6;
    mr.rdParm[1]  = x5;
    mr.rdParm[2]  = x4;
    mr.rdParm[3]  = x3;
    mr.rdParm[4]  = x2;
    mr.rdParm[5]  = x1;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * bW16Emit8 - This is the base routine to emit a Win16 drawing order
 *             with 8 parameters.
 ***************************************************************************/
BOOL bW16Emit8
(
PLOCALDC   pLocalDC,
WORD       RecordID,
WORD       x1,
WORD       x2,
WORD       x3,
WORD       x4,
WORD       x5,
WORD       x6,
WORD       x7,
WORD       x8
)
{
BOOL        b;
METARECORD8 mr;

    mr.rdSize     = sizeof(mr) / sizeof(WORD);
    mr.rdFunction = RecordID;
    mr.rdParm[0]  = x8;
    mr.rdParm[1]  = x7;
    mr.rdParm[2]  = x6;
    mr.rdParm[3]  = x5;
    mr.rdParm[4]  = x4;
    mr.rdParm[5]  = x3;
    mr.rdParm[6]  = x2;
    mr.rdParm[7]  = x1;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * bW16Emit9 - This is the base routine to emit a Win16 drawing order
 *             with 9 parameters.
 ***************************************************************************/
BOOL bW16Emit9
(
PLOCALDC   pLocalDC,
WORD       RecordID,
WORD       x1,
WORD       x2,
WORD       x3,
WORD       x4,
WORD       x5,
WORD       x6,
WORD       x7,
WORD       x8,
WORD       x9
)
{
BOOL        b;
METARECORD9 mr;

    mr.rdSize     = sizeof(mr) / sizeof(WORD);
    mr.rdFunction = RecordID;
    mr.rdParm[0]  = x9;
    mr.rdParm[1]  = x8;
    mr.rdParm[2]  = x7;
    mr.rdParm[3]  = x6;
    mr.rdParm[4]  = x5;
    mr.rdParm[5]  = x4;
    mr.rdParm[6]  = x3;
    mr.rdParm[7]  = x2;
    mr.rdParm[8]  = x1;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * CreateFontIndirect - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16CreateFontIndirect
(
PLOCALDC       pLocalDC,
LPWIN16LOGFONT lpWin16LogFont
)
{
BOOL    b;
METARECORD_CREATEFONTINDIRECT mr;

    mr.rdSize     = sizeof(mr) / sizeof(WORD);
    mr.rdFunction = META_CREATEFONTINDIRECT;
    mr.lf16       = *lpWin16LogFont;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * Polyline/Polygon - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16Poly
(
PLOCALDC pLocalDC,
LPPOINTS ppt,
SHORT    cpt,
WORD     metaType
)
{
BOOL    b ;
WORD    nSize ;
METARECORD_POLY mr;

        // Caculate the size of the points array

        nSize = (WORD) (cpt * sizeof(POINTS));

        // Build up the header of the Win16 poly record

    mr.rdSize     = (sizeof(mr) + nSize) / sizeof(WORD);
    mr.rdFunction = metaType;
    mr.cpt        = cpt;

        // Emit the Header, then if it succeds emit the points.

        b = bEmit(pLocalDC, &mr, sizeof(mr));
        if (b)
        {
            b = bEmit(pLocalDC, ppt, nSize);
        }

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * PolyPolygon - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16PolyPolygon
(
PLOCALDC pLocalDC,
PPOINTS  ppt,
PWORD    pcpt,
WORD     cpt,
WORD     ccpt
)
{
BOOL    b ;
WORD    nSize ;
METARECORD_POLYPOLYGON mr;

        nSize  = cpt * sizeof(POINTS);
        nSize += ccpt * sizeof(WORD);
        nSize += sizeof(mr);

        // Build up the header of the Win16 polyline record

    mr.rdSize     = nSize / sizeof(WORD);
    mr.rdFunction = META_POLYPOLYGON;
    mr.ccpt       = ccpt;

        // Emit the Header, then if it succeds emit the Point counts,
        // then if it succeds emit the points.

        b = bEmit(pLocalDC, &mr, sizeof(mr));
        if (b)
        {
            b = bEmit(pLocalDC, pcpt, ccpt * sizeof(WORD));
            if (b)
            {
                b = bEmit(pLocalDC, ppt, cpt * sizeof(POINTS));
            }

        }

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * StretchBlt - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16StretchBlt
(
  PLOCALDC pLocalDC,
  SHORT    x,
  SHORT    y,
  SHORT    cx,
  SHORT    cy,
  SHORT    xSrc,
  SHORT    ySrc,
  SHORT    cxSrc,
  SHORT    cySrc,
  DWORD    rop,
  PBITMAPINFO lpbmi,
  DWORD       cbbmi,
  PBYTE    lpBits,
  DWORD    cbBits
)
{
BOOL        b ;
DWORD       nSize ;
METARECORD_DIBSTRETCHBLT mr;
DWORD       clrUsed;
WORD        clrTableSize;
WORD        newClrTableSize;
PBITMAPINFO lpnewbmi;
DWORD       newcbbmi;

    // Need to make real sure the plane count is 1,
    // otherwise this is not a DIB.

    if (lpbmi->bmiHeader.biPlanes != 1)
    {
        RIPS("MF3216: bEmitWin16StretchBlt, Invalid biPlanes in DIB\n") ;
        return (FALSE) ;
    }

    lpnewbmi = NULL;
    newcbbmi = 0;
    // Some programs don't work well with ClrUsed so always fill the palette
    clrTableSize = GetSizeOfColorTable((LPBITMAPINFOHEADER)lpbmi);
    clrUsed = lpbmi->bmiHeader.biClrUsed;
    lpbmi->bmiHeader.biClrUsed = 0;
    newClrTableSize = GetSizeOfColorTable((LPBITMAPINFOHEADER)lpbmi);
    if (newClrTableSize != clrTableSize)
    {
        // It can happen that we are passed a color table bigger then we
        // expect. So only copy the size of the new colortable
        newcbbmi = lpbmi->bmiHeader.biSize + newClrTableSize;
        lpnewbmi = (PBITMAPINFO) LocalAlloc(LMEM_FIXED, newcbbmi);
        if (lpnewbmi != NULL)
        {
            // Copy the old header and fill the rest of the palette with 0
            memcpy((void*) lpnewbmi, (void*)lpbmi, min(cbbmi, newcbbmi));
            if (newcbbmi > cbbmi)
            {
                memset((void*) (((char*)lpnewbmi) + cbbmi), 0, newcbbmi - cbbmi);
            }
            lpbmi = lpnewbmi;
            cbbmi = newcbbmi;
        }

    }

    // Create the static portion of the
    // Win 3.0 StretchBlt metafile record.

    nSize = sizeof(mr) + cbbmi + cbBits;

    mr.rdSize     = nSize / sizeof(WORD);
    mr.rdFunction = META_DIBSTRETCHBLT;
    mr.rop        = rop;
    mr.cySrc      = cySrc;
    mr.cxSrc      = cxSrc;
    mr.ySrc       = ySrc;
    mr.xSrc       = xSrc;
    mr.cy         = cy;
    mr.cx         = cx;
    mr.y          = y;
    mr.x          = x;

    b = bEmit(pLocalDC, &mr, sizeof(mr));
    if (b)
    {
        // Emit the bitmap info

        b = bEmit(pLocalDC, lpbmi, cbbmi);
        if (b)
        {
            // Emit the actual bits, if any.
            b = bEmit(pLocalDC, lpBits, cbBits);
        }
    }

    // Update the global max record size.

    vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

    if (lpnewbmi != NULL)
    {
        LocalFree((HLOCAL) lpnewbmi);
    }

    return(b);
}

/****************************************************************************
 * ExtTextOut - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16ExtTextOut
(
PLOCALDC pLocalDC,
SHORT    x,
SHORT    y,
WORD     fwOpts,
PRECTS   prcts,
PSTR     ach,
SHORT    nCount,
PWORD    lpDx
)
{
BOOL    b ;
DWORD   i, nBaseRecord ;
WORD    awRecord[11] ;


        // Calculate the size of the record

        i = ((WORD) nCount + 1) / 2 * 2;   // i = size of string in bytes
    if (lpDx)
            i += (WORD) nCount * sizeof(WORD); // add in size of Dx vector
        i += sizeof(awRecord);             // add in size of basic record
        if (!(fwOpts & (ETO_OPAQUE | ETO_CLIPPED)))
            i -= sizeof(RECTS);            // adjust for a rectangle being present
        i /= sizeof(WORD) ;                // change to word count

        // Set the record size, type,
        // x & y position, character count, and options.

        awRecord[0] = LOWORD(i) ;
        awRecord[1] = HIWORD(i) ;
        awRecord[2] = META_EXTTEXTOUT ;
        awRecord[3] = y ;
        awRecord[4] = x ;
        awRecord[5] = nCount ;
        awRecord[6] = fwOpts ;

        // Only if there is a opaque / clipping rectangle present
        // do we copy it over, other wise it is nonexistent.
        // We need to adjust the size of the Record emitted based upon
        // the existence of the opaque / clipping rectangle.

        nBaseRecord = 7 * sizeof(WORD) ;
        if (fwOpts & (ETO_OPAQUE | ETO_CLIPPED))
        {
            awRecord[7] = prcts->left ;
            awRecord[8] = prcts->top ;
            awRecord[9] = prcts->right ;
            awRecord[10] = prcts->bottom ;

            nBaseRecord += 4 * sizeof(WORD) ;
        }

        // Emit the record.

        b = bEmit(pLocalDC, awRecord, nBaseRecord) ;
        if (b)
        {
            // Emit the character string.

            i = ((WORD) nCount + 1) / 2 * 2 ;
            b = bEmit(pLocalDC, ach, i) ;
            if (b)
            {
        if (lpDx)
        {
                    // Emit the intercharacter spacing array

                    i = (WORD) (nCount * sizeof(WORD)) ;
                    b = bEmit(pLocalDC, lpDx, i) ;
                }
            }
        }

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) awRecord) ;

        return(b) ;
}

/****************************************************************************
 * Create Region - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16CreateRegion
(
PLOCALDC pLocalDC,
DWORD    cbRgn,
PVOID    pRgn
)
{
BOOL        b;
METARECORD0 mr;

    mr.rdSize     = (sizeof(mr) + cbRgn) / sizeof(WORD);
    mr.rdFunction = META_CREATEREGION;

    // Emit the header.

        b = bEmit(pLocalDC, &mr, sizeof(mr));

    // Emit the region data.

    b = bEmit(pLocalDC, pRgn, cbRgn);

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * SetPaletteEntries - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16SetPaletteEntries
(
PLOCALDC       pLocalDC,
DWORD          iStart,
DWORD          cEntries,
LPPALETTEENTRY pPalEntries
)
{
BOOL    b ;
DWORD   cbPalEntries ;
METARECORD_SETPALENTRIES mr;

        cbPalEntries = cEntries * sizeof(PALETTEENTRY);

    mr.rdSize     = (sizeof(mr) + cbPalEntries) / sizeof(WORD);
    mr.rdFunction = META_SETPALENTRIES;
    mr.iStart     = (WORD) iStart;
    mr.cEntries   = (WORD) cEntries;

        // Emit the header.

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Emit the actual palette entries.

        b = bEmit(pLocalDC, pPalEntries, cbPalEntries) ;

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * CreatePalette - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16CreatePalette
(
PLOCALDC     pLocalDC,
LPLOGPALETTE lpLogPal
)
{
BOOL    b;
DWORD   cbLogPal;
METARECORD0 mr;

        cbLogPal  = sizeof(LOGPALETTE) - sizeof(PALETTEENTRY)
            + lpLogPal->palNumEntries * sizeof(PALETTEENTRY) ;

    mr.rdSize     = (sizeof(mr) + cbLogPal) / sizeof(WORD);
    mr.rdFunction = META_CREATEPALETTE;

        // Emit the header.

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Emit the actual logpalette.

        b = bEmit(pLocalDC, lpLogPal, cbLogPal);

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return (b) ;
}

/****************************************************************************
 * CreateBrushIndirect - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16CreateBrushIndirect
(
PLOCALDC        pLocalDC,
LPWIN16LOGBRUSH lpLogBrush16
)
{
BOOL    b;
METARECORD_CREATEBRUSHINDIRECT mr;

    mr.rdSize     = sizeof(mr) / sizeof(WORD);
    mr.rdFunction = META_CREATEBRUSHINDIRECT;
    mr.lb16       = *lpLogBrush16;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

/****************************************************************************
 * CreateDIPatternBrush - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16CreateDIBPatternBrush
(
PLOCALDC    pLocalDC,
PBITMAPINFO pBitmapInfo,
DWORD       cbBitmapInfo,
PBYTE       pBits,
DWORD       cbBits,
WORD        iUsage,
WORD        iType
)
{
BOOL    b ;
METARECORD_DIBCREATEPATTERNBRUSH mr;

    mr.rdSize     = (sizeof(mr) + cbBitmapInfo + cbBits + 1) / sizeof(WORD);
    mr.rdFunction = META_DIBCREATEPATTERNBRUSH;
    mr.iType      = iType;
    mr.iUsage     = iUsage;

// On NT, the packed DIB is dword aligned.  But on win3x, it is word aligned.
// Therefore, we emit the bitmap info followed by the bitmap bits in two
// separate stages.

        ASSERTGDI(cbBitmapInfo % 2 == 0,
        "MF3216: bEmitWin16CreateDIBPatternBrush, bad bitmap info size");

        // Emit the static portion of the record.

        b = bEmit(pLocalDC, &mr, sizeof(mr));
        if (b == FALSE)
            goto error_exit ;

        // Emit the bitmap info.

        b = bEmit(pLocalDC, pBitmapInfo, cbBitmapInfo) ;
        if (b == FALSE)
            goto error_exit ;

        // Emit the bitmap bits.

        b = bEmit(pLocalDC, pBits, (cbBits + 1) / sizeof(WORD) * sizeof(WORD)) ;

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

error_exit:
        return(b);
}

/****************************************************************************
 * CreatePen - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16CreatePen
(
PLOCALDC pLocalDC,
WORD     iPenStyle,
PPOINTS  pptsWidth,
COLORREF crColor
)
{
BOOL    b;
METARECORD_CREATEPENINDIRECT mr;

    mr.rdSize     = sizeof(mr) / sizeof(WORD);
    mr.rdFunction = META_CREATEPENINDIRECT;
    mr.lopn16.lopnStyle = iPenStyle;
    mr.lopn16.lopnWidth = *pptsWidth;
    mr.lopn16.lopnColor = crColor;

        b = bEmit(pLocalDC, &mr, sizeof(mr));

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}

//#if 0
/****************************************************************************
 * Escape - Win16 Metafile Emitter
 ***************************************************************************/
BOOL bEmitWin16Escape
(
PLOCALDC pLocalDC,
SHORT    wEscape,
SHORT    wCount,
LPSTR    lpInData,
LPSTR    lpOutData
)
{
BOOL    b ;
METARECORD_ESCAPE mr;

        NOTUSED(lpOutData) ;

        // Init the type & length field of the metafile record.
        // Then emit the header of the escape record to the Win16 metafile.

    mr.rdSize     = (sizeof(mr) + (WORD) wCount) / sizeof(WORD);
    mr.rdFunction = META_ESCAPE;
    mr.wEscape    = wEscape;
    mr.wCount     = (WORD) wCount;

        b = bEmit(pLocalDC, &mr, sizeof(mr));
        if (b)
        {
            // Emit the actual data.
            b = bEmit(pLocalDC, lpInData, (DWORD) (WORD) wCount) ;
        }

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) &mr);

        return(b);
}
//#endif // 0

/****************************************************************************
 * Escape - Win16 Metafile Emitter for enhanced metafile comment
 ***************************************************************************/
BOOL bEmitWin16EscapeEnhMetaFile
(
  PLOCALDC pLocalDC,
  PMETARECORD_ESCAPE pmfe,
  LPBYTE   lpEmfData
)
{
BOOL    b ;
PMETA_ESCAPE_ENHANCED_METAFILE pmfeEnhMF = (PMETA_ESCAPE_ENHANCED_METAFILE) pmfe;

        // Emit the header of the escape record to the Win16 metafile.

        b = bEmit(pLocalDC, (PVOID) pmfeEnhMF, sizeof(META_ESCAPE_ENHANCED_METAFILE));
        if (b)
        {
            // Emit the enhanced metafile data.
            b = bEmit(pLocalDC, lpEmfData, pmfeEnhMF->cbCurrent);
        }

        // Update the global max record size.

        vUpdateMaxRecord(pLocalDC, (PMETARECORD) pmfeEnhMF);

        return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\sources.inc ===
!ifndef GDIPROOT
GDIPROOT=$(ADVCORE_PATH)\gdiplus
!endif

!include $(GDIPROOT)\sources.inc

GDIPIMG=$(GDIPROOT)\engine\imaging
INCLUDES=$(INCLUDES);$(GDIPIMG)\api;$(GDIPROOT)\sdkinc;$(GDIPROOT)\privinc;..;.

MAJORCOMP=windows
MINORCOMP=gdiplus

CHICAGO_PRODUCT=1

## SubSystem must be 4.00 to load on Win95

SUBSYSTEM_VERSION=4.00

C_DEFINES=$(C_DEFINES) -DWINVER=0x0500

# The imaging code has 3 targets - IMAGING.DLL, GDIPLUS.DLL and GDIPSTAT.LIB
#
# All 3 link to the files listed in LIBIMAGINGLIBS,
# but only GDIPLUS.DLL and IMAGING.DLL link to the ones in IMAGINGLIBS.

LIBIMAGINGLIBS=\
    $(GDIPIMG)\bmp\$(O)\bmp.lib \
    $(GDIPIMG)\jpeg\lib\$(O)\jpeg.lib \
    $(GDIPIMG)\jpeg\libjpegmem\$(O)\jpegmem.lib \
    $(GDIPIMG)\gif\lib\$(O)\gif.lib \
    $(GDIPIMG)\gif\liblzw\$(O)\liblzw.lib \
    $(GDIPIMG)\png\lib\$(O)\png.lib \
    $(GDIPIMG)\emf\$(O)\emf.lib \
    $(GDIPIMG)\wmf\$(O)\wmf.lib \
    $(GDIPIMG)\off_tiff\lib\$(O)\tiff.lib \
    $(GDIPIMG)\off_tiff\libtiff\$(O)\libtiff.lib \
    $(GDIPIMG)\ico\$(O)\ico.lib \
    $(GDIPIMG)\api\$(O)\imageapi.lib

    
IMAGINGLIBS=\
    $(LIBIMAGINGLIBS) \
    $(GDIPIMG)\png\libpng\$(O)\libpng.lib \
    $(GDIPIMG)\png\zlib\$(O)\zlib.lib \
    $(GDIPIMG)\jpeg\libjpeg\lib\$(O)\jpegfull.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\api\basicops.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   basicops.cpp
*
* Abstract:
*
*   Implementation of IBasicImageOps interface
*
* Revision History:
*
*   05/10/1999 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Function Description:
*
*   Clone image property items from current object to the destination object
*
* Arguments:
*
*   dstBmp   --- [IN]Pointer to the destination GpMemoryBitmap object
*
* Return Value:
*
*   Status code
*
* Note:
*   This is a private method. So we don't need to do input parameter
*   validation since the caller should do this for us.
*
* Revision History:
*
*   09/08/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::ClonePropertyItems(
    IN GpMemoryBitmap* dstBmp
    )
{
    if ( PropertyNumOfItems < 1 )
    {
        // No property

        return S_OK;
    }

    // PropertyListHead and PropertyListTail are always uninitialized and
    // therefore we have to skip the first one and make the loop skip the 
    // last one.
    
    InternalPropertyItem*   pTemp = PropertyListHead.pNext;

    while ( pTemp->pNext != NULL )
    {
        // Add current item into the destination property item list
        
        if ( AddPropertyList(&(dstBmp->PropertyListTail),
                             pTemp->id,
                             pTemp->length,
                             pTemp->type,
                             pTemp->value) != S_OK )
        {
            WARNING(("MemBitmap::ClonePropertyItems-AddPropertyList() failed"));
            return E_FAIL;
        }
        
        pTemp = pTemp->pNext;
    }

    dstBmp->PropertyNumOfItems = PropertyNumOfItems;
    dstBmp->PropertyListSize = PropertyListSize;
    
    return S_OK;
}// ClonePropertyItems()

/**************************************************************************\
*
* Function Description:
*
*   Clone an area of the bitmap image
*
* Arguments:
*
*   rect - Specifies the image area to be cloned
*          NULL means the entire image
*   outbmp - Returns a pointer to the cloned bitmap image
*   bNeedCloneProperty--Flag caller passes in to indicate if this method
*                       should clone property or not
*
* Return Value:
*
*   Status code
*
* Note: if it is a partial clone, the caller should not ask cloning
*       property items. Otherwise, there will be inconsistency in the image
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::Clone(
    IN OPTIONAL const RECT* rect,
    OUT IBitmapImage** outbmp,
    BOOL    bNeedCloneProperty
    )
{
    ASSERT(IsValid());

    *outbmp = NULL;

    // Lock the current bitmap object and validate source rectangle

    GpLock lock(&objectLock);
    HRESULT hr;
    RECT area;
    GpMemoryBitmap* bmp;

    if (lock.LockFailed())
    {
        WARNING(("GpMemoryBitmap::Clone---Object busy"));
        hr = IMGERR_OBJECTBUSY;
    }
    else if (!ValidateImageArea(&area, rect))
    {
        WARNING(("GpMemoryBitmap::Clone---Invalid clone area"));
        hr = E_INVALIDARG;
    }
    else if ((bmp = new GpMemoryBitmap()) == NULL)
    {
        WARNING(("GpMemoryBitmap::Clone---Out of memory"));
        hr = E_OUTOFMEMORY;
    }
    else
    {
        UINT w = area.right - area.left;
        UINT h = area.bottom - area.top;
        RECT r = { 0, 0, w, h };
        BitmapData bmpdata;

        // Initialize the new bitmap image object

        hr = bmp->InitNewBitmap(w, h, PixelFormat);

        if (SUCCEEDED(hr))
        {
            // Copy pixel data from the current bitmap image object
            // to the new bitmap image object.

            bmp->GetBitmapAreaData(&r, &bmpdata);

            hr = InternalLockBits(&area,
                                  IMGLOCK_READ|IMGLOCK_USERINPUTBUF,
                                  PixelFormat,
                                  &bmpdata);

            if (SUCCEEDED(hr))
            {
                InternalUnlockBits(&r, &bmpdata);
            }
                
            // Clone color palettes, flags, etc.

            if (SUCCEEDED(hr))
            {
                // Copy DPI info.

                bmp->xdpi = this->xdpi;
                bmp->ydpi = this->ydpi;
                
                hr = bmp->CopyPaletteFlagsEtc(this);                
            }

            // Clone all the property items if there is any and the caller wants
            // to
            
            if ( SUCCEEDED(hr)
               &&(bNeedCloneProperty == TRUE)
               &&(PropertyNumOfItems > 0) )
            {
                hr = ClonePropertyItems(bmp);
            }
        }

        if (SUCCEEDED(hr))
        {
            *outbmp = bmp;
        }
        else
        {
            delete bmp;
        }
    }

    return hr;
}// Clone()


/**************************************************************************\
*
* Function Description:
*
*   Functions for flipping a scanline
*
* Arguments:
*
*   dst - Pointer to the destination scanline
*   src - Pointer to the source scanline
*   count - Number of pixels
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID _FlipXNone(BYTE* dst, const BYTE* src, UINT count)
{
    memcpy(dst, src, count);
}

BYTE byteRev[] = {0x0, 0x8, 0x4, 0xc,
                  0x2, 0xa, 0x6, 0xe,
                  0x1, 0x9, 0x5, 0xd,
                  0x3, 0xb, 0x7, 0xf};
// Given a byte as input, return the byte resulting from reversing the bits
// of the input byte.
BYTE ByteReverse (BYTE bIn)
{
    BYTE bOut;  // return value

    bOut =
        (byteRev[ (bIn & 0xf0) >> 4 ]) |
        (byteRev[ (bIn & 0x0f)] << 4) ;

    return bOut;
}

// these masks are used in the shift left phase of FlipX1bpp
BYTE maskLeft[]  = {0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f};
BYTE maskRight[] = {0xff, 0xfe, 0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x80};

VOID _FlipX1bpp(BYTE* dst, const BYTE* src, UINT count)
{
    UINT iByte; // byte within the scan line

    if (count == 0)
    {
        return;
    }

    // The algorithm for 1 bpp flip is:
    // 1. Reverse the order of the bytes in the scan line.
    // 2. Reverse the bits within each byte of the scan line.
    // 3. Shift the bits of the scan line to be aligned on the left.

    UINT numBytes = (count + 7) / 8;    // number of bytes in the scan line

    // Step 1
    for (iByte = 0; iByte < numBytes; iByte++)
    {
        dst[iByte] = src[numBytes - 1 - iByte];
    }

    // Step 2
    for (iByte = 0; iByte < numBytes; iByte++)
    {
        dst[iByte] = ByteReverse(dst[iByte]);
    }

    // Step 3
    UINT extraBits = count & 0x07;  // count mod 8
    BYTE maskL = maskLeft[extraBits];
    BYTE maskR = maskRight[extraBits];
    for (iByte = 0; iByte < numBytes - 1; iByte++)
    {
        dst[iByte] =
            ((dst[iByte]   & maskL) << (8 - extraBits)) |
            ((dst[iByte+1] & maskR) >> (extraBits)) ;
    }
    // last byte: iByte = numBytes-1
    dst[iByte] = ((dst[iByte]   & maskL) << (8 - extraBits));
}

VOID _FlipX4bpp(BYTE* dst, const BYTE* src, UINT count)
{
    // if the number of pixels in the scanline is odd, we have to deal with
    // nibbles across byte boundaries.
    if (count % 2)
    {
        BYTE temp;

        dst += (count / 2);

        // Handle the last dst byte
        *dst = *src & 0xf0;
        dst--;
        count--;
        // ASSERT: count is now even.
        while (count)
        {
            *dst = (*src & 0x0f) | (*(src+1) & 0xf0);
            src++;
            dst--;
            count -= 2;
        }
    }
    else
    {
        dst += (count / 2) - 1;

        // ASSERT: count is even.
        while (count)
        {
            *dst = *src;
            *dst = ((*dst & 0xf0) >> 4) | ((*dst & 0x0f) << 4);
            dst--;
            src++;
            count -= 2;
        }
    }
}

VOID _FlipX8bpp(BYTE* dst, const BYTE* src, UINT count)
{
    dst += count;

    while (count--)
        *--dst = *src++;
}

VOID _FlipX16bpp(BYTE* dst, const BYTE* src, UINT count)
{
    WORD* d = (WORD*) dst;
    const WORD* s = (const WORD*) src;

    d += count;

    while (count--)
        *--d = *s++;
}

VOID _FlipX24bpp(BYTE* dst, const BYTE* src, UINT count)
{
    dst += 3 * (count-1);

    while (count--)
    {
        dst[0] = src[0];
        dst[1] = src[1];
        dst[2] = src[2];

        src += 3;
        dst -= 3;
    }
}

VOID _FlipX32bpp(BYTE* dst, const BYTE* src, UINT count)
{
    DWORD* d = (DWORD*) dst;
    const DWORD* s = (const DWORD*) src;

    d += count;

    while (count--)
        *--d = *s++;
}

/**************************************************************************\
*
* Function Description:
*
*   Flip a 48 BPP bitmap horizontally
*
* Arguments:
*
*   dst ----------- Pointer to destination image data
*   src ----------- Pointer to source image data
*   count --------- Number of pixels in a line
*
* Return Value:
*
*   NONE
*
* Revision History:
*
*   10/10/2000 minliu
*       Wrote it.
*
\**************************************************************************/

VOID
_FlipX48bpp(
    BYTE* dst,
    const BYTE* src,
    UINT count
    )
{
    // dst pointer points to the last pixel in the line

    dst += 6 * (count - 1);

    // Loop through each pixel in this line

    while (count--)
    {
        GpMemcpy(dst, src, 6);

        // Each pixel takes 6 bytes. Move to next pixel. src move left to right
        // and dst move right to left

        src += 6;
        dst -= 6;
    }
}// _FlipX48bpp()

/**************************************************************************\
*
* Function Description:
*
*   Flip a 64 BPP bitmap horizontally
*
* Arguments:
*
*   dst ----------- Pointer to destination image data
*   src ----------- Pointer to source image data
*   count --------- Number of pixels in a line
*
* Return Value:
*
*   NONE
*
* Revision History:
*
*   10/10/2000 minliu
*       Wrote it.
*
\**************************************************************************/

VOID
_FlipX64bpp(
    BYTE* dst,
    const BYTE* src,
    UINT count
    )
{
    // dst pointer points to the last pixel in the line
    
    dst += 8 * (count - 1);

    // Loop through each pixel in this line
    
    while (count--)
    {
        GpMemcpy(dst, src, 8);

        // Each pixel takes 8 bytes. Move to next pixel. src move left to right
        // and dst move right to left
        
        src += 8;
        dst -= 8;
    }
}// _FlipX64bpp()

/**************************************************************************\
*
* Function Description:
*
*   Flip the bitmap image in x- and/or y-direction
*
* Arguments:
*
*   flipX - Whether to flip horizontally
*   flipY - Whether to flip vertically
*   outbmp - Returns a pointer to the flipped bitmap image
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::Flip(
    IN BOOL flipX,
    IN BOOL flipY,
    OUT IBitmapImage** outbmp
    )
{
    // If no flipping is involved, just call Clone (including the property)

    if ( !flipX && !flipY )
    {
        return this->Clone(NULL, outbmp, TRUE);
    }

    ASSERT(IsValid());

    *outbmp = NULL;

    // Lock the current bitmap object
    // and validate source rectangle

    GpLock lock(&objectLock);
    HRESULT hr;
    GpMemoryBitmap* bmp = NULL;

    if (lock.LockFailed())
    {
        hr = IMGERR_OBJECTBUSY;
    }
    else if ((bmp = new GpMemoryBitmap()) == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = bmp->InitNewBitmap(Width, Height, PixelFormat);

        if (FAILED(hr))
        {
            goto exitFlip;
        }

        UINT pixsize = GetPixelFormatSize(PixelFormat);
        UINT count = Width;
        VOID (*flipxProc)(BYTE*, const BYTE*, UINT);

        if (!flipX)
        {
            count = (Width * pixsize + 7) / 8;
            flipxProc = _FlipXNone;
        }
        else switch (pixsize)
        {
        case 1:
            flipxProc = _FlipX1bpp;
            break;

        case 4:
            flipxProc = _FlipX4bpp;
            break;

        case 8:
            flipxProc = _FlipX8bpp;
            break;

        case 16:
            flipxProc = _FlipX16bpp;
            break;

        case 24:
            flipxProc = _FlipX24bpp;
            break;

        case 32:
            flipxProc = _FlipX32bpp;
            break;

        case 48:
            flipxProc = _FlipX48bpp;
            break;

        case 64:
            flipxProc = _FlipX64bpp;
            break;

        default:
            WARNING(("Flip: pixel format not yet supported"));

            hr = E_NOTIMPL;
            goto exitFlip;
        }

        // Do the flipping

        const BYTE* src = (const BYTE*) this->Scan0;
        BYTE* dst = (BYTE*) bmp->Scan0;
        INT dstinc = bmp->Stride;

        if (flipY)
        {
            dst += (Height - 1) * dstinc;
            dstinc = -dstinc;
        }

        for (UINT y = 0; y < Height; y++ )
        {
            flipxProc(dst, src, count);
            src += this->Stride;
            dst += dstinc;
        }

        // Clone color palettes, flags, etc.

        // Copy DPI info.

        bmp->xdpi = this->xdpi;
        bmp->ydpi = this->ydpi;
        
        hr = bmp->CopyPaletteFlagsEtc(this);
    }

exitFlip:

    if ( SUCCEEDED(hr) )
    {
        *outbmp = bmp;
    }
    else
    {
        delete bmp;
    }

    return hr;
}// Flip()

/**************************************************************************\
*
* Function Description:
*
*   Resize the bitmap image
*
* Arguments:
*
*   newWidth - Specifies the new bitmap width
*   newHeight - Specifies the new bitmap height
*   pixfmt - Specifies the new bitmap pixel format
*   hints - Specifies which interpolation method to use
*   outbmp - Returns a pointer to the resized bitmap image
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::Resize(
    IN UINT newWidth,
    IN UINT newHeight,
    IN PixelFormatID pixfmt,
    IN InterpolationHint hints,
    OUT IBitmapImage** outbmp
    )
{
    ASSERT(IsValid());

    *outbmp = NULL;

    // Validate input parameters

    if (newWidth == 0 || newHeight == 0)
        return E_INVALIDARG;

    HRESULT hr;
    GpMemoryBitmap* bmp;

    hr = GpMemoryBitmap::CreateFromImage(
                this,
                newWidth,
                newHeight,
                pixfmt,
                hints,
                &bmp);

    if (SUCCEEDED(hr))
        *outbmp = bmp;
    
    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Functions for rotating bitmap 90 degrees or 270 degrees
*
* Arguments:
*
*   dst - Destination bitmap image data
*   src - Source bitmap image data
*   Sinc - direction to increment the source within a scanline (+1 or -1)
*   sinc - direction and amount to increment the source per scanline
*
*   For a rotation of 90 degrees, src should be set to the beginning of the last
*   scanline, Sinc should be set to +1, and sinc should be set to -Stride of a src scanline.
*
*   For a rotation of 270 degrees, src should be set to the beginning of scanline 0,
*   Sinc should be set to -1, and sinc should be set to +Stride of a src scanline.
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

#define _ROTATETMPL(name, T)                                \
                                                            \
VOID                                                        \
name(                                                       \
    BitmapData* dst,                                        \
    const BYTE UNALIGNED* src,                              \
    INT Sinc,                                               \
    INT sinc                                                \
    )                                                       \
{                                                           \
    T* D = (T*) dst->Scan0;                                 \
    const T* S = (const T*) src;                            \
    UINT y = dst->Height;                                   \
    INT Dinc = dst->Stride / sizeof(T);                     \
                                                            \
    sinc /= sizeof(T);                                      \
                                                            \
    if (Sinc < 0)                                           \
        S += (y - 1);                                       \
                                                            \
    while (y--)                                             \
    {                                                       \
        T* d = D;                                           \
        const T* s = S;                                     \
        UINT x = dst->Width;                                \
                                                            \
        while (x--)                                         \
        {                                                   \
            *d++ = *s;                                      \
            s += sinc;                                      \
        }                                                   \
                                                            \
        D += Dinc;                                          \
        S += Sinc;                                          \
    }                                                       \
}

_ROTATETMPL(_Rotate8bpp, BYTE)
_ROTATETMPL(_Rotate16bpp, WORD)
_ROTATETMPL(_Rotate32bpp, DWORD)


VOID
_Rotate1bpp(
    BitmapData* dst,
    const BYTE UNALIGNED* src,
    INT Sinc,
    INT sinc
    )
{

    UINT iAngle = 0;
    BYTE UNALIGNED* dstRowTemp = static_cast<BYTE UNALIGNED*>(dst->Scan0);
    BYTE UNALIGNED* dstColTemp = static_cast<BYTE UNALIGNED*>(dst->Scan0);
    UINT dstY = dst->Height;    // number of destination rows we need to output
    UINT dstX = dst->Width / 8;
    UINT extraDstRowBits = dst->Width % 8;
    UINT dstRow = 0;        // the destination row we are working on
    UINT dstColByte = 0;    // the byte within the destination row we are working on
    BYTE UNALIGNED* topSrc;       // the top of the source bitmap
    INT srcStride = abs(sinc);
    UINT srcRow;    // which source row we are reading
    UINT srcByte;   // which byte within the source row we are reading
    UINT srcBit;    // which bit within the source byte we are reading

    if (Sinc == 1)
    {
        iAngle = 90;
    }
    else
    {
        ASSERT (Sinc == -1);
        iAngle = 270;
    }

    topSrc = const_cast<BYTE UNALIGNED*>(src);
    topSrc = (iAngle == 270) ? topSrc : (topSrc + sinc * ((INT)dst->Width - 1));

    // This code is pretty brute force, but it is fairly simple.
    // We should change the algorithm if performance is a problem.
    // The algorithm is: for each destination byte (starting at the upper
    // left corner of the destination and moving left to right, top to bottom),
    // grab the appropriate bytes from the source.  To avoid accessing memory
    // out of bounds of the source, we need to handle the last x mod 8 bits
    // at the end of the destination row.
    if (iAngle == 90)
    {
        for (dstRow = 0; dstRow < dstY; dstRow++)
        {
            srcByte = dstRow / 8;   // byte within the source row
            srcBit = 7 - (dstRow & 0x07);     // which source bit we need to mask
            for (dstColByte = 0; dstColByte < dstX; dstColByte++)
            {
                srcRow = (dst->Width - 1) - (dstColByte * 8);   // the first source row corresponding to the dest byte
                *dstColTemp =
                    (((topSrc[(srcRow - 0) * srcStride + srcByte] & (1 << srcBit)) >> srcBit) << 7) |
                    (((topSrc[(srcRow - 1) * srcStride + srcByte] & (1 << srcBit)) >> srcBit) << 6) |
                    (((topSrc[(srcRow - 2) * srcStride + srcByte] & (1 << srcBit)) >> srcBit) << 5) |
                    (((topSrc[(srcRow - 3) * srcStride + srcByte] & (1 << srcBit)) >> srcBit) << 4) |
                    (((topSrc[(srcRow - 4) * srcStride + srcByte] & (1 << srcBit)) >> srcBit) << 3) |
                    (((topSrc[(srcRow - 5) * srcStride + srcByte] & (1 << srcBit)) >> srcBit) << 2) |
                    (((topSrc[(srcRow - 6) * srcStride + srcByte] & (1 << srcBit)) >> srcBit) << 1) |
                    (((topSrc[(srcRow - 7) * srcStride + srcByte] & (1 << srcBit)) >> srcBit) << 0)
                    ;
                dstColTemp++;
            }
            // Handle the last few bits on the row
            // ASSERT: dstColTemp is pointing to the last byte on the destination row
            if (extraDstRowBits)
            {
                UINT extraBit;
                *dstColTemp = 0;
                srcRow = (dst->Width - 1) - (dstColByte * 8);    // the first source row corresponding to the dest byte
                for (extraBit = 0 ; extraBit < extraDstRowBits; extraBit++)
                {
                    *dstColTemp |=
                        (((topSrc[(srcRow - extraBit) * srcStride + srcByte] & (1 << srcBit)) >> srcBit) << (7 - extraBit))
                        ;
                }
            }
            dstRowTemp += dst->Stride;
            dstColTemp = dstRowTemp;
        }
    }
    else
    {
        ASSERT (iAngle == 270);
        for (dstRow = 0; dstRow < dstY; dstRow++)
        {
            srcByte =  ((dstY - 1) - dstRow) / 8;   // byte within the source row
            srcBit = 7 - (((dstY - 1) - dstRow) & 0x07);    // which source bit we need to mask
            for (dstColByte = 0; dstColByte < dstX; dstColByte++)
            {
                srcRow = dstColByte * 8;    // the first source row corresponding to the dest byte
                *dstColTemp =
                    (((topSrc[(srcRow + 0) * srcStride + srcByte] & (1 << srcBit)) >> srcBit) << 7) |
                    (((topSrc[(srcRow + 1) * srcStride + srcByte] & (1 << srcBit)) >> srcBit) << 6) |
                    (((topSrc[(srcRow + 2) * srcStride + srcByte] & (1 << srcBit)) >> srcBit) << 5) |
                    (((topSrc[(srcRow + 3) * srcStride + srcByte] & (1 << srcBit)) >> srcBit) << 4) |
                    (((topSrc[(srcRow + 4) * srcStride + srcByte] & (1 << srcBit)) >> srcBit) << 3) |
                    (((topSrc[(srcRow + 5) * srcStride + srcByte] & (1 << srcBit)) >> srcBit) << 2) |
                    (((topSrc[(srcRow + 6) * srcStride + srcByte] & (1 << srcBit)) >> srcBit) << 1) |
                    (((topSrc[(srcRow + 7) * srcStride + srcByte] & (1 << srcBit)) >> srcBit) << 0)
                    ;
                dstColTemp++;
            }
            // Handle the last few bits on the row
            // ASSERT: dstColTemp is pointing to the last byte on the destination row
            if (extraDstRowBits)
            {
                UINT extraBit;
                *dstColTemp = 0;
                srcRow = dstColByte * 8;    // the first source row corresponding to the dest byte
                for (extraBit = 0 ; extraBit < extraDstRowBits; extraBit++)
                {
                    *dstColTemp |=
                        (((topSrc[(srcRow + extraBit) * srcStride + srcByte] & (1 << srcBit)) >> srcBit) << (7 - extraBit))
                        ;
                }
            }
            dstRowTemp += dst->Stride;
            dstColTemp = dstRowTemp;
        }
    }

}


VOID
_Rotate4bpp(
    BitmapData* dst,
    const BYTE UNALIGNED* src,
    INT Sinc,
    INT sinc
    )
{
    const BYTE* tempSrc;
    BYTE UNALIGNED* Dst;
    UINT dstY = dst->Height;
    UINT dstX;  // used to hold the current pixel of the dst;
    BOOL bOddPixelsInScanline = (dstY % 2);
    UINT iAngle = (Sinc > 0) ? 90 : 270;

    // if the number of pixels in a src scanline is odd, handle the last
    // src nibble separately.
    if (bOddPixelsInScanline)
    {
        tempSrc = src + (dstY / 2);  // point to the byte that contains the "odd" nibble.

        Dst = (BYTE UNALIGNED*) dst->Scan0;
        if (iAngle == 90)
        {
            Dst += (((INT)dstY - 1) * dst->Stride);
        }

        // ASSERT: 
        // if we process src pixels backwards in the scanline (i.e., we are
        // rotating 270 degrees), then dst points to the first scanline.
        // if we process src pixels forwards in the scanline (i.e., we are
        // rotating 90 degrees), then dst points to the last scanline.

        dstX = dst->Width;
        while (dstX)
        {
            // take the high order nibble of the Src and deposit it
            // into the high order nibble of the Dst
            *Dst = *tempSrc & 0xf0;
            tempSrc += sinc;
            dstX--;
            if (!dstX)
                break;

            // take the high order nibble of the Src and deposit it
            // into the low order nibble of the Dst
            *Dst |= (*tempSrc & 0xf0) >> 4;
            tempSrc += sinc;
            dstX--;

            Dst++;
        }
        dstY--;
    }

    tempSrc = src;
    Dst = (BYTE UNALIGNED*) dst->Scan0;

    // start at the end of src scanline if the angle is 270,
    // excluding the last nibble if dstY is odd.
    // Also, if we have an odd number of pixels in a src scanline, start Dst
    // at the second scanline, since the first dst scanline was handled above.
    if (iAngle == 270)
    {
        tempSrc = src + (dstY / 2) - 1;
        if (bOddPixelsInScanline)
        {
            Dst += dst->Stride;
        }
    }

    // Handle the rest of the scanlines.  The following code is pretty brute force.
    // It handles 90 degrees and 270 degrees separately, because in the 90 degree
    // case, we need to process the high src nibbles within a src byte first, whereas
    // in the 270 case, we need to process the low nibbles first.
    if (iAngle == 90)
    {
        while (dstY)
        {
            BYTE* d = Dst;
            const BYTE* s = tempSrc;
            dstX = dst->Width;        

            while (dstX)
            {
                // take the high order nibble of the Src and deposit it
                // into the high order nibble of the Dst
                *d = *s & 0xf0;
                s += sinc;
                dstX--;
                if (!dstX)
                    break;
            
                // take the high order nibble of the Src and deposit it
                // into the low order nibble of the Dst
                *d |= (*s & 0xf0) >> 4;
                s += sinc;
                dstX--;

                d++;
            }
            dstY--;
            if (!dstY)
                break;

            Dst += dst->Stride;
            d = Dst;
            s = tempSrc;
            dstX = dst->Width;        

            while (dstX)
            {
                // take the low order nibble of the Src and deposit it
                // into the high order nibble of the Dst
                *d = (*s & 0x0f) << 4;
                s += sinc;
                dstX--;
                if (!dstX)
                    break;
            
                // take the low order nibble of the Src and deposit it
                // into the low order nibble of the Dst
                *d |= *s & 0x0f;
                s += sinc;
                dstX--;

                d++;
            }
            dstY--;

            Dst += dst->Stride;
            tempSrc += Sinc;
        }
    }
    else
    {
        // ASSERT: iAngle == 270
        while (dstY)
        {
            BYTE* d = Dst;
            const BYTE* s = tempSrc;
            dstX = dst->Width;        

            while (dstX)
            {
                // take the low order nibble of the Src and deposit it
                // into the high order nibble of the Dst
                *d = (*s & 0x0f) << 4;
                s += sinc;
                dstX--;
                if (!dstX)
                    break;
            
                // take the low order nibble of the Src and deposit it
                // into the low order nibble of the Dst
                *d |= *s & 0x0f;
                s += sinc;
                dstX--;

                d++;
            }
            dstY--;
            if (!dstY)
                break;

            Dst += dst->Stride;
            d = Dst;
            s = tempSrc;
            dstX = dst->Width;        

            while (dstX)
            {
                // take the high order nibble of the Src and deposit it
                // into the high order nibble of the Dst
                *d = *s & 0xf0;
                s += sinc;
                dstX--;
                if (!dstX)
                    break;
            
                // take the high order nibble of the Src and deposit it
                // into the low order nibble of the Dst
                *d |= (*s & 0xf0) >> 4;
                s += sinc;
                dstX--;

                d++;
            }
            dstY--;

            Dst += dst->Stride;
            tempSrc += Sinc;
        }

    }
}


VOID
_Rotate24bpp(
    BitmapData* dst,
    const BYTE UNALIGNED* S,
    INT Sinc,
    INT sinc
    )
{
    BYTE UNALIGNED* D = (BYTE UNALIGNED*) dst->Scan0;
    UINT y = dst->Height;

    // start at the end of src scanline if direction is -1 within a scanline
    if (Sinc < 0)
        S += 3 * (y - 1);

    Sinc *= 3;

    while (y--)
    {
        BYTE* d = D;
        const BYTE UNALIGNED* s = S;
        UINT x = dst->Width;

        while (x--)
        {
            d[0] = s[0];
            d[1] = s[1];
            d[2] = s[2];

            d += 3;
            s += sinc;
        }

        D += dst->Stride;
        S += Sinc;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Functions for rotating a 48 BPP bitmap 90 degrees or 270 degrees
*
* Arguments:
*
*   dstBmp  ----------- Destination bitmap image data
*   srcData ----------- Source bitmap image data
*   iLineIncDirection - Direction to increment the source (+1 or -1)
*   iSrcStride -------- Direction and amount to increment the source per
*                       scanline. If the stride is negative, it means we are
*                       moving bottom up
*
*   Note to caller:
*       For a rotation of 90 degrees, "srcData" should be set to the beginning
*   of the last scanline, "iLineIncDirection" should be set to +1, and
*   "iSrcStride" should be set to -Stride of a src scanline.
*
*   For a rotation of 270 degrees, "srcData" should be set to the beginning of
*   scanline 0, "iLineIncDirection" should be set to -1, and "iSrcStride" should
*   be set to +Stride of a src scanline.
*
* Return Value:
*
*   NONE
*
* Revision History:
*
*   10/10/2000 minliu
*       Wrote it.
*
\**************************************************************************/

VOID
_Rotate48bpp(
    BitmapData* dstBmp,
    const BYTE UNALIGNED* srcData,
    INT         iLineIncDirection,
    INT         iSrcStride
    )
{
    UINT        uiCurrentLine = dstBmp->Height;
    const BYTE UNALIGNED* pSrcData = srcData;

    // Start at the end of src scanline if direction is < 0 (rotate 270)

    if ( iLineIncDirection < 0 )
    {
        pSrcData += 6 * (uiCurrentLine - 1);
    }

    iLineIncDirection *= 6;     // 6 bytes for each 48 bpp pixel

    BYTE*       pDstLine = (BYTE UNALIGNED*)dstBmp->Scan0;
    
    // Rotate line by line

    while ( uiCurrentLine-- )
    {
        BYTE* dstPixel = pDstLine;
        const BYTE UNALIGNED* srcPixel = pSrcData;
        UINT x = dstBmp->Width;

        // Move one pixel at a time horizontally

        while ( x-- )
        {
            // Copy 6 bytes from source to dest

            GpMemcpy(dstPixel, srcPixel, 6);

            // Move dst one pixel to the next (6 bytes)

            dstPixel += 6;

            // Move src pointer to the next line

            srcPixel += iSrcStride;
        }

        // Move dest to the next line

        pDstLine += dstBmp->Stride;

        // Move src to one pixel to the right (rotate 90) or to the left (270)

        pSrcData += iLineIncDirection;
    }
}// _Rotate48bpp()

/**************************************************************************\
*
* Function Description:
*
*   Functions for rotating a 64 BPP bitmap 90 degrees or 270 degrees
*
* Arguments:
*
*   dstBmp  ----------- Destination bitmap image data
*   srcData ----------- Source bitmap image data
*   iLineIncDirection - Direction to increment the source (+1 or -1)
*   iSrcStride -------- Direction and amount to increment the source per
*                       scanline. If the stride is negative, it means we are
*                       moving bottom up
*
*   Note to caller:
*       For a rotation of 90 degrees, "srcData" should be set to the beginning
*   of the last scanline, "iLineIncDirection" should be set to +1, and
*   "iSrcStride" should be set to -Stride of a src scanline.
*
*   For a rotation of 270 degrees, "srcData" should be set to the beginning of
*   scanline 0, "iLineIncDirection" should be set to -1, and "iSrcStride" should
*   be set to +Stride of a src scanline.
*
* Return Value:
*
*   NONE
*
* Revision History:
*
*   10/10/2000 minliu
*       Wrote it.
*
\**************************************************************************/

VOID
_Rotate64bpp(
    BitmapData* dstBmp,
    const BYTE UNALIGNED* srcData,
    INT         iLineIncDirection,
    INT         iSrcStride
    )
{
    UINT        uiCurrentLine = dstBmp->Height;
    const BYTE UNALIGNED* pSrcData = srcData;

    // Start at the end of src scanline if direction is < 0, (rotate 270)

    if ( iLineIncDirection < 0 )
    {
        pSrcData += 8 * (uiCurrentLine - 1);
    }

    iLineIncDirection *= 8;     // 8 bytes for each 64 bpp pixel

    BYTE UNALIGNED* pDstLine = (BYTE UNALIGNED*)dstBmp->Scan0;
    
    // Rotate line by line

    while ( uiCurrentLine-- )
    {
        BYTE* dstPixel = pDstLine;
        const BYTE UNALIGNED* srcPixel = pSrcData;
        UINT x = dstBmp->Width;

        // Move one pixel at a time horizontally

        while ( x-- )
        {
            // Copy 8 bytes from source to dest

            GpMemcpy(dstPixel, srcPixel, 8);

            // Move dst one pixel to the next (8 bytes)

            dstPixel += 8;

            // Move src pointer to the next line

            srcPixel += iSrcStride;
        }

        // Move dest to the next line

        pDstLine += dstBmp->Stride;
        
        // Move src to one pixel to the right (rotate 90) or to the left (270)

        pSrcData += iLineIncDirection;
    }
}// _Rotate64bpp()

/**************************************************************************\
*
* Function Description:
*
*   Rotate the bitmap image by the specified angle
*
* Arguments:
*
*   angle - Specifies the rotation angle, in degrees
*   hints - Specifies which interpolation method to use
*   outbmp - Returns a pointer to the rotated bitmap image
*
* Return Value:
*
*   Status code
*
* Notes:
*
*   Currently we only support 90-degree rotations.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::Rotate(
    IN FLOAT angle,
    IN InterpolationHint hints,
    OUT IBitmapImage** outbmp
    )
{
    // Get the integer angle

    INT iAngle = (INT) angle;

    iAngle %= 360;

    if ( iAngle < 0 )
    {
        iAngle += 360;
    }

    switch (iAngle)
    {
    case 0:
    case 360:
        return this->Clone(NULL, outbmp, TRUE);
        break;

    case 180:
        return this->Flip(TRUE, TRUE, outbmp);
        break;

    case 90:
    case 270:
        break;
    
    default:
        return E_NOTIMPL;
    }

    // Lock the current bitmap image
    // and create the new bitmap image

    ASSERT(IsValid());

    *outbmp = NULL;

    GpLock lock(&objectLock);
    HRESULT hr;
    GpMemoryBitmap* bmp = NULL;

    if ( lock.LockFailed() )
    {
        hr = IMGERR_OBJECTBUSY;
    }
    else if ((bmp = new GpMemoryBitmap()) == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = bmp->InitNewBitmap(Height, Width, PixelFormat);

        if (FAILED(hr))
        {
            goto exitRotate;
        }

        ASSERT(bmp->Width == this->Height &&
               bmp->Height == this->Width);

        VOID (*rotateProc)(BitmapData*, const BYTE UNALIGNED*, INT, INT);

        switch (GetPixelFormatSize(PixelFormat))
        {
        case 1:
            rotateProc = _Rotate1bpp;
            break;

        case 4:
            rotateProc = _Rotate4bpp;
            break;

        case 8:
            rotateProc = _Rotate8bpp;
            break;

        case 16:
            rotateProc = _Rotate16bpp;
            break;

        case 24:
            rotateProc = _Rotate24bpp;
            break;

        case 32:
            rotateProc = _Rotate32bpp;
            break;

        case 48:
            rotateProc = _Rotate48bpp;
            break;

        case 64:
            rotateProc = _Rotate64bpp;
            break;

        default:

            WARNING(("Rotate: pixel format not yet supported"));
            
            hr = E_NOTIMPL;
            goto exitRotate;
        }

        // Do the rotation

        const BYTE UNALIGNED* src = (const BYTE UNALIGNED*) this->Scan0;
        INT sinc = this->Stride;
        INT Sinc;

        if ( iAngle == 90 )
        {
            // clockwise
            
            src += sinc * ((INT)this->Height - 1);
            Sinc = 1;
            sinc = -sinc;
        }
        else
        {
            Sinc = -1;
        }

        rotateProc(bmp, src, Sinc, sinc);

        // Copy DPI info.
        // Note: when the code falls here, we know it is either 90 or -90 degree
        // rotation. So the DPI value should be swapped

        bmp->xdpi = this->ydpi;
        bmp->ydpi = this->xdpi;

        // Clone color palettes, flags, etc.

        hr = bmp->CopyPaletteFlagsEtc(this);
    }

exitRotate:

    if ( SUCCEEDED(hr) )
    {
        *outbmp = bmp;
    }
    else
    {
        delete bmp;
    }

    return hr;
}// Rotate()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\api\bitmap.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   bitmap.cpp
*
* Abstract:
*
*   Implementation of Bitmap class:
*       basic operations such as constructors/destructor
*       IBitmapImage methods
*
* Revision History:
*
*   05/10/1999 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "propertyutil.hpp"

#include "..\..\render\srgb.hpp"

//
// Information about various pixel data formats
//

const struct PixelFormatDescription PixelFormatDescs[PIXFMT_MAX] =
{
    {  0,  0,  0,  0, PIXFMT_UNDEFINED       },
    {  0,  0,  0,  0, PIXFMT_1BPP_INDEXED    },
    {  0,  0,  0,  0, PIXFMT_4BPP_INDEXED    },
    {  0,  0,  0,  0, PIXFMT_8BPP_INDEXED    },
    {  0,  0,  0,  0, PIXFMT_16BPP_GRAYSCALE },
    {  0,  5,  5,  5, PIXFMT_16BPP_RGB555    },
    {  0,  5,  6,  5, PIXFMT_16BPP_RGB565    },
    {  1,  5,  5,  5, PIXFMT_16BPP_ARGB1555  },
    {  0,  8,  8,  8, PIXFMT_24BPP_RGB       },
    {  0,  8,  8,  8, PIXFMT_32BPP_RGB       },
    {  8,  8,  8,  8, PIXFMT_32BPP_ARGB      },
    {  8,  8,  8,  8, PIXFMT_32BPP_PARGB     },
    {  0, 16, 16, 16, PIXFMT_48BPP_RGB       },
    { 16, 16, 16, 16, PIXFMT_64BPP_ARGB      },
    { 16, 16, 16, 16, PIXFMT_64BPP_PARGB     }
};

typedef HRESULT (WINAPI *ALPHABLENDFUNCTION)(HDC hdcDest,
                                             int nXOriginDest,
                                             int nYOriginDest,
                                             int nWidthDest,
                                             int hHeightDest,
                                             HDC hdcSrc,
                                             int nXOriginSrc,
                                             int nYOriginSrc,
                                             int nWidthSrc,
                                             int nHeightSrc,
                                             BLENDFUNCTION blendFunction
                                             );

BOOL                fHasLoadedMSIMG32 = FALSE;
HINSTANCE           g_hInstMsimg32 = NULL;
ALPHABLENDFUNCTION  pfnAlphaBlend = (ALPHABLENDFUNCTION)NULL;

ALPHABLENDFUNCTION
GetAlphaBlendFunc()
{
    // This is the first time we call this function. First we need to acquire
    // global critical section to protect 2+ threads calling this function at
    // the same time

    ImagingCritSec critsec;

    if ( fHasLoadedMSIMG32 == TRUE )
    {
        // We have already loaded

        return pfnAlphaBlend;
    }

    // Do a check again just to prevent this scenario:
    // 2+ threads calling this function at the same time. At that time, we
    // haven't call LoadLibrary() yet. So 1 thread get the critical section and
    // falls through doing the load. The others are blocked at above function
    // call. So when the 1st one finished. The flag should be set to TRUE and
    // we should return immediately.

    if ( fHasLoadedMSIMG32 == TRUE )
    {
        // The first thread has already loaded the dll. Just return here

        return pfnAlphaBlend;
    }

    g_hInstMsimg32 = LoadLibraryA("msimg32.dll");
    
    if ( g_hInstMsimg32 )
    {
        pfnAlphaBlend = (ALPHABLENDFUNCTION)GetProcAddress(g_hInstMsimg32,
                                                           "AlphaBlend");
    }

    // No matter fail or succeed, we always set this flag to TRUE

    fHasLoadedMSIMG32 = TRUE;

    return pfnAlphaBlend;
}// GetAlphaBlendFunc()

/**************************************************************************\
*
* Function Description:
*
*   Implementation of QueryInterface method
*
* Arguments:
*
*   riid - Specifies the interface ID to be queried
*   ppv - Returns a pointer to the interface found
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::QueryInterface(
    REFIID riid,
    VOID** ppv
    )
{
    if (riid == IID_IBitmapImage)
        *ppv = static_cast<IBitmapImage*>(this);
    else if (riid == IID_IImage)
        *ppv = static_cast<IImage*>(this);
    else if (riid == IID_IUnknown)
        *ppv = static_cast<IUnknown*>(static_cast<IBitmapImage*>(this));
    else if (riid == IID_IBasicBitmapOps)
        *ppv = static_cast<IBasicBitmapOps*>(this);
    else if (riid == IID_IImageSink)
        *ppv = static_cast<IImageSink*>(this);
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Create a new GpMemoryBitmap object and
*   intializes it to its default state
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

GpMemoryBitmap::GpMemoryBitmap()
{
    // Initialize the bitmap object to its default state

    Scan0 = NULL;
    Width = Height = 0;
    Stride = 0;
    PixelFormat = PIXFMT_UNDEFINED;
    Reserved = 0;
    comRefCount = 1;
    bitsLock = -1;

    // Start: [Bug 103296]
    // Change this code to use Globals::DesktopDpiX and Globals::DesktopDpiY
    HDC hdc;
    hdc = ::GetDC(NULL);
    if ((hdc == NULL) || 
        ((xdpi = (REAL)::GetDeviceCaps(hdc, LOGPIXELSX)) <= 0) ||
        ((ydpi = (REAL)::GetDeviceCaps(hdc, LOGPIXELSY)) <= 0))
    {
        WARNING(("GetDC or GetDeviceCaps failed"));
        xdpi = DEFAULT_RESOLUTION;
        ydpi = DEFAULT_RESOLUTION;
    }
    ::ReleaseDC(NULL, hdc);
    // End: [Bug 103296]

    creationFlag = CREATEDFROM_NONE;
    cacheFlags = IMGFLAG_NONE;
    colorpal = NULL;
    propset = NULL;
    ddrawSurface = NULL;
    sourceFProfile = NULL;
    alphaTransparency = ALPHA_UNKNOWN;

    // Initialize the state used to support DrawImage abort and color adjust

    callback = NULL;
    callbackData = NULL;


    // Property item stuff

    PropertyListHead.pPrev = NULL;
    PropertyListHead.pNext = &PropertyListTail;
    PropertyListHead.id = 0;
    PropertyListHead.length = 0;
    PropertyListHead.type = 0;
    PropertyListHead.value = NULL;

    PropertyListTail.pPrev = &PropertyListHead;
    PropertyListTail.pNext = NULL;
    PropertyListTail.id = 0;
    PropertyListTail.length = 0;
    PropertyListTail.type = 0;
    PropertyListTail.value = NULL;
    
    PropertyListSize = 0;
    PropertyNumOfItems = 0;
    
    JpegDecoderPtr = NULL;

    // Increment global COM component count

    IncrementComComponentCount();
}


/**************************************************************************\
*
* Function Description:
*
*   GpMemoryBitmap object destructor
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

GpMemoryBitmap::~GpMemoryBitmap()
{
    // Delete the color palette object, if any

    if ( NULL != colorpal )
    {
        GpFree(colorpal);
    }

    // If we have a pointer to the source image, release it

    if (JpegDecoderPtr)
    {
        JpegDecoderPtr->Release();
    }

    // Free memory for the bitmap pixel data, if needed

    FreeBitmapMemory();

    // Decrement global COM component count

    DecrementComComponentCount();

    if (propset)
        propset->Release();

    if(ddrawSurface)
    {
        if(Scan0 != NULL)
        {
            WARNING(("Direct draw surfaces was locked at bitmap deletion"));
            UnlockDirectDrawSurface();
        }
        ddrawSurface->Release();
    }

    // Free all the cached property items if we have allocated them

    if ( PropertyNumOfItems > 0 )
    {
        InternalPropertyItem*   pTempCurrent = PropertyListHead.pNext;
        InternalPropertyItem*   pTempNext = NULL;
        
        for ( int i = 0; 
              ((i < (INT)PropertyNumOfItems) && (pTempCurrent != NULL)); ++i )
        {
            pTempNext = pTempCurrent->pNext;

            GpFree(pTempCurrent->value);
            GpFree(pTempCurrent);

            pTempCurrent = pTempNext;
        }
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Allocate pixel data buffer for the bitmap object
*
* Arguments:
*
*   width, height    - Specifies the bitmap dimension
*   pixfmt           - Specifies the pixel foformat
*   [IN/OUT] bmpdata - The bitmap data structure
*   clear            - TRUE if we must clear the bitmap
*
* Notes:
*   bmpdata->Reserved must be set to zero on entry to this function
*   or at least have the highword clear (memory allocation flags).
*
*   If clear is TRUE, the bitmap is filled with zero (for palettized formats
*   and formats without an alpha channel) or opaque black (if there's an 
*   alpha channel).
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

BOOL
GpMemoryBitmap::AllocBitmapData(
    UINT width,
    UINT height,
    PixelFormatID pixfmt,
    BitmapData* bmpdata,
    INT *alphaFlags,
    BOOL clear
    )
{
    ASSERT(IsValidPixelFormat(pixfmt));
    ASSERT(width > 0 && height > 0);

    // Reserved should be set to zero before calling this function.
    // This field has bits ORed into it to track how the memory was allocated
    // and if extraneous bits are set, this will free the memory incorrectly.
    // NOTE: this is an overagressive check - we could get away with asserting
    // that none of the memory alloc flags are set.

    ASSERT((bmpdata->Reserved & ~BMPDATA_LOCKMODEMASK) == 0);

    // Allocate memory using a simple heuristic:
    //  use VirtualAlloc if the buffer size is larger than 64KB
    //  use malloc otherwise
    //
    // NOTE: The initial content of the bitmap is undefined.

    UINT stride = CalcScanlineStride(width, GetPixelFormatSize(pixfmt));
    UINT size = stride*height;

    if (size < OSInfo::VAllocChunk)
    {
        bmpdata->Reserved |= BMPDATA_MALLOC;
        bmpdata->Scan0 = GpMalloc(size);
    }
    else
    {
        bmpdata->Reserved |= BMPDATA_VALLOC;

        #if PROFILE_MEMORY_USAGE
        MC_LogAllocation(size);
        #endif

        bmpdata->Scan0 = VirtualAlloc(
                            NULL,
                            size,
                            MEM_RESERVE|MEM_COMMIT,
                            PAGE_READWRITE);
    }

    // Check if memory allocation failed

    if (bmpdata->Scan0 == NULL)
    {
        WARNING(("Failed to allocate bitmap data"));

        bmpdata->Reserved &= ~BMPDATA_ALLOCMASK;
        return FALSE;
    }

    // Check if memory needs to be initialized

    if (clear)
    {
        // [agodfrey] Hot fix for WFC. I've commented out the
        // 'clear to opaque black' until we give WFC a 'clear' API.
        #if 0
            if (IsAlphaPixelFormat(pixfmt))
            {
                // For formats with an alpha channel, we fill with
                // opaque black. If we do this, the caller can know that an
                // initialized bitmap has no transparent pixels, making it easier
                // to track when transparent pixels are written into the image.
                //
                // We want to track this so that we can apply optimizations when
                // we know there are no transparent pixels.

                UINT x,y;
                BYTE *dataPtr = static_cast<BYTE *>(bmpdata->Scan0);

                switch (pixfmt)
                {
                case PIXFMT_32BPP_ARGB:
                case PIXFMT_32BPP_PARGB:
                    for (y=0; y<height; y++)
                    {
                        ARGB *scanPtr = reinterpret_cast<ARGB *>(dataPtr);
                        for (x=0; x<width; x++)
                        {
                            *scanPtr++ = 0xff000000;
                        }
                        dataPtr += stride;
                    }
                    break;

                case PIXFMT_64BPP_ARGB:
                case PIXFMT_64BPP_PARGB:
                    sRGB::sRGB64Color c;
                    c.r = c.g = c.b = 0;
                    c.argb = sRGB::SRGB_ONE;

                    for (y=0; y<height; y++)
                    {
                        ARGB64 *scanPtr = reinterpret_cast<ARGB64 *>(dataPtr);
                        for (x=0; x<width; x++)
                        {
                            *scanPtr++ = c.argb;
                        }
                        dataPtr += stride;
                    }
                    break;

                case PIXFMT_16BPP_ARGB1555:
                    for (y=0; y<height; y++)
                    {
                        UINT16 *scanPtr = reinterpret_cast<UINT16 *>(dataPtr);
                        for (x=0; x<width; x++)
                        {
                            *scanPtr++ = 0x8000;
                        }
                        dataPtr += stride;
                    }
                    break;

                default:
                    // This switch statement needs to handle all formats that have
                    // alpha. If we get here, we've forgotten a format.

                    RIP(("Unhandled format has alpha"));

                    break;
                }
                if (alphaFlags)
                    *alphaFlags = ALPHA_OPAQUE;
            }
            else
            {
                memset(bmpdata->Scan0, 0, size);
                if (alphaFlags)
                    *alphaFlags = ALPHA_NONE;
            }

        #else

            memset(bmpdata->Scan0, 0, size);

            if (alphaFlags)
            {
                if (IsAlphaPixelFormat(pixfmt))
                    *alphaFlags = ALPHA_SIMPLE;
                else if (IsIndexedPixelFormat(pixfmt))
                    *alphaFlags = ALPHA_UNKNOWN;
                else
                    *alphaFlags = ALPHA_NONE;
            }

        #endif
    }

    bmpdata->Width = width;
    bmpdata->Height = height;
    bmpdata->Stride = stride;
    bmpdata->PixelFormat = pixfmt;

    return TRUE;
}

HRESULT
GpMemoryBitmap::AllocBitmapMemory(
    UINT width,
    UINT height,
    PixelFormatID pixfmt,
    BOOL clear
    )
{
    ASSERT(Scan0 == NULL);

    BitmapData* bmpdata = this;

    return AllocBitmapData(width, height, pixfmt, bmpdata, &alphaTransparency, clear) ?
                S_OK :
                E_OUTOFMEMORY;
}


/**************************************************************************\
*
* Function Description:
*
*   Free pixel data buffer associated with the bitmap object
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpMemoryBitmap::FreeBitmapData(
    const BitmapData* bmpdata
    )
{
    UINT_PTR flags = bmpdata->Reserved;

    if (flags & BMPDATA_MALLOC)
    {
        // Pixel data buffer was allocated
        // by calling runtime function malloc()

        GpFree(bmpdata->Scan0);
    }
    else if (flags & BMPDATA_VALLOC)
    {
        // Pixel data buffer was allocated
        // by calling win32 API VirtualAlloc

        VirtualFree(bmpdata->Scan0, 0, MEM_RELEASE);
    }
}

VOID
GpMemoryBitmap::FreeBitmapMemory()
{
    FreeBitmapData(static_cast<BitmapData*>(this));

    Reserved &= ~BMPDATA_ALLOCMASK;
    Scan0 = NULL;
}


/**************************************************************************\
*
* Function Description:
*
*   Initialize a new bitmap image object of the specified
*   dimension and pixel format.
*
* Arguments:
*
*   width, height - Specifies the desired bitmap size, in pixels
*   pixfmt - Specifies the desired pixel data format
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::InitNewBitmap(
    IN UINT width,
    IN UINT height,
    IN PixelFormatID pixfmt,
    IN BOOL clear
    )
{
    ASSERT(creationFlag == CREATEDFROM_NONE);

    // Validate input parameters

    if (width == 0 ||
        height == 0 ||
        width > INT_MAX / 64 ||
        height >= INT_MAX / width ||
        !IsValidPixelFormat(pixfmt))
    {
        WARNING(("Invalid parameters in InitNewBitmap"));
        return E_INVALIDARG;
    }

    // Allocate pixel data buffer

    HRESULT hr;

    hr = AllocBitmapMemory(width, height, pixfmt, clear);

    if (SUCCEEDED(hr))
        creationFlag = CREATEDFROM_NEW;

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Initialize a new bitmap image with an IImage object
*
* Arguments:
*
*   image - Pointer to the source IImage object
*   width, height - Desired bitmap dimension
*       0 means the same dimension as the source
*   pixfmt - Desired pixel format
*       PIXFMT_DONTCARE means the same pixel format as the source
*   hints - Specifies interpolation hints
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::InitImageBitmap(
    IN IImage* image,
    IN UINT width,
    IN UINT height,
    IN PixelFormatID pixfmt,
    IN InterpolationHint hints,
    IN DrawImageAbort callback,
    IN VOID* callbackData
    )
{
    ASSERT(creationFlag == CREATEDFROM_NONE);

    // Validate input parameters

    if (pixfmt != PIXFMT_DONTCARE && !IsValidPixelFormat(pixfmt) ||
        width == 0 && height != 0 ||
        height == 0 && width != 0)
    {
        return E_INVALIDARG;
    }

    // Remember optional parameters

    this->Width = width;
    this->Height = height;
    this->PixelFormat = pixfmt;

    GpBitmapScaler* scaler = NULL;
    IImageSink* sink = static_cast<IImageSink*>(this);

    HRESULT hr;

    if ( width == 0 && height == 0)
    {
        // The caller didn't specify a new dimension:
        //  sink source image data directly into this bitmap
    }
    else
    {
        ImageInfo imageInfo;
        hr = image->GetImageInfo(&imageInfo);

        // !!!TODO, what if GetImageInfo() call failed? Say, the source image is
        // bad. Shall we continue to create a scaler for it?

        if (SUCCEEDED(hr) && (imageInfo.Flags & IMGFLAG_SCALABLE))
        {
            // The caller specified a new dimension
            // and the source image is scalable:
            //  sink directly into this bitmap
        }
        else
        {
            // Otherwise, we need to layer a bitmap scaler sink
            // on top of this bitmap. Use default interpolation
            // algorithm here.

            scaler = new GpBitmapScaler(sink, width, height, hints);

            if (!scaler)
                return E_OUTOFMEMORY;

            sink = static_cast<IImageSink*>(scaler);
        }

        // GpmemoryBitmap should have the same image info flag as the source

        cacheFlags = imageInfo.Flags;
    }

    // Set the special DrawImage state.

    SetDrawImageSupport(callback, callbackData);

    // Ask the source image to push data into the sink

    hr = image->PushIntoSink(sink);

    if (SUCCEEDED(hr))
    {
        creationFlag = CREATEDFROM_IMAGE;
    }

    // Reset the special DrawImage state.

    SetDrawImageSupport(NULL, NULL);

    // Set the alpha hint.

    if (CanHaveAlpha(this->PixelFormat, this->colorpal))
    {
        // Exception: destination 16bpp ARGB 1555 can stay ALPHA_SIMPLE.

        if (this->PixelFormat == PIXFMT_16BPP_ARGB1555)
            alphaTransparency = ALPHA_SIMPLE;
        else
            alphaTransparency = ALPHA_UNKNOWN;
    }
    else
        alphaTransparency = ALPHA_NONE;

    delete scaler;
    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Create a new bitmap image object from an IImage object
*
* Arguments:
*
*   image -
*   width -
*   height -
*   pixfmt -
*   hints - Same as for the instance method InitImageBitmap.
*   bmp - Return a pointer to the newly created bitmap image object.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::CreateFromImage(
    IN IImage* image,
    IN UINT width,
    IN UINT height,
    IN PixelFormatID pixfmt,
    IN InterpolationHint hints,
    OUT GpMemoryBitmap** bmp,
    IN DrawImageAbort callback,
    IN VOID* callbackData
    )
{
    GpMemoryBitmap* newbmp = new GpMemoryBitmap();

    if (newbmp == NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = newbmp->InitImageBitmap(
        image, 
        width, 
        height, 
        pixfmt, 
        hints,
        callback, 
        callbackData
    );

    if (SUCCEEDED(hr))
    {
        *bmp = newbmp;
    }
    else
    {
        delete newbmp;
    }

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Initialize a new bitmap image object with
*   user-supplied memory buffer
*
* Arguments:
*
*   bitmapData - Information about user-supplied memory buffer
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::InitMemoryBitmap(
    IN BitmapData* bitmapData
    )
{
    ASSERT(creationFlag == CREATEDFROM_NONE);

    // Validate input parameters

    if (bitmapData == NULL ||
        bitmapData->Width == 0 ||
        bitmapData->Height == 0 ||
        (bitmapData->Stride & 3) != 0 ||
        bitmapData->Scan0 == NULL ||
        !IsValidPixelFormat(bitmapData->PixelFormat) ||
        bitmapData->Reserved != 0)
    {
        return E_INVALIDARG;
    }

    // Copy the specified bitmap data buffer information

    *((BitmapData*) this) = *bitmapData;
    creationFlag = CREATEDFROM_USERBUF;

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*   Given a pointer to a direct draw pixel format structure return
*   an appropriate PixelFormatID if possible otherwise return
*   PIXFMT_UNDEFINED.
*
* Arguments:
*
*   pfmt - pointer to DDPIXELFORMAT structure
*
* Return Value:
*
*   PixelFormatID
*
* History:
*
*   10/1/1999 bhouse    Created it.
*
\**************************************************************************/

PixelFormatID DDPixelFormatToPixelFormatID(DDPIXELFORMAT * pfmt)
{
    PixelFormatID   id = PIXFMT_UNDEFINED;

    if(pfmt->dwFlags & (DDPF_FOURCC | DDPF_ALPHA | DDPF_BUMPLUMINANCE |
                        DDPF_BUMPDUDV | DDPF_COMPRESSED | DDPF_LUMINANCE |
                        DDPF_PALETTEINDEXED2 | DDPF_RGBTOYUV |
                        DDPF_STENCILBUFFER | DDPF_YUV | DDPF_ZBUFFER |
                        DDPF_ZPIXELS))
    {
        // we don't support it
    }
    else if(pfmt->dwFlags & DDPF_PALETTEINDEXED1)
    {
        id = PIXFMT_1BPP_INDEXED;
    }
    else if(pfmt->dwFlags & DDPF_PALETTEINDEXED4)
    {
        id = PIXFMT_4BPP_INDEXED;
    }
    else if(pfmt->dwFlags & DDPF_PALETTEINDEXED8)
    {
        id = PIXFMT_8BPP_INDEXED;
    }
    else if(pfmt->dwFlags & DDPF_RGB)
    {
        switch(pfmt->dwRGBBitCount)
        {
        case 16:
            {
                if(pfmt->dwRBitMask == 0xF800 &&
                   pfmt->dwGBitMask == 0x07E0 &&
                   pfmt->dwBBitMask == 0x001F)
                {
                    id = PIXFMT_16BPP_RGB565;
                }
                else if(pfmt->dwRBitMask == 0x7C00 &&
                        pfmt->dwGBitMask == 0x03E0 &&
                        pfmt->dwBBitMask == 0x001F)
                {
                    id = PIXFMT_16BPP_RGB555;
                }
                else if (pfmt->dwRBitMask == 0x7C00 &&
                         pfmt->dwGBitMask == 0x03E0 &&
                         pfmt->dwBBitMask == 0x001F &&
                         pfmt->dwRGBAlphaBitMask == 0x8000)
                {
                    id = PIXFMT_16BPP_ARGB1555;
                }
            }
            break;
        case 24:
            {
                if(pfmt->dwRBitMask == 0xFF0000 &&
                   pfmt->dwGBitMask == 0xFF00 &&
                   pfmt->dwBBitMask == 0xFF)
                {
                    id = PIXFMT_24BPP_RGB;
                }
            }
            break;
        case 32:
            {
                if(pfmt->dwRBitMask == 0xFF0000 &&
                   pfmt->dwGBitMask == 0xFF00 &&
                   pfmt->dwBBitMask == 0xFF)
                {
                    if(pfmt->dwFlags & DDPF_ALPHAPIXELS)
                    {
                        if(pfmt->dwRGBAlphaBitMask == 0xFF000000)
                        {
                            if(pfmt->dwFlags & DDPF_ALPHAPREMULT)
                                id = PIXFMT_32BPP_PARGB;
                            else
                                id = PIXFMT_32BPP_ARGB;
                        }
                    }
                    else
                    {
                        id = PIXFMT_32BPP_RGB;
                    }

                }
            }
            break;
        }

    }

    return id;
}

/**************************************************************************\
*
* Function Description:
*
*   Initialize a new bitmap image object with
*   a user-supplied direct draw surface
*
* Arguments:
*
*   surface - Reference to a direct draw suface
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::InitDirectDrawBitmap(
    IN IDirectDrawSurface7 * surface
    )
{
    ASSERT(creationFlag == CREATEDFROM_NONE);

    // Validate input parameters

    if (surface == NULL)
    {
        return E_INVALIDARG;
    }

    // Validate surface

    HRESULT hr;
    DDSURFACEDESC2 ddsd;

    memset(&ddsd, 0, sizeof(ddsd));
    ddsd.dwSize = sizeof(ddsd);
    hr = surface->GetSurfaceDesc(&ddsd);

    if(hr != DD_OK)
    {
        WARNING(("Can not get surface description"));
        return E_INVALIDARG;
    }

    if(ddsd.dwWidth <= 0)
    {
        WARNING(("Unsupported surface width"));
        return E_INVALIDARG;
    }

    Width = ddsd.dwWidth;

    if(ddsd.dwHeight <= 0)
    {
        WARNING(("Unsupported surface height"));
        return E_INVALIDARG;
    }

    Height = ddsd.dwHeight;

    if(ddsd.lPitch & 3)
    {
        // QUESTION: Why do we require pitch to be a multiple of a four bytes?
        WARNING(("Unsupported surface pitch"));
        return E_INVALIDARG;
    }

    // Stride can change when we lock the surface
    // Stride = ddsd.lPitch;

    // Map Direct Draw pixel format to image pixel format

    PixelFormat = DDPixelFormatToPixelFormatID(&ddsd.ddpfPixelFormat);

    if(PixelFormat == PIXFMT_UNDEFINED)
    {
        WARNING(("Unsupported surface pixel format"));
        return E_INVALIDARG;
    }

    surface->AddRef();

    // QUESTION: Do we need this?  Overkill?

    Stride = 0;
    Scan0 = NULL;

    ddrawSurface = surface;
    creationFlag = CREATEDFROM_DDRAWSURFACE;

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*   Get the encoder parameter list size from an encoder object specified by
*   input clsid
*
* Arguments:
*
*   clsid - Specifies the encoder class ID
*   size--- The size of the encoder parameter list
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   03/22/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::GetEncoderParameterListSize(
    IN  CLSID* clsidEncoder,
    OUT UINT* size
    )
{
    return CodecGetEncoderParameterListSize(clsidEncoder, size);    
}// GetEncoderParameterListSize()

/**************************************************************************\
*
* Function Description:
*
*   Get the encoder parameter list from an encoder object specified by
*   input clsid
*
* Arguments:
*
*   clsid --- Specifies the encoder class ID
*   size----- The size of the encoder parameter list
*   pBuffer-- Buffer for storing the list
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   03/22/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::GetEncoderParameterList(
    IN CLSID* clsidEncoder,
    IN UINT size,
    OUT EncoderParameters* pBuffer
    )
{
    return CodecGetEncoderParameterList(clsidEncoder, size, pBuffer);
}// GetEncoderParameterList()

/**************************************************************************\
*
* Function Description:
*
*   Save image property items to the destination sink
*
* Arguments:
*
*   pImageSrc   --- [IN]Pointer to the source image object
*   pEncodeSink---- [IN]Pointer to the sink we are pushing to
*
* Return Value:
*
*   Status code
*
* Note:
*   This is a private method. So we don't need to do input parameter
*   validation since the caller should do this for us.
*
* Revision History:
*
*   09/06/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::SavePropertyItems(
    IN GpDecodedImage* pImageSrc,
    IImageSink* pEncodeSink
    )
{
    // Check if the sink needs property stuff.
    // If the sink can save property and we have either the source
    // image pointer or we have property items stored in this
    // GpMemoryBitmap object, then we push the property items first
    // Note: it is not right that we have property items stored in
    // this GpMemoryBitmap object and we also have the source image
    // pointer

    HRESULT hResult = S_OK;

    // If the save operation is between two JPEG images (src and dest are JPEG),
    // then we need to establish a link between decoder and encoder so that
    // the encoder can copy application headers from the decoder and save it in
    // the new image

    void *pRawInfo = NULL;

    if (JpegDecoderPtr)
    {
        hResult = JpegDecoderPtr->GetRawInfo(&pRawInfo);
    }

    if (FAILED(hResult))
    {
        return hResult;
    }

    if ( ((pImageSrc != NULL ) || (PropertyNumOfItems > 0) )
         &&(pEncodeSink->NeedRawProperty(pRawInfo) == S_OK) )
    {
        UINT    uiTotalBufferSize = 0;
        UINT    uiNumOfItems = 0;

        if ( pImageSrc != NULL )
        {
            hResult = pImageSrc->GetPropertySize(&uiTotalBufferSize,
                                                 &uiNumOfItems);
        }
        else
        {
            hResult = GetPropertySize(&uiTotalBufferSize,
                                      &uiNumOfItems);
        }

        if ( FAILED(hResult) )
        {
            WARNING(("::SaveToStream--GetPropertySize() failed"));
            return hResult;
        }

        // Move all the property items to the sink if there is any

        if (uiNumOfItems > 0)
        {
            PropertyItem*   pBuffer = NULL;

            // Ask the destination to provide the memory

            hResult = pEncodeSink->GetPropertyBuffer(uiTotalBufferSize,
                                                     &pBuffer);                        
            if ( FAILED(hResult) )
            {
                WARNING(("GpMemoryBmp::Save-GetPropertyBuffer failed"));
                return hResult;
            }

            // if GetPropertyBuffer succeeded, pBuffer must be set

            ASSERT(pBuffer != NULL);

            // Get all the property items from the source

            if ( pImageSrc != NULL )
            {
                hResult = pImageSrc->GetAllPropertyItems(
                                                        uiTotalBufferSize,
                                                        uiNumOfItems,
                                                        pBuffer);
            }
            else
            {
                hResult = GetAllPropertyItems(uiTotalBufferSize,
                                              uiNumOfItems,
                                              pBuffer);
            }

            if ( hResult != S_OK )
            {
                WARNING(("GpMemoryBmp::Save-GetAllPropertyItems fail"));
                return hResult;
            }

            // Push all property items to destination

            hResult = pEncodeSink->PushPropertyItems(uiNumOfItems,
                                                     uiTotalBufferSize,
                                                     pBuffer,
                                                     FALSE  // No ICC change
                                                     );
        }
    }// If the sink needs raw property

    return hResult;
}// SavePropertyItems()

HRESULT
GpMemoryBitmap::SetJpegQuantizationTable(
    IN IImageEncoder* pEncoder
    )
{
    UINT    uiLumTableSize = 0;
    UINT    uiChromTableSize = 0;
    EncoderParameters* pMyEncoderParams = NULL;

    HRESULT hResult = GetPropertyItemSize(PropertyTagLuminanceTable,
                                          &uiLumTableSize);

    if ( FAILED(hResult) || (uiLumTableSize == 0) )
    {
        // This image doesn't have luminance table or something is
        // wrong.

        WARNING(("GpMemoryBitmap::SetJpegQuantizationTable-No luminance tbl"));
        return hResult;
    }

    // Note: For a gray scale JPEG, it doesn't have a chrominance table. So the
    // function call below might return failure. But this is OK.

    hResult = GetPropertyItemSize(PropertyTagChrominanceTable,
                                  &uiChromTableSize);

    if ( FAILED(hResult) )
    {
        // Some codecs fail and set uiChromTableSize to a bogus value,
        // so we re-initialize it here

        uiChromTableSize = 0;
    }

    // Find luminance and chrominance table

    PropertyItem*   pLumTable = (PropertyItem*)GpMalloc(uiLumTableSize);
    if ( pLumTable == NULL )
    {
        WARNING(("GpMemoryBitmap::SetJpegQuantizationTable---Out of memory"));

        hResult = E_OUTOFMEMORY;
        goto CleanUp;
    }
    
    hResult = GetPropertyItem(PropertyTagLuminanceTable,
                              uiLumTableSize, pLumTable);
    if ( FAILED(hResult) )
    {
        WARNING(("GpMemoryBitmap::SetJpegQuantizationTable-No luminance tbl"));
        goto CleanUp;        
    }

    PropertyItem*   pChromTable = NULL;

    if ( uiChromTableSize != 0 )
    {
        pChromTable = (PropertyItem*)GpMalloc(uiChromTableSize);
        if ( pChromTable == NULL )
        {
            WARNING(("GpMemoryBitmap::SetJpegQuantizationTable-Out of memory"));

            hResult = E_OUTOFMEMORY;
            goto CleanUp;
        }
        
        hResult = GetPropertyItem(PropertyTagChrominanceTable,
                                  uiChromTableSize, pChromTable);
        if ( FAILED(hResult) )
        {
            WARNING(("GpMemBitmap::SetJpegQuantizationTable-No chrom table"));
            goto CleanUp;
        }
    }

    pMyEncoderParams = (EncoderParameters*)
                               GpMalloc( sizeof(EncoderParameters)
                                        + 2 * sizeof(EncoderParameter));

    if ( pMyEncoderParams == NULL )
    {
        WARNING(("GpMemoryBitmap::SetJpegQuantizationTable---Out of memory"));
        hResult = E_OUTOFMEMORY;
        goto CleanUp;
    }

    // Note: the size for a luminance table and chrominance table should always
    // be 64, that is, pLumTable->length / sizeof(UINT16) == 64. Here, just for
    // save reason, we don't hard-coded it as 64. But the lower level JPEG
    // SetEncoderParameters() will fail and print out warning message if the
    // size is not 64

    pMyEncoderParams->Parameter[0].Guid = ENCODER_LUMINANCE_TABLE;
    pMyEncoderParams->Parameter[0].NumberOfValues = pLumTable->length
                                                  / sizeof(UINT16);
    pMyEncoderParams->Parameter[0].Type = EncoderParameterValueTypeShort;
    pMyEncoderParams->Parameter[0].Value = (VOID*)(pLumTable->value);
    pMyEncoderParams->Count = 1;

    if ( uiChromTableSize != 0 )
    {
        pMyEncoderParams->Parameter[1].Guid = ENCODER_CHROMINANCE_TABLE;
        pMyEncoderParams->Parameter[1].NumberOfValues = pChromTable->length
                                                      / sizeof(UINT16);
        pMyEncoderParams->Parameter[1].Type = EncoderParameterValueTypeShort;
        pMyEncoderParams->Parameter[1].Value = (VOID*)(pChromTable->value);
        pMyEncoderParams->Count++;
    }

    hResult = pEncoder->SetEncoderParameters(pMyEncoderParams);
    
CleanUp:
    if ( pLumTable != NULL )
    {
        GpFree(pLumTable);
    }

    if ( pChromTable != NULL )
    {
        GpFree(pChromTable);
    }

    if ( pMyEncoderParams != NULL )
    {
        GpFree(pMyEncoderParams);
    }

    return hResult;
}// SetJpegQuantizationTable()

/**************************************************************************\
*
* Function Description:
*
*   Get the bitmap image to the specified stream.
*
* Arguments:
*
*   stream -------- Target stream
*   clsidEncoder -- Specifies the CLSID of the encoder to use
*   encoderParams - Optional parameters to pass to the encoder before
*                   starting encoding
*   ppEncoderPtr -- [OUT]Pointer to the encoder object 
*   pImageSrc   --- [IN]Pointer to the source image object
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::SaveToStream(
    IN IStream* stream,
    IN CLSID* clsidEncoder,
    IN EncoderParameters* encoderParams,
    IN BOOL fSpecialJPEG,
    OUT IImageEncoder** ppEncoderPtr,
    IN GpDecodedImage* pImageSrc
    )
{
    if ( ppEncoderPtr == NULL )
    {
        WARNING(("GpMemoryBitmap::SaveToStream---Invalid input arg"));
        return E_INVALIDARG;
    }

    // Get an image encoder.

    IImageEncoder* pEncoder = NULL;

    HRESULT hResult = CreateEncoderToStream(clsidEncoder, stream, &pEncoder);
    if ( SUCCEEDED(hResult) )
    {
        // Return the pointer to encoder back to caller

        *ppEncoderPtr = pEncoder;

        // Pass encode parameters to the encoder.
        // MUST do this before getting the sink interface.

        if ( encoderParams != NULL )
        {
            hResult = pEncoder->SetEncoderParameters(encoderParams);
        }

        if ( SUCCEEDED(hResult) || ( hResult == E_NOTIMPL) )
        {
            if ( fSpecialJPEG == TRUE )
            {
                // Set JPEG quantization table

                hResult = SetJpegQuantizationTable(pEncoder);

                if ( FAILED(hResult) )
                {
                    WARNING(("GpMemBitmap::SetJpegQuantizationTable-Failed"));
                    return hResult;
                }
            }

            // Get an image sink from the encoder.

            IImageSink* pEncodeSink = NULL;

            hResult = pEncoder->GetEncodeSink(&pEncodeSink);
            if ( SUCCEEDED(hResult) )
            {
                hResult = SavePropertyItems(pImageSrc, pEncodeSink);
                if ( SUCCEEDED(hResult) )
                {
                    // Push bitmap into the encoder sink.

                    hResult = this->PushIntoSink(pEncodeSink);
                }

                pEncodeSink->Release();
            }// Succeed in getting an encoder sink
        }
    }// Succeed in getting an encoder

    return hResult;
}// SaveToStream()

/**************************************************************************\
*
* Function Description:
*
*   Get the bitmap image to the specified stream.
*
* Arguments:
*
*   stream - Target stream
*   clsidEncoder - Specifies the CLSID of the encoder to use
*   encoderParams - Optional parameters to pass to the encoder before
*                   starting encoding
*   ppEncoderPtr -- [OUT]Pointer to the encoder object 
*   pImageSrc   --- [IN]Pointer to the source image object
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::SaveToFile(
    IN const WCHAR* filename,
    IN CLSID* clsidEncoder,
    IN EncoderParameters* encoderParams,
    IN BOOL fSpecialJPEG,
    OUT IImageEncoder** ppEncoderPtr,
    IN GpDecodedImage* pImageSrc
    )
{
    IStream* stream = NULL;

    HRESULT hResult = CreateStreamOnFileForWrite(filename, &stream);

    if ( SUCCEEDED(hResult) )
    {
        hResult = SaveToStream(stream, clsidEncoder,
                               encoderParams, fSpecialJPEG, ppEncoderPtr,
                               pImageSrc);
        stream->Release();
    }

    return hResult;
}// SaveToFile()

/**************************************************************************\
*
* Function Description:
*
* Append current GpMemoryBitmap object to current encoder object
*
* Note: this call will happen under following scenario:
*   The source image is a multi-frame image (TIFF, GIF). The caller is
*   navigating among the pages and append the current page to the file for
*   saving
*
* Arguments:
*
*   encoderParams - Optional parameters to pass to the encoder before
*                   starting encoding
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   04/21/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::SaveAppend(
    IN const EncoderParameters* encoderParams,
    IN IImageEncoder* destEncoderPtr,
    IN GpDecodedImage* pImageSrc
    )
{
    // The dest encoder pointer can't be NULL. Otherwise, it is a failure

    if ( destEncoderPtr == NULL )
    {
        WARNING(("GpMemoryBitmap::SaveAppend---Called without an encoder"));
        return E_FAIL;
    }

    HRESULT hResult = S_OK;

    // Pass encode parameters to the encoder.
    // MUST do this before getting the sink interface.

    if ( encoderParams != NULL )
    {
        hResult = destEncoderPtr->SetEncoderParameters(encoderParams);
    }

    // Note: it is OK that an encoder might not implement SetEncoderParameters()

    if ( (hResult == S_OK) || (hResult == E_NOTIMPL) )
    {
        // Get an image sink from the encoder.
    
        IImageSink*  pEncodeSink = NULL;

        hResult = destEncoderPtr->GetEncodeSink(&pEncodeSink);
        if ( SUCCEEDED(hResult) )
        {
            hResult = SavePropertyItems(pImageSrc, pEncodeSink);
            if ( FAILED(hResult) )
            {
                WARNING(("GpMemoryBmp:Save-SavePropertyItems() failed"));
                return hResult;
            }
            
            // Push bitmap into the encoder sink.

            hResult = this->PushIntoSink(pEncodeSink);

            pEncodeSink->Release();
        }
    }

    return hResult;
}// SaveAppend()

/**************************************************************************\
*
* Function Description:
*
*   Get the device-independent physical dimension of the image
*   in unit of 0.01mm
*
* Arguments:
*
*   size - Buffer for returning physical dimension information
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::GetPhysicalDimension(
    OUT SIZE* size
    )
{
    if ( !IsValid() )
    {
        return E_FAIL;
    }

    GpLock lock(&objectLock);

    if (lock.LockFailed())
        return IMGERR_OBJECTBUSY;

    // Convert to 0.01mm units

    size->cx = Pixel2HiMetric(Width, xdpi);
    size->cy = Pixel2HiMetric(Height, ydpi);

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Get basic information about the bitmap image object
*
* Arguments:
*
*   imageInfo - Buffer for returning basic image info
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::GetImageInfo(
    OUT ImageInfo* imageInfo
    )
{
    if ( !IsValid() )
    {
        return E_FAIL;
    }

    GpLock lock(&objectLock);

    if (lock.LockFailed())
        return IMGERR_OBJECTBUSY;

    imageInfo->RawDataFormat = IMGFMT_MEMORYBMP;
    imageInfo->PixelFormat = PixelFormat;
    imageInfo->Width = imageInfo->TileWidth = Width;
    imageInfo->Height = imageInfo->TileHeight = Height;
    imageInfo->Xdpi = xdpi;
    imageInfo->Ydpi = ydpi;

    UINT flags = cacheFlags;

    if (CanHaveAlpha(PixelFormat, colorpal))
        flags |= IMGFLAG_HASALPHA;

    imageInfo->Flags = flags;
    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Set image flags
*
* Arguments:
*
*   flags - Specifies the new image flags
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::SetImageFlags(
    IN UINT flags
    )
{
    if ( !IsValid() )
    {
        return E_FAIL;
    }

#if 0
    // Only the top half is settable
    // Note: [minliu] This is not right. Flags like SINKFLAG_TOPDOWN which is
    // defined as 0x0001000, SinkFlagsMultipass also has bottom half.

    if (flags & 0xffff)
        return E_INVALIDARG;
#endif

    GpLock lock(&objectLock);

    if (lock.LockFailed())
        return IMGERR_OBJECTBUSY;

    // !!! TODO
    //  Need to honor IMGFLAG_READONLY in other methods.

    cacheFlags = flags;
    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Display the image in a GDI device context
*
* Arguments:
*
*   hdc - Specifies the destination device context to draw into
*   dstRect - Specifies the area on the destination DC
*   srcRect - Specifies the source area in the bitmap image
*       NULL means the entire bitmap
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::Draw(
    IN HDC hdc,
    IN const RECT* dstRect,
    IN OPTIONAL const RECT* srcRect
    )
{
    HRESULT hr;

    hr = LockDirectDrawSurface();

    if(SUCCEEDED(hr))
    {
        if ( !IsValid() )
        {
            UnlockDirectDrawSurface();
            
            return E_FAIL;
        }

        // Lock the current bitmap object
        // and validate source rectangle

        RECT r, subarea;
        GpLock lock(&objectLock);

        if (lock.LockFailed())
            return IMGERR_OBJECTBUSY;

        // The source rectangle is in 0.01mm unit.
        //  So we need to convert it to pixel unit here.

        if (srcRect)
        {
            r.left = HiMetric2Pixel(srcRect->left, xdpi);
            r.right = HiMetric2Pixel(srcRect->right, xdpi);
            r.top = HiMetric2Pixel(srcRect->top, ydpi);
            r.bottom = HiMetric2Pixel(srcRect->bottom, ydpi);

            srcRect = &r;
        }

        if (!ValidateImageArea(&subarea, srcRect))
        {
            WARNING(("Invalid source rectangle in Draw"));
            hr = E_INVALIDARG;
        }
        else
        {
            // Call GDI to do the drawing if the pixel format
            // is directly supported by GDI. Otherwise, we first
            // convert the pixel format into the canonical 32bpp
            // ARGB format and then call GDI.

            hr = IsGDIPixelFormat(PixelFormat) ?
                        DrawWithGDI(hdc, dstRect, &subarea) :
                        DrawCanonical(hdc, dstRect, &subarea);
        }

        UnlockDirectDrawSurface();
    }

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Draw the bitmap into a GDI device context
*   by directly calling GDI APIs.
*
* Arguments:
*
*   hdc - Specifies the destination device context to draw into
*   dstRect - Specifies the area on the destination DC
*   srcRect - Specifies the source area in the bitmap image
*
* Return Value:
*
*   Status code
*
* Notes:
*
*   We assume the current bitmap object is already marked busy.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::DrawWithGDI(
    HDC hdc,
    const RECT* dstRect,
    RECT* srcRect
    )
{
    // !!! TODO
    // Check if the bitmap can potentially have alpha information

    // Figure out if the bitmap is bottom-up
    // and if its scanline stride satisfies GDI requirement.
    // GDI scanlines are always rounded up to multiples of DWORDs.

    HRESULT hr = S_OK;
    UINT pixsize;
    INT gdiStride, srcStride;
    INT w, h;
    BYTE* dataptr;

    pixsize = GetPixelFormatSize(PixelFormat);
    if ( pixsize == 0 )
    {
        return E_FAIL;
    }

    gdiStride = (((pixsize * Width + 7) >> 3) + 3) & ~3;
    w = Width;
    h = Height;
    srcStride = Stride;
    BOOL    fHasAlpha = FALSE;

    INT srcRectTop;
    if (srcStride > 0)
    {
        // Top-down bitmap

        h = -h;
        dataptr = (BYTE*) Scan0;

        // For top-down bitmaps, StretchDIBits YSrc argument is actually
        // the distance from the bottom of the image

        srcRectTop = Height - srcRect->bottom;
    }
    else
    {
        // Bottom-up bitmap

        srcStride = -srcStride;
        dataptr = (BYTE*) Scan0 + (Height-1) * Stride;
        srcRectTop = srcRect->top;
    }

    if (srcStride != gdiStride)
    {
        ASSERT(srcStride > gdiStride);
        w = 8 * gdiStride / pixsize;
    }

    // Compose a GDI BITMAPINFO structure corresponding
    // to the pixel format of the current bitmap object.

    struct {
        BITMAPINFOHEADER bmih;
        ARGB colors[256];
    } bmpinfo;

    ZeroMemory(&bmpinfo.bmih, sizeof(bmpinfo.bmih));

    bmpinfo.bmih.biSize = sizeof(bmpinfo.bmih);
    bmpinfo.bmih.biWidth = w;
    bmpinfo.bmih.biHeight = h;
    bmpinfo.bmih.biPlanes = 1;
    bmpinfo.bmih.biBitCount = (WORD) pixsize;
    bmpinfo.bmih.biCompression = BI_RGB;

    if (IsIndexedPixelFormat(PixelFormat))
    {
        const ColorPalette* pal = GetCurrentPalette();
        if ( pal == NULL )
        {
            return E_FAIL;
        }

        
        // If the palette has alpha in it, we need to set fHasAlpha to TRUE so
        // that we will use AlphaBlend to draw this image later.
        // Note: we don't need to fill "bmpinfo.colors" any more since we will
        // convert the image to a 32 BPP ARGB later

        if ( pal->Flags & PALFLAG_HASALPHA )
        {
            fHasAlpha = TRUE;

            // AlphaBlend doesn't support indexed format. We will have to
            // convert it to 32 BPP later. So change the bit count here to 32

            bmpinfo.bmih.biBitCount = 32;
        }
        else
        {
            GpMemcpy(bmpinfo.colors,
                     pal->Entries,
                     pal->Count * sizeof(ARGB));
        }
    }
    else if (pixsize == 16)
    {
        // 16bpp pixel formats are handled as GDI bit-field formats

        bmpinfo.bmih.biCompression = BI_BITFIELDS;

        if (PixelFormat == PIXFMT_16BPP_RGB565)
        {
            bmpinfo.colors[0] = 0x1f << 11;
            bmpinfo.colors[1] = 0x3f << 5;
            bmpinfo.colors[2] = 0x1f;
        }
        else if ( PixelFormat == PIXFMT_16BPP_ARGB1555 )
        {
            // AlphaBlend doesn't support 16BPP ARGB format. We will have to
            // convert it to 32 BPP later. So change the bit count here to 32
            // Note: It is very important to set biCompression as BI_RGB. That
            // means we don't need a palette when we call CreateDIBSection

            bmpinfo.bmih.biBitCount = 32;
            bmpinfo.bmih.biCompression = BI_RGB;
        }
        else
        {
            bmpinfo.colors[0] = 0x1f << 10;
            bmpinfo.colors[1] = 0x1f << 5;
            bmpinfo.colors[2] = 0x1f;
        }
    }

    // First check if we have alpha blend function on this system or not

    ALPHABLENDFUNCTION myAlphaBlend = GetAlphaBlendFunc();

    // !!!TODO, we need to let 64_BPP_ARGB falls into this path as well
    
    if ( (myAlphaBlend != NULL )
       &&( (PixelFormat == PIXFMT_32BPP_ARGB)
         ||(PixelFormat == PIXFMT_16BPP_ARGB1555)
         ||(fHasAlpha == TRUE) ) )
    {
        HDC     hMemDC = CreateCompatibleDC(hdc);

        if ( hMemDC == NULL )
        {
            WARNING(("CreateCompatibleDC failed"));
            goto handle_err;
        }

        // Create a 32 BPP DIB section

        VOID*   myBits;
        HBITMAP hBitMap = CreateDIBSection(hMemDC,
                                           (BITMAPINFO*)&bmpinfo,
                                           DIB_RGB_COLORS,
                                           &myBits,
                                           NULL,
                                           0);

        if ( hBitMap == NULL )
        {
            WARNING(("CreateDIBSection failed"));
            goto handle_err;
        }

        // Source image has alpha in it. We have to call AlphaBlend() to draw it
        // But before that, we have to convert our ARGB format to a
        // pre-multiplied ARGB format since GDI only knows the later format

        if ( PixelFormat == PIXFMT_32BPP_ARGB )
        {
            // Set the bits in the DIB

            ARGB*   pSrcBits = (ARGB*)dataptr;
            ARGB*   pDstBits = (ARGB*)myBits;

            for ( UINT i = 0; i < Height; ++ i )
            {
                for ( UINT j = 0; j < Width; ++j )
                {
                    *pDstBits++ = Premultiply(*pSrcBits++);
                }
            }        
        }// 32 BPP ARGB to PARGB
        else if ( PixelFormat == PIXFMT_16BPP_ARGB1555 )
        {
            UINT16* pui16Bits = (UINT16*)dataptr;
            ARGB*   pDest = (ARGB*)myBits;

            for ( UINT i = 0; i < Height; ++ i )
            {
                for ( UINT j = 0; j < Width; ++j )
                {
                    // If the 1st bits is 0, then the whole 16 bits set to 0
                    // if it is 1, we don't need to do anything for the rest
                    // 15 bits

                    if ( ((*pui16Bits) & 0x8000) == 0 )
                    {
                        *pDest++ = 0;
                    }
                    else
                    {
                        ARGB v = *pui16Bits;
                        ARGB r = (v >> 10) & 0x1f;
                        ARGB g = (v >>  5) & 0x1f;
                        ARGB b = (v      ) & 0x1f;

                        *pDest++ = ALPHA_MASK
                                 | (r << RED_SHIFT)
                                 | (g << GREEN_SHIFT)
                                 | (b << BLUE_SHIFT);
                    }

                    pui16Bits++;
                }
            }
        }// 16 BPP ARGB to PARGB
        else
        {
            // AlphaBlend only supports 32 ARGB format. So we have to do a
            // conversion here
            // Make a BitmapData structure to do a format conversion

            BitmapData srcBitmapData;

            srcBitmapData.Scan0 = Scan0;
            srcBitmapData.Width = Width;
            srcBitmapData.Height = Height;
            srcBitmapData.PixelFormat = PixelFormat;
            srcBitmapData.Reserved = 0;
            srcBitmapData.Stride = Stride;

            BitmapData dstBitmapData;

            dstBitmapData.Scan0 = myBits;
            dstBitmapData.Width = Width;
            dstBitmapData.Height = Height;
            dstBitmapData.PixelFormat = PIXFMT_32BPP_ARGB;
            dstBitmapData.Reserved = 0;
            dstBitmapData.Stride = (Width << 2);
            
            // Get the source palette

            const ColorPalette* pal = GetCurrentPalette();

            // Since we are not allowed to modify the source palette, we have to
            // make a COPY of it. Here "FALSE" is to tell the function use
            // GpMalloc to allocate memory

            ColorPalette* pModifiedPal = CloneColorPalette(pal, FALSE);
            if ( pModifiedPal == NULL )
            {
                goto handle_err;
            }

            for ( UINT i = 0; i < pal->Count; ++i )
            {
                // A palette entry is in ARGB format. If the alpha value not
                // equals to 255, that means it is translucent. We have to
                // pre-multiply the pixel value

                if ( (pal->Entries[i] & 0xff000000) != 0xff000000 )
                {                    
                    pModifiedPal->Entries[i] = Premultiply(pal->Entries[i]);
                }
            }
            
            // Do the data conversion.

            hr = ConvertBitmapData(&dstBitmapData,
                                   NULL,
                                   &srcBitmapData,
                                   pModifiedPal);

            GpFree(pModifiedPal);

            if ( !SUCCEEDED(hr) )
            {
                WARNING(("MemBitmap::DrawWithGDI--ConvertBitmapData fail"));
                goto handle_err;
            }
        }// Indexed case

        HBITMAP hOldBitMap = (HBITMAP)SelectObject(hMemDC, hBitMap);

        if ( hOldBitMap == NULL )
        {
            WARNING(("SelectObject failed"));
            goto handle_err;
        }

        BLENDFUNCTION   myBlendFunction;

        myBlendFunction.BlendOp = AC_SRC_OVER;
        myBlendFunction.BlendFlags = 0;
        myBlendFunction.SourceConstantAlpha = 255;  //use per-pixel alpha values
        myBlendFunction.AlphaFormat = AC_SRC_ALPHA;

        if ( myAlphaBlend(hdc,
                          dstRect->left,
                          dstRect->top,
                          dstRect->right - dstRect->left,
                          dstRect->bottom - dstRect->top,
                          hMemDC,
                          srcRect->left,
                          srcRect->top,
                          srcRect->right - srcRect->left,
                          srcRect->bottom - srcRect->top,
                          myBlendFunction) == GDI_ERROR )
        {
            WARNING(("AlphaBlend failed"));
            goto handle_err;
        }

        // Free the resource

        SelectObject(hMemDC, hOldBitMap);
        
        DeleteObject(hBitMap);
        DeleteDC(hMemDC);
    }
    else
    {
        // Call GDI to do the drawing

        if (StretchDIBits(
                hdc,
                dstRect->left,
                dstRect->top,
                dstRect->right - dstRect->left,
                dstRect->bottom - dstRect->top,
                srcRect->left,
                srcRectTop,
                srcRect->right - srcRect->left,
                srcRect->bottom - srcRect->top,
                dataptr,
                (BITMAPINFO*) &bmpinfo,
                DIB_RGB_COLORS,
                SRCCOPY) == GDI_ERROR)
        {
            WARNING(("StretchDIBits failed"));

            goto handle_err;
        }
    }

    return hr;

handle_err:
    DWORD err = GetLastError();

    hr = HRESULT_FROM_WIN32(err);

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Draw the bitmap into a GDI device context
*   by creating a temporary bitmap in 32bpp ARGB canonical format
*   and then call GDI calls.
*
* Arguments:
*
*   hdc - Specifies the destination device context to draw into
*   dstRect - Specifies the area on the destination DC
*   srcRect - Specifies the source area in the bitmap image
*
* Return Value:
*
*   Status code
*
* Notes:
*
*   We assume the current bitmap object is already marked busy.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::DrawCanonical(
    HDC hdc,
    const RECT* dstRect,
    RECT* srcRect
    )
{
    // Create a temporary bitmap in 32bpp ARGB canonical pixel format

    GpMemoryBitmap bmpcopy;
    HRESULT hr;
    RECT rect;

    rect.left = rect.top = 0;
    rect.right = srcRect->right - srcRect->left;
    rect.bottom = srcRect->bottom - srcRect->top;

    hr = bmpcopy.InitNewBitmap(rect.right, rect.bottom, PIXFMT_32BPP_ARGB);

    // Convert from current pixel format into 32bpp ARGB

    if (SUCCEEDED(hr))
    {
        BitmapData bmpdata;

        bmpcopy.GetBitmapAreaData(&rect, &bmpdata);

        hr = InternalLockBits(
                srcRect,
                IMGLOCK_READ|IMGLOCK_USERINPUTBUF,
                PIXFMT_32BPP_ARGB,
                &bmpdata);

        if (SUCCEEDED(hr))
            InternalUnlockBits(srcRect, &bmpdata);

    }

    // Draw the temporary bitmap
    rect.left = Pixel2HiMetric(rect.left, xdpi);
    rect.right = Pixel2HiMetric(rect.right, xdpi);
    rect.top = Pixel2HiMetric(rect.top, ydpi);
    rect.bottom = Pixel2HiMetric(rect.bottom, ydpi);

    if (SUCCEEDED(hr))
        hr = bmpcopy.Draw(hdc, dstRect, &rect);

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Push image data into an IImageSink
*
* Arguments:
*
*   sink - The sink for receiving bitmap image data
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::PushIntoSink(
    IN IImageSink* sink
    )
{
    if ( !IsValid() )
    {
        return E_FAIL;
    }

    // Lock the bitmap object

    GpLock lock(&objectLock);

    if (lock.LockFailed())
        return IMGERR_OBJECTBUSY;

    ImageInfo imageinfo;
    RECT subarea, bandRect;
    BitmapData bmpdata;
    HRESULT hr;

    imageinfo.RawDataFormat = IMGFMT_MEMORYBMP;
    imageinfo.PixelFormat = PixelFormat;
    imageinfo.Width = imageinfo.TileWidth = Width;
    imageinfo.Height = imageinfo.TileHeight = Height;
    imageinfo.Xdpi = xdpi;
    imageinfo.Ydpi = ydpi;

    imageinfo.Flags = SINKFLAG_TOPDOWN | SINKFLAG_FULLWIDTH;

    // Check if the image in the memory has alpha or not. If YES, set the
    // HASALPHA flag, before we push it into the sink.
    // Note: We should use CanHaveAlpha() here. But since this function is
    // broken for indexed format, we have to check it explicitly here.
    // Note: Inside CanHaveAlpha(), for an index pixel format, it should check
    // if it has PALFLAG_HASALPHA flag set before it can claim it has alpha.
    // See Windows bug#392927 to see what will happen if we don't set this flag
    // correctly.

    if ( IsAlphaPixelFormat(PixelFormat) ||
         ( IsIndexedPixelFormat(PixelFormat) &&
           colorpal &&
           (colorpal->Flags & PALFLAG_HASALPHA) ) )
    {
        imageinfo.Flags |= SINKFLAG_HASALPHA;
    }

    // Negotiate the parameters with the sink

    hr = sink->BeginSink(&imageinfo, &subarea);

    if (FAILED(hr))
        return hr;

    // Validate subarea information returned by the sink

    PixelFormatID pixfmt = imageinfo.PixelFormat;

    if (!ValidateImageArea(&bandRect, &subarea) ||
        !IsValidPixelFormat(pixfmt) ||
        imageinfo.TileHeight == 0)
    {
        hr = E_UNEXPECTED;
        goto exitPushIntoSink;
    }

    // Give the sink our color palette, if any

    const ColorPalette* pal;

    if (pal = GetCurrentPalette())
    {
        hr = sink->SetPalette(pal);

        if (FAILED(hr))
            goto exitPushIntoSink;
    }

    if (PixelFormat == pixfmt)
    {
        // Fast path: the sink can take our native pixel format
        // Just give our bitmap data to the sink in one shot.

        GetBitmapAreaData(&bandRect, &bmpdata);
        hr = sink->PushPixelData(&bandRect, &bmpdata, TRUE);
    }
    else
    {
        // Give data to the sink one band at a time
        // and perform pixel format conversion too

        INT ymax = bandRect.bottom;
        INT w = bandRect.right - bandRect.left;
        INT dh = imageinfo.TileHeight;

        // Throttle memory usage by limiting band size

        INT lineSize = (w * GetPixelFormatSize(pixfmt) + 7) / 8;
        INT maxBand = OSInfo::VAllocChunk * 4 / lineSize;

        if (dh > maxBand)
            dh = maxBand;

        // Allocate a temporary buffer large enough for one band

        bmpdata.Reserved = 0;

        if (!AllocBitmapData(w, dh, pixfmt, &bmpdata, NULL))
        {
            hr = E_OUTOFMEMORY;
            goto exitPushIntoSink;
        }

        BitmapData tempData = bmpdata;

        do
        {
            // Check for abort.

            if (callback && ((*callback)(callbackData)))
            {
                hr = IMGERR_ABORT;
                break;
            }

            // Get pixel data for the current band

            bandRect.bottom = bandRect.top + dh;

            if (bandRect.bottom > ymax)
                bandRect.bottom = ymax;

            hr = InternalLockBits(
                    &bandRect,
                    IMGLOCK_READ|IMGLOCK_USERINPUTBUF,
                    pixfmt,
                    &tempData);

            if (SUCCEEDED(hr))
            {
                // Push the current band to the sink

                hr = sink->PushPixelData(&bandRect, &tempData, TRUE);
                InternalUnlockBits(&bandRect, &tempData);
            }

            if (FAILED(hr))
                break;

            // Move on to the next band

            bandRect.top += dh;
        }
        while (bandRect.top < ymax);

        FreeBitmapData(&bmpdata);
    }

exitPushIntoSink:

    return sink->EndSink(hr);
}


/**************************************************************************\
*
* Function Description:
*
*   Get bitmap dimensions in pixels
*
* Arguments:
*
*   size - Buffer for returning bitmap size
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::GetSize(
    OUT SIZE* size
    )
{
    if ( !IsValid() )
    {
        return E_FAIL;
    }

    GpLock lock(&objectLock);

    if (lock.LockFailed())
        return IMGERR_OBJECTBUSY;

    size->cx = Width;
    size->cy = Height;
    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Access bitmap pixel data
*
* Arguments:
*
*   rect - Specifies the area of the bitmap to be accessed
*       NULL means the entire bitmap
*   flags - Misc. lock flags
*   pixfmt - Specifies the desired pixel data format
*   lockedBitmapData - Return information about the locked pixel data
*
* Return Value:
*
*   Status code
*
* Notes:
*
*   If IMGLOCK_USERINPUTBUF bit of flags is set, then the caller must
*   also initialize the scan0 and stride fields of lockedBitmapData.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::LockBits(
    IN const RECT* rect,
    IN UINT flags,
    IN PixelFormatID pixfmt,
    OUT BitmapData* lockedBitmapData
    )
{
    if ( !IsValid() )
    {
        return E_FAIL;
    }

    // Validate input parameters

    if (pixfmt != PIXFMT_DONTCARE && !IsValidPixelFormat(pixfmt) ||
        (flags & ~BMPDATA_LOCKMODEMASK) != 0 ||
        !lockedBitmapData ||
        (flags & IMGLOCK_USERINPUTBUF) && !lockedBitmapData->Scan0)
    {
        WARNING(("Invalid parameters in LockBits"));
        return E_INVALIDARG;
    }

    // Lock the current bitmap object

    GpLock lock(&objectLock);

    if (lock.LockFailed())
        return IMGERR_OBJECTBUSY;

    // We can only have one lock at a time
    // Validate the specified lock area, if any

    HRESULT hr;

    if (InterlockedIncrement(&bitsLock) != 0)
        hr = IMGERR_BADLOCK;
    else if (!ValidateImageArea(&lockedArea, rect))
    {
        WARNING(("Invalid bitmap area in LockBits"));
        hr = E_INVALIDARG;
    }
    else
        hr = InternalLockBits(&lockedArea, flags, pixfmt, lockedBitmapData);

    if (FAILED(hr))
        InterlockedDecrement(&bitsLock);

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Internal implementation of IBitmapImage::LockBits method.
*   We assume parameter validation and internal house-keeping chores
*   (object locks, etc.) have already been done.
*
* Arguments:
*
*   Same as for LockBits.
*
* Return Value:
*
*   Status code.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::InternalLockBits(
    const RECT* rect,
    UINT flags,
    PixelFormatID pixfmt,
    BitmapData* lockedData
    )
{
    HRESULT hr;

    if((hr = LockDirectDrawSurface()) != S_OK)
        return hr;

    // Composite a BitmapData structure for 
    // the specified area of the bitmap image

    BitmapData bmpdata;

    GetBitmapAreaData(rect, &bmpdata);

    // Make sure the left side of the locked area
    // is aligned on a byte boundary

    UINT pixsize;
    UINT startBit;

    if (pixfmt == PIXFMT_DONTCARE)
        pixfmt = PixelFormat;

    pixsize = GetPixelFormatSize(pixfmt);
    startBit = GetPixelFormatSize(PixelFormat) * rect->left & 7;

    lockedData->Width = bmpdata.Width;
    lockedData->Height = bmpdata.Height;
    lockedData->PixelFormat = pixfmt;
    lockedData->Reserved = flags;

    // Fast case: the requested pixel format is the same
    // as our internal pixel format AND the left side of
    // the locked area is byte-aligned.

    if (pixfmt == PixelFormat && startBit == 0)
    {
        if (! (flags & IMGLOCK_USERINPUTBUF))
        {
            // Return a pointer directly to our
            // internal bitmap pixel data buffer

            lockedData->Scan0 = bmpdata.Scan0;
            lockedData->Stride = bmpdata.Stride;
        }
        else if (flags & IMGLOCK_READ)
        {
            //
            // Use the caller-supplied buffer
            //

            const BYTE* s = (const BYTE*) bmpdata.Scan0;
            BYTE* d = (BYTE*) lockedData->Scan0;
            UINT bytecnt = (bmpdata.Width * pixsize + 7) >> 3;
            UINT y = bmpdata.Height;

            while (y--)
            {
                memcpy(d, s, bytecnt);
                s += bmpdata.Stride;
                d += lockedData->Stride;
            }
        }

        return S_OK;
    }

    // Slow case: the requested pixel format doesn't match
    // the native pixel format of the bitmap image.
    // We allocate a temporary buffer if the caller didn't
    // provide one and do format conversion.

    if (! (flags & IMGLOCK_USERINPUTBUF) &&
        ! AllocBitmapData(bmpdata.Width, bmpdata.Height, pixfmt, lockedData, NULL))
    {
        UnlockDirectDrawSurface();
        return E_OUTOFMEMORY;
    }

    // If locking for write only, then don't need to read source pixels.
    // NOTE: The initial content of the locked bitmap data is undefined.

    if (! (flags & IMGLOCK_READ))
        return S_OK;

    if (startBit == 0)
    {
        // Perform format conversion on source pixel data

        hr = ConvertBitmapData(
                lockedData,
                colorpal,
                &bmpdata,
                colorpal);
    }
    else
    {
        // Very slow case: the left side of the locked area
        // is NOT byte-aligned. 

        hr = ConvertBitmapDataSrcUnaligned(
                lockedData,
                colorpal,
                &bmpdata,
                colorpal,
                startBit);
    }

    if (FAILED(hr))
    {
        FreeBitmapData(lockedData);
        UnlockDirectDrawSurface();
    }

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Unlock an area of the bitmap previously locked by a LockBits call
*
* Arguments:
*
*   lockedBitmapData - Information returned by a previous LockBits call
*       Must not have been modified since LockBits returned.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::UnlockBits(
    IN const BitmapData* lockedBitmapData
    )
{
    if ( !IsValid() )
    {
        return E_FAIL;
    }

    // Lock the current bitmap object

    HRESULT hr;
    GpLock lock(&objectLock);

    if (lock.LockFailed())
        hr = IMGERR_OBJECTBUSY;
    else if (lockedBitmapData == NULL)
        hr = E_INVALIDARG;
    else if (bitsLock != 0)
        hr = IMGERR_BADUNLOCK;
    else
    {
        hr = InternalUnlockBits(&lockedArea, lockedBitmapData);
        InterlockedDecrement(&bitsLock);
    }

    return hr;
}

HRESULT
GpMemoryBitmap::InternalUnlockBits(
    const RECT* rect,
    const BitmapData* lockedData
    )
{
    HRESULT hr;
    UINT_PTR flags = lockedData->Reserved;

    if (flags & IMGLOCK_WRITE)
    {
        if (flags & (BMPDATA_ALLOCMASK | IMGLOCK_USERINPUTBUF))
        {
            // Composite a BitmapData structure for
            // the specified area of the bitmap image

            BitmapData bmpdata;
            GetBitmapAreaData(rect, &bmpdata);

            UINT startBit;

            startBit = GetPixelFormatSize(PixelFormat) * rect->left & 7;

            if (startBit == 0)
            {
                // The left column of the locked area is byte-aligned

                hr = ConvertBitmapData(
                        &bmpdata,
                        colorpal,
                        lockedData,
                        colorpal);
            }
            else
            {
                // The left column of the locked area is NOT byte-aligned.

                hr = ConvertBitmapDataDstUnaligned(
                        &bmpdata,
                        colorpal,
                        lockedData,
                        colorpal,
                        startBit);
            }
        }
        else
            hr = S_OK;

        // if the destination has alpha and the locked format has alpha,
        // then lockbits may have caused the alpha data to change

        if (CanHaveAlpha(PixelFormat, colorpal) &&
            (IsAlphaPixelFormat(lockedData->PixelFormat) || 
             IsIndexedPixelFormat(lockedData->PixelFormat)))
        {
            if (this->PixelFormat == PIXFMT_16BPP_ARGB1555)
            {
                alphaTransparency = ALPHA_SIMPLE;
            }
            else
            {
                alphaTransparency = ALPHA_UNKNOWN;
            }
        }
        else
        {
            alphaTransparency = ALPHA_NONE;
        }
    }
    else
        hr = S_OK;

    // Always free any temporary buffer we allocated during LockBits
    // whether or not unlock was successful.

    FreeBitmapData(lockedData);

    // Always unlock the direct draw surface

    UnlockDirectDrawSurface();

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Set color palette associated with the bitmap image
*
* Arguments:
*
*   palette - Specifies the new color palette
*       NULL to remove an existing palette associated with the image.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::SetPalette(
    IN const ColorPalette* palette
    )
{
    // Validate input parameters

    if ( palette == NULL )
    {
        WARNING(("Invalid parameter in SetPalette"));
        return E_INVALIDARG;
    }

    // Make a copy of the input color palette

    ColorPalette* newpal = CloneColorPalette(palette);

    if (newpal == NULL)
        return E_OUTOFMEMORY;

    // Lock the current bitmap object

    GpLock lock(&objectLock);

    if (lock.LockFailed())
    {
        GpFree(newpal);
        return IMGERR_OBJECTBUSY;
    }


    // !!! [asecchia] what does it mean to set a palette on a non
    // palettized image.

    // Free the old palette, if any
    // and select the new palette into the bitmap object
    if ( NULL != this->colorpal )
    {
        GpFree(this->colorpal);
    }

    this->colorpal = newpal;

    // Compute transparancy hint from palette
    alphaTransparency = ALPHA_OPAQUE;
    for (UINT i = 0; i < newpal->Count; i++)
    {
        ARGB argb = newpal->Entries[i] & 0xff000000;

        if (argb != 0xff000000)
        {
            if (argb == 0)
                alphaTransparency = ALPHA_SIMPLE;
            else
            {
                alphaTransparency = ALPHA_COMPLEX;
                break;
            }
        }
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Get color palette associated with the bitmap image
*
* Arguments:
*
*   palette - Returns a pointer to a copy of the color palette
*       associated with the current image
*
* Return Value:
*
*   Status code
*
* Notes:
*
*   If a palette is returned to the caller, the caller is then
*   responsible to free the memory afterwards by calling CoTaskMemFree.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::GetPalette(
    OUT ColorPalette** palette
    )
{
    HRESULT hr;

    *palette = NULL;

    GpLock lock(&objectLock);

    if (lock.LockFailed())
        hr = IMGERR_OBJECTBUSY;
    else
    {
        const ColorPalette* pal = GetCurrentPalette();
        
        if (pal == NULL)
            hr = IMGERR_NOPALETTE;
        else if ((*palette = CloneColorPalette(pal, TRUE)) == NULL)
            hr = E_OUTOFMEMORY;
        else
            hr = S_OK;
    }

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Begin sinking source image data into the bitmap object
*
* Arguments:
*
*   imageInfo - For negotiating data transfer parameters with the source
*   subarea - For returning subarea information
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::BeginSink(
    IN OUT ImageInfo* imageInfo,
    OUT OPTIONAL RECT* subarea
    )
{
    // We only access in-memory pixel data

    imageInfo->RawDataFormat = IMGFMT_MEMORYBMP;

    // Negotiate pixel format

    PixelFormatID pixfmt;

    if ((pixfmt = PixelFormat) == PIXFMT_DONTCARE)
        pixfmt = imageInfo->PixelFormat;

    if (!IsValidPixelFormat(pixfmt))
        return E_INVALIDARG;

    // Indicate whether we can support alpha

    if (IsAlphaPixelFormat(pixfmt) || IsIndexedPixelFormat(pixfmt))
        imageInfo->Flags |= SINKFLAG_HASALPHA;
    else
        imageInfo->Flags &= ~SINKFLAG_HASALPHA;

    // Check if we can support composite semantics

    if (!IsValid())
        imageInfo->Flags &= ~SINKFLAG_COMPOSITE;

    // We don't support multi-pass for now. MINLIU 08/22/00
    // This fixes a bunch of GIF problems.

    imageInfo->Flags &= ~SINKFLAG_MULTIPASS;

    // Negotiate bitmap dimension

    BOOL noCurDimension = (Width == 0 && Height == 0);
    BOOL srcScalable = (imageInfo->Flags & SINKFLAG_SCALABLE);

    if (noCurDimension && srcScalable)
    {
        // Current bitmap is empty and source is scalable:
        //  use the source dimension and sink's resolution

        Width = imageInfo->Width;
        Height = imageInfo->Height;

        imageInfo->Xdpi = xdpi;
        imageInfo->Ydpi = ydpi;
    }
    else if (noCurDimension ||
             Width == imageInfo->Width && Height == imageInfo->Height)
    {
        // Current image is empty:
        //  use the source dimension and resolution

        ASSERT(!noCurDimension || Scan0 == NULL);

        Width = imageInfo->Width;
        Height = imageInfo->Height;
        xdpi = imageInfo->Xdpi;
        ydpi = imageInfo->Ydpi;
    }
    else if (srcScalable)
    {
        // Source is scalable and sink has a preferred dimension
        //  use the sink's preferred dimension

        xdpi = imageInfo->Xdpi * Width / imageInfo->Width;
        ydpi = imageInfo->Ydpi * Height / imageInfo->Height;

        imageInfo->Width = Width;
        imageInfo->Height = Height;
        imageInfo->Xdpi = xdpi;
        imageInfo->Ydpi = ydpi;
    }
    else
    {
        // Source is not scalable and sink has a preferred dimension
        return E_INVALIDARG;
    }

    // Allocate bitmap memory buffer

    if (!IsValid())
    {
        HRESULT hr = AllocBitmapMemory(Width, Height, pixfmt);

        if (FAILED(hr))
            return hr;
    }

    // We always want the whole source image

    if (subarea)
    {
        subarea->left = subarea->top = 0;
        subarea->right = Width;
        subarea->bottom = Height;
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   End the sink process
*
* Arguments:
*
*   statusCode - Last status code
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::EndSink(
    HRESULT statusCode
    )
{
    return statusCode;
}


/**************************************************************************\
*
* Function Description:
*
*   Ask the sink to allocate pixel data buffer
*
* Arguments:
*
*   rect - Specifies the interested area of the bitmap
*   pixelFormat - Specifies the desired pixel format
*   lastPass - Whether this the last pass over the specified area
*   bitmapData - Returns information about pixel data buffer
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::GetPixelDataBuffer(
    IN const RECT* rect,
    IN PixelFormatID pixelFormat,
    IN BOOL lastPass,
    OUT BitmapData* bitmapData
    )
{
    ASSERT(bitmapData);

    if (IsValid())
        return LockBits(rect, IMGLOCK_WRITE, pixelFormat, bitmapData);
    else
        return E_UNEXPECTED;
}


/**************************************************************************\
*
* Function Description:
*
*   Give the sink pixel data and release data buffer
*
* Arguments:
*
*   bitmapData - Buffer filled by previous GetPixelDataBuffer call
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::ReleasePixelDataBuffer(
    IN const BitmapData* bitmapData
    )
{
    ASSERT(bitmapData);

    if (IsValid())
        return UnlockBits(bitmapData);
    else
        return E_UNEXPECTED;
}


/**************************************************************************\
*
* Function Description:
*
*   Push pixel data into the bitmap object
*
* Arguments:
*
*   rect - Specifies the affected area of the bitmap 
*   bitmapData - Info about the pixel data being pushed
*   lastPass - Whether this is the last pass over the specified area
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::PushPixelData(
    IN const RECT* rect,
    IN const BitmapData* bitmapData,
    IN BOOL lastPass
    )
{
    ASSERT(bitmapData);

    if (bitmapData->PixelFormat == PIXFMT_DONTCARE)
        return E_INVALIDARG;

    // Lock the bitmap object

    HRESULT hr;
    RECT area;
    GpLock lock(&objectLock);

    if (lock.LockFailed())
        hr = IMGERR_OBJECTBUSY;
    else if (!IsValid())
        hr = E_UNEXPECTED;
    else if (!ValidateImageArea(&area, rect))
        hr = E_INVALIDARG;
    else
    {
        BitmapData tempData = *bitmapData;
    
        // Push pixel data into the bitmap
    
        hr = InternalLockBits(
                &area,
                IMGLOCK_WRITE|IMGLOCK_USERINPUTBUF,
                tempData.PixelFormat,
                &tempData);
    
        if (SUCCEEDED(hr))
            hr = InternalUnlockBits(&area, &tempData);

    }
    
    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Push raw image data into the bitmap
*
* Arguments:
*
*   buffer - Pointer to image data buffer
*   bufsize - Size of the data buffer
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::PushRawData(
    IN const VOID* buffer,
    IN UINT bufsize
    )
{
    // We don't support raw image data transfer.
    // The only format we support is in-memory pixel data.

    return E_NOTIMPL;
}


/**************************************************************************\
*
* Function Description:
*
*   Get a thumbnail representation for the image object
*
* Arguments:
*
*   thumbWidth, thumbHeight - Specifies the desired thumbnail size in pixels
*   thumbImage - Return a pointer to the thumbnail image
*       The caller should Release it after using it.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::GetThumbnail(
    IN OPTIONAL UINT thumbWidth,
    IN OPTIONAL UINT thumbHeight,
    OUT IImage** thumbImage
    )
{
    if (thumbWidth == 0 && thumbHeight == 0)
        thumbWidth = thumbHeight = DEFAULT_THUMBNAIL_SIZE;

    if (thumbWidth && !thumbHeight ||
        !thumbWidth && thumbHeight)
    {
        return E_INVALIDARG;
    }

    // Generate the thumbnail using the averaging interpolation algorithm

    HRESULT hr;
    GpMemoryBitmap* bmp;

    hr = GpMemoryBitmap::CreateFromImage(
                        this,
                        thumbWidth,
                        thumbHeight,
                        PIXFMT_DONTCARE,
                        INTERP_AVERAGING,
                        &bmp);

    if (SUCCEEDED(hr))
    {
        hr = bmp->QueryInterface(IID_IImage, (VOID**) thumbImage);
        bmp->Release();
    }

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   Lock and update appropriate class member data if the direct draw 
*   suface referenced by the bitmap exists.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::LockDirectDrawSurface(void)
{
    HRESULT hr = S_OK;

    if(creationFlag == CREATEDFROM_DDRAWSURFACE)
    {
        ASSERT(ddrawSurface != NULL);
        ASSERT(Scan0 == NULL);

        DDSURFACEDESC2 ddsd;
        
        memset(&ddsd, 0, sizeof(ddsd));
        ddsd.dwSize = sizeof(ddsd);
        hr = ddrawSurface->Lock(NULL, &ddsd, DDLOCK_WAIT, NULL);

        if(hr == DD_OK)
        {
            ASSERT(ddsd.lpSurface != NULL);
            ASSERT(!(ddsd.lPitch & 3));
            Scan0 = ddsd.lpSurface;
            Stride = ddsd.lPitch;
        }
        else
        {
            WARNING(("Unable to lock direct draw suface"));
        }

    }

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   Unlock the direct draw suface referenced by the bitmap if it exists.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::UnlockDirectDrawSurface(void)
{
    HRESULT hr = S_OK;

    if(creationFlag == CREATEDFROM_DDRAWSURFACE)
    {
        ASSERT(Scan0 != NULL);

        hr = ddrawSurface->Unlock(NULL);
        Scan0 = NULL;
        Stride = 0;

        if(hr != DD_OK)
        {
            WARNING(("Error unlocking direct draw surface"));
        }
    }

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   Retrieves the transparency of the GpMemoryBitmap.
*
* Arguments:
*
*   transparency - return buffer for the transparency hint
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::GetAlphaHint(INT* alphaHint)
{
    HRESULT hr = S_OK;

    *alphaHint = alphaTransparency;

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   Sets the transparency of the GpMemoryBitmap.
*
* Arguments:
*
*   transparency - new transparency hint
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::SetAlphaHint(INT alphaHint)
{
    HRESULT hr = S_OK;

    alphaTransparency = alphaHint;

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   Get the counter of property items in the image
*
* Arguments:
*
*   [OUT]numOfProperty - The number of property items in the image
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   09/06/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::GetPropertyCount(
    OUT UINT*   numOfProperty
    )
{
    if ( numOfProperty == NULL )
    {
        WARNING(("GpMemoryBitmap::GetPropertyCount---Invalid input parameter"));
        return E_INVALIDARG;
    }

    // Note: we don't need to check if there is a property in this
    // GpMemoryBitmap object or not.
    // If it doesn't have one, we will return zero (initialized in constructor).
    // Otherwise, return the real counter

    *numOfProperty = PropertyNumOfItems;

    return S_OK;
}// GetPropertyCount()

/**************************************************************************\
*
* Function Description:
*
*   Get a list of property IDs for all the property items in the image
*
* Arguments:
*
*   [IN]  numOfProperty - The number of property items in the image
*   [OUT] list----------- A memory buffer the caller provided for storing the
*                         ID list
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   09/06/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::GetPropertyIdList(
    IN UINT numOfProperty,
  	IN OUT PROPID* list
    )
{
    if ( (numOfProperty != PropertyNumOfItems) || (list == NULL) )
    {
        WARNING(("GpMemoryBitmap::GetPropertyIdList--invalid parameters"));
        return E_INVALIDARG;
    }

    if ( PropertyNumOfItems == 0 )
    {
        // This is OK since there is no property in this image

        return S_OK;
    }
    
    // Coping list IDs from our internal property item list

    InternalPropertyItem*   pTemp = PropertyListHead.pNext;

    for ( int i = 0;
         (  (i < (INT)PropertyNumOfItems) && (pTemp != NULL)
         && (pTemp != &PropertyListTail));
         ++i )
    {
        list[i] = pTemp->id;
        pTemp = pTemp->pNext;
    }

    return S_OK;
}// GetPropertyIdList()

/**************************************************************************\
*
* Function Description:
*
*   Get the size, in bytes, of a specific property item, specified by the
*   property ID
*
* Arguments:
*
*   [IN]propId - The ID of a property item caller is interested
*   [OUT]size--- Size of this property item, in bytes
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   09/06/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::GetPropertyItemSize(
    IN PROPID propId,
    OUT UINT* size
    )
{
    if ( size == NULL )
    {
        WARNING(("GpMemoryBitmap::GetPropertyItemSize--size is NULL"));
        return E_INVALIDARG;
    }

    if ( PropertyNumOfItems < 1 )
    {
        // No property item exist in this GpMemoryBitmap object

        WARNING(("GpMemoryBitmap::GetPropertyItemSize---No property exist"));
        return E_FAIL;
    }

    // Loop through our cache list to see if we have this ID or not
    // Note: if pTemp->pNext == NULL, it means pTemp points to the Tail node

    InternalPropertyItem*   pTemp = PropertyListHead.pNext;

    while ( (pTemp->pNext != NULL) && (pTemp->id != propId) )
    {
        pTemp = pTemp->pNext;
    }

    if ( pTemp->pNext == NULL )
    {
        // This ID doesn't exist

        WARNING(("MemBitmap::GetPropertyItemSize-Required item doesn't exist"));
        return IMGERR_PROPERTYNOTFOUND;
    }

    // The size of an property item should be "The size of the item structure
    // plus the size for the value

    *size = pTemp->length + sizeof(PropertyItem);

    return S_OK;
}// GetPropertyItemSize()

/**************************************************************************\
*
* Function Description:
*
*   Get a specific property item, specified by the prop ID.
*
* Arguments:
*
*   [IN]propId -- The ID of the property item caller is interested
*   [IN]propSize- Size of the property item. The caller has allocated these
*                 "bytes of memory" for storing the result
*   [OUT]pItemBuffer- A memory buffer for storing this property item
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   09/06/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::GetPropertyItem(
    IN  PROPID              propId,
    IN  UINT                propSize,
    IN  OUT PropertyItem*   pItemBuffer
    )
{
    if ( pItemBuffer == NULL )
    {
        WARNING(("GpMemoryBitmap::GetPropertyItem--Input buffer is NULL"));
        return E_INVALIDARG;
    }

    if ( PropertyNumOfItems < 1 )
    {
        // No property item exist in this GpMemoryBitmap object

        WARNING(("GpMemoryBitmap::GetPropertyItem---No property exist"));
        return E_FAIL;
    }

    // Loop through our cache list to see if we have this ID or not
    // Note: if pTemp->pNext == NULL, it means pTemp points to the Tail node

    InternalPropertyItem*   pTemp = PropertyListHead.pNext;
    UNALIGNED BYTE*   pOffset = (BYTE*)pItemBuffer + sizeof(PropertyItem);

    while ( (pTemp->pNext != NULL) && (pTemp->id != propId) )
    {
        pTemp = pTemp->pNext;
    }

    if ( pTemp->pNext == NULL )
    {
        // This ID doesn't exist in the list

        WARNING(("GpMemBitmap::GetPropertyItem---Require item doesn't exist"));
        return IMGERR_PROPERTYNOTFOUND;
    }
    else if ( (pTemp->length + sizeof(PropertyItem)) != propSize )
    {
        WARNING(("GpMemBitmap::GetPropertyItem---Invalid input propsize"));
        return E_FAIL;
    }

    // Found the ID in the list and return the item

    pItemBuffer->id = pTemp->id;
    pItemBuffer->length = pTemp->length;
    pItemBuffer->type = pTemp->type;
    pItemBuffer->value = pOffset;

    GpMemcpy(pOffset, pTemp->value, pTemp->length);

    return S_OK;
}// GetPropertyItem()

/**************************************************************************\
*
* Function Description:
*
*   Get the size of ALL property items in the image
*
* Arguments:
*
*   [OUT]totalBufferSize-- Total buffer size needed, in bytes, for storing all
*                          property items in the image
*   [OUT]numOfProperty --- The number of property items in the image
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   09/06/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::GetPropertySize(
    OUT UINT* totalBufferSize,
    OUT UINT* numProperties
    )
{
    if ( (totalBufferSize == NULL) || (numProperties == NULL) )
    {
        WARNING(("GpMemoryBitmap::GetPropertySize--invalid inputs"));
        return E_INVALIDARG;
    }

    // Note: we don't need to check if there is a property in this
    // GpMemoryBitmap object or not.
    // If it doesn't have one, we will return zero (initialized in constructor).
    // Otherwise, return the real counter
    
    *numProperties = PropertyNumOfItems;

    // Total buffer size should be list value size plus the total header size

    *totalBufferSize = PropertyListSize
                     + PropertyNumOfItems * sizeof(PropertyItem);

    return S_OK;
}// GetPropertySize()

/**************************************************************************\
*
* Function Description:
*
*   Get ALL property items in the image
*
* Arguments:
*
*   [IN]totalBufferSize-- Total buffer size, in bytes, the caller has allocated
*                         memory for storing all property items in the image
*   [IN]numOfProperty --- The number of property items in the image
*   [OUT]allItems-------- A memory buffer caller has allocated for storing all
*                         the property items
*
*   Note: "allItems" is actually an array of PropertyItem
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   09/06/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::GetAllPropertyItems(
    IN UINT totalBufferSize,
    IN UINT numProperties,
    IN OUT PropertyItem* allItems
    )
{
    // Figure out total property header size first

    UINT    uiHeaderSize = PropertyNumOfItems * sizeof(PropertyItem);

    if ( (totalBufferSize != (uiHeaderSize + PropertyListSize))
       ||(numProperties != PropertyNumOfItems)
       ||(allItems == NULL) )
    {
        WARNING(("GpMemoryBitmap::GetPropertyItems--invalid inputs"));
        return E_INVALIDARG;
    }

    if ( PropertyNumOfItems < 1 )
    {
        // No property item exist in this GpMemoryBitmap object

        WARNING(("GpMemoryBitmap::GetAllPropertyItems---No property exist"));
        return E_FAIL;
    }

    // Loop through our cache list and assigtn the result out

    InternalPropertyItem*   pTempSrc = PropertyListHead.pNext;
    PropertyItem*           pTempDst = allItems;
    UNALIGNED BYTE*         pOffSet = (UNALIGNED BYTE*)allItems + uiHeaderSize;
        
    for ( int i = 0; i < (INT)PropertyNumOfItems; ++i )
    {
        pTempDst->id = pTempSrc->id;
        pTempDst->length = pTempSrc->length;
        pTempDst->type = pTempSrc->type;
        pTempDst->value = (void*)pOffSet;

        GpMemcpy(pOffSet, pTempSrc->value, pTempSrc->length);

        pOffSet += pTempSrc->length;
        pTempSrc = pTempSrc->pNext;
        pTempDst++;
    }
    
    return S_OK;
}// GetAllPropertyItems()

/**************************************************************************\
*
* Function Description:
*
*   Remove a specific property item, specified by the prop ID.
*
* Arguments:
*
*   [IN]propId -- The ID of the property item to be removed
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   09/06/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::RemovePropertyItem(
    IN PROPID   propId
    )
{
    if ( PropertyNumOfItems < 1 )
    {
        WARNING(("GpMemoryBitmap::RemovePropertyItem--No property item exist"));
        return E_FAIL;
    }

    // Loop through our cache list to see if we have this ID or not
    // Note: if pTemp->pNext == NULL, it means pTemp points to the Tail node

    InternalPropertyItem*   pTemp = PropertyListHead.pNext;

    while ( (pTemp->pNext != NULL) && (pTemp->id != propId) )
    {
        pTemp = pTemp->pNext;
    }

    if ( pTemp->pNext == NULL )
    {
        // Item not found

        WARNING(("GpMemoryBitmap::RemovePropertyItem-Property item not found"));
        return IMGERR_PROPERTYNOTFOUND;
    }

    // Found the item in the list. Remove it

    PropertyNumOfItems--;
    PropertyListSize -= pTemp->length;
        
    RemovePropertyItemFromList(pTemp);
       
    // Remove the item structure

    GpFree(pTemp);

    return S_OK;
}// RemovePropertyItem()

/**************************************************************************\
*
* Function Description:
*
*   Set a property item, specified by the propertyitem structure. If the item
*   already exists, then its contents will be updated. Otherwise a new item
*   will be added
*
* Arguments:
*
*   [IN]item -- A property item the caller wants to set
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   09/06/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::SetPropertyItem(
    IN PropertyItem item
    )
{
    InternalPropertyItem*   pTemp = PropertyListHead.pNext;
        
    // There are property items in the list.
    // Loop through our cache list to see if we have this ID or not
    // Note: if pTemp->pNext == NULL, it means pTemp points to the Tail node

    while ( (pTemp->pNext != NULL) && (pTemp->id != item.id) )
    {
        pTemp = pTemp->pNext;
    }

    if ( pTemp->pNext == NULL )
    {
        // This item doesn't exist in the list, add it into the list
        
        PropertyNumOfItems++;
        PropertyListSize += item.length;
        
        if ( AddPropertyList(&PropertyListTail,
                             item.id,
                             item.length,
                             item.type,
                             item.value) != S_OK )
        {
            WARNING(("GpMemBitmap::SetPropertyItem-AddPropertyList() failed"));
            return E_FAIL;
        }
    }
    else
    {
        // This item already exists in the link list, update the info
        // Update the size first

        PropertyListSize -= pTemp->length;
        PropertyListSize += item.length;
        
        // Free the old item

        GpFree(pTemp->value);

        pTemp->length = item.length;
        pTemp->type = item.type;

        pTemp->value = GpMalloc(item.length);
        if ( pTemp->value == NULL )
        {
            // Since we already freed the old item, we should set its length to
            // 0 before return

            pTemp->length = 0;
            WARNING(("GpMemBitmap::SetPropertyItem-Out of memory"));
            return E_OUTOFMEMORY;
        }

        GpMemcpy(pTemp->value, item.value, item.length);
    }

    return S_OK;
}// SetPropertyItem()

/**************************************************************************\
*
* Function Description:
*
*   Sets the min/max alpha of the GpMemoryBitmap.
*
* Arguments:
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::SetMinMaxAlpha(BYTE minA, BYTE maxA)
{
    HRESULT hr = S_OK;

    minAlpha = minA;
    maxAlpha = maxA;

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   Gets the min/max alpha of the GpMemoryBitmap.
*
* Arguments:
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::GetMinMaxAlpha(BYTE* minA, BYTE* maxA)
{
    HRESULT hr = S_OK;

    *minA = minAlpha;
    *maxA = maxAlpha;

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   Get a pointer of the decoder.
*   The main purpose for this function is to get a pointer to the JPEg decoder
*   so that we can get information from the JPEG decoder and pass it to the
*   JPEG encoder. This way, we can preserve all the private application headers.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::SetSpecialJPEG(
    GpDecodedImage *pImgSrc         // Pointer to the DecodedImage, the source
    )
{
    HRESULT hr = E_INVALIDARG;

    if (pImgSrc)
    {
        ImageInfo imgInfo;
        hr = pImgSrc->GetImageInfo(&imgInfo);

        if (SUCCEEDED(hr))
        {
            // Check if the source is JPEG or not

            if (imgInfo.RawDataFormat == IMGFMT_JPEG)
            {
                // If we already have a pointer to the JPEG decoder somewhow,
                // release it first

                if (JpegDecoderPtr)
                {
                    JpegDecoderPtr->Release();
                    JpegDecoderPtr = NULL;
                }

                // Get the decoder pointer

                hr = pImgSrc->GetDecoderPtr(&JpegDecoderPtr);
                if (SUCCEEDED(hr))
                {
                    JpegDecoderPtr->AddRef();
                }
            }
            else
            {
                // Valid only the source is JPEG image

                hr = E_INVALIDARG;
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\api\codecmgr.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   codecmgr.cpp
*
* Abstract:
*
*   Image codec management functions
*
* Revision History:
*
*   05/13/1999 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "codecmgr.hpp"

extern BOOL SuppressExternalCodecs;

//
// Various data structures for maintaining the cache of codecs
//

static DWORD LastCheckRegTime;      // when was registry last checked
static DWORD SystemRegCookie;       // cookie value in the system hive
static DWORD UserRegCookie;         // cookie value in the user hive
static DWORD MaxSigSize;            // max signature size for all decoders
BOOL CodecCacheUpdated;      // whether codec cache was updated
CachedCodecInfo* CachedCodecs;      // cached list of codecs

// How frequently we recheck the registry: at most every 30 seconds

#define CHECKREG_INTERVAL 30000

// The root registry key under which we keep information
//  under either HKLM or HKCU

#define REGSTR_CODECROOT \
        L"Software\\Microsoft\\Imaging\\Codecs"

// Last update cookie value

#define REGSTR_LASTCOOKIE           L"_LastCookie"

// Registry value entries for each installed codec

#define REGSTR_CODEC_INFOSIZE       L"_InfoSize"
#define REGSTR_CODEC_CLSID          L"CLSID"
#define REGSTR_CODEC_DLLNAME        L"DLLNAME"
#define REGSTR_CODEC_FORMATID       L"Format ID"
#define REGSTR_CODEC_FORMATDESC     L"File Type Description"
#define REGSTR_CODEC_FILENAMEEXT    L"Filename Extension"
#define REGSTR_CODEC_MIMETYPE       L"MIME Type"
#define REGSTR_CODEC_VERSION        L"Version"
#define REGSTR_CODEC_FLAGS          L"Flags"
#define REGSTR_CODEC_SIGCOUNT       L"Signature Count"
#define REGSTR_CODEC_SIGSIZE        L"Signature Size"
#define REGSTR_CODEC_SIGPATTERN     L"Signature Pattern"
#define REGSTR_CODEC_SIGMASK        L"Signature Mask"

// Insert a new node into the head of cached codec info list

inline VOID
InsertCachedCodecInfo(
    CachedCodecInfo* info
    )
{
    info->prev = NULL;
    info->next = CachedCodecs;

    if (CachedCodecs)
        CachedCodecs->prev = info;

    CachedCodecs = info;
    CodecCacheUpdated = TRUE;
}

// Delete a list from the cached codec info list

inline VOID
DeleteCachedCodecInfo(
    CachedCodecInfo* info
    )
{
    CachedCodecInfo* next = info->next;

    if (info == CachedCodecs)
        CachedCodecs = next;

    if (next)
        next->prev = info->prev;

    if (info->prev)
        info->prev->next = next;

    GpFree(info);
    CodecCacheUpdated = TRUE;
}

// Force a reload of cached codec information from registry

inline VOID
ForceReloadCachedCodecInfo()
{
    LastCheckRegTime = GetTickCount() - CHECKREG_INTERVAL;
}

// Doing a blocking read on a stream

inline HRESULT
BlockingReadStream(
    IStream* stream,
    VOID* buf,
    UINT size,
    UINT* bytesRead
    )
{
    HRESULT hr = S_OK;
    ULONG n;

    *bytesRead = 0;

    while (size)
    {
        n = 0;
        hr = stream->Read(buf, size, &n);
        *bytesRead += n;

        if (hr != E_PENDING)
            break;

        size -= n;
        buf = (BYTE*) buf + n;
        Sleep(0);
    }

    return hr;
}

// Doing a blocking relative seek on a stream

inline HRESULT
BlockingSeekStreamCur(
    IStream* stream,
    INT offset,
    ULARGE_INTEGER* pos
    )
{
    HRESULT hr;
    LARGE_INTEGER move;

    move.QuadPart = offset;

    for (;;)
    {
        hr = stream->Seek(move, STREAM_SEEK_CUR, pos);

        if (hr != E_PENDING)
            return hr;

        Sleep(0);
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Free cached information about codecs
*
* Arguments:
*
*   classFlags - Which classes of codecs are affected
*       built-in
*       system-wide
*       per-user
*
* Return Value:
*
*   NONE
*
* Notes:
*
*   We assume the caller has already taken care of
*   the imaging critical section here.
*
\**************************************************************************/

VOID
FreeCachedCodecInfo(
    UINT classFlags
    )
{
    CachedCodecInfo* cur = CachedCodecs;

    // Loop through the list of cached codecs

    while (cur != NULL)
    {
        CachedCodecInfo* next = cur->next;

        // Free the current node

        if (cur->Flags & classFlags)
            DeleteCachedCodecInfo(cur);

        // Move on to the next node

        cur = next;
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Initialize cached information about built-in codecs
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

// BMP file header signature information

#include "bmp\bmpcodec.hpp"

#define BMPVERSION  1
#define BMPSIGCOUNT 1
#define BMPSIGSIZE  2

// The BMP signature is taken from the BITMAPFILEHEADER structure.
// Initially I set the signature to require zeros for the bfReserved1
// and bfReserved2 fields.  However, there exist BMP files with non-zero
// values in these fields and so the signature now only looks for the "BM"
// characters in the bfType field.

const BYTE BMPHeaderPattern[BMPSIGCOUNT*BMPSIGSIZE] =
{
    0x42, 0x4D        // bfType = 'BM'
};

const BYTE BMPHeaderMask[BMPSIGCOUNT*BMPSIGSIZE] =
{
    0xff, 0xff
};

const CLSID BmpCodecClsID =
{
    0x557cf400,
    0x1a04,
    0x11d3,
    {0x9a, 0x73, 0x00, 0x00, 0xf8, 0x1e, 0xf3, 0x2e}
};

// Create an instance of BMP codec object

HRESULT CreateBmpCodecInstance(REFIID iid, VOID** codec)
{
    HRESULT hr;
    GpBmpCodec *bmpCodec = new GpBmpCodec();

    if (bmpCodec != NULL)
    {
        hr = bmpCodec->QueryInterface(iid, codec);
        bmpCodec->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *codec = NULL;
    }

    return hr;
}

// JPEG file header signature information

#include "jpeg\jpgcodec.hpp"

#define JPEGVERSION     1
#define JPEGSIGCOUNT    1
#define JPEGSIGSIZE     2

const BYTE JPEGHeaderPattern[JPEGSIGCOUNT*JPEGSIGSIZE] =
{
    0xff, 0xd8
};

const BYTE JPEGHeaderMask[JPEGSIGCOUNT*JPEGSIGSIZE] =
{
    0xff, 0xff
};

const CLSID JpegCodecClsID =
{
    0x557cf401,
    0x1a04,
    0x11d3,
    {0x9a, 0x73, 0x00, 0x00, 0xf8, 0x1e, 0xf3, 0x2e}
};

// Create an instance of JPG codec object

HRESULT CreateJpegCodecInstance(REFIID iid, VOID** codec)
{
    HRESULT hr;
    GpJpegCodec *jpegCodec = new GpJpegCodec();

    if (jpegCodec != NULL)
    {
        hr = jpegCodec->QueryInterface(iid, codec);
        jpegCodec->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *codec = NULL;
    }

    return hr;
}

#ifndef _BUILD_EXTERNAL_GIF

// GIF file header signature information

#include "gif\gifcodec.hpp"
#include "gif\gifconst.cpp"

// Create an instance of GIF codec object

HRESULT CreateGifCodecInstance(REFIID iid, VOID** codec)
{
    HRESULT hr;
    GpGifCodec *gifCodec = new GpGifCodec();

    if (gifCodec != NULL)
    {
        hr = gifCodec->QueryInterface(iid, codec);
        gifCodec->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *codec = NULL;
    }

    return hr;
}

#endif // !_BUILD_EXTERNAL_GIF

// EMF file header signature information

#include "emf\emfcodec.hpp"

#define EMFVERSION  1
#define EMFSIGCOUNT 1
#define EMFSIGSIZE  44

const BYTE EMFHeaderPattern[EMFSIGCOUNT*EMFSIGSIZE] =
{
    0, 0, 0, 0,  // iType

    0, 0, 0, 0,  // nSize

    0, 0, 0, 0,  // rclBounds
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,

    0, 0, 0, 0,  // rclFrame
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,

    0x20, 0x45, 0x4D, 0x46 // dSignature = ENHMETA_SIGNATURE
};

const BYTE EMFHeaderMask[EMFSIGCOUNT*EMFSIGSIZE] =
{
    0, 0, 0, 0,  // iType

    0, 0, 0, 0,  // nSize

    0, 0, 0, 0,  // rclBounds
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,

    0, 0, 0, 0,  // rclFrame
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,

    0xff, 0xff, 0xff, 0xff // dSignature
};

const CLSID EMFCodecClsID =
{
    0x557cf403,
    0x1a04,
    0x11d3,
    {0x9a, 0x73, 0x00, 0x00, 0xf8, 0x1e, 0xf3, 0x2e}
};

// Create an instance of EMF codec object

HRESULT CreateEMFCodecInstance(REFIID iid, VOID** codec)
{
    HRESULT hr;
    GpEMFCodec *EMFCodec = new GpEMFCodec();

    if (EMFCodec != NULL)
    {
        hr = EMFCodec->QueryInterface(iid, codec);
        EMFCodec->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *codec = NULL;
    }

    return hr;
}


// WMF file header signature information

#include "wmf\wmfcodec.hpp"

#define WMFVERSION  1
#define WMFSIGCOUNT 1
#define WMFSIGSIZE  4

const BYTE WMFHeaderPattern[WMFSIGCOUNT*WMFSIGSIZE] =
{
    0xD7, 0xCD, 0xC6, 0x9A
};

const BYTE WMFHeaderMask[WMFSIGCOUNT*WMFSIGSIZE] =
{
    0xff, 0xff, 0xff, 0xff
};

const CLSID WMFCodecClsID =
{
    0x557cf404,
    0x1a04,
    0x11d3,
    {0x9a, 0x73, 0x00, 0x00, 0xf8, 0x1e, 0xf3, 0x2e}
};

// Create an instance of WMF codec object

HRESULT CreateWMFCodecInstance(REFIID iid, VOID** codec)
{
    HRESULT hr;
    GpWMFCodec *WMFCodec = new GpWMFCodec();

    if (WMFCodec != NULL)
    {
        hr = WMFCodec->QueryInterface(iid, codec);
        WMFCodec->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *codec = NULL;
    }

    return hr;
}

// TIFF file header signature information

#include "off_tiff\tiffcodec.hpp"

#define TIFFVERSION     1
#define TIFFSIGCOUNT    2
#define TIFFSIGSIZE     2

const BYTE TIFFHeaderPattern[TIFFSIGCOUNT * TIFFSIGSIZE] =
{
    0x49, 0x49,       // bfType = '0x4949H' little endian
    0x4D, 0x4D        // bfType = '0x4D4DH' big endian
};

const BYTE TIFFHeaderMask[TIFFSIGCOUNT * TIFFSIGSIZE] =
{
    0xff, 0xff,
    0xff, 0xff
};

const CLSID TiffCodecClsID =
{
    0x557cf405,
    0x1a04,
    0x11d3,
    {0x9a, 0x73, 0x00, 0x00, 0xf8, 0x1e, 0xf3, 0x2e}
};

// Create an instance of TIFF codec object

HRESULT CreateTiffCodecInstance(REFIID iid, VOID** codec)
{
    HRESULT hr;
    GpTiffCodec *tiffCodec = new GpTiffCodec();

    if ( tiffCodec != NULL )
    {
        hr = tiffCodec->QueryInterface(iid, codec);
        tiffCodec->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *codec = NULL;
    }

    return hr;
}

// PNG file header signature information

#include "png\pngcodec.hpp"

#define PNGVERSION  1
#define PNGSIGCOUNT 1
#define PNGSIGSIZE  8

const BYTE PNGHeaderPattern[PNGSIGCOUNT*PNGSIGSIZE] =
{
    137, 80, 78, 71, 13, 10, 26, 10
};

const BYTE PNGHeaderMask[PNGSIGCOUNT*PNGSIGSIZE] =
{
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

const CLSID PngCodecClsID =
{
    0x557cf406,
    0x1a04,
    0x11d3,
    {0x9a, 0x73, 0x00, 0x00, 0xf8, 0x1e, 0xf3, 0x2e}
};

// Create an instance of PNG codec object

HRESULT CreatePngCodecInstance(REFIID iid, VOID** codec)
{
    HRESULT hr;
    GpPngCodec *pngCodec = new GpPngCodec();

    if (pngCodec != NULL)
    {
        hr = pngCodec->QueryInterface(iid, codec);
        pngCodec->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *codec = NULL;
    }

    return hr;
}


// ICO (icon) file header signature information

#include "ico\icocodec.hpp"

#define ICOVERSION  1
#define ICOSIGCOUNT 1
#define ICOSIGSIZE  4

const BYTE ICOHeaderPattern[ICOSIGCOUNT*ICOSIGSIZE] =
{
    0, 0, 1, 0
};

const BYTE ICOHeaderMask[ICOSIGCOUNT*ICOSIGSIZE] =
{
    0xff, 0xff, 0xff, 0xff
};

const CLSID IcoCodecClsID =
{
    0x557cf407,
    0x1a04,
    0x11d3,
    {0x9a, 0x73, 0x00, 0x00, 0xf8, 0x1e, 0xf3, 0x2e}
};

// Create an instance of ICO codec object

HRESULT CreateIcoCodecInstance(REFIID iid, VOID** codec)
{
    HRESULT hr;
    GpIcoCodec *icoCodec = new GpIcoCodec();

    if (icoCodec != NULL)
    {
        hr = icoCodec->QueryInterface(iid, codec);
        icoCodec->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *codec = NULL;
    }

    return hr;
}


//!!!TODO: Office cannot use resource strings, so built-in codecs will
//!!!      have hardcoded strings for now.  Need to figure out how to
//!!!      make these localizable (maybe hardcoded for gdipstat.lib,
//!!!      resource strings for gdiplus.dll?).
//#define USE_RESOURCE_STRINGS

struct
{
    const GUID* Clsid;
    const GUID* FormatID;
    #if defined(USE_RESOURCE_STRINGS)
        INT CodecNameId;
        INT FormatDescriptionId;
        INT FilenameExtensionId;
        INT MimeTypeId;
    #else
        WCHAR *CodecNameStr;
        WCHAR *FormatDescriptionStr;
        WCHAR *FilenameExtensionStr;
        WCHAR *MimeTypeStr;
    #endif
    DWORD Version;
    DWORD Flags;
    DWORD SigCount;
    DWORD SigSize;
    const BYTE* SigPattern;
    const BYTE* SigMask;
    CreateCodecInstanceProc creationProc;
}
const BuiltinCodecs[] =
{
    // Built-in BMP encoder / decoder

    {
        &BmpCodecClsID,
        &IMGFMT_BMP,

        #if defined(USE_RESOURCE_STRINGS)
            IDS_BMP_CODECNAME,
            IDS_BMP_FORMATDESC,
            IDS_BMP_FILENAMEEXT,
            IDS_BMP_MIMETYPE,
        #else
            L"Built-in BMP Codec",
            L"BMP",
            L"*.BMP;*.DIB;*.RLE",
            L"image/bmp",
        #endif
        BMPVERSION,
        IMGCODEC_ENCODER |
            IMGCODEC_DECODER |
            IMGCODEC_SUPPORT_BITMAP,
        BMPSIGCOUNT,
        BMPSIGSIZE,
        BMPHeaderPattern,
        BMPHeaderMask,
        CreateBmpCodecInstance
    },

    // Built-in JPEG encoder / decoder

    {
        &JpegCodecClsID,
        &IMGFMT_JPEG,

        #if defined(USE_RESOURCE_STRINGS)
            IDS_JPEG_CODECNAME,
            IDS_JPEG_FORMATDESC,
            IDS_JPEG_FILENAMEEXT,
            IDS_JPEG_MIMETYPE,
        #else
            L"Built-in JPEG Codec",
            L"JPEG",
            L"*.JPG;*.JPEG;*.JPE;*.JFIF",
            L"image/jpeg",
        #endif
        JPEGVERSION,
        IMGCODEC_ENCODER |
            IMGCODEC_DECODER |
            IMGCODEC_SUPPORT_BITMAP,
        JPEGSIGCOUNT,
        JPEGSIGSIZE,
        JPEGHeaderPattern,
        JPEGHeaderMask,
        CreateJpegCodecInstance
    },

    #ifndef _BUILD_EXTERNAL_GIF

    // Built-in GIF encoder / decoder

    {
        &GifCodecClsID,
        &IMGFMT_GIF,

        #if defined(USE_RESOURCE_STRINGS)
            IDS_GIF_CODECNAME,
            IDS_GIF_FORMATDESC,
            IDS_GIF_FILENAMEEXT,
            IDS_GIF_MIMETYPE,
        #else
            L"Built-in GIF Codec",
            L"GIF",
            L"*.GIF",
            L"image/gif",
        #endif
        GIFVERSION,
        IMGCODEC_ENCODER |
            IMGCODEC_DECODER |
            IMGCODEC_SUPPORT_BITMAP,
        GIFSIGCOUNT,
        GIFSIGSIZE,
        GIFHeaderPattern,
        GIFHeaderMask,
        CreateGifCodecInstance
    },

    #endif // !_BUILD_EXTERNAL_GIF

    // Built-in EMF encoder / decoder

    {
        &EMFCodecClsID,
        &IMGFMT_EMF,

        #if defined(USE_RESOURCE_STRINGS)
            IDS_EMF_CODECNAME,
            IDS_EMF_FORMATDESC,
            IDS_EMF_FILENAMEEXT,
            IDS_EMF_MIMETYPE,
        #else
            L"Built-in EMF Codec",
            L"EMF",
            L"*.EMF",
            L"image/x-emf",
        #endif
        EMFVERSION,
        IMGCODEC_DECODER |
            IMGCODEC_SUPPORT_BITMAP,
        EMFSIGCOUNT,
        EMFSIGSIZE,
        EMFHeaderPattern,
        EMFHeaderMask,
        CreateEMFCodecInstance
    },

    // Built-in WMF encoder / decoder

    {
        &WMFCodecClsID,
        &IMGFMT_WMF,

        #if defined(USE_RESOURCE_STRINGS)
            IDS_WMF_CODECNAME,
            IDS_WMF_FORMATDESC,
            IDS_WMF_FILENAMEEXT,
            IDS_WMF_MIMETYPE,
        #else
            L"Built-in WMF Codec",
            L"WMF",
            L"*.WMF",
            L"image/x-wmf",
        #endif
        WMFVERSION,
        IMGCODEC_DECODER |
            IMGCODEC_SUPPORT_BITMAP,
        WMFSIGCOUNT,
        WMFSIGSIZE,
        WMFHeaderPattern,
        WMFHeaderMask,
        CreateWMFCodecInstance
    },

    // Built-in TIFF encoder / decoder

    {
        &TiffCodecClsID,
        &IMGFMT_TIFF,

        #if defined(USE_RESOURCE_STRINGS)
            IDS_TIFF_CODECNAME,
            IDS_TIFF_FORMATDESC,
            IDS_TIFF_FILENAMEEXT,
            IDS_TIFF_MIMETYPE,
        #else
            L"Built-in TIFF Codec",
            L"TIFF",
            L"*.TIF;*.TIFF",
            L"image/tiff",
        #endif
        TIFFVERSION,
        IMGCODEC_ENCODER |
            IMGCODEC_DECODER |
            IMGCODEC_SUPPORT_BITMAP,
        TIFFSIGCOUNT,
        TIFFSIGSIZE,
        TIFFHeaderPattern,
        TIFFHeaderMask,
        CreateTiffCodecInstance
    },

    // Built-in PNG encoder / decoder

    {
        &PngCodecClsID,
        &IMGFMT_PNG,

        #if defined(USE_RESOURCE_STRINGS)
            IDS_PNG_CODECNAME,
            IDS_PNG_FORMATDESC,
            IDS_PNG_FILENAMEEXT,
            IDS_PNG_MIMETYPE,
        #else
            L"Built-in PNG Codec",
            L"PNG",
            L"*.PNG",
            L"image/png",
        #endif
        PNGVERSION,
        IMGCODEC_ENCODER |
            IMGCODEC_DECODER |
            IMGCODEC_SUPPORT_BITMAP,
        PNGSIGCOUNT,
        PNGSIGSIZE,
        PNGHeaderPattern,
        PNGHeaderMask,
        CreatePngCodecInstance
    },

    // Built-in ICO decoder

    {
        &IcoCodecClsID,
        &IMGFMT_ICO,

        #if defined(USE_RESOURCE_STRINGS)
            IDS_ICO_CODECNAME,
            IDS_ICO_FORMATDESC,
            IDS_ICO_FILENAMEEXT,
            IDS_ICO_MIMETYPE,
        #else
            L"Built-in ICO Codec",
            L"ICO",
            L"*.ICO",
            L"image/x-icon",
        #endif
        ICOVERSION,
        IMGCODEC_DECODER |
            IMGCODEC_SUPPORT_BITMAP,
        ICOSIGCOUNT,
        ICOSIGSIZE,
        ICOHeaderPattern,
        ICOHeaderMask,
        CreateIcoCodecInstance
    }

};

#if defined(USE_RESOURCE_STRINGS)
    #define LOADRSRCSTR(_f)                             \
            WCHAR _f##Str[MAX_PATH];                    \
            INT _f##Len;                                \
            _f##Len = _LoadString(                      \
                        DllInstance,                    \
                        BuiltinCodecs[index]._f##Id,    \
                        _f##Str,                        \
                        MAX_PATH);                      \
            if (_f##Len <= 0) continue;                 \
            _f##Len = (_f##Len + 1) * sizeof(WCHAR)
#else
    #define LOADRSRCSTR(_f)                                         \
            WCHAR _f##Str[MAX_PATH];                                \
            INT _f##Len;                                            \
            _f##Len = UnicodeStringLength(BuiltinCodecs[index]._f##Str);         \
            if (_f##Len <= 0) continue;                             \
            _f##Len = (_f##Len + 1) * sizeof(WCHAR);                \
            memcpy(_f##Str, BuiltinCodecs[index]._f##Str, _f##Len)
#endif

#define COPYRSRCSTR(_f)                             \
        cur->_f = (const WCHAR*) buf;               \
        memcpy(buf, _f##Str, _f##Len);              \
        buf += _f##Len

VOID
InitializeBuiltinCodecs()
{
    TRACE(("Entering InitializeBuiltinCodecs...\n"));

    INT index = sizeof(BuiltinCodecs) / sizeof(BuiltinCodecs[0]);

    while (index--)
    {
        // Load resource strings

        LOADRSRCSTR(CodecName);
        LOADRSRCSTR(FormatDescription);
        LOADRSRCSTR(FilenameExtension);
        LOADRSRCSTR(MimeType);

        // Compute the total size of the codec info

        UINT sigBytes = BuiltinCodecs[index].SigCount *
                        BuiltinCodecs[index].SigSize;

        UINT size = sizeof(CachedCodecInfo) +
                    CodecNameLen +
                    FormatDescriptionLen +
                    FilenameExtensionLen +
                    MimeTypeLen +
                    2*sigBytes;

        size = ALIGN16(size);

        // Allocate memory

        BYTE* buf = (BYTE*) GpMalloc(size);

        if ( buf == NULL )
            continue;

        // Fill out CachedCodecInfo structure

        CachedCodecInfo* cur = (CachedCodecInfo*) buf;
        cur->structSize = size;
        buf += sizeof(CachedCodecInfo);

        cur->Clsid = *BuiltinCodecs[index].Clsid;
        cur->FormatID = *BuiltinCodecs[index].FormatID;

        COPYRSRCSTR(CodecName);
        COPYRSRCSTR(FormatDescription);
        COPYRSRCSTR(FilenameExtension);
        COPYRSRCSTR(MimeType);

        cur->DllName = NULL;
        cur->Flags = BuiltinCodecs[index].Flags | IMGCODEC_BUILTIN;
        cur->Version = BuiltinCodecs[index].Version;
        cur->creationProc = BuiltinCodecs[index].creationProc;
        cur->SigCount = BuiltinCodecs[index].SigCount;
        cur->SigSize = BuiltinCodecs[index].SigSize;

        if (sigBytes)
        {
            cur->SigPattern = buf;
            memcpy(buf, BuiltinCodecs[index].SigPattern, sigBytes);
            buf += sigBytes;

            cur->SigMask = buf;
            memcpy(buf, BuiltinCodecs[index].SigMask, sigBytes);
            buf += sigBytes;
        }
        else
            cur->SigPattern = cur->SigMask = NULL;

        TRACE(("  %ws\n", cur->CodecName));

        InsertCachedCodecInfo(cur);
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Reload information about installed codecs from the registry
*
* Arguments:
*
*   hiveKey - Handle to the registry hive
*   regkeyStr - Root key where we kept info about installed codecs
*   cookie - The last cookie value we read out of the registry
*   classFlags - Specifies the class of codecs
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

#define ISOK(s)     ((s) == ERROR_SUCCESS)
#define ISERR(s)    ((s) != ERROR_SUCCESS)

#define GETREGDWORD(hkey, regstr, val)                              \
        if (ISERR(_RegGetDWORD(hkey, regstr, &val)))                \
            return FALSE

#define GETREGGUID(hkey, regstr, val)                               \
        if (ISERR(_RegGetBinary(hkey, regstr, &val, sizeof(GUID)))) \
            return FALSE

#define GETREGSTR(hkey, regstr, buf)                                \
        if (ISERR(_RegGetString(hkey, regstr, (WCHAR*) p, size)))   \
            return FALSE;                                           \
        buf = (const WCHAR*) p;                                     \
        n = SizeofWSTR(buf);                                        \
        if (size < n)                                               \
            return FALSE;                                           \
        p += n;                                                     \
        size -= n

#define GETREGBIN(hkey, regstr, buf, _n)                            \
        if (ISERR(_RegGetBinary(hkey, regstr, p, _n)))              \
            return FALSE;                                           \
        buf = p;                                                    \
        if (size < n)                                               \
            return FALSE;                                           \
        p += _n;                                                    \
        size -= _n

BOOL
ReadCodecRegValues(
    const WCHAR* codecName,
    HKEY hkey,
    CachedCodecInfo* info,
    UINT size
    )
{
    ASSERT(size > sizeof(CachedCodecInfo) &&
           size == ALIGN16(size));

    ZeroMemory(info, sizeof(CachedCodecInfo));

    info->structSize = size;
    size -= sizeof(CachedCodecInfo);

    // Copy codec name string

    BYTE* p = (BYTE*) info + sizeof(CachedCodecInfo);
    UINT n = SizeofWSTR(codecName);

    if (size < n)
        return FALSE;

    memcpy(p, codecName, n);
    info->CodecName = (const WCHAR*) p;
    size -= n;
    p += n;

    // Read the following values:
    //  codec COM object class ID
    //  file format identifier
    //  codec flags

    GETREGGUID(hkey, REGSTR_CODEC_CLSID, info->Clsid);
    GETREGGUID(hkey, REGSTR_CODEC_FORMATID, info->FormatID);
    GETREGDWORD(hkey, REGSTR_CODEC_VERSION, info->Version);
    GETREGDWORD(hkey, REGSTR_CODEC_FLAGS, info->Flags);

    // we only support version 1 codecs for now

    if (info->Version != 1)
        return FALSE;

    // Only the low-word of the codec flags is meaningfully persisted

    info->Flags &= 0xffff;

    // Read various string information
    //  dll name
    //  file type description
    //  filename extension
    //  mime type

    GETREGSTR(hkey, REGSTR_CODEC_DLLNAME, info->DllName);
    GETREGSTR(hkey, REGSTR_CODEC_FORMATDESC, info->FormatDescription);
    GETREGSTR(hkey, REGSTR_CODEC_FILENAMEEXT, info->FilenameExtension);
    GETREGSTR(hkey, REGSTR_CODEC_MIMETYPE, info->MimeType);

    // Read magic header pattern and mask information for decoders.
    // NOTE: This should be done last to avoid alignment problems.

    if (info->Flags & IMGCODEC_DECODER)
    {
        GETREGDWORD(hkey, REGSTR_CODEC_SIGCOUNT, info->SigCount);
        GETREGDWORD(hkey, REGSTR_CODEC_SIGSIZE, info->SigSize);

        n = info->SigCount * info->SigSize;

        if (n == 0 || 2*n > size)
            return FALSE;

        GETREGBIN(hkey, REGSTR_CODEC_SIGPATTERN, info->SigPattern, n);
        GETREGBIN(hkey, REGSTR_CODEC_SIGMASK, info->SigMask, n);
    }

    return TRUE;
}

VOID
ReloadCodecInfoFromRegistry(
    HKEY hiveKey,
    const WCHAR* regkeyStr,
    DWORD* cookie,
    UINT classFlags
    )
{
    // Open the root registry key

    HKEY hkeyRoot;

    if (ISERR(_RegOpenKey(hiveKey, regkeyStr, KEY_READ, &hkeyRoot)))
        return;

    // Read the cookie value in the root registry key

    DWORD newCookie;

    if (ISERR(_RegGetDWORD(hkeyRoot, REGSTR_LASTCOOKIE, &newCookie)))
        newCookie = 0;

    // Cookie hasn't changed, we don't need to do anything

    if (newCookie == *cookie)
    {
        RegCloseKey(hkeyRoot);
        return;
    }

    *cookie = newCookie;

    // Enumerate subkeys - one for each codec

    WCHAR subkeyStr[MAX_PATH];
    DWORD keyIndex = 0;

    while (ISOK(_RegEnumKey(hkeyRoot, keyIndex, subkeyStr)))
    {
        keyIndex++;

        // Open the subkey for the next codec

        HKEY hkeyCodec;

        if (ISERR(_RegOpenKey(hkeyRoot, subkeyStr, KEY_READ, &hkeyCodec)))
            continue;

        // Figure out how big a buffer we need to hold information
        // about the this codec. And then allocate enough memory.

        CachedCodecInfo* cur = NULL;
        DWORD infosize;

        if (ISOK(_RegGetDWORD(hkeyCodec, REGSTR_CODEC_INFOSIZE, &infosize)) &&
            infosize > sizeof(CachedCodecInfo) &&
            infosize == ALIGN16(infosize) &&
            (cur = (CachedCodecInfo*) GpMalloc(infosize)) &&
            ReadCodecRegValues(subkeyStr, hkeyCodec, cur, infosize))
        {
            // Insert the new codec info at the head of the list

            cur->Flags |= classFlags;
            InsertCachedCodecInfo(cur);
        }
        else
        {
            // Wasn't able to read codec info from registry

            GpFree(cur);
        }

        RegCloseKey(hkeyCodec);
    }

    RegCloseKey(hkeyRoot);
}


/**************************************************************************\
*
* Function Description:
*
*   Initialize cached list of decoders and encoders
*   by reading information out of the registry
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Status code
*
* Notes:
*
*   We assume the caller has already taken care of
*   the imaging critical section here.
*
\**************************************************************************/

VOID
ReloadCachedCodecInfo()
{
    TRACE(("Entering ReloadCachedCodecInfo...\n"));

    BOOL checkReg;

    CodecCacheUpdated = FALSE;

    if (CachedCodecs == NULL)
    {
        // This is the very first time ReloadCachedCodecInfo is called.
        // So initialize built-in codecs here.

        InitializeBuiltinCodecs();

        // Make sure we reload registry info

        checkReg = TRUE;
    }
    else
    {
        // Now check to see if it's time to check yet

        DWORD gap = GetTickCount() - LastCheckRegTime;
        checkReg = gap >= CHECKREG_INTERVAL;
    }

    if (!checkReg)
        return;

    if (!SuppressExternalCodecs)
    {
        // Reload info about system-wide codecs from the registry
    
        ReloadCodecInfoFromRegistry(
            HKEY_LOCAL_MACHINE,
            REGSTR_CODECROOT,
            &SystemRegCookie,
            IMGCODEC_SYSTEM);
    
        // Reload info about per-user codecs from the registry
    
        ReloadCodecInfoFromRegistry(
            HKEY_CURRENT_USER,
            REGSTR_CODECROOT,
            &UserRegCookie,
            IMGCODEC_USER);
    }

    // Recalculate maximum magic header size for all codecs

    if (CodecCacheUpdated)
    {
        DWORD maxsize = 0;
        CachedCodecInfo* cur = CachedCodecs;

        while (cur)
        {
            VERBOSE((
                "Codec: %ws\n"
                "    DllName: %ws\n"
                "    Version = 0x%x\n"
                "    flags = 0x%x\n"
                "    format = %ws\n"
                "    ext = %ws",
                cur->CodecName,
                cur->DllName,
                cur->Version,
                cur->Flags,
                cur->FormatDescription,
                cur->FilenameExtension));

            if (cur->SigSize > maxsize)
                maxsize = cur->SigSize;

            cur = cur->next;
        }

        MaxSigSize = maxsize;
        CodecCacheUpdated = FALSE;
    }

    LastCheckRegTime = GetTickCount();
}


/**************************************************************************\
*
* Function Description:
*
*   Install a codec: save relevant information into the registry
*
* Arguments:
*
*   codecInfo - Information about the codec to be installed
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

#define IMGCODEC_CLASSMASKS (IMGCODEC_BUILTIN|IMGCODEC_SYSTEM|IMGCODEC_USER)

#define SETREGDWORD(hkey, regstr, val)                              \
        status = _RegSetDWORD(hkey, regstr, val);                   \
        if (ISERR(status)) goto exitLabel

#define SETREGGUID(hkey, regstr, val)                               \
        status = _RegSetBinary(hkey, regstr, &val, sizeof(GUID));   \
        if (ISERR(status)) goto exitLabel

#define SETREGSTR(hkey, regstr, buf)                                \
        status = _RegSetString(hkey, regstr, buf);                  \
        if (ISERR(status)) goto exitLabel

#define SETREGBIN(hkey, regstr, buf, size)                          \
        status = _RegSetBinary(hkey, regstr, buf, size);            \
        if (ISERR(status)) goto exitLabel



HRESULT
InstallCodec(
    const ImageCodecInfo* codecInfo
    )
{
    // Validate input parameters

    if (!codecInfo ||
        !codecInfo->CodecName ||
        !codecInfo->DllName ||
        !codecInfo->Version ||
        !codecInfo->FormatDescription ||
        !codecInfo->FilenameExtension ||
        !codecInfo->MimeType)
    {
        return E_INVALIDARG;
    }

    UINT flags = codecInfo->Flags & IMGCODEC_CLASSMASKS;
    DWORD sigBytes = codecInfo->SigCount * codecInfo->SigSize;
    HKEY hive;

    if (flags == IMGCODEC_SYSTEM)
        hive = HKEY_LOCAL_MACHINE;
    else if (flags == IMGCODEC_USER)
        hive = HKEY_CURRENT_USER;
    else
        return E_INVALIDARG;

    flags = codecInfo->Flags & (IMGCODEC_ENCODER|IMGCODEC_DECODER);

    if ((flags == 0) ||
        (flags & IMGCODEC_DECODER) && !sigBytes ||
        sigBytes && (!codecInfo->SigPattern || !codecInfo->SigMask))
    {
        return E_INVALIDARG;
    }

    // Open the root registry key

    HKEY hkeyRoot = NULL;
    HKEY hkey = NULL;
    LONG status;

    status = _RegCreateKey(hive, REGSTR_CODECROOT, KEY_ALL_ACCESS, &hkeyRoot);

    if (ISERR(status))
        goto exitLabel;

    // Update the cookie value under the root registry key

    DWORD cookie;

    if (ISERR(_RegGetDWORD(hkeyRoot, REGSTR_LASTCOOKIE, &cookie)))
        cookie = 0;

    cookie++;

    SETREGDWORD(hkeyRoot, REGSTR_LASTCOOKIE, cookie);

    // Create the subkey corresponding to the new codec.
    // If the subkey already exists, then just open it.

    status = _RegCreateKey(
                hkeyRoot,
                codecInfo->CodecName,
                KEY_ALL_ACCESS,
                &hkey);

    if (ISERR(status))
        goto exitLabel;

    // Figure out the total size of codec info

    UINT size;

    size = sizeof(CachedCodecInfo) +
           SizeofWSTR(codecInfo->CodecName) +
           SizeofWSTR(codecInfo->DllName) +
           SizeofWSTR(codecInfo->FormatDescription) +
           SizeofWSTR(codecInfo->FilenameExtension) +
           SizeofWSTR(codecInfo->MimeType) +
           2*sigBytes;

    size = ALIGN16(size);

    SETREGDWORD(hkey, REGSTR_CODEC_INFOSIZE, size);

    // Save codec flags, class ID, and file format ID
    // and magic file header information, if any

    SETREGDWORD(hkey, REGSTR_CODEC_VERSION, codecInfo->Version);
    SETREGDWORD(hkey, REGSTR_CODEC_FLAGS, codecInfo->Flags);
    SETREGGUID(hkey, REGSTR_CODEC_CLSID, codecInfo->Clsid);
    SETREGGUID(hkey, REGSTR_CODEC_FORMATID, codecInfo->FormatID);

    if (sigBytes)
    {
        SETREGDWORD(hkey, REGSTR_CODEC_SIGCOUNT, codecInfo->SigCount);
        SETREGDWORD(hkey, REGSTR_CODEC_SIGSIZE, codecInfo->SigSize);
        SETREGBIN(hkey, REGSTR_CODEC_SIGPATTERN, codecInfo->SigPattern, sigBytes);
        SETREGBIN(hkey, REGSTR_CODEC_SIGMASK, codecInfo->SigMask, sigBytes);
    }

    // Save string information:
    //  file format description
    //  filename extension
    //  MIME type

    SETREGSTR(hkey, REGSTR_CODEC_DLLNAME, codecInfo->DllName);
    SETREGSTR(hkey, REGSTR_CODEC_FORMATDESC, codecInfo->FormatDescription);
    SETREGSTR(hkey, REGSTR_CODEC_FILENAMEEXT, codecInfo->FilenameExtension);
    SETREGSTR(hkey, REGSTR_CODEC_MIMETYPE, codecInfo->MimeType);

    // Force a reload of cached codec information from registry

    ForceReloadCachedCodecInfo();

exitLabel:

    if (hkey)
        RegCloseKey(hkey);

    if (hkeyRoot)
        RegCloseKey(hkeyRoot);

    return (status == ERROR_SUCCESS) ?
                S_OK :
                HRESULT_FROM_WIN32(status);
}


/**************************************************************************\
*
* Function Description:
*
*   Uninstall a codec
*
* Arguments:
*
*   codecName - Name of the codec to be uninstalled
*   flags - Uninstall system-wide or per-user codec
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
UninstallCodec(
    const WCHAR* codecName,
    UINT flags
    )
{
    // Validate input parameters

    if (!codecName ||
        flags != IMGCODEC_USER && flags != IMGCODEC_SYSTEM)
    {
        return E_INVALIDARG;
    }

    // Open the root registry key

    HKEY hive, hkeyRoot;
    LONG status;

    hive = (flags == IMGCODEC_USER) ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE;
    status = _RegOpenKey(hive, REGSTR_CODECROOT, KEY_ALL_ACCESS, &hkeyRoot);

    if (ISERR(status))
        return HRESULT_FROM_WIN32(status);

    // Update the cookie value under the root registry key

    DWORD cookie;

    if (ISERR(_RegGetDWORD(hkeyRoot, REGSTR_LASTCOOKIE, &cookie)))
        cookie = 0;

    cookie++;
    SETREGDWORD(hkeyRoot, REGSTR_LASTCOOKIE, cookie);

    // Delete the subkey corresponding to the specified decoder

    status = RecursiveDeleteRegKey(hkeyRoot, codecName);

    // Force a reload of cached codec information from registry

    ForceReloadCachedCodecInfo();

exitLabel:

    RegCloseKey(hkeyRoot);

    return (status == ERROR_SUCCESS) ?
                S_OK :
                HRESULT_FROM_WIN32(status);
}

/**************************************************************************\
*
* Function Description:
*
*   Our own fake CoCreateInstance
*
* Arguments:
*
*   clsId - CLSID of the codec DLL installed
*   DllName - Dll name
*   iid - whether we want decoder or encoder
*   codec - pointer to the decoder/encoder we are returning
*
* Return Value:
*
*   status code
*
\**************************************************************************/
HRESULT MyCreateInstance(WCHAR* DllName, REFIID iid, VOID** codec)
{
    HINSTANCE h;
    HRESULT   hr = IMGERR_FAILLOADCODEC;;

    if ((h = LoadLibrary(DllName)) != NULL)
    {
        CreateCodecInstanceProc CreateCodecInstance;

        if ((CreateCodecInstance = 
             (CreateCodecInstanceProc)GetProcAddress(h, "CreateCodecInstance")) != NULL)
        {
            hr = CreateCodecInstance(iid, codec);
            return hr;
        }
    }

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   Find a decoder that recognizes the specified header signature
*
* Arguments:
*
*   sigbuf - Pointer to file header data
*   sigsize - Size of file header data buffer
*   classMask - Specifies the specific class of decoders to look for
*
* Return Value:
*
*   Pointer to the CachedCodecInfo structure corresponding to
*   the decoder found. NULL if nothing is found.
*
* Note:
*
*   The caller should be holding the global imaging critical section.
*
\**************************************************************************/

CachedCodecInfo*
FindDecoderWithHeader(
    const VOID* sigbuf,
    UINT sigsize,
    UINT classMask
    )
{
    CachedCodecInfo* cur;
    const BYTE* srcdata = (const BYTE*) sigbuf;

    for (cur = CachedCodecs; cur; cur = cur->next)
    {

        if (!(cur->Flags & IMGCODEC_DECODER) ||
            (cur->Flags & classMask) != classMask ||
            cur->SigSize > sigsize)
        {
            continue;
        }

        // Try to find a matching decoder based on
        // information in the file header.

        const BYTE* pat = cur->SigPattern;
        const BYTE* mask = cur->SigMask;
        UINT n = min(sigsize, cur->SigSize);
        UINT j = cur->SigCount;
        UINT i;

        while (j--)
        {
            for (i=0; i < n; i++)
            {
                if ((srcdata[i] & mask[i]) != pat[i])
                    break;
            }

            if (i == n)
                return cur;

            pat += cur->SigSize;
            mask += cur->SigSize;
        }
    }

    return NULL;
}


/**************************************************************************\
*
* Function Description:
*
*   Get a decoder object that can process the specified data stream
*
* Arguments:
*
*   stream - Specifies the input data stream
*   decoder - If the call is successful, return a pointer to
*       an initialized IImageDecoder object
*   flags - Misc. flags
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
CreateDecoderForStream(
    IStream* stream,
    IImageDecoder** decoder,
    DecoderInitFlag flags
    )
{
    // Reload cached codec information if necessary
    //  and figure out the maximum magic header size

    UINT sigsize, bytesRead;
    BYTE stackbuf[64];
    GpTempBuffer sigbuf(stackbuf, sizeof(stackbuf));

    {
        // Acquire global critical section

        ImagingCritSec critsec;

        ReloadCachedCodecInfo();
        sigsize = MaxSigSize;
    }

    if (sigsize == 0)
        return IMGERR_CODECNOTFOUND;
    else if (!sigbuf.Realloc(sigsize))
        return E_OUTOFMEMORY;

    // Seek the stream back to the beginning.
    // Note: This is also a check to see if the input stream is seekable or not.
    // For some net streams, it might not be seekable.

    HRESULT hr;

    LARGE_INTEGER   move;

    move.QuadPart = 0;

    hr = stream->Seek(move, STREAM_SEEK_SET, NULL);

    // !!! TODO: Some stream implementation return 0x0000007e, not as the
    // conventional 0x8000xxxx return code. WFC stream class is an example. So
    // we might need to check if (hr == S_OK) here, instead of FAILED(hr)

    if (FAILED(hr))
    {
        // !!! TODO
        // The stream is not seekable. We need to wrap a seekable interface
        // around it.

        WARNING(("Non-seekable stream in CreateDecoderForStream"));
        return hr;
    }

    // Read the magic header info and
    //  move the seek pointer back to its initial position

    VOID* p = sigbuf.GetBuffer();

    hr = BlockingReadStream(stream, p, sigsize, &bytesRead);

    if (bytesRead == 0)
        return FAILED(hr) ? hr : E_FAIL;

    hr = BlockingSeekStreamCur(stream, - (INT) bytesRead, NULL);

    if (FAILED(hr))
        return hr;

    CreateCodecInstanceProc creationProc;
    CLSID clsid;
    WCHAR* DllName;
    CachedCodecInfo* found = NULL;

    {
        // Acquire global critical section

        ImagingCritSec critsec;

        // Check if the caller want to get to built-in decoders first

        if (flags & DECODERINIT_BUILTIN1ST)
            found = FindDecoderWithHeader(p, bytesRead, IMGCODEC_BUILTIN);

        if (!found)
            found = FindDecoderWithHeader(p, bytesRead, 0);

        if (found && !(creationProc = found->creationProc))
        {
            clsid = found->Clsid;
            DllName = (WCHAR*)found->DllName;
        }
    }

    if (!found)
        return IMGERR_CODECNOTFOUND;

    // Create an instance of image decoder

    IImageDecoder* codec;

    if (creationProc)
    {
        // Built-in decoder

        hr = creationProc(IID_IImageDecoder, (VOID**) &codec);
    }
    else
    {
        // External decoder

        hr = MyCreateInstance(
                DllName,
                IID_IImageDecoder,
                (VOID**) &codec);
    }

    if (FAILED(hr))
        return hr;

    // Initialize the decoder with input data stream

    hr = codec->InitDecoder(stream, flags);

    if (SUCCEEDED(hr))
    {
        *decoder = codec;
    }
    else
    {
        // Terminate the decoder first so that the codec can do all the clean
        // up and resource free. Then release the codec

        codec->TerminateDecoder();
        codec->Release();
    }

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   Get the encoder parameter list size from an encoder object specified by
*   input clsid
*
* Arguments:
*
*   clsid - Specifies the encoder class ID
*   size--- The size of the encoder parameter list
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   03/22/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
CodecGetEncoderParameterListSize(
    const CLSID* clsid,
    UINT*   size
    )
{
    BOOL bFound = FALSE;
    WCHAR* DllName;

    CreateCodecInstanceProc creationProc;

    {
        // Acquire global critical section

        ImagingCritSec critsec;

        ReloadCachedCodecInfo();

        // Check if we have an encoder with the specified class ID

        CachedCodecInfo* curCodec;

        for ( curCodec = CachedCodecs;
              curCodec != NULL;
              curCodec = curCodec->next)
        {
            if ( (curCodec->Flags & IMGCODEC_ENCODER)
               &&(curCodec->Clsid == *clsid) )
            {
                bFound = TRUE;
                DllName = (WCHAR*)curCodec->DllName;
                creationProc = curCodec->creationProc;

                break;
            }
        }
    }

    if ( bFound == FALSE )
    {
        return IMGERR_CODECNOTFOUND;
    }

    // Create an instance of image encoder

    IImageEncoder* pEncoder;
    HRESULT hResult;

    if ( creationProc )
    {
        // Built-in encoder

        hResult = creationProc(IID_IImageEncoder, (VOID**)&pEncoder);
    }
    else
    {
        // External encoder

        hResult = MyCreateInstance(DllName, IID_IImageEncoder,(VOID**)&pEncoder);
    }

    if ( FAILED(hResult) )
    {
        return hResult;
    }

    // Initialize the decoder with input data stream

    hResult = pEncoder->GetEncoderParameterListSize(size);

    pEncoder->Release();

    return hResult;
}// CodecGetEncoderParameterListSize()

/**************************************************************************\
*
* Function Description:
*
*   Get the encoder parameter list from an encoder object specified by
*   input clsid
*
* Arguments:
*
*   clsid - Specifies the encoder class ID
*   size--- The size of the encoder parameter list
*   Params--List of encoder parameters
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   03/22/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
CodecGetEncoderParameterList(
    const CLSID*    clsid,
    const IN UINT   size,
    OUT EncoderParameters*  pBuffer
    )
{
    BOOL bFound = FALSE;
    WCHAR* DllName;

    CreateCodecInstanceProc creationProc;

    {
        // Acquire global critical section

        ImagingCritSec critsec;

        ReloadCachedCodecInfo();

        // Check if we have an encoder with the specified class ID

        CachedCodecInfo* curCodec;

        for ( curCodec = CachedCodecs;
              curCodec != NULL;
              curCodec = curCodec->next)
        {
            if ( (curCodec->Flags & IMGCODEC_ENCODER)
               &&(curCodec->Clsid == *clsid) )
            {
                bFound = TRUE;
                DllName = (WCHAR*)curCodec->DllName;
                creationProc = curCodec->creationProc;

                break;
            }
        }
    }

    if ( bFound == FALSE )
    {
        return IMGERR_CODECNOTFOUND;
    }

    // Create an instance of image encoder

    IImageEncoder* pEncoder;
    HRESULT hResult;

    if ( creationProc )
    {
        // Built-in encoder

        hResult = creationProc(IID_IImageEncoder, (VOID**)&pEncoder);
    }
    else
    {
        // External encoder

        hResult = MyCreateInstance(DllName, IID_IImageEncoder,(VOID**)&pEncoder);
    }

    if ( FAILED(hResult) )
    {
        return hResult;
    }

    // Initialize the decoder with input data stream

    hResult = pEncoder->GetEncoderParameterList(size, pBuffer);

    pEncoder->Release();

    return hResult;
}// CodecGetEncoderParameterList()

/**************************************************************************\
*
* Function Description:
*
*   Get an encoder object to output to the specified stream
*
* Arguments:
*
*   clsid - Specifies the encoder class ID
*   stream - Specifies the output data stream
*   encoder - If the call is successful, return a pointer to
*       an initialized IImageEncoder object
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
CreateEncoderToStream(
    const CLSID* clsid,
    IStream* stream,
    IImageEncoder** encoder
    )
{
    BOOL found = FALSE;
    WCHAR* DllName;
    BOOL needSeekable;
    CreateCodecInstanceProc creationProc;

    {
        // Acquire global critical section

        ImagingCritSec critsec;

        ReloadCachedCodecInfo();

        // Check if we have an encoder with the specified class ID

        CachedCodecInfo* cur;

        for (cur = CachedCodecs; cur != NULL; cur = cur->next)
        {
            if ((cur->Flags & IMGCODEC_ENCODER) && cur->Clsid == *clsid)
            {
                found = TRUE;

                DllName = (WCHAR*)cur->DllName;
                creationProc = cur->creationProc;

                if (cur->Flags & IMGCODEC_SEEKABLE_ENCODE)
                    needSeekable = TRUE;

                break;
            }
        }
    }

    if (!found)
        return IMGERR_CODECNOTFOUND;

    // Create an instance of image encoder

    IImageEncoder* codec;
    HRESULT hr;

    if (creationProc)
    {
        // Built-in encoder

        hr = creationProc(IID_IImageEncoder, (VOID**) &codec);
    }
    else
    {
        // External encoder

        hr = MyCreateInstance(
                DllName,
                IID_IImageEncoder,
                (VOID**) &codec);
    }

    if (FAILED(hr))
        return hr;

    // Initialize the decoder with input data stream

    hr = codec->InitEncoder(stream);

    if (SUCCEEDED(hr))
        *encoder = codec;
    else
        codec->Release();

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Get the list of installed codecs
*
* Arguments:
*
*   count - Return the number of installed codecs
*   codecs - Pointer to an array of ImageCodecInfo structures
*   selectionFlag - Whether caller is interested in decoders or encoders
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

#define COPYCODECINFOSTR(_f)            \
        dst->_f = (const WCHAR*) buf;   \
        size = SizeofWSTR(cur->_f);     \
        memcpy(buf, cur->_f, size);     \
        buf += size

HRESULT
GetInstalledCodecs(
    UINT* count,
    ImageCodecInfo** codecs,
    UINT selectionFlag
    )
{
    TRACE(("GetInstalledCodecs: flag = 0x%x\n", selectionFlag));

    // Acquire global critical section

    ImagingCritSec critsec;

    ReloadCachedCodecInfo();

    CachedCodecInfo* cur;
    UINT n, size;

    // Count the number of selected codecs
    // and figure the amount of memory we need to allocate

    n = size = 0;

    for (cur = CachedCodecs; cur; cur = cur->next)
    {
        if (cur->Flags & selectionFlag)
        {
            n++;
            size += cur->structSize;
        }
    }

    BYTE* buf;
    HRESULT hr;

    *count = 0;
    *codecs = NULL;

    // Allocate output memory buffer

    if (n == 0)
        hr = IMGERR_CODECNOTFOUND;
    else if ((buf = (BYTE*) GpCoAlloc(size)) == NULL)
        hr = E_OUTOFMEMORY;
    else
    {
        *count = n;
        *codecs = (ImageCodecInfo*) buf;

        // Copy codec information to the output buffer

        ImageCodecInfo* dst = *codecs;
        buf += n * sizeof(ImageCodecInfo);

        for (cur = CachedCodecs; cur; cur = cur->next)
        {
            if ((cur->Flags & selectionFlag) == 0)
                continue;

            // First do a simple memory copy

            *dst = *static_cast<ImageCodecInfo*>(cur);

            // Then modify the pointer fields

            COPYCODECINFOSTR(CodecName);

            if (cur->DllName != NULL)
            {
                COPYCODECINFOSTR(DllName);
            }

            COPYCODECINFOSTR(FormatDescription);
            COPYCODECINFOSTR(FilenameExtension);
            COPYCODECINFOSTR(MimeType);

            if (size = cur->SigCount*cur->SigSize)
            {
                dst->SigPattern = buf;
                memcpy(buf, cur->SigPattern, size);
                buf += size;

                dst->SigMask = buf;
                memcpy(buf, cur->SigMask, size);
                buf += size;
            }

            dst++;
        }

        hr = S_OK;
    }

    // Global critical section is released in critsec destructor

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\api\codecmgr.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   codecmgr.hpp
*
* Abstract:
*
*   Codec management functions
*
* Revision History:
*
*   05/13/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _CODECMGR_HPP
#define _CODECMGR_HPP

//
// Various data structures for maintaining the cache of codecs
//
typedef HRESULT (*CreateCodecInstanceProc)(REFIID, VOID**);

struct CachedCodecInfo : public ImageCodecInfo
{
    CachedCodecInfo* next;
    CachedCodecInfo* prev;
    UINT structSize;
    CreateCodecInstanceProc creationProc;
};

extern CachedCodecInfo* CachedCodecs;      // cached list of codecs
extern BOOL CodecCacheUpdated;             // when cachedcode list has been udpated

//
// Get a decoder object that can process the specified data stream
//

HRESULT
CreateDecoderForStream(
    IStream* stream,
    IImageDecoder** decoder,
    DecoderInitFlag flags
    );

//
// Get an encoder parameter list size
//
HRESULT
CodecGetEncoderParameterListSize(
    const CLSID* clsid,
    UINT*   size
    );

//
// Get an encoder parameter list
//
HRESULT
CodecGetEncoderParameterList(
    const CLSID*    clsid,
    const IN UINT   size,
    OUT EncoderParameters*  pBuffer
    );

//
// Get an encoder object to output to the specified stream
//

HRESULT
CreateEncoderToStream(
    const CLSID* clsid,
    IStream* stream,
    IImageEncoder** encoder
    );

//
// Initialize cached list of decoders and encoders
// by reading information out of the registry.
//

VOID ReloadCachedCodecInfo();

//
// Free any cached information about installed codecs
//

VOID
FreeCachedCodecInfo(
    UINT flags
    );

//
// Get the list of installed codecs
//

HRESULT
GetInstalledCodecs(
    UINT* count,
    ImageCodecInfo** codecs,
    UINT selectionFlag
    );

//
// Install a codec: save relevant information into the registry
//

HRESULT
InstallCodec(
    const ImageCodecInfo* codecInfo
    );

// Uninstall a codec

HRESULT
UninstallCodec(
    const WCHAR* codecName,
    UINT flags
    );

#endif // !_CODECMGR_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\api\colorpal.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   colorpal.cpp
*
* Abstract:
*
*   Color palette related functions
*
* Revision History:
*
*   05/17/1999 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

//
// Default 1bpp color palette
//

#define MAKEPALENTRY(r, g, b) MAKEARGB(255, r, g, b)

struct
{
    UINT flags;
    UINT count;
    ARGB entries[2];
}
const Default1bppColorPalette =
{
    PALFLAG_GRAYSCALE,
    2,

    MAKEPALENTRY(0x00, 0x00, 0x00),
    MAKEPALENTRY(0xff, 0xff, 0xff)
};

//
// Default 4bpp color palette - VGA palette
//

struct
{
    UINT flags;
    UINT count;
    ARGB entries[16];
}
const Default4bppColorPalette =
{
    0,
    16,

    MAKEPALENTRY(0x00, 0x00, 0x00),
    MAKEPALENTRY(0x80, 0x00, 0x00),
    MAKEPALENTRY(0x00, 0x80, 0x00),
    MAKEPALENTRY(0x80, 0x80, 0x00),
    MAKEPALENTRY(0x00, 0x00, 0x80),
    MAKEPALENTRY(0x80, 0x00, 0x80),
    MAKEPALENTRY(0x00, 0x80, 0x80),
    MAKEPALENTRY(0x80, 0x80, 0x80),
    MAKEPALENTRY(0xC0, 0xC0, 0xC0),
    MAKEPALENTRY(0xFF, 0x00, 0x00),
    MAKEPALENTRY(0x00, 0xFF, 0x00),
    MAKEPALENTRY(0xFF, 0xFF, 0x00),
    MAKEPALENTRY(0x00, 0x00, 0xFF),
    MAKEPALENTRY(0xFF, 0x00, 0xFF),
    MAKEPALENTRY(0x00, 0xFF, 0xFF),
    MAKEPALENTRY(0xFF, 0xFF, 0xFF)
};

//
// Default 8bpp color palette
//

struct
{
    UINT flags;
    UINT count;
    ARGB entries[256];
}
const Default8bppColorPalette =
{
    PALFLAG_HALFTONE,
    256,

    MAKEPALENTRY(0x00, 0x00, 0x00),     // 16 VGA colors
    MAKEPALENTRY(0x80, 0x00, 0x00),
    MAKEPALENTRY(0x00, 0x80, 0x00),
    MAKEPALENTRY(0x80, 0x80, 0x00),
    MAKEPALENTRY(0x00, 0x00, 0x80),
    MAKEPALENTRY(0x80, 0x00, 0x80),
    MAKEPALENTRY(0x00, 0x80, 0x80),
    MAKEPALENTRY(0x80, 0x80, 0x80),
    MAKEPALENTRY(0xC0, 0xC0, 0xC0),
    MAKEPALENTRY(0xFF, 0x00, 0x00),
    MAKEPALENTRY(0x00, 0xFF, 0x00),
    MAKEPALENTRY(0xFF, 0xFF, 0x00),
    MAKEPALENTRY(0x00, 0x00, 0xFF),
    MAKEPALENTRY(0xFF, 0x00, 0xFF),
    MAKEPALENTRY(0x00, 0xFF, 0xFF),
    MAKEPALENTRY(0xFF, 0xFF, 0xFF),

    0,                                  // 24 unused entries
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,

    // !!! TODO
    //  Use simple 4x4 dither cell for now.
    //  Eventually should switch to Daniel's supercells.

    MAKEPALENTRY(0x00, 0x00, 0x00),
    MAKEPALENTRY(0x00, 0x00, 0x33),
    MAKEPALENTRY(0x00, 0x00, 0x66),
    MAKEPALENTRY(0x00, 0x00, 0x99),
    MAKEPALENTRY(0x00, 0x00, 0xCC),
    MAKEPALENTRY(0x00, 0x00, 0xFF),
    MAKEPALENTRY(0x00, 0x33, 0x00),
    MAKEPALENTRY(0x00, 0x33, 0x33),
    MAKEPALENTRY(0x00, 0x33, 0x66),
    MAKEPALENTRY(0x00, 0x33, 0x99),
    MAKEPALENTRY(0x00, 0x33, 0xCC),
    MAKEPALENTRY(0x00, 0x33, 0xFF),
    MAKEPALENTRY(0x00, 0x66, 0x00),
    MAKEPALENTRY(0x00, 0x66, 0x33),
    MAKEPALENTRY(0x00, 0x66, 0x66),
    MAKEPALENTRY(0x00, 0x66, 0x99),
    MAKEPALENTRY(0x00, 0x66, 0xCC),
    MAKEPALENTRY(0x00, 0x66, 0xFF),
    MAKEPALENTRY(0x00, 0x99, 0x00),
    MAKEPALENTRY(0x00, 0x99, 0x33),
    MAKEPALENTRY(0x00, 0x99, 0x66),
    MAKEPALENTRY(0x00, 0x99, 0x99),
    MAKEPALENTRY(0x00, 0x99, 0xCC),
    MAKEPALENTRY(0x00, 0x99, 0xFF),
    MAKEPALENTRY(0x00, 0xCC, 0x00),
    MAKEPALENTRY(0x00, 0xCC, 0x33),
    MAKEPALENTRY(0x00, 0xCC, 0x66),
    MAKEPALENTRY(0x00, 0xCC, 0x99),
    MAKEPALENTRY(0x00, 0xCC, 0xCC),
    MAKEPALENTRY(0x00, 0xCC, 0xFF),
    MAKEPALENTRY(0x00, 0xFF, 0x00),
    MAKEPALENTRY(0x00, 0xFF, 0x33),
    MAKEPALENTRY(0x00, 0xFF, 0x66),
    MAKEPALENTRY(0x00, 0xFF, 0x99),
    MAKEPALENTRY(0x00, 0xFF, 0xCC),
    MAKEPALENTRY(0x00, 0xFF, 0xFF),
    MAKEPALENTRY(0x33, 0x00, 0x00),
    MAKEPALENTRY(0x33, 0x00, 0x33),
    MAKEPALENTRY(0x33, 0x00, 0x66),
    MAKEPALENTRY(0x33, 0x00, 0x99),
    MAKEPALENTRY(0x33, 0x00, 0xCC),
    MAKEPALENTRY(0x33, 0x00, 0xFF),
    MAKEPALENTRY(0x33, 0x33, 0x00),
    MAKEPALENTRY(0x33, 0x33, 0x33),
    MAKEPALENTRY(0x33, 0x33, 0x66),
    MAKEPALENTRY(0x33, 0x33, 0x99),
    MAKEPALENTRY(0x33, 0x33, 0xCC),
    MAKEPALENTRY(0x33, 0x33, 0xFF),
    MAKEPALENTRY(0x33, 0x66, 0x00),
    MAKEPALENTRY(0x33, 0x66, 0x33),
    MAKEPALENTRY(0x33, 0x66, 0x66),
    MAKEPALENTRY(0x33, 0x66, 0x99),
    MAKEPALENTRY(0x33, 0x66, 0xCC),
    MAKEPALENTRY(0x33, 0x66, 0xFF),
    MAKEPALENTRY(0x33, 0x99, 0x00),
    MAKEPALENTRY(0x33, 0x99, 0x33),
    MAKEPALENTRY(0x33, 0x99, 0x66),
    MAKEPALENTRY(0x33, 0x99, 0x99),
    MAKEPALENTRY(0x33, 0x99, 0xCC),
    MAKEPALENTRY(0x33, 0x99, 0xFF),
    MAKEPALENTRY(0x33, 0xCC, 0x00),
    MAKEPALENTRY(0x33, 0xCC, 0x33),
    MAKEPALENTRY(0x33, 0xCC, 0x66),
    MAKEPALENTRY(0x33, 0xCC, 0x99),
    MAKEPALENTRY(0x33, 0xCC, 0xCC),
    MAKEPALENTRY(0x33, 0xCC, 0xFF),
    MAKEPALENTRY(0x33, 0xFF, 0x00),
    MAKEPALENTRY(0x33, 0xFF, 0x33),
    MAKEPALENTRY(0x33, 0xFF, 0x66),
    MAKEPALENTRY(0x33, 0xFF, 0x99),
    MAKEPALENTRY(0x33, 0xFF, 0xCC),
    MAKEPALENTRY(0x33, 0xFF, 0xFF),
    MAKEPALENTRY(0x66, 0x00, 0x00),
    MAKEPALENTRY(0x66, 0x00, 0x33),
    MAKEPALENTRY(0x66, 0x00, 0x66),
    MAKEPALENTRY(0x66, 0x00, 0x99),
    MAKEPALENTRY(0x66, 0x00, 0xCC),
    MAKEPALENTRY(0x66, 0x00, 0xFF),
    MAKEPALENTRY(0x66, 0x33, 0x00),
    MAKEPALENTRY(0x66, 0x33, 0x33),
    MAKEPALENTRY(0x66, 0x33, 0x66),
    MAKEPALENTRY(0x66, 0x33, 0x99),
    MAKEPALENTRY(0x66, 0x33, 0xCC),
    MAKEPALENTRY(0x66, 0x33, 0xFF),
    MAKEPALENTRY(0x66, 0x66, 0x00),
    MAKEPALENTRY(0x66, 0x66, 0x33),
    MAKEPALENTRY(0x66, 0x66, 0x66),
    MAKEPALENTRY(0x66, 0x66, 0x99),
    MAKEPALENTRY(0x66, 0x66, 0xCC),
    MAKEPALENTRY(0x66, 0x66, 0xFF),
    MAKEPALENTRY(0x66, 0x99, 0x00),
    MAKEPALENTRY(0x66, 0x99, 0x33),
    MAKEPALENTRY(0x66, 0x99, 0x66),
    MAKEPALENTRY(0x66, 0x99, 0x99),
    MAKEPALENTRY(0x66, 0x99, 0xCC),
    MAKEPALENTRY(0x66, 0x99, 0xFF),
    MAKEPALENTRY(0x66, 0xCC, 0x00),
    MAKEPALENTRY(0x66, 0xCC, 0x33),
    MAKEPALENTRY(0x66, 0xCC, 0x66),
    MAKEPALENTRY(0x66, 0xCC, 0x99),
    MAKEPALENTRY(0x66, 0xCC, 0xCC),
    MAKEPALENTRY(0x66, 0xCC, 0xFF),
    MAKEPALENTRY(0x66, 0xFF, 0x00),
    MAKEPALENTRY(0x66, 0xFF, 0x33),
    MAKEPALENTRY(0x66, 0xFF, 0x66),
    MAKEPALENTRY(0x66, 0xFF, 0x99),
    MAKEPALENTRY(0x66, 0xFF, 0xCC),
    MAKEPALENTRY(0x66, 0xFF, 0xFF),
    MAKEPALENTRY(0x99, 0x00, 0x00),
    MAKEPALENTRY(0x99, 0x00, 0x33),
    MAKEPALENTRY(0x99, 0x00, 0x66),
    MAKEPALENTRY(0x99, 0x00, 0x99),
    MAKEPALENTRY(0x99, 0x00, 0xCC),
    MAKEPALENTRY(0x99, 0x00, 0xFF),
    MAKEPALENTRY(0x99, 0x33, 0x00),
    MAKEPALENTRY(0x99, 0x33, 0x33),
    MAKEPALENTRY(0x99, 0x33, 0x66),
    MAKEPALENTRY(0x99, 0x33, 0x99),
    MAKEPALENTRY(0x99, 0x33, 0xCC),
    MAKEPALENTRY(0x99, 0x33, 0xFF),
    MAKEPALENTRY(0x99, 0x66, 0x00),
    MAKEPALENTRY(0x99, 0x66, 0x33),
    MAKEPALENTRY(0x99, 0x66, 0x66),
    MAKEPALENTRY(0x99, 0x66, 0x99),
    MAKEPALENTRY(0x99, 0x66, 0xCC),
    MAKEPALENTRY(0x99, 0x66, 0xFF),
    MAKEPALENTRY(0x99, 0x99, 0x00),
    MAKEPALENTRY(0x99, 0x99, 0x33),
    MAKEPALENTRY(0x99, 0x99, 0x66),
    MAKEPALENTRY(0x99, 0x99, 0x99),
    MAKEPALENTRY(0x99, 0x99, 0xCC),
    MAKEPALENTRY(0x99, 0x99, 0xFF),
    MAKEPALENTRY(0x99, 0xCC, 0x00),
    MAKEPALENTRY(0x99, 0xCC, 0x33),
    MAKEPALENTRY(0x99, 0xCC, 0x66),
    MAKEPALENTRY(0x99, 0xCC, 0x99),
    MAKEPALENTRY(0x99, 0xCC, 0xCC),
    MAKEPALENTRY(0x99, 0xCC, 0xFF),
    MAKEPALENTRY(0x99, 0xFF, 0x00),
    MAKEPALENTRY(0x99, 0xFF, 0x33),
    MAKEPALENTRY(0x99, 0xFF, 0x66),
    MAKEPALENTRY(0x99, 0xFF, 0x99),
    MAKEPALENTRY(0x99, 0xFF, 0xCC),
    MAKEPALENTRY(0x99, 0xFF, 0xFF),
    MAKEPALENTRY(0xCC, 0x00, 0x00),
    MAKEPALENTRY(0xCC, 0x00, 0x33),
    MAKEPALENTRY(0xCC, 0x00, 0x66),
    MAKEPALENTRY(0xCC, 0x00, 0x99),
    MAKEPALENTRY(0xCC, 0x00, 0xCC),
    MAKEPALENTRY(0xCC, 0x00, 0xFF),
    MAKEPALENTRY(0xCC, 0x33, 0x00),
    MAKEPALENTRY(0xCC, 0x33, 0x33),
    MAKEPALENTRY(0xCC, 0x33, 0x66),
    MAKEPALENTRY(0xCC, 0x33, 0x99),
    MAKEPALENTRY(0xCC, 0x33, 0xCC),
    MAKEPALENTRY(0xCC, 0x33, 0xFF),
    MAKEPALENTRY(0xCC, 0x66, 0x00),
    MAKEPALENTRY(0xCC, 0x66, 0x33),
    MAKEPALENTRY(0xCC, 0x66, 0x66),
    MAKEPALENTRY(0xCC, 0x66, 0x99),
    MAKEPALENTRY(0xCC, 0x66, 0xCC),
    MAKEPALENTRY(0xCC, 0x66, 0xFF),
    MAKEPALENTRY(0xCC, 0x99, 0x00),
    MAKEPALENTRY(0xCC, 0x99, 0x33),
    MAKEPALENTRY(0xCC, 0x99, 0x66),
    MAKEPALENTRY(0xCC, 0x99, 0x99),
    MAKEPALENTRY(0xCC, 0x99, 0xCC),
    MAKEPALENTRY(0xCC, 0x99, 0xFF),
    MAKEPALENTRY(0xCC, 0xCC, 0x00),
    MAKEPALENTRY(0xCC, 0xCC, 0x33),
    MAKEPALENTRY(0xCC, 0xCC, 0x66),
    MAKEPALENTRY(0xCC, 0xCC, 0x99),
    MAKEPALENTRY(0xCC, 0xCC, 0xCC),
    MAKEPALENTRY(0xCC, 0xCC, 0xFF),
    MAKEPALENTRY(0xCC, 0xFF, 0x00),
    MAKEPALENTRY(0xCC, 0xFF, 0x33),
    MAKEPALENTRY(0xCC, 0xFF, 0x66),
    MAKEPALENTRY(0xCC, 0xFF, 0x99),
    MAKEPALENTRY(0xCC, 0xFF, 0xCC),
    MAKEPALENTRY(0xCC, 0xFF, 0xFF),
    MAKEPALENTRY(0xFF, 0x00, 0x00),
    MAKEPALENTRY(0xFF, 0x00, 0x33),
    MAKEPALENTRY(0xFF, 0x00, 0x66),
    MAKEPALENTRY(0xFF, 0x00, 0x99),
    MAKEPALENTRY(0xFF, 0x00, 0xCC),
    MAKEPALENTRY(0xFF, 0x00, 0xFF),
    MAKEPALENTRY(0xFF, 0x33, 0x00),
    MAKEPALENTRY(0xFF, 0x33, 0x33),
    MAKEPALENTRY(0xFF, 0x33, 0x66),
    MAKEPALENTRY(0xFF, 0x33, 0x99),
    MAKEPALENTRY(0xFF, 0x33, 0xCC),
    MAKEPALENTRY(0xFF, 0x33, 0xFF),
    MAKEPALENTRY(0xFF, 0x66, 0x00),
    MAKEPALENTRY(0xFF, 0x66, 0x33),
    MAKEPALENTRY(0xFF, 0x66, 0x66),
    MAKEPALENTRY(0xFF, 0x66, 0x99),
    MAKEPALENTRY(0xFF, 0x66, 0xCC),
    MAKEPALENTRY(0xFF, 0x66, 0xFF),
    MAKEPALENTRY(0xFF, 0x99, 0x00),
    MAKEPALENTRY(0xFF, 0x99, 0x33),
    MAKEPALENTRY(0xFF, 0x99, 0x66),
    MAKEPALENTRY(0xFF, 0x99, 0x99),
    MAKEPALENTRY(0xFF, 0x99, 0xCC),
    MAKEPALENTRY(0xFF, 0x99, 0xFF),
    MAKEPALENTRY(0xFF, 0xCC, 0x00),
    MAKEPALENTRY(0xFF, 0xCC, 0x33),
    MAKEPALENTRY(0xFF, 0xCC, 0x66),
    MAKEPALENTRY(0xFF, 0xCC, 0x99),
    MAKEPALENTRY(0xFF, 0xCC, 0xCC),
    MAKEPALENTRY(0xFF, 0xCC, 0xFF),
    MAKEPALENTRY(0xFF, 0xFF, 0x00),
    MAKEPALENTRY(0xFF, 0xFF, 0x33),
    MAKEPALENTRY(0xFF, 0xFF, 0x66),
    MAKEPALENTRY(0xFF, 0xFF, 0x99),
    MAKEPALENTRY(0xFF, 0xFF, 0xCC),
    MAKEPALENTRY(0xFF, 0xFF, 0xFF)
};

/**************************************************************************\
*
* Function Description:
*
*   Get default color palette for the specified pixel format
*
* Arguments:
*
*   pixfmt - Specifies the pixel format
*       must be one of the indexed color formats
*
* Return Value:
*
*   Pointer to the requested default color palette
*
\**************************************************************************/

const ColorPalette*
GetDefaultColorPalette(
    PixelFormatID pixfmt
    )
{
    const ColorPalette* pal;

    switch (pixfmt)
    {
    case PIXFMT_1BPP_INDEXED:

        pal = (const ColorPalette*) &Default1bppColorPalette;
        break;

    case PIXFMT_4BPP_INDEXED:
        pal = (const ColorPalette*) &Default4bppColorPalette;
        break;

    case PIXFMT_8BPP_INDEXED:
        pal = (const ColorPalette*) &Default8bppColorPalette;
        break;

    default:
        RIP(("Invalid pixel format in GetDefaultColorPalette"));
        pal = NULL;
        break;
    }

    return pal;
}


/**************************************************************************\
*
* Function Description:
*
*   Make a copy of the specified color palette
*
* Arguments:
*
*   oldpal - Specifies the palette to be copied
*   useCoalloc - Use CoTaskMemAlloc or malloc to allocate memory?
*
* Return Value:
*
*   Pointer to the new copy of the palette
*   NULL if there is an error
*
\**************************************************************************/

ColorPalette*
CloneColorPalette(
    const ColorPalette* oldpal,
    BOOL useCoalloc
    )
{

    // Allocate memory for the new palette

    ColorPalette* newpal;
    UINT size;

    size = offsetof(ColorPalette, Entries) + oldpal->Count * sizeof(ARGB);
    newpal = (ColorPalette*) (useCoalloc ? GpCoAlloc(size) : GpMalloc(size));

    if (newpal != NULL)
    {
        // Copy the input palette contents

        memcpy(newpal, oldpal, size);
    }
    else
    {
        WARNING(("Out of memory in CloneColorPalette"));
    }

    return newpal;
}

/**************************************************************************\
*
* Function Description:
*
* Make a copy of the specified color palette, padding the end so that
* the result has the given number of entries.
*
* Arguments:
*
*   oldpal     - Specifies the palette to be copied
*   numEntries - The number of entries the new palette should have
*   fillColor  - The color to use for the extra entries (if any)
*
* Notes:
*
*   Doesn't handle shrinks. numEntries must be at least as much as the
*   number of entries in the original palette.
*
* Return Value:
*
*   Pointer to the new copy of the palette
*   NULL if there is an error
*
\**************************************************************************/

ColorPalette*
CloneColorPaletteResize(
    const ColorPalette* oldpal,
    UINT numEntries,
    ARGB fillColor
    )
{
    ASSERT(numEntries >= oldpal->Count);
    
    // Allocate memory for the new palette

    ColorPalette* newpal;
    UINT oldsize, newsize;

    oldsize = offsetof(ColorPalette, Entries) + oldpal->Count * sizeof(ARGB);
    newsize = oldsize + (numEntries - oldpal->Count) * sizeof(ARGB);
    
    newpal = static_cast<ColorPalette*>(GpMalloc(newsize));

    if (newpal != NULL)
    {
        // Copy the input palette contents

        memcpy(newpal, oldpal, oldsize);
        newpal->Count = numEntries;
        
        UINT i;
        ARGB *ptr = &(newpal->Entries[oldpal->Count]);
        
        for (i=oldpal->Count;i<numEntries;i++)
        {
            *ptr++ = fillColor;
        }
    }
    else
    {
        WARNING(("Out of memory in CloneColorPaletteResize"));
    }

    return newpal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\api\bitmap.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   bitmap.hpp
*
* Abstract:
*
*   GpMemoryBitmap class declarations
*
* Revision History:
*
*   05/10/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _BITMAP_HPP
#define _BITMAP_HPP

#include "propertyutil.hpp"

//--------------------------------------------------------------------------
// Information about various pixel data formats we support
//--------------------------------------------------------------------------

struct PixelFormatDescription
{
    BYTE Abits;
    BYTE Rbits;
    BYTE Gbits;
    BYTE Bbits;
    PixelFormatID pixelFormat;
};

extern const PixelFormatDescription PixelFormatDescs[];

// Extract the index field from the pixel format ID

inline UINT
GetPixelFormatIndex(
    PixelFormatID pixfmt
    )
{
    return pixfmt & 0xff;
}

// Check if a pixel format ID is valid

inline BOOL
IsValidPixelFormat(
    PixelFormatID pixfmt
    )
{
    UINT index = GetPixelFormatIndex(pixfmt);

    return index < PIXFMT_MAX &&
           PixelFormatDescs[index].pixelFormat == (pixfmt & 0xffffff);
}

// Determine if the pixel format is supported by GDI

inline BOOL
IsGDIPixelFormat(
    PixelFormatID pixfmt
    )
{
    return (pixfmt & PIXFMTFLAG_GDI) != 0;
}

// Whether the pixel format can have alpha

inline BOOL
CanHaveAlpha(
    PixelFormatID pixfmt,
    const ColorPalette* pal
    )
{
    return IsAlphaPixelFormat(pixfmt) ||
           IsIndexedPixelFormat(pixfmt);
//           pal && (pal->Flags & PALFLAG_HASALPHA);
}

// Scanline stride for our internal bitmaps are always multiples of 4

#define STRIDE_ALIGNMENT(x) (((x) + 3) & ~3)

inline UINT
CalcScanlineStride(
    UINT width,
    UINT pixsize
    )
{
    return STRIDE_ALIGNMENT((width * pixsize + 7) >> 3);
}

// Convert pixel unit to 0.01mm unit

inline INT
Pixel2HiMetric(
    INT pixels,
    double dpi
    )
{
    return (INT) (pixels * 2540.0 / dpi + 0.5);
}

// Convert 0.01mm unit to pixel unit

inline INT
HiMetric2Pixel(
    INT himetric,
    double dpi
    )
{
    return (INT) (himetric * dpi / 2540.0 + 0.5);
}

enum ColorAdjustType;

//--------------------------------------------------------------------------
// GpMemoryBitmap class
//--------------------------------------------------------------------------

class GpRecolor;
class GpDecodedImage;

class GpMemoryBitmap :
            public IBitmapImage,
            public IImage,
            public IImageSink,
            public IBasicBitmapOps,
            public BitmapData
{
    friend class GpBitmapDecodeSink;
    friend class GpBitmap;
    friend class CopyOnWriteBitmap;
    

public:


    //------------------------------------------------------------
    // Public constructors/destructors used internally
    // by ourselves
    //------------------------------------------------------------

    GpMemoryBitmap();
    virtual ~GpMemoryBitmap();

    // Initialize a new bitmap image object of the specified
    // dimension and pixel format.

    HRESULT
    InitNewBitmap(
        IN UINT width,
        IN UINT height,
        IN PixelFormatID pixelFormat,
        BOOL clear = FALSE
        );

    // Initialize a new bitmap image with an IImage object

    HRESULT
    InitImageBitmap(
        IN IImage* image,
        IN UINT width,
        IN UINT height,
        IN PixelFormatID pixelFormat,
        IN InterpolationHint hints,
        IN DrawImageAbort callback = NULL,
        IN VOID* callbackData = NULL
        );

    // Initialize a new bitmap image object with
    // user-supplied memory buffer

    HRESULT
    InitMemoryBitmap(
        IN BitmapData* bitmapData
        );

    // Initialize a new bitmap image object as
    // a wrapper around a direct draw surface.

    HRESULT
    InitDirectDrawBitmap(
        IN IDirectDrawSurface7 * suface
        );

    // Create a new bitmap image object from an IImage object

    static HRESULT
    CreateFromImage(
        IN IImage* image,
        IN UINT width,
        IN UINT height,
        IN PixelFormatID pixelFormat,
        IN InterpolationHint hints,
        OUT GpMemoryBitmap** bmp,
        IN DrawImageAbort callback = NULL,
        IN VOID* callbackData = NULL
        );

    // Save the bitmap object to a stream

    HRESULT
    SaveToStream(
        IN IStream* stream,
        IN CLSID* clsidEncoder,
        IN EncoderParameters* encoderParams,
        IN BOOL fSpecialJPEG,
        OUT IImageEncoder** ppEncoderPtr,
        IN GpDecodedImage* pImageSrc = NULL
        );

    // Save the bitmap object to a stream

    HRESULT
    SaveToFile(
        IN const WCHAR* filename,
        IN CLSID* clsidEncoder,
        IN EncoderParameters* encoderParams,
        IN BOOL fSpecialJPEG,
        OUT IImageEncoder** ppEncoderPtr,
        IN GpDecodedImage* pImageSrc = NULL
        );

    // Append the bitmap object to current encoder object

    HRESULT
    SaveAppend(
        IN const EncoderParameters* encoderParams,
        IN IImageEncoder* destEncoderPtr,
        IN GpDecodedImage* pImageSrc = NULL
        );

    // Get the encoder parameter list size

    HRESULT
    GetEncoderParameterListSize(
        IN  CLSID* clsidEncoder,
        OUT UINT* size
        );

    // Get the encoder parameter list
    
    HRESULT
    GetEncoderParameterList(
        IN CLSID* clsidEncoder,
        IN UINT size,
        OUT EncoderParameters* pBuffer
        );

    // Color adjustment

    HRESULT
    PerformColorAdjustment(
        IN GpRecolor* recolor,
        IN ColorAdjustType type,
        IN DrawImageAbort callback,
        IN VOID* callbackData
        );

    STDMETHOD(GetPropertyCount)(
        OUT UINT*   numOfProperty
        );

    STDMETHOD(GetPropertyIdList)(
        IN UINT numOfProperty,
        IN OUT PROPID* list
        );

    STDMETHOD(GetPropertyItemSize)(
        IN PROPID propId, 
        OUT UINT* size
        );

    STDMETHOD(GetPropertyItem)(
        IN PROPID            propId,
        IN UINT              propSize,
        IN OUT PropertyItem* buffer
        );

    STDMETHOD(GetPropertySize)(
        OUT UINT* totalBufferSize,
        OUT UINT* numProperties
        );

    STDMETHOD(GetAllPropertyItems)(
        IN UINT totalBufferSize,
        IN UINT numProperties,
        IN OUT PropertyItem* allItems
        );

    STDMETHOD(RemovePropertyItem)(
        IN PROPID   propId
        );

    STDMETHOD(SetPropertyItem)(
        IN PropertyItem item
        );

    //------------------------------------------------------------
    // Public IImage interface methods
    //------------------------------------------------------------

    // Overwritten QueryInterface method

    STDMETHOD(QueryInterface)(
        REFIID riid,
        VOID** ppv
        );

    // Increment reference count

    STDMETHOD_(ULONG, AddRef)(VOID)
    {
        return InterlockedIncrement(&comRefCount);
    }

    // Decrement reference count

    STDMETHOD_(ULONG, Release)(VOID)
    {
        ULONG count = InterlockedDecrement(&comRefCount);

        if (count == 0)
            delete this;

        return count;
    }

    // Get the device-independent physical dimension of the image
    //  in unit of 0.01mm

    STDMETHOD(GetPhysicalDimension)(
        OUT SIZE* size
        );

    // Get basic image information

    STDMETHOD(GetImageInfo)(
        OUT ImageInfo* imageInfo
        );

    // Set image flags

    STDMETHOD(SetImageFlags)(
        IN UINT flags
        );
 
    // Display the image in a GDI device context

    STDMETHOD(Draw)(
        IN HDC hdc,
        IN const RECT* dstRect,
        IN OPTIONAL const RECT* srcRect
        );

    // Push image data into an IImageSink

    STDMETHOD(PushIntoSink)(
        IN IImageSink* sink
        );

    // Get a thumbnail representation for the image object

    STDMETHOD(GetThumbnail)(
        IN OPTIONAL UINT thumbWidth,
        IN OPTIONAL UINT thumbHeight,
        OUT IImage** thumbImage
        );

    //------------------------------------------------------------
    // Public IBitmapImage interface methods
    //------------------------------------------------------------

    // Get bitmap dimensions in pixels

    STDMETHOD(GetSize)(
        OUT SIZE* size
        );

    // Get bitmap pixel format

    STDMETHOD(GetPixelFormatID)(
        OUT PixelFormatID* pixelFormat
        )
    {
        ASSERT(IsValid());

        *pixelFormat = this->PixelFormat;
        return S_OK;
    }

    // Access bitmap data in native pixel format

    STDMETHOD(LockBits)(
        IN const RECT* rect,
        IN UINT flags,
        IN PixelFormatID pixelFormat,
        OUT BitmapData* lockedBitmapData
        );

    STDMETHOD(UnlockBits)(
        IN const BitmapData* lockedBitmapData
        );

    // Set/get palette associated with the bitmap image

    STDMETHOD(GetPalette)(
        OUT ColorPalette** palette
        );

    STDMETHOD(SetPalette)(
        IN const ColorPalette* palette
        );

    //------------------------------------------------------------
    // Public IImageSInk interface methods
    //------------------------------------------------------------

    // Begin the sink process

    STDMETHOD(BeginSink)(
        IN OUT ImageInfo* imageInfo,
        OUT OPTIONAL RECT* subarea
        );

    // End the sink process

    STDMETHOD(EndSink)(
        IN HRESULT statusCode
        );

    // Ask the sink to allocate pixel data buffer

    STDMETHOD(GetPixelDataBuffer)(
        IN const RECT* rect,
        IN PixelFormatID pixelFormat,
        IN BOOL lastPass,
        OUT BitmapData* bitmapData
        );

    // Give the sink pixel data and release data buffer

    STDMETHOD(ReleasePixelDataBuffer)(
        IN const BitmapData* bitmapData
        );

    // Push pixel data

    STDMETHOD(PushPixelData)(
        IN const RECT* rect,
        IN const BitmapData* bitmapData,
        IN BOOL lastPass
        );

    // Push raw image data

    STDMETHOD(PushRawData)(
        IN const VOID* buffer,
        IN UINT bufsize
        );

    STDMETHOD(NeedTransform)(
        OUT UINT* rotation
        )
    {
        return E_NOTIMPL;
    }

    STDMETHOD(NeedRawProperty)(void *pSrc)
    {
        // GpMemoryBitmap can't handle raw property

        return E_FAIL;
    }
    
    STDMETHOD(PushRawInfo)(
        IN OUT void* info
        )
    {
        return E_NOTIMPL;
    }
    
    STDMETHOD(GetPropertyBuffer)(
        IN     UINT            uiTotalBufferSize,
        IN OUT PropertyItem**  ppBuffer
        )
    {
        return E_NOTIMPL;
    }
    
    STDMETHOD(PushPropertyItems)(
        IN UINT             numOfItems,
        IN UINT             uiTotalBufferSize,
        IN PropertyItem*    item,
        IN BOOL             fICCProfileChanged
        )
    {
        return E_NOTIMPL;
    }
    
    //------------------------------------------------------------
    // Public IBasicBitmapOps interface methods
    //------------------------------------------------------------

    // Clone an area of the bitmap image

    STDMETHOD(Clone)(
        IN OPTIONAL const RECT* rect,
        OUT IBitmapImage** outbmp,
        BOOL    bNeedCloneProperty
        );

    // Flip the bitmap image in x- and/or y-direction

    STDMETHOD(Flip)(
        IN BOOL flipX,
        IN BOOL flipY,
        OUT IBitmapImage** outbmp
        );

    // Resize the bitmap image

    STDMETHOD(Resize)(
        IN UINT newWidth,
        IN UINT newHeight,
        IN PixelFormatID pixelFormat,
        IN InterpolationHint hints,
        OUT IBitmapImage** outbmp
        );

    // Rotate the bitmap image by the specified angle

    STDMETHOD(Rotate)(
        IN FLOAT angle,
        IN InterpolationHint hints,
        OUT IBitmapImage** outbmp
        );

    // Adjust the brightness of the bitmap image

    STDMETHOD(AdjustBrightness)(
        IN FLOAT percent
        );

    // Adjust the contrast of the bitmap image

    STDMETHOD(AdjustContrast)(
        IN FLOAT shadow,
        IN FLOAT highlight
        );

    // Adjust the gamma of the bitmap image

    STDMETHOD(AdjustGamma)(
        IN FLOAT gamma
        );

    //------------------------------------------------------------
    // Public methods used internally by ourselves
    //------------------------------------------------------------

    // Check if the image object is in valid state

    BOOL IsValid() const
    {
        return (Scan0 != NULL ||
                (creationFlag == CREATEDFROM_DDRAWSURFACE &&
                 ddrawSurface != NULL));
    }

    HRESULT
    SetResolution(REAL Xdpi, REAL Ydpi)
    {
        HRESULT hr = S_OK;

        if ((Xdpi > 0.0) && (Ydpi > 0.0))
        {
            xdpi = static_cast<double>(Xdpi);
            ydpi = static_cast<double>(Ydpi);
        }
        else
        {
            hr = E_INVALIDARG;
        }

        return hr;
    }

    // Indicate the type of alpha in the bitmap

    // !!! TO DO: after we remove imaging.dll, we should remove these and use
    // the DpTransparency flags instead

    enum
    {
        ALPHA_UNKNOWN,
        ALPHA_COMPLEX,
        ALPHA_SIMPLE,
        ALPHA_OPAQUE,
        ALPHA_NEARCONSTANT,
        ALPHA_NONE
    };

    HRESULT SetMinMaxAlpha (BYTE minAlpha, BYTE maxAlpha);
    HRESULT GetMinMaxAlpha (BYTE* minAlpha, BYTE* maxAlpha);

    HRESULT GetAlphaHint(INT* alphaHint);
    HRESULT SetAlphaHint(INT alphaHint);

    HRESULT SetSpecialJPEG(GpDecodedImage *pImgSrc);

protected:

    // Allocate/free pixel data buffer

    static BOOL
    AllocBitmapData(
        UINT width,
        UINT height,
        PixelFormatID pixelFormat,
        BitmapData* bmpdata,
        INT *alphaFlags,
        BOOL clear = FALSE
        );

    static VOID
    FreeBitmapData(
        const BitmapData* bmpdata
        );

private:

    // Indicate how a bitmap object was created

    enum
    {
        CREATEDFROM_NONE,
        CREATEDFROM_NEW,
        CREATEDFROM_IMAGE,
        CREATEDFROM_USERBUF,
        CREATEDFROM_DDRAWSURFACE
    };

    LONG comRefCount;           // COM object reference count
    GpLockable objectLock;      // object busy lock
    LONG bitsLock;              // whether the pixel data has been locked
    double xdpi, ydpi;          // resolution
    INT creationFlag;           // how was the bitmap object created
    UINT cacheFlags;            // image flags
    ColorPalette *colorpal;     // color palette
    RECT lockedArea;            // area that has been locked
    IPropertySetStorage *propset; // bitmap image properties
    IDirectDrawSurface7 *ddrawSurface; // direct draw surface
    PROFILE *sourceFProfile;    // source color profile for the front end.
                                // usually extracted from the embedded image profile.
    INT alphaTransparency;

    BYTE minAlpha;
    BYTE maxAlpha;

    // Support DrawImage abort

    DrawImageAbort callback;
    VOID* callbackData;

    // Property related private members
    
    InternalPropertyItem    PropertyListHead;
    InternalPropertyItem    PropertyListTail;
    UINT                    PropertyListSize;
    UINT                    PropertyNumOfItems;
    
    IImageDecoder           *JpegDecoderPtr;    // Pointer to source decoder

    HRESULT
    AllocBitmapMemory(
        UINT width,
        UINT height,
        PixelFormatID pixelFormat,
        BOOL clear = FALSE
        );

    VOID FreeBitmapMemory();

    // Determine if a specified rectangle is a valid subarea of the image

    BOOL
    ValidateImageArea(
        RECT* dstrect,
        const RECT* srcrect
        )
    {
        if (srcrect == NULL)
        {
            dstrect->left = dstrect->top = 0;
            dstrect->right = Width;
            dstrect->bottom = Height;
        }
        else
        {
            if (srcrect->left < 0 ||
                srcrect->right < 0 ||
                srcrect->left >= srcrect->right ||
                srcrect->right > (INT) Width ||
                srcrect->top >= srcrect->bottom ||
                srcrect->bottom > (INT) Height)
            {
                return FALSE;
            }

            *dstrect = *srcrect;
        }

        return TRUE;
    }

    // Helper functions for locking/unlocking ddraw surface
    HRESULT LockDirectDrawSurface();
    HRESULT UnlockDirectDrawSurface();

    // Internal implementation of IBitmapImage::LockBits and 
    // IBitmapImage::UnlockBits methods. We assume the parameter
    // validation and other house-keeping chores have already been done.

    HRESULT
    InternalLockBits(
        const RECT* rect,
        UINT flags,
        PixelFormatID pixfmt,
        BitmapData* lockedData
        );
    
    HRESULT
    InternalUnlockBits(
        const RECT* rect,
        const BitmapData* lockedData
        );

    // Draw the bitmap using GDI calls

    HRESULT
    DrawWithGDI(
        HDC hdc,
        const RECT* dstRect,
        RECT* srcRect
        );

    // Draw the bitmap by creating temporary canonical bitmap

    HRESULT
    DrawCanonical(
        HDC hdc,
        const RECT* dstRect,
        RECT* srcRect
        );

    // Compose a BitmapData structure for the specified
    // area of the bitmap image.

    VOID
    GetBitmapAreaData(
        const RECT* rect,
        BitmapData* bmpdata
        )
    {
        bmpdata->Width = rect->right - rect->left;
        bmpdata->Height = rect->bottom - rect->top;
        bmpdata->PixelFormat = PixelFormat;
        bmpdata->Stride = Stride;
        bmpdata->Reserved = 0;

        bmpdata->Scan0 = (BYTE*) Scan0 +
                         rect->top * Stride +
                         (rect->left * GetPixelFormatSize(PixelFormat) >> 3);
    }

    // Copy palette, flags, etc.

    HRESULT
    CopyPaletteFlagsEtc(
        const GpMemoryBitmap* srcbmp
        )
    {
        HRESULT hr;

        // Copy color palette, if any

        if (srcbmp->colorpal)
        {
            hr = this->SetPalette(srcbmp->colorpal);

            if (FAILED(hr))
                return hr;
        }

        // Copy flags, etc.
        //  !!! TODO

        return S_OK;
    }

    // Perform point operation on a bitmap image

    HRESULT
    PerformPointOps(
        const BYTE lut[256]
        );

    // Get the current palette associated with the bitmap image

    const ColorPalette*
    GetCurrentPalette() const
    {
        if (colorpal)
            return colorpal;
        else if (IsIndexedPixelFormat(PixelFormat))
            return GetDefaultColorPalette(PixelFormat);
        else
            return NULL;
    }

    // Set the state needed to support DrawImage abort and color adjust

    VOID
    SetDrawImageSupport(
        IN DrawImageAbort newCallback,
        IN VOID* newCallbackData
        )
    {
        callback = newCallback;
        callbackData = newCallbackData;
    }

    // Save image property items to the destination sink

    HRESULT
    SavePropertyItems(
        IN GpDecodedImage* pImageSrc,
        IImageSink* pEncodeSink
        );

    HRESULT
    SetJpegQuantizationTable(
        IN IImageEncoder* pEncoder
        );

    // Copy all the property items from current GpMemoryBitmap to the dst object

    HRESULT
    ClonePropertyItems(
        IN GpMemoryBitmap* dstBmp
        );
};

//
// Map COLORREF values to ARGB values
//

inline ARGB COLORREFToARGB(COLORREF color)
{
    return (ARGB) 0xff000000 |
           ((ARGB) (color & 0xff) << 16) |
           ((ARGB) color & 0x00ff00) |
           ((ARGB) (color >> 16) & 0xff);
}

//
// Map ARGB values to COLORREF values
//

inline COLORREF ARGBToCOLORREF(ARGB argb)
{
    //  alpha component is simply ignored
    return (COLORREF)(((argb >> 16) & 0xff) | 
                      (argb & 0x0000ff00) | 
                      ((argb & 0xff) << 16));
}

//
// Flag bits for BitmapData.bmpdataFlags field
//  low-word = ImageLockMode
//  high-word = flag bits below
//

enum
{
    BMPDATA_MALLOC = 0x00010000,
    BMPDATA_VALLOC = 0x00020000,

    BMPDATA_ALLOCMASK = BMPDATA_MALLOC|BMPDATA_VALLOC,
    BMPDATA_LOCKMODEMASK = 0xffff,
};

//
// Perform pixel data format conversion
//

HRESULT
ConvertBitmapData(
    const BitmapData* dstbmp,
    const ColorPalette* dstpal,
    const BitmapData* srcbmp,
    const ColorPalette* srcpal
    );

HRESULT
ConvertBitmapDataSrcUnaligned(
    const BitmapData* dstbmp,
    const ColorPalette* dstpal,
    const BitmapData* srcbmp,
    const ColorPalette* srcpal,
    UINT startBit
    );

HRESULT
ConvertBitmapDataDstUnaligned(
    const BitmapData* dstbmp,
    const ColorPalette* dstpal,
    const BitmapData* srcbmp,
    const ColorPalette* srcpal,
    UINT startBit
    );

#endif // !_BITMAP_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\api\colorpal.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   colorpal.hpp
*
* Abstract:
*
*   Color palette related declarations
*
* Revision History:
*
*   05/17/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _COLORPAL_HPP
#define _COLORPAL_HPP

//
// Return the default color palette for the specified pixel format
//

const ColorPalette*
GetDefaultColorPalette(
    PixelFormatID pixfmt
    );

//
// Make a copy of the specified color palette
//

ColorPalette*
CloneColorPalette(
    const ColorPalette* oldpal,
    BOOL useCoalloc = FALSE
    );

//
// Make a copy of the specified color palette, padding the end so that
// the result has the given number of entries.
//

ColorPalette*
CloneColorPaletteResize(
    const ColorPalette* oldpal,
    UINT numEntries,
    ARGB fillColor
    );

#endif // !_COLORPAL_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\api\comutils.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   comutils.hpp
*
* Abstract:
*
*   COM utility functions and macros
*
* Revision History:
*
*   05/13/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _COMUTILS_HPP
#define _COMUTILS_HPP

//--------------------------------------------------------------------------
// Macros for incrementing or decrementing COM component count
//--------------------------------------------------------------------------

extern HINSTANCE DllInstance;
extern LONG ComComponentCount;

inline VOID IncrementComComponentCount()
{
    InterlockedIncrement(&ComComponentCount);
}

inline VOID DecrementComComponentCount()
{
    InterlockedDecrement(&ComComponentCount);
}


//--------------------------------------------------------------------------
// Template for implementing IUnknown interface
//
// NOTES:
// 1. We can only handle objects that has one interface other than IUnknown.
// 2. We do not support aggregation.
//--------------------------------------------------------------------------

template <class I> class IUnknownBase : public I
{
public:

    // Query interface: note that we can only handle
    // objects that one interface other than IUnknown.

    STDMETHOD(QueryInterface)(REFIID riid, VOID** ppv)
    {
        if (riid == IID_IUnknown)
            *ppv = static_cast<IUnknown*>(this);
        else if (riid == __uuidof(I))
            *ppv = static_cast<I*>(this);
        else
        {
            *ppv = NULL;
            return E_NOINTERFACE;
        }

        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK;
    }

    // Increment reference count

    STDMETHOD_(ULONG, AddRef)(VOID)
    {
        return InterlockedIncrement(&comRefCount);
    }

    // Decrement reference count

    STDMETHOD_(ULONG, Release)(VOID)
    {
        ULONG count = InterlockedDecrement(&comRefCount);

        if (count == 0)
            delete this;

        return count;
    }

protected:

    LONG comRefCount;

    // Constructor: notice that when an object is first
    // created, its reference count is set to 1.

    IUnknownBase<I>()
    {
        comRefCount = 1;
    }

    // Declare an empty virtual destructor

    virtual ~IUnknownBase<I>() {}
};


//--------------------------------------------------------------------------
// Template for implementing IClassFactory interface
//--------------------------------------------------------------------------

template <class T> class IClassFactoryBase
    : public IUnknownBase<IClassFactory>
{
public:

    // NOTE: We don't count class factory objects in ComComponentCount.
    // This means that the existence of a running class factory is not
    // guaranteed to keep a server loaded in memory.

    // Create a new instance of the component

    STDMETHOD(CreateInstance)(
        IUnknown* outer,
        REFIID riid,
        VOID** ppv
        )
    {
        // We don't support aggregation

        if (outer != NULL)
            return CLASS_E_NOAGGREGATION;

        // Instantiate a new object

        T* obj = new T;

        if (obj == NULL)
            return E_OUTOFMEMORY;

        // Get the requested interface

        HRESULT hr = obj->QueryInterface(riid, ppv);
        obj->Release();

        return hr;
    }

    // Lock/unlock the component server DLL

    STDMETHOD(LockServer)(BOOL lock)
    {
        if (lock)
        {
            IncrementComComponentCount();
        }
        else
        {
            DecrementComComponentCount();
        }

        return S_OK;
    }
};


//--------------------------------------------------------------------------
// Helper function for registering and unregistering a component
//--------------------------------------------------------------------------

struct ComComponentRegData
{
    const CLSID* clsid;
    const WCHAR* compName;
    const WCHAR* progID;
    const WCHAR* progIDNoVer;
    const WCHAR* threading;
};

HRESULT
RegisterComComponent(
    const ComComponentRegData* regdata,
    BOOL registerIt
    );

#endif // !_COMUTILS_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\api\convertfmt.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   Bitmap format conversion
*
* Abstract:
*
*   Convert bitmap data between different pixel formats
*
* Revision History:
*
*   05/13/1999 davidx
*       Created it.
*   09/30/1999 agodfrey
*       Moved the ScanlineConverter to 'EpFormatConverter' in Engine\Render
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Function Description:
*
*   Copy a scanline from an unaligned source buffer to
*   an aligned destination buffer.
*
* Arguments:
*
*   dst - Pointer to the destination buffer
*   src - Pointer to the source buffer
*   totalBits - Total number of bits for the scanline
*   startBit - Number of source bits to skip
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
ReadUnalignedScanline(
    BYTE* dst,
    const BYTE* src,
    UINT totalBits,
    UINT startBit
    )
{
    // Process the whole bytes in the destination
    // NOTE: we probably could be faster doing DWORD reads/writes
    // at the expense of more complicated code. Since this code
    // path is rare, we'll take the simple route.

    UINT bytecnt = totalBits >> 3;
    UINT rem = 8 - startBit;

    while (bytecnt--)
    {
        *dst++ = (src[0] << startBit) | (src[1] >> rem);
        src++;
    }

    // Handle the last partial byte

    if ((totalBits &= 7) != 0)
    {
        BYTE mask = ~(0xff >> totalBits);
        BYTE val = (src[0] << startBit);

        if (totalBits > rem)
            val |= (src[1] >> rem);

        *dst = (*dst & ~mask) | (val & mask);
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Copy a scanline from an aligned source buffer to
*   an unaligned destination buffer.
*
* Arguments:
*
*   dst - Pointer to the destination buffer
*   src - Pointer to the source buffer
*   totalBits - Total number of bits for the scanline
*   startBit - Number of destination bits to skip
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
WriteUnalignedScanline(
    BYTE* dst,
    const BYTE* src,
    UINT totalBits,
    UINT startBit
    )
{
    UINT rem = 8-startBit;
    BYTE mask, val;

    // Special case: startBit+totalBits < 8
    //  i.e. destination fits entirely in a partial byte

    if (totalBits < rem)
    {
        mask = (0xff >> startBit);
        mask ^= (mask >> totalBits);

        *dst = (*dst & ~mask) | ((*src >> startBit) & mask);
        return;
    }

    // Handle the first partial destination byte

    *dst = (*dst & ~(0xff >> startBit)) | (*src >> startBit);
    dst++;
    totalBits -= rem;

    // Handle the whole destination bytes

    UINT bytecnt = totalBits >> 3;

    while (bytecnt--)
    {
        *dst++ = (src[0] << rem) | (src[1] >> startBit);
        src++;
    }

    // Handle the last partial destination byte

    if ((totalBits &= 7) != 0)
    {
        mask = ~(0xff >> totalBits);
        val = src[0] << rem;

        if (totalBits > startBit)
            val |= src[1] >> startBit;

        *dst = (*dst & ~mask) | (val & mask);
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Perform conversion between various pixel data formats
*
* Arguments:
*
*   dstbmp - Specifies the destination bitmap data buffer
*   dstpal - Specifies the destination color palette, if any
*   srcbmp - Specifies the source bitmap data buffer
*   srcpal - Specifies the source color palette, if any
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
ConvertBitmapData(
    const BitmapData* dstbmp,
    const ColorPalette* dstpal,
    const BitmapData* srcbmp,
    const ColorPalette* srcpal
    )
{
    ASSERT(dstbmp->Width == srcbmp->Width &&
           dstbmp->Height == srcbmp->Height);

    // Create a format conversion object

    EpFormatConverter linecvt;
    HRESULT hr;

    hr = linecvt.Initialize(dstbmp, dstpal, srcbmp, srcpal);

    if (SUCCEEDED(hr))
    {
        const BYTE* s = (const BYTE*) srcbmp->Scan0;
        BYTE* d = (BYTE*) dstbmp->Scan0;
        UINT y = dstbmp->Height;

        // Convert one scanline at a time

        while (y--)
        {
            linecvt.Convert(d, s);
            s += srcbmp->Stride;
            d += dstbmp->Stride;
        }
    }

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Perform conversion between various pixel data formats
*   The starting pixel is not on a byte boundary in the source bitmap.
*
* Arguments:
*
*   dstbmp - Specifies the destination bitmap data buffer
*   dstpal - Specifies the destination color palette, if any
*   srcbmp - Specifies the source bitmap data buffer
*   srcpal - Specifies the source color palette, if any
*   startBit - Number of bits to skip
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
ConvertBitmapDataSrcUnaligned(
    const BitmapData* dstbmp,
    const ColorPalette* dstpal,
    const BitmapData* srcbmp,
    const ColorPalette* srcpal,
    UINT startBit
    )
{
    ASSERT(startBit > 0 && startBit <= 7);
    ASSERT(GetPixelFormatSize(srcbmp->PixelFormat) % 8 != 0);

    ASSERT(dstbmp->Width == srcbmp->Width &&
           dstbmp->Height == srcbmp->Height);

    // Create a format converter object

    EpFormatConverter linecvt;
    HRESULT hr;
    UINT totalBits;

    BYTE stackbuf[512];
    GpTempBuffer tempbuf(stackbuf, sizeof(stackbuf));

    totalBits = srcbmp->Width * GetPixelFormatSize(srcbmp->PixelFormat);
    hr = linecvt.Initialize(dstbmp, dstpal, srcbmp, srcpal);

    // Allocate temporary memory to hold byte-aligned source scanline

    if (SUCCEEDED(hr) &&
        !tempbuf.Realloc(STRIDE_ALIGNMENT((totalBits + 7) >> 3)))
    {
        WARNING(("Out of memory"));
        hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        const BYTE* s = (const BYTE*) srcbmp->Scan0;
        BYTE* d = (BYTE*) dstbmp->Scan0;
        BYTE* t = (BYTE*) tempbuf.GetBuffer();
        UINT y = dstbmp->Height;

        // Convert one scanline at a time

        while (y--)
        {
            // Copy source scanline into the byte-aligned buffer

            ReadUnalignedScanline(t, s, totalBits, startBit);
            s += srcbmp->Stride;

            linecvt.Convert(d, t);
            d += dstbmp->Stride;
        }
    }

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Perform conversion between various pixel data formats
*   The starting pixel is not on a byte boundary in the destination bitmap.
*
* Arguments:
*
*   dstbmp - Specifies the destination bitmap data buffer
*   dstpal - Specifies the destination color palette, if any
*   srcbmp - Specifies the source bitmap data buffer
*   srcpal - Specifies the source color palette, if any
*   startBit - Number of bits to skip
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
ConvertBitmapDataDstUnaligned(
    const BitmapData* dstbmp,
    const ColorPalette* dstpal,
    const BitmapData* srcbmp,
    const ColorPalette* srcpal,
    UINT startBit
    )
{
    ASSERT(startBit > 0 && startBit <= 7);
    ASSERT(GetPixelFormatSize(dstbmp->PixelFormat) % 8 != 0);

    ASSERT(dstbmp->Width == srcbmp->Width &&
           dstbmp->Height == srcbmp->Height);

    // Create a format converter object

    EpFormatConverter linecvt;
    HRESULT hr;
    UINT totalBits;

    BYTE stackbuf[512];
    GpTempBuffer tempbuf(stackbuf, sizeof(stackbuf));

    totalBits = dstbmp->Width * GetPixelFormatSize(dstbmp->PixelFormat);
    hr = linecvt.Initialize(dstbmp, dstpal, srcbmp, srcpal);

    // Allocate temporary memory to hold byte-aligned source scanline

    if (SUCCEEDED(hr) &&
        !tempbuf.Realloc(STRIDE_ALIGNMENT((totalBits + 7) >> 3)))
    {
        WARNING(("Out of memory"));
        hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        const BYTE* s = (const BYTE*) srcbmp->Scan0;
        BYTE* d = (BYTE*) dstbmp->Scan0;
        BYTE* t = (BYTE*) tempbuf.GetBuffer();
        UINT y = dstbmp->Height;

        // Convert one scanline at a time

        while (y--)
        {
            linecvt.Convert(t, s);
            s += srcbmp->Stride;

            // Copy the byte-aligned buffer to destination scanline

            WriteUnalignedScanline(d, t, totalBits, startBit);
            d += dstbmp->Stride;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\api\decodedimg.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   decodedimg.cpp
*
* Abstract:
*
*   Implementation of GpDecodedImage class
*
* Revision History:
*
*   05/26/1999 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"


/**************************************************************************\
*
* Function Description:
*
*   Create a GpDecodedImage object from a stream or a file
*
* Arguments:
*
*   stream/filename - Specifies the input data stream or filename
*   image - Returns a pointer to newly created image object
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpDecodedImage::CreateFromStream(
    IStream* stream,
    GpDecodedImage** image
    )
{
    if ( image == NULL )
    {
        return E_INVALIDARG;
    }

    GpDecodedImage* pImage = new GpDecodedImage(stream);

    if ( pImage == NULL )
    {
        return E_OUTOFMEMORY;
    }
    else if ( pImage->IsValid() )
    {
        *image = pImage;

        return S_OK;
    }
    else
    {
        delete pImage;

        return E_FAIL;
    }
}// CreateFromStream()

HRESULT
GpDecodedImage::CreateFromFile(
    const WCHAR* filename,
    GpDecodedImage** image
    )
{
    HRESULT hr;
    IStream* stream;

    hr = CreateStreamOnFileForRead(filename, &stream);

    if (SUCCEEDED(hr))
    {
        hr = CreateFromStream(stream, image);
        stream->Release();
    }

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Construct a GpDecodedImage object from an input stream
*
* Arguments:
*
*   stream - Pointer to the input stream
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

GpDecodedImage::GpDecodedImage(
    IStream* stream
    )
{
    // Hold a reference to the input stream

    inputStream = stream;
    inputStream->AddRef();

    // Initialize other fields to their default values

    decoder = NULL;
    decodeCache = NULL;
    cacheFlags = IMGFLAG_READONLY;
    gotProps = FALSE;
    propset = NULL;

    // Set override resolution to zero (i.e., no override)

    xdpiOverride = 0.0;
    ydpiOverride = 0.0;

    SetValid ( GetImageDecoder() == S_OK );
}


/**************************************************************************\
*
* Function Description:
*
*   GpDecodedImage destructor
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

GpDecodedImage::~GpDecodedImage()
{
    if (decodeCache)
        decodeCache->Release();
    
    if (decoder)
    {   
        decoder->TerminateDecoder();
        decoder->Release();
    }
    
    if (inputStream)
        inputStream->Release();

    if (propset)
        propset->Release();

    SetValid(FALSE);    // so we don't use a deleted object
}


/**************************************************************************\
*
* Function Description:
*
*   Get the device-independent physical dimension of the image
*   in unit of 0.01mm
*
* Arguments:
*
*   size - Buffer for returning physical dimension information
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpDecodedImage::GetPhysicalDimension(
    OUT SIZE* size
    )
{
    // Query basic image info

    ImageInfo imageinfo;
    HRESULT hr;

    hr = InternalGetImageInfo(&imageinfo);

    if (SUCCEEDED(hr))
    {
        size->cx = Pixel2HiMetric(imageinfo.Width, imageinfo.Xdpi);
        size->cy = Pixel2HiMetric(imageinfo.Height, imageinfo.Ydpi);
    }

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Get basic information about the decoded image object
*
* Arguments:
*
*   imageInfo - Buffer for returning basic image info
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpDecodedImage::GetImageInfo(
    OUT ImageInfo* imageInfo
    )
{
    // Query basic image info

    HRESULT hr;

    hr = InternalGetImageInfo(imageInfo);

    if (SUCCEEDED(hr))
    {
        // Merge in our own image cache hints

        GpLock lock(&objectLock);

        if (lock.LockFailed())
            hr = IMGERR_OBJECTBUSY;
        else
            imageInfo->Flags = (imageInfo->Flags & 0xffff) | cacheFlags;
    }

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Set image flags
*
* Arguments:
*
*   flags - New image flags
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpDecodedImage::SetImageFlags(
    IN UINT flags
    )
{
    // Only the top half of the image flag is settable.

    if (flags & 0xffff)
        return E_INVALIDARG;

    // Lock the image object

    GpLock lock(&objectLock);

    if (lock.LockFailed())
        return IMGERR_OBJECTBUSY;

    // If image caching is being turn off
    // then blow away any cache we may current have

    cacheFlags = flags;

    if (!(flags & IMGFLAG_CACHING) && decodeCache)
    {
        decodeCache->Release();
        decodeCache = NULL;
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Display the image in a GDI device context
*
* Arguments:
*
*   hdc - Specifies the destination device context
*   dstRect - Specifies the destination rectangle
*   srcRect - Specifies the source rectangle
*       NULL means the entire image
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpDecodedImage::Draw(
    IN HDC hdc,
    IN const RECT* dstRect,
    IN OPTIONAL const RECT* srcRect
    )
{
    // Lock the current image object

    GpLock lock(&objectLock);

    if (lock.LockFailed())
        return IMGERR_OBJECTBUSY;

    // !!! TODO
    //  Eventually we'll create an IImageSink object
    //  on top of the destination hdc and then ask
    //  decoder to push image data into that sink.
    //  For now, always decode into a memory bitmap.

    HRESULT hr;

    if (decodeCache == NULL)
    {
        // Allocate a new GpMemoryBitmap object

        GpMemoryBitmap* bmp = new GpMemoryBitmap();

        if (bmp == NULL)
            return E_OUTOFMEMORY;

        // Ask the decoder to push data into the memory bitmap

        hr = InternalPushIntoSink(bmp);

        if (SUCCEEDED(hr))
            hr = bmp->QueryInterface(IID_IImage, (VOID**) &decodeCache);

        bmp->Release();

        if (FAILED(hr))
            return hr;
    }

    // Ask the memory bitmap to draw itself

    hr = decodeCache->Draw(hdc, dstRect, srcRect);

    // Blow away the memory bitmap cache if needed

    if ((cacheFlags & IMGFLAG_CACHING) == 0)
    {
        decodeCache->Release();
        decodeCache = NULL;
    }

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Push image data into an IImageSink
*
* Arguments:
*
*   sink - The sink for receiving image data
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpDecodedImage::PushIntoSink(
    IN IImageSink* sink
    )
{
    // Lock the current image object

    GpLock lock(&objectLock);

    if (lock.LockFailed())
        return IMGERR_OBJECTBUSY;

    return InternalPushIntoSink(sink);
}

HRESULT
GpDecodedImage::InternalPushIntoSink(
    IImageSink* sink
    )
{
    // Make sure we have a decoder object

    HRESULT hr = GetImageDecoder();

    if (FAILED(hr))
        return hr;

    // Start decoding

    hr = decoder->BeginDecode(sink, propset);

    if (FAILED(hr))
        return hr;

    // Decode the source image

    while ((hr = decoder->Decode()) == E_PENDING)
        Sleep(0);

    // Stop decoding

    return decoder->EndDecode(hr);
}

/**************************************************************************\
*
* Function Description:
*
*   Ask the decoder if it can do the requested operation (color key output,
*   channel seperation for now)
*
* Arguments:
*
*   Guid    - Guid for request the operation (DECODER_TRANSCOLOR,
*             DECODER_OUTPUTCHANNEL)
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   11/22/1999 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpDecodedImage::QueryDecoderParam(
    IN GUID     Guid
    )
{
    // Make sure we have a decoder object

    HRESULT hResult = GetImageDecoder();

    if ( FAILED(hResult) )
    {
        return hResult;
    }

    // Query decoder capability for the real codec decoder

    hResult = decoder->QueryDecoderParam(Guid);

    return hResult;
}// QueryDecoderParam()

/**************************************************************************\
*
* Function Description:
*
*   Tell the decoder how to output decoded image data (color key output,
*   channel seperation for now)
*
* Arguments:
*
*   Guid    - Guid for request the operation (DECODER_TRANSCOLOR,
*             DECODER_OUTPUTCHANNEL)
*   Length  - Length of the input parameters
*   Value   - Value to set the decode parameter
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   11/22/1999 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpDecodedImage::SetDecoderParam(
    IN GUID     Guid,
    IN UINT     Length,
    IN PVOID    Value
    )
{
    // Make sure we have a decoder object

    HRESULT hResult = GetImageDecoder();

    if ( FAILED(hResult) )
    {
        return hResult;
    }

    // Set decoder parameters for the real codec decoder

    hResult = decoder->SetDecoderParam(Guid, Length, Value);

    return hResult;
}// SetDecoderParam()

HRESULT
GpDecodedImage::GetPropertyCount(
    OUT UINT*   numOfProperty
    )
{
    // Make sure we have a decoder object

    HRESULT hResult = GetImageDecoder();

    if ( FAILED(hResult) )
    {
        return hResult;
    }

    // Get property item count from the real codec decoder

    hResult = decoder->GetPropertyCount(numOfProperty);

    return hResult;
}// GetPropertyItemCount()

HRESULT
GpDecodedImage::GetPropertyIdList(
    IN UINT numOfProperty,
  	IN OUT PROPID* list
    )
{
    // Make sure we have a decoder object

    HRESULT hResult = GetImageDecoder();

    if ( FAILED(hResult) )
    {
        return hResult;
    }

    // Get property item list from the real codec decoder

    hResult = decoder->GetPropertyIdList(numOfProperty, list);

    return hResult;
}// GetPropertyIdList()

HRESULT
GpDecodedImage::GetPropertyItemSize(
    IN PROPID propId,
    OUT UINT* size
    )
{
    // Make sure we have a decoder object

    HRESULT hResult = GetImageDecoder();

    if ( FAILED(hResult) )
    {
        return hResult;
    }

    // Get property item size from the real codec decoder

    hResult = decoder->GetPropertyItemSize(propId, size);

    return hResult;
}// GetPropertyItemSize()

HRESULT
GpDecodedImage::GetPropertyItem(
    IN PROPID               propId,
    IN  UINT                propSize,
    IN OUT PropertyItem*    buffer
    )
{
    // Make sure we have a decoder object

    HRESULT hResult = GetImageDecoder();

    if ( FAILED(hResult) )
    {
        return hResult;
    }

    // Get property item from the real codec decoder

    hResult = decoder->GetPropertyItem(propId, propSize, buffer);

    return hResult;
}// GetPropertyItem()

HRESULT
GpDecodedImage::GetPropertySize(
    OUT UINT* totalBufferSize,
    OUT UINT* numProperties
    )
{
    // Make sure we have a decoder object

    HRESULT hResult = GetImageDecoder();

    if ( FAILED(hResult) )
    {
        return hResult;
    }

    // Get property size from the real codec decoder

    hResult = decoder->GetPropertySize(totalBufferSize, numProperties);

    return hResult;
}// GetPropertySize()

HRESULT
GpDecodedImage::GetAllPropertyItems(
    IN UINT totalBufferSize,
    IN UINT numProperties,
    IN OUT PropertyItem* allItems
    )
{
    // Make sure we have a decoder object

    HRESULT hResult = GetImageDecoder();

    if ( FAILED(hResult) )
    {
        return hResult;
    }

    // Get all property items from the real codec decoder

    hResult = decoder->GetAllPropertyItems(totalBufferSize, numProperties,
                                           allItems);

    return hResult;
}// GetAllPropertyItems()

HRESULT
GpDecodedImage::RemovePropertyItem(
    IN PROPID   propId
    )
{
    // Make sure we have a decoder object

    HRESULT hResult = GetImageDecoder();

    if ( FAILED(hResult) )
    {
        return hResult;
    }

    // Remove this property item from the list

    hResult = decoder->RemovePropertyItem(propId);

    return hResult;
}// RemovePropertyItem()

HRESULT
GpDecodedImage::SetPropertyItem(
    IN PropertyItem item
    )
{
    // Make sure we have a decoder object

    HRESULT hResult = GetImageDecoder();

    if ( FAILED(hResult) )
    {
        return hResult;
    }

    // Set this property item in the list

    hResult = decoder->SetPropertyItem(item);

    return hResult;
}// SetPropertyItem()

/**************************************************************************\
*
* Function Description:
*
*   Ask the decoder for basic image info
*
* Arguments:
*
*   imageinfo - Pointer to buffer for receiving image info
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpDecodedImage::InternalGetImageInfo(
    ImageInfo* imageInfo
    )
{
    // Lock the current image object

    HRESULT hr;
    GpLock lock(&objectLock);

    if (lock.LockFailed())
        hr = IMGERR_OBJECTBUSY;
    else
    {
        // Make sure we have a decoder object

        hr = GetImageDecoder();

        if (SUCCEEDED(hr))
            hr = decoder->GetImageInfo(imageInfo);

        if ((xdpiOverride > 0.0) && (ydpiOverride > 0.0))
        {
            imageInfo->Xdpi = static_cast<double>(xdpiOverride);
            imageInfo->Ydpi = static_cast<double>(ydpiOverride);
        }
    }

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   Ask the decoder for total number of frames in the image
*
* Arguments:
*
*   dimensionID - Dimension ID (PAGE, RESOLUTION, TIME) the caller wants to
*                 get the total number of frame for
*   count       - Total number of frame
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   11/19/1999 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpDecodedImage::GetFrameCount(
    IN const GUID*  dimensionID,
    OUT UINT*       count
    )
{
    // Lock the current image object

    HRESULT hResult;
    GpLock  lock(&objectLock);

    if ( lock.LockFailed() )
    {
        hResult = IMGERR_OBJECTBUSY;
    }
    else
    {
        // Make sure we have a decoder object

        hResult = GetImageDecoder();

        if ( SUCCEEDED(hResult) )
        {
            // Get the frame count from the decoder

            hResult = decoder->GetFrameCount(dimensionID, count);
        }
    }

    return hResult;
}// GetFrameCount()

/**************************************************************************\
*
* Function Description:
*
*     Get the total number of dimensions the image supports
*
* Arguments:
*
*     count -- number of dimensions this image format supports
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpDecodedImage::GetFrameDimensionsCount(
    UINT* count
    )
{
    // Lock the current image object

    HRESULT hResult;
    GpLock  lock(&objectLock);

    if ( lock.LockFailed() )
    {
        hResult = IMGERR_OBJECTBUSY;
    }
    else
    {
        // Make sure we have a decoder object

        hResult = GetImageDecoder();

        if ( SUCCEEDED(hResult) )
        {
            // Get the frame dimension info from the deocder

            hResult = decoder->GetFrameDimensionsCount(count);
        }
    }

    return hResult;
}// GetFrameDimensionsCount()

/**************************************************************************\
*
* Function Description:
*
*     Get an ID list of dimensions the image supports
*
* Arguments:
*
*     dimensionIDs---Memory buffer to hold the result ID list
*     count -- number of dimensions this image format supports
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpDecodedImage::GetFrameDimensionsList(
    GUID*   dimensionIDs,
    UINT    count
    )
{
    // Lock the current image object

    HRESULT hResult;
    GpLock  lock(&objectLock);

    if ( lock.LockFailed() )
    {
        hResult = IMGERR_OBJECTBUSY;
    }
    else
    {
        // Make sure we have a decoder object

        hResult = GetImageDecoder();

        if ( SUCCEEDED(hResult) )
        {
            // Get the frame dimension info from the deocder

            hResult = decoder->GetFrameDimensionsList(dimensionIDs, count);
        }
    }

    return hResult;
}// GetFrameDimensionsList()

/**************************************************************************\
*
* Function Description:
*
*   Select the active frame in the bitmap image
*
* Arguments:
*
*   dimensionID  - Dimension ID (PAGE, RESOLUTION, TIME) of where the caller
*                  wants to set the active frame
*   frameIndex   - Index number of the frame to be selected
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   11/19/1999 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpDecodedImage::SelectActiveFrame(
    IN const GUID*  dimensionID,
    IN UINT         frameIndex
    )
{
    // Lock the current image object

    HRESULT hResult;
    GpLock  lock(&objectLock);

    if ( lock.LockFailed() )
    {
        hResult = IMGERR_OBJECTBUSY;
    }
    else
    {
        // Make sure we have a decoder object

        hResult = GetImageDecoder();

        if ( SUCCEEDED(hResult) )
        {
            // Set the active frame in the decoder

            hResult = decoder->SelectActiveFrame(dimensionID, frameIndex);
        }
    }

    return hResult;
}// SelectActiveFrame()

/**************************************************************************\
*
* Function Description:
*
*   Make sure we have a decoder object associated with the image
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Status code
*
* Note:
*
*   We assume the caller has already locked the current image object.
*
\**************************************************************************/

HRESULT
GpDecodedImage::GetImageDecoder()
{
    ASSERT(inputStream != NULL);

    if (decoder != NULL)
        return S_OK;

    // Create and initialize the decoder object

    return CreateDecoderForStream(inputStream, &decoder, DECODERINIT_NONE);
}


/**************************************************************************\
*
* Function Description:
*
*   Get a thumbnail representation for the image object
*
* Arguments:
*
*   thumbWidth, thumbHeight - Specifies the desired thumbnail size in pixels
*   thumbImage - Return a pointer to the thumbnail image
*       The caller should Release it after using it.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpDecodedImage::GetThumbnail(
    IN OPTIONAL UINT thumbWidth,
    IN OPTIONAL UINT thumbHeight,
    OUT IImage** thumbImage
    )
{
    if (thumbWidth && !thumbHeight ||
        !thumbWidth && thumbHeight)
    {
        return E_INVALIDARG;
    }

    // Ask the decoder for thumbnail image.
    // If one is returned, check if the size matches the requested size.
    //  match: just return the thumbnail returned by the decoder
    //  mismatch: scale the thumbnail returned by the decoder to the desired size

    HRESULT hr;
    IImage* img = NULL;

    {
        GpLock lock(&objectLock);

        if (lock.LockFailed())
            return IMGERR_OBJECTBUSY;

        hr = GetImageDecoder();

        if (FAILED(hr))
            return hr;

        hr = decoder->GetThumbnail(thumbWidth, thumbHeight, &img);

        if (SUCCEEDED(hr))
        {
            ImageInfo imginfo;
            hr = img->GetImageInfo(&imginfo);

            if (SUCCEEDED(hr) &&
                imginfo.Width == thumbWidth || thumbWidth == 0 &&
                imginfo.Height == thumbHeight || thumbHeight == 0)
            {
                *thumbImage = img;
                return S_OK;
            }
        }
        else
            img = NULL;
    }

    if (thumbWidth == 0 && thumbHeight == 0)
        thumbWidth = thumbHeight = DEFAULT_THUMBNAIL_SIZE;

    // Otherwise, generate the thumbnail ourselves using the built-in scaler
    // or scale the thumbnail returned by the decoder to the right size

    GpMemoryBitmap* bmp;

    hr = GpMemoryBitmap::CreateFromImage(
                        img ? img : this,
                        thumbWidth,
                        thumbHeight,
                        PIXFMT_DONTCARE,
                        INTERP_AVERAGING,
                        &bmp);

    if (SUCCEEDED(hr))
    {
        hr = bmp->QueryInterface(IID_IImage, (VOID**) thumbImage);
        bmp->Release();
    }

    if (img)
        img->Release();

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   Set the image resolution.  Overrides the native resolution of the image.
*
* Arguments:
*
*   Xdpi, Ydpi - new resolution
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpDecodedImage::SetResolution(
    IN REAL Xdpi,
    IN REAL Ydpi
    )
{
    HRESULT hr = S_OK;

    if ((Xdpi > 0.0) && (Ydpi > 0.0))
    {
        xdpiOverride = Xdpi;
        ydpiOverride = Ydpi;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   Get the encoder parameter list size from an encoder object specified by
*   input clsid
*
* Arguments:
*
*   clsid - Specifies the encoder class ID
*   size--- The size of the encoder parameter list
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   03/22/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpDecodedImage::GetEncoderParameterListSize(
    IN  CLSID* clsidEncoder,
    OUT UINT* size
    )
{
    return CodecGetEncoderParameterListSize(clsidEncoder, size);    
}// GetEncoderParameterListSize()

/**************************************************************************\
*
* Function Description:
*
*   Get the encoder parameter list from an encoder object specified by
*   input clsid
*
* Arguments:
*
*   clsid --- Specifies the encoder class ID
*   size----- The size of the encoder parameter list
*   pBuffer-- Buffer for storing the list
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   03/22/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpDecodedImage::GetEncoderParameterList(
    IN CLSID* clsidEncoder,
    IN UINT size,
    OUT EncoderParameters* pBuffer
    )
{
    return CodecGetEncoderParameterList(clsidEncoder, size, pBuffer);
}// GetEncoderParameterList()

/**************************************************************************\
*
* Function Description:
*
*   Save the bitmap image to the specified stream.
*
* Arguments:
*
*   stream ------------ Target stream
*   clsidEncoder ------ Specifies the CLSID of the encoder to use
*   encoderParameters - Optional parameters to pass to the encoder before
*                       starting encoding
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   03/22/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpDecodedImage::SaveToStream(
    IN IStream* stream,
    IN CLSID* clsidEncoder,
    IN EncoderParameters* encoderParams,
    OUT IImageEncoder** ppEncoderPtr
    )
{
    if ( ppEncoderPtr == NULL )
    {
        WARNING(("GpDecodedImage::SaveToStream---Invalid input arg"));
        return E_INVALIDARG;
    }

    // Get an image encoder.

    IImageEncoder* pEncoder = NULL;

    HRESULT hResult = CreateEncoderToStream(clsidEncoder, stream, &pEncoder);

    if ( SUCCEEDED(hResult) )
    {
        *ppEncoderPtr = pEncoder;

        // Pass encode parameters to the encoder.
        // MUST do this before getting the sink interface.

        if ( encoderParams != NULL )
        {
            hResult = pEncoder->SetEncoderParameters(encoderParams);
        }

        if ( (hResult == S_OK) || (hResult == E_NOTIMPL) )
        {
            // Note: if the codec doesn't support SetEncoderparameters(), it is
            // still fine to save the image
            
            // Get an image sink from the encoder.

            IImageSink* encodeSink = NULL;

            hResult = pEncoder->GetEncodeSink(&encodeSink);
            if ( SUCCEEDED(hResult) )
            {
                // Push bitmap into the encoder sink.

                hResult = this->PushIntoSink(encodeSink);

                encodeSink->Release();                
            }
        }
    }

    return hResult;
}// SaveToStream()

/**************************************************************************\
*
* Function Description:
*
*   Save the bitmap image to the specified file.
*
* Arguments:
*
*   filename      ----- Target filename
*   clsidEncoder  ----- Specifies the CLSID of the encoder to use
*   encoderParameters - Optional parameters to pass to the encoder before
*                       starting encoding
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   03/06/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpDecodedImage::SaveToFile(
    IN const WCHAR* filename,
    IN CLSID* clsidEncoder,
    IN EncoderParameters* encoderParams,
    OUT IImageEncoder** ppEncoderPtr
    )
{
    IStream* stream;

    HRESULT hResult = CreateStreamOnFileForWrite(filename, &stream);

    if ( SUCCEEDED(hResult) )
    {
        hResult = SaveToStream(stream, clsidEncoder,
                               encoderParams, ppEncoderPtr);
        stream->Release();
    }

    return hResult;
}// SaveToFile()

/**************************************************************************\
*
* Function Description:
*
*   Append the bitmap object to current encoder object
*
* Arguments:
*
*   encoderParameters - Optional parameters to pass to the encoder before
*                       starting encoding
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   04/21/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpDecodedImage::SaveAppend(
    IN const EncoderParameters* encoderParams,
    IN IImageEncoder* destEncoderPtr
    )
{
    // The dest encoder pointer can't be NULL. Otherwise, it is a failure

    if ( destEncoderPtr == NULL )
    {
        WARNING(("GpDecodedImage::SaveAppend---Called without an encoder"));
        return E_FAIL;
    }

    HRESULT hResult = S_OK;
    
    // Pass encode parameters to the encoder.
    // MUST do this before getting the sink interface.

    if ( encoderParams != NULL )
    {
        hResult = destEncoderPtr->SetEncoderParameters(encoderParams);
    }

    if ( (hResult == S_OK) || (hResult == E_NOTIMPL) )
    {
        // Note: if the codec doesn't support SetEncoderparameters(), it is
        // still fine to save the image
            
        // Get an image sink from the encoder.

        IImageSink* encodeSink = NULL;

        hResult = destEncoderPtr->GetEncodeSink(&encodeSink);
        if ( SUCCEEDED(hResult) )
        {
            // Push bitmap into the encoder sink.

            hResult = this->PushIntoSink(encodeSink);

            encodeSink->Release();
        }
    }

    return hResult;
}// SaveAppend()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\api\decodedimg.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   decodedimg.hpp
*
* Abstract:
*
*   GpDecodedImage class declarations
*
* Revision History:
*
*   05/26/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _DECODEDIMG_HPP
#define _DECODEDIMG_HPP

//--------------------------------------------------------------------------
// GpDecodedImage class
//--------------------------------------------------------------------------

class GpDecodedImage : public IUnknownBase<IImage>
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagDecodedImage) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid DecodedImage");
        }
    #endif

        return (Tag == ObjectTagDecodedImage);
    }
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagDecodedImage : ObjectTagInvalid;
    }

public:

    static HRESULT
    CreateFromFile(
        const WCHAR* filename,
        GpDecodedImage** image
        );

    static HRESULT
    CreateFromStream(
        IStream* stream,
        GpDecodedImage** image
        );

    //------------------------------------------------------------
    // Public IImage interface methods
    //------------------------------------------------------------

    // Get the device-independent physical dimension of the image
    //  in unit of 0.01mm

    STDMETHOD(GetPhysicalDimension)(
        OUT SIZE* size
        );

    // Get basic image information

    STDMETHOD(GetImageInfo)(
        OUT ImageInfo* imageInfo
        );

    // Set image flags

    STDMETHOD(SetImageFlags)(
        IN UINT flags
        );

    // Display the image in a GDI device context

    STDMETHOD(Draw)(
        IN HDC hdc,
        IN const RECT* dstRect,
        IN OPTIONAL const RECT* srcRect
        );

    // Push image data into an IImageSink

    STDMETHOD(PushIntoSink)(
        IN IImageSink* sink
        );

    // Get a thumbnail representation for the image object

    STDMETHOD(GetThumbnail)(
        IN OPTIONAL UINT thumbWidth,
        IN OPTIONAL UINT thumbHeight,
        OUT IImage** thumbImage
        );

    STDMETHOD(GetFrameCount)(
        IN const GUID* dimensionID,
        OUT UINT* count
        );

    STDMETHOD(GetFrameDimensionsCount)(
        OUT UINT* count
        );

    STDMETHOD(GetFrameDimensionsList)(
        OUT GUID* dimensionIDs,
        IN OUT UINT count
        );
    
    STDMETHOD(SelectActiveFrame)(
        IN const GUID* dimensionID,
        IN UINT frameIndex
        );

    // Query decoder capability

    STDMETHOD(QueryDecoderParam)(
        IN GUID Guid
        );

    // Set decoder parameter

    STDMETHOD(SetDecoderParam)(
        IN GUID Guid,
        IN UINT Length,
        IN PVOID Value
        );

    STDMETHOD(GetPropertyCount)(
        OUT UINT*   numOfProperty
        );

    STDMETHOD(GetPropertyIdList)(
        IN UINT numOfProperty,
        IN OUT PROPID* list
        );

    STDMETHOD(GetPropertyItemSize)(
        IN PROPID propId, 
        OUT UINT* size
        );
    
    STDMETHOD(GetPropertyItem)(
        IN PROPID            propId,
        IN UINT              propSize,
        IN OUT PropertyItem* buffer
        );

    STDMETHOD(GetPropertySize)(
        OUT UINT* totalBufferSize,
		OUT UINT* numProperties
        );

    STDMETHOD(GetAllPropertyItems)(
        IN UINT totalBufferSize,
        IN UINT numProperties,
        IN OUT PropertyItem* allItems
        );

    STDMETHOD(RemovePropertyItem)(
        IN PROPID   propId
        );

    STDMETHOD(SetPropertyItem)(
        IN PropertyItem item
        );

    // Set override resolution (replaces the native resolution)

    STDMETHOD(SetResolution)(
        IN REAL Xdpi,
        IN REAL Ydpi
        );

    // Save the bitmap object to a stream

    HRESULT
    SaveToStream(
        IN IStream* stream,
        IN CLSID* clsidEncoder,
        IN EncoderParameters* encoderParams,
        OUT IImageEncoder** ppEncoderPtr
        );

    // Save the bitmap object to a file

    HRESULT
    SaveToFile(
        IN const WCHAR* filename,
        IN CLSID* clsidEncoder,
        IN EncoderParameters* encoderParams,
        OUT IImageEncoder** ppEncoderPtr
        );
    
    // Append the bitmap object to current encoder object

    HRESULT
    SaveAppend(
        IN const EncoderParameters* encoderParams,
        IN IImageEncoder* destEncoderPtr
        );

    // Get the encoder parameter list size

    HRESULT
    GetEncoderParameterListSize(
        IN  CLSID* clsidEncoder,
        OUT UINT* size
        );

    // Get the encoder parameter list
    
    HRESULT
    GetEncoderParameterList(
        IN CLSID* clsidEncoder,
        IN UINT size,
        OUT EncoderParameters* pBuffer
        );

    // Return the pointer to the real decoder object to the caller

    HRESULT
    GetDecoderPtr(IImageDecoder **ppDecoder)
    {
        HRESULT hr = E_INVALIDARG;
        if (ppDecoder)
        {
            hr = GetImageDecoder();
            if (SUCCEEDED(hr))
            {
                *ppDecoder = decoder;
            }
        }

        return hr;
    }

private:

    GpLockable objectLock;      // object busy lock
    IImageDecoder* decoder;     // ref to decoder object
    IStream* inputStream;       // ref to input data stream
    IImage* decodeCache;        // ref to decoded image cache
    UINT cacheFlags;            // image hints
    BOOL gotProps;              // already asked decoder for properties?
    IPropertySetStorage* propset; // image properties
    REAL xdpiOverride;          // if non-zero, overrides the native dpi
    REAL ydpiOverride;          // if non-zero, overrides the native dpi

    GpDecodedImage(IStream* stream);
    ~GpDecodedImage();

    HRESULT GetImageDecoder();
    HRESULT InternalGetImageInfo(ImageInfo*);
    HRESULT InternalPushIntoSink(IImageSink*);
};

#endif // !_DECODEDIMG_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\api\filestream.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   filestream.hpp
*
* Abstract:
*
*   Wrap an IStream interface on top of a file
*
* Revision History:
*
*   07/02/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _FILESTREAM_HPP
#define _FILESTREAM_HPP

//
// Multi-thread semantics:
//  FILESTREAM_USEBUSYLOCK - busy lock
//  FILESTREAM_USEWAITLOCK - wait lock
//  FILESTREAM_USENOLOCK - no lock
//

#define FILESTREAM_USEBUSYLOCK

#if defined(FILESTREAM_USEBUSYLOCK)

//
// Busy lock
//

#define DECLARE_FILESTREAMLOCK \
        GpLockable objectLock;

#define ACQUIRE_FILESTREAMLOCK \
        GpLock fsLock(&objectLock); \
        if (fsLock.LockFailed()) \
            return HRESULT_FROM_WIN32(ERROR_BUSY);

#elif defined(FILESTREAM_USEWAITLOCK)

//
// Wait lock
//

class GpFileStreamLockable
{
public:
    GpFileStreamLockable()
    {
        InitializeCriticalSection(&critsect);
    }

    ~GpFileStreamLockable()
    {
        DeleteCriticalSection(&critsect);
    }

private:
    CRITICAL_SECTION critsect;
};

class GpFileStreamLock
{
public:
    GpFileStreamLock(CRITICAL_SECTION* critsect)
    {
        this->critsect = critsect;
        EnterCriticalSection(critsect);
    }

    ~GpFileStreamLock()
    {
        LeaveCriticalSection(critsect);
    }

private:
    CRITICAL_SECTION* critsect;
};

#define DECLARE_FILESTREAMLOCK \
        GpFileStreamLockable objectLock;

#define ACQUIRE_FILESTREAMLOCK \
        GpFileStreamLock fsLock(&objectLock);

#else // FILESTREAM_USENOLOCK

//
// No lock
//

#define DECLARE_FILESTREAMLOCK
#define ACQUIRE_FILESTREAMLOCK

#endif //  // FILESTREAM_USENOLOCK


class GpFileStream : public IUnknownBase<IStream>
{
public:

    GpFileStream()
    {
        fileHandle = INVALID_HANDLE_VALUE;
        filename = NULL;
        accessMode = 0;
    }

    ~GpFileStream()
    {
        if (fileHandle != INVALID_HANDLE_VALUE)
            CloseHandle(fileHandle);
        
        GpFree(filename);
    }

    HRESULT InitFile(const WCHAR* filename, UINT mode);

    STDMETHOD(Read)(
        VOID* buf,
        ULONG cb,
        ULONG* cbRead
        );

    STDMETHOD(Seek)(
        LARGE_INTEGER offset,
        DWORD origin,
        ULARGE_INTEGER* newPos
        );

    STDMETHOD(Stat)(
        STATSTG* statstg,
        DWORD statFlag
        );

    STDMETHOD(Write)(
        const VOID* buf,
        ULONG cb,
        ULONG* cbWritten
        );

    STDMETHOD(CopyTo)(
        IStream* stream,
        ULARGE_INTEGER cb,
        ULARGE_INTEGER* cbRead,
        ULARGE_INTEGER* cbWritten
        );

    STDMETHOD(SetSize)(
        ULARGE_INTEGER newSize
        );

    STDMETHOD(Commit)(
        DWORD commitFlags
        );

    STDMETHOD(Revert)();

    STDMETHOD(LockRegion)(
        ULARGE_INTEGER offset,
        ULARGE_INTEGER cb,
        DWORD lockType
        );

    STDMETHOD(UnlockRegion)(
        ULARGE_INTEGER offset,
        ULARGE_INTEGER cb,
        DWORD lockType
        );

    STDMETHOD(Clone)(
        IStream** stream
        );

private:

    DECLARE_FILESTREAMLOCK

    HANDLE fileHandle;
    WCHAR* filename;
    UINT accessMode;
};

#endif // !_FILESTREAM_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\api\icmdll.hpp ===
/**************************************************************************\
* 
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   icmdll.hpp
*
* Abstract:
*
*   Declaration of support functions for hooking ICM 2.0
*
\**************************************************************************/

HRESULT LoadICMDll();

typedef HPROFILE (WINAPI * OpenColorProfileProc)(
    PPROFILE pProfile,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    DWORD dwCreationMode
);

typedef HPROFILE (WINAPI * OpenColorProfileWProc)(
    PPROFILE pProfile,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    DWORD dwCreationMode
);

typedef BOOL (WINAPI * CloseColorProfileProc) (
    HPROFILE hProfile
);

typedef HTRANSFORM (WINAPI * CreateMultiProfileTransformProc)(
    PHPROFILE pahProfiles,
    DWORD nProfiles,
    PDWORD padwIntent,
    DWORD nIntents,
    DWORD dwFlags,
    DWORD indexPreferredCMM
);

typedef BOOL (WINAPI * DeleteColorTransformProc)(
    HTRANSFORM hColorTransform
);

typedef BOOL (WINAPI * TranslateBitmapBitsProc)(
    HTRANSFORM hColorTransform,
    PVOID pSrcBits,
    BMFORMAT bmInput,
    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwInputStride,
    PVOID pDestBits,
    BMFORMAT bmOutput,
    DWORD dwOutputStride,
    PBMCALLBACKFN pfnCallback,
    ULONG ulCallbackData
);

extern OpenColorProfileProc            pfnOpenColorProfile;
extern OpenColorProfileWProc           pfnOpenColorProfileW;
extern CloseColorProfileProc           pfnCloseColorProfile;
extern CreateMultiProfileTransformProc pfnCreateMultiProfileTransform;
extern DeleteColorTransformProc        pfnDeleteColorTransform;
extern TranslateBitmapBitsProc         pfnTranslateBitmapBits;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\api\filestream.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   filestream.hpp
*
* Abstract:
*
*   Wrap an IStream interface on top of a file
*
* Revision History:
*
*   07/02/1999 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"


/**************************************************************************\
*
* Function Description:
*
*   Initialize a file stream object
*
* Arguments:
*
*   filename - Specifies the name of the file
*   mode - Specifies the desired access mode
*       STGM_READ, STGM_WRITE, or STGM_READWRITE
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpFileStream::InitFile(
    const WCHAR* filename,
    UINT mode
    )
{
    if (mode != STGM_READ &&
        mode != STGM_WRITE &&
        mode != STGM_READWRITE)
    {
        return E_INVALIDARG;
    }

    // Make a copy of the filename string

    this->filename = UnicodeStringDuplicate(filename);

    if (!this->filename)
        return E_OUTOFMEMORY;

    // Open the file for reading and/or writing

    switch (accessMode = mode)
    {
    case STGM_READ:

        // Set access mode to READ
        // Set share mode as READ which means the subsequent open operations on
        //   this file will succeed if and only if it is a READ operation.
        //   (NOTE: we can't put FILE_SHARE_WRITE here to enable the subsequent
        //   write operation on this image. The reason is that we do a memory
        //   mapping below. If we allow the user writes to the same file, it
        //   means that the decoder and encoder will point to the same piece of
        //   data in memory. This will damage the result image if we write some
        //   bits and read from it later.
        // OPEN_EXISTING means to open the file. The function fails if the file
        //   does not exist. 

        fileHandle = _CreateFile(
                        filename,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL);
        break;

    case STGM_WRITE:

        // Set access mode to WRITE
        // Set share mode as READ only, which means the subsequent open
        //   operations on this file will succeed if and only if it is a READ
        //   operation.
        //   (NOTE: with this share mode, we open the specified file here for
        //   writing. The user can also open it later for reading only. But we
        //   don't allow it for writing because in our multi-frame image save
        //   case, we will keep the file open till all the frames are written.
        //   If we allow the FILE_SHARE_WRITE, and the user opens it for writing
        //   while we are in the middle of saving multi-frame image. Bad thing
        //   will happen).
        // OPEN_ALWAYS means to open the file, if it exists. If the file does
        //   not exist, the function creates the file.

        fileHandle = _CreateFile(
                        filename,
                        GENERIC_WRITE,
                        FILE_SHARE_READ,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL);
        if (fileHandle != INVALID_HANDLE_VALUE)

        {
            // Set the "end of file".
            // This is to prevent the following problem:
            // The caller asks us to write to an exisitng file. If the new file
            // size is smaller than the original one, the file size of the final
            // result file will be the same as the old one, that is, leave some
            // garbage at the end of the new file.
            
            SetEndOfFile(fileHandle);
        }

        break;

    case STGM_READWRITE:

        fileHandle = _CreateFile(
                        filename,
                        GENERIC_READ|GENERIC_WRITE,
                        0,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL);
        break;
    }

    if (fileHandle == INVALID_HANDLE_VALUE)
        return GetWin32HRESULT();

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Read data from a file stream
*
* Arguments:
*
*   buf - Points to buffer into which the stream is read
*   cb - Specifies the number of bytes to read
*   *cbRead - Returns the number of bytes actually read
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpFileStream::Read(
    VOID* buf,
    ULONG cb,
    ULONG* cbRead
    )
{
    ACQUIRE_FILESTREAMLOCK

    HRESULT hr;

    hr = ReadFile(fileHandle, buf, cb, &cb, NULL) ?
                S_OK :
                GetWin32HRESULT();

    if (cbRead)
        *cbRead = cb;
    
    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Move the seek pointer in a file stream
*
* Arguments:
*
*   offset - Specifies the amount to move
*   origin - Specifies the origin of the movement
*   newPos - Returns the new seek pointer
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpFileStream::Seek(
    LARGE_INTEGER offset,
    DWORD origin,
    ULARGE_INTEGER* newPos
    )
{
    ACQUIRE_FILESTREAMLOCK

    // Interpret the value of 'origin' parameter

    switch (origin)
    {
    case STREAM_SEEK_SET:
        origin = FILE_BEGIN;
        break;

    case STREAM_SEEK_CUR:
        origin = FILE_CURRENT;
        break;

    case STREAM_SEEK_END:
        origin = FILE_END;
        break;
    
    default:
        return E_INVALIDARG;
    }

    // Set file pointer

    DWORD lowPart;
    LONG highPart = offset.HighPart;

    lowPart = SetFilePointer(fileHandle, offset.LowPart, &highPart, origin);

    if (lowPart == 0xffffffff && GetLastError() != NO_ERROR)
        return GetWin32HRESULT();

    if (newPos)
    {
        newPos->LowPart = lowPart;
        newPos->HighPart = highPart;
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Get information about file stream
*
* Arguments:
*
*   stat - Output buffer for returning file stream information
*   flags - Misc. flag bits
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpFileStream::Stat(
    STATSTG* stat,
    DWORD flags
    )
{
    ACQUIRE_FILESTREAMLOCK

    stat->type = STGTY_STREAM;
    stat->grfMode = accessMode;
    stat->grfStateBits = stat->reserved = 0;

    ZeroMemory(&stat->clsid, sizeof(stat->clsid));

    // !!! TODO
    //  We currently don't support locking operations

    stat->grfLocksSupported = 0;

    // Get file size information

    stat->cbSize.LowPart = GetFileSize(fileHandle, &stat->cbSize.HighPart);

    if (stat->cbSize.LowPart == 0xffffffff &&
        GetLastError() != NO_ERROR)
    {
        return GetWin32HRESULT();
    }

    // Get file time information

    if (!GetFileTime(fileHandle, &stat->ctime, &stat->atime, &stat->mtime))
        return GetWin32HRESULT();

    // Copy filename, if necessary

    if (flags & STATFLAG_NONAME)
        stat->pwcsName = NULL;
    else
    {
        INT cnt = SizeofWSTR(filename);

        stat->pwcsName = (WCHAR*) GpCoAlloc(cnt);

        if (!stat->pwcsName)
            return E_OUTOFMEMORY;
        
        memcpy(stat->pwcsName, filename, cnt);
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Write data into a file stream
*
* Arguments:
*
*   buf - Pointer to buffer of data to be written
*   cb - Specifies the number of bytes to write
*   cbWritten - Returns the number of bytes actually written
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpFileStream::Write(
    const VOID* buf,
    ULONG cb,
    ULONG* cbWritten
    )
{
    ACQUIRE_FILESTREAMLOCK

    HRESULT hr;

    hr = WriteFile(fileHandle, buf, cb, &cb, NULL) ?
                S_OK :
                GetWin32HRESULT();

    if (cbWritten)
        *cbWritten = cb;

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Copy a specified number of bytes from the current
*   file stream to another stream.
*
* Arguments:
*
*   stream - Specifies the destination stream
*   cb - Specifies the number of bytes to copy
*   cbRead - Returns the number of bytes actually read
*   cbWritten - Returns the number of bytes actually written
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpFileStream::CopyTo(
    IStream* stream,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER* cbRead,
    ULARGE_INTEGER* cbWritten
    )
{
    // !!! TODO
    WARNING(("GpFileStream::CopyTo not yet implemented"));

    return E_NOTIMPL;
}


/**************************************************************************\
*
* Function Description:
*
*   Changes the size of the file stream object
*
* Arguments:
*
*   newSize - Specifies the new size of the file stream
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpFileStream::SetSize(
    ULARGE_INTEGER newSize
    )
{
    // !!! TODO
    WARNING(("GpFileStream::SetSize not yet implemented"));

    return E_NOTIMPL;
}


/**************************************************************************\
*
* Function Description:
*
*   Commit changes made to a file stream
*
* Arguments:
*
*   commitFlags - Specifies how changes are commited
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpFileStream::Commit(
    DWORD commitFlags
    )
{
    ACQUIRE_FILESTREAMLOCK

    if (accessMode != STGM_READ &&
        !(commitFlags & STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE) &&
        !FlushFileBuffers(fileHandle))
    {
        return GetWin32HRESULT();
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Discards all changes that have been made to a transacted stream
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpFileStream::Revert()
{
    WARNING(("GpFileStream::Revert not supported"));
    return E_NOTIMPL;
}


/**************************************************************************\
*
* Function Description:
*
*   Restricts access to a specified range of bytes in a file stream
*
* Arguments:
*
*   offset - Specifies the beginning of the byte range
*   cb - Specifies the length of the byte range
*   lockType - Specifies the lock type
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpFileStream::LockRegion(
    ULARGE_INTEGER offset,
    ULARGE_INTEGER cb,
    DWORD lockType
    )
{
    // !!! TODO
    WARNING(("GpFileStream::LockRegion not yet implemented"));

    return E_NOTIMPL;
}


/**************************************************************************\
*
* Function Description:
*
*   Remove the access restrictions on a range of byte
*   previously locked through a LockRegion call
*
* Arguments:
*
*   offset - Specifies the beginning of the byte range
*   cb - Specifies the length of the byte range
*   lockType - Specifies the lock type
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpFileStream::UnlockRegion(
    ULARGE_INTEGER offset,
    ULARGE_INTEGER cb,
    DWORD lockType
    )
{
    // !!! TODO
    WARNING(("GpFileStream::UnlockRegion not yet implemented"));

    return E_NOTIMPL;
}


/**************************************************************************\
*
* Function Description:
*
*   Creates a new stream object with its own seek pointer
*   that references the same bytes as the original stream. 
*
* Arguments:
*
*   stream - Returns the pointer to the cloned stream
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpFileStream::Clone(
    IStream** stream
    )
{
    WARNING(("GpFileStream::Clone not supported"));
    return E_NOTIMPL;
}


/**************************************************************************\
*
* Function Description:
*
*   Create an IStream on top of a file for writing
*
* Arguments:
*
*   filename - Specifies the filename
*   stream - Returns a pointer to the newly created stream object
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
CreateStreamOnFileForWrite(
    const WCHAR* filename,
    IStream** stream
    )
{
    GpFileStream* fs;

    fs = new GpFileStream();

    if (fs == NULL)
        return E_OUTOFMEMORY;
    
    HRESULT hr = fs->InitFile(filename, STGM_WRITE);

    if (FAILED(hr))
        delete fs;
    else
        *stream = static_cast<IStream*>(fs);
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\api\icmdll.cpp ===
/**************************************************************************\
*
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   icmdll.cpp
*
* Abstract:
*
*   Implementation of functions to hook ICM 2.0
*
\**************************************************************************/

#include "precomp.hpp"

#include "..\..\runtime\critsec.hpp"

typedef enum {
    Unitialized = 0,
    Loaded,
    LoadFailed
} IcmDllLoadState;

IcmDllLoadState IcmState = Unitialized;

HMODULE ghInstICMDll = NULL;
        
OpenColorProfileProc pfnOpenColorProfile =
    (OpenColorProfileProc) NULL;

OpenColorProfileWProc pfnOpenColorProfileW =
    (OpenColorProfileWProc) NULL;

CloseColorProfileProc pfnCloseColorProfile =
    (CloseColorProfileProc) NULL;

CreateMultiProfileTransformProc pfnCreateMultiProfileTransform = 
    (CreateMultiProfileTransformProc) NULL;

DeleteColorTransformProc pfnDeleteColorTransform =
    (DeleteColorTransformProc) NULL;

TranslateBitmapBitsProc pfnTranslateBitmapBits =
    (TranslateBitmapBitsProc) NULL;

/**************************************************************************\
*
* Function Description:
*   Loads the ICM dll if it's there
*
\**************************************************************************/

HRESULT LoadICMDll()
{
    HRESULT hr;

    {
        // Protect access to the global variables in this scope:

        LoadLibraryCriticalSection llcs;

        if (IcmState == Loaded)
        {
            hr = S_OK;
        }
        else if (IcmState == LoadFailed)
        {
            hr = E_FAIL;
        }
        else
        {
            // Assume failure; set success if DLL loads and we hook needed
            // functions:

            hr = E_FAIL;
            IcmState = LoadFailed;

            ghInstICMDll = LoadLibraryA("mscms.dll");
            if(ghInstICMDll)
            {
                pfnOpenColorProfile = (OpenColorProfileProc) GetProcAddress(
                    ghInstICMDll, "OpenColorProfileA");

                pfnOpenColorProfileW = (OpenColorProfileWProc) GetProcAddress(
                    ghInstICMDll, "OpenColorProfileW");

                pfnCreateMultiProfileTransform =
                    (CreateMultiProfileTransformProc)GetProcAddress(
                    ghInstICMDll, "CreateMultiProfileTransform");

                pfnTranslateBitmapBits =
                    (TranslateBitmapBitsProc)GetProcAddress(
                    ghInstICMDll, "TranslateBitmapBits");

                pfnCloseColorProfile =
                    (CloseColorProfileProc)GetProcAddress(
                    ghInstICMDll, "CloseColorProfile");

                pfnDeleteColorTransform =
                    (DeleteColorTransformProc)GetProcAddress(
                    ghInstICMDll, "DeleteColorTransform");

                if(pfnOpenColorProfile &&
                   pfnOpenColorProfileW &&
                   pfnCloseColorProfile &&
                   pfnCreateMultiProfileTransform &&
                   pfnDeleteColorTransform &&
                   pfnTranslateBitmapBits)
                {
                    IcmState = Loaded;
                    hr = S_OK;
                }
            }
            else
            {
                WARNING(("Failed to load mscms.dll with code %d", GetLastError()));
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\api\imgguids.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   imgguids.cpp
*
* Abstract:
*
*   GUIDs defined and used by the imaging library
*
* Revision History:
*
*   05/10/1999 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

#include <initguid.h>
#include "imgguids.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\api\imgfactory.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   imgfactory.hpp
*
* Abstract:
*
*   ImagingFactory class declarations
*
* Revision History:
*
*   05/13/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _IMGFACTORY_HPP
#define _IMGFACTORY_HPP

//--------------------------------------------------------------------------
// Imaging library factory class
//--------------------------------------------------------------------------

class GpImagingFactory : public IUnknownBase<IImagingFactory>
{
public:

    //------------------------------------------------------------
    // Public IImagingFactory interface methods
    //------------------------------------------------------------

    // Create an image object from an input stream
    //  stream doesn't have to seekable
    //  caller should Release the stream if call is successful

    STDMETHOD(CreateImageFromStream)(
        IN IStream* stream,
        OUT IImage** image
        );

    // Create an image object from a file

    STDMETHOD(CreateImageFromFile)(
        IN const WCHAR* filename,
        OUT IImage** image
        );

    // Create an image object from a memory buffer

    STDMETHOD(CreateImageFromBuffer)(
        IN const VOID* buf,
        IN UINT size,
        IN BufferDisposalFlag disposalFlag,
        OUT IImage** image
        );
    
    // Create a new bitmap image object

    STDMETHOD(CreateNewBitmap)(
        IN UINT width,
        IN UINT height,
        IN PixelFormatID pixelFormat,
        OUT IBitmapImage** bitmap
        );

    // Create a bitmap image from an IImage object

    STDMETHOD(CreateBitmapFromImage)(
        IN IImage* image,
        IN OPTIONAL UINT width,
        IN OPTIONAL UINT height,
        IN OPTIONAL PixelFormatID pixelFormat,
        IN InterpolationHint hints,
        OUT IBitmapImage** bitmap
        );

    // Create a new bitmap image object on user-supplied memory buffer

    STDMETHOD(CreateBitmapFromBuffer)(
        IN BitmapData* bitmapData,
        OUT IBitmapImage** bitmap
        );

    // Create an image decoder object to process the given input stream

    STDMETHOD(CreateImageDecoder)(
        IN IStream* stream,
        IN DecoderInitFlag flags,
        OUT IImageDecoder** decoder
        );

    // Create an image encoder object that can output data in
    // the specified image file format.

    STDMETHOD(CreateImageEncoderToStream)(
        IN const CLSID* clsid,
        IN IStream* stream,
        OUT IImageEncoder** encoder
        );

    STDMETHOD(CreateImageEncoderToFile)(
        IN const CLSID* clsid,
        IN const WCHAR* filename,
        OUT IImageEncoder** encoder
        );

    // Get a list of all currently installed image decoders

    STDMETHOD(GetInstalledDecoders)(
        OUT UINT* count,
        OUT ImageCodecInfo** decoders
        );

    // Get a list of all currently installed image decoders

    STDMETHOD(GetInstalledEncoders)(
        OUT UINT* count,
        OUT ImageCodecInfo** encoders
        );

    // Install an image encoder / decoder
    //  caller should do the regular COM component
    //  installation before calling this method

    STDMETHOD(InstallImageCodec)(
        IN const ImageCodecInfo* codecInfo
        );

    // Uninstall an image encoder / decoder

    STDMETHOD(UninstallImageCodec)(
        IN const WCHAR* codecName,
        IN UINT flags
        );
};

#endif // !_IMGFACTORY_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\api\imgfactory.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   imgfactory.cpp
*
* Abstract:
*
*   Implementation of GpImagingFactory class
*
* Revision History:
*
*   05/11/1999 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"


/**************************************************************************\
*
* Function Description:
*
*   Create an image object from an input stream
*
* Arguments:
*
*   stream - Specifies the input data stream
*   image - Returns a pointer to an IImage object
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpImagingFactory::CreateImageFromStream(
    IN IStream* stream,
    OUT IImage** image
    )
{
    HRESULT hr;
    GpDecodedImage* img;

    hr = GpDecodedImage::CreateFromStream(stream, &img);

    if (SUCCEEDED(hr))
        *image = img;

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Create an image object from a file
*
* Arguments:
*
*   filename - Specifies the name of the image file
*   image - Returns a pointer to an IImage object
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpImagingFactory::CreateImageFromFile(
    IN const WCHAR* filename,
    OUT IImage** image
    )
{
    HRESULT hr;
    GpDecodedImage* img;

    hr = GpDecodedImage::CreateFromFile(filename, &img);

    if (SUCCEEDED(hr))
        *image = img;

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Create an image object from a memory buffer
*
* Arguments:
*
*   buf - Pointer to the memory buffer
*   size - Size of the buffer, in bytes
*   disposalFlags - How to dispose the buffer after image is released
*   image - Returns a pointer to an IImage object
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpImagingFactory::CreateImageFromBuffer(
    IN const VOID* buf,
    IN UINT size,
    IN BufferDisposalFlag disposalFlag,
    OUT IImage** image
    )
{
    // Validate disposal flag parameter

    UINT allocFlag;

    switch (disposalFlag)
    {
    case DISPOSAL_NONE:
        allocFlag = GpReadOnlyMemoryStream::FLAG_NONE;
        break;

    case DISPOSAL_GLOBALFREE:
        allocFlag = GpReadOnlyMemoryStream::FLAG_GALLOC;
        break;

    case DISPOSAL_COTASKMEMFREE:
        allocFlag = GpReadOnlyMemoryStream::FLAG_COALLOC;
        break;

    case DISPOSAL_UNMAPVIEW:
        allocFlag = GpReadOnlyMemoryStream::FLAG_MAPFILE;
        break;
    
    default:
        return E_INVALIDARG;
    }

    // Create an IStream on top of the memory buffer
    
    GpReadOnlyMemoryStream* stream;

    stream = new GpReadOnlyMemoryStream();

    if (!stream)
        return E_OUTOFMEMORY;

    stream->InitBuffer(buf, size);

    // Create a decoded image object from the stream

    HRESULT hr;
    GpDecodedImage* img;
    
    hr = GpDecodedImage::CreateFromStream(stream, &img);

    if (SUCCEEDED(hr))
    {
        stream->SetAllocFlag(allocFlag);
        hr = img->QueryInterface(IID_IImage, (void **) image);
        img->Release();
    }

    stream->Release();

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Create a new bitmap image object
*
* Arguments:
*
*   width, height - Specifies the new bitmap dimension, in pixels
*   pixelFormat - Specifies the desired pixel data format
*   bitmap - Return a pointer to IBitmapImage interface
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

#define CREATEBITMAP_SNIPPET                        \
        *bitmap = NULL;                             \
        HRESULT hr;                                 \
        GpMemoryBitmap* bm = new GpMemoryBitmap();  \
        if (bm == NULL)                             \
            return E_OUTOFMEMORY;

#define CHECKBITMAP_SNIPPET                         \
        if (FAILED(hr))                             \
            delete bm;                              \
        else                                        \
            *bitmap = bm;                           \
        return hr;

HRESULT
GpImagingFactory::CreateNewBitmap(
    IN UINT width,
    IN UINT height,
    IN PixelFormatID pixelFormat,
    OUT IBitmapImage** bitmap
    )
{
    CREATEBITMAP_SNIPPET

    hr = bm->InitNewBitmap(width, height, pixelFormat);

    CHECKBITMAP_SNIPPET
}


/**************************************************************************\
*
* Function Description:
*
*   Create a bitmap image from an IImage object
*
* Arguments:
*
*   image - Specifies the source image object
*   width, height - Specifies the desired dimension of the bitmap
*       0 means the same dimension as the source image
*   hints - Specifies interpolation hints
*   bitmap - Return a pointer to IBitmapImage interface
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpImagingFactory::CreateBitmapFromImage(
    IN IImage* image,
    IN OPTIONAL UINT width,
    IN OPTIONAL UINT height,
    IN OPTIONAL PixelFormatID pixelFormat,
    IN InterpolationHint hints,
    OUT IBitmapImage** bitmap
    )
{
    HRESULT hr;
    GpMemoryBitmap* bmp;

    hr = GpMemoryBitmap::CreateFromImage(
                image,
                width,
                height,
                pixelFormat,
                hints,
                &bmp);

    if (SUCCEEDED(hr))
        *bitmap = bmp;

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Create a new bitmap image object on user-supplied memory buffer
*
* Arguments:
*
*   bitmapData - Information about user-supplied memory buffer
*   pixelFormat - Specifies the desired pixel data format
*   bitmap - Return a pointer to IBitmapImage interface
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpImagingFactory::CreateBitmapFromBuffer(
    IN BitmapData* bitmapData,
    OUT IBitmapImage** bitmap
    )
{
    CREATEBITMAP_SNIPPET

    hr = bm->InitMemoryBitmap(bitmapData);

    CHECKBITMAP_SNIPPET
}


/**************************************************************************\
*
* Function Description:
*
*   Create an image decoder object to process the specified input stream
*
* Arguments:
*
*   stream - Specifies the input data stream
*   flags - Misc. flags
*   decoder - Return a pointer to an IImageDecoder interface
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpImagingFactory::CreateImageDecoder(
    IN IStream* stream,
    IN DecoderInitFlag flags,
    OUT IImageDecoder** decoder
    )
{
    // Find an approriate decoder object that
    // can handle the given input data stream.
    //
    // NOTE: We assume the returned decoder object
    // has already been initialize with the input stream.

    return CreateDecoderForStream(stream, decoder, flags);
}


/**************************************************************************\
*
* Function Description:
*
*   Create an image encoder object that can output data in
*   the specified image file format.
*
* Arguments:
*
*   clsid - Specifies the encoder object class ID
*   stream - Specifies the output data stream, or
*   filename - Specifies the output filename
*   encoder - Return a pointer to an IImageEncoder interface
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpImagingFactory::CreateImageEncoderToStream(
    IN const CLSID* clsid,
    IN IStream* stream,
    OUT IImageEncoder** encoder
    )
{
    return CreateEncoderToStream(clsid, stream, encoder);
}

HRESULT
GpImagingFactory::CreateImageEncoderToFile(
    IN const CLSID* clsid,
    IN const WCHAR* filename,
    OUT IImageEncoder** encoder
    )
{
    HRESULT hr;
    IStream* stream;

    hr = CreateStreamOnFileForWrite(filename, &stream);

    if (SUCCEEDED(hr))
    {
        hr = CreateImageEncoderToStream(clsid, stream, encoder);
        stream->Release();
    }

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Get a list of all currently installed image decoders
*
* Arguments:
*
*   count - Return the number of installed decoders 
*   decoders - Return a pointer to an array of ImageCodecInfo structures
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpImagingFactory::GetInstalledDecoders(
    OUT UINT* count,
    OUT ImageCodecInfo** decoders
    )
{
    return GetInstalledCodecs(count, decoders, IMGCODEC_DECODER);
}


/**************************************************************************\
*
* Function Description:
*
*   Get a list of all currently installed image encoders
*
* Arguments:
*
*   count - Return the number of installed encoders
*   encoders - Return a pointer to an array of ImageCodecInfo structures
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpImagingFactory::GetInstalledEncoders(
    OUT UINT* count,
    OUT ImageCodecInfo** encoders
    )
{
    return GetInstalledCodecs(count, encoders, IMGCODEC_ENCODER);
}


/**************************************************************************\
*
* Function Description:
*
*   Install an image encoder / decoder
*       caller should do the regular COM component
*       installation before calling this method
*
* Arguments:
*
*   codecInfo - Information about the codec
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpImagingFactory::InstallImageCodec(
    IN const ImageCodecInfo* codecInfo
    )
{
    return InstallCodec(codecInfo);
}

/**************************************************************************\
*
* Function Description:
*
*   Uninstall an image encoder / decoder
*
* Arguments:
*
*   codecName - Specifies the name of the codec to be uninstalled
*   flags - Specifies whether to uninstall system-wide or per-user codec
*       IMGCODEC_SYSTEM or IMGCODEC_USER
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpImagingFactory::UninstallImageCodec(
    IN const WCHAR* codecName,
    IN UINT flags
    )
{
    return UninstallCodec(codecName, flags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\api\imgrsrc.h ===
//
// Strings for built-in BMP codec
//

#define IDS_BMP_CODECNAME       2010
#define IDS_BMP_FORMATDESC      2011
#define IDS_BMP_FILENAMEEXT     2012
#define IDS_BMP_MIMETYPE        2013

#define IDS_JPEG_CODECNAME      2020
#define IDS_JPEG_FORMATDESC     2021
#define IDS_JPEG_FILENAMEEXT    2022
#define IDS_JPEG_MIMETYPE       2023

#define IDS_GIF_CODECNAME       2030
#define IDS_GIF_FORMATDESC      2031
#define IDS_GIF_FILENAMEEXT     2032
#define IDS_GIF_MIMETYPE        2033

#define IDS_EMF_CODECNAME       2040
#define IDS_EMF_FORMATDESC      2041
#define IDS_EMF_FILENAMEEXT     2042
#define IDS_EMF_MIMETYPE        2043

#define IDS_WMF_CODECNAME       2050
#define IDS_WMF_FORMATDESC      2051
#define IDS_WMF_FILENAMEEXT     2052
#define IDS_WMF_MIMETYPE        2053

#define IDS_TIFF_CODECNAME      2060
#define IDS_TIFF_FORMATDESC     2061
#define IDS_TIFF_FILENAMEEXT    2062
#define IDS_TIFF_MIMETYPE       2063

#define IDS_PNG_CODECNAME       2070
#define IDS_PNG_FORMATDESC      2071
#define IDS_PNG_FILENAMEEXT     2072
#define IDS_PNG_MIMETYPE        2073

#define IDS_ICO_CODECNAME       2080
#define IDS_ICO_FORMATDESC      2081
#define IDS_ICO_FILENAMEEXT     2082
#define IDS_ICO_MIMETYPE        2083
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\api\imginit.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   imginit.cpp
*
* Abstract:
*
*   Initialization of imaging libraray
*
* Revision History:
*
*   05/10/1999 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

//
// Global critical section
//

CRITICAL_SECTION ImagingCritSec::critSec;
BOOL             ImagingCritSec::initialized;

//
// Global COM component count
//

LONG ComComponentCount;

BOOL SuppressExternalCodecs;

//
// Initialization
//

BOOL
InitImagingLibrary(BOOL suppressExternalCodecs)
{
    
    // !!! TODO
    //  Since we have our own DLL entrypoint here, the standard
    //  runtime library initialization isn't performed. Specifically,
    //  global static C++ objects are not initialized.
    //  
    //  Manually perform any necessary initialization here.

    SuppressExternalCodecs = suppressExternalCodecs;

    __try
    {
        ImagingCritSec::InitializeCritSec();
        GpMallocTrackingCriticalSection::InitializeCriticalSection();   
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // We couldn't allocate the criticalSection
        // Return an error
        return FALSE;
    }
    return TRUE;
}


//
// Cleanup
//
extern HINSTANCE    g_hInstMsimg32;

VOID
CleanupImagingLibrary()
{
    if ( g_hInstMsimg32 != NULL )
    {
        ImagingCritSec critsec;

        FreeLibrary(g_hInstMsimg32);
        g_hInstMsimg32 = NULL;
    }

    FreeCachedCodecInfo(-1);
    GpMallocTrackingCriticalSection::DeleteCriticalSection();
    ImagingCritSec::DeleteCritSec();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\api\memstream.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   memstream.cpp
*
* Abstract:
*
*   Read-only memory stream implementation
*
* Revision History:
*
*   06/14/1999 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"


/**************************************************************************\
*
* Function Description:
*
*   Read data from a memory stream
*
* Arguments:
*
*   buf - Points to the output buffer for reading data into
*   cb - Number of bytes to read
*   cbRead - Returns the number of bytes actually read
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpReadOnlyMemoryStream::Read(
    VOID* buf,
    ULONG cb,
    ULONG* cbRead
    )
{
    GpLock lock(&objectLock);

    if (lock.LockFailed())
        return IMGERR_OBJECTBUSY;

    HRESULT hr = S_OK;
    UINT n = memsize - curptr;

    if (n > cb)
        n = cb;

    __try
    {
        GpMemcpy(buf, membuf+curptr, n);
        curptr += n;
        if (cbRead) *cbRead = n;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = STG_E_READFAULT;
        if (cbRead) *cbRead = 0;
    }

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Change the current pointer in a memory stream
*
* Arguments:
*
*   offset - Specifies the amount of movement
*   origin - Specifies the origin of movement
*   newPos - Returns the new pointer position after the move
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpReadOnlyMemoryStream::Seek(
    LARGE_INTEGER offset,
    DWORD origin,
    ULARGE_INTEGER* newPos
    )
{
    GpLock lock(&objectLock);

    if (lock.LockFailed())
        return IMGERR_OBJECTBUSY;

    LONGLONG pos;

    switch (origin)
    {
    case STREAM_SEEK_SET:

        pos = offset.QuadPart;
        break;

    case STREAM_SEEK_END:

        pos = memsize;
        break;
    
    case STREAM_SEEK_CUR:

        pos = (LONGLONG) curptr + offset.QuadPart;
        break;

    default:

        pos = -1;
        break;
    }

    if (pos < 0 || pos > memsize)
        return E_INVALIDARG;

    curptr = (DWORD) pos;

    if (newPos)
        newPos->QuadPart = pos;

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Return general information about a memory stream
*
* Arguments:
*
*   statstg - Output buffer
*   statFlag - Misc. flags
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpReadOnlyMemoryStream::Stat(
    STATSTG* statstg,
    DWORD statFlag
    )
{
    if (NULL == statstg)
    {
        return E_INVALIDARG;
    }
    
    GpLock lock(&objectLock);

    if (lock.LockFailed())
        return IMGERR_OBJECTBUSY;

    ZeroMemory(statstg, sizeof(STATSTG));

    statstg->type = STGTY_STREAM;
    statstg->cbSize.QuadPart = memsize;
    statstg->grfMode = STGM_READ;

    if (hfile != INVALID_HANDLE_VALUE &&
        !GetFileTime(hfile, 
                     &statstg->ctime,
                     &statstg->atime,
                     &statstg->mtime))
    {
        return GetWin32HRESULT();
    }

    if (!(statFlag & STATFLAG_NONAME))
    {
        const WCHAR* p = filename ? filename : L"";
        INT count = SizeofWSTR(p);

        #if PROFILE_MEMORY_USAGE
        MC_LogAllocation(count);
        #endif
        
        statstg->pwcsName = (WCHAR*) CoTaskMemAlloc(count);

        if (!statstg->pwcsName)
            return E_OUTOFMEMORY;
        
        GpMemcpy(statstg->pwcsName, p, count);
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Initialize a read-only memory stream by mapping a file
*
* Arguments:
*
*   filename - Specifies the name of the input file
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpReadOnlyMemoryStream::InitFile(
    const WCHAR* filename
    )
{
    // Make a copy of the filename string

    this->filename = UnicodeStringDuplicate(filename);

    if (!this->filename)
        return E_OUTOFMEMORY;

    // Open a handle to the specified file
    // Set access mode to READ
    // Set share mode as READ which means the subsequent open operations on
    //   this file will succeed if and only if it is a READ operation.
    //   (NOTE: we can't put FILE_SHARE_WRITE here to enable the subsequent
    //   write operation on this image. The reason is that we do a memory
    //   mapping below. If we allow the user writes to the same file, it
    //   means that the decoder and encoder will point to the same piece of
    //   data in memory. This will damage the result image if we write some
    //   bits and read from it later.
    // OPEN_EXISTING means to open the file. The function fails if the file
    //   does not exist. 

    hfile = _CreateFile(filename,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL);

    if (hfile == INVALID_HANDLE_VALUE)
        return GetWin32HRESULT();

    // Obtain the file size
    //  NOTE: We don't support files larger than 4GB.

    DWORD sizeLow, sizeHigh;
    sizeLow = GetFileSize(hfile, &sizeHigh);

    if (sizeLow == 0xffffffff || sizeHigh != 0)
        return GetWin32HRESULT();

    // Map the file into memory

    HANDLE filemap;
    VOID* fileview = NULL;

    filemap = CreateFileMappingA(hfile, NULL, PAGE_READONLY, 0, 0, NULL);

    if (filemap)
    {
        fileview = MapViewOfFile(filemap, FILE_MAP_READ, 0, 0, 0);
        CloseHandle(filemap);
    }

    if (!fileview)
        return GetWin32HRESULT();

    InitBuffer(fileview, sizeLow, FLAG_MAPFILE);
    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Create an IStream on top of a file for reading
*
* Arguments:
*
*   filename - Specifies the filename
*   stream - Returns a pointer to the newly created stream object
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
CreateStreamOnFileForRead(
    const WCHAR* filename,
    IStream** stream
    )
{
    // Create a new GpReadOnlyMemoryStream object

    GpReadOnlyMemoryStream* memstrm;

    memstrm = new GpReadOnlyMemoryStream();

    if (!memstrm)
        return E_OUTOFMEMORY;

    // Initialize it with a memory mapped file

    HRESULT hr = memstrm->InitFile(filename);

    if (FAILED(hr))
        delete memstrm;
    else
        *stream = static_cast<IStream*>(memstrm);

    return hr;
}

// GpWriteOnlyMemoryStream

/**************************************************************************\
*
* Function Description:
*
*   Change the current pointer in a memory stream
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpWriteOnlyMemoryStream::Seek(
    LARGE_INTEGER offset,   // Specifies the amount of movement
    DWORD origin,           // Specifies the origin of movement
    ULARGE_INTEGER* newPos  // Returns the new pointer position after the move
    )
{
    GpLock lock(&objectLock);

    if (lock.LockFailed())
    {
        return IMGERR_OBJECTBUSY;
    }

    LONGLONG pos = 0;

    switch (origin)
    {
    case STREAM_SEEK_SET:
        pos = offset.QuadPart;
        break;

    case STREAM_SEEK_END:
        pos = m_uMemSize;
        break;
    
    case STREAM_SEEK_CUR:
        pos = (LONGLONG)m_curPtr + offset.QuadPart;
        break;

    default:
        pos = -1;
        break;
    }

    if ((pos < 0) || (pos > m_uMemSize))
    {
        return E_INVALIDARG;
    }

    m_curPtr = (DWORD)pos;

    if (newPos)
    {
        newPos->QuadPart = pos;
    }

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*   Return general information about a memory stream
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpWriteOnlyMemoryStream::Stat(
    STATSTG* statstg,       // Output buffer
    DWORD statFlag          // Misc. flags
    )
{
    if (NULL == statstg)
    {
        return E_INVALIDARG;
    }

    GpLock lock(&objectLock);

    if (lock.LockFailed())
    {
        return IMGERR_OBJECTBUSY;
    }

    ZeroMemory(statstg, sizeof(STATSTG));

    statstg->type = STGTY_STREAM;
    statstg->cbSize.QuadPart = m_uMemSize;
    statstg->grfMode = STGM_WRITE;              // Write only
    statstg->pwcsName = NULL;                   // No file name

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*   Write data into a file stream
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpWriteOnlyMemoryStream::Write(
    IN const VOID* srcBuf,      // Pointer to buffer of data to be written
    IN ULONG cbNeedToWrite,     // Specifies the number of bytes to write
    OUT ULONG *cbWritten        // Returns the number of bytes actually written
    )
{
    if ((NULL == srcBuf) || (NULL == cbWritten))
    {
        return E_INVALIDARG;
    }

    if (cbNeedToWrite == 0)
    {
        return S_OK;
    }

    GpLock lock(&objectLock);

    if (lock.LockFailed())
    {
        return IMGERR_OBJECTBUSY;
    }
    
    // Check if the unfilled bytes left in our memory buffer can hold the
    // requirement or not

    ASSERT(m_uMemSize >= m_curPtr);

    if ((m_uMemSize - m_curPtr) < cbNeedToWrite)
    {
        // Can't fill the requirement, then double current memory buffer

        UINT uNewSize = (m_uMemSize << 1);

        // Check if this new size can meet the requirement

        ASSERT(uNewSize >= m_curPtr);
        if ((uNewSize - m_curPtr) < cbNeedToWrite)
        {
            // If not, then just allocate whatever the caller asks for
            // That is, the new size will be the caller asks for "cbNeedToWrite"
            // plus all the BYTEs we have written "m_curPtr"

            uNewSize = cbNeedToWrite + m_curPtr;
        }

        BYTE *pbNewBuf = (BYTE*)GpRealloc(m_pMemBuf, uNewSize);

        if (pbNewBuf)
        {
            // Note: GpRealloc() will copy the old contents into "pbNewBuf"
            // before return to us if it succeed

            m_pMemBuf = pbNewBuf;

            // Update memory buffer size.
            // Note: we don't need to update m_curPtr.

            m_uMemSize = uNewSize;
        }
        else
        {
            // Note: if the memory expansion failed, we simply return. So we
            // still have all the old contents. The contents buffer will be
            // freed when the destructor is called.

            WARNING(("GpWriteOnlyMemoryStream::Write---Out of memory"));
            return E_OUTOFMEMORY;
        }        
    }// If the buffer left is too small

    ASSERT((m_uMemSize - m_curPtr) >= cbNeedToWrite);
    
    HRESULT hr = S_OK;

    __try
    {
        GpMemcpy(m_pMemBuf + m_curPtr, srcBuf, cbNeedToWrite);

        // Move the current pointer

        m_curPtr += cbNeedToWrite;
        *cbWritten = cbNeedToWrite;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // Note: we return STG_E_READFAULT, rather than STG_E_WRITEFAULT
        // because we are sure the destination buffer is OK. The reason we get
        // an exception is most likely due to the source. For example, if the
        // source is the result of file mapping across the net. It might not
        // available at this moment when we do the copy

        hr = STG_E_READFAULT;
        *cbWritten = 0;
    }

    return hr;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\api\imgutils.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   imgutils.hpp
*
* Abstract:
*
*   Misc. utility functions and macros
*
* Revision History:
*
*   05/13/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _IMGUTILS_HPP
#define _IMGUTILS_HPP

//--------------------------------------------------------------------------
// Memory allocation/deallocation macros
//--------------------------------------------------------------------------

inline LPVOID
GpCoAlloc(
    SIZE_T cb
    )
{
    #if PROFILE_MEMORY_USAGE
    MC_LogAllocation(cb);
    #endif
    return CoTaskMemAlloc(cb);
}
    
#define GpCoFree        CoTaskMemFree

#define SizeofSTR(s)    (sizeof(CHAR) * (strlen(s) + 1))
#define SizeofWSTR(s)   (sizeof(WCHAR) * (UnicodeStringLength(s) + 1))
#define ALIGN4(x)       (((x) + 3) & ~3)
#define ALIGN16(x)      (((x) + 15) & ~15)


//--------------------------------------------------------------------------
// Helper class for managing temporary memory buffer
// NOTE: This is intended to reduce malloc/free calls.
//--------------------------------------------------------------------------

class GpTempBuffer
{
public:
    GpTempBuffer(VOID* stackbuf, UINT bufsize)
    {
        buffer = stackbuf;
        this->bufsize = bufsize;
        allocFlag = FALSE;
    }

    GpTempBuffer()
    {
        buffer = NULL;
        bufsize = 0;
        allocFlag = FALSE;
    }

    ~GpTempBuffer()
    {
        if (allocFlag)
            GpFree(buffer);
    }

    VOID* GetBuffer()
    {
        return buffer;
    }

    BOOL Realloc(UINT size)
    {
        if (size <= bufsize)
            return TRUE;

        if (allocFlag)
            GpFree(buffer);
        
        allocFlag = TRUE;
        bufsize = size;
        buffer = GpMalloc(size);

        return buffer != NULL;
    }
    
private:
    
    VOID* buffer;
    UINT bufsize;
    BOOL allocFlag;

    // Disable copy constructor and assignment operator

    GpTempBuffer(const GpTempBuffer&);
    GpTempBuffer& operator=(const GpTempBuffer&);
};


//--------------------------------------------------------------------------
// Global critical section (for each process)
//--------------------------------------------------------------------------

class ImagingCritSec
{
public:

    static VOID InitializeCritSec()
    {
        __try
        {
            ::InitializeCriticalSection(&critSec);
        }
        __except(EXCEPTION_CONTINUE_SEARCH)
        {
        }

        initialized = TRUE;
    }

    static VOID DeleteCritSec()
    {
        if (initialized)
        {
            DeleteCriticalSection(&critSec);
            initialized = FALSE;
        }
    }

    ImagingCritSec()
    {
        ASSERT(initialized);
        EnterCriticalSection(&critSec);
    }

    ~ImagingCritSec()
    {
        ASSERT(initialized);
        LeaveCriticalSection(&critSec);
    }

private:
    static CRITICAL_SECTION critSec;
    static BOOL initialized;
};


//--------------------------------------------------------------------------
// Functions for dealing with ARGB color values
//--------------------------------------------------------------------------

// Convert 32bpp PARGB to 32bpp ARGB

ARGB Unpremultiply(ARGB argb);

// Convert 32bpp ARGB to 32bpp PARGB

inline ARGB Premultiply(ARGB argb)
{
    ARGB a = (argb >> ALPHA_SHIFT);

    if (a == 255)
        return argb;
    else if (a == 0)
        return 0;

    ARGB _000000gg = (argb >> 8) & 0x000000ff;
    ARGB _00rr00bb = (argb & 0x00ff00ff);

    ARGB _0000gggg = _000000gg * a + 0x00000080;
    _0000gggg += (_0000gggg >> 8);

    ARGB _rrrrbbbb = _00rr00bb * a + 0x00800080;
    _rrrrbbbb += ((_rrrrbbbb >> 8) & 0x00ff00ff);

    return (a << ALPHA_SHIFT) |
           (_0000gggg & 0x0000ff00) |
           ((_rrrrbbbb >> 8) & 0x00ff00ff);
}

// Fill an ARGB pixel buffer with the specified color value

inline VOID FillMemoryARGB(ARGB* p, UINT count, ARGB c)
{
    while (count--)
        *p++ = c;
}

// Copy an ARGB pixel buffer

inline VOID CopyMemoryARGB(ARGB* d, const ARGB* s, UINT count)
{
    while (count--)
        *d++ = *s++;
}

// Recursively delete a registry key

LONG
RecursiveDeleteRegKey(
    HKEY parentKey,
    const WCHAR* keyname
    );


//--------------------------------------------------------------------------
// Unicode wrappers for win9x
//--------------------------------------------------------------------------

LONG
_RegCreateKey(
    HKEY rootKey,
    const WCHAR* keyname,
    REGSAM samDesired,
    HKEY* hkeyResult
    );

LONG
_RegOpenKey(
    HKEY rootKey,
    const WCHAR* keyname,
    REGSAM samDesired,
    HKEY* hkeyResult
    );

LONG
_RegEnumKey(
    HKEY parentKey,
    DWORD index,
    WCHAR* subkeyStr
    );

LONG
_RegDeleteKey(
    HKEY parentKey,
    const WCHAR* keyname
    );

LONG
_RegSetString(
    HKEY hkey,
    const WCHAR* name,
    const WCHAR* value
    );

LONG
_RegSetDWORD(
    HKEY hkey,
    const WCHAR* name,
    DWORD value
    );

LONG
_RegSetBinary(
    HKEY hkey,
    const WCHAR* name,
    const VOID* value,
    DWORD size
    );

LONG
_RegGetDWORD(
    HKEY hkey,
    const WCHAR* name,
    DWORD* value
    );

LONG
_RegGetBinary(
    HKEY hkey,
    const WCHAR* name,
    VOID* buf,
    DWORD size
    );

LONG
_RegGetString(
    HKEY hkey,
    const WCHAR* name,
    WCHAR* buf,
    DWORD size
    );

BOOL
_GetModuleFileName(
    HINSTANCE moduleHandle,
    WCHAR* moduleName
    );

INT
_LoadString(
    HINSTANCE hInstance,
    UINT strId,
    WCHAR* buf,
    INT size
    );

HBITMAP
_LoadBitmap(
    HINSTANCE hInstance,
    const WCHAR *bitmapName
    );

HANDLE
_CreateFile(
    const WCHAR* filename,
    DWORD accessMode,
    DWORD shareMode,
    DWORD creationFlags,
    DWORD attrs
    );


//--------------------------------------------------------------------------
// Helper class for converting Unicode input strings to ANSI strings
//  NOTE: we only handle strings with length < MAX_PATH.
//--------------------------------------------------------------------------

//--------------------------------------------------------------------------
// IStream helper functions
//--------------------------------------------------------------------------

//Blocking and nonblocking reading from stream w/ error checking
HRESULT ReadFromStream(IN IStream* stream, OUT VOID* buffer, IN INT count, 
    IN BOOL blocking);

//Blocking and nonblocking seeking from stream w/ error checking
HRESULT SeekThroughStream(IN IStream* stream, IN INT count, IN BOOL 
    blocking);

inline BOOL
ReadStreamBytes(
    IStream* stream,
    VOID* buf,
    UINT size
    )
{
    ULONG cbRead;

    return SUCCEEDED(stream->Read(buf, size, &cbRead)) &&
           (size == cbRead);
}

inline BOOL
SeekStreamPos(
    IStream* stream,
    DWORD   dwOrigin,
    UINT pos
    )
{
    LARGE_INTEGER i;

    i.QuadPart = pos;
    return SUCCEEDED(stream->Seek(i, dwOrigin, NULL));
}

HRESULT
CreateStreamOnFileForRead(
    const WCHAR* filename,
    IStream** stream
    );

HRESULT
CreateStreamOnFileForWrite(
    const WCHAR* filename,
    IStream** stream
    );

HRESULT
CreateIPropertySetStorageOnHGlobal(
    IPropertySetStorage** propSet,
    HGLOBAL hmem = NULL
    );

inline HRESULT
GetWin32HRESULT()
{
    DWORD err = GetLastError();
    return err ? HRESULT_FROM_WIN32(err) : E_FAIL;
}


//--------------------------------------------------------------------------
// Print out debug messages using a message box
//--------------------------------------------------------------------------

#if DBG
VOID DbgMessageBox(const CHAR* format, ...);
#endif

//
// Trace function calls
//

#if DBG && defined(ENABLE_TRACE)
#define TRACE(msg) DbgPrint msg
#else
#define TRACE(msg)
#endif

#endif // !_IMGUTILS_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\api\imgutils.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   imgutils.cpp
*
* Abstract:
*
*   Misc. utility functions
*
* Revision History:
*
*   05/13/1999 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"


/**************************************************************************\
*
* Function Description:
*
*   Convert a 32bpp premultiplied ARGB value to
*   a 32bpp non-premultiplied ARGB value
*
* Arguments:
*
*   argb - Premultiplied ARGB value
*
* Return Value:
*
*   Non-premultiplied ARGB value
*
\**************************************************************************/

// Precomputed table for 255/a, 0 < a <= 255
//  in 16.16 fixed point format

static const ARGB UnpremultiplyTable[256] =
{
    0x000000,0xff0000,0x7f8000,0x550000,0x3fc000,0x330000,0x2a8000,0x246db6,
    0x1fe000,0x1c5555,0x198000,0x172e8b,0x154000,0x139d89,0x1236db,0x110000,
    0x0ff000,0x0f0000,0x0e2aaa,0x0d6bca,0x0cc000,0x0c2492,0x0b9745,0x0b1642,
    0x0aa000,0x0a3333,0x09cec4,0x0971c7,0x091b6d,0x08cb08,0x088000,0x0839ce,
    0x07f800,0x07ba2e,0x078000,0x074924,0x071555,0x06e453,0x06b5e5,0x0689d8,
    0x066000,0x063831,0x061249,0x05ee23,0x05cba2,0x05aaaa,0x058b21,0x056cef,
    0x055000,0x05343e,0x051999,0x050000,0x04e762,0x04cfb2,0x04b8e3,0x04a2e8,
    0x048db6,0x047943,0x046584,0x045270,0x044000,0x042e29,0x041ce7,0x040c30,
    0x03fc00,0x03ec4e,0x03dd17,0x03ce54,0x03c000,0x03b216,0x03a492,0x03976f,
    0x038aaa,0x037e3f,0x037229,0x036666,0x035af2,0x034fca,0x0344ec,0x033a54,
    0x033000,0x0325ed,0x031c18,0x031281,0x030924,0x030000,0x02f711,0x02ee58,
    0x02e5d1,0x02dd7b,0x02d555,0x02cd5c,0x02c590,0x02bdef,0x02b677,0x02af28,
    0x02a800,0x02a0fd,0x029a1f,0x029364,0x028ccc,0x028656,0x028000,0x0279c9,
    0x0273b1,0x026db6,0x0267d9,0x026217,0x025c71,0x0256e6,0x025174,0x024c1b,
    0x0246db,0x0241b2,0x023ca1,0x0237a6,0x0232c2,0x022df2,0x022938,0x022492,
    0x022000,0x021b81,0x021714,0x0212bb,0x020e73,0x020a3d,0x020618,0x020204,
    0x01fe00,0x01fa0b,0x01f627,0x01f252,0x01ee8b,0x01ead3,0x01e72a,0x01e38e,
    0x01e000,0x01dc7f,0x01d90b,0x01d5a3,0x01d249,0x01cefa,0x01cbb7,0x01c880,
    0x01c555,0x01c234,0x01bf1f,0x01bc14,0x01b914,0x01b61e,0x01b333,0x01b051,
    0x01ad79,0x01aaaa,0x01a7e5,0x01a529,0x01a276,0x019fcb,0x019d2a,0x019a90,
    0x019800,0x019577,0x0192f6,0x01907d,0x018e0c,0x018ba2,0x018940,0x0186e5,
    0x018492,0x018245,0x018000,0x017dc1,0x017b88,0x017957,0x01772c,0x017507,
    0x0172e8,0x0170d0,0x016ebd,0x016cb1,0x016aaa,0x0168a9,0x0166ae,0x0164b8,
    0x0162c8,0x0160dd,0x015ef7,0x015d17,0x015b3b,0x015965,0x015794,0x0155c7,
    0x015400,0x01523d,0x01507e,0x014ec4,0x014d0f,0x014b5e,0x0149b2,0x01480a,
    0x014666,0x0144c6,0x01432b,0x014193,0x014000,0x013e70,0x013ce4,0x013b5c,
    0x0139d8,0x013858,0x0136db,0x013562,0x0133ec,0x01327a,0x01310b,0x012fa0,
    0x012e38,0x012cd4,0x012b73,0x012a15,0x0128ba,0x012762,0x01260d,0x0124bc,
    0x01236d,0x012222,0x0120d9,0x011f93,0x011e50,0x011d10,0x011bd3,0x011a98,
    0x011961,0x01182b,0x0116f9,0x0115c9,0x01149c,0x011371,0x011249,0x011123,
    0x011000,0x010edf,0x010dc0,0x010ca4,0x010b8a,0x010a72,0x01095d,0x01084a,
    0x010739,0x01062b,0x01051e,0x010414,0x01030c,0x010206,0x010102,0x010000,
};

ARGB
Unpremultiply(
    ARGB argb
    )
{
    // Get alpha value

    ARGB a = argb >> ALPHA_SHIFT;

    // Special case: fully transparent or fully opaque

    if (a == 0 || a == 255)
        return argb;

    ARGB f = UnpremultiplyTable[a];

    ARGB r = ((argb >>   RED_SHIFT) & 0xff) * f >> 16;
    ARGB g = ((argb >> GREEN_SHIFT) & 0xff) * f >> 16;
    ARGB b = ((argb >>  BLUE_SHIFT) & 0xff) * f >> 16;

    return (a << ALPHA_SHIFT) |
           ((r > 255 ? 255 : r) << RED_SHIFT) |
           ((g > 255 ? 255 : g) << GREEN_SHIFT) |
           ((b > 255 ? 255 : b) << BLUE_SHIFT);
}


/**************************************************************************\
*
* Function Description:
*
*   Create a new registry key and set its default value
*
* Arguments:
*
*   parentKey - Handle to the parent registry key
*   keyname - Specifies the name of the subkey
*   value - Default value for the subkey
*   retkey - Buffer for returning a handle to the opened subkey
*       NULL if the caller is not interested in such
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

LONG
SetRegKeyValue(
    HKEY parentKey,
    const WCHAR* keyname,
    const WCHAR* value,
    HKEY* retkey
    )
{
    HKEY hkey;
    LONG status;

    // Create or open the specified registry key

    status = _RegCreateKey(parentKey, keyname, KEY_ALL_ACCESS, &hkey);
                
    if (status != ERROR_SUCCESS)
        return status;

    // Set the default value for the new key

    status = _RegSetString(hkey, NULL, value);

    // Check if the caller is interested in the handle to the new key

    if (status == ERROR_SUCCESS && retkey)
        *retkey = hkey;
    else
        RegCloseKey(hkey);

    return status;
}


/**************************************************************************\
*
* Function Description:
*
*   Delete a registry key and everything below it.
*
* Arguments:
*
*   parentKey - Handle to the parent registry key
*   keyname - Specifies the name of the subkey to be deleted
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

LONG
RecursiveDeleteRegKey(
    HKEY parentKey,
    const WCHAR* keyname
    )
{
    HKEY hkey;
    LONG status;

    // Open the specified registry key

    status = _RegOpenKey(parentKey, keyname, KEY_ALL_ACCESS, &hkey);
                 
    if (status != ERROR_SUCCESS)
        return status;

    // Enumerate all subkeys

    WCHAR subkeyStr[MAX_PATH];
    
    do
    {
        status = _RegEnumKey(hkey, 0, subkeyStr);
                        
        // Recursively delete subkeys

        if (status == ERROR_SUCCESS)
            status = RecursiveDeleteRegKey(hkey, subkeyStr);
    }
    while (status == ERROR_SUCCESS);

    // Close the specified key and then delete it

    RegCloseKey(hkey);
    return _RegDeleteKey(parentKey, keyname);
}


/**************************************************************************\
*
* Function Description:
*
*   Register / unregister a COM component
*
* Arguments:
*
*   regdata - Component registration data
*   registerIt - Whether to register or unregister the component
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
RegisterComComponent(
    const ComComponentRegData* regdata,
    BOOL registerIt
    )
{
    static const WCHAR CLSID_KEYSTR[] = L"CLSID";
    static const WCHAR INPROCSERVER32_KEYSTR[] = L"InProcServer32";
    static const WCHAR THREADING_VALSTR[] = L"ThreadingModel";
    static const WCHAR PROGID_KEYSTR[] = L"ProgID";
    static const WCHAR PROGIDNOVER_KEYSTR[] = L"VersionIndependentProgID";
    static const WCHAR CURVER_KEYSTR[] = L"CurVer";

    // compose class ID string

    WCHAR clsidStr[64];
    StringFromGUID2(*regdata->clsid, clsidStr, 64);

    // open registry key HKEY_CLASSES_ROOT\CLSID

    LONG status;
    HKEY clsidKey;

    status = _RegOpenKey(
                HKEY_CLASSES_ROOT,
                CLSID_KEYSTR,
                KEY_ALL_ACCESS,
                &clsidKey);
                
    if (status != ERROR_SUCCESS)
        return HRESULT_FROM_WIN32(status);

    if (registerIt)
    {
        // Register the component

        HKEY hkey;
        WCHAR fullpath[MAX_PATH];

        // HKEY_CLASSES_ROOT
        //  <Version-independent ProgID> - component friendly name
        //      CLSID - current version class ID
        //      CurVer - current version ProgID

        if (!_GetModuleFileName(DllInstance, fullpath))
        {
            status = GetLastError();
            goto regcompExit;
        }

        status = SetRegKeyValue(
                    HKEY_CLASSES_ROOT,
                    regdata->progIDNoVer,
                    regdata->compName,
                    &hkey);

        if (status != ERROR_SUCCESS)
            goto regcompExit;

        status = SetRegKeyValue(hkey, CLSID_KEYSTR, clsidStr, NULL);

        if (status == ERROR_SUCCESS)
            status = SetRegKeyValue(hkey, CURVER_KEYSTR, regdata->progID, NULL);

        RegCloseKey(hkey);

        if (status != ERROR_SUCCESS)
            goto regcompExit;

        // HKEY_CLASSES_ROOT
        //  <ProgID> - friendly component name
        //      CLSID - class ID

        status = SetRegKeyValue(
                    HKEY_CLASSES_ROOT,
                    regdata->progID,
                    regdata->compName,
                    &hkey);

        if (status == ERROR_SUCCESS)
        {
            status = SetRegKeyValue(hkey, CLSID_KEYSTR, clsidStr, NULL);
            RegCloseKey(hkey);
        }

        if (status != ERROR_SUCCESS)
            goto regcompExit;

        // HKEY_CLASSES_ROOT
        //  CLSID
        //      <class ID> - friendly component name
        //          InProcServer32 - full pathname to component DLL
        //              Threading : REG_SZ : threading model
        //          ProgID - current version ProgID
        //          VersionIndependentProgID - ...

        status = SetRegKeyValue(clsidKey, clsidStr, regdata->compName, &hkey);

        if (status != ERROR_SUCCESS)
            goto regcompExit;

        HKEY inprocKey;
        status = SetRegKeyValue(hkey, INPROCSERVER32_KEYSTR, fullpath, &inprocKey);

        if (status == ERROR_SUCCESS)
        {
            status = _RegSetString(inprocKey, THREADING_VALSTR, regdata->threading);
            RegCloseKey(inprocKey);
        }

        if (status == ERROR_SUCCESS)
            status = SetRegKeyValue(hkey, PROGID_KEYSTR, regdata->progID, NULL);

        if (status == ERROR_SUCCESS)
            status = SetRegKeyValue(hkey, PROGIDNOVER_KEYSTR, regdata->progIDNoVer, NULL);

        RegCloseKey(hkey);
    }
    else
    {
        // Unregister the component

        status = RecursiveDeleteRegKey(clsidKey, clsidStr);

        if (status == ERROR_SUCCESS)
            status = RecursiveDeleteRegKey(HKEY_CLASSES_ROOT, regdata->progIDNoVer);

        if (status == ERROR_SUCCESS)
            status = RecursiveDeleteRegKey(HKEY_CLASSES_ROOT, regdata->progID);
    }

regcompExit:

    RegCloseKey(clsidKey);

    if (status == ERROR_SUCCESS)
        return S_OK;
    else
    {
        WARNING(("RegisterComComponent (%d) failed: 0x%08x", registerIt, status));
        return HRESULT_FROM_WIN32(status);
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Create/open a registry key
*
* Arguments:
*
*   rootKey - Specifies the root registry key
*   keyname - Relative path to the new registry key to be created
*   samDesired - Desired access mode
*   hkeyResult - Returns a handle to the new key
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

LONG
_RegCreateKey(
    HKEY rootKey,
    const WCHAR* keyname,
    REGSAM samDesired,
    HKEY* hkeyResult
    )
{
    DWORD disposition;

    // Windows NT - Unicode

    if (OSInfo::IsNT)
    {
        return RegCreateKeyExW(
                    rootKey,
                    keyname,
                    0,
                    NULL,
                    0,
                    samDesired,
                    NULL,
                    hkeyResult,
                    &disposition);
    }

    // Windows 9x - non-Unicode

    AnsiStrFromUnicode subkeyStr(keyname);

    if (subkeyStr.IsValid())
    {
        return RegCreateKeyExA(
                    rootKey,
                    subkeyStr,
                    0,
                    NULL,
                    0,
                    samDesired,
                    NULL,
                    hkeyResult,
                    &disposition);
    }
    else
        return ERROR_INVALID_DATA;
}


/**************************************************************************\
*
* Function Description:
*
*   Open a registry key
*
* Arguments:
*
*   rootKey - Specifies the root registry key
*   keyname - Relative path to the new registry key to be opened
*   samDesired - Desired access mode
*   hkeyResult - Returns a handle to the opened key
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

LONG
_RegOpenKey(
    HKEY rootKey,
    const WCHAR* keyname,
    REGSAM samDesired,
    HKEY* hkeyResult
    )
{
    // Windows NT - Unicode

    if (OSInfo::IsNT)
    {
        return RegOpenKeyExW(
                    rootKey,
                    keyname,
                    0,
                    samDesired,
                    hkeyResult);
    }

    // Windows 9x - non-Unicode

    AnsiStrFromUnicode subkeyStr(keyname);
    
    if (subkeyStr.IsValid())
    {
        return RegOpenKeyExA(
                    rootKey,
                    subkeyStr,
                    0, 
                    samDesired,
                    hkeyResult);
    }
    else
        return ERROR_INVALID_DATA;
}


/**************************************************************************\
*
* Function Description:
*
*   Enumerate the subkeys under the specified registry key
*
* Arguments:
*
*   parentKey - Handle to the parent registry key
*   index - Enumeration index
*   subkeyStr - Buffer for holding the subkey name
*       must be able to hold at least MAX_PATH characters
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

LONG
_RegEnumKey(
    HKEY parentKey,
    DWORD index,
    WCHAR* subkeyStr
    )
{
    // Windows NT - Unicode

    FILETIME filetime;
    DWORD subkeyLen = MAX_PATH;

    if (OSInfo::IsNT)
    {
        return RegEnumKeyExW(
                    parentKey,
                    index,
                    subkeyStr,
                    &subkeyLen,
                    NULL,
                    NULL,
                    NULL,
                    &filetime);
    }

    // Windows 9x - non-Unicode

    CHAR ansibuf[MAX_PATH];
    LONG status;

    status = RegEnumKeyExA(
                    parentKey,
                    index,
                    ansibuf,
                    &subkeyLen,
                    NULL,
                    NULL,
                    NULL,
                    &filetime);

    return (status != ERROR_SUCCESS) ? status :
           AnsiToUnicodeStr(ansibuf, subkeyStr, MAX_PATH) ?
                ERROR_SUCCESS :
                ERROR_INVALID_DATA;
}


/**************************************************************************\
*
* Function Description:
*
*   Delete the specified registry key
*
* Arguments:
*
*   parentKey - Handle to the parent registry key
*   keyname - Name of the subkey to be deleted
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

LONG
_RegDeleteKey(
    HKEY parentKey,
    const WCHAR* keyname
    )
{
    // Windows NT - Unicode

    if (OSInfo::IsNT)
        return RegDeleteKeyW(parentKey, keyname);

    // Windows 9x - non-Unicode

    AnsiStrFromUnicode subkeyStr(keyname);

    return subkeyStr.IsValid() ?
                RegDeleteKeyA(parentKey, subkeyStr) :
                ERROR_INVALID_DATA;
}


/**************************************************************************\
*
* Function Description:
*
*   Write string value into the registry
*
* Arguments:
*
*   hkey - Specifies the registry key under which the value is written
*   name - Specifies the name of the value
*   value - Specifies the string value to be written
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

LONG
_RegSetString(
    HKEY hkey,
    const WCHAR* name,
    const WCHAR* value
    )
{
    // Windows NT - Unicode

    if (OSInfo::IsNT)
    {
        return RegSetValueExW(
                    hkey,
                    name,
                    0,
                    REG_SZ,
                    (const BYTE*) value,
                    SizeofWSTR(value));
    }

    // Windows 9x - non-Unicode

    AnsiStrFromUnicode nameStr(name);
    AnsiStrFromUnicode valueStr(value);
    const CHAR* ansival;

    if (!nameStr.IsValid() || !valueStr.IsValid())
        return ERROR_INVALID_DATA;

    ansival = valueStr;

    return RegSetValueExA(
                hkey,
                nameStr,
                0,
                REG_SZ,
                (const BYTE*) ansival,
                SizeofSTR(ansival));
}


/**************************************************************************\
*
* Function Description:
*
*   Write DWORD value into the registry
*
* Arguments:
*
*   hkey - Specifies the registry key under which the value is written
*   name - Specifies the name of the value
*   value - Specifies the DWORD value to be written
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

LONG
_RegSetDWORD(
    HKEY hkey,
    const WCHAR* name,
    DWORD value
    )
{
    // Windows NT - Unicode

    if (OSInfo::IsNT)
    {
        return RegSetValueExW(
                    hkey,
                    name,
                    0,
                    REG_DWORD,
                    (const BYTE*) &value,
                    sizeof(value));
    }

    // Windows 9x - non-Unicode

    AnsiStrFromUnicode nameStr(name);

    if (nameStr.IsValid())
    {
        return RegSetValueExA(
                    hkey,
                    nameStr,
                    0,
                    REG_DWORD,
                    (const BYTE*) &value,
                    sizeof(value));
    }
    else
        return ERROR_INVALID_DATA;
}


/**************************************************************************\
*
* Function Description:
*
*   Write binary value into the registry
*
* Arguments:
*
*   hkey - Specifies the registry key under which the value is written
*   name - Specifies the name of the value
*   value - Specifies the binary value to be written
*   size - Size of the binary value, in bytes
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

LONG
_RegSetBinary(
    HKEY hkey,
    const WCHAR* name,
    const VOID* value,
    DWORD size
    )
{
    // Windows NT - Unicode

    if (OSInfo::IsNT)
    {
        return RegSetValueExW(
                    hkey,
                    name,
                    0,
                    REG_BINARY,
                    (const BYTE*) value,
                    size);
    }

    // Windows 9x - non-Unicode

    AnsiStrFromUnicode nameStr(name);

    if (nameStr.IsValid())
    {
        return RegSetValueExA(
                    hkey,
                    nameStr,
                    0,
                    REG_BINARY,
                    (const BYTE*) value,
                    size);
    }
    else
        return ERROR_INVALID_DATA;
}


/**************************************************************************\
*
* Function Description:
*
*   Read DWORD value out of the registry
*
* Arguments:
*
*   hkey - The registry under which to read the value from
*   name - Name of the value to be read
*   value - Returns the DWORD value read
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

LONG
_RegGetDWORD(
    HKEY hkey,
    const WCHAR* name,
    DWORD* value
    )
{
    // Windows NT - Unicode

    LONG status;
    DWORD regtype;
    DWORD regsize = sizeof(DWORD);

    if (OSInfo::IsNT)
    {
        status = RegQueryValueExW(
                    hkey,
                    name,
                    NULL,
                    &regtype,
                    (BYTE*) value,
                    &regsize);
    }
    else
    {
        // Windows 9x - non-Unicode

        AnsiStrFromUnicode nameStr(name);

        if (!nameStr.IsValid())
            return ERROR_INVALID_DATA;

        status = RegQueryValueExA(
                    hkey,
                    nameStr,
                    NULL,
                    &regtype,
                    (BYTE*) value,
                    &regsize);
    }

    return (status != ERROR_SUCCESS) ? status :
           (regtype != REG_DWORD || regsize != sizeof(DWORD)) ?
                ERROR_INVALID_DATA :
                ERROR_SUCCESS;
}


/**************************************************************************\
*
* Function Description:
*
*   Read binary value out of the registry
*
* Arguments:
*
*   hkey - The registry under which to read the value from
*   name - Name of the value to be read
*   buf - Output buffer
*   size - Size of the output buffer, in bytes
*
* Return Value:
*
*   Status code
*
* Notes:
*
*   The size of the value read out of the registry must be exactly
*   the same as the specified output buffer size.
*
\**************************************************************************/

LONG
_RegGetBinary(
    HKEY hkey,
    const WCHAR* name,
    VOID* buf,
    DWORD size
    )
{
    // Windows NT - Unicode

    LONG status;
    DWORD regtype;
    DWORD regsize = size;

    if (OSInfo::IsNT)
    {
        status = RegQueryValueExW(
                    hkey,
                    name,
                    NULL,
                    &regtype,
                    (BYTE*) buf,
                    &regsize);
    }
    else
    {
        // Windows 9x - non-Unicode

        AnsiStrFromUnicode nameStr(name);

        if (!nameStr.IsValid())
            return ERROR_INVALID_DATA;

        status = RegQueryValueExA(
                    hkey,
                    nameStr,
                    NULL,
                    &regtype,
                    (BYTE*) buf,
                    &regsize);
    }

    return (status != ERROR_SUCCESS) ? status :
           (regtype != REG_BINARY || regsize != size) ?
                ERROR_INVALID_DATA :
                ERROR_SUCCESS;
}


/**************************************************************************\
*
* Function Description:
*
*   Read string value out of the registry
*
* Arguments:
*
*   hkey - The registry under which to read the value from
*   name - Name of the value to be read
*   buf - Output buffer
*   size - Size of the output buffer, in bytes
*
* Return Value:
*
*   Status code
*
* Notes:
*
*   The longest string we can handle here is MAX_PATH-1.
*
\**************************************************************************/

LONG
_RegGetString(
    HKEY hkey,
    const WCHAR* name,
    WCHAR* buf,
    DWORD size
    )
{
    // Windows NT - Unicode

    LONG status;
    DWORD regtype;
    DWORD regsize;

    if (OSInfo::IsNT)
    {
        regsize = size;

        status = RegQueryValueExW(
                    hkey,
                    name,
                    NULL,
                    &regtype,
                    (BYTE*) buf,
                    &regsize);
        
        return (status == ERROR_SUCCESS && regtype != REG_SZ) ?
                    ERROR_INVALID_DATA :
                    status;
    }

    // Windows 9x - non-Unicode

    CHAR ansibuf[MAX_PATH];
    AnsiStrFromUnicode nameStr(name);

    if (!nameStr.IsValid())
        return ERROR_INVALID_DATA;

    size /= 2;
    regsize = MAX_PATH;

    status = RegQueryValueExA(
                hkey,
                nameStr,
                NULL,
                &regtype,
                (BYTE*) ansibuf,
                &regsize);

    return (status != ERROR_SUCCESS) ? status :
           (regtype != REG_SZ) ? ERROR_INVALID_DATA :
           AnsiToUnicodeStr(ansibuf, buf, size) ?
                ERROR_SUCCESS :
                ERROR_INVALID_DATA;
}


/**************************************************************************\
*
* Function Description:
*
*   Get the full path name of the specified module
*
* Arguments:
*
*   moduleHandle - Module handle
*   moduleName - Buffer for holding the module filename
*       must be able to hold at least MAX_PATH characters
*
* Return Value:
*
*   TRUE if successful, FALSE if there is an error
*
\**************************************************************************/

BOOL
_GetModuleFileName(
    HINSTANCE moduleHandle,
    WCHAR* moduleName
    )
{
    // Windows NT - Unicode

    if (OSInfo::IsNT)
        return GetModuleFileNameW(moduleHandle, moduleName, MAX_PATH);

    // Windows 9x - non-Unicode

    CHAR ansibuf[MAX_PATH];

    return GetModuleFileNameA(moduleHandle, ansibuf, MAX_PATH) ?
                AnsiToUnicodeStr(ansibuf, moduleName, MAX_PATH) :
                FALSE;
}


/**************************************************************************\
*
* Function Description:
*
*   Load string resource
*
* Arguments:
*
*   hInstance - handle of module containing string resource 
*   strId - string resource identifier
*   buf - string output buffer
*   size - size of output buffer, in characters
*
* Return Value:
*
*   Length of the loaded string (excluding null terminator)
*   0 if there is an error
*
\**************************************************************************/

INT
_LoadString(
    HINSTANCE hInstance,
    UINT strId,
    WCHAR* buf,
    INT size
    )
{
    // Windows NT - Unicode

    if (OSInfo::IsNT)
        return LoadStringW(hInstance, strId, buf, size);

    // Windows 9x - non-Unicode

    CHAR ansibuf[MAX_PATH];
    INT n;

    // NOTE: we only support string length < MAX_PATH

    if (size > MAX_PATH)
        return 0;

    n = LoadStringA(hInstance, strId, ansibuf, MAX_PATH);
    return (n > 0 && AnsiToUnicodeStr(ansibuf, buf, size)) ? n : 0;
}


/**************************************************************************\
*
* Function Description:
*
*   Load bitmap resource
*
* Arguments:
*
*   hInstance - handle of module containing bitmap resource
*   bitmapName - pointer to bitmap resource name OR bitmap resource
*       identifier (resource identifier is zero in high order word)
*
* Return Value:
*
*   Handle of the loaded bitmap
*   0 if there is an error
*
\**************************************************************************/

HBITMAP
_LoadBitmap(
    HINSTANCE hInstance,
    const WCHAR *bitmapName
    )
{
    // Windows NT - Unicode

    if (OSInfo::IsNT)
    {
        return LoadBitmapW(hInstance, bitmapName);
    }

    // Win9x - ANSI only

    else
    {
        if (!IS_INTRESOURCE(bitmapName))
        {
            AnsiStrFromUnicode bitmapStr(bitmapName);

            if (bitmapStr.IsValid())
            {
                return LoadBitmapA(hInstance, bitmapStr);
            }
            else
            {
                return (HBITMAP) NULL;
            }
        }
        else
        {
            // If bitmapName is really an integer resource identifier,
            // then it can be passed directly to the ANSI version of the
            // API.

            return LoadBitmapA(hInstance, (LPCSTR) bitmapName);
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Create or open the specified file
*
* Arguments:
*
*   filename - specifies the name of the file
*   accessMode - specifies the desired access mode
*   shareMode - specifies the share mode
*   creationFlags - creation flags
*   attrs - attribute flags
*
* Return Value:
*
*   Handle to the file created or opened
*   INVALID_HANDLE_VALUE if there is an error
*
\**************************************************************************/

HANDLE
_CreateFile(
    const WCHAR* filename,
    DWORD accessMode,
    DWORD shareMode,
    DWORD creationFlags,
    DWORD attrs
    )
{
    // Windows NT - Unicode

    if (OSInfo::IsNT)
    {
        return CreateFileW(
                    filename,
                    accessMode,
                    shareMode,
                    NULL,
                    creationFlags,
                    attrs,
                    NULL);
    }

    // Windows 9x - non-Unicode

    AnsiStrFromUnicode nameStr(filename);

    if (nameStr.IsValid())
    {
        return CreateFileA(
                    nameStr,
                    accessMode,
                    shareMode,
                    NULL,
                    creationFlags,
                    attrs,
                    NULL);
    }
    else
        return INVALID_HANDLE_VALUE;
}


/**************************************************************************\
*
* Function Description:
*
*   Create an IPropertySetStorage object on top of a memory buffer
*
* Arguments:
*
*   propSet - Returns a pointer to the newly created object
*   hmem - Optional handle to memory buffer
*       if NULL, we'll allocate memory ourselves
*       otherwise, must be allocated by GlobalAlloc and 
*           must be moveable and non-discardable
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
CreateIPropertySetStorageOnHGlobal(
    IPropertySetStorage** propSet,
    HGLOBAL hmem
    )
{
    HRESULT hr;
    ILockBytes* lockbytes;
    IStorage* stg;

    hr = CreateILockBytesOnHGlobal(hmem, TRUE, &lockbytes);

    if (FAILED(hr))
        return hr;

    hr = StgCreateDocfileOnILockBytes(lockbytes, 
        STGM_DIRECT | STGM_READWRITE | STGM_CREATE  | STGM_SHARE_EXCLUSIVE, 
        0, 
        &stg);
    lockbytes->Release();

    if (FAILED(hr))
        return hr;
    
    hr = stg->QueryInterface(IID_IPropertySetStorage, (VOID**) propSet);
    stg->Release();

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Print out debug messages using a message box
*
* Arguments:
*
*   format - printf format string
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

#if DBG
// This function is never used anywhere in the imaging tree.
/*
VOID
DbgMessageBox(
    const CHAR* format,
    ...
    )
{
    CHAR buf[1024];
    va_list arglist;

    va_start(arglist, format);
    vsprintf(buf, format, arglist);
    va_end(arglist);

    MessageBoxA(NULL, buf, "Debug Message", MB_OK);
}
*/

#endif // DBG


/**************************************************************************\
*
* Function Description:
*
*     Reads a specified number bytes from a stream.  Blocking behavior:
*
*     - If the decoder is in blocking mode and the stream returns E_PENDING 
*         then this function blocks until the stream returns the data.
*     - If the decoder is in non-blocking mode and the stream returns 
*         E_PENDING then this function seeks back in the stream to before 
*         the read and returns E_PENDING.
*     
*     If the stream returns a success but reutrns less bytes than the number 
*     requested then this function returns E_FAIL.
*
* Arguments:
*
*     stream - Stream to read from.
*     buffer - Array to read into.  If buffer is NULL then this function seeks 
*         instead of reading.  If the buffer is NULL and the count is negative 
*         then the stream seeks backwards
*     count - Number of bytes to read.
*     blocking - TRUE if this function should block if the stream returns 
*         E_PENDING.  From a decoder, use something like"!(decoderFlags & 
*         DECODERINIT_NOBLOCK)"
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
ReadFromStream(IN IStream* stream, OUT VOID* buffer, IN INT count, IN BOOL 
    blocking)
{
    HRESULT hresult;
    LONG actualread = 0;
    LARGE_INTEGER lcount;
    ULARGE_INTEGER lactualread;
    BOOL repeat;

    do
    {
        repeat = FALSE;

        if (buffer)
        {
            if (count < 0)
                return E_INVALIDARG;
            hresult = stream->Read(buffer, (unsigned)count, (unsigned long*)&actualread);
        }
        else
        {
            lcount.QuadPart = count;
            hresult = stream->Seek(lcount, STREAM_SEEK_CUR, NULL);
            if (SUCCEEDED(hresult))
                actualread = count;
        }

        if (hresult == E_PENDING && blocking)
        {
            buffer = (char*)buffer + actualread;
            count -= actualread;
            repeat = TRUE;
            Sleep(0);
        }
    } while(repeat);

    if (blocking)
    {
        if (actualread != count)
            return E_FAIL;
        ASSERT(hresult != E_PENDING);
    }
    else if (hresult == E_PENDING)
    {
        LONGLONG lread;
        LARGE_INTEGER seekcount;

        seekcount.QuadPart = -((LONGLONG)actualread);

        hresult = stream->Seek(seekcount, STREAM_SEEK_CUR, NULL);
        if (FAILED(hresult))
            return hresult;

        return E_PENDING;
    }

    if (FAILED(hresult))
        return hresult;

    if (actualread != count)
        return E_FAIL;

    return hresult;
}


/**************************************************************************\
*
* Function Description:
*
*     Seeks 'count' number of bytes forward in a stream from the current 
*     stream pointer.  If 'count' is negative then the stream seeks backwards. 
*     Handles both blocking and non-blocking seeking.
*
* Arguments:
*
*     stream - Stream to seek through.
*     count - Number of bytes to seek.
*     blocking - TRUE if this function should block if the stream returns 
*         E_PENDING.  From a decoder, use something like"!(decoderFlags & 
*         DECODERINIT_NOBLOCK)"
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
SeekThroughStream(IN IStream* stream, IN INT count, IN BOOL blocking)
{
    return ReadFromStream(stream, NULL, count, blocking);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\api\memstream.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   memstream.hpp
*
* Abstract:
*
*   Read-only memory stream declarations
*
* Revision History:
*
*   06/14/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _MEMSTREAM_HPP
#define _MEMSTREAM_HPP

class GpReadOnlyMemoryStream : public IUnknownBase<IStream>
{
public:

    GpReadOnlyMemoryStream()
    {
        membuf = NULL;
        memsize = curptr = 0;
        allocFlag = FLAG_NONE;
        hfile = INVALID_HANDLE_VALUE;
        filename = NULL;
    }

    ~GpReadOnlyMemoryStream()
    {
        VOID* p = (VOID*) membuf;

        // Free memory if necessary

        if (p != NULL)
        {
            switch (allocFlag)
            {
            case FLAG_GALLOC:
                GlobalFree((HGLOBAL) p);
                break;

            case FLAG_VALLOC:
                VirtualFree(p, 0, MEM_RELEASE);
                break;

            case FLAG_COALLOC:
                CoTaskMemFree(p);
                break;

            case FLAG_MAPFILE:
                UnmapViewOfFile(p);
                break;
            }
        }

        // Close the open file, if any

        if (hfile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hfile);
        }
        
        if (filename)
        {
            GpFree(filename);
        }
    }

    enum
    {
        FLAG_NONE,
        FLAG_GALLOC,
        FLAG_VALLOC,
        FLAG_COALLOC,
        FLAG_MAPFILE
    };

    VOID InitBuffer(const VOID* buf, UINT size, UINT allocFlag = FLAG_NONE)
    {
        membuf = (const BYTE*) buf;
        memsize = size;
        curptr = 0;
        this->allocFlag = allocFlag;
    }

    HRESULT InitFile(const WCHAR* filename);

    VOID SetAllocFlag(UINT allocFlag)
    {
        this->allocFlag = allocFlag;
    }

    //----------------------------------------------------------------
    // IStream interface methods
    //----------------------------------------------------------------

    STDMETHOD(Read)(
        VOID* buf,
        ULONG cb,
        ULONG* cbRead
        );

    STDMETHOD(Seek)(
        LARGE_INTEGER offset,
        DWORD origin,
        ULARGE_INTEGER* newPos
        );

    STDMETHOD(Stat)(
        STATSTG* statstg,
        DWORD statFlag
        );

    STDMETHOD(Write)(
        const VOID* buf,
        ULONG cb,
        ULONG* cbWritten
        )
    {
        return STG_E_ACCESSDENIED;
    }

    STDMETHOD(CopyTo)(
        IStream* stream,
        ULARGE_INTEGER cb,
        ULARGE_INTEGER* cbRead,
        ULARGE_INTEGER* cbWritten
        )
    {
        return E_NOTIMPL;
    }
        
    STDMETHOD(SetSize)(
        ULARGE_INTEGER newSize
        )
    {
        return E_NOTIMPL;
    }

    STDMETHOD(Commit)(
        DWORD commitFlags
        )
    {
        return S_OK;
    }

    STDMETHOD(Revert)()
    {
        return E_NOTIMPL;
    }

    STDMETHOD(LockRegion)(
        ULARGE_INTEGER offset,
        ULARGE_INTEGER cb,
        DWORD lockType
        )
    {
        return E_NOTIMPL;
    }

    STDMETHOD(UnlockRegion)(
        ULARGE_INTEGER offset,
        ULARGE_INTEGER cb,
        DWORD lockType
        )
    {
        return E_NOTIMPL;
    }

    STDMETHOD(Clone)(
        IStream** stream
        )
    {
        return E_NOTIMPL;
    }

private:

    GpLockable objectLock;
    const BYTE* membuf;
    UINT memsize;
    UINT curptr;
    UINT allocFlag;
    HANDLE hfile;
    WCHAR* filename;
};

class GpWriteOnlyMemoryStream : public IUnknownBase<IStream>
{
private:

    GpLockable objectLock;              // Object lock
    BYTE *m_pMemBuf;                    // Poinetr to memory buffer
    UINT m_uMemSize;                    // Memory buffer size
    UINT m_curPtr;                      // Current memory position

public:
    GpWriteOnlyMemoryStream()
    {
        m_pMemBuf = NULL;
        m_uMemSize = 0;
        m_curPtr = 0;
    }

    ~GpWriteOnlyMemoryStream()
    {
        // Free memory if necessary

        if (m_pMemBuf != NULL)
        {
            GpFree(m_pMemBuf);
            m_pMemBuf = NULL;
        }
        
        m_uMemSize = 0;
        m_curPtr = 0;
    }

    // This method lets the caller set the size of memory buffer being allocated

    HRESULT InitBuffer(const UINT uSize)
    {
        // Initialize buffer size should be bigger than zero

        if (uSize == 0)
        {
            return E_INVALIDARG;
        }

        HRESULT hr = E_OUTOFMEMORY;
        m_pMemBuf = (BYTE*)GpMalloc(uSize);
        if (m_pMemBuf)
        {
            m_uMemSize = uSize;
            m_curPtr = 0;

            hr = S_OK;
        }

        return hr;
    }

    // This method returns how many bytes have been written in the buffer and
    // also returns the starting pointer of the memory buffer
    
    HRESULT GetBitsPtr(BYTE **ppStartPtr, UINT *puSize)
    {
        HRESULT hr = E_INVALIDARG;

        if (ppStartPtr && puSize)
        {
            *ppStartPtr = m_pMemBuf;
            *puSize = m_curPtr;
            hr = S_OK;
        }

        return hr;
    }

    //----------------------------------------------------------------
    // IStream interface methods
    //----------------------------------------------------------------

    STDMETHOD(Read)(
        VOID* buf,
        ULONG cb,
        ULONG* cbRead
        )
    {
        // This is a write only class. Can't allow Read()

        return STG_E_ACCESSDENIED;
    }

    STDMETHOD(Seek)(
        LARGE_INTEGER offset,
        DWORD origin,
        ULARGE_INTEGER* newPos
        );

    STDMETHOD(Stat)(
        STATSTG* statstg,
        DWORD statFlag
        );

    STDMETHOD(Write)(
        const VOID* buf,
        ULONG cb,
        ULONG* cbWritten
        );

    STDMETHOD(CopyTo)(
        IStream* stream,
        ULARGE_INTEGER cb,
        ULARGE_INTEGER* cbRead,
        ULARGE_INTEGER* cbWritten
        )
    {
        return E_NOTIMPL;
    }
        
    STDMETHOD(SetSize)(
        ULARGE_INTEGER newSize
        )
    {
        return E_NOTIMPL;
    }

    STDMETHOD(Commit)(
        DWORD commitFlags
        )
    {
        return S_OK;
    }

    STDMETHOD(Revert)()
    {
        return E_NOTIMPL;
    }

    STDMETHOD(LockRegion)(
        ULARGE_INTEGER offset,
        ULARGE_INTEGER cb,
        DWORD lockType
        )
    {
        return E_NOTIMPL;
    }

    STDMETHOD(UnlockRegion)(
        ULARGE_INTEGER offset,
        ULARGE_INTEGER cb,
        DWORD lockType
        )
    {
        return E_NOTIMPL;
    }

    STDMETHOD(Clone)(
        IStream **stream
        )
    {
        return E_NOTIMPL;
    }
};

#endif // !_MEMSTREAM_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\api\mmx.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   mmx.hpp
*
* Abstract:
*
*   MMX related declarations
*
* Revision History:
*
*   06/07/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _MMX_HPP
#define _MMX_HPP

#ifdef _X86_

// Use MMX to linearly interpolate two scanlines

VOID
MMXBilinearScale(
    ARGB* dstbuf,
    const ARGB* line0,
    const ARGB* line1,
    INT w0,
    INT w1,
    INT count
    );

// Use MMX to interpolate four scanlines with specified weights

VOID
MMXBicubicScale(
    ARGB* dstbuf,
    const ARGB* line0,
    const ARGB* line1,
    const ARGB* line2,
    const ARGB* line3,
    INT w0,
    INT w1,
    INT w2,
    INT w3,
    INT count
    );

#endif // _X86_

#endif // !_MMX_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\api\pointops.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   pointops.cpp
*
* Abstract:
*
*   Perform basic point operations on a bitmap image
*
* Revision History:
*
*   07/16/1999 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"


/**************************************************************************\
*
* Function Description:
*
*   Adjust the brightness of the bitmap image
*
* Arguments:
*
*   percent - Specifies how much to adjust the brightness by
*       assuming intensity value is between 0 and 1
*       new intensity = old intensity + percent
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::AdjustBrightness(
    IN FLOAT percent
    )
{
    if (percent > 1 || percent < -1)
        return E_INVALIDARG;

    // Compute the lookup table entries

    BYTE lut[256];
    INT incr = (INT) (percent * 255);

    for (INT i=0; i < 256; i++)
    {
        INT j = i + incr;
        lut[i] = (BYTE) ((j < 0) ? 0 : (j > 255) ? 255 : j);
    }

    // Call the common function to do the work

    return PerformPointOps(lut);
}


/**************************************************************************\
*
* Function Description:
*
*   Adjust the contrast of the bitmap image
*
* Arguments:
*
*   shadow - new intensity value corresponding to old intensity value 0
*   highlight - new intensity value corresponding to old value 1
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::AdjustContrast(
    IN FLOAT shadow,
    IN FLOAT highlight
    )
{
    BYTE lut[256];

    // Compute the lookup table entries

    INT l, h;

    l = (INT) (shadow * 255);
    h = (INT) (highlight * 255);

    if (l > h)
        return E_INVALIDARG;
    
    for (INT i=0; i < 256; i++)
    {
        INT j = l + i * (h - l) / 255;
        lut[i] = (BYTE) ((j < 0) ? 0 : (j > 255) ? 255 : j);
    }

    // Call the common function to do the work

    return PerformPointOps(lut);
}


/**************************************************************************\
*
* Function Description:
*
*   Adjust the gamma of the bitmap image
*
* Arguments:
*
*   gamma - Specifies the gamma value
*       new intensity = old intensity ** gamma
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::AdjustGamma(
    IN FLOAT gamma
    )
{
    // Compute the lookup table entries

    BYTE lut[256];

    lut[0] = 0;

    for (INT i=1; i < 256; i++)
        lut[i] = (BYTE) (pow(i / 255.0, gamma) * 255);

    // Call the common function to do the work

    return PerformPointOps(lut);
}


/**************************************************************************\
*
* Function Description:
*
*   Perform point operation on an array of 32bpp pixels
*
* Arguments:
*
*   pixbuf - Pointer to the pixel buffer to be operated on
*   count - Pixel count
*   lut - Specifies the lookup table to be used
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
PointOp32bppProc(
    ARGB* pixbuf,
    UINT count,
    const BYTE lut[256]
    )
{
    while (count--)
    {
        ARGB p = *pixbuf;

        *pixbuf++ = ((ARGB) lut[ p        & 0xff]      ) |
                    ((ARGB) lut[(p >>  8) & 0xff] <<  8) |
                    ((ARGB) lut[(p >> 16) & 0xff] << 16) |
                    (p & 0xff000000);
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Perform point operation on an array of 24bpp pixels
*
* Arguments:
*
*   pixbuf - Pointer to the pixel buffer to be operated on
*   count - Pixel count
*   lut - Specifies the lookup table to be used
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
PointOp24bppProc(
    BYTE* pixbuf,
    UINT count,
    const BYTE lut[256]
    )
{
    count *= 3;

    while (count--)
    {
        *pixbuf = lut[*pixbuf];
        pixbuf++;
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Perform point operations on a bitmap image
*
* Arguments:
*
*   lut - Specifies the lookup table to be used
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::PerformPointOps(
    const BYTE lut[256]
    )
{
    // Lock the current bitmap image object

    GpLock lock(&objectLock);

    if (lock.LockFailed())
        return IMGERR_OBJECTBUSY;

    // If we're dealing with indexed color images,
    // then perform the point operation on the color palette

    if (IsIndexedPixelFormat(PixelFormat))
    {
        ColorPalette* pal = CloneColorPalette(GetCurrentPalette());

        if (pal == NULL)
            return E_OUTOFMEMORY;
        
        PointOp32bppProc(
            pal->Entries,
            pal->Count,
            lut);
        
        GpFree(colorpal);
        colorpal = pal;

        return S_OK;
    }

    // Determine what pixel format we want to operate on

    PixelFormatID pixfmt;
        
    if (PixelFormat == PIXFMT_24BPP_RGB ||
        PixelFormat == PIXFMT_32BPP_RGB ||
        PixelFormat == PIXFMT_32BPP_ARGB)
    {
        pixfmt = PixelFormat;
    }
    else
        pixfmt = PIXFMT_32BPP_ARGB;

    // Allocate temporary scanline buffer if necessary

    GpTempBuffer tempbuf(NULL, 0);
    BitmapData bmpdata;
    RECT rect = { 0, 0, Width, 1 };
    UINT flags = IMGLOCK_READ|IMGLOCK_WRITE;
    HRESULT hr;

    if (pixfmt != PixelFormat)
    {
        bmpdata.Stride = Width * sizeof(ARGB);
        bmpdata.Reserved = 0;

        if (!tempbuf.Realloc(bmpdata.Stride))
            return E_OUTOFMEMORY;
        
        bmpdata.Scan0 = tempbuf.GetBuffer();
        flags |= IMGLOCK_USERINPUTBUF;
    }

    // Process one scanline at a time
    //
    // NOTE: May want to consider doing multiple scanlines
    // per iteration to reduce the overhead from calling
    // Lock/UnlockBits.

    for (UINT y=0; y < Height; y++)
    {
        hr = InternalLockBits(&rect, flags, pixfmt, &bmpdata);

        if (FAILED(hr))
            return hr;

        if (pixfmt == PIXFMT_24BPP_RGB)
        {
            PointOp24bppProc(
                (BYTE*) bmpdata.Scan0,
                bmpdata.Width,
                lut);
        }
        else
        {
            PointOp32bppProc(
                (ARGB*) bmpdata.Scan0,
                bmpdata.Width,
                lut);
        }

        InternalUnlockBits(&rect, &bmpdata);

        rect.top += 1;
        rect.bottom += 1;
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Perform color adjustment on a bitmap image
*
* Arguments:
*
*   imageAttributes - Pointer to the color adjustment parameters
*   callback - Abort callback
*   callbackData - Data to pass to the abort callback
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpMemoryBitmap::PerformColorAdjustment(
    IN GpRecolor* recolor,
    IN ColorAdjustType type,
    IN DrawImageAbort callback,
    IN VOID* callbackData
    )
{
    // Lock the current bitmap image object

    GpLock lock(&objectLock);

    if (lock.LockFailed())
        return IMGERR_OBJECTBUSY;

    // Flush dirty state

    recolor->Flush();

    // If we're dealing with indexed color images,
    // then perform the point operation on the color palette

    if (IsIndexedPixelFormat(PixelFormat))
    {
        ColorPalette* pal = CloneColorPalette(GetCurrentPalette());

        if (pal == NULL)
            return E_OUTOFMEMORY;
        
        recolor->ColorAdjust(
            pal->Entries,
            pal->Count,
            type
        );
        
        GpFree(colorpal);
        colorpal = pal;

        return S_OK;
    }

    // Determine what pixel format we want to operate on

    PixelFormatID pixfmt;

    //!!!TODO: can optimize for 24bpp by implementing
    //!!!      GpRecolor::ColorAdjust24bppProc
    //!!!      (see GpMemoryBitmap:: and PointOp24bppProc above)

    if (PixelFormat == PIXFMT_32BPP_RGB ||
        PixelFormat == PIXFMT_32BPP_ARGB)
    {
        pixfmt = PixelFormat;
    }
    else
        pixfmt = PIXFMT_32BPP_ARGB;

    // Allocate temporary scanline buffer if necessary

    GpTempBuffer tempbuf(NULL, 0);
    BitmapData bmpdata;
    RECT rect = { 0, 0, Width, 1 };
    UINT flags = IMGLOCK_READ|IMGLOCK_WRITE;
    HRESULT hr;

    if (pixfmt != PixelFormat)
    {
        bmpdata.Stride = Width * sizeof(ARGB);
        bmpdata.Reserved = 0;

        if (!tempbuf.Realloc(bmpdata.Stride))
            return E_OUTOFMEMORY;
        
        bmpdata.Scan0 = tempbuf.GetBuffer();
        flags |= IMGLOCK_USERINPUTBUF;
    }

    // Process one scanline at a time
    //
    // NOTE: May want to consider doing multiple scanlines
    // per iteration to reduce the overhead from calling
    // Lock/UnlockBits.

    for (UINT y=0; y < Height; y++)
    {
        if (callback && ((*callback)(callbackData)))
        {
            return IMGERR_ABORT;
        }

        hr = InternalLockBits(&rect, flags, pixfmt, &bmpdata);

        if (FAILED(hr))
        {
            return hr;
        }

        recolor->ColorAdjust(
            static_cast<ARGB*>(bmpdata.Scan0),
            bmpdata.Width, 
            type
        );

        InternalUnlockBits(&rect, &bmpdata);

        rect.top += 1;
        rect.bottom += 1;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\api\mmx.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   mmx.cpp
*
* Abstract:
*
*   MMX specific routines
*
* Revision History:
*
*   06/07/1999 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

#ifdef _X86_

/**************************************************************************\
*
* Function Description:
*
*   Use MMX to linearly interpolate between two scanlines
*
* Arguments:
*
*   dstbuf - Destination buffer
*   line0 - Pointer to the first source scanline
*   line1 - Pointer to the second source scanline
*   w0 - Weight for the first scanline, in .8 fixed point format
*   w1 - Weight for the second scanline
*   count - Number of ARGB pixels
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
MMXBilinearScale(
    ARGB* dstbuf,
    const ARGB* line0,
    const ARGB* line1,
    INT w0,
    INT w1,
    INT count
    )
{
    __asm
    {
        push    esi             ; save esi and edi on stack
        push    edi
        mov     ecx, count      ; ecx = count
        mov     edi, dstbuf     ; edi = dstbuf
        mov     esi, line0      ; esi = line0
        mov     ebx, line1      ; ebx = line1

        movd    mm3, w0         ; mm3 = w0 repeat 4 times
        movd    mm4, w1         ; mm4 = w1 repeat 4 times
        pxor    mm0, mm0        ; mm0 = 0
        punpcklwd mm3, mm3
        punpcklwd mm4, mm4
        punpcklwd mm3, mm3
        punpcklwd mm4, mm4

    L1:
        test    ecx, ecx        ; while ecx != 0
        jz      L2

        movd    mm1, [esi]      ; mm1 = next 4 bytes from line0
        dec     ecx
        add     esi, 4
        movd    mm2, [ebx]      ; mm2 = next 4 bytes from line1
        punpcklbw mm1, mm0
        add     ebx, 4
        punpcklbw mm2, mm0

        pmullw  mm1, mm3        ; mm1 <= mm1 * mm3 + mm2 * mm4
        pmullw  mm2, mm4
        paddw   mm1, mm2

        psrlw   mm1, 8
        packuswb mm1, mm0       ; save 4 result bytes to dstbuf
        movd    [edi], mm1
        add     edi, 4
        jmp     L1

    L2:
        pop     edi             ; restore edi and esi
        pop     esi
        emms
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Use MMX to interpolate four scanlines with specified weights
*
* Arguments:
*
*   dstbuf - Destination buffer
*   line0, line1, line2, line3 - Pointer to the source scanlines
*   w0, w1, w2, w3 - Weights for each source scanline
*   count - Number of ARGB pixels
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
MMXBicubicScale(
    ARGB* dstbuf,
    const ARGB* line0,
    const ARGB* line1,
    const ARGB* line2,
    const ARGB* line3,
    INT w0,
    INT w1,
    INT w2,
    INT w3,
    INT count
    )
{
    __asm
    {
        push    esi                 ; save esi and edi on stack
        push    edi

        movd    mm0, w0             ; mm0 = w0, 15-bit precision, repeated 4 times
        movd    mm1, w1             ; mm1 <=> w1
        movd    mm2, w2             ; mm2 <=> w2
        movd    mm3, w3             ; mm3 <=> w3

        psrlq   mm0, 1
        psrlq   mm1, 1
        psrlq   mm2, 1
        psrlq   mm3, 1

        punpcklwd mm0, mm0
        punpcklwd mm1, mm1
        punpcklwd mm2, mm2
        punpcklwd mm3, mm3

        punpcklwd mm0, mm0
        punpcklwd mm1, mm1
        punpcklwd mm2, mm2
        punpcklwd mm3, mm3

        mov     edi, dstbuf         ; edi = dstbuf
        mov     ecx, count          ; ecx = count
        mov     esi, line0          ; esi = line0
        mov     eax, line1          ; eax = line1
        mov     ebx, line2          ; ebx = line2
        mov     edx, line3          ; edx = line3
        pxor    mm7, mm7            ; mm7 = 0

    L1: test    ecx, ecx            ; while ecx != 0
        jz      L2
        dec     ecx

        movd    mm4, [esi]          ; next pixel from line0
        movd    mm5, [eax]          ; next pixel from line1
        punpcklbw mm4, mm7
        punpcklbw mm5, mm7
        psllw   mm4, 3
        psllw   mm5, 3
        pmulhw  mm4, mm0
        pmulhw  mm5, mm1
        add     esi, 4
        add     eax, 4

        movd    mm6, [ebx]          ; next pixel from line2
        paddsw  mm4, mm5
        punpcklbw mm6, mm7
        movd    mm5, [edx]          ; next pixel from line3
        psllw   mm6, 3
        punpcklbw mm5, mm7
        pmulhw  mm6, mm2
        psllw   mm5, 3
        paddsw  mm4, mm6
        pmulhw  mm5, mm3
        add     ebx, 4
        paddsw  mm4, mm5
        add     edx, 4
        psraw   mm4, 2

        packuswb mm4, mm7
        movd    [edi], mm4
        add     edi, 4
        jmp     L1

    L2:
        pop     edi                 ; restore edi and esi
        pop     esi
        emms
    }
}

#endif // _X86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\api\propertyutil.hpp ===
#ifndef _PROPERTYUTIL_HPP_
#define _PROPERTYUTIL_HPP_

typedef struct tagInternalPropertyItem
{
    struct tagInternalPropertyItem*   pNext;
    struct tagInternalPropertyItem*   pPrev;
    PROPID  id;     // ID of this property
    ULONG   length; // Length of the property
    WORD    type;   // Type of the value, one of TAG_TYPE_ defined in imaging.h
    VOID*   value;  // property value
} InternalPropertyItem;

HRESULT
AddProperty(IPropertyStorage*   propStg, 
            PROPID              propidKey,
            WCHAR*              value);

HRESULT 
AddProperty(IPropertyStorage*   propStg, 
            PROPID              propidKey,
            CHAR*               value);

HRESULT 
AddProperty(IPropertyStorage*   propStg,
            PROPID              propidKey,
            INT                 value);

HRESULT 
AddProperty(IPropertyStorage*   propStg,
            PROPID              propidKey,
            double              value);

HRESULT 
AddProperty(IPropertyStorage*   propStg, 
            PROPID              propidKey,
            UCHAR*              value,
            UINT                uiLength);

HRESULT
AddProperty(IPropertyStorage* propStg,
            PROPID              propidKey,
            FILETIME            value);

HRESULT
AddPropertyList(InternalPropertyItem*   pTail,
                PROPID                  id,
                UINT                    uiLength,
                WORD                    wType,
                VOID*                   pValue);
HRESULT
RemovePropertyItemFromList(InternalPropertyItem* pItem);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\api\propertyutil.cpp ===
#include "precomp.hpp"
#include "propertyutil.hpp"

#define PROPID_NAME_FIRST 1024

/**************************************************************************\
*
* Function Description:
*
*     This function returns a SysAllocString compatible string, but
*     without introducing a dependency on oleaut32.dll.
*     Note:  Do not use this to allocate strings that will be freed
*     with oleaut32's SysFreeString, because they may not come from
*     the same heap.
*
* Arguments:
*
*     sz - string to be allocated
*
* Return Value:
*
*   BSTR string
*
\**************************************************************************/

BSTR
ImgSysAllocString(
    const OLECHAR *sz
    )
{
    INT len   = UnicodeStringLength(sz);
    BSTR bstr = (BSTR) GpMalloc(sizeof(WCHAR) * (len + 1) + sizeof(ULONG));
    if (bstr) 
    {
        *((ULONG *) bstr) = len * sizeof(WCHAR);
        bstr = (BSTR) (((ULONG *) bstr) + 1); // Return a pointer just past
                                              // the dword count
        UnicodeStringCopy(bstr, sz);
    }
    
    return bstr;
}

/**************************************************************************\
*
* Function Description:
*
*     This functions frees a BSTR allocated with ImgSysAllocString.
*     Note:  Do not use this function to free a string allocated using
*     oleaut32's SysAllocString, because they may not come from the
*     same heap
*
* Arguments:
*
*     sz - string to be allocated
*
* Return Value:
*
*   BSTR string
*
\**************************************************************************/

VOID
ImgSysFreeString(
    BSTR bstr
    )
{
    if (bstr) 
    {
        bstr = (BSTR) (((ULONG *) bstr) - 1);  // Allocation starts 4 bytes before the first character
        GpFree(bstr);
    }
}


/**************************************************************************\
*
* Function Description:
*
*     Adds a unicode string to a property storage
*
* Arguments:
*
*     propStg -- The property storage to modify
*     pwszKey -- A string value describing the property
*     propidKey -- a PROPID describing the property
*     value -- A unicode string to be used as the value
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT 
AddProperty(
    IPropertyStorage *propStg, 
    PROPID propidKey, 
    WCHAR *value
    )
{
    HRESULT hresult;
    PROPSPEC propSpec[2];
    INT cSpec = 0;

    if ( propidKey != 0 )
    {        
        propSpec[cSpec].ulKind = PRSPEC_PROPID;
        propSpec[cSpec].propid = propidKey;
        cSpec++;
    }

    PROPVARIANT variant[1];
    PropVariantInit(&variant[0]);
    variant[0].vt = VT_BSTR;
    BSTR bstr = ImgSysAllocString(value);
    variant[0].bstrVal = bstr;

    hresult = propStg->WriteMultiple(cSpec, propSpec, variant, PROPID_NAME_FIRST);

    ImgSysFreeString(bstr);
    return hresult;
}

/**************************************************************************\
*
* Function Description:
*
*     Adds a single byte string to a property storage
*
* Arguments:
*
*     propStg -- The property storage to modify
*     pwszKey -- A string value describing the property
*     propidKey -- a PROPID describing the property
*     value -- A character string to be used as the value
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT 
AddProperty(
    IPropertyStorage *propStg, 
    PROPID propidKey, 
    CHAR *value
    )
{
    HRESULT hresult;

    WCHAR str[MAX_PATH];
    if (!AnsiToUnicodeStr(value, str, MAX_PATH)) 
    {
        return E_FAIL;
    }
    
    PROPSPEC propSpec[2];
    INT cSpec = 0;

    if ( propidKey != 0 )
    {        
        propSpec[cSpec].ulKind = PRSPEC_PROPID;
        propSpec[cSpec].propid = propidKey;
        cSpec++;
    }

    PROPVARIANT variant[1];
    PropVariantInit(&variant[0]);
    variant[0].vt = VT_BSTR;
    BSTR bstr = ImgSysAllocString(str);
    variant[0].bstrVal = bstr;

    hresult = propStg->WriteMultiple(cSpec, propSpec, variant, PROPID_NAME_FIRST);

    ImgSysFreeString(bstr);
    return hresult;
}

/**************************************************************************\
*
* Function Description:
*
*     Adds an integer to a property storage
*
* Arguments:
*
*     propStg -- The property storage to modify
*     pwszKey -- A string value describing the property
*     propidKey -- a PROPID describing the property
*     value -- An integer to be used as the value
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT 
AddProperty(
    IPropertyStorage *propStg,
    PROPID propidKey, 
    INT value
    )
{
    PROPSPEC propSpec[2];
    INT cSpec = 0;

    if ( propidKey != 0 )
    {        
        propSpec[cSpec].ulKind = PRSPEC_PROPID;
        propSpec[cSpec].propid = propidKey;
        cSpec++;
    }

    PROPVARIANT variant[1];
    PropVariantInit(&variant[0]);
    variant[0].vt = VT_I4;
    variant[0].lVal = value;

    return propStg->WriteMultiple(cSpec, propSpec, variant, PROPID_NAME_FIRST); 
}

/**************************************************************************\
*
* Function Description:
*
*     Adds a double to a property storage
*
* Arguments:
*
*     propStg -- The property storage to modify
*     pwszKey -- A string value describing the property
*     propidKey -- a PROPID describing the property
*     value -- A double to be used as the value
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT 
AddProperty(
    IPropertyStorage *propStg,
    PROPID propidKey, 
    double value
    )
{
    PROPSPEC propSpec[2];
    INT cSpec = 0;

    if ( propidKey != 0 )
    {        
        propSpec[cSpec].ulKind = PRSPEC_PROPID;
        propSpec[cSpec].propid = propidKey;
        cSpec++;
    }

    PROPVARIANT variant[1];
    PropVariantInit(&variant[0]);
    variant[0].vt = VT_R8;
    variant[0].dblVal = value;

    return propStg->WriteMultiple(cSpec, propSpec, variant, PROPID_NAME_FIRST); 
}

HRESULT 
AddProperty(
    IPropertyStorage*   propStg, 
    PROPID              propidKey, 
    UCHAR*              value,
    UINT                uiLength
    )
{
    PROPSPEC propSpec[2];
    INT cSpec = 0;

    if ( propidKey != 0 )
    {        
        propSpec[cSpec].ulKind = PRSPEC_PROPID;
        propSpec[cSpec].propid = propidKey;
        cSpec++;
    }

    PROPVARIANT variant[1];
    PropVariantInit(&variant[0]);
    variant[0].vt = VT_VECTOR | VT_UI1;
    variant[0].caub.cElems = uiLength;
    variant[0].caub.pElems = value;

    return propStg->WriteMultiple(cSpec, propSpec, variant, PROPID_NAME_FIRST);
}

HRESULT
AddProperty(
    IPropertyStorage* propStg,
    PROPID              propidKey,
    FILETIME            value
    )
{
    PROPSPEC propSpec[2];
    INT cSpec = 0;

    if ( propidKey != 0 )
    {        
        propSpec[cSpec].ulKind = PRSPEC_PROPID;
        propSpec[cSpec].propid = propidKey;
        cSpec++;
    }

    PROPVARIANT variant[1];
    PropVariantInit(&variant[0]);
    variant[0].vt = VT_FILETIME;
    variant[0].filetime = value;

    return propStg->WriteMultiple(cSpec, propSpec, variant, PROPID_NAME_FIRST);
}

HRESULT
AddPropertyList(
    InternalPropertyItem*   pTail,
    PROPID                  id,
    UINT                    uiLength,
    WORD                    wType,
    VOID*                   pValue
    )
{
    InternalPropertyItem* pNewItem = new InternalPropertyItem();

    if ( pNewItem == NULL )
    {
        return E_OUTOFMEMORY;
    }

    pNewItem->id = id;
    pNewItem->type = wType;
    pNewItem->length = uiLength;
    pNewItem->value = GpMalloc(uiLength);
    if ( pNewItem->value == NULL )
    {
        // need to clean up this if we allocated the first one and 
        // failed the second one.
        
        delete pNewItem;
        
        WARNING(("AddPropertyList--out of memory"));
        return E_OUTOFMEMORY;
    }

    GpMemcpy(pNewItem->value, pValue, uiLength);
    
    pTail->pPrev->pNext = pNewItem;
    pNewItem->pPrev = pTail->pPrev;
    pNewItem->pNext = pTail;
    pTail->pPrev = pNewItem;

    return S_OK;
}// AddPropertyList()

HRESULT
RemovePropertyItemFromList(
    InternalPropertyItem*   pItem
    )
{
    if ( pItem == NULL )
    {
        WARNING(("JPEG::RemovePropertyItemFromList--Empty input"));
        return E_FAIL;
    }

    // Free the memory allocated in this item

    GpFree(pItem->value);

    InternalPropertyItem*   pPrev = pItem->pPrev;
    InternalPropertyItem*   pNext = pItem->pNext;

    // pPrev will never be NULL because we always have the guardian, the header
    // note in the list. Same for the tail node

    ASSERT(pPrev != NULL);
    ASSERT(pNext != NULL);

    pPrev->pNext = pNext;
    pNext->pPrev = pPrev;

    return S_OK;
}// AddPropertyList()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\api\resample.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   resample.cpp
*
* Abstract:
*
*   Bitamp scaler implementation
*
* Revision History:
*
*   06/01/1999 davidx
*       Created it.
*
* Notes:
*
*   We assume the pixels are on integer coordinates and
*   pixel area is centered around it. To scale a scanline
*   of s pixels to d pixels, we have the following equations:
*          x     |   y
*       -----------------
*         -0.5   |  -0.5
*        s - 0.5 | d - 0.5
*
*       y + 0.5   x + 0.5
*       ------- = -------
*         d         s
*
*   Forward mapping from source to destination coordinates:
*
*           d            d-s
*       y = - x + 0.5 * -----
*           s             s
*
*   Inverse mapping from destination to source coordinates:
*   
*           s            s-d
*       x = - y + 0.5 * -----
*           d             d
*
\**************************************************************************/

#include "precomp.hpp"


/**************************************************************************\
*
* Function Description:
*
*   GpBitmapScaler constructor / destructor
*
* Arguments:
*
*   dstsink - Destination sink for the scaler
*   dstwidth, dstheight - Destination dimension
*   interp - Interpolation method
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

GpBitmapScaler::GpBitmapScaler(
    IImageSink* dstsink,
    UINT dstwidth,
    UINT dstheight,
    InterpolationHint interp
    )
{
    this->dstSink = dstsink;
    dstsink->AddRef();

    this->dstWidth = dstwidth;
    this->dstHeight = dstheight;

    // Default to bilinear interpolation

    if (interp < INTERP_NEAREST_NEIGHBOR || interp > INTERP_BICUBIC)
        interp = INTERP_BILINEAR;

    interpX = interpY = interp;

    dstBand = OSInfo::VAllocChunk / dstWidth;

    if (dstBand < 4)
        dstBand = 4;

    cachedDstCnt = cachedDstRemaining = 0;
    cachedDstNext = NULL;
    tempSrcBuf = tempDstBuf = NULL;
    tempSrcLines = tempDstSize = 0;
    m_fNeedToPremultiply = false;

    SetValid(FALSE);
}

GpBitmapScaler::~GpBitmapScaler()
{
    ASSERT(cachedDstCnt == 0);

    dstSink->Release();
    if (NULL != tempSrcBuf)
    {
        GpFree(tempSrcBuf);
    }
    if (NULL != tempDstBuf)
    {
        GpFree(tempDstBuf);
    }

    SetValid(FALSE);    // so we don't use a deleted object
}


/**************************************************************************\
*
* Function Description:
*
*   Begin sinking source image data into the bitmap scaler
*
* Arguments:
*
*   imageInfo - For negotiating data transfer parameters with the source
*   subarea - For returning subarea information
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpBitmapScaler::BeginSink(
    IN OUT ImageInfo* imageInfo,
    OUT OPTIONAL RECT* subarea
    )
{
    ImageInfo tempinfo;
    HRESULT hr;

    // Whistler Bug 191203 - For scaling results to be correct you need to
    // do it in pre-multiplied space. Our scaler only works on 32 BPP data,
    // but didn't care about whether or not it was pre-multiplied.
    //
    // KLUDGE ALERT!
    // All of the V1 codecs will produce ARGB data (not pre-multiplied).
    // So we will fool the code, by saying it is PARGB, and we will do the
    // the premultiplying step right before we push the data into the scaler.
    // The exception to this is RGB formats that have no alpha as they are
    // pre-multiplied by default.
    //
    // In V2 we should address this problem properly. - JBronsk
    //
    // Note: We don't have CMYK as a color format. But if an image is in
    // CMYK color space and it contains an ICM color profile for CMYK to RGB
    // conversion, the lower level codec will return the data in its native
    // format, that is CMYK, while it still claims it is ARGB. In this case,
    // we CANNOT do premultiply since the channels are really CMYK not ARGB.
    // But there is one kind of CMYK JPEG which will set IMGFLAG_COLORSPACE_CMYK
    // and it is still in 24 RGB mode.
    // So: !(  ((imageInfo->Flags & IMGFLAG_COLORSPACE_CMYK)
    //      ==IMGFLAG_COLORSPACE_CMYK)&&(GetPixelFormatSize(pixelFormat) == 32))
    // means if the source image format is CMYK and its pixel size is 32, then
    // we don't need to do a pre-multiply. See Windows bug# 412605
    // Here we have another not perfect case, that is, if the source image is
    // in CMYK space. But it doesn't have ICM profile. So the lower level codec
    // will convert it to RGB and fill the alpha bits as ff. It returns the
    // format as ARGB. Though we might miss the following premultiply case, it
    // is OK since premultiply doesn't have any effect for alpha = 0xff.

    pixelFormat = imageInfo->PixelFormat;
    if ((pixelFormat != PIXFMT_32BPP_RGB) && // if not 32 BPP and pre-multipled
	    (pixelFormat != PIXFMT_32BPP_PARGB) &&
        (!(((imageInfo->Flags & IMGFLAG_COLORSPACE_CMYK)==IMGFLAG_COLORSPACE_CMYK)&&
           (GetPixelFormatSize(pixelFormat) == 32))) )
    {
	    if ((pixelFormat != PixelFormat16bppRGB555) &&
		    (pixelFormat != PixelFormat16bppRGB565) &&
		    (pixelFormat != PixelFormat48bppRGB) &&
		    (pixelFormat != PixelFormat24bppRGB))
	    {
		    m_fNeedToPremultiply = true; // pre-multiply if required
	    }
	    pixelFormat = PIXFMT_32BPP_PARGB; // set format to pre-multiplied
    }

    srcWidth = imageInfo->Width;
    srcHeight = imageInfo->Height;

    BOOL partialScaling;
    
    partialScaling = (imageInfo->Flags & SINKFLAG_PARTIALLY_SCALABLE) &&
                     (imageInfo->Width != (UINT) dstWidth ||
                      imageInfo->Height != (UINT) dstHeight);

    if (partialScaling)
    {
        imageInfo->Width = dstWidth;
        imageInfo->Height = dstHeight;
    }
    else
    {
        imageInfo->Flags &= ~SINKFLAG_PARTIALLY_SCALABLE;

        tempinfo.RawDataFormat = IMGFMT_MEMORYBMP;
        tempinfo.PixelFormat = pixelFormat;
        tempinfo.Width = dstWidth;
        tempinfo.Height = dstHeight;
        tempinfo.Xdpi = imageInfo->Xdpi * dstWidth / srcWidth;
        tempinfo.Ydpi = imageInfo->Ydpi * dstHeight / srcHeight;
        tempinfo.TileWidth = dstWidth;
        tempinfo.TileHeight = dstBand;

        tempinfo.Flags = SINKFLAG_TOPDOWN | 
                         SINKFLAG_FULLWIDTH |
                         (imageInfo->Flags & SINKFLAG_HASALPHA);

        // Negotiate with the destination sink

        hr = dstSink->BeginSink(&tempinfo, NULL);

        if (FAILED(hr))
            return hr;
        
        dstBand = tempinfo.TileHeight;

        if (tempinfo.Flags & SINKFLAG_WANTPROPS)
            imageInfo->Flags |= SINKFLAG_WANTPROPS;

        // We expect the destination sink to support 32bpp ARGB

        pixelFormat = tempinfo.PixelFormat;
        ASSERT(GetPixelFormatSize(pixelFormat) == 32);
    }

    imageInfo->PixelFormat = pixelFormat;
    imageInfo->RawDataFormat = IMGFMT_MEMORYBMP;

    imageInfo->Flags = (imageInfo->Flags & 0xffff) |
                        SINKFLAG_TOPDOWN |
                        SINKFLAG_FULLWIDTH;

    if (subarea)
    {
        subarea->left = subarea->top = 0;
        subarea->right = imageInfo->Width;
        subarea->bottom = imageInfo->Height;
    }

    // Initialize internal states of the scaler object

    return partialScaling ? S_OK : InitScalerState();
}


/**************************************************************************\
*
* Function Description:
*
*   Initialize internal states of the scaler object
*     This should be called before each pass.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpBitmapScaler::InitScalerState()
{
    // Common initialization by all interpolation algorithms

    srcy = dsty = 0;
    xratio = (FIX16) ((double) srcWidth * FIX16_ONE / dstWidth);
    yratio = (FIX16) ((double) srcHeight * FIX16_ONE / dstHeight);
    invxratio = (FIX16) ((double) dstWidth * FIX16_ONE / srcWidth);
    invyratio = (FIX16) ((double) dstHeight * FIX16_ONE / srcHeight);

    // NOTE:
    // If source and destination dimensions are within
    // +/- 2% of each other, we'll just fall back to
    // nearest neighbor interpolation algorithm.

    if (abs(FIX16_ONE - xratio) <= FIX16_ONE/50)
        interpX = INTERP_NEAREST_NEIGHBOR;
    
    if (abs(FIX16_ONE - yratio) <= FIX16_ONE/50)
        interpY = INTERP_NEAREST_NEIGHBOR;

    // Algorithm specific initialization

    HRESULT hr;

    srcPadding = 4;

    switch (interpX)
    {
    case INTERP_BILINEAR:
        xscaleProc = ScaleLineBilinear;
        break;

    case INTERP_AVERAGING:

        // If scaling up in x-direction,
        //  substitute with bilinear interpolation

        if (dstWidth >= srcWidth)
            xscaleProc = ScaleLineBilinear;
        else
        {
            xscaleProc = ScaleLineAveraging;
            srcPadding = 0;
        }
        break;

    case INTERP_BICUBIC:
        xscaleProc = ScaleLineBicubic;
        break;

    default:
        srcPadding = 0;
        xscaleProc = ScaleLineNearestNeighbor;
        break;
    }

    switch (interpY)
    {
    case INTERP_BILINEAR:

        hr = InitBilinearY();
        break;

    case INTERP_AVERAGING:

        if (dstHeight >= srcHeight)
        {
            // Scaling up in y-direction
            //  substitute with bilinear interpolation

            hr = InitBilinearY();
        }
        else
        {
            // Scaling down in y-direction
            //  use averaging algorithm

            pushSrcLineProc = PushSrcLineAveraging;
            ystepFrac = yratio;

            // Allocate space for temporary accumulator buffer
            //  we use one 32-bit integer for each color component

            UINT size1 = ALIGN4(dstWidth * sizeof(ARGB));
            UINT size2 = 4*dstWidth*sizeof(DWORD);

            hr = AllocTempDstBuffer(size1+size2);
            
            if (SUCCEEDED(hr))
            {
                accbufy = (DWORD*) ((BYTE*) tempDstBuf + size1);
                memset(accbufy, 0, size2);
            }
        }
        break;

    case INTERP_BICUBIC:

        pushSrcLineProc = PushSrcLineBicubic;
        hr = AllocTempDstBuffer(4*dstWidth*sizeof(ARGB));

        if (SUCCEEDED(hr))
        {
            tempLines[0].buf = tempDstBuf;
            tempLines[1].buf = tempLines[0].buf + dstWidth;
            tempLines[2].buf = tempLines[1].buf + dstWidth;
            tempLines[3].buf = tempLines[2].buf + dstWidth;
            tempLines[0].current =
            tempLines[1].current =
            tempLines[2].current =
            tempLines[3].current = -1;

            ystepFrac = (yratio - FIX16_ONE) >> 1;
            ystep = ystepFrac >> FIX16_SHIFT;
            ystepFrac &= FIX16_MASK;
            UpdateExpectedTempLinesBicubic(ystep);
        }
        break;

    default:

        pushSrcLineProc = PushSrcLineNearestNeighbor;
        ystep = srcHeight >> 1;
        hr = AllocTempDstBuffer(dstWidth*sizeof(ARGB));
        break;
    }

    SetValid(SUCCEEDED(hr));
    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Allocate temporary memory buffer for holding destination scanlines
*
* Arguments:
*
*   size - Desired of the temporary destination buffer
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpBitmapScaler::AllocTempDstBuffer(
    INT size
    )
{
    if (size > tempDstSize)
    {
        if ( NULL != tempDstBuf )
        {
            GpFree(tempDstBuf);
        }

        tempDstBuf = (ARGB*) GpMalloc(size);
        tempDstSize = tempDstBuf ? size : 0;
    }

    return tempDstBuf ? S_OK : E_OUTOFMEMORY;
}


/**************************************************************************\
*
* Function Description:
*
*   End the sink process
*
* Arguments:
*
*   statusCode - Last status code
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpBitmapScaler::EndSink(
    HRESULT statusCode
    )
{
    HRESULT hr = FlushDstBand();

    if (FAILED(hr))
        statusCode = hr;

    return dstSink->EndSink(statusCode);
}


/**************************************************************************\
*
* Function Description:
*
*   Ask the sink to allocate pixel data buffer
*
* Arguments:
*
*   rect - Specifies the interested area of the bitmap
*   pixelFormat - Specifies the desired pixel format
*   lastPass - Whether this the last pass over the specified area
*   bitmapData - Returns information about pixel data buffer
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpBitmapScaler::GetPixelDataBuffer(
    IN const RECT* rect,
    IN PixelFormatID pixelFormat,
    IN BOOL lastPass,
    OUT BitmapData* bitmapData
    )
{
    // We only accept bitmap data in top-down banding order

    ASSERT(IsValid());
    ASSERT(rect->left == 0 && rect->right == srcWidth);
    ASSERT(rect->top < rect->bottom && rect->bottom <= srcHeight);
    ASSERT(srcy == rect->top);
    ASSERT(lastPass);

    // Allocate memory for holding source pixel data

    bitmapData->Width = srcWidth;
    bitmapData->Height = rect->bottom - rect->top;
    bitmapData->Reserved = 0;
    bitmapData->PixelFormat = this->pixelFormat;

    // NOTE: we pad two extra pixels on each end of the scanline

    bitmapData->Stride = (srcWidth + 4) * sizeof(ARGB);
    bitmapData->Scan0 = AllocTempSrcBuffer(bitmapData->Height);

    return bitmapData->Scan0 ? S_OK: E_OUTOFMEMORY;
}


/**************************************************************************\
*
* Function Description:
*
*   Give the sink pixel data and release data buffer
*
* Arguments:
*
*   bitmapData - Buffer filled by previous GetPixelDataBuffer call
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpBitmapScaler::ReleasePixelDataBuffer(
    IN const BitmapData* bitmapData
    )
{
    HRESULT hr;
    INT count = bitmapData->Height;
    ARGB* p = (ARGB*) bitmapData->Scan0;

    while (count--)
    {
 	    if (m_fNeedToPremultiply)
	    {
		    for (UINT i = 0; i < bitmapData->Width; i++)
		    {
			    p[i] = Premultiply(p[i]);
		    }
	    }

        if (srcPadding)
        {
            p[-2] = p[-1] = p[0];
            p[srcWidth] = p[srcWidth+1] = p[srcWidth-1];
        }

        hr = (this->*pushSrcLineProc)(p);
        srcy++;

        if (FAILED(hr))
            return hr;

        p = (ARGB*) ((BYTE*) p + bitmapData->Stride);
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Push pixel data into the bitmap scaler
*
* Arguments:
*
*   rect - Specifies the affected area of the bitmap
*   bitmapData - Info about the pixel data being pushed
*   lastPass - Whether this is the last pass over the specified area
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpBitmapScaler::PushPixelData(
    IN const RECT* rect,
    IN const BitmapData* bitmapData,
    IN BOOL lastPass
    )
{
    // We only accept bitmap data in top-down banding order

    ASSERT(IsValid());
    ASSERT(rect->left == 0 && rect->right == srcWidth);
    ASSERT(rect->top < rect->bottom && rect->bottom <= srcHeight);
    ASSERT(srcy == rect->top);
    ASSERT(lastPass);
    ASSERT(rect->right - rect->left == (INT) bitmapData->Width &&
           rect->bottom - rect->top == (INT) bitmapData->Height);

    HRESULT hr = S_OK;
    INT count = bitmapData->Height;
    ARGB* p = (ARGB*) bitmapData->Scan0;

    if (srcPadding == 0)
    {
        // If we don't need to pad source scanlines,
        // then we can use the source pixel data buffer directly

        while (count--)
        {
            if (m_fNeedToPremultiply)
            {
	            for (UINT i = 0; i < bitmapData->Width; i++)
	            {
		            p[i] = Premultiply(p[i]);
	            }
            }

            hr = (this->*pushSrcLineProc)(p);
            srcy++;

            if (FAILED(hr))
                break;

            p = (ARGB*) ((BYTE*) p + bitmapData->Stride);
        }
    }
    else
    {
        // Otherwise, we need to copy source pixel data into
        // a temporary buffer one scanline at a time.

        ARGB* buf = AllocTempSrcBuffer(1);

        if (buf == NULL)
            return E_OUTOFMEMORY;

        while (count--)
        {
            if (m_fNeedToPremultiply)
            {
	            for (UINT i = 0; i < bitmapData->Width; i++)
	            {
		            p[i] = Premultiply(p[i]);
	            }
            }

            ARGB* s = p;
            ARGB* d = buf;
            INT x = srcWidth;

            d[-2] = d[-1] = *s;

            while (x--)
                *d++ = *s++;

            d[0] = d[1] = s[-1];

            hr = (this->*pushSrcLineProc)(buf);
            srcy++;

            if (FAILED(hr))
                break;

            p = (ARGB*) ((BYTE*) p + bitmapData->Stride);
        }
    }

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Pass color palette to an image sink
*
* Arguments:
*
*   palette - Pointer to the color palette to be set
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpBitmapScaler::SetPalette(
    IN const ColorPalette* palette
    )
{
    // We don't have anything to do with color palettes.
    // Just pass it down stream to the destination sink.

    return dstSink->SetPalette(palette);
}


/**************************************************************************\
*
* Function Description:
*
*   Allocate temporary memory for holding source pixel data
*
* Arguments:
*
*   lines - How many source scanlines are needed
*
* Return Value:
*
*   Pointer to the temporary source buffer
*   NULL if there is an error
*
\**************************************************************************/

ARGB*
GpBitmapScaler::AllocTempSrcBuffer(
    INT lines
    )
{
    // NOTE: We leave two extra pixels at each end of the scanline

    if (lines > tempSrcLines)
    {
        if ( NULL != tempSrcBuf )
        {
            GpFree(tempSrcBuf);
        }
        tempSrcBuf = (ARGB*) GpMalloc((srcWidth + 4) * lines * sizeof(ARGB));

        if (!tempSrcBuf)
            return NULL;

        tempSrcLines = lines;
    }

    return tempSrcBuf + 2;
}


/**************************************************************************\
*
* Function Description:
*
*   Push a source scanline into the bitmap scaler
*       using nearest neighbor interpolation algorithm
*
* Arguments:
*
*   s - Pointer to source scanline pixel values
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

#define GETNEXTDSTLINE(d)                           \
        {                                           \
            if (cachedDstRemaining == 0)            \
            {                                       \
                hr = GetNextDstBand();              \
                if (FAILED(hr)) return hr;          \
            }                                       \
            cachedDstRemaining--;                   \
            d = (ARGB*) cachedDstNext;              \
            cachedDstNext += cachedDstData.Stride;  \
            dsty++;                                 \
        }
    
HRESULT
GpBitmapScaler::PushSrcLineNearestNeighbor(
    const ARGB* s
    )
{
    ystep += dstHeight;

    if (ystep < srcHeight)
        return S_OK;

    INT lines = ystep / srcHeight;
    ystep %= srcHeight;

    // Ask for pixel data buffer from the destination sink

    ARGB* d;
    HRESULT hr;
    
    GETNEXTDSTLINE(d);

    // Scale the source line

    (this->*xscaleProc)(d, s);

    // Replicate the scaled line, if necessary

    ARGB* p;

    if (cachedDstRemaining < --lines)
    {
        CopyMemoryARGB(tempDstBuf, d, dstWidth);
        p = tempDstBuf;
    }
    else
        p = d;

    while (lines--)
    {
        GETNEXTDSTLINE(d);
        CopyMemoryARGB(d, p, dstWidth);
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Scale one scanline using nearest neighbor interpolation algorithm
*
* Arguments:
*
*   d - Points to destination pixel buffer
*   s - Points to source pixel values
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpBitmapScaler::ScaleLineNearestNeighbor(
    ARGB* d,
    const ARGB* s
    )
{
    INT xstep = srcWidth >> 1;
    INT cx = srcWidth;

    while (cx--)
    {
        xstep += dstWidth;

        while (xstep >= srcWidth)
        {
            xstep -= srcWidth;
            *d++ = *s;
        }

        *s++;
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Push a source scanline into the bitmap scaler
*       using bilinear interpolation algorithm
*
* Arguments:
*
*   s - Pointer to source scanline pixel values
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpBitmapScaler::PushSrcLineBilinear(
    const ARGB* s
    )
{
    // Check if the current source line is useful

    if (srcy == tempLines[0].expected)
    {
        (this->*xscaleProc)(tempLines[0].buf, s);
        tempLines[0].current = srcy;
    }

    if (srcy == tempLines[1].expected)
    {
        (this->*xscaleProc)(tempLines[1].buf, s);
        tempLines[1].current = srcy;
    }

    // Emit destination scanline, if any

    while (dsty < dstHeight &&
           tempLines[1].current != -1 &&
           tempLines[0].current != -1)
    {

        // Ask for pixel data buffer from the destination sink

        ARGB* d;
        HRESULT hr;
        
        GETNEXTDSTLINE(d);

        // Linearly interpolate between two neighboring scanlines

        ARGB* s0 = tempLines[0].buf;
        ARGB* s1 = tempLines[1].buf;

        UINT w1 = ystepFrac >> 8;
        UINT w0 = 256 - w1;
        INT count = dstWidth;

        if (w1 == 0)
        {
            // Fast path: no interpolation necessary

            CopyMemoryARGB(d, s0, count);
        }

        #ifdef _X86_

        else if (OSInfo::HasMMX)
        {
            MMXBilinearScale(d, s0, s1, w0, w1, count);
        }

        #endif // _X86_

        else
        {
            // Normal case: interpolate two neighboring lines

            while (count--)
            {
                ARGB A00aa00gg, A00rr00bb;

                A00aa00gg = *s0++;
                A00rr00bb = A00aa00gg & 0x00ff00ff;
                A00aa00gg = (A00aa00gg >> 8) & 0x00ff00ff;

                ARGB B00aa00gg, B00rr00bb;

                B00aa00gg = *s1++;
                B00rr00bb = B00aa00gg & 0x00ff00ff;
                B00aa00gg = (B00aa00gg >> 8) & 0x00ff00ff;

                ARGB Caaaagggg, Crrrrbbbb;

                Caaaagggg = (A00aa00gg * w0 + B00aa00gg * w1);
                Crrrrbbbb = (A00rr00bb * w0 + B00rr00bb * w1) >> 8;

                *d++ = (Caaaagggg & 0xff00ff00) |
                       (Crrrrbbbb & 0x00ff00ff);
            }
        }

        // Update internal states

        ystepFrac += yratio;
        ystep += (ystepFrac >> FIX16_SHIFT);
        ystepFrac &= FIX16_MASK;
        UpdateExpectedTempLinesBilinear(ystep);
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Initial internal states for bilinear scaling in y-direction
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpBitmapScaler::InitBilinearY()
{
    pushSrcLineProc = PushSrcLineBilinear;

    HRESULT hr = AllocTempDstBuffer(2*dstWidth*sizeof(ARGB));

    if (SUCCEEDED(hr))
    {
        tempLines[0].buf = tempDstBuf;
        tempLines[1].buf = tempDstBuf + dstWidth;
        tempLines[0].current = 
        tempLines[1].current = -1;

        ystepFrac = (yratio - FIX16_ONE) >> 1;
        ystep = ystepFrac >> FIX16_SHIFT;
        ystepFrac &= FIX16_MASK;
        UpdateExpectedTempLinesBilinear(ystep);
    }

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Update the expected source line information for 
*   the y-direction of bilinear scaling
*
* Arguments:
*
*   line - The index of the active scanline
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpBitmapScaler::UpdateExpectedTempLinesBilinear(
    INT line
    )
{
    // Clamp to within range

    INT ymax = srcHeight-1;
    INT line0 = line < 0 ? 0 : line > ymax ? ymax : line;
    INT line1 = line+1 > ymax ? ymax : line+1;

    // Check if line0 is ready

    ARGB* p;

    if ((tempLines[0].expected = line0) != tempLines[0].current)
    {
        if (line0 == tempLines[1].current)
        {
            // switch line1 to line0

            tempLines[1].current = tempLines[0].current;
            tempLines[0].current = line0;

            p = tempLines[0].buf;
            tempLines[0].buf = tempLines[1].buf;
            tempLines[1].buf = p;
        }
        else
            tempLines[0].current = -1;
    }

    // Check if line1 is ready

    if ((tempLines[1].expected = line1) != tempLines[1].current)
    {
        if (line1 == tempLines[0].current)
        {
            // Copy line0 to line1
            //  this could happen at the bottom of the image

            tempLines[1].current = line1;
            CopyMemoryARGB(tempLines[1].buf, tempLines[0].buf, dstWidth);
        }
        else
            tempLines[1].current = -1;
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Scale one scanline using bilinear interpolation algorithm
*
* Arguments:
*
*   d - Points to destination pixel buffer
*   s - Points to source pixel values
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpBitmapScaler::ScaleLineBilinear(
    ARGB* d,
    const ARGB* s
    )
{
    ARGB* dend = d + dstWidth;
    INT count = dstWidth;
    FIX16 xstep;

    // Figure out initial sampling position in the source line

    xstep = (xratio - FIX16_ONE) >> 1;
    s += (xstep >> FIX16_SHIFT);
    xstep &= FIX16_MASK;

    // Loop over all destination pixels

    while (count--)
    {
        UINT w1 = xstep >> 8;
        UINT w0 = 256 - w1;

        ARGB A00aa00gg = s[0];
        ARGB A00rr00bb = A00aa00gg & 0x00ff00ff;
        A00aa00gg = (A00aa00gg >> 8) & 0x00ff00ff;

        ARGB B00aa00gg = s[1];
        ARGB B00rr00bb = B00aa00gg & 0x00ff00ff;
        B00aa00gg = (B00aa00gg >> 8) & 0x00ff00ff;

        ARGB Caaaagggg = A00aa00gg * w0 + B00aa00gg * w1;
        ARGB Crrrrbbbb = (A00rr00bb * w0 + B00rr00bb * w1) >> 8;

        *d++ = (Caaaagggg & 0xff00ff00) |
               (Crrrrbbbb & 0x00ff00ff);
        
        // Check if we need to move source pointer

        xstep += xratio;
        s += (xstep >> FIX16_SHIFT);
        xstep &= FIX16_MASK;
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Push a source scanline into the bitmap scaler
*       using averaging interpolation algorithm
*
* Arguments:
*
*   s - Pointer to source scanline pixel values
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpBitmapScaler::PushSrcLineAveraging(
    const ARGB* s
    )
{
    // This is only used for scaling down

    ASSERT(srcHeight >= dstHeight);

    if (dsty >= dstHeight)
        return S_OK;

    // Scale the current line horizontally

    (this->*xscaleProc)(tempDstBuf, s);
    s = tempDstBuf;

    INT count = dstWidth;
    DWORD* acc = accbufy;
    
    const BYTE *kptr = reinterpret_cast<const BYTE*>(s);

    if (ystepFrac > FIX16_ONE)
    {
        // Consume the entire input scanline
        // without emit an output scanline

        while (count--)
        {
            // Consume the entire source pixel
            // without emitting a destination pixel
            acc[0] += (DWORD)(kptr[0]) << FIX16_SHIFT; 
            acc[1] += (DWORD)(kptr[1]) << FIX16_SHIFT; 
            acc[2] += (DWORD)(kptr[2]) << FIX16_SHIFT; 
            acc[3] += (DWORD)(kptr[3]) << FIX16_SHIFT; 
            
            acc += 4;
            kptr += 4;
        }

        ystepFrac -= FIX16_ONE;
    }
    else
    {
        // Emit an output scanline

        ARGB* d;
        HRESULT hr;
        
        GETNEXTDSTLINE(d);
        
        BYTE *dptr = reinterpret_cast<BYTE*>(d);
        BYTE *dend = reinterpret_cast<BYTE*>(d+dstWidth);

        BYTE a, r, g, b;
        DWORD t1, t2;

        while (count--)
        {
            t1 = kptr[0]; 
            t2 = t1 * ystepFrac;
            b = Fix16MulRoundToByte((acc[0] + t2), invyratio);
            acc[0] = (t1 << FIX16_SHIFT) - t2;
            
            t1 = kptr[1]; 
            t2 = t1 * ystepFrac;
            g = Fix16MulRoundToByte((acc[1] + t2), invyratio);
            acc[1] = (t1 << FIX16_SHIFT) - t2;
            
            t1 = kptr[2]; 
            t2 = t1 * ystepFrac;
            r = Fix16MulRoundToByte((acc[2] + t2), invyratio);
            acc[2] = (t1 << FIX16_SHIFT) - t2;
            
            t1 = kptr[3]; 
            t2 = t1 * ystepFrac;
            a = Fix16MulRoundToByte((acc[3] + t2), invyratio);
            acc[3] = (t1 << FIX16_SHIFT) - t2;

            kptr += 4;
            acc += 4;

            dptr[0] = b;
            dptr[1] = g;
            dptr[2] = r;
            dptr[3] = a;
            dptr += 4;
        }

        ystepFrac = yratio - (FIX16_ONE - ystepFrac);
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Scale one scanline using averaging interpolation algorithm
*
* Arguments:
*
*   d - Points to destination pixel buffer
*   s - Points to source pixel values
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpBitmapScaler::ScaleLineAveraging(
    ARGB* d,
    const ARGB* s
    )
{
    DWORD accA, accR, accG, accB;
    DWORD outfrac = xratio;
    const DWORD invx = invxratio;
    
    BYTE *dptr = reinterpret_cast<BYTE*>(d);
    BYTE *dend = reinterpret_cast<BYTE*>(d+dstWidth);
    const BYTE *kptr = reinterpret_cast<const BYTE*>(s);
    accA = accR = accG = accB = 0;

    for (;;)
    {
        if (outfrac > FIX16_ONE)
        {
            // Consume the entire source pixel
            // without emitting a destination pixel
            accB += (DWORD)(kptr[0]) << FIX16_SHIFT; 
            accG += (DWORD)(kptr[1]) << FIX16_SHIFT; 
            accR += (DWORD)(kptr[2]) << FIX16_SHIFT; 
            accA += (DWORD)(kptr[3]) << FIX16_SHIFT; 
            
            outfrac -= FIX16_ONE;
        }
        else
        {
            // Emit an output pixel

            BYTE a, r, g, b;
            DWORD t1, t2;


            t1 = kptr[0]; 
            t2 = t1 * outfrac;
            b = Fix16MulRoundToByte((accB + t2), invx);
            accB = (t1 << FIX16_SHIFT) - t2;
            
            t1 = kptr[1]; 
            t2 = t1 * outfrac;
            g = Fix16MulRoundToByte((accG + t2), invx);
            accG = (t1 << FIX16_SHIFT) - t2;
            
            t1 = kptr[2]; 
            t2 = t1 * outfrac;
            r = Fix16MulRoundToByte((accR + t2), invx);
            accR = (t1 << FIX16_SHIFT) - t2;
            
            t1 = kptr[3];
            t2 = t1 * outfrac;
            a = Fix16MulRoundToByte((accA + t2), invx);
            accA = (t1 << FIX16_SHIFT) - t2;


            dptr[0] = b;
            dptr[1] = g;
            dptr[2] = r;
            dptr[3] = a;
            dptr += 4;
            
            if (dptr == dend)
                break;

            outfrac = xratio - (FIX16_ONE - outfrac);
        }

        // Move on to the next source pixel

        kptr += 4;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Push a source scanline into the bitmap scaler
*       using bicubic interpolation algorithm
*
* Arguments:
*
*   s - Pointer to source scanline pixel values
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

// Cubic interpolation table

const FIX16 GpBitmapScaler::cubicCoeffTable[2*BICUBIC_STEPS+1] =
{
    65536, 65496, 65379, 65186, 64920, 64583, 64177, 63705,
    63168, 62569, 61911, 61195, 60424, 59600, 58725, 57802,
    56832, 55818, 54763, 53668, 52536, 51369, 50169, 48939,
    47680, 46395, 45087, 43757, 42408, 41042, 39661, 38268,
    36864, 35452, 34035, 32614, 31192, 29771, 28353, 26941,
    25536, 24141, 22759, 21391, 20040, 18708, 17397, 16110,
    14848, 13614, 12411, 11240, 10104,  9005,  7945,  6927,
     5952,  5023,  4143,  3313, 2536,  1814,  1149,   544,
        0,  -496,  -961, -1395, -1800, -2176, -2523, -2843,
    -3136, -3403, -3645, -3862, -4056, -4227, -4375, -4502,
    -4608, -4694, -4761, -4809, -4840, -4854, -4851, -4833,
    -4800, -4753, -4693, -4620, -4536, -4441, -4335, -4220,
    -4096, -3964, -3825, -3679, -3528, -3372, -3211, -3047,
    -2880, -2711, -2541, -2370, -2200, -2031, -1863, -1698,
    -1536, -1378, -1225, -1077, -936,  -802,  -675,  -557,
     -448,  -349,  -261,  -184, -120,   -69,   -31,    -8,
        0
};

HRESULT
GpBitmapScaler::PushSrcLineBicubic(
    const ARGB* s
    )
{
    // Check if the current source line is useful

    for (INT i=0; i < 4; i++)
    {
        if (srcy == tempLines[i].expected)
        {
            (this->*xscaleProc)(tempLines[i].buf, s);
            tempLines[i].current = srcy;
        }
    }

    if (tempLines[3].current == -1 ||
        tempLines[2].current == -1 ||
        tempLines[1].current == -1 ||
        tempLines[0].current == -1)
    {
        return S_OK;
    }

    // Emit destination scanline, if any

    while (dsty < dstHeight)
    {
        // Ask for pixel data buffer from the destination sink

        ARGB* d;
        HRESULT hr;
        
        GETNEXTDSTLINE(d);

        // Interpolate four neighboring scanlines

        INT x = ystepFrac >> (FIX16_SHIFT - BICUBIC_SHIFT);

        if (x == 0)
        {
            // Fast case: skip the interpolation

            CopyMemoryARGB(d, tempLines[1].buf, dstWidth);
        }
        
        #ifdef _X86_

        else if (OSInfo::HasMMX)
        {
            MMXBicubicScale(
                d,
                tempLines[0].buf,
                tempLines[1].buf,
                tempLines[2].buf,
                tempLines[3].buf,
                cubicCoeffTable[BICUBIC_STEPS+x],
                cubicCoeffTable[x],
                cubicCoeffTable[BICUBIC_STEPS-x],
                cubicCoeffTable[2*BICUBIC_STEPS-x],
                dstWidth);
        }

        #endif // _X86_

        else
        {
            // Interpolate scanlines

            FIX16 w0 = cubicCoeffTable[BICUBIC_STEPS+x];
            FIX16 w1 = cubicCoeffTable[x];
            FIX16 w2 = cubicCoeffTable[BICUBIC_STEPS-x];
            FIX16 w3 = cubicCoeffTable[2*BICUBIC_STEPS-x];

            const FIX16* p0 = (const FIX16*) tempLines[0].buf;
            const FIX16* p1 = (const FIX16*) tempLines[1].buf;
            const FIX16* p2 = (const FIX16*) tempLines[2].buf;
            const FIX16* p3 = (const FIX16*) tempLines[3].buf;

            for (x=0; x < dstWidth; x++)
            {
                FIX16 a, r, g, b;

                a = (w0 * ((p0[x] >> 24) & 0xff) +
                     w1 * ((p1[x] >> 24) & 0xff) +
                     w2 * ((p2[x] >> 24) & 0xff) +
                     w3 * ((p3[x] >> 24) & 0xff)) >> FIX16_SHIFT;

                a = (a < 0) ? 0 : (a > 255) ? 255 : a;

                r = (w0 * ((p0[x] >> 16) & 0xff) +
                     w1 * ((p1[x] >> 16) & 0xff) +
                     w2 * ((p2[x] >> 16) & 0xff) +
                     w3 * ((p3[x] >> 16) & 0xff)) >> FIX16_SHIFT;

                r = (r < 0) ? 0 : (r > 255) ? 255 : r;

                g = (w0 * ((p0[x] >> 8) & 0xff) +
                     w1 * ((p1[x] >> 8) & 0xff) +
                     w2 * ((p2[x] >> 8) & 0xff) +
                     w3 * ((p3[x] >> 8) & 0xff)) >> FIX16_SHIFT;

                g = (g < 0) ? 0 : (g > 255) ? 255 : g;

                b = (w0 * (p0[x] & 0xff) +
                     w1 * (p1[x] & 0xff) +
                     w2 * (p2[x] & 0xff) +
                     w3 * (p3[x] & 0xff)) >> FIX16_SHIFT;

                b = (b < 0) ? 0 : (b > 255) ? 255 : b;

                d[x] = (a << 24) | (r << 16) | (g << 8) | b;
            }
        }

        // Update internal states

        ystepFrac += yratio;
        ystep += (ystepFrac >> FIX16_SHIFT);
        ystepFrac &= FIX16_MASK;

        if (!UpdateExpectedTempLinesBicubic(ystep))
            break;
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Scale one scanline using bicubic interpolation algorithm
*
* Arguments:
*
*   d - Points to destination pixel buffer
*   s - Points to source pixel values
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpBitmapScaler::ScaleLineBicubic(
    ARGB* d,
    const ARGB* s
    )
{
    INT count = dstWidth;
    FIX16 xstep;

    // Figure out initial sampling position in the source line

    xstep = (xratio - FIX16_ONE) >> 1;
    s += (xstep >> FIX16_SHIFT);
    xstep &= FIX16_MASK;

    // Loop over all destination pixels

    while (count--)
    {
        INT x = xstep >> (FIX16_SHIFT - BICUBIC_SHIFT);
        FIX16 w0 = cubicCoeffTable[BICUBIC_STEPS+x];
        FIX16 w1 = cubicCoeffTable[x];
        FIX16 w2 = cubicCoeffTable[BICUBIC_STEPS-x];
        FIX16 w3 = cubicCoeffTable[2*BICUBIC_STEPS-x];

        const FIX16* p = (const FIX16*) s;
        FIX16 a, r, g, b;

        a = (w0 * ((p[-1] >> 24) & 0xff) +
             w1 * ((p[ 0] >> 24) & 0xff) +
             w2 * ((p[ 1] >> 24) & 0xff) +
             w3 * ((p[ 2] >> 24) & 0xff)) >> FIX16_SHIFT;

        a = (a < 0) ? 0 : (a > 255) ? 255 : a;

        r = (w0 * ((p[-1] >> 16) & 0xff) +
             w1 * ((p[ 0] >> 16) & 0xff) +
             w2 * ((p[ 1] >> 16) & 0xff) +
             w3 * ((p[ 2] >> 16) & 0xff)) >> FIX16_SHIFT;

        r = (r < 0) ? 0 : (r > 255) ? 255 : r;

        g = (w0 * ((p[-1] >> 8) & 0xff) +
             w1 * ((p[ 0] >> 8) & 0xff) +
             w2 * ((p[ 1] >> 8) & 0xff) +
             w3 * ((p[ 2] >> 8) & 0xff)) >> FIX16_SHIFT;

        g = (g < 0) ? 0 : (g > 255) ? 255 : g;

        b = (w0 * (p[-1] & 0xff) +
             w1 * (p[ 0] & 0xff) +
             w2 * (p[ 1] & 0xff) +
             w3 * (p[ 2] & 0xff)) >> FIX16_SHIFT;

        b = (b < 0) ? 0 : (b > 255) ? 255 : b;

        *d++ = (a << 24) | (r << 16) | (g << 8) | b;

        // Check if we need to move source pointer

        xstep += xratio;
        s += (xstep >> FIX16_SHIFT);
        xstep &= FIX16_MASK;
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Update the expected source line information for
*   the y-direction of bicubic scaling
*
* Arguments:
*
*   line - The index of the active scanline
*
* Return Value:
*
*   TRUE if all there are enough source data to emit a destination line
*   FALSE otherwise
*
\**************************************************************************/

BOOL
GpBitmapScaler::UpdateExpectedTempLinesBicubic(
    INT line
    )
{
    BOOL ready = TRUE;
    INT y, ymax = srcHeight-1;
    line--;
    
    for (INT i=0; i < 4; i++)
    {
        // Clamp line index to within range

        y = (line < 0) ? 0 : line > ymax ? ymax : line;
        line++;

        if ((tempLines[i].expected = y) != tempLines[i].current)
        {
            for (INT j=i+1; j < 4; j++)
            {
                if (y == tempLines[j].current)
                    break;
            }

            if (j < 4)
            {
                if (y < ymax)
                {
                    ARGB* p = tempLines[i].buf;
                    tempLines[i].buf = tempLines[j].buf;
                    tempLines[j].buf = p;

                    tempLines[j].current = tempLines[i].current;
                }
                else
                {
                    CopyMemoryARGB(
                        tempLines[i].buf,
                        tempLines[j].buf,
                        dstWidth);
                }

                tempLines[i].current = y;
            }
            else
            {
                tempLines[i].current = -1;
                ready = FALSE;
            }
        }
    }

    return ready;
}


/**************************************************************************\
*
* Function Description:
*
*   Cache the next band of destination bitmap data
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpBitmapScaler::GetNextDstBand()
{
    ASSERT(dsty < dstHeight);

    HRESULT hr;

    // Make sure we flush the previously cached band 
    // to the destination sink.

    if (cachedDstCnt)
    {
        hr = dstSink->ReleasePixelDataBuffer(&cachedDstData);
        cachedDstCnt = cachedDstRemaining = 0;

        if (FAILED(hr))
            return hr;
    }

    // Now ask the destination for the next band

    INT h = min(dstBand, dstHeight-dsty);
    RECT rect = { 0, dsty, dstWidth, dsty+h };

    hr = dstSink->GetPixelDataBuffer(
                    &rect,
                    pixelFormat,
                    TRUE,
                    &cachedDstData);

    if (FAILED(hr))
        return hr;

    cachedDstCnt = cachedDstRemaining = h;
    cachedDstNext = (BYTE*) cachedDstData.Scan0;
    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Flush any cached destination bands
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpBitmapScaler::FlushDstBand()
{
    if (cachedDstRemaining != 0)
        WARNING(("Missing destination scanlines"));

    HRESULT hr;

    hr = cachedDstCnt == 0 ?
            S_OK :
            dstSink->ReleasePixelDataBuffer(&cachedDstData);

    cachedDstCnt = cachedDstRemaining = 0;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\api\resample.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   resample.hpp
*
* Abstract:
*
*   Bitmap scaler declarations 
*
* Revision History:
*
*   06/01/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _RESAMPLE_HPP
#define _RESAMPLE_HPP


class GpBitmapScaler : public IUnknownBase<IImageSink>
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagBitmapScaler : ObjectTagInvalid;
    }

public:

    // Constructor / destructor

    GpBitmapScaler(
        IImageSink* dstsink,
        UINT dstwidth,
        UINT dstheight,
        InterpolationHint interp = InterpolationHintDefault
        );

    ~GpBitmapScaler();

    // Begin the sink process

    STDMETHOD(BeginSink)(
        IN OUT ImageInfo* imageInfo,
        OUT OPTIONAL RECT* subarea
        );

    // End the sink process

    STDMETHOD(EndSink)(
        IN HRESULT statusCode
        );

    // Pass the color palette to the image sink

    STDMETHOD(SetPalette)(
        IN const ColorPalette* palette
        );

    // Ask the sink to allocate pixel data buffer

    STDMETHOD(GetPixelDataBuffer)(
        IN const RECT* rect,
        IN PixelFormatID pixelFormat,
        IN BOOL lastPass,
        OUT BitmapData* bitmapData
        );

    // Give the sink pixel data and release data buffer

    STDMETHOD(ReleasePixelDataBuffer)(
        IN const BitmapData* bitmapData
        );

    // Push pixel data

    STDMETHOD(PushPixelData)(
        IN const RECT* rect,
        IN const BitmapData* bitmapData,
        IN BOOL lastPass
        );

    // Push raw image data

    STDMETHOD(PushRawData)(
        IN const VOID* buffer,
        IN UINT bufsize
        )
    {
        return E_NOTIMPL;
    }

    STDMETHOD(NeedTransform)(
        OUT UINT* rotation
        )
    {
        return E_NOTIMPL;
    }

    STDMETHOD(NeedRawProperty)(void *pSRc)
    {
        // GpBitmapScaler can't handle raw property

        return E_FAIL;
    }
    
    STDMETHOD(PushRawInfo)(
        IN OUT void* info
        )
    {
        return E_NOTIMPL;
    }

    STDMETHOD(GetPropertyBuffer)(
        IN     UINT            uiTotalBufferSize,
        IN OUT PropertyItem**  ppBuffer
        )
    {
        return E_NOTIMPL;
    }

    STDMETHOD(PushPropertyItems)(
        IN UINT             numOfItems,
        IN UINT             uiTotalBufferSize,
        IN PropertyItem*    item,
        IN BOOL             fICCProfileChanged
        )
    {
        return E_NOTIMPL;
    }

private:

    typedef HRESULT (GpBitmapScaler::*YSCALEPROC)(const ARGB*);
    typedef VOID (GpBitmapScaler::*XSCALEPROC)(ARGB*, const ARGB*);

    typedef struct 
    {
        INT current;
        INT expected;
        ARGB* buf;
    } TEMPLINEINFO;


    IImageSink* dstSink;
    INT dstWidth, dstHeight, dstBand;
    InterpolationHint interpX, interpY;
    PixelFormatID pixelFormat;
    INT srcWidth, srcHeight;
    ARGB* tempSrcBuf;
    INT tempSrcLines;
    ARGB* tempDstBuf;
    INT tempDstSize;
    DWORD* accbufy;
    YSCALEPROC pushSrcLineProc;
    XSCALEPROC xscaleProc;
    INT ystep, srcy, dsty;
    FIX16 yratio, xratio, ystepFrac;
    FIX16 invyratio, invxratio;
    TEMPLINEINFO tempLines[4];
    INT srcPadding;
    BitmapData cachedDstData;
    INT cachedDstCnt, cachedDstRemaining;
    BYTE* cachedDstNext;
    bool m_fNeedToPremultiply;

    // Check if the scaler object is in a valid state

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagBitmapScaler) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid BitmapScaler");
        }
    #endif

        return (Tag == ObjectTagBitmapScaler);
    }

    // Push one source scanline into the bitmap scaler sink

    HRESULT PushSrcLineNearestNeighbor(const ARGB* s);
    HRESULT PushSrcLineBilinear(const ARGB* s);
    HRESULT PushSrcLineAveraging(const ARGB* s);
    HRESULT PushSrcLineBicubic(const ARGB* s);

    // Scale one scanine

    VOID ScaleLineNearestNeighbor(ARGB* d, const ARGB* s);
    VOID ScaleLineBilinear(ARGB* d, const ARGB* s);
    VOID ScaleLineAveraging(ARGB* d, const ARGB* s);
    VOID ScaleLineBicubic(ARGB* d, const ARGB* s);

    // Get buffer for next destination band

    HRESULT GetNextDstBand();
    HRESULT FlushDstBand();

    // Allocate temporary memory for holding source pixel data

    ARGB* AllocTempSrcBuffer(INT lines);
    HRESULT AllocTempDstBuffer(INT size);

    // Initialize internal states of the scaler object

    HRESULT InitScalerState();
    HRESULT InitBilinearY();
    VOID UpdateExpectedTempLinesBilinear(INT line);
    BOOL UpdateExpectedTempLinesBicubic(INT line);

    // Cubic interpolation table

    enum
    {
        BICUBIC_SHIFT = 6,
        BICUBIC_STEPS = 1 << BICUBIC_SHIFT
    };

    static const FIX16 cubicCoeffTable[2*BICUBIC_STEPS+1];
};

#endif // !_RESAMPLE_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\api\recolor.cpp ===
/**************************************************************************\
* 
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   recolor.cpp
*
* Abstract:
*
*   Recoloring operations.
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Function Description:
*
*   Flush any dirty state in the recoloring and recompute accelerations
*   if necessary.
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpRecolorObject::Flush()
{
    matrixType = MatrixNone;
    gammaLut = FALSE;

    if (!(validFlags & ValidNoOp))
    {
        if (validFlags & ValidMatrix)
        {
            BOOL DiagonalMatrix = TRUE;
            BOOL TranslateMatrix = TRUE;
            BOOL ZeroesAt3 = TRUE;
            UINT i, j;

            for (i = 0; (i < 5) && DiagonalMatrix; i++)
            {
                for (j = 0; (j < 5) && DiagonalMatrix; j++)
                {
                    if ((i != j) && (matrix.m[i][j] != 0.0))
                        DiagonalMatrix = FALSE;
                }
            }
            
            for (i = 0; (i < 4) && TranslateMatrix; i++)
            {
                for (j = 0; (j < 5) && TranslateMatrix; j++)
                {
                    if (((i==j) && (REALABS(matrix.m[i][j]-1.0f) >= REAL_EPSILON)) ||
                        ((i!=j) && (REALABS(matrix.m[i][j]) >= REAL_EPSILON)))
                    {
                        TranslateMatrix = FALSE;
                    }
                }
            }
            
            if(TranslateMatrix)
            {
                matrixType = MatrixTranslate;
            }
            else
            {              
                // If the alpha channel diagonal is zero, we *must* perform
                // alpha channel recoloring because the image is becoming
                // fully transparent.
                
                if (DiagonalMatrix)
                {
                    // If it's a diagonal matrix and the alpha channel scale
                    // factor is 1, we can use a 3 channel scale.
    
                    if ( REALABS(matrix.m[3][3]-1.0f) >= REAL_EPSILON )
                    {
                        ZeroesAt3 = FALSE;
                    }
                }
                else
                {
                    for (i = 0; (i < 5) && ZeroesAt3; i++)
                    {
                        if( i == 3 )
                        {
                            // The alpha channel scale component on the main
                            // diagonal must be 1.0
                                                
                            if(REALABS(matrix.m[3][3]-1.0f) >= REAL_EPSILON) {
                                ZeroesAt3 = FALSE;
                                break;
                            }
                        }
                        else if (( REALABS(matrix.m[i][3]) >= REAL_EPSILON) || 
                                 ( REALABS(matrix.m[3][i]) >= REAL_EPSILON))
                        {
                            // All of the matrix elements that contribute alpha
                            // channel stuff must be zero (exception above).
                            
                            ZeroesAt3 = FALSE;
                            break;
                        }
                    }
                }
    
                if (DiagonalMatrix)
                {
                    if (ZeroesAt3)
                    {
                        matrixType = MatrixScale3;
                    }
                    else
                    {
                        matrixType = MatrixScale4;
                    }
    
                }
                else
                {
                    if (ZeroesAt3)
                    {
                        matrixType = Matrix4x4;
                    }
                    else
                    {
                        matrixType = Matrix5x5;
                    }
                }
            }
        }
        else
        {
            matrixType = MatrixNone;
        }

        ComputeLuts();
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Initialize the recoloring lookup tables
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpRecolorObject::ComputeLuts()
{
    // Lookup table to handle scaling-only default color matrix:

    if ((matrixType == MatrixScale3) || (matrixType == MatrixScale4))
    {
        {
            REAL scaleR = matrix.m[0][0];
            REAL scaleG = matrix.m[1][1];
            REAL scaleB = matrix.m[2][2];
            REAL scaleA;
            
            if (matrixType == MatrixScale4)
            {
                scaleA = matrix.m[3][3];
            }
            else
            {
                scaleA = 1.0f;
            }

            for (INT i = 0; i < 256; i++)
            {
                lutR[i] = (BYTE) ((REAL) i * scaleR);
                lutG[i] = (BYTE) ((REAL) i * scaleG);
                lutB[i] = (BYTE) ((REAL) i * scaleB);
                lutA[i] = (BYTE) ((REAL) i * scaleA);
            }
        }
    }

    // Lookup table to handle the gray scale matrix:

    if (validFlags & ValidGrayMatrix)
    {
        for (UINT index = 0; index < 256; index++)
        {
            Color gray(static_cast<BYTE>(index), 
                       static_cast<BYTE>(index), 
                       static_cast<BYTE>(index));

            grayMatrixLUT[index] = gray.GetValue();
        }
        TransformColor5x5(grayMatrixLUT, 256, matrixGray);
    }

    // Lookup tables to handle gamma correction and bileveling:

    UINT maskedFlags = validFlags & (ValidGamma | ValidBilevel);

    gammaLut = (maskedFlags != 0);
    if(!gammaLut) return;

    if (maskedFlags == ValidGamma)
    {
        // Just gamma

        for (INT i=0; i < 256; i++)
            lut[i] = (BYTE) (pow(i / 255.0, extraGamma) * 255);
    }
    else if (maskedFlags == ValidBilevel)
    {
        // Just threshold

        BYTE threshold = static_cast<BYTE>(GpCeiling(bilevelThreshold * 255.0f));

        for (INT i=0; i < 256; i++)
        {
            if (i < threshold)
                lut[i] = 0;
            else
                lut[i] = 255;
        }
    }
    else
    {
        // Both gamma and threshold

        for (INT i=0; i < 256; i++)
        {
            if (pow(i / 255.0, extraGamma) < bilevelThreshold)
                lut[i] = 0;
            else
                lut[i] = 255;
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Perform color twist recoloring using the color matrix.
*   Use special handling of Grays if necessary
*
* Arguments:
*
*   pixbuf - Pointer to the pixel buffer to be operated on
*   count - Pixel count
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpRecolorObject::ComputeColorTwist(
    ARGB*               pixbufIn,
    UINT                countIn
    )
{
    ARGB* pixbuf;
    UINT  count;

    //QUAL: The result of the matrix is quantized to 8-bit so we can
    //      go through the LUT for the gamma/threshold operation.  For
    //      best results, the result of the matrix operation should
    //      be preserved and the gamma/threshold done it.
    //      For the special case of scaling, we can combine the
    //      LUTs rather than cascading for better accuracy and performance.

    pixbuf = pixbufIn;
    count  = countIn;

    switch(matrixType)
    {
    case MatrixNone:     
        // Nothing to do - handle the Gamma LUT after the switch
    break;

    case Matrix4x4:
    // !!! PERF [asecchia]
    // We don't have a 4x4 optimized codepath yet - fall through
    // to the general 5x5 transform.
    
    case Matrix5x5:
        if(matrixFlags == ColorMatrixFlagsDefault)
        {
            TransformColor5x5(pixbuf, count, matrix);
        }
        else
        {
            ASSERT((matrixFlags == ColorMatrixFlagsSkipGrays)||
                   (matrixFlags == ColorMatrixFlagsAltGray));            
            
            TransformColor5x5AltGrays(
                pixbuf, 
                count, 
                matrix, 
                matrixFlags == ColorMatrixFlagsSkipGrays
            );
        }
    break;

    case MatrixScale3:
    // !!! PERF [asecchia]
    // We don't have a scale 3 optimized codepath yet - fall through
    // to the more general scale 4 code.
    // The alpha LUT is set up to be the identity, so this will work.
    
    case MatrixScale4:
        if(matrixFlags == ColorMatrixFlagsDefault)
        {
            TransformColorScale4(pixbuf, count);
        }
        else
        {
            ASSERT((matrixFlags == ColorMatrixFlagsSkipGrays)||
                   (matrixFlags == ColorMatrixFlagsAltGray));            
            
            TransformColorScale4AltGrays(
                pixbuf, 
                count, 
                matrixFlags == ColorMatrixFlagsSkipGrays
            );
        }
        break;
        
    case MatrixTranslate:
        if(matrixFlags == ColorMatrixFlagsDefault)
        {
            TransformColorTranslate(pixbuf, count, matrix);
        }
        else
        {
            ASSERT((matrixFlags == ColorMatrixFlagsSkipGrays)||
                   (matrixFlags == ColorMatrixFlagsAltGray));            
            
            TransformColorTranslateAltGrays(
                pixbuf, 
                count, 
                matrix,
                matrixFlags == ColorMatrixFlagsSkipGrays
            );
        }
        break;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Perform point operation on an array of 32bpp pixels
*
* Arguments:
*
*   pixbuf - Pointer to the pixel buffer to be operated on
*   count - Pixel count
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpRecolorObject::ColorAdjust(
    ARGB*               pixbufIn,
    UINT                countIn
    )
{
    ARGB* pixbuf;
    UINT  count;

    // Do LUT remapping:

    if (validFlags & ValidRemap)
    {
        pixbuf = pixbufIn;
        count  = countIn;

        while (count--)
        {
            ARGB p = *pixbuf;

            ColorMap *currentMap = colorMap;
            ColorMap *endMap = colorMap + colorMapCount;

            for ( ; currentMap < endMap; currentMap++)
            {
                if (p == currentMap->oldColor.GetValue())
                {
                    *pixbuf = currentMap->newColor.GetValue();
                    break;
                }
            }

            pixbuf++;
        }
    }

    // Do transparancy color keys:

    if (validFlags & ValidColorKeys)
    {
        pixbuf = pixbufIn;
        count  = countIn;

        while (count--)
        {
            ARGB p = *pixbuf;

            if ((((p      ) & 0xff) >=  colorKeyLow.GetBlue() ) &&
                (((p      ) & 0xff) <= colorKeyHigh.GetBlue() ) &&
                (((p >>  8) & 0xff) >=  colorKeyLow.GetGreen()) &&
                (((p >>  8) & 0xff) <= colorKeyHigh.GetGreen()) &&
                (((p >> 16) & 0xff) >=  colorKeyLow.GetRed()  ) &&
                (((p >> 16) & 0xff) <= colorKeyHigh.GetRed()  ))
            {
                *pixbuf = p & 0x00ffffff;
            }
            pixbuf++;
        }
    }

    // Do color twist

    ComputeColorTwist(pixbufIn, countIn);

    // Do the gamma and thresholding.
        
    if (gammaLut)
    {
        TransformColorGammaLUT(pixbufIn, countIn);
    }

    // CMYK Channel output handling:

    if ( validFlags & ValidOutputChannel )
    {
        DoCmykSeparation(pixbufIn, countIn);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Perform CMYK separation.
*
* Arguments:
*
*   pixbuf - Pointer to the pixel buffer to be processed
*   count - Pixel count
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpRecolorObject::DoCmykSeparation(
    ARGB* pixbuf,
    UINT  count
    )
{
    switch (CmykState)
    {
    case CmykByICM:
        DoCmykSeparationByICM(pixbuf, count);
        break;

#ifdef CMYK_INTERPOLATION_ENABLED
    case CmykByInterpolation:
        DoCmykSeparationByInterpolation(pixbuf, count);
        break;
#endif

    case CmykByMapping:
    default:
        DoCmykSeparationByMapping(pixbuf, count);
        break;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Perform CMYK separation by using ICM2.0 "outside of DC" functions.
*
* Arguments:
*
*   pixbuf - Pointer to the pixel buffer to be processed
*   count - Pixel count
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpRecolorObject::DoCmykSeparationByICM(
    ARGB* pixbuf,
    UINT  count
    )
{
    ASSERT(transformSrgbToCmyk != NULL);

    // Translate from sRGB to CMYK.  Only one scanline (plus as ARGB
    // scanline is already DWORD aligned), so we can let ICM compute
    // default stride.

    if ((*pfnTranslateBitmapBits)(
            transformSrgbToCmyk,
            pixbuf,
            BM_xRGBQUADS,
            count,
            1,
            0,
            pixbuf,
            BM_CMYKQUADS,
            0,
            NULL,
            NULL))
    {
        ULONG channelMask;
        ULONG channelShift;

        // Replicate the chosen channel to each of the destination
        // channels (negative image, since separation is being done
        // for output to a separation plate).  For example, if
        // ColorChannelFlagsM is specified, make each pixel equal
        // to (255, 255-Magenta, 255-Magenta, 255-Magenta).

        switch (ChannelIndex)
        {
        case ColorChannelFlagsC:
            channelMask = 0xff000000;
            channelShift = 24;
            break;

        case ColorChannelFlagsM:
            channelMask = 0x00ff0000;
            channelShift = 16;
            break;

        case ColorChannelFlagsY:
            channelMask = 0x0000ff00;
            channelShift = 8;
            break;

        default:
        case ColorChannelFlagsK:
            channelMask = 0x000000ff;
            channelShift = 0;
            break;
        }

        while (count--)
        {
            BYTE c = 255 - (BYTE)((*pixbuf & channelMask) >> channelShift);
            *pixbuf++ = MAKEARGB(255, c, c, c);
        }
    }
}

#ifdef CMYK_INTERPOLATION_ENABLED
/**************************************************************************\
*
* Function Description:
*
*   Perform CMYK separation using a tetrahedral interpolation.
*
* Arguments:
*
*   pixbuf - Pointer to the pixel buffer to be processed
*   count - Pixel count
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpRecolorObject::DoCmykSeparationByInterpolation(
    ARGB* pixbuf,
    UINT  count
    )
{
    ASSERT((interpSrgbToCmyk != NULL) && interpSrgbToCmyk->IsValid());

    UINT uiChannel;

    // Figure out the channel index

    switch ( ChannelIndex )
    {
    case ColorChannelFlagsC:
        uiChannel = 0;
        break;

    case ColorChannelFlagsM:
        uiChannel = 1;
        break;

    case ColorChannelFlagsY:
        uiChannel = 2;
        break;

    default:
    case ColorChannelFlagsK:
        uiChannel = 3;
        break;
    }

    BYTE cTemp[4];

    while (count--)
    {
        interpSrgbToCmyk->Transform((BYTE *) pixbuf, cTemp);

        *pixbuf++ = MAKEARGB(255,
                             255 - cTemp[uiChannel],
                             255 - cTemp[uiChannel],
                             255 - cTemp[uiChannel]);
    }
}
#endif

/**************************************************************************\
*
* Function Description:
*
*   Perform CMYK separation using a simple mapping:
*
*       C' = 1 - R
*       M' = 1 - G
*       Y' = 1 - B
*       K  = min(C, M, Y)
*       C  = C' - K
*       Y  = Y' - K
*       M  = M' - K
*
* Arguments:
*
*   pixbuf - Pointer to the pixel buffer to be processed
*   count - Pixel count
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpRecolorObject::DoCmykSeparationByMapping(
    ARGB* pixbuf,
    UINT  count
    )
{
    UINT uiChannel;

    // Figure out the channel index

    switch ( ChannelIndex )
    {
    case ColorChannelFlagsC:
        uiChannel = 0;

        break;

    case ColorChannelFlagsM:
        uiChannel = 1;

        break;

    case ColorChannelFlagsY:
        uiChannel = 2;

        break;

    case ColorChannelFlagsK:
        uiChannel = 3;

        break;

    default:
        // Invalid channel requirement

        return;
    }

    BYTE    cTemp[4];

    while ( count-- )
    {
        ARGB p = *pixbuf;

        // Get C, M, Y from 1 - R, 1 - G and 1 - B, respectively

        cTemp[0] = 255 - (BYTE)((p & 0x00ff0000) >> 16);    // C
        cTemp[1] = 255 - (BYTE)((p & 0x0000ff00) >> 8);     // M
        cTemp[2] = 255 - (BYTE)(p & 0x000000ff);            // Y

        // K = min(C, M, Y)

        cTemp[3] = cTemp[0];                                // K

        if ( cTemp[3] > cTemp[1] )
        {
            cTemp[3] = cTemp[1];
        }

        if ( cTemp[3] > cTemp[2] )
        {
            cTemp[3] = cTemp[2];
        }

        // C = C - K, M = M - K, Y = Y - K. But here we only need to
        // calculate the required channel. If required channel is K, then
        // we don't need to do any calculation

        if ( uiChannel < 3 )
        {
            cTemp[uiChannel] = cTemp[uiChannel] - cTemp[3];
        }

        // Compose the output channel (Note: negative image since the
        // separation is intended to go to a separation plate).

        *pixbuf++ = MAKEARGB(255,
                             255 - cTemp[uiChannel],
                             255 - cTemp[uiChannel],
                             255 - cTemp[uiChannel]);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Setup the state needed to do sRGB to CMYK conversion.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Can be one of the following values:
*
*       CmykBySimple
*           Setup to do conversion by simple mapping, DoSimpleCmykSeparation
*
*       CmykByICM
*           Setup to do conversion via ICM 2.0, DoIcmCmykSeparation
*
*       CmykByInterpolation
*           Setup to do conversion via tetrahedral interpolation,
*           DoInterpolatedCmykSeparation
*
\**************************************************************************/

#ifdef CMYK_INTERPOLATION_ENABLED
// Bring in the big sRGB to CMYK table

#include "srgb2cmyk.h"
#endif

HRESULT
GpRecolorObject::SetupCmykSeparation(WCHAR *profile)
{
    HRESULT hr = E_INVALIDARG;

    if (profile)
    {
        // First try ICM:

        hr = LoadICMDll();
        if (SUCCEEDED(hr))
        {
            HTRANSFORM transform;
            HPROFILE colorProfs[2];
            WCHAR *profileName;

            UINT profileSize = sizeof(WCHAR) * (UnicodeStringLength(profile) + 1);
            profileName = (WCHAR *) GpMalloc(profileSize);

            if (profileName)
            {
                UnicodeStringCopy(profileName, profile);

                // Setup source profile (assumes source is sRGB):

                PROFILE srgbProfile;
                char srgbProfileName[40] = "sRGB Color Space Profile.icm";
                srgbProfile.dwType = PROFILE_FILENAME;
                srgbProfile.pProfileData = srgbProfileName;
                srgbProfile.cbDataSize = 40;

                colorProfs[0] = (*pfnOpenColorProfile)(&srgbProfile,
                                                       PROFILE_READ,
                                                       FILE_SHARE_READ,
                                                       OPEN_EXISTING);

                // Setup destination CMYK profile:

                PROFILE cmykProfile;
                cmykProfile.dwType = PROFILE_FILENAME;
                cmykProfile.pProfileData = profileName;
                cmykProfile.cbDataSize = profileSize;

                colorProfs[1] = (*pfnOpenColorProfileW)(&cmykProfile,
                                                        PROFILE_READ,
                                                        FILE_SHARE_READ,
                                                        OPEN_EXISTING);

                // Assume failure:

                hr = E_INVALIDARG;

                if ((colorProfs[0] != NULL) && (colorProfs[1] != NULL))
                {
                    // Create color transform:

                    DWORD intents[2] = {INTENT_PERCEPTUAL, INTENT_PERCEPTUAL};

                    transform =
                        (*pfnCreateMultiProfileTransform)(colorProfs,
                                                          2,
                                                          intents,
                                                          2,
                                                          BEST_MODE |
                                                          USE_RELATIVE_COLORIMETRIC,
                                                          0);
                    if (transform != NULL)
                    {
                        // Replace current ICM separation info with the new stuff:

                        CleanupCmykSeparation();
                        transformSrgbToCmyk = transform;
                        profiles[0] = colorProfs[0];
                        profiles[1] = colorProfs[1];
                        cmykProfileName = profileName;

                        CmykState = CmykByICM;

                        hr = S_OK;
                    }
                }

                // If not successful, cleanup:

                if (FAILED(hr))
                {
                    // Cleanup the temp ICM separation info:

                    if (colorProfs[0] != NULL)
                        (*pfnCloseColorProfile)(colorProfs[0]);

                    if (colorProfs[1] != NULL)
                        (*pfnCloseColorProfile)(colorProfs[1]);

                    if (profileName != NULL)
                        GpFree(profileName);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

        }
        else
        {
            hr = E_FAIL;
        }

#ifdef CMYK_INTERPOLATION_ENABLED
        // If ICM failed, try setting up for interpolation

        if (CmykState == CmykByMapping)
        {
            interpSrgbToCmyk = new K2_Tetrahedral(SrgbToCmykTable, 17, 3, 4);

            if (interpSrgbToCmyk)
            {
                if (interpSrgbToCmyk->IsValid())
                {
                    CmykState = CmykByInterpolation;
                    hr = S_OK;
                }
                else
                {
                    CleanupCmykSeparation();
                }
            }
        }
#endif
    }

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   Cleanup state setup by SetupCmykSeparation.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpRecolorObject::CleanupCmykSeparation()
{
    if (transformSrgbToCmyk)
    {
        (*pfnDeleteColorTransform)(transformSrgbToCmyk);
        transformSrgbToCmyk = NULL;
    }

    if (profiles[0] != NULL)
    {
        (*pfnCloseColorProfile)(profiles[0]);
        profiles[0] = NULL;
    }

    if (profiles[1] != NULL)
    {
        (*pfnCloseColorProfile)(profiles[1]);
        profiles[1] = NULL;
    }

#ifdef CMYK_INTERPOLATION_ENABLED
    if (interpSrgbToCmyk)
    {
        delete interpSrgbToCmyk;
        interpSrgbToCmyk = NULL;
    }
#endif

    if (cmykProfileName != NULL)
    {
        GpFree(cmykProfileName);
        cmykProfileName = NULL;
    }

    CmykState = CmykByMapping;
}

#ifdef CMYK_INTERPOLATION_ENABLED
//==============================================================================

inline
int K2_Tetrahedral::addshift(int x)  
{
    return ( 17*( 17*((x & 0x0004) >> 2) + ((x & 0x0002) >> 1) ) + (x & 0x0001) );
}

K2_Tetrahedral::K2_Tetrahedral(BYTE *tbl, int tableDim, int inDim, int outDim)
{
    int i, j, tableSize = 0;

    // Currently only need sRGB to CMYK conversion, so we can assume inDim==3
    // and outDim==4.
    //ASSERT((inDim==3) || (inDim==4));
    ASSERT(inDim==3);

    ASSERT(tableDim == 17);

    for (i=0; i<K2_TETRAHEDRAL_MAX_TABLES; i++)
    {
        table[i] = NULL;
    }

    inDimension = inDim;
    outDimension = outDim;
    tableDimension = tableDim;

    if (inDimension == 3)
        tableSize = 17*17*17;
    if (inDimension == 4)
        tableSize = 17*17*17*17;

    UINT *tableBuffer = (UINT *) GpMalloc(sizeof(UINT) * tableSize * outDimension);

    if (tableBuffer)
    {
        for (i=0; i<outDimension; i++)
        {
            table[i] = tableBuffer + (tableSize * i);

            for (j=0; j<tableSize; j++)
            {
                table[i][j] = (*tbl++);
            }
        }

        valid = TRUE;
    }
    else
    {
        WARNING(("K2_Tetrahedral - unable to allocate memory"));
        valid = FALSE;
    }
}

K2_Tetrahedral::~K2_Tetrahedral()
{
    if (table[0])
        GpFree(table[0]);

    SetValid(FALSE);    // so we don't use a deleted object
}

inline
void K2_Tetrahedral::Transform (BYTE *in, BYTE *out)
{
    unsigned int *tbl, r1, r2;
    register int  a, b, c;
    register char v0, v1, v2, v3;
    register char v1_and_v0, v2_and_v1, v3_and_v2;
    register char v1_or_v0,  v2_or_v1,  v3_or_v2;
    register char v2_and_v1_and_v0, v3_or_v2_or_v1_or_v0;
    register char v2_and_v1_or_v0,  v3_or_v2_or_v1_and_v0;
    register char v2_or_v1_and_v0,  v3_or_v2_and_v1_or_v0;
    register char v2_or_v1_or_v0,   v3_or_v2_and_v1_and_v0;
    register char v3_and_v2_and_v1, v3_and_v2_or_v1_or_v0;
    register char v3_and_v2_or_v1,  v3_and_v2_or_v1_and_v0;
    register char v3_or_v2_and_v1,  v3_and_v2_and_v1_or_v0;
    register char v3_or_v2_or_v1,   v3_and_v2_and_v1_and_v0;
    register int index0, index1, index2, index3, index4, index5, index6, index7;
    register int index8, index9, index10, index11, index12, index13, index14, index15;

    //a = (in[0] >= 0xF8) ? (int)in[0]+1 : (int)in[0];
    //b = (in[1] >= 0xF8) ? (int)in[1]+1 : (int)in[1];
    //c = (in[2] >= 0xF8) ? (int)in[2]+1 : (int)in[2];
    a = (in[2] >= 0xF8) ? (int)in[2]+1 : (int)in[2];
    b = (in[1] >= 0xF8) ? (int)in[1]+1 : (int)in[1];
    c = (in[0] >= 0xF8) ? (int)in[0]+1 : (int)in[0];

    // Compute slices across the input components
    v0 = ( (a & 0x01) << 2 ) + ( (b & 0x01) << 1 ) + ( (c & 0x01) );
    v1 = ( (a & 0x02) << 1 ) + ( (b & 0x02) )      + ( (c & 0x02) >> 1);
    v2 = ( (a & 0x04) )      + ( (b & 0x04) >> 1 ) + ( (c & 0x04) >> 2);
    v3 = ( (a & 0x08) >> 1 ) + ( (b & 0x08) >> 2 ) + ( (c & 0x08) >> 3);

    // Compute offset from origin
    v1_and_v0               = v1 & v0;
    v1_or_v0                = v1 | v0;
    v2_and_v1               = v2 & v1;
    v2_and_v1_and_v0        = v2 & v1_and_v0;
    v2_and_v1_or_v0         = v2 & v1_or_v0;
    v2_or_v1                = v2 | v1;
    v2_or_v1_and_v0         = v2 | v1_and_v0;
    v2_or_v1_or_v0          = v2 | v1_or_v0;
    v3_and_v2               = v3 & v2;
    v3_and_v2_and_v1        = v3 & v2_and_v1;
    v3_and_v2_and_v1_and_v0 = v3 & v2_and_v1_and_v0;
    v3_and_v2_and_v1_or_v0  = v3 & v2_and_v1_or_v0;
    v3_and_v2_or_v1         = v3 & v2_or_v1;
    v3_and_v2_or_v1_and_v0  = v3 & v2_or_v1_and_v0;
    v3_and_v2_or_v1_or_v0   = v3 & v2_or_v1_or_v0;
    v3_or_v2                = v3 | v2;
    v3_or_v2_and_v1         = v3 | v2_and_v1;
    v3_or_v2_and_v1_and_v0  = v3 | v2_and_v1_and_v0;
    v3_or_v2_and_v1_or_v0   = v3 | v2_and_v1_or_v0;
    v3_or_v2_or_v1          = v3 | v2_or_v1;
    v3_or_v2_or_v1_and_v0   = v3 | v2_or_v1_and_v0;
    v3_or_v2_or_v1_or_v0    = v3 | v2_or_v1_or_v0;

    // Generate indicies into table
    index0  = ( 17*17*(a>>4) ) + ( 17*(b>>4) ) + (c>>4);
    index1  = addshift(v3);
    index2  = addshift(v3_and_v2);
    index3  = addshift(v3_and_v2_and_v1);
    index4  = addshift(v3_and_v2_and_v1_and_v0);
    index5  = addshift(v3_and_v2_and_v1_or_v0);
    index6  = addshift(v3_and_v2_or_v1);
    index7  = addshift(v3_and_v2_or_v1_and_v0);
    index8  = addshift(v3_and_v2_or_v1_or_v0);
    index9  = addshift(v3_or_v2);
    index10 = addshift(v3_or_v2_and_v1);
    index11 = addshift(v3_or_v2_and_v1_and_v0);
    index12 = addshift(v3_or_v2_and_v1_or_v0);
    index13 = addshift(v3_or_v2_or_v1);
    index14 = addshift(v3_or_v2_or_v1_and_v0);
    index15 = addshift(v3_or_v2_or_v1_or_v0);

    // Compute output
    if (inDimension == 3)
    {
        for (int i=0; i<outDimension; i++)
        {
            tbl = table[i] + index0;

            r1 = (tbl[0] + tbl[index1] + tbl[index2] + tbl[index3] +
                  tbl[index4] + tbl[index5] + tbl[index6] + tbl[index7] +
                  tbl[index8] + tbl[index9] + tbl[index10] + tbl[index11] +
                  tbl[index12] + tbl[index13] + tbl[index14] + tbl[index15] +
                  0x08 ) >> 4;

            if (r1 > 255)
                out[i] = (BYTE) 255;
            else
                out[i] = (BYTE) r1;
        }
    }
    else if (inDimension == 4)
    {
        // 4D interpolator (linearly interpolate on 4th dimension)

        unsigned int kindex, koffset1, koffset2;
        double fraction, ip, r;

        kindex   = in[3] >> 4;
        koffset1 = 17*17*17 * kindex;
        koffset2 = 17*17*17 * (kindex + 1);

        if (kindex < 15)
            fraction = (double)(in[3] & 0x0f)/16.0;
        else                                      // Do end point short step
            fraction = (double)(in[3] & 0x0f)/15.0;

        for (int i=0; i<outDimension; i++)
        {
            tbl = table[i] + index0 + koffset1;

            r1 = tbl[0] + tbl[index1] + tbl[index2] + tbl[index3] +
                 tbl[index4] + tbl[index5] + tbl[index6] + tbl[index7] +
                 tbl[index8] + tbl[index9] + tbl[index10] + tbl[index11] +
                 tbl[index12] + tbl[index13] + tbl[index14] + tbl[index15];

            tbl = table[i] + index0 + koffset2;

            r2 = tbl[0] + tbl[index1] + tbl[index2] + tbl[index3] +
                 tbl[index4] + tbl[index5] + tbl[index6] + tbl[index7] +
                 tbl[index8] + tbl[index9] + tbl[index10] + tbl[index11] +
                 tbl[index12] + tbl[index13] + tbl[index14] + tbl[index15];

            r = ((double)r1 + ((double)r2-(double)r1)*fraction )/16.0 + 0.5;  // interpolate & round

            modf(r,&ip);

            if (ip > 255)
                ip = 255;

            out[i] = (BYTE)ip;
        }
    }
}
#endif


// Weird channel ordering.

#define B_CHANNEL 2
#define G_CHANNEL 1
#define R_CHANNEL 0
#define A_CHANNEL 3

/**************************************************************************\
*
* Function Description:
*
*   Apply the 5x5 Color Matrix in place
*
* Arguments:
*
*   InOut buf     - the color data
*   IN    count   - number of pixels in the color data
*   IN    cmatrix - The color matrix to use for the transform.
*
* Return Value:
*
*   NONE
*
\**************************************************************************/


VOID
GpRecolorObject::TransformColor5x5(
    ARGB *buf, 
    INT count,
    ColorMatrix cmatrix    
)
{
    // must be passed a valid buffer.
    
    ASSERT(count >= 0);
    ASSERT(buf != NULL);
    
    INT i = count;
    
    // Set up byte pointers to each of the color chanels for this pixel.
    
    BYTE *b = (BYTE*) buf;
    BYTE *g;
    BYTE *r;
    BYTE *a;
    
    // Pre-compute the translation component -- it'll be the same
    // for all pixels.
    
    REAL b_c = cmatrix.m[4][B_CHANNEL] * 255;
    REAL g_c = cmatrix.m[4][G_CHANNEL] * 255;
    REAL r_c = cmatrix.m[4][R_CHANNEL] * 255;
    REAL a_c = cmatrix.m[4][A_CHANNEL] * 255;
    
    BYTE bv;
    BYTE gv;
    BYTE rv;
    BYTE av;    
    
    // Run through all the pixels in the input buffer.
    
    while(i--) 
    {
        // b channel is already set - set the others
        
        g = b+1;
        r = b+2;
        a = b+3;
        
        // access the individual channels using byte pointer access
        
        // !!! [asecchia] not computing the homogenous coordinate -
        //     perspective transform is ignored.
        //     We should be computing the coefficient and dividing 
        //     by it for each channel.
        
        // BackWords order BGRA
            
        // Compute the matrix channel contributions into temporary storage
        // so that we avoid propagating the new value of the channel into
        // the computation for the next channel.
        
        // Blue channel
        bv = ByteSaturate( GpRound (
            cmatrix.m[0][B_CHANNEL] * (*r) +
            cmatrix.m[1][B_CHANNEL] * (*g) +
            cmatrix.m[2][B_CHANNEL] * (*b) +
            cmatrix.m[3][B_CHANNEL] * (*a) + b_c
        )); 
        
        // Green channel
        gv = ByteSaturate( GpRound (
            cmatrix.m[0][G_CHANNEL] * (*r) +
            cmatrix.m[1][G_CHANNEL] * (*g) +
            cmatrix.m[2][G_CHANNEL] * (*b) +
            cmatrix.m[3][G_CHANNEL] * (*a) + g_c
        )); 

        // Red channel
        rv = ByteSaturate( GpRound (
            cmatrix.m[0][R_CHANNEL] * (*r) +
            cmatrix.m[1][R_CHANNEL] * (*g) +
            cmatrix.m[2][R_CHANNEL] * (*b) +
            cmatrix.m[3][R_CHANNEL] * (*a) + r_c
        )); 
        
        // Alpha channel
        av = ByteSaturate( GpRound (
            cmatrix.m[0][A_CHANNEL] * (*r) +
            cmatrix.m[1][A_CHANNEL] * (*g) +
            cmatrix.m[2][A_CHANNEL] * (*b) +
            cmatrix.m[3][A_CHANNEL] * (*a) + a_c
        )); 
                
        // Update the pixel in the buffer.
        
        *b = bv;
        *g = gv;
        *r = rv;
        *a = av;
        
        // Next pixel.
        
        b += 4;
    }    
}

/**************************************************************************\
*
* Function Description:
*
*   Apply the 5x5 Color Matrix in place - handle special case grays
*
* Arguments:
*
*   InOut buf     - the color data
*   IN    count   - number of pixels in the color data
*   IN    cmatrix - The color matrix to use for the transform.
*   IN    skip    - True if the skip grays flag is on.
*
* Return Value:
*
*   NONE
*
\**************************************************************************/


VOID
GpRecolorObject::TransformColor5x5AltGrays(
    ARGB *buf, 
    INT count,
    ColorMatrix cmatrix,
    BOOL skip
)
{
    // must be passed a valid buffer.
    
    ASSERT(count >= 0);
    ASSERT(buf != NULL);
    
    INT i = count;
    
    // Set up byte pointers to each of the color chanels for this pixel.
    
    BYTE *b = (BYTE*) buf;
    BYTE *g;
    BYTE *r;
    BYTE *a;
    
    // Pre-compute the translation component -- it'll be the same
    // for all pixels.
    
    REAL b_c = cmatrix.m[4][B_CHANNEL] * 255;
    REAL g_c = cmatrix.m[4][G_CHANNEL] * 255;
    REAL r_c = cmatrix.m[4][R_CHANNEL] * 255;
    REAL a_c = cmatrix.m[4][A_CHANNEL] * 255;
    
    BYTE bv;
    BYTE gv;
    BYTE rv;
    BYTE av;
    
    // Run through all the pixels in the input buffer.
    
    while(i--) 
    {
        if(!IsPureGray((ARGB*)b))
        {        
            // b channel is already set - set the others
            
            g = b+1;
            r = b+2;
            a = b+3;
            
            // access the individual channels using byte pointer access
            
            // !!! [asecchia] not computing the homogenous coordinate -
            //     perspective transform is ignored.
            //     We should be computing the coefficient and dividing 
            //     by it for each channel.
            
            // BackWords order BGRA
            
            // Compute the matrix channel contributions into temporary storage
            // so that we avoid propagating the new value of the channel into
            // the computation for the next channel.
            
            // Blue channel
            bv = ByteSaturate( GpRound (
                cmatrix.m[0][B_CHANNEL] * (*r) +
                cmatrix.m[1][B_CHANNEL] * (*g) +
                cmatrix.m[2][B_CHANNEL] * (*b) +
                cmatrix.m[3][B_CHANNEL] * (*a) + b_c
            )); 
            
            // Green channel
            gv = ByteSaturate( GpRound (
                cmatrix.m[0][G_CHANNEL] * (*r) +
                cmatrix.m[1][G_CHANNEL] * (*g) +
                cmatrix.m[2][G_CHANNEL] * (*b) +
                cmatrix.m[3][G_CHANNEL] * (*a) + g_c
            )); 
    
            // Red channel
            rv = ByteSaturate( GpRound (
                cmatrix.m[0][R_CHANNEL] * (*r) +
                cmatrix.m[1][R_CHANNEL] * (*g) +
                cmatrix.m[2][R_CHANNEL] * (*b) +
                cmatrix.m[3][R_CHANNEL] * (*a) + r_c
            )); 
            
            // Alpha channel
            av = ByteSaturate( GpRound (
                cmatrix.m[0][A_CHANNEL] * (*r) +
                cmatrix.m[1][A_CHANNEL] * (*g) +
                cmatrix.m[2][A_CHANNEL] * (*b) +
                cmatrix.m[3][A_CHANNEL] * (*a) + a_c
            ));
            
            // Update the pixel in the buffer.
            
            *b = bv;
            *g = gv;
            *r = rv;
            *a = av;
        }
        else
        {
            if(!skip) 
            {
                *(ARGB *)b = grayMatrixLUT[*b];
            }
        }
        
        // Next pixel.
            
        b += 4;
    }    
}


/**************************************************************************\
*
* Function Description:
*
*   Apply the 5x5 Color Matrix in place. Special case for the ARGB scale
*
* Arguments:
*
*   InOut buf     - the color data
*   IN    count   - number of pixels in the color data
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpRecolorObject::TransformColorScale4(
    ARGB *buf, 
    INT count
)
{
    // must be passed a valid buffer.
    ASSERT(count >= 0);
    ASSERT(buf != NULL);
    
    INT i = count;
    BYTE *b = (BYTE*) buf;
    
    // Run through all the pixels in the input buffer.
    
    while(i--) 
    {
        // access the individual channels using byte pointer access
        // Ignore the gamma LUT for the alpha channel.

        // BackWords order BGRA
        *b++ = lutB[*b];
        *b++ = lutG[*b];
        *b++ = lutR[*b];
        *b++ = lutA[*b];
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Apply the 5x5 Color Matrix in place. Special case for the ARGB scale.
*   Handle special case grays.   
*
* Arguments:
*
*   InOut buf     - the color data
*   IN    count   - number of pixels in the color data
*   IN    skip    - True if the skip grays flag is on.
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpRecolorObject::TransformColorScale4AltGrays(
    ARGB *buf, 
    INT count,
    BOOL skip
)
{
    // must be passed a valid buffer.
    ASSERT(count >= 0);
    ASSERT(buf != NULL);
    
    INT i = count;
    BYTE *b = (BYTE*) buf;
    
    // Run through all the pixels in the input buffer.
    
    while(i--) 
    {
        if(!IsPureGray((ARGB*)b))
        {        
            // access the individual channels using byte pointer access
            // Ignore the gamma LUT for the alpha channel.
    
            // BackWords order BGRA
            *b++ = lutB[*b];
            *b++ = lutG[*b];
            *b++ = lutR[*b];
            *b++ = lutA[*b];
        }
        else
        {
            if(!skip) 
            {
                *(ARGB *)b = grayMatrixLUT[*b];
            }
            
            b += 4;
        }
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Apply the Gamma Look Up Table (LUT)
*
* Arguments:
*
*   InOut buf     - the color data
*   IN    count   - number of pixels in the color data
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpRecolorObject::TransformColorGammaLUT(
    ARGB *buf, 
    INT count
)
{
    // must be passed a valid buffer.
    ASSERT(count >= 0);
    ASSERT(buf != NULL);
    
    INT i = count;
    BYTE *b = (BYTE*) buf;
    
    // Run through all the pixels in the input buffer.
    
    while(i--) 
    {
        // access the individual channels using byte pointer access
        // Ignore the gamma LUT for the alpha channel.

        // BackWords order BGRA
        *b++ = lut[*b];
        *b++ = lut[*b];
        *b++ = lut[*b];
         b++;             // don't gamma convert the alpha channel
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Apply the 5x5 Color Matrix in the special case of only translation
*
* Arguments:
*
*   InOut buf     - the color data
*   IN    count   - number of pixels in the color data
*   IN    cmatrix - The color matrix to use for the transform.
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpRecolorObject::TransformColorTranslate(
    ARGB *buf, 
    INT count,
    ColorMatrix cmatrix
)
{
    // must be passed a valid buffer.
    ASSERT(count >= 0);
    ASSERT(buf != NULL);
    
    INT i = count;
    BYTE *b = (BYTE*) buf;
    INT b_c = GpRound( cmatrix.m[4][B_CHANNEL] * 255 );
    INT g_c = GpRound( cmatrix.m[4][G_CHANNEL] * 255 );
    INT r_c = GpRound( cmatrix.m[4][R_CHANNEL] * 255 );
    INT a_c = GpRound( cmatrix.m[4][A_CHANNEL] * 255 );
    
    
    // Run through all the pixels in the input buffer.
    
    while(i--) 
    {
        // access the individual channels using byte pointer access
        
        // BackWords order BGRA
        *b++ = ByteSaturate((*b) + b_c);
        *b++ = ByteSaturate((*b) + g_c);
        *b++ = ByteSaturate((*b) + r_c);
        *b++ = ByteSaturate((*b) + a_c);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Apply the 5x5 Color Matrix in the special case of only translation
*   Handle special case grays.
*
* Arguments:
*
*   InOut buf     - the color data
*   IN    count   - number of pixels in the color data
*   IN    cmatrix - The color matrix to use for the transform.
*   IN    skip    - True if the skip grays flag is on.
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
GpRecolorObject::TransformColorTranslateAltGrays(
    ARGB *buf, 
    INT count,
    ColorMatrix cmatrix,
    BOOL skip
)
{
    // must be passed a valid buffer.
    ASSERT(count >= 0);
    ASSERT(buf != NULL);
    
    INT i = count;
    BYTE *b = (BYTE*) buf;
    INT b_c = GpRound( cmatrix.m[4][B_CHANNEL] * 255 );
    INT g_c = GpRound( cmatrix.m[4][G_CHANNEL] * 255 );
    INT r_c = GpRound( cmatrix.m[4][R_CHANNEL] * 255 );
    INT a_c = GpRound( cmatrix.m[4][A_CHANNEL] * 255 );
    
    // Run through all the pixels in the input buffer.
    
    while(i--) 
    {
        if(!IsPureGray((ARGB*)b))
        {
            // access the individual channels using byte pointer access

            // BackWords order BGRA
            *b++ = ByteSaturate((*b) + b_c);
            *b++ = ByteSaturate((*b) + g_c);
            *b++ = ByteSaturate((*b) + r_c);
            *b++ = ByteSaturate((*b) + a_c);
        }
        else 
        {
            if(!skip) 
            {
                *(ARGB *)b = grayMatrixLUT[*b];
            }
        
            b += 4;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\api\srgb2cmyk.h ===
BYTE SrgbToCmykTable[19652] =
{
200,210,221,214,241,255,255,255,255,255,255,255,253,248,244,242,242,
186,198,204,203,221,219,246,245,244,243,243,255,253,247,244,242,241,
168,186,198,206,215,214,232,240,238,253,251,250,242,237,233,230,228,
187,171,185,196,206,215,227,237,247,253,250,244,241,235,231,228,227,
193,175,188,190,197,206,217,228,235,240,248,238,232,226,222,225,224,
197,182,190,193,196,198,204,216,224,228,231,231,224,218,217,215,213,
200,201,191,200,198,198,197,204,212,216,218,221,216,210,207,205,203,
207,206,193,204,203,201,198,198,203,207,206,206,210,200,195,194,195,
209,213,197,204,209,206,202,198,199,201,199,194,193,188,182,180,181,
206,209,214,206,213,210,206,200,196,197,196,189,182,179,171,165,164,
201,203,207,205,211,211,207,201,194,191,191,188,179,172,168,155,151,
192,194,197,199,204,207,204,199,192,187,184,184,179,168,162,155,141,
183,184,186,190,197,199,198,195,189,183,179,177,175,167,157,154,143,
177,178,180,183,190,189,187,184,181,176,171,168,166,166,157,147,144,
177,178,180,182,183,181,180,176,173,171,165,160,155,152,155,145,137,
177,178,179,178,176,176,173,171,169,163,162,156,149,145,139,145,136,
177,178,177,175,174,174,171,170,164,162,162,154,147,141,136,128,137,
187,194,212,227,236,247,254,255,255,255,255,255,251,246,243,241,241,
172,182,198,212,225,238,243,242,242,242,255,255,251,246,243,241,240,
168,170,182,195,207,221,237,238,253,251,250,248,241,235,231,229,228,
174,171,173,185,198,209,223,235,245,251,249,246,239,233,230,227,226,
186,183,180,182,190,201,212,224,232,237,245,238,230,225,221,224,223,
192,193,185,187,190,192,200,212,221,225,229,229,222,217,216,214,213,
191,196,189,195,193,193,193,200,209,213,216,219,214,208,206,204,207,
193,202,191,202,199,197,194,195,200,204,203,204,206,198,195,193,195,
207,209,209,202,206,203,199,195,196,198,196,192,191,187,181,179,180,
205,208,213,205,211,208,203,197,194,195,194,187,181,178,169,164,163,
199,202,206,204,210,209,205,198,192,189,189,186,177,170,167,154,150,
191,193,196,200,204,206,202,197,190,185,183,182,177,166,161,154,140,
182,183,185,189,196,200,197,194,187,181,178,176,174,166,155,152,142,
177,178,180,183,189,188,186,183,180,175,170,167,165,164,156,146,143,
177,178,179,181,182,180,179,175,172,170,164,159,154,151,154,144,136,
177,178,178,177,175,175,172,170,168,162,161,155,148,144,138,144,135,
177,177,176,175,173,174,170,169,163,161,161,153,146,140,135,127,136,
159,166,187,187,218,233,249,253,255,255,255,253,248,244,241,239,239,
145,154,173,194,209,225,239,251,255,255,255,253,247,243,240,239,239,
143,144,157,176,195,211,228,241,249,248,247,244,237,233,229,238,238,
156,154,155,168,185,199,215,229,238,248,246,241,235,231,227,225,225,
165,171,167,168,178,192,205,218,226,232,240,234,227,222,224,222,221,
172,183,181,177,179,183,193,206,216,221,225,226,219,214,214,212,211,
186,188,189,187,185,184,185,193,204,209,212,216,211,206,204,202,205,
189,193,195,195,192,190,187,188,194,199,200,201,203,196,193,191,193,
193,204,203,199,200,197,193,190,191,194,192,189,188,184,179,177,179,
194,205,208,203,207,204,199,193,190,191,190,184,178,175,168,163,162,
191,200,203,209,208,206,201,195,189,186,186,183,174,167,160,152,149,
185,191,194,199,202,203,199,194,187,182,180,179,174,164,158,152,138,
180,182,184,187,195,197,195,190,184,179,175,173,171,164,153,150,141,
175,177,179,182,187,186,184,181,177,173,168,165,164,162,153,144,141,
176,177,178,180,179,178,175,173,170,168,162,157,153,149,152,142,134,
176,177,176,175,174,174,170,169,164,160,159,153,146,142,137,142,133,
176,175,175,173,171,172,168,167,162,159,159,153,144,138,133,126,135,
120,135,153,174,181,190,230,245,250,250,249,246,242,239,237,237,237,
115,124,145,168,186,207,224,237,252,254,251,246,242,239,237,236,236,
120,120,131,153,177,195,215,229,240,243,250,245,241,237,236,235,235,
136,133,131,143,165,184,202,218,228,239,241,235,230,226,224,222,222,
153,154,150,149,159,176,192,208,218,224,234,227,222,223,220,219,219,
166,167,167,164,163,169,181,196,208,214,218,220,215,213,211,209,209,
165,170,177,176,172,171,172,183,195,202,206,210,207,204,201,199,203,
170,186,184,184,182,178,176,178,185,192,193,195,198,192,190,188,191,
187,191,195,193,192,188,184,181,183,186,186,183,183,181,176,174,176,
190,193,202,201,200,197,191,186,183,184,183,178,173,171,164,161,161,
188,190,200,203,202,200,195,188,183,180,181,178,169,163,157,149,147,
182,184,191,196,200,198,195,189,182,177,175,175,170,159,154,149,136,
174,176,181,185,193,194,191,186,180,174,171,169,167,159,149,146,138,
166,167,177,180,184,182,180,177,174,170,165,163,161,159,150,141,136,
166,175,177,177,176,175,172,170,167,164,159,154,150,146,148,139,131,
167,174,174,173,171,171,168,166,161,158,156,150,145,140,134,139,130,
167,173,172,171,169,170,166,161,159,157,150,150,144,136,131,124,132,
 92,111,124,145,167,190,193,227,238,238,240,237,235,233,232,232,233,
 93,102,119,141,163,184,199,221,236,243,240,237,234,233,232,232,233,
101,102,111,132,156,177,198,213,226,242,238,235,233,231,230,230,231,
116,113,111,120,143,166,187,204,215,226,230,226,223,220,219,218,219,
136,134,130,126,134,157,176,194,206,214,223,221,219,217,215,215,215,
151,152,151,147,143,150,165,182,196,204,209,212,210,207,206,205,211,
158,160,161,161,157,154,157,169,184,193,198,203,201,198,196,199,199,
164,164,169,170,168,164,161,163,173,182,185,188,190,187,185,187,187,
169,172,182,181,180,176,171,169,171,175,177,176,176,174,171,172,173,
175,186,191,191,190,187,181,175,173,175,174,170,166,165,159,157,158,
183,185,189,195,194,192,187,180,174,172,173,170,162,157,153,146,144,
178,180,183,192,193,191,188,182,175,170,168,168,163,153,148,138,132,
171,172,175,181,186,187,184,180,174,168,165,164,162,154,144,139,133,
163,164,166,177,179,178,176,173,169,165,160,158,157,154,144,135,132,
164,165,167,173,172,171,168,165,162,157,154,149,146,143,144,135,127,
165,166,170,169,167,165,164,160,157,154,152,146,141,136,131,135,126,
165,166,169,168,166,163,162,158,156,153,147,146,140,133,128,120,128,
 75, 86,105,119,140,165,188,194,203,225,226,225,224,226,226,227,229,
 76, 84, 99,116,137,161,184,198,216,226,225,224,225,225,225,226,228,
 83, 86, 96,111,132,155,178,195,209,224,224,223,223,223,224,225,226,
 96, 95, 96,103,122,146,169,188,200,212,220,220,220,220,221,222,224,
113,112,109,105,112,135,156,177,191,201,211,210,209,209,209,210,211,
130,131,129,125,120,126,146,165,182,191,198,203,201,200,204,205,206,
142,142,143,143,139,134,138,153,170,181,187,193,192,193,193,194,195,
154,155,153,154,152,147,144,147,158,169,175,179,182,180,181,181,183,
161,164,166,166,165,161,155,153,156,162,166,166,168,167,166,167,171,
166,169,173,178,177,173,167,161,161,162,162,160,158,158,153,153,154,
169,171,182,185,184,181,176,168,163,162,163,159,153,149,145,141,141,
167,174,177,182,184,182,178,172,165,160,159,160,154,145,141,133,129,
166,167,170,174,181,179,176,172,166,160,157,156,154,146,137,133,128,
160,161,163,166,173,172,170,166,162,158,154,152,151,146,137,129,126,
161,162,164,166,166,164,162,159,155,151,149,144,141,138,138,129,121,
162,163,163,162,162,160,159,154,152,148,147,141,136,131,126,130,121,
163,162,161,163,161,158,158,153,151,145,142,141,135,130,124,116,123,
 62, 72, 86, 99,117,140,163,182,192,202,209,211,212,213,215,220,223,
 62, 70, 86, 97,114,136,160,178,194,204,208,210,212,213,217,219,222,
 66, 71, 82, 95,109,131,155,174,189,203,206,209,210,213,215,218,220,
 78, 78, 82, 91,103,124,147,169,182,194,203,206,208,210,212,215,218,
 91, 92, 91, 90, 97,114,136,159,175,185,196,200,203,205,208,210,213,
108,107,106,103,100,105,125,146,164,176,185,191,193,194,196,198,200,
122,122,122,121,118,112,116,135,152,165,173,181,183,184,186,187,194,
136,136,135,135,133,129,124,128,142,155,162,167,171,172,173,178,181,
150,150,149,148,147,143,137,135,138,146,153,156,159,159,159,163,166,
157,159,164,162,161,157,151,145,145,146,147,148,148,149,147,147,151,
161,162,166,172,170,167,161,154,149,149,149,146,142,140,138,135,136,
159,161,165,174,173,171,166,160,152,148,149,148,142,135,132,126,124,
156,157,160,167,172,170,166,161,155,150,147,146,144,136,128,124,114,
151,152,158,161,165,164,163,159,155,150,146,143,142,138,128,121,115,
157,158,160,159,159,157,155,152,148,144,142,138,135,132,131,121,115,
158,158,157,156,154,154,150,148,145,140,137,135,130,125,120,123,114,
157,157,156,155,156,153,149,147,142,139,136,135,129,124,118,111,116,
 52, 60, 76, 85, 98,117,139,157,173,184,190,195,199,203,205,208,211,
 51, 59, 71, 82, 96,114,136,154,170,182,189,195,198,202,205,208,215,
 52, 58, 69, 81, 92,110,131,150,166,180,187,193,197,200,203,210,213,
 61, 62, 68, 79, 89,103,124,145,160,173,183,189,193,197,203,207,211,
 73, 74, 74, 77, 85, 96,115,138,155,166,178,184,189,194,198,202,206,
 87, 87, 87, 86, 85, 91,107,127,146,158,168,177,183,187,192,190,194,
103,102,102,100, 97, 94, 98,117,134,148,158,167,172,176,179,183,187,
117,117,116,115,113,109,104,108,125,139,147,154,160,163,167,170,174,
132,131,131,130,128,124,119,116,119,130,139,143,148,149,152,156,159,
144,147,145,144,142,139,133,128,126,127,131,135,137,139,139,142,145,
150,151,155,155,154,150,145,138,133,133,133,131,129,130,129,129,131,
150,152,155,159,159,157,152,145,138,135,136,135,129,123,123,119,118,
148,149,152,156,159,158,154,149,143,137,135,135,133,125,117,115,108,
144,145,147,150,156,156,153,149,145,139,135,133,133,128,118,112,108,
145,146,147,151,150,148,146,143,139,135,132,129,127,125,122,112,107,
147,148,150,149,147,144,143,139,136,132,129,127,123,119,114,115,106,
151,150,150,148,146,146,142,138,135,132,126,124,122,117,112,104,109,
 42, 49, 59, 69, 82, 98,117,132,147,159,169,177,183,190,195,199,204,
 41, 48, 59, 68, 80, 95,114,130,144,158,168,176,182,189,194,198,203,
 42, 48, 58, 68, 78, 92,110,127,141,155,166,174,180,187,192,197,201,
 47, 50, 56, 66, 76, 87,104,123,137,149,161,170,178,184,189,194,203,
 57, 58, 60, 63, 73, 82, 96,115,132,144,155,166,173,179,187,193,198,
 69, 70, 71, 71, 72, 79, 90,107,125,138,149,159,167,175,181,187,192,
 84, 84, 83, 83, 81, 80, 85,100,117,131,140,150,158,166,169,174,179,
 99, 99, 98, 96, 93, 90, 87, 92,109,122,131,139,146,153,159,165,170,
113,113,112,111,108,105,100, 97,100,113,123,129,135,139,144,150,155,
127,127,126,125,123,119,114,110,107,108,115,121,125,128,131,135,140,
138,138,138,137,135,132,126,120,117,116,115,115,117,119,120,122,126,
138,140,142,144,143,140,135,129,123,120,121,120,115,111,112,111,113,
137,138,141,145,145,143,140,135,128,123,121,123,121,112,106,102,101,
134,135,138,141,145,144,141,137,132,127,123,121,122,117,106,102, 99,
138,139,141,141,140,138,136,133,129,125,121,120,118,116,111,101, 98,
140,140,139,138,138,136,133,130,127,122,119,118,115,111,106,106, 97,
140,140,139,140,138,135,134,130,127,122,118,116,115,110,105, 97,101,
 32, 39, 47, 58, 66, 80, 97,110,121,134,147,157,167,174,180,189,195,
 32, 39, 47, 56, 65, 78, 95,109,119,132,145,155,166,173,179,188,194,
 32, 38, 47, 55, 64, 76, 91,107,117,129,143,153,164,171,180,187,192,
 36, 39, 45, 54, 63, 73, 86,102,114,124,138,151,160,168,177,184,190,
 44, 46, 47, 52, 61, 70, 80, 96,110,120,131,145,155,165,173,179,186,
 54, 55, 56, 56, 59, 68, 76, 88,104,115,126,138,150,159,167,176,183,
 67, 67, 67, 67, 66, 66, 74, 83, 98,110,120,129,141,152,160,168,176,
 81, 81, 80, 78, 76, 74, 74, 80, 93,105,114,122,130,140,150,155,162,
 95, 95, 93, 92, 89, 85, 82, 80, 85, 97,107,114,121,128,135,142,150,
109,108,107,106,103, 99, 95, 91, 88, 90, 99,106,111,116,121,128,134,
121,120,119,118,116,113,107,102, 99, 97, 96,100,103,107,110,114,120,
128,127,127,126,125,122,117,112,107,104,105,103,100, 99,100,103,106,
125,126,129,130,130,128,124,119,113,108,107,109,107, 98, 95, 93, 95,
123,124,126,129,131,129,127,123,118,113,109,109,110,104, 94, 91, 90,
124,125,126,129,128,127,124,122,118,114,110,108,107,106, 98, 90, 87,
129,128,129,128,127,125,123,119,116,112,108,106,105,102, 97, 95, 86,
132,131,130,129,127,127,123,119,116,113,108,105,106,102, 96, 89, 91,
 23, 30, 36, 43, 52, 63, 78, 90, 98,109,124,138,147,159,167,174,185,
 24, 29, 36, 43, 51, 62, 76, 89, 97,107,122,136,146,158,166,173,184,
 24, 29, 36, 43, 50, 60, 73, 87, 95,103,119,134,144,156,164,171,183,
 27, 30, 35, 43, 50, 58, 70, 84, 93,100,114,129,140,153,161,172,180,
 34, 35, 36, 42, 49, 57, 66, 78, 90, 97,108,123,138,148,157,168,176,
 42, 43, 44, 44, 48, 55, 63, 72, 85, 94,102,116,130,141,153,162,170,
 52, 52, 52, 53, 52, 53, 61, 69, 79, 90, 98,107,122,135,145,154,166,
 64, 64, 63, 62, 61, 59, 60, 67, 75, 86, 94,103,113,125,137,147,156,
 77, 77, 76, 74, 71, 68, 66, 67, 72, 81, 90, 97,105,114,125,132,141,
 90, 90, 88, 87, 84, 80, 75, 73, 72, 75, 83, 90, 97,103,112,120,128,
102,101,100, 99, 97, 93, 88, 84, 81, 79, 79, 84, 89, 94,100,106,114,
110,110,109,108,107,104, 99, 94, 90, 88, 87, 86, 86, 87, 89, 94, 99,
114,115,114,114,113,111,107,102, 97, 93, 92, 93, 91, 84, 83, 83, 88,
111,112,114,117,115,114,111,108,103, 98, 95, 96, 96, 90, 81, 79, 77,
109,110,117,116,116,115,112,110,106,101, 98, 96, 96, 94, 85, 78, 75,
118,117,117,116,115,113,111,108,104,100, 97, 94, 94, 92, 87, 82, 75,
119,119,118,119,117,115,111,109,104,101, 98, 95, 93, 93, 87, 79, 80,
 16, 21, 27, 32, 39, 48, 60, 71, 77, 87,101,117,131,140,149,162,170,
 17, 21, 27, 32, 39, 47, 58, 70, 76, 85,100,115,129,139,152,161,169,
 17, 21, 27, 32, 38, 46, 56, 68, 75, 81, 96,112,127,137,151,159,167,
 20, 22, 26, 32, 38, 45, 54, 65, 73, 78, 92,108,123,134,147,156,165,
 25, 26, 27, 32, 38, 44, 52, 61, 71, 76, 84,102,118,129,143,152,165,
 31, 32, 33, 33, 37, 44, 50, 58, 67, 74, 79, 94,111,126,137,146,159,
 39, 39, 40, 40, 40, 42, 49, 56, 63, 71, 76, 85,102,117,129,142,152,
 48, 48, 48, 48, 47, 46, 47, 55, 60, 67, 74, 81, 93,108,122,133,143,
 60, 59, 59, 57, 55, 53, 52, 53, 59, 64, 71, 77, 84, 99,111,123,134,
 72, 71, 70, 68, 65, 62, 59, 58, 58, 62, 67, 72, 80, 88,100,111,119,
 83, 83, 82, 80, 78, 73, 69, 64, 63, 63, 64, 68, 73, 80, 88, 98,107,
 92, 92, 91, 90, 88, 85, 81, 76, 72, 71, 70, 69, 71, 73, 77, 85, 92,
 98, 99, 97, 97, 95, 93, 90, 85, 80, 77, 77, 77, 73, 70, 71, 74, 80,
100,100,102,100, 99, 98, 95, 92, 87, 83, 81, 81, 81, 74, 67, 66, 69,
 99,100,101,103,102,100, 98, 95, 91, 87, 84, 83, 83, 80, 71, 66, 64,
105,104,104,104,103,101, 98, 95, 92, 88, 85, 83, 82, 80, 75, 68, 64,
109,109,108,106,105,102,101, 97, 94, 89, 86, 84, 82, 83, 76, 68, 68,
 11, 14, 19, 23, 28, 34, 43, 52, 56, 59, 81, 95,111,121,136,145,159,
 11, 14, 19, 23, 28, 34, 42, 51, 56, 58, 79, 94,110,120,134,144,158,
 12, 14, 19, 23, 28, 33, 41, 50, 55, 57, 76, 91,107,122,133,142,156,
 14, 15, 18, 23, 28, 33, 40, 48, 54, 56, 71, 87,104,119,129,144,153,
 17, 18, 19, 23, 28, 33, 39, 46, 52, 55, 65, 81, 98,114,125,139,149,
 22, 23, 23, 24, 28, 33, 38, 44, 50, 54, 56, 73, 92,107,119,134,144,
 28, 28, 29, 29, 29, 32, 37, 42, 48, 53, 56, 64, 83,100,115,126,137,
 35, 35, 35, 35, 35, 34, 36, 42, 46, 50, 55, 58, 74, 91,106,117,131,
 43, 43, 43, 42, 40, 39, 38, 40, 46, 49, 52, 56, 63, 81, 96,110,121,
 53, 53, 52, 51, 49, 46, 44, 43, 45, 49, 50, 53, 60, 72, 87, 99,111,
 64, 63, 62, 61, 58, 55, 51, 48, 48, 49, 50, 52, 55, 63, 75, 88, 99,
 74, 73, 72, 71, 69, 66, 61, 57, 54, 53, 53, 52, 54, 58, 65, 75, 85,
 81, 81, 80, 79, 77, 75, 72, 67, 63, 60, 60, 59, 55, 55, 58, 64, 72,
 85, 86, 85, 84, 83, 81, 78, 75, 70, 66, 66, 66, 64, 57, 53, 54, 61,
 85, 85, 87, 87, 85, 84, 82, 79, 76, 72, 69, 69, 69, 64, 55, 52, 51,
 90, 92, 91, 90, 88, 87, 84, 82, 78, 74, 72, 70, 69, 67, 60, 53, 51,
 95, 95, 94, 93, 91, 91, 88, 84, 81, 77, 74, 72, 70, 69, 64, 55, 54,
  7,  9, 12, 15, 19, 23, 28, 33, 35, 42, 52, 76, 91,107,117,132,142,
  7,  9, 12, 15, 18, 23, 28, 33, 35, 40, 51, 75, 90,106,116,131,141,
  7,  9, 12, 15, 18, 22, 27, 32, 35, 37, 48, 72, 87,104,114,129,139,
  9, 10, 12, 15, 19, 22, 27, 31, 34, 33, 44, 68, 84,101,116,127,137,
 11, 11, 12, 15, 19, 22, 26, 31, 34, 34, 38, 63, 79, 96,111,122,138,
 14, 15, 15, 16, 19, 22, 26, 30, 34, 35, 35, 56, 72, 90,106,117,132,
 18, 19, 19, 19, 19, 22, 26, 29, 33, 35, 36, 47, 64, 82, 98,110,125,
 23, 23, 23, 23, 23, 23, 25, 29, 33, 35, 36, 38, 55, 74, 90,105,117,
 29, 29, 29, 28, 28, 27, 26, 29, 33, 35, 35, 36, 45, 64, 81, 96,107,
 36, 36, 35, 34, 33, 31, 30, 30, 32, 35, 36, 35, 38, 54, 71, 85, 99,
 44, 44, 43, 42, 40, 38, 35, 34, 34, 35, 37, 36, 36, 42, 61, 76, 88,
 54, 53, 52, 51, 49, 46, 43, 40, 38, 38, 38, 38, 37, 39, 49, 63, 76,
 62, 62, 61, 60, 58, 55, 52, 48, 44, 42, 43, 42, 38, 38, 42, 53, 64,
 69, 68, 67, 66, 64, 62, 60, 57, 53, 49, 49, 49, 46, 39, 39, 43, 53,
 71, 71, 71, 70, 69, 67, 65, 62, 59, 55, 53, 53, 53, 47, 39, 39, 42,
 77, 77, 76, 75, 73, 71, 70, 67, 63, 60, 57, 55, 55, 52, 46, 39, 38,
 81, 81, 80, 81, 80, 77, 74, 72, 68, 64, 61, 60, 58, 55, 50, 41, 39,
  3,  5,  7,  8, 10, 12, 15, 17, 16, 31, 39, 64, 78, 88,105,115,130,
  3,  5,  7,  8, 10, 12, 15, 17, 16, 30, 38, 62, 72, 87,104,114,129,
  4,  5,  7,  9, 10, 12, 15, 17, 17, 15, 36, 60, 70, 85,102,112,128,
  5,  5,  7,  9, 10, 12, 15, 17, 17, 15, 30, 56, 66, 82, 99,109,125,
  6,  6,  7,  9, 11, 13, 15, 17, 18, 16, 25, 37, 61, 77, 94,110,121,
  8,  8,  8,  9, 11, 13, 15, 17, 18, 17, 20, 31, 55, 71, 89,105,116,
 10, 11, 11, 11, 11, 13, 15, 17, 19, 19, 17, 25, 48, 64, 82, 98,109,
 13, 13, 14, 14, 13, 13, 15, 17, 19, 20, 19, 18, 40, 56, 74, 90,102,
 17, 17, 17, 17, 16, 16, 15, 18, 20, 21, 20, 19, 31, 47, 65, 81, 96,
 21, 21, 21, 21, 20, 19, 18, 18, 20, 22, 22, 20, 19, 37, 55, 72, 87,
 27, 27, 26, 26, 24, 23, 21, 21, 21, 22, 24, 22, 20, 26, 45, 61, 76,
 34, 33, 33, 32, 30, 29, 26, 25, 23, 23, 24, 24, 21, 20, 33, 51, 66,
 42, 41, 40, 39, 38, 36, 33, 30, 28, 27, 27, 27, 23, 22, 22, 39, 53,
 48, 48, 47, 46, 45, 43, 41, 38, 34, 32, 31, 31, 28, 23, 24, 30, 43,
 54, 53, 53, 52, 50, 49, 47, 44, 41, 38, 36, 36, 34, 29, 23, 25, 33,
 61, 62, 63, 61, 59, 56, 52, 50, 47, 43, 41, 39, 39, 36, 29, 24, 23,
 69, 68, 68, 66, 64, 62, 59, 58, 54, 50, 48, 45, 44, 40, 34, 27, 24,
  1,  1,  2,  2,  3,  3,  3,  2,  0,  0, 28, 37, 62, 77, 86,103,113,
  1,  1,  2,  3,  3,  3,  3,  2,  0,  0, 27, 36, 61, 76, 85,102,112,
  1,  1,  2,  3,  3,  3,  3,  2,  1,  0, 25, 34, 59, 74, 83,101,111,
  1,  2,  2,  3,  3,  3,  4,  3,  1,  0, 22, 31, 56, 71, 81, 98,108,
  2,  2,  2,  3,  4,  4,  4,  4,  2,  0,  0, 28, 51, 66, 76, 94,105,
  3,  3,  3,  3,  4,  4,  5,  5,  4,  1,  0, 20, 46, 55, 71, 89,105,
  4,  4,  4,  4,  4,  5,  6,  6,  6,  4,  1, 16, 26, 49, 65, 82, 98,
  5,  5,  5,  5,  5,  5,  6,  7,  7,  6,  4, 10, 20, 42, 57, 75, 91,
  7,  7,  7,  7,  7,  7,  6,  7,  8,  8,  6,  3, 14, 34, 49, 67, 83,
  9,  9,  9,  9,  9,  8,  8,  8,  9,  9,  8,  6,  3, 25, 40, 58, 73,
 12, 12, 12, 12, 11, 10, 10,  9,  9, 10, 10,  9,  6,  9, 30, 48, 63,
 17, 16, 16, 16, 15, 14, 13, 12, 11, 11, 11, 11,  8,  5, 20, 36, 52,
 22, 22, 21, 20, 19, 18, 17, 15, 14, 13, 13, 13, 11,  7, 10, 26, 42,
 28, 28, 27, 26, 25, 24, 22, 20, 18, 17, 16, 15, 14, 10,  9, 18, 31,
 33, 33, 32, 31, 30, 29, 28, 26, 23, 21, 20, 19, 17, 14, 10, 10, 24,
 40, 40, 39, 37, 35, 34, 33, 33, 29, 26, 24, 23, 22, 19, 14, 11, 14,
 61, 61, 62, 61, 59, 56, 52, 43, 39, 35, 32, 31, 28, 25, 19, 13, 11,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 26, 36, 61, 76, 85,103,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 25, 35, 60, 75, 85,102,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 24, 33, 58, 73, 83,101,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 22, 31, 55, 70, 80, 98,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 19, 28, 52, 67, 77, 94,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 15, 24, 47, 62, 72, 89,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 17, 41, 55, 66, 84,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 12, 22, 44, 59, 77,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  6, 16, 36, 52, 69,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 10, 28, 43, 60,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 20, 34, 51,
  2,  2,  2,  2,  2,  2,  1,  1,  0,  0,  0,  0,  0,  0,  6, 24, 40,
  6,  5,  5,  5,  5,  4,  3,  3,  2,  1,  1,  0,  0,  0,  0, 16, 29,
 10, 10,  9,  8,  8,  7,  7,  6,  4,  3,  3,  2,  1,  0,  0,  7, 21,
 15, 14, 14, 13, 12, 11, 11, 10,  8,  7,  6,  4,  3,  2,  0,  0, 14,
 19, 19, 18, 17, 16, 15, 15, 14, 12, 10,  9,  7,  6,  4,  2,  0,  6,
 40, 40, 39, 38, 36, 33, 31, 28, 30, 25, 21, 18, 15, 11,  7,  1,  0,
185,195,202,199,230,244,245,249,254,255,255,255,255,252,250,248,248,
155,161,173,179,205,207,227,230,234,238,241,255,252,249,247,246,246,
116,114,132,157,178,186,202,212,217,238,241,243,239,237,235,233,233,
 84, 95, 98,119,144,164,181,195,212,225,229,229,230,228,227,226,227,
 69, 78, 73, 88,107,130,151,169,186,200,212,211,212,212,212,216,218,
 54, 62, 59, 61, 78, 95,113,134,153,170,182,190,192,193,197,199,201,
 41, 41, 47, 43, 53, 68, 83, 98,118,135,150,160,165,169,174,178,182,
 29, 29, 36, 31, 34, 46, 59, 72, 85,102,117,127,135,141,147,154,162,
 21, 20, 25, 24, 22, 27, 37, 48, 60, 71, 86, 97,103,110,119,128,136,
 15, 14, 13, 15, 13, 15, 20, 28, 36, 45, 55, 67, 76, 80, 90,100,109,
  8,  8,  7,  8,  7,  7,  8, 12, 17, 23, 30, 37, 46, 54, 58, 73, 84,
  2,  2,  1,  1,  0,  0,  1,  2,  3,  6, 10, 14, 19, 26, 33, 48, 59,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  3,  8, 13, 35,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
188,198,209,225,235,242,246,250,255,255,255,255,254,251,249,248,248,
155,165,180,200,214,223,228,231,235,239,255,255,251,249,247,246,246,
115,123,135,158,179,195,208,213,236,239,242,243,239,236,234,233,233,
 93, 95,103,121,146,165,181,197,213,227,230,231,229,228,227,226,227,
 75, 75, 78, 90,109,132,152,169,186,200,212,213,212,212,211,216,218,
 59, 58, 62, 64, 79, 96,114,134,154,170,182,190,191,193,197,199,201,
 46, 44, 48, 45, 54, 69, 84, 99,118,136,150,160,165,169,174,178,185,
 34, 31, 37, 32, 36, 46, 60, 73, 86,103,117,127,135,142,148,154,162,
 22, 21, 21, 24, 23, 28, 38, 49, 60, 72, 86, 97,104,110,119,128,136,
 15, 15, 13, 16, 14, 16, 20, 29, 37, 46, 56, 68, 76, 81, 90,100,110,
  9,  8,  8,  9,  7,  7,  9, 12, 18, 24, 30, 38, 47, 54, 59, 74, 86,
  2,  2,  1,  1,  1,  0,  1,  2,  4,  6, 10, 14, 20, 27, 33, 48, 59,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  3,  9, 13, 35,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
184,206,219,202,235,240,247,252,255,255,255,255,254,251,249,248,247,
165,174,189,205,215,222,233,245,255,255,255,254,251,248,246,245,245,
129,129,139,160,181,196,209,224,238,241,243,242,238,236,234,241,241,
107,106,109,124,148,166,182,197,213,229,231,231,229,227,226,226,226,
 87, 84, 86, 95,112,136,153,170,187,200,212,212,212,211,215,216,217,
 69, 65, 65, 69, 82, 99,117,136,155,171,183,190,191,192,196,198,201,
 49, 48, 49, 50, 57, 71, 86,101,119,137,151,161,166,169,174,178,185,
 37, 35, 35, 36, 38, 48, 62, 74, 87,104,118,128,135,142,148,154,162,
 26, 23, 23, 25, 25, 29, 39, 51, 62, 73, 88, 98,104,111,120,128,137,
 18, 15, 14, 16, 15, 17, 21, 30, 38, 47, 57, 69, 77, 82, 91,100,110,
 10,  9,  8,  7,  8,  8, 10, 13, 19, 25, 31, 39, 48, 55, 62, 74, 86,
  3,  2,  2,  1,  1,  1,  1,  2,  4,  7, 11, 15, 21, 28, 34, 49, 62,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  4, 10, 13, 35,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
211,197,227,232,214,214,244,254,255,255,255,255,252,250,248,247,247,
180,187,199,210,214,222,232,244,255,255,255,253,250,247,246,245,245,
145,145,153,170,187,198,209,224,240,244,250,247,244,242,241,240,241,
121,120,118,130,152,169,183,198,214,228,232,230,228,226,225,225,226,
 98, 97, 96,101,117,139,155,171,187,201,213,212,211,214,214,215,217,
 75, 75, 75, 77, 86,103,121,138,156,172,183,190,191,194,196,198,200,
 59, 58, 56, 57, 62, 74, 89,104,121,139,152,161,166,170,174,178,185,
 44, 39, 40, 41, 43, 51, 64, 77, 90,106,120,129,136,142,149,154,162,
 29, 28, 27, 27, 29, 32, 42, 53, 64, 75, 89,100,106,112,120,128,137,
 20, 19, 17, 17, 18, 19, 23, 31, 40, 49, 59, 71, 79, 83, 92,103,112,
 11, 11,  9,  8,  9, 10, 11, 14, 20, 26, 33, 41, 50, 57, 63, 77, 87,
  4,  3,  2,  1,  1,  1,  2,  3,  5,  8, 12, 17, 22, 30, 36, 49, 62,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2,  6, 11, 16, 36,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 10,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
213,200,226,232,235,239,224,254,255,255,255,254,251,249,247,246,246,
191,197,208,216,221,224,224,244,255,255,254,251,248,246,244,244,244,
163,164,173,187,197,204,213,226,239,252,248,245,242,241,240,240,240,
138,136,135,145,162,175,187,200,215,228,231,228,226,225,224,225,225,
111,110,110,112,125,144,157,172,189,202,212,213,213,213,214,215,216,
 85, 85, 86, 87, 93,108,126,141,158,173,184,190,192,194,196,198,204,
 65, 64, 64, 66, 69, 78, 93,108,124,141,153,162,167,170,174,180,184,
 49, 49, 47, 48, 51, 56, 67, 80, 93,108,122,131,137,143,149,156,162,
 36, 35, 31, 32, 34, 37, 45, 56, 67, 78, 92,102,107,114,122,130,137,
 24, 21, 20, 20, 21, 23, 26, 34, 43, 52, 62, 74, 81, 85, 94,103,112,
 13, 12, 12, 10, 11, 12, 13, 16, 22, 29, 36, 44, 53, 60, 64, 78, 88,
  5,  4,  4,  2,  2,  2,  3,  4,  7, 10, 14, 19, 25, 32, 39, 52, 63,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  4,  8, 14, 21, 41,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 10,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
215,220,215,233,238,243,247,238,241,255,255,251,248,247,245,245,245,
200,204,212,219,226,231,237,240,254,255,252,248,246,244,243,243,243,
177,180,188,199,206,212,219,229,240,250,245,243,240,239,238,238,239,
154,153,155,164,176,186,194,205,218,228,233,231,230,230,230,231,233,
127,126,126,128,137,152,163,176,191,203,213,212,212,212,213,214,216,
 99, 98, 98,100,103,115,131,144,160,175,185,190,192,193,198,201,204,
 76, 75, 75, 77, 79, 85, 98,113,128,143,155,163,167,172,176,180,184,
 56, 56, 56, 57, 60, 63, 72, 84, 98,112,125,133,138,144,151,156,162,
 40, 39, 39, 39, 42, 44, 50, 60, 71, 82, 95,104,110,116,123,131,140,
 28, 27, 26, 24, 26, 28, 31, 38, 47, 56, 65, 77, 83, 88, 97,106,113,
 17, 16, 14, 13, 13, 15, 17, 19, 25, 32, 39, 47, 56, 63, 69, 81, 90,
  7,  5,  5,  4,  3,  4,  5,  6,  9, 12, 17, 22, 28, 36, 42, 53, 66,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  3,  6, 11, 17, 22, 42,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 11,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
222,224,229,235,241,247,251,255,252,253,253,249,245,243,241,243,244,
210,212,213,223,230,237,243,248,254,254,249,246,242,240,241,241,242,
191,193,199,205,212,220,227,234,242,248,243,240,237,237,236,237,238,
169,168,170,178,186,195,204,212,222,229,232,229,228,228,229,230,232,
144,143,143,145,152,162,173,184,196,205,213,214,214,216,217,219,222,
114,113,113,114,116,124,138,151,165,178,186,192,193,195,197,200,203,
 89, 88, 88, 88, 90, 93,103,118,132,147,157,165,169,172,176,180,188,
 67, 67, 67, 67, 70, 72, 78, 89,103,116,128,135,141,146,151,159,165,
 48, 47, 47, 48, 50, 53, 56, 65, 76, 87, 98,107,112,118,125,133,140,
 32, 31, 30, 30, 32, 35, 38, 42, 51, 60, 70, 80, 86, 90, 99,107,116,
 19, 19, 18, 17, 17, 19, 21, 24, 29, 36, 43, 51, 60, 66, 72, 83, 92,
  9,  8,  8,  5,  6,  6,  8,  9, 12, 15, 20, 26, 32, 40, 45, 57, 68,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  3,  6,  9, 14, 20, 28, 43,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  3, 17,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
229,231,221,231,243,249,254,255,255,255,251,246,243,241,239,239,239,
219,221,225,230,234,241,247,251,255,253,248,243,240,238,237,236,240,
203,204,208,213,218,226,234,239,244,248,242,237,235,233,232,235,237,
183,182,183,189,195,203,214,220,226,231,230,227,226,225,227,228,230,
158,158,157,159,165,173,185,195,203,209,215,213,213,214,216,218,221,
130,129,129,129,132,137,149,162,174,183,189,194,196,198,201,199,202,
102,102,101,100,102,105,112,126,139,152,161,167,171,174,178,183,187,
 79, 79, 79, 79, 80, 82, 85, 94,108,119,131,138,143,149,154,159,165,
 57, 57, 57, 58, 60, 63, 65, 71, 81, 92,102,110,116,121,128,134,141,
 39, 38, 38, 39, 40, 43, 46, 49, 56, 66, 74, 84, 90, 94,102,110,117,
 23, 23, 22, 22, 23, 25, 27, 30, 34, 41, 48, 56, 65, 70, 77, 86, 94,
 11, 11, 10,  9,  9, 10, 12, 14, 16, 19, 24, 30, 37, 45, 50, 61, 71,
  0,  0,  0,  0,  0,  0,  0,  0,  2,  4,  6,  9, 13, 19, 24, 33, 47,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2,  6, 18,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
236,237,239,241,245,251,255,255,255,255,250,243,239,238,237,237,237,
227,229,231,234,238,244,249,253,255,254,247,241,237,236,235,235,235,
213,214,217,220,225,231,238,243,247,250,240,235,232,231,230,231,232,
194,194,195,200,205,212,220,226,231,235,231,227,224,223,223,224,229,
171,171,170,172,178,185,195,205,210,214,217,213,212,212,215,217,220,
144,144,144,144,146,152,161,175,185,190,194,195,196,198,201,204,208,
116,116,116,116,117,119,125,137,150,161,166,171,174,178,179,183,187,
 91, 91, 91, 91, 91, 93, 96,103,114,125,136,143,147,152,157,162,168,
 68, 68, 69, 69, 71, 72, 75, 78, 86, 96,105,114,120,125,131,137,144,
 47, 47, 47, 48, 50, 52, 55, 58, 63, 71, 80, 88, 94, 98,105,113,120,
 28, 29, 29, 29, 30, 32, 35, 38, 40, 46, 54, 62, 69, 74, 81, 89, 97,
 14, 14, 14, 13, 14, 15, 17, 19, 21, 24, 29, 35, 42, 50, 54, 65, 74,
  2,  2,  1,  0,  0,  1,  2,  3,  5,  7, 10, 13, 18, 23, 29, 37, 50,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2,  7, 10, 23,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
240,241,242,237,247,252,255,255,255,255,249,243,238,235,233,235,236,
232,234,236,236,241,246,250,253,255,255,246,240,235,232,231,233,234,
220,221,224,226,230,235,240,244,248,253,242,235,231,228,229,229,230,
202,203,205,209,213,219,225,230,234,239,233,226,223,221,222,223,224,
181,181,182,184,190,198,204,211,216,219,221,215,212,212,212,214,216,
157,157,157,158,160,168,176,185,193,197,199,198,197,197,199,204,207,
130,130,130,131,132,135,142,150,162,170,173,176,176,179,183,187,192,
104,103,104,104,105,108,110,116,125,135,143,148,152,156,161,163,169,
 80, 80, 80, 81, 82, 83, 85, 89, 95,103,111,118,125,129,135,141,148,
 57, 58, 58, 59, 60, 62, 64, 67, 71, 77, 85, 92, 98,103,109,116,123,
 37, 37, 37, 37, 39, 41, 43, 46, 48, 53, 60, 68, 74, 79, 85, 92,100,
 18, 19, 19, 19, 20, 21, 23, 25, 28, 30, 35, 41, 48, 55, 58, 69, 77,
  5,  5,  4,  4,  4,  5,  6,  8, 10, 12, 14, 18, 23, 29, 34, 41, 54,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  3,  6, 11, 15, 28,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
243,244,245,246,249,253,255,255,255,255,249,241,236,234,232,231,234,
236,237,239,240,243,248,250,252,255,255,247,239,234,231,229,229,233,
226,226,228,230,234,239,242,244,247,255,243,235,230,227,226,225,229,
210,210,212,215,219,224,229,232,235,240,235,227,223,220,219,222,223,
190,190,191,193,199,205,211,215,218,222,224,216,212,211,210,213,215,
167,168,168,169,173,180,188,193,198,201,204,201,198,197,199,201,204,
143,143,143,144,145,149,157,163,170,177,179,181,179,180,183,186,193,
117,117,117,118,120,122,124,130,137,145,151,154,156,158,163,168,174,
 92, 92, 92, 93, 95, 97, 99,101,106,113,119,125,131,134,139,143,149,
 69, 69, 69, 70, 71, 73, 75, 77, 80, 85, 93, 98,103,108,113,120,127,
 46, 46, 46, 47, 49, 51, 53, 55, 58, 61, 67, 74, 79, 84, 89, 95,103,
 26, 26, 26, 26, 27, 29, 31, 33, 36, 38, 42, 48, 54, 59, 63, 73, 80,
  8,  8,  8,  9,  9, 10, 12, 13, 16, 18, 20, 23, 29, 34, 39, 47, 57,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  3,  5,  7, 11, 16, 20, 32,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  8,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
245,245,246,247,249,253,255,255,255,255,249,240,235,232,229,230,230,
240,240,241,242,245,248,251,251,253,254,247,238,233,230,229,228,228,
230,231,232,233,236,240,243,244,245,249,243,234,229,226,225,224,225,
216,216,217,219,223,228,232,233,234,239,235,227,222,219,219,219,219,
198,198,198,200,205,210,215,218,220,222,224,217,212,210,210,211,215,
178,178,178,178,182,188,194,198,201,204,207,202,199,198,198,199,204,
154,154,155,156,156,160,168,173,177,181,184,185,181,181,182,187,191,
129,130,130,131,132,133,136,143,147,153,158,161,160,161,164,168,173,
104,104,105,106,108,110,111,113,118,123,129,133,136,138,142,148,155,
 80, 80, 81, 82, 83, 85, 87, 89, 91, 96,102,106,110,113,118,125,129,
 56, 57, 57, 58, 59, 61, 63, 65, 68, 71, 75, 81, 85, 89, 93,100,107,
 34, 34, 34, 35, 36, 38, 40, 42, 44, 47, 50, 55, 60, 65, 68, 76, 83,
 14, 14, 15, 15, 16, 17, 18, 20, 22, 25, 27, 30, 35, 40, 45, 52, 61,
  0,  0,  0,  0,  0,  0,  1,  3,  4,  6,  8, 10, 13, 17, 22, 24, 37,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2,  5, 13,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
247,247,247,248,249,253,255,254,254,255,243,239,233,230,228,227,229,
243,242,243,244,246,249,251,251,250,254,241,237,231,228,227,225,228,
235,234,235,236,238,241,244,244,244,247,237,233,227,225,223,222,225,
222,222,222,224,226,230,233,234,234,236,230,226,221,219,217,219,219,
206,206,205,207,210,214,218,220,221,221,220,216,211,210,209,211,212,
187,187,186,186,189,193,198,201,203,205,207,203,199,198,197,200,202,
165,165,165,165,165,169,174,179,181,184,187,187,183,182,184,186,189,
142,142,142,142,143,143,146,151,155,159,163,167,164,163,165,168,175,
117,117,117,118,119,120,121,122,127,132,137,141,142,141,144,149,155,
 92, 92, 93, 94, 95, 97, 98, 99,101,106,111,115,117,118,122,127,135,
 68, 68, 68, 69, 71, 73, 74, 76, 78, 81, 85, 90, 93, 95, 98,105,112,
 43, 44, 44, 45, 46, 47, 49, 51, 54, 57, 59, 63, 68, 71, 74, 81, 87,
 21, 21, 22, 22, 23, 25, 26, 28, 30, 33, 35, 38, 42, 46, 50, 57, 65,
  3,  3,  3,  4,  4,  5,  7,  8, 10, 12, 14, 16, 18, 23, 27, 31, 42,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  3,  7, 11, 17,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
249,248,248,249,250,253,253,253,252,247,244,233,231,228,226,227,226,
245,244,244,245,246,249,250,249,249,245,242,230,228,226,224,225,225,
238,237,237,238,239,242,243,243,243,241,238,227,225,222,221,222,222,
227,226,226,227,229,231,233,234,233,235,231,220,219,216,217,217,217,
212,212,211,212,214,216,219,221,221,221,222,212,210,208,209,209,212,
195,194,194,193,195,198,201,204,205,206,208,200,198,196,197,198,203,
175,174,174,173,173,176,179,182,185,187,189,186,184,182,183,185,190,
152,152,152,151,151,152,154,158,161,164,168,170,167,165,166,170,173,
128,128,128,128,129,129,129,131,135,139,143,147,147,145,146,150,155,
103,104,104,105,106,107,107,107,110,114,118,122,126,124,125,129,136,
 79, 80, 80, 81, 82, 84, 85, 86, 87, 90, 94, 98,101,102,103,108,114,
 55, 55, 55, 56, 57, 58, 60, 62, 64, 67, 69, 73, 77, 80, 81, 85, 92,
 30, 30, 30, 31, 32, 33, 35, 37, 39, 42, 44, 47, 51, 55, 58, 63, 69,
  9,  9, 10, 10, 11, 12, 13, 15, 17, 19, 21, 23, 26, 31, 34, 37, 46,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  3,  4,  6,  9, 13, 16, 23,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
250,249,249,249,250,251,252,251,251,237,232,225,224,224,224,224,226,
246,246,245,245,246,248,249,247,248,235,230,223,222,223,222,222,225,
240,239,239,239,240,242,243,242,242,242,227,219,219,219,219,219,222,
230,230,229,229,230,232,234,233,233,233,223,214,214,214,213,214,217,
217,216,216,216,217,219,221,221,221,222,216,212,206,206,206,209,210,
201,200,200,199,200,202,204,205,206,207,206,202,195,195,195,198,200,
182,181,181,180,180,182,184,186,188,189,192,189,183,182,182,185,188,
160,160,160,159,159,159,161,163,166,168,172,174,167,166,166,169,172,
137,137,137,137,137,137,137,139,142,145,149,153,150,148,148,151,157,
114,114,114,114,114,115,115,116,118,121,124,128,133,129,128,131,137,
 90, 90, 91, 91, 92, 93, 93, 94, 95, 98,101,104,108,108,107,110,116,
 66, 66, 66, 67, 68, 69, 71, 72, 74, 76, 78, 81, 84, 89, 88, 90, 95,
 40, 40, 41, 41, 42, 43, 45, 47, 49, 52, 54, 56, 60, 64, 67, 69, 74,
 17, 17, 17, 18, 19, 20, 21, 23, 25, 27, 29, 32, 35, 39, 43, 45, 52,
  0,  0,  0,  0,  0,  0,  2,  3,  5,  7,  9, 11, 13, 16, 20, 22, 28,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  4,  7,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
250,250,250,249,249,250,250,249,249,250,225,222,218,220,220,222,223,
247,246,246,246,246,247,247,246,246,248,224,221,216,218,219,220,221,
241,241,240,240,241,242,242,241,240,244,221,218,213,215,216,217,218,
232,232,231,231,232,233,234,233,232,234,216,213,208,210,210,212,214,
220,220,219,219,220,221,222,222,221,222,226,206,201,202,203,205,207,
205,205,204,204,205,206,207,207,207,208,211,199,192,192,193,196,200,
187,187,187,187,187,187,188,190,190,191,195,187,184,180,181,184,188,
167,167,166,166,166,166,167,169,170,172,175,173,170,166,167,169,174,
145,145,145,145,144,144,145,146,148,150,153,158,154,150,150,152,157,
122,122,122,122,122,122,123,124,125,127,129,133,137,132,132,133,138,
 99,100,100,100,100,101,101,102,103,105,107,109,113,115,112,113,118,
 76, 76, 77, 77, 78, 79, 79, 81, 82, 84, 86, 87, 90, 95, 93, 94, 97,
 51, 52, 52, 52, 53, 54, 56, 57, 59, 62, 64, 65, 67, 72, 74, 75, 78,
 25, 26, 26, 27, 28, 29, 30, 32, 34, 37, 40, 42, 44, 47, 52, 53, 58,
  5,  5,  5,  5,  6,  7,  8, 10, 12, 14, 16, 18, 21, 24, 28, 29, 35,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  4,  7, 10, 13,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
247,238,242,241,244,242,242,239,237,236,233,217,215,214,217,218,221,
244,236,239,238,241,240,240,237,235,234,231,216,213,212,215,217,220,
239,231,234,234,236,235,236,234,231,230,228,213,211,209,212,214,217,
230,232,227,226,231,228,229,228,225,225,223,209,206,205,207,209,213,
219,221,222,220,220,223,222,219,217,216,216,203,200,198,201,202,206,
205,207,208,208,208,209,209,209,207,206,206,194,192,190,192,193,197,
191,189,191,191,192,193,193,193,194,193,193,194,183,179,181,182,186,
170,171,172,172,173,173,173,174,175,176,177,179,170,168,166,169,173,
150,151,151,151,152,152,152,153,154,155,157,161,155,153,151,153,157,
130,130,130,130,130,130,131,131,133,134,135,138,143,135,134,136,139,
108,108,108,108,108,108,109,110,111,113,114,115,119,118,116,117,120,
 85, 85, 86, 86, 86, 87, 88, 89, 90, 92, 93, 94, 96,100, 98, 98,101,
 62, 62, 62, 62, 63, 64, 65, 67, 68, 71, 73, 74, 74, 78, 80, 80, 82,
 36, 36, 37, 37, 38, 39, 40, 42, 44, 47, 50, 52, 53, 54, 59, 60, 63,
 12, 13, 13, 13, 14, 15, 16, 18, 20, 23, 25, 28, 30, 32, 35, 37, 41,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  2,  4,  6,  8, 11, 13, 17, 19,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
189,164,122, 98, 48, 22, 14,  8,  4,  2,  1,  0,  0,  0,  0,  0,  0,
181,168,135,106, 66, 53, 25, 18, 12,  8,  5,  0,  0,  0,  0,  0,  0,
174,180,145,111, 76, 61, 39, 26, 18,  4,  2,  0,  0,  0,  0,  0,  0,
229,187,169,132, 99, 72, 49, 32, 15,  4,  1,  0,  0,  0,  0,  0,  0,
253,209,202,165,127, 94, 69, 46, 27, 11,  0,  0,  0,  0,  0,  0,  0,
255,228,221,197,160,122, 90, 66, 43, 23,  6,  0,  0,  0,  0,  0,  0,
255,255,233,221,186,150,116, 87, 63, 39, 19,  2,  0,  0,  0,  0,  0,
255,255,245,241,209,174,141,110, 83, 59, 35, 14,  0,  0,  0,  0,  0,
255,255,254,247,230,199,167,135,105, 78, 53, 28,  8,  0,  0,  0,  0,
255,255,255,255,248,220,191,160,128,100, 73, 45, 21,  2,  0,  0,  0,
255,255,255,255,255,235,208,180,150,120, 93, 66, 37, 14,  0,  0,  0,
255,255,255,255,255,244,220,195,167,138,111, 85, 57, 29,  7,  0,  0,
255,255,255,255,255,246,228,206,180,154,126,100, 74, 47, 20,  0,  0,
255,255,255,255,253,239,222,204,186,163,139,113, 89, 65, 38, 12,  0,
255,255,255,255,246,233,219,203,187,170,148,124,101, 79, 60, 37, 14,
255,255,255,251,242,231,217,204,190,172,157,135,112, 91, 71, 57, 36,
255,255,255,250,240,232,219,207,192,178,166,145,123,102, 83, 65, 54,
185,159,111, 70, 44, 24, 13,  8,  4,  2,  1,  0,  0,  0,  0,  0,  0,
186,164,126, 83, 54, 34, 24, 17, 12,  8,  0,  0,  0,  0,  0,  0,  0,
201,173,139,106, 75, 51, 32, 24,  7,  4,  2,  0,  0,  0,  0,  0,  0,
227,203,165,129, 97, 71, 49, 30, 14,  4,  1,  0,  0,  0,  0,  0,  0,
252,231,201,163,125, 93, 68, 46, 26, 11,  0,  0,  0,  0,  0,  0,  0,
255,254,220,196,159,121, 90, 66, 43, 23,  6,  0,  0,  0,  0,  0,  0,
255,255,236,220,185,149,115, 86, 63, 39, 19,  2,  0,  0,  0,  0,  0,
255,255,246,244,208,173,140,109, 82, 58, 34, 14,  0,  0,  0,  0,  0,
255,255,255,248,229,198,166,134,104, 78, 52, 28,  8,  0,  0,  0,  0,
255,255,255,255,247,219,190,159,127, 99, 72, 45, 21,  2,  0,  0,  0,
255,255,255,255,255,234,208,179,149,120, 93, 65, 37, 14,  0,  0,  0,
255,255,255,255,255,244,220,195,167,138,110, 84, 56, 28,  7,  0,  0,
255,255,255,255,255,250,228,206,180,154,126,100, 74, 46, 20,  0,  0,
255,255,255,255,253,239,222,204,186,163,138,113, 88, 64, 37, 12,  0,
255,255,255,255,246,233,219,203,187,170,147,124,101, 79, 60, 36, 13,
255,255,255,251,242,231,217,204,190,172,156,135,111, 91, 71, 56, 35,
255,255,255,249,240,231,218,207,191,177,165,144,122,102, 83, 64, 53,
168,154,111, 98, 50, 29, 12,  7,  3,  2,  1,  0,  0,  0,  0,  0,  0,
180,158,123, 85, 58, 37, 20,  8,  2,  1,  0,  0,  0,  0,  0,  0,  0,
198,169,131,103, 74, 51, 32, 16,  6,  3,  1,  0,  0,  0,  0,  0,  0,
223,200,160,123, 94, 69, 48, 29, 14,  2,  0,  0,  0,  0,  0,  0,  0,
233,229,197,159,122, 91, 67, 46, 26, 10,  0,  0,  0,  0,  0,  0,  0,
245,252,227,194,157,119, 89, 65, 43, 22,  6,  0,  0,  0,  0,  0,  0,
255,255,249,219,183,148,113, 85, 62, 39, 18,  2,  0,  0,  0,  0,  0,
255,255,255,240,206,171,139,108, 81, 58, 34, 13,  0,  0,  0,  0,  0,
255,255,255,251,228,196,164,132,103, 77, 52, 28,  7,  0,  0,  0,  0,
255,255,255,255,246,218,188,157,126, 98, 71, 44, 21,  1,  0,  0,  0,
255,255,255,255,255,233,207,178,148,119, 92, 64, 36, 14,  0,  0,  0,
255,255,255,255,255,243,219,194,166,137,109, 83, 56, 28,  7,  0,  0,
255,255,255,255,255,250,228,204,180,153,125, 99, 73, 46, 19,  0,  0,
255,255,255,255,252,239,222,204,184,162,138,112, 88, 63, 36, 11,  0,
255,255,255,255,246,233,218,203,186,169,147,123,100, 78, 59, 35, 13,
255,255,255,251,241,230,217,203,187,171,156,134,111, 90, 70, 56, 34,
255,255,255,249,239,231,218,206,191,177,165,145,121,101, 82, 64, 52,
178,145,120, 89, 76, 60, 18,  7,  4,  2,  0,  0,  0,  0,  0,  0,  0,
180,159,127, 94, 69, 43, 23, 10,  2,  1,  0,  0,  0,  0,  0,  0,  0,
195,166,130,104, 76, 53, 33, 17,  5,  2,  0,  0,  0,  0,  0,  0,  0,
218,198,155,118, 92, 68, 47, 28, 13,  2,  0,  0,  0,  0,  0,  0,  0,
239,227,196,155,117, 89, 66, 45, 25,  9,  0,  0,  0,  0,  0,  0,  0,
255,245,225,191,154,116, 87, 64, 42, 22,  6,  0,  0,  0,  0,  0,  0,
255,252,246,216,180,145,111, 84, 61, 38, 18,  1,  0,  0,  0,  0,  0,
255,255,255,236,203,168,136,106, 80, 57, 33, 13,  0,  0,  0,  0,  0,
255,255,255,253,225,194,161,130,101, 75, 51, 27,  7,  0,  0,  0,  0,
255,255,255,255,244,216,186,155,124, 96, 70, 43, 20,  1,  0,  0,  0,
255,255,255,255,255,232,205,176,146,117, 90, 63, 35, 13,  0,  0,  0,
255,255,255,255,255,242,218,193,165,135,108, 82, 54, 27,  6,  0,  0,
255,255,255,255,255,249,228,203,179,152,124, 98, 72, 45, 19,  0,  0,
255,255,255,255,255,238,221,204,184,162,137,112, 87, 62, 35,  9,  0,
255,255,255,255,245,232,218,202,185,168,146,122, 99, 77, 58, 34, 12,
255,255,255,250,240,229,216,202,186,170,155,133,111, 89, 69, 54, 33,
255,255,255,248,239,230,217,202,190,176,157,143,122,100, 81, 63, 51,
184,149,132,102, 73, 46, 43, 11,  4,  2,  0,  0,  0,  0,  0,  0,  0,
186,166,136,105, 77, 52, 36, 13,  4,  0,  0,  0,  0,  0,  0,  0,  0,
196,170,140,113, 84, 59, 36, 19,  7,  0,  0,  0,  0,  0,  0,  0,  0,
220,196,156,120, 95, 70, 48, 28, 13,  2,  0,  0,  0,  0,  0,  0,  0,
241,224,194,152,114, 87, 64, 43, 24,  9,  0,  0,  0,  0,  0,  0,  0,
255,247,224,191,151,113, 86, 63, 41, 21,  5,  0,  0,  0,  0,  0,  0,
255,255,243,214,178,142,109, 83, 60, 37, 17,  1,  0,  0,  0,  0,  0,
255,255,255,233,200,165,133,103, 78, 56, 32, 12,  0,  0,  0,  0,  0,
255,255,255,249,222,190,157,127, 99, 73, 50, 26,  6,  0,  0,  0,  0,
255,255,255,255,241,213,183,151,121, 94, 68, 42, 19,  0,  0,  0,  0,
255,255,255,255,254,230,203,174,143,115, 89, 61, 34, 12,  0,  0,  0,
255,255,255,255,255,240,216,191,162,133,106, 81, 53, 26,  6,  0,  0,
255,255,255,255,255,246,225,202,177,150,122, 96, 71, 43, 18,  0,  0,
255,255,255,255,254,237,222,203,183,161,136,111, 85, 60, 33, 10,  0,
255,255,255,254,244,231,216,201,184,165,144,121, 98, 76, 56, 32, 10,
255,255,255,248,239,227,214,200,185,169,153,131,109, 88, 68, 52, 31,
255,255,253,246,237,226,215,201,188,174,156,142,121, 99, 80, 61, 50,
190,172,137,114, 85, 55, 31, 27, 16,  1,  0,  0,  0,  0,  0,  0,  0,
193,174,147,116, 88, 60, 35, 21,  5,  0,  0,  0,  0,  0,  0,  0,  0,
200,178,150,123, 94, 67, 42, 23,  8,  0,  0,  0,  0,  0,  0,  0,  0,
219,195,161,130,103, 77, 52, 31, 14,  2,  0,  0,  0,  0,  0,  0,  0,
239,220,192,152,115, 89, 65, 43, 24,  9,  0,  0,  0,  0,  0,  0,  0,
255,244,221,188,147,109, 83, 61, 39, 19,  4,  0,  0,  0,  0,  0,  0,
255,255,241,212,177,139,105, 81, 59, 36, 16,  0,  0,  0,  0,  0,  0,
255,255,254,230,198,162,130,101, 76, 54, 31, 11,  0,  0,  0,  0,  0,
255,255,255,245,218,186,153,123, 96, 71, 48, 25,  5,  0,  0,  0,  0,
255,255,255,255,237,210,179,147,118, 91, 65, 40, 18,  0,  0,  0,  0,
255,255,255,255,251,227,200,170,140,112, 86, 58, 32, 11,  0,  0,  0,
255,255,255,255,255,238,214,188,159,131,104, 78, 50, 24,  5,  0,  0,
255,255,255,255,255,244,223,200,175,147,120, 94, 69, 41, 17,  0,  0,
255,255,255,255,252,240,221,202,182,160,135,109, 84, 58, 32,  9,  0,
255,255,255,255,242,230,215,199,182,163,143,119, 96, 74, 53, 29,  8,
255,255,254,247,237,225,213,198,183,167,151,129,107, 86, 66, 50, 29,
255,255,250,245,235,224,214,199,186,169,154,140,119, 98, 78, 59, 48,
193,177,152,124, 96, 66, 39, 19, 11,  3,  0,  0,  0,  0,  0,  0,  0,
197,180,153,127, 99, 70, 43, 22,  6,  0,  0,  0,  0,  0,  0,  0,  0,
203,184,159,132,103, 76, 49, 27, 10,  0,  0,  0,  0,  0,  0,  0,  0,
218,196,167,140,112, 85, 58, 35, 16,  2,  0,  0,  0,  0,  0,  0,  0,
235,217,191,156,122, 95, 70, 46, 25,  9,  0,  0,  0,  0,  0,  0,  0,
255,240,217,185,145,108, 83, 60, 38, 18,  4,  0,  0,  0,  0,  0,  0,
255,255,238,209,174,135,101, 78, 56, 33, 14,  0,  0,  0,  0,  0,  0,
255,255,252,227,195,160,127, 97, 74, 52, 29,  9,  0,  0,  0,  0,  0,
255,255,255,241,214,183,150,120, 92, 69, 46, 23,  4,  0,  0,  0,  0,
255,255,255,255,232,205,175,143,114, 88, 62, 38, 16,  0,  0,  0,  0,
255,255,255,255,247,223,196,166,136,108, 82, 55, 30, 10,  0,  0,  0,
255,255,255,255,255,234,211,184,155,127,101, 75, 47, 23,  4,  0,  0,
255,255,255,255,255,241,220,197,172,144,117, 92, 66, 39, 15,  0,  0,
255,255,255,255,255,238,223,203,182,159,132,107, 82, 56, 30,  7,  0,
255,255,255,253,243,228,214,197,180,160,141,118, 94, 72, 50, 26,  4,
255,255,252,245,235,223,210,196,180,163,145,127,105, 84, 63, 47, 27,
255,252,248,241,233,222,209,197,181,167,151,137,116, 95, 76, 57, 45,
196,181,153,131,105, 77, 49, 24,  4,  0,  0,  0,  0,  0,  0,  0,  0,
199,183,161,137,108, 80, 52, 27,  7,  0,  0,  0,  0,  0,  0,  0,  0,
204,187,165,140,112, 85, 58, 32, 12,  0,  0,  0,  0,  0,  0,  0,  0,
216,197,172,147,120, 92, 66, 40, 18,  2,  0,  0,  0,  0,  0,  0,  0,
233,215,189,158,129,101, 76, 50, 27,  9,  0,  0,  0,  0,  0,  0,  0,
251,235,213,182,146,112, 87, 63, 39, 19,  3,  0,  0,  0,  0,  0,  0,
255,254,234,205,171,133,100, 77, 54, 31, 12,  0,  0,  0,  0,  0,  0,
255,255,248,224,192,157,123, 93, 71, 49, 26,  7,  0,  0,  0,  0,  0,
255,255,255,237,211,180,147,115, 88, 66, 43, 21,  3,  0,  0,  0,  0,
255,255,255,251,228,201,171,139,109, 83, 59, 36, 15,  0,  0,  0,  0,
255,255,255,255,242,218,192,162,132,104, 78, 51, 28,  8,  0,  0,  0,
255,255,255,255,252,230,207,180,151,123, 98, 72, 44, 21,  2,  0,  0,
255,255,255,255,255,238,217,194,168,140,114, 89, 63, 36, 13,  0,  0,
255,255,255,255,255,242,221,201,180,155,129,104, 79, 54, 28,  6,  0,
255,255,255,251,241,229,212,195,178,158,137,115, 92, 69, 46, 22,  1,
255,255,249,242,233,221,207,193,177,160,142,124,103, 81, 61, 44, 23,
252,250,245,239,230,219,207,193,179,164,146,129,113, 92, 73, 54, 42,
201,186,166,142,115, 86, 58, 30,  6,  0,  0,  0,  0,  0,  0,  0,  0,
202,187,167,144,117, 89, 61, 33, 10,  0,  0,  0,  0,  0,  0,  0,  0,
207,191,171,148,121, 93, 66, 38, 14,  0,  0,  0,  0,  0,  0,  0,  0,
216,198,176,153,127,100, 73, 46, 21,  1,  0,  0,  0,  0,  0,  0,  0,
230,213,188,161,136,108, 82, 56, 30,  9,  0,  0,  0,  0,  0,  0,  0,
246,231,210,180,147,118, 91, 68, 41, 18,  1,  0,  0,  0,  0,  0,  0,
255,249,230,203,170,133,102, 79, 55, 31, 11,  0,  0,  0,  0,  0,  0,
255,255,244,220,189,155,120, 91, 69, 46, 24,  6,  0,  0,  0,  0,  0,
255,255,254,234,207,176,144,111, 84, 62, 40, 18,  1,  0,  0,  0,  0,
255,255,255,245,223,197,167,135,105, 79, 56, 33, 13,  0,  0,  0,  0,
255,255,255,255,237,213,187,158,127,100, 74, 48, 26,  7,  0,  0,  0,
255,255,255,255,247,226,202,176,147,119, 94, 68, 41, 19,  1,  0,  0,
255,255,255,255,253,234,213,189,163,136,110, 86, 60, 33, 12,  0,  0,
255,255,255,255,255,239,220,199,176,151,125,101, 77, 51, 25,  4,  0,
255,255,255,253,243,226,212,194,175,155,134,113, 89, 66, 42, 18,  0,
255,253,249,242,230,218,205,190,173,156,137,121,100, 78, 58, 40, 19,
249,247,243,235,226,215,204,189,175,158,142,125,110, 89, 70, 51, 38,
207,193,173,147,124, 95, 66, 36, 10,  0,  0,  0,  0,  0,  0,  0,  0,
208,193,175,152,126, 98, 68, 39, 13,  0,  0,  0,  0,  0,  0,  0,  0,
211,196,177,155,130,102, 73, 44, 17,  0,  0,  0,  0,  0,  0,  0,  0,
217,201,181,160,135,108, 80, 51, 24,  1,  0,  0,  0,  0,  0,  0,  0,
229,213,190,165,141,116, 88, 61, 33,  9,  0,  0,  0,  0,  0,  0,  0,
243,229,208,180,150,124, 98, 72, 44, 18,  0,  0,  0,  0,  0,  0,  0,
255,244,226,201,169,135,107, 82, 58, 31,  9,  0,  0,  0,  0,  0,  0,
255,255,240,218,190,156,121, 92, 70, 46, 22,  3,  0,  0,  0,  0,  0,
255,255,249,230,205,175,141,109, 82, 60, 37, 16,  0,  0,  0,  0,  0,
255,255,255,241,219,193,163,131,101, 75, 53, 30, 10,  0,  0,  0,  0,
255,255,255,251,232,209,183,154,123, 95, 69, 45, 23,  5,  0,  0,  0,
255,255,255,255,242,221,198,172,143,115, 90, 64, 37, 16,  0,  0,  0,
255,255,255,255,249,230,208,185,159,132,106, 82, 56, 30, 10,  0,  0,
255,255,255,255,253,236,216,195,172,147,121, 97, 73, 48, 22,  3,  0,
255,255,255,255,239,227,209,194,174,153,132,109, 86, 63, 37, 14,  0,
255,254,245,238,229,217,202,187,170,152,134,115, 97, 75, 54, 36, 15,
246,243,239,232,223,212,199,185,170,154,137,120,106, 87, 66, 48, 34,
215,201,182,160,134,104, 73, 41, 12,  0,  0,  0,  0,  0,  0,  0,  0,
215,201,183,161,135,106, 76, 44, 15,  0,  0,  0,  0,  0,  0,  0,  0,
217,203,185,164,138,110, 80, 49, 20,  0,  0,  0,  0,  0,  0,  0,  0,
221,206,188,167,143,115, 87, 57, 27,  2,  0,  0,  0,  0,  0,  0,  0,
229,215,195,172,148,122, 95, 66, 36,  9,  0,  0,  0,  0,  0,  0,  0,
241,228,209,182,155,129,104, 77, 48, 19,  0,  0,  0,  0,  0,  0,  0,
251,241,224,200,170,138,112, 86, 61, 32,  8,  0,  0,  0,  0,  0,  0,
255,250,236,216,190,157,122, 96, 72, 47, 21,  1,  0,  0,  0,  0,  0,
255,255,245,227,204,176,142,109, 83, 60, 36, 14,  0,  0,  0,  0,  0,
255,255,254,237,216,191,161,128, 99, 73, 51, 27,  8,  0,  0,  0,  0,
255,255,255,246,227,205,179,150,120, 91, 65, 42, 20,  2,  0,  0,  0,
255,255,255,255,237,217,194,168,140,112, 86, 59, 35, 14,  0,  0,  0,
255,255,255,255,244,225,204,180,155,128,103, 78, 52, 27,  8,  0,  0,
255,255,255,255,249,231,212,191,167,142,117, 94, 70, 44, 20,  1,  0,
255,255,255,252,242,231,210,195,174,152,130,107, 84, 60, 35, 12,  0,
252,250,245,238,229,213,200,183,168,149,130,111, 93, 72, 50, 31, 10,
244,241,237,228,219,208,196,181,166,149,132,115, 99, 83, 63, 44, 30,
223,209,191,170,143,112, 80, 46, 15,  0,  0,  0,  0,  0,  0,  0,  0,
223,209,192,170,144,114, 82, 49, 17,  0,  0,  0,  0,  0,  0,  0,  0,
223,210,193,172,147,118, 87, 54, 22,  0,  0,  0,  0,  0,  0,  0,  0,
226,213,196,175,151,122, 93, 62, 29,  2,  0,  0,  0,  0,  0,  0,  0,
232,219,201,180,155,128,101, 71, 39, 10,  0,  0,  0,  0,  0,  0,  0,
240,229,211,187,161,135,108, 82, 51, 21,  0,  0,  0,  0,  0,  0,  0,
249,239,223,201,173,143,116, 91, 64, 34,  8,  0,  0,  0,  0,  0,  0,
255,247,234,214,190,158,125,100, 75, 48, 21,  0,  0,  0,  0,  0,  0,
255,254,242,225,203,176,142,110, 85, 61, 36, 12,  0,  0,  0,  0,  0,
255,255,250,234,214,190,160,127, 98, 74, 51, 26,  5,  0,  0,  0,  0,
255,255,255,242,224,202,176,146,117, 89, 64, 40, 18,  0,  0,  0,  0,
255,255,255,250,233,213,190,164,136,109, 82, 55, 32, 12,  0,  0,  0,
255,255,255,255,240,221,200,177,151,125,100, 75, 48, 24,  6,  0,  0,
255,255,255,255,244,227,207,186,163,138,114, 90, 66, 40, 17,  0,  0,
255,255,255,255,248,230,212,193,172,149,126,103, 81, 57, 32, 10,  0,
254,251,247,233,224,212,199,181,166,146,126,107, 88, 68, 46, 25,  5,
239,237,232,226,217,206,191,177,161,144,127,110, 93, 79, 58, 39, 25,
229,216,200,178,151,119, 86, 51, 16,  0,  0,  0,  0,  0,  0,  0,  0,
229,216,200,179,153,121, 89, 54, 19,  0,  0,  0,  0,  0,  0,  0,  0,
229,217,201,180,154,124, 93, 59, 24,  0,  0,  0,  0,  0,  0,  0,  0,
231,219,203,183,158,129, 98, 66, 32,  2,  0,  0,  0,  0,  0,  0,  0,
234,223,207,186,162,134,105, 76, 42, 11,  0,  0,  0,  0,  0,  0,  0,
240,230,214,192,167,140,112, 85, 54, 22,  0,  0,  0,  0,  0,  0,  0,
247,238,223,202,176,147,120, 94, 67, 36,  8,  0,  0,  0,  0,  0,  0,
254,246,232,213,189,159,128,102, 78, 50, 21,  0,  0,  0,  0,  0,  0,
255,251,239,223,201,175,141,111, 87, 63, 36, 10,  0,  0,  0,  0,  0,
255,255,246,230,211,188,158,126, 98, 75, 51, 25,  2,  0,  0,  0,  0,
255,255,253,238,220,198,173,144,114, 88, 64, 39, 15,  0,  0,  0,  0,
255,255,255,245,228,209,186,160,132,105, 78, 52, 29,  8,  0,  0,  0,
255,255,255,251,235,217,196,173,148,121, 96, 71, 43, 21,  3,  0,  0,
255,255,255,254,239,222,203,182,158,134,110, 86, 62, 37, 15,  0,  0,
255,255,255,255,242,226,208,188,167,145,122, 99, 77, 53, 28,  7,  0,
255,245,240,233,224,213,200,180,164,144,123,104, 85, 65, 41, 19,  0,
238,235,231,224,215,201,188,174,157,140,122,105, 88, 72, 54, 34, 20,
235,222,206,185,158,125, 91, 56, 18,  0,  0,  0,  0,  0,  0,  0,  0,
234,222,206,185,159,127, 93, 59, 21,  0,  0,  0,  0,  0,  0,  0,  0,
234,223,207,186,160,130, 97, 64, 26,  0,  0,  0,  0,  0,  0,  0,  0,
235,224,208,188,163,133,102, 70, 34,  1,  0,  0,  0,  0,  0,  0,  0,
237,226,211,191,167,138,109, 79, 45, 11,  0,  0,  0,  0,  0,  0,  0,
240,231,216,195,171,144,115, 88, 57, 23,  0,  0,  0,  0,  0,  0,  0,
246,237,223,203,178,150,123, 96, 69, 37,  7,  0,  0,  0,  0,  0,  0,
251,243,230,212,189,160,130,104, 80, 52, 21,  0,  0,  0,  0,  0,  0,
255,249,237,221,199,173,141,112, 89, 65, 37,  9,  0,  0,  0,  0,  0,
255,252,242,227,208,185,155,124, 97, 76, 52, 24,  0,  0,  0,  0,  0,
255,255,247,233,216,195,169,140,111, 86, 64, 39, 13,  0,  0,  0,  0,
255,255,253,240,223,204,182,156,128,101, 76, 51, 27,  5,  0,  0,  0,
255,255,255,245,229,212,192,169,144,117, 92, 66, 40, 18,  0,  0,  0,
255,255,255,249,234,217,198,178,155,130,106, 83, 59, 32, 12,  0,  0,
255,255,255,250,236,220,203,183,163,140,117, 95, 73, 49, 25,  5,  0,
250,247,242,235,225,213,193,179,163,141,124,104, 84, 62, 39, 16,  0,
237,235,230,218,209,198,185,169,153,137,118,101, 83, 66, 48, 29, 14,
238,226,210,188,162,129, 94, 60, 21,  8,  0,  0,  0,  0,  0,  0,  0,
237,226,210,189,163,131, 96, 62, 24,  9,  0,  0,  0,  0,  0,  0,  0,
237,226,210,190,164,134,100, 66, 29,  0,  0,  0,  0,  0,  0,  0,  0,
237,226,211,191,167,137,105, 73, 37,  3,  0,  0,  0,  0,  0,  0,  0,
238,228,213,194,170,142,111, 81, 47, 12,  0,  0,  0,  0,  0,  0,  0,
239,230,216,197,173,147,118, 89, 58, 24,  0,  0,  0,  0,  0,  0,  0,
243,234,221,202,179,152,125, 98, 70, 38,  7,  0,  0,  0,  0,  0,  0,
248,240,228,210,187,160,132,106, 80, 53, 21,  0,  0,  0,  0,  0,  0,
252,246,234,218,197,171,141,113, 89, 65, 37,  8,  0,  0,  0,  0,  0,
255,249,239,224,206,182,153,123, 97, 75, 51, 24,  0,  0,  0,  0,  0,
255,251,242,229,212,191,166,137,108, 85, 63, 38, 12,  0,  0,  0,  0,
255,254,245,233,217,199,177,152,124, 97, 74, 50, 26,  3,  0,  0,  0,
255,255,250,238,223,206,187,165,139,113, 88, 63, 38, 15,  0,  0,  0,
255,255,253,241,227,211,193,174,151,126,102, 79, 54, 29,  8,  0,  0,
255,255,254,243,229,214,197,179,159,136,113, 91, 69, 45, 21,  3,  0,
255,255,255,250,237,221,203,178,162,146,122,102, 81, 59, 35, 13,  0,
231,228,223,216,207,196,183,165,150,133,114, 97, 79, 62, 43, 24,  9,
238,227,212,190,164,133, 98, 62, 24,  0,  1,  0,  0,  0,  0,  0,  0,
238,227,212,191,165,134,100, 64, 27,  0,  2,  0,  0,  0,  0,  0,  0,
238,227,212,191,166,137,103, 68, 32,  0,  2,  0,  0,  0,  0,  0,  0,
237,227,212,193,168,140,108, 75, 39,  5,  4,  0,  0,  0,  0,  0,  0,
237,228,214,195,171,144,114, 82, 48, 14,  0,  0,  0,  0,  0,  0,  0,
237,229,216,197,175,149,121, 91, 59, 25,  0,  0,  0,  0,  0,  0,  0,
239,232,219,201,179,154,127,100, 70, 38,  7,  0,  0,  0,  0,  0,  0,
243,236,224,207,186,160,134,108, 81, 52, 21,  1,  0,  0,  0,  0,  0,
248,241,231,215,194,169,142,115, 90, 65, 36,  7,  0,  0,  0,  0,  0,
252,246,236,222,203,180,152,123, 98, 75, 50, 22,  0,  0,  0,  0,  0,
253,248,239,226,209,189,164,135,107, 84, 62, 37, 11,  0,  0,  0,  0,
253,248,240,228,213,195,173,148,121, 95, 72, 49, 24,  1,  0,  0,  0,
254,249,241,231,217,201,182,160,135,109, 84, 60, 37, 14,  0,  0,  0,
255,252,244,233,220,205,189,170,147,123, 98, 74, 49, 26,  5,  0,  0,
255,252,245,235,222,208,192,175,156,133,110, 88, 65, 40, 17,  0,  0,
255,255,250,240,224,210,194,181,160,140,119, 98, 77, 55, 31, 10,  0,
255,255,255,253,240,224,208,163,147,130,113, 94, 77, 58, 39, 19,  3,
234,217,206,186,163,133,102, 70, 37,  7,  0,  0,  0,  0,  0,  0,  0,
234,217,206,187,164,135,104, 72, 38,  8,  0,  0,  0,  0,  0,  0,  0,
233,217,207,187,165,136,106, 74, 41, 11,  0,  0,  0,  0,  0,  0,  0,
232,225,207,188,168,139,110, 79, 46, 15,  0,  0,  0,  0,  0,  0,  0,
231,225,213,193,170,145,115, 85, 53, 21,  0,  0,  0,  0,  0,  0,  0,
232,226,214,196,174,149,121, 92, 61, 29,  2,  3,  0,  0,  0,  0,  0,
235,226,216,199,179,155,128,101, 71, 39, 10,  0,  0,  0,  0,  0,  0,
235,230,220,204,184,160,135,109, 82, 52, 20,  0,  0,  0,  0,  0,  0,
241,237,226,211,191,168,143,117, 91, 65, 35,  5,  0,  0,  0,  0,  0,
248,242,232,218,200,177,152,125, 99, 75, 50, 21,  0,  0,  0,  0,  0,
250,245,236,223,207,186,162,134,108, 85, 62, 36,  9,  0,  0,  0,  0,
250,245,237,226,211,193,171,146,119, 94, 72, 48, 23,  0,  0,  0,  0,
248,244,237,226,213,197,178,157,132,107, 83, 59, 35, 12,  0,  0,  0,
249,244,237,227,215,201,185,166,144,120, 96, 71, 46, 24,  3,  0,  0,
249,245,238,229,217,204,189,173,153,130,108, 85, 61, 35, 14,  0,  0,
249,245,238,229,217,204,191,176,158,138,116, 96, 75, 52, 27,  7,  0,
255,255,252,243,230,216,200,184,169,149,128,107, 87, 66, 43, 18,  0,
250,248,233,210,184,149,116, 85, 56, 33, 16,  3,  0,  0,  0,  0,  0,
232,232,221,201,177,154,120, 96, 74, 52, 33,  0,  0,  0,  0,  0,  0,
200,206,201,188,161,143,114, 91, 73, 32, 15,  0,  0,  0,  0,  0,  0,
190,183,183,174,153,130,106, 81, 51, 22,  6,  0,  0,  0,  0,  0,  0,
170,163,168,160,147,126,104, 83, 58, 29,  0,  0,  0,  0,  0,  0,  0,
142,139,146,144,133,119,101, 83, 64, 41, 14,  0,  0,  0,  0,  0,  0,
115,116,116,119,115,104, 92, 80, 64, 47, 26,  3,  0,  0,  0,  0,  0,
 91, 91, 89, 93, 93, 87, 78, 70, 62, 48, 32, 14,  0,  0,  0,  0,  0,
 67, 68, 68, 70, 70, 70, 64, 57, 52, 45, 34, 20,  6,  0,  0,  0,  0,
 44, 45, 45, 48, 47, 49, 47, 43, 39, 34, 30, 21, 11,  1,  0,  0,  0,
 23, 23, 23, 25, 24, 24, 26, 25, 23, 22, 19, 16, 11,  5,  0,  0,  0,
  6,  5,  4,  4,  1,  0,  2,  4,  6,  7,  8,  8,  7,  5,  1,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
246,241,226,204,179,145,110, 80, 52, 30, 14,  1,  0,  0,  0,  0,  0,
230,229,217,195,168,141,116, 93, 70, 49,  5,  0,  0,  0,  0,  0,  0,
204,207,202,184,160,133,106, 88, 48, 29, 12,  0,  0,  0,  0,  0,  0,
187,186,183,176,154,129,105, 78, 49, 19,  3,  0,  0,  0,  0,  0,  0,
169,169,169,161,149,127,104, 83, 58, 29,  0,  0,  0,  0,  0,  0,  0,
143,145,145,144,134,120,102, 83, 64, 41, 14,  0,  0,  0,  0,  0,  0,
113,115,116,119,116,104, 93, 80, 65, 47, 25,  3,  0,  0,  0,  0,  0,
 88, 91, 89, 93, 93, 88, 79, 71, 62, 49, 32, 14,  0,  0,  0,  0,  0,
 67, 68, 69, 70, 70, 70, 64, 58, 52, 46, 34, 20,  6,  0,  0,  0,  0,
 44, 45, 45, 48, 48, 49, 48, 43, 39, 35, 30, 21, 11,  1,  0,  0,  0,
 24, 23, 23, 26, 24, 25, 26, 26, 24, 22, 20, 17, 12,  5,  0,  0,  0,
  6,  5,  4,  3,  2,  1,  2,  5,  7,  8,  8,  8,  7,  5,  1,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
229,228,213,196,169,138, 99, 71, 44, 26, 10,  0,  0,  0,  0,  0,  0,
222,221,208,187,162,136,106, 68, 31, 15,  1,  0,  0,  0,  0,  0,  0,
200,202,200,182,157,131,103, 74, 42, 24,  8,  0,  0,  0,  0,  0,  0,
183,182,184,178,155,129,105, 77, 48, 13,  0,  0,  0,  0,  0,  0,  0,
160,166,165,162,153,128,104, 82, 57, 28,  0,  0,  0,  0,  0,  0,  0,
134,143,144,143,136,124,103, 83, 63, 40, 13,  0,  0,  0,  0,  0,  0,
114,114,116,119,116,106, 95, 81, 65, 47, 25,  2,  0,  0,  0,  0,  0,
 89, 91, 91, 93, 93, 89, 80, 72, 63, 49, 32, 14,  0,  0,  0,  0,  0,
 67, 68, 69, 70, 71, 71, 65, 59, 53, 46, 34, 20,  6,  0,  0,  0,  0,
 45, 45, 45, 48, 48, 50, 49, 44, 40, 35, 31, 21, 11,  1,  0,  0,  0,
 25, 24, 23, 23, 24, 26, 27, 27, 25, 23, 20, 17, 12,  5,  0,  0,  0,
  7,  6,  5,  3,  2,  2,  4,  6,  7,  8,  9,  9,  7,  5,  1,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
213,201,191,174,162,142, 94, 59, 36, 19,  5,  0,  0,  0,  0,  0,  0,
206,204,193,173,154,128, 99, 64, 27,  9,  0,  0,  0,  0,  0,  0,  0,
193,195,192,175,152,127,100, 71, 36, 16,  0,  0,  0,  0,  0,  0,  0,
177,178,182,176,155,129,103, 76, 47, 13,  0,  0,  0,  0,  0,  0,  0,
159,161,161,163,156,130,105, 82, 57, 27,  0,  0,  0,  0,  0,  0,  0,
138,140,140,140,138,129,105, 83, 63, 39, 13,  0,  0,  0,  0,  0,  0,
107,111,115,116,116,108, 98, 83, 65, 46, 25,  2,  0,  0,  0,  0,  0,
 84, 91, 90, 91, 93, 90, 82, 74, 64, 49, 32, 13,  0,  0,  0,  0,  0,
 67, 68, 69, 70, 71, 71, 66, 60, 54, 48, 34, 20,  5,  0,  0,  0,  0,
 46, 47, 46, 48, 49, 50, 50, 45, 41, 37, 32, 22, 11,  1,  0,  0,  0,
 26, 26, 24, 24, 26, 27, 29, 28, 26, 24, 21, 18, 12,  5,  0,  0,  0,
  8,  8,  6,  4,  2,  4,  5,  8,  9, 10, 10,  9,  8,  5,  1,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  2,  1,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
190,180,172,155,136,113,108, 53, 25, 12,  0,  0,  0,  0,  0,  0,  0,
189,185,175,157,137,118, 99, 58, 23,  1,  0,  0,  0,  0,  0,  0,  0,
182,182,178,164,141,118, 94, 66, 32,  0,  0,  0,  0,  0,  0,  0,  0,
170,171,174,168,149,124,100, 73, 44, 11,  0,  0,  0,  0,  0,  0,  0,
157,156,157,160,154,131,105, 82, 55, 26,  0,  0,  0,  0,  0,  0,  0,
134,135,135,136,139,132,107, 84, 62, 38, 12,  0,  0,  0,  0,  0,  0,
109,110,112,113,114,111,103, 85, 65, 45, 24,  1,  0,  0,  0,  0,  0,
 86, 87, 90, 90, 91, 91, 84, 77, 66, 50, 31, 13,  0,  0,  0,  0,  0,
 66, 67, 69, 70, 71, 71, 68, 62, 56, 49, 35, 19,  5,  0,  0,  0,  0,
 47, 48, 48, 49, 50, 51, 51, 47, 42, 38, 33, 22, 11,  0,  0,  0,  0,
 27, 27, 27, 26, 27, 29, 30, 30, 28, 25, 22, 19, 12,  5,  0,  0,  0,
  9,  9,  8,  5,  5,  6,  8, 10, 11, 11, 11, 10,  8,  6,  1,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2,  2,  2,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
173,167,154,140,121,100, 76, 70, 50,  5,  0,  0,  0,  0,  0,  0,  0,
172,168,157,142,123,104, 80, 59, 19,  0,  0,  0,  0,  0,  0,  0,  0,
170,167,161,148,127,107, 86, 59, 28,  0,  0,  0,  0,  0,  0,  0,  0,
159,160,160,154,137,114, 93, 68, 40,  8,  0,  0,  0,  0,  0,  0,  0,
147,148,149,151,144,125,102, 79, 53, 24,  0,  0,  0,  0,  0,  0,  0,
127,129,130,132,135,129,108, 84, 62, 37, 10,  0,  0,  0,  0,  0,  0,
106,107,108,109,111,111,106, 87, 66, 45, 23,  0,  0,  0,  0,  0,  0,
 88, 89, 88, 88, 89, 90, 86, 81, 67, 49, 30, 12,  0,  0,  0,  0,  0,
 67, 68, 70, 69, 70, 71, 70, 64, 59, 50, 34, 19,  4,  0,  0,  0,  0,
 48, 48, 49, 50, 51, 52, 52, 49, 44, 40, 34, 22, 10,  0,  0,  0,  0,
 29, 29, 28, 28, 30, 31, 32, 32, 30, 27, 24, 20, 12,  5,  0,  0,  0,
 11, 10,  9,  8,  8,  9, 10, 12, 14, 13, 13, 12,  9,  6,  1,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2,  3,  3,  2,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
155,150,139,125,108, 90, 68, 41, 29, 10,  0,  0,  0,  0,  0,  0,  0,
156,150,141,127,110, 92, 71, 46, 17,  0,  0,  0,  0,  0,  0,  0,  0,
154,151,143,130,115, 96, 77, 52, 23,  0,  0,  0,  0,  0,  0,  0,  0,
147,147,145,136,122,102, 83, 61, 34,  5,  0,  0,  0,  0,  0,  0,  0,
136,136,137,137,128,112, 92, 72, 47, 20,  0,  0,  0,  0,  0,  0,  0,
118,120,123,124,125,118,101, 81, 59, 34,  8,  0,  0,  0,  0,  0,  0,
100,101,103,105,106,107,103, 86, 65, 44, 21,  0,  0,  0,  0,  0,  0,
 84, 84, 85, 86, 87, 88, 86, 83, 67, 49, 29, 11,  0,  0,  0,  0,  0,
 67, 67, 68, 69, 70, 70, 70, 66, 61, 50, 34, 18,  4,  0,  0,  0,  0,
 48, 49, 50, 51, 52, 52, 52, 51, 47, 42, 35, 21, 10,  0,  0,  0,  0,
 29, 30, 30, 31, 32, 32, 33, 34, 32, 29, 26, 21, 12,  4,  0,  0,  0,
 13, 13, 12, 10, 11, 12, 13, 15, 16, 16, 15, 13, 10,  6,  1,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  3,  4,  4,  4,  2,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
137,132,121,111, 96, 81, 61, 36,  9,  0,  0,  0,  0,  0,  0,  0,  0,
138,133,124,113, 98, 83, 64, 40, 13,  0,  0,  0,  0,  0,  0,  0,  0,
137,134,126,114,101, 86, 68, 46, 20,  0,  0,  0,  0,  0,  0,  0,  0,
132,132,129,118,106, 92, 74, 53, 29,  3,  0,  0,  0,  0,  0,  0,  0,
123,123,124,121,111, 98, 81, 62, 39, 15,  0,  0,  0,  0,  0,  0,  0,
110,111,112,113,111,104, 90, 72, 51, 28,  5,  0,  0,  0,  0,  0,  0,
 94, 94, 97,100,100, 99, 95, 81, 62, 40, 18,  0,  0,  0,  0,  0,  0,
 80, 80, 81, 83, 85, 84, 85, 82, 66, 47, 28,  9,  0,  0,  0,  0,  0,
 65, 66, 67, 68, 69, 69, 68, 67, 63, 49, 32, 17,  2,  0,  0,  0,  0,
 49, 50, 50, 51, 52, 52, 52, 52, 49, 44, 34, 21,  9,  0,  0,  0,  0,
 30, 31, 32, 32, 33, 34, 34, 35, 35, 31, 28, 22, 12,  4,  0,  0,  0,
 14, 14, 14, 13, 14, 15, 16, 17, 19, 19, 17, 15, 12,  6,  1,  0,  0,
  1,  0,  0,  0,  0,  0,  0,  0,  2,  4,  5,  6,  6,  5,  2,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
119,114,107, 97, 85, 71, 55, 33,  9,  0,  0,  0,  0,  0,  0,  0,  0,
120,115,108, 98, 86, 73, 58, 36, 12,  0,  0,  0,  0,  0,  0,  0,  0,
120,116,109,100, 88, 76, 61, 41, 17,  0,  0,  0,  0,  0,  0,  0,  0,
117,116,112,102, 91, 80, 66, 47, 24,  2,  0,  0,  0,  0,  0,  0,  0,
109,110,110,107, 95, 85, 72, 54, 33, 11,  0,  0,  0,  0,  0,  0,  0,
 99,100,101,102, 98, 89, 79, 63, 43, 21,  1,  0,  0,  0,  0,  0,  0,
 87, 88, 89, 91, 91, 89, 83, 71, 54, 33, 13,  0,  0,  0,  0,  0,  0,
 75, 76, 77, 79, 81, 80, 79, 76, 62, 44, 25,  7,  0,  0,  0,  0,  0,
 63, 63, 64, 65, 67, 67, 66, 67, 63, 48, 31, 16,  1,  0,  0,  0,  0,
 48, 49, 50, 51, 52, 52, 52, 51, 51, 45, 33, 20,  8,  0,  0,  0,  0,
 31, 32, 33, 34, 35, 35, 36, 35, 36, 34, 29, 22, 12,  3,  0,  0,  0,
 16, 16, 16, 16, 17, 18, 19, 20, 20, 21, 19, 16, 12,  6,  0,  0,  0,
  3,  2,  2,  0,  0,  1,  2,  4,  6,  7,  8,  8,  7,  5,  2,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
103, 98, 93, 85, 74, 62, 49, 29,  9,  0,  0,  0,  0,  0,  0,  0,  0,
103, 99, 93, 85, 74, 63, 50, 32, 11,  0,  0,  0,  0,  0,  0,  0,  0,
103,100, 94, 86, 76, 65, 53, 36, 15,  0,  0,  0,  0,  0,  0,  0,  0,
101,100, 96, 88, 79, 68, 57, 41, 20,  1,  0,  0,  0,  0,  0,  0,  0,
 95, 96, 96, 92, 82, 72, 62, 47, 27,  8,  0,  0,  0,  0,  0,  0,  0,
 88, 89, 89, 90, 85, 75, 67, 55, 36, 16,  0,  0,  0,  0,  0,  0,  0,
 79, 80, 81, 81, 81, 78, 70, 62, 45, 26,  8,  0,  0,  0,  0,  0,  0,
 70, 70, 71, 73, 73, 72, 70, 66, 54, 37, 19,  3,  0,  0,  0,  0,  0,
 59, 60, 61, 62, 64, 64, 62, 62, 59, 44, 28, 13,  0,  0,  0,  0,  0,
 47, 48, 48, 49, 50, 51, 51, 50, 51, 46, 32, 19,  7,  0,  0,  0,  0,
 33, 33, 33, 34, 35, 36, 36, 36, 36, 35, 31, 21, 11,  3,  0,  0,  0,
 18, 18, 18, 18, 19, 20, 21, 21, 22, 23, 21, 18, 13,  6,  0,  0,  0,
  5,  5,  4,  4,  4,  5,  6,  7,  9, 10, 11, 10,  8,  6,  2,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  2,  2,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 87, 84, 79, 72, 62, 52, 41, 25,  8,  0,  0,  0,  0,  0,  0,  0,  0,
 87, 84, 79, 73, 63, 53, 42, 27,  9,  0,  0,  0,  0,  0,  0,  0,  0,
 87, 85, 80, 73, 65, 54, 44, 30, 12,  0,  0,  0,  0,  0,  0,  0,  0,
 86, 85, 82, 75, 67, 57, 48, 34, 17,  1,  0,  0,  0,  0,  0,  0,  0,
 81, 82, 82, 77, 69, 60, 51, 40, 23,  6,  0,  0,  0,  0,  0,  0,  0,
 76, 76, 77, 77, 72, 63, 55, 46, 30, 13,  0,  0,  0,  0,  0,  0,  0,
 70, 70, 71, 71, 70, 66, 58, 51, 38, 21,  5,  0,  0,  0,  0,  0,  0,
 63, 63, 64, 64, 64, 62, 60, 54, 45, 30, 14,  1,  0,  0,  0,  0,  0,
 54, 55, 56, 57, 57, 56, 54, 54, 49, 38, 23, 10,  0,  0,  0,  0,  0,
 45, 45, 46, 47, 48, 49, 48, 47, 47, 43, 29, 16,  5,  0,  0,  0,  0,
 32, 33, 33, 34, 35, 36, 36, 35, 35, 36, 32, 20, 10,  1,  0,  0,  0,
 19, 19, 19, 20, 21, 22, 22, 22, 22, 23, 23, 19, 12,  5,  0,  0,  0,
  7,  7,  7,  7,  8,  8,  9, 10, 11, 12, 13, 12, 10,  6,  2,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  2,  3,  3,  3,  2,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 73, 70, 66, 60, 51, 42, 33, 20,  7,  0,  0,  0,  0,  0,  0,  0,  0,
 73, 70, 66, 60, 52, 43, 34, 22,  8,  0,  0,  0,  0,  0,  0,  0,  0,
 72, 70, 66, 61, 53, 44, 35, 24, 10,  0,  0,  0,  0,  0,  0,  0,  0,
 71, 71, 68, 62, 55, 46, 38, 28, 13,  1,  0,  0,  0,  0,  0,  0,  0,
 68, 68, 68, 64, 56, 48, 40, 32, 18,  5,  0,  0,  0,  0,  0,  0,  0,
 64, 64, 65, 64, 59, 51, 44, 36, 24, 10,  0,  0,  0,  0,  0,  0,  0,
 59, 59, 60, 60, 59, 54, 46, 40, 31, 16,  4,  0,  0,  0,  0,  0,  0,
 54, 54, 55, 55, 54, 52, 49, 42, 36, 24, 10,  0,  0,  0,  0,  0,  0,
 48, 48, 48, 49, 49, 47, 45, 44, 39, 31, 17,  6,  0,  0,  0,  0,  0,
 40, 41, 41, 42, 43, 42, 41, 39, 39, 35, 24, 12,  3,  0,  0,  0,  0,
 31, 31, 32, 33, 34, 34, 34, 33, 33, 34, 30, 18,  8,  0,  0,  0,  0,
 20, 20, 20, 21, 22, 22, 23, 23, 23, 23, 24, 21, 12,  5,  0,  0,  0,
  9,  9,  9,  9, 10, 11, 11, 12, 12, 13, 14, 14, 11,  6,  1,  0,  0,
  0,  0,  0,  0,  0,  0,  1,  2,  3,  4,  5,  5,  5,  4,  3,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 58, 55, 52, 47, 40, 32, 25, 15,  5,  0,  0,  0,  0,  0,  0,  0,  0,
 58, 55, 52, 47, 41, 33, 25, 17,  6,  0,  0,  0,  0,  0,  0,  0,  0,
 57, 56, 53, 48, 41, 34, 26, 18,  7,  0,  0,  0,  0,  0,  0,  0,  0,
 56, 56, 54, 49, 43, 35, 28, 21, 10,  1,  0,  0,  0,  0,  0,  0,  0,
 54, 55, 54, 51, 44, 37, 30, 24, 14,  3,  0,  0,  0,  0,  0,  0,  0,
 51, 51, 52, 51, 47, 39, 33, 27, 18,  7,  0,  0,  0,  0,  0,  0,  0,
 48, 48, 48, 48, 47, 42, 35, 30, 23, 12,  3,  0,  0,  0,  0,  0,  0,
 43, 44, 44, 44, 43, 42, 37, 32, 26, 18,  8,  0,  0,  0,  0,  0,  0,
 39, 39, 40, 40, 39, 38, 36, 34, 29, 23, 13,  4,  0,  0,  0,  0,  0,
 34, 34, 35, 35, 35, 34, 32, 31, 30, 26, 19,  9,  1,  0,  0,  0,  0,
 28, 28, 28, 29, 29, 29, 28, 27, 27, 27, 22, 14,  5,  0,  0,  0,  0,
 19, 19, 20, 20, 21, 21, 22, 21, 22, 22, 22, 18, 10,  3,  0,  0,  0,
 10, 10, 10, 11, 11, 12, 12, 12, 13, 13, 14, 14, 12,  6,  1,  0,  0,
  2,  2,  2,  2,  2,  3,  3,  4,  5,  5,  6,  7,  7,  5,  3,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 41, 40, 37, 34, 28, 22, 16, 10,  3,  0,  0,  0,  0,  0,  0,  0,  0,
 42, 40, 38, 34, 29, 23, 17, 11,  4,  0,  0,  0,  0,  0,  0,  0,  0,
 42, 41, 38, 35, 29, 23, 18, 12,  5,  0,  0,  0,  0,  0,  0,  0,  0,
 41, 41, 39, 35, 30, 25, 19, 14,  6,  0,  0,  0,  0,  0,  0,  0,  0,
 40, 40, 40, 37, 32, 26, 21, 16,  9,  2,  0,  0,  0,  0,  0,  0,  0,
 38, 38, 38, 38, 34, 28, 23, 18, 12,  5,  0,  0,  0,  0,  0,  0,  0,
 35, 36, 36, 36, 35, 30, 25, 20, 15,  8,  2,  0,  0,  0,  0,  0,  0,
 32, 33, 33, 33, 32, 31, 27, 22, 18, 12,  5,  0,  0,  0,  0,  0,  0,
 29, 29, 30, 30, 29, 28, 27, 24, 20, 15,  9,  2,  0,  0,  0,  0,  0,
 26, 26, 26, 27, 26, 25, 24, 23, 22, 18, 13,  6,  0,  0,  0,  0,  0,
 22, 23, 23, 23, 23, 22, 21, 20, 20, 19, 15, 10,  3,  0,  0,  0,  0,
 17, 17, 17, 18, 18, 18, 18, 17, 17, 17, 17, 13,  6,  1,  0,  0,  0,
 10, 10, 10, 11, 11, 11, 12, 12, 12, 13, 13, 13, 10,  4,  0,  0,  0,
  4,  4,  4,  4,  4,  4,  5,  5,  6,  6,  7,  7,  7,  6,  2,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  2,  2,  2,  1,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 24, 24, 22, 20, 16, 12,  9,  5,  1,  1,  0,  0,  0,  0,  0,  0,  0,
 25, 24, 23, 20, 17, 13,  9,  6,  2,  1,  0,  0,  0,  0,  0,  0,  0,
 25, 24, 23, 21, 17, 13, 10,  6,  2,  0,  0,  0,  0,  0,  0,  0,  0,
 25, 25, 24, 21, 18, 14, 11,  7,  3,  0,  0,  0,  0,  0,  0,  0,  0,
 24, 25, 24, 23, 19, 15, 12,  9,  5,  1,  0,  0,  0,  0,  0,  0,  0,
 23, 24, 24, 24, 21, 17, 13, 10,  6,  2,  0,  0,  0,  0,  0,  0,  0,
 22, 23, 23, 23, 22, 19, 15, 12,  9,  4,  1,  0,  0,  0,  0,  0,  0,
 21, 21, 21, 21, 21, 20, 17, 14, 11,  7,  2,  0,  0,  0,  0,  0,  0,
 19, 19, 19, 19, 19, 18, 18, 15, 12,  9,  5,  1,  0,  0,  0,  0,  0,
 17, 17, 17, 17, 17, 17, 16, 15, 14, 11,  7,  3,  0,  0,  0,  0,  0,
 15, 15, 16, 16, 15, 15, 14, 14, 14, 13, 10,  6,  2,  0,  0,  0,  0,
 13, 13, 13, 13, 13, 13, 12, 12, 12, 12, 11,  8,  4,  0,  0,  0,  0,
  9,  9,  9,  9,  9, 10, 10, 10,  9,  9,  9,  9,  6,  2,  0,  0,  0,
  4,  4,  4,  4,  5,  5,  5,  5,  6,  6,  6,  7,  6,  4,  1,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  1,  1,  2,  2,  3,  3,  3,  2,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  7,  7,  6,  6,  5,  3,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  7,  7,  7,  6,  5,  3,  2,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  7,  8,  7,  7,  5,  4,  2,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  8,  8,  8,  7,  6,  4,  3,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  8,  9,  9,  8,  7,  5,  3,  2,  1,  0,  0,  0,  0,  0,  0,  0,  0,
  8,  9,  9,  9,  8,  6,  4,  3,  1,  0,  0,  0,  0,  0,  0,  0,  0,
  9,  9,  9,  9,  9,  7,  6,  4,  3,  1,  0,  0,  0,  0,  0,  0,  0,
  9,  9,  9,  9,  9,  9,  7,  5,  4,  2,  0,  0,  0,  0,  0,  0,  0,
  8,  8,  9,  9,  9,  8,  8,  7,  5,  3,  1,  0,  0,  0,  0,  0,  0,
  8,  8,  8,  8,  8,  8,  8,  7,  6,  5,  3,  1,  0,  0,  0,  0,  0,
  8,  8,  8,  8,  8,  7,  7,  7,  7,  6,  4,  2,  1,  0,  0,  0,  0,
  7,  7,  7,  7,  7,  7,  7,  6,  6,  6,  5,  3,  2,  0,  0,  0,  0,
  6,  6,  6,  6,  6,  6,  6,  6,  5,  5,  5,  4,  3,  1,  0,  0,  0,
  3,  3,  3,  4,  4,  4,  4,  4,  4,  4,  4,  4,  3,  2,  0,  0,  0,
  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,  1,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  2,  2,  2,  2,  2,  2,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,
  2,  2,  2,  2,  2,  2,  2,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,
  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\api\recolor.hpp ===
/**************************************************************************\
* 
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   recolor.hpp
*
* Abstract:
*
*   GpRecolor and GpRecolorObject class declarations
*
\**************************************************************************/

#ifndef _RECOLOR_HPP
#define _RECOLOR_HPP

//#define CMYK_INTERPOLATION_ENABLED
#ifdef CMYK_INTERPOLATION_ENABLED

//--------------------------------------------------------------------------
// K2_Tetrahedral class
//
// Used to do tetrahedral interpolation for color space conversion
//--------------------------------------------------------------------------

#define K2_TETRAHEDRAL_MAX_TABLES 4

class K2_Tetrahedral
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagK2_Tetrahedral : ObjectTagInvalid;
    }

public:

    K2_Tetrahedral(BYTE*, int, int, int);
    ~K2_Tetrahedral();

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagK2_Tetrahedral) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid K2_Tetrahedral");
        }
    #endif

        return (Tag == ObjectTagK2_Tetrahedral);
    }

    VOID Transform(BYTE*, BYTE*);

private:

    int inDimension, outDimension;
    int tableDimension;
    unsigned int *table[K2_TETRAHEDRAL_MAX_TABLES];

    int addshift(int);
};
#endif

//--------------------------------------------------------------------------
// GpRecolorObject class
//--------------------------------------------------------------------------

class GpRecolorObject
{
    friend class GpMemoryBitmap;

public:

    GpRecolorObject()
    {
        validFlags = 0;

        colorMapSize = 0;
        colorMap = NULL;

        grayMatrixLUT = NULL;

        profiles[0] = NULL;
        profiles[1] = NULL;
        transformSrgbToCmyk = NULL;
#ifdef CMYK_INTERPOLATION_ENABLED
        interpSrgbToCmyk = NULL;
#endif
        cmykProfileName = NULL;
        CmykState = CmykByMapping;
    }

    ~GpRecolorObject()
    {
        if (colorMap)
            GpFree(colorMap);

        if (grayMatrixLUT)
            GpFree(grayMatrixLUT);

        CleanupCmykSeparation();
    }

    VOID Dispose()
    {
        delete this;
    }

    VOID Flush();

    // Perform recoloring:

    VOID
    ColorAdjust(
        ARGB* pixbufIn,
        UINT  countIn
        );

    // Recoloring helper functions:

    VOID
    ComputeColorTwist(
        ARGB* pixbufIn,
        UINT  countIn
        );

    VOID
    DoCmykSeparation(
        ARGB* pixbuf,
        UINT  count
        );

    // Methods to set recoloring attributes:

    HRESULT
    SetColorMatrix(
        ColorMatrix *colorMatrix,
        ColorMatrixFlags flags = ColorMatrixFlagsDefault
        )
    {
        if (colorMatrix &&
            ((flags == ColorMatrixFlagsDefault) || (flags == ColorMatrixFlagsSkipGrays)))
        {
            matrix = *colorMatrix;
            matrixFlags = flags;
            SetFlag(ValidMatrix);
            ClearFlag(ValidGrayMatrix);
            return S_OK;
        }
        else
            return E_INVALIDARG;
    }

    HRESULT
    SetColorMatrices(
        ColorMatrix *colorMatrix,
        ColorMatrix *grayMatrix,
        ColorMatrixFlags flags = ColorMatrixFlagsDefault
        )
    {
        if ((grayMatrix == NULL) || (flags != ColorMatrixFlagsAltGray))
            return SetColorMatrix(colorMatrix, flags);

        if (grayMatrixLUT == NULL)
        {
            grayMatrixLUT = static_cast<ARGB *>(GpMalloc(256*sizeof(ARGB)));

            if (grayMatrixLUT == NULL)
            {
                ClearFlag(ValidGrayMatrix);
                return E_OUTOFMEMORY;
            }
        }

        if (colorMatrix)
        {
            matrix = *colorMatrix;
            matrixGray = *grayMatrix;
            matrixFlags = flags;
            SetFlag(ValidMatrix);
            SetFlag(ValidGrayMatrix);
            return S_OK;
        }
        else
            return E_INVALIDARG;
    }

    HRESULT ClearColorMatrices()
    {
        ClearFlag(ValidMatrix);
        ClearFlag(ValidGrayMatrix);
        return S_OK;
    }

    HRESULT SetThreshold(REAL threshold)
    {
        bilevelThreshold = threshold;
        SetFlag(ValidBilevel);
        return S_OK;
    }

    HRESULT ClearThreshold()
    {
        ClearFlag(ValidBilevel);
        return S_OK;
    }

    HRESULT SetGamma(REAL gamma)
    {
        if ( gamma <= 0.0 )
        {
            WARNING(("GpRecolorObject::SetGamma---can't set gamma <= 0.0"));
            return E_FAIL;
        }

        extraGamma = gamma;
        SetFlag(ValidGamma);
        return S_OK;
    }

    HRESULT ClearGamma()
    {
        ClearFlag(ValidGamma);
        return S_OK;
    }

    HRESULT SetNoOp()
    {
        SetFlag(ValidNoOp);
        return S_OK;
    }

    HRESULT ClearNoOp()
    {
        ClearFlag(ValidNoOp);
        return S_OK;
    }

    HRESULT SetColorKey(Color* colorLow, Color* colorHigh)
    {
        if (colorLow && colorHigh &&
            (colorLow->GetRed()   <= colorHigh->GetRed()  ) &&
            (colorLow->GetGreen() <= colorHigh->GetGreen()) &&
            (colorLow->GetBlue()  <= colorHigh->GetBlue() ))
        {
            colorKeyLow  = *colorLow;
            colorKeyHigh = *colorHigh;
            SetFlag(ValidColorKeys);
            return S_OK;
        }
        else
            return E_INVALIDARG;
    }

    HRESULT ClearColorKey()
    {
        ClearFlag(ValidColorKeys);
        return S_OK;
    }

    HRESULT SetOutputChannel(ColorChannelFlags channelFlags)
    {
        if ( (channelFlags >= ColorChannelFlagsC)
           &&(channelFlags < ColorChannelFlagsLast) )
        {
            ChannelIndex = channelFlags;

            SetFlag(ValidOutputChannel);

            return S_OK;
        }
        else
        {
            return E_INVALIDARG;
        }
    }
    
    HRESULT ClearOutputChannel()
    {
        ClearFlag(ValidOutputChannel);
        return S_OK;        
    }

    HRESULT SetOutputChannelProfile(WCHAR *profile)
    {
        HRESULT hr = SetupCmykSeparation(profile);

        if (SUCCEEDED(hr))
        {
            SetFlag(ValidChannelProfile);
        }

        return hr;
    }
    
    HRESULT ClearOutputChannelProfile()
    {
        CleanupCmykSeparation();
        ClearFlag(ValidChannelProfile);

        return S_OK;        
    }

    HRESULT SetRemapTable(UINT mapSize, ColorMap *map)
    {
        if (mapSize && map)
        {
            if (mapSize > colorMapSize)
            {
                VOID *newmap = GpMalloc(mapSize * sizeof(ColorMap));

                if (newmap)
                {
                    if (colorMap)
                        GpFree(colorMap);

                    colorMapSize = mapSize;
                    colorMap = static_cast<ColorMap *>(newmap);
                }
                else
                    return E_OUTOFMEMORY;
            }

            SetFlag(ValidRemap);
            colorMapCount = mapSize;
            memcpy(static_cast<VOID*>(colorMap), static_cast<VOID*>(map),
                   mapSize * sizeof(ColorMap));

            return S_OK;
        }
        else
            return E_INVALIDARG;
    }

    HRESULT ClearRemapTable()
    {
        ClearFlag(ValidRemap);
        return S_OK;
    }

public:

    enum
    {
        ValidNoOp           = 0x00000001,
        ValidMatrix         = 0x00000002,
        ValidBilevel        = 0x00000004,
        ValidGamma          = 0x00000008,
        ValidColorKeys      = 0x00000010,
        ValidRemap          = 0x00000020,
        ValidOutputChannel  = 0x00000040,
        ValidGrayMatrix     = 0x00000080,
        ValidChannelProfile = 0x00000100
    };

public:

    UINT validFlags;

    ColorMatrixFlags matrixFlags;
    ColorMatrix matrix;
    ColorMatrix matrixGray;

    REAL bilevelThreshold;
    REAL extraGamma;

    Color colorKeyLow;
    Color colorKeyHigh;

    ColorChannelFlags   ChannelIndex;   
    
    UINT colorMapSize;
    UINT colorMapCount;
    ColorMap *colorMap;

private:

    VOID SetFlag(UINT flag)
    {
        validFlags |= flag;
    }

    VOID ClearFlag(UINT flag)
    {
        validFlags &= ~flag;
    }

public:

    enum
    {
        MatrixNone      = 0,
        Matrix4x4       = 1,
        Matrix5x5       = 2,
        MatrixScale3    = 3,    // used for contrast adjustments
        MatrixScale4    = 4,    // used for contrast adjustments
        MatrixTranslate = 5     // used for brightness adjustments
    };

private:

    UINT matrixType;
    BOOL gammaLut;
    BYTE lutR[256];
    BYTE lutG[256];
    BYTE lutB[256];
    BYTE lutA[256];
    BYTE lut[256];
    ARGB *grayMatrixLUT;

    // CMYK separation data

    enum
    {
        CmykByMapping       = 0,
        CmykByICM           = 1,
        CmykByInterpolation = 2
    };

    UINT CmykState;
    WCHAR *cmykProfileName;             // filename of CMYK ICC profile
    HPROFILE profiles[2];               // for ICM-based separation
    HTRANSFORM transformSrgbToCmyk;     // for ICM-based separation
#ifdef CMYK_INTERPOLATION_ENABLED
    K2_Tetrahedral* interpSrgbToCmyk;   // for interpolation-based separation
#endif

    VOID ComputeLuts();

    inline BOOL IsPureGray(ARGB* argb)
    {
        // Access the RGB channels through byte pointer comparisons.

        return (
            (*(BYTE*)(argb) == (*( (BYTE*)(argb)+1 ))) &&
            (*(BYTE*)(argb) == (*( (BYTE*)(argb)+2 )))
        );
    }
    
    inline BYTE ByteSaturate(INT i) 
    {
        if(i > 255) {i = 255;}
        if(i < 0) {i = 0;}                   
        return (BYTE)i;
    }

    VOID TransformColor5x5(
        ARGB *buf, 
        INT count, 
        ColorMatrix cmatrix
    );
    
    VOID TransformColor5x5AltGrays(
        ARGB *buf, 
        INT count, 
        ColorMatrix cmatrix,
        BOOL skip
    );
    
    VOID TransformColorGammaLUT(ARGB *buf, INT count);
    
    VOID TransformColorScale4(
        ARGB *buf, 
        INT count
    );
    
    VOID TransformColorScale4AltGrays(
        ARGB *buf, 
        INT count,
        BOOL skip
    );
    
    VOID TransformColorTranslate(
        ARGB *buf, 
        INT count, 
        ColorMatrix cmatrix
    );
    
    VOID TransformColorTranslateAltGrays(
        ARGB *buf, 
        INT count, 
        ColorMatrix cmatrix,
        BOOL skip
    );

    VOID
    DoCmykSeparationByICM(
        ARGB* pixbuf,
        UINT  count
        );

#ifdef CMYK_INTERPOLATION_ENABLED
    VOID
    DoCmykSeparationByInterpolation(
        ARGB* pixbuf,
        UINT  count
        );
#endif

    VOID
    DoCmykSeparationByMapping(
        ARGB* pixbuf,
        UINT  count
        );

    HRESULT SetupCmykSeparation(WCHAR *profile);
    VOID CleanupCmykSeparation();
};

//--------------------------------------------------------------------------
// GpRecolor class
//--------------------------------------------------------------------------

class GpRecolor
{
protected:
    // If NULL, use RecolorObject[ColorAdjustTypeDefault], unless
    // IsIdentity is TRUE.
    
    GpRecolorObject *       RecolorObject[ColorAdjustTypeCount];

    // If set, there is no recoloring for this type of object
    BYTE                    IsIdentity[ColorAdjustTypeCount];
    
public:

    GpRecolor()
    {
        GpMemset(RecolorObject, 0, ColorAdjustTypeCount * sizeof(RecolorObject[0]));
        GpMemset(IsIdentity,    0, ColorAdjustTypeCount * sizeof(IsIdentity[0]));
    }

    ~GpRecolor()
    {
        for (INT i = 0; i < ColorAdjustTypeCount; i++)
        {
            delete RecolorObject[i];
        }
    }

    VOID Dispose()
    {
        delete this;
    }

    // Set to identity, regardless of what the default color adjustment is.
    VOID
    SetToIdentity(
        ColorAdjustType     type
        )
    {
        if ((type == ColorAdjustTypeDefault) || ValidColorAdjustType(type))
        {
            delete RecolorObject[type];
            RecolorObject[type] = NULL;
            IsIdentity[type] = TRUE;
        }
    }

    // Remove any individual color adjustments, and go back to using the default
    VOID
    Reset(
        ColorAdjustType     type
        )
    {
        if ((type == ColorAdjustTypeDefault) || ValidColorAdjustType(type))
        {
            delete RecolorObject[type];
            RecolorObject[type] = NULL;
            IsIdentity[type] = FALSE;
        }
    }

    VOID
    ColorAdjust(
        ARGB*               pixbufIn,
        UINT                countIn,
        ColorAdjustType     type
        ) const
    {
        GpRecolorObject *   recolorObject = UseRecolorObject(type);
        
        if (recolorObject != NULL)
        {
            recolorObject->ColorAdjust(pixbufIn, countIn);
        }
    }

    VOID
    ColorAdjustCOLORREF(
        COLORREF *          color,
        ColorAdjustType     type
        ) const
    {
        GpRecolorObject *   recolorObject = UseRecolorObject(type);
        
        if (recolorObject != NULL)
        {
            ARGB    argb = COLORREFToARGB(*color);
            recolorObject->ColorAdjust(&argb, 1);
            *color = ARGBToCOLORREF(argb);
        }
    }

    UINT
    GetValidFlags(
        ColorAdjustType     type
        ) const
    {
        UINT                validFlags    = 0;
        GpRecolorObject *   recolorObject = UseRecolorObject(type);

        if (recolorObject != NULL)
        {
            validFlags = recolorObject->validFlags;
        }
        return validFlags;
    }

    BOOL 
    HasRecoloring(
        ColorAdjustType type
        ) const
    {
        if (type != ColorAdjustTypeAny)
        {
            return (GetValidFlags(type) != 0);
        }
        else
        {
            GpRecolorObject *   recolorObject;
            
            for (INT i = ColorAdjustTypeDefault; i < ColorAdjustTypeCount; i++)
            {
                recolorObject = ClearRecolorObject((ColorAdjustType)i);
                if ((recolorObject != NULL) && (recolorObject->validFlags != 0))
                {
                    return TRUE;
                }
            }
        }
        return FALSE;
    }

    ARGB
    GetColorKeyLow(
        ColorAdjustType     type
        ) const
    {
        ARGB                argb          = 0;
        GpRecolorObject *   recolorObject = UseRecolorObject(type);

        if (recolorObject != NULL)
        {
            argb = recolorObject->colorKeyLow.GetValue();
        }
        return argb;
    }

    ARGB
    GetColorKeyHigh(
        ColorAdjustType     type
        ) const
    {
        ARGB                argb          = 0;
        GpRecolorObject *   recolorObject = UseRecolorObject(type);

        if (recolorObject != NULL)
        {
            argb = recolorObject->colorKeyHigh.GetValue();
        }
        return argb;
    }

    ColorChannelFlags
    GetChannelIndex(
        ColorAdjustType     type
        ) const
    {
        ColorChannelFlags   channelIndex  = ColorChannelFlagsC;
        GpRecolorObject *   recolorObject = UseRecolorObject(type);

        if (recolorObject != NULL)
        {
            channelIndex = recolorObject->ChannelIndex;
        }
        return channelIndex;
    }

    // Flush all the recolor objects.
    VOID Flush()
    {
        INT     type;
        
        for (type = ColorAdjustTypeDefault; type < ColorAdjustTypeCount; type++)
        {
            if ((RecolorObject[type] != NULL) &&
                ((type == ColorAdjustTypeDefault) || 
                 (RecolorObject[type] != RecolorObject[ColorAdjustTypeDefault])))
            {
                RecolorObject[type]->Flush();
            }
        }
    }

    HRESULT
    SetColorMatrices(
        ColorAdjustType type,
        ColorMatrix *colorMatrix,
        ColorMatrix *grayMatrix,
        ColorMatrixFlags flags = ColorMatrixFlagsDefault
        )
    {
        if (colorMatrix || grayMatrix)
        {
            GpRecolorObject *   recolorObject = SetRecolorObject(type);

            if (recolorObject != NULL)
            {
                return recolorObject->SetColorMatrices(colorMatrix,
                                                       grayMatrix,
                                                       flags);
            }
        }
        return E_FAIL;
    }

    HRESULT ClearColorMatrices(
        ColorAdjustType type
        )
    {
        GpRecolorObject *   recolorObject = ClearRecolorObject(type);
        
        if (recolorObject != NULL)
        {
            recolorObject->ClearColorMatrices();
        }
        return S_OK;    // nothing to clear if recolorObject is NULL
    }

    HRESULT SetThreshold(
        ColorAdjustType type,
        REAL threshold
        )
    {
        GpRecolorObject *   recolorObject = SetRecolorObject(type);

        if (recolorObject != NULL)
        {
            return recolorObject->SetThreshold(threshold);
        }
        return E_FAIL;
    }

    HRESULT ClearThreshold(
        ColorAdjustType type
        )
    {
        GpRecolorObject *   recolorObject = ClearRecolorObject(type);
        
        if (recolorObject != NULL)
        {
            recolorObject->ClearThreshold();
        }
        return S_OK;    // nothing to clear if recolorObject is NULL
    }

    HRESULT SetGamma(
        ColorAdjustType type,
        REAL gamma
        )
    {
        GpRecolorObject *   recolorObject = SetRecolorObject(type);

        if (recolorObject != NULL)
        {
            return recolorObject->SetGamma(gamma);
        }
        return E_FAIL;
    }

    HRESULT ClearGamma(
        ColorAdjustType type
        )
    {
        GpRecolorObject *   recolorObject = ClearRecolorObject(type);
        
        if (recolorObject != NULL)
        {
            recolorObject->ClearGamma();
        }
        return S_OK;    // nothing to clear if recolorObject is NULL
    }

    HRESULT SetNoOp(
        ColorAdjustType type
        )
    {
        GpRecolorObject *   recolorObject = SetRecolorObject(type);

        if (recolorObject != NULL)
        {
            return recolorObject->SetNoOp();
        }
        return E_FAIL;
    }

    HRESULT ClearNoOp(
        ColorAdjustType type
        )
    {
        GpRecolorObject *   recolorObject = ClearRecolorObject(type);
        
        if (recolorObject != NULL)
        {
            recolorObject->ClearNoOp();
        }
        return S_OK;    // nothing to clear if recolorObject is NULL
    }

    HRESULT SetColorKey(
        ColorAdjustType type,
        Color* colorLow, 
        Color* colorHigh
        )
    {
        if (colorLow && colorHigh &&
            (colorLow->GetRed()   <= colorHigh->GetRed()  ) &&
            (colorLow->GetGreen() <= colorHigh->GetGreen()) &&
            (colorLow->GetBlue()  <= colorHigh->GetBlue() ))
        {
            GpRecolorObject *   recolorObject = SetRecolorObject(type);

            if (recolorObject != NULL)
            {
                return recolorObject->SetColorKey(colorLow, colorHigh);
            }
        }
        return E_FAIL;
    }

    HRESULT ClearColorKey(
        ColorAdjustType type
        )
    {
        GpRecolorObject *   recolorObject = ClearRecolorObject(type);
        
        if (recolorObject != NULL)
        {
            recolorObject->ClearColorKey();
        }
        return S_OK;    // nothing to clear if recolorObject is NULL
    }

    HRESULT SetOutputChannel(
        ColorAdjustType type,
        ColorChannelFlags channelFlags
        )
    {
        if ( (channelFlags >= ColorChannelFlagsC)
           &&(channelFlags < ColorChannelFlagsLast) )
        {
            GpRecolorObject *   recolorObject = SetRecolorObject(type);

            if (recolorObject != NULL)
            {
                return recolorObject->SetOutputChannel(channelFlags);
            }
        }
        return E_FAIL;
    }
    
    HRESULT ClearOutputChannel(
        ColorAdjustType type
        )
    {
        GpRecolorObject *   recolorObject = ClearRecolorObject(type);
        
        if (recolorObject != NULL)
        {
            recolorObject->ClearOutputChannel();
        }
        return S_OK;    // nothing to clear if recolorObject is NULL
    }

    HRESULT SetOutputChannelProfile(
        ColorAdjustType type,
        WCHAR *profile
        )
    {
        if (profile)
        {
            GpRecolorObject *   recolorObject = SetRecolorObject(type);

            if (recolorObject != NULL)
            {
                return recolorObject->SetOutputChannelProfile(profile);
            }
        }
        return E_FAIL;
    }
    
    HRESULT ClearOutputChannelProfile(
        ColorAdjustType type
        )
    {
        GpRecolorObject *   recolorObject = ClearRecolorObject(type);
        
        if (recolorObject != NULL)
        {
            recolorObject->ClearOutputChannelProfile();
        }
        return S_OK;    // nothing to clear if recolorObject is NULL
    }

    HRESULT SetRemapTable(
        ColorAdjustType type,
        UINT mapSize, 
        ColorMap *map
        )
    {
        if (mapSize && map)
        {
            GpRecolorObject *   recolorObject = SetRecolorObject(type);

            if (recolorObject != NULL)
            {
                return recolorObject->SetRemapTable(mapSize, map);
            }
        }
        return E_FAIL;
    }

    HRESULT ClearRemapTable(
        ColorAdjustType type
        )
    {
        GpRecolorObject *   recolorObject = ClearRecolorObject(type);
        
        if (recolorObject != NULL)
        {
            recolorObject->ClearRemapTable();
        }
        return S_OK;    // nothing to clear if recolorObject is NULL
    }

protected:
    BOOL ValidColorAdjustType(ColorAdjustType type) const
    {
        return ((type > ColorAdjustTypeDefault) && (type < ColorAdjustTypeCount));
    }

    // Get a recolor object for doing a color adjustment; if NULL, use default
    GpRecolorObject *
    UseRecolorObject(
        ColorAdjustType     type
        ) const
    {
        GpRecolorObject *   recolorObject = NULL;

        if (ValidColorAdjustType(type))
        {
            recolorObject = RecolorObject[type];

            if ((recolorObject == NULL) && (!IsIdentity[type]))
            {
                recolorObject = RecolorObject[ColorAdjustTypeDefault];
            }
        }
        return recolorObject;
    }

    // Get a recolor object to clear; if there isn't one, then nothing to clear
    GpRecolorObject *
    ClearRecolorObject(
        ColorAdjustType     type
        ) const
    {
        if ((type == ColorAdjustTypeDefault) || ValidColorAdjustType(type))
        {
            return RecolorObject[type];
        }
        return NULL;
    }

    // Get a recolor object to set; if there isn't one, create one
    GpRecolorObject *
    SetRecolorObject(
        ColorAdjustType     type
        )
    {
        GpRecolorObject *   recolorObject = NULL;
        
        if ((type == ColorAdjustTypeDefault) || ValidColorAdjustType(type))
        {
            recolorObject = RecolorObject[type];

            if (recolorObject == NULL)
            {
                recolorObject = new GpRecolorObject();
                RecolorObject[type] = recolorObject;
                if (recolorObject != NULL)
                {
                    IsIdentity[type] = FALSE;
                }
            }
        }
        return recolorObject;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\bmp\bmpcodec.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   bmpcodec.cpp
*
* Abstract:
*
*   Shared methods for the bitmap codec
*
* Revision History:
*
*   5/10/1999 OriG
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "bmpcodec.hpp"


/**************************************************************************\
*
* Function Description:
*
*     Constructor
*
* Return Value:
*
*   none
*
\**************************************************************************/

GpBmpCodec::GpBmpCodec(
    void
    )
{
    comRefCount   = 1;
}

/**************************************************************************\
*
* Function Description:
*
*     Destructor
*
* Return Value:
*
*   none
*
\**************************************************************************/

GpBmpCodec::~GpBmpCodec(
    void
    )
{
}

/**************************************************************************\
*
* Function Description:
*
*     QueryInterface
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP
GpBmpCodec::QueryInterface(
    REFIID riid,
    VOID** ppv
    )
{
    if (riid == IID_IImageDecoder)
    {
        *ppv = static_cast<IImageDecoder*>(this);
    }
    else if (riid == IID_IImageEncoder)
    {    
        *ppv = static_cast<IImageEncoder*>(this);
    }
    else if (riid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(static_cast<IImageDecoder*>(this));
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     AddRef
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP_(ULONG)
GpBmpCodec::AddRef(
    VOID)
{
    return InterlockedIncrement(&comRefCount);
}

/**************************************************************************\
*
* Function Description:
*
*     Release
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP_(ULONG)
GpBmpCodec::Release(
    VOID)
{
    ULONG count = InterlockedDecrement(&comRefCount);

    if (count == 0)
    {
        delete this;
    }

    return count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\bmp\bmpcodec.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   bmpcodec.hpp
*
* Abstract:
*
*   Header file for the bitmap encoder/decoder
*
* Revision History:
*
*   5/13/1999 OriG (Ori Gershony)
*       Created it.
*
*   2/7/2000  OriG (Ori Gershony)
*       Move encoder and decoder into separate classes
*
\**************************************************************************/

#include "bmpdecoder.hpp"
#include "bmpencoder.hpp"

class GpBmpCodec : public GpBmpDecoder, public GpBmpEncoder
{
protected:
    LONG comRefCount;       // COM object reference count    

public:

    // Constructor and Destructor
    
    GpBmpCodec::GpBmpCodec(void);
    GpBmpCodec::~GpBmpCodec(void);

    // IUnknown methods

    STDMETHOD(QueryInterface)(REFIID riid, VOID** ppv);
    STDMETHOD_(ULONG, AddRef)(VOID);
    STDMETHOD_(ULONG, Release)(VOID);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\bmp\bmpdecoder.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   decoder.cpp
*
* Abstract:
*
*   Implementation of the bitmap filter decoder
*
* Revision History:
*
*   5/10/1999 OriG
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "bmpdecoder.hpp"

/**************************************************************************\
*
* Function Description:
*
*     Initialize the image decoder
*
* Arguments:
*
*     stream -- The stream containing the bitmap data
*     flags - Misc. flags
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpDecoder::InitDecoder(
    IN IStream* stream,
    IN DecoderInitFlag flags
    )
{
    HRESULT hresult;
    
    // Make sure we haven't been initialized already
    
    if (pIstream) 
    {
        WARNING(("GpBmpDecoder::InitDecoded -- InitDecoded() called twice"));
        return E_FAIL;
    }

    // Keep a reference on the input stream
    
    stream->AddRef();  
    pIstream = stream;
    SetValid(TRUE);

    bReadHeaders = FALSE;
    hBitmapGdi = NULL;
    pBitsGdi = NULL;

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Reads the bitmap headers out of the stream
*
* Return Value:
*
*   Status code
*
\**************************************************************************/
    
HRESULT
GpBmpDecoder::ReadBitmapHeaders(
    void
    )
{
    if (!bReadHeaders) 
    {
        // Read bitmap file header
    
        if (!ReadStreamBytes(pIstream, &bmfh, sizeof(BITMAPFILEHEADER)) ||
            (bmfh.bfType != 0x4D42) ||
            (bmfh.bfOffBits >= bmfh.bfSize))
        {
            // There are .BMP files with bad headers that paintbrush can read.
            // We should not fail to decode them.

#ifdef BAD_HEADER_WARNING
            WARNING(("Bad .BMP header information"));
#endif            
            //return E_FAIL;
        }

        // Read bitmap info header
    
        BITMAPV5HEADER* bmih = &bmiBuffer.header;
        if (!ReadStreamBytes(pIstream, bmih, sizeof(DWORD)))
        {
            SetValid(FALSE);
            WARNING(("BmpDecoder::ReadBitmapHeaders-ReadStreamBytes() failed"));
            return E_FAIL;
        }
 
        if ((bmih->bV5Size == sizeof(BITMAPINFOHEADER)) ||
            (bmih->bV5Size == sizeof(BITMAPV4HEADER)) ||
            (bmih->bV5Size == sizeof(BITMAPV5HEADER)) )
        {
            // Good, we have the standard BITMAPINFOHEADER
            // or BITMAPV4HEADER or BITMAPV5HEADER

            if (!ReadStreamBytes(pIstream, 
                                 ((PBYTE) bmih) + sizeof(DWORD), 
                                 bmih->bV5Size - sizeof(DWORD)))
            {
                SetValid(FALSE);
                WARNING(("BmpDec::ReadBitmapHeaders-ReadStreamBytes() failed"));
                return E_FAIL;
            }
        
            // Read color table/bitmap mask if appropriate

            UINT colorTableSize = GetColorTableCount() * sizeof(RGBQUAD);

            // Some badly formed images, see Windows bug #513274, may contain
            // more than 256 entries in the color look table which is useless
            // from technical point of view. We can reject this kind of file.

            if (colorTableSize > 1024)
            {
                return E_FAIL;
            }

            if (colorTableSize && !ReadStreamBytes(pIstream, bmiBuffer.colors, colorTableSize))
            {
                SetValid(FALSE);
                WARNING(("BmpDec::ReadBitmapHeaders-ReadStreamBytes() failed"));
                return E_FAIL;
            }
        }
        else if (bmih->bV5Size == sizeof(BITMAPCOREHEADER)) 
        {
            BITMAPCOREHEADER bch;

            if (!ReadStreamBytes(pIstream, 
                                 ((PBYTE) &bch) + sizeof(DWORD), 
                                 sizeof(BITMAPCOREHEADER) - sizeof(DWORD)))
            {
                SetValid(FALSE);
                WARNING(("BmpDec::ReadBitmapHeaders-ReadStreamBytes() failed"));
                return E_FAIL;
            }

            bmih->bV5Width       = bch.bcWidth;
            bmih->bV5Height      = bch.bcHeight;
            bmih->bV5Planes      = bch.bcPlanes;
            bmih->bV5BitCount    = bch.bcBitCount;
            bmih->bV5Compression = BI_RGB;
            bmih->bV5ClrUsed     = 0;
        
            // Read color table/bitmap mask if appropriate

            UINT colorTableCount = GetColorTableCount();
            
            // Some badly formed images, see Windows bug #513274, may contain
            // more than 256 entries in the color look table. Reject this file.

            if (colorTableCount > 256)
            {
                return E_FAIL;
            }

            RGBTRIPLE rgbTripleBuffer[256];
            
            if (colorTableCount)
            {
                if (!ReadStreamBytes(pIstream, rgbTripleBuffer,
                                     colorTableCount * sizeof(RGBTRIPLE)))
                {
                    SetValid(FALSE);
                    WARNING(("BmpDec::ReadBmpHeader-ReadStreamBytes() failed"));
                    return E_FAIL;
                }    

                for (UINT i=0; i<colorTableCount; i++) 
                {
                    bmiBuffer.colors[i].rgbBlue     = rgbTripleBuffer[i].rgbtBlue;
                    bmiBuffer.colors[i].rgbGreen    = rgbTripleBuffer[i].rgbtGreen;
                    bmiBuffer.colors[i].rgbRed      = rgbTripleBuffer[i].rgbtRed;
                    bmiBuffer.colors[i].rgbReserved = 0x0; 
                }
            }
        }
        else
        {
            WARNING(("GpBmpDecoder::ReadBitmapHeaders--unknown bitmap header"));
            SetValid(FALSE);
            return E_FAIL;
        }

        // Check for top-down bitmaps

        IsTopDown = (bmih->bV5Height < 0);

        bReadHeaders = TRUE;
    }

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Computes the number of entries in the color table
*
* Return Value:
*
*     Number of entries in color table
*
\**************************************************************************/

UINT   
GpBmpDecoder::GetColorTableCount(
    void)
{
    BITMAPV5HEADER* bmih = &bmiBuffer.header;
    UINT count = 0;

    if (bmih->bV5Compression == BI_BITFIELDS)
    {
        if (bmih->bV5BitCount == 16 || bmih->bV5BitCount == 32)
        {
            count = 3;
        }
    }
    else switch (bmih->bV5BitCount)
    {
         case 1:
         case 4:
         case 8:

             if (bmih->bV5ClrUsed != 0)
             {    
                 count = bmih->bV5ClrUsed;
             }
             else
             {    
                 count = (1 << bmih->bV5BitCount);
             }

             break;
    }

    return count;
}

/**************************************************************************\
*
* Function Description:
*
*     Sets the palette in decodeSink.  Note that colorPalette is freed at
*     the end of the decode operation.
*
* Return Value:
*s
*     Number of entries in color table
*
\**************************************************************************/

HRESULT
GpBmpDecoder::SetBitmapPalette()
{
    BITMAPV5HEADER* bmih = &bmiBuffer.header;
    
    if ((bmih->bV5BitCount == 1) ||
        (bmih->bV5BitCount == 4) ||
        (bmih->bV5BitCount == 8))
    {
        if (!pColorPalette) 
        {
            UINT colorTableCount = GetColorTableCount();

            // Some badly formed images, see Windows bug #513274, may contain
            // more than 256 entries in the color look table. Reject this file.

            if (colorTableCount > 256)
            {
                return E_FAIL;
            }

            pColorPalette = (ColorPalette *) GpMalloc(sizeof(ColorPalette) + 
                colorTableCount * sizeof(ARGB));

            if (!pColorPalette) 
            {
                WARNING(("BmpDecoder::SetBitmapPalette----Out of memory"));
                return E_OUTOFMEMORY;
            }

            pColorPalette->Flags = 0;
            pColorPalette->Count = colorTableCount;

            UINT i;
            for (i=0; i < colorTableCount; i++) 
            {
                pColorPalette->Entries[i] = MAKEARGB(
                    255,
                    bmiBuffer.colors[i].rgbRed,
                    bmiBuffer.colors[i].rgbGreen,
                    bmiBuffer.colors[i].rgbBlue);
            }
        }
       
        decodeSink->SetPalette(pColorPalette);
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*     Computes the pixel format ID of the bitmap
*
* Return Value:
*
*     Pixel format ID
*
\**************************************************************************/

PixelFormatID 
GpBmpDecoder::GetPixelFormatID(
    void)
{
    BITMAPV5HEADER* bmih = &bmiBuffer.header;
    PixelFormatID pixelFormatID;

    switch(bmih->bV5BitCount)
    {
    case 1:
        pixelFormatID = PIXFMT_1BPP_INDEXED;
        break;

    case 4:
        pixelFormatID = PIXFMT_4BPP_INDEXED;
        break;

    case 8:
        pixelFormatID = PIXFMT_8BPP_INDEXED;
        break;

    case 16:
        pixelFormatID = PIXFMT_16BPP_RGB555;
        break;

    case 24:
        pixelFormatID = PIXFMT_24BPP_RGB;
        break;

    case 32:
        pixelFormatID = PIXFMT_32BPP_RGB;
        break;

    case 64:
        pixelFormatID = PIXFMT_64BPP_ARGB;
        break;
    
    default:
        pixelFormatID = PIXFMT_UNDEFINED;
        break;
    }

    // Let's return non BI_RGB images in a 32BPP format.  This is because
    // GDI doesn't always do the SetDIBits correctly on arbitrary palettes.

    if (bmih->bV5Compression != BI_RGB) 
    {
        pixelFormatID = PIXFMT_32BPP_RGB;
    }

    return pixelFormatID;
}

STDMETHODIMP 
GpBmpDecoder::QueryDecoderParam(
    IN GUID     Guid
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP 
GpBmpDecoder::SetDecoderParam(
    IN GUID     Guid,
    IN UINT     Length,
    IN PVOID    Value
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP 
GpBmpDecoder::GetPropertyCount(
    OUT UINT*   numOfProperty
    )
{
    if ( numOfProperty == NULL )
    {
        return E_INVALIDARG;
    }

    *numOfProperty = 0;
    return S_OK;
}

STDMETHODIMP 
GpBmpDecoder::GetPropertyIdList(
    IN UINT numOfProperty,
    IN OUT PROPID* list
    )
{
    if ( (numOfProperty != 0) || (list == NULL) )
    {
        return E_INVALIDARG;
    }

    return S_OK;
}

HRESULT
GpBmpDecoder::GetPropertyItemSize(
    IN PROPID propId,
    OUT UINT* size
    )
{
    if ( size == NULL )
    {
        return E_INVALIDARG;
    }

    *size = 0;
    return IMGERR_PROPERTYNOTFOUND;
}// GetPropertyItemSize()

HRESULT
GpBmpDecoder::GetPropertyItem(
    IN PROPID               propId,
    IN UINT                 propSize,
    IN OUT PropertyItem*    buffer
    )
{
    if ( (propSize != 0) || (buffer == NULL) )
    {
        return E_INVALIDARG;
    }

    return IMGERR_PROPERTYNOTFOUND;
}// GetPropertyItem()

HRESULT
GpBmpDecoder::GetPropertySize(
    OUT UINT* totalBufferSize,
    OUT UINT* numProperties
    )
{
    if ( (totalBufferSize == NULL) || (numProperties == NULL) )
    {
        return E_INVALIDARG;
    }

    *totalBufferSize = 0;
    *numProperties = 0;

    return S_OK;
}// GetPropertySize()

HRESULT
GpBmpDecoder::GetAllPropertyItems(
    IN UINT totalBufferSize,
    IN UINT numProperties,
    IN OUT PropertyItem* allItems
    )
{
    if ( (totalBufferSize != 0) || (numProperties != 0) || (allItems == NULL) )
    {
        return E_INVALIDARG;
    }

    return S_OK;
}// GetAllPropertyItems()

HRESULT
GpBmpDecoder::RemovePropertyItem(
    IN PROPID   propId
    )
{
    return IMGERR_PROPERTYNOTFOUND;
}// RemovePropertyItem()

HRESULT
GpBmpDecoder::SetPropertyItem(
    IN PropertyItem item
    )
{
    return IMGERR_PROPERTYNOTSUPPORTED;
}// SetPropertyItem()

/**************************************************************************\
*
* Function Description:
*
*     Cleans up the image decoder
*
* Arguments:
*
*     none
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

// Clean up the image decoder object

STDMETHODIMP 
GpBmpDecoder::TerminateDecoder()
{
    // Release the input stream
    
    if (!IsValid())
    {
        WARNING(("GpBmpDecoder::TerminateDecoder -- invalid image"))
        return E_FAIL;
    }

    if(pIstream)
    {
        pIstream->Release();
        pIstream = NULL;
    }

    if (hBitmapGdi) 
    {
        DeleteObject(hBitmapGdi);
        hBitmapGdi = NULL;
        pBitsGdi = NULL;
        
        WARNING(("GpBmpCodec::TerminateDecoder--need to call EndDecode first"));
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Initiates the decode of the current frame
*
* Arguments:
*
*   decodeSink - The sink that will support the decode operation
*   newPropSet - New image property sets, if any
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpDecoder::BeginDecode(
    IN IImageSink* imageSink,
    IN OPTIONAL IPropertySetStorage* newPropSet
    )
{
    if (!IsValid())
    {
        WARNING(("GpBmpDecoder::BeginDecode -- invalid image"))
        return E_FAIL;
    }

    if (decodeSink) 
    {
        WARNING(("BeginDecode called again before call to EngDecode"));
        return E_FAIL;
    }

    imageSink->AddRef();
    decodeSink = imageSink;

    currentLine = 0;
    bCalledBeginSink = FALSE;

    return S_OK;
}
    

/**************************************************************************\
*
* Function Description:
*
*     Ends the decode of the current frame
*
* Arguments:
*
*     statusCode -- status of decode operation

* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpDecoder::EndDecode(
    IN HRESULT statusCode
    )
{
    if (!IsValid())
    {
        WARNING(("GpBmpDecoder::EndDecode -- invalid image"))
        return E_FAIL;
    }

    if (pColorPalette) 
    {
        // free the color palette

        GpFree(pColorPalette);
        pColorPalette = NULL;
    }

    if (hBitmapGdi) 
    {
        DeleteObject(hBitmapGdi);
        hBitmapGdi = NULL;
        pBitsGdi = NULL;
    }
    
    if (!decodeSink) 
    {
        WARNING(("EndDecode called before call to BeginDecode"));
        return E_FAIL;
    }
    
    HRESULT hresult = decodeSink->EndSink(statusCode);

    decodeSink->Release();
    decodeSink = NULL;

    if (FAILED(hresult)) 
    {
        WARNING(("GpBmpDecoder::EndDecode -- EndSink() failed"))
        statusCode = hresult; // If EndSink failed return that (more recent)
                              // failure code
    }

    return statusCode;
}


/**************************************************************************\
*
* Function Description:
*
*     Sets up the ImageInfo structure
*
* Arguments:
*
*     ImageInfo -- information about the decoded image
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpDecoder::GetImageInfo(OUT ImageInfo* imageInfo)
{
    HRESULT hresult;

    hresult = ReadBitmapHeaders();
    if (FAILED(hresult)) 
    {
        WARNING(("GpBmpDecoder::GetImageInfo -- ReadBitmapHeaders failed."));
        return hresult;
    }
    
    BITMAPV5HEADER* bmih = &bmiBuffer.header;
    
    imageInfo->RawDataFormat = IMGFMT_BMP;
    imageInfo->PixelFormat   = GetPixelFormatID();
    imageInfo->Width         = bmih->bV5Width;
    imageInfo->Height        = abs(bmih->bV5Height);
    imageInfo->TileWidth     = bmih->bV5Width;
    imageInfo->TileHeight    = 1;
    imageInfo->Flags         = SINKFLAG_TOPDOWN
                             | SINKFLAG_FULLWIDTH
                             | IMGFLAG_HASREALPIXELSIZE
                             | IMGFLAG_COLORSPACE_RGB;

    // if both XPelsPerMeter and YPelsPerMeter are greater than 0, then
    // we claim that the file has real dpi info in the flags.  Otherwise,
    // we set the dpi's to the default and claim that the dpi's are fake.
    if ( (bmih->bV5XPelsPerMeter > 0) && (bmih->bV5YPelsPerMeter > 0) )
    {
        imageInfo->Xdpi = (bmih->bV5XPelsPerMeter * 254.0) / 10000.0;
        imageInfo->Ydpi = (bmih->bV5YPelsPerMeter * 254.0) / 10000.0;
        imageInfo->Flags |= IMGFLAG_HASREALDPI;
    }
    else
    {
        // Start: [Bug 103296]
        // Change this code to use Globals::DesktopDpiX and Globals::DesktopDpiY
        HDC hdc;
        hdc = ::GetDC(NULL);
        if ((hdc == NULL) || 
            ((imageInfo->Xdpi = (REAL)::GetDeviceCaps(hdc, LOGPIXELSX)) <= 0) ||
            ((imageInfo->Ydpi = (REAL)::GetDeviceCaps(hdc, LOGPIXELSY)) <= 0))
        {
            WARNING(("BmpDecoder::GetImageInfo-GetDC or GetDeviceCaps failed"));
            imageInfo->Xdpi = DEFAULT_RESOLUTION;
            imageInfo->Ydpi = DEFAULT_RESOLUTION;
        }
        ::ReleaseDC(NULL, hdc);
        // End: [Bug 103296]
    }

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Decodes the current frame
*
* Arguments:
*
*     decodeSink --  The sink that will support the decode operation
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpDecoder::Decode()
{
    BITMAPV5HEADER* bmih = &bmiBuffer.header;
    HRESULT hresult;
    ImageInfo imageInfo;

    if (!IsValid())
    {
        WARNING(("GpBmpDecoder::Decode -- invalid image"))
        return E_FAIL;
    }

    hresult = GetImageInfo(&imageInfo);
    if (FAILED(hresult)) 
    {
        WARNING(("GpBmpDecoder::Decode -- GetImageInfo() failed"))
        return hresult;
    }

    // Inform the sink that decode is about to begin

    if (!bCalledBeginSink) 
    {
        hresult = decodeSink->BeginSink(&imageInfo, NULL);
        if (!SUCCEEDED(hresult)) 
        {
            WARNING(("GpBmpDecoder::Decode -- BeginSink() failed"))
            return hresult;
        }

        // Client cannot modify height and width

        imageInfo.Width  = bmih->bV5Width;
        imageInfo.Height = abs(bmih->bV5Height);

        bCalledBeginSink = TRUE;
    
        // Set the palette in the sink.  Shouldn't do anything if there's 
        // no palette to set.

        hresult = SetBitmapPalette();
        if (!SUCCEEDED(hresult)) 
        {
            WARNING(("GpBmpDecoder::Decode -- SetBitmapPalette() failed"))
            return hresult;
        }
    }

    PixelFormatID srcPixelFormatID = GetPixelFormatID();
    
    // Check the required pixel format. If it is not one of our supportted
    // format, switch it to a canonical one
    
    if ( imageInfo.PixelFormat != srcPixelFormatID )
    {
        // The sink is trying to negotiate a format with us

        switch ( imageInfo.PixelFormat )
        {
            // If the sink asks for one of the BMP supported image format, we
            // will honor its request if we can convert from current format to
            // the destination format. If we can't, then we can only decode it
            // to 32 ARGB

        case PIXFMT_1BPP_INDEXED:
        case PIXFMT_4BPP_INDEXED:
        case PIXFMT_8BPP_INDEXED:
        case PIXFMT_16BPP_RGB555:
        case PIXFMT_24BPP_RGB:
        case PIXFMT_32BPP_RGB:
        {
            // Check if we can convert the source pixel format to the format
            // sink required. If not. we return 32BPP ARGB

            EpFormatConverter linecvt;
            if ( linecvt.CanDoConvert(srcPixelFormatID,
                                      imageInfo.PixelFormat) == FALSE )
            {
                imageInfo.PixelFormat = PIXFMT_32BPP_ARGB;
            }
        }
            break;

        default:

            // For all the rest format, we convert it to 32BPP_ARGB and let
            // the sink to do the conversion to the format it likes

            imageInfo.PixelFormat = PIXFMT_32BPP_ARGB;

            break;
        }// switch ( imageInfo.PixelFormat )
    }// if ( imageInfo.PixelFormat != srcPixelFormatID )

    // Decode the current frame
    
    hresult = DecodeFrame(imageInfo);

    return hresult;
}// Decode()

/**************************************************************************\
*
* Function Description:
*
*     Decodes the current frame
*
* Arguments:
*
*     imageInfo -- decoding parameters
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpDecoder::DecodeFrame(
    IN ImageInfo& imageInfo
    )
{
    BITMAPV5HEADER* bmih = &bmiBuffer.header;
    HRESULT hresult;
    RECT currentRect;
    INT bmpStride;

    // Compute DWORD aligned stride of bitmap in stream

    if (bmih->bV5Compression == BI_RGB) 
    {
        bmpStride = (bmih->bV5Width * bmih->bV5BitCount + 7) / 8;
        bmpStride = (bmpStride + 3) & (~0x3);
    }
    else
    {
        // Non BI_RGB bitmaps are stored in 32BPP

        bmpStride = bmih->bV5Width * sizeof(RGBQUAD);
    }

    // Do we need to change format?
    
    PixelFormatID pixelFormatID = GetPixelFormatID();
    if (pixelFormatID == PIXFMT_UNDEFINED) 
    {
        WARNING(("GpBmpDecoder::DecodeFrame---Pixel format undefined"));
        return E_FAIL;
    }    

    // Buffer to hold one line of original image bits

    VOID* pOriginalBits = GpMalloc(bmpStride);
    if (!pOriginalBits) 
    {
        WARNING(("GpBmpDecoder::DecodeFrame---GpMalloc() failed"));
        return E_OUTOFMEMORY;
    }

    // Adjust for top-down bitmap

    if (IsTopDown)
    {
        bmpStride = -bmpStride;
    }

    currentRect.left = 0;
    currentRect.right = imageInfo.Width;

    while (currentLine < (INT) imageInfo.Height) 
    {
        // Read one source line from the image

        hresult = ReadLine(pOriginalBits, currentLine, imageInfo);
               
        if (FAILED(hresult)) 
        {
            if (pOriginalBits)
            {
                GpFree(pOriginalBits);
            }

            WARNING(("GpBmpDecoder::DecodeFrame---ReadLine() failed"));
            return hresult;
        }
        
        currentRect.top = currentLine;
        currentRect.bottom = currentLine + 1;

        BitmapData bitmapData;
        hresult = decodeSink->GetPixelDataBuffer(&currentRect, 
                                                 imageInfo.PixelFormat, 
                                                 TRUE,
                                                 &bitmapData);
        if (!SUCCEEDED(hresult)) 
        {
            if (pOriginalBits)
            {
                GpFree(pOriginalBits);
            }
            
            WARNING(("GpBmpDecoder::DecodeFrame--GetPixelDataBuffer() failed"));
            return E_FAIL;
        }
        
        if (pixelFormatID != imageInfo.PixelFormat) 
        {
            // Need to copy bits to bitmapData.scan0
            
            BitmapData bitmapDataOriginal;
            bitmapDataOriginal.Width = bitmapData.Width;
            bitmapDataOriginal.Height = 1;
            bitmapDataOriginal.Stride = bmpStride;
            bitmapDataOriginal.PixelFormat = pixelFormatID;
            bitmapDataOriginal.Scan0 = pOriginalBits;
            bitmapDataOriginal.Reserved = 0;
            
            // Convert the image from "pixelFormatID" to "imageInfo.PixelFormat"
            // The result will be in "bitmapData"

            hresult = ConvertBitmapData(&bitmapData,
                                        pColorPalette,
                                        &bitmapDataOriginal,
                                        pColorPalette);
            if ( FAILED(hresult) )
            {
                WARNING (("BmpDecoder::DecodeFrame--ConvertBitmapData failed"));
                if (pOriginalBits)
                {
                    GpFree(pOriginalBits);
                }

                // We should not failed here since we have done the check if we
                // can do the conversion or not in Decode()

                ASSERT(FALSE);
                return E_FAIL;
            }
        }
        else
        {
            // Note: Theoritically, bmpStride == uiDestStride. But some codec
            // might not allocate DWORD aligned memory chunk, like gifencoder.
            // So the problem will occur in GpMemcpy() below when we fill the
            // dest buffer. Though we can fix it in the encoder side. But it is
            // not realistic if the encoder is written by 3rd party ISVs.
            //
            // One example is when you open an 8bpp indexed BMP and save it as
            // GIF. If the width is 0x14d (333 in decimal), the GIF encoder only
            // allocates 14d bytes for each scan line. So we have to calculate
            // the destStride and use it when do a memcpy()

            UINT    uiDestStride = imageInfo.Width
                                 * GetPixelFormatSize(imageInfo.PixelFormat);
            uiDestStride = (uiDestStride + 7) >> 3; // Total bytes needed

            GpMemcpy(bitmapData.Scan0, pOriginalBits, uiDestStride);
        }

        hresult = decodeSink->ReleasePixelDataBuffer(&bitmapData);
        if (!SUCCEEDED(hresult)) 
        {
            if (pOriginalBits)
            {
                GpFree(pOriginalBits);
            }
            
            WARNING (("BmpDec::DecodeFrame--ReleasePixelDataBuffer() failed"));
            return E_FAIL;
        }

        currentLine++;
    }
    
    if (pOriginalBits)
    {
        GpFree(pOriginalBits);
    }
    
    return S_OK;
}// DecodeFrame()
    
/**************************************************************************\
*
* Function Description:
*
*     Reads a line in the native format into pBits
*
* Arguments:
*
*     pBits -- a buffer to hold the line data
*     currentLine -- The line to read
*     imageInfo -- info about the image
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpDecoder::ReadLine(
    IN VOID *pBits,
    IN INT currentLine,
    IN ImageInfo imageInfo
    )
{
    BITMAPV5HEADER* bmih = &bmiBuffer.header;
    HRESULT hresult;
    
    switch (bmih->bV5Compression) 
    {
    case BI_RGB:
        hresult = ReadLine_BI_RGB(pBits, currentLine, imageInfo);
        break;

    case BI_BITFIELDS:

        // Let's use GDI to do the bitfields rendering (much easier than
        // writing special purpose code for this).  This is the same
        // codepath we use for RLEs.

    case BI_RLE8:
    case BI_RLE4:
        hresult = ReadLine_GDI(pBits, currentLine, imageInfo);
        break;

    default:
        WARNING(("GpBmpDecoder::ReadLine---Unknown bitmap format"));
        hresult = E_FAIL;
        break;
    }

    return hresult;
}
    
    
/**************************************************************************\
*
* Function Description:
*
*     Reads a line in the native format into pBits.  This is the case where
*     the format is BI_RGB.
*
* Arguments:
*
*     pBits -- a buffer to hold the line data
*     currentLine -- The line to read
*     imageInfo -- info about the image
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpDecoder::ReadLine_BI_RGB(
    IN VOID *pBits,
    IN INT currentLine,
    IN ImageInfo imageInfo
    )
{
    BITMAPV5HEADER* bmih = &bmiBuffer.header;
    
    // Compute DWORD aligned stride of bitmap in stream

    UINT bmpStride = (bmih->bV5Width * bmih->bV5BitCount + 7) / 8;
    bmpStride = (bmpStride + 3) & (~0x3);

    // Seek to beginning of stream data

    INT offset;

    if (IsTopDown)
    {
        offset = bmfh.bfOffBits +
                 bmpStride * currentLine;
    }
    else
    {
        offset = bmfh.bfOffBits +
                 bmpStride * (imageInfo.Height - currentLine - 1);
    }

    if (!SeekStreamPos(pIstream, STREAM_SEEK_SET, offset))
    {
        WARNING(("GpBmpDecoder::ReadLine_BI_RGB---SeekStreamPos() failed"));
        return E_FAIL;
    }

    // Read one line

    if (!ReadStreamBytes(pIstream, 
                         (void *) pBits,
                         (bmih->bV5Width * bmih->bV5BitCount + 7) / 8)) 
    {
        WARNING(("GpBmpDecoder::ReadLine_BI_RGB---ReadStreamBytes() failed"));
        return E_FAIL;
    }

    return S_OK;
}
    

/**************************************************************************\
*
* Function Description:
*
*     Uses GDI to decode a non-native format into a known DIB format
*
* Arguments:
*
*     pBits -- a buffer to hold the line data
*     currentLine -- The line to read
*     imageInfo -- info about the image
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpDecoder::ReadLine_GDI(
    IN VOID *pBits,
    IN INT currentLine,
    IN ImageInfo imageInfo
    )
{
    HRESULT hresult;

    if (!pBitsGdi) 
    {
        hresult = GenerateGdiBits(imageInfo);
        if (FAILED(hresult)) 
        {
            WARNING(("GpBmpDecoder::ReadLine_GDI---GenerateGdiBits() failed"));
            return hresult;
        }
    }

    BITMAPV5HEADER* bmih = &bmiBuffer.header;
    
    // Compute DWORD aligned stride of bitmap in stream

    UINT bmpStride = bmih->bV5Width * sizeof(RGBQUAD);

    if (IsTopDown)
    {
        GpMemcpy(pBits,
                 ((PBYTE) pBitsGdi) + bmpStride * currentLine,
                 bmpStride);
    }
    else
    {
        GpMemcpy(pBits,
                 ((PBYTE)pBitsGdi)
                    + bmpStride * (imageInfo.Height - currentLine - 1),
                 bmpStride);
    }

    return S_OK;
}



/**************************************************************************\
*
* Function Description:
*
*     Uses GDI to generate image bits in a known format (from RLE)
*     
* Arguments:
*
*     imageInfo -- info about the image
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpDecoder::GenerateGdiBits(
    IN ImageInfo imageInfo
    )
{
    BITMAPV5HEADER* bmih = &bmiBuffer.header;
    HRESULT hresult;

    // Allocate temporary storage for bits from stream
    
    STATSTG statStg;
    hresult = pIstream->Stat(&statStg, STATFLAG_NONAME);
    if (FAILED(hresult))
    {
        WARNING(("GpBmpDecoder::GenerateGdiBits---Stat() failed"));
        return hresult;
    }
    // According to the document for IStream::Stat::StatStage(), the caller
    // has to free the pwcsName string
    
    CoTaskMemFree(statStg.pwcsName);
    
    UINT bufferSize = statStg.cbSize.LowPart - bmfh.bfOffBits;    
    VOID *pStreamBits = GpMalloc(bufferSize);
    if (!pStreamBits) 
    {
        WARNING(("GpBmpDecoder::GenerateGdiBits---GpMalloc() failed"));
        return E_OUTOFMEMORY;
    }
    
    // Now read the bits from the stream

    if (!SeekStreamPos(pIstream, STREAM_SEEK_SET, bmfh.bfOffBits))
    {
        WARNING(("GpBmpDecoder::GenerateGdiBits---SeekStreamPos() failed"));
        GpFree(pStreamBits);
        return E_FAIL;
    }
    
    if (!ReadStreamBytes(pIstream, pStreamBits, bufferSize))
    {
        WARNING(("GpBmpDecoder::GenerateGdiBits---ReadStreamBytes() failed"));
        GpFree(pStreamBits);
        return E_FAIL;
    }

    // Now allocate a GDI DIBSECTION to render the bitmap

    BITMAPINFO bmi;
    bmi.bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth         = bmih->bV5Width;
    bmi.bmiHeader.biHeight        = bmih->bV5Height;
    bmi.bmiHeader.biPlanes        = 1;
    bmi.bmiHeader.biBitCount      = 32;
    bmi.bmiHeader.biCompression   = BI_RGB;
    bmi.bmiHeader.biSizeImage     = 0;
    bmi.bmiHeader.biXPelsPerMeter = bmih->bV5XPelsPerMeter;
    bmi.bmiHeader.biYPelsPerMeter = bmih->bV5YPelsPerMeter;
    bmi.bmiHeader.biClrUsed       = 0;
    bmi.bmiHeader.biClrImportant  = 0;

    HDC hdcScreen = GetDC(NULL);
    if ( hdcScreen == NULL )
    {
        WARNING(("GpBmpDecoder::GenerateGdiBits---GetDC failed"));
        GpFree(pStreamBits);
        return E_FAIL;
    }

    hBitmapGdi = CreateDIBSection(hdcScreen, 
                                  (BITMAPINFO *) &bmi, 
                                  DIB_RGB_COLORS, 
                                  (void **) &pBitsGdi, 
                                  NULL, 
                                  0);
    if (!hBitmapGdi) 
    {
        GpFree(pStreamBits);
        ReleaseDC(NULL, hdcScreen);
        WARNING(("GpBmpDecoder::GenerateGdiBits--failed to create DIBSECTION"));
        return E_FAIL;
    }

    // The BITMAPINFOHEADER in the file should already have the correct size set
    // for RLEs, but in some cases it doesn't so we will fix it here.

    if ((bmih->bV5SizeImage == 0) || (bmih->bV5SizeImage > bufferSize)) 
    {
        bmih->bV5SizeImage = bufferSize;
    }
    
    // we need to convert bmiBuffer into a BITMAPINFO so that SetDIBits
    // understands the structure passed in.
    BITMAPINFO *pbmiBufferTemp;

    pbmiBufferTemp = static_cast<BITMAPINFO *>
        (GpMalloc(sizeof (BITMAPINFO) + (255 * sizeof(RGBQUAD))));
    if (!pbmiBufferTemp)
    {
        DeleteObject(hBitmapGdi);
        GpFree(pStreamBits);
        ReleaseDC(NULL, hdcScreen);
        WARNING(("GpBmpDecoder::GenerateGdiBits -- failed in GpMalloc()"));
        return E_FAIL;
    }

    pbmiBufferTemp->bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
    pbmiBufferTemp->bmiHeader.biWidth         = bmiBuffer.header.bV5Width;
    pbmiBufferTemp->bmiHeader.biHeight        = bmiBuffer.header.bV5Height;
    pbmiBufferTemp->bmiHeader.biPlanes        = bmiBuffer.header.bV5Planes;
    pbmiBufferTemp->bmiHeader.biBitCount      = bmiBuffer.header.bV5BitCount;
    pbmiBufferTemp->bmiHeader.biCompression   = bmiBuffer.header.bV5Compression;
    pbmiBufferTemp->bmiHeader.biSizeImage     = bmiBuffer.header.bV5SizeImage;
    pbmiBufferTemp->bmiHeader.biXPelsPerMeter = bmiBuffer.header.bV5XPelsPerMeter;
    pbmiBufferTemp->bmiHeader.biYPelsPerMeter = bmiBuffer.header.bV5YPelsPerMeter;
    pbmiBufferTemp->bmiHeader.biClrUsed       = bmiBuffer.header.bV5ClrUsed;
    pbmiBufferTemp->bmiHeader.biClrImportant  = bmiBuffer.header.bV5ClrImportant;

    for (int i = 0; i < 256; i++)
    {
        pbmiBufferTemp->bmiColors[i] = bmiBuffer.colors[i];
    }

    // for V4 and V5 headers, if we have BI_BITFIELDS for biCompression, then
    // copy the RGB masks into the first three colors
    if (((bmih->bV5Size == sizeof(BITMAPV4HEADER)) ||
         (bmih->bV5Size == sizeof(BITMAPV5HEADER)))  &&
        (bmih->bV5Compression == BI_BITFIELDS))
    {
        *((DWORD *) &(pbmiBufferTemp->bmiColors[0])) = bmih->bV5RedMask;
        *((DWORD *) &(pbmiBufferTemp->bmiColors[1])) = bmih->bV5GreenMask;
        *((DWORD *) &(pbmiBufferTemp->bmiColors[2])) = bmih->bV5BlueMask;
    }

    INT numLinesCopied = SetDIBits(hdcScreen, 
                                   hBitmapGdi, 
                                   0, 
                                   imageInfo.Height,
                                   pStreamBits, 
                                   pbmiBufferTemp,
                                   DIB_RGB_COLORS);

    GpFree(pbmiBufferTemp);
    GpFree(pStreamBits);
    ReleaseDC(NULL, hdcScreen);

    if (numLinesCopied != (INT) imageInfo.Height) 
    {
        WARNING(("GpBmpDecoder::GenerateGdiBits -- SetDIBits failed"));
        DeleteObject(hBitmapGdi);
        hBitmapGdi = NULL;
        pBitsGdi = NULL;

        return E_FAIL;
    }

    // At this point pBitsGdi contains the rendered bits in a native format.
    // This buffer will be released in EndDecode.

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Get the total number of dimensions the image supports
*
* Arguments:
*
*     count -- number of dimensions this image format supports
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpDecoder::GetFrameDimensionsCount(
    UINT* count
    )
{
    if ( count == NULL )
    {
        WARNING(("GpBmpDecoder::GetFrameDimensionsCount-Invalid input parameter"));
        return E_INVALIDARG;
    }
    
    // Tell the caller that BMP is a one dimension image.

    *count = 1;

    return S_OK;
}// GetFrameDimensionsCount()

/**************************************************************************\
*
* Function Description:
*
*     Get an ID list of dimensions the image supports
*
* Arguments:
*
*     dimensionIDs---Memory buffer to hold the result ID list
*     count -- number of dimensions this image format supports
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpDecoder::GetFrameDimensionsList(
    GUID*   dimensionIDs,
    UINT    count
    )
{
    if ( (count != 1) || (dimensionIDs == NULL) )
    {
        WARNING(("GpBmpDecoder::GetFrameDimensionsList-Invalid input param"));
        return E_INVALIDARG;
    }

    // BMP image only supports page dimension

    dimensionIDs[0] = FRAMEDIM_PAGE;

    return S_OK;
}// GetFrameDimensionsList()

/**************************************************************************\
*
* Function Description:
*
*     Get number of frames for the specified dimension
*     
* Arguments:
*
*     dimensionID --
*     count --     
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpDecoder::GetFrameCount(
    IN const GUID* dimensionID,
    OUT UINT* count
    )
{
    if ( (NULL == count) || (*dimensionID != FRAMEDIM_PAGE) )
    {
        WARNING(("GpBmpDecoder::GetFrameCount -- invalid parameters"))
        return E_INVALIDARG;
    }
    
    if (!IsValid())
    {
        WARNING(("GpBmpDecoder::GetFrameCount -- invalid image"))
        return E_FAIL;
    }

    *count = 1;
    
    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Select currently active frame
*     
* Arguments:
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpDecoder::SelectActiveFrame(
    IN const GUID* dimensionID,
    IN UINT frameIndex
    )
{
    if (!IsValid())
    {
        WARNING(("GpBmpDecoder::SelectActiveFrame -- invalid image"))
        return E_FAIL;
    }

    if ( (dimensionID == NULL) || (*dimensionID != FRAMEDIM_PAGE) )
    {
        WARNING(("GpBmpDecoder::SelectActiveFrame--Invalid GUID input"));
        return E_INVALIDARG;
    }

    if ( frameIndex > 1 )
    {
        // BMP is a single frame image format

        WARNING(("GpBmpDecoder::SelectActiveFrame--Invalid frame index"));
        return E_INVALIDARG;
    }

    return S_OK;
}// SelectActiveFrame()

/**************************************************************************\
*
* Function Description:
*
*   Get image thumbnail
*
* Arguments:
*
*   thumbWidth, thumbHeight - Specifies the desired thumbnail size in pixels
*   thumbImage - Returns a pointer to the thumbnail image
*
* Return Value:
*
*   Status code
*
* Note:
*
*   Even if the optional thumbnail width and height parameters are present,
*   the decoder is not required to honor it. The requested size is used
*   as a hint. If both width and height parameters are 0, then the decoder
*   is free to choose an convenient thumbnail size.
*
\**************************************************************************/

HRESULT
GpBmpDecoder::GetThumbnail(
    IN OPTIONAL UINT thumbWidth,
    IN OPTIONAL UINT thumbHeight,
    OUT IImage** thumbImage
    )
{
    if (!IsValid())
    {
        WARNING(("GpBmpDecoder::GetThumbnail -- invalid image"))
        return E_FAIL;
    }

    return E_NOTIMPL;
}

/**************************************************************************\
*
* Function Description:
*
*     Constructor
*
* Return Value:
*
*   none
*
\**************************************************************************/

GpBmpDecoder::GpBmpDecoder(
    void
    )
{
    comRefCount   = 1;
    pIstream      = NULL;
    decodeSink    = NULL;
    pColorPalette = NULL;
    GpMemset(&bmiBuffer.header, 0, sizeof(BITMAPV5HEADER));
}

/**************************************************************************\
*
* Function Description:
*
*     Destructor
*
* Return Value:
*
*   none
*
\**************************************************************************/

GpBmpDecoder::~GpBmpDecoder(
    void
    )
{
    // The destructor should never be called before Terminate is called, but
    // if it does we should release our reference on the stream anyway to avoid
    // a memory leak.

    if(pIstream)
    {
        WARNING(("GpBmpCodec::~GpBmpCodec -- need to call TerminateDecoder first"));
        pIstream->Release();
        pIstream = NULL;
    }

    if(pColorPalette)
    {
        WARNING(("GpBmpCodec::~GpBmpCodec -- color palette not freed"));
        GpFree(pColorPalette);
        pColorPalette = NULL;
    }

    SetValid(FALSE);    // so we don't use a deleted object
}

/**************************************************************************\
*
* Function Description:
*
*     QueryInterface
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP
GpBmpDecoder::QueryInterface(
    REFIID riid,
    VOID** ppv
    )
{
    if (riid == IID_IImageDecoder)
    {
        *ppv = static_cast<IImageDecoder*>(this);
    }
    else if (riid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(static_cast<IImageDecoder*>(this));
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     AddRef
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP_(ULONG)
GpBmpDecoder::AddRef(
    VOID)
{
    return InterlockedIncrement(&comRefCount);
}

/**************************************************************************\
*
* Function Description:
*
*     Release
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP_(ULONG)
GpBmpDecoder::Release(
    VOID)
{
    ULONG count = InterlockedDecrement(&comRefCount);

    if (count == 0)
    {
        delete this;
    }

    return count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\bmp\bmpdecoder.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   bmpdecoder.hpp
*
* Abstract:
*
*   Header file for the bitmap decoder
*
* Revision History:
*
*   5/13/1999 OriG (Ori Gershony)
*       Created it.
*
*   2/7/2000  OriG (Ori Gershony)
*       Move encoder and decoder into separate classes
*
\**************************************************************************/

class GpBmpDecoder : public IImageDecoder
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagBmpDecoder) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid BmpDecoder");
        }
    #endif

        return (Tag == ObjectTagBmpDecoder);
    }
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagBmpDecoder : ObjectTagInvalid;
    }

private:
    
    IStream *pIstream;
    IImageSink* decodeSink;
    ColorPalette *pColorPalette;

    BITMAPFILEHEADER bmfh;

    HBITMAP hBitmapGdi; // bitmap for GDI to render into (from RLE)
    VOID *pBitsGdi;     // bits pointer for above bitmap
    BOOL IsTopDown;     // indicates top-down instead of GDI default bottom-up
    
    // Bitmap info header and color table
    struct 
    {
        BITMAPV5HEADER header;  // this is allowed to be a BITMAPINFOHEADER or
                                // a BITMAPV4HEADER.  bV5Size determines what
                                // kind of header it really is.
        RGBQUAD colors[256];
    } bmiBuffer;

    BOOL bReadHeaders;
    BOOL bCalledBeginSink;
    INT currentLine;

    HRESULT ReadBitmapHeaders(void);
    UINT GetColorTableCount(void);
    HRESULT SetBitmapPalette();
    PixelFormatID GetPixelFormatID(void);
    STDMETHODIMP DecodeFrame(IN ImageInfo& imageInfo);
    STDMETHODIMP ReadLine(IN VOID *pBits, IN INT currentLine, 
                          IN ImageInfo imageInfo);
    STDMETHODIMP ReadLine_BI_RGB(IN VOID *pBits, IN INT currentLine, 
                                 IN ImageInfo imageInfo);
    STDMETHODIMP ReadLine_GDI(IN VOID *pBits, IN INT currentLine, 
                              IN ImageInfo imageInfo);
    STDMETHODIMP GenerateGdiBits(IN ImageInfo imageInfo);

protected:
    LONG comRefCount;       // COM object reference count    

public:
    
    // Constructor and Destructor
    
    GpBmpDecoder(void);
    ~GpBmpDecoder(void);

    // IImageDecoder methods
    
    STDMETHOD(InitDecoder)(IN IStream* stream, IN DecoderInitFlag flags);
    STDMETHOD(TerminateDecoder) ();
    STDMETHOD(BeginDecode)(IN IImageSink* imageSink, IN OPTIONAL IPropertySetStorage* newPropSet);
    STDMETHOD(Decode)();
    STDMETHOD(EndDecode)(IN HRESULT statusCode);
    STDMETHOD(GetFrameDimensionsCount)(OUT UINT* count);
    STDMETHOD(GetFrameDimensionsList)(OUT GUID* dimensionIDs,IN OUT UINT count);
    STDMETHOD(GetFrameCount)(IN const GUID* dimensionID, OUT UINT* count);
    STDMETHOD(SelectActiveFrame)(IN const GUID* dimensionID, 
        IN UINT frameIndex);
    STDMETHOD(GetImageInfo)(OUT ImageInfo* imageInfo);
    STDMETHOD(GetThumbnail)(IN OPTIONAL UINT thumbWidth, IN OPTIONAL UINT thumbHeight,
        OUT IImage** thumbImage);
    STDMETHOD(QueryDecoderParam)(IN GUID Guid);
    STDMETHOD(SetDecoderParam)(IN GUID Guid, IN UINT Length, IN PVOID Value);
    STDMETHOD(GetPropertyCount)(OUT UINT* numOfProperty);
    STDMETHOD(GetPropertyIdList)(IN UINT numOfProperty,IN OUT PROPID* list);
    STDMETHOD(GetPropertyItemSize)(IN PROPID propId, OUT UINT* size);    
    STDMETHOD(GetPropertyItem)(IN PROPID propId, IN UINT propSize,
                               IN OUT PropertyItem* buffer);
    STDMETHOD(GetPropertySize)(OUT UINT* totalBufferSize,
                               OUT UINT* numProperties);
    STDMETHOD(GetAllPropertyItems)(IN UINT totalBufferSize,
                                   IN UINT numProperties,
                                   IN OUT PropertyItem* allItems);
    STDMETHOD(RemovePropertyItem)(IN PROPID propId);
    STDMETHOD(SetPropertyItem)(IN PropertyItem item);
    STDMETHOD(GetRawInfo)(IN OUT void** info)
    {
        return E_NOTIMPL;
    }
    
    // IUnknown methods

    STDMETHOD(QueryInterface)(REFIID riid, VOID** ppv);
    STDMETHOD_(ULONG, AddRef)(VOID);
    STDMETHOD_(ULONG, Release)(VOID);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\emf\emfdecoder.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   emfdecoder.cpp
*
* Abstract:
*
*   Implementation of the EMF decoder
*
* Revision History:
*
*   6/14/1999 OriG
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "emfcodec.hpp"

/**************************************************************************\
*
* Function Description:
*
*     Initialize the image decoder
*
* Arguments:
*
*     stream -- The stream containing the bitmap data
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpEMFCodec::InitDecoder(
    IN IStream* stream,
    IN DecoderInitFlag flags
    )
{
    HRESULT hresult;
    
    // Make sure we haven't been initialized already
    
    if (pIstream) 
    {
        return E_FAIL;
    }

    // Keep a reference on the input stream
    
    stream->AddRef();  
    pIstream = stream;
    bReadHeader = FALSE;
    bReinitializeEMF = FALSE;

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Cleans up the image decoder
*
* Arguments:
*
*     none
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP 
GpEMFCodec::TerminateDecoder()
{
    // Release the input stream
    
    if(pIstream)
    {
        pIstream->Release();
        pIstream = NULL;
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*     Reads the EMF header
*
* Arguments:
*
*     none
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP 
GpEMFCodec::ReadEMFHeader()
{
    HRESULT hresult;
    
    if (!pIstream) 
    {
        return E_FAIL;
    }

    if (!bReadHeader) 
    {
        ULONG cbRead;
        hresult = pIstream->Read((void *) &emh, sizeof(emh), &cbRead);
        if (FAILED(hresult)) 
        {
            return hresult;
        }
        if (cbRead != sizeof(emh)) 
        {
            return E_FAIL;
        }

        bReadHeader = TRUE;

        imageInfo.RawDataFormat = IMGFMT_EMF;
        imageInfo.PixelFormat = PIXFMT_32BPP_RGB;
        imageInfo.Width  = emh.rclBounds.right  - emh.rclBounds.left;
        imageInfo.Height = emh.rclBounds.bottom - emh.rclBounds.top;
        imageInfo.TileWidth  = imageInfo.Width;
        imageInfo.TileHeight = 1; // internal GDI format is bottom-up...

        #define MM_PER_INCH 25.4
        imageInfo.Xdpi = MM_PER_INCH * emh.szlDevice.cx / emh.szlMillimeters.cx;
        imageInfo.Ydpi = MM_PER_INCH * emh.szlDevice.cy / emh.szlMillimeters.cy;
        imageInfo.Flags = SINKFLAG_TOPDOWN
                        | SINKFLAG_FULLWIDTH
                        | SINKFLAG_SCALABLE
                        | IMGFLAG_HASREALPIXELSIZE
                        | IMGFLAG_COLORSPACE_RGB;
    }

    return S_OK;
}

STDMETHODIMP 
GpEMFCodec::QueryDecoderParam(
    IN GUID		Guid
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP 
GpEMFCodec::SetDecoderParam(
    IN GUID		Guid,
	IN UINT		Length,
	IN PVOID	Value
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP 
GpEMFCodec::GetPropertyCount(
    OUT UINT*   numOfProperty
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP 
GpEMFCodec::GetPropertyIdList(
    IN UINT numOfProperty,
  	IN OUT PROPID* list
    )
{
    return E_NOTIMPL;
}

HRESULT
GpEMFCodec::GetPropertyItemSize(
    IN PROPID propId,
    OUT UINT* size
    )
{
    return E_NOTIMPL;
}// GetPropertyItemSize()

HRESULT
GpEMFCodec::GetPropertyItem(
    IN PROPID               propId,
    IN UINT                 propSize,
    IN OUT PropertyItem*    buffer
    )
{
    return E_NOTIMPL;
}// GetPropertyItem()

HRESULT
GpEMFCodec::GetPropertySize(
    OUT UINT* totalBufferSize,
    OUT UINT* numProperties
    )
{
    return E_NOTIMPL;
}// GetPropertySize()

HRESULT
GpEMFCodec::GetAllPropertyItems(
    IN UINT totalBufferSize,
    IN UINT numProperties,
    IN OUT PropertyItem* allItems
    )
{
    return E_NOTIMPL;
}// GetAllPropertyItems()

HRESULT
GpEMFCodec::RemovePropertyItem(
    IN PROPID   propId
    )
{
    return E_NOTIMPL;
}// RemovePropertyItem()

HRESULT
GpEMFCodec::SetPropertyItem(
    IN PropertyItem item
    )
{
    return E_NOTIMPL;
}// SetPropertyItem()

/**************************************************************************\
*
* Function Description:
*
*     Initiates the decode of the current frame
*
* Arguments:
*
*   decodeSink --  The sink that will support the decode operation
*   newPropSet - New image property sets, if any
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpEMFCodec::BeginDecode(
    IN IImageSink* imageSink,
    IN OPTIONAL IPropertySetStorage* newPropSet
    )
{
    if (decodeSink) 
    {
        WARNING(("BeginDecode called again before call to EngDecode"));
        return E_FAIL;
    }

    imageSink->AddRef();
    decodeSink = imageSink;

    return S_OK;
}
    

/**************************************************************************\
*
* Function Description:
*
*     Ends the decode of the current frame
*
* Arguments:
*
*     statusCode -- status of decode operation

* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpEMFCodec::EndDecode(
    IN HRESULT statusCode
    )
{
    HRESULT hresult;

    if (!decodeSink) 
    {
        WARNING(("EndDecode called before call to BeginDecode"));
        return E_FAIL;
    }
    
    hresult = decodeSink->EndSink(statusCode);

    decodeSink->Release();
    decodeSink = NULL;

    bReinitializeEMF = TRUE;
    
    return hresult;
}


/**************************************************************************\
*
* Function Description:
*
*     Decodes the current frame
*
* Arguments:
*
*     decodeSink --  The sink that will support the decode operation
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpEMFCodec::GetImageInfo(OUT ImageInfo* imageInfoArg)
{
    HRESULT hresult;

    hresult = ReadEMFHeader();
    if (FAILED(hresult)) 
    {
        return hresult;
    }

    *imageInfoArg = imageInfo;

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Decodes the current frame
*
* Arguments:
*
*     decodeSink --  The sink that will support the decode operation
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpEMFCodec::Decode()
{
    HRESULT hresult = S_OK;
    void *buffer;

    // If this is the second time through this stream, reinitialize pointer.

    if (bReinitializeEMF) 
    {
        bReadHeader = FALSE;
        if (!pIstream) 
        {
            return E_FAIL;
        }

        LARGE_INTEGER zero = {0,0};
        hresult = pIstream->Seek(zero, STREAM_SEEK_SET, NULL);
        if (!SUCCEEDED(hresult))
        {
            return hresult;
        }
    }

    hresult = ReadEMFHeader();
    if (FAILED(hresult)) 
    {
        return hresult;
    }

    // Allocate a buffer for the metafile

    buffer = GpMalloc(emh.nBytes);
    if (!buffer) 
    {
        return E_OUTOFMEMORY;
    }

    // Copy the metafile header to the start of the buffer

    *((ENHMETAHEADER *) buffer) = emh;

    // Now read the rest of the metafile into the buffer

    void *restOfBuffer = (void *) (((BYTE *) buffer) + sizeof(emh));
    ULONG cbRead;
    hresult = pIstream->Read(restOfBuffer, emh.nBytes - sizeof(emh), &cbRead);
    if (FAILED(hresult)) 
    {
        return hresult;
    }
    if (cbRead != (emh.nBytes - sizeof(emh))) 
    {
        return E_FAIL;
    }

    // Call BeginSink

    hresult = decodeSink->BeginSink(&imageInfo, NULL);
    if (FAILED(hresult)) 
    {
        return hresult;
    }

    // Create memory DC and dibsection

    BITMAPINFO bmi;
    bmi.bmiHeader.biSize     = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth    = imageInfo.Width;
    bmi.bmiHeader.biHeight   = imageInfo.Height;
    bmi.bmiHeader.biPlanes   = 1;
    bmi.bmiHeader.biBitCount = 32;
    bmi.bmiHeader.biCompression = BI_RGB;
    bmi.bmiHeader.biSizeImage = 0;
    bmi.bmiHeader.biXPelsPerMeter = 0;
    bmi.bmiHeader.biYPelsPerMeter = 0;
    bmi.bmiHeader.biClrUsed = 0;
    bmi.bmiHeader.biClrImportant = 0;

    PBYTE pBits;
    HDC hdcScreen = GetDC(NULL);
    if ( hdcScreen == NULL )
    {
        GpFree(buffer);
        return E_FAIL;
    }

    HDC hdcMem = CreateCompatibleDC(hdcScreen);
    if ( hdcMem == NULL )
    {
        ReleaseDC(NULL, hdcScreen);
        GpFree(buffer);
        return E_FAIL;
    }

    HBITMAP hbitmap = CreateDIBSection(hdcScreen, 
                                       &bmi, 
                                       DIB_RGB_COLORS,
                                        (void **) &pBits, 
                                       NULL, 
                                       0);
    if (!hbitmap) 
    {
        WARNING(("GpEMFCodec::Decode -- failed to create DIBSection"));

        DeleteDC(hdcMem);
        ReleaseDC(NULL, hdcScreen);
        GpFree(buffer);
        return E_OUTOFMEMORY;
    }

    // Initialize background to white

    UINT *p = (UINT *) pBits;
    UINT numPixels = imageInfo.Width * imageInfo.Height;
    UINT i;
    for (i = 0; i < numPixels; i++, p++) 
    {
        *p = 0x00ffffff;
    }

    HBITMAP hOldBitmap = reinterpret_cast<HBITMAP>(SelectObject(hdcMem, hbitmap));
        
    // Create a handle for the metafile backing the bits from the stream

    HENHMETAFILE hemf = SetEnhMetaFileBits(emh.nBytes, (BYTE *) buffer);
    if (!hemf) 
    {
        WARNING(("GpEMFCodec::Decode -- cannot create metafile backing stream bits"));

        DeleteDC(hdcMem);

        HBITMAP hTempBitmap = reinterpret_cast<HBITMAP>(SelectObject(hdcMem,
                                                                   hOldBitmap));
        if ( hTempBitmap != NULL )
        {
            DeleteObject(hTempBitmap);
        }
        ReleaseDC(NULL, hdcScreen);
        GpFree(buffer);
        return E_FAIL;
    }

    // Play the metafile onto the memory DC

    RECT rect;
    rect.left = rect.top = 0;
    rect.right = imageInfo.Width;
    rect.bottom = imageInfo.Height;
    PlayEnhMetaFile(hdcMem, hemf, &rect);
 
    // And finally deliver the bits to the sink

    // ASSERT: The bits are in PIXFMT_32BPP_RGB format (no alpha values)
    
    BitmapData bitmapData;

    bitmapData.Width  = imageInfo.Width;
    bitmapData.Height = 1;
    bitmapData.Stride = bitmapData.Width * 4;
    bitmapData.PixelFormat = PIXFMT_32BPP_ARGB;
    bitmapData.Reserved = 0;

    rect.left  = 0;
    rect.right = imageInfo.Width;

    for (i=0; i < imageInfo.Height; i++) 
    {
        rect.top    = i;
        rect.bottom = i + 1;
        bitmapData.Scan0 = pBits + (imageInfo.Height - i - 1) * bitmapData.Stride;

        // need to fill in the alpha values to make the bits be PIXFMT_32BPP_ARGB format,
        // which is a canonical format.
        UINT j;
        BYTE *ptr;
        for (j = 0, ptr = static_cast<BYTE *>(bitmapData.Scan0);
             j < imageInfo.Width;
             j++, ptr += 4)
        {
            // fill in the alpha value with 0xff
            *(ptr + 3) = 0xff;
        }

        hresult = decodeSink->PushPixelData(&rect, 
                                            &bitmapData,
                                            TRUE);

        if (FAILED(hresult)) 
        {
            WARNING(("GpEMFCodec::Decode -- failed call to PushPixelData"));
            break;
        }
    }    
    
    // Release objects
    
    DeleteEnhMetaFile(hemf);
    DeleteObject(SelectObject(hdcMem, hOldBitmap));
    DeleteDC(hdcMem);
    ReleaseDC(NULL, hdcScreen);
    GpFree(buffer);
    
    return hresult;
}

/**************************************************************************\
*
* Function Description:
*
*     Get the total number of dimensions the image supports
*
* Arguments:
*
*     count -- number of dimensions this image format supports
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpEMFCodec::GetFrameDimensionsCount(
    UINT* count
    )
{
    if ( count == NULL )
    {
        WARNING(("GpEmfCodec::GetFrameDimensionsCount--Invalid input parameter"));
        return E_INVALIDARG;
    }
    
    // Tell the caller that EMF is a one dimension image.

    *count = 1;
    
    return S_OK;
}// GetFrameDimensionsCount()

/**************************************************************************\
*
* Function Description:
*
*     Get an ID list of dimensions the image supports
*
* Arguments:
*
*     dimensionIDs---Memory buffer to hold the result ID list
*     count -- number of dimensions this image format supports
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpEMFCodec::GetFrameDimensionsList(
    GUID*   dimensionIDs,
    UINT    count
    )
{
    if ( (count != 1) || (dimensionIDs == NULL) )
    {
        WARNING(("GpEmfCodec::GetFrameDimensionsList-Invalid input param"));
        return E_INVALIDARG;
    }

    dimensionIDs[0] = FRAMEDIM_PAGE;

    return S_OK;
}// GetFrameDimensionsList()

/**************************************************************************\
*
* Function Description:
*
*     Get number of frames for the specified dimension
*     
* Arguments:
*
*     dimensionID --
*     count --     
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpEMFCodec::GetFrameCount(
    IN const GUID* dimensionID,
    OUT UINT* count
    )
{
    if ( (NULL == count) || (*dimensionID != FRAMEDIM_PAGE) )
    {
        return E_INVALIDARG;
    }
    
    *count = 1;

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Select currently active frame
*     
* Arguments:
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpEMFCodec::SelectActiveFrame(
    IN const GUID* dimensionID,
    IN UINT frameIndex
    )
{
    return E_NOTIMPL;
}



/**************************************************************************\
*
* Function Description:
*
*   Get image thumbnail
*
* Arguments:
*
*   thumbWidth, thumbHeight - Specifies the desired thumbnail size in pixels
*   thumbImage - Returns a pointer to the thumbnail image
*
* Return Value:
*
*   Status code
*
* Note:
*
*   Even if the optional thumbnail width and height parameters are present,
*   the decoder is not required to honor it. The requested size is used
*   as a hint. If both width and height parameters are 0, then the decoder
*   is free to choose an convenient thumbnail size.
*
\**************************************************************************/

HRESULT
GpEMFCodec::GetThumbnail(
    IN OPTIONAL UINT thumbWidth,
    IN OPTIONAL UINT thumbHeight,
    OUT IImage** thumbImage
    )
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\emf\emfcodec.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   emfcodec.hpp
*
* Abstract:
*
*   Header file for the EMF encoder/decoder
*
* Revision History:
*
*   6/14/1999 OriG
*       Created it.
*
\**************************************************************************/

class GpEMFCodec : public IImageDecoder
{
private:

    // =====================================================
    // Decoder privates
    // =====================================================

    IStream *pIstream;
    IImageSink* decodeSink;
    ImageInfo imageInfo;
    ENHMETAHEADER emh;
    BOOL bReadHeader;
    BOOL bReinitializeEMF;
    
protected:
    LONG comRefCount;       // COM object reference count    

public:

    // Constructor and Destructor
    
    GpEMFCodec::GpEMFCodec(void);
    GpEMFCodec::~GpEMFCodec(void);

    // IImageDecoder methods
    
    STDMETHOD(InitDecoder)(IN IStream* stream, IN DecoderInitFlag flags);
    STDMETHOD(TerminateDecoder) ();
    STDMETHOD(BeginDecode)(IN IImageSink* imageSink, IN OPTIONAL IPropertySetStorage* newPropSet);
    STDMETHOD(Decode)();
    STDMETHOD(EndDecode)(IN HRESULT statusCode);
    STDMETHOD(GetFrameDimensionsCount)(OUT UINT* count);
    STDMETHOD(GetFrameDimensionsList)(OUT GUID* dimensionIDs,IN OUT UINT count);
    STDMETHOD(GetFrameCount)(IN const GUID* dimensionID, OUT UINT* count);
    STDMETHOD(SelectActiveFrame)(IN const GUID* dimensionID, 
        IN UINT frameIndex);
    STDMETHOD(GetImageInfo)(OUT ImageInfo* imageInfo);
    STDMETHOD(GetThumbnail)(IN OPTIONAL UINT thumbWidth, IN OPTIONAL UINT thumbHeight,
        OUT IImage** thumbImage);
    STDMETHOD(QueryDecoderParam)(IN GUID Guid);
    STDMETHOD(SetDecoderParam)(IN GUID Guid, IN UINT Length, IN PVOID Value);
    STDMETHOD(GetPropertyCount)(OUT UINT* numOfProperty);
    STDMETHOD(GetPropertyIdList)(IN UINT numOfProperty,IN OUT PROPID* list);
    STDMETHOD(GetPropertyItemSize)(IN PROPID propId, OUT UINT* size);    
    STDMETHOD(GetPropertyItem)(IN PROPID propId, IN UINT propSize,
                               IN OUT PropertyItem* buffer);
    STDMETHOD(GetPropertySize)(OUT UINT* totalBufferSize,
                               OUT UINT* numProperties);
    STDMETHOD(GetAllPropertyItems)(IN UINT totalBufferSize,
                                   IN UINT numProperties,
                                   IN OUT PropertyItem* allItems);
    STDMETHOD(RemovePropertyItem)(IN PROPID propId);
    STDMETHOD(SetPropertyItem)(IN PropertyItem item);
    STDMETHOD(GetRawInfo)(IN OUT void** info)
    {
        return E_NOTIMPL;
    }
    
    STDMETHOD(ReadEMFHeader());
    
    // IUnknown methods

    STDMETHOD(QueryInterface)(REFIID riid, VOID** ppv);
    STDMETHOD_(ULONG, AddRef)(VOID);
    STDMETHOD_(ULONG, Release)(VOID);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\dll\dllentry.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   dllentry.cpp
*
* Abstract:
*
*   Description of what this module does.
*
* Revision History:
*
*   05/10/1999 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"


//
// DLL instance handle
//

extern HINSTANCE DllInstance;

BOOL InitImagingLibrary(BOOL suppressExternalCodecs);
VOID CleanupImagingLibrary();

/**************************************************************************\
*
* Function Description:
*
*   DLL entrypoint
*
* Arguments:
* Return Value:
*
*   See Win32 SDK documentation
*
\**************************************************************************/

extern "C" BOOL
DllEntryPoint(
    HINSTANCE   dllHandle,
    DWORD       reason,
    CONTEXT*    reserved
    )
{
    BOOL ret = TRUE;
    
    switch (reason)
    {
    case DLL_PROCESS_ATTACH:

        // To improve the working set, we tell the system we don't
        // want any DLL_THREAD_ATTACH calls

        DllInstance = dllHandle;
        DisableThreadLibraryCalls(dllHandle);
        
        ret = GpRuntime::Initialize();

        if (ret)
        {
            ret = InitImagingLibrary(FALSE);
        }
        break;

    case DLL_PROCESS_DETACH:

        CleanupImagingLibrary();
        GpRuntime::Uninitialize();
        break;
    }

    return ret;
}


/**************************************************************************\
*
* Function Description:
*
*   Determine whether the DLL can be safely unloaded
*   See Win32 SDK documentation for more details.
*
\**************************************************************************/

STDAPI
DllCanUnloadNow()
{
    return (ComComponentCount == 0) ? S_OK : S_FALSE;
}


/**************************************************************************\
*
* Function Description:
*
*   Retrieves a class factory object from a DLL.
*   See Win32 SDK documentation for more details.
*
\**************************************************************************/

typedef IClassFactoryBase<GpImagingFactory> GpDllClassFactory;

STDAPI
DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    VOID** ppv
    )
{
    if (rclsid != CLSID_ImagingFactory)
        return CLASS_E_CLASSNOTAVAILABLE;

    GpDllClassFactory* factory = new GpDllClassFactory();

    if (factory == NULL)
        return E_OUTOFMEMORY;

    HRESULT hr = factory->QueryInterface(riid, ppv);
    factory->Release();

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Register/unregister our COM component
*   See Win32 SDK documentation for more details.
*
\**************************************************************************/

static const ComComponentRegData ComRegData =
{
    &CLSID_ImagingFactory,
    L"ImagingFactory COM Component",
    L"imaging.ImagingFactory.1",
    L"imaging.ImagingFactory",
    L"Both"
};

STDAPI
DllRegisterServer()
{
    return RegisterComComponent(&ComRegData, TRUE);
}

STDAPI
DllUnregisterServer()
{
    return RegisterComComponent(&ComRegData, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\gif\gifbuffer.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*    gifbuffer.cpp
*
* Abstract:
*
*    The GifBuffer class holds gif data that has been uncompressed. It is
*    able to hold data one line at a time or as one large chunk, depending on
*    how it is needed.
*
* Revision History:
*
*    7/9/1999 t-aaronl
*        Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "gifbuffer.hpp"

/**************************************************************************\
*
* Function Description:
*
*     Contructor for GifBuffer
*
* Arguments:
*
*     none
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

GifBuffer::GifBuffer(
    IN IImageSink*      pSink,
    IN RECT             imageDataRect,
    IN RECT             imageRect,
    IN RECT             frameRect,
    IN BOOL             fOneRowAtATime, 
    IN PixelFormatID    pixelFormat, 
    IN ColorPalette*    pColorPalette, 
    IN BOOL             fHasLocalPalette, 
    IN GifFrameCache*   pGifFrameCache, 
    IN BOOL             fSinkData, 
    IN BOOL             fHasTransparentColor,
    IN BYTE             cTransIndex, 
    IN BYTE             cDisposalMethod
    )
{
    SinkPtr               = pSink;
    OriginalImageRect     = imageDataRect;
    OutputImageRect       = imageRect;
    FrameRect             = frameRect;
    IsOneRowAtATime       = fOneRowAtATime;
    DstPixelFormat        = pixelFormat;
    BufferColorPalettePtr = (ColorPalette*)&ColorPaletteBuffer;
    
    GpMemcpy(BufferColorPalettePtr, pColorPalette, 
        offsetof(ColorPalette, Entries) + pColorPalette->Count * sizeof(ARGB));
    
    CurrentFrameCachePtr  = pGifFrameCache;
    NeedSendDataToSink    = fSinkData;
    TransparentIndex      = cTransIndex;
    DisposalMethod        = cDisposalMethod;
    HasTransparentColor   = fHasTransparentColor;

    // Initialize the CurrentFrameCachePtr, if necessary.
    // ASSERT: fHasLocalPalette should be TRUE if and only if there is a
    // local palette associated with the current frame OR BufferColorPalettePtr
    // could be different from the previous color palette (which might
    // be the case if the transparent color index changed in the last gce).
    
    if ( CurrentFrameCachePtr != NULL )
    {
        if ( (CurrentFrameCachePtr->CachePaletteInitialized() == FALSE)
           ||(fHasLocalPalette == TRUE) )
        {
            if ( CurrentFrameCachePtr->SetFrameCachePalette(pColorPalette)
                 == FALSE )
            {
                SetValid(FALSE);
                return;
            }

            DstPixelFormat = CurrentFrameCachePtr->pixformat;
        }
    }

    // Create a BitmapDataBuffer which can holds the whole OutputImageRect. The
    // real memory buffer is pointed by RegionBufferPtr

    BitmapDataBuffer.Width = OutputImageRect.right - OutputImageRect.left;
    
    UINT    uiOriginalImageStride = OriginalImageRect.right
                                  - OriginalImageRect.left;
    BufferStride = BitmapDataBuffer.Width;
    if ( DstPixelFormat == PIXFMT_32BPP_ARGB )
    {
        uiOriginalImageStride = (uiOriginalImageStride << 2);
        BufferStride = (BufferStride << 2);
    }
    
    BitmapDataBuffer.Height = OutputImageRect.bottom - OutputImageRect.top;
    BitmapDataBuffer.Stride = BufferStride;
    BitmapDataBuffer.PixelFormat = DstPixelFormat;
    BitmapDataBuffer.Scan0 = NULL;
    BitmapDataBuffer.Reserved = 0;
    SetValid(TRUE);

    if ( IsOneRowAtATime == FALSE )
    {
        // If we are buffering the whole image then we have to get a pointer to 
        // the buffer that we will use
        
        if ( CurrentFrameCachePtr == NULL )
        {
            RegionBufferPtr = (BYTE*)GpMalloc(BitmapDataBuffer.Stride
                                              * BitmapDataBuffer.Height);
        }
        else
        {
            // If we are in animated mode then use the frame cache's
            // RegionBufferPtr to hold the current data
            
            RegionBufferPtr = CurrentFrameCachePtr->GetBuffer();
        }

        if ( RegionBufferPtr == NULL )
        {
            WARNING(("GifBuffer::GifBuffer---RegionBufferPtr is NULL"));
            SetValid(FALSE);
        }
        else
        {
            BitmapDataBuffer.Scan0 = RegionBufferPtr;
        }
    }// Not one row at a time
    else
    {
        // If it is One Row At A Time, then we don't need a Region Buffer

        RegionBufferPtr = NULL;
    }

    // If it is a multi-framed GIF and Dispose method is 3, then we need to
    // create a restore buffer

    if ( (CurrentFrameCachePtr != NULL) && (DisposalMethod == 3) )
    {
        RestoreBufferPtr = (BYTE*)GpMalloc(BitmapDataBuffer.Stride
                                           * BitmapDataBuffer.Height);
        if ( RestoreBufferPtr == NULL )
        {
            WARNING(("GifBuffer::GifBuffer---RestoreBufferPtr is NULL"));
            SetValid(FALSE);
        }
        else
        {
            // Copy "OutputImageRect" data in the cache to RestoreBufferPtr

            CurrentFrameCachePtr->CopyFromCache(OutputImageRect,
                                                RestoreBufferPtr);
        }
    }
    else
    {
        RestoreBufferPtr = NULL;
    }

    // Allocate bunch of buffers we need

    ScanlineBufferPtr = (BYTE*)GpMalloc(uiOriginalImageStride);
    TempBufferPtr = (BYTE*)GpMalloc(uiOriginalImageStride);
    ExcessBufferPtr = (BYTE*)GpMalloc(uiOriginalImageStride);

    if ( (ScanlineBufferPtr == NULL)
       ||(TempBufferPtr == NULL)
       ||(ExcessBufferPtr == NULL) )
    {
        SetValid(FALSE);
    }

    CurrentRowPtr = NULL;
}// GifBuffer Ctor()

/**************************************************************************\
*
* Function Description:
*
*     Destructor for GifBuffer
*
* Arguments:
*
*     none
*
* Return Value:
*
*     none
*
\**************************************************************************/

GifBuffer::~GifBuffer()
{
    if ( CurrentFrameCachePtr == NULL )
    {
        // Region buffer will be allocated only when CurrentFrameCachePtr is
        // NULL. See the code in the Constructor

        GpFree(RegionBufferPtr);
    }

    BufferColorPalettePtr->Count = 0;

    GpFree(ScanlineBufferPtr);
    GpFree(TempBufferPtr);
    GpFree(ExcessBufferPtr);

    if ( RestoreBufferPtr != NULL )
    {
        // RestoreBufferPtr should be freed in FinishFrame() and set to NULL

        WARNING(("GifBuffer::~GifBuffer---RestoreBufferPtr not null"));
        GpFree(RestoreBufferPtr);
    }

    SetValid(FALSE);                // So we don't use a deleted object
}// GifBuffer Dstor()

/**************************************************************************\
*
* Function Description:
*
*   Sets CurrentRowPtr to point to a buffer from the sink if the GifBuffer is in
*   "one row at a time mode". Otherwise set CurrentRowPtr to point to the whole
*   image buffer where the decompressed data should be written.
*
* Arguments:
*
*     iRow --- Row number to get a pointer to.
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
GifBuffer::GetBuffer(
    IN INT iRow
    )
{
    if ( IsOneRowAtATime == TRUE )
    {
        // If it is One Row At A Time, we can ask the sink to allocate the
        // buffer and directly dump the decode result one raw at a time to that
        // buffer

        RECT currentRect = {0,
                            OutputImageRect.top + iRow, 
                            OutputImageRect.right - OutputImageRect.left,
                            OutputImageRect.top + iRow + 1
                           };

        HRESULT hResult = SinkPtr->GetPixelDataBuffer(&currentRect,
                                                      DstPixelFormat, 
                                                      TRUE,
                                                      &BitmapDataBuffer);
        if ( FAILED(hResult) )
        {
            WARNING(("GifBuffer::GetBuffer---GetPixelDataBuffer() failed"));
            return hResult;
        }

        CurrentRowPtr = (UNALIGNED BYTE*)(BitmapDataBuffer.Scan0);

        if ( CurrentFrameCachePtr != NULL )
        {
            // Copy one line of data from the frame cache into CurrentRowPtr

            CurrentFrameCachePtr->FillScanline(CurrentRowPtr, iRow);
        }
    }
    else
    {
        // Not one row at a time.

        if ( CurrentFrameCachePtr == NULL )
        {
            // No frame cache, then use our own RegionBuffer to receive
            // decompressed data

            CurrentRowPtr = RegionBufferPtr + iRow * BufferStride;
        }
        else
        {
            // If there is a frame cache, then we just get a pointer to the
            // current row in the frame cache

            CurrentRowPtr = CurrentFrameCachePtr->GetScanLinePtr(iRow);
        }
    }

    // Remember current row number

    CurrentRowNum = iRow;

    return S_OK;
}// GetBuffer()

/**************************************************************************\
*
* Function Description:
*
*   Sends the buffer to the sink. If the color needs to be converted from 
*   8bppIndexed to 32bppARGB then it uses the 'BufferColorPalettePtr' member
*   variable for the conversion.
*
* Arguments:
*
*     fPadBorder      -- Whether we should pad the borders of the line with
*                        the background color
*     cBackGroundColor-- The color to use if fPadBorder or padLine is TRUE
*     iLine           -- Line to use from the CurrentFrameCachePtr, if necessary
*     fPadLine        -- Whether the entire line should be padded
*                        (with the background color)
*     fSkipLine       -- Whether the entire line should be skipped
*                        (using the CurrentFrameCachePtr to fill in the line)
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
GifBuffer::ReleaseBuffer(
    IN BOOL fPadBorder,
    IN BYTE cBackGroundColor,
    IN int  iLine,
    IN BOOL fPadLine,
    IN BOOL fSkipLine
    )
{
    if ( fSkipLine == FALSE )
    {
        if ( CurrentRowPtr == NULL )
        {
            WARNING(("Gif:ReleaseBuffer-GetBuf must be called bef ReleaseBuf"));
            return E_FAIL;
        }
    
        if ( fPadLine == TRUE )
        {
            // Pad the whole line with background color. Result is in
            // CurrentRowPtr

            ASSERT(OutputImageRect.left == 0);

            if ( DstPixelFormat == PIXFMT_8BPP_INDEXED )
            {
                for ( int i = 0; i < OutputImageRect.right; i++ )
                {
                    CurrentRowPtr[i] = cBackGroundColor;
                }
            }
            else
            {
                // 32 bpp ARGB mode

                for ( int i = 0; i < OutputImageRect.right; i++ )
                {
                    ((ARGB*)CurrentRowPtr)[i] =
                        BufferColorPalettePtr->Entries[cBackGroundColor];
                }
            }
        }// ( fPadLine == TRUE )
        else
        {
            // Not pad line case
            // ASSERT: ScanlineBufferPtr now contains all of the pixels in a
            // line of the image. We now copy the correct bits (i.e., accounting
            // for clipping and horizontal padding) of ScanlineBufferPtr to
            // CurrentRowPtr.
    
            int i;

            if ( DstPixelFormat == PIXFMT_8BPP_INDEXED )
            {
                ASSERT(CurrentFrameCachePtr == NULL);

                // Fill the left of the clip region with background color

                for ( i = 0; i < FrameRect.left; i++ )
                {
                    CurrentRowPtr[i] = cBackGroundColor;
                }

                // Fill the clip region with real data

                for ( i = FrameRect.left; i < FrameRect.right; i++ )
                {
                    CurrentRowPtr[i] = ScanlineBufferPtr[i - FrameRect.left];
                }

                // Fill the right of the clip region with background color

                for (i = FrameRect.right; i < OutputImageRect.right; i++)
                {
                    CurrentRowPtr[i] = cBackGroundColor;
                }
            }// 8BPP mode
            else
            {
                // 32 bpp mode

                ASSERT(DstPixelFormat == PIXFMT_32BPP_ARGB);

                BYTE*   pInputBuffer = NULL;
                if ( CurrentFrameCachePtr != NULL )
                {
                    pInputBuffer = CurrentFrameCachePtr->GetScanLinePtr(iLine);
                }

                if ( fPadBorder == TRUE )
                {
                    // Fill the left of the clip region with background color
                    
                    for ( i = 0; i < FrameRect.left; i++ )
                    {
                        ((ARGB*)CurrentRowPtr)[i] =
                               BufferColorPalettePtr->Entries[cBackGroundColor];
                    }

                    // Fill the right of clip region with background color

                    for ( i = FrameRect.right; i < OutputImageRect.right; i++ )
                    {
                        ((ARGB*)CurrentRowPtr)[i] =
                              BufferColorPalettePtr->Entries[cBackGroundColor];
                    }
                }// ( fPadBorder == TRUE )
                else
                {
                    // Not pad board case
                    // Fill the region outside of the clip region with data
                    // from the frame cache if we have one (pInputBuffer!= NULL)

                    if ( pInputBuffer != NULL )
                    {
                        for ( i = 0; i < FrameRect.left; i++ )
                        {
                            ((ARGB*)CurrentRowPtr)[i]= ((ARGB*)pInputBuffer)[i];
                        }

                        for (i = FrameRect.right; i <OutputImageRect.right; i++)
                        {
                            ((ARGB*)CurrentRowPtr)[i]= ((ARGB*)pInputBuffer)[i];
                        }
                    }
                }

                // Now fill the data inside the clip region

                for ( i = FrameRect.left; i < FrameRect.right; i++ )
                {
                    ARGB    argbTemp =
                                ((ARGB*)ScanlineBufferPtr)[i - FrameRect.left];

                    // If there is a frame cache and the pixel is transparent,
                    // then assign the background pixel value to it. Otherwise,
                    // assign the full ARGB value

                    if ( (CurrentFrameCachePtr != NULL)
                       &&((argbTemp & ALPHA_MASK) == 0) )
                    {
                        ((ARGB*)CurrentRowPtr)[i] =((ARGB*)pInputBuffer)[i];
                    }
                    else
                    {
                        ((ARGB*)CurrentRowPtr)[i] = argbTemp;
                    }
                }// Fill data inside clip region
            }// 32 bpp mode
        }// None pad line case
    }// ( fSkipLine == FALSE )

    // ASSERT: CurrentRowPtr now contains exactly the bits needed to release to
    // the sink
    // Update the cache if necessary. This line is the result of the compositing
    // and should be put in the cache if there is one. This will be used to
    // compose the next frame

    if ( CurrentFrameCachePtr != NULL )
    {
        CurrentFrameCachePtr->PutScanline(CurrentRowPtr, CurrentRowNum);
    }

    // Release the line if we are in "One row at a time" mode

    if ( IsOneRowAtATime == TRUE )
    {
        HRESULT hResult = SinkPtr->ReleasePixelDataBuffer(&BitmapDataBuffer);
        if (FAILED(hResult))
        {
            WARNING(("GifBuf::ReleaseBuffer-ReleasePixelDataBuffer() failed"));
            return hResult;
        }
    }

    CurrentRowPtr = NULL;

    return S_OK;
}// ReleaseBuffer()

/**************************************************************************\
*
* Function Description:
*
*     Called after all the data in the frame has been set. Pushes the buffer.
*
* Arguments:
*
*     fLastFrame is FALSE if the image is multipass and this is not the last 
*     pass. It is TRUE otherwise (default is TRUE).
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
GifBuffer::FinishFrame(
    IN BOOL fLastFrame
    )
{
    HRESULT hResult;

    // Check if we still have a line need to draw into

    if ( CurrentRowPtr != NULL )
    {        
        WARNING(("Buf::FinishFrame-ReleaseBuf must be called bef FinishFrame"));
        
        // Release the last line

        hResult = ReleaseBuffer(FALSE,          // Don't pad the board
                                0,              // Background color
                                0,              // Line number
                                FALSE,          // Don't pad the line
                                FALSE);         // Don't skip the line
        if ( FAILED(hResult) )
        {
            WARNING(("GifBuffer::FinishFrame---ReleaseBuffer() failed"));
            return hResult;
        }
    }

    if ( (IsOneRowAtATime == FALSE) && (NeedSendDataToSink == TRUE) )
    {
        // Send all the data down to the sink at once

        ASSERT(BitmapDataBuffer.Scan0 == RegionBufferPtr);
        hResult = SinkPtr->PushPixelData(&OutputImageRect, &BitmapDataBuffer,
                                         fLastFrame);
        if ( FAILED(hResult) )
        {
            WARNING(("GifBuffer::FinishFrame---PushPixelData() failed"));
            return hResult;
        }
    }

    if ( fLastFrame == TRUE )
    {
        if ( DisposalMethod == 3 )
        {
            // Restore from last frame

            ASSERT(RestoreBufferPtr);
            CurrentFrameCachePtr->CopyToCache(FrameRect, RestoreBufferPtr);
            GpFree(RestoreBufferPtr);
            RestoreBufferPtr = NULL;
        }
        else if ( DisposalMethod == 2 )
        {
            // Restore to background

            CurrentFrameCachePtr->ClearCache(FrameRect);
        }
    }

    return S_OK;
}// FinishFrame()

/**************************************************************************\
*
* Function Description:
*
*   Gets all scanlines from 'top' to 'bottom', fills them with 'color' then 
*   releases them.
*
* Arguments:
*
*   Top and bottom bounds and the fill color.
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
GifBuffer::PadScanLines(
    IN INT  iTopLine,
    IN INT  iBottomLine,
    IN BYTE color
    )
{
    for ( INT y = iTopLine; y <= iBottomLine; y++ )
    {
        HRESULT hResult = GetBuffer(y);
        if ( FAILED(hResult) )
        {
            WARNING(("GifBuffer::PadScanLines---GetBuffer() failed"));
            return hResult;
        }

        if ( DstPixelFormat == PIXFMT_8BPP_INDEXED )
        {
            GpMemset(ScanlineBufferPtr, color,
                     OriginalImageRect.right - OriginalImageRect.left);
        }
        else
        {
            ASSERT(DstPixelFormat == PIXFMT_32BPP_ARGB);
            for (int i = 0;
                 i < (OriginalImageRect.right - OriginalImageRect.left); i++)
            {
                ((ARGB*)(ScanlineBufferPtr))[i] =
                                BufferColorPalettePtr->Entries[color];
            }
        }

        hResult = ReleaseBuffer(FALSE,          // Don't pad the board
                                color,          // Background color
                                y,              // Line number
                                TRUE,           // Pad the line
                                FALSE);         // Don't skip the line
        if ( FAILED(hResult) )
        {
            WARNING(("GifBuffer::PadScanLines---ReleaseBuffer() failed"));
            return hResult;
        }
    }

    return S_OK;
}// PadScanLines()

/**************************************************************************\
*
* Function Description:
*
*     Gets all scanlines from 'top' to 'bottom' then releases them.
*
* Arguments:
*
*     Top and bottom bounds.
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
GifBuffer::SkipScanLines(
    IN INT top,
    IN INT bottom
    )
{
    for ( INT y = top; y <= bottom; y++ )
    {
        HRESULT hResult = GetBuffer(y);
        if (FAILED(hResult))
        {
            WARNING(("GifBuffer::SkipScanLines---GetBuffer() failed"));
            return hResult;
        }

        hResult = ReleaseBuffer(FALSE, 0, 0, FALSE, TRUE);
        if (FAILED(hResult))
        {
            WARNING(("GifBuffer::SkipScanLines---ReleaseBuffer() failed"));
            return hResult;
        }
    }

    return S_OK;
}// SkipScanLines()

/**************************************************************************\
*
* Function Description:
*
*     CopyLine makes a copy of the current line, releases it, gets the next 
*     line and puts the data from the first line into the new one.  The new 
*     one still needs to be released.  This function invalidates any copy of 
*     the pointer to the data that the caller may have.  The caller must 
*     GetCurrentBuffer() to refresh the pointer to the data.
*
* Arguments:
*
*     none
*
* Return Value:
*
*     none
*
\**************************************************************************/

STDMETHODIMP
GifBuffer::CopyLine()
{
    HRESULT hResult = S_OK;

    if ( CurrentRowNum < OutputImageRect.bottom - 1 )
    {
        UINT    uiDstPixelSize = 1;

        if ( DstPixelFormat == PIXFMT_32BPP_ARGB )
        {
            uiDstPixelSize = (uiDstPixelSize << 2);
        }

        ASSERT(TempBufferPtr != NULL);

        GpMemcpy(TempBufferPtr, ScanlineBufferPtr,
                (OriginalImageRect.right - OriginalImageRect.left)
                 * uiDstPixelSize);

        // Sends the buffer to the sink

        hResult = ReleaseBuffer(FALSE,          // Don't pad the board
                                0,              // Background color
                                0,              // Line number
                                FALSE,          // Don't pad the line
                                FALSE);         // Don't skip the line
    
        if ( SUCCEEDED(hResult) )
        {
            // Sets CurrentRowPtr to an approprite buffer

            hResult = GetBuffer(CurrentRowNum + 1);
        }
        
        GpMemcpy(ScanlineBufferPtr, TempBufferPtr,
                (OriginalImageRect.right - OriginalImageRect.left)
                 * uiDstPixelSize);
    }

    return hResult;
}// CopyLine()

/**************************************************************************\
*
* Function Description:
*
*     This function assumes that the buffer that contains the relevant
*     data for the current scanline (ScanlineBufferPtr) contains
*     (8BPP) indexes.  This function uses the color palette to convert the
*     buffer into ARGB values.
*
* Arguments:
*
*     none
*
* Return Value:
*
*     none
*
\**************************************************************************/

void
GifBuffer::ConvertBufferToARGB()
{
    if ( HasTransparentColor == TRUE )
    {
        for ( int i = OriginalImageRect.right - OriginalImageRect.left - 1;
              i >= 0; i--)
        {
            // If the index equals the transparent index, then set the pixel as
            // transparent. Otherwise, get the real ARGB value from the palette
            //
            // Note: ScanlineBufferPtr is allocated in the constructor. The
            // pixel format has been taken into consideration. So we have
            // allocated enough bytes for 32 ARGB case. So we won't write out
            // the memory bounds.
            // Note: Writing over ScanlineBufferPtr works because we start from
            // the end of the buffer and move backwards.

            if ( ((BYTE*)ScanlineBufferPtr)[i] == TransparentIndex )
            {
                ((ARGB*)ScanlineBufferPtr)[i] = 0x00000000;
            }
            else
            {
                ((ARGB*)(ScanlineBufferPtr))[i] =
                  BufferColorPalettePtr->Entries[((BYTE*)ScanlineBufferPtr)[i]];
            }
        }
    }
    else
    {
        for ( int i = OriginalImageRect.right - OriginalImageRect.left - 1;
              i >= 0; i--)
        {
            ((ARGB*)(ScanlineBufferPtr))[i] =
                  BufferColorPalettePtr->Entries[((BYTE*)ScanlineBufferPtr)[i]];
        }
    }
}// ConvertBufferToARGB()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\bmp\bmpencoder.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   bmpencoder.cpp
*
* Abstract:
*
*   Implementation of the bitmap filter encoder.  This file contains the
*   methods for both the encoder (IImageEncoder) and the encoder's sink
*  (IImageSink).
*
* Revision History:
*
*   5/10/1999 OriG
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "bmpencoder.hpp"


// =======================================================================
// IImageEncoder methods
// =======================================================================

/**************************************************************************\
*
* Function Description:
*
*     Initialize the image encoder
*
* Arguments:
*
*     stream - input stream to write encoded data
*
* Return Value:
*
*   Status code
*
\**************************************************************************/
    
STDMETHODIMP
GpBmpEncoder::InitEncoder(
    IN IStream* stream
    )
{
    // Make sure we haven't been initialized already

    if (pIoutStream)
    {
        return E_FAIL;
    }

    // Keep a reference on the input stream

    stream->AddRef();
    pIoutStream = stream;

    return S_OK;
}
        
/**************************************************************************\
*
* Function Description:
*
*     Cleans up the image encoder
*
* Arguments:
*
*     NONE
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpEncoder::TerminateEncoder()
{
    // Release the input stream

    if(pIoutStream)
    {
        pIoutStream->Release();
        pIoutStream = NULL;
    }

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Returns a pointer to the vtable of the encoder sink.  The caller will
*     push the bitmap bits into the encoder sink, which will encode the
*     image.
*
* Arguments:
*
*     sink - upon exit will contain a pointer to the IImageSink vtable
*       of this object
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpEncoder::GetEncodeSink(
    OUT IImageSink** sink
    )
{
    AddRef();
    *sink = static_cast<IImageSink*>(this);

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Set active frame dimension
*
* Arguments:
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpEncoder::SetFrameDimension(
    IN const GUID* dimensionID
    )
{
    return S_OK;
}

HRESULT
GpBmpEncoder::GetEncoderParameterListSize(
    OUT UINT* size
    )
{
    return E_NOTIMPL;
}// GetEncoderParameterListSize()

HRESULT
GpBmpEncoder::GetEncoderParameterList(
    IN  UINT   size,
    OUT EncoderParameters* Params
    )
{
    return E_NOTIMPL;
}// GetEncoderParameterList()

HRESULT
GpBmpEncoder::SetEncoderParameters(
    IN const EncoderParameters* Param
    )
{
    return S_OK;
}// SetEncoderParameters()

// =======================================================================
// IImageSink methods
// =======================================================================

/**************************************************************************\
*
* Function Description:
*
*     Caches the image info structure and initializes the sink state
*
* Arguments:
*
*     imageInfo - information about the image and format negotiations
*     subarea - the area in the image to deliver into the sink, in our
*       case the whole image.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP 
GpBmpEncoder::BeginSink(
    IN OUT ImageInfo* imageInfo,
    OUT OPTIONAL RECT* subarea
    )
{
    //Require TOPDOWN and FULLWIDTH
    imageInfo->Flags = imageInfo->Flags | SINKFLAG_TOPDOWN | SINKFLAG_FULLWIDTH;

    //Disallow SCALABLE, PARTIALLY_SCALABLE, MULTIPASS and COMPOSITE
    imageInfo->Flags = imageInfo->Flags & ~SINKFLAG_SCALABLE & ~SINKFLAG_PARTIALLY_SCALABLE & ~SINKFLAG_MULTIPASS & ~SINKFLAG_COMPOSITE;

    encoderImageInfo = *imageInfo;
    bWroteHeader = FALSE;

    if (subarea) 
    {
        // Deliver the whole image to the encoder

        subarea->left = subarea->top = 0;
        subarea->right  = imageInfo->Width;
        subarea->bottom = imageInfo->Height;
    }

    return S_OK;
}
    

/**************************************************************************\
*
* Function Description:
*
*     Cleans up the sink state
*
* Arguments:
*
*     statusCode - the reason why the sink is terminating
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP 
GpBmpEncoder::EndSink(
    IN HRESULT statusCode
    )
{
    return statusCode;
}
    
/**************************************************************************\
*
* Function Description:
*
*     Writes the bitmap file headers
*
* Arguments:
*
*     palette - the color palette to put in the bitmap info header (can be
*       NULL)
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP 
GpBmpEncoder::WriteHeader(
    IN const ColorPalette* palette
    )
{
    BITMAPFILEHEADER bfh;
    BITMAPINFOHEADER bmih;
    RGBQUAD bmiColors[256];
    UINT numColors = 0; // Number of colors in bmiColors
    HRESULT hresult;
    BOOL bNeedPalette = FALSE;

    if (bWroteHeader) 
    {
        // Already wrote the header

        return S_OK;
    }

    // Setup BITMAPINFOHEADER

    ZeroMemory(&bmih, sizeof(bmih));
    bmih.biSize   = sizeof(bmih);
    bmih.biWidth  = encoderImageInfo.Width;
    bmih.biHeight = encoderImageInfo.Height;
    bmih.biPlanes = 1;
    bmih.biCompression = BI_RGB;

    // 1 inch = 2.54 cm - so scale by 100/2.54 to get pixels per meter from DPI

    bmih.biXPelsPerMeter = (LONG)((encoderImageInfo.Xdpi * 100.0 / 2.54) + 0.5);
    bmih.biYPelsPerMeter = (LONG)((encoderImageInfo.Ydpi * 100.0 / 2.54) + 0.5);

    // Format specific setup work

    if (encoderImageInfo.PixelFormat == PIXFMT_1BPP_INDEXED)
    {
        bmih.biBitCount = 1;
        bNeedPalette = TRUE;
    }
    else if (encoderImageInfo.PixelFormat == PIXFMT_4BPP_INDEXED)
    {
        bmih.biBitCount = 4;
        bNeedPalette = TRUE;
    }
    else if (encoderImageInfo.PixelFormat == PIXFMT_8BPP_INDEXED) 
    {
        bmih.biBitCount = 8;
        bNeedPalette = TRUE;        
    }
    else if (encoderImageInfo.PixelFormat == PIXFMT_16BPP_RGB555) 
    {
        bmih.biBitCount = 16;
    }
    else if (encoderImageInfo.PixelFormat == PIXFMT_16BPP_RGB565) 
    {
        bmih.biBitCount = 16;
        bmih.biCompression = BI_BITFIELDS;
        numColors = 3;
        ((UINT32 *) bmiColors)[0] = 0xf800;
        ((UINT32 *) bmiColors)[1] = 0x07e0;
        ((UINT32 *) bmiColors)[2] = 0x001f;
    }
    else if (encoderImageInfo.PixelFormat == PIXFMT_24BPP_RGB) 
    {
        bmih.biBitCount = 24;
    }
    else if ((encoderImageInfo.PixelFormat == PIXFMT_32BPP_RGB) ||
             (encoderImageInfo.PixelFormat == PIXFMT_32BPP_ARGB) ||
             (encoderImageInfo.PixelFormat == PIXFMT_32BPP_PARGB))
    {
        bmih.biBitCount = 32;
    }
    else if ((encoderImageInfo.PixelFormat == PIXFMT_64BPP_ARGB) ||
         (encoderImageInfo.PixelFormat == PIXFMT_64BPP_PARGB))
    {
        bmih.biBitCount = 64;
    }

    else
    {
        // For other format we'll save as 32BPP RGB.
        
        encoderImageInfo.PixelFormat = PIXFMT_32BPP_RGB;
        bmih.biBitCount = 32;
    }
     
    // Get palette if necessary

    if (bNeedPalette)
    {
        if (!palette) 
        {
            WARNING(("GpBmpEncoder::WriteHeader -- Palette needed but not provided by sink\n"));
            return E_FAIL;
        }

        numColors = palette->Count;
        for (UINT i=0; i<numColors; i++) 
        {
            bmiColors[i] = *((RGBQUAD *) (&palette->Entries[i]));
        }
    
        bmih.biClrUsed = bmih.biClrImportant = numColors;
    }
    
    // Compute the bitmap stride

    bitmapStride = (encoderImageInfo.Width * bmih.biBitCount + 7) / 8;
    bitmapStride = (bitmapStride + 3) & (~3);
    

    // Now fill in the BITMAPFILEHEADER

    bfh.bfType = 0x4d42;
    bfh.bfReserved1 = 0;
    bfh.bfReserved2 = 0;
    bfh.bfOffBits = sizeof(bfh) + sizeof(bmih) + numColors * sizeof(RGBQUAD);
    bfh.bfSize = bfh.bfOffBits + bitmapStride * encoderImageInfo.Height;

    // Write the BITMAPFILEHEADER

    ULONG cbWritten;
    hresult = pIoutStream->Write((void *)&bfh, sizeof(bfh), &cbWritten);
    if (!SUCCEEDED(hresult)) 
    {
        return hresult;
    }
    if (cbWritten != sizeof(bfh)) 
    {
        return E_FAIL;
    }

    // Write the BITMAPINFOHEADER

    hresult = pIoutStream->Write((void *)&bmih, sizeof(bmih), &cbWritten);
    if (!SUCCEEDED(hresult)) 
    {
        return hresult;
    }
    if (cbWritten != sizeof(bmih)) 
    {
        return E_FAIL;
    }

    // Write the bmiColors

    if (numColors) 
    {
        hresult = pIoutStream->Write((void *)bmiColors, numColors * sizeof(RGBQUAD), &cbWritten);
        if (!SUCCEEDED(hresult)) 
        {
            return hresult;
        }
        if (cbWritten != numColors * sizeof(RGBQUAD)) 
            {
            return E_FAIL;
        }
    }

    // Remember offset of data from beginning of stream

    encodedDataOffset = sizeof(bfh) + sizeof (bmih) + numColors * sizeof(RGBQUAD);
    
    bWroteHeader = TRUE;
    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*     Sets the bitmap palette
*
* Arguments:
*
*     palette - The palette to set in the sink
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP 
GpBmpEncoder::SetPalette(
    IN const ColorPalette* palette
    )
{
    return WriteHeader(palette);
}

/**************************************************************************\
*
* Function Description:
*
*     Gives a buffer to the sink where data is to be deposited    
*
* Arguments:
*
*     rect - Specifies the interested area of the bitmap
*     pixelFormat - Specifies the desired pixel format
*     lastPass - Whether this the last pass over the specified area
*     bitmapData - Returns information about pixel data buffer
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpEncoder::GetPixelDataBuffer(
    IN const RECT* rect, 
    IN PixelFormatID pixelFormat,
    IN BOOL lastPass,
    OUT BitmapData* bitmapData
    )
{
    HRESULT hresult;
    
    // Write bitmap headers if haven't done so yet
    
    hresult = WriteHeader(NULL);
    if (!SUCCEEDED(hresult)) 
    {
        return hresult;
    }
    
    if ((rect->left != 0) || (rect->right != (LONG) encoderImageInfo.Width)) 
    {
        WARNING(("GpBmpEncoder::GetPixelDataBuffer -- must be same width as image"));
        return E_INVALIDARG;
    }

    if (pixelFormat != encoderImageInfo.PixelFormat)
    {
        WARNING(("GpBmpEncoder::GetPixelDataBuffer -- bad pixel format"));
        return E_INVALIDARG;
    }

    if (!lastPass) 
    {
        WARNING(("GpBmpEncoder::GetPixelDataBuffer -- must receive last pass pixels"));
        return E_INVALIDARG;
    }

    bitmapData->Width       = encoderImageInfo.Width;
    bitmapData->Height      = rect->bottom - rect->top;
    bitmapData->Stride      = bitmapStride;
    bitmapData->PixelFormat = encoderImageInfo.PixelFormat;
    bitmapData->Reserved    = 0;
    
    // Remember the rectangle to be encoded

    encoderRect = *rect;
    
    // Now allocate the buffer where the data will go
    
    if (!lastBufferAllocated) 
    {
        lastBufferAllocated = GpMalloc(bitmapStride * bitmapData->Height);
        if (!lastBufferAllocated) 
        {
            return E_OUTOFMEMORY;
        }
        bitmapData->Scan0 = lastBufferAllocated;
    }
    else
    {
        WARNING(("GpBmpEncoder::GetPixelDataBuffer -- need to first free buffer obtained in previous call"));
        return E_FAIL;
    }


    return S_OK;    
}

/**************************************************************************\
*
* Function Description:
*
*     Write out the data from the sink's buffer into the stream
*
* Arguments:
*
*     bitmapData - Buffer filled by previous GetPixelDataBuffer call
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpEncoder::ReleasePixelDataBuffer(
    IN const BitmapData* bitmapData
    )
{
    HRESULT hresult = S_OK;
    
    // Write one scanline at a time going from bottom to top (make stream
    // writes more sequential).

    INT scanLine;
    for (scanLine = encoderRect.bottom - 1;
         scanLine >= encoderRect.top;
         scanLine--) 
    {
        // Seek to beginning of line

        if (!SeekStreamPos(pIoutStream, STREAM_SEEK_SET,
            encodedDataOffset + (encoderImageInfo.Height - 1 - scanLine) * bitmapStride))
        {
            hresult = E_FAIL;
            break;  // make sure we free bitmapData->scan0 before we return
        }

        // Now write the bits to the stream

        ULONG cbWritten;
        BYTE *pLineBits = ((BYTE *) bitmapData->Scan0) + 
            (scanLine - encoderRect.top) * bitmapData->Stride;
        hresult = pIoutStream->Write((void *) pLineBits, bitmapStride, &cbWritten);
        if (!SUCCEEDED(hresult)) 
        {
            break;  // make sure we free bitmapData->scan0 before we return
        }
        if (cbWritten != (UINT) bitmapStride) 
        {
            hresult = E_FAIL;
            break;  // make sure we free bitmapData->scan0 before we return
        }
    }

    // Free the memory buffer since we're done with it

    if (bitmapData->Scan0 == lastBufferAllocated)
    {
        GpFree(bitmapData->Scan0);
        lastBufferAllocated = NULL;
    }

    return hresult;
}
    

/**************************************************************************\
*
* Function Description:
*
*     Push data into stream (buffer supplied by caller)
*
* Arguments:
*
*     rect - Specifies the affected area of the bitmap
*     bitmapData - Info about the pixel data being pushed
*     lastPass - Whether this is the last pass over the specified area
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpEncoder::PushPixelData(
    IN const RECT* rect,
    IN const BitmapData* bitmapData,
    IN BOOL lastPass
    )
{
    HRESULT hresult;
    
    // Write bitmap headers if haven't done so yet
    
    hresult = WriteHeader(NULL);
    if (!SUCCEEDED(hresult)) 
    {
        return hresult;
    }
    
    encoderRect = *rect;

    if (!lastPass) 
    {
        WARNING(("GpBmpEncoder::PushPixelData -- must receive last pass pixels"));
        return E_INVALIDARG;
    }

    return ReleasePixelDataBuffer(bitmapData);
}


/**************************************************************************\
*
* Function Description:
*
*     Pushes raw compressed data into the .bmp stream.  Not implemented
*     because this filter doesn't understand raw compressed data.
*
* Arguments:
*
*     buffer - Pointer to image data buffer
*     bufsize - Size of the data buffer
*    
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpBmpEncoder::PushRawData(
    IN const VOID* buffer, 
    IN UINT bufsize
    )
{
    return E_NOTIMPL;
}


/**************************************************************************\
*
* Function Description:
*
*     Constructor
*
* Return Value:
*
*   none
*
\**************************************************************************/

GpBmpEncoder::GpBmpEncoder(
    void
    )
{
    comRefCount   = 1;
    pIoutStream   = NULL;
    lastBufferAllocated = NULL;
}

/**************************************************************************\
*
* Function Description:
*
*     Destructor
*
* Return Value:
*
*   none
*
\**************************************************************************/

GpBmpEncoder::~GpBmpEncoder(
    void
    )
{
    // The destructor should never be called before Terminate is called, but
    // if it does we should release our reference on the stream anyway to avoid
    // a memory leak.

    if(pIoutStream)
    {
        WARNING(("GpBmpCodec::~GpBmpCodec -- need to call TerminateEncoder first"));
        pIoutStream->Release();
        pIoutStream = NULL;
    }

    if(lastBufferAllocated)
    {
        WARNING(("GpBmpCodec::~GpBmpCodec -- sink buffer not freed"));
        GpFree(lastBufferAllocated);
        lastBufferAllocated = NULL;
    }
}

/**************************************************************************\
*
* Function Description:
*
*     QueryInterface
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP
GpBmpEncoder::QueryInterface(
    REFIID riid,
    VOID** ppv
    )
{
    if (riid == IID_IImageEncoder)
    {    
        *ppv = static_cast<IImageEncoder*>(this);
    }
    else if (riid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(static_cast<IImageEncoder*>(this));
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     AddRef
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP_(ULONG)
GpBmpEncoder::AddRef(
    VOID)
{
    return InterlockedIncrement(&comRefCount);
}

/**************************************************************************\
*
* Function Description:
*
*     Release
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP_(ULONG)
GpBmpEncoder::Release(
    VOID)
{
    ULONG count = InterlockedDecrement(&comRefCount);

    if (count == 0)
    {
        delete this;
    }

    return count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\bmp\bmpencoder.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   bmpencoder.hpp
*
* Abstract:
*
*   Header file for the bitmap encoder
*
* Revision History:
*
*   5/13/1999 OriG (Ori Gershony)
*       Created it.
*
*   2/7/2000  OriG (Ori Gershony)
*       Move encoder and decoder into separate classes
*
\**************************************************************************/

class GpBmpEncoder : public IImageEncoder, public IImageSink
{
private:
    
    IStream *pIoutStream;
    ImageInfo encoderImageInfo;
    BOOL bWroteHeader;
    RECT encoderRect;       // Area to be encoded next
    INT encodedDataOffset;  // offset of data from beginning of stream
    VOID *lastBufferAllocated;
    INT bitmapStride;

    STDMETHODIMP WriteHeader(IN const ColorPalette* palette);

protected:
    LONG comRefCount;       // COM object reference count    

public:

    // Constructor and Destructor
    
    GpBmpEncoder::GpBmpEncoder(void);
    GpBmpEncoder::~GpBmpEncoder(void);

    // IImageEncoder methods

    STDMETHOD(InitEncoder)(IN IStream* stream);
    STDMETHOD(TerminateEncoder)();
    STDMETHOD(GetEncodeSink)(OUT IImageSink** sink);
    STDMETHOD(SetFrameDimension)(IN const GUID* dimensionID);
    STDMETHOD(GetEncoderParameterListSize)(OUT UINT* size);
    STDMETHOD(GetEncoderParameterList)(IN UINT	  size,
                                       OUT EncoderParameters* Params);
    STDMETHOD(SetEncoderParameters)(IN const EncoderParameters* Param);

    STDMETHOD(NeedTransform(OUT UINT* rotation))
    {
        return E_NOTIMPL;
    }
    
    STDMETHOD(NeedRawProperty)(void *pSRc)
    {
        // BMP can't handle raw property when saving for now

        return E_FAIL;
    }
    
    STDMETHOD(PushRawInfo)(IN void* info)
    {
        return E_NOTIMPL;
    }

    STDMETHOD(GetPropertyBuffer)(
        IN     UINT            uiTotalBufferSize,
        IN OUT PropertyItem**  ppBuffer
        )
    {
        return E_NOTIMPL;
    }
    
    STDMETHOD(PushPropertyItems)(
        IN UINT             numOfItems,
        IN UINT             uiTotalBufferSize,
        IN PropertyItem*    item,
        IN BOOL             fICCProfileChanged
        )
    {
        return E_NOTIMPL;
    }

    // IImageSink methods (sink for encoder)

    STDMETHOD(BeginSink)(IN OUT ImageInfo* imageInfo, 
        OUT OPTIONAL RECT* subarea);
    STDMETHOD(EndSink)(IN HRESULT statusCode);
    STDMETHOD(SetPalette)(IN const ColorPalette* palette);
    STDMETHOD(GetPixelDataBuffer)(IN const RECT* rect, 
        IN PixelFormatID pixelFormat, IN BOOL lastPass,
        OUT BitmapData* bitmapData);
    STDMETHOD(ReleasePixelDataBuffer)(IN const BitmapData* bitmapData);
    STDMETHOD(PushRawData)(IN const VOID* buffer, IN UINT bufsize);
    STDMETHOD(PushPixelData)(IN const RECT* rect,
        IN const BitmapData* bitmapData, IN BOOL lastPass);

    // IUnknown methods

    STDMETHOD(QueryInterface)(REFIID riid, VOID** ppv);
    STDMETHOD_(ULONG, AddRef)(VOID);
    STDMETHOD_(ULONG, Release)(VOID);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\gif\gifbuffer.hpp ===
#pragma once

/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*    gifbuffer.hpp
*
* Abstract:
*
*    The GifBuffer class holds gif data that has been uncompressed.  It is
*    able to hold data one line at a time or as one large chunk, depending on
*    how it is needed.
*
* Revision History:
*
*    7/7/1999 t-aaronl
*        Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "gifframecache.hpp"

class GifBuffer
{
public:
    GifBuffer(IN IImageSink* _sink,
              IN RECT _imagedatarect,
              IN RECT _imagerect,
              IN RECT _framerect,
              IN BOOL _onerowatatime,
              IN PixelFormatID _pixelformat,
              IN ColorPalette *_colorpalette,
              IN BOOL haslocalpalette,
              IN GifFrameCache *gifframecache,
              IN BOOL _sinkdata,
              IN BOOL usetransparency,
              IN BYTE _transindex,
              IN BYTE _disposalmethod);
    ~GifBuffer();

    STDMETHOD(GetBuffer)(IN INT row);
    STDMETHOD(ReleaseBuffer)(IN BOOL padBorder,
                             IN BYTE backgroundColor,
                             IN int line,
                             IN BOOL padLine,
                             IN BOOL skipLine);
    STDMETHOD(FinishFrame)(IN BOOL lastframe = TRUE);
    STDMETHOD(PadScanLines)(INT top, INT bottom, BYTE color);
    STDMETHOD(SkipScanLines)(INT top, INT bottom);
    STDMETHOD(CopyLine)();

    // Returns a pointer to where the uncompressed data should be written to.

    BYTE*   GetCurrentBuffer()
    {
        return ScanlineBufferPtr;
    }

    // Returns a pointer to where the uncompressed data should be written to
    // in the case where we are not actually rendering the output line.

    BYTE*   GetExcessBuffer()
    {
        return ExcessBufferPtr;
    }

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagGifBuffer) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid GifBuffer");
        }
    #endif

        return (Tag == ObjectTagGifBuffer);
    }
    void ConvertBufferToARGB();

private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    
    ObjectTag           Tag;        // Keep this as the 1st value in the object!

    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagGifBuffer : ObjectTagInvalid;
    }

    BitmapData  BitmapDataBuffer;   // Holds info and data to be passed to the
                                    // sink
    BYTE ColorPaletteBuffer[offsetof(ColorPalette, Entries)
                            + sizeof(ARGB) * 256];
    ColorPalette* BufferColorPalettePtr;
                                    // Current color palette in the GIF buffer
    IImageSink* SinkPtr;            // The sink that this buffer is talking to
    GifFrameCache* CurrentFrameCachePtr;
                                    // A cache of the all of the data currently
                                    //   decoded between frames
    RECT    OriginalImageRect;      // Original image data's dimensions
    RECT    OutputImageRect;        // The output image's full dimensions
    RECT    FrameRect;              // OriginalImageRect, clipped to
                                    //   OutputImageRect
    PixelFormatID DstPixelFormat;   // Pixelformat that the sink wants
    UINT    BufferStride;           // Byte offset of the next line in the
                                    //   buffer
    INT     CurrentRowNum;          // The number of the row that is currently
                                    //   being drawn into
    BYTE*   RegionBufferPtr;        // Beginning of the region being drawn into
    UNALIGNED BYTE* CurrentRowPtr;  // Points to the beginning of the row that
                                    //   is currently being drawn into
    BYTE*   ScanlineBufferPtr;      // The output of the decompressor is placed
                                    // here before being copied to CurrentRowPtr
    BYTE*   TempBufferPtr;          // Same as ScanlineBufferPtr, except this is
                                    //   used when HasTransparentColor is TRUE
    BYTE*   ExcessBufferPtr;        // Buffer for lines that won't be rendered
    BYTE*   RestoreBufferPtr;       // Buffer containing info from the last
                                    //   frame drawn for purposes of replacing
                                    //   the current data according to the gif's
                                    //   disposal method
    BYTE    TransparentIndex;       // Index of the transparent color if there
                                    //   is one
    BYTE    DisposalMethod;         // 0-1: leave as is,
                                    // 2:replace w/ background,
                                    // 3: replace w/ previous frame
    BOOL    IsOneRowAtATime;        // TRUE: one row will be sent to the sink at
                                    //   a time, in ReleaseBuffer()
                                    // FALSE: data will be buffered and sent in
                                    //   one chunk in FinishFrame()
    BOOL    NeedSendDataToSink;     // TRUE: data should be sent to the sink
    BOOL    HasTransparentColor;    // TRUE: current frame has a transparent
                                    //   color
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\emf\emfcodec.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   emfcodec.cpp
*
* Abstract:
*
*   Shared methods for the EMF codec
*
* Revision History:
*
*   6/14/1999 OriG
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "emfcodec.hpp"


/**************************************************************************\
*
* Function Description:
*
*     Constructor
*
* Return Value:
*
*   none
*
\**************************************************************************/

GpEMFCodec::GpEMFCodec(
    void
    )
{
    comRefCount   = 1;
    pIstream      = NULL;
    decodeSink    = NULL;
}

/**************************************************************************\
*
* Function Description:
*
*     Destructor
*
* Return Value:
*
*   none
*
\**************************************************************************/

GpEMFCodec::~GpEMFCodec(
    void
    )
{
    // The destructor should never be called before Terminate is called, but
    // if it does we should release our reference on the stream anyway to avoid
    // a memory leak.

    if(pIstream)
    {
        WARNING(("GpEMFCodec::~GpEMFCodec -- need to call TerminateDecoder first"));
        pIstream->Release();
        pIstream = NULL;
    }
}

/**************************************************************************\
*
* Function Description:
*
*     QueryInterface
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP
GpEMFCodec::QueryInterface(
    REFIID riid,
    VOID** ppv
    )
{
    if (riid == IID_IImageDecoder)
    {
        *ppv = static_cast<IImageDecoder*>(this);
    }
    else if (riid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(static_cast<IImageDecoder*>(this));
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     AddRef
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP_(ULONG)
GpEMFCodec::AddRef(
    VOID)
{
    return InterlockedIncrement(&comRefCount);
}

/**************************************************************************\
*
* Function Description:
*
*     Release
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP_(ULONG)
GpEMFCodec::Release(
    VOID)
{
    ULONG count = InterlockedDecrement(&comRefCount);

    if (count == 0)
    {
        delete this;
    }

    return count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\gif\giffile.h ===
#pragma once

/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   giffile.hpp
*
* Abstract:
*
*   Header file with gif file structures.
*
* Revision History:
*
*   6/8/1999 t-aaronl
*       Created it.
*
\**************************************************************************/


#define GIFPLAINTEXTEXTENSIONSIZE 13
#define GIFAPPEXTENSIONHEADERSIZE 11

#pragma pack(1)

struct GifFileHeader  //13 bytes
{
    BYTE signature[6];
    WORD LogicScreenWidth;
    WORD LogicScreenHeight;
    BYTE globalcolortablesize: 3;  //bit fields in reverse significant order
    BYTE sortflag: 1;
    BYTE colorresolution: 3;
    BYTE globalcolortableflag: 1;  // <- most significant
    BYTE backgroundcolor;
    BYTE pixelaspect;
};

struct GifPaletteEntry
{
    BYTE red;
    BYTE green;
    BYTE blue;
};

struct GifColorTable  //palette is up to 3*256 BYTEs
{
    GifPaletteEntry colors[256];
};

struct GifImageDescriptor  //9 bytes
{
  //BYTE imageseparator;  //=0x2C
    WORD left;
    WORD top;
    WORD width;
    WORD height;
    BYTE localcolortablesize: 3;  //bit fields in reverse significant order
    BYTE reserved: 2;
    BYTE sortflag: 1;
    BYTE interlaceflag: 1;
    BYTE localcolortableflag: 1;  // <- most significant
};

struct GifGraphicControlExtension  //6 bytes
{
  //BYTE extensionintroducer;  //=0x21
  //BYTE graphiccontrollabel;  //=0xF9
    BYTE blocksize;
    BYTE transparentcolorflag: 1;  //bit fields in reverse significant order
    BYTE userinputflag: 1;
    BYTE disposalmethod: 3;
    BYTE reserved: 3;  // <- most significant

    WORD delaytime;  //in hundreths of a second
    BYTE transparentcolorindex;
};

#pragma pack()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\gif\gifcodec.hpp ===
#pragma once

/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   gifcodec.hpp
*
* Abstract:
*
*   Header file for the gif encoder/decoder
*
* Revision History:
*
*   5/13/1999 t-aaronl
*       Created it from OriG's template.
*
\**************************************************************************/

#include "giffile.h"
#include "liblzw/lzwread.h"
#include "liblzw/lzwwrite.h"
#include "gifoverflow.hpp"
#include "gifbuffer.hpp"
#include "gifframecache.hpp"


//TODO: The encoder and decoder should be split into separate classes 
//because they really don't share anything between themselves anyway.
class GpGifCodec : public IImageDecoder,
                   public IImageEncoder,
                   public IImageSink
{
private:

    /*-----------------\
      For en/decoding
    \-----------------*/
    ImageInfo   CachedImageInfo;    // Image info for input image
    BOOL        IsImageInfoCached;  // TRUE if we have already cached it
    BOOL        HasCodecInitialized;//TRUE if Init(En|De)coder has been called
                                    // before the corresponding Terminate.
    BOOL        HasCalledBeginDecode;// State for BeginDecode/EndDecode
    IStream *istream;
    BYTE colorpalettebuffer[offsetof(ColorPalette, Entries) + sizeof(ARGB) * 256];
    ColorPalette *colorpalette;

    /*-----------------\
      For decoding
    \-----------------*/
    IImageSink* decodeSink;
    GifFileHeader gifinfo;
    BOOL bGifinfoFirstFrameDim;
    WORD gifinfoFirstFrameWidth;
    WORD gifinfoFirstFrameHeight;
    BOOL bGifinfoMaxDim;
    WORD gifinfoMaxWidth;
    WORD gifinfoMaxHeight;
    GifColorTable GlobalColorTable;     // GIF global color table
    GifGraphicControlExtension lastgce; // The scope of a GCE is limited to
                                        // The following image chunk.
    GifFrameCache*  GifFrameCachePtr;   // Pointer to the Gif Frame Cache
    DecoderInitFlag decoderflags;
    BOOL blocking;
    BOOL lastgcevalid;                  // TRUE if the variable lastgce has been
                                        //   set.
    BOOL headerread;
    BOOL firstdecode;
    BOOL HasCalledBeginSink;
    BOOL IsAnimatedGif;                 // True if the image is animated GIF
    BOOL IsMultiImageGif;               // True if the image is a multiimage GIF
    WORD FrameDelay;                    // Frame delay, in hundreths of a second
    BOOL HasLoopExtension;
    UINT16 LoopCount;                   // Loop count for an animated gif
    BOOL moreframes;
    UINT GlobalColorTableSize;          // GIF global color table size
    INT TotalNumOfFrame;
    INT currentframe;
    LONGLONG frame0pos;

    // Property related variables

    UINT    PropertyNumOfItems;         // Number of property items in the image
    UINT    PropertyListSize;           // Total bytes for storing values
    BOOL    HasProcessedPropertyItem;   // TRUE if we have processed once
    UINT*   FrameDelayArrayPtr;         // A pointer to an array of frame delay
                                        // value. Each frame has a frame delay
    UINT    FrameDelayBufferSize;       // Current size of the buffer for
                                        // storingframe delay info
    BYTE*   CommentsBufferPtr;          // A pointer to the comments buffer
    UINT    CommentsBufferLength;       // Length of comments chunk

    int TranslateInterlacedLine(IN int line, IN int height, IN int pass);
    int WhichPass(IN int line, IN int height);
    int NumRowsInPass(IN int pass);
    BYTE GetBackgroundColor (void);
    void CopyConvertPalette(IN GifColorTable *gct, 
                            OUT ColorPalette *cp, 
                            IN UINT count);
    STDMETHOD(SetFrameColorTable)(IN BOOL local, 
                                 IN OUT ColorPalette *colorpalette);
    STDMETHOD(GetOutputSpace)(IN int line, 
                              IN GifBuffer &gifbuffer, 
                              IN LZWDecompressor &lzwdecompressor, 
                              IN GifOverflow &gifoverflow, 
                              IN GifImageDescriptor currentImageInfo, 
                              IN GifImageDescriptor clippedCurrentImageInfo, 
                              IN BOOL padborder);
    STDMETHOD(GetCompressedData)(IN LZWDecompressor &lzwdecompressor,
                                 IN BYTE compresseddata[256], 
                                 OUT BOOL &stillmoredata);
    STDMETHOD(ReadGifHeaders)();
    STDMETHOD(ProcessImageChunk)(IN BOOL processdata, 
                                 IN BOOL sinkdata,
                                 ImageInfo dstImageInfo);
    STDMETHOD(ProcessGraphicControlChunk)(IN BOOL processdata);
    STDMETHOD(ProcessCommentChunk)(IN BOOL processdata);
    STDMETHOD(ProcessPlainTextChunk)(IN BOOL processdata);
    STDMETHOD(ProcessApplicationChunk)(IN BOOL processdata);
    STDMETHOD(SeekThroughDataChunk)(IN IStream *istream, IN BYTE headersize);
    STDMETHOD(MarkStream)(IN IStream *istream, OUT LONGLONG &markpos);
    STDMETHOD(ResetStream)(IN IStream *istream, IN LONGLONG &markpos);
    STDMETHOD(SkipToNextFrame)();
    STDMETHOD(ReadFrameProperties)();
    STDMETHOD(MoveToNextFrame)();
    STDMETHOD(DoDecode)(BOOL processdata, BOOL sinkdata, BOOL decodeframe);

    /*-----------------\
      For encoding
    \-----------------*/
    RECT encoderrect;  //Contains the bounds that the encoder is handling.
    RECT scanrect;  //Contains the bounds of the area that is currently being 
                    //pushed into the encoder
    unsigned __int8* compressionbuffer;
    BOOL headerwritten;
    BOOL bTransparentColorIndex;
    UINT transparentColorIndex;
    BOOL from32bpp;
    BOOL gif89;
    BOOL interlaced;
    int currentline;
    STDMETHOD(WritePalette)();
    STDMETHOD(WriteGifHeader)(IN ImageInfo &imageinfo, IN BOOL from32bpp);
    STDMETHOD(WriteGifGraphicControlExtension) (IN BYTE packedFields,
                                                IN WORD delayTime,
                                                IN UINT transparentColorIndex);
    STDMETHOD(WriteGifImageDescriptor)(IN ImageInfo &imageinfo, IN BOOL 
        from32bpp);
    STDMETHOD(AllocateCompressionBuffer)(const BitmapData *bitmapdata);
    STDMETHOD(CompressAndWriteImage)();
    STDMETHOD(WriteImage)();
    int TranslateInterlacedLineBackwards(IN int line, IN int height);

protected:
    LONG comRefCount;  //COM object reference count    

public:

    // Constructor and Destructor
    
    GpGifCodec::GpGifCodec(void);
    GpGifCodec::~GpGifCodec(void);

    // IImageDecoder methods
    
    STDMETHOD(InitDecoder)(IN IStream* stream, IN DecoderInitFlag flags);
    STDMETHOD(TerminateDecoder)();
    STDMETHOD(BeginDecode)(IN IImageSink* imageSink, IN OPTIONAL 
        IPropertySetStorage* newPropSet);
    STDMETHOD(Decode)();
    STDMETHOD(EndDecode)(IN HRESULT statusCode);

    STDMETHOD(GetFrameDimensionsCount)(OUT UINT* count);
    STDMETHOD(GetFrameDimensionsList)(OUT GUID* dimensionIDs,IN OUT UINT count);
    STDMETHOD(GetFrameCount)(IN const GUID* dimensionID, OUT UINT* count);
    STDMETHOD(SelectActiveFrame)(IN const GUID* dimensionID, 
        IN UINT frameIndex);
    STDMETHOD(GetImageInfo)(OUT ImageInfo* imageInfo);
    STDMETHOD(GetThumbnail)(IN OPTIONAL UINT thumbWidth, IN OPTIONAL UINT thumbHeight,
        OUT IImage** thumbImage);
    STDMETHOD(QueryDecoderParam)(IN GUID Guid);
    STDMETHOD(SetDecoderParam)(IN GUID Guid, IN UINT Length, IN PVOID Value);
    STDMETHOD(GetPropertyCount)(OUT UINT* numOfProperty);
    STDMETHOD(GetPropertyIdList)(IN UINT numOfProperty,IN OUT PROPID* list);
    STDMETHOD(GetPropertyItemSize)(IN PROPID propId, OUT UINT* size);    
    STDMETHOD(GetPropertyItem)(IN PROPID propId, IN UINT propSize,
                               IN OUT PropertyItem* buffer);
    STDMETHOD(GetPropertySize)(OUT UINT* totalBufferSize,
                               OUT UINT* numProperties);
    STDMETHOD(GetAllPropertyItems)(IN UINT totalBufferSize,
                                   IN UINT numProperties,
                                   IN OUT PropertyItem* allItems);
    STDMETHOD(RemovePropertyItem)(IN PROPID propId);
    STDMETHOD(SetPropertyItem)(IN PropertyItem item);
    STDMETHOD(GetRawInfo)(IN OUT void** info)
    {
        return E_NOTIMPL;
    }

    // IImageEncoder methods

    STDMETHOD(InitEncoder)(IN IStream* stream);
    STDMETHOD(TerminateEncoder)();
    STDMETHOD(GetEncodeSink)(OUT IImageSink** sink);
    STDMETHOD(SetFrameDimension)(IN const GUID* dimensionID);
    STDMETHOD(GetEncoderParameterListSize)(OUT UINT* size);
    STDMETHOD(GetEncoderParameterList)(IN UINT	  size,
                                       OUT EncoderParameters* Params);
    STDMETHOD(SetEncoderParameters)(IN const EncoderParameters* Param);

    STDMETHOD(NeedTransform(OUT UINT* rotation))
    {
        return E_NOTIMPL;
    }
    
    STDMETHOD(NeedRawProperty)(void *pSRc)
    {
        // GIF can't handle raw property when saving for now

        return E_FAIL;
    }
    
    STDMETHOD(PushRawInfo)(IN OUT void* info)
    {
        return E_NOTIMPL;
    }
    
    STDMETHOD(GetPropertyBuffer)(
        IN     UINT            uiTotalBufferSize,
        IN OUT PropertyItem**  ppBuffer
        )
    {
        return E_NOTIMPL;
    }
    
    STDMETHOD(PushPropertyItems)(
        IN UINT             numOfItems,
        IN UINT             uiTotalBufferSize,
        IN PropertyItem*    item,
        IN BOOL             fICCProfileChanged
        )
    {
        return E_NOTIMPL;
    }

    // IImageSink methods (sink for encoder)

    STDMETHOD(BeginSink)(IN OUT ImageInfo* imageInfo, 
        OUT OPTIONAL RECT* subarea);
    STDMETHOD(EndSink)(IN HRESULT statusCode);
    STDMETHOD(SetPalette)(IN const ColorPalette* palette);
    STDMETHOD(GetPixelDataBuffer)(IN const RECT* rect, 
        IN PixelFormatID pixelFormat, IN BOOL lastPass,
        OUT BitmapData* bitmapData);
    STDMETHOD(ReleasePixelDataBuffer)(IN const BitmapData* bitmapData);
    STDMETHOD(PushRawData)(IN const VOID* buffer, IN UINT bufsize);
    STDMETHOD(PushPixelData)(IN const RECT* rect,
        IN const BitmapData* bitmapData, IN BOOL lastPass);

    // IUnknown methods

    STDMETHOD(QueryInterface)(REFIID riid, VOID** ppv);
    STDMETHOD_(ULONG, AddRef)(VOID);
    STDMETHOD_(ULONG, Release)(VOID);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\gif\gifconst.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   gifconst.cpp
*
* Abstract:
*
*   Constant data related to GIF codec
*
* Revision History:
*
*   06/16/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _GIFCONST_CPP
#define _GIFCONST_CPP

#define GIFVERSION 1

#define GIFSIGCOUNT 2
#define GIFSIGSIZE  6

const BYTE GIFHeaderPattern[GIFSIGCOUNT*GIFSIGSIZE] =
{
    0x47, 0x49, 0x46,  //'GIF'
    0x38, 0x39, 0x61,  //'89a'

    0x47, 0x49, 0x46,  //'GIF'
    0x38, 0x37, 0x61   //'87a'
};

const BYTE GIFHeaderMask[GIFSIGCOUNT*GIFSIGSIZE] =
{
    0xff, 0xff, 0xff,
    0xff, 0xff, 0xff,

    0xff, 0xff, 0xff,
    0xff, 0xff, 0xff
};

const CLSID GifCodecClsID =
{
    0x557cf402,
    0x1a04,
    0x11d3,
    {0x9a, 0x73, 0x00, 0x00, 0xf8, 0x1e, 0xf3, 0x2e}
};

#endif // !_GIFCONST_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\gif\gifencoder.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   gifencoder.cpp
*
* Abstract:
*
*   Implementation of the gif filter encoder.  This file contains the
*   methods for both the encoder (IImageEncoder) and the encoder's sink
*   (IImageSink).
*
* Revision History:
*
*   6/9/1999 t-aaronl
*       Created it from OriG's template
*
\**************************************************************************/

#include "precomp.hpp"
#include "gifcodec.hpp"

/**************************************************************************\
*
* Function Description:
*
*     Initialize the image encoder
*
* Arguments:
*
*     stream - input stream to write encoded data
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::InitEncoder(IN IStream* stream)
{
    //Check to see if this decoder or encoder is already initialized
    if (HasCodecInitialized)
    {
        WARNING(("Encoder already initialized."));
        return E_FAIL;
    }
    HasCodecInitialized = TRUE;

    // Make sure we haven't been initialized already
    if (istream)
    {
        WARNING(("Encoder already initialized."));
        return E_FAIL;
    }

    // Keep a reference on the input stream
    stream->AddRef();
    istream = stream;

    HasCalledBeginDecode = FALSE;
    headerwritten = FALSE;
    bTransparentColorIndex = FALSE;
    transparentColorIndex = 0;
    compressionbuffer = NULL;

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*     Cleans up the image encoder
*
* Arguments:
*
*     none
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::TerminateEncoder()
{
    if (!HasCodecInitialized)
    {
        WARNING(("Encoder not initialized."));
        return E_FAIL;
    }
    HasCodecInitialized = FALSE;
    
    // Release the input stream
    if (istream)
    {
        istream->Release();
        istream = NULL;
    }

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Returns a pointer to the vtable of the encoder sink.  The caller will
*     push the bitmap bits into the encoder sink, which will encode the
*     image.
*
* Arguments:
*
*     sink - upon exit will contain a pointer to the IImageSink vtable
*       of this object
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::GetEncodeSink(
    OUT IImageSink** sink
    )
{
    AddRef();
    *sink = static_cast<IImageSink*>(this);

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Set active frame dimension
*
* Arguments:
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::SetFrameDimension(
    IN const GUID* dimensionID
    )
{
    return E_NOTIMPL;
}

HRESULT
GpGifCodec::GetEncoderParameterListSize(
    OUT UINT* size
    )
{
    return E_NOTIMPL;
}// GetEncoderParameterListSize()

HRESULT
GpGifCodec::GetEncoderParameterList(
    IN  UINT   size,
    OUT EncoderParameters* Params
    )
{
    return E_NOTIMPL;
}// GetEncoderParameterList()

HRESULT
GpGifCodec::SetEncoderParameters(
    IN const EncoderParameters* Param
    )
{
    return E_NOTIMPL;
}// SetEncoderParameters()

/**************************************************************************\
*
* Function Description:
*
*     Caches the image info structure and initializes the sink state
*
* Arguments:
*
*     imageInfo - information about the image and format negotiations
*     subarea - the area in the image to deliver into the sink, in our
*       case the whole image.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP 
GpGifCodec::BeginSink(
    IN OUT ImageInfo* imageInfo,
    OUT OPTIONAL RECT* subarea
    )
{
    HRESULT hresult;
    
    if ( HasCalledBeginDecode)
    {
        WARNING(("BeginSink called twice without a EndSink between."));
        return E_FAIL;
    }
    HasCalledBeginDecode = TRUE;

    //TODO: actually find out if the image is interlaced from the metadata instead of just setting it to false
    interlaced = FALSE;

    if (!subarea) 
    {
        // Deliver the whole image to the encoder
        encoderrect.left = 0;
        encoderrect.top = 0;
        encoderrect.right = imageInfo->Width;
        encoderrect.bottom = imageInfo->Height;
    }
    else
    {
        // !!! This else code does the same thing as the if part.
        // !!! Need to investigate what the GIF code can handle here.
        subarea->left = subarea->top = 0;
        subarea->right  = imageInfo->Width;
        subarea->bottom = imageInfo->Height;
        encoderrect = *subarea;
    }

    //The data is pushed in top-down order so the currentline is the next line 
    //of data that we expect.
    currentline = encoderrect.top;

    //Tell the source just what we can do

    if (imageInfo->PixelFormat != PIXFMT_8BPP_INDEXED)
    {
        imageInfo->PixelFormat = PIXFMT_32BPP_ARGB;
        from32bpp = TRUE;
    }
    else
    {
        from32bpp = FALSE;
    }

    //Require TOPDOWN and FULLWIDTH
    imageInfo->Flags = imageInfo->Flags | SINKFLAG_TOPDOWN | SINKFLAG_FULLWIDTH;

    //Disallow SCALABLE, PARTIALLY_SCALABLE, MULTIPASS and COMPOSITE
    imageInfo->Flags = imageInfo->Flags & ~SINKFLAG_SCALABLE & ~SINKFLAG_PARTIALLY_SCALABLE & ~SINKFLAG_MULTIPASS & ~SINKFLAG_COMPOSITE;

    CachedImageInfo = *imageInfo;

    colorpalette->Count = 0;


    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*     Clean up the sink state including writing whatever we have of an 
*     incomplete image to the output stream.
*
* Arguments:
*
*     statusCode - the reason why the sink is terminating
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP 
GpGifCodec::EndSink(
    IN HRESULT statusCode)
{
    HRESULT hresult;
 
    if (!HasCalledBeginDecode)
    {
        WARNING(("EndDecode called before call to BeginDecode\n"));
        return E_FAIL;
    }

    //Assuming that we have some data to write to the disk, write it.
    if (compressionbuffer)
    {
        int height = encoderrect.bottom - encoderrect.top;
        int width = encoderrect.right - encoderrect.left;

        //Fill the end of an incomplete image with 0's.
        if (from32bpp)
            width *= 4;
        while (currentline < height)
        {

            memset(compressionbuffer + (currentline * width), gifinfo.backgroundcolor, (height - currentline) * width);

            currentline++;
        }

        hresult = WriteImage();
        if (FAILED(hresult))
            return hresult;
    }
    
    //TODO: move writing the trailer to after all frames are written
    BYTE c = 0x3B;  //Gif trailer chunk marker
    hresult = istream->Write(&c, 1, NULL);
    if (FAILED(hresult))
        return hresult;

    //Get ready for the next encoding.
    HasCalledBeginDecode = FALSE;
    headerwritten = FALSE;

    GpFree(compressionbuffer);
    compressionbuffer = NULL;

    return statusCode;
}

/**************************************************************************\
*
* Function Description:
*
*     Sets the bitmap palette.  The first palette entry with an alpha
*     value == 0 is set to be the transparent color index.
*
* Arguments:
*
*     palette - The palette to set in the sink
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP 
GpGifCodec::SetPalette(IN const ColorPalette* palette)
{
    DWORD i;
    
    //TODO: palettes larger than 256 have to be downsampled or halftoned 
    //because gif only supports maximum 256 color palettes.  The negotiation 
    //process should probably include the palette size.

    //Gifs only support a palette with a power of 2 for the number of colors.
    DWORD numcolors = Gppow2 (Gplog2(palette->Count-1)+1);

    //Copy the palette passed to us into our own data structure.
    for (i=0;i<palette->Count;i++)
    {
        colorpalette->Entries[i] = palette->Entries[i];
    }

    //Fill the unused entries with 0's.
    for (i=palette->Count;i<numcolors;i++)
    {
        colorpalette->Entries[i] = 0;
    }
    
    colorpalette->Count = numcolors;
    colorpalette->Flags = palette->Flags;

    // Set the first color palette entry with alpha value == 0 to
    // be the transparent index (so that when we save to GIF format,
    // that transparency information is not lost).
    for (i = 0; i < palette->Count; i++)
    {
        if ((palette->Entries[i] & ALPHA_MASK) == 0x00)
        {
            transparentColorIndex = i;
            bTransparentColorIndex = TRUE;
            break;
        }
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*     Allocates a block o' memory to hold uncompressed data that is in the 
*     process of being turned into compressed data
*
* Arguments:
*
*     bitmapData - information about pixel data buffer
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::AllocateCompressionBuffer(const BitmapData *bitmapdata)
{
    if (!compressionbuffer) 
    {
        int width = encoderrect.right - encoderrect.left;
        int height = encoderrect.bottom - encoderrect.top;
        if (from32bpp)
        {
            compressionbuffer = (unsigned __int8*)GpMalloc(width * height * 4);
        }
        else
        {
            compressionbuffer = (unsigned __int8*)GpMalloc(width * height);
        }
        if (!compressionbuffer)
        {
            WARNING(("GpGifCodec::AllocateCompressionBuffer - Out of memory."));
            return E_OUTOFMEMORY;
        }
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*     Gives a buffer to the sink where data is to be deposited    
*
* Arguments:
*
*     rect - Specifies the interested area of the bitmap
*     pixelFormat - Specifies the desired pixel format
*     lastPass - Whether this the last pass over the specified area
*     bitmapData - Returns information about pixel data buffer
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::GetPixelDataBuffer(
    IN const RECT* rect, 
    IN PixelFormatID pixelFormat,
    IN BOOL lastPass,
    OUT BitmapData* bitmapdata
    )
{
    HRESULT hresult;

    if (!from32bpp && colorpalette->Count == 0)
    {
        WARNING(("SetPalette was not called before requesting data in 8bpp indexed mode."));
        return E_FAIL;
    }

    if ((rect->left < 0) || (rect->top < 0)) 
    {
        WARNING(("GpGifCodec::GetPixelDataBuffer -- requested area lies out of (0,0),(width,height)."));
        return E_INVALIDARG;
    }

    if (rect->top != currentline)
    {
        WARNING(("GpGifCodec::PushPixelDataBuffer -- lines out of order."));
        return E_INVALIDARG;
    }

    if ((pixelFormat != PIXFMT_32BPP_ARGB) &&
        (pixelFormat != PIXFMT_8BPP_INDEXED))
    {
        WARNING(("GpGifCodec::GetPixelDataBuffer -- bad pixel format"));
        return E_INVALIDARG;
    }

    if (!lastPass)
    {
        WARNING(("GpGifCodec::GetPixelDataBuffer -- must receive last pass pixels"));
        return E_INVALIDARG;
    }

    bitmapdata->Width = CachedImageInfo.Width;
    bitmapdata->Height = rect->bottom - rect->top;
    bitmapdata->Stride = from32bpp ? CachedImageInfo.Width * 4 : CachedImageInfo.Width;
    bitmapdata->PixelFormat = CachedImageInfo.PixelFormat;
    bitmapdata->Reserved = 0;

    hresult = AllocateCompressionBuffer(bitmapdata);
    if (FAILED(hresult))
        return hresult;

    //Give a pointer to the place in the compression buffer that the user asks 
    //for.
    bitmapdata->Scan0 = compressionbuffer + rect->top * bitmapdata->Stride;

    scanrect = *rect;
    
    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*     Write out the data from the sink's buffer into the stream
*
* Arguments:
*
*     bitmapData - Buffer filled by previous GetPixelDataBuffer call
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::ReleasePixelDataBuffer(IN const BitmapData* bitmapData)
{
    HRESULT hresult;

    hresult = PushPixelData(&scanrect, bitmapData, TRUE);
    if (FAILED(hresult))
        return hresult;
    
    return S_OK;
}
    

/**************************************************************************\
*
* Function Description:
*
*     Push data into stream (buffer supplied by caller)
*
* Arguments:
*
*     rect - Specifies the affected area of the bitmap
*     bitmapData - Info about the pixel data being pushed
*     lastPass - Whether this is the last pass over the specified area
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::PushPixelData(IN const RECT *rect, IN const BitmapData *bitmapdata, IN BOOL lastPass)
{
    HRESULT hresult;

    if (!from32bpp && colorpalette->Count == 0)
    {
        WARNING(("GpGifCodec::PushPixelDataBuffer -- SetPalette was not called before sending data in 8bpp indexed mode."));
        return E_FAIL;
    }

    if ((rect->left < 0) || (rect->top < 0))
    {
        WARNING(("GpGifCodec::PushPixelDataBuffer -- requested area lies out of (0,0),(width,height)."));
        return E_INVALIDARG;
    }

    if (rect->top != currentline)
    {
        WARNING(("GpGifCodec::PushPixelDataBuffer -- lines out of order."));
        return E_INVALIDARG;
    }

    if ((bitmapdata->PixelFormat != PIXFMT_32BPP_ARGB) &&
        (bitmapdata->PixelFormat != PIXFMT_8BPP_INDEXED))
    {
        WARNING(("GpGifCodec::PushPixelDataBuffer -- bad pixel format."));
        return E_INVALIDARG;
    }

    if (!lastPass)
    {
        WARNING(("GpGifCodec::PushPixelDataBuffer -- must receive last pass pixels."));
        return E_INVALIDARG;
    }

    hresult = AllocateCompressionBuffer(bitmapdata);
    if (FAILED(hresult))
        return hresult;

    if (!compressionbuffer)
        return E_OUTOFMEMORY;

    int line;
    for (line=0;line<rect->bottom-rect->top;line++)
    {
        int modline = currentline + line;

        //TODO:  Interlacing encoding does not work correctly.
        if (interlaced)
        {
            modline = TranslateInterlacedLineBackwards(currentline, encoderrect.bottom - encoderrect.top);
        }
        
        //Copy the data from the current scanline buffer to the correct location in the compression buffer.
        if (from32bpp)
        {
            memcpy(compressionbuffer + modline * bitmapdata->Width * 4, (unsigned __int8*)bitmapdata->Scan0 + line * bitmapdata->Stride, bitmapdata->Width * 4);
        }
        else
        {
            memcpy(compressionbuffer + modline * bitmapdata->Width, (unsigned __int8*)bitmapdata->Scan0 + line * bitmapdata->Stride, bitmapdata->Width);
        }
    }

    currentline += line;

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*     Pushes raw compressed data into the Gif stream.  Not implemented
*     because this filter doesn't understand raw compressed data.
*
* Arguments:
*
*     buffer - Pointer to image data buffer
*     bufsize - Size of the data buffer
*    
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::PushRawData(IN const VOID* buffer, IN UINT bufsize)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\gif\gifcodec.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   gifcodec.cpp
*
* Abstract:
*
*   Shared methods for the gif codec
*
* Revision History:
*
*   5/13/1999 t-aaronl
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "gifcodec.hpp"

// Create an instance of gif codec object

HRESULT CreateCodecInstance(REFIID iid, VOID** codec)
{
    HRESULT hr;
    GpGifCodec *GifCodec = new GpGifCodec();

    if (GifCodec != NULL)
    {
        hr = GifCodec->QueryInterface(iid, codec);
        GifCodec->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *codec = NULL;
    }

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*     Constructor
*
* Return Value:
*
*   none
*
\**************************************************************************/

GpGifCodec::GpGifCodec(
    void
    )
{
    comRefCount = 1;
    istream = NULL;
    decodeSink = NULL;
    HasCodecInitialized = FALSE;
    HasCalledBeginDecode = FALSE;
    GifFrameCachePtr = NULL;
    IsAnimatedGif = FALSE;
    IsMultiImageGif = FALSE;
    FrameDelay = 0;
    HasLoopExtension = FALSE;
    TotalNumOfFrame = -1;
    moreframes = TRUE;
    currentframe = -1;
    firstdecode = TRUE;
    colorpalette = (ColorPalette*)&colorpalettebuffer;

    IncrementComComponentCount();
}

/**************************************************************************\
*
* Function Description:
*
*     Destructor
*
* Return Value:
*
*   none
*
\**************************************************************************/

GpGifCodec::~GpGifCodec(
    void
    )
{
    // The destructor should never be called before Terminate is called, but
    // if it does we should release our reference on the stream anyway to avoid
    // a memory leak.

    if(istream)
    {
        WARNING(("GpGifCodec::~GpGifCodec -- need to call TerminateDecoder first"));
        istream->Release();
        istream = NULL;
    }

    DecrementComComponentCount();
}

/**************************************************************************\
*
* Function Description:
*
*     QueryInterface
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::QueryInterface(
    REFIID riid,
    VOID** ppv
    )
{
    if (riid == IID_IImageDecoder)
    {
        *ppv = static_cast<IImageDecoder*>(this);
    }
    else if (riid == IID_IImageEncoder)
    {    
        *ppv = static_cast<IImageEncoder*>(this);
    }
    else if (riid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(static_cast<IImageDecoder*>(this));
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     AddRef
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP_(ULONG)
GpGifCodec::AddRef(
    VOID)
{
    return InterlockedIncrement(&comRefCount);
}

/**************************************************************************\
*
* Function Description:
*
*     Release
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP_(ULONG)
GpGifCodec::Release(
    VOID)
{
    ULONG count = InterlockedDecrement(&comRefCount);

    if (count == 0)
    {
        delete this;
    }

    return count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\gif\gifdecoder.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   gifdecoder.cpp
*
* Abstract:
*
*   Implementation of the gif decoder
*
* Revision History:
*
*   6/7/1999 t-aaronl
*       Created it from OriG's template
*
\**************************************************************************/

#include "precomp.hpp"
#include "gifcodec.hpp"

#define FRAMEBLOCKSIZE 100

/**************************************************************************\
*
* Function Description:
*
*     Initialize the image decoder
*
* Arguments:
*
*     stream -- The stream containing the bitmap data
*     flags -- Flags indicating the decoder's behavior (eg. blocking vs. 
*         non-blocking)
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::InitDecoder(
    IN IStream* _istream,
    IN DecoderInitFlag flags
    )
{
    // Check to see if this decoder is already initialized
    // Note: HasCodecInitialized is set to FALSE in constructor
    
    if ( HasCodecInitialized == TRUE )
    {
        WARNING(("GpGifCodec::InitDecoder---Decoder is already initialized"));
        return E_FAIL;
    }

    HasCodecInitialized = TRUE;

    // Make sure we haven't been initialized already
    
    if ( istream )
    {
        WARNING(("GpGifCodec::InitDecoder---Input stream pointer is NULL"));
        return E_INVALIDARG;
    }

    // Keep a reference on the input stream
    
    _istream->AddRef();
    istream = _istream;

    decoderflags = flags;
    HasCalledBeginSink = FALSE;

    IsImageInfoCached = FALSE;

    //flag to ensure that we don't read the image header more than once
    
    headerread = FALSE;
    firstdecode = TRUE;
    gif89 = FALSE;

    lastgcevalid = FALSE;               // Hasn't found any GCE chunk yet
    GpMemset(&lastgce, 0, sizeof(GifGraphicControlExtension));

    bGifinfoFirstFrameDim = FALSE;
    gifinfoFirstFrameWidth = 0;
    gifinfoFirstFrameHeight = 0;
    bGifinfoMaxDim = FALSE;
    gifinfoMaxWidth = 0;
    gifinfoMaxHeight = 0;
    
    // Note: Loop count will be set in ProcessApplicationChunk() if there is one

    LoopCount = 1;

    // Property related stuff

    PropertyNumOfItems = 0;             // Hasn't found any property items yet
    PropertyListSize = 0;
    HasProcessedPropertyItem = FALSE;
    FrameDelayBufferSize = FRAMEBLOCKSIZE;
    FrameDelayArrayPtr = (UINT*)GpMalloc(FrameDelayBufferSize * sizeof(UINT));
    if ( FrameDelayArrayPtr == NULL )
    {
        WARNING(("GpGifCodec::InitDecoder---Out of memory"));
        return E_OUTOFMEMORY;
    }

    CommentsBufferPtr = NULL;
    CommentsBufferLength = 0;

    GpMemset(&gifinfo, 0, sizeof(gifinfo));
    frame0pos = 0;
    GlobalColorTableSize = 0;

    blocking = !(decoderflags & DECODERINIT_NOBLOCK);

    return S_OK;
}// InitDecoder()

/**************************************************************************\
*
* Function Description:
*
*     Cleans up the image decoder
*
* Arguments:
*
*     none
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

// Clean up the image decoder object

STDMETHODIMP 
GpGifCodec::TerminateDecoder()
{
    if ( HasCodecInitialized == FALSE )
    {
        WARNING(("GpGifCodec::TerminateDecoder--The codec is not started yet"));
        return E_FAIL;
    }

    HasCodecInitialized = FALSE;
    
    // Release the input stream
    
    if( istream )
    {
        istream->Release();
        istream = NULL;
    }

    delete GifFrameCachePtr;

    if ( FrameDelayArrayPtr != NULL )
    {
        GpFree(FrameDelayArrayPtr);
        FrameDelayArrayPtr = NULL;
    }

    if ( CommentsBufferPtr != NULL )
    {
        GpFree(CommentsBufferPtr);
        CommentsBufferPtr = NULL;
    }

    return S_OK;
}// TerminateDecoder()

STDMETHODIMP 
GpGifCodec::QueryDecoderParam(
    IN GUID     Guid
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP 
GpGifCodec::SetDecoderParam(
    IN GUID     Guid,
    IN UINT     Length,
    IN PVOID    Value
    )
{
    return E_NOTIMPL;
}

/**************************************************************************\
*
* Function Description:
*
*   Get the count of property items in the image
*
* Arguments:
*
*   [OUT]numOfProperty - The number of property items in the image
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   03/23/2000 minliu
*       Created it.
*
\**************************************************************************/

STDMETHODIMP 
GpGifCodec::GetPropertyCount(
    OUT UINT* numOfProperty
    )
{
    if ( numOfProperty == NULL )
    {
        WARNING(("GpGifCodec::GetPropertyCount--numOfProperty is NULL"));
        return E_INVALIDARG;
    }

    if ( TotalNumOfFrame == -1 )
    {
        UINT uiDummy;
        HRESULT hResult = GetFrameCount(&FRAMEDIM_TIME, &uiDummy);
        
        if ( FAILED(hResult) )
        {
            return hResult;
        }
    }

    *numOfProperty = PropertyNumOfItems;

    return S_OK;
}// GetPropertyCount()

/**************************************************************************\
*
* Function Description:
*
*   Get a list of property IDs for all the property items in the image
*
* Arguments:
*
*   [IN]  numOfProperty - The number of property items in the image
*   [OUT] list----------- A memory buffer the caller provided for storing the
*                         ID list
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   03/23/2000 minliu
*       Created it.
*
\**************************************************************************/

STDMETHODIMP 
GpGifCodec::GetPropertyIdList(
    IN UINT numOfProperty,
    IN OUT PROPID* list
    )
{
    if ( TotalNumOfFrame == -1 )
    {
        UINT uiDummy;
        HRESULT hResult = GetFrameCount(&FRAMEDIM_TIME, &uiDummy);
        
        if ( FAILED(hResult) )
        {
            return hResult;
        }
    }

    // After the property item list is built, "PropertyNumOfItems" will be set
    // to the correct number of property items in the image
    // Here we need to validate if the caller passes us the correct number of
    // IDs which we returned through GetPropertyItemCount(). Also, this is also
    // a validation for memory allocation because the caller allocates memory
    // based on the number of items we returned to it

    if ( (numOfProperty != PropertyNumOfItems) || (list == NULL) )
    {
        WARNING(("GpGifCodec::GetPropertyList--input wrong"));
        return E_INVALIDARG;
    }

    if ( PropertyNumOfItems == 0 )
    {
        // This is OK since there is no property in this image

        return S_OK;
    }
    
    // We have "framedelay", "comments" and "loop count" property items to
    // return for now

    list[0] = TAG_FRAMEDELAY;

    UINT uiIndex = 1;

    if ( CommentsBufferLength != 0 )
    {
        list[uiIndex++] = EXIF_TAG_USER_COMMENT;
    }

    if ( HasLoopExtension == TRUE )
    {
        list[uiIndex++] = TAG_LOOPCOUNT;
    }

    return S_OK;
}// GetPropertyIdList()

/**************************************************************************\
*
* Function Description:
*
*   Get the count of property items in the image
*
* Arguments:
*
*   [OUT]numOfProperty - The number of property items in the image
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   03/23/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpGifCodec::GetPropertyItemSize(
    IN PROPID propId,
    OUT UINT* size
    )
{
    HRESULT hResult = S_OK;

    if ( size == NULL )
    {
        WARNING(("GpGifDecoder::GetPropertyItemSize--size is NULL"));
        return E_INVALIDARG;
    }

    if ( TotalNumOfFrame == -1 )
    {
        UINT uiDummy;
        hResult = GetFrameCount(&FRAMEDIM_TIME, &uiDummy);
        
        if ( FAILED(hResult) )
        {
            return hResult;
        }
    }

    if ( propId == TAG_FRAMEDELAY )
    {
        // The size of an property item should be "The size of the item
        // structure plus the size for the value.
        // Here the size of the value is the total number of frame times UINT

        *size = TotalNumOfFrame * sizeof(UINT) + sizeof(PropertyItem);
    }
    else if ( propId == EXIF_TAG_USER_COMMENT )
    {
        // Note: we need extra 1 byte to put an NULL terminator at the end when
        // we return the "comments" section back to caller

        *size = CommentsBufferLength + sizeof(PropertyItem) + 1;
    }
    else if ( propId == TAG_LOOPCOUNT )
    {
        // A loop count takes a UINT16 to return to caller

        *size = sizeof(UINT16) + sizeof(PropertyItem);
    }
    else
    {
        // Item not found

        hResult = IMGERR_PROPERTYNOTFOUND;
    }

    return hResult;
}// GetPropertyItemSize()

/**************************************************************************\
*
* Function Description:
*
*   Get a specific property item, specified by the prop ID.
*
* Arguments:
*
*   [IN]propId -- The ID of the property item caller is interested
*   [IN]propSize- Size of the property item. The caller has allocated these
*                 "bytes of memory" for storing the result
*   [OUT]pBuffer- A memory buffer for storing this property item
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   03/23/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpGifCodec::GetPropertyItem(
    IN PROPID               propId,
    IN UINT                 propSize,
    IN OUT PropertyItem*    pItemBuffer
    )
{
    HRESULT hResult = S_OK;

    if ( pItemBuffer == NULL )
    {
        WARNING(("GpGifCodec::GetPropertyItem--Buffer is NULL"));
        return E_INVALIDARG;
    }

    if ( TotalNumOfFrame == -1 )
    {
        UINT uiDummy;
        hResult = GetFrameCount(&FRAMEDIM_TIME, &uiDummy);
        
        if ( FAILED(hResult) )
        {
            return hResult;
        }
    }

    BYTE*   pOffset = (BYTE*)pItemBuffer + sizeof(PropertyItem);

    if ( propId == TAG_FRAMEDELAY )
    {
        UINT iTempLength = TotalNumOfFrame * sizeof(UINT);

        if ( propSize != (iTempLength  + sizeof(PropertyItem)) )
        {
            WARNING(("GpGifCodec::GetPropertyItem--wrong size"));
            return E_INVALIDARG;
        }

        // Assign the item

        pItemBuffer->id = TAG_FRAMEDELAY;
        pItemBuffer->length = TotalNumOfFrame * sizeof(UINT);
        pItemBuffer->type = TAG_TYPE_LONG;
        pItemBuffer->value = pOffset;

        GpMemcpy(pOffset, FrameDelayArrayPtr, iTempLength);
    }
    else if ( propId == EXIF_TAG_USER_COMMENT )
    {
        if ( propSize != (CommentsBufferLength + sizeof(PropertyItem) + 1) )
        {
            WARNING(("GpGifCodec::GetPropertyItem--wrong size"));
            return E_INVALIDARG;
        }
        
        // Assign the item

        pItemBuffer->id = EXIF_TAG_USER_COMMENT;
        pItemBuffer->length = CommentsBufferLength + 1;
        pItemBuffer->type = TAG_TYPE_ASCII;
        pItemBuffer->value = pOffset;

        GpMemcpy(pOffset, CommentsBufferPtr, CommentsBufferLength);
        *(pOffset + CommentsBufferLength) = '\0';
    }
    else if ( propId == TAG_LOOPCOUNT )
    {
        UINT uiSize = sizeof(UINT16);

        if ( propSize != (uiSize + sizeof(PropertyItem)) )
        {
            WARNING(("GpGifCodec::GetPropertyItem--wrong size"));
            return E_INVALIDARG;
        }
        
        // Assign the item

        pItemBuffer->id = TAG_LOOPCOUNT;
        pItemBuffer->length = uiSize;
        pItemBuffer->type = TAG_TYPE_SHORT;
        pItemBuffer->value = pOffset;

        GpMemcpy(pOffset, &LoopCount, uiSize);
    }
    else
    {
        // ID not found

        hResult = IMGERR_PROPERTYNOTFOUND;
    }

    return hResult;
}// GetPropertyItem()

/**************************************************************************\
*
* Function Description:
*
*   Get the size of ALL property items in the image
*
* Arguments:
*
*   [OUT]totalBufferSize-- Total buffer size needed, in bytes, for storing all
*                          property items in the image
*   [OUT]numOfProperty --- The number of property items in the image
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   03/23/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpGifCodec::GetPropertySize(
    OUT UINT* totalBufferSize,
    OUT UINT* numProperties
    )
{
    if ( (totalBufferSize == NULL) || (numProperties == NULL) )
    {
        WARNING(("GpGifCodec::GetPropertySize--invalid inputs"));
        return E_INVALIDARG;
    }

    if ( TotalNumOfFrame == -1 )
    {
        UINT uiDummy;
        HRESULT hResult = GetFrameCount(&FRAMEDIM_TIME, &uiDummy);
        
        if ( FAILED(hResult) )
        {
            return hResult;
        }
    }

    *numProperties = PropertyNumOfItems;

    // Total buffer size should be list value size plus the total header size

    *totalBufferSize = PropertyListSize
                     + PropertyNumOfItems * sizeof(PropertyItem);

    return S_OK;
}// GetPropertySize()

/**************************************************************************\
*
* Function Description:
*
*   Get ALL property items in the image
*
* Arguments:
*
*   [IN]totalBufferSize-- Total buffer size, in bytes, the caller has allocated
*                         memory for storing all property items in the image
*   [IN]numOfProperty --- The number of property items in the image
*   [OUT]allItems-------- A memory buffer caller has allocated for storing all
*                         the property items
*
*   Note: "allItems" is actually an array of PropertyItem
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   03/23/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpGifCodec::GetAllPropertyItems(
    IN UINT totalBufferSize,
    IN UINT numProperties,
    IN OUT PropertyItem* allItems
    )
{
    // Figure out total property header size first

    UINT    uiHeaderSize = PropertyNumOfItems * sizeof(PropertyItem);

    if ( (totalBufferSize != (uiHeaderSize + PropertyListSize))
       ||(numProperties != PropertyNumOfItems)
       ||(allItems == NULL) )
    {
        WARNING(("GpGifDecoder::GetPropertyItems--invalid inputs"));
        return E_INVALIDARG;
    }

    if ( TotalNumOfFrame == -1 )
    {
        UINT uiDummy;
        HRESULT hResult = GetFrameCount(&FRAMEDIM_TIME, &uiDummy);
        
        if ( FAILED(hResult) )
        {
            return hResult;
        }
    }
    
    // Assign the frame delay property item first because it always has one

    PropertyItem*   pTempDst = allItems;
    UINT    uiTemp = TotalNumOfFrame * sizeof(UINT);

    BYTE*   pOffset = (BYTE*)pTempDst
                    + PropertyNumOfItems * sizeof(PropertyItem);

    pTempDst->id = TAG_FRAMEDELAY;
    pTempDst->length = uiTemp;
    pTempDst->type = TAG_TYPE_LONG;
    pTempDst->value = pOffset;

    GpMemcpy(pOffset, FrameDelayArrayPtr, pTempDst->length);

    pOffset += uiTemp;

    if ( CommentsBufferLength != 0 )
    {
        pTempDst++;

        pTempDst->id = EXIF_TAG_USER_COMMENT;
        pTempDst->length = CommentsBufferLength;
        pTempDst->type = TAG_TYPE_ASCII;
        pTempDst->value = pOffset;

        GpMemcpy(pOffset, CommentsBufferPtr, CommentsBufferLength);

        // Note: we should add a NULL terminator at the end to be safe since
        // we tell the caller this is an ASCII type. Some GIF images might not
        // have NULL terminator in their comments section
        // We can do this because set this extra byte in the GetPropertySize()

        *(pOffset + CommentsBufferLength) = '\0';
        
        pOffset += (CommentsBufferLength + 1);
    }

    if ( HasLoopExtension == TRUE )
    {
        pTempDst++;

        pTempDst->id = TAG_LOOPCOUNT;
        pTempDst->length = sizeof(UINT16);
        pTempDst->type = TAG_TYPE_SHORT;
        pTempDst->value = pOffset;

        GpMemcpy(pOffset, &LoopCount, sizeof(UINT16));
    }

    return S_OK;
}// GetAllPropertyItems()

HRESULT
GpGifCodec::RemovePropertyItem(
    IN PROPID   propId
    )
{
    return IMGERR_PROPERTYNOTFOUND;
}// RemovePropertyItem()

HRESULT
GpGifCodec::SetPropertyItem(
    IN PropertyItem item
    )
{
    return IMGERR_PROPERTYNOTSUPPORTED;
}// SetPropertyItem()

/**************************************************************************\
*
* Function Description:
*
*     Initiates the decode of the current frame
*
* Arguments:
*
*     decodeSink --  The sink that will support the decode operation
*     newPropSet - New image property sets, if any
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::BeginDecode(
    IN IImageSink* imageSink,
    IN OPTIONAL IPropertySetStorage* newPropSet
    )
{
    if ( HasCalledBeginDecode == TRUE )
    {
        WARNING(("Gif::BeginDecode---BeginDecode() already been called"));
        return E_FAIL;
    }

    HasCalledBeginDecode = TRUE;

    imageSink->AddRef();
    decodeSink = imageSink;

    HasCalledBeginSink = FALSE;

    // If this is single page gif and we have done, at least, one decoding,
    // then we should seek back to the beginning of the stream so that the
    // caller can re-decode the image again. Note: multi-image gif is a single
    // page image, in this sense. For animated gif, we can't seek back since the
    // caller might want to decode the next frame.

    if ( !firstdecode && (IsAnimatedGif == FALSE) )
    {
        LARGE_INTEGER zero = {0, 0};
        HRESULT hResult = istream->Seek(zero, STREAM_SEEK_SET, NULL);
        if ( FAILED(hResult) )
        {
            WARNING(("GpGifCodec::BeginDecode---Stream seek() fail"));
            return hResult;
        }

        headerread = FALSE;
        gif89 = FALSE;
    }

    firstdecode = FALSE;

    colorpalette->Count = 0;
    
    return S_OK;
}// BeginDecode()

/**************************************************************************\
*
* Function Description:
*
*     Ends the decode of the current frame
*
* Arguments:
*
*     statusCode -- status of decode operation

* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::EndDecode(
    IN HRESULT statusCode
    )
{
    if ( HasCalledBeginDecode == FALSE )
    {
        WARNING(("GifCodec::EndDecode-Call this func before call BeginDecode"));
        return E_FAIL;
    }

    HasCalledBeginDecode = FALSE;
    
    HRESULT hResult = decodeSink->EndSink(statusCode);

    decodeSink->Release();
    decodeSink = NULL;

    return hResult;
}// EndDecode()

/**************************************************************************\
*
* Function Description:
*
*     Reads information on the gif file from the stream
*
* Arguments:
*
*     none
*
* Return Value:
*
*     Status code from the stream
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::ReadGifHeaders()
{
    if ( headerread )
    {
        return S_OK;
    }

    HRESULT hResult = ReadFromStream(istream, &gifinfo, sizeof(GifFileHeader),
                                     blocking);
    if ( FAILED(hResult) )
    {
        WARNING(("GpGifCodec::ReadGifHeaders---ReadFromStream failed"));
        return hResult;
    }

    CachedImageInfo.RawDataFormat = IMGFMT_GIF;

    // Note: Pixelformat and width, height might be overwritten later if we
    // figure out this is a multi-frame image
    //
    // Note: we return LogicScreenWidth and height as the width and height for
    // current image(Actually for all the frames in the same GIF images). The
    // reason is that the area of the logic screen is the area we fill up the
    // bits for the GIF image. That is, when a caller asks for a frame, we give
    // it the current logic screen area which might different than the current
    // frame.

    CachedImageInfo.PixelFormat   = PIXFMT_8BPP_INDEXED;
    CachedImageInfo.Width         = gifinfo.LogicScreenWidth;
    CachedImageInfo.Height        = gifinfo.LogicScreenHeight;
    
    double pixelaspect = gifinfo.pixelaspect ? (double)(gifinfo.pixelaspect + 
                                                15) / 64 : 1;

    // Start: [Bug 103296]
    // Change this code to use Globals::DesktopDpiX and Globals::DesktopDpiY

    HDC hdc;
    hdc = ::GetDC(NULL);
    if ( (hdc == NULL)
      || ((CachedImageInfo.Xdpi = (REAL)::GetDeviceCaps(hdc, LOGPIXELSX)) <= 0)
      || ((CachedImageInfo.Ydpi = (REAL)::GetDeviceCaps(hdc, LOGPIXELSY)) <= 0))
    {
        WARNING(("GetDC or GetDeviceCaps failed"));
        CachedImageInfo.Xdpi = DEFAULT_RESOLUTION;
        CachedImageInfo.Ydpi = DEFAULT_RESOLUTION;
    }
    ::ReleaseDC(NULL, hdc);
    // End: [Bug 103296]

    // By default, we assume the image has no alpha info in it. Later on, we
    // will add this flag if this image has a GCE

    CachedImageInfo.Xdpi    /= pixelaspect;
    CachedImageInfo.Flags   = SINKFLAG_FULLWIDTH
                            | SINKFLAG_MULTIPASS
                            | SINKFLAG_COMPOSITE
                            | IMGFLAG_COLORSPACE_RGB
                            | IMGFLAG_HASREALPIXELSIZE;
    CachedImageInfo.TileWidth  = gifinfo.LogicScreenWidth;
    CachedImageInfo.TileHeight = 1;

    // Check the signature to make sure that this is a genuine GIF file.

    if ( GpMemcmp(gifinfo.signature, "GIF87a", 6)
      &&(GpMemcmp(gifinfo.signature, "GIF89a", 6)) )
    {
        WARNING(("GpGifCodec::Decode - Gif signature does not match."));
        return E_FAIL;
    }
    
    if ( gifinfo.globalcolortableflag )  //has global color table
    {
        GlobalColorTableSize = 1 << ((gifinfo.globalcolortablesize) + 1);
        hResult = ReadFromStream(istream, &GlobalColorTable,
                                 GlobalColorTableSize * sizeof(GifPaletteEntry),
                                 blocking);
        if ( FAILED(hResult) )
        {
            WARNING(("GpGifCodec::ReadGifHeaders---ReadFromStream 2 failed"));
            return hResult;
        }

        CopyConvertPalette(&GlobalColorTable, colorpalette,
                           GlobalColorTableSize);
    }

    MarkStream(istream, frame0pos);

    headerread = TRUE;
    currentframe = -1;

    return hResult;
}// ReadGifHeaders()

/**************************************************************************\
*
* Function Description:
*
*     Gets information on the height, width, etc of the image
*
* Arguments:
*
*     imageInfo --  ImageInfo struct that is filled with image specs
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::GetImageInfo(
    OUT ImageInfo*  imageInfo
    )
{
    if ( imageInfo == NULL )
    {
        WARNING(("GpGifCodec::GetImageInfo---Invalid input"));
        return E_INVALIDARG;
    }

    HRESULT hResult = S_OK;
    UINT frame_count;   // used for return value of GetFrameCount()

    if ( IsImageInfoCached == TRUE )
    {
        GpMemcpy(imageInfo, &CachedImageInfo, sizeof(ImageInfo));
        return S_OK;
    }

    // Calculate TotalNumOfFrame if we haven't done it.
    // Note: TotalNumOfFrame = -1 means we haven't called GetFrameCount().
    // This variable will be updated inside GetFrameCount()

    if ( TotalNumOfFrame == -1 )
    {
        hResult = GetFrameCount(&FRAMEDIM_TIME, &frame_count);
        if ( FAILED(hResult) )
        {
            WARNING(("GpGifCodec::GetImageInfo---GetFrameCount failed"));
            return hResult;
        }
    }

    // For multi-frame image, we need to adjust the width and height of the
    // logical screen size if necessary

    if ( IsAnimatedGif == TRUE )
    {
        ASSERT(bGifinfoFirstFrameDim);
        
        if ( gifinfo.LogicScreenWidth < gifinfoFirstFrameWidth )
        {
            gifinfo.LogicScreenWidth = gifinfoFirstFrameWidth;
        }

        if ( gifinfo.LogicScreenHeight < gifinfoFirstFrameHeight )
        {
            gifinfo.LogicScreenHeight = gifinfoFirstFrameHeight;
        }
    }
    else if ( IsMultiImageGif == TRUE )
    {
        // Multi-image gif

        if ( gifinfo.LogicScreenWidth < gifinfoMaxWidth )
        {
            gifinfo.LogicScreenWidth = gifinfoMaxWidth;
        }
        if ( gifinfo.LogicScreenHeight < gifinfoMaxHeight )
        {
            gifinfo.LogicScreenHeight = gifinfoMaxHeight;
        }
    }

    hResult = ReadGifHeaders();

    // gifinfo dimensions might have changed to the dimensions of the first
    // frame (if we have a multi-frame image).
    
    CachedImageInfo.Width = gifinfo.LogicScreenWidth;
    CachedImageInfo.Height = gifinfo.LogicScreenHeight;
    
    if ( SUCCEEDED(hResult) )
    {
        *imageInfo = CachedImageInfo;
        IsImageInfoCached = TRUE;
    }

    return hResult;
}// GetImageInfo()

/**************************************************************************\
*
* Function Description:
*
*     Decodes the current frame
*
* Arguments:
*
*     none
*
* Note: The callers to this function are:
*   ::Decode-------------Calls with (TRUE,  TRUE,   TRUE)
*   ::SkipToNextFrame----Calls with (FALSE, FALSE,  TRUE)
*   ::ReadFrameProperty--Calls with (TRUE,  FALSE,  FALSE)
*   ::MoveToNextFrame----Calls with (TRUE,  FALSEE, TRUE)
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::DoDecode(
    BOOL processdata,
    BOOL sinkdata,
    BOOL decodeframe
    )
{
    ImageInfo sinkImageInfo;

    HRESULT hResult = GetImageInfo(&sinkImageInfo);
    if (FAILED(hResult)) 
    {
        WARNING(("GpGifCodec::DoDecode---GetImageInfo() failed"));
        return hResult;
    }

    if (!HasCalledBeginSink && sinkdata)
    {
        hResult = ReadGifHeaders();
        if (FAILED(hResult))
        {
            WARNING(("GpGifCodec::DoDecode---ReadGifHeaders() failed"));
            return hResult;
        }

        hResult = decodeSink->BeginSink(&sinkImageInfo, NULL);
        if (FAILED(hResult))
        {
            WARNING(("GpGifCodec::DoDecode---BeginSink() failed"));
            return hResult;
        }

        if ( sinkImageInfo.PixelFormat != CachedImageInfo.PixelFormat )

        {
            // Basically GIF doesn't allow the sink negotiate the pixel format.
            // A GIF can be either 8 or 32 bpp. If it is 8 bpp, and the sink
            // askes for 8 bpp, we are OK. Otherwise, we always return 32 bpp to
            // the sink. From performance point of view, it is the same to ask
            // GIF decoder doing the format or the sink does the format
            // conversion

            sinkImageInfo.PixelFormat = PIXFMT_32BPP_ARGB;
        }

        HasCalledBeginSink = TRUE;
    }

    if ( processdata &&
       ((IsAnimatedGif == TRUE) || (IsMultiImageGif == TRUE))
       && (GifFrameCachePtr == NULL) )
    {
        // If we are animating, then we need to use PIXFMT_32BPP_ARGB

        sinkImageInfo.PixelFormat = PIXFMT_32BPP_ARGB;
        GifFrameCachePtr = new GifFrameCache(gifinfo, sinkImageInfo.PixelFormat,
                                             GetBackgroundColor());
        if ( GifFrameCachePtr == NULL )
        {
            WARNING(("GpGifCodec::DoDecode---new GifFrameCache() failed"));
            return E_OUTOFMEMORY;
        }

        // We need to check if the frame cache is really valid. Under low
        // memory situation, the GifFrameCache class will have problem to
        // allocate a memory buffer, see Windows bug#411946

        if ( GifFrameCachePtr->IsValid() == FALSE )
        {
            WARNING(("GpGifCodec::DoDecode---new GifFrameCache not valid"));

            // If the frame cache buffer is invalid, we should delete the
            // pointer here so that we know that we don't have a frame cache

            delete GifFrameCachePtr;
            GifFrameCachePtr = NULL;
            return E_OUTOFMEMORY;
        }
    }

    BOOL stillreading = TRUE;
    while (stillreading)
    {
        BYTE chunktype;

        //Read in the chunk type.

        hResult = ReadFromStream(istream, &chunktype, sizeof(BYTE), blocking);
        if (FAILED(hResult))
        {
            WARNING(("GpGifCodec::DoDecode---ReadFromStream() failed"));
            return hResult;
        }

        switch(chunktype)
        {
        case 0x2C:  //Image Chunk
            if (decodeframe)
            {
                hResult = ProcessImageChunk(processdata, sinkdata,
                                            sinkImageInfo);
                if ( FAILED(hResult) )
                {
                    WARNING(("GifCodec::DoDecode-ProcessImageChunk() failed"));
                    return hResult;
                }

                if ( processdata )
                {
                    currentframe++;
                }

                if ( HasProcessedPropertyItem == FALSE )
                {
                    // Note: "TotalNumOfFrame" starts at 0, set in GetFrameCount()

                    INT iTemp = TotalNumOfFrame;

                    // Store frame delay info here for property use

                    if ( iTemp >= (INT)FrameDelayBufferSize )
                    {
                        // We have more frames than we allocated.
                        
                        FrameDelayBufferSize = (FrameDelayBufferSize << 1);

                        VOID*  pExpandBuf = GpRealloc(FrameDelayArrayPtr,
                                           FrameDelayBufferSize * sizeof(UINT));
                        if ( pExpandBuf != NULL )
                        {
                            // Note: GpRealloc will copy the old contents to the
                            // new expanded buffer before return if it succeed

                            FrameDelayArrayPtr = (UINT*)pExpandBuf;
                        }
                        else
                        {
                            // Note: if the memory expansion failed, we simply
                            // return E_OUTOFMEMORY. So we still have all the
                            // old contents. The contents buffer will be
                            // freed when the destructor is called.

                            WARNING(("GpGifCodec::DoDecode---Out of memory"));
                            return E_OUTOFMEMORY;
                        }
                    }

                    // Attach the delaytime info from the closest GCE to the
                    // delay time property list                    

                    FrameDelayArrayPtr[iTemp] = lastgce.delaytime;
                }
            }
            else
            {
                //Move one byte backwards in the stream because we want to be 
                //able to re-enter this procedure and know which chunk type 
                //to process

                hResult = SeekThroughStream(istream, -1, blocking);
                if (FAILED(hResult))
                {
                    WARNING(("GifCodec::DoDecode--SeekThroughStream() failed"));
                    return hResult;
                }
            }
            stillreading = FALSE;
            break;
        case 0x3B:  //Terminator Chunk
            stillreading = FALSE;
            if (!processdata)
            {
                // Note: this is not an error. If the caller not asking for
                // process data, we just return.

                return IMGERR_NOFRAME;
            }

            break;
        case 0x21:  //Extension
            //Read in the extension chunk type
            hResult = ReadFromStream(istream, &chunktype, sizeof(BYTE),
                                     blocking);
            if (FAILED(hResult))
            {
                WARNING(("GpGifCodec::DoDecode---ReadFromStream() failed"));
                return hResult;
            }

            switch(chunktype)
            {
            case 0xF9:
                hResult = ProcessGraphicControlChunk(processdata);
                break;
            case 0xFE:
                hResult = ProcessCommentChunk(processdata);
                break;
            case 0x01:
                hResult = ProcessPlainTextChunk(processdata);
                break;
            case 0xFF:
                hResult = ProcessApplicationChunk(processdata);
                break;
            default:
                stillreading = FALSE;
            }

            if ( FAILED(hResult) )
            {
                WARNING(("GpGifCodec::DoDecode---Process chunk failed"));
                return hResult;
            }

            break;
        case 0x00:
            // For protection against corrupt gifs we don't necessarily wait 
            // until the last 0 byte is read from the image chunk.  So, we 
            // ignore the 0 here if/when it comes up.
            break;
        default:
            // Unknown chunk type

            return IMGERR_NOFRAME;
        }
    }

    return S_OK;
}// DoDecode()

/**************************************************************************\
*
* Function Description:
*
*     Wrapper for DoDecode()
*
* Arguments:
*
*     none
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::Decode()
{
    HRESULT     hResult = S_OK;
    
    if ( IsMultiImageGif == TRUE )
    {
        // For multi-image GIF, we need to decode them all at once and show the
        // last image, which contains the compositing results of all the images.
        // So here we just seek to the last page of this image and decode it
        
        LONGLONG    llMark;
        INT         iCurrentFrame = 1;
        
        while ( iCurrentFrame < TotalNumOfFrame )
        {
            hResult = MoveToNextFrame();
            if ( SUCCEEDED(hResult) )
            {
                iCurrentFrame++;
            }
            else
            {
                WARNING(("GpGifCodec::Decode---No frame"));
                return IMGERR_NOFRAME;
            }
        }

        // Make sure that the frame exists by seeing if we can skip to the next
        // frame.
        
        hResult = MarkStream(istream, llMark);
        if ( FAILED(hResult) )
        {
            WARNING(("GpGifCodec::Decode---MarkStream() failed"));
            return hResult;
        }

        hResult = SkipToNextFrame();
        if ( FAILED(hResult) )
        {
            WARNING(("GpGifCodec::Decode---SkipToNextFrame() failed"));
            return hResult;
        }

        hResult = ResetStream(istream, llMark);
        if ( FAILED(hResult) )
        {
            WARNING(("GpGifCodec::Decode---ReadStream() failed"));
            return hResult;
        }
    }
    
    LONGLONG mark;

    // Before we call the lower level to decode one frame, we have to remember
    // the position for current frame in the whole GIF stream. After decode the
    // current frame, we should reset it back to this position so that the next
    // call to ::Decode() still decodes the current frame, not the next frame

    hResult = MarkStream(istream, mark);
    if ( FAILED(hResult) )
    {
        WARNING(("GpGifCodec::Decode---MarkStream() failed"));
        return hResult;
    }

    hResult = DoDecode(TRUE, TRUE, TRUE);
    if ( FAILED(hResult) )
    {
        WARNING(("GpGifCodec::Decode---DoDecode() failed"));
        return hResult;
    }

    hResult = ResetStream(istream, mark);
    if ( FAILED(hResult) )
    {
        WARNING(("GpGifCodec::Decode---ResetStream() failed"));
        return hResult;
    }

    // Reduce the "currentframe down by one. Note: this one is incremented in
    // DoDecode()

    currentframe--;

    return hResult;
}// Decode()

/**************************************************************************\
*
* Function Description:
*
*     Get the total number of dimensions the image supports
*
* Arguments:
*
*     count -- number of dimensions this image format supports
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::GetFrameDimensionsCount(
    UINT* count
    )
{
    if ( count == NULL )
    {
        WARNING(("GpGifCodec::GetFrameDimensionsCount--Invalid input parameter"));
        return E_INVALIDARG;
    }
    
    // Tell the caller that GIF is a one dimension image.

    *count = 1;

    return S_OK;
}// GetFrameDimensionsCount()

/**************************************************************************\
*
* Function Description:
*
*     Get an ID list of dimensions the image supports
*
* Arguments:
*
*     dimensionIDs---Memory buffer to hold the result ID list
*     count -- number of dimensions this image format supports
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::GetFrameDimensionsList(
    GUID*   dimensionIDs,
    UINT    count
    )
{
    if ( (count != 1) || (dimensionIDs == NULL) )
    {
        WARNING(("GpGifCodec::GetFrameDimensionsList-Invalid input param"));
        return E_INVALIDARG;
    }

    dimensionIDs[0] = FRAMEDIM_TIME;

    return S_OK;
}// GetFrameDimensionsList()

/**************************************************************************\
*
* Function Description:
*
*     Get number of frames for the specified dimension
*     
* Arguments:
*
*     dimensionID -- a dimensionID GUID
*     count -- number of frames in the image of dimension dimensionID    
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::GetFrameCount(
    IN const GUID* dimensionID,
    OUT UINT* count
    )
{
    if ( (count == NULL) || (*dimensionID != FRAMEDIM_TIME) )
    {
        WARNING(("GpGifCodec::GetFrameCount---Invalid input"));
        return E_INVALIDARG;
    }

    if ( TotalNumOfFrame != -1 )
    {
        // We have already know the TotalNumOfFrame, just return
        
        *count = TotalNumOfFrame;

        return S_OK;
    }

    // This is the first time we parse the image

    HRESULT hResult;
    BOOL headerread_pre = headerread;

    // headerread_pre is TRUE if we have read the GIF headers before
    // calling SkipToNextFrame(), which will call ReadGifHeaders().

    TotalNumOfFrame = 0;

    LONGLONG mark;

    hResult = MarkStream(istream, mark);
    if (FAILED(hResult))
    {
        WARNING(("GpGifCodec::GetFrameCount---MarkStream() failed"));
        return hResult;
    }

    if (headerread_pre)
    {
        hResult = ResetStream(istream, frame0pos);
        if (FAILED(hResult))
        {
            WARNING(("GpGifCodec::GetFrameCount---ReadStream() failed"));
            return hResult;
        }
    }

    hResult = S_OK;
    while ( SUCCEEDED(hResult) )
    {
        // Call SkipToNextFrame repeatedly to get the total number of frames.
        // SkipToNextFrame returns S_OK when it can advance to the next frame.
        // Otherwise it returns an error code IMGERR_NOFRAME.

        hResult = SkipToNextFrame();
        if ( SUCCEEDED(hResult) )
        {
            TotalNumOfFrame++;
        }
    }

    // If all went well, we now have the frame count, but hResult should be set
    // to IMGERR_NOFRAME. However, it is possible that another failure occurred,
    // so check for that and return if necessary.

    if ( FAILED(hResult) && (hResult != IMGERR_NOFRAME) )
    {
        WARNING(("GpGifCodec::GetFrameCount---Fail to count frame"));
        return hResult;
    }

    // if we hadn't read the headers before calculating TotalNumOfFrame,
    // then we should have done so by this point.  Reset the stream
    // to frame0pos (the previous mark should be zero in this case).
    // Otherwise, reset the stream to the previous mark.

    if (!headerread_pre)
    {
        ASSERT (headerread);
        ASSERT (mark == 0);
        hResult = ResetStream(istream, frame0pos);
    }
    else
    {
        hResult = ResetStream(istream, mark);
    }

    if ( FAILED(hResult) )
    {
        WARNING(("GpGifCodec::GetFrameCount---ResetStream() failed"));
        return hResult;
    }

    // After loop through all the frames, we set "bGifinfoMaxDim" to true
    // which means we don't need to do further maximum dimension size
    // adjustment. We can also determine if this image is a multi-image gif
    // or animated gif

    bGifinfoMaxDim = TRUE;

    if ( TotalNumOfFrame > 1 )
    {
        // If a multi-frame GIF image has loop extension or has a non-zero
        // frame delay, then this image is called animated GIF. Otherwise,
        // it is a multi-image GIF
        // Note: "HasLoopExtension" is set in
        // GpGifCodec::ProcessApplicationChunk(). "FrameDelay" is set in
        // GpGifCodec::ProcessGraphicControlChunk()

        if ( (HasLoopExtension == TRUE) || (FrameDelay > 0) )
        {
            IsAnimatedGif = TRUE;
            *count = TotalNumOfFrame;
        }
        else
        {
            IsMultiImageGif = TRUE;

            // We treate a multi-image GIF as a single frame GIF

            *count = 1;
        }
        
        // For multi-frame image, we have to return 32 bpp. Because:
        // 1) We need to do compositing of multi-frame
        // 2) Different frame might have different color attributes, like one
        //    has transparency and the other don't etc.
        // By the way, ReadGifHeaders() reads the GIF header only once. at that
        // time it doesn't have the knowledge of how many frames in the image.
        // So we have to set the PixelFormat in this function depends on the
        // image type info.

        if ( (IsAnimatedGif == TRUE) || (IsMultiImageGif == TRUE) )
        {
            CachedImageInfo.PixelFormat = PIXFMT_32BPP_ARGB;
        }
        else
        {
            CachedImageInfo.PixelFormat = PIXFMT_8BPP_INDEXED;
        }
    }
    else
    {
        // Return 1 for single frame image

        *count = 1;
    }

    // After this function, we should gather all the property related info

    PropertyNumOfItems = 1;
    PropertyListSize = TotalNumOfFrame * sizeof(UINT);

    // Check if we encounted comments chunk

    if ( CommentsBufferLength != 0 )
    {
        PropertyNumOfItems++;

        // Note: we need to add 1 extra bytes at the end for "comments"
        // section because we nned to put a NULL terminator there

        PropertyListSize += CommentsBufferLength + 1;
    }

    if ( HasLoopExtension == TRUE )
    {
        // This image has loop extension
        
        PropertyNumOfItems++;

        // A loop count takes an UINT16

        PropertyListSize += sizeof(UINT16);
    }

    HasProcessedPropertyItem = TRUE;

    return S_OK;
}// GetFrameCount()

/**************************************************************************\
*
* Function Description:
*
*     Select currently active frame
*     
* Arguments:
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::SelectActiveFrame(
    IN const GUID* dimensionID,
    IN UINT frameIndex
    )
{
    HRESULT hResult = S_OK;
    
    if ( TotalNumOfFrame == -1 )
    {
        // If the caller hasn't called GetFrameCount(), do it now since this is
        // the function initializes all the info

        UINT uiDummy;
        hResult = GetFrameCount(&FRAMEDIM_TIME, &uiDummy);
        
        if ( FAILED(hResult) )
        {
            WARNING(("GpGifCodec::SelectActiveFrame---GetFrameCount() failed"));
            return hResult;
        }
    }

    // For multi-image gif, we tells the caller there is only 1 frame because
    // we have to decode them at once and composite them, according to the spec.
    // So if the caller wants to set frameIndex on a frame > 1, we return fail.
    // Note: Later, if we really need to allow the caller to access to a
    // perticular frame, we can use SetDecoderParam() to do this and add one
    // more flag to indicate this requirement

    if ( (IsMultiImageGif == TRUE) && ( frameIndex > 1 ) )
    {
        WARNING(("GpGifCodec::SelectActiveFrame---Invalid parameter"));
        return E_INVALIDARG;
    }

    if ( frameIndex >= (UINT)TotalNumOfFrame )
    {
        WARNING(("GpGifCodec::SelectActiveFrame---Invalid index parameter"));
        return E_INVALIDARG;
    }

    if (*dimensionID != FRAMEDIM_TIME)
    {
        WARNING(("GpGifCodec::SelectActiveFrame---Invalid parameter, GUID"));
        return E_INVALIDARG;
    }

    //TODO:  If frameIndex == currentframe then we already have an exact 
    //cached copy of the image that they are requesting.  We should just 
    //sink it.  For now it regenerates the image from the beginning of the 
    //stream.  This is VERY inefficient.

    if ((signed)frameIndex <= currentframe)
    {
        ResetStream(istream, frame0pos);
        currentframe = -1;
    }

    LONGLONG mark;
    while ((signed)frameIndex > currentframe + 1)
    {
        hResult = MoveToNextFrame();
        if (SUCCEEDED(hResult))
        {
            // we don't need to increment currentframe because
            // MoveToNextFrame() does that for us.
        }
        else
        {
            WARNING(("GpGifCodec::SelectActiveFrame---No frame"));
            return IMGERR_NOFRAME;
        }
    }

    // Make sure that the frame exists by seeing if we can skip to the next frame.
    hResult = MarkStream(istream, mark);
    if ( FAILED(hResult) )
    {
        WARNING(("GpGifCodec::SelectActiveFrame---MarkStream() failed"));
        return hResult;
    }

    // (note: SkipToNextFrame() does not increment currentframe.)

    hResult = SkipToNextFrame();
    if (FAILED(hResult))
    {
        WARNING(("GpGifCodec::SelectActiveFrame---SkipToNextFrame() failed"));
        return hResult;
    }

    hResult = ResetStream(istream, mark);
    if (FAILED(hResult))
    {
        WARNING(("GpGifCodec::SelectActiveFrame---ResetStream() failed"));
        return hResult;
    }

    return S_OK;
}// SelectActiveFrame()

/**************************************************************************\
*
* Function Description:
*
*   Get image thumbnail
*
* Arguments:
*
*   thumbWidth, thumbHeight - Specifies the desired thumbnail size in pixels
*   thumbImage - Returns a pointer to the thumbnail image
*
* Return Value:
*
*   Status code
*
* Note:
*
*   Even if the optional thumbnail width and height parameters are present,
*   the decoder is not required to honor it. The requested size is used
*   as a hint. If both width and height parameters are 0, then the decoder
*   is free to choose an convenient thumbnail size.
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::GetThumbnail(
    IN OPTIONAL UINT thumbWidth,
    IN OPTIONAL UINT thumbHeight,
    OUT IImage** thumbImage
    )
{
    return E_NOTIMPL;
}

/**************************************************************************\
*
* Function Description:
*
*     Moves the stream seek pointer past the end of the current frame.
*
* Arguments:
*
*     none
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::SkipToNextFrame()
{
    // processdata = FALSE, sinkdata = FALSE, decodeframe = TRUE

    return DoDecode(FALSE, FALSE, TRUE);
}// SkipToNextFrame()

/**************************************************************************\
*
* Function Description:
*
*     Moves the stream seek pointer to the beginning of the image data.  This 
*     allows properties to be read without the image being decoded.
*
* Arguments:
*
*     none
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::ReadFrameProperties()
{
    //processdata = TRUE, sinkdata = FALSE, decodeframe = FALSE
    
    return DoDecode(TRUE, FALSE, FALSE); 
}// ReadFrameProperties()

/**************************************************************************\
*
* Function Description:
*
*     Moves the stream seek pointer past the end of the current frame and 
*     updates the cache to that frame.
*
* Arguments:
*
*     none
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::MoveToNextFrame()
{
    //processdata = TRUE, sinkdata = FALSE, decodeframe = TRUE
    
    return DoDecode(TRUE, FALSE, TRUE); 
}// MoveToNextFrame()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\gif\gifframecache.hpp ===
#pragma once

/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*    gifframecache.hpp
*
* Abstract:
*
*    The GifFrameCache class holds a copy of the previous frame that has been 
*    decompressed.  This is used so that when the client asks for some frame, 
*    x, the decompressor already has frame x-1 to composite upon and doesn't 
*    have to redecompress the entire gif up to that point
*
* Revision History:
*
*    7/12/1999 t-aaronl
*        Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "giffile.h"

class GifFrameCache
{
public:
    PixelFormatID pixformat;

    GifFrameCache(IN GifFileHeader &gifinfo,
                  IN PixelFormatID _pixformat,
                  IN BYTE gifCodecBackgroundColor);
    ~GifFrameCache();

    void    InitializeCache();
    void    ClearCache(IN RECT rect);
    void    CopyFromCache(IN RECT rect, IN OUT BYTE *_buffer);
    void    CopyToCache(IN RECT rect, IN BYTE *_buffer);
    void    FillScanline(IN OUT BYTE *scanline, IN UINT row);
    BYTE*   GetScanLinePtr(IN UINT row);
    void    PutScanline(IN BYTE *scanline, IN UINT row);
    BOOL    SetFrameCachePalette(IN ColorPalette *colorpalette);
    
    BOOL    IsValid()
    {
        return ValidFlag;
    }

    // Return TRUE if and only if SetPalette() has been called on this
    // Gif Frame Cache.

    BOOL    CachePaletteInitialized()
    {
        return HasCachePaletteInitialized;
    }

    BYTE*   GetBuffer()
    {
        return FrameCacheBufferPtr;
    }
    
    // Set the background color index of the gifframecache.

    void    SetBackgroundColorIndex(BYTE index)
    {
        BackGroundColorIndex = index;
    }

private:
    UINT    FrameCacheWidth;            // Width of frame cache
    UINT    FrameCacheHeight;           // Height of frame cache
    UINT    FrameCacheSize;             // Size of the whole frame cache in
                                        //   BYTES
    BYTE    BackGroundColorIndex;       // Background color index
    BOOL    Is32Bpp;                    // TRUE if the cache is in 32 bpp mode
    BYTE*   FrameCacheBufferPtr;        // Pointer to the frame cache buffer
    ColorPalette* CacheColorPalettePtr; // Pointer to color palette
    BOOL    HasCachePaletteInitialized; // TRUE if color palette has initialized
    BYTE    ColorPaletteBuffer[offsetof(ColorPalette, Entries)
                               + sizeof(ARGB) * 256];

    BOOL    ConvertTo32bpp();
    BOOL    ValidFlag;                  // TRUE if this frame cache is valid
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\gif\dll\gifguids.cpp ===
#include "precomp.hpp"

#include <initguid.h>
#include "imgguids.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\gif\gifframecache.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*    gifframecache.cpp
*
* Abstract:
*
*    The GifFrameCache class holds a frame of data to be used to composite 
*    upon for subsequent frames.
*
* Revision History:
*
*    7/16/1999 t-aaronl
*        Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "gifframecache.hpp"

/**************************************************************************\
*
* Function Description:
*
*     Contructor for GifFrameCache
*
* Arguments:
*
*     none
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

GifFrameCache::GifFrameCache(
    IN GifFileHeader &gifinfo,
    IN PixelFormatID _pixformat,
    IN BYTE gifCodecBackgroundColor
    ): ValidFlag(TRUE)
{
    FrameCacheWidth = gifinfo.LogicScreenWidth;
    FrameCacheHeight = gifinfo.LogicScreenHeight;

    // The gifCodecBackgroundColor should be determined by the function
    // GpGifCodec::GetBackgroundColor()
    
    BackGroundColorIndex = gifCodecBackgroundColor;
    CacheColorPalettePtr = (ColorPalette*)&ColorPaletteBuffer;
    CacheColorPalettePtr->Flags = 0;
    CacheColorPalettePtr->Count = 0;
    HasCachePaletteInitialized = FALSE;
    pixformat = _pixformat;

    Is32Bpp = (pixformat == PIXFMT_32BPP_ARGB);

    FrameCacheSize = FrameCacheWidth * FrameCacheHeight * (Is32Bpp ? 4 : 1);
    FrameCacheBufferPtr = (BYTE*)GpMalloc(FrameCacheSize);
    if ( FrameCacheBufferPtr == NULL )
    {
        ValidFlag = FALSE;
    }
}

/**************************************************************************\
*
* Function Description:
*
*     Destructor for GifFrameCache
*
* Arguments:
*
*     none
*
* Return Value:
*
*     none
*
\**************************************************************************/

GifFrameCache::~GifFrameCache()
{
    CacheColorPalettePtr->Count = 0;
    GpFree(FrameCacheBufferPtr);
}

/**************************************************************************\
*
* Function Description:
*
*     Performs operations needed to begin the current frame
*
* Arguments:
*
*     none
*
* Return Value:
*
*     none
*
\**************************************************************************/

void 
GifFrameCache::InitializeCache()
{
    RECT rect = {0,
                 0,
                 FrameCacheWidth,
                 FrameCacheHeight
                };

    ClearCache(rect);
}

/**************************************************************************\
*
* Function Description:
*
*     Clears the specified area of the cache with the background color
*
* Arguments:
*
*     none
*
* Return Value:
*
*     none
*
\**************************************************************************/

void 
GifFrameCache::ClearCache(
    IN RECT rect
    )
{
    if ( Is32Bpp == TRUE )
    {
        // For a 32 bpp cache buffer, we have to set the color value for each
        // pixel

        ARGB color = CacheColorPalettePtr->Entries[BackGroundColorIndex];
        
        // TODO: the cache may be initialized before the CacheColorPalettePtr is
        // valid? I'm not sure, but it needs to be looked at.

        for ( int y = rect.top; y < rect.bottom; y++ )
        {
            ARGB* bufferstart = (ARGB*)FrameCacheBufferPtr
                              + y * FrameCacheWidth;

            for ( int x = rect.left; x < rect.right; x++ )
            {
                bufferstart[x] = color;
            }
        }
    }
    else
    {
        // For a 8 bpp cache buffer, we need only to set the color index value
        // for each pixel
        
        INT     rectwidth = rect.right - rect.left;
        BYTE*   bufferleft = FrameCacheBufferPtr + rect.left;

        for ( int y = rect.top; y < rect.bottom; y++ )
        {
            GpMemset(bufferleft + y * FrameCacheWidth,
                     BackGroundColorIndex, rectwidth);
        }
    }
}// ClearCache()

/**************************************************************************\
*
* Function Description:
*
*     Copies a rectangle of data in the cache to the specified buffer.
*
* Arguments:
*
*     none
*
* Return Value:
*
*     none
*
\**************************************************************************/

void 
GifFrameCache::CopyFromCache(
    IN RECT         rect,
    IN OUT BYTE*    pDstBuffer
    )
{
    ASSERT(rect.right >= rect.left);

    UINT    uiPixelSize = Is32Bpp ? 4 : 1;
    INT     iRectStride = (rect.right - rect.left) * uiPixelSize;
    UINT    uiFrameCacheStride = FrameCacheWidth * uiPixelSize;
    BYTE*   pBufferLeft = FrameCacheBufferPtr + rect.left * uiPixelSize;

    for ( int y = rect.top; y < rect.bottom; y++ )
    {
        GpMemcpy(pDstBuffer + y * iRectStride,
                 pBufferLeft + y * uiFrameCacheStride,
                 iRectStride);
    }
}

/**************************************************************************\
*
* Function Description:
*
*     Copies a rectangle of data in the specified buffer to the cache.
*
* Arguments:
*
*     none
*
* Return Value:
*
*     none
*
\**************************************************************************/

void 
GifFrameCache::CopyToCache(
    IN RECT         rect,
    IN OUT BYTE*    pSrcBuffer
    )
{
    ASSERT(rect.right >= rect.left);
    
    UINT    uiPixelSize = Is32Bpp ? 4 : 1;
    INT     iRectStride = (rect.right - rect.left) * uiPixelSize;
    BYTE*   pBufferLeft = FrameCacheBufferPtr + rect.left * uiPixelSize;
    UINT    uiFrameCacheStride = FrameCacheWidth * uiPixelSize;

    for ( int y = rect.top; y < rect.bottom; y++ )
    {
        GpMemcpy(pBufferLeft + y * uiFrameCacheStride,
                 pSrcBuffer + y * iRectStride,
                 iRectStride);
    }
}// CopyToCache()

/**************************************************************************\
*
* Function Description:
*
*     Copies one line of data from the frame cache into a buffer
*
* Arguments:
*
*   pbDstBuffer  - location of where to put the data
*   uiCurrentRow - index of the data in the cache
*
* Return Value:
*
*     none
*
\**************************************************************************/

void 
GifFrameCache::FillScanline(
    BYTE*   pbDstBuffer,
    UINT    uiCurrentRow
    )
{
    ASSERT(uiCurrentRow < FrameCacheHeight);
    ASSERT(pbDstBuffer != NULL);

    UINT pos = uiCurrentRow * FrameCacheWidth * (Is32Bpp ? 4 : 1);
    ASSERT(pos < FrameCacheSize);

    GpMemcpy(pbDstBuffer, FrameCacheBufferPtr + pos,
             FrameCacheWidth * (Is32Bpp ? 4 : 1));
}// FillScanline()

/**************************************************************************\
*
* Function Description:
*
*     Gets a pointer to a scanline in the cache
*
* Arguments:
*
*     uiRowNum - index of the data in the cache
*
* Return Value:
*
*     a pointer to the beginning of the requested row
*
\**************************************************************************/

BYTE* 
GifFrameCache::GetScanLinePtr(
    UINT uiRowNum
    )
{
    ASSERT(uiRowNum < FrameCacheHeight);

    UINT uiPos = uiRowNum * FrameCacheWidth * (Is32Bpp ? 4 : 1);
    ASSERT(uiPos < FrameCacheSize);

    return FrameCacheBufferPtr + uiPos;
}// GetScanLinePtr()

/**************************************************************************\
*
* Function Description:
*
*     Copies data from the scanline location into the cache
*
* Arguments:
*
*     pScanLine - location of where to take the data from
*     uiRowNum  - index of the data in the cache
*
*
* Return Value:
*
*     none
*
\**************************************************************************/

void 
GifFrameCache::PutScanline(
    BYTE*   pScanLine,
    UINT    uiRowNum
    )
{
    ASSERT(uiRowNum < FrameCacheHeight);
    ASSERT(pScanLine != NULL);

    UINT uiPos = uiRowNum * FrameCacheWidth;
    ASSERT(uiPos < FrameCacheSize / (Is32Bpp ? 4 : 1));

    GpMemcpy(FrameCacheBufferPtr + uiPos * (Is32Bpp ? 4 : 1), pScanLine,
             FrameCacheWidth * (Is32Bpp ? 4 : 1));
}// PutScanline()

/**************************************************************************\
*
* Function Description:
*
*     Allocates a new palette and copies a palette into it.
*
* Arguments:
*
*     palette - The palette to set in the sink
*
* Return Value:
*
*     none
*
\**************************************************************************/

BOOL
GifFrameCache::SetFrameCachePalette(
    IN ColorPalette* pSrcPalette
    )
{
    UINT i;

    BOOL fIsSamePalette = TRUE;
    
    if ( (CacheColorPalettePtr->Count != 0) && (Is32Bpp == FALSE) )
    {
        pSrcPalette->Count = CacheColorPalettePtr->Count;

        for ( i = 0; i < pSrcPalette->Count && fIsSamePalette; i++ )
        {
            fIsSamePalette = (pSrcPalette->Entries[i]
                              == CacheColorPalettePtr->Entries[i]);
        }

        // TODO/NOTE:  If the palettes are not the same I am converting the
        // cache to 32bpp and using that mode from now on.  However, it would
        // not be that difficult to optimize the case where if the two palettes
        // have less than 257 colors, merge the palettes together and still be
        // in 8 bpp indexed.

        if ( fIsSamePalette == FALSE )
        {
            if ( ConvertTo32bpp() == TRUE )
            {
                pixformat = PIXFMT_32BPP_ARGB;
            }
            else
            {
                return FALSE;
            }
        }
        else
        {
            pixformat = PIXFMT_8BPP_INDEXED;
        }
    }
    else
    {
        GpMemcpy(CacheColorPalettePtr, 
                 pSrcPalette, 
                 offsetof(ColorPalette, Entries)
                 + pSrcPalette->Count*sizeof(ARGB));
    }

    HasCachePaletteInitialized = TRUE;

    return TRUE;
}// SetFrameCachePalette()

/**************************************************************************\
*
* Function Description:
*
*     Converts the cache into 32bpp ARGB from 8bpp indexed
*
* Arguments:
*
*     none
*
* Return Value:
*
*     none
*
\**************************************************************************/

BOOL 
GifFrameCache::ConvertTo32bpp()
{
    UINT    uiNewNumOfBytes = FrameCacheSize * 4;
    BYTE*   pNewBuffer = (BYTE*)GpMalloc(uiNewNumOfBytes);

    if ( pNewBuffer == NULL )
    {
        WARNING(("GifFrameCache::ConvertTo32bpp---Out of memory"));
        return FALSE;
    }

    for ( UINT i = 0; i < FrameCacheSize; i++ )
    {
        ((ARGB*)pNewBuffer)[i] =
            CacheColorPalettePtr->Entries[FrameCacheBufferPtr[i]];
    }

    GpFree(FrameCacheBufferPtr);
    FrameCacheBufferPtr = pNewBuffer;

    FrameCacheSize = uiNewNumOfBytes;
    Is32Bpp = TRUE;

    return TRUE;
}// ConvertTo32bpp()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\gif\gifproc.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   gifproc.cpp 
*
* Abstract:
*
*   The part of the implementation for the gif decoder that handles each
*       type of chunk
*
* Revision History:
*
*   6/8/1999 t-aaronl
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "gifcodec.hpp"


/**************************************************************************\
*
* Progressive, interlacing and multipass:
*
*   This decoder must send the data to the sink in a way that it can 
*   understand based on the requirements negotiated upon.  We try to 
*   deliver the image in as progressive of a way as the sink can support.
*   There are three parameters to decide on how the data will be passed:
*   Interlaced, multipass and topdown.  Interlaced is stored in the image 
*   file, multipass is a flag that the sink sets if it can handle multiple
*   revisions of the same data and topdown is set by the sink if it can 
*   only handle the data in top-down order.  The table below explains the 
*   cases that must be considered.
*
*                  | interlaced          | not interlaced
*   ---------------+---------------------+---------------------
*       topdown SP | case 3              | case 1
*       topdown MP | case 4              | case 1
*   ---------------+---------------------+---------------------
*    nottopdown SP | case 2              | case 1
*    nottopdown MP | case 4              | case 1
*
*   case 1: Don't do anything special.  Just take the data, decode it and 
*           send it row by row to the sink.
*   case 2: Same as case 1 but send the lines to the sink in a the 
*           translated order so that the sink has image non-interlaced.
*   case 3: Allocate a buffer for the whole image, decode the image into 
*           that buffer into the correct line order and pass the whole 
*           buffer to the sink in one piece.
*   case 4: Same as case 3 but after each pass (at 1/8, 1/8, 1/4, 1/2 of 
*           the data) send the so-far completed image to the sink
*
\**************************************************************************/


/**************************************************************************\
*
* Function Description:
*
*     For an interlaced GIF, there are four passes.  This function returns
*     0-3 to indicate which pass the line is on.
*
* Arguments:
*
*     A line number of an interlaced GIF image and the GIF's height.
*
* Return Value:
*
*     the pass number.
*
\**************************************************************************/

int
GpGifCodec::WhichPass(
    int line,
    int height
    )
{
    if ( line < (height - 1) / 8 + 1)
    {
        return 0;
    }
    else if (line < (height - 1) / 4 + 1)
    {
        return 1;
    }
    else if (line < (height - 1) / 2 + 1)
    {
        return 2;
    }
    else
    {
        return 3;
    }
}// WhichPass()

/**************************************************************************\
*
* Function Description:
*
*     For an interlaced GIF, there are four passes.  After each pass, a 
*     portion of the image has been drawn.  After the first pass, an eighth
*     has been drawn, after the second, a quarter, etc.  To fill the entire 
*     area of a multipass image with each frame, the lines so far drawn must
*     be copied to the x succeeding rows where 1/(x-1) is the amount of the 
*     image that will be drawn in that pass.
*
* Arguments:
*
*     The pass number
*
* Return Value:
*
*     x (see description above)
*
\**************************************************************************/

int
GpGifCodec::NumRowsInPass(
    int pass
    )
{
    switch (pass)
    {
    case 0:
        return 8;

    case 1:
        return 4;

    case 2:
        return 2;

    case 3:
        return 1;
    }

    ASSERT(FALSE);
    return 0;  //This is bad and should not happen.  GIFs only have 4 passes
}// NumRowsInPass()

/**************************************************************************\
*
* Function Description:
*
*     Translates the line number of a line in an interlaced gif image to 
*     the correct non-interlaced order
*
* Arguments:
*
*     A line number of an interlaced GIF image, the GIF's height and the 
*     current pass number.
*
* Return Value:
*
*     The line number that an interlaced line is mapped to.
*
\**************************************************************************/

int
GpGifCodec::TranslateInterlacedLine(
    int line,
    int height,
    int pass
    )
{
    switch (pass)
    {
    case 0:
        return line * 8;

    case 1:
        return (line - ((height - 1) / 8 + 1)) * 8 + 4;

    case 2:
        return (line - ((height - 1) / 4 + 1)) * 4 + 2;

    case 3:
        return (line - ((height - 1) / 2 + 1)) * 2 + 1;
    }
    
    //This is bad and should not happen.  GIFs only have 4 passes

    ASSERT(FALSE);
    return 0;
}// TranslateInterlacedLine()

/**************************************************************************\
*
* Function Description:
*
*     Translates the line number of a line in an non-interlaced gif image to 
*     the interlaced order.  This is the inverse function of 
*     TranslateInterlacedLine.
*
* Arguments:
*
*     A line number of an interlaced GIF image and the GIF's height.
*
* Return Value:
*
*     The interlaced line number that an non-interlaced line is mapped to.
*
\**************************************************************************/

int
GpGifCodec::TranslateInterlacedLineBackwards(
    int line,
    int height
    )
{
    if (line % 8 == 0)
    {
        return line / 8;
    }
    else if ((line - 4) % 8 == 0)
    {
        return line / 8 + (height+7) / 8;
    }
    else if ((line - 2) % 4 == 0)
    {
        return line / 4 + (height+3) / 4;
    }
    else
    {
        return line / 2 + (height+1) / 2;
    }
}// TranslateInterlacedLineBackwards()

/**************************************************************************\
*
* Function Description:
*
*   To be compatible with what Office does, we use the following way to select
*   the background color in case an image does not fill the entire logical
*   screen area:
*   If there is a transparent color index, use it (i.e., ignore the background
*   color).
*   Otherwise, use the background color index (even if the global color table
*   flag is off).
*
* Arguments:
*
*     none
*
* Return Value:
*
*     background color
*
\**************************************************************************/

BYTE
GpGifCodec::GetBackgroundColor()
{
    BYTE backgroundColor;

    backgroundColor = gifinfo.backgroundcolor;
    if ( lastgcevalid && (lastgce.transparentcolorflag) )
    {
        backgroundColor = lastgce.transparentcolorindex;
    }

    return backgroundColor;
}// GetBackgroundColor()
    
/**************************************************************************\
*
* Function Description:
*
*     Copies a GifColorPalette into a ColorPalette.
*
* Arguments:
*
*     gcp - GifColorPalette structure to be copied into:
*     cp - ColorPalette.
*
* Return Value:
*
*     none
*
\**************************************************************************/

void
GpGifCodec::CopyConvertPalette(
    IN GifColorTable *gct,
    OUT ColorPalette *cp,
    IN UINT count
    )
{
    cp->Count = count;
    cp->Flags = 0;

    //Copy the color palette from a gif file into a ColorPalette structure
    // suitable for Imaging.

    for ( UINT i=0; i<count; i++ )
    {
        cp->Entries[i] = MAKEARGB(255, gct->colors[i].red, 
                                  gct->colors[i].green, gct->colors[i].blue);
    }

    //If there is a transparent entry in the color palette then set it.

    if (lastgcevalid && (lastgce.transparentcolorflag))
    {
        INT index = lastgce.transparentcolorindex;
        cp->Entries[index] = MAKEARGB(0, gct->colors[index].red, 
                                      gct->colors[index].green,
                                      gct->colors[index].blue);
        cp->Flags = PALFLAG_HASALPHA;
    }   
}// CopyConvertPalette()

/**************************************************************************\
*
* Function Description:
*
*   This function sets up the local color table for a frame. If the local color
*   table exists, it reads in the local color table and assign it. Otherwise it
*   uses the global color table as the local color table
*
* Arguments:
*
*   fHasLocalTable - TRUE if the gif file has a local color table
*   pColorPalette -- Pointer to current color table  
*
* Return Value:
*
*   A pointer to current color table.
*
* Note:
*   Caller must deallocate.
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::SetFrameColorTable(
    IN BOOL                 fHasLocalTable,
    IN OUT ColorPalette*    pColorPalette
    )
{
    GifColorTable*  pCurrentColorTable;
    GifColorTable localcolortable;

    pColorPalette->Flags = PALFLAG_HASALPHA;

    //local indicates that this gif has local color table and the stream 
    //is pointing to it.  We just have to read it in.
    
    if ( fHasLocalTable == TRUE )
    {
        HRESULT hResult = ReadFromStream(istream, &localcolortable, 
                                 pColorPalette->Count * sizeof(GifPaletteEntry),
                                 blocking);
        if ( FAILED(hResult) )
        {
            WARNING(("GpGifCodec::SetFrameColorTable--ReadFromStream() failed"));
            return hResult;
        }

        pCurrentColorTable = &localcolortable;
    }
    else if (gifinfo.globalcolortableflag)
    {
        pCurrentColorTable = &GlobalColorTable;
        pColorPalette->Count = GlobalColorTableSize;
    }
    else
    {
        WARNING(("GpGifCodec::SetFrameColorTable--palette missing"));
        return E_FAIL;
    }

    // Copy the color palette from the gif file into a ColorPalette structure 
    // suitable for Imaging.

    CopyConvertPalette(pCurrentColorTable, pColorPalette, pColorPalette->Count);

    return S_OK;
}// SetFrameColorTable()

/**************************************************************************\
*
* Function Description:
*
*     Gives the decompressor a buffer to output data to.  This function 
*     also copies the leftover data that is in the gifoverflow buffer from the 
*     previous line into the beginning of the new buffer.
*
* Arguments:
*
*     line - The current line number
*     gifbuffer - GifBuffer structure that controls the uncompressed output 
*         buffers
*     The LZWDecompressor, which uses the output buffer
*     GifOverflow buffer structure
*     image info descriptor of the current frame
*     clipped image info descriptor of the current frame
*     Flag to indicate whether to pad the left and right of the current 
*         scanline
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::GetOutputSpace(
    IN int line,
    IN GifBuffer &gifbuffer,
    IN LZWDecompressor &lzwdecompressor,
    IN GifOverflow &gifoverflow,
    IN GifImageDescriptor currentImageInfo,
    IN GifImageDescriptor clippedCurrentImageInfo,
    IN BOOL padborder
    )
{
    HRESULT hResult;

    // ASSERT: currentImageInfo is the original GIF image data for the current
    // frame.
    // clippedCurrentImageInfo is the original GIF image data for the current
    // frame, clipped according to the logical screen area.

    // Somewhat of a hack: if the line we are trying to output is beyond the end
    // the buffer, then we lie to GetBuffer about which line we actually want
    // to write to.  We reuse the last line of the buffer.
    
    INT bufferLine = line + currentImageInfo.top;

    // The case when line == 0,  clippedCurrentImageInfo.height == 0,
    // currentImageInfo.top == 0,
    // and clippedCurrentImageInfo.height == 0 should not happen.
    
    ASSERTMSG((bufferLine >= 0),
              ("GetOutputSpace: about to access a bad location in buffer"));

    if (line < clippedCurrentImageInfo.height)
    {
        hResult = gifbuffer.GetBuffer(bufferLine);
        if (FAILED(hResult))
        {
            WARNING(("GpGifCodec::GetOutputSpace-could not get output buffer"));
            return hResult;
        }
        
        lzwdecompressor.m_pbOut =(unsigned __int8*)gifbuffer.GetCurrentBuffer();
    }
    else
    {
        lzwdecompressor.m_pbOut = (unsigned __int8*)gifbuffer.GetExcessBuffer();
    }

    lzwdecompressor.m_cbOut = currentImageInfo.width;

    if ( gifoverflow.inuse )
    {
        // If the amount of data that gifoverflowed into the buffer over the 
        // amount that is needed to finish the row is too little to finish a 
        // second row then copy the remaining data into the decompressor.  If 
        // there is another full row then copy that into the gifoverflow buffer 
        // and continue.

        if (gifoverflow.by <= currentImageInfo.width)
        {
            GpMemcpy(lzwdecompressor.m_pbOut,
                     gifoverflow.buffer + gifoverflow.needed,
                     gifoverflow.by);
            lzwdecompressor.m_pbOut += gifoverflow.by;
            lzwdecompressor.m_cbOut -= gifoverflow.by;

            gifoverflow.inuse = FALSE;
        }
        else
        {
            GpMemcpy(lzwdecompressor.m_pbOut,
                     gifoverflow.buffer + gifoverflow.needed, 
                     currentImageInfo.width);
            
            lzwdecompressor.m_pbOut += currentImageInfo.width;
            lzwdecompressor.m_cbOut = 0;

            GpMemcpy(gifoverflow.buffer,
                     gifoverflow.buffer + gifoverflow.needed
                                        + currentImageInfo.width,
                     gifoverflow.by - currentImageInfo.width);

            gifoverflow.needed = 0;
            gifoverflow.by -= currentImageInfo.width;
            //gifoverflow is still in use
        }
    }

    lzwdecompressor.m_fNeedOutput = FALSE;

    return S_OK;
}// GetOutputSpace()

/**************************************************************************\
*
* Function Description:
*
*     Reads compressed data from the stream into a buffer that the 
*     decompressor can process.
*
* Arguments:
*
*     The LZWDecompressor, which uses the input buffer
*     A buffer in which to put the compressed data
*     A flag that is set to FALSE if there is no more data that can be read 
*         from the stream or if the end of the imagechunk is reached
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::GetCompressedData(
    IN LZWDecompressor &lzwdecompressor, 
    IN BYTE *compresseddata,
    OUT BOOL &stillmoredata
    )
{
    HRESULT hResult;

    BYTE blocksize;
    
    hResult = ReadFromStream(istream, &blocksize, sizeof(BYTE), blocking);
    if (FAILED(hResult))
    {
        WARNING(("GpGifCodec::GetCompressedData--first ReadFromStream failed"));
        return hResult;
    }

    if (blocksize > 0)
    {
        hResult = ReadFromStream(istream, compresseddata, blocksize, blocking);
        if (FAILED(hResult))
        {
            WARNING(("GifCodec::GetCompressedData--2nd ReadFromStream failed"));
            return hResult;
        }
        
        lzwdecompressor.m_pbIn = (unsigned __int8*)compresseddata;
        lzwdecompressor.m_cbIn = blocksize;
        lzwdecompressor.m_fNeedInput = FALSE;
    }
    else
    {
        stillmoredata = FALSE;

        // Since the next data chunk size is 0, so the decompressor can say
        // "need data" any more

        lzwdecompressor.m_cbIn = blocksize;
        lzwdecompressor.m_fNeedInput = FALSE;
    }

    return S_OK;
}// GetCompressedData()

/**************************************************************************\
*
* Function Description:
*
*     Process the image data chunks for a gif stream.
*
* Arguments:
*
*     none
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::ProcessImageChunk(
    IN BOOL bNeedProcessData,
    IN BOOL sinkdata,
    ImageInfo dstImageInfo
    )
{
    // "currentimageinfo" contains the original image info data for the current
    // image. "clippedCurrentImageInfo" has its width and height clipped in case
    // the bounds of the resulting rectangle are beyond the bounds of the
    // logical screen area.

    GifImageDescriptor currentImageInfo;
    GifImageDescriptor clippedCurrentImageInfo;

    // Read in the Image Descriptor, skipping the Image Separator character
    // because it has already been read from the stream and is not needed anyway

    HRESULT hResult = ReadFromStream(istream, 
                                     &currentImageInfo, 
                                     sizeof(GifImageDescriptor), 
                                     blocking);
    if ( FAILED(hResult) )
    {
        WARNING(("GpGifCodec::ProcessImageChunk -- 1st ReadFromStream failed"));
        return hResult;
    }

    // Update the frame width and height info for current frame
    // Note: this is needed for some GIFs which have zero length logic screen
    // width or height. So we have to expand the logic screen width and height
    // to the first frame width and height

    if ( (CachedImageInfo.Width == 0 )
       ||(CachedImageInfo.Height == 0) )
    {
        CachedImageInfo.Width = currentImageInfo.width;
        CachedImageInfo.Height = currentImageInfo.height;

        gifinfo.LogicScreenWidth = currentImageInfo.width;
        gifinfo.LogicScreenHeight = currentImageInfo.height;
    }

    clippedCurrentImageInfo = currentImageInfo;

    // For animated (multi-framed) GIFs, we need possibly to expand the gifinfo
    // information to equal the rectangle of the first frame.  Store the
    // information if we are processing the first frame.

    if ( !bGifinfoFirstFrameDim && (currentframe == -1) )
    {
        gifinfoFirstFrameWidth = currentImageInfo.left + currentImageInfo.width;
        gifinfoFirstFrameHeight = currentImageInfo.top +currentImageInfo.height;
        bGifinfoFirstFrameDim = TRUE;
    }

    // We need to remember what the maximum bounds of all frames are in when we
    // have a multi-imaged GIF.

    if ( !bGifinfoMaxDim )
    {
        if ( gifinfoMaxWidth < currentImageInfo.left + currentImageInfo.width )
        {
            gifinfoMaxWidth = currentImageInfo.left + currentImageInfo.width;
        }

        if ( gifinfoMaxHeight < currentImageInfo.top + currentImageInfo.height )
        {
            gifinfoMaxHeight = currentImageInfo.top + currentImageInfo.height;
        }
    }

    // Crop the image to the gif's bounds

    if ( (currentImageInfo.top + currentImageInfo.height)
         > gifinfo.LogicScreenHeight )
    {
        if ( currentImageInfo.top > gifinfo.LogicScreenHeight )
        {
            clippedCurrentImageInfo.height = 0;
            clippedCurrentImageInfo.top = gifinfo.LogicScreenHeight;
        }
        else
        {
            clippedCurrentImageInfo.height = gifinfo.LogicScreenHeight
                                           - currentImageInfo.top;
        }
    }

    if ( (currentImageInfo.left + currentImageInfo.width)
         > gifinfo.LogicScreenWidth )
    {
        if ( currentImageInfo.left > gifinfo.LogicScreenWidth )
        {
            clippedCurrentImageInfo.width = 0;
            clippedCurrentImageInfo.left = gifinfo.LogicScreenWidth;
        }
        else
        {
            clippedCurrentImageInfo.width = gifinfo.LogicScreenWidth
                                          - currentImageInfo.left;
        }
    }

    // See comment at top of file for explanations of the gif cases

    INT gifstate;
    if ( !(currentImageInfo.interlaceflag) )
    {
        gifstate = 1;
    }
    else if ( dstImageInfo.Flags & SINKFLAG_MULTIPASS )
    {
        // Case 4 will not work correctly in animated gifs with transparency.

        if ( !(IsAnimatedGif || IsMultiImageGif) )
        {
            gifstate = 4;
        }
        else
        {
            gifstate = 3;
        }
    }
    else if ( !(dstImageInfo.Flags & SINKFLAG_TOPDOWN) )
    {
        gifstate = 2;
    }
    else
    {
        gifstate = 3;
    }

    // Setup color table for current frame

    BOOL fHasLocalPalette = (currentImageInfo.localcolortableflag) > 0;
    UINT uiLocalColorTableSize = 0;

    if ( fHasLocalPalette == TRUE )
    {
        // According to the GIF spec, the actual size of the color table equals
        // "raise 2 to the value of the LocalColorTableSize + 1"

        uiLocalColorTableSize = 1 << ((currentImageInfo.localcolortablesize)+1);
    }

    BYTE colorPaletteBuffer[offsetof(ColorPalette, Entries)
                            + sizeof(ARGB) * 256];
    ColorPalette*   pFrameColorTable = (ColorPalette*)&colorPaletteBuffer;

    pFrameColorTable->Count = uiLocalColorTableSize;

    hResult = SetFrameColorTable(fHasLocalPalette, pFrameColorTable);
    if ( FAILED(hResult) )
    {
        // We ran out of memory or out of data in the stream.

        WARNING(("GpGifCodec::ProcessImageChunk--SetFrameColorTable() failed"));
        return hResult;
    }

    if ( bNeedProcessData == FALSE )
    {
        // The caller just wants a framecount, not real processing
        // Skip code size, which is one byte and ignore the rest of the chunk.

        hResult = SeekThroughDataChunk(istream, 1);
        if ( FAILED(hResult) )
        {
            WARNING(("Gif::ProcessImageChunk--SeekThroughDataChunk failed"));
            return hResult;
        }

        return S_OK;
    }

    if ( sinkdata )
    {
        // Use the current frame color tabel as sink palette

        hResult = decodeSink->SetPalette(pFrameColorTable);
        if ( FAILED(hResult) )
        {
            WARNING(("GpGifCodec::ProcessImageChunk---SetPalette() failed"));
            return hResult;
        }
    }

    // ASSERT: At this point, the color palette for the current frame is
    // correct (including transparency).

    // Read the codesize from the file.  The GIF decoder needs this to begin.
    
    BYTE cLzwCodeSize;
    hResult = ReadFromStream(istream, &cLzwCodeSize, sizeof(BYTE), blocking);
    if ( FAILED(hResult) )
    {
        WARNING(("GpGifCodec::ProcessImageChunk -- 2nd ReadFromStream failed"));
        return hResult;
    }

    // Minimum code size should be within the range of 2 - 8

    if ( (cLzwCodeSize < 2) || (cLzwCodeSize > 8) )
    {
        WARNING(("GpGifCodec::ProcessImageChunk---Wrong code size"));
        return E_FAIL;
    }

    // Create a LZW decompressor object based on lzw code zie

    BYTE compresseddata[256];
    
    AutoPointer<LZWDecompressor> myLzwDecompressor;
    myLzwDecompressor = new LZWDecompressor(cLzwCodeSize);

    if ( myLzwDecompressor == NULL )
    {
        WARNING(("GpGifCodec::ProcessImageChunk-Can't create LZWDecompressor"));
        return E_OUTOFMEMORY;
    }

    // imagedatarect is the dimensions of the input image

    RECT imagedatarect = { currentImageInfo.left,
                           currentImageInfo.top,
                           currentImageInfo.left + currentImageInfo.width,
                           currentImageInfo.top + currentImageInfo.height
                         };

    // imagerect is the dimensions of the output image

    RECT imagerect = {0,
                      0,
                      gifinfo.LogicScreenWidth,
                      gifinfo.LogicScreenHeight
                     };

    // framerect is the rectangle in the entire image that the current frame is
    // drawing in

    RECT framerect = { clippedCurrentImageInfo.left,
                       clippedCurrentImageInfo.top,
                       clippedCurrentImageInfo.left
                            + clippedCurrentImageInfo.width,
                       clippedCurrentImageInfo.top
                            + clippedCurrentImageInfo.height
                     };

    // Get disposal method

    BYTE dispose = (lastgcevalid && GifFrameCachePtr)
                 ? lastgce.disposalmethod : 0;

    BOOL fUseTransparency = (IsAnimatedGif || IsMultiImageGif)
                        && (lastgcevalid && lastgce.transparentcolorflag);

    // Create a GIF buffer to store current frame

    AutoPointer<GifBuffer> gifbuffer;

    gifbuffer = new GifBuffer(decodeSink, 
                        imagedatarect,
                        imagerect,
                        framerect,
                        (gifstate == 1 || gifstate == 2) && sinkdata, 
                        dstImageInfo.PixelFormat, 
                        pFrameColorTable, 
                        fHasLocalPalette
                            || (lastgcevalid && (lastgce.transparentcolorflag)), 
                        GifFrameCachePtr, 
                        sinkdata, 
                        fUseTransparency, 
                        lastgce.transparentcolorindex, 
                        dispose);

    if ( gifbuffer == NULL )
    {
        WARNING(("GpGifCodec::ProcessImageChunk--could not create gifbuffer"));
        return E_OUTOFMEMORY;
    }

    if ( gifbuffer->IsValid() == FALSE )
    {
        WARNING(("GpGifCodec::ProcessImageChunk--could not create gifbuffer"));
        return E_FAIL;
    }

    // Check if we are at the first frame.
    // Note: GifFrameCachePtr is created in GpGifDecoder::DoDecode()

    if ( (GifFrameCachePtr != NULL) && (currentframe == -1) )
    {
        GifFrameCachePtr->InitializeCache();
    }

    if ( currentImageInfo.localcolortableflag && (GifFrameCachePtr != NULL) )
    {
        dstImageInfo.PixelFormat = GifFrameCachePtr->pixformat;
    }

    ASSERT(clippedCurrentImageInfo.top <= gifinfo.LogicScreenHeight);

    // If we are considering the first frame (currentframe == -1) and the image
    // is vertically larger than the current frame then pad the top. Later
    // frames will have the non-image part filled already (from previous frames)

    BOOL fNeedPadBorder = (currentframe == -1);

    if ( (fNeedPadBorder == TRUE) && (clippedCurrentImageInfo.top > 0) )
    {
        hResult = gifbuffer->PadScanLines(0, 
                                         clippedCurrentImageInfo.top - 1, 
                                         GetBackgroundColor());
        if ( FAILED(hResult) )
        {
            WARNING(("GpGifCodec::ProcessImageChunk -- PadScanLines failed."));
            return hResult;
        }
    }
    else if ( clippedCurrentImageInfo.top > 0 )
    {
        hResult = gifbuffer->SkipScanLines(0, clippedCurrentImageInfo.top - 1);
        if ( FAILED(hResult) )
        {
            WARNING(("GpGifCodec::ProcessImageChunk -- SkipScanLines failed."));
            return hResult;
        }
    }

    // NOTE: This buffer contains at least the image's width + 256 bytes which 
    // should be enough space for any GIF to overflow into.  I am not 
    // absolutely sure that this is the case but it works for all of the gifs 
    // that I have tested it against. [t-aaronl]
    // !!! New unscientific formula to allow more buffer space [dchinn, 11/5/99]

    UINT32 uiMmaxGifOverflow = currentImageInfo.width + 1024;

    AutoPointer<GifOverflow> myGifOverflow;
    myGifOverflow = new GifOverflow(uiMmaxGifOverflow);

    if ( myGifOverflow == NULL )
    {
        WARNING(("GpGifCodec::ProcessImageChunk--Create GifOverflow failed"));
        return E_OUTOFMEMORY;
    }

    if ( !myGifOverflow->IsValid() )
    {
        WARNING(("GifCodec::ProcessImageChunk-- Could not create gifoverflow"));
        return E_OUTOFMEMORY;
    }

    // Decompress the GIF.

    BOOL    fStillMoreData = TRUE;
    int     iCurrentOutPutLine = 0;
    
    // Decode image line by line

    while ( ( (fStillMoreData == TRUE) || myGifOverflow->inuse )
          &&(iCurrentOutPutLine < currentImageInfo.height) )
    {
        // Figure out which pass (out of four) the current line will/would be 
        // in if the GIF were interlaced.

        int iPass = WhichPass(iCurrentOutPutLine, currentImageInfo.height);

        int iLine = iCurrentOutPutLine;

        // If the image is interlaced then flip the line drawing order

        if ( gifstate != 1 )
        {
            iLine = TranslateInterlacedLine(iCurrentOutPutLine, 
                                            currentImageInfo.height, iPass);
        }

        // fReleaseLine is TRUE if and only if we actually will output the line
        // (If it is FALSE, then we consume input without rendering the line.)

        BOOL fReleaseLine = (iLine < clippedCurrentImageInfo.height);

        // Get output space (in myLzwDecompressor) if it is required

        if ( myLzwDecompressor->m_fNeedOutput == TRUE )
        {
            hResult = GetOutputSpace(iLine, 
                                     *gifbuffer, 
                                     *myLzwDecompressor, 
                                     *myGifOverflow, 
                                     currentImageInfo,
                                     clippedCurrentImageInfo,
                                     fNeedPadBorder);
            if ( FAILED(hResult) )
            {
                WARNING(("GifCodec::ProcessImageChunk--GetOutputSpace failed"));
                return hResult;
            }
        }

        // Check if we have the output space or not

        if ( NULL == myLzwDecompressor->m_pbOut )
        {
            WARNING(("GpGifCodec::ProcessImageChunk---Output buffer is null"));
            return E_OUTOFMEMORY;
        }

        // Check if the decompressor needs more input

        if ( myLzwDecompressor->m_fNeedInput == TRUE )
        {
            // Get more compressed data from the source
            // Note: Here "compressddata" is a buffer of size 256 BYTEs. It will
            // be used in GetCompressedData() and the address will be assigned
            // to myLzwDecompressor->m_pbIn;

            hResult = GetCompressedData(*myLzwDecompressor, 
                                        compresseddata, 
                                        fStillMoreData);

            // If the read failed or the next data chunk size is 0, stop reading
            // here. But before that, we need to pad the missing lines

            if ( (FAILED(hResult)) || (myLzwDecompressor->m_cbIn == 0) )
            {
                WARNING(("Gif::ProcessImageChunk--GetCompressedData failed"));
                fStillMoreData = FALSE;
                if ( fReleaseLine )
                {
                    // See ASSERT at the next call to ConvertBufferToARGB()
                    // below.

                    if ( dstImageInfo.PixelFormat == PIXFMT_32BPP_ARGB )
                    {
                        gifbuffer->ConvertBufferToARGB();
                    }

                    gifbuffer->ReleaseBuffer(fNeedPadBorder,
                                            GetBackgroundColor(),
                                            clippedCurrentImageInfo.top + iLine,
                                            FALSE,
                                            FALSE);
                }

                // Pad from next line (line + 1) to the end f current frame.
                // Note: we also need to take care of the offset for current
                // frame (clippedCurrentImageInfo.top).
                // Also, "currentImageInfo.height" is the total row number. Our
                // image starts at row 0, that is, we need this "-1"
#if 0
                hResult = gifbuffer->PadScanLines(clippedCurrentImageInfo.top
                                                  + iLine + 1,
                                                 clippedCurrentImageInfo.top
                                                  + currentImageInfo.height - 1,
                                                 GetBackgroundColor());

                // Now skip the rest of the logical screen area

                hResult = gifbuffer->SkipScanLines(clippedCurrentImageInfo.top
                                               + clippedCurrentImageInfo.height,
                                                  gifinfo.height - 1);
#else
                hResult = gifbuffer->SkipScanLines(clippedCurrentImageInfo.top
                                                  + iLine + 1,
                                                  gifinfo.LogicScreenHeight- 1);

#endif
                if ( FAILED(hResult) )
                {
                    WARNING(("ProcessImageChunk--SkipScanLines() failed."));
                    return hResult;
                }
                
                // Release everything we have in the buffer to the sink

//                hResult = gifbuffer->ReleaseBuffer(FALSE, 0, 0, FALSE, FALSE);
                hResult = gifbuffer->FinishFrame();

                WARNING(("ProcessImageC-return abnormal because missing bits"));
                return hResult;
            }
        }// (m_fNeedInput == TRUE)

        // Decompress the available lzw data
        // Note: FProcess() returns false when it reaches EOD or an error

        if ( myLzwDecompressor->FProcess() == NULL )
        {                                 
            fStillMoreData = FALSE;
        }

        // If one row is decompressed and the decoder is in multipass mode then 
        // sink the line

        if ( (myLzwDecompressor->m_cbOut == 0)
           ||( (myGifOverflow->inuse == TRUE)
             &&(((static_cast<int>(uiMmaxGifOverflow)
                  - myLzwDecompressor->m_cbOut) - myGifOverflow->needed) > 0)))
        {
            // Anytime the output buffer is full then we need more output space

            myLzwDecompressor->m_fNeedOutput = TRUE;

            if ( myGifOverflow->inuse == TRUE )
            {
                if ( myGifOverflow->needed != 0 )
                {
                    BYTE*   pScanline = NULL;
                    if ( fReleaseLine == TRUE )
                    {
                        pScanline = gifbuffer->GetCurrentBuffer();
                    }
                    else
                    {
                        pScanline = gifbuffer->GetExcessBuffer();
                    }

                    GpMemcpy(pScanline + (currentImageInfo.width
                                         - myGifOverflow->needed), 
                             myGifOverflow->buffer, myGifOverflow->needed);

                    myGifOverflow->by = uiMmaxGifOverflow
                                     - myLzwDecompressor->m_cbOut
                                     - myGifOverflow->needed;
                }
                else
                {
                    myLzwDecompressor->m_pbOut = 
                                         (unsigned __int8*)myGifOverflow->buffer
                                              + myGifOverflow->by;
                    myLzwDecompressor->m_cbOut = uiMmaxGifOverflow
                                              - myGifOverflow->by;
                }
            }

            if ( gifstate == 4 )
            {
                if ( fReleaseLine == TRUE )
                {
                    for ( INT i = 0; i < NumRowsInPass(iPass) - 1; i++ )
                    {
                        // CopyLine() makes a copy of the current line, releases
                        // it, gets the next line and puts the data from the
                        // first line into the new one.  The new one still needs
                        // to be released.

                        hResult = gifbuffer->CopyLine();
                        if ( FAILED(hResult) )
                        {
                            WARNING(("ProcessImageC--.CopyLine() failed."));
                            return hResult;
                        }
                    }
                }
            }

            if ( fReleaseLine == TRUE )
            {
                // ASSERT: gifbuffer now contains the indexes of colors in the
                // framerect of the current frame for the current scanline. If
                // the pixel format is 8BPP_INDEXED, then the entire scanline is
                // 8BPP values, and so we need not do anything more. However, if
                // the pixel format is 32BPP_ARGB, then we need to convert the
                // indexes to ARGB values and then fill in the left and right
                // margins of the scanline (outside of the framerect) with ARGB
                // values from the GifFrameCachePtr (which will be true only if the
                // GIF is animated).

                if ( dstImageInfo.PixelFormat == PIXFMT_32BPP_ARGB )
                {
                    gifbuffer->ConvertBufferToARGB();
                }
    
                hResult = gifbuffer->ReleaseBuffer(fNeedPadBorder,
                                                  GetBackgroundColor(),
                                                  clippedCurrentImageInfo.top
                                                    + iLine,
                                                  FALSE,
                                                  FALSE);
                if ( FAILED(hResult) )
                {
                    WARNING(("ProcessImageChunk--ReleaseBuffer() failed."));
                    return hResult;
                }
            }

            iCurrentOutPutLine++;
        }
        else
        {
            // An infinite cycle arises when the decompressor needs more output 
            // space to finish the current row than is available.  So, we give 
            // the decompressor an extra row of 'myGifOverflow' buffer.

            if ( myLzwDecompressor->m_fNeedOutput )
            {
                // make sure that the outputbuffer and the myGifOverflow buffer
                // are not both full while the decompressor needs more data.

                if ( myGifOverflow->inuse )
                {
                    // If this happens then the output buffer needs to increase 
                    // in size (maxgifoverflow).  I don't expect this to occur.

                    WARNING(("Output buf and myGifOverflow buf are both full"));
                    return E_FAIL;
                }
                else
                {
                    myGifOverflow->needed = myLzwDecompressor->m_cbOut;
                    myLzwDecompressor->m_pbOut =
                                    (unsigned __int8*)myGifOverflow->buffer;
                    myLzwDecompressor->m_cbOut = uiMmaxGifOverflow;
                    myGifOverflow->inuse = TRUE;
                    myLzwDecompressor->m_fNeedOutput = FALSE;
                }
            }
        }            

        // If a pass (other than the last pass) is complete in a multipass mode 
        // then sink that pass.

        if ( (gifstate == 4) && (iPass != WhichPass(iCurrentOutPutLine, 
                                                    currentImageInfo.height)) )
        {
            if ( fReleaseLine )
            {
                hResult = gifbuffer->FinishFrame(FALSE);
                if ( FAILED(hResult) )
                {
                    WARNING(("ProcessImageChunk--FinishFrame() failed."));
                    return hResult;
                }
            }
        }
    } // the main while loop

    // If we are considering the first frame (currentframe == -1) and the image
    // is vertically larger than the current frame then pad the bottom.  Later
    // frames will have the non-image part filled already (from previous frames)

    if ( (fNeedPadBorder == TRUE )
      &&( (clippedCurrentImageInfo.top + clippedCurrentImageInfo.height)
           < gifinfo.LogicScreenHeight) )
    {
        hResult = gifbuffer->PadScanLines(clippedCurrentImageInfo.top
                                          + clippedCurrentImageInfo.height,
                                         gifinfo.LogicScreenHeight - 1, 
                                         GetBackgroundColor());
        if ( FAILED(hResult) )
        {
            WARNING(("GpGifCodec::ProcessImageChunk -- PadScanLines failed."));
            return hResult;
        }
    }
    else if ( (clippedCurrentImageInfo.top + clippedCurrentImageInfo.height)
               < gifinfo.LogicScreenHeight)
    {
        hResult = gifbuffer->SkipScanLines(clippedCurrentImageInfo.top
                                           + clippedCurrentImageInfo.height,
                                          gifinfo.LogicScreenHeight - 1);
        if ( FAILED(hResult) )
        {
            WARNING(("GpGifCodec::ProcessImageChunk -- SkipScanLines failed."));
            return hResult;
        }
    }

    hResult = gifbuffer->FinishFrame();
    if ( FAILED(hResult) )
    {
        WARNING(("GpGif::ProcessImageChunk--gifbuffer->FinishFrame() failed."));
        return hResult;
    }

    lastgcevalid = FALSE;
    
    return S_OK;
}// ProcessImageChunk()

/**************************************************************************\
*
* Function Description:
*
*     Process the graphic control chunks for a gif stream.
*
* Arguments:
*
*     none
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::ProcessGraphicControlChunk(
    IN BOOL process
    )
{
    GifGraphicControlExtension gce;
    HRESULT hResult = ReadFromStream(istream, &gce, 
                                     sizeof(GifGraphicControlExtension),
                                     blocking);
    
    if ( gce.delaytime > 0 )
    {
        FrameDelay = gce.delaytime;
    }

    // If we are applying the gce to the next frame, then save it in lastgce.
    // Otherwise, we are just reading through the bytes without using them.
    
    lastgce = gce;

    // Set the correct alpha flag if the image has transparency info

    if ( lastgce.transparentcolorflag )
    {
        CachedImageInfo.Flags   |= SINKFLAG_HASALPHA;
    }

    if (process)
    {
        if (SUCCEEDED(hResult))
        {
            lastgcevalid = TRUE;
        }

        // It is possible that the gifframe cache has already been initialized
        // before reading a GCE that will be used for the next frame.  The
        // background color of the GifFrameCachePtr is influenced by the lastgce
        // (This is because of Office's definition of the background color --
        // the GIF spec says nothing about using the transparency index in the
        // lastgce to determine the background color.)
        // In that case, we need to update the GifFrameCachePtr's background color.
        
        if (GifFrameCachePtr && lastgce.transparentcolorflag)
        {
            GifFrameCachePtr->SetBackgroundColorIndex(
                                                lastgce.transparentcolorindex);
        }
    }

    return hResult;
}// ProcessGraphicControlChunk()

/**************************************************************************\
*
* Function Description:
*
*     Process the comment chunks for a gif stream.
*
* Arguments:
*
*     none
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::ProcessCommentChunk(
    IN BOOL process
    )
{
    if ( HasProcessedPropertyItem == TRUE )
    {
        // We don't need to parse this chunk, just seek it out

        return SeekThroughDataChunk(istream, 0);
    }

    // Figure out the block size first

    BYTE cBlockSize;

    HRESULT hResult = ReadFromStream(istream, &cBlockSize, sizeof(BYTE),
                                     blocking);
    if ( FAILED(hResult) )
    {
        WARNING(("GpGifCodec::ProcessCommentChunk--ReadFromStream failed"));
        return hResult;
    }

    // Keep reading data subblocks until we reach a terminator block (0x00)

    while ( cBlockSize )
    {
        BYTE*   pBuffer = (BYTE*)GpMalloc(cBlockSize);
        if ( pBuffer == NULL )
        {
            WARNING(("GpGifCodec::ProcessCommentChunk--out of memory"));
            return E_OUTOFMEMORY;
        }

        // Read in the comments chunk

        hResult = ReadFromStream(istream, pBuffer, cBlockSize, blocking);

        if ( FAILED(hResult) )
        {
            WARNING(("GpGifCodec::ProcessCommentChunk--ReadFromStream failed"));
            return hResult;
        }
        
        // Append to the comments buffer

        VOID*  pExpandBuf = GpRealloc(CommentsBufferPtr,
                                      CommentsBufferLength + cBlockSize);
        if ( pExpandBuf != NULL )
        {
            // Note: GpRealloc() will copy the old contents to the new expanded
            // buffer before return if it succeed.
            
            CommentsBufferPtr = (BYTE*)pExpandBuf;            
        }
        else
        {
            // Note: if the memory expansion failed, we simply return. So we
            // still have all the old contents. The contents buffer will be
            // freed when the destructor is called.

            WARNING(("GpGifCodec::ProcessCommentChunk--out of memory2"));
            return E_OUTOFMEMORY;
        }
        
        GpMemcpy(CommentsBufferPtr + CommentsBufferLength, pBuffer, cBlockSize);
        CommentsBufferLength += cBlockSize;

        GpFree(pBuffer);

        // Get the next block size

        hResult = ReadFromStream(istream, &cBlockSize, sizeof(BYTE), blocking);
        if ( FAILED(hResult) )
        {
            WARNING(("GpGifCodec::ProcessCommentChunk-ReadFromStream2 failed"));
            return hResult;
        }
    }

    return S_OK;
}// ProcessCommentChunk()

/**************************************************************************\
*
* Function Description:
*
*     Process the plain text chunks for a gif stream.
*
* Arguments:
*
*     none
*
* Return Value:
*
*   Status code
*
* TODO: Currently ignores plain text
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::ProcessPlainTextChunk(
    IN BOOL process
    )
{
    return SeekThroughDataChunk(istream, GIFPLAINTEXTEXTENSIONSIZE);
}// ProcessPlainTextChunk()

/**************************************************************************\
*
* Function Description:
*
*     Process the application chunks for a gif stream.
*
* Arguments:
*
*     none
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::ProcessApplicationChunk(
    IN BOOL process
    )
{
    HRESULT hResult = S_OK;

    BYTE extsize;
    BYTE header[GIFAPPEXTENSIONHEADERSIZE];

    hResult = ReadFromStream(istream, &extsize, 1, blocking);
    if (FAILED(hResult))
    {
        WARNING(("GpGif::ProcessApplicationChunk--1st ReadFromStream failed."));
        return hResult;
    }

    if (extsize != GIFAPPEXTENSIONHEADERSIZE)
    {
        return SeekThroughDataChunk(istream, extsize);
    }

    hResult = ReadFromStream(istream, header, extsize, blocking);
    if (FAILED(hResult))
    {
        WARNING(("GpGif::ProcessApplicationChunk--2nd ReadFromStream failed"));
        return hResult;
    }

    // Check if this image has an application extension

    if (!GpMemcmp(header, "NETSCAPE2.0", 11) || 
        !GpMemcmp(header, "ANIMEXTS1.0", 11))
    {
        // We see the application extension

        BYTE ucLoopType;
        hResult = ReadFromStream(istream, &extsize, 1, blocking);
        if (FAILED(hResult))
        {
            WARNING(("Gif:ProcessApplicationChunk--3rd ReadFromStream failed"));
            return hResult;
        }

        if (extsize > 0)
        {
            hResult = ReadFromStream(istream, &ucLoopType, 1, blocking);
            if (FAILED(hResult))
            {
                WARNING(("ProcessApplicationChunk--4th ReadFromStream failed"));
                return hResult;
            }

            if ( ucLoopType == 1 )
            {
                // This image has a loop extension. A loop type == 1 indicates
                // this is an animated GIF

                HasLoopExtension = TRUE;

                hResult = ReadFromStream(istream, &LoopCount, 2, blocking);
                if (FAILED(hResult))
                {
                    WARNING(("ProcessApplicationChunk--5th ReadStream failed"));
                    return hResult;
                }

                //If loop count is 0 the image loops forever but we want 
                //loop count to be -1 if the image loops forever
                
                INT lc = (INT)LoopCount;
                if (lc == 0)
                {
                    lc = -1;
                }
            }
            else
            {
                // If the loop type is not 1, ignore the loop count.
                // ??? Should be +2

                return SeekThroughDataChunk(istream, -2);
            }
        }
    }
    else
    {
        // Unknown application chunk, just seek through

        hResult = SeekThroughDataChunk(istream, 0);
        if ( FAILED(hResult) )
        {
            WARNING(("ProcessApplicationChunk ---SeekThroughDataChunk failed"));
            return hResult;
        }
    }
    
    return S_OK;
}// ProcessApplicationChunk

/**************************************************************************\
*
* Function Description:
*
*     Positions the seek pointer in a stream after the following data sub 
*     blocks.
*
* Arguments:
*
*     stream to perform the operation in.
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::SeekThroughDataChunk(
    IN IStream* istream,
    IN BYTE     headersize
    )
{
    HRESULT hResult;

    // If headersize != 0, reposition the stream pointer by headersize bytes

    if (headersize)
    {
        hResult = SeekThroughStream(istream, headersize, blocking);
        if (FAILED(hResult))
        {
            WARNING(("Gif::SeekThroughDataChunk-1st SeekThroughStream failed"));
            return hResult;
        }
    }

    BYTE subblocksize;

    hResult = ReadFromStream(istream, &subblocksize, sizeof(BYTE), blocking);
    if (FAILED(hResult))
    {
        WARNING(("GifCodec::SeekThroughDataChunk --1st ReadFromStream failed"));
        return hResult;
    }

    // Keep reading data subblocks until we reach a terminator block (0x00)
    
    while (subblocksize)
    {
        hResult = SeekThroughStream(istream, subblocksize, blocking);
        
        if (FAILED(hResult))
        {
            WARNING(("Gif:SeekThroughDataChunk--2nd SeekThroughStream failed"));
            return hResult;
        }

        hResult = ReadFromStream(istream, &subblocksize, sizeof(BYTE),
                                 blocking);
        if ( FAILED(hResult) )
        {
            WARNING(("GpGif::SeekThroughDataChunk--2nd ReadFromStream failed"));
            return hResult;
        }
    }

    return S_OK;
}// SeekThroughDataChunk()

/**************************************************************************\
*
* Function Description:
*
*     Gets the current location in the datastream
*
* Arguments:
*
*     markpos - place to put the current location
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::MarkStream(
    IN IStream *istream,
    OUT LONGLONG &markpos
    )
{
    HRESULT hResult;    
    LARGE_INTEGER li;
    ULARGE_INTEGER uli;

    li.QuadPart = 0;
    hResult = istream->Seek(li, STREAM_SEEK_CUR, &uli);
    if (FAILED(hResult))
    {
        WARNING(("GpGifCodec::MarkStream -- Seek failed."));
        return hResult;
    }
    markpos = uli.QuadPart;

    return S_OK;
}// MarkStream()

/**************************************************************************\
*
* Function Description:
*
*     Seeks to a specified location in the datastream
*
* Arguments:
*
*     markpos - the location to seek to
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::ResetStream(
    IN IStream *istream,
    IN LONGLONG &markpos
    )
{
    HRESULT hResult;
    LARGE_INTEGER li;

    li.QuadPart = markpos;
    hResult = istream->Seek(li, STREAM_SEEK_SET, NULL);
    if (FAILED(hResult))
    {
        WARNING(("GpGifCodec::ResetStream -- Seek failed."));
        return hResult;
    }

    return S_OK;
}// ResetStream()

/**************************************************************************\
*
* Function Description:
*
*     Writes the gif palette to the output stream.
*
* Arguments:
*
*     none
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::WritePalette()
{
    HRESULT hResult;
    DWORD actualwritten;

    for (DWORD i=0;i<colorpalette->Count;i++)
    {
        BYTE *argb = (BYTE*)&colorpalette->Entries[i];
        GifPaletteEntry gpe;
        gpe.red = argb[2]; gpe.green = argb[1]; gpe.blue = argb[0];
        hResult = istream->Write((BYTE*)&gpe, sizeof(GifPaletteEntry), 
            &actualwritten);
        if (FAILED(hResult) || actualwritten != sizeof(GifPaletteEntry))
        {
            WARNING(("GpGifCodec::WritePalette -- Write failed."));
            return hResult;
        }
    }

    return S_OK;
}// WritePalette()

/**************************************************************************\
*
* Function Description:
*
*     Writes the gif file header to the output stream.
*
* Arguments:
*
*     imageinfo - structure which contains the info that needs to be written 
*         to the header.
*     from32bpp - flag to indicate whether the data is coming from a 32bpp 
*         data source
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::WriteGifHeader(
    IN ImageInfo    &imageinfo,
    IN BOOL         from32bpp
    )
{
    HRESULT hResult;
    GifFileHeader dstGifInfo;
    DWORD actualwritten;

    if (!gif89)
    {
        GpMemcpy(dstGifInfo.signature, "GIF87a", 6);
    }
    else
    {
        GpMemcpy(dstGifInfo.signature, "GIF89a", 6);
    }

    ASSERT(imageinfo.Width < 0x10000 &&
           imageinfo.Height < 0x10000);

    dstGifInfo.LogicScreenWidth = (WORD)imageinfo.Width;
    dstGifInfo.LogicScreenHeight = (WORD)imageinfo.Height;

    if (from32bpp)
    {
        dstGifInfo.globalcolortableflag = 1;
        dstGifInfo.colorresolution = 7;
        dstGifInfo.sortflag = 0;
        dstGifInfo.globalcolortablesize = 7;
    }
    else
    {
        ASSERT(colorpalette);
        dstGifInfo.globalcolortableflag = 1;
        dstGifInfo.colorresolution = 7;
        dstGifInfo.sortflag = 0;
        dstGifInfo.globalcolortablesize = 
            (BYTE)(log((double)colorpalette->Count-1) / log((double)2));
    }
    //TODO: set backgroundcolor from metadata

    dstGifInfo.backgroundcolor = 0;

    //TODO: calculate pixelaspect

    dstGifInfo.pixelaspect = 0;
    
    hResult = istream->Write(&dstGifInfo, sizeof(GifFileHeader),
                             &actualwritten);
    if (FAILED(hResult) || actualwritten != sizeof(GifFileHeader))
    {
        WARNING(("GpGifCodec::WriteGifHeader -- Write failed."));
        return hResult;
    }

    return S_OK;
}// WriteGifHeader()

/**************************************************************************\
*
* Function Description:
*
*     Writes a gif graphics control extension to the output stream.
*
* Arguments:
*
*     packedFields -- packed fields field of the gce
*     delayTime    -- delay time field of the gce
*     transparentColorIndex -- transparent color index field of the gce
*
* Return Value:
*
*     Status code
*
\**************************************************************************/
STDMETHODIMP
GpGifCodec::WriteGifGraphicControlExtension(
    IN BYTE packedFields,
    IN WORD delayTime,
    IN UINT transparentColorIndex
    )
{
    BYTE gceChunk[3] = {0x21, 0xF9, 0x04};  // gce chunk marker + block size
    BYTE blockTerminator = 0x00;
    HRESULT hResult;
    DWORD actualwritten;

    hResult = istream->Write(gceChunk, 3, &actualwritten);
    if (FAILED(hResult) || actualwritten != 3)
    {
        WARNING(("GpGifCodec::WriteGifImageDescriptor -- 1st Write failed."));
        return hResult;
    }

    hResult = istream->Write(&packedFields, sizeof(BYTE), &actualwritten);
    if (FAILED(hResult) || actualwritten != sizeof(BYTE))
    {
        WARNING(("GpGifCodec::WriteGifImageDescriptor -- 2nd Write failed."));
        return hResult;
    }

    hResult = istream->Write(&delayTime, sizeof(WORD), &actualwritten);
    if (FAILED(hResult) || actualwritten != sizeof(WORD))
    {
        WARNING(("GpGifCodec::WriteGifImageDescriptor -- 3rd Write failed."));
        return hResult;
    }

    hResult = istream->Write(&transparentColorIndex, sizeof(BYTE),
                             &actualwritten);
    if (FAILED(hResult) || actualwritten != sizeof(BYTE))
    {
        WARNING(("GpGifCodec::WriteGifImageDescriptor -- 4th Write failed."));
        return hResult;
    }

    hResult = istream->Write(&blockTerminator, sizeof(BYTE), &actualwritten);
    if (FAILED(hResult) || actualwritten != sizeof(BYTE))
    {
        WARNING(("GpGifCodec::WriteGifImageDescriptor -- fifth Write failed."));
        return hResult;
    }

    return S_OK;
}// WriteGifGraphicControlExtension()

/**************************************************************************\
*
* Function Description:
*
*     Writes the gif image descriptor to the output stream.
*
* Arguments:
*
*     imageinfo - structure which contains the info that needs to be written 
*         to the header.
*     from32bpp - flag to indicate whether the data is coming from a 32bpp 
*         data source
*
* Return Value:
*
*     Status code
*
\**************************************************************************/


STDMETHODIMP
GpGifCodec::WriteGifImageDescriptor(
    IN ImageInfo &imageinfo,
    IN BOOL from32bpp
    )
{
    HRESULT hResult;
    DWORD actualwritten;
    GifImageDescriptor imagedescriptor;

    ASSERT(imageinfo.Width < 0x10000 && 
           imageinfo.Height < 0x10000);

    imagedescriptor.left = 0;
    imagedescriptor.top = 0;
    imagedescriptor.width = (WORD) imageinfo.Width;
    imagedescriptor.height = (WORD) imageinfo.Height;
    
    //TODO: local color table from properties
    
    imagedescriptor.localcolortableflag = 0;
    imagedescriptor.interlaceflag = interlaced ? 1 : 0;
    imagedescriptor.sortflag = 0;
    imagedescriptor.reserved = 0;
    imagedescriptor.localcolortablesize = 0;

    BYTE c = 0x2C;  //GifImageDescriptor chunk marker
    hResult = istream->Write(&c, sizeof(BYTE), &actualwritten);
    if (FAILED(hResult) || actualwritten != sizeof(BYTE))
    {
        WARNING(("GpGifCodec::WriteGifImageDescriptor -- 1st Write failed."));
        return hResult;
    }

    hResult = istream->Write(&imagedescriptor, sizeof(GifImageDescriptor), 
        &actualwritten);
    if (FAILED(hResult) || actualwritten != sizeof(GifImageDescriptor))
    {
        WARNING(("GpGifCodec::WriteGifImageDescriptor -- 2nd Write failed."));
        return hResult;
    }

    return S_OK;
}// WriteGifImageDescriptor()

/**************************************************************************\
*
* Function Description:
*
*     Takes a buffer to uncompressed indexed image data and compresses it.
*
* Arguments:
*
*     none
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::CompressAndWriteImage()
{
    HRESULT hResult = S_OK;
    DWORD actualwritten;

    int bytesinoutput = 0;
    DWORD colorbits = (DWORD)(log((double)colorpalette->Count-1)
                            / log((double)2)) + 1;
    const int outbuffersize = 4096;
    AutoArray<unsigned __int8> outbuffer(new unsigned __int8 [outbuffersize]);

    if ( outbuffer == NULL )
    {
        WARNING(("GifCodec:CompressAndWriteImage-Failed create outbuffer"));
        return E_OUTOFMEMORY;
    }

    //Create the compressor

    AutoPointer<LZWCompressor> compressor;
    compressor = new LZWCompressor(colorbits, outbuffer.Get(), &bytesinoutput,
                                   outbuffersize);
    if ( compressor == NULL )
    {
        WARNING(("GifCodec:CompressAndWriteImage-Failed create LZWCompressor"));
        return E_OUTOFMEMORY;
    }

    compressor->DoDefer(FALSE);

    //bytesininput is the number of uncompressed bytes we have.
    
    DWORD bytesininput = (encoderrect.right - encoderrect.left)
                       * (encoderrect.bottom - encoderrect.top);

    // i is the number of uncompressed bytes we have processed.
    
    DWORD i = 0;

    while (i < bytesininput)
    {
        //Send one uncompressed character to the compressor at a time.
        
        compressor->FHandleCh((DWORD)((unsigned __int8*)compressionbuffer)[i]);

        //When the buffer is almost full then write it out.
        //Leave the buffer with a little extra because the compressor requires 
        //it.
        
        if (bytesinoutput + compressor->COutput() + 64 > outbuffersize)
        {
            hResult = istream->Write(outbuffer.Get(), bytesinoutput, &actualwritten);
            if (FAILED(hResult) || actualwritten != (unsigned)bytesinoutput)
            {
                WARNING(("GifCodec::CompressAndWriteImage--1st Write failed"));
                return hResult;
            }

            for (int j=0;j<compressor->COutput();j++)
            {
                outbuffer[j] = outbuffer[j+bytesinoutput];
            }

            bytesinoutput = 0;
        }
        
        i++;
    }
    compressor->End();
    hResult = istream->Write(outbuffer.Get(), bytesinoutput, &actualwritten);
    if (FAILED(hResult) || actualwritten != (unsigned)bytesinoutput)
    {
        WARNING(("GpGifCodec::CompressAndWriteImage -- 2nd Write failed."));
        return hResult;
    }

    return S_OK;
}// CompressAndWriteImage()

/**************************************************************************\
*
* Function Description:
*
*     Writes an image to the output stream (along with gif headers, if they 
*     have not yet been written.)
*
* Arguments:
*
*     none
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

STDMETHODIMP
GpGifCodec::WriteImage()
{
    HRESULT hResult;

    if (from32bpp)
    {
        //If the image is in 32bppARGB then we need to dither it down to 8bpp.

        unsigned __int8* halftonebuffer = compressionbuffer;
        int width = (encoderrect.right-encoderrect.left);
        int height = (encoderrect.bottom-encoderrect.top);
        int numbytes = width * height;

        compressionbuffer = static_cast<unsigned __int8 *>(GpMalloc(numbytes));
        if (compressionbuffer == NULL)
        {
            WARNING(("GpGifCodec::WriteImage -- Out of memory"));
            return E_OUTOFMEMORY;
        }

        Halftone32bppTo8bpp((BYTE*)halftonebuffer, width * 4, 
                            (BYTE*)compressionbuffer, width, 
                            width, height, 0, 0);

        GpFree(halftonebuffer);
        halftonebuffer = NULL;
    }
    
    //If the image headers have not yet been written then write them out now.
    
    gif89 = FALSE;
    if (!headerwritten)
    {
        //TODO: set gif89 to true if the gif is animated (has delay > 0).  
        //Need metadata for this.
        
        gif89 = TRUE;

        if (from32bpp)
        {
            SetPalette(GetDefaultColorPalette(PIXFMT_8BPP_INDEXED));
        }

        hResult = WriteGifHeader(CachedImageInfo, from32bpp);
        if (FAILED(hResult))
        {
            WARNING(("GpGifCodec::WriteImage -- WriteGifHeader failed."));
            return hResult;
        }
        headerwritten = TRUE;

        hResult = WritePalette();
        if (FAILED(hResult))
        {
            WARNING(("GpGifCodec::WriteImage -- WritePalette failed."));
            return hResult;
        }
    }

    // write gce if needed
    
    if (bTransparentColorIndex)
    {
        hResult = WriteGifGraphicControlExtension(static_cast<BYTE>(0x01),
                                                  0,
                                                  transparentColorIndex);
        if (FAILED(hResult))
        {
            WARNING(("Gif:WriteImage-WriteGifGraphicsControlExtension failed"));
            return hResult;
        }
    }

    hResult = WriteGifImageDescriptor(CachedImageInfo, from32bpp);
    if (FAILED(hResult))
    {
        WARNING(("GpGifCodec::WriteImage -- WriteGifImageDescriptor failed."));
        return hResult;
    }

    CompressAndWriteImage();

    GpFree(compressionbuffer);
    compressionbuffer = NULL;

    return S_OK;
}// WriteImage()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\gif\dll\gifutils.cpp ===
#include "precomp.hpp"
#include "imgutils.cpp"
#include "colorpal.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\gif\gifoverflow.hpp ===
#pragma once

/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   gifoverflow.hpp
*
* Abstract:
*
*   It is possible (and likely) that while processing data, the decompressor
*   will want to write a large chunk of data to the output buffer while there
*   is only a small amount of space left.  This occurs near the end of some
*   scanlines.  The solution is to create an overflow buffer that is switched
*   with the output buffer so that the decompressor has plenty of room to write
*   into.  The data that is needed to complete the original scanline is then
*   copied over from the overflow buffer to the output buffer.
*
* Revision History:
*
*   7/7/1999 t-aaronl
*       Created it.
*
\**************************************************************************/


class GifOverflow
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagGifOverflow : ObjectTagInvalid;
    }

public:
    GifOverflow(INT buffersize)
    {
        buffer = (BYTE*)GpMalloc(buffersize);
        SetValid(buffer != NULL);
        inuse = FALSE;
        needed = 0;
        by = 0;
    }

    ~GifOverflow()
    {
        GpFree(buffer);
        buffer = NULL;
        SetValid(FALSE);    // so we don't use a deleted object
    }

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagGifOverflow) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid GifOverflow");
        }
    #endif

        return (Tag == ObjectTagGifOverflow);
    }

    BOOL inuse;
    BYTE *buffer;
    int needed;  //how much buffer space is needed to overflow into
    int by;  //how much extra buffer space was used when the last line was
             //processed

private:
    INT buffersize;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\gif\dll\dllentry.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   dllentry.cpp
*
* Abstract:
*
*   Description of what this module does.
*
* Revision History:
*
*   05/10/1999 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "gifcodec.hpp"
#include "gifconst.cpp"

//
// DLL instance handle
//

extern HINSTANCE DllInstance;

//
// Global COM component count
//

LONG ComComponentCount;


/**************************************************************************\
*
* Function Description:
*
*   DLL entrypoint
*
* Arguments:
* Return Value:
*
*   See Win32 SDK documentation
*
\**************************************************************************/

extern "C" BOOL
DllEntryPoint(
    HINSTANCE   dllHandle,
    DWORD       reason,
    CONTEXT*    reserved
    )
{
    BOOL ret = TRUE;
    
    switch (reason)
    {
    case DLL_PROCESS_ATTACH:

        // To improve the working set, we tell the system we don't
        // want any DLL_THREAD_ATTACH calls

        DllInstance = dllHandle;
        DisableThreadLibraryCalls(dllHandle);

        __try
        {
            GpMallocTrackingCriticalSection::InitializeCriticalSection();  
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            // We couldn't allocate the criticalSection
            // Return an error
            ret = FALSE;
        }
        
        if (ret)
        {
            ret = GpRuntime::Initialize();
        }
        break;

    case DLL_PROCESS_DETACH:
        GpRuntime::Uninitialize();
        break;
    }

    return ret;
}


/**************************************************************************\
*
* Function Description:
*
*   Determine whether the DLL can be safely unloaded
*   See Win32 SDK documentation for more details.
*
\**************************************************************************/

STDAPI
DllCanUnloadNow()
{
    return (ComComponentCount == 0) ? S_OK : S_FALSE;
}


/**************************************************************************\
*
* Function Description:
*
*   Retrieves a class factory object from a DLL.
*   See Win32 SDK documentation for more details.
*
\**************************************************************************/

typedef IClassFactoryBase<GpGifCodec> GpGifCodecFactory;

STDAPI
DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    VOID** ppv
    )
{
    if (rclsid != GifCodecClsID)
        return CLASS_E_CLASSNOTAVAILABLE;

    GpGifCodecFactory* factory = new GpGifCodecFactory();

    if (factory == NULL)
        return E_OUTOFMEMORY;

    HRESULT hr = factory->QueryInterface(riid, ppv);
    factory->Release();

    return hr;
}


/**************************************************************************\
*
* Function Description:
*
*   Register/unregister our COM component
*   See Win32 SDK documentation for more details.
*
\**************************************************************************/

static const ComComponentRegData ComRegData =
{
    &GifCodecClsID,
    L"GIF Decoder / Encoder 1.0",
    L"imaging.GifCodec.1",
    L"imaging.GifCodec",
    L"Both"
};


// !!! TODO
//  These strings should come out of the resource.
//  Use hard-coded strings for now.

const WCHAR GifCodecName[] = L"GIF Decoder / Encoder";
const WCHAR GifDllName[] = L"G:\\sd6nt\\windows\\AdvCore\\gdiplus\\Engine\\imaging\\gif\\dll\\objd\\i386\\gifcodec.dll";
const WCHAR GifFormatDescription[] = L"Graphics Interchange Format";
const WCHAR GifFilenameExtension[] = L"*.GIF";
const WCHAR GifMimeType[] = L"image/gif";

// Create an instance of ImagingFactory object

inline HRESULT
GetImagingFactory(
    IImagingFactory** imgfact
    )
{
    return CoCreateInstance(
                CLSID_ImagingFactory,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IImagingFactory,
                (VOID**) imgfact);
}

STDAPI
DllRegisterServer()
{
    HRESULT hr;

    // Regular COM component registration

    hr = RegisterComComponent(&ComRegData, TRUE);
    if (FAILED(hr))
        return hr;

    // Imaging related registration

    IImagingFactory* imgfact;

    hr = GetImagingFactory(&imgfact);

    if (FAILED(hr))
        return hr;

    ImageCodecInfo codecInfo;

    codecInfo.Clsid = GifCodecClsID;
    codecInfo.FormatID = IMGFMT_GIF;
    codecInfo.CodecName = GifCodecName;
    codecInfo.DllName = GifDllName;
    codecInfo.FormatDescription = GifFormatDescription;
    codecInfo.FilenameExtension = GifFilenameExtension;
    codecInfo.MimeType = GifMimeType;
    codecInfo.Flags = IMGCODEC_ENCODER |
                      IMGCODEC_DECODER |
                      IMGCODEC_SUPPORT_BITMAP |
                      IMGCODEC_SYSTEM;
    codecInfo.SigCount = GIFSIGCOUNT;
    codecInfo.SigSize = GIFSIGSIZE;
    codecInfo.Version = GIFVERSION;
    codecInfo.SigPattern = GIFHeaderPattern;
    codecInfo.SigMask = GIFHeaderMask;

    hr = imgfact->InstallImageCodec(&codecInfo);
    imgfact->Release();
    
    return hr;
}

STDAPI
DllUnregisterServer()
{
    HRESULT hr;

    // Regular COM component deregistration

    hr = RegisterComComponent(&ComRegData, FALSE);

    if (FAILED(hr))
        return hr;

    // Imaging related deregistration

    IImagingFactory* imgfact;

    hr = GetImagingFactory(&imgfact);

    if (FAILED(hr))
        return hr;

    hr = imgfact->UninstallImageCodec(GifCodecName, IMGCODEC_SYSTEM);
    imgfact->Release();
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\gif\liblzw\lzw.h ===
/*****************************************************************************
	lzw.h

	Owner: JohnBo
	Copyright (c) 1997 Microsoft Corporation

	LZW compression code.  One or more of the inventions in this file may
	be covered by letters patent owned by Unisys Inc and licensed under a
	cross license agreement by Microsoft Corporation.

	Generic LZW compression and decompression structures.
*****************************************************************************/
#pragma once

#include <stdlib.h>
#include <string.h>
#include "lzwutil.h"

#pragma intrinsic(memset, memcpy, memcmp)
#pragma intrinsic(strlen, strcpy, strcmp, strcat)
#pragma intrinsic(abs)

#define __int32 int
#define __int16 short

#if !DEBUG && GINTERNAL
	#pragma optimize("gitawb2", on)
	#pragma message("    optimize (lzw) should only appear in GIF files")
#endif


/* Unreferenced in-line functions will be removed. */
#pragma warning(disable: 4514)


/*****************************************************************************
	A class which holds the information which is shared between LZW (GIF)
	compression and decompression.
******************************************************************* JohnBo **/
class LZW
	{
protected:
	inline LZW(unsigned int bcodeSize):
		m_bcodeSize(LZW_B8(bcodeSize))
		{
		LZW_ASSERT(bcodeSize >= 2 && bcodeSize <= 8);
		}
	
	/* METHODS */
	/* Standard GIF definitions. */
	inline unsigned __int16 WClear(void) const
		{
		return LZW_B16(1U<<m_bcodeSize);
		}
	inline unsigned __int16 WEOD(void) const
		{
		return LZW_B16(1U+(1U<<m_bcodeSize));
		}

	/* DATA TYPES */
	/* Basic types. */
	typedef unsigned __int32 TokenValue;
	typedef unsigned __int16 TokenIndex;

	/* Constants. */
	enum
		{
		ctokenBits = 12,
		ctokens = (1U<<ctokenBits),
		};

	/* DATA */
	unsigned __int8  m_bcodeSize;    // The LZW initial code size
	};


/*****************************************************************************
	A class which also holds the current token size.
******************************************************************* JohnBo **/
class LZWState : protected LZW
	{
protected:
	inline LZWState(unsigned int bcodeSize):
		m_ibitsToken(LZW_B8(bcodeSize+1)),
		m_itokenLast(WEOD()),
		LZW(bcodeSize)
		{}

	unsigned __int8  m_ibitsToken; // The (current) number of bits in a token
	TokenIndex       m_itokenLast; // The last token to be allocated
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\gif\liblzw\lzwimage.cpp ===
/*****************************************************************************
	lzwimage.cpp

	Owner: JohnBo
	Copyright (c) 1997 Microsoft Corporation

	Write the GIF "table based image data" - does not write anything else.
	Is capable of handling input data in a variety of formats.
*****************************************************************************/
#include "lzwimage.h"


/*----------------------------------------------------------------------------
	Utility to byte swap a ULONG.
------------------------------------------------------------------- JohnBo -*/
#pragma intrinsic(_rotl, _rotr)
inline unsigned __int32 BSwap(unsigned __int32 u)
	{
	return (_rotl(u, 8) & 0xFF00FF) + _rotr(u & 0xFF00FF, 8);
	}


/*----------------------------------------------------------------------------
	The arbitrary padded output engine.
------------------------------------------------------------------- JohnBo -*/
bool LZWImageCompressor::FBig32(const unsigned __int32*puRow, int cuRow,
	int iWidth, int iHeight, int iBitCount, bool fInterlace)
	{
	/* This assert will fire if FWrite is called more than once. */
	LZW_ASSERT(m_ibOut == 1);

	/* We require data on a 32bpp boundary (always.) */
	LZW_ASSERT((((int)puRow) & 3) == 0);

	/* Both width and height must be greater than 0. */
	LZW_ASSERT(iWidth > 0 && iHeight > 0);

	/* Compress row-by-row - we cannot compress the whole lot at once because
		there may be padding in each row.  iWidth is converted into bits for
		convenience in the loop below (see above.) */
	iWidth *= iBitCount;  // Now in bits.

	/* Interlace is handled by setting a step count for the y ordinate.  The
		value is actually the initial count (bottom 3 bits) and the step count
		(next four bits). */
	int yStep(fInterlace ? (8<<3) : (1<<3));
	do
		{
		/* Note that this does correctly handle interlaced images with fewer
			than 8 rows - the early passes get droped. */
		for (int y=(yStep & 7); y<iHeight; y += (yStep>>3))
			{
			/* The input is provided in 32 bit quantities, we rely on the pvBits
				being aligned to a 32 bit boundary. */
			const unsigned __int32 *pu = puRow + y * cuRow;
			int ibits(iWidth);
			while (ibits > 0)
				{
				NextBlock(BSwap(*pu++), iBitCount, ibits > 32 ? 32 : ibits);
				ibits -= 32;
				if (m_fError)
					goto fail;
				}
			}
		if (yStep == (8<<3))
			yStep += 4;  // Second pass only
		else
			yStep >>= 1; // Gives 1<<2 if not interlaced.
		}
	while (yStep > (1<<3));

fail:
	/* Finally end the data stream. */
	EndAndFlushBuffers();
	return !m_fError;
	}


/*----------------------------------------------------------------------------
	The big-endian 32bpp padded case.
------------------------------------------------------------------- JohnBo -*/
bool LZWImageCompressor::FBig32(const void *pvBits, int iWidth, int iHeight,
	int iBitCount, bool fInterlace)
	{
	const unsigned __int32 *puRow = static_cast<const unsigned __int32*>(pvBits);
	int cuRow((iWidth*iBitCount + 31) >> 5);

	/* Compress row-by-row - we cannot compress the whole lot at once because
		there may be padding in each row.  iWidth is converted into bits for
		convenience in the loop below (see above.) */
	if (iHeight > 0)  // Top down
		{
		puRow += cuRow * (iHeight-1);
		cuRow = -cuRow;
		}
	else              // Bottom up
		iHeight = (-iHeight);

	return FBig32(puRow, cuRow, iWidth, iHeight, iBitCount, fInterlace);
	}


/*----------------------------------------------------------------------------
	Flush the output if required, or unconditionally at the end, a flush is
	required when there is insufficient output for the maximum number of codes
	which can be handled at one step.  The limit is 32 codes plus one clear
	code plus one block counter - 34x12bits (51 bytes.)  The flush actually
	allows 64 bytes because the arithmetic calculation is tricky.

	NOTE: the caller now checks for the requirement to flush, this makes
	for better performance by avoiding a function call overhead in the
	typical case.
------------------------------------------------------------------- JohnBo -*/
void LZWImageCompressor::FlushOutput(bool fForce)
	{
	if (!FWrite(fForce))
		{
		m_fError = true;
		return;
		}

	/* Output has finished if fForce is true, so we don't require
		any more buffer space. */
	if (fForce)
		return;

	/* Otherwise do some error checking to avoid memory overwrites if
		there are bugs in this code. */
	/* Now there must be space in the buffer for one block plus up to
		32 codes beyond it.  These codes will be short, but I actually
		allow 64 bytes to be safe. */
	if ((unsigned int)(m_ibOut+(256+64)) > (unsigned int)m_cbOut)
		{
		LZW_ASSERT(("FWrite implementation error", false));
		m_fError = true;
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\gif\liblzw\lzwimage.h ===
/*****************************************************************************
	lzwimage.h

	Owner: JohnBo
	Copyright (c) 1997 Microsoft Corporation

	Write the GIF "table based image data" - does not write anything else.
	Is capable of handling input data in a variety of formats.
*****************************************************************************/
#pragma once

#include "lzwwrite.h"


/*****************************************************************************
	The basic class to output image data.  This has a virtual "output" (FWrite)
	method which must be implemented in a sub-class.  The sub-class must also
	provide the actual IO buffer.
******************************************************************* JohnBo **/
class LZWImageCompressor : public LZWCompressor
	{
public:
	/* WARNING: the initializer for LZWCompressor expects m_ibOut to be 
		initialized correctly, so we must initialize it in the LZWCompressor
		constructor call - member initialization *follows* base initialization.
		If specified defered clear codes are supported on the image output -
		the current implementation is very crude, it just switches of clear
		codes for the whole image.
		*/
	LZWImageCompressor(void *pv, int cb, int ibpp, bool fDoDefer):
		m_fError(false),
		m_fDataError(false),
		LZWCompressor(ibpp, pv, (m_ibOut=0, &m_ibOut), cb)
		{
		/* The code size should already have been output (this is a sanity check
			which actually relies on knowledge of the interal implementation - not
			particularly nice.) */
		LZW_ASSERT(m_ibOut == 1);
		/* The buffer must be big enough to allow for 256 bytes of slack.  In
			practice this check ensures that we have reasonable buffer space. */
		LZW_ASSERT(cb >= 1024+256);
		/* Handle the defered clear codes. */
		DoDefer(fDoDefer);
		}

	/* Data is big or little endian (but bytes are always big) and may be
		padded to some arbitrary boundary, only big endian 32bpp padding is
		implemented at present.  Other options can be added easily.  The
		fInterlace flag indicates that the output image should be interlaced.
		The sub-class can set the DoDefer option explicitly if required before
		calling this API. */
	bool FBig32(const void *pvBits, int iWidth, int iHeight, int iBitCount,
		bool fInterlace);

	/* The same but the caller specifies a pointer to the first (top)
		row and a "stride" between rows, the latter may be negative, it is
		a count of the 32bit steps (*not* byte steps) from one row to the
		next (thus each row must be on a 32 bit boundary). */
	bool FBig32(const unsigned __int32*puRow, int cuRow, int iWidth,
		int iHeight, int iBitCount, bool fInterlace);

	/* ALTERNATIVE: to stream the data yourself, use this API.
		Handle the next block of input, check the buffer to see if it needs to
		be flushed. */
	inline void NextBlock(unsigned __int32 ibuffer, int ibpp, int cbits)
	  	{
		if (!FHandleInput(ibuffer, ibpp, cbits))
			m_fDataError = true;
		/* Take care over the following check, it must be correct! */
		if ((unsigned int)(m_ibOut+COutput()+64) > (unsigned int)m_cbOut)
			FlushOutput(false);
		}

	/* call this at the end of compression */
	inline void EndAndFlushBuffers()
		{
		End();
		FlushOutput(true);
		}

	/* Return true if there has been a data error. */
	bool FDataError(void) const { return m_fDataError; }
	bool FInternalError(void) const { return m_fError; }

protected:
	/* FWrite must be implemented in the sub-class, it flushes the given
		buffer to the output device.  It is permitted to update the pointers
		but it must always copy the data from the end of the region it flushes
		until m_ibOut to the start of the new buffer.   When the argument to
		FWrite is true the whole buffer must be flushed, otherwise it is
		sufficient to flush enough to leave 256 bytes free. */
	virtual bool FWrite(bool fForce) = 0;

	int  m_ibOut;         // See above for initialization trick.

private:
	/* PRIVATE DATA. */
	bool m_fError;        // Record any error in IO
	bool m_fDataError;    // An error in the input data

	/*** Private APIs ***/
	/*	Flush the output fForce says that this is an unconditional flush at
		the end. */
	void FlushOutput(bool fForce);
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\gif\liblzw\lzwread.cpp ===
/*****************************************************************************
	lzwread.cpp

	Owner: JohnBo
	Copyright (c) 1997 Microsoft Corporation

	LZW compression code.  One or more of the inventions in this file may
	be covered by letters patent owned by Unisys Inc and licensed under a
	cross license agreement by Microsoft Corporation.
*****************************************************************************/
#include "lzwread.h"


/*----------------------------------------------------------------------------
	Reset the decompressor state.  This API is provided so the same object
	can be used to decompress multiple images within a GIF stream.  The LZWIO
	object is not reset, the caller must ensure that it is set up correctly.
------------------------------------------------------------------- JohnBo -*/
void LZWDecompressor::Reset(unsigned __int8 bcodeSize)
	{
	LZW_ASSERT(bcodeSize < 12);

	m_bcodeSize = bcodeSize;
	m_chPrev = 0;
	m_fEnded = false;
	m_fError = false;
	m_iInput = 0;
	m_cbInput = 0;
	m_iTokenPrev = WClear();

	/* The initial elements of the token array must be preset to single
		character tokens. */
	for (int i=0; i<WClear(); ++i)
		m_rgtoken[i] = ChToken(static_cast<unsigned __int8>(i));

	/* Executing Clear() at this point resets the rest of the token array, it
		does also reset the clear code and the EOD code. */
	Clear();
	}


/*----------------------------------------------------------------------------
	Handle any available data, returning false only on EOD or terminal error.
------------------------------------------------------------------- JohnBo -*/
bool LZWDecompressor::FHandleNext(void)
	{
	int iInput(m_iInput);
	int cbInput(m_cbInput);

	/* Preload the previous token value and the "first character" of this token,
		which is saved below. */
	int              iTokenPrev(m_iTokenPrev);
	unsigned __int32 tokenPrev(m_rgtoken[iTokenPrev]);
	unsigned __int8  chFirst(m_chPrev);
	for (;;)
		{
		/* Gather the bits for the next token. */
		LZW_ASSERT(cbInput >= 0);
		while (cbInput < m_ibitsToken)
			{
			if (m_cbIn <= 0)
				{
				m_fNeedInput = true;
				goto LMore;
				}
			iInput += *m_pbIn++ << cbInput;
			cbInput += 8;
			--m_cbIn;
			}

		/* Extract the token and, if it will fit in the output, write it
			out.  To do this look the token up in the table, this contains
			a flag (bSimple) which indicates if the "normal" processing
			method will work.  The non-normal case is actually a spurious
			load of the token table entry, the theory is that the condition
			arises sufficiently rarely for this to be more efficient than the
			multiple checks which would otherwise be required. */
		LZW_ASSERT(cbInput >= m_ibitsToken);
		int              iToken(iInput & ((1<<m_ibitsToken)-1));
		LZW_ASSERT(iToken >= 0 && iToken < ctokens);
		unsigned __int32 token(m_rgtoken[iToken]);
		int              ilen(ILen(token));

		if (ilen <= 0) // Not a regular token in the table
			{
			/* Not a regular token - either the token which has yet to be
				written or a clear or EOD token. */
			if (iToken == WClear())
				{
				cbInput -= m_ibitsToken;
				iInput >>= m_ibitsToken;
				Clear();
				iTokenPrev = iToken; // Needed if we have run out of data
				tokenPrev = 0;       // No preceding token now
				continue;
				}
			else if (iToken == WEOD())
				{
				/* This is EOF, but there may already have been some output.
					The API returns true regardless. */
				m_fEnded = true;
				iTokenPrev = WEOD();
				break;
				}
			else if (iToken != m_itokenLast+1)
				{
				/* This is the error condition - an out of range token code in
					the input stream. */
				LZW_ASSERT(iToken > m_itokenLast);
				m_fError = true;
				return false;
				}

			/* So it is the magic token+1, the token without precedence, the
				token of the nouveau riche.  What can we do with it?  We simply
				slap together some pale imitation and wait, remarkably the
				imitation *is* the token, the lie is actually the truth. */
			LZW_ASSERT(ILen(tokenPrev) > 0);
			token = NextToken(iTokenPrev, tokenPrev, chFirst);
			ilen = ILen(token);
			}

		/* Now the token can be handled if there is sufficient space in the
			output buffer, otherwise processing has to wait until that space
			is provided by the caller. */
		if (ilen > m_cbOut)  // No room at 't inn lad.
			{
			m_fNeedOutput = true;
			goto LMore;
			}

		/* We have room to handle this token, so consume it from the input
			stack. */
		cbInput -= m_ibitsToken;
		iInput >>= m_ibitsToken;

		/* Output - simple, start with the token value of this token and
			work backwards.  This will leave chFirst set to the first character
			in the token which has been output. */
		m_cbOut -= ilen;
		m_pbOut += ilen;
			{
			unsigned __int8  *pbOut = m_pbOut;
			unsigned __int32  tokenNext(token);
			for (;;)
				{
				chFirst = Ch(tokenNext);
				*--pbOut = chFirst;
				LZW_ASSERT(ilen-- == ILen(tokenNext));
				if (ILen(tokenNext) <= 1)
					break;
				tokenNext = m_rgtoken[IPrev(tokenNext)];
				}

			/* Note that ilen is only changed in debug, ship builds do not need
				it after the calculation of m_pbOut. */
			LZW_ASSERT(ilen == 0);
			}

		/* We have output this token, so add the *next* token to the
			table.  Note that deferred clear codes mean that the table
			may be full.  Also the first token after the clear code is
			always a "native" token and nothing gets added to the string
			table. */
		if (m_itokenLast < 4095 && ILen(tokenPrev) > 0)
			{
			int iTokenNew(++m_itokenLast);
			m_rgtoken[iTokenNew] = NextToken(iTokenPrev, tokenPrev, chFirst);

			/* This may blow our bit limit, in which case the token bit count
				goes up by one now.  Remember that we can see m_itokenLast+1 in
				the stream, so the increment point is when this would require
				more bits than we have to our name at present. */
			if ((iTokenNew & (iTokenNew+1)) == 0 && m_itokenLast < 4095)
				{
				++m_ibitsToken;
				LZW_ASSERT(m_ibitsToken <= ctokenBits);
				}
			}

		/* The previous token is this token. */
		iTokenPrev = iToken;
		tokenPrev = token;
		}

LMore:
	/* This must be saved for the next time round. */
	m_chPrev = chFirst;
	m_iTokenPrev = iTokenPrev;

	m_iInput = iInput;
	m_cbInput = cbInput;
	return true;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\gif\liblzw\lzwutil.h ===
/*****************************************************************************
	lzwutil.h

	Owner: JohnBo
	Copyright (c) 1997 Microsoft Corporation

	Support APIs
*****************************************************************************/
#pragma once

/*****************************************************************************
	External APIs.  Clients of this library must implement the following
	APIs for debug purposes - they are not compiled in in non-debug versions
	of the code.
******************************************************************* JohnBo **/
#if DEBUG
	/* Clients must implement the following. */
	void LZWError(char *file, int line, char *message);

	#define LZW_ASSERT(c) ((c) || (LZWError(__FILE__, __LINE__, #c),0))
#else
	#define LZW_ASSERT(c) (0)
#endif

/* Error checking (assert) macros associated with this. */
#define LZW_B8(i) (LZW_ASSERT((i)<256 && (i)>=0),\
	static_cast<unsigned __int8>(i))
#define LZW_B16(i) (LZW_ASSERT((i)<65536 && (i)>=0),\
	static_cast<unsigned __int16>(i))


/*****************************************************************************
	Utility to set a two byte quantity in the standard GIF little endian
	format, likewise for four bytes (GAMMANOW extension.)
******************************************************************* JohnBo **/
inline void GIF16Bit(unsigned __int8 *pb, int i)
	{
	LZW_ASSERT(i >= 0 && i < 65536);
	pb[0] = static_cast<unsigned __int8>(i);
	pb[1] = static_cast<unsigned __int8>(i>>8);
	}

/* Inverse operation. */
inline unsigned __int16 GIFU16(const unsigned __int8 *pb)
	{
	return static_cast<unsigned __int16>(pb[0] + (pb[1] << 8));
	}


inline void GIF32Bit(unsigned __int8 *pb, unsigned __int32 i)
	{
	pb[0] = static_cast<unsigned __int8>(i);
	pb[1] = static_cast<unsigned __int8>(i>>8);
	pb[2] = static_cast<unsigned __int8>(i>>16);
	pb[3] = static_cast<unsigned __int8>(i>>24);
	}

/* Inverse operation. */
inline unsigned __int32 GIFU32(const unsigned __int8 *pb)
	{
	return pb[0] + (pb[1] << 8) + (pb[2] << 16) + (pb[3] << 24);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\gif\liblzw\lzwwrite.h ===
/*****************************************************************************
	lzwwrite.h

	Owner: JohnBo
	Copyright (c) 1997 Microsoft Corporation

	LZW compression code.  One or more of the inventions in this file may
	be covered by letters patent owned by Unisys Inc and licensed under a
	cross license agreement by Microsoft Corporation.

	Compressor: general prinicples.

	The input is a sequence of characters of some bit size, the output is a
	sequence of tokens initially of bit size+1 size, increasing up to 12 bits.
	The algorithm looks for the current token plus the next character in the
	token table, if it finds it that becomes the current token, if not the
	current token is output and the next character becomes the new current token.
	At this point a token corresponding to the one which was being looked for
	is added to the table.

	This implementation generates a hash table of token+character values, an
	alternative might encode all the possible (known) token+character values
	as a letter tree attached to the token.  It's not obvious which would be
	faster - the letter tree has a worst case behavior determined by the need
	to search for every possible character after a given token, the hash
	approach depends on the behavior of the hash function.  The hash function
	implementation is easier, so it is used.
*****************************************************************************/
#pragma once

#include "lzw.h"


/*****************************************************************************
	The compressor class, designed to be stack allocated it requires no
	additional memory.
******************************************************************* JohnBo **/
class LZWCompressor : private LZWState
	{
public:
	/* The output buffer is supplied to the initializer and must not change
		during use of the compressor.  The counter, *pibOut is updated to
		reflect the number of bytes available in the buffer.  At any call
		to HandleInput there must always be sufficient space for the 32 bits
		of input plus 31 bits of pending output - for 1bpp input that means
		32*12+31+12(clear code) bits - 52 bytes, plus one byte for a new
		block count.  To be safe ensure that 64 bytes are available. At
		a call to End() there must be at least 8 bytes available. */
	inline LZWCompressor(unsigned int ibits, void *pvOut, int *pibOut,
		int cbOut):
		m_ishiftHash(LZW_B8(chashBits-ibits)),
		m_fDefer(false),
		m_itoken(WClear()),  // Clear code - force clear at start
		m_iOutput(0),
		m_cbitsOutput(0),
		m_cOutput(1),        // 1 for count byte
		m_pbOut(static_cast<unsigned __int8*>(pvOut)),
		m_pibOut(pibOut),
		m_cbOut(cbOut),
		LZWState(ibits == 1 ? 2 : ibits)
		{
		/* The first byte of the data which is output is the code size,
			except that it isn't, it is code size - 1 (1 less than the
			initial code size in the stream). */
		m_pbOut[(*m_pibOut)++] = m_bcodeSize;
		m_pbOut[*m_pibOut] = 255;  // Assume full block
		/* Remainder of setup corresponds to initial clear code. */
		Clear();
		}

	/* Clear the table.  The clear code is output. */
	inline void ForceClear(void)
		{
		TokenIndex itoken(m_itoken);
		if (itoken != WClear())
			{
			Output(itoken);
			m_itoken = WClear();
			}
		}

	/* Handle the next input character. */
	bool FHandleCh(unsigned int ch);

	/* End the output, any remaining bits will be flushed to the output buffer,
		padded with garbage as required.  The API may require up to 8 bytes
		more (including a one byte terminator block.) */
	void End(void);

	/* Return the number of bytes of "pending" output, the compressor may write
		up to 256 bytes beyond the current end of buffer before updating the
		buffer count, these must be preserved by the caller.  This API allows the
		caller to find out how many such bytes have been written. */
	inline int COutput(void) const { return m_cOutput; }

	/* Enable or disable deferring the emission of the clear code.  "What magic
		is this?" you ask.  GIF (*including* GIF87a) permits the compressor to
		refrain from clearing the compression table when it has generated 4096
		codes - instead it keeps on outputting data without generating new table
		entries.  This is normally very efficient if the nature of the data has
		not changed.  Unfortunately a few programs, probably implemented by
		Cthulu themself, fail horribly (i.e. crash) when confronted by the
		resultant perfectly well formed (is that a clue?) GIF.  Obviously I
		do not utter the name of the program. */
	inline void DoDefer(bool fDefer)
		{
		m_fDefer = fDefer;
		}

protected:
	/* Handle some input.  The input is in a buffer which is *always* big-endian
		(so it matches both PNG and Win32 bit order) and the first bit is in the
		MSB position.  Returns false if any image data is out of range. */
	bool FHandleInput(unsigned __int32 input, int bpp, int cbits);

	/* The information about the IO buffer.  Available to the sub-class to
		avoid it having to replicate the information. */
	unsigned __int8  *m_pbOut;
	int               m_cbOut;

private:
	/* DATA TYPES */
	/* Constants. */
	enum
		{
		chashBits = 13,
		chashSize = (1U<<chashBits),
		hashMask = (chashSize-1),
		tokenIndexEnd = 0,
		tokenShift = (ctokenBits+8),      // For "next" value
		tokenMask = ((1U<<tokenShift)-1)  // Character + max token index
		};

	/* PRIVATE DATA */
	unsigned __int8  m_ishiftHash; // Amount to shift char value to get hash value
	bool             m_fDefer;     // Defer omission of the clear code while set

	TokenIndex       m_itoken;     // The current token (index into array.)

	/* The output accumulator - this only works on a little endian architecture,
		however big endian architectures need only ensure that the bytes are
		byte swapped on output.   The data in here is a bit count in the top
		six bits plus the actual bits in the lower order bits. */
	unsigned __int32  m_iOutput;
	int               m_cbitsOutput;
	int               m_cOutput;   // Current count of output bytes
	int              *m_pibOut;

	/* An array of tokens - 4096 entries, each holding the character of the
		token and the preceding token, note that the initial entries are not
		used (they are the base single character tokens.) */
	TokenValue m_rgtoken[ctokens];   // 16384 bytes

	/* The hash table. */
	TokenIndex m_rgwHash[chashSize]; // 16384 bytes

	/* PRIVATE APIS */
	/* Clear the encoder.  Must be called first, but this is an inevitable
		result of setting WClear() in m_itoken. */
	inline void Clear(void)
		{
		/* Note the wackiness to handle the fact that the predefined codes fill
			up two entries in the table - so we start with 2bpp for a 1bpp image,
			(i.e. the first code will really take 3 bits.) */
		m_ibitsToken = LZW_B8(m_bcodeSize+1);
		/* The "next token" must allow for the GIF clear code and the EOD
			code, so the "last" token is set to WEOD(). */
		m_itokenLast = WEOD();
		/* The hash table is set to "empty" by the following.  Note that the
			token table is not re-initialized. */
		memset(m_rgwHash, 0, sizeof m_rgwHash);
		}

	/* Output the current token. */
	void Output(TokenIndex itoken);
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\ico\icocodec.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   icocodec.hpp
*
* Abstract:
*
*   Header file for the icon encoder/decoder
*
* Revision History:
*
*   10/4/1999 DChinn
*       Created it.
*
\**************************************************************************/

#include "icofile.h"

class GpIcoCodec : public IImageDecoder
{
private:

    // =====================================================
    // Decoder privates
    // =====================================================

    IStream *pIstream;
    IImageSink* decodeSink;

    // structures for the incoming data
    ICONHEADER IconHeader;
    ICONDESC *IconDesc;
    BmiBuffer *BmiHeaders; // Bitmap info header and color table for each image
    BYTE **ANDmask;       // essentially, the transparency info for each image
    // Note: we do not cache the XORmask (which is essentially the pixel data)

    ColorPalette *pColorPalette;
    HBITMAP hBitmapGdi; // bitmap for GDI to render into (from RLE)
    VOID *pBitsGdi;     // bits pointer for above bitmap
    
    BOOL bReadHeaders;      // TRUE if we have read in the headers
    BOOL bCalledBeginSink;  // TRUE if we have called BeginSink()
    UINT iSelectedIconImage;    // which image we are decoding
                                                                               
    INT currentLine;

    // Used for multires decoding:
    BOOL haveValidIconRes;
    UINT indexMatch;
    UINT desiredWidth;
    UINT desiredHeight;
    UINT desiredBits;

    VOID CleanUp(void);
    BOOL GpIcoCodec::IsValidDIB(UINT iImage);
    HRESULT GpIcoCodec::ReadHeaders(void);
    UINT GpIcoCodec::GetColorTableCount(UINT iImage);
    UINT GpIcoCodec::SelectIconImage(void);
    HRESULT GpIcoCodec::SetBitmapPalette(UINT iImage);
    PixelFormatID GpIcoCodec::GetPixelFormatID(UINT iImage);
    STDMETHODIMP GpIcoCodec::DecodeFrame(IN ImageInfo& imageInfo);
    STDMETHODIMP GpIcoCodec::ReadLine(IN VOID *pBits, 
        IN INT currentLine, IN ImageInfo imageInfo);
    STDMETHODIMP GpIcoCodec::ReadLine_BI_RGB(IN VOID *pBits, 
        IN INT currentLine, IN ImageInfo imageInfo);
    STDMETHODIMP GpIcoCodec::ReadLine_GDI(IN VOID *pBits, 
        IN INT currentLine, IN ImageInfo imageInfo);
    STDMETHODIMP GpIcoCodec::GenerateGdiBits(IN ImageInfo imageInfo);

    // =====================================================
    // Encoder privates
    // =====================================================

    // None -- encoder not implemented.

protected:
    LONG comRefCount;       // COM object reference count    

public:

    // Constructor and Destructor
    
    GpIcoCodec::GpIcoCodec(void);
    GpIcoCodec::~GpIcoCodec(void);

    // IImageDecoder methods
    
    STDMETHOD(InitDecoder)(IN IStream* stream, IN DecoderInitFlag flags);
    STDMETHOD(TerminateDecoder) ();
    STDMETHOD(BeginDecode)(IN IImageSink* imageSink, IN OPTIONAL IPropertySetStorage* newPropSet);
    STDMETHOD(Decode)();
    STDMETHOD(EndDecode)(IN HRESULT statusCode);

    STDMETHOD(GetFrameDimensionsCount)(OUT UINT* count);
    STDMETHOD(GetFrameDimensionsList)(OUT GUID* dimensionIDs,IN OUT UINT count);
    STDMETHOD(GetFrameCount)(IN const GUID* dimensionID, OUT UINT* count);
    STDMETHOD(SelectActiveFrame)(IN const GUID* dimensionID, 
        IN UINT frameIndex);
    STDMETHOD(GetImageInfo)(OUT ImageInfo* imageInfo);
    STDMETHOD(GetThumbnail)(IN OPTIONAL UINT thumbWidth, IN OPTIONAL UINT thumbHeight,
        OUT IImage** thumbImage);
    STDMETHOD(QueryDecoderParam)(IN GUID Guid);
    STDMETHOD(SetDecoderParam)(IN GUID Guid, IN UINT Length, IN PVOID Value);
    STDMETHOD(GetPropertyCount)(OUT UINT* numOfProperty);
    STDMETHOD(GetPropertyIdList)(IN UINT numOfProperty,IN OUT PROPID* list);
    STDMETHOD(GetPropertyItemSize)(IN PROPID propId, OUT UINT* size);    
    STDMETHOD(GetPropertyItem)(IN PROPID propId, IN UINT propSize,
                               IN OUT PropertyItem* buffer);
    STDMETHOD(GetPropertySize)(OUT UINT* totalBufferSize,
                               OUT UINT* numProperties);
    STDMETHOD(GetAllPropertyItems)(IN UINT totalBufferSize,
                                   IN UINT numProperties,
                                   IN OUT PropertyItem* allItems);
    STDMETHOD(RemovePropertyItem)(IN PROPID propId);
    STDMETHOD(SetPropertyItem)(IN PropertyItem item);
    STDMETHOD(GetRawInfo)(IN OUT void** info)
    {
        return E_NOTIMPL;
    }

    // IUnknown methods

    STDMETHOD(QueryInterface)(REFIID riid, VOID** ppv);
    STDMETHOD_(ULONG, AddRef)(VOID);
    STDMETHOD_(ULONG, Release)(VOID);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\gif\liblzw\lzwwrite.cpp ===
/*****************************************************************************
	lzwwrite.cpp

	Owner: JohnBo
	Copyright (c) 1997 Microsoft Corporation

	LZW compression code.  One or more of the inventions in this file may
	be covered by letters patent owned by Unisys Inc and licensed under a
	cross license agreement by Microsoft Corporation.
*****************************************************************************/
#include "lzwwrite.h"


/*----------------------------------------------------------------------------
	Output the current token.
------------------------------------------------------------------- JohnBo -*/
void LZWCompressor::Output(TokenIndex itoken)
	{
	/* Following checks for potential overflow. */
	int ibits(m_cbitsOutput);
	unsigned __int32 iOutput(m_iOutput);
		{
		int ishift(m_ibitsToken);
		LZW_ASSERT(ibits+ishift <= 32);
		LZW_ASSERT(itoken < (1U<<ishift));
		iOutput += (itoken << ibits);
		ibits += ishift;
		}

	/* Can we output a byte? */
	for (;;)
		{
		if (ibits < 8)
			{
			m_cbitsOutput = ibits;
			m_iOutput = iOutput;
			return;
			}
		LZW_ASSERT(m_cOutput > 0 && m_cOutput < 256);

		int ibOut(*m_pibOut);
		/* Check for buffer overflow - this must never happen. */
		LZW_ASSERT(ibOut+m_cOutput < m_cbOut);
		m_pbOut[ibOut+(m_cOutput++)] = static_cast<unsigned __int8>(iOutput);
		iOutput >>= 8;
		ibits -= 8;

		/* Check for full buffer. */
		if (m_cOutput >= 256)
			{
			LZW_ASSERT(m_cOutput == 256);
			ibOut += 256;
			*m_pibOut = ibOut;
			/* We may need space for up to 32 codes after this one - 31 still
				pending plus a clear code, the check is performed here to
				guarantee that we will never overflow.  32 codes can be up to
				12 bits each, so the total is 48 bytes. */
			LZW_ASSERT(ibOut+48 < m_cbOut);
			m_pbOut[ibOut] = 255; // Assume full buffer
			m_cOutput = 1;        // 1 byte count consumed
			}
		}
	}


/*----------------------------------------------------------------------------
	End the output, any remaining bits will be flushed to the output buffer,
	padded with zeroes as required.  The API can call Output up to two times,
	and we may have up to 31 pending bits, so that makes 31+12+12 bits at
	most (55 bits), plus a one byte terminator - 8 bytes.
------------------------------------------------------------------- JohnBo -*/
void LZWCompressor::End(void)
	{
	LZW_ASSERT(m_cbOut - *m_pibOut >= COutput()+8);

	/* Output the current token then the EOD code, note that, in the
		degenerate empty image case the token can be the clear code. */
	TokenIndex itoken(m_itoken);
	LZW_ASSERT(itoken != WEOD());
	Output(itoken);
	if (itoken == WClear())
		Clear();
	m_itoken = itoken = WEOD();
	Output(itoken);

	/* And force the final output.  At this point we expect there to
		be less than 8 bits still to go because that is how Output works,
		we also expect (require) there still to be space in the output
		buffer - we will use this space for the null terminator if it
		isn't used for an output byte. */
	int ibits(m_cbitsOutput);
	LZW_ASSERT(ibits < 8);
	if (ibits > 0)
		{
		LZW_ASSERT(m_cOutput > 0 && m_cOutput < 256);
		m_pbOut[(*m_pibOut)+(m_cOutput++)] =
			static_cast<unsigned __int8>(m_iOutput);
		LZW_ASSERT(m_cOutput <= 256);
		}

	/* Flush a partial buffer. */
	if (m_cOutput > 1)
		{
		m_pbOut[*m_pibOut] = LZW_B8(m_cOutput-1);
		*m_pibOut += m_cOutput;
		m_cOutput = 1;
		}

	/* Output the terminator block. */
	LZW_ASSERT(m_cOutput == 1);
	m_pbOut[(*m_pibOut)++] = 0;
	m_cOutput = 0; // Terminated now

	LZW_ASSERT(*m_pibOut <= m_cbOut);
	}


/*----------------------------------------------------------------------------
	Handle some input.  The input is in a buffer which is *always* big-endian
	(so it matches both PNG and Win32 bit order) and the first bit is in the
	MSB position.
------------------------------------------------------------------- JohnBo -*/
bool LZWCompressor::FHandleInput(unsigned __int32 input, int bpp, int cbits)
	{
	LZW_ASSERT(cbits >= bpp);

	/* Read the members of the control structure into local variables. */
	TokenIndex      itoken(m_itoken);         // Current token
	LZW_ASSERT(itoken != WEOD());             // Should never arise
	const unsigned __int8 ibits(m_bcodeSize); // Limit on character size
	LZW_ASSERT(ibits <= cbits || cbits == 1 && ibits == 2/*monochrome*/);
	const unsigned __int8 ihShl(m_ishiftHash);

#define OVERFLOWOK 1
#if !OVERFLOWOK
	bool fOverflow(false);
#endif
	for (;;)
		{
		/* Extract the next character from the high bits of the input
			buffer. */
		unsigned __int8 ch(LZW_B8(input >> (32-bpp)));
	#if OVERFLOWOK
		/* This arises inside the GEL rendering code for XOR handling on
			Win95 because we map the last color to the highest pixel value. */
		ch &= (1U<<ibits)-1;
	#else
		if (ch >= (1U<<ibits))
			{
			ch &= (1U<<ibits)-1;
			fOverflow = true;
			}
	#endif

		/* If the current token is the clear code then this character
			becomes the (new) current token and we clear the encoder
			state. */
		if (itoken == WClear())
			{
			Output(itoken);
			Clear();
			itoken = ch;
			}
		else
			{
			/* This line (alone) determines the format of a token value, it must
				completely encode the prefix+character.  The hash value attempts to
				distribute the use of the hash table as early as possible.  In
				particular there is no chance of a dual hit on a hash table entry
				until ibits+codebits > hash bits, the hash bits must be >= token
				bits and >= character bits. */
			unsigned int tokenValue((ch << ctokenBits) + itoken);
			unsigned int ihash(itoken ^ (ch << ihShl));

			/* Search down the chain (if any) for a match against the token value.
				Note that the actual 32 bit values have the next element of the
				chain in the top 12 bits. */
			TokenIndex tokenIndex(m_rgwHash[ihash]);
			while (tokenIndex != tokenIndexEnd)
				{
				TokenValue tokenNext(m_rgtoken[tokenIndex]);
				if (tokenValue == (tokenNext & tokenMask))
					{
					/* The string is in the table, use it as the current token. */
					itoken = tokenIndex;
					goto LContinue;
					}

				/* No match, look at the next token. */
				tokenIndex = LZW_B16(tokenNext >> tokenShift);
				}

			/* If we get here the string is not in the table.  It must be entered
				into it (as the next token) and linked into the list.  We preserve
				the ihash value for this - we actually link to the head of the
				list.  This might be slightly slower than desireable, depending on
				how long the list gets, as possibly the more frequent strings occur
				earlier...  Note that we are adding a new token, so we must take
				account of deferred clear codes at this point.  First output the
				current token (using the current bit count.) */
			Output(itoken);
			tokenIndex = m_itokenLast;
			if (tokenIndex < (ctokens-1))
				{
				m_rgtoken[++tokenIndex] =
					tokenValue + (m_rgwHash[ihash] << tokenShift);
				m_rgwHash[ihash] = tokenIndex;
				m_itokenLast = tokenIndex;

				/* At this point the number of bits required to output a token may
					have increased - note that the previous token can be output with
					the previous number of bits, because it cannot be the new token.
					This happens when we hit a power of 2. */
				if (tokenIndex >= (1 << m_ibitsToken))
					{
					LZW_ASSERT(tokenIndex == (1<<m_ibitsToken));
					++m_ibitsToken;
					LZW_ASSERT(m_ibitsToken <= ctokenBits);
					}
				}
			else if (!m_fDefer)
				{
				/* We must clear the table now, first output this token (which
					generates a value for token 4096 - if the decoder fails to
					take account of this it will overwrite memory.  So far as I
					can see all decoders must deal correctly with this factoid -
					otherwise GIF would always have failed to use the final code. */
				Output(WClear());
				Clear();
				}

			/* The unhandled character is the new token. */
			itoken = ch;
			}

LContinue:
		cbits -= bpp;
		if (cbits < bpp)
			{
			m_itoken = itoken;
			LZW_ASSERT(cbits == 0);
		#if !OVERFLOWOK
			return !fOverflow;
		#else
			return true;
		#endif
			}
		input <<= bpp;
		}
	}


/*----------------------------------------------------------------------------
	Handle the next (single) input character.
------------------------------------------------------------------- JohnBo -*/
bool LZWCompressor::FHandleCh(unsigned int ch)
	{
	LZW_ASSERT(m_cbOut - *m_pibOut >= 256);
	LZW_ASSERT(ch < (1U<<m_bcodeSize));

	/* Call the internal API. */
	unsigned __int32 iInput(ch);
	iInput <<= 32-8;
	return FHandleInput(iInput, 8, 8);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\gif\liblzw\lzwread.h ===
/*****************************************************************************
	lzwread.h

	Owner: JohnBo
	Copyright (c) 1997 Microsoft Corporation

	LZW compression code.  One or more of the inventions in this file may
	be covered by letters patent owned by Unisys Inc and licensed under a
	cross license agreement by Microsoft Corporation.

	LZW decompression (reading LZW writing bytes) code.

	The LZW decompressor uses the same state class as the compressor
	(LZWState).  It reads and writes byte streams.  Since GIF pixel values are
	always <256 the class writes codes into bytes.  It does this even if they
	fit into less space.   During IO the LZWIO structure may need to provide
	up to 4096 bytes free in the output buffer, otherwise output may not be
	possible.  The bool elements of the LZWIO are never cleared by the
	decompressor, only set.
*****************************************************************************/
#pragma once
#define LZWREAD_H 1

#include "lzw.h"


/*****************************************************************************
	LZWIO - abstraction of the input and output buffers, used to allow
	the caller to do buffer management in whatever fashion is appropriate.
******************************************************************* JohnBo **/
struct LZWIO
	{
	inline LZWIO():
		m_pbIn(NULL), m_cbIn(0), m_pbOut(NULL), m_cbOut(0),
		m_fNeedInput(true), m_fNeedOutput(true)
		{}

	const unsigned __int8 *m_pbIn;
	int              m_cbIn;          // Description of the input buffer
	unsigned __int8 *m_pbOut;
	int              m_cbOut;         // Description of the output buffer
	bool             m_fNeedInput;    // Set when input required
	bool             m_fNeedOutput;   // Set when output space required
	};


/*****************************************************************************
	The decompressor class - an LZWState and an LZWIO, the latter being
	public.
******************************************************************* JohnBo **/
class LZWDecompressor : private LZWState, public LZWIO
	{
public:
	inline LZWDecompressor(unsigned __int8 bcodeSize):
		m_chPrev(0),
		m_fEnded(false),
		m_fError(false),
		m_iInput(0),
		m_cbInput(0),
		m_iTokenPrev(WClear()),
		LZWState(bcodeSize),
		LZWIO()
		{
		LZW_ASSERT(bcodeSize < 12);

		/* The initial elements of the token array must be preset to single
			character tokens.  Note that, in the monochrome case, there will
			be two invalid tokens in there! */
		for (int i=0; i<WClear(); ++i)
			m_rgtoken[i] = ChToken((unsigned __int8)i);

		/* Executing Clear() at this point resets the rest of the token array,
			it does also reset the clear code and the EOD code. */
		Clear();
		}

	/* Process the data stream.  The API returns false at the end of the
		stream or after a terminal error, otherwise it returns true. */
	inline bool FProcess(void)
		{
		if (m_fEnded || m_fError) return false;
		LZW_ASSERT(!m_fNeedInput && !m_fNeedOutput);
		LZW_ASSERT(m_pbIn != NULL && m_pbOut != NULL);
		LZW_ASSERT(m_cbIn >= 0 && m_cbOut >= 0);
		return FHandleNext();
		}

	/* Has an error been encountered? */
	inline bool FLZWError(void) const { return m_fError; }
	inline bool FLZWEOF(void) const { return m_fEnded; }

	/* Reset the decompressor state.  This API is provided so the same object
		can be used to decompress multiple images within a GIF stream.  The
		LZWIO object is not reset, the caller must ensure that it is set up
		correctly. */
	void Reset(unsigned __int8 bcodeSize);

protected:

private:
	/* Constants. */
	enum
		{
		lengthShift = (32-12),     // Where a token length is stored in the value
		};

	/* PRIVATE DATA */
	unsigned __int8 m_chPrev;     // The first character of the previous token
	bool            m_fEnded;     // Set after the zero length block has been seen
	bool            m_fError;     // A terminal error has been encountered

	/* The input buffer. */
	int             m_iInput;     // Input bits
	int             m_cbInput;    // Count of pending input bits
	int             m_iTokenPrev; // The previous output token

	/* The token table. */
	TokenValue m_rgtoken[ctokens];

	/* PRIVATE METHODS */
	/* Handle any available data, returning false only on EOD or terminal error. */
	bool FHandleNext(void);

	/* Clear the state of the decoder. */
	inline void Clear(void)
		{
		/* Note the wackiness to handle the fact that the predefined codes fill
			up two entries in the table - so we start with 2bpp for a 1bpp image,
			(i.e. the first code will really take 3 bits.) */
		m_ibitsToken = LZW_B8(m_bcodeSize+1);
		/* The "next token" must allow for the GIF clear code and the EOD
			code, so the "last" token is set to WEOD(). */
		m_itokenLast = WEOD();
		/* Only the generated tokens can be cleared - the others must be left
			untouched. */
		memset(m_rgtoken + WClear(), 0,
			(ctokens - WClear()) * sizeof m_rgtoken[0]);
		}

	/* Accessors on TokenValues.  These define the format of a token value, it is
		simply:

			length(12bits) previous(12bits) last character(8 bits)

		with the length in the most significant bits. */
	static inline int ILen(TokenValue tokenValue)
		{
		return tokenValue >> lengthShift;
		}

	static inline int IPrev(TokenValue tokenValue)
		{
		return (tokenValue >> 8) & (ctokens-1);
		}

	static unsigned __int8 Ch(TokenValue tokenValue)
		{
		return (unsigned __int8)tokenValue;
		}

	/* Constructors for token values.  These construct a token directly from a
		character (it will be a terminal token) or from a previous token. */
	static inline TokenValue ChToken(unsigned __int8 ch)
		{
		return ch + (1U<<lengthShift);
		}

	static inline TokenValue NextToken(int iTokenPrev, TokenValue tokenPrev,
		unsigned __int8 ch)
		{
		LZW_ASSERT(iTokenPrev < ctokens);
		return ((tokenPrev + (1U<<lengthShift)) & (0xFFFU << lengthShift)) +
			(iTokenPrev << 8) + ch;
		}
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\ico\icodecoder.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   icodecoder.cpp
*
* Abstract:
*
*   Implementation of the icon filter decoder
*
* Revision History:
*
*   10/4/1999 DChinn
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "icocodec.hpp"

/**************************************************************************\
*
* Function Description:
*
*     Initialize the image decoder
*
* Arguments:
*
*     stream -- The stream containing the bitmap data
*     flags - Misc. flags
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpIcoCodec::InitDecoder(
    IN IStream* stream,
    IN DecoderInitFlag flags
    )
{
    HRESULT hresult;
    
    // Make sure we haven't been initialized already
    
    if (pIstream) 
    {
        return E_FAIL;
    }

    // Keep a reference on the input stream
    
    stream->AddRef();  
    pIstream = stream;

    IconDesc = NULL;
    BmiHeaders = NULL;
    ANDmask = NULL;
    pColorPalette = NULL;
    bReadHeaders = FALSE;

    hBitmapGdi = NULL;
    pBitsGdi = NULL;

    haveValidIconRes = FALSE;
    indexMatch = (UINT) -1;
    desiredWidth  = 0;
    desiredHeight = 0;
    desiredBits   = 0;

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*   Free all allocated memory (icon headers, icon descriptors, etc.)
*
* Return Value:
*
*   none
*
\**************************************************************************/
VOID
GpIcoCodec::CleanUp ()
{

    // free the headers
    GpFree(IconDesc);
    IconDesc = NULL;
    GpFree(BmiHeaders);
    BmiHeaders = NULL;

    // free the AND masks
    if (ANDmask)
    {
        for (UINT iImage = 0; iImage < IconHeader.ImageCount; iImage++)
        {
            GpFree(ANDmask[iImage]);
            ANDmask[iImage]= NULL;
        }
        GpFree(ANDmask);
        ANDmask = NULL;
    }
}

    
/**************************************************************************\
*
* Function Description:
*
*     Determines whether the iImage'th image in the icon is valid.
*     The checks here come from the checks that occur in imagedit.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/
    
BOOL
GpIcoCodec::IsValidDIB(
    UINT iImage
    )
{
    DWORD cbColorTable = 0;
    DWORD cbXORMask;
    DWORD cbANDMask;

    if (BmiHeaders[iImage].header.biPlanes != 1)
    {
        return FALSE;
    }

    if ((BmiHeaders[iImage].header.biBitCount != 1) &&
        (BmiHeaders[iImage].header.biBitCount != 4) &&
        (BmiHeaders[iImage].header.biBitCount != 8) &&
        (BmiHeaders[iImage].header.biBitCount != 24)&&
        (BmiHeaders[iImage].header.biBitCount != 32))
    {
        return FALSE;
    }

    if ( BmiHeaders[iImage].header.biBitCount != 32 )
    {
        // 32 bpp don't have color table

        cbColorTable = (1 << BmiHeaders[iImage].header.biBitCount) * sizeof(RGBQUAD);
    }

    cbXORMask = ((((BmiHeaders[iImage].header.biWidth *
                    BmiHeaders[iImage].header.biBitCount) + 31) & 0xffffffe0) / 8) *
                    BmiHeaders[iImage].header.biHeight;
    cbANDMask = (((BmiHeaders[iImage].header.biWidth + 31) & 0xffffffe0) / 8) *
        BmiHeaders[iImage].header.biHeight;

    /* The following check, which is what imagedit does, works for some icon files
       but not others.  We'll leave the check out until we figure out what the
       correct should be.
       
    // The size field should be either 0 or size of XORMask plus size of ANDMask
    if (BmiHeaders[iImage].header.biSizeImage &&
        (BmiHeaders[iImage].header.biSizeImage != cbXORMask + cbANDMask))
    {
        return FALSE;
    }
    */

    if (IconDesc[iImage].DIBSize !=
        sizeof(BITMAPINFOHEADER) + cbColorTable + cbXORMask + cbANDMask)
    {
        return FALSE;
    }

    return TRUE;
}


/**************************************************************************\
*
* Function Description:
*
*     Reads the headers (icon header, icon descriptors, bitmap headers)
*     out of the stream
*
* Return Value:
*
*   Status code
*
\**************************************************************************/
    
HRESULT
GpIcoCodec::ReadHeaders(
    void
    )
{
    HRESULT rv = S_OK;

    if (!bReadHeaders) 
    {

        UINT iImage;    // index for images
        DWORD ulFilePos;    // used for icon descriptor validation

        // Read icon headers
        if (!ReadStreamBytes(pIstream, &IconHeader, sizeof(ICONHEADER)))
        {
            WARNING(("GpIcoCodec::ReadBitmapHeaders -- can't read icon header"));
            rv = E_FAIL;
            goto done;
        }
        if (IconHeader.ResourceType != 1)
        {
            WARNING(("GpIcoCodec::ReadBitmapHeaders -- resource type != 1"));
            rv = E_FAIL;
            goto done;
        }

        if ( IconHeader.ImageCount < 1 )
        {
            WARNING(("GpIcoCodec::ReadBitmapHeaders -- ImageCount < 1"));
            rv = E_FAIL;
            goto done;
        }

        IconDesc = static_cast<ICONDESC *>
            (GpMalloc (sizeof(ICONDESC) * IconHeader.ImageCount));
        if (!IconDesc)
        {
            WARNING(("GpIcoCodec::ReadBitmapHeaders -- can't allocate memory for icon descriptors"));
            rv = E_OUTOFMEMORY;
            goto done;
        }

        // Read the icon descriptors
        for (iImage = 0; iImage < IconHeader.ImageCount; iImage++)
        {
            if (!ReadStreamBytes(pIstream, &IconDesc[iImage], sizeof(ICONDESC)))
            {
                WARNING(("GpIcoCodec::ReadBitmapHeaders -- can't read icon descriptors"));
                rv = E_FAIL;
                goto done;
            }
        }

        // Validate the icon descriptors -- does NOT check whether the offsets
        // go beyond the end of the stream
        ulFilePos = sizeof(ICONHEADER) + IconHeader.ImageCount * sizeof(ICONDESC);
        for (iImage = 0; iImage < IconHeader.ImageCount; iImage++)
        {
            if (IconDesc[iImage].DIBOffset != ulFilePos)
            {
                WARNING(("GpIcoCodec::ReadBitmapHeaders -- bad icon descriptors"));
                rv = E_FAIL;
                goto done;
            }
            ulFilePos += IconDesc[iImage].DIBSize;
        }

        // Allocate the array of ANDmask pointers
        ANDmask = static_cast<BYTE **>
            (GpMalloc (sizeof(BYTE *) * IconHeader.ImageCount));
        if (!ANDmask)
        {
            WARNING(("GpIcoCodec::ReadBitmapHeaders -- can't allocate memory for ANDmask"));
            rv = E_OUTOFMEMORY;
            goto done;
        }
        for (iImage = 0; iImage < IconHeader.ImageCount; iImage++)
        {
            ANDmask[iImage] = NULL;
        }


        BmiHeaders = static_cast<BmiBuffer *>
            (GpMalloc (sizeof(BmiBuffer) * IconHeader.ImageCount));
        if (!BmiHeaders)
        {
            WARNING(("GpIcoCodec::ReadBitmapHeaders -- can't allocate memory for BmiHeaders"));
            rv = E_OUTOFMEMORY;
            goto done;
        }
        // Read bitmap info headers
        for (iImage = 0; iImage < IconHeader.ImageCount; iImage++)
        {
            if (!SeekStreamPos(pIstream, STREAM_SEEK_SET,
                               IconDesc[iImage].DIBOffset))
            {
                WARNING(("GpIcoCodec::ReadBitmapHeaders -- can't seek to read BmiHeaders"));
                rv = E_FAIL;
                goto done;
            }

            if (!ReadStreamBytes(pIstream, &BmiHeaders[iImage].header,
                                 sizeof(DWORD)))
            {
                WARNING(("GpIcoCodec::ReadBitmapHeaders -- can't read BmiHeader size"));
                rv = E_FAIL;
                goto done;
            }

            if (BmiHeaders[iImage].header.biSize == sizeof(BITMAPINFOHEADER)) 
            {
                // We have the standard BITMAPINFOHEADER

                if (!ReadStreamBytes(pIstream, 
                                     ((PBYTE) &(BmiHeaders[iImage].header)) + sizeof(DWORD), 
                                     sizeof(BITMAPINFOHEADER) - sizeof(DWORD)))
                {
                    WARNING(("GpIcoCodec::ReadBitmapHeaders -- can't read BmiHeader"));
                    rv = E_FAIL;
                    goto done;
                }

                // In icon files, the height is actually twice the real height
                BmiHeaders[iImage].header.biHeight /= 2;

                if (!IsValidDIB(iImage))
                {
                    WARNING(("GpIcoCodec::ReadBitmapHeaders -- bad DIB"));
                    rv = E_FAIL;
                    goto done;
                }

                // Read color table/bitmap mask if appropriate

                UINT colorTableSize = GetColorTableCount(iImage) * sizeof(RGBQUAD);
                
                // Some badly formed images, see Windows bug #513274, may contain
                // more than 256 entries in the color look table which is
                // useless from technical point of view. Reject this file.

                if (colorTableSize > 1024)
                {
                    return E_FAIL;
                }

                if (colorTableSize &&
                    !ReadStreamBytes(pIstream,
                                     &(BmiHeaders[iImage].colors),
                                     colorTableSize))
                {
                    WARNING(("GpIcoCodec::ReadBitmapHeaders -- can't read color table"));
                    rv = E_FAIL;
                    goto done;
                }    

                // Read the ANDmask for each image.  For each pixel i, set the value
                // of ANDmask[iImage] + i to either 0xff or 0x0, which represents
                // the alpha value.
                UINT bmpStride = (BmiHeaders[iImage].header.biWidth *
                                  BmiHeaders[iImage].header.biBitCount + 7) / 8;
                bmpStride = (bmpStride + 3) & (~0x3);
                
                if (!SeekStreamPos(pIstream, STREAM_SEEK_SET,
                                   IconDesc[iImage].DIBOffset +
                                   sizeof(BITMAPINFOHEADER) +
                                   colorTableSize +
                                   bmpStride * BmiHeaders[iImage].header.biHeight))
                {
                    WARNING(("GpIcoCodec::ReadBitmapHeaders -- can't seek to read ANDmask"));
                    rv = E_FAIL;
                    goto done;
                }

                ANDmask[iImage] =  static_cast<BYTE *>
                    (GpMalloc(BmiHeaders[iImage].header.biWidth *
                              BmiHeaders[iImage].header.biHeight));
                if (!ANDmask[iImage])
                {
                    WARNING(("GpIcoCodec::ReadBitmapHeaders -- can't allocate memory for ANDmask"));
                    rv = E_OUTOFMEMORY;
                    goto done;
                }

                // ANDBuffer holds the bits from the stream
                // Note: since an AND buffer is a monochrome DIB. This means 1
                // bit per pixel. Since a DIB must be DWORD aligned on each
                // line, so the XAnd mask has to pad it if the width/8 is not
                // DWORD aligned
                //
                // Note: Here uiAndBufStride is in number of bytes
                
                UINT uiAndBufStride = (((BmiHeaders[iImage].header.biWidth + 7)
                                    / 8 ) + 3) & (~0x3);
                UINT uiAndBufSize = uiAndBufStride
                                  * BmiHeaders[iImage].header.biHeight;
                
                BYTE* ANDBuffer = (BYTE*)GpMalloc(uiAndBufSize);
                if (!ANDBuffer)
                {
                    WARNING(("Ico::ReadBitmapHeaders--Alloc AND buf mem fail"));
                    rv = E_OUTOFMEMORY;
                    goto done;
                }

                if ( !ReadStreamBytes(pIstream, ANDBuffer, uiAndBufSize) )

                {

                    WARNING(("GpIcoCodec::ReadBitmapHeaders -- can't read ANDmask"));
                    rv = E_FAIL;
                    goto done;
                }

                // Convert the bits to bytes -- store the alpha values from top to bottom
                
                UINT iByteOffset = 0;
                UINT bit = 0;
                LONG_PTR Width = (LONG_PTR)BmiHeaders[iImage].header.biWidth;
                LONG_PTR Height = (LONG_PTR)BmiHeaders[iImage].header.biHeight;
                BYTE *dst;
                BYTE *src;
                BYTE* srcStart;
                for (LONG_PTR iRow = Height - 1; iRow >= 0; iRow--, bit = 0)
                {
                    srcStart = ANDBuffer + (Height - 1 - iRow) * uiAndBufStride;
                    iByteOffset = 0;

                    for (LONG_PTR iCol = 0; iCol < Width; iCol++)
                    {
                        // mask = 0 means opaque (alpha = 255) and
                        // mask = 1 means transparent (alpha = 0)
                        dst = ANDmask[iImage];
                        src = srcStart + iByteOffset;
                        dst += iRow*Width+iCol;

                        if(*src & (1 << (7-bit))) 
                        {
                            *dst = 0;
                        }
                        else
                        {
                            *dst = 0xff;
                        }

                        bit++;

                        if (bit == 8)
                        {
                            bit = 0;
                            iByteOffset++;
                        }
                    }
                }
                GpFree(ANDBuffer);
            }
            else
            {
                WARNING(("GpIcoCodec::ReadBitmapHeaders -- unknown bitmap header"));
                rv = E_FAIL;
                goto done;
            }

            bReadHeaders = TRUE;
        }
    }
    
done:
    if (rv != S_OK)
    {
        CleanUp();
    }
    return rv;
}


/**************************************************************************\
*
* Function Description:
*
*     Computes the number of entries in the color table of image number iImage
*
* Return Value:
*
*     Number of entries in color table
*
\**************************************************************************/

UINT   
GpIcoCodec::GetColorTableCount(
    UINT iImage)
{
    BITMAPINFOHEADER* bmih = &BmiHeaders[iImage].header;
    UINT count = 0;

    if (bmih->biCompression == BI_BITFIELDS)
    {
        if (bmih->biBitCount == 16 || bmih->biBitCount == 32)
        {
            count = 3;
        }
    }
    else switch (bmih->biBitCount)
    {
         case 1:
         case 4:
         case 8:

             if (bmih->biClrUsed != 0)
             {    
                 count = bmih->biClrUsed;
             }
             else
             {    
                 count = (1 << bmih->biBitCount);
             }

             break;
    }

    return count;
}

/**************************************************************************\
*
* Function Description:
*
*     Sets the palette in decodeSink to that of the iImage'th image.
*     Note that colorPalette is freed at the end of the decode operation.
*
* Return Value:
*
*     Status code
*
\**************************************************************************/

HRESULT
GpIcoCodec::SetBitmapPalette(UINT iImage)
{
    BITMAPINFOHEADER* bmih = &BmiHeaders[iImage].header;
    
    if ((bmih->biBitCount == 1) ||
        (bmih->biBitCount == 4) ||
        (bmih->biBitCount == 8))
    {
        if (!pColorPalette) 
        {
            UINT colorTableCount = GetColorTableCount(iImage);

            // Some badly formed images, see Windows bug #513274, may contain
            // more than 256 entries in the color look table. Reject this file.

            if (colorTableCount > 256)
            {
                return E_FAIL;
            }

            // !!! Does this allocate sizeof(ARGB) more bytes than necessary?
            pColorPalette = static_cast<ColorPalette *>
                (GpMalloc(sizeof(ColorPalette) + colorTableCount * sizeof(ARGB)));

            if (!pColorPalette) 
            {
                return E_OUTOFMEMORY;
            }

            pColorPalette->Flags = 0;
            pColorPalette->Count = colorTableCount;

            UINT i;
            for (i = 0; i < colorTableCount; i++) 
            {
                pColorPalette->Entries[i] = MAKEARGB(
                    255,
                    BmiHeaders[iImage].colors[i].rgbRed,
                    BmiHeaders[iImage].colors[i].rgbGreen,
                    BmiHeaders[iImage].colors[i].rgbBlue);
            }
        }
       
        decodeSink->SetPalette(pColorPalette);
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*     Computes the pixel format ID of the iImage'th image in the icon
*
* Return Value:
*
*     Pixel format ID
*
\**************************************************************************/

PixelFormatID 
GpIcoCodec::GetPixelFormatID(
    UINT iImage)
{
    BITMAPINFOHEADER* bmih = &BmiHeaders[iImage].header;
    PixelFormatID pixelFormatID;

    switch(bmih->biBitCount)
    {
    case 1:
        pixelFormatID = PIXFMT_1BPP_INDEXED;
        break;

    case 4:
        pixelFormatID = PIXFMT_4BPP_INDEXED;
        break;

    case 8:
        pixelFormatID = PIXFMT_8BPP_INDEXED;
        break;

    case 16:
        pixelFormatID = PIXFMT_16BPP_RGB555;
        break;

    case 24:
        pixelFormatID = PIXFMT_24BPP_RGB;
        break;

    case 32:
        pixelFormatID = PIXFMT_32BPP_RGB;
        break;
    
    default:
        pixelFormatID = PIXFMT_UNDEFINED;
        break;
    }

    // Let's return non BI_RGB images in a 32BPP format.  This is because
    // GDI doesn't always do the SetDIBits correctly on arbitrary palettes.

    if (bmih->biCompression != BI_RGB) 
    {
        pixelFormatID = PIXFMT_32BPP_RGB;
    }

    return pixelFormatID;
}


/**************************************************************************\
*
* Function Description:
*
*     Cleans up the image decoder
*
* Arguments:
*
*     none
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

// Clean up the image decoder object

STDMETHODIMP 
GpIcoCodec::TerminateDecoder()
{
    // Release the input stream
    
    if(pIstream)
    {
        pIstream->Release();
        pIstream = NULL;
    }

    if (hBitmapGdi) 
    {
        DeleteObject(hBitmapGdi);
        hBitmapGdi = NULL;
        pBitsGdi = NULL;
        
        WARNING(("pIcoCodec::TerminateDecoder -- need to call EndDecode first"));
    }

    CleanUp();

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Indicates whether the specified GUID is a supported decode parameter
*     for the current image.
*
* Arguments:
*
*     Guid - Specifies GUID of interest
*
* Return Value:
*
*   S_OK if successful
*   E_FAIL otherwise
*
\**************************************************************************/

STDMETHODIMP 
GpIcoCodec::QueryDecoderParam(
    IN GUID Guid
    )
{
    if ((Guid == DECODER_ICONRES) && (IconHeader.ImageCount > 1))
        return S_OK;
    else
        return E_FAIL;
}

/**************************************************************************\
*
* Function Description:
*
*     Sets the specified decode parameter.
*
* Arguments:
*
*     Guid - Specifies decode parameter GUID
*     Length - Length of the buffer containing decode parameter value
*     Value - Points to buffer containing decode parameter value
*
* Return Value:
*
*   S_OK if successful
*   E_FAIL if current image does not support decode parameter
*   E_INVALIDARG if unrecognized parameter or bad parameter value
*
\**************************************************************************/

STDMETHODIMP 
GpIcoCodec::SetDecoderParam(
    IN GUID  Guid,
    IN UINT  Length,
    IN PVOID Value
    )
{
    if (Guid == DECODER_ICONRES)
    {
        if (IconHeader.ImageCount > 1)
        {
            if (Length == (3 * sizeof(UINT)))
            {
                UINT* params = static_cast<UINT*>(Value);

                if ((params[0] > 0) && (params[1] > 0) && (params[2] > 0))
                {
                    // If same as the current parameters, then results
                    // of previous seach is still valid.  But if anything
                    // is different, need to

                    if ((desiredWidth  != params[0]) ||
                        (desiredHeight != params[1]) ||
                        (desiredBits   != params[2]))
                    {
                        desiredWidth  = params[0];
                        desiredHeight = params[1];
                        desiredBits   = params[2];

                        indexMatch = (UINT) -1;
                    }

                    haveValidIconRes = TRUE;

                    return S_OK;
                }
                else
                {
                    WARNING(("SetDecoderParam: invalid value"));
                    return E_INVALIDARG;
                }
            }
            else
            {
                WARNING(("SetDecoderParam: invalid buffer"));
                return E_INVALIDARG;
            }
        }
        else
        {
            return E_FAIL;
        }
    }
    else
    {
        WARNING(("SetDecoderParam: unknown GUID"));
        return E_INVALIDARG;
    }
}

STDMETHODIMP 
GpIcoCodec::GetPropertyCount(
    OUT UINT* numOfProperty
    )
{
    if ( numOfProperty == NULL )
    {
        return E_INVALIDARG;
    }

    *numOfProperty = 0;
    return S_OK;
}// GetPropertyCount()

STDMETHODIMP 
GpIcoCodec::GetPropertyIdList(
    IN UINT numOfProperty,
    IN OUT PROPID* list
    )
{
    if ( (numOfProperty != 0) || (list == NULL) )
    {
        return E_INVALIDARG;
    }
    
    return S_OK;
}// GetPropertyIdList()

HRESULT
GpIcoCodec::GetPropertyItemSize(
    IN PROPID propId,
    OUT UINT* size
    )
{
    if ( size == NULL )
    {
        return E_INVALIDARG;
    }

    *size = 0;
    return IMGERR_PROPERTYNOTFOUND;
}// GetPropertyItemSize()

HRESULT
GpIcoCodec::GetPropertyItem(
    IN PROPID               propId,
    IN UINT                 propSize,
    IN OUT PropertyItem*    buffer
    )
{
    if ( (propSize != 0) || (buffer == NULL) )
    {
        return E_INVALIDARG;
    }

    return IMGERR_PROPERTYNOTFOUND;
}// GetPropertyItem()

HRESULT
GpIcoCodec::GetPropertySize(
    OUT UINT* totalBufferSize,
    OUT UINT* numProperties
    )
{
    if ( (totalBufferSize == NULL) || (numProperties == NULL) )
    {
        return E_INVALIDARG;
    }

    *totalBufferSize = 0;
    *numProperties = 0;

    return S_OK;
}// GetPropertySize()

HRESULT
GpIcoCodec::GetAllPropertyItems(
    IN UINT totalBufferSize,
    IN UINT numProperties,
    IN OUT PropertyItem* allItems
    )
{
    if ( (totalBufferSize != 0) || (numProperties != 0) || (allItems == NULL) )
    {
        return E_INVALIDARG;
    }

    return S_OK;
}// GetAllPropertyItems()

HRESULT
GpIcoCodec::RemovePropertyItem(
    IN PROPID   propId
    )
{
    return IMGERR_PROPERTYNOTFOUND;
}// RemovePropertyItem()

HRESULT
GpIcoCodec::SetPropertyItem(
    IN PropertyItem item
    )
{
    return IMGERR_PROPERTYNOTSUPPORTED;
}// SetPropertyItem()

/**************************************************************************\
*
* Function Description:
*
*   Initiates the decode of the current frame
*
* Arguments:
*
*   decodeSink - The sink that will support the decode operation
*   newPropSet - New image property sets, if any
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpIcoCodec::BeginDecode(
    IN IImageSink* imageSink,
    IN OPTIONAL IPropertySetStorage* newPropSet
    )
{
    if (decodeSink) 
    {
        WARNING(("BeginDecode called again before call to EngDecode"));
        return E_FAIL;
    }

    imageSink->AddRef();
    decodeSink = imageSink;
    
    currentLine = 0;
    bCalledBeginSink = FALSE;

    return S_OK;
}
    

/**************************************************************************\
*
* Function Description:
*
*     Ends the decode of the current frame
*
* Arguments:
*
*     statusCode -- status of decode operation

* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpIcoCodec::EndDecode(
    IN HRESULT statusCode
    )
{
    GpFree(pColorPalette);
    pColorPalette = NULL;

    if (hBitmapGdi) 
    {
        DeleteObject(hBitmapGdi);
        hBitmapGdi = NULL;
        pBitsGdi = NULL;
    }
    
    if (!decodeSink) 
    {
        WARNING(("EndDecode called before call to BeginDecode"));
        return E_FAIL;
    }
    
    HRESULT hresult = decodeSink->EndSink(statusCode);

    decodeSink->Release();
    decodeSink = NULL;

    if (FAILED(hresult)) 
    {
        statusCode = hresult; // If EndSink failed return that (more recent)
                              // failure code
    }

    return statusCode;
}

/***************************************************************************\
* MyAbs
*
* NOTE: copied from ntuser\client\clres.c, function MyAbs()
*
* Calcules my weighted absolute value of the difference between 2 nums.
* This of course normalizes values to >= zero.  But it also doubles them
* if valueHave < valueWant.  This is because you get worse results trying
* to extrapolate from less info up then interpolating from more info down.
*
\***************************************************************************/

UINT MyAbs(
    int valueHave,
    int valueWant)
{
    int diff = (valueHave - valueWant);

    if (diff < 0)
        diff = 2 * (-diff);

    return (UINT)diff;
}

/***************************************************************************\
* Magnitude
*
* NOTE: copied from ntuser\client\clres.c, function Magnitude()
*
* Used by the color-delta calculations.  The reason is that num colors is
* always a power of 2.  So we use the log 2 of the want vs. have values
* to avoid having weirdly huge sets.
*
\***************************************************************************/

UINT Magnitude(
    UINT nValue)
{
    if (nValue < 4)
        return 1;
    else if (nValue < 8)
        return 2;
    else if (nValue < 16)
        return 3;
    else if (nValue < 256)
        return 4;
    else
        return 8;
}

/***************************************************************************\
* MatchImage
*
* NOTE: adapted from ntuser\client\clres.c, function MatchImage()
*
* Returns a number that measures how "far away" the given image is
* from a desired one.  The value is 0 for an exact match.  Note that our
* formula has the following properties:
*     (1) Differences in width/height count much more than differences in
*         color format.
*     (2) Fewer colors give a smaller difference than more
*     (3) Bigger images are better than smaller, since shrinking produces
*             better results than stretching.
*
* The formula is the sum of the following terms:
*     Log2(colors wanted) - Log2(colors really), times -2 if the image
*         has more colors than we'd like.  This is because we will lose
*         information when converting to fewer colors, like 16 color to
*         monochrome.
*     Log2(width really) - Log2(width wanted), times -2 if the image is
*         narrower than what we'd like.  This is because we will get a
*         better result when consolidating more information into a smaller
*         space, than when extrapolating from less information to more.
*     Log2(height really) - Log2(height wanted), times -2 if the image is
*         shorter than what we'd like.  This is for the same reason as
*         the width.
*
* Let's step through an example.  Suppose we want a 16 color, 32x32 image,
* and are choosing from the following list:
*     16 color, 64x64 image
*     16 color, 16x16 image
*      8 color, 32x32 image
*      2 color, 32x32 image
*
* We'd prefer the images in the following order:
*      8 color, 32x32         : Match value is 0 + 0 + 1     == 1
*     16 color, 64x64         : Match value is 1 + 1 + 0     == 2
*      2 color, 32x32         : Match value is 0 + 0 + 3     == 3
*     16 color, 16x16         : Match value is 2*1 + 2*1 + 0 == 4
*
\***************************************************************************/

UINT MatchImage(
    BITMAPINFOHEADER* bmih,
    UINT              cxWant,
    UINT              cyWant,
    UINT              uColorsWant
    )
{
    UINT uColorsNew;
    UINT cxNew;
    UINT cyNew;

    cxNew = bmih->biWidth;
    cyNew = bmih->biHeight;

    UINT bpp = bmih->biBitCount;
    if (bpp > 8)
        bpp = 8;

    uColorsNew = 1 << bpp;

    // Here are the rules for our "match" formula:
    //      (1) A close size match is much preferable to a color match
    //      (2) Fewer colors are better than more
    //      (3) Bigger icons are better than smaller
    //
    // The color count, width, and height are powers of 2.  So we use Magnitude()
    // which calculates the order of magnitude in base 2.

    return( 2*MyAbs(Magnitude(uColorsWant), Magnitude(uColorsNew)) +
              MyAbs(cxNew, cxWant) +
              MyAbs(cyNew, cyWant));
}

/**************************************************************************\
*
* Function Description:
*
*     Determine which image of the icon file to use in decoding
*
* Arguments:
*
*     none
*
* Return Value:
*
*   index of the image to be used in decoding
*
\**************************************************************************/

UINT
GpIcoCodec::SelectIconImage(void)
{
    if (haveValidIconRes)
    {
        if (indexMatch == (UINT) -1)
        {
            UINT currentMetric;
            UINT bestIndex = 0;
            UINT bestMetric = (UINT)-1;

            // This search is based on the MatchImage and GetBestImage
            // functions used in NtUser (ntuser\client\clres.c) to create
            // icons.

            // Get desired number of colors in # value, not bits value.  Note that
            // ntuser does not deal with 16- or 32- or 24- bit color icons.
            //
            // The icon resources can be 16, 24, 32 bpp, but the restable only has
            // a color count, so a HiColor icon would have a max value in the
            // restable.

            UINT desiredColors = desiredBits;

            if (desiredColors > 8)
                desiredColors = 8;

            desiredColors = 1 << desiredColors;

            for (UINT iImage = 0; iImage < IconHeader.ImageCount; iImage++)
            {
                // Get "matching" value.  How close are we to what we want?

                currentMetric = MatchImage(&BmiHeaders[iImage].header,
                                           desiredWidth, desiredHeight,
                                           desiredColors);

                if (!currentMetric)
                {
                    // We've found an exact match!

                    return iImage;

                }
                else if (currentMetric < bestMetric)
                {

                    // We've found a better match than the current alternative.

                    bestMetric = currentMetric;
                    bestIndex = iImage;
                }
            }

            indexMatch = bestIndex;
        }

        return indexMatch;
    }
    else
    {
        return (IconHeader.ImageCount - 1);
    }
}


/**************************************************************************\
*
* Function Description:
*
*     Sets up the ImageInfo structure
*
* Arguments:
*
*     ImageInfo -- information about the decoded image
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpIcoCodec::GetImageInfo(OUT ImageInfo* imageInfo)
{
    HRESULT hresult;

    hresult = ReadHeaders();
    if (FAILED(hresult)) 
    {
        return hresult;
    }
    
    iSelectedIconImage = SelectIconImage();
    BITMAPINFOHEADER* bmih = &BmiHeaders[iSelectedIconImage].header;
    
    imageInfo->RawDataFormat = IMGFMT_ICO;
    imageInfo->PixelFormat   = PIXFMT_32BPP_ARGB;
    imageInfo->Width         = bmih->biWidth;
    imageInfo->Height        = bmih->biHeight;
    imageInfo->TileWidth     = bmih->biWidth;
    imageInfo->TileHeight    = 1;

    // Start: [Bug 103296]
    // Change this code to use Globals::DesktopDpiX and Globals::DesktopDpiY
    HDC hdc;
    hdc = ::GetDC(NULL);
    if ((hdc == NULL) || 
        ((imageInfo->Xdpi = (REAL)::GetDeviceCaps(hdc, LOGPIXELSX)) <= 0) ||
        ((imageInfo->Ydpi = (REAL)::GetDeviceCaps(hdc, LOGPIXELSY)) <= 0))
    {
        WARNING(("GetDC or GetDeviceCaps failed"));
        imageInfo->Xdpi = DEFAULT_RESOLUTION;
        imageInfo->Ydpi = DEFAULT_RESOLUTION;
    }
    ::ReleaseDC(NULL, hdc);
    // End: [Bug 103296]

    imageInfo->Flags         = SINKFLAG_TOPDOWN
                             | SINKFLAG_FULLWIDTH
                             | SINKFLAG_HASALPHA
                             | IMGFLAG_HASREALPIXELSIZE
                             | IMGFLAG_COLORSPACE_RGB;

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Decodes the current frame
*
* Arguments:
*
*     decodeSink --  The sink that will support the decode operation
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpIcoCodec::Decode()
{
    BITMAPINFOHEADER* bmih = NULL;
    HRESULT hresult;
    ImageInfo imageInfo;

    hresult = GetImageInfo(&imageInfo);
    if (FAILED(hresult)) 
    {
        return hresult;
    }

    bmih = &BmiHeaders[iSelectedIconImage].header;

    // Inform the sink that decode is about to begin

    if (!bCalledBeginSink) 
    {
        hresult = decodeSink->BeginSink(&imageInfo, NULL);
        if (!SUCCEEDED(hresult)) 
        {
            return hresult;
        }

        // This decoder insists on the canonical format 32BPP_ARGB
        imageInfo.PixelFormat   = PIXFMT_32BPP_ARGB;
        
        // Client cannot modify height and width
        imageInfo.Width         = bmih->biWidth;
        imageInfo.Height        = bmih->biHeight;


        bCalledBeginSink = TRUE;
    
        // Set the palette in the sink.  Shouldn't do anything if there's 
        // no palette to set.

        hresult = SetBitmapPalette(iSelectedIconImage);
        if (!SUCCEEDED(hresult)) 
        {
            return hresult;
        }
    }

    // Decode the current frame
    
    hresult = DecodeFrame(imageInfo);

    return hresult;
}

/**************************************************************************\
*
* Function Description:
*
*     Decodes the current frame
*
* Arguments:
*
*     imageInfo -- decoding parameters
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpIcoCodec::DecodeFrame(
    IN ImageInfo& imageInfo
    )
{
    BITMAPINFOHEADER* bmih = &BmiHeaders[iSelectedIconImage].header;
    HRESULT hresult;
    RECT currentRect;
    UINT bmpStride;

    // Compute DWORD aligned stride of bitmap in stream

    if (bmih->biCompression == BI_RGB) 
    {
        bmpStride = (bmih->biWidth * bmih->biBitCount + 7) / 8;
        bmpStride = (bmpStride + 3) & (~0x3);
    }
    else
    {
        // Non BI_RGB bitmaps are stored in 32BPP

        bmpStride = bmih->biWidth * sizeof(RGBQUAD);
    }

    VOID *pOriginalBits = NULL; // Buffer to hold original image bits
    pOriginalBits = GpMalloc(bmpStride);
    if (!pOriginalBits) 
    {
        return E_OUTOFMEMORY;
    }
    
    currentRect.left = 0;
    currentRect.right = imageInfo.Width;

    while (currentLine < (INT) imageInfo.Height) 
    {
        currentRect.top = currentLine;
        currentRect.bottom = currentLine + 1;

        BitmapData bitmapData;
        hresult = decodeSink->GetPixelDataBuffer(&currentRect, 
                                                 imageInfo.PixelFormat, 
                                                 TRUE,
                                                 &bitmapData);
        if (!SUCCEEDED(hresult)) 
        {
            if (pOriginalBits)
            {
                GpFree(pOriginalBits);
            }
            return E_FAIL;
        }

        VOID *pBits;
        pBits = pOriginalBits;
      
        // Read one source line from the image

        hresult = ReadLine(pBits, currentLine, imageInfo);
               
        if (FAILED(hresult)) 
        {
            if (pOriginalBits)
            {
                GpFree(pOriginalBits);
            }
            return hresult;
        }
        
        BitmapData bitmapDataOriginal;
        bitmapDataOriginal.Width = bitmapData.Width;
        bitmapDataOriginal.Height = 1;
        bitmapDataOriginal.Stride = bmpStride;
        bitmapDataOriginal.PixelFormat = GetPixelFormatID(iSelectedIconImage);
        bitmapDataOriginal.Scan0 = pOriginalBits;
        bitmapDataOriginal.Reserved = 0;
        
        ConvertBitmapData(&bitmapData,
                          pColorPalette,
                          &bitmapDataOriginal,
                          pColorPalette);

        // Now that the RGB values are correct, we need to fill in the
        // Alpha values according to the ANDmask.  Note that the values in
        // the ANDmask are arranged top-down.
        UINT offset = currentLine * bitmapData.Width;
        for (UINT iCol = 0; iCol < bitmapData.Width; iCol++)
        {
            // The alpha value is the fourth byte of the ARGB four-byte sequence
            *(static_cast<BYTE *> (bitmapData.Scan0) + (iCol * sizeof(ARGB)) + 3) =
                *(ANDmask[iSelectedIconImage] + offset + iCol);
        }

        hresult = decodeSink->ReleasePixelDataBuffer(&bitmapData);
        if (!SUCCEEDED(hresult)) 
        {
            if (pOriginalBits)
            {
                GpFree(pOriginalBits);
            }
            return E_FAIL;
        }

        currentLine++;
    }
    
    if (pOriginalBits)
    {
        GpFree(pOriginalBits);
    }
    
    return S_OK;
}
    
    
/**************************************************************************\
*
* Function Description:
*
*     Reads a line in the native format into pBits
*
* Arguments:
*
*     pBits -- a buffer to hold the line data
*     currentLine -- The line to read
*     imageInfo -- info about the image
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpIcoCodec::ReadLine(
    IN VOID *pBits,
    IN INT currentLine,
    IN ImageInfo imageInfo
    )
{
    BITMAPINFOHEADER* bmih = &BmiHeaders[iSelectedIconImage].header;
    HRESULT hresult;
    
    switch (bmih->biCompression) 
    {
    case BI_RGB:
        hresult = ReadLine_BI_RGB(pBits, currentLine, imageInfo);
        break;

    case BI_BITFIELDS:

        // Let's use GDI to do the bitfields rendering (much easier than
        // writing special purpose code for this).  This is the same
        // codepath we use for RLEs.

    case BI_RLE8:
    case BI_RLE4:
        hresult = ReadLine_GDI(pBits, currentLine, imageInfo);
        break;

    default:
        WARNING(("Unknown bitmap format"));
        hresult = E_FAIL;
        break;
    }

    return hresult;
}
    
    
/**************************************************************************\
*
* Function Description:
*
*     Reads a line in the native format into pBits.  This is the case where
*     the format is BI_RGB.
*
* Arguments:
*
*     pBits -- a buffer to hold the line data
*     currentLine -- The line to read
*     imageInfo -- info about the image
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpIcoCodec::ReadLine_BI_RGB(
    IN VOID *pBits,
    IN INT currentLine,
    IN ImageInfo imageInfo
    )
{
    BITMAPINFOHEADER* bmih = &BmiHeaders[iSelectedIconImage].header;
    
    // Compute DWORD aligned stride of bitmap in stream

    UINT bmpStride = (bmih->biWidth * bmih->biBitCount + 7) / 8;
    bmpStride = (bmpStride + 3) & (~0x3);

    // Seek to beginning of stream data

    INT offset = IconDesc[iSelectedIconImage].DIBOffset +
        sizeof(*bmih) +
        GetColorTableCount(iSelectedIconImage) * sizeof(RGBQUAD) +
        bmpStride * (imageInfo.Height - currentLine - 1);
    if (!SeekStreamPos(pIstream, STREAM_SEEK_SET, offset))
    {
        return E_FAIL;
    }

    // Read one line

    if (!ReadStreamBytes(pIstream, 
                         (void *) pBits,
                         (bmih->biWidth * bmih->biBitCount + 7) / 8)) 
    {
        return E_FAIL;
    }

    return S_OK;
}
    

/**************************************************************************\
*
* Function Description:
*
*     Uses GDI to decode a non-native format into a known DIB format
*
* Arguments:
*
*     pBits -- a buffer to hold the line data
*     currentLine -- The line to read
*     imageInfo -- info about the image
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpIcoCodec::ReadLine_GDI(
    IN VOID *pBits,
    IN INT currentLine,
    IN ImageInfo imageInfo
    )
{
    HRESULT hresult;

    if (!pBitsGdi) 
    {
        hresult = GenerateGdiBits(imageInfo);
        if (FAILED(hresult)) 
        {
            return hresult;
        }
    }

    BITMAPINFOHEADER* bmih = &BmiHeaders[iSelectedIconImage].header;
    
    // Compute DWORD aligned stride of bitmap in stream

    UINT bmpStride = bmih->biWidth * sizeof(RGBQUAD);

    memcpy(pBits, 
           ((PBYTE) pBitsGdi) + bmpStride * (imageInfo.Height - currentLine - 1),
           bmpStride);

    return S_OK;
}



/**************************************************************************\
*
* Function Description:
*
*     Uses GDI to generate image bits in a known format (from RLE)
*     
* Arguments:
*
*     imageInfo -- info about the image
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpIcoCodec::GenerateGdiBits(
    IN ImageInfo imageInfo
    )
{
    BITMAPINFOHEADER* bmih = &BmiHeaders[iSelectedIconImage].header;
    HRESULT hresult;

    // Allocate temporary storage for bits from stream
    
    STATSTG statStg;
    hresult = pIstream->Stat(&statStg, STATFLAG_NONAME);
    if (FAILED(hresult))
    {
        return hresult;
    }
    // According to the document for IStream::Stat::StatStage(), the caller
    // has to free the pwcsName string
    CoTaskMemFree(statStg.pwcsName);
    
    // size of the XOR mask = (size of DIB) minus (size of AND mask)
    // the formula below assumes that the bits for the AND mask
    // are tightly packed (even across scanlines).
    UINT bufferSize = IconDesc[iSelectedIconImage].DIBSize -
        ((IconDesc[iSelectedIconImage].Width *
          IconDesc[iSelectedIconImage].Height) >> 3);    
    VOID *pStreamBits = GpMalloc(bufferSize);
    if (!pStreamBits) 
    {
        return E_OUTOFMEMORY;
    }
    
    // Now read the bits from the stream

    if (!SeekStreamPos(pIstream, STREAM_SEEK_SET,
                       IconDesc[iSelectedIconImage].DIBOffset +
                       sizeof(BmiBuffer)))
    {
        GpFree(pStreamBits);
        return E_FAIL;
    }
    
    if (!ReadStreamBytes(pIstream, pStreamBits, bufferSize))
    {
        GpFree(pStreamBits);
        return E_FAIL;
    }

    // Now allocate a GDI DIBSECTION to render the bitmap

    BITMAPINFO bmi;
    bmi.bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth         = imageInfo.Width;
    bmi.bmiHeader.biHeight        = imageInfo.Height;
    bmi.bmiHeader.biPlanes        = 1;
    bmi.bmiHeader.biBitCount      = 32;
    bmi.bmiHeader.biCompression   = BI_RGB;
    bmi.bmiHeader.biSizeImage     = 0;
    bmi.bmiHeader.biXPelsPerMeter = bmih->biXPelsPerMeter;
    bmi.bmiHeader.biYPelsPerMeter = bmih->biYPelsPerMeter;
    bmi.bmiHeader.biClrUsed       = 0;
    bmi.bmiHeader.biClrImportant  = 0;

    HDC hdcScreen = GetDC(NULL);
    if ( hdcScreen == NULL )
    {
        GpFree(pStreamBits);
        return E_FAIL;
    }
    
    hBitmapGdi = CreateDIBSection(hdcScreen, 
                                  (BITMAPINFO *) &bmi, 
                                  DIB_RGB_COLORS, 
                                  (void **) &pBitsGdi, 
                                  NULL, 
                                  0);
    if (!hBitmapGdi) 
    {
        GpFree(pStreamBits);
        ReleaseDC(NULL, hdcScreen);
        WARNING(("GpIcoCodec::GenerateGdiBits -- failed to create DIBSECTION"));
        return E_FAIL;
    }

    // The BITMAPINFOHEADER in the file should already have the correct size set for
    // RLEs, but in some cases it doesn't so we will fix it here.

    if ((bmih->biSizeImage == 0) || (bmih->biSizeImage > bufferSize)) 
    {
        bmih->biSizeImage = bufferSize;
    }
    
    INT numLinesCopied = SetDIBits(hdcScreen, 
                                   hBitmapGdi, 
                                   0, 
                                   imageInfo.Height,
                                   pStreamBits, 
                                   (BITMAPINFO *) &BmiHeaders[iSelectedIconImage], 
                                   DIB_RGB_COLORS);

    GpFree(pStreamBits);
    ReleaseDC(NULL, hdcScreen);

    if (numLinesCopied != (INT) imageInfo.Height) 
    {
        WARNING(("GpIcoCodec::GenerateGdiBits -- SetDIBits failed"));
        DeleteObject(hBitmapGdi);
        hBitmapGdi = NULL;
        pBitsGdi = NULL;

        return E_FAIL;
    }

    // At this point pBitsGdi contains the rendered bits in a native format.
    // This buffer will be released in EndDecode.

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Get the total number of dimensions the image supports
*
* Arguments:
*
*     count -- number of dimensions this image format supports
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpIcoCodec::GetFrameDimensionsCount(
    UINT* count
    )
{
    if ( count == NULL )
    {
        WARNING(("GpIcoCodec::GetFrameDimensionsCount--Invalid input parameter"));
        return E_INVALIDARG;
    }
    
    // Tell the caller that ICO is a one dimension image.

    *count = 1;

    return S_OK;
}// GetFrameDimensionsCount()

/**************************************************************************\
*
* Function Description:
*
*     Get an ID list of dimensions the image supports
*
* Arguments:
*
*     dimensionIDs---Memory buffer to hold the result ID list
*     count -- number of dimensions this image format supports
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpIcoCodec::GetFrameDimensionsList(
    GUID*   dimensionIDs,
    UINT    count
    )
{
    if ( (count != 1) || (dimensionIDs == NULL) )
    {
        WARNING(("GpIcoCodec::GetFrameDimensionsList-Invalid input param"));
        return E_INVALIDARG;
    }

    dimensionIDs[0] = FRAMEDIM_PAGE;

    return S_OK;
}// GetFrameDimensionsList()

/**************************************************************************\
*
* Function Description:
*
*     Get number of frames for the specified dimension
*     
* Arguments:
*
*     dimensionID --
*     count --     
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpIcoCodec::GetFrameCount(
    IN const GUID* dimensionID,
    OUT UINT* count
    )
{
    *count = 1;
    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Select currently active frame
*     
* Arguments:
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpIcoCodec::SelectActiveFrame(
    IN const GUID* dimensionID,
    IN UINT frameIndex
    )
{
    if ( (dimensionID == NULL) || (*dimensionID != FRAMEDIM_PAGE) )
    {
        WARNING(("GpIcoCodec::SelectActiveFrame--Invalid GUID input"));
        return E_INVALIDARG;
    }

    if ( frameIndex > 1 )
    {
        // ICO is a single frame image format

        WARNING(("GpIcoCodec::SelectActiveFrame--Invalid frame index"));
        return E_INVALIDARG;
    }

    return S_OK;
}// SelectActiveFrame()

/**************************************************************************\
*
* Function Description:
*
*   Get image thumbnail
*
* Arguments:
*
*   thumbWidth, thumbHeight - Specifies the desired thumbnail size in pixels
*   thumbImage - Returns a pointer to the thumbnail image
*
* Return Value:
*
*   Status code
*
* Note:
*
*   Even if the optional thumbnail width and height parameters are present,
*   the decoder is not required to honor it. The requested size is used
*   as a hint. If both width and height parameters are 0, then the decoder
*   is free to choose an convenient thumbnail size.
*
\**************************************************************************/

HRESULT
GpIcoCodec::GetThumbnail(
    IN OPTIONAL UINT thumbWidth,
    IN OPTIONAL UINT thumbHeight,
    OUT IImage** thumbImage
    )
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\ico\icocodec.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   icocodec.cpp
*
* Abstract:
*
*   Shared methods for the icon codec
*
* Revision History:
*
*   10/4/1999 DChinn
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "icocodec.hpp"


/**************************************************************************\
*
* Function Description:
*
*     Constructor
*
* Return Value:
*
*   none
*
\**************************************************************************/

GpIcoCodec::GpIcoCodec(
    void
    )
{
    comRefCount   = 1;
    pIstream      = NULL;
    decodeSink    = NULL;
    pColorPalette = NULL;
}

/**************************************************************************\
*
* Function Description:
*
*     Destructor
*
* Return Value:
*
*   none
*
\**************************************************************************/

GpIcoCodec::~GpIcoCodec(
    void
    )
{
    // The destructor should never be called before Terminate is called, but
    // if it does we should release our reference on the stream anyway to avoid
    // a memory leak.

    if(pIstream)
    {
        WARNING(("GpIcoCodec::~GpIcoCodec -- need to call TerminateDecoder first\n"));
        pIstream->Release();
        pIstream = NULL;
    }

    if(pColorPalette)
    {
        WARNING(("GpIcoCodec::~GpIcoCodec -- color palette not freed\n"));
        GpFree(pColorPalette);
        pColorPalette = NULL;
    }

}

/**************************************************************************\
*
* Function Description:
*
*     QueryInterface
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP
GpIcoCodec::QueryInterface(
    REFIID riid,
    VOID** ppv
    )
{
    if (riid == IID_IImageDecoder)
    {
        *ppv = static_cast<IImageDecoder*>(this);
    }
    else if (riid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(static_cast<IImageDecoder*>(this));
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     AddRef
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP_(ULONG)
GpIcoCodec::AddRef(
    VOID)
{
    return InterlockedIncrement(&comRefCount);
}

/**************************************************************************\
*
* Function Description:
*
*     Release
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP_(ULONG)
GpIcoCodec::Release(
    VOID)
{
    ULONG count = InterlockedDecrement(&comRefCount);

    if (count == 0)
    {
        delete this;
    }

    return count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\ico\icofile.h ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   icofile.h
*
* Abstract:
*
*   Header file with icon file structures.
*
* Revision History:
*
*   10/6/1999 DChinn
*       Created it.
*
\**************************************************************************/

#ifndef ICOFILE_H
#define ICOFILE_H

// The 3.0 icon structures come from the imagedit code

// 3.0 icon header
typedef struct {
    WORD Reserved;              // always 0
    WORD ResourceType;          // 1 for icons
    WORD ImageCount;            // number of images in file
} ICONHEADER;

// 3.0 icon descriptor
// Note that for an icon, the DIBSize includes the XORmask and
// the ANDmask.
typedef struct {
    BYTE Width;                 // width of image
    BYTE Height;                // height of image
    BYTE ColorCount;            // number of colors in image
    BYTE Unused;
    WORD nColorPlanes;          // color planes
    WORD BitCount;              // bits per pixel
    DWORD DIBSize;              // size of DIB for this image
    DWORD DIBOffset;            // offset to DIB for this image
} ICONDESC;

typedef struct 
{
    BITMAPINFOHEADER header;
    RGBQUAD colors[256];
} BmiBuffer;

#endif ICOFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\jpeg\adobethum.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   adobethum.cpp
*
* Abstract:
*
*   Read the properties from an APP13 header
*
* Revision History:
*
*   10/05/1999 MinLiu
*       Wrote it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "propertyutil.hpp"
#include "appproc.hpp"

#include <stdio.h>
#include <windows.h>

// Note: All data in Adobe file format are stored in big endian byte order. So
// under an X86 system, we have do the swap

inline UINT32
Read32(PCHAR* ppStart)
{
    UINT32 ui32Temp = *((UNALIGNED UINT32*)(*ppStart));
    *ppStart += 4;

    UINT32  uiResult = ((ui32Temp & 0xff) << 24)
                     | (((ui32Temp >> 8) & 0xff) << 16)
                     | (((ui32Temp >> 16) & 0xff) << 8)
                     | ((ui32Temp >> 24) & 0xff);

    return uiResult;
}// Read32()

inline UINT16
Read16(PCHAR* ppStart)
{
    UINT16 ui16Temp = *((UINT16*)(*ppStart));
    *ppStart += 2;

    UINT16  uiResult = ((ui16Temp & 0xff) << 8)
                     | ((ui16Temp >> 8) & 0xff);

    return uiResult;
}// Read16()

// Given an Adobe image resource block, this function parses the PString field.
// A Pascal string is a stream of characters and the first byte is the length of
// the string.
// Also, according to Adobe, this string is padded to make size even.
//
// This function returns the number of bytes occupied by the PString field.
//
// pResource---Points to the beginning of the PString field
//
// Note: the caller should guarantee that the pResource is valid

inline UINT32
GetPStringLength(
    char*   pResource
    )
{
    // First, get the "total length of the string"
    // Note: Here + 1 for the counter byte itself. So if the counter is 7,
    // actually we should have at least 8 bytes in this PString

    UINT32  uiStringLength = (UINT32)(*pResource) + 1;

    if ( (uiStringLength % 2 ) == 1 )
    {
        // The length is odd, so we need to pad it

        uiStringLength++;
    }

    return uiStringLength;
}// GetPStringLength()

// Adobe Image resource IDs
// This list is printed in "Photoshop File Formats.pdf" from Adobe Photoshop 5.0
// SDK document, Chapter 2 "Document File Formats", Table 2-2, page 8
//    Hex   Dec     Description
//  0x03E8  1000    Obsolete Photoshop 2.0 only. Contains five int16 values:
//                  number of channels, rows, columns, depth, and mode.
//  0x03E9  1001    Optional. Macintosh print manager print info record.
//  0x03EB  1003    Obsolete Photoshop 2.0 only. Contains the indexed color
//                  table.
//  0x03ED  1005    ResolutionInfo structure. See Appendix A in Photoshop SDK
//                  Guide.pdf.
//  0x03EE  1006    Names of the alpha channels as a series of Pascal strings.
//  0x03EF  1007    DisplayInfo structure. See Appendix A in Photoshop SDK
//                  Guide.pdf.
//  0x03F0  1008    Optional. The caption as a Pascal string.
//  0x03F1  1009    Border information. Contains a fixed-number for the border
//                  width, and an int16 for border units (1=inches, 2=cm,
//                  3=points, 4=picas, 5=columns).
//  0x03F2  1010    Background color. See the Colors additional file information
//  0x03F3  1011    Print flags. A series of one byte boolean values (see Page
//                  Setup dialog): labels, crop marks, color bars, registration
//                  marks, negative, flip, interpolate, caption.
//  0x03F4  1012    Grayscale and multichannel halftoning information.
//  0x03F5  1013    Color halftoning information.
//  0x03F6  1014    Duotone halftoning information.
//  0x03F7  1015    Grayscale and multichannel transfer function.
//  0x03F8  1016    Color transfer functions.
//  0x03F9  1017    Duotone transfer functions.
//  0x03FA  1018    Duotone image information.
//  0x03FB  1019    Two bytes for the effective black and white values for the
//                  dot range.
//  0x03FC  1020    Obsolete.
//  0x03FD  1021    EPS options.
//  0x03FE  1022    Quick Mask information. 2 bytes containing Quick Mask
//                  channel ID, 1 byte boolean indicating whether the mask was
//                  initially empty.
//  0x03FF  1023    Obsolete.
//  0x0400  1024    Layer state information. 2 bytes containing the index of
//                  target layer. 0=bottom layer.
//  0x0401  1025    Working path (not saved). See path resource format later in
//                  this chapter.
//  0x0402  1026    Layers group information. 2 bytes per layer containing a
//                  group ID for the dragging groups. Layers in a group have the
//                  same group ID.
//  0x0403  1027    Obsolete.
//  0x0404  1028    IPTC-NAA record. This contains the File Info... information.
//  0x0405  1029    Image mode for raw format files.
//  0x0406  1030    JPEG quality. Private.
//  0x0408  1032    New since version 4.0 of Adobe Photoshop:
//                  Grid and guides information. See grid and guides resource
//                  format later in this chapter.
//  0x0409  1033    New since version 4.0 of Adobe Photoshop:
//                  Thumbnail resource. See thumbnail resource format later in
//                  this chapter..
//  0x040A  1034    New since version 4.0 of Adobe Photoshop:
//                  Copyright flag. Boolean indicating whether image is
//                  copyrighted. Can be set via Property suite or by user in
//                  File Info...
//  0x040B  1035    New since version 4.0 of Adobe Photoshop:
//                  URL. Handle of a text string with uniform resource locator.
//                  Can be set via Property suite or by user in File Info...
//  0x040C  1036    New since version 5.0 of Adobe Photoshop:
//                  Thumbnail resource for Adobe 5.0+ generated JPEG image.
//                  Found it through reverse engineering. Not documented in this
//                  chapter. MinLiu, 10/07/99
//  0x07D0-0x0BB6 2000-2998
//                  Path Information (saved paths). See path resource format
//                  later in this chapter.
//  0x0BB7  2999    Name of clipping path. See path resource format later in
//                  this chapter.
//  0x2710 10000    Print flags information. 2 bytes version (=1), 1 byte center
//                  crop marks, 1 byte (=0), 4 bytes bleed width value, 2 bytes
//                  bleed width scale.

HRESULT
DoSwapRandB(
    IImage** ppSrcImage
    )
{
    // First we need to get an GpMemoryBitmap from IImage

    IImage* pSrcImage = *ppSrcImage;

    ImageInfo   srcImageInfo;
    pSrcImage->GetImageInfo(&srcImageInfo);
    
    GpMemoryBitmap* pMemBitmap = NULL;

    HRESULT hResult = GpMemoryBitmap::CreateFromImage(pSrcImage,
                                                      srcImageInfo.Width,
                                                      srcImageInfo.Height,
                                                      srcImageInfo.PixelFormat,
                                                      INTERP_DEFAULT,
                                                      &pMemBitmap);

    if (FAILED(hResult))
    {
        WARNING(("AdobeThumb, DoSwapRandB()---CreateFromImage failed"));
        return E_FAIL;
    }

    // Now we can play with the bits now

    BitmapData  srcBitmapData;
    RECT        myRect;

    myRect.left = 0;
    myRect.top = 0;
    myRect.right = srcImageInfo.Width;
    myRect.bottom = srcImageInfo.Height;

    hResult = pMemBitmap->LockBits(&myRect,
                                   IMGLOCK_WRITE,
                                   srcImageInfo.PixelFormat,
                                   &srcBitmapData);

    if (FAILED(hResult))
    {
        WARNING(("AdobeThumb, DoSwapRandB()---LockBits failed"));
        return hResult;
    }
    
    // Swap the data, R and B swap

    BYTE*   pSrcBits = (BYTE*)srcBitmapData.Scan0;

    if ( srcBitmapData.PixelFormat == PIXFMT_24BPP_RGB )
    {
        for ( UINT i = 0; i < srcBitmapData.Height; ++i )
        {
            for ( UINT j = 0; j < srcBitmapData.Width; ++j )
            {
                BYTE    cTemp = pSrcBits[2];
                pSrcBits[2] = pSrcBits[0];
                pSrcBits[0] = cTemp;

                pSrcBits += 3;
            }

            pSrcBits = (BYTE*)srcBitmapData.Scan0 + i * srcBitmapData.Stride;
        }
    }
    else
    {
        // All JPEG thumbnail should be in 24 RGB format

        WARNING(("Wrong JPEG thumbnail pixel format"));
        ASSERT(0);
    }

    hResult = pMemBitmap->UnlockBits(&srcBitmapData);
    if (FAILED(hResult))
    {
        WARNING(("AdobeThumb, DoSwapRandB()---UnlockBits failed"));
        return hResult;
    }

    // Release the original IImage

    pSrcImage->Release();

    // Convert the result back to IImage
    
    hResult = pMemBitmap->QueryInterface(IID_IImage, (void**)&pSrcImage);
    pMemBitmap->Release();
    if (FAILED(hResult))
    {
        WARNING(("AdobeThumb, DoSwapRandB()---QueryInterface failed"));
        return hResult;
    }

    *ppSrcImage = pSrcImage;

    return S_OK;
}// DoSwapRandB()

/**************************************************************************\
*
* Function Description:
*
*     Decodes the thumbnail image from given Adobe app13 header. Swap color
* channels if necessary.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
DecodeApp13Thumbnail(
    IImage** pThumbImage,   // The thumbnail extracted from the APP13 header
    PVOID pStart,           // A pointer to the beginning of the APP13 header
    INT iNumOfBytes,        // The length of the APP13 header
    BOOL bNeedConvert       // TRUE, if we need to do a R and B channle swap
                            // before return
    )
{
    // Thumbnail resource format
    // Adobe Photoshop 4.0 and later stores thumbnail information for preview
    // display in an image resource block. These resource blocks consist of an
    // initial 28 byte header, followed by a JFIF thumnail in BGR (blue, green,
    // red) order for both Macintosh and Windows.
    //
    // Thumnail resource header
    //
    // Type     Name            Description
    //
    // int32    format          = 1 (kJpegRGB). Also supports kRawRGB (0).
    // int32    width           Width of thumbnail in pixels.
    // int32    height          Height of thumbnail in pixels.
    // int32    widthbytes      Padded row bytes as (width * bitspixel + 31)
    //                                              / 32 * 4.
    // int32    size            Total size as widthbytes * height * planes
    // int32    compressedsize  Size after compression. Used for consistentcy
    //                          check.
    // int16    bitspixel       = 24. Bits per pixel.
    // int16    planes          = 1. Number of planes.
    // Variable Data            JFIF data in BGR format.
    
    char*   pChar = (char*)pStart;
    int     iFormat = Read32(&pChar);
    int     iWidth = Read32(&pChar);
    int     iHeight = Read32(&pChar);
    int     iWidthBytes = Read32(&pChar);
    int     iSize = Read32(&pChar);
    int     iCompressedSize = Read32(&pChar);
    INT16   i16BitsPixel = Read16(&pChar);
    INT16   i16Planes = Read16(&pChar);
        
    // The total bytes left for the thumbnail is "iNumOfBytes -28" bytes.
    // Here 28 is the total bytes the header takes
    //
    // We need to do a sanity check here to be sure that we passed the correct
    // data down. The size of the RAW JPEG data has to be the same as
    // "iCompressedSize"

    if ( iCompressedSize != (iNumOfBytes - 28) )
    {
        WARNING(("DecodeApp13Thumbnail:  raw jpeg data size wrong"));
        return E_INVALIDARG;
    }
    
    // Now we get the pointer to the data bits. We decode the thumbnail depends
    // on the compression format

    if ( iFormat == 1 )
    {
        // This is JPEG compressed thumbnail.

        #if PROFILE_MEMORY_USAGE
        MC_LogAllocation(iCompressedSize);
        #endif

        PVOID pvRawData = CoTaskMemAlloc(iCompressedSize);

        if ( NULL == pvRawData )
        {
            WARNING(("DecodeApp13Thumbnail:  out of memory"));
            return E_OUTOFMEMORY;
        }

        GpMemcpy(pvRawData, (PVOID)pChar, iCompressedSize);

        GpImagingFactory imgFact;

        // Tell ImageFactory to free the memory using GotaskMemFree() since we
        // allocated it through CoTaskMemAlloc()

        HRESULT hResult = imgFact.CreateImageFromBuffer(pvRawData, 
                                                        iCompressedSize, 
                                                        DISPOSAL_COTASKMEMFREE, 
                                                        pThumbImage);

        if ( FAILED(hResult) )
        {
            // If image creation succeeded, thumbnailBits will be freed by 
            // the IImage destructor

            CoTaskMemFree(pvRawData);
        }

        // If we need swap, do it

        if ( bNeedConvert == TRUE )
        {
            return DoSwapRandB(pThumbImage);
        }
    }// JPEG raw data

    return S_OK;
}// DecodeApp13Thumbnail()

/**************************************************************************\
*
* Function Description:
*
*   This function decodes an PS4 thumbnail from APP13 header and then adds it to
* the property list.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
AddPS4ThumbnailToPropertyList(
    InternalPropertyItem* pTail,// Tail to property item list
    PVOID pStart,               // Point to the beginning of the thumb resource
    INT cBytes,                 // Resource block size, in BYTEs
    OUT UINT *puThumbLength     // Total bytes of thumbanil data
    )
{
    // Call DecodeApp13Thumbnail() first to swap the color for PS4 thumbnail

    IImage *pThumbImg = NULL;

    HRESULT hr = DecodeApp13Thumbnail(&pThumbImg, pStart, cBytes, TRUE);
    if (SUCCEEDED(hr))
    {
        // Now we get a correct thumbnail in memory. Need to convert it to a
        // JPEG stream

        hr = AddThumbToPropertyList(
            pTail,
            (GpMemoryBitmap*)pThumbImg,
            cBytes,
            puThumbLength
            );

        // No matter we succeed in SaveIImageToJPEG(), we have to release
        // pThumbImg

        pThumbImg->Release();
    }

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   Gets the thumbnail from an APP13 marker
*
* Arguments:
*
*   pThumbImage ---- a pointer to the thumbnail image object to be created
*                    based on data extracted from the APP1 header
*   pvMarker ------- pointer to APP13 marker data
*   ui16MarkerLength -- length of APP13 segment
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GetAPP13Thumbnail(
    OUT IImage**    pThumbImage, 
    IN PVOID        pvMarker, 
    IN UINT16       ui16MarkerLength
    )
{
    *pThumbImage = NULL;

    // For any Adobe APP13 header, length must be at least 12

    if ( ui16MarkerLength < 12 )
    {
        return S_OK;
    }

    // Expect to find a header starting with "Photoshop " - if we get this then
    // skip everything until the trailing null.

    PCHAR   pChar = (PCHAR)pvMarker;
    INT     iBytesChecked = 0;

    if ( GpMemcmp(pChar, "Photoshop ", 10) == 0)
    {
        iBytesChecked = 10;
    }
    else if (GpMemcmp(pChar, "Adobe_Photoshop", 15) == 0)
    {
        iBytesChecked = 15;
    }
    else
    {
        WARNING(("GetAPP13Thumbnail:  APP13 header not Photoshop"));
        return S_OK;;
    }

    // Scan until we hit the end or a null.

    pChar += iBytesChecked;

    while ( (iBytesChecked < ui16MarkerLength) && (*pChar != 0) )
    {
        ++iBytesChecked;
        ++pChar;
    }

    iBytesChecked++;
    ++pChar;

    // If we didn't get a NULL before the end assume *not* photoshop
    
    if ( iBytesChecked >= ui16MarkerLength )
    {
        WARNING(("GetAPP13Thumbnail:  APP13 header not Photoshop"));
        return S_OK;;
    }

    // Now we should encount Adobe Image Resource block
    // The basic structure of Image Resource Blocks is shown below.
    // Image resources use several standard ID numbers, as shown below. Not
    // all file formats use all IDs. Some information may be stored in other
    // sections of the file.
    //
    //  Type    Name    Description
    //-------------------------------------------------------
    // OSType   Type    Photoshop always uses its signature, 8BIM.
    // int16    ID      Unique identifier.
    // PString  Name    A pascal string, padded to make size even (a null name
    //                  consists of two bytes of 0)
    // int32    Size    Actual size of resource data. This does not include the
    //                  Type, ID, Name, or Size fields.
    // Variable Data    Resource data, padded to make size even

    // Loop through all the resource blocks. Here "+12" is because a resource
    // block should have at least 12 bytes

    while ((iBytesChecked + 12) < ui16MarkerLength)
    {
        UINT16 ui16TagId = 0;
        INT32 iSize = 0;

        if ( GpMemcmp(pChar, "8BIM", 4) == 0 )
        {
            // It is a Photoshop resource block

            pChar += 4;

            // First, get the TAG

            ui16TagId = Read16(&pChar);

            // Skip the name field

            UINT32  uiNameStringLength = GetPStringLength(pChar);
            pChar += uiNameStringLength;

            // Get actual size of the resource data

            iSize = Read32(&pChar);

            // Total read 10 (4 for OSType, 2 for ID, 4 for Size) + "NameString
            // length" bytes so far

            iBytesChecked += (10 + uiNameStringLength);

            // According to Adobe Image resource ID, 1033(0x0409) is for Adobe
            // PhotoShop 4.0 Thumbnail and 1036(0x040C) is for PhotoShop 5.0
            // Thumbnail. We are only interested in these two tags now

            if ( ui16TagId == 1036 )
            {
                // If it is a Photoshop 5.0 thumbnail, we just need to
                // get the image and return. We don't need to further analyze
                // the resource data

                pvMarker = (PVOID)pChar;
                
                return DecodeApp13Thumbnail(pThumbImage, pvMarker, iSize,FALSE);
            }
            else if ( ui16TagId == 1033 )
            {
                // In Adobe Photoshop 4.0, the thumbnail is stored with R and B
                // swapped. So we have to swap it back before we return. That's
                // the reason we set the last parameter as TRUE
                
                pvMarker = (PVOID)pChar;
                
                return DecodeApp13Thumbnail(pThumbImage, pvMarker, iSize, TRUE);
            }
            else
            {
                // Proceed to the next tag. But before that we should be sure
                // that the size is an even number. If not, add 1

                if ( iSize & 1 )
                {
                    ++iSize;
                }

                iBytesChecked += iSize;
                pChar += iSize;
            }
        }// If the resource is started with 8BIM.
        else
        {
            // As the Adobe 5.0 SDK says that "Photoshop always uses its
            // signature, 8BIM". So if we don't find this signature, we can
            // assume this is not a correct APP13 marker

            WARNING(("GetAPP13Thumbnail: Header not started with 8BIM"));
            return S_OK;;
        }
    }// Loop through all the resource blocks

    // We don't find any PhotShop 4 or PhotoShop 5 thumbnail images if we reach
    // here

    return S_OK;
}// GetAPP13Thumbnail()

WCHAR*
ResUnits(
    int iType
    )
{
    switch ( iType )
    {
    case 1:
        return L"DPI\0";

    case 2:
        return L"DPcm\0";

    default:
        return L"UNKNOWN Res Unit Type\0";
    }
}// ResUnits()

WCHAR*
LengthUnits(
    int iType
    )
{
    switch ( iType )
    {
        case 1:
        return L"inches\0";

        case 2:
        return L"cm\0";

        case 3:
        return L"points\0";

        case 4:
        return L"picas\0";

        case 5:
        return L"columns\0";

        default:
                return L"UNKNOWN Length Unit Type\0";
        }
}// LengthUnits()

WCHAR*
Shape(
    int i
    )
{
    switch (i)
    {
    case 1:
        return L"ellipse";

    case 2:
        return L"line";

    case 3:
        return L"square";

    case 4:
        return L"cross";

    case 6:
        return L"diamond";
        
    default:
        if (i < 0)
        {
            return L"Custom";
        }
        else
        {
            return L"UNKNOWN:%d";
        }
    }
}// Shape()

HRESULT
TransformApp13(
    BYTE*   pApp13Data,
    UINT16  uiApp13Length
    )
{
    HRESULT             hResult;
    WCHAR               awcBuff[1024];

    // For any Adobe APP13 header, length must be at least 12

    if ( uiApp13Length < 12 )
    {
        return S_OK;
    }

    // Expect to find a header starting with "Photoshop " - if we get this then
    // skip everything until the trailing null.

    PCHAR   pChar = (PCHAR)pApp13Data;
    UINT    uiBytesChecked = 0;

    if ( GpMemcmp(pChar, "Photoshop ", 10) == 0)
    {
        uiBytesChecked = 10;
    }
    else if (GpMemcmp(pChar, "Adobe_Photoshop", 15) == 0)
    {
        uiBytesChecked = 15;
    }
    else
    {
        WARNING(("TransformApp13:  APP13 header not Photoshop"));
        return S_OK;;
    }

    // Scan until we hit the end or a null.

    pChar += uiBytesChecked;

    while ( (uiBytesChecked < uiApp13Length) && (*pChar != 0) )
    {
        ++uiBytesChecked;
        ++pChar;
    }

    uiBytesChecked++;
    ++pChar;

    // If we didn't get a NULL before the end assume *not* photoshop
    
    if ( uiBytesChecked >= uiApp13Length )
    {
        WARNING(("TransformApp13:  APP13 header not Photoshop"));
        return S_OK;;
    }

    // Now we should encount Adobe Image Resource block
    // The basic structure of Image Resource Blocks is shown below.
    // Image resources use several standard ID numbers, as shown below. Not
    // all file formats use all IDs. Some information may be stored in other
    // sections of the file.
    //
    //  Type    Name    Description
    //-------------------------------------------------------
    // OSType   Type    Photoshop always uses its signature, 8BIM.
    // int16    ID      Unique identifier.
    // PString  Name    A pascal string, padded to make size even (a null name
    //                  consists of two bytes of 0)
    // int32    Size    Actual size of resource data. This does not include the
    //                  Type, ID, Name, or Size fields.
    // Variable Data    Resource data, padded to make size even

    // Loop through all the resource blocks. Here "+12" is because a resource
    // block should have at least 12 bytes

    while ( uiBytesChecked + 12 < uiApp13Length )
    {
        UINT16  ui16TagId;
        INT32   iSize;
        char    ucTemp;
        WCHAR   awcTemp[100];
        UINT16* pui16TagAddress = 0;

        if ( GpMemcmp(pChar, "8BIM", 4) == 0 )
        {
            // It is a Photoshop resource block

            pChar += 4;

            // Remember the tag address for write back

            pui16TagAddress = (UINT16*)pChar;

            // First, get the TAG

            ui16TagId = Read16(&pChar);

            // Skip the name field

            UINT32  uiNameStringLength = GetPStringLength(pChar);
            pChar += uiNameStringLength;

            // Get actual size of the resource data

            iSize = Read32(&pChar);

            // Total read 10(4 for OSType, 2 for ID, 4 for Size) + "NameString
            // length" bytes so far

            uiBytesChecked += (10 + uiNameStringLength);

            // Now start to parsing the TAG we got and store the property
            // correspondingly
            // Note: For the explanation for each tags, see the top of this file

            switch ( ui16TagId )
            {
            case 1033:
            case 1036:
            {
                // (0x409) (0x40C) It is a Photoshop 4.0 or 5.0 thumbnail

                INT32   iFormat = Read32(&pChar);
                INT32   iWidth = Read32(&pChar);
                INT32   iHeight = Read32(&pChar);
                INT32   iWidthBytes = Read32(&pChar);
                INT32   size = Read32(&pChar);
                INT32   iCompressedSize = Read32(&pChar);
                INT16   i16BitsPixel = Read16(&pChar);
                INT16   i16Planes = Read16(&pChar);

                switch ( iFormat )
                {
                case 0:
                    // Raw RGB format
                    
                    break;

                case 1:
                    // JPEG format
                    
                    break;

                default:
                    WARNING(("BAD thumbnail data format"));
                    
                    break;
                }

                // Switching thumbnail here
                
                // Here 28 is the total bytes the header takes
                
                uiBytesChecked += iSize;
                pChar += (iSize - 28);

                // Switch the thumbnail tag to an unknown tag for now to disable
                // thumbnail after transformation

                *pui16TagAddress = (UINT16)0x3fff;
            }

                break;
            
            default:

                uiBytesChecked += iSize;
                pChar += iSize;
                
                break;
            }// TAG parsing
            
            // Proceed to the next tag. But before that we should be sure
            // that the size is an even number. If not, add 1

            if ( iSize & 1 )
            {
                ++iSize;
                pChar++;
            }
        }// If the resource is started with 8BIM.
        else
        {
            // As the Adobe 5.0 SDK says that "Photoshop always uses its
            // signature, 8BIM". So if we don't find this signature, we can
            // assume this is not a correct APP13 marker

            WARNING(("TransformApp13: Header not started with 8BIM"));
            
            return S_OK;;
        }
    }// Loop through all the resource blocks

    return S_OK;
}// TransformApp13()

/**************************************************************************\
*
* Function Description:
*
*     Decodes the Adobe app13 header and build a PropertyItem list
*
* Arguments:
*
*     [OUT] ppList--------- A pointer to a list of property items
*     [OUT] puiListSize---- The total size of the property list, in bytes.
*     [OUT] puiNumOfItems-- Total number of property items
*     [IN]  lpAPP13Data---- A pointer to the beginning of the APP13 header
*     [IN]  ui16MarkerLength - The length of the APP13 header
*
* Return Value:
*
*   Status code
*
* Note: We don't bother to check input parameters here because this function
*       is only called from jpgdecoder.cpp which has already done the input
*       validation there.
*
\**************************************************************************/

HRESULT
BuildApp13PropertyList(
    InternalPropertyItem*   pTail,
    UINT*                   puiListSize,
    UINT*                   puiNumOfItems,
    LPBYTE                  lpAPP13Data,
    UINT16                  ui16MarkerLength
    )
{
    HRESULT hResult = S_OK;
    UINT    uiListSize = 0;
    UINT    uiNumOfItems = 0;
    UINT    valueLength;

    // For any Adobe APP13 header, length must be at least 12

    if ( ui16MarkerLength < 12 )
    {
        return S_OK;
    }

    // Expect to find a header starting with "Photoshop " - if we get this then
    // skip everything until the trailing null.

    PCHAR   pChar = (PCHAR)lpAPP13Data;
    INT     iBytesChecked = 0;

    if ( GpMemcmp(pChar, "Photoshop ", 10) == 0)
    {
        iBytesChecked = 10;
    }
    else if (GpMemcmp(pChar, "Adobe_Photoshop", 15) == 0)
    {
        iBytesChecked = 15;
    }
    else
    {
        WARNING(("BuildApp13PropertyList:  APP13 header not Photoshop"));
        return S_OK;;
    }

    // Scan until we hit the end or a null.

    pChar += iBytesChecked;

    while ( (iBytesChecked < ui16MarkerLength) && (*pChar != 0) )
    {
        ++iBytesChecked;
        ++pChar;
    }

    iBytesChecked++;
    ++pChar;

    // If we didn't get a NULL before the end assume *not* photoshop
    
    if ( iBytesChecked >= ui16MarkerLength )
    {
        WARNING(("BuildApp13PropertyList:  APP13 header not Photoshop"));
        return S_OK;;
    }

    // Now we should encount Adobe Image Resource block
    // The basic structure of Image Resource Blocks is shown below.
    // Image resources use several standard ID numbers, as shown below. Not
    // all file formats use all IDs. Some information may be stored in other
    // sections of the file.
    //
    //  Type    Name    Description
    //-------------------------------------------------------
    // OSType   Type    Photoshop always uses its signature, 8BIM.
    // int16    ID      Unique identifier.
    // PString  Name    A pascal string, padded to make size even (a null name
    //                  consists of two bytes of 0)
    // int32    Size    Actual size of resource data. This does not include the
    //                  Type, ID, Name, or Size fields.
    // Variable Data    Resource data, padded to make size even

    // Loop through all the resource blocks. Here "+12" is because a resource
    // block should have at least 12 bytes

    while ( (iBytesChecked + 12) < ui16MarkerLength )
    {
        UINT16  ui16TagId;
        INT32   iSize;
        char    ucTemp;
        WCHAR   awcTemp[100];

        if ( GpMemcmp(pChar, "8BIM", 4) == 0 )
        {
            // It is a Photoshop resource block

            pChar += 4;

            // First, get the TAG

            ui16TagId = Read16(&pChar);

            // Skip the name field

            UINT32  uiNameStringLength = GetPStringLength(pChar);
            pChar += uiNameStringLength;

            // Get actual size of the resource data

            iSize = Read32(&pChar);

            // Total read 10(4 for OSType, 2 for ID, 4 for Size) + "NameString
            // length" bytes so far

            iBytesChecked += (10 + uiNameStringLength);

            // Now start to parsing the TAG we got and store the property
            // correspondingly
            // Note: For the explanation for each tags, see the top of this file

            switch ( ui16TagId )
            {
            case 1005:
                // (0x3ED) Resolution unit info. Has to be 16 bytes long
                
                if ( iSize != 16 )
                {
                    WARNING(("APP13_Property: Bad length for tag 1005(0x3ed)"));
                    
                    iBytesChecked += iSize;
                    pChar += iSize;
                }
                else
                {
                    INT32   hRes = Read32(&pChar);
                    INT16   hResUnit = Read16(&pChar);
                    INT16   widthUnit = Read16(&pChar);
                    INT32   vRes = Read32(&pChar);
                    INT16   vResUnit = Read16(&pChar);
                    INT16   heightUnit = Read16(&pChar);
                    
                    // We have read total of 16 bytes

                    iBytesChecked += 16;
                    
                    // EXIF doesn't have the concept of X res unit and Y res
                    // unit. It has only one res unit.
                    // Besides, there is no UI in Photoshop to allow you set
                    // different res unit for X and Y. So here we will write out
                    // resolution info iff the hResUnit and vResUnit are
                    // identical

                    if (hResUnit == vResUnit)
                    {
                        LONG    llTemp[2];
                        llTemp[0] = hRes;
                        llTemp[1] = (1 << 16);
                        valueLength = sizeof(LONGLONG);

                        hResult = AddPropertyList(
                            pTail, 
                            TAG_X_RESOLUTION,
                            valueLength, 
                            TAG_TYPE_RATIONAL,
                            llTemp
                            );

                        if (FAILED(hResult))
                        {
                            goto Done;
                        }

                        uiNumOfItems++;
                        uiListSize += valueLength;

                        // property....

                        llTemp[0] = vRes;
                        llTemp[1] = (1 << 16);

                        hResult = AddPropertyList(
                            pTail, 
                            TAG_Y_RESOLUTION,
                            valueLength, 
                            TAG_TYPE_RATIONAL,
                            llTemp
                            );

                        if (FAILED(hResult))
                        {
                            goto Done;
                        }

                        uiNumOfItems++;
                        uiListSize += valueLength;

                        // According to the spec, Adobe always stores DPI
                        // value in hRes and vRes fields, regardless what the
                        // value is set in hResUnit/vResUnit.
                        // So the res unit we set here is always 2, which
                        // according to EXIF spec is inch

                        hResUnit = 2;

                        valueLength = sizeof(SHORT);

                        hResult = AddPropertyList(
                            pTail, 
                            TAG_RESOLUTION_UNIT,
                            valueLength, 
                            TAG_TYPE_SHORT,
                            &hResUnit
                            );

                        if (FAILED(hResult))
                        {
                            goto Done;
                        }

                        uiNumOfItems++;
                        uiListSize += valueLength;
                    }// hResUnit == vResUnit
                }
                    break;

            case 1033:
            case 1036:
            {
                // Remember the beginning of the thumbnail resource block

                CHAR *pThumbRes = pChar;

                // (0x409) (0x40C) It is a Photoshop 4.0 or 5.0 thumbnail

                INT32   iFormat = Read32(&pChar);
                INT32   iWidth = Read32(&pChar);
                INT32   iHeight = Read32(&pChar);
                INT32   iWidthBytes = Read32(&pChar);
                INT32   size = Read32(&pChar);
                INT32   iCompressedSize = Read32(&pChar);
                INT16   i16BitsPixel = Read16(&pChar);
                INT16   i16Planes = Read16(&pChar);

                if (iFormat == 1)
                {
                    // JPEG compressed thumbnail
                    // Add a JPEG compression TAG to it. This is necessary when
                    // this thumbnail is saved in the APP1's 1st IFD

                    valueLength = sizeof(UINT16);
                    UINT16 u16Dummy = 6;    // JPEG compression value

                    hResult = AddPropertyList(
                        pTail,
                        TAG_THUMBNAIL_COMPRESSION,
                        valueLength,
                        TAG_TYPE_SHORT,
                        (void*)&u16Dummy
                        );

                    if (FAILED(hResult))
                    {
                        goto Done;
                    }

                    uiNumOfItems++;
                    uiListSize += valueLength;

                    UINT uThumLength = (UINT)iCompressedSize;

                    if (ui16TagId == 1036)
                    {
                        // Photoshop V5.0+ thumbnail. We can add it to the
                        // property list directly

                        hResult = AddPropertyList(
                            pTail,
                            TAG_THUMBNAIL_DATA,
                            iCompressedSize,
                            TAG_TYPE_BYTE,
                            (void*)pChar
                            );
                    }
                    else if (ui16TagId == 1033)
                    {
                        // Photoshop V4.0 and older thumbnail. We have to color swap
                        // it before it can be add to property list

                        hResult = AddPS4ThumbnailToPropertyList(
                            pTail,
                            pThumbRes,
                            iSize,
                            &uThumLength
                            );
                    }

                    if (FAILED(hResult))
                    {
                        goto Done;
                    }

                    uiNumOfItems++;
                    uiListSize += uThumLength;

                    // Here 28 is the total bytes the header takes

                    iBytesChecked += iSize;
                    pChar += (iSize - 28);
                    
                    // Here 28 is the total bytes the header takes

                    iBytesChecked += iSize;
                    pChar += (iSize - 28);
                }// (iFormat == 1)
            }

                break;
            
            default:                
                iBytesChecked += iSize;
                pChar += iSize;
                
                break;
            }// TAG parsing
            
            // Proceed to the next tag. But before that we should be sure
            // that the size is an even number. If not, add 1

            if ( iSize & 1 )
            {
                ++iSize;
                pChar++;
            }
        }// If the resource is started with 8BIM.
        else
        {
            // As the Adobe 5.0 SDK says that "Photoshop always uses its
            // signature, 8BIM". So if we don't find this signature, we can
            // assume this is not a correct APP13 marker

            WARNING(("BuildApp13PropertyList: Header not started with 8BIM"));
            
            hResult = S_OK;
            
            // We must go to done because we've potentially added a lot of 
            // properties successfully. We need to account for those in the
            // list - otherwise they won't get cleaned up correctly.
            
            goto Done;
        }

        if ( FAILED(hResult) )
        {
            goto Done;
        }
    }// Loop through all the resource blocks


Done:
    
    *puiNumOfItems += uiNumOfItems;
    *puiListSize += uiListSize;

    return hResult;
}// BuildApp13PropertyList()

/**************************************************************************\
*
* Function Description:
*
*     Extract Adobe information, like resolution etc, from the header and set
*     the j_decompress_ptr accordingly
*
* Arguments:
*
*   [IN/OUT] cinfo------JPEG decompress structure
*   [IN] pApp13Data-----Pointer to APP13 header
*   [IN] uiApp13Length--Total length of this APP13 header in bytes
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
ReadApp13HeaderInfo(
    j_decompress_ptr    cinfo,
    BYTE*               pApp13Data,
    UINT16              uiApp13Length
    )
{
    HRESULT             hResult;

    // For any Adobe APP13 header, length must be at least 12

    if ( uiApp13Length < 12 )
    {
        return S_OK;
    }

    // Expect to find a header starting with "Photoshop " - if we get this then
    // skip everything until the trailing null.

    PCHAR   pChar = (PCHAR)pApp13Data;
    UINT    uiBytesChecked = 0;

    if ( GpMemcmp(pChar, "Photoshop ", 10) == 0 )
    {
        uiBytesChecked = 10;
    }
    else if ( GpMemcmp(pChar, "Adobe_Photoshop", 15) == 0 )
    {
        uiBytesChecked = 15;
    }
    else
    {
        WARNING(("ReadApp13HeaderInfo:  APP13 header not Photoshop"));
        return S_OK;;
    }

    // Scan until we hit the end or a null.

    pChar += uiBytesChecked;

    while ( (uiBytesChecked < uiApp13Length) && (*pChar != 0) )
    {
        ++uiBytesChecked;
        ++pChar;
    }

    uiBytesChecked++;
    ++pChar;

    // If we didn't get a NULL before the end assume *not* photoshop
    
    if ( uiBytesChecked >= uiApp13Length )
    {
        WARNING(("ReadApp13HeaderInfo:  APP13 header not Photoshop"));
        return S_OK;;
    }

    // Now we should encount Adobe Image Resource block
    // The basic structure of Image Resource Blocks is shown below.
    // Image resources use several standard ID numbers, as shown below. Not
    // all file formats use all IDs. Some information may be stored in other
    // sections of the file.
    //
    //  Type    Name    Description
    //-------------------------------------------------------
    // OSType   Type    Photoshop always uses its signature, 8BIM.
    // int16    ID      Unique identifier.
    // PString  Name    A pascal string, padded to make size even (a null name
    //                  consists of two bytes of 0)
    // int32    Size    Actual size of resource data. This does not include the
    //                  Type, ID, Name, or Size fields.
    // Variable Data    Resource data, padded to make size even

    // Loop through all the resource blocks. Here "+12" is because a resource
    // block should have at least 12 bytes

    while ( uiBytesChecked + 12 < uiApp13Length )
    {
        UINT16  ui16TagId;
        INT32   iSize;
        char    ucTemp;
        WCHAR   awcTemp[100];
        UINT16* pui16TagAddress = 0;

        if ( GpMemcmp(pChar, "8BIM", 4) == 0 )
        {
            // It is a Photoshop resource block

            pChar += 4;

            // Remember the tag address for write back

            pui16TagAddress = (UINT16*)pChar;

            // First, get the TAG

            ui16TagId = Read16(&pChar);

            // Skip the name field

            UINT32  uiNameStringLength = GetPStringLength(pChar);
            pChar += uiNameStringLength;

            // Get actual size of the resource data

            iSize = Read32(&pChar);

            // Total read 10(4 for OSType, 2 for ID, 4 for Size) + "NameString
            // length" bytes so far

            uiBytesChecked += (10 + uiNameStringLength);

            // Now start to parsing the TAG to get resolution info
            // Note: For the explanation for each tags, see the top of this file

            switch ( ui16TagId )
            {
            case 1005:
                // (0x3ED) Resolution unit info. Has to be 16 bytes long
                
                if ( iSize != 16 )
                {
                    WARNING(("ReadApp13HeaderInfo: Bad length for tag 0x3ed"));
                    
                    uiBytesChecked += iSize;
                    pChar += iSize;
                }
                else
                {
                    // Adobe ResolutionInfo structure, from
                    // "Photoshop API Guide .pdf", page 172
                    //
                    // Type     Field   Description
                    // Fixed    hRes    Horizontal resolution in pixels per inch
                    // int16    hResUnit 1=display horitzontal resolution in
                    //                  pixels per inch; 2=display horitzontal
                    //                  resolution in pixels per cm.
                    // int16    widthUnit Display width as 1=inches; 2=cm;
                    //                  3=points; 4=picas; 5=col-umns.
                    // Fixed    vRes    Vertial resolution in pixels per inch.
                    // int16    vResUnit 1=display vertical resolution in pixels
                    //                  per inch; 2=display vertical resolution
                    //                  in pixels per cm.
                    // int16    heightUnit Display height as 1=inches; 2=cm;
                    //                  3=points; 4=picas; 5=col-umns.

                    INT32   hRes = Read32(&pChar);
                    INT16   hResUnit = Read16(&pChar);
                    INT16   widthUnit = Read16(&pChar);
                    INT32   vRes = Read32(&pChar);
                    INT16   vResUnit = Read16(&pChar);
                    INT16   heightUnit = Read16(&pChar);
                    
                    // We have read total of 16 bytes

                    uiBytesChecked += 16;

                    if ( hResUnit == vResUnit )
                    {
                        cinfo->X_density = (UINT16)((double)hRes / 65536.0+0.5);
                        cinfo->Y_density = (UINT16)((double)vRes / 65536.0+0.5);

                        // According to the spec above, Adobe always stores DPI
                        // value in hRes and vRes fields, regardless what the
                        // value is set in hResUnit/vResUnit.
                        // For GDI+, since we only report DPI info to the
                        // caller. So this is perfect for us, that is, we always
                        // get the value and tell the caller that the UNIT is
                        // DPI (pixel per inch, aka DPI)
                        // See Windows bug#407100

                        cinfo->density_unit = 1;
                    }
                }
                
                break;

            default:

                uiBytesChecked += iSize;
                pChar += iSize;
                
                break;
            }// TAG parsing
            
            // Proceed to the next tag. But before that we should be sure
            // that the size is an even number. If not, add 1

            if ( iSize & 1 )
            {
                ++iSize;
                pChar++;
            }
        }// If the resource is started with 8BIM.
        else
        {
            // As the Adobe 5.0 SDK says that "Photoshop always uses its
            // signature, 8BIM". So if we don't find this signature, we can
            // assume this is not a correct APP13 marker

            WARNING(("ReadApp13HeaderInfo: Header not started with 8BIM"));
            
            return S_OK;;
        }
    }// Loop through all the resource blocks

    return S_OK;
}// ReadApp13HeaderInfo()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\jpeg\appproc.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   markerproc.cpp
*
* Abstract:
*
*   Read the app,  other than APP0,1,13, properties from an APP header
*
* Revision History:
*
*   10/05/1999 MinLiu
*       Wrote it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "propertyutil.hpp"

/**************************************************************************\
*
* Function Description:
*
*     Extract the ICC_PROFILE from an APP2 header and build a PropertyItem list
*
* Arguments:
*
*     [OUT] ppList--------- A pointer to a list of property items
*     [OUT] puiListSize---- The total size of the property list, in bytes.
*     [OUT] puiNumOfItems-- Total number of property items
*     [IN]  lpAPP2Data----- A pointer to the beginning of the APP2 header
*     [IN]  iMarkerLength - The length of the APP13 header
*
* Return Value:
*
*   Status code
*
* Note: We don't bother to check input parameters here because this function
*       is only called from jpgdecoder.cpp which has already done the input
*       validation there.
*
*       An APP2 header usually contains either ICC_PROFILE info or FLASHPIX
*       information. We are not interested in FLASHPIX info here
*
*   Here is the "ICC_PROFILE in JFIF" spec from ICC
*
* B.4 Embedding ICC Profiles in JFIF Files
* The JPEG standard (ISO/IEC 10918-1) supports application specific data
* segments. These segments may be used for tagging images with ICC profiles.
* The APP2 marker is used to introduce the tag. Given that there are only 15
* supported APP markers, there is a chance of many applications using the same
* marker. ICC tags are thus identified by beginning the data with a special null
* terminated byte sequence, "ICC_PROFILE".
* The length field of a JPEG marker is only two bytes long; the length of the
* length field is included in the total. Hence, the values 0 and 1 are not legal
* lengths. This would limit maximum data length to 65533. The identification
* sequence would lower this even further. As it is quite possible for an ICC
* profile to be longer than this, a mechanism must exist to break the profile
* into chunks and place each chunk in a separate marker. A mechanism to identify
* each chunk in sequence order would thus be useful.
* The identifier sequence is followed by one byte indicating the sequence number
* of the chunk (counting starts at 1) and one byte indicating the total number
* of chunks. All chunks in the sequence must indicate the same total number of
* chunks. The one-byte chunk count limits the size of embeddable profiles to
* 16,707,345 bytes.
*
\**************************************************************************/

//!!! TODO, need some test images which contains more than 1 ICC_PROFILE chunk

HRESULT
BuildApp2PropertyList(
    InternalPropertyItem*   pTail,
    UINT*                   puiListSize,
    UINT*                   puiNumOfItems,
    LPBYTE                  lpAPP2Data,
    UINT16                  iMarkerLength
    )
{
    HRESULT hResult = S_OK;
    UINT    uiListSize = 0;
    UINT    uiNumOfItems = 0;

    PCHAR   pChar = (PCHAR)lpAPP2Data;
    INT     iBytesChecked = 0;
    INT     iProfileIndex = 0;
    INT     iProfileTotal = 0;
    INT     iProfileLength = 0;

    // Expect ICC_PROFILE followed by the two byte count/limit values, our
    // byte count has already discounted the length.

    if ( (iMarkerLength >= 14) && (GpMemcmp(pChar, "ICC_PROFILE", 12) == 0) )
    {
        // For an ICC_PROFILE, the header should be something like:
        // "ICCPROFILE xy". Here "x" is the current index of the profile, "y" is
        // the total number of profiles in this header
        //
        // If it is a profile chunk, it must be the *next* chunk, if not we will
        // junk all the ICC chunks we find.

        if ( pChar[12] == (iProfileIndex + 1) )
        {
            if ( iProfileIndex == 0 )
            {
                // First chunk

                if ( iProfileTotal == 0 )
                {
                    // Really is the first one since we haven't got the total
                    // number yet

                    if ( pChar[13] > 0 )
                    {
                        iProfileIndex = 1;
                        iProfileTotal = pChar[13];

                        // We allow emtpy chunks!

                        iProfileLength = iMarkerLength - 14;
                        pChar = (PCHAR)lpAPP2Data + 14;

                        uiNumOfItems++;
                        uiListSize += iProfileLength;

                        hResult = AddPropertyList(pTail,
                                                  TAG_ICC_PROFILE,
                                                  iProfileLength,
                                                  TAG_TYPE_BYTE,
                                                  (void*)pChar);
                    }// Total number of chunks
                    else
                    {
                        WARNING(("JPEG ICC_PROFILE Total chunk No. is 0 %d %d",
                                 pChar[12], pChar[13]));
                        return E_FAIL;
                    }
                }// Check if we have got the total chunk number yet
                else
                {
                    // We can't accept "ICCPROFILE xy" where "x" is zero and "y"
                    // is not zero

                    WARNING(("JPEG: ICC_PROFILE[%d,%d], inconsistent %d",
                             pChar[12], pChar[13],iProfileTotal));
                    
                    return E_FAIL;
                }
            }// Check if it is the first chunk, if ( iProfileIndex == 0 )
            else if ( pChar[13] == iProfileTotal )
            {
                // This is not the first chunk. It is a subsequence chunk

                iProfileIndex++;
                iProfileLength += iMarkerLength - 14;

                return S_OK;
            }
            else
            {
                WARNING(("JPEG: ICC_PROFILE[%d,%d], changed count [,%d]",
                         pChar[12], pChar[13], iProfileTotal));
            }
        }
        else if ( (iProfileIndex == 256)
                ||(iProfileIndex == iProfileTotal)
                && (pChar[13] == iProfileTotal)
                && (pChar[12] >= 1)
                && (pChar[12] <= iProfileTotal) )
        {

            // If we read the same JPEG header twice we get here on the first
            // chunk and all subsequent ones, allow this to happen.
            // (iProfileIndex == 256) means Already cancelled

            return S_OK;
        }
        else
        {
            WARNING(("JPEG: ICC_PROFILE[%d,%d], expected [%d,]",
                     pChar[12], pChar[13], iProfileIndex));
        }

        // This cancels all further checking, because m_iICC+1 is 257 and
        // this is bigger than any byte value.

        iProfileIndex = 256;
    }// ICC_PROFILE signiture
    else
    {
        WARNING(("JPEG: FlashPix: APP2 marker not yet handled"));
        
        return S_OK;
    }

    *puiNumOfItems += uiNumOfItems;
    *puiListSize += uiListSize;

    return hResult;
}// BuildApp2PropertyList()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\jpeg\exif.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   exif.cpp
*
* Abstract:
*
*   Read the exif properties from an APP1 header
*
* Revision History:
*
*   7/13/1999 OriG
*       Created it.  Based on code by RickTu.
*
*   7/31/2000 MinLiu took over. 90% of the old code are gone, replaced with
*   a new Image property concept based code
*
\**************************************************************************/

#include "precomp.hpp"
#include "jpgcodec.hpp"
#include "propertyutil.hpp"
#include "appproc.hpp"

/**************************************************************************\
*
* Function Description:
*
*     Swaps an IFD tag
*
* Arguments:
*
*     IFD_TAG -- a pointer to the IFD tag
*
* Return Value:
*
*   IFD_TAG
*
\**************************************************************************/

IFD_TAG
SwapIFD_TAG(
    IFD_TAG UNALIGNED * pTag
    )
{
    IFD_TAG tNewTag;

    tNewTag.wTag = SWAP_WORD(pTag->wTag);
    tNewTag.wType = SWAP_WORD(pTag->wType);
    tNewTag.dwCount= SWAP_DWORD(pTag->dwCount);
    if (tNewTag.dwCount == 1)
    {
        switch (tNewTag.wType)
        {
        case TAG_TYPE_BYTE:
            tNewTag.b = pTag->b;
            break;

        case TAG_TYPE_SHORT:
            tNewTag.us = SWAP_WORD(pTag->us);
            break;

        default:
            // This swap will cover all of our cases.

            tNewTag.dwOffset = SWAP_DWORD(pTag->dwOffset);
            break;
        }
    }
    else
    {
        // This swap will cover all of our cases.

        tNewTag.dwOffset = SWAP_DWORD(pTag->dwOffset);
    }

    return tNewTag;
}// SwapIFD_TAG()

/**************************************************************************\
*
* Function Description:
*
*     Creates thumbnail from EXIF image
*
* Arguments:
*
*     thumbImage - The thumbnail extracted from the APP1 header
*     lpBase -- A pointer to the beginning of the APP1 header
*     count -- The length of the APP1 header
*     pTag -- A pointer to the current IFD tag
*     pdwThumbnailOffset -- The offset of the thumbnail in the APP1 header
*     pdwThumbnailLength -- The length of the thumbnail data
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
DecodeThumbnailTags(
    OUT IImage **thumbImage,
    IN LPBYTE lpBase,
    IN INT count,
    IN IFD_TAG UNALIGNED * pTag,
    IN OUT DWORD *pdwThumbnailOffset,
    IN OUT DWORD *pdwThumbnailLength
    )
{
    HRESULT hresult;

    if (*thumbImage)
    {
        WARNING(("DecodeThumbnailTag called when thumbnail already created"));
        return S_OK;
    }

    switch (pTag->wTag) {
    case TAG_JPEG_INTER_FORMAT:
        if ( (pTag->wType != TAG_TYPE_LONG) || (pTag->dwCount != 1) )
        {
            WARNING(("JPEGInterchangeFormat unit found, invalid format."));
        }
        else
        {
            *pdwThumbnailOffset = pTag->dwOffset;
        }
        break;
    case TAG_JPEG_INTER_LENGTH:
        if ( (pTag->wType != TAG_TYPE_LONG) || (pTag->dwCount != 1) )
        {
            WARNING(("JPEGInterchangeLength unit found, invalid format."));
        }
        else
        {
            *pdwThumbnailLength = pTag->dwOffset;
        }
        break;
    default:
        WARNING(("TAG: Invalid Thumbnail Tag"));
        break;
    }

    if (*pdwThumbnailOffset && *pdwThumbnailLength)
    {
        if ((*pdwThumbnailOffset + *pdwThumbnailLength) > ((DWORD) count))
        {
            WARNING(("Thumbnail found outside boundary of APP1 header"));
            return E_FAIL;
        }

        #if PROFILE_MEMORY_USAGE
        MC_LogAllocation(*pdwThumbnailLength);
        #endif
        PVOID thumbnailBits = CoTaskMemAlloc(*pdwThumbnailLength);
        if (!thumbnailBits)
        {
            WARNING(("DecodeThumbnailTags:  out of memory"));
            return E_OUTOFMEMORY;
        }

        GpMemcpy(thumbnailBits,
                 (PVOID) (lpBase + *pdwThumbnailOffset),
                 *pdwThumbnailLength);

        GpImagingFactory imgFact;

        hresult = imgFact.CreateImageFromBuffer(thumbnailBits,
                                                *pdwThumbnailLength,
                                                DISPOSAL_COTASKMEMFREE,
                                                thumbImage);

        if (FAILED(hresult))
        {
            // If image creation succeeded, thumbnailBits will be freed by
            // the IImage destructor

            CoTaskMemFree(thumbnailBits);
        }
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*     Decodes the EXIF app1 header
*
* Arguments:
*
*     propStgImg -- The property storage to modify
*     thumbImage -- The thumbnail extracted from the APP1 header
*     lpStart -- A pointer to the beginning of the APP1 header
*     count -- The length of the APP1 header
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
DecodeApp1(
    IImage **thumbImage,
    LPBYTE lpStart,
    INT count
    )
{
    DWORD  dwThumbnailOffset = 0;
    DWORD  dwThumbnailLength = 0;
    LPBYTE lpData = NULL;
    DWORD  offset = 0;
    WORD   wEntries = 0;

    //
    // Decipher data
    //

    if (count < 8)
    {
        //
        // Make sure the buffer is big enough
        //

        return E_FAIL;
    }

    BOOL    bBigEndian = (*(WORD UNALIGNED *)(lpStart) == 0x4D4D);

    offset = *(DWORD UNALIGNED *)(lpStart + 4);
    if (bBigEndian) 
        offset = SWAP_DWORD(offset);

    lpData = (lpStart + offset);

    //
    // Loop through IFD's
    //

    do
    {
        //
        // Get number of entries
        //

        if ((INT) (lpData - lpStart) > (count + (INT) sizeof(WORD)))
        {
            //
            // Buffer too small
            //

            return E_FAIL;
        }


        wEntries = *(WORD UNALIGNED*)lpData;
        if (bBigEndian)
            wEntries = SWAP_WORD(wEntries);
        lpData += sizeof(WORD);

        // Loop through entries

        if (((INT)(lpData - lpStart) + ((INT)wEntries * (INT)sizeof(IFD_TAG)))
            > (INT)count )
        {
            // Buffer too small

            return E_FAIL;
        }

        IFD_TAG UNALIGNED * pTag = (IFD_TAG UNALIGNED *)lpData;
        for (INT i = 0; i < wEntries; i++)
        {
            pTag = ((IFD_TAG UNALIGNED*)lpData) + i;

            IFD_TAG tNewTag;
            if (bBigEndian) {
                tNewTag = SwapIFD_TAG(pTag);
                pTag = &tNewTag;
            }

            // Extract thumbnail

            switch (pTag->wTag)
            {
            case TAG_JPEG_INTER_FORMAT:
            case TAG_JPEG_INTER_LENGTH:
                DecodeThumbnailTags(thumbImage, lpStart, count, pTag,
                                    &dwThumbnailOffset, &dwThumbnailLength);
                break;

            case TAG_COMPRESSION:
                // Hit thumbnail compression TAG.
                // According to EXIF 2.1 spec, a thumbnail can only be
                // compressed using JPEG format. So the compress value should be
                // "6". If the value is "1", it means we have an uncompressed
                // thumbnail which can only be in TIFF format

                if (pTag->us == 1)
                {
                    DecodeTiffThumbnail(
                        lpStart,
                        lpData - 2,
                        bBigEndian,
                        count,
                        thumbImage
                        );
                }

                break;

            default:
                break;
            }
        }

        lpData = (LPBYTE)(((IFD_TAG UNALIGNED*)lpData)+wEntries);

        //
        // get offset to next IFD
        //

        if ((INT) (lpData - lpStart) > (count + (INT) sizeof(DWORD)))
        {
            //
            // Buffer too small
            //

            return E_FAIL;
        }
        
        offset = *(DWORD UNALIGNED *)lpData;
        if (bBigEndian)
            offset = SWAP_DWORD(offset);

        if (offset)
        {
            lpData = (lpStart + offset);
        }


    } while ( offset );

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*   Gets the thumbnail from an APP1 marker
*
* Arguments:
*
*   thumbImage - a pointer to the thumbnail image object to be created
*       based on data extracted from the APP1 header
*   APP1_marker - pointer to APP1 marker data
*   APP1_length - length of APP1 segment
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT GetAPP1Thumbnail(
    OUT IImage **thumbImage,
    IN PVOID APP1_marker,
    IN UINT16 APP1_length
    )
{
    *thumbImage = NULL;

    // Go past end of APP1 header

    if (APP1_length < 6)
    {
        return S_OK;
    }

    PCHAR p = (PCHAR) APP1_marker;
    if ((p[0] != 'E') ||
        (p[1] != 'x') ||
        (p[2] != 'i') ||
        (p[3] != 'f'))
    {
        WARNING(("GetAPP1Thumbnail:  APP1 header not EXIF"));
        return S_OK;
    }

    APP1_length -= 6;
    APP1_marker = (PVOID) (p + 6);

    return DecodeApp1(thumbImage, (LPBYTE) APP1_marker, APP1_length);
}

/**************************************************************************\
*
* Function Description:
*
*   Property value adjustment for EXIf IFD according to transform type. Like
*   adjust X and Y dimention value if the image is rotated
*
* Arguments:
*
*   [IN]lpBase------Pointer to EXIF data
*   [IN]count-------Length of the data
*   [IN]pTag--------Current EXIF tag
*   [IN]bBigEndian--Flag for big endian
*   [IN]uiXForm-----Transform method
*
* Return Value:
*
*   Return S_OK if everything is OK. Otherwise, return error code
*
* Revision History:
*
*   2/01/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
TransformExifIFD(
    LPBYTE lpBase,
    INT count,
    IFD_TAG UNALIGNED * pTag,
    BOOL bBigEndian,
    UINT uiXForm,
    UINT uiNewWidth,
    UINT uiNewHeight
    )
{
    INT iPixXDimIndex = -1;
    INT iPixYDimIndex = -1;
    IFD_TAG tNewTag;

    if ( (pTag->wType != TAG_TYPE_LONG)  || (pTag->dwCount != 1) )
    {
        WARNING(("EXIF TransformExifIFD---Malformed exif pointer"));
        return E_FAIL;
    }

    // Get pointer to EXIF IFD info

    LPBYTE lpExif = lpBase + pTag->dwOffset;

    // Figure out how many entries there are, and skip to the data section...

    if ( (INT)((INT_PTR)lpExif + sizeof(WORD) - (INT_PTR)lpBase) > count )
    {
        WARNING(("EXIF TransformExifIFD---Buffer too small 1"));
        return E_FAIL;
    }

    WORD wNumEntries = *(WORD*)lpExif;
    lpExif += sizeof(WORD);

    if ( bBigEndian == TRUE )
    {
        wNumEntries = SWAP_WORD(wNumEntries);
    }

    if ( (INT)((INT_PTR)lpExif + sizeof(IFD_TAG) *wNumEntries - (INT_PTR)lpBase)
         > count )
    {
        WARNING(("EXIF TransformExifIFD---Buffer too small 2"));
        return E_FAIL;
    }

    IFD_TAG UNALIGNED * pExifTag = (IFD_TAG UNALIGNED *)lpExif;

    for (INT i = 0; i < wNumEntries; i++)
    {
        pExifTag = ((IFD_TAG*)lpExif) + i;

        if ( bBigEndian == TRUE )
        {
            tNewTag = SwapIFD_TAG(pExifTag);
            pExifTag = &tNewTag;
        }

        switch( pExifTag->wTag )
        {
        case EXIF_TAG_PIX_X_DIM:
            if ( (pExifTag->dwCount != 1)
               ||( (pExifTag->wType != TAG_TYPE_SHORT)
                 &&(pExifTag->wType != TAG_TYPE_LONG) ) )
            {
                WARNING(("TransformExifIFD-PixelXDimension invalid format"));
            }
            else
            {
                iPixXDimIndex = i;

                if ( uiNewWidth != 0 )
                {
                    pExifTag->ul = uiNewWidth;
                    if ( bBigEndian == TRUE )
                    {
                        pExifTag->ul = SWAP_DWORD(pExifTag->ul);
                    }
                }
            }

            break;

        case EXIF_TAG_PIX_Y_DIM:
            if ( (pExifTag->dwCount != 1)
               ||( (pExifTag->wType != TAG_TYPE_SHORT)
                 &&(pExifTag->wType != TAG_TYPE_LONG) ) )
            {
                WARNING(("TransformExifIFD PixelYDimension invalid format."));
            }
            else
            {
                iPixYDimIndex = i;
                if ( uiNewHeight != 0 )
                {
                    pExifTag->ul = uiNewHeight;

                    if ( bBigEndian == TRUE )
                    {
                        pExifTag->ul = SWAP_DWORD(pExifTag->ul);
                    }
                }
            }

            break;

        case TAG_THUMBNAIL_RESOLUTION_X:
        case TAG_THUMBNAIL_RESOLUTION_Y:
            if ( (pExifTag->wType == TAG_TYPE_LONG) && (pExifTag->dwCount == 1))
            {
                // Change the thumbnail tag to comments tag for now
                // So no app will read this non-transformed thumbnail

                pExifTag->wTag = EXIF_TAG_USER_COMMENT;

                if ( bBigEndian == TRUE )
                {
                    // Since we have to write the data back, we have to do
                    // another swap

                    tNewTag = SwapIFD_TAG(pExifTag);

                    // Find the dest address

                    pExifTag = ((IFD_TAG UNALIGNED *)lpExif) + i;

                    GpMemcpy(pExifTag, &tNewTag, sizeof(IFD_TAG));
                }
            }

            break;

        default:
            break;
        }// switch ( pExifTag->wTag )
    }// Loop through all the TAGs

    // Swap X dimension and Y dimension value if they exist and the
    // transformation is 90 or 270 rotation

    if ( (iPixXDimIndex >= 0) && (iPixYDimIndex >= 0)
       &&((uiXForm == JXFORM_ROT_90) || (uiXForm == JXFORM_ROT_270)) )
    {
        // Get X resolution TAG

        pTag = ((IFD_TAG UNALIGNED *)lpExif) + iPixXDimIndex;

        // Set Y resolution tag as X resolution tag

        pTag->wTag = EXIF_TAG_PIX_Y_DIM;

        if ( bBigEndian == TRUE )
        {
            // Since we only change the wTag field, so we need only to swap
            // this WORD, not the whole IFD_TAG

            tNewTag.wTag = SWAP_WORD(pTag->wTag);
            pTag->wTag = tNewTag.wTag;
        }

        // Get Y resolution TAG

        pTag = ((IFD_TAG UNALIGNED*)lpExif) + iPixYDimIndex;

        // Set X resolution tag as Y resolution tag

        pTag->wTag = EXIF_TAG_PIX_X_DIM;

        if ( bBigEndian == TRUE )
        {
            // Since we only change the wTag field, so we need only to swap
            // this WORD, not the whole IFD_TAG

            tNewTag.wTag = SWAP_WORD(pTag->wTag);
            pTag->wTag = tNewTag.wTag;
        }
    }

    return S_OK;
}// TransformExifIFD()

/**************************************************************************\
*
* Function Description:
*
*    Property value adjustment according to transform type. Like adjust X
*   and Y dimention value if the image is rotated
*
* Arguments:
*   IN BYTE*    pApp1Data-----Pointer to APP1 header
*   IN UINT     uiApp1Length--Total length of this APP1 header in bytes
*   IN UINT     uiXForm-------Transform method
*
* Return Value:
*
*   Return S_OK if everything is OK. Otherwise, return error code
*
* Revision History:
*
*   2/01/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
TransformApp1(
    BYTE*   pApp1Data,
    UINT16  uiApp1Length,
    UINT    uiXForm,
    UINT    uiNewWidth,
    UINT    uiNewHeight
    )
{
    BYTE UNALIGNED*   pcSrcData = pApp1Data;
    BYTE UNALIGNED*   lpData;
    int     iBytesRemaining;
    BOOL    bBigEndian = FALSE;
    ULONG   ulIfdOffset;
    ULONG   dwThumbnailOffset = 0;
    ULONG   dwThumbnailLength = 0;

    int     iXResolutionIndex = -1;
    int     iYResolutionIndex = -1;

    BOOL    bHasThumbNailIFD = FALSE;   // Will be set to TRUE if we are in 1st
                                        // IFD

    // Decipher data

    if ( uiApp1Length < 6 )
    {
        // Data length must be longer than 6 bytes

        WARNING(("Exif TransformApp1---uiApp1Length too small"));
        return E_FAIL;
    }

    // Check the header to see if it is EXIF

    if ( (pcSrcData[0] != 'E')
       ||(pcSrcData[1] != 'x')
       ||(pcSrcData[2] != 'i')
       ||(pcSrcData[3] != 'f') )
    {
        WARNING(("Exif TransformApp1---Header is not Exif"));
        return E_FAIL;
    }

    uiApp1Length -= 6;
    pcSrcData += 6;
    iBytesRemaining = uiApp1Length;

    // Check if it is Big Endian or Little Endian

    if ( *(UINT16 UNALIGNED*)(pcSrcData) == 0x4D4D )
    {
        bBigEndian = TRUE;
    }

    ulIfdOffset = *(UINT32 UNALIGNED*)(pcSrcData + 4);
    if ( bBigEndian == TRUE )
    {
        ulIfdOffset = SWAP_DWORD(ulIfdOffset);
    }

    lpData = (pcSrcData + ulIfdOffset);

    // Loop through all IFDs

    do
    {
        // Get number of entries

        if ((int)(lpData - pcSrcData) > (iBytesRemaining + (int)sizeof(UINT16)))
        {
            // Buffer too small

            WARNING(("Exif TransformApp1---Buffer too small 1"));
            return E_FAIL;
        }

        UINT16  wEntries = *(UINT16 UNALIGNED*)lpData;

        if ( bBigEndian )
        {
            wEntries = SWAP_WORD(wEntries);
        }

        lpData += sizeof(UINT16);

        // Loop through entries

        if (((int)(lpData - pcSrcData) + ((int)wEntries * (int)sizeof(IFD_TAG)))
            > (int)iBytesRemaining )
        {
            // Buffer too small

            WARNING(("Exif TransformApp1---Buffer too small 2"));
            return E_FAIL;
        }

        IFD_TAG UNALIGNED * pTag = (IFD_TAG UNALIGNED *)lpData;
        IFD_TAG     tNewTag;
        IFD_TAG     tTempTag;

        for ( int i = 0; i < wEntries; ++i )
        {
            pTag = ((IFD_TAG UNALIGNED *)lpData) + i;

            if ( bBigEndian == TRUE )
            {
                tNewTag = SwapIFD_TAG(pTag);
                pTag = &tNewTag;
            }

            // Transform tag values

            switch ( pTag->wTag )
            {
            case TAG_EXIF_IFD:
                TransformExifIFD(pcSrcData, iBytesRemaining, pTag, bBigEndian,
                                 uiXForm, uiNewWidth, uiNewHeight);
                break;

            case TAG_JPEG_INTER_FORMAT:
                if ( (pTag->wType == TAG_TYPE_LONG) && (pTag->dwCount == 1) )
                {
                    dwThumbnailOffset = pTag->dwOffset;

                    // Change the thumbnail tag to comments tag for now
                    // So no app will read this non-transformed thumbnail

                    pTag->wTag = EXIF_TAG_USER_COMMENT;

                    if ( bBigEndian == TRUE )
                    {
                        // Since we have to write the data back, we have to do
                        // another swap

                        tTempTag = SwapIFD_TAG(pTag);

                        // Find the dest address

                        pTag = ((IFD_TAG UNALIGNED *)lpData) + i;

                        GpMemcpy(pTag, &tTempTag, sizeof(IFD_TAG));
                    }
                }

                break;

            case TAG_JPEG_INTER_LENGTH:
                if ( (pTag->wType == TAG_TYPE_LONG) && (pTag->dwCount == 1) )
                {
                    dwThumbnailLength = pTag->dwOffset;

                    // Change the thumbnail tag to comments tag for now
                    // So no app will read this non-transformed thumbnail

                    pTag->wTag = EXIF_TAG_USER_COMMENT;

                    if ( bBigEndian == TRUE )
                    {
                        // Since we have to write the data back, we have to do
                        // another swap

                        tTempTag = SwapIFD_TAG(pTag);

                        // Find the dest address

                        pTag = ((IFD_TAG UNALIGNED *)lpData) + i;

                        GpMemcpy(pTag, &tTempTag, sizeof(IFD_TAG));
                    }
                }

                break;

            case TAG_X_RESOLUTION:
            case TAG_Y_RESOLUTION:
            case TAG_COMPRESSION:
            case TAG_IMAGE_WIDTH:
            case TAG_IMAGE_HEIGHT:
            case TAG_RESOLUTION_UNIT:
                if ( (bHasThumbNailIFD == TRUE)
                   &&(pTag->dwCount == 1) )
                {
                    // Change the thumbnail tag to comments tag for now
                    // so that no app will read this non-transformed thumbnail

                    pTag->wTag = EXIF_TAG_USER_COMMENT;

                    if ( bBigEndian == TRUE )
                    {
                        // Since we have to write the data back, we have to do
                        // another swap

                        tTempTag = SwapIFD_TAG(pTag);

                        // Find the dest address

                        pTag = ((IFD_TAG UNALIGNED *)lpData) + i;

                        GpMemcpy(pTag, &tTempTag, sizeof(IFD_TAG));
                    }
                }

                break;

            case EXIF_TAG_PIX_X_DIM:
                if ( (pTag->dwCount == 1)
                   &&( (pTag->wType == TAG_TYPE_SHORT)
                     ||(pTag->wType == TAG_TYPE_LONG) ) )
                {
                    iXResolutionIndex = i;

                    if ( uiNewWidth != 0 )
                    {
                        pTag->ul = uiNewWidth;
                        if ( bBigEndian == TRUE )
                        {
                            pTag->ul = SWAP_DWORD(pTag->ul);
                        }
                    }
                }

                break;

            case EXIF_TAG_PIX_Y_DIM:
                if ( (pTag->dwCount == 1)
                 &&( (pTag->wType == TAG_TYPE_SHORT)
                   ||(pTag->wType == TAG_TYPE_LONG) ) )
                {
                    iYResolutionIndex = i;
                    if ( uiNewHeight != 0 )
                    {
                        pTag->ul = uiNewHeight;

                        if ( bBigEndian == TRUE )
                        {
                            pTag->ul = SWAP_DWORD(pTag->ul);
                        }
                    }
                }

                break;

            default:
                // We don't care the rest tags

                break;
            }// switch

#if 0
            // !!!Don't remove this code. This is the place where we need to add
            // code in V2 to transform the thumbnail
            //
            // Launch another transformation process here for thumbnail

            if ( (dwThumbnailOffset != 0) && (dwThumbnailLength != 0) )
            {
                // We got the bits

                void* pBits = pcSrcData + dwThumbnailOffset;

                FILE* hFile = fopen("aaa.jpg", "w");
                fwrite(pBits, 1, (size_t)dwThumbnailLength, hFile);
                fclose(hFile);
            }
#endif
        }// Loop all the entries

        // Swap X resolution and Y resolution value if they exist and the
        // transformation is 90 or 270 rotation

        if ( (iXResolutionIndex >= 0) && (iYResolutionIndex >= 0)
           &&((uiXForm == JXFORM_ROT_90) || (uiXForm == JXFORM_ROT_270)) )
        {
            // Get X resolution TAG

            pTag = ((IFD_TAG UNALIGNED *)lpData) + iXResolutionIndex;

            // Set Y resolution tag as X resolution tag

            pTag->wTag = EXIF_TAG_PIX_Y_DIM;

            if ( bBigEndian == TRUE )
            {
                // Since we only change the wTag field, so we need only to swap
                // this WORD, not the whole IFD_TAG

                tNewTag.wTag = SWAP_WORD(pTag->wTag);
                pTag->wTag = tNewTag.wTag;
            }

            // Get Y resolution TAG

            pTag = ((IFD_TAG UNALIGNED *)lpData) + iYResolutionIndex;

            // Set X resolution tag as Y resolution tag

            pTag->wTag = EXIF_TAG_PIX_X_DIM;

            if ( bBigEndian == TRUE )
            {
                // Since we only change the wTag field, so we need only to swap
                // this WORD, not the whole IFD_TAG

                tNewTag.wTag = SWAP_WORD(pTag->wTag);
                pTag->wTag = tNewTag.wTag;
            }
        }

        lpData = (BYTE*)(((IFD_TAG UNALIGNED *)lpData) + wEntries);

        // get offset to next IFD

        if ((int) (lpData - pcSrcData) > (iBytesRemaining +(int)sizeof(UINT32)))
        {
            // Buffer too small

            WARNING(("Exif TransformApp1---Buffer too small 3"));
            return E_FAIL;
        }

        ulIfdOffset = *(UINT32 UNALIGNED*)lpData;
        if ( bBigEndian == TRUE )
        {
            ulIfdOffset = SWAP_DWORD(ulIfdOffset);
        }

        if ( ulIfdOffset )
        {
            bHasThumbNailIFD = TRUE;
            lpData = (pcSrcData + ulIfdOffset);
        }
    } while ( ulIfdOffset );

    return S_OK;
}// TransformApp1()

/**************************************************************************\
*
* Function Description:
*
*   Add a property item into the InternalPropertyItem list
*
* Arguments:
*
*   [IN/OUT]pTail---A pointer to the tail of the last entry in the property list
*   [IN]lpBase------Base address for APP1 data
*   [IN]pTag--------Current IFD tag
*   [IN]bBigEndian--Flag for big endian
*   [IN/OUT]puiListSize--Current list size
*
* Note: For BigEndian case, the caller has swapped everything in the TAG, but
*       not in the offset section. So if we want to get values from pTag->us,
*       or pTag->l etc., we don't need to swap them any more
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   02/27/2000 MinLiu
*       Created it.
*
\**************************************************************************/

HRESULT
AddPropertyListDirect(
    InternalPropertyItem*   pTail,
    LPBYTE                  lpBase,
    IFD_TAG UNALIGNED *     pTag,
    BOOL                    bBigEndian,
    UINT*                   puiListSize
    )
{
    // Prepare a new property item to be attached to the property link list

    InternalPropertyItem* pNewItem = new InternalPropertyItem();

    if ( pNewItem == NULL )
    {
        WARNING(("AddPropertyListDirect---Out of memory"));
        return E_OUTOFMEMORY;
    }

    pNewItem->id    = pTag->wTag;
    pNewItem->type  = pTag->wType;

    HRESULT         hResult = S_OK;
    VOID UNALIGNED* pValueBuffer = NULL;
    BOOL            fHasAllocatedBuffer = FALSE;
    UINT            uiLength = 0;
    VOID*           pValue = NULL;

    if ( pTag->dwCount > 0 )
    {
        // Doesn't make sense if dwCount < 1. But we still need to add it to the
        // list so that we won't lose any property information

        switch ( pTag->wType )
        {
        case TAG_TYPE_BYTE:
        {
            LPSTR psz = NULL;

            if ( pTag->dwCount <= 4 )
            {
                psz = (LPSTR)&pTag->dwOffset;
            }
            else
            {
                psz = (LPSTR)(lpBase + pTag->dwOffset);
            }

            if ( bBigEndian )
            {
                char cTemp0 = psz[0];
                char cTemp1 = psz[1];

                psz[0] = psz[3];
                psz[1] = psz[2];
                psz[2] = cTemp1;
                psz[3] = cTemp0;
            }

            uiLength = pTag->dwCount;
            pValue = (PVOID)psz;

            break;
        }

        case TAG_TYPE_ASCII:
        {
            LPSTR psz = NULL;

            if ( pTag->dwCount <= 4 )
            {
                psz = (LPSTR)&pTag->dwOffset;
            }
            else
            {
                psz = (LPSTR)(lpBase + pTag->dwOffset);
            }

            // According to the EXIF2.1 spec, an ASCII type means "an 8-bit byte
            // containing one 7-bit ASCII code. The final byte is terminated
            // with NULL".
            // But in real life, there are cameras, like "Canon PowerShot S100"
            // which doesn't follow this rule in some of the ASCII tags it
            // produces, see Windows bug#403951. So we have to
            // protect ourselves running into buffer over-run problem.
            
            if (psz[pTag->dwCount - 1] == '\0')
            {
                uiLength = strlen(psz) + 1;
                pValue = (PVOID)psz;
            }
            else
            {
                // Apparently the source doesn't have a NULL terminator at the
                // place where it should be. Do safe copy.
                // Note: some cameras do weird things, like JVC GR_DVL915U, it
                // claims the camera model field has 20 bytes, like this:
                // "GR-DV***[00][00][00][00][00][00][00][00][00][00][00][00]"
                // We decided to take only the first 9 bytes in this case to
                // report the camera model. Because it doesn't make sense for
                // our SHELL UI to display extra 12 bytes of NULL chars there.
                // That's also the reason we need to do a strlen() here.

                UINT uiTempLength = pTag->dwCount + 1;  // Including the NULL
                pValueBuffer = (PVOID)GpMalloc(uiTempLength);
                if (pValueBuffer == NULL)
                {
                    WARNING(("AddPtyLstDir-Fail alloc %x bytes",uiTempLength));
                    hResult = E_OUTOFMEMORY;
                    goto CleanUp;
                }
                
                // Set this flag so that the temp buffer will be freed at the
                // end of this function

                fHasAllocatedBuffer = TRUE;

                // Only copy the first "pTag->dwCount" bytes

                GpMemcpy(pValueBuffer, (BYTE*)(psz), pTag->dwCount);

                // Stick a NULL at the end

                ((char*)pValueBuffer)[pTag->dwCount] = '\0';

                // Re-calculate the length

                uiLength = strlen(((char*)pValueBuffer)) + 1;
                pValue = (PVOID)pValueBuffer;
            }

            break;
        }

        case TAG_TYPE_SHORT:
            uiLength = pTag->dwCount * sizeof(short);
            pValueBuffer = (VOID*)GpMalloc(uiLength);
            if ( pValueBuffer == NULL )
            {
                WARNING(("AddPropertyLstDir-Fail to alloc %x bytes", uiLength));
                hResult = E_OUTOFMEMORY;
                goto CleanUp;
            }

            fHasAllocatedBuffer = TRUE;

            switch ( pTag->dwCount )
            {
            case 1:
                // One short value.

                GpMemcpy(pValueBuffer, &pTag->us, uiLength);

                break;

            case 2:
                // Two short values
                // Note: In this case, pTag->dwOffset stores TWO short values,
                // not the offset.
                // In big endian case, since dwOffset has already been swapped.
                // So it has the little endian order now. But the order for two
                // SHORTs is still not right. It stores the 1st SHORT value in
                // its higher 2 bytes and 2nd SHORT value in its lower two
                // bytes.
                // Here is an example: Say original value is 0x12345678 in big
                // endian mode. It was intend to be two SHORTs of 0x1234 and
                // 0x5678. So the correct little endian value for it should be
                // two SHORTs of 0x7856 and 0x3412. When the caller swapped the
                // whole TAG, it swaps the LONG value of 0x12345678 to
                // 0x78563412. So in order to get two SHORTs of little endian to
                // be stored in a LONG position, we should do the following code

                if ( bBigEndian )
                {
                    INT16*  pTemp = (INT16*)pValueBuffer;
                    *pTemp++ = (INT16)((pTag->dwOffset & 0xffff0000) >> 16);
                    *pTemp = (INT16)(pTag->dwOffset & 0x0000ffff);
                }
                else
                {
                    GpMemcpy(pValueBuffer, &pTag->dwOffset, uiLength);
                }

                break;

            default:
                // More than 2 SHORT values, that is, more than 4 bytes of value
                // So we have to get it from the offset section

                GpMemcpy(pValueBuffer, (BYTE*)(lpBase + pTag->dwOffset),
                         uiLength);

                if ( bBigEndian )
                {
                    // Swap all the SHORT values

                    INT16*  pTemp = (INT16*)pValueBuffer;
                    for ( int i = 0; i < (int)pTag->dwCount; ++i )
                    {
                        *pTemp++ = SWAP_WORD(*pTemp);
                    }

                    break;
                }
            }// switch (dwCount)
            
            pValue = pValueBuffer;

            break;

        case TAG_TYPE_LONG:
        case TAG_TYPE_SLONG:
            uiLength = pTag->dwCount * sizeof(long);

            if ( pTag->dwCount == 1 )
            {
                // If there is only one LONG value, we can get it from pTag->l
                // directly, no swap is needed even for Big Endian case

                pValueBuffer = &pTag->l;
            }
            else
            {
                if ( bBigEndian )
                {
                    // This is a big-endian image. So we create a temp buffer
                    // here. Get the original values to this buffer, then swap
                    // it

                    pValueBuffer = (VOID*)GpMalloc(uiLength);
                    if ( pValueBuffer == NULL )
                    {
                        WARNING(("AddPropertyLstDir--Alloc %x bytes",uiLength));
                        hResult = E_OUTOFMEMORY;
                        goto CleanUp;
                    }

                    fHasAllocatedBuffer = TRUE;

                    // We have more than 4 bytes of value. So it has to be
                    // stored in the offset section

                    GpMemcpy(pValueBuffer, (BYTE*)(lpBase + pTag->dwOffset),
                             uiLength);

                    // Swap all the LONG values

                    INT32*   pTemp = (INT32*)pValueBuffer;
                    for ( int i = 0; i < (int)pTag->dwCount; ++i )
                    {
                        *pTemp++ = SWAP_DWORD(*pTemp);
                    }
                }// Big endian case
                else
                {
                    // For none BigEndian case, we can get the value directy
                    // from the source

                    pValueBuffer = (VOID*)(lpBase + pTag->dwOffset);
                }
            }// (dwCount > 1)

            pValue = pValueBuffer;

            break;

        case TAG_TYPE_RATIONAL:
        case TAG_TYPE_SRATIONAL:
            // The size for this item is dwCount times 2 longs ( = RATIONAL)

            uiLength = pTag->dwCount * 2 * sizeof(long);

            if ( bBigEndian )
            {
                // This is a big-endian image. So we create a temp buffer here.
                // Get the original values to this buffer, then swap it if
                // necessary

                pValueBuffer = (PVOID)GpMalloc(uiLength);
                if ( pValueBuffer == NULL )
                {
                    WARNING(("AddPropertyLstDir-Fail alloc %x bytes",uiLength));
                    hResult = E_OUTOFMEMORY;
                    goto CleanUp;
                }

                fHasAllocatedBuffer = TRUE;

                GpMemcpy(pValueBuffer, (BYTE*)(lpBase + pTag->dwOffset),
                         uiLength);

                // Casting the source value to INT32 world and swap it

                INT32*  piTemp = (INT32*)pValueBuffer;
                for ( int i = 0; i < (int)pTag->dwCount; ++i )
                {
                    // A Rational is composed of two long values. The first one
                    // is the numerator and the second one is the denominator.

                    INT32    lNum = *piTemp;
                    INT32    lDen = *(piTemp + 1);

                    // Swap the value

                    lNum = SWAP_DWORD(lNum);
                    lDen = SWAP_DWORD(lDen);

                    // Put it back

                    *piTemp = lNum;
                    *(piTemp + 1) = lDen;

                    piTemp += 2;
                }
            }// Big endian case
            else
            {
                // For none BigEndian case, we can get the value directy from
                // the source

                pValueBuffer = (VOID*)(lpBase + pTag->dwOffset);
            }

            pValue = pValueBuffer;

            break;

        default:
            WARNING(("EXIF: Unknown tag type"));

            // Note: the caller should not call this function if the type is
            // TAG_TYPE_UNDEFINED

            hResult = E_FAIL;
            goto CleanUp;
        }// switch on tag type    
    }// ( pTag->dwCount > 0 )

    if ( uiLength != 0 )
    {
        pNewItem->value = GpMalloc(uiLength);
        if ( pNewItem->value == NULL )
        {
            WARNING(("AddPropertyListDirect fail to alloca %d bytes",uiLength));
            hResult = E_OUTOFMEMORY;
            goto CleanUp;
        }

        GpMemcpy(pNewItem->value, pValue, uiLength);
    }
    else
    {
        pNewItem->value = NULL;
    }

    pNewItem->length = uiLength;
    pTail->pPrev->pNext = pNewItem;
    pNewItem->pPrev = pTail->pPrev;
    pNewItem->pNext = pTail;
    pTail->pPrev = pNewItem;

    *puiListSize += uiLength;

    // Set hResult to S_OK so pNewItem won't be deleted below

    hResult = S_OK;

CleanUp:
    // If we fail into here and hResult is not S_OK, it means something is wrong
    // Do some clean ups before return

    if ( (hResult != S_OK) && (pNewItem != NULL) )
    {
        delete pNewItem;
    }
    
    if ( fHasAllocatedBuffer == TRUE )
    {
        // If we have allocated the buffer, then free it

        GpFree(pValueBuffer);
    }
    
    return hResult;
}// AddPropertyListDirect()

/**************************************************************************\
*
* Function Description:
*
*     Decodes an EXIF IFD into a property storage
*
* Arguments:
*
*     propStgImg -- The property storage to modify
*     lpBase -- A pointer to the beginning of the APP1 header
*     count -- The length of the APP1 header
*     pTag -- A pointer to the current IFD tag
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   02/27/2000 MinLiu
*       Created it.
*
\**************************************************************************/

HRESULT
BuildPropertyListFromExifIFD(
    InternalPropertyItem*   pTail,
    UINT*                   puiListSize,
    UINT*                   puiNumOfItems,
    LPBYTE                  lpBase,
    INT                     count,
    IFD_TAG UNALIGNED *     pTag,
    BOOL                    bBigEndian
    )
{
    HRESULT hResult = S_OK;
    UINT    uiListSize = *puiListSize;
    UINT    uiNumOfItems = *puiNumOfItems;

    if ( (pTag->wType != TAG_TYPE_LONG)  || (pTag->dwCount != 1) )
    {
        WARNING(("BuildPropertyListFromExifIFD: Malformed exif ptr"));
        return E_FAIL;
    }

    // Get pointer to EXIF IFD info

    LPBYTE lpExif = lpBase + pTag->dwOffset;

    // Figure out how many entries there are, and skip to the data section...

    if ( (INT)((INT_PTR)lpExif + sizeof(WORD) - (INT_PTR)lpBase) > count )
    {
        WARNING(("BuildPropertyListFromExifIFD---Buffer too small"));
        return E_FAIL;
    }

    WORD wNumEntries = *(WORD UNALIGNED *)lpExif;
    lpExif += sizeof(WORD);
    if ( bBigEndian )
    {
        wNumEntries = SWAP_WORD(wNumEntries);
    }

    if ( (INT)((INT_PTR)lpExif + sizeof(IFD_TAG) * wNumEntries
              -(INT_PTR)lpBase) > count )
    {
        WARNING(("BuildPropertyListFromExifIFD---Buffer too small"));
        return E_FAIL;
    }

    IFD_TAG UNALIGNED * pExifTag = (IFD_TAG UNALIGNED *)lpExif;
    UINT    valueLength;

    for ( INT i = 0; i < wNumEntries; ++i )
    {
        IFD_TAG tNewTag;
        pExifTag = ((IFD_TAG UNALIGNED *)lpExif) + i;
        if ( bBigEndian == TRUE )
        {
            tNewTag = SwapIFD_TAG(pExifTag);
            pExifTag = &tNewTag;
        }

        // No need to parse these tags. But we can't add any unknown type
        // into the list because we don't know its length

        if (pExifTag->wTag == EXIF_TAG_INTEROP)
        {
            hResult = BuildInterOpPropertyList(
                pTail,
                &uiListSize,
                &uiNumOfItems,
                lpBase,
                count,
                pExifTag,
                bBigEndian
                );
        }
        else if ( pExifTag->wType != TAG_TYPE_UNDEFINED )
        {
            uiNumOfItems++;
            hResult = AddPropertyListDirect(pTail, lpBase, pExifTag,
                                            bBigEndian, &uiListSize);
        }
        else if ( pExifTag->dwCount <= 4 )
        {
            // According to the spec, an "UNDEFINED" value is an 8-bits type
            // that can take any value depends on the field.
            // In case where the value fits in 4 bytes, the value itself is
            // recorded. That is, "dwOffset" is the value for these "dwCount"
            // fields.

            uiNumOfItems++;
            uiListSize += pExifTag->dwCount;
            LPSTR pVal = (LPSTR)&pExifTag->dwOffset;

            if ( bBigEndian )
            {
                char cTemp0 = pVal[0];
                char cTemp1 = pVal[1];
                pVal[0] = pVal[3];
                pVal[1] = pVal[2];
                pVal[2] = cTemp1;
                pVal[3] = cTemp0;
            }

            hResult = AddPropertyList(pTail,
                                      pExifTag->wTag,
                                      pExifTag->dwCount,
                                      pExifTag->wType,
                                      pVal);
        }// ( pExifTag->dwCount <= 4 )
        else
        {
            uiNumOfItems++;
            uiListSize += pExifTag->dwCount;
            PVOID   pTemp = lpBase + pExifTag->dwOffset;

            hResult = AddPropertyList(pTail,
                                      pExifTag->wTag,
                                      pExifTag->dwCount,
                                      TAG_TYPE_UNDEFINED,
                                      pTemp);
        }// ( pExifTag->dwCount > 4 )

        if ( FAILED(hResult) )
        {
            WARNING(("BuildPropertyListFromExifIFD---AddPropertyList failed"));
            break;
        }
    }// Loop through all the EXIF IFD entries

    *puiListSize = uiListSize;
    *puiNumOfItems = uiNumOfItems;

    return hResult;
}// BuildPropertyListFromExifIFD()

/**************************************************************************\
*
* Function Description:
*
*     Decodes the EXIF app1 header and build a PropertyItem list
*
* Arguments:
*
*     [OUT] ppList-------- A pointer to a list of property items
*     [OUT] puiListSize--- The total size of the property list, in bytes.
*     [OUT] puiNumOfItems- Total number of property items
*     [IN]  pStart ------- A pointer to the beginning of the APP1 header
*     [IN]  iApp1Length -- The length of the APP1 header
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   02/27/2000 MinLiu
*       Created it.
*
\**************************************************************************/

HRESULT
BuildApp1PropertyList(
    InternalPropertyItem*  pTail,
    UINT*           puiListSize,
    UINT*           puiNumOfItems,
    LPBYTE          lpAPP1Data,
    UINT16          iApp1Length
    )
{
    DWORD   dwThumbnailOffset = 0;
    DWORD   dwThumbnailLength = 0;
    LPBYTE  lpData = NULL;
    ULONG   ulIfdOffset = 0;
    WORD    wEntries = 0;
    HRESULT hResult = S_OK;

    // Input parameter validation

    if ( (pTail == NULL) || (puiListSize == NULL)
       ||(puiNumOfItems == NULL) || (lpAPP1Data == NULL) )
    {
        return E_FAIL;
    }

    if ( iApp1Length < 6 )
    {
        // This APP1 header apparently doesn't have information.
        // Note: we should return S_OK, not fail. Because this function call
        // succeed.

        *puiListSize = 0;
        *puiNumOfItems = 0;

        return S_OK;
    }

    // Check the signature

    PCHAR p = (PCHAR)lpAPP1Data;
    if ( (p[0] != 'E')
       ||(p[1] != 'x')
       ||(p[2] != 'i')
       ||(p[3] != 'f') )
    {
        WARNING(("BuildApp1PropertyList:  APP1 header not EXIF"));
        return S_OK;
    }

    // At the beginning of APP1 chunk is "Exif00", the signature part. All the
    // "offset" is relative to the bytes after this 6 bytes. So we move forward
    // 6 bytes now

    iApp1Length -= 6;
    lpAPP1Data = (LPBYTE)(p + 6);

    // The next 2 bytes is either 0x4D4D or 0x4949 to indicate endian type

    BOOL bBigEndian = (*(WORD UNALIGNED *)(lpAPP1Data) == 0x4D4D);

    // The next two bytes is fixed: 0x2A00, signature
    // After this two bytes, it is the IFD offset, 4 bytes

    ulIfdOffset = *(DWORD UNALIGNED *)(lpAPP1Data + 4);
    if ( bBigEndian )
    {
        ulIfdOffset = SWAP_DWORD(ulIfdOffset);
    }

    lpData = (lpAPP1Data + ulIfdOffset);

    UINT    uiNumOfItems = 0;
    UINT    uiListSize = 0;
    UINT    valueLength;
    BOOL    bHasThumbNailIFD = FALSE;

    // Loop through IFD's

    do
    {
        // Get number of entries

        if ( (INT)(lpData - lpAPP1Data) > (iApp1Length + (INT)sizeof(WORD)) )
        {
            // Buffer too small

            WARNING(("BuildApp1PropertyList--Input buffer size is not right"));
            return E_FAIL;
        }

        wEntries = *(WORD UNALIGNED *)lpData;
        if ( bBigEndian )
        {
            wEntries = SWAP_WORD(wEntries);
        }

        lpData += sizeof(WORD);

        // Loop through entries

        if ( ((INT)(lpData - lpAPP1Data)
             + ((INT)wEntries * (INT)sizeof(IFD_TAG))) > (INT)iApp1Length )
        {
            // Buffer too small

            WARNING(("BuildApp1PropertyList--Input buffer size is not right"));
            return E_FAIL;
        }

        IFD_TAG UNALIGNED * pTag = (IFD_TAG UNALIGNED *)lpData;

        ULONG   ulThumbnailOffset = 0;
        ULONG   ulThumbnailLength = 0;

        for ( INT i = 0; i < wEntries; ++i )
        {
            pTag = ((IFD_TAG UNALIGNED *)lpData) + i;

            IFD_TAG tNewTag;
            if ( bBigEndian == TRUE )
            {
                tNewTag = SwapIFD_TAG(pTag);
                pTag = &tNewTag;
            }

            // Extract properties

            switch (pTag->wTag)
            {
            case TAG_EXIF_IFD:
            case TAG_GPS_IFD:
                hResult = BuildPropertyListFromExifIFD(
                    pTail,
                    &uiListSize,
                    &uiNumOfItems,
                    lpAPP1Data,
                    iApp1Length,
                    pTag,
                    bBigEndian
                    );

                break;

            // Note: For JPEG thumbnail information, these following 2 TAGs
            // will each come once. We can store the THUMBNAIL_DATA info only
            // after we see both of the TAGs

            case TAG_JPEG_INTER_FORMAT:
                if ( (pTag->wType != TAG_TYPE_LONG) || (pTag->dwCount != 1) )
                {
                    WARNING(("InterchangeFormat unit found, invalid format."));
                }
                else
                {
                    ulThumbnailOffset = pTag->dwOffset;

                    valueLength = sizeof(UINT32);
                    uiNumOfItems++;
                    uiListSize += valueLength;
                    hResult = AddPropertyList(pTail, pTag->wTag,
                                              valueLength, TAG_TYPE_LONG,
                                              &pTag->dwOffset);
                }

                if ( (ulThumbnailLength != 0) && (ulThumbnailOffset != 0) )
                {
                    if ( (ulThumbnailOffset + ulThumbnailLength) > iApp1Length )
                    {
                        WARNING(("BuildApp1PropertyList-Thumb offset too big"));
                    }
                    else
                    {
                        // We are sure we have a thumbnail image, add it to the
                        // property list

                        valueLength = ulThumbnailLength;
                        uiNumOfItems++;
                        uiListSize += valueLength;
                        hResult = AddPropertyList(
                            pTail,
                            TAG_THUMBNAIL_DATA,
                            valueLength,
                            TAG_TYPE_BYTE,
                            lpAPP1Data + ulThumbnailOffset);
                    }
                }

                break;

            case TAG_JPEG_INTER_LENGTH:
                if ( (pTag->wType != TAG_TYPE_LONG) || (pTag->dwCount != 1) )
                {
                    WARNING(("InterchangeLength unit found, invalid format."));
                }
                else
                {
                    ulThumbnailLength = pTag->ul;

                    valueLength = sizeof(UINT32);
                    uiNumOfItems++;
                    uiListSize += valueLength;
                    hResult = AddPropertyList(pTail, pTag->wTag,
                                              valueLength, TAG_TYPE_LONG,
                                              &pTag->ul);
                }

                if ( (ulThumbnailLength != 0) && (ulThumbnailOffset != 0) )
                {
                    // Check if we really has so much data in the buffer
                    // Note: we need this check here because some camera vandors
                    // put wrong thumbnail info in the header. If we don't check
                    // the offset or size here, we will be in trouble
                    // With the check below, if we find this kind of image, we
                    // just ignore the thumbnail data section

                    if ( (ulThumbnailOffset + ulThumbnailLength) > iApp1Length )
                    {
                        WARNING(("BuildApp1PropertyList-Thumb offset too big"));
                    }
                    else
                    {
                        // We are sure we have a thumbnail image, add it to the
                        // property list

                        valueLength = ulThumbnailLength;
                        uiNumOfItems++;
                        uiListSize += valueLength;
                        hResult = AddPropertyList(pTail, TAG_THUMBNAIL_DATA,
                                                  valueLength, TAG_TYPE_BYTE,
                                                lpAPP1Data + ulThumbnailOffset);
                    }
                }

                break;

            default:
                // Do a TAG id checking if the tags are in 1st IFD.
                // Note: the reason we need to do this is that EXIF spec doesn't
                // specify a way to distinguish the IFD locations for some of
                // TAGs, like "Compression Scheme", "Resolution Unit" etc. This
                // causes problem for user reading the TAG id and understand it.
                // It also get confused when doing a saving. For now, we
                // distinguish them by assign them a different ID. When save the
                // image, we convert it back so that the image we write out
                // still complies with EXIF spec.

                if ( bHasThumbNailIFD == TRUE )
                {
                    switch ( pTag->wTag )
                    {
                    case TAG_IMAGE_WIDTH:
                        pTag->wTag = TAG_THUMBNAIL_IMAGE_WIDTH;
                        break;

                    case TAG_IMAGE_HEIGHT:
                        pTag->wTag = TAG_THUMBNAIL_IMAGE_HEIGHT;
                        break;

                    case TAG_BITS_PER_SAMPLE:
                        pTag->wTag = TAG_THUMBNAIL_BITS_PER_SAMPLE;
                        break;
                        
                    case TAG_COMPRESSION:
                        pTag->wTag = TAG_THUMBNAIL_COMPRESSION;
                        
                        // Hit thumbnail compression TAG.
                        // According to EXIF 2.1 spec, a thumbnail can only be
                        // compressed using JPEG format. So the compress value should be
                        // "6". If the value is "1", it means we have an uncompressed
                        // thumbnail which can only be in TIFF format

                        if (pTag->us == 1)
                        {
                            hResult = ConvertTiffThumbnailToJPEG(
                                lpAPP1Data,
                                lpData - 2,
                                bBigEndian,
                                iApp1Length,
                                pTail,
                                &uiNumOfItems,
                                &uiListSize
                                );
                        }

                        break;

                    case TAG_PHOTOMETRIC_INTERP:
                        pTag->wTag = TAG_THUMBNAIL_PHOTOMETRIC_INTERP;
                        break;

                    case TAG_IMAGE_DESCRIPTION:
                        pTag->wTag = TAG_THUMBNAIL_IMAGE_DESCRIPTION;
                        break;

                    case TAG_EQUIP_MAKE:
                        pTag->wTag = TAG_THUMBNAIL_EQUIP_MAKE;
                        break;

                    case TAG_EQUIP_MODEL:
                        pTag->wTag = TAG_THUMBNAIL_EQUIP_MODEL;
                        break;

                    case TAG_STRIP_OFFSETS:
                        pTag->wTag = TAG_THUMBNAIL_STRIP_OFFSETS;
                        break;

                    case TAG_ORIENTATION:
                        pTag->wTag = TAG_THUMBNAIL_ORIENTATION;
                        break;

                    case TAG_SAMPLES_PER_PIXEL:
                        pTag->wTag = TAG_THUMBNAIL_SAMPLES_PER_PIXEL;
                        break;

                    case TAG_ROWS_PER_STRIP:
                        pTag->wTag = TAG_THUMBNAIL_ROWS_PER_STRIP;
                        break;

                    case TAG_STRIP_BYTES_COUNT:
                        pTag->wTag = TAG_THUMBNAIL_STRIP_BYTES_COUNT;
                        break;
                    
                    case TAG_X_RESOLUTION:
                        pTag->wTag = TAG_THUMBNAIL_RESOLUTION_X;
                        break;

                    case TAG_Y_RESOLUTION:
                        pTag->wTag = TAG_THUMBNAIL_RESOLUTION_Y;
                        break;

                    case TAG_PLANAR_CONFIG:
                        pTag->wTag = TAG_THUMBNAIL_PLANAR_CONFIG;
                        break;

                    case TAG_RESOLUTION_UNIT:
                        pTag->wTag = TAG_THUMBNAIL_RESOLUTION_UNIT;
                        break;

                    case TAG_TRANSFER_FUNCTION:
                        pTag->wTag = TAG_THUMBNAIL_TRANSFER_FUNCTION;
                        break;

                    case TAG_SOFTWARE_USED:
                        pTag->wTag = TAG_THUMBNAIL_SOFTWARE_USED;
                        break;

                    case TAG_DATE_TIME:
                        pTag->wTag = TAG_THUMBNAIL_DATE_TIME;
                        break;

                    case TAG_ARTIST:
                        pTag->wTag = TAG_THUMBNAIL_ARTIST;
                        break;

                    case TAG_WHITE_POINT:
                        pTag->wTag = TAG_THUMBNAIL_WHITE_POINT;
                        break;

                    case TAG_PRIMAY_CHROMATICS:
                        pTag->wTag = TAG_THUMBNAIL_PRIMAY_CHROMATICS;
                        break;

                    case TAG_YCbCr_COEFFICIENTS:
                        pTag->wTag = TAG_THUMBNAIL_YCbCr_COEFFICIENTS;
                        break;

                    case TAG_YCbCr_SUBSAMPLING:
                        pTag->wTag = TAG_THUMBNAIL_YCbCr_SUBSAMPLING;
                        break;

                    case TAG_YCbCr_POSITIONING:
                        pTag->wTag = TAG_THUMBNAIL_YCbCr_POSITIONING;
                        break;

                    case TAG_REF_BLACK_WHITE:
                        pTag->wTag = TAG_THUMBNAIL_REF_BLACK_WHITE;
                        break;

                    case TAG_COPYRIGHT:
                        pTag->wTag = TAG_THUMBNAIL_COPYRIGHT;
                        break;
                    
                    default:
                        break;
                    }
                }

                if ( pTag->wType != TAG_TYPE_UNDEFINED )
                {
                    hResult = AddPropertyListDirect(pTail, lpAPP1Data, pTag,
                                                    bBigEndian, &uiListSize);
                }
                else
                {
                    if ( pTag->dwCount > 4 )
                    {
                        hResult = AddPropertyList(pTail,
                                                  pTag->wTag,
                                                  pTag->dwCount,
                                                  TAG_TYPE_UNDEFINED,
                                                  lpAPP1Data + pTag->dwOffset);
                    }
                    else
                    {
                        hResult = AddPropertyList(pTail,
                                                  pTag->wTag,
                                                  pTag->dwCount,
                                                  TAG_TYPE_UNDEFINED,
                                                  &pTag->dwOffset);
                    }
                    
                    if (SUCCEEDED(hResult))
                    {
                        uiListSize += pTag->dwCount;
                    }
                }

                if (SUCCEEDED(hResult))
                {
                    uiNumOfItems++;
                }

                break;
            }

            if (FAILED(hResult))
            {
                break;
            }
        }// Loop through all the entries in current IFD

        if (FAILED(hResult))
        {
            break;
        }

        lpData = (LPBYTE)(((IFD_TAG*)lpData) + wEntries);

        // Get offset to next IFD

        if ((INT)(lpData - lpAPP1Data) > (iApp1Length + (INT)sizeof(DWORD)))
        {
            // Buffer too small

            WARNING(("BuildApp1PropertyList--Input buffer size is not right"));
            return E_FAIL;
        }

        ulIfdOffset = *(DWORD UNALIGNED *)lpData;
        if ( bBigEndian )
        {
            ulIfdOffset = SWAP_DWORD(ulIfdOffset);
        }

        if ( ulIfdOffset )
        {
            // We find 1st IFD in this image, thumbnail IFD

            bHasThumbNailIFD = TRUE;
            lpData = (lpAPP1Data + ulIfdOffset);
        }
    } while ( ulIfdOffset );

    *puiNumOfItems += uiNumOfItems;
    *puiListSize += uiListSize;

    return hResult;
}// BuildApp1PropertyList()

/**************************************************************************\
*
* Function Description:
*
*     Extract EXIF information, like resolution etc, from the header and set
*     the j_decompress_ptr accordingly
*
* Arguments:
*
*   [IN/OUT] cinfo-----JPEG decompress structure
*   [IN] pApp1Data-----Pointer to APP1 header
*   [IN] uiApp1Length--Total length of this APP1 header in bytes
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   02/29/2000 MinLiu
*       Created it.
*
\**************************************************************************/

HRESULT
ReadApp1HeaderInfo(
    j_decompress_ptr    cinfo,
    BYTE*               pApp1Data,
    UINT16              uiApp1Length
    )
{
    BYTE*   pcSrcData = pApp1Data;
    BYTE*   lpData;
    int     iBytesRemaining;
    BOOL    bBigEndian = FALSE;
    ULONG   ulIfdOffset;

    // Decipher data

    if ( uiApp1Length < 6 )
    {
        // Data length must be longer than 6 bytes

        return E_FAIL;
    }

    // Check the header to see if it is EXIF

    if ( (pcSrcData[0] != 'E')
         ||(pcSrcData[1] != 'x')
         ||(pcSrcData[2] != 'i')
         ||(pcSrcData[3] != 'f') )
    {
        // It is not EXIF APP1 header. We don't bother to check the header
        // Note: we don't want the the APP to fail. Just return S_OK here,
        // not E_FAIL

        return S_OK;
    }

    uiApp1Length -= 6;
    pcSrcData += 6;
    iBytesRemaining = uiApp1Length;

    // Check if it is Big Endian or Little Endian

    if ( *(UINT16 UNALIGNED *)(pcSrcData) == 0x4D4D )
    {
        bBigEndian = TRUE;
    }

    ulIfdOffset = *(UINT32 UNALIGNED *)(pcSrcData + 4);
    if ( bBigEndian )
    {
        ulIfdOffset = SWAP_DWORD(ulIfdOffset);
    }

    // Get the pointer to the 1st IFD data structure, the primary image
    // structure

    lpData = (pcSrcData + ulIfdOffset);

    // Get number of entries

    if ( (int)(lpData - pcSrcData) > (iBytesRemaining + (int)sizeof(UINT16)) )
    {
        // Buffer too small

        return E_FAIL;
    }

    UINT16  wEntries = *(UINT16 UNALIGNED *)lpData;

    if ( bBigEndian )
    {
        wEntries = SWAP_WORD(wEntries);
    }

    lpData += sizeof(UINT16);

    // Loop through entries

    if ( ((int)(lpData - pcSrcData) + ((int)wEntries * (int)sizeof(IFD_TAG)))
        > (int)iBytesRemaining )
    {
        // Buffer too small

        return E_FAIL;
    }

    IFD_TAG UNALIGNED * pTag = (IFD_TAG UNALIGNED *)lpData;
    IFD_TAG     tNewTag;

    for ( int i = 0; i < wEntries; ++i )
    {
        pTag = ((IFD_TAG UNALIGNED *)lpData) + i;

        if ( bBigEndian == TRUE )
        {
            tNewTag = SwapIFD_TAG(pTag);
            pTag = &tNewTag;
        }

        // Extract resolution information from IFD[0]

        switch ( pTag->wTag )
        {
        case TAG_X_RESOLUTION:
            if ( (pTag->wType != TAG_TYPE_RATIONAL)
                 ||(pTag->dwCount != 1) )
            {
                WARNING(("TAG: XResolution found, invalid format."));
            }
            else
            {
                LONG UNALIGNED * pLong = (LONG*)(pcSrcData + pTag->dwOffset);
                LONG   num,den;
                DOUBLE  dbl;

                num = *pLong++;
                den = *pLong;
                if ( bBigEndian )
                {
                    num = SWAP_DWORD(num);
                    den = SWAP_DWORD(den);
                }

                dbl = (DOUBLE)num / (DOUBLE)den;

                cinfo->X_density = (UINT16)dbl;
            }

            break;

        case TAG_Y_RESOLUTION:
            if ( (pTag->wType != TAG_TYPE_RATIONAL)
                 ||(pTag->dwCount != 1) )
            {
                WARNING(("TAG: YResolution found, invalid format."));
            }
            else
            {
                LONG UNALIGNED * pLong = (LONG*)(pcSrcData + pTag->dwOffset);
                LONG   num,den;
                DOUBLE  dbl;

                num = *pLong++;
                den = *pLong;
                if ( bBigEndian )
                {
                    num = SWAP_DWORD(num);
                    den = SWAP_DWORD(den);
                }

                dbl = (DOUBLE)num / (DOUBLE)den;

                cinfo->Y_density = (UINT16)dbl;
            }

            break;

        case TAG_RESOLUTION_UNIT:
            if ( (pTag->wType != TAG_TYPE_SHORT) || (pTag->dwCount != 1) )
            {
                WARNING(("TAG: Resolution unit found, invalid format."))
            }
            else
            {
                switch ( pTag->us )
                {
                case 2:
                    // Resolution unit: inch
                    // Note: the convension for resolution unit in EXIF and in
                    // IJG JPEG library is different. In EXIF, "2" for inch and
                    // "3" for centimeter. In IJG lib, "1" for inch and "2" for
                    // centimeter.

                    cinfo->density_unit = 1;

                    break;

                case 3:
                    // Resolution unit: centimeter

                    cinfo->density_unit = 2;

                    break;

                default:
                    // Unknow Resolution unit:

                    cinfo->density_unit = 0;
                }
            }

            break;

        default:
            // We don't care the rest tags

            break;
        }// switch
    }// Loop all the entries

    lpData = (BYTE*)(((IFD_TAG UNALIGNED *)lpData) + wEntries);

    // Get offset to next IFD

    if ((int) (lpData - pcSrcData) > (iBytesRemaining +(int)sizeof(UINT32)))
    {
        // Buffer too small

        return E_FAIL;
    }

    return S_OK;
}// ReadApp1HeaderInfo()

/**************************************************************************\
*
* Function Description:
*
*   This function checks a given TAG ID to see if it belongs to the EXIF IFD
* section.
*
* Note: we don't count EXIF_TAG_INTEROP as in this section since it will be
* added based on if we have InterOP ID or not.
*
* Return Value:
*
*   Return TRUE if the input ID belongs to EXIF IFD. Otherwise, return FALSE.
*
\**************************************************************************/

BOOL
IsInExifIFDSection(
    PROPID id               // ID to be checked
    )
{
    switch (id)
    {
    case EXIF_TAG_EXPOSURE_TIME:
    case EXIF_TAG_F_NUMBER:
    case EXIF_TAG_EXPOSURE_PROG:
    case EXIF_TAG_SPECTRAL_SENSE:
    case EXIF_TAG_ISO_SPEED:
    case EXIF_TAG_OECF:
    case EXIF_TAG_VER:
    case EXIF_TAG_D_T_ORIG:
    case EXIF_TAG_D_T_DIGITIZED:
    case EXIF_TAG_COMP_CONFIG:
    case EXIF_TAG_COMP_BPP:
    case EXIF_TAG_SHUTTER_SPEED:
    case EXIF_TAG_APERATURE:
    case EXIF_TAG_BRIGHTNESS:
    case EXIF_TAG_EXPOSURE_BIAS:
    case EXIF_TAG_MAX_APERATURE:
    case EXIF_TAG_SUBJECT_DIST:
    case EXIF_TAG_METERING_MODE:
    case EXIF_TAG_LIGHT_SOURCE:
    case EXIF_TAG_FLASH:
    case EXIF_TAG_FOCAL_LENGTH:
    case EXIF_TAG_MAKER_NOTE:
    case EXIF_TAG_USER_COMMENT:
    case EXIF_TAG_D_T_SUBSEC:
    case EXIF_TAG_D_T_ORIG_SS:
    case EXIF_TAG_D_T_DIG_SS:
    case EXIF_TAG_FPX_VER:
    case EXIF_TAG_COLOR_SPACE:
    case EXIF_TAG_PIX_X_DIM:
    case EXIF_TAG_PIX_Y_DIM:
    case EXIF_TAG_RELATED_WAV:
    case EXIF_TAG_FLASH_ENERGY:
    case EXIF_TAG_SPATIAL_FR:
    case EXIF_TAG_FOCAL_X_RES:
    case EXIF_TAG_FOCAL_Y_RES:
    case EXIF_TAG_FOCAL_RES_UNIT:
    case EXIF_TAG_SUBJECT_LOC:
    case EXIF_TAG_EXPOSURE_INDEX:
    case EXIF_TAG_SENSING_METHOD:
    case EXIF_TAG_FILE_SOURCE:
    case EXIF_TAG_SCENE_TYPE:
    case EXIF_TAG_CFA_PATTERN:
        return TRUE;

    default:
        return FALSE;
    }
}// IsInExifIFDSection()

/**************************************************************************\
*
* Function Description:
*
*   This function checks a given TAG ID to see if it belongs to the GPS IFD
* section.
*
* Return Value:
*
*   Return TRUE if the input ID belongs to GPS IFD. Otherwise, return FALSE.
*
\**************************************************************************/

BOOL
IsInGpsIFDSection(
    PROPID id               // ID to be checked
    )
{
    switch (id)
    {
    case GPS_TAG_VER:
    case GPS_TAG_LATTITUDE_REF:
    case GPS_TAG_LATTITUDE:
    case GPS_TAG_LONGITUDE_REF:
    case GPS_TAG_LONGITUDE:
    case GPS_TAG_ALTITUDE_REF:
    case GPS_TAG_ALTITUDE:
    case GPS_TAG_GPS_TIME:
    case GPS_TAG_GPS_SATELLITES:
    case GPS_TAG_GPS_STATUS:
    case GPS_TAG_GPS_MEASURE_MODE:
    case GPS_TAG_GPS_DOP:
    case GPS_TAG_SPEED_REF:
    case GPS_TAG_SPEED:
    case GPS_TAG_TRACK_REF:
    case GPS_TAG_TRACK:
    case GPS_TAG_IMG_DIR_REF:
    case GPS_TAG_IMG_DIR:
    case GPS_TAG_MAP_DATUM:
    case GPS_TAG_DEST_LAT_REF:
    case GPS_TAG_DEST_LAT:
    case GPS_TAG_DEST_LONG_REF:
    case GPS_TAG_DEST_LONG:
    case GPS_TAG_DEST_BEAR_REF:
    case GPS_TAG_DEST_BEAR:
    case GPS_TAG_DEST_DIST_REF:
    case GPS_TAG_DEST_DIST:
        return TRUE;

    default:
        return FALSE;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   This function checks a given TAG ID to see if it should be written after
* TAG_EXIF_IFD and TAG_GPS_IFD in the 0th IFD. This is for sorting purpose.
*
* Return Value:
*
*   Return TRUE if the input ID should be written after TAG_EXIF_IFD and
* TAG_GPS_IFD in the 0th IFD. Otherwise, return FALSE.
*
\**************************************************************************/

BOOL
IsInLargeSection(
    PROPID id               // ID to be checked
    )
{
    // Of course, if it is a GPS_IFD, we don't need to do so.

    if ((id > TAG_EXIF_IFD) && (id != TAG_GPS_IFD) &&
        (IsInExifIFDSection(id) == FALSE) &&
        (IsInFilterOutSection(id) == FALSE))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}// IsInExifIFDSection()

/**************************************************************************\
*
* Function Description:
*
*   This function checks a given TAG ID to see if it belongs to the thumbnail
* section.
*
* Note: since we store thumbnail in JPEG compressed format. So following TAGs
* should not be saved:
*    case TAG_THUMBNAIL_IMAGE_WIDTH:
*    case TAG_THUMBNAIL_IMAGE_HEIGHT:
*    case TAG_THUMBNAIL_BITS_PER_SAMPLE:
*    case TAG_THUMBNAIL_PHOTOMETRIC_INTERP:
*    case TAG_THUMBNAIL_STRIP_OFFSETS:
*    case TAG_THUMBNAIL_SAMPLES_PER_PIXEL:
*    case TAG_THUMBNAIL_ROWS_PER_STRIP:
*    case TAG_THUMBNAIL_STRIP_BYTES_COUNT:
*    case TAG_THUMBNAIL_PLANAR_CONFIG:
*    case TAG_THUMBNAIL_YCbCr_COEFFICIENTS:
*    case TAG_THUMBNAIL_YCbCr_SUBSAMPLING:
*    case TAG_THUMBNAIL_REF_BLACK_WHITE:
* They are all in IsInFilterOutSection()
*
* Return Value:
*
*   Return TRUE if the input ID belongs to thumbnail IFD. Otherwise, return
* FALSE.
*
\**************************************************************************/

BOOL
IsInThumbNailSection(
    PROPID id               // ID to be checked
    )
{
    switch (id)
    {
    case TAG_THUMBNAIL_COMPRESSION:
    case TAG_THUMBNAIL_IMAGE_DESCRIPTION:
    case TAG_THUMBNAIL_EQUIP_MAKE:
    case TAG_THUMBNAIL_EQUIP_MODEL:
    case TAG_THUMBNAIL_ORIENTATION:
    case TAG_THUMBNAIL_RESOLUTION_X:
    case TAG_THUMBNAIL_RESOLUTION_Y:
    case TAG_THUMBNAIL_RESOLUTION_UNIT:
    case TAG_THUMBNAIL_TRANSFER_FUNCTION:
    case TAG_THUMBNAIL_SOFTWARE_USED:
    case TAG_THUMBNAIL_DATE_TIME:
    case TAG_THUMBNAIL_ARTIST:
    case TAG_THUMBNAIL_WHITE_POINT:
    case TAG_THUMBNAIL_PRIMAY_CHROMATICS:
    case TAG_THUMBNAIL_YCbCr_POSITIONING:
    case TAG_THUMBNAIL_COPYRIGHT:
        return TRUE;

    default:
        return FALSE;
    }
}// IsInThumbNailSection()

/**************************************************************************\
*
* Function Description:
*
*   This function filters out TAGs which is not necessary to be written in the
* APP1 header. For example, most of them are GDI+ internal thumbnail TAGs, they
* will be converted to real Exif spec when written out. Also in the list below
* are TAG_EXIF_IFD, TAG_GPS_IFD, EXIF_TAG_INTEROP etc. These tags are written
* based on if we have specific tags under these IFDs.
*   Filter out TAG_LUMINANCE_TABLE and TAG_CHROMINANCE_TABLE because these will
* be set in jpeg_set_quality if the user uses its own tables.
*   ICC profile should be written to APP2 header, not here.
*
* Return Value:
*
*   Return TRUE if the input ID is in the filter out list. Otherwise, return
* FALSE.
*
\**************************************************************************/

BOOL
IsInFilterOutSection(
    PROPID id               // ID to be checked
    )
{
    switch (id)
    {
    case TAG_THUMBNAIL_IMAGE_WIDTH:
    case TAG_THUMBNAIL_IMAGE_HEIGHT:
    case TAG_THUMBNAIL_BITS_PER_SAMPLE:
    case TAG_THUMBNAIL_PHOTOMETRIC_INTERP:
    case TAG_THUMBNAIL_STRIP_OFFSETS:
    case TAG_THUMBNAIL_SAMPLES_PER_PIXEL:
    case TAG_THUMBNAIL_ROWS_PER_STRIP:
    case TAG_THUMBNAIL_STRIP_BYTES_COUNT:
    case TAG_THUMBNAIL_PLANAR_CONFIG:
    case TAG_THUMBNAIL_YCbCr_COEFFICIENTS:
    case TAG_THUMBNAIL_YCbCr_SUBSAMPLING:
    case TAG_THUMBNAIL_REF_BLACK_WHITE:
    case TAG_EXIF_IFD:
    case TAG_GPS_IFD:
    case TAG_LUMINANCE_TABLE:
    case TAG_CHROMINANCE_TABLE:
    case EXIF_TAG_INTEROP:
    case TAG_JPEG_INTER_FORMAT:
    case TAG_ICC_PROFILE:
        return TRUE;

    default:
        return FALSE;
    }
}// IsInFilterOutSection()

/**************************************************************************\
*
* Function Description:
*
*   This function creates an JPEG APP1 marker (EXIF) in memory, based on input
*   PropertyItem list.
*
* Return Value:
*
*   Status code
*
* Note:
*   During writing to the buffer, we don't need to check if we exceed the bounds
*   of the marker buffer or not. This is for performance reason. The caller
*   should allocate sufficient memory buffer for this routine
*
* Revision History:
*
*   07/06/2000 MinLiu
*       Created it.
*
\**************************************************************************/

HRESULT
CreateAPP1Marker(
    IN PropertyItem* pPropertyList,// Input PropertyItem list
    IN UINT uiNumOfPropertyItems,  // Number of Property items in the input list
    IN BYTE *pbMarkerBuffer,       // Memory buffer for storing the APP1 header
    OUT UINT *puiCurrentLength,    // Total bytes written to APP1 header buffer
    IN UINT uiTransformation       // Transformation info
    )
{
    if ((pbMarkerBuffer == NULL) || (puiCurrentLength == NULL))
    {
        WARNING(("EXIF: CreateAPP1Marker failed---Invalid input parameters"));
        return E_INVALIDARG;
    }

    BOOL fRotate = FALSE;

    // Check if the user has asked for lossless transformation. If yes, we need
    // to do something below.

    if ((uiTransformation == EncoderValueTransformRotate90) ||
        (uiTransformation == EncoderValueTransformRotate270))
    {
        fRotate = TRUE;
    }

    ULONG uiNumOfTagsToWrite = 0;     // Number of TAGs needed to be written in
                                      // current IFD
    ULONG ulThumbnailLength = 0;      // Thumbnail length, in bytes
    BYTE *pbThumbBits = NULL;         // Pointer to thumbnail bits
    UINT uiNumOfExifTags = 0;         // Number of EXIF specific TAGs
    UINT uiNumOfGpsTags = 0;          // Number of GPS specific TAGs
    UINT uiNumOfLargeTags = 0;        // Number of TAGs larger than TAG_EXIF_IFD
    UINT uiNumOfThumbnailTags = 0;    // Number of thumbnail TAGs
    UINT uiNumOfInterOPTags = 0;      // Number of interoperability TAGs
    
    PropertyItem *pItem = pPropertyList;

    // Categorize TAGs: Count how many TAGs are really needed to be saved,
    // filter out tags which are not necessary to be saved, not supported etc.

    for (int i = 0; i < (INT)uiNumOfPropertyItems; ++i)
    {
        // If the image is rotated, we need to swap all related property items
        // by swapping IDs

        if (fRotate == TRUE)
        {
            SwapIDIfNeeded(pItem);
        }// Swap ID values if it is rotated

        if (IsInExifIFDSection(pItem->id) == TRUE)
        {
            // We hit an EXIF specific TAG. Need to write it in ExifIFD later

            uiNumOfExifTags++;
        }
        else if (IsInGpsIFDSection(pItem->id) == TRUE)
        {
            // We hit an GPS specific TAG. Need to write it in GpsIFD later

            uiNumOfGpsTags++;
        }
        else if (IsInInterOPIFDSection(pItem->id) == TRUE)
        {
            // We hit an EXIF interOP specific TAG. Need to write it in
            // ExifIFD's InterOP IFD later

            uiNumOfInterOPTags++;
        }
        else if (IsInLargeSection(pItem->id) == TRUE)
        {
            // We hit a TAG which has an ID bigger than TAG_EXIF_IFD, like the
            // SHELL's Unicode user comments, title tags etc.
            // Need to write it after the TAG_EXIF_IFD tag

            uiNumOfLargeTags++;
            uiNumOfTagsToWrite++;
        }
        else if (IsInThumbNailSection(pItem->id) == TRUE)
        {
            // Hit a useful thumbnail TAG. Write it to 1st IFD later

            uiNumOfThumbnailTags++;
        }
        else if (pItem->id == TAG_THUMBNAIL_DATA)
        {
            pbThumbBits = (BYTE*)pItem->value;

            if (pbThumbBits)
            {
                // Get total thumbnail length

                ulThumbnailLength = pItem->length;
            }
            else
            {
                WARNING(("Exif---CreateAPP1Marker, NULL thumbnail bits"));

                // Set ulThumbnailLength = 0 which means we don't have thumb

                ulThumbnailLength = 0;
            }
        }
        else if ((IsInFilterOutSection(pItem->id) == FALSE) &&
                 (pItem->id != TAG_JPEG_INTER_LENGTH))
        {
            // Hit a real TAG needs to be written in 0th IFD
            // Note: we don't need to count TAG_JPEG_INTER_LENGTH since we will
            // treat it specially in writing thumbnail section

            uiNumOfTagsToWrite++;
        }
        
        // Move onto next item

        pItem++;
    }// Loop through all the property items to Categorize them

    if ((uiNumOfTagsToWrite == 0) && (uiNumOfExifTags == 0) &&
        (uiNumOfGpsTags == 0) && (uiNumOfInterOPTags == 0) &&
        (uiNumOfThumbnailTags == 0) && (ulThumbnailLength != 0))
    {
        // If there is nothing to write, just bail out

        return S_OK;
    }

    // Sort all tags based on their ID

    SortTags(pPropertyList, uiNumOfPropertyItems);
    
    // If we need to write EXIF or GPS specific tag, we need to allocate one
    // entry for each of them

    if (uiNumOfExifTags > 0)
    {
        uiNumOfTagsToWrite++;
    }

    if (uiNumOfGpsTags > 0)
    {
        uiNumOfTagsToWrite++;
    }
    
    // Write an EXIF header out, aka EXIF Identifier

    BYTE *pbCurrent = pbMarkerBuffer;
    pbCurrent[0] = 'E';
    pbCurrent[1] = 'x';
    pbCurrent[2] = 'i';
    pbCurrent[3] = 'f';
    pbCurrent[4] = 0;
    pbCurrent[5] = 0;

    UINT uiTotalBytesWritten = 6;           // Total bytes written so far

    // Write out machine type as "little endian" and "identification" bytes 2A

    UINT16 UNALIGNED *pui16Temp = (UINT16 UNALIGNED*)(pbMarkerBuffer +
                                                      uiTotalBytesWritten);
    pui16Temp[0] = 0x4949;
    pui16Temp[1] = 0x2A;

    uiTotalBytesWritten += 4;

    // Use 4 bytes to write out 0th offset to 0th IFD. Since we write out the
    // 0th IFD immediately after the header, so we put 8 here. This means that
    // the 0th IFD is 8 bytes after the "little endian" and "offset" field.

    UINT32 UNALIGNED *pulIFDOffset = (UINT32 UNALIGNED*)(pbMarkerBuffer +
                                                         uiTotalBytesWritten);
    *pulIFDOffset = 8;

    uiTotalBytesWritten += 4;
    
    // Fill in the "number of entry" field, 2 bytes

    UINT16 UNALIGNED *pui16NumEntry = (UINT16 UNALIGNED*)(pbMarkerBuffer +
                                                          uiTotalBytesWritten);
    *pui16NumEntry = (UINT16)uiNumOfTagsToWrite;

    uiTotalBytesWritten += 2;

    // We need to create "uiNumOfTagsToWrite" of TAG entries (aka directory
    // entries in TIFF's term)

    ULONG ulTagSectionLength = sizeof(IFD_TAG) * uiNumOfTagsToWrite;
    IFD_TAG *pTagBuf = (IFD_TAG*)GpMalloc(ulTagSectionLength);
    if (pTagBuf == NULL)
    {
        WARNING(("EXIF: CreateAPP1Marker failed---Out of memory"));
        return E_OUTOFMEMORY;
    }

    // We can't write all the TAGs now since we can't fill in all the values at
    // this moment. So we have to remember where to write 0th IFD, (pbIFDOffset)

    BYTE *pbIFDOffset = pbMarkerBuffer + uiTotalBytesWritten;

    // We need to count "ulTagSectionLength" bytes as written. This makes it
    // easier for counting the offset below.
    // Note: Here "+4" is for the 4 bytes taken for writing the offset for next
    // IFD offset. We will fill in the value later

    uiTotalBytesWritten += (ulTagSectionLength + 4);

    // Figure out the offset for 0th IFD value section
    // According to the EXIF spec, "0th IFD value" section should be after "0th
    // IFD". So here we need to figure out the offset for that value "pbCurrent"

    pbCurrent = pbMarkerBuffer + uiTotalBytesWritten;

    pItem = pPropertyList;          // Let pItem points to the beginning of
                                    // PropertyItem buffer

    IFD_TAG *pCurrentTag = NULL;    // Current tag to write to memory buffer
    ULONG uiNumOfTagsWritten = 0;   // Counter of TAGs written

    HRESULT hr = S_OK;

    // Write 0th IFD

    for (int i = 0; i < (INT)uiNumOfPropertyItems; ++i)
    {
        MakeOffsetEven(uiTotalBytesWritten);

        // Filter out tags which are not necessary to be saved in 0th IFD at
        // this moment

        if ( (IsInFilterOutSection(pItem->id) == TRUE)
           ||(IsInThumbNailSection(pItem->id) == TRUE)
           ||(IsInExifIFDSection(pItem->id) == TRUE)
           ||(IsInGpsIFDSection(pItem->id) == TRUE)
           ||(IsInLargeSection(pItem->id) == TRUE)
           ||(IsInInterOPIFDSection(pItem->id) == TRUE)
           ||(pItem->id == TAG_JPEG_INTER_LENGTH)
           ||(pItem->id == TAG_THUMBNAIL_DATA) )
        {
            // Move onto next PropertyItem

            pItem++;
            continue;
        }

        // Hit a TAG which needs to be saved in 0th IFD. So fill out a new TAG
        // structure

        pCurrentTag = pTagBuf + uiNumOfTagsWritten;
        
        hr = WriteATag(
            pbMarkerBuffer,
            pCurrentTag,
            pItem,
            &pbCurrent,
            &uiTotalBytesWritten
            );

        if (FAILED(hr))
        {
            WARNING(("EXIF: CreateAPP1Marker--WriteATag() failed"));
            break;
        }

        uiNumOfTagsWritten++;

        // Move onto next PropertyItem

        pItem++;
    }// Write 0th IFD

    if (SUCCEEDED(hr))
    {
        // Check if we need to write EXIF IFD or not

        UINT UNALIGNED *pExifIFDOffset = NULL;  // Pointer to remember Exif IFD
                                                // offset

        if (uiNumOfExifTags > 0)
        {
            // Find the memory location for storing Exif TAG

            pCurrentTag = pTagBuf + uiNumOfTagsWritten;

            // Fill out an EXIF IFD Tag

            pCurrentTag->wTag = TAG_EXIF_IFD;
            pCurrentTag->wType = TAG_TYPE_LONG;
            pCurrentTag->dwCount = 1;

            // Set the offset for specific EXIF IFD entry

            pCurrentTag->dwOffset = uiTotalBytesWritten - 6;

            // This "offset" might get changed if there is any "large tag" needs
            // to be written. So remember the address now so we can update it
            // later.

            pExifIFDOffset = (UINT UNALIGNED*)(&(pCurrentTag->dwOffset));

            uiNumOfTagsWritten++;
        }

        UINT UNALIGNED *pGpsIFDOffset = NULL; // Pointer to remember Gps IFD
                                              // offset

        if (uiNumOfGpsTags > 0)
        {
            // Find the memory location for storing Gps TAG

            pCurrentTag = pTagBuf + uiNumOfTagsWritten;

            // Fill out an GPS IFD Tag

            pCurrentTag->wTag = TAG_GPS_IFD;
            pCurrentTag->wType = TAG_TYPE_LONG;
            pCurrentTag->dwCount = 1;

            // Set the offset for specific GPS IFD entry

            pCurrentTag->dwOffset = uiTotalBytesWritten - 6;

            // This "offset" might get changed if there is any "large tag" needs
            // to be written. So remember the address now so we can update it
            // later.

            pGpsIFDOffset = (UINT UNALIGNED*)(&(pCurrentTag->dwOffset));

            uiNumOfTagsWritten++;
        }

        // Check if we need to write any tags after TAG_EXIF_IFD id

        if (uiNumOfLargeTags > 0)
        {
            pItem = pPropertyList;

            for (int i = 0; i < (INT)uiNumOfPropertyItems; ++i)
            {
                MakeOffsetEven(uiTotalBytesWritten);

                if (IsInLargeSection(pItem->id) == TRUE)
                {
                    // Hit a large TAG. Fill out a new TAG structure

                    pCurrentTag = pTagBuf + uiNumOfTagsWritten;

                    hr = WriteATag(
                        pbMarkerBuffer,
                        pCurrentTag,
                        pItem,
                        &pbCurrent,
                        &uiTotalBytesWritten
                        );

                    if (FAILED(hr))
                    {
                        WARNING(("EXIF: CreateAPP1Marker--WriteATag() failed"));
                        break;
                    }

                    uiNumOfTagsWritten++;
                }

                // Move onto next PropertyItem

                pItem++;
            }// Loop through all the property items to write large TAGs

            // Adjust the ExifIFDOffset pointer if necessary

            if (SUCCEEDED(hr) && pExifIFDOffset)
            {
                *pExifIFDOffset = (uiTotalBytesWritten - 6);
            }

            if (SUCCEEDED(hr) && pGpsIFDOffset)
            {
                *pGpsIFDOffset = (uiTotalBytesWritten - 6);
            }
        }// If we need to write TAGs after TAG_EXIF_IFD

        if (SUCCEEDED(hr))
        {
            // These two numbers should be identical. Assert here in case we
            // messed up the categorizing and writing above

            ASSERT(uiNumOfTagsWritten == uiNumOfTagsToWrite);

            // Now fill the EXIF specific IFD if necessary

            if (uiNumOfExifTags > 0)
            {
                hr = WriteExifIFD(
                    pbMarkerBuffer,
                    pPropertyList,
                    uiNumOfPropertyItems,
                    uiNumOfExifTags,
                    uiNumOfInterOPTags,
                    &uiTotalBytesWritten
                    );

                if (SUCCEEDED(hr) && pGpsIFDOffset)
                {
                    *pGpsIFDOffset = (uiTotalBytesWritten - 6);
                }
            }// Write EXIF specific IFD

            if (SUCCEEDED(hr))
            {
                // Now fill the GPS specific IFD if necessary

                if (uiNumOfGpsTags > 0)
                {
                    hr = WriteGpsIFD(
                        pbMarkerBuffer,
                        pPropertyList,
                        uiNumOfPropertyItems,
                        uiNumOfGpsTags,
                        &uiTotalBytesWritten
                        );
                }// Write GPS specific IFD

                if (SUCCEEDED(hr))
                {
                    // After the above loop, we have filled all the fields in
                    // all the TAG structures. Write out all the directory
                    // entries now

                    GpMemcpy(pbIFDOffset, (BYTE*)pTagBuf, ulTagSectionLength);

                    // Set the offset to next IFD

                    pbCurrent = pbIFDOffset + ulTagSectionLength;
                    pulIFDOffset = (UINT32 UNALIGNED*)pbCurrent;

                    // Check if we need to write out the thumbnail, aka 1st IFD

                    if ((ulThumbnailLength != 0) && (pbThumbBits != NULL))
                    {
                        // Offset has to be an even number

                        MakeOffsetEven(uiTotalBytesWritten);

                        // Fill the offset value in 0th IFD offset field to
                        // point it to 1st IFD

                        *pulIFDOffset = (uiTotalBytesWritten - 6);

                        BYTE *pbDummy = (BYTE*)pulIFDOffset;

                        hr = Write1stIFD(
                            pbMarkerBuffer,
                            pPropertyList,
                            uiNumOfPropertyItems,
                            uiNumOfThumbnailTags,
                            ulThumbnailLength,
                            pbThumbBits,
                            &pbDummy,
                            &uiTotalBytesWritten
                            );

                        pulIFDOffset = (UINT32 UNALIGNED*)pbDummy;
                    }

                    if (SUCCEEDED(hr))
                    {
                        // Set the next IFD offset to NULL to terminate the page

                        *pulIFDOffset = 0;

                        *puiCurrentLength = uiTotalBytesWritten;
                    }
                }
            }
        }
    }

    if (pTagBuf)
    {
        GpFree(pTagBuf);
    }

    return hr;
}// CreateAPP1Marker()

/**************************************************************************\
*
* Function Description:
*
*   This function uses SHELL sort to sort TAGs based on their ID
*
* Return Value:
*
*   None.
*
\**************************************************************************/

void
SortTags(
    PropertyItem *pItemBuffer,
    UINT cPropertyItems
    )
{
    PropertyItem tempTag;
    
    PropertyItem *pTag = pItemBuffer;
    
    // Shell sort

    for (int step = (cPropertyItems >> 1); step > 0; step >>= 1 ) 
    {
        for (int i = step; i < (int)cPropertyItems; i++)
        {
            for (int j = i - step; j >= 0; j-= step ) 
            {
                if (pTag[j].id < pTag[j+1].id)
                {
                    break;
                }

                tempTag = pTag[j];
                pTag[j] = pTag[j + step];
                pTag[j + step] = tempTag;
            }
        }
    }

    return;
}// SortTags()

/**************************************************************************\
*
* Function Description:
*
*   This function is used to swap the a TAG id when rotate 90/270 degree
*
* Return Value:
*
*   None.
*
\**************************************************************************/

void
SwapIDIfNeeded(
    PropertyItem *pItem
    )
{
    switch (pItem->id)
    {
    case PropertyTagImageWidth:
        pItem->id = PropertyTagImageHeight;
        break;

    case PropertyTagImageHeight:
        pItem->id = PropertyTagImageWidth;
        break;

    case PropertyTagXResolution:
        pItem->id = PropertyTagYResolution;
        break;

    case PropertyTagYResolution:
        pItem->id = PropertyTagXResolution;
        break;

    case PropertyTagResolutionXUnit:
        pItem->id = PropertyTagResolutionYUnit;
        break;

    case PropertyTagResolutionYUnit:
        pItem->id = PropertyTagResolutionXUnit;
        break;

    case PropertyTagResolutionXLengthUnit:
        pItem->id = PropertyTagResolutionYLengthUnit;
        break;

    case PropertyTagResolutionYLengthUnit:
        pItem->id = PropertyTagResolutionXLengthUnit;
        break;

    case PropertyTagExifPixXDim:
        pItem->id = PropertyTagExifPixYDim;
        break;

    case PropertyTagExifPixYDim:
        pItem->id = PropertyTagExifPixXDim;
        break;

    case PropertyTagExifFocalXRes:
        pItem->id = PropertyTagExifFocalYRes;
        break;

    case PropertyTagExifFocalYRes:
        pItem->id = PropertyTagExifFocalXRes;
        break;

    case PropertyTagThumbnailResolutionX:
        pItem->id = PropertyTagThumbnailResolutionY;
        break;

    case PropertyTagThumbnailResolutionY:
        pItem->id = PropertyTagThumbnailResolutionX;
        break;

    default:
        // For rest of property IDs, no need to swap

        break;
    }

    return;
}

/**************************************************************************\
*
* Function Description:
*
*   This function writes out a TAG
*
* Return Value:
*
*   Status code.
*
\**************************************************************************/

HRESULT
WriteATag(
    BYTE *pbMarkerBuffer,       // Pointer to marker buffer for IFD
    IFD_TAG *pCurrentTag,       // Current TAG
    PropertyItem *pTempItem,    // Property item
    BYTE **ppbCurrent,          // Position
    UINT *puiTotalBytesWritten  // Total bytes written
    )
{
    HRESULT hr = S_OK;

    pCurrentTag->wTag = (WORD)pTempItem->id;

    // NOTE: there is A difference between "IFD_TAG.dwCount" and
    // PropertyItem.length
    // "IFD_TAG.dwCount" means the number of values. IT IS NOT THE SUM OF
    //  THE BYTES
    // "PropertyItem.length" is "Length of the property value, in bytes"
    // So we need to do some convertion here

    pCurrentTag->dwCount = pTempItem->length;
    pCurrentTag->wType = pTempItem->type;

    switch (pCurrentTag->wType)
    {
    case TAG_TYPE_ASCII:
    case TAG_TYPE_BYTE:
    case TAG_TYPE_UNDEFINED:
        pCurrentTag->dwCount = pTempItem->length;

        if (pCurrentTag->dwCount > 4)
        {
            // Write to the current mark buffer and remember the offset

            GpMemcpy(*ppbCurrent, (BYTE*)pTempItem->value, pTempItem->length);

            // Here "-6" is because the offset starts at 6 bytes after
            // the "Exif  ", EXIF signature

            pCurrentTag->dwOffset = *puiTotalBytesWritten - 6;
            *puiTotalBytesWritten += pTempItem->length;
            MakeOffsetEven(*puiTotalBytesWritten);
            *ppbCurrent = pbMarkerBuffer + (*puiTotalBytesWritten);
        }
        else
        {
            // Write to the current mark buffer and remember the offset

            GpMemcpy(
                &pCurrentTag->dwOffset,
                (BYTE*)pTempItem->value,
                pTempItem->length
                );
        }

        break;

    case TAG_TYPE_RATIONAL:
    case TAG_TYPE_SRATIONAL:
        pCurrentTag->dwCount = (pTempItem->length >> 3);

        // Write to the current mark buffer and remember the offset

        GpMemcpy(*ppbCurrent, (BYTE*)pTempItem->value, pTempItem->length);

        // Here "-6" is because the offset starts at 6 bytes after the
        // "Exif  ", EXIF signature

        pCurrentTag->dwOffset = (*puiTotalBytesWritten - 6);

        *puiTotalBytesWritten += pTempItem->length;
        MakeOffsetEven(*puiTotalBytesWritten);
        *ppbCurrent = pbMarkerBuffer + (*puiTotalBytesWritten);

        break;

    case TAG_TYPE_SHORT:
        pCurrentTag->dwCount = (pTempItem->length >> 1);

        if (pCurrentTag->dwCount == 1)
        {
            pCurrentTag->us = *((UINT16 UNALIGNED*)pTempItem->value);
        }
        else
        {
            // We have to write the value to the offset field

            GpMemcpy(*ppbCurrent, (BYTE*)pTempItem->value, pTempItem->length);

            // Here "-6" is because the offset starts at 6 bytes after
            // the "Exif  ", EXIF signature

            pCurrentTag->dwOffset = *puiTotalBytesWritten - 6;

            *puiTotalBytesWritten += pTempItem->length;
            MakeOffsetEven(*puiTotalBytesWritten);
            *ppbCurrent = pbMarkerBuffer + (*puiTotalBytesWritten);
        }

        break;

    case TAG_TYPE_LONG:
    case TAG_TYPE_SLONG:
        pCurrentTag->dwCount = (pTempItem->length >> 2);

        if (pCurrentTag->dwCount == 1)
        {
            pCurrentTag->l = *((INT32 UNALIGNED*)pTempItem->value);
        }
        else
        {
            // We have to write the value to the offset field

            GpMemcpy(*ppbCurrent, (BYTE*)pTempItem->value, pTempItem->length);

            // Here "-6" is because the offset starts at 6 bytes after
            // the "Exif  ", EXIF signature

            pCurrentTag->dwOffset = (*puiTotalBytesWritten - 6);

            *puiTotalBytesWritten += pTempItem->length;
            MakeOffsetEven(*puiTotalBytesWritten);
            *ppbCurrent = pbMarkerBuffer + (*puiTotalBytesWritten);
        }

        break;

    default:
        WARNING(("EXIF: WriteExifHeader---Unknown property type"));

        hr = E_FAIL;
    }// switch on type

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   This function writes out all thumbnail tags
*
* Return Value:
*
*   Status code.
*
\**************************************************************************/

HRESULT
WriteThumbnailTags(
    IN PropertyItem *pItemBuffer,           // Property item list
    IN BYTE *pbMarkerBuffer,                // Pointer to marker buffer for IFD
    IN IFD_TAG *pTags,                      // TAG to be written
    IN UINT uiNumOfPropertyItems,           // Number of property items
    IN OUT UINT *puiNumOfThumbnailTagsWritten,  // Num of thumbnail tags written
    IN OUT UINT *puiTotalBytesWritten,      // Total bytes written so far
    IN BOOL fWriteSmallTag                  // TRUE if to write TAG whose ID is
                                            //smaller than TAG_JPEG_INTER_FORMAT
    )
{
    PropertyItem *pItem = pItemBuffer;

    // Figure out the offset for 1st IFD value section

    BYTE *pbCurrent = pbMarkerBuffer + (*puiTotalBytesWritten);

    IFD_TAG *pCurrentTag = NULL;
    HRESULT hr = S_OK;

    for (int i = 0; i < (INT)uiNumOfPropertyItems; ++i)
    {
        // Only write Thumbnail specific TAGs

        if (IsInThumbNailSection(pItem->id) == TRUE)
        {
            // Need to copy the property item first since we don't want to
            // values in the original property item.

            PropertyItem tempItem;
            CopyPropertyItem(pItem, &tempItem);
            
            // Map all GDI+ internal thumbnail TAG IDs to EXIF defined tag IDs.

            ThumbTagToMainImgTag(&tempItem);
        
            if (((fWriteSmallTag == TRUE) &&
                 (tempItem.id < TAG_JPEG_INTER_FORMAT)) ||
                ((fWriteSmallTag == FALSE) &&
                 (tempItem.id > TAG_JPEG_INTER_LENGTH)))
            {
                // Fill out a new TAG structure

                pCurrentTag = pTags + (*puiNumOfThumbnailTagsWritten);
        
                hr = WriteATag(
                    pbMarkerBuffer,
                    pCurrentTag,
                    &tempItem,
                    &pbCurrent,
                    puiTotalBytesWritten
                    );

                if (FAILED(hr))
                {
                    WARNING(("WriteThumbnailTags failed--WriteATag failed"));
                    break;
                }

                *puiNumOfThumbnailTagsWritten += 1;
            }
        }

        // Move onto next PropertyItem

        pItem++;
    }// Loop through all the property items to write EXIF tags

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   This function writes out the EXIF IFD.
*
* Return Value:
*
*   Status code.
*
\**************************************************************************/

HRESULT
WriteExifIFD(
    IN BYTE *pbMarkerBuffer,            // Pointer to marker buffer for IFD
    IN PropertyItem *pItemBuffer,       // Property item list
    IN UINT uiNumOfPropertyItems,       // Number of property items
    IN UINT uiNumOfExifTags,            // Number of Exif property items
    IN UINT uiNumOfInterOPTags,         // Number of InterOP property items
    IN OUT UINT *puiTotalBytesWritten   // Total bytes written
    )
{
    // ISSUE-2002/02/04--minliu, Due to the lack of spec for InterOpbility, we
    // don't want to write InterOP IFD. So this line below gurantees that we
    // won't write this IFD. We will take this line out in GDI+ V2 if we feel
    // we need to support it.

    uiNumOfInterOPTags = 0;

    if (uiNumOfInterOPTags > 0)
    {
        // If we see InterOP tags, we need to add one entry in the exif IFD

        uiNumOfExifTags++;
    }

    // Fill in the number of entry field, 2 bytes

    UINT16 UNALIGNED *pui16NumEntry = (UINT16 UNALIGNED*)(pbMarkerBuffer +
                                                      (*puiTotalBytesWritten));
    *pui16NumEntry = (UINT16)uiNumOfExifTags;

    *puiTotalBytesWritten += 2;

    UINT uiExifTagSectionLength = sizeof(IFD_TAG) * uiNumOfExifTags;

    IFD_TAG *pTagBuf = (IFD_TAG*)GpMalloc(uiExifTagSectionLength);

    if (pTagBuf == NULL)
    {
        WARNING(("EXIF: WriteExifHeader failed---Out of memory"));
        return E_OUTOFMEMORY;
    }

    // Remember where to write EXIF IFD, (pbExifIFDOffset). We can't write
    // all the TAGs now since we can't fill in all the values at this moment

    BYTE *pbExifIFDOffset = pbMarkerBuffer + (*puiTotalBytesWritten);

    // We need to count "uiExifTagSectionLength" bytes as written. This
    // makes it easier for counting the offset below.
    // Here "+4" is for 4 bytes for writing next IFD offset.

    *puiTotalBytesWritten += (uiExifTagSectionLength + 4);
    MakeOffsetEven(*puiTotalBytesWritten);

    // Figure out the offset for EXIF IFD value section

    BYTE *pbCurrent = pbMarkerBuffer + (*puiTotalBytesWritten);
    PropertyItem *pItem = pItemBuffer;
    IFD_TAG *pCurrentTag = NULL;
    UINT cExifTagsWritten = 0; // Num of EXIF tags have been written so far
    UINT cLargeTag = 0;
    HRESULT hr = S_OK;

    for (int i = 0; i < (INT)uiNumOfPropertyItems; ++i)
    {
        // Only write EXIF specific TAGs

        if (IsInExifIFDSection(pItem->id) == TRUE)
        {
            // Find an EXIF tag. Need to figure out if its TAG id is bigger than
            // InterOP tag or not on condition if we need to write InterOP tag

            if ((uiNumOfInterOPTags > 0) && (pItem->id > EXIF_TAG_INTEROP))
            {
                // Rememeber we have hit a tag whose ID is > EXIF_TAG_INTEROP
                // We have to write this TAG after InterOP IFD

                cLargeTag++;
            }
            else
            {
                // Fill out a new TAG structure

                pCurrentTag = pTagBuf + cExifTagsWritten;

                hr = WriteATag(
                    pbMarkerBuffer,
                    pCurrentTag,
                    pItem,
                    &pbCurrent,
                    puiTotalBytesWritten
                    );

                if (FAILED(hr))
                {
                    WARNING(("EXIF: WriteExifHeader failed--WriteATag failed"));
                    break;
                }

                cExifTagsWritten++;
            }
        }

        // Move onto next PropertyItem

        pItem++;
    }// Loop through all the property items to write EXIF tags

    if (SUCCEEDED(hr))
    {
        // It's time to write InterOP IFD if necessary
        // Pointer to remember InterOP IFD offset

        UINT UNALIGNED *pInterOPIFDOffset = NULL;

        if (uiNumOfInterOPTags > 0)
        {
            // Find the memory location for storing InterOP TAG

            pCurrentTag = pTagBuf + cExifTagsWritten;

            // Fill out an InterOP IFD Tag

            pCurrentTag->wTag = EXIF_TAG_INTEROP;
            pCurrentTag->wType = TAG_TYPE_LONG;
            pCurrentTag->dwCount = 1;

            // Set the offset for specific InterOP IFD entry

            pCurrentTag->dwOffset = (*puiTotalBytesWritten - 6);

            // This "offset" might get changed if there is any "large tag" needs to
            // be written. So remember the address now so we can update it later.

            pInterOPIFDOffset = (UINT UNALIGNED*)(&(pCurrentTag->dwOffset));

            cExifTagsWritten++;
        }

        // Write any TAGs whose id > EXIF_TAG_INTEROP, if there is any

        if (cLargeTag > 0)
        {
            pItem = pItemBuffer;

            for (int i = 0; i < (INT)uiNumOfPropertyItems; ++i)
            {
                MakeOffsetEven(*puiTotalBytesWritten);

                if ((IsInExifIFDSection(pItem->id) == TRUE) &&
                    (pItem->id > EXIF_TAG_INTEROP))
                {
                    // Hit a large TAG. Fill out a new TAG structure

                    pCurrentTag = pTagBuf + cExifTagsWritten;

                    hr = WriteATag(
                        pbMarkerBuffer,
                        pCurrentTag,
                        pItem,
                        &pbCurrent,
                        puiTotalBytesWritten
                        );

                    if (FAILED(hr))
                    {
                        WARNING(("WriteExifHeader failed--WriteATag failed"));
                        break;
                    }
                    
                    cExifTagsWritten++;
                }
                
                // Move onto next PropertyItem
                
                pItem++;
            }// Loop through all the property items to write large TAGs

            // Adjust the ExifIFDOffset pointer if necessary

            if (SUCCEEDED(hr) && pInterOPIFDOffset)
            {
                *pInterOPIFDOffset = (*puiTotalBytesWritten - 6);
            }
        }

        if (SUCCEEDED(hr))
        {
            // After the above loop, we have fill all the fields in all the EXIF
            // TAG structure. Write out all the directory entries now

            GpMemcpy(pbExifIFDOffset, (BYTE*)pTagBuf, uiExifTagSectionLength);

            // Now fill the InterOP IFD if necessary

            if (uiNumOfInterOPTags > 0)
            {
                hr = WriteInterOPIFD(
                    pbMarkerBuffer,
                    pItemBuffer,
                    uiNumOfPropertyItems,
                    uiNumOfInterOPTags,
                    puiTotalBytesWritten
                    );
            }// Write EXIF specific IFD

            // Add a NULL at the end to terminate the EXIF offset.

            *((UINT32 UNALIGNED*)(pbExifIFDOffset + uiExifTagSectionLength)) =
                NULL;
        }
    }

    GpFree(pTagBuf);

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   This function writes out the GPS IFD.
*
* Return Value:
*
*   Status code.
*
\**************************************************************************/

HRESULT
WriteGpsIFD(
    IN BYTE *pbMarkerBuffer,            // Pointer to marker buffer for IFD
    IN PropertyItem *pItemBuffer,       // Property item list
    IN UINT uiNumOfPropertyItems,       // Number of property items
    IN UINT uiNumOfGpsTags,             // Number of GPS tags
    IN OUT UINT *puiTotalBytesWritten   // Total bytes written in the marker buf
    )
{
    if (uiNumOfGpsTags < 1)
    {
        // Nothing needs to be written

        return S_OK;
    }

    HRESULT hr = S_OK;

    // Fill in the number of entry field, 2 bytes

    UINT16 UNALIGNED *pui16NumEntry = (UINT16 UNALIGNED*)(pbMarkerBuffer +
                                                      (*puiTotalBytesWritten));
    *pui16NumEntry = (UINT16)uiNumOfGpsTags;

    *puiTotalBytesWritten += 2;

    UINT uiGpsTagSectionLength = sizeof(IFD_TAG) * uiNumOfGpsTags;

    IFD_TAG *pTagBuf = (IFD_TAG*)GpMalloc(uiGpsTagSectionLength);

    if (pTagBuf == NULL)
    {
        WARNING(("EXIF: WriteGpsHeader failed---Out of memory"));
        return E_OUTOFMEMORY;
    }

    // Remember where to write GPS IFD, (pbGPSIFDOffset). We can't write
    // all the TAGs now since we can't fill in all the values at this moment

    BYTE *pbGpsIFDOffset = pbMarkerBuffer + (*puiTotalBytesWritten);

    // We need to count "uiGpsTagSectionLength" bytes as written. This
    // makes it easier for counting the offset below.
    // Here "+4" is for 4 bytes for writing next IFD offset.

    *puiTotalBytesWritten += (uiGpsTagSectionLength + 4);
    MakeOffsetEven(*puiTotalBytesWritten);

    // Figure out the offset for GPS IFD value section

    BYTE *pbCurrent = pbMarkerBuffer + (*puiTotalBytesWritten);
    PropertyItem *pItem = pItemBuffer;
    IFD_TAG *pCurrentTag = NULL;
    UINT cGpsTagsWritten = 0; // Num of GPS tags have been written so far

    for (int i = 0; i < (INT)uiNumOfPropertyItems; ++i)
    {
        // Only write GPS specific TAGs

        if (IsInGpsIFDSection(pItem->id) == TRUE)
        {
            // Fill out a new TAG structure

            pCurrentTag = pTagBuf + cGpsTagsWritten;

            hr = WriteATag(
                pbMarkerBuffer,
                pCurrentTag,
                pItem,
                &pbCurrent,
                puiTotalBytesWritten
                );

            if (FAILED(hr))
            {
                WARNING(("EXIF: WriteGpsHeader---WriteATag() failed"));                
                break;
            }

            cGpsTagsWritten++;
        }

        // Move onto next PropertyItem

        pItem++;
    }// Loop through all the property items to write GPS tags

    if (SUCCEEDED(hr))
    {
        // After the above loop, we have fill all the fields in all the GPS TAG
        // structure. Write out all the directory entries now

        GpMemcpy(pbGpsIFDOffset, (BYTE*)pTagBuf, uiGpsTagSectionLength);

        // Add a NULL at the end to terminate the GPS offset.

        *((UINT32 UNALIGNED*)(pbGpsIFDOffset + uiGpsTagSectionLength)) = NULL;
    }

    GpFree(pTagBuf);

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   This function writes out the 1st IFD.
*
* Return Value:
*
*   Status code.
*
\**************************************************************************/

HRESULT
Write1stIFD(
    IN BYTE *pbMarkerBuffer,            // Pointer to marker buffer for IFD
    IN PropertyItem *pItemBuffer,       // Property item list
    IN UINT uiNumOfPropertyItems,       // Number of property items
    IN ULONG uiNumOfThumbnailTags,      // Number of thumbnail tags
    IN ULONG ulThumbnailLength,         // Thumbnail length
    IN BYTE *pbThumbBits,               // Thumbnail bits
    IN OUT BYTE **ppbIFDOffset,         // Pointer of "Offset to next IFD"
    IN OUT UINT *puiTotalBytesWritten   // Total bytes written in the marker buf
    )
{
    if (uiNumOfThumbnailTags < 1)
    {
        // Nothing needs to be written

        return S_OK;
    }

    HRESULT hr = S_OK;

    // We will write out 2 TAGs for 1st IFD, InterLength and InterFormat
    // plus some extra IDs

    BYTE *pbCurrent = pbMarkerBuffer + (*puiTotalBytesWritten);
    UINT16 UNALIGNED *pui16NumEntry = (UINT16 UNALIGNED*)pbCurrent;
    *pui16NumEntry = (UINT16)(2 + uiNumOfThumbnailTags);

    *puiTotalBytesWritten += 2;

    ULONG ulTagSectionLength = sizeof(IFD_TAG) * (2 + uiNumOfThumbnailTags);

    IFD_TAG *pTagBuf = (IFD_TAG*)GpMalloc(ulTagSectionLength);

    if (pTagBuf == NULL)
    {
        WARNING(("EXIF: WriteExifHeader failed---Out of memory"));
        return E_OUTOFMEMORY;
    }

    // Remember where to write 1th IFD, (pbIFDOffset).

    BYTE *pbIFDOffset = pbMarkerBuffer + (*puiTotalBytesWritten);

    // We need to count "ulTagSectionLength" bytes as written. This is
    // easier for counting the offset below
    // Note: Here "+4" is for the 4 bytes taken for writing the offset for
    // next IFD offset. We will fill the value later

    *puiTotalBytesWritten += (ulTagSectionLength + 4);

    UINT uiNumOfThumbnailTagsWritten = 0;

    // Write thumbnail items with TAGs smaller than JPEG tag

    hr = WriteThumbnailTags(
        pItemBuffer,
        pbMarkerBuffer,
        pTagBuf,
        uiNumOfPropertyItems,
        &uiNumOfThumbnailTagsWritten,
        puiTotalBytesWritten,
        TRUE                            // Write TAGs smaller than JPEG tag
        );

    if (SUCCEEDED(hr))
    {
        // Fill in 2 thumbnail data TAGs

        IFD_TAG *pCurrentTag = pTagBuf + uiNumOfThumbnailTagsWritten;
        pCurrentTag->wTag = TAG_JPEG_INTER_FORMAT;
        pCurrentTag->wType = TAG_TYPE_LONG;
        pCurrentTag->dwCount = 1;
        pCurrentTag->dwOffset = (*puiTotalBytesWritten - 6);

        uiNumOfThumbnailTagsWritten++;

        pCurrentTag = pTagBuf + uiNumOfThumbnailTagsWritten;
        pCurrentTag->wTag = TAG_JPEG_INTER_LENGTH;
        pCurrentTag->wType = TAG_TYPE_LONG;
        pCurrentTag->dwCount = 1;
        pCurrentTag->ul = ulThumbnailLength;

        uiNumOfThumbnailTagsWritten++;

        // Write thumbnail items with TAGs bigger than JPEG tag
        
        hr = WriteThumbnailTags(
            pItemBuffer,
            pbMarkerBuffer,
            pTagBuf,
            uiNumOfPropertyItems,
            &uiNumOfThumbnailTagsWritten,
            puiTotalBytesWritten,
            FALSE                           // Write TAGs bigger than JPEG tag
            );

        if (SUCCEEDED(hr))
        {
            // Write out all the directory entries for 1st IFD now

            GpMemcpy(pbIFDOffset, (BYTE*)pTagBuf, ulTagSectionLength);

            // Set the offset to next IFD

            pbCurrent = pbIFDOffset + ulTagSectionLength;
            *ppbIFDOffset = pbCurrent;

            // Figure out the offset for 1st IFD value section

            pbCurrent = pbMarkerBuffer + (*puiTotalBytesWritten);

            // Write the thumbnail bits now

            GpMemcpy(pbCurrent, pbThumbBits, ulThumbnailLength);

            *puiTotalBytesWritten += ulThumbnailLength;
        }
    }

    GpFree(pTagBuf);

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   This function extracts a TIFF thumbnail from the exif header
*
* Note: it is the caller's responsibility to free the memory in "thumbImage" if
* this function return S_OK.
*
* Return Value:
*
*   Status code.
*
\**************************************************************************/

HRESULT
DecodeTiffThumbnail(
    IN BYTE *pApp1Data,         // Base address for APP1 chunk
    IN BYTE *pIFD1,             // Base address for IFD 1
    IN BOOL fBigEndian,         // Flag for endian info
    IN INT nApp1Length,         // Length of APP1 chunk
    OUT IImage **thumbImage     // Result thumbnail image
    )
{
    HRESULT hr = E_FAIL;

    if (*thumbImage)
    {
        WARNING(("DecodeTiffThumbnail called when thumbnail already created"));
        return S_OK;
    }

    UINT16 cEntry = *(UINT16 UNALIGNED*)pIFD1;
    if (fBigEndian)
    {
        cEntry = SWAP_WORD(cEntry);
    }

    // Move the IFD pointer 2 bytes for the "entry field"

    pIFD1 += sizeof(UINT16);

    IFD_TAG UNALIGNED *pTag = (IFD_TAG UNALIGNED*)pIFD1;
    UINT nWidth = 0;            // Thumbnail width
    UINT nHeight = 0;           // Thumbnail height
    UINT16 u16PhtoInterpo = 0;  // Photometric interpretation
    UINT16 u16Compression = 0;  // Compression flag
    UINT16 u16PlanarConfig = 1; // Default planar-config is 1, aka interleaving
    UINT16 u16SubHoriz = 0;     // Horizontal sub-sampling
    UINT16 u16SubVert = 0;      // Vertical sub-sampling
    UINT16 u16YCbCrPos = 0;     // YCbCr position
    float rLumRed = 0.0f;       // YCbCr coefficient for RED
    float rLumGreen = 0.0f;     // YCbCr coefficient for GREEN
    float rLumBlue = 0.0f;      // YCbCr coefficient for BLUE

    float rYLow = 0.0f;         // YCbCr Reference: Y black
    float rYHigh = 0.0f;        // YCbCr Reference: Y white
    float rCbLow = 0.0f;        // YCbCr Reference: Cb black
    float rCbHigh = 0.0f;       // YCbCr Reference: Cr white
    float rCrLow = 0.0f;        // YCbCr Reference: Cr black
    float rCrHigh = 0.0f;       // YCbCr Reference: Cr white

    BYTE *pBits = NULL;         // Bits to thumbnail data

    // Loop through all the TAGs to extract thumbnail related info

    for (INT i = 0; i < cEntry; i++)
    {
        pTag = ((IFD_TAG UNALIGNED*)pIFD1) + i;

        // Check if we have read outside of the APP1 buffer

        if (((BYTE*)pTag + sizeof(IFD_TAG)) > (pApp1Data + nApp1Length))
        {
            WARNING(("DecodeTiffThumbnail read TAG value outside of boundary"));
            return E_FAIL;
        }
        
        IFD_TAG tNewTag;

        if (fBigEndian)
        {
            tNewTag = SwapIFD_TAG(pTag);
            pTag = &tNewTag;
        }

        switch (pTag->wTag)
        {
        case TAG_COMPRESSION:
        case TAG_THUMBNAIL_COMPRESSION:
            if (pTag->wType == TAG_TYPE_SHORT)
            {
                u16Compression = pTag->us;
            }

            break;

        case TAG_IMAGE_WIDTH:
        case TAG_THUMBNAIL_IMAGE_WIDTH:
            if (pTag->wType == TAG_TYPE_LONG)
            {
                nWidth = pTag->ul;
            }
            else if (pTag->wType == TAG_TYPE_SHORT)
            {
                // Note: Image width can be LONG or SHORT

                nWidth = pTag->us;
            }

            break;

        case TAG_IMAGE_HEIGHT:
        case TAG_THUMBNAIL_IMAGE_HEIGHT:
            if (pTag->wType == TAG_TYPE_LONG)
            {
                nHeight = pTag->ul;
            }
            else if (pTag->wType == TAG_TYPE_SHORT)
            {
                // Note: Image height can be LONG or SHORT
                
                nHeight = pTag->us;
            }

            break;

        case TAG_STRIP_OFFSETS:
        case TAG_THUMBNAIL_STRIP_OFFSETS:
        {
            int nOffset = 0;

            if (pTag->wType == TAG_TYPE_LONG)
            {
                nOffset = pTag->dwOffset;
            }
            else if (pTag->wType == TAG_TYPE_SHORT)
            {
                // Note: Strip offset can be LONG or SHORT
                
                nOffset = pTag->us;
            }

            // Double check if the offset is valid

            if ((nOffset > 0) && (nOffset < nApp1Length))
            {
                // Offset for data bits has to be within our memory buffer range

                pBits = pApp1Data + nOffset;
            }
        }
            break;
        
        case TAG_PLANAR_CONFIG:
        case TAG_THUMBNAIL_PLANAR_CONFIG:
            if (pTag->wType == TAG_TYPE_SHORT)
            {
                u16PlanarConfig = pTag->us;
            }

            break;

        case TAG_PHOTOMETRIC_INTERP:
        case TAG_THUMBNAIL_PHOTOMETRIC_INTERP:
            if (pTag->wType == TAG_TYPE_SHORT)
            {
                u16PhtoInterpo = pTag->us;
            }

            break;

        case TAG_YCbCr_COEFFICIENTS:
        case TAG_THUMBNAIL_YCbCr_COEFFICIENTS:
            if ((pTag->wType == TAG_TYPE_RATIONAL) && (pTag->dwCount == 3))
            {
                int UNALIGNED *piValue = (int UNALIGNED*)(pApp1Data +
                                                          pTag->dwOffset);

                rLumRed = GetValueFromRational(piValue, fBigEndian);

                piValue += 2;
                rLumGreen = GetValueFromRational(piValue, fBigEndian);

                piValue += 2;
                rLumBlue = GetValueFromRational(piValue, fBigEndian);                
            }

            break;

        case TAG_YCbCr_SUBSAMPLING:
        case TAG_THUMBNAIL_YCbCr_SUBSAMPLING:
            if ((pTag->wType == TAG_TYPE_SHORT) && (pTag->dwCount == 2))
            {
                u16SubHoriz = (UINT16)(pTag->ul & 0x0000ffff);
                u16SubVert = (UINT16)((pTag->ul & 0x00ff0000) >> 16);
            }

            break;

        case TAG_YCbCr_POSITIONING:
        case TAG_THUMBNAIL_YCbCr_POSITIONING:
            if ((pTag->wType == TAG_TYPE_SHORT) && (pTag->dwCount == 1))
            {
                u16YCbCrPos = pTag->us;
            }

            break;

        case TAG_REF_BLACK_WHITE:
        case TAG_THUMBNAIL_REF_BLACK_WHITE:
            if ((pTag->wType == TAG_TYPE_RATIONAL) && (pTag->dwCount == 6))
            {
                int UNALIGNED *piValue = (int UNALIGNED*)(pApp1Data +
                                                          pTag->dwOffset);                
                
                rYLow = GetValueFromRational(piValue, fBigEndian);

                piValue += 2;
                rYHigh = GetValueFromRational(piValue, fBigEndian);

                piValue += 2;
                rCbLow = GetValueFromRational(piValue, fBigEndian);
                
                piValue += 2;
                rCbHigh = GetValueFromRational(piValue, fBigEndian);
                
                piValue += 2;
                rCrLow = GetValueFromRational(piValue, fBigEndian);
                
                piValue += 2;
                rCrHigh = GetValueFromRational(piValue, fBigEndian);                
            }

            break;

        default:
            break;
        }// switch on ID
    }// Loop through all the TAGs

    // Decode the TIFF image if we have valid bits, width and height. Also, it
    // has to be uncompressed TIFF ((u16Compression == 1)

    GpMemoryBitmap *pBmp = NULL;

    if (pBits && (nWidth != 0) &&(nHeight != 0) && (u16Compression == 1))
    {
        // Create a GpMemoryBitmap to hold the decoded image

        pBmp = new GpMemoryBitmap();
        if (pBmp)
        {
            // Create a memory buffer to hold the result

            hr = pBmp->InitNewBitmap(nWidth, nHeight, PIXFMT_24BPP_RGB);
            if (SUCCEEDED(hr))
            {
                // Lock the memory buffer for write

                BitmapData bmpData;

                hr = pBmp->LockBits(
                    NULL,
                    IMGLOCK_WRITE,
                    PIXFMT_24BPP_RGB,
                    &bmpData
                    );
                
                if (SUCCEEDED(hr))
                {
                    // Get the pointer to the memory buffer so that we can write
                    // to it

                    BYTE *pBuf = (BYTE*)bmpData.Scan0;

                    if (u16PhtoInterpo == 2)
                    {
                        // Uncompressed RGB TIFF. This is the simplest case,
                        // just copy the bits from the source
                        // Before that, we need to be sure we do memory copy
                        // within the buffer range

                        int nBufSize = nWidth * nHeight * 3;

                        if ((pBits + nBufSize) <= (nApp1Length + pApp1Data))
                        {
                            // Convert from BGR to RGB

                            BYTE *pSrc = pBits;
                            BYTE *pDest = pBuf;

                            for (int i = 0; i < (int)nHeight; ++i)
                            {
                                for (int j = 0; j < (int)nWidth; ++j)
                                {
                                    pDest[2] = pSrc[0];
                                    pDest[1] = pSrc[1];
                                    pDest[0] = pSrc[2];

                                    pSrc += 3;
                                    pDest += 3;
                                }
                            }
                        }
                        else
                        {
                            WARNING(("DecodeTiffThumb---Not enough src data"));
                            hr = E_INVALIDARG;
                        }
                    }// RGB TIFF
                    else if ((u16PhtoInterpo == 6) && (u16PlanarConfig == 1))
                    {
                        // YCbCr TIFF thumbnail. Data are stored in chunky
                        // (interleaving) mode

                        int nMemSize = nWidth * nHeight;
                        BYTE *pbY = (BYTE*)GpMalloc(nMemSize);
                        int *pnCb = (int*)GpMalloc(nMemSize * sizeof(int));
                        int *pnCr = (int*)GpMalloc(nMemSize * sizeof(int));

                        if (pbY && pnCb && pnCr)
                        {
                            if (((2 == u16SubHoriz) && (1 == u16SubVert)) ||
                                ((1 == u16SubHoriz) && (2 == u16SubVert)))
                            {
                                // YCbCr 4:2:0 and YCbCr 4:0:2

                                hr = Get420YCbCrChannels(
                                    nWidth,
                                    nHeight,
                                    pBits,
                                    pbY,
                                    pnCb,
                                    pnCr,
                                    rYLow,
                                    rYHigh,
                                    rCbLow,
                                    rCbHigh,
                                    rCrLow,
                                    rCrHigh
                                    );
                            }
                            else if ((2 == u16SubHoriz) && (2 == u16SubVert))
                            {
                                // YCbCr 4:2:2

                                hr = Get422YCbCrChannels(
                                    nWidth,
                                    nHeight,
                                    pBits,
                                    pbY,
                                    pnCb,
                                    pnCr,
                                    rYLow,
                                    rYHigh,
                                    rCbLow,
                                    rCbHigh,
                                    rCrLow,
                                    rCrHigh
                                    );
                            }

                            if (SUCCEEDED(hr))
                            {
                                if ((0 != rLumRed) && (0 != rLumGreen) &&
                                    (0 != rLumBlue))
                                {
                                    hr = YCbCrToRgbWithCoeff(
                                        pbY,        // Pointer to Y data
                                        pnCb,       // Pointer to Cb data
                                        pnCr,       // Pointer to Cr data
                                        rLumRed,    // Red coefficient
                                        rLumGreen,  // Green coefficient
                                        rLumBlue,   // Blue coefficient
                                        pBuf,       // Pointer to output buffer
                                        nHeight,    // Number of rows
                                        nWidth,     // Output width
                                        nWidth * 3  // Stride of output buffer
                                        );
                                }
                                else
                                {
                                    hr = YCbCrToRgbNoCoeff(
                                        pbY,        // Pointer to Y data
                                        pnCb,       // Pointer to Cb data
                                        pnCr,       // Pointer to Cr data
                                        pBuf,       // Pointer to output buffer
                                        nHeight,    // Number of rows
                                        nWidth,     // Output width
                                        nWidth * 3  // Stride of output buffer
                                        );
                                }
                            }
                        }// if (pbY && pnCb && pnCr)
                        else
                        {
                            WARNING(("DecodeTiffThumbnail---Out of memory"));
                            hr = E_OUTOFMEMORY;
                        }

                        if (pbY)
                        {
                            GpFree(pbY);
                        }

                        if (pnCb)
                        {
                            GpFree(pnCb);
                        }

                        if (pnCr)
                        {
                            GpFree(pnCr);
                        }
                    }// YCbCr TIFF case
                    else
                    {
                        // Invalid thumbnail format

                        WARNING(("DecodeTiffThumb--Invalid thumbnail format"));
                        hr = E_FAIL;
                    }

                    if (SUCCEEDED(hr))
                    {
                        // Unlock the bits

                        hr = pBmp->UnlockBits(&bmpData);

                        if (SUCCEEDED(hr))
                        {
                            // Give the thumbnail to caller

                            *thumbImage = pBmp;
                        }
                    }
                }// LockBits() succeed
            }// InitNewBitmap() succeed
        }// If (pBmp)
        else
        {
            WARNING(("DecodeTiffThumbnail--New GpMemoryBitmap() failed"));
            hr = E_OUTOFMEMORY;
        }
    }// If we have a valid thumbnail

    // If this function succeed, then we pass the Thumbnail image (a
    // GpMemoryBitmap object) to the caller in the "thumbImage" object.
    // Otherwise, we have to free it.

    if (FAILED(hr))
    {
        delete pBmp;
    }

    return hr;
}

static CLSID InternalJpegClsID =
{
    0x557cf401,
    0x1a04,
    0x11d3,
    {0x9a, 0x73, 0x00, 0x00, 0xf8, 0x1e, 0xf3, 0x2e}
};

/**************************************************************************\
*
* Function Description:
*
*   This function converts a TIFF thumbnail to a JPEG compressed thumbnail.
*
* Return Value:
*
*   Status code.
*
\**************************************************************************/

HRESULT
ConvertTiffThumbnailToJPEG(
    IN LPBYTE lpApp1Data,               // Base address for APP1 chunk
    IN LPBYTE lpIFD1,                   // Base address for IFD 1
    IN BOOL fBigEndian,                 // Flag for endian info
    IN INT nApp1Length,                 // Length of APP1 chunk
    IN OUT InternalPropertyItem *pTail, // Tail of the property link list
    IN OUT UINT *puiNumOfItems,         // Number of property items in the link
                                        // list
    IN OUT UINT *puiListSize            // Total length of the property value
                                        // buffer
    )
{
    IImage *pThumbImg = NULL;

    // First, get the TIFF thumbnail

    HRESULT hr = DecodeTiffThumbnail(
        lpApp1Data,     // Base address for APP1 chunk
        lpIFD1,         // Base address for IFD 1
        fBigEndian,     // Flag for endian info
        nApp1Length,    // Length of APP1 chunk
        &pThumbImg      // Result thumbnail will be in IImage format
        );
    
    if (SUCCEEDED(hr))
    {
        // Create a memory stream for writing the JPEG

        GpWriteOnlyMemoryStream *pDestStream = new GpWriteOnlyMemoryStream();
        if (pDestStream)
        {
            // Set the buffer size (allocate the memory) based on the size of
            // APP1 chunk for holding the result JPEG file.
            // Note: the size here is not important since
            // GpWriteOnlyMemoryStream() will do realloc if necessary. Here we
            // think set the initial buffer of the size of APP1 header should be
            // sufficient. The reason is that the APP1 header contains original
            // uncompressed TIFF file, plus other information in the APP1
            // header. This should be bigger than the result JPEG compressed
            // thumbnail.

            hr = pDestStream->InitBuffer(nApp1Length);
            if (SUCCEEDED(hr))
            {
                // Since we don't want APP0 in the final JPEG file. Make up a
                // encoder parameter to suppress APP0

                BOOL fSuppressAPP0 = TRUE;
                
                EncoderParameters encoderParams;

                encoderParams.Count = 1;
                encoderParams.Parameter[0].Guid = ENCODER_SUPPRESSAPP0;
                encoderParams.Parameter[0].Type = TAG_TYPE_BYTE;
                encoderParams.Parameter[0].NumberOfValues = 1;
                encoderParams.Parameter[0].Value = (VOID*)&fSuppressAPP0;


                IImageEncoder *pDstJpegEncoder = NULL;
                
                // Save thumbnail to the memory stream
                // Note: this casting might looks dangerous. But it is not since
                // we "know" the real thumbnail data from the decoder is in a
                // GpMemoryBitmap format.

                hr = ((GpMemoryBitmap*)pThumbImg)->SaveToStream(
                    pDestStream,                // Dest stream
                    &InternalJpegClsID,         // JPEG clsID
                    &encoderParams,             // Encoder parameters
                    FALSE,                      // Not a special JPEG
                    &pDstJpegEncoder,           // Encoder pointer
                    NULL                        // No decoder source
                    );
                if (SUCCEEDED(hr))
                {
                    // Release the encoder object

                    pDstJpegEncoder->TerminateEncoder();
                    pDstJpegEncoder->Release();

                    // Get the bits from the stream and set the property

                    BYTE *pRawBits = NULL;
                    UINT nLength = 0;

                    hr = pDestStream->GetBitsPtr(&pRawBits, &nLength);

                    if (SUCCEEDED(hr))
                    {
                        // We are sure we have a thumbnail image, add it to the
                        // property list

                        hr = AddPropertyList(
                            pTail,
                            TAG_THUMBNAIL_DATA,
                            nLength,
                            TAG_TYPE_BYTE,
                            pRawBits
                            );

                        if (SUCCEEDED(hr))
                        {
                            *puiNumOfItems += 1;
                            *puiListSize += nLength;
                        }
                    }
                }// SaveToStream succeed
            }// InitBuffer() succeed

            pDestStream->Release();
        }// Create GpWriteOnlyMemoryStream() succeed

        // Release the source thumbnail image

        pThumbImg->Release();
    }

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   This function converts a GDI+ internal thumbnail TAG ID to thumbnail tag
* ID.
*
* Note: the reason we have to do thumbnail ID to GDI+ internal thumbnail tag ID
* during decoding and restore it when writing out is because the original
* thumbnail IDs are the same as the main image IDs, like ImageWidth, Height etc.
* This causes confusion to the final users who use/set/remove TAG ids. That's
* the reason we have to distinguish them.
*
* Return Value:
*
*   Status code.
*
\**************************************************************************/

void
ThumbTagToMainImgTag(
    PropertyItem *pTag      // Property TAG whos ID needs to be converted
    )
{
    switch (pTag->id)
    {
    case TAG_THUMBNAIL_COMPRESSION:
        pTag->id = TAG_COMPRESSION;
        if (*((UINT16 UNALIGNED*)pTag->value) == 1)
        {
            // GDI+ only writes JPEG compressed thumbnail. So the value should
            // be 6

            *((UINT16 UNALIGNED*)pTag->value) = 6;
        }

        break;

    case TAG_THUMBNAIL_IMAGE_DESCRIPTION:
        pTag->id = TAG_IMAGE_DESCRIPTION;
        break;

    case TAG_THUMBNAIL_EQUIP_MAKE:
        pTag->id = TAG_EQUIP_MAKE;
        break;

    case TAG_THUMBNAIL_EQUIP_MODEL:
        pTag->id = TAG_EQUIP_MODEL;
        break;

    case TAG_THUMBNAIL_ORIENTATION:
        pTag->id = TAG_ORIENTATION;
        break;

    case TAG_THUMBNAIL_RESOLUTION_X:
        pTag->id = TAG_X_RESOLUTION;
        break;

    case TAG_THUMBNAIL_RESOLUTION_Y:
        pTag->id = TAG_Y_RESOLUTION;
        break;

    case TAG_THUMBNAIL_RESOLUTION_UNIT:
        pTag->id = TAG_RESOLUTION_UNIT;
        break;

    case TAG_THUMBNAIL_TRANSFER_FUNCTION:
        pTag->id = TAG_TRANSFER_FUNCTION;
        break;

    case TAG_THUMBNAIL_SOFTWARE_USED:
        pTag->id = TAG_SOFTWARE_USED;
        break;

    case TAG_THUMBNAIL_DATE_TIME:
        pTag->id = TAG_DATE_TIME;
        break;

    case TAG_THUMBNAIL_ARTIST:
        pTag->id = TAG_ARTIST;
        break;

    case TAG_THUMBNAIL_WHITE_POINT:
        pTag->id = TAG_WHITE_POINT;
        break;

    case TAG_THUMBNAIL_PRIMAY_CHROMATICS:
        pTag->id = TAG_PRIMAY_CHROMATICS;
        break;

    case TAG_THUMBNAIL_YCbCr_COEFFICIENTS:
        pTag->id = TAG_YCbCr_COEFFICIENTS;
        break;

    case TAG_THUMBNAIL_YCbCr_SUBSAMPLING:
        pTag->id = TAG_YCbCr_SUBSAMPLING;
        break;

    case TAG_THUMBNAIL_YCbCr_POSITIONING:
        pTag->id = TAG_YCbCr_POSITIONING;
        break;

    case TAG_THUMBNAIL_REF_BLACK_WHITE:
        pTag->id = TAG_REF_BLACK_WHITE;
        break;

    case TAG_THUMBNAIL_COPYRIGHT:
        pTag->id = TAG_COPYRIGHT;
        break;

    default:
        // None thumbnail TAG, do nothing

        break;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   This function walks through the InterOperability IFD and put all the IDs it
* find to the property list.
*
* Return Value:
*
*   Status code.
*
\**************************************************************************/

HRESULT
BuildInterOpPropertyList(
    IN InternalPropertyItem *pTail,     // Tail of property list
    IN OUT UINT *puiListSize,           // Property list size
    UINT *puiNumOfItems,                // Total number of property items
    BYTE *lpBase,                       // Base address of 
    INT count,
    IFD_TAG UNALIGNED *pTag,
    BOOL bBigEndian
    )
{
    HRESULT hr = S_OK;
    UINT uiListSize = *puiListSize;
    UINT uiNumOfItems = *puiNumOfItems;

    if ((pTag->wType != TAG_TYPE_LONG) || (pTag->dwCount != 1))
    {
        WARNING(("BuildInterOpPropertyList: Malformed InterOP ptr"));
        return E_FAIL;
    }

    // Get pointer to InterOP IFD info

    BYTE *lpInterOP = lpBase + pTag->dwOffset;

    // Figure out how many entries there are, and skip to the data section...

    if ((INT)((INT_PTR)lpInterOP + sizeof(WORD) - (INT_PTR)lpBase) > count)
    {
        WARNING(("BuildInterOpPropertyList---Buffer too small"));
        return E_FAIL;
    }

    WORD wNumEntries = *(WORD UNALIGNED*)lpInterOP;
    lpInterOP += sizeof(WORD);
    if (bBigEndian)
    {
        wNumEntries = SWAP_WORD(wNumEntries);
    }

    if ((INT)((INT_PTR)lpInterOP + sizeof(IFD_TAG) * wNumEntries
              -(INT_PTR)lpBase) > count)
    {
        WARNING(("BuildInterOpPropertyList---Buffer too small"));
        return E_FAIL;
    }

    IFD_TAG UNALIGNED *pInterOPTag = (IFD_TAG UNALIGNED*)lpInterOP;
    UINT valueLength;

    for (INT i = 0; i < wNumEntries; ++i)
    {
        IFD_TAG tNewTag;
        pInterOPTag = ((IFD_TAG UNALIGNED*)lpInterOP) + i;
        if (bBigEndian == TRUE)
        {
            tNewTag = SwapIFD_TAG(pInterOPTag);
            pInterOPTag = &tNewTag;

            // Hack here:

            if (pInterOPTag->wType == TAG_TYPE_ASCII)
            {
                pInterOPTag->dwOffset = SWAP_DWORD(pInterOPTag->dwOffset);
            }
        }

        // Change InterOP tags to a identifiable TAGs.

        InterOPTagToGpTag(pInterOPTag);

        // No need to parse these tags. But we can't add any unknown type
        // into the list because we don't know its length

        if (pInterOPTag->wType != TAG_TYPE_UNDEFINED)
        {
            uiNumOfItems++;
            hr = AddPropertyListDirect(pTail, lpBase, pInterOPTag,
                                            bBigEndian, &uiListSize);
        }
        else if (pInterOPTag->dwCount <= 4)
        {
            // According to the spec, an "UNDEFINED" value is an 8-bits type
            // that can take any value depends on the field.
            // In case where the value fits in 4 bytes, the value itself is
            // recorded. That is, "dwOffset" is the value for these "dwCount"
            // fields.

            uiNumOfItems++;
            uiListSize += pInterOPTag->dwCount;
            LPSTR pVal = (LPSTR)&pInterOPTag->dwOffset;

            if (bBigEndian)
            {
                char cTemp0 = pVal[0];
                char cTemp1 = pVal[1];
                pVal[0] = pVal[3];
                pVal[1] = pVal[2];
                pVal[2] = cTemp1;
                pVal[3] = cTemp0;
            }

            hr = AddPropertyList(
                pTail,
                pInterOPTag->wTag,
                pInterOPTag->dwCount,
                pInterOPTag->wType,
                pVal
                );
        }// ( pInterOPTag->dwCount <= 4 )
        else
        {
            uiNumOfItems++;
            uiListSize += pInterOPTag->dwCount;
            PVOID pTemp = lpBase + pInterOPTag->dwOffset;

            hr = AddPropertyList(
                pTail,
                pInterOPTag->wTag,
                pInterOPTag->dwCount,
                TAG_TYPE_UNDEFINED,
                pTemp
                );
        }// ( pInterOPTag->dwCount > 4 )

        if (FAILED(hr))
        {
            WARNING(("BuildInterOpPropertyList---AddPropertyList failed"));
            return hr;
        }
    }// Loop through all the INTEROP IFD entries

    *puiListSize = uiListSize;
    *puiNumOfItems = uiNumOfItems;

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   This function converts the InterOperability TAG ID to GDI+ internal
* InterOperability tag ID.
*
* Note: the reason we have to do InterOperability ID to GDI+ internal tag ID
* during decoding and restore it when writing out is because the original
* InterOperability ID is only 1,2,3,4... This conflicts with tags under GPS
* section.
*
* Return Value:
*
*   Status code.
*
\**************************************************************************/

void
InterOPTagToGpTag(
    IFD_TAG UNALIGNED *pInterOPTag
    )
{
    switch (pInterOPTag->wTag)
    {
    case 1:
        pInterOPTag->wTag = TAG_INTEROP_INDEX;
        break;

    case 2:
        pInterOPTag->wTag = TAG_INTEROP_EXIFR98VER;
        break;
    
    default:
        break;
    }

    return;
}

/**************************************************************************\
*
* Function Description:
*
*   This function restores the proper InterOperability TAG ID from GDI+
* internal InterOperability ID.
*
* Note: the reason we have to do InterOperability ID to GDI+ internal tag ID
* during decoding and restore it when writing out is because the original
* InterOperability ID is only 1,2,3,4... This conflicts with tags under GPS
* section.
*
* Return Value:
*
*   Status code.
*
\**************************************************************************/

void
RestoreInterOPTag(
    IFD_TAG UNALIGNED *pInterOPTag      // Pointer to TAG to be changed
    )
{
    switch (pInterOPTag->wTag)
    {
    case TAG_INTEROP_INDEX:
        pInterOPTag->wTag = 1;
        break;

    case TAG_INTEROP_EXIFR98VER:
        pInterOPTag->wTag = 2;
        break;
    
    default:
        break;
    }

    return;
}

/**************************************************************************\
*
* Function Description:
*
*   This function returns TRUE if a given property ID belongs to
* InterOperability IFD. Otherwise return FALSE.
*
* Return Value:
*
*   Status code.
*
\**************************************************************************/

BOOL
IsInInterOPIFDSection(
    PROPID  id                          // ID of TAG to be verified
    )
{
    switch (id)
    {
    case TAG_INTEROP_INDEX:
    case TAG_INTEROP_EXIFR98VER:
        return TRUE;

    default:
        return FALSE;
    }
}

/**************************************************************************\
*
* Function Description:
*
* This function writes an InterOperability IFD tags inside Exif IFD
*
* Return Value:
*
*   Status code.
*
\**************************************************************************/

HRESULT
WriteInterOPIFD(
    IN OUT BYTE *pbMarkerBuffer,      // Points to the beginning of APP1 buffer
    IN PropertyItem *pPropertyList,   // The list of input property
    IN UINT cPropertyItems,           // Number of property items in the list
    IN UINT cInterOPTags,             // Number of InterOperability tags
    IN OUT UINT *puiTotalBytesWritten // Counter for total bytes written so far
    )
{
    HRESULT hr = S_OK;

    // Fill in the number of entry field, 2 bytes

    UINT16 UNALIGNED *pui16NumEntry = (UINT16 UNALIGNED*)(pbMarkerBuffer +
                                                        *puiTotalBytesWritten);
    *pui16NumEntry = (UINT16)cInterOPTags;

    *puiTotalBytesWritten += 2;

    UINT uiInterOPSectionLength = sizeof(IFD_TAG) * cInterOPTags;

    IFD_TAG *pTagBuf = (IFD_TAG*)GpMalloc(uiInterOPSectionLength);

    if (pTagBuf == NULL)
    {
        WARNING(("EXIF: WriteInterOPIFD failed---Out of memory"));
        return E_OUTOFMEMORY;
    }

    // Remember where to write InterOP IFD, (pbInterOPIFDOffset). We can't write
    // all the TAGs now since we can't fill in all the values at this moment

    BYTE *pbInterOPIFDOffset = pbMarkerBuffer + (*puiTotalBytesWritten);

    // We need to count "uiInterOPSectionLength" bytes as written. This
    // makes it easier for counting the offset below.
    // Here "+4" is for 4 bytes for writing next IFD offset.

    *puiTotalBytesWritten += (uiInterOPSectionLength + 4);
    MakeOffsetEven(*puiTotalBytesWritten);

    // Figure out the offset for InterOP IFD value section

    BYTE *pbCurrent = pbMarkerBuffer + (*puiTotalBytesWritten);
    PropertyItem *pItem = pPropertyList;
    IFD_TAG *pCurrentTag = NULL;
    UINT cInterOPTagsWritten = 0;// Num of InterOP tags have been written so far

    for (int i = 0; i < (INT)cPropertyItems; ++i)
    {
        // Only write InterOP specific TAGs

        if (IsInInterOPIFDSection(pItem->id) == TRUE)
        {
            // Fill out a new TAG structure

            pCurrentTag = pTagBuf + cInterOPTagsWritten;

            WriteATag(
                pbMarkerBuffer,
                pCurrentTag,
                pItem,
                &pbCurrent,
                puiTotalBytesWritten
                );

            RestoreInterOPTag(pCurrentTag);

            cInterOPTagsWritten++;
        }

        // Move onto next PropertyItem

        pItem++;
    }// Loop through all the property items to write EXIF tags

    // After the above loop, we have fill all the fields in all the InterOP TAG
    // structure. Write out all the directory entries now

    GpMemcpy(pbInterOPIFDOffset, (BYTE*)pTagBuf, uiInterOPSectionLength);

    // Add a NULL at the end to terminate the InterOP offset.

    *((UINT32 UNALIGNED*)(pbInterOPIFDOffset + uiInterOPSectionLength)) = NULL;

    GpFree(pTagBuf);

    return hr;
}

//
// Convert some rows of samples to the output colorspace.
//
// Note that we change from noninterleaved, one-plane-per-component format
// to interleaved-pixel format.  The output buffer is therefore three times
// as wide as the input buffer.
// A starting row offset is provided only for the input buffer.  The caller
// can easily adjust the passed output_buf value to accommodate any row
// offset required on that side.
//

const int c_ScaleBits = 16;
#define ONE_HALF	((INT32) 1 << (c_ScaleBits - 1))
#define FIX(x)		((INT32) ((x) * (1L<<c_ScaleBits) + 0.5))
#define SHIFT_TEMPS	INT32 shift_temp;
#define RIGHT_SHIFT(x,shft)  \
	((shift_temp = (x)) < 0 ? \
	 (shift_temp >> (shft)) | ((~((INT32) 0)) << (32-(shft))) : \
	 (shift_temp >> (shft)))
#define RGB_RED		2	/* Offset of Red in an RGB scanline element */
#define RGB_GREEN	1	/* Offset of Green */
#define RGB_BLUE	0	/* Offset of Blue */

/**************************************************************************\
*
* Function Description:
*
*   Given Y, Cb, Cr bits stream, this function converts a YCbCr image into RGB
* image.
*
* The conversion equations to be implemented are therefore
*	R = Y + 1.40200 * Cr
*	G = Y - 0.34414 * Cb - 0.71414 * Cr
*	B = Y + 1.77200 * Cb
*
* Return Value:
*
*   Status code.
*
\**************************************************************************/

HRESULT
YCbCrToRgbNoCoeff(
    IN BYTE *pbY,              // Pointer to Y data
    IN int *pnCb,              // Pointer to Cb data
    IN int *pnCr,              // Pointer to Cr data
    OUT BYTE *pbDestBuf,       // Pointer to output buffer
    IN int nRows,              // Number of rows
    IN int nCols,              // Number of columns
    IN INT nOutputStride       // Stride of output buffer
    )
{
    HRESULT hr = S_OK;

    if (pbY && pnCb && pnCr && pbDestBuf && (nRows > 0) && (nCols > 0))
    {
        int *pnCrRTable = (int*)GpMalloc(256 * sizeof(int));
        int *pnCbBTable = (int*)GpMalloc(256 * sizeof(int));
        INT32 *pnCrGTable = (INT32*)GpMalloc(256 * sizeof(INT32));
        INT32 *pnCbGTable = (INT32*)GpMalloc(256 * sizeof(INT32));
        SHIFT_TEMPS

        if (pnCrRTable && pnCbBTable && pnCrGTable && pnCbGTable)
        {
            INT32 x = -128;

            // Build the YCbCr to RGB convert table

            for (int i = 0; i <= 255; i++)
            {
                // "i" is the actual input pixel value, in the range [0, 255]
                // The Cb or Cr value we are thinking of is x = i - 128
                // Cr=>R value is nearest int to 1.40200 * x

                pnCrRTable[i] = (int)RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF,
                                                 c_ScaleBits);

                // Cb=>B value is nearest int to 1.77200 * x

                pnCbBTable[i] = (int)RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF,
                                                 c_ScaleBits);

                // Cr=>G value is scaled-up -0.71414 * x

                pnCrGTable[i] = (- FIX(0.71414)) * x;

                // Cb=>G value is scaled-up -0.34414 * x
                // We also add in ONE_HALF so that need not do it in inner loop

                pnCbGTable[i] = (- FIX(0.34414)) * x + ONE_HALF;

                x++;
            }
        }
        else
        {
            WARNING(("YCbCrToRgbNoCoeff---Out of memory"));
            hr = E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hr))
        {
            // YCbCr to RGB Color mapping

            BYTE *pbOutputRow = pbDestBuf;

            for (int i = 0; i < nRows; ++i)
            {
                BYTE *pbOutput = pbOutputRow;

                for (int j = 0; j < nCols; ++j)
                {
                    int nY = (int)(*pbY++);
                    int nCb = *pnCb++;
                    int nCr = *pnCr++;

                    pbOutput[RGB_RED] = ByteSaturate(nY + pnCrRTable[nCr]);
                    pbOutput[RGB_GREEN] = ByteSaturate(nY +
                        ((int)RIGHT_SHIFT(pnCbGTable[nCb] + pnCrGTable[nCr],
                                          c_ScaleBits)));
                    pbOutput[RGB_BLUE] = ByteSaturate(nY + pnCbBTable[nCb]);

                    pbOutput += 3;    // Move onto next pixel. 
                }

                pbOutputRow += nOutputStride;
            }
        }

        if (pnCrRTable)
        {
            GpFree(pnCrRTable);
        }

        if (pnCbBTable)
        {
            GpFree(pnCbBTable);
        }

        if (pnCrGTable)
        {
            GpFree(pnCrGTable);
        }

        if (pnCbGTable)
        {
            GpFree(pnCbGTable);
        }
    }
    else
    {
        WARNING(("YCbCrToRgbNoCoeff---Invalid input parameters"));
        hr = E_INVALIDARG;
    }

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   Given Y, Cb, Cr bits stream and YCbCr coefficients, this function converts
* a YCbCr image into RGB image.
*
*   Formula used in this function is from CCIR Recommendation 601-1, "Encoding
* Parameters of Digital Television for Studios".
*
*   R = Cr * (2 - 2 * LumaRed) + Y
*   G = (Y - LumaBlue * B - LumaRed * R) / LumaGreen
*   B = Cb * (2 - 2 * LumaBlue) + Y
*
* Return Value:
*
*   Status code.
*
\**************************************************************************/

HRESULT
YCbCrToRgbWithCoeff(
    IN BYTE *pbY,          // Pointer to Y data
    IN int *pnCb,          // Pointer to Cb data
    IN int *pnCr,          // Pointer to Cr data
    IN float rLumRed,      // Red coefficient
    IN float rLumGreen,    // Green coefficient
    IN float rLumBlue,     // Blue coefficient
    OUT BYTE *pbDestBuf,   // Pointer to output buffer
    IN int nRows,          // Number of rows
    IN int nCols,          // Number of columns
    IN INT nOutputStride   // Stride of output buffer
    )
{
    HRESULT hr = E_INVALIDARG;

    if (pbY && pnCb && pnCr && pbDestBuf && (rLumGreen != 0.0f))
    {
        BYTE *pbOutputRow = pbDestBuf;

        for (int i = 0; i < nRows; ++i)
        {
            BYTE *pbOutput = pbOutputRow;

            for (int j = 0; j < nCols; ++j)
            {
                int nY = (int)(*pbY++);
                int nCb = *pnCb++;
                int nCr = *pnCr++;

                int nRed = GpRound((float)nY + (float)nCr * 2.0f *
                                   (1.0f - rLumRed));
                int nBlue = GpRound((float)nY + (float)nCb * 2.0f *
                                    (1.0f - rLumBlue));

                pbOutput[RGB_GREEN] = ByteSaturate(GpRound(((float)nY -
                                    rLumBlue * nBlue -
                                    rLumRed * nRed)/ rLumGreen));
                pbOutput[RGB_RED] = ByteSaturate(nRed);
                pbOutput[RGB_BLUE] = ByteSaturate(nBlue);
                pbOutput += 3;    // Move onto next pixel. 
            }

            pbOutputRow += nOutputStride;
        }

        hr = S_OK;
    }

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   Convert the source image bits from YCbCr420 or YCbCr402 format to 3 separate
* channels: Y, Cb, Cr. The reference black and white values for each channel are
* passed in.
*
* The original data is stored as Y00, Y01, Cb0, Cr0, Y02, Y03, Cb1, Cr1......
*
* YCbCr 420 means that image width of the chroma image is half the image width
* of the associated luma image.
*
* YCbCr 402 means that image height of the chroma image is half the image height
* of the associated luma image.
*
* Note: I couldn't find any document regarding how the data is stored for
* YCbCr420 and 402. Exif spec V2.1 has very limited information about YCbCr420.
* It also contains mistakes in the diagram. I have done some reverse engineering
* based on exisitng images from digital cameras and I found that the data for
* these two formats are stored exactly the same. The reason is that the input is
* just a bits stream. It stores 2 Y values then 1 Cb and 1 Cr values, no matter
* chroma width or height is the half of the luma image.
*
* Note: ISSUE-2002/01/30--minliu:
* It will be much faster to build a lookup table based on input Black and
* white values for each channel, instead of calculating scale and offset for
* each pixel. Should be implemented in V2.
*
* Return Value:
*
*   Status code.
*
\**************************************************************************/

HRESULT
Get420YCbCrChannels(
    IN int nWidth,              // Image width
    IN int nHeight,             // Image height
    IN BYTE *pBits,             // Poinetr to source data bits in YCbCr format
    OUT BYTE *pbY,              // Output buffer for Y value
    OUT int *pnCb,              // Output buffer for Cb value
    OUT int *pnCr,              // Output buffer for Cr value
    IN float rYLow,             // Black reference value for Y channel
    IN float rYHigh,            // White reference value for Y channel
    IN float rCbLow,            // Black reference value for Cb channel
    IN float rCbHigh,           // White reference value for Cb channel
    IN float rCrLow,            // Black reference value for Cr channel
    IN float rCrHigh            // White reference value for Cr channel
    )
{
    if ((nWidth <=0) || (nHeight <= 0) || (NULL == pBits) || (NULL == pbY) ||
        (NULL == pnCb) || (NULL == pnCr) ||
        (rYLow > rYHigh) || (rCbLow > rCbHigh) || (rCrLow > rCrHigh))
    {
        WARNING(("Get420YCbCrChannels---Invalid input parameter"));
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    float rYScale =  1.0f;
    float rCbScale = 1.0f;
    float rCrScale = 1.0f;
    
    if (rYHigh != rYLow)
    {
        rYScale =  255.0f / (rYHigh - rYLow);
    }

    if (rCbHigh != rCbLow)
    {
        rCbScale = 127.0f / (rCbHigh - rCbLow);
    }

    if (rCrHigh != rCrLow)
    {
        rCrScale = 127.0f / (rCrHigh - rCrLow);
    }

    // Loop through the input data to extract Y, Cb, Cr values.
    // ISSUE-2002/01/30--minliu: Read the "Notes" above for future improvement

    for (int i = 0; i < nHeight; i++)
    {
        for (int j = 0; j < nWidth / 2; j++)
        {
            *pbY++ = ByteSaturate(GpRound((float(*pBits++) - rYLow) * rYScale));
            *pbY++ = ByteSaturate(GpRound((float(*pBits++) - rYLow) * rYScale));

            // Let two neighboring Cb/Cr has the same value

            int nCb = GpRound((float(*pBits++) - rCbLow) * rCbScale);
            *pnCb++ = nCb;
            *pnCb++ = nCb;

            int nCr = GpRound((float(*pBits++) - rCrLow) * rCrScale);
            *pnCr++ = nCr;
            *pnCr++ = nCr;
        }
    }

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   Convert the source image bits from YCbCr422 format to 3 separate channels:
* Y, Cb, Cr. The reference black and white values for each channel are passed in
* The original data is stored as Y00, Y01, Y10, Y11, Cb0, Cr0, Y02, Y03, Y12,
* Y13, Cb1, Cr1
*
* YCbCr 422 means that image width and height of the chroma image is half the
* image width and height of the associated luma image.
*
* Note: ISSUE-2002/01/30--minliu:
* It will be much faster to build a lookup table based on input Black and
* white values for each channel, instead of calculating scale and offset for
* each pixel. Should be implemented in V2.
*
* Return Value:
*
*   Status code.
*
\**************************************************************************/

HRESULT
Get422YCbCrChannels(
    IN int nWidth,          // Image width
    IN int nHeight,         // Image height
    IN BYTE *pBits,         // Poinetr to source data bits in YCbCr format
    OUT BYTE *pbY,          // Output buffer for Y value
    OUT int *pnCb,          // Output buffer for Cb value
    OUT int *pnCr,          // Output buffer for Cr value
    IN float rYLow,         // Black reference value for Y channel
    IN float rYHigh,        // White reference value for Y channel
    IN float rCbLow,        // Black reference value for Cb channel
    IN float rCbHigh,       // White reference value for Cb channel
    IN float rCrLow,        // Black reference value for Cr channel
    IN float rCrHigh        // White reference value for Cr channel
    )
{
    if ((nWidth <=0) || (nHeight <= 0) || (NULL == pBits) || (NULL == pbY) ||
        (NULL == pnCb) || (NULL == pnCr) ||
        (rYLow > rYHigh) || (rCbLow > rCbHigh) || (rCrLow > rCrHigh))
    {
        WARNING(("Get422YCbCrChannels---Invalid input parameter"));
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    float rYScale = 1.0f;
    float rCbScale = 1.0f;
    float rCrScale = 1.0f;
    
    if (rYHigh != rYLow)
    {
        rYScale =  255.0f / (rYHigh - rYLow);
    }

    if (rCbHigh != rCbLow)
    {
        rCbScale = 127.0f / (rCbHigh - rCbLow);
    }

    if (rCrHigh != rCrLow)
    {
        rCrScale = 127.0f / (rCrHigh - rCrLow);
    }

    BYTE *pbYRow = pbY;
    int *pnCbRow = pnCb;
    int *pnCrRow = pnCr;
    
    int nGap = 2 * nWidth;

    // Loop through the input data to extract Y, Cb, Cr values.
    // ISSUE-2002/01/30--minliu: Read the "Notes" above for future improvement

    for (int i = 0; i < nHeight / 2; i++)
    {
        BYTE *pbOddYRow = pbYRow;           // Odd row pointer in output buffer
        BYTE *pbEvenYRow = pbYRow + nWidth; // Even row pointer in output buffer
        int *pnOddCbRow = pnCbRow;
        int *pnEvenCbRow = pnCbRow + nWidth;
        int *pnOddCrRow = pnCrRow;
        int *pnEvenCrRow = pnCrRow + nWidth;
        
        for (int j = 0; j < nWidth / 2; j++)
        {
            // Read 4 Y values first

            *pbOddYRow++ = ByteSaturate(GpRound((float(*pBits++) - rYLow) *
                                                rYScale));
            *pbOddYRow++ = ByteSaturate(GpRound((float(*pBits++) - rYLow) *
                                                rYScale));
            *pbEvenYRow++ = ByteSaturate(GpRound((float(*pBits++) - rYLow) *
                                                 rYScale));
            *pbEvenYRow++ = ByteSaturate(GpRound((float(*pBits++) - rYLow) *
                                                 rYScale));

            // Let two neighboring columns and two neighboring rows Cb/Cr all
            // have the same value

            int nCb = GpRound((float(*pBits++) - rCbLow) * rCbScale);
            *pnOddCbRow++ = nCb;
            *pnOddCbRow++ = nCb;            
            *pnEvenCbRow++ = nCb;
            *pnEvenCbRow++ = nCb;
            
            int nCr = GpRound((float(*pBits++) - rCrLow) * rCrScale);
            *pnOddCrRow++ = nCr;
            *pnOddCrRow++ = nCr;
            *pnEvenCrRow++ = nCr;
            *pnEvenCrRow++ = nCr;
        }
        
        pbYRow += nGap;         // Move up two rows
        pnCbRow += nGap;        // Move up two rows
        pnCrRow += nGap;        // Move up two rows
    }

    return hr;
}

/**************************************************************************\
*
* Function Description:
*
*   Given an GpMemoryBitmap object (mainly for thumbnail images), this function
* converts it to a memory stream in JPEG format. Then adds it to the property
* list. The size of the JPEG stream is returned to caller through
* "puThumbLength".
*
* Return Value:
*
*   Status code.
*
\**************************************************************************/

HRESULT
AddThumbToPropertyList(
    IN InternalPropertyItem* pTail, // Tail to property item list
    IN GpMemoryBitmap *pThumbImg,   // Thumbnail image
    IN INT nSize,                   // Minimum size to hold the dest JPEG image
    OUT UINT *puThumbLength         // Total bytes of thumbanil data
    )
{
    if ((NULL == puThumbLength) || (nSize <= 0) || (NULL == pThumbImg) ||
        (NULL == pTail))
    {
        WARNING(("AddThumbToPropertyList---Invalid input parameter"));
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    // Create a memory stream for holding the JPEG

    GpWriteOnlyMemoryStream *pDestStream = new GpWriteOnlyMemoryStream();
    if (pDestStream)
    {
        // Set initial memory buffer size for the image
        // Note: this size might be too small for the final JPEG image. But the
        // GpWriteOnlyMemoryStream object will expand the memory buffer when
        // needed

        hr = pDestStream->InitBuffer((UINT)nSize);
        if (SUCCEEDED(hr))
        {
            // Since we don't want APP0 in the final JPEG file. Make up an
            // encoder parameter to suppress APP0

            BOOL fSuppressAPP0 = TRUE;

            EncoderParameters encoderParams;

            encoderParams.Count = 1;
            encoderParams.Parameter[0].Guid = ENCODER_SUPPRESSAPP0;
            encoderParams.Parameter[0].Type = TAG_TYPE_BYTE;
            encoderParams.Parameter[0].NumberOfValues = 1;
            encoderParams.Parameter[0].Value = (VOID*)&fSuppressAPP0;

            // Save thumbnail to the memory stream

            IImageEncoder *pDstJpegEncoder = NULL;

            hr = ((GpMemoryBitmap*)pThumbImg)->SaveToStream(
                pDestStream,                // Dest stream
                &InternalJpegClsID,         // JPEG clsID
                &encoderParams,             // Encoder parameters
                FALSE,                      // Not a special JPEG
                &pDstJpegEncoder,           // Encoder pointer
                NULL                        // No decoder source
                );

            if (SUCCEEDED(hr))
            {
                // We have got the JPEG data in pDestStream now. Terminate the
                // encoder object

                ASSERT(pDstJpegEncoder != NULL);
                pDstJpegEncoder->TerminateEncoder();
                pDstJpegEncoder->Release();

                // Get the bits from the stream and set the property
                // Note: GetBitsPtr() just gives us a pointer to the memory
                // stream. This function here doesn't own the memory. The memory
                // will be released when pDestStream->Release() is called

                BYTE *pThumbBits = NULL;
                UINT uThumbLength = 0;
                
                hr = pDestStream->GetBitsPtr(&pThumbBits, &uThumbLength);

                if (SUCCEEDED(hr))
                {
                    // Add thumbnail data to property list
                    // Note: AddPropertyList() will make a copy of the data

                    hr = AddPropertyList(
                        pTail,
                        TAG_THUMBNAIL_DATA,
                        uThumbLength,
                        TAG_TYPE_BYTE,
                        (void*)pThumbBits
                        );

                    if (SUCCEEDED(hr))
                    {
                        // Tell the caller the size of thumbnail data we saved

                        *puThumbLength = uThumbLength;
                    }
                }
            }// SaveToStream succeed
        }// InitBuffer() succeed

        pDestStream->Release();
    }// Create GpWriteOnlyMemoryStream() succeed
    else
    {
        WARNING(("AddThumbToPropertyList--GpWriteOnlyMemoryStream() failed"));
        hr = E_OUTOFMEMORY;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\jpeg\appproc.hpp ===
#ifndef _APPPROC_HPP_
#define _APPPROC_HPP_

extern "C" {
    #include "jpeglib.h"
};

typedef struct
{
    WORD    wTag;
    WORD    wType;
    DWORD   dwCount;        // Number of "wTypes"
    union
    {
        DWORD   dwOffset;   // either value (if 4-bytes or less) or address of
                            // value
        USHORT  us;
        ULONG   ul;
        BYTE    b;
        LONG    l;
    };

} IFD_TAG;

#define SWAP_DWORD(_x) ((((_x) & 0xff) << 24)|((((_x)>>8) & 0xff) << 16)|((((_x)>>16) & 0xff) << 8)|((((_x)>>24) & 0xff) << 0))
#define SWAP_WORD(_x) ((((_x) & 0xff) << 8)|((((_x)>>8) & 0xff) << 0))

// Get thumbnail from APP1 header

HRESULT
GetAPP1Thumbnail(OUT IImage** thumbImage,
                 IN PVOID     APP1_marker,
                 IN UINT16    APP1_length);

// Get thumbnail from APP13 header

HRESULT
GetAPP13Thumbnail(OUT IImage**  thumbImage,
                  IN  PVOID     APP13_marker,
                  IN  UINT16    APP13_length);

// Doing APP1 header reansformation

HRESULT
TransformApp1(BYTE*     pApp1Data,
              UINT16    uiApp1Length,
              UINT      uiXForm,
              UINT      uiNewWidth,
              UINT      uiNewHeight);

// Doing APP13 header reansformation

HRESULT
TransformApp13(BYTE*    pApp1Data,
               UINT16   uiApp1Length);

HRESULT
BuildApp1PropertyList(InternalPropertyItem*  pTail,
                      UINT*           puiListSize,
                      UINT*           puiNumOfItems,
                      LPBYTE          lpStart,
                      UINT16          uiApp1Length);

HRESULT
BuildApp2PropertyList(InternalPropertyItem*  pTail,
                      UINT*           puiListSize,
                      UINT*           puiNumOfItems,
                      LPBYTE          lpStart,
                      UINT16          uiApp2Length);

HRESULT
BuildApp13PropertyList(InternalPropertyItem*  pTail,
                       UINT*           puiListSize,
                       UINT*           puiNumOfItems,
                       LPBYTE          lpStart,
                       UINT16          uiApp13Length);

HRESULT
ReadApp1HeaderInfo(j_decompress_ptr    cinfo,
                   BYTE*               pApp1Data,
                   UINT16              uiApp1Length);

HRESULT
ReadApp13HeaderInfo(j_decompress_ptr    cinfo,
                    BYTE*               pApp13Data,
                    UINT16              uiApp13Length);

HRESULT
CreateAPP1Marker(IN PropertyItem *pItemBuffer,
                 IN UINT uiNumOfPropertyItems,
                 IN BYTE *pMarkerBuffer,
                 OUT UINT* puiCurrentLength,
                 IN UINT uiTransformation);

void
SortTags(PropertyItem *pItemBuffer, UINT cPropertyItems);

void
SwapIDIfNeeded(PropertyItem *pItem);

BOOL
IsInLargeSection(PROPID id);

BOOL
IsInExifIFDSection(PROPID id);

BOOL
IsInGpsIFDSection(PROPID id);

BOOL
IsInFilterOutSection(PROPID id);

BOOL
IsInThumbNailSection(PROPID id);

BOOL
IsInInterOPIFDSection(PROPID id);

HRESULT
WriteATag(
    BYTE *pMarkerBuffer,
    IFD_TAG *pCurrentTag,
    PropertyItem *pTempItem,
    BYTE **ppbCurrent,
    UINT *puiTotalBytesWritten);

HRESULT
WriteThumbnailTags(
    PropertyItem *pItemBuffer,
    BYTE *pMarkerBuffer,
    IFD_TAG *pTags,
    UINT uiNumOfPropertyItems,
    UINT *puiNumOfThumbnailTagsWritten,
    UINT *puiTotalBytesWritten,
    BOOL fWriteSmallTag);

HRESULT
WriteExifIFD(
    BYTE *pMarkerBuffer,
    PropertyItem *pItemBuffer,
    UINT uiNumOfPropertyItems,
    UINT uiNumOfExifTags,
    UINT uiNumOfInterOPTags,
    UINT *puiTotalBytesWritten);

HRESULT
WriteGpsIFD(
    BYTE *pMarkerBuffer,
    PropertyItem *pItemBuffer,
    UINT uiNumOfPropertyItems,
    UINT uiNumOfGpsTags,
    UINT *puiTotalBytesWritten);

HRESULT
Write1stIFD(
    BYTE *pMarkerBuffer,
    PropertyItem *pItemBuffer,
    UINT uiNumOfPropertyItems,
    ULONG uiNumOfThumbnailTags,
    ULONG ulThumbnailLength,
    BYTE *pbThumbBits,
    BYTE **ppbIFDOffset,
    UINT *puiTotalBytesWritten);

HRESULT
WriteInterOPIFD(
    PBYTE pMarkerBuffer,
    PropertyItem *pItemBuffer,
    UINT uiNumOfPropertyItems,
    UINT uiNumOfInterOPTags,
    UINT *puiTotalBytesWritten);

HRESULT
DecodeTiffThumbnail(
    BYTE *pApp1Data,
    BYTE *pIFD1,
    BOOL fBigEndian,
    INT nApp1Length,
    OUT IImage **thumbImage);

HRESULT
ConvertTiffThumbnailToJPEG(
    LPBYTE lpApp1Data,
    LPBYTE lpIFD1,
    BOOL fBigEndian,
    INT nApp1Length,
    InternalPropertyItem *pTail,
    UINT *puiNumOfItems,
    UINT *puiListSize);

void
ThumbTagToMainImgTag(PropertyItem *pTag);

HRESULT
BuildInterOpPropertyList(
    InternalPropertyItem *pTail,
    UINT *puiListSize,
    UINT *puiNumOfItems,
    BYTE *lpBase,
    INT count,
    IFD_TAG UNALIGNED *pTag,
    BOOL bBigEndian);

void
InterOPTagToGpTag(IFD_TAG UNALIGNED *pInterOPTag);

void
RestoreInterOPTag(IFD_TAG UNALIGNED *pInterOPTag);

inline
void MakeOffsetEven(UINT& nOffset)
{
    if (nOffset % 2)
    {
        nOffset++;
    }
}

HRESULT
Get420YCbCrChannels(
    IN int nWidth,
    IN int nHeight,
    IN BYTE *pBits,
    OUT BYTE *pbY,
    OUT int *pnCb,
    OUT int *pnCr,
    IN float rYLow,
    IN float rYHigh,
    IN float rCbLow,
    IN float rCbHigh,
    IN float rCrLow,
    IN float rCrHigh
    );

HRESULT
Get422YCbCrChannels(
    IN int nWidth,
    IN int nHeight,
    IN BYTE *pBits,
    OUT BYTE *pbY,
    OUT int *pnCb,
    OUT int *pnCr,
    IN float rYLow,
    IN float rYHigh,
    IN float rCbLow,
    IN float rCbHigh,
    IN float rCrLow,
    IN float rCrHigh
    );

HRESULT
YCbCrToRgbNoCoeff(
    BYTE *pbY,
    int *pnCb,
    int *pnCr,
    BYTE *pbDestBuf,
    int nRows,
    int nCols,
    INT nOutputStride
    );

HRESULT
YCbCrToRgbWithCoeff(
    BYTE *pbY,
    int *pnCb,
    int *pnCr,
    float rLumRed,
    float rLumGreen,
    float rLumBlue,
    BYTE *pbDestBuf,
    int nRows,
    int nCols,
    int nOutputStride);

inline
void
CopyPropertyItem(
    PropertyItem *pSrc,
    PropertyItem *pDst
    )
{
    pDst->id = pSrc->id;
    pDst->length = pSrc->length;
    pDst->type = pSrc->type;
    pDst->value = pSrc->value;
}

inline BYTE
ByteSaturate(
    INT i
    )
{
    if (i > 255)
    {
        i = 255;
    }
    else if (i < 0)
    {
        i = 0;
    }

    return (BYTE)i;
}

// This function retrives a rational value from the input buffer and return the
// the final value. It also does the endian swap if necessary.
// Note: this is an internal service function. So the caller should be sure
// to pass valid pointers in. This saves some return code checking

inline float
GetValueFromRational(
    int UNALIGNED *piValue,     // int pointer to source data
    BOOL fBigEndian             // Flag for endian value
    )
{
    INT32 nNum = *piValue;
    INT32 nDen = *(piValue + 1);

    if (fBigEndian)
    {
        nNum = SWAP_DWORD(nNum);
        nDen = SWAP_DWORD(nDen);
    }

    float rRetValue = 0.0f;

    if (0 != nDen)
    {
        rRetValue = (float)nNum / (float)nDen;
    }

    return rRetValue;
}

HRESULT
DoSwapRandB(IImage** ppSrcImage);

HRESULT
DecodeApp13Thumbnail(
    IImage** pThumbImage,
    PVOID pStart,
    INT iNumOfBytes,
    BOOL bNeedConvert);

WCHAR*
ResUnits(int iType);

WCHAR*
LengthUnits(int iType);

WCHAR*
Shape(int i);

HRESULT
AddThumbToPropertyList(
    IN InternalPropertyItem* pTail,
    IN GpMemoryBitmap *pThumbImg,
    IN INT nSize,
    OUT UINT *puThumbLength);

HRESULT
AddPS4ThumbnailToPropertyList(
    InternalPropertyItem* pTail,
    PVOID pStart,
    INT cBytes,
    OUT UINT *puThumbLength);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\jpeg\jerror.c ===
/*
 * jerror.c
 *
 * Version which doesn't use CRT functions - agodfrey 8/9/99
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains simple error-reporting and trace-message routines.
 * These are suitable for Unix-like systems and others where writing to
 * stderr is the right thing to do.  Many applications will want to replace
 * some or all of these routines.
 *
 * These routines are used by both the compression and decompression code.
 */

/* this is not a core library module, so it doesn't define JPEG_INTERNALS */
#include "jinclude.h"
#include "jpeglib.h"
#include "jversion.h"
#include "jerror.h"

#ifndef EXIT_FAILURE		/* define exit() codes if not provided */
#define EXIT_FAILURE  1
#endif


/*
 * Create the message string table.
 * We do this from the master message list in jerror.h by re-reading
 * jerror.h with a suitable definition for macro JMESSAGE.
 * The message table is made an external symbol just in case any applications
 * want to refer to it directly.
 */

#ifdef NEED_SHORT_EXTERNAL_NAMES
#define jpeg_std_message_table	jMsgTable
#endif

#define JMESSAGE(code,string)	string ,

const char * const jpeg_std_message_table[] = {
#include "jerror.h"
  NULL
};


/*
 * Error exit handler: must not return to caller.
 *
 * Applications may override this if they want to get control back after
 * an error.  Typically one would longjmp somewhere instead of exiting.
 * The setjmp buffer can be made a private field within an expanded error
 * handler object.  Note that the info needed to generate an error message
 * is stored in the error object, so you can generate the message now or
 * later, at your convenience.
 * You should make sure that the JPEG object is cleaned up (with jpeg_abort
 * or jpeg_destroy) at some point.
 */

METHODDEF(void)
error_exit (j_common_ptr cinfo)
{
  /* Always display the message */
  (*cinfo->err->output_message) (cinfo);

  /* Let the memory manager delete any temp files before we die */
  jpeg_destroy(cinfo);

  // exit(EXIT_FAILURE);
}


/*
 * Actual output of an error or trace message.
 * Applications may override this method to send JPEG messages somewhere
 * other than stderr.
 */

METHODDEF(void)
output_message (j_common_ptr cinfo)
{
  char buffer[JMSG_LENGTH_MAX];

  /* Create the message */
  (*cinfo->err->format_message) (cinfo, buffer);

  /* Send it to stderr, adding a newline */
  // fprintf(stderr, "%s\n", buffer);
}


/*
 * Decide whether to emit a trace or warning message.
 * msg_level is one of:
 *   -1: recoverable corrupt-data warning, may want to abort.
 *    0: important advisory messages (always display to user).
 *    1: first level of tracing detail.
 *    2,3,...: successively more detailed tracing messages.
 * An application might override this method if it wanted to abort on warnings
 * or change the policy about which messages to display.
 */

METHODDEF(void)
emit_message (j_common_ptr cinfo, int msg_level)
{
  struct jpeg_error_mgr * err = cinfo->err;

  if (msg_level < 0) {
    /* It's a warning message.  Since corrupt files may generate many warnings,
     * the policy implemented here is to show only the first warning,
     * unless trace_level >= 3.
     */
    if (err->num_warnings == 0 || err->trace_level >= 3)
      (*err->output_message) (cinfo);
    /* Always count warnings in num_warnings. */
    err->num_warnings++;
  } else {
    /* It's a trace message.  Show it if trace_level >= msg_level. */
    if (err->trace_level >= msg_level)
      (*err->output_message) (cinfo);
  }
}


/*
 * Format a message string for the most recent JPEG error or message.
 * The message is stored into buffer, which should be at least JMSG_LENGTH_MAX
 * characters.  Note that no '\n' character is added to the string.
 * Few applications should need to override this method.
 */

METHODDEF(void)
format_message (j_common_ptr cinfo, char * buffer)
{
  struct jpeg_error_mgr * err = cinfo->err;
  int msg_code = err->msg_code;
  const char * msgtext = NULL;
  const char * msgptr;
  char ch;
  boolean isstring;

  /* Look up message string in proper table */
  if (msg_code > 0 && msg_code <= err->last_jpeg_message) {
    msgtext = err->jpeg_message_table[msg_code];
  } else if (err->addon_message_table != NULL &&
	     msg_code >= err->first_addon_message &&
	     msg_code <= err->last_addon_message) {
    msgtext = err->addon_message_table[msg_code - err->first_addon_message];
  }

  /* Defend against bogus message number */
  if (msgtext == NULL) {
    err->msg_parm.i[0] = msg_code;
    msgtext = err->jpeg_message_table[0];
  }

  /* Check for string parameter, as indicated by %s in the message text */
  isstring = FALSE;
  msgptr = msgtext;
  while ((ch = *msgptr++) != '\0') {
    if (ch == '%') {
      if (*msgptr == 's') isstring = TRUE;
      break;
    }
  }

  /* Format the message into the passed buffer */
/*  if (isstring)
    sprintf(buffer, msgtext, err->msg_parm.s);
  else
    sprintf(buffer, msgtext,
	    err->msg_parm.i[0], err->msg_parm.i[1],
	    err->msg_parm.i[2], err->msg_parm.i[3],
	    err->msg_parm.i[4], err->msg_parm.i[5],
	    err->msg_parm.i[6], err->msg_parm.i[7]);
*/        
}


/*
 * Reset error state variables at start of a new image.
 * This is called during compression startup to reset trace/error
 * processing to default state, without losing any application-specific
 * method pointers.  An application might possibly want to override
 * this method if it has additional error processing state.
 */

METHODDEF(void)
reset_error_mgr (j_common_ptr cinfo)
{
  cinfo->err->num_warnings = 0;
  /* trace_level is not reset since it is an application-supplied parameter */
  cinfo->err->msg_code = 0;	/* may be useful as a flag for "no error" */
}


/*
 * Fill in the standard error-handling methods in a jpeg_error_mgr object.
 * Typical call is:
 *	struct jpeg_compress_struct cinfo;
 *	struct jpeg_error_mgr err;
 *
 *	cinfo.err = jpeg_std_error(&err);
 * after which the application may override some of the methods.
 */

GLOBAL(struct jpeg_error_mgr *)
jpeg_std_error (struct jpeg_error_mgr * err)
{
  err->error_exit = error_exit;
  err->emit_message = emit_message;
  err->output_message = output_message;
  err->format_message = format_message;
  err->reset_error_mgr = reset_error_mgr;

  err->trace_level = 0;		/* default = no tracing */
  err->num_warnings = 0;	/* no warnings emitted yet */
  err->msg_code = 0;		/* may be useful as a flag for "no error" */

  /* Initialize message table pointers */
  err->jpeg_message_table = jpeg_std_message_table;
  err->last_jpeg_message = (int) JMSG_LASTMSGCODE - 1;

  err->addon_message_table = NULL;
  err->first_addon_message = 0;	/* for safety */
  err->last_addon_message = 0;

  return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\jpeg\jpgcodec.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   bmpcodec.hpp
*
* Abstract:
*
*   Header file for the jpeg encoder/decoder
*
* Revision History:
*
*   5/13/1999 OriG
*       Created it.
*
\**************************************************************************/

#ifndef _JPEGLIB_H
extern "C" {
    #include "jpeglib.h"
    #include "transupp.h"
};

#include "propertyutil.hpp"

#define _JPEGLIB_H
#endif

#define DEFAULT_JPEG_TILE 8
#define NO_TRANSFORM_REQUIRED 99

class jpeg_datasrc;
class jpeg_datadest;

// The first jpeg app header in the jpeg property storage

#define FIRST_JPEG_APP_HEADER 10

#define PROPID_NAME_FIRST 1024

#define CINFO (* ((jpeg_decompress_struct *)(this)))

boolean jpeg_marker_APP1_parser(j_decompress_ptr cinfo);

class GpJpegDecoder : public IImageDecoder,
                      public jpeg_decompress_struct
{
    IStream *pIstream;
    IImageSink* decodeSink;
    ImageInfo imageInfo;
    struct jpeg_error_mgr jerr;
    jpeg_datasrc *datasrc;
    BOOL bReinitializeJpeg;
    JSAMPROW scanlineBuffer[1];
   
    BOOL bCalled_jpeg_read_header;  // jpeg_read_header was already called
    BOOL bCalled_BeginSink;

    STDMETHOD(SetGrayscalePalette)(VOID);
    STDMETHOD(ReinitializeJpeg)(VOID);
    STDMETHOD(ReadJpegHeaders)(VOID);
    BOOL read_jpeg_marker(j_decompress_ptr cinfo, SHORT app_header,
                          VOID **ppBuffer, UINT16 *pLength);
    STDMETHOD(SetMarkerProcessors)(VOID);
    STDMETHOD(jtransformation_markers_setup)(j_decompress_ptr srcinfo,
                                             JCOPY_OPTION option);

    STDMETHOD(UnsetMarkerProcessors)(VOID);
    STDMETHOD(DecodeForChannel)(VOID);
    STDMETHOD(DecodeForColorKeyRange)(VOID);
    STDMETHOD(DecodeForTransform)();
    STDMETHOD(BuildPropertyItemList)();
    VOID CleanUpPropertyItemList();
    STDMETHOD(ChangePropertyValue)(PROPID propID, UINT uiNewValue,
                                   UINT*  puiOldValue);
    STDMETHOD(PassPropertyToSink)();

    IImage *thumbImage;

    typedef enum
    {
        CHANNEL_1 = 0,
        CHANNEL_2,
        CHANNEL_3,
        CHANNEL_4,
        CHANNEL_LUMINANCE
    } JPEG_COLOR_CHANNLE;

    BOOL    IsCMYK;             // TRUE if the source image is an CMYK image
    BOOL    IsChannleView;      // True if the caller set the output format as
                                // channel by channel through SetDecoderParam
    JPEG_COLOR_CHANNLE ChannelIndex;
                                // Index for the channel caller specified
    BOOL    HasSetColorKeyRange;// TRUE if the caller called SetDecoderParam and
                                // set the color key range
    UINT    TransColorKeyLow;   // Transparent color key, lower bounds
    UINT    TransColorKeyHigh;  // Transparent color key, higher bounds

    J_COLOR_SPACE   OriginalColorSpace;
    JXFORM_CODE     TransformInfo;
                                // Information for transformation when decode

    // Property item stuff

    BOOL            HasProcessedPropertyItem;
    InternalPropertyItem   PropertyListHead;
    InternalPropertyItem   PropertyListTail;
    UINT            PropertyListSize;
    UINT            PropertyNumOfItems;
    BOOL            HasPropertyChanged;
    BOOL            HasSetICCProperty;
    int             SrcHSampleFactor[MAX_COMPS_IN_SCAN];
    int             SrcVSampleFactor[MAX_COMPS_IN_SCAN];
    BOOL            CanTrimEdge;   // TRUE if we can trim during transformation
    int             InfoSrcHeader; // APP header number where we got header info
    int             ThumbSrcHeader;// APP header number where we got thumbnail
    int             PropertySrcHeader; // APP header number where got property
    STDMETHOD(CallBeginSink)(VOID);

public:
    BOOL jpeg_marker_processor(j_decompress_ptr cinfo, SHORT app_header);
    BOOL jpeg_thumbnail_processor(j_decompress_ptr cinfo, SHORT app_header);
    BOOL jpeg_property_processor(j_decompress_ptr cinfo, SHORT app_header);
    BOOL jpeg_header_processor(j_decompress_ptr cinfo, SHORT app_header);

    UINT jpeg_get_current_xform()
    {
        return (UINT)TransformInfo;
    }

    BOOL jpeg_get_trim_option()
    {
        return CanTrimEdge;
    }
    
    int* jpeg_get_hSampFactor()
    {
        return SrcHSampleFactor;
    }

    int* jpeg_get_vSampFactor()
    {
        return SrcVSampleFactor;
    }
    
    BOOL bAppMarkerPresent;
    INT JpegAppHeaderCount;

protected:
    LONG    comRefCount;       // COM object reference count    
    
public:

    // Constructor and Destructor
    
    GpJpegDecoder::GpJpegDecoder(void);
    GpJpegDecoder::~GpJpegDecoder(void);
    
    // IImageDecoder methods
    
    STDMETHOD(InitDecoder)(IN IStream* stream, IN DecoderInitFlag flags);
    STDMETHOD(TerminateDecoder) ();
    STDMETHOD(BeginDecode)(IN IImageSink* imageSink,
                           IN OPTIONAL IPropertySetStorage* newPropSet);
    STDMETHOD(Decode)();
    STDMETHOD(EndDecode)(IN HRESULT statusCode);

    STDMETHOD(GetFrameDimensionsCount)(OUT UINT* count);
    STDMETHOD(GetFrameDimensionsList)(OUT GUID* dimensionIDs,IN OUT UINT count);
    STDMETHOD(GetFrameCount)(IN const GUID* dimensionID, OUT UINT* count);
    STDMETHOD(SelectActiveFrame)(IN const GUID* dimensionID, 
        IN UINT frameIndex);
    STDMETHOD(GetImageInfo)(OUT ImageInfo* imageInfo);
    STDMETHOD(GetThumbnail)(IN OPTIONAL UINT thumbWidth, 
        IN OPTIONAL UINT thumbHeight, OUT IImage** thumbImage);
    STDMETHOD(QueryDecoderParam)(IN GUID Guid);
    STDMETHOD(SetDecoderParam)(IN GUID Guid, IN UINT Length, IN PVOID Value);
    STDMETHOD(GetPropertyCount)(OUT UINT* numOfProperty);
    STDMETHOD(GetPropertyIdList)(IN UINT numOfProperty,IN OUT PROPID* list);
    STDMETHOD(GetPropertyItemSize)(IN PROPID propId, OUT UINT* size);    
    STDMETHOD(GetPropertyItem)(IN PROPID propId, IN UINT propSize,
                               IN OUT PropertyItem* buffer);
    STDMETHOD(GetPropertySize)(OUT UINT* totalBufferSize,
                               OUT UINT* numProperties);
    STDMETHOD(GetAllPropertyItems)(IN UINT totalBufferSize,
                                   IN UINT numProperties,
                                   IN OUT PropertyItem* allItems);
    STDMETHOD(RemovePropertyItem)(IN PROPID propId);
    STDMETHOD(SetPropertyItem)(IN PropertyItem item);
    STDMETHOD(GetRawInfo)(IN OUT void** ppInfo);

    // IUnknown methods

    STDMETHOD(QueryInterface)(REFIID riid, VOID** ppv);
    STDMETHOD_(ULONG, AddRef)(VOID);
    STDMETHOD_(ULONG, Release)(VOID);
};


class GpJpegEncoder : public IImageEncoder,
                      public IImageSink
{
private:
    struct jpeg_compress_struct compress_info;
    struct jpeg_error_mgr       jerr;
    jpeg_datadest*              datadest;
    
    IStream*    pIoutStream;
    ImageInfo   encoderImageInfo;
    PVOID       lastBufferAllocated;
    RECT        encoderRect;
    INT         EP_Quality;
    JSAMPROW    scanlineBuffer[1];
    UINT        RequiredTransformation; // Transformation info
    BOOL        IsCompressFinished;
    BOOL        HasAPP1Marker;          // True if we have APP1 marker
    PBYTE       APP1MarkerBufferPtr;    // Buffer for holding APP1 marker data
    UINT        APP1MarkerLength;       // Total length, in bytes, of APP1
    BOOL        HasAPP2Marker;          // True if we have APP2 marker
    PBYTE       APP2MarkerBufferPtr;    // Buffer for holding the APP2 marker
    UINT        APP2MarkerLength;       // Total length, in bytes, of APP2
    BOOL        HasICCProfileChanged;   // TRUE if user set the ICC profile
    BOOL        HasSetLuminanceTable;
    BOOL        HasSetChrominanceTable;
    UINT16      LuminanceTable[DCTSIZE2];
    UINT16      ChrominanceTable[DCTSIZE2];
    BOOL        HasSetDestColorSpace;   // TRUE if the caller has set the dest
                                        // color space
    BOOL        AllowToTrimEdge;        // TRUE if the caller wants us to trim
                                        // the edge if the size doesn't meet
                                        // lossless transformation requirement
    BOOL m_fSuppressAPP0;               // TRUE if caller wants to suppress APP0
    J_COLOR_SPACE   DestColorSpace;
    struct jpeg_decompress_struct* SrcInfoPtr;
                                        // Pointer to decompressor structure

    HRESULT CreateAPP2Marker(
        IN PropertyItem* pPropertyList,
        IN UINT uiNumOfPropertyItems);

protected:
    LONG comRefCount;       // COM object reference count    

public:

    // Constructor and Destructor
    
    GpJpegEncoder::GpJpegEncoder(void);
    GpJpegEncoder::~GpJpegEncoder(void);

    // IImageEncoder methods

    STDMETHOD(InitEncoder)(IN IStream* stream);
    STDMETHOD(TerminateEncoder)();
    STDMETHOD(GetEncodeSink)(OUT IImageSink** sink);
    STDMETHOD(SetFrameDimension)(IN const GUID* dimensionID);
    
    // IImageSink methods (sink for encoder)

    STDMETHOD(BeginSink)(IN OUT ImageInfo* imageInfo, 
                         OUT OPTIONAL RECT* subarea);
    STDMETHOD(EndSink)(IN HRESULT statusCode);
    STDMETHOD(SetPalette)(IN const ColorPalette* palette);
    STDMETHOD(GetPixelDataBuffer)(IN const RECT* rect, 
                                  IN PixelFormatID pixelFormat,
                                  IN BOOL lastPass,
                                  OUT BitmapData* bitmapData);
    STDMETHOD(ReleasePixelDataBuffer)(IN const BitmapData* bitmapData);
    STDMETHOD(PushRawData)(IN const VOID* buffer, IN UINT bufsize);
    STDMETHOD(PushPixelData)(IN const RECT* rect,
                             IN const BitmapData* bitmapData,
                             IN BOOL lastPass);
    STDMETHOD(PushRawInfo)(IN OUT void* info);
    STDMETHOD(GetPropertyBuffer)(IN UINT uiTotalBufferSize,
                                 IN OUT PropertyItem**  ppBuffer);
    
    STDMETHOD(PushPropertyItems)(IN UINT numOfItems,
                                 IN UINT uiTotalBufferSize,
                                 IN PropertyItem* item,
                                 IN BOOL fICCProfileChanged);
    
    STDMETHOD(NeedTransform(OUT UINT* transformation))
    {
        if ( (EP_Quality != -1) || (HasSetLuminanceTable == TRUE) )
        {
            // The caller has set the quality requirement or set its own
            // quantization So we can't do any lossless transform.
            // Note: we these two booleans (HasSetLuminanceTable and
            // HasSetChrominanceTable), we need to check only one of them
            // because they should either both TRUE or both FALSE

            return E_NOTIMPL;
        }
        else
        {
            // Tell the decoder we need a lossless transformation
            // Note: Here I (minliu) use the 1st bits of this UINT value to
            // tell the decoder if the user wants to trim the edge or not.
            // Unfortunately this is the only function between decoder and
            // encoder to pass lossless transformation info. In V2, we should
            // add a separate API to let decoder query the TRIM info.

            *transformation = RequiredTransformation
                            | (AllowToTrimEdge << 31);
            return S_OK;
        }
    }
    
    STDMETHOD(NeedRawProperty)(void *pInfo)
    {
        // JPG can handle raw property when saving
        // Also remember the decoder structure so that we can copy private
        // application markers later

        if (pInfo)
        {
            SrcInfoPtr = (jpeg_decompress_struct*)pInfo;
        }

        return S_OK;
    }
    
    STDMETHOD(GetEncoderParameterListSize)(OUT UINT* size);
    STDMETHOD(GetEncoderParameterList)(IN UINT	  size,
                                       OUT EncoderParameters* Params);
    STDMETHOD(SetEncoderParameters)(IN const EncoderParameters* Param);

    // IUnknown methods

    STDMETHOD(QueryInterface)(REFIID riid, VOID** ppv);
    STDMETHOD_(ULONG, AddRef)(VOID);
    STDMETHOD_(ULONG, Release)(VOID);
};

class GpJpegCodec : public GpJpegDecoder,
                    public GpJpegEncoder
{
protected:
    LONG comRefCount;       // COM object reference count    

public:

    // Constructor and Destructor
    
    GpJpegCodec::GpJpegCodec(void);
    GpJpegCodec::~GpJpegCodec(void);

    // IUnknown methods

    STDMETHOD(QueryInterface)(REFIID riid, VOID** ppv);
    STDMETHOD_(ULONG, AddRef)(VOID);
    STDMETHOD_(ULONG, Release)(VOID);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\jpeg\jpgcodec.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   bmpcodec.cpp
*
* Abstract:
*
*   Shared methods for the jpeg codec
*
* Revision History:
*
*   5/10/1999 OriG
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "jpgcodec.hpp"


/**************************************************************************\
*
* Function Description:
*
*     Constructor
*
* Return Value:
*
*   none
*
\**************************************************************************/

GpJpegCodec::GpJpegCodec(
    void
    )
{
    comRefCount   = 1;
}

GpJpegDecoder::GpJpegDecoder(
    void
    )
{
    comRefCount   = 1;
    pIstream      = NULL;
    decodeSink    = NULL;
    scanlineBuffer[0] = NULL;
    datasrc = NULL;

    // Property item stuff

    HasProcessedPropertyItem = FALSE;
    
    PropertyListHead.pPrev = NULL;
    PropertyListHead.pNext = &PropertyListTail;
    PropertyListHead.id = 0;
    PropertyListHead.length = 0;
    PropertyListHead.type = 0;
    PropertyListHead.value = NULL;

    PropertyListTail.pPrev = &PropertyListHead;
    PropertyListTail.pNext = NULL;
    PropertyListTail.id = 0;
    PropertyListTail.length = 0;
    PropertyListTail.type = 0;
    PropertyListTail.value = NULL;

    PropertyListSize = 0;
    PropertyNumOfItems = 0;
    HasPropertyChanged = FALSE;
    HasSetICCProperty = FALSE;
}

GpJpegEncoder::GpJpegEncoder(
    void
    )
{
    comRefCount   = 1;
    pIoutStream   = NULL;
    datadest = NULL;
    lastBufferAllocated = NULL;
}

/**************************************************************************\
*
* Function Description:
*
*     Destructor
*
* Return Value:
*
*   none
*
\**************************************************************************/

GpJpegCodec::~GpJpegCodec(
    void
    )
{
}

GpJpegDecoder::~GpJpegDecoder(
    void
    )
{
    // The destructor should never be called before Terminate is called, but
    // if it does we should release our reference on the stream anyway to avoid
    // a memory leak.

    if(pIstream)
    {
        WARNING(("GpJpegCodec::~GpJpegCodec -- need to call TerminateDecoder first"));
        pIstream->Release();
        pIstream = NULL;
    }

    if (scanlineBuffer[0] != NULL) 
    {
        WARNING(("GpJpegCodec::~GpJpegCodec -- need to call TerminateDecoder first"));
        GpFree(scanlineBuffer[0]);
        scanlineBuffer[0] = NULL;
    }

    // Free all the cached property items if we have allocated them

    if ( HasProcessedPropertyItem == TRUE )
    {
        CleanUpPropertyItemList();
    }
}

GpJpegEncoder::~GpJpegEncoder(
    void
    )
{
    // The destructor should never be called before Terminate is called, but
    // if it does we should release our reference on the stream anyway to avoid
    // a memory leak.

    if(pIoutStream)
    {
        WARNING(("GpJpegCodec::~GpJpegCodec -- need to call TerminateDecoder first"));
        pIoutStream->Release();
        pIoutStream = NULL;
    }

    if (lastBufferAllocated) 
    {
        WARNING(("GpJpegCodec::~GpJpegCodec -- lastBufferAllocated should be NULL"));
        GpFree(lastBufferAllocated);
        lastBufferAllocated = NULL;
    }
}

/**************************************************************************\
*
* Function Description:
*
*     QueryInterface
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP
GpJpegCodec::QueryInterface(
    REFIID riid,
    VOID** ppv
    )
{
    if (riid == IID_IImageDecoder)
    {
        *ppv = static_cast<IImageDecoder*>(this);
    }
    else if (riid == IID_IImageEncoder)
    {    
        *ppv = static_cast<IImageEncoder*>(this);
    }
    else if (riid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(static_cast<IImageDecoder*>(this));
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

STDMETHODIMP
GpJpegDecoder::QueryInterface(
    REFIID riid,
    VOID** ppv
    )
{
    if (riid == IID_IImageDecoder)
    {
        *ppv = static_cast<IImageDecoder*>(this);
    }
    else if (riid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(static_cast<IImageDecoder*>(this));
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

STDMETHODIMP
GpJpegEncoder::QueryInterface(
    REFIID riid,
    VOID** ppv
    )
{
    if (riid == IID_IImageEncoder)
    {    
        *ppv = static_cast<IImageEncoder*>(this);
    }
    else if (riid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(static_cast<IImageEncoder*>(this));
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     AddRef
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP_(ULONG)
GpJpegCodec::AddRef(
    VOID)
{
    return InterlockedIncrement(&comRefCount);
}

STDMETHODIMP_(ULONG)
GpJpegDecoder::AddRef(
    VOID)
{
    return InterlockedIncrement(&comRefCount);
}

STDMETHODIMP_(ULONG)
GpJpegEncoder::AddRef(
    VOID)
{
    return InterlockedIncrement(&comRefCount);
}

/**************************************************************************\
*
* Function Description:
*
*     Release
*
* Return Value:
*
*   status
*
\**************************************************************************/

STDMETHODIMP_(ULONG)
GpJpegCodec::Release(
    VOID)
{
    ULONG count = InterlockedDecrement(&comRefCount);

    if (count == 0)
    {
        delete this;
    }

    return count;
}

STDMETHODIMP_(ULONG)
GpJpegDecoder::Release(
    VOID)
{
    ULONG count = InterlockedDecrement(&comRefCount);

    if (count == 0)
    {
        delete this;
    }

    return count;
}

STDMETHODIMP_(ULONG)
GpJpegEncoder::Release(
    VOID)
{
    ULONG count = InterlockedDecrement(&comRefCount);

    if (count == 0)
    {
        delete this;
    }

    return count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\jpeg\jpgdecoder.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   jpgdecoder.cpp
*
* Abstract:
*
*   Implementation of the jpeg decoder
*
* Revision History:
*
*   5/10/1999 OriG
*       Created it.
*   07/17/1999 Min Liu took over
*       added bunch of new features and bug fixing
*
\**************************************************************************/

#include "precomp.hpp"
#include "jpgcodec.hpp"
#include "appproc.hpp"

VOID jpeg_error_exit(j_common_ptr cinfo);
VOID GetNewDimensionValuesForTrim(j_decompress_ptr    cinfo,
                                  UINT                uiTransform,
                                  UINT*               puiNewWidth,
                                  UINT*               puiNewHeight);

// JPEG decompression data source module

class jpeg_datasrc : public jpeg_source_mgr
{
public:

    jpeg_datasrc(IStream* stream)
    {
        init_source = jpeg_datasrc::InitSource;
        term_source = jpeg_datasrc::TermSource;
        fill_input_buffer = jpeg_datasrc::FillBuffer;
        skip_input_data = jpeg_datasrc::SkipData;
        resync_to_restart = jpeg_resync_to_restart;

        bytes_in_buffer = 0;
        next_input_byte = buffer;
        this->stream = stream;
        this->hLastError = S_OK;
    }

    HRESULT
    GetLastError()
    {
        return hLastError;
    };

private:

    static void
    InitSource(j_decompress_ptr cinfo)
    {
    }

    static void
    TermSource(j_decompress_ptr cinfo)
    {
    }

    static BOOL
    FillBuffer(j_decompress_ptr cinfo)
    {
        jpeg_datasrc* src = (jpeg_datasrc*) cinfo->src;

        ULONG cb = 0;

        src->hLastError = src->stream->Read(src->buffer, JPEG_INBUF_SIZE, &cb);

        if (FAILED(src->hLastError))
        {
            return FALSE;
        }

        if (cb == 0)
        {
            // insert a faked EOI marker

            src->buffer[0] = 0xff;
            src->buffer[1] = JPEG_EOI;
            cb = 2;
        }

        src->next_input_byte =  src->buffer;
        src->bytes_in_buffer = cb;
        return TRUE;
    }

    static void
    SkipData(j_decompress_ptr cinfo, long num_bytes)
    {
        if (num_bytes > 0)
        {
            jpeg_datasrc* src = (jpeg_datasrc*) cinfo->src;

            while (num_bytes > (long) src->bytes_in_buffer)
            {
                num_bytes -= src->bytes_in_buffer;
                FillBuffer(cinfo);
            }

            src->next_input_byte += num_bytes;
            src->bytes_in_buffer -= num_bytes;
        }
    }

private:

    enum { JPEG_INBUF_SIZE = 4096 };

    IStream* stream;
    JOCTET buffer[JPEG_INBUF_SIZE];
    HRESULT hLastError;     // Last error from the stream class
};

// =======================================================================
// Macros from JPEG library to read from source manager
// =======================================================================

#define MAKESTMT(stuff)     do { stuff } while (0)

#define INPUT_VARS(cinfo)  \
    struct jpeg_source_mgr * datasrc = (cinfo)->src;  \
    const JOCTET * next_input_byte = datasrc->next_input_byte;  \
    size_t bytes_in_buffer = datasrc->bytes_in_buffer

#define INPUT_SYNC(cinfo)  \
    ( datasrc->next_input_byte = next_input_byte,  \
      datasrc->bytes_in_buffer = bytes_in_buffer )

#define INPUT_RELOAD(cinfo)  \
    ( next_input_byte = datasrc->next_input_byte,  \
      bytes_in_buffer = datasrc->bytes_in_buffer )

#define MAKE_BYTE_AVAIL(cinfo,action)  \
    if (bytes_in_buffer == 0) {  \
      if (! (*datasrc->fill_input_buffer) (cinfo))  \
        { action; }  \
      INPUT_RELOAD(cinfo);  \
    }

#define INPUT_BYTE(cinfo,V,action)  \
    MAKESTMT( MAKE_BYTE_AVAIL(cinfo,action); \
          bytes_in_buffer--; \
          V = GETJOCTET(*next_input_byte++); )

#define INPUT_2BYTES(cinfo,V,action)  \
    MAKESTMT( MAKE_BYTE_AVAIL(cinfo,action); \
          bytes_in_buffer--; \
          V = ((unsigned int) GETJOCTET(*next_input_byte++)) << 8; \
          MAKE_BYTE_AVAIL(cinfo,action); \
          bytes_in_buffer--; \
          V += GETJOCTET(*next_input_byte++); )

// =======================================================================
// skip_variable is from the JPEG library and is used to skip over
// markers we don't want to read.  skip_variable_APP1 does the same
// things excepts that it also sets bAppMarkerPresent to TRUE so that we
// will know that the image contains an APP1 header.  If we wish to
// get the APP1 header later, we will need to re-read the JPEG headers.
// =======================================================================

static boolean skip_variable (j_decompress_ptr cinfo)
/* Skip over an unknown or uninteresting variable-length marker */
{
  INT32 length;
  INPUT_VARS(cinfo);
  INPUT_2BYTES(cinfo, length, return FALSE);
  length -= 2;

  INPUT_SYNC(cinfo);            /* do before skip_input_data */
  if (length > 0)
    (*cinfo->src->skip_input_data) (cinfo, (long) length);


  return TRUE;
}

static boolean skip_variable_APP1 (j_decompress_ptr cinfo)
{
    // Remember that we've seen the APP1 header

    ((GpJpegCodec *) (cinfo))->bAppMarkerPresent = TRUE; 
    
    // Now skip the header info

    return skip_variable(cinfo);
}

/**************************************************************************\
*
* Function Description:
*
*     Initialize the image decoder
*
* Arguments:
*
*     stream -- The stream containing the bitmap data
*     flags - Misc. flags
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpJpegDecoder::InitDecoder(
    IN IStream* stream,
    IN DecoderInitFlag flags
    )
{
    HRESULT hresult = S_OK;
    
    // Make sure we haven't been initialized already
    
    if (pIstream) 
    {
        return E_FAIL;
    }

    // Keep a reference on the input stream
    
    stream->AddRef();  
    pIstream = stream;

    bReinitializeJpeg = FALSE;
    scanlineBuffer[0] = NULL;
    thumbImage = NULL;
    bAppMarkerPresent = FALSE;
    IsCMYK = FALSE;                     // By default, we deal with RGB image
    IsChannleView = FALSE;              // By default we output the full color
    ChannelIndex = CHANNEL_1;
    HasSetColorKeyRange = FALSE;
    OriginalColorSpace = JCS_UNKNOWN;
    TransformInfo = JXFORM_NONE;        // Default for no transform decode
    CanTrimEdge = FALSE;
    InfoSrcHeader = -1;                 // We haven't processed any app header
    ThumbSrcHeader = -1;
    PropertySrcHeader = -1;

    for ( int i = 0; i < MAX_COMPS_IN_SCAN; ++i )
    {
        SrcHSampleFactor[i] = 0;
        SrcVSampleFactor[i] = 0;
    }
    
    __try
    {
        // Allocate and initialize a JPEG decompression object

        (CINFO).err = jpeg_std_error(&jerr);
        jerr.error_exit = jpeg_error_exit;

        jpeg_create_decompress(&(CINFO));

        // Specify data source

        datasrc = new jpeg_datasrc(stream);
        if (datasrc == NULL)
        {
            return E_OUTOFMEMORY;
        }
        (CINFO).src = datasrc;

        // Make sure we remember we've seen the APP1 and APP13 header
        
        jpeg_set_marker_processor(&(CINFO), JPEG_APP0 + 1, skip_variable_APP1);
        jpeg_set_marker_processor(&(CINFO), JPEG_APP0 + 13, skip_variable_APP1);
        
        bCalled_jpeg_read_header = FALSE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hresult = E_FAIL;
    }    
    
    return hresult;
}// InitDecoder()

/**************************************************************************\
*
* Function Description:
*
*     Cleans up the image decoder
*
* Arguments:
*
*     none
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP 
GpJpegDecoder::TerminateDecoder()
{
    HRESULT hresult = S_OK;

    // Release the input stream
    
    if(pIstream)
    {
        pIstream->Release();
        pIstream = NULL;
    }

    // Clean up the datasrc

    if (datasrc) 
    {
        delete datasrc;
        datasrc = NULL;
    }

    if (scanlineBuffer[0] != NULL) 
    {
        WARNING(("GpJpegDecoder::TerminateDecoder-scanlineBuffer not NULL"));
        GpFree(scanlineBuffer[0]);
        scanlineBuffer[0] = NULL;
    }

    if (thumbImage) 
    {
        thumbImage->Release();
        thumbImage = NULL;
        ThumbSrcHeader = -1;
    }

    __try
    {
        jpeg_destroy_decompress(&(CINFO));
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hresult = E_FAIL;
    }

    // Free all the cached property items if we have allocated them

    if ( HasProcessedPropertyItem == TRUE )
    {
        CleanUpPropertyItemList();
    }

    return hresult;
}// TerminateDecoder()

/**************************************************************************\
*
* Function Description:
*
*     Let the caller query if the decoder supports its decoding requirements
*
* Arguments:
*
*     none
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpJpegDecoder::QueryDecoderParam(
    IN GUID     Guid
    )
{
    if ( (Guid == DECODER_TRANSCOLOR) || ( Guid == DECODER_OUTPUTCHANNEL ) )
    {
        return S_OK;
    }

    return E_FAIL;
}// QueryDecoderParam()

/**************************************************************************\
*
* Function Description:
*
*     Setup the decoder parameters. Caller calls this function before calling
*   Decode(). This will set up the output format, like channel output,
*   transparanet key etc.
*
* Arguments:
*
*   Guid-----The GUID for decoder parameter
*   Length---Length of the decoder parameter in bytes
*   Value----Value of the parameter
*
* Return Value:
*
*   Status code
*
* Note:
*   We should ignore any unknown parameters, not return invalid parameter
*
\**************************************************************************/

STDMETHODIMP 
GpJpegDecoder::SetDecoderParam(
    IN GUID     Guid,
    IN UINT     Length,
    IN PVOID    Value
    )
{
    if ( Guid == DECODER_TRANSCOLOR )
    {
        if ( Length != 8 )
        {
            return E_INVALIDARG;
        }
        else
        {
            UINT*   puiTemp = (UINT*)Value;
            
            TransColorKeyLow = *puiTemp++;
            TransColorKeyHigh = *puiTemp;

            HasSetColorKeyRange = TRUE;
        }
    }
    else if ( Guid == DECODER_OUTPUTCHANNEL )
    {
        if ( Length != 1 )
        {
            return E_INVALIDARG;
        }
        else
        {
            // Note: We cannot check if the setting is valid or not here.
            // For example, the caller might set "view channel K" on an RGB
            // image. But at this moment, the Decoder() method might hasn't
            // been called yet. We haven't read the image header yet.

            IsChannleView = TRUE;

            char cChannelName = *(char*)Value;
            
            switch ( (UINT)cChannelName )
            {
            case 'C':
            case 'c':
                ChannelIndex = CHANNEL_1;

                break;

            case 'M':
            case 'm':
                ChannelIndex = CHANNEL_2;
                
                break;

            case 'Y':
            case 'y':
                ChannelIndex = CHANNEL_3;
                
                break;

            case 'K':
            case 'k':
                ChannelIndex = CHANNEL_4;

                break;

            case 'R':
            case 'r':
                ChannelIndex = CHANNEL_1;

                break;

            case 'G':
            case 'g':
                ChannelIndex = CHANNEL_2;

                break;

            case 'B':
            case 'b':
                ChannelIndex = CHANNEL_3;

                break;

            case 'L':
            case 'l':
                ChannelIndex = CHANNEL_LUMINANCE;
                break;
                
            default:
                WARNING(("SetDecoderParam: Unknown channle name"));
                return E_INVALIDARG;
            }// switch()
        }// Length = 1
    }// DECODER_OUTPUTCHANNEL GUID

    return S_OK;
}// SetDecoderParam()

/**************************************************************************\
*
* Function Description:
*
*     Initiates the decode of the current frame
*
* Arguments:
*
*   decodeSink --  The sink that will support the decode operation
*   newPropSet - New image property sets, if any
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpJpegDecoder::BeginDecode(
    IN IImageSink* imageSink,
    IN OPTIONAL IPropertySetStorage* newPropSet
    )
{
    HRESULT hresult;
    
    if (decodeSink) 
    {
        WARNING(("BeginDecode called again before call to EngDecode"));
        return E_FAIL;
    }

    imageSink->AddRef();
    decodeSink = imageSink;

    bCalled_BeginSink = FALSE;
    
    return S_OK;
}
    
    
/**************************************************************************\
*
* Function Description:
*
*     Calls BeginSink
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpJpegDecoder::CallBeginSink(
    VOID
    )
{
    HRESULT hresult = S_OK;

    if (!bCalled_BeginSink) 
    {
        hresult = GetImageInfo(&imageInfo);
        if (FAILED(hresult)) 
        {
            WARNING(("GpJpegDecoder::CallBeginSink---GetImageInfo() failed"));
            return hresult;
        }

        RECT subarea;
        subarea.left = subarea.top = 0;
        subarea.right = (CINFO).image_width;
        subarea.bottom = (CINFO).image_height;
        
        // Pass property items to the sink if necessary

        hresult = PassPropertyToSink();
        if (FAILED(hresult)) 
        {
            WARNING(("GpJpegDecoder::CallBeginSink---BeginSink() failed"));
            return hresult;
        }

        hresult = decodeSink->BeginSink(&imageInfo, &subarea);
        if (FAILED(hresult)) 
        {
            WARNING(("GpJpegDecoder::CallBeginSink---BeginSink() failed"));
            return hresult;
        }

        // Negotiate for scaling factor

        BOOL bCallSinkAgain = FALSE;
        if ((imageInfo.Flags & SINKFLAG_PARTIALLY_SCALABLE) &&
            ((imageInfo.Height != (CINFO).image_height) ||
             (imageInfo.Width  != (CINFO).image_width)))
              
        {
            bCallSinkAgain = TRUE;

            INT scaleX = (CINFO).image_width  / imageInfo.Width;
            INT scaleY = (CINFO).image_height / imageInfo.Height;
            INT scale  = min(scaleX, scaleY);

            if (scale >= 8) 
            {
                (CINFO).scale_denom = 8;
            } 
            else if (scale >= 4) 
            {
                (CINFO).scale_denom = 4;
            }
            else if (scale >= 2) 
            {
                (CINFO).scale_denom = 2;
            }
        }
    
        __try
        {
            if (!jpeg_start_decompress(&(CINFO)))
            {
                WARNING(("JpegDec::CallBeginSink-jpeg_start_decompress fail"));
                return (datasrc->GetLastError());
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING(("JpegDec::CallBeginSink-jpeg_start_decompress exception"));
            return E_FAIL;
        }        
        
        if (bCallSinkAgain) 
        {
            imageInfo.Flags &= ~SINKFLAG_PARTIALLY_SCALABLE;
            imageInfo.Width = (CINFO).output_width;
            imageInfo.Height = (CINFO).output_height;
            imageInfo.Xdpi *= (CINFO).scale_denom;
            imageInfo.Ydpi *= (CINFO).scale_denom;
            
            hresult = decodeSink->BeginSink(&imageInfo, &subarea);
            if (FAILED(hresult)) 
            {
                WARNING(("GpJpegDecoder::CallBeginSink--BeginSink() 2 failed"));
                return hresult;
            }
        }

        bCalled_BeginSink = TRUE;
        
        if ((imageInfo.PixelFormat != PIXFMT_24BPP_RGB) &&
            (imageInfo.PixelFormat != PIXFMT_32BPP_RGB) &&
            (imageInfo.PixelFormat != PIXFMT_32BPP_ARGB) &&
            (imageInfo.PixelFormat != PIXFMT_32BPP_PARGB))
        {
            if ((imageInfo.PixelFormat == PIXFMT_8BPP_INDEXED) &&
                ((CINFO).out_color_space == JCS_GRAYSCALE))
            {
                hresult = SetGrayscalePalette();
            }
            else
            {
                // Can't satisfy their request.  Will give them our
                // canonical format instead.

                imageInfo.PixelFormat = PIXFMT_32BPP_ARGB;
            }
        }
    
        ASSERT(scanlineBuffer[0] == NULL);
        if ( IsCMYK == TRUE )
        {
            scanlineBuffer[0] = (JSAMPROW) GpMalloc(imageInfo.Width << 2);
        }
        else
        {
            scanlineBuffer[0] = (JSAMPROW) GpMalloc(imageInfo.Width * 3);
        }

        if (scanlineBuffer[0] == NULL) 
        {
            WARNING(("GpJpegDecoder::CallBeginSink--Out of memory"));
            hresult = E_OUTOFMEMORY;
        }    
    }
     
    return hresult;
}
    
/**************************************************************************\
*
* Function Description:
*
*     Sets the grayscale palette into the sink
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpJpegDecoder::SetGrayscalePalette(
    VOID
    )
{
    ColorPalette *pColorPalette;
    HRESULT hresult;

    pColorPalette = (ColorPalette *) GpMalloc (sizeof(ColorPalette) + 
                                             256 * sizeof(ARGB));
    if (!pColorPalette) 
    {
        return E_OUTOFMEMORY;
    }

    // Set the grayscale palette

    pColorPalette->Flags = 0;
    pColorPalette->Count = 256;
    for (INT i=0; i<256; i++) 
    {
        pColorPalette->Entries[i] = MAKEARGB(255, (BYTE)i, (BYTE)i, (BYTE)i);
    }

    // Set the palette in the sink
    
    hresult = decodeSink->SetPalette(pColorPalette);   

    GpFree (pColorPalette);
    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Ends the decode of the current frame
*
* Arguments:
*
*     statusCode -- status of decode operation
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpJpegDecoder::EndDecode(
    IN HRESULT statusCode
    )
{
    HRESULT hResult = S_OK;
    
    bReinitializeJpeg = TRUE;

    if (scanlineBuffer[0] != NULL) 
    {
        GpFree(scanlineBuffer[0]);
        scanlineBuffer[0] = NULL;
    }

    if (!decodeSink) 
    {
        WARNING(("EndDecode called before call to BeginDecode"));
        return E_FAIL;
    }
    
    if ( bCalled_BeginSink )
    {
        hResult = decodeSink->EndSink(statusCode);

        if ( FAILED(hResult) )
        {
            WARNING(("GpJpegCodec::EndDecode--EndSink failed"));
            statusCode = hResult; // If EndSink failed return that (more recent)
                                  // failure code
        }
        bCalled_BeginSink = FALSE;
    }

    decodeSink->Release();
    decodeSink = NULL;

    return statusCode;
}

/**************************************************************************\
*
* Function Description:
*
*     Reinitialize the jpeg decoding
*
* Arguments:
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpJpegDecoder::ReinitializeJpeg(
    VOID
    )
{
    HRESULT hresult;

    if (bReinitializeJpeg) 
    {
        // We're reading this image for a second time.  Need to reinitialize
        // the jpeg state

        __try
        {
            // Reset the stream to the beginning of the file

            LARGE_INTEGER zero = {0,0};
            hresult = pIstream->Seek(zero, STREAM_SEEK_SET, NULL);
            if (!SUCCEEDED(hresult)) 
            {
                return hresult;
            }

            // Reset jpeg state

            jpeg_abort_decompress(&(CINFO));

            if ((CINFO).src) 
            {
                delete (CINFO).src;
                (CINFO).src = new jpeg_datasrc(pIstream);
                datasrc = (jpeg_datasrc*)((CINFO).src);

                if ((CINFO).src == NULL)
                {
                    return E_OUTOFMEMORY;
                }
            }

            bCalled_jpeg_read_header = FALSE;
            bReinitializeJpeg = FALSE;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            return E_FAIL;
        }    
    }

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Read the jpeg headers
*
* Arguments:
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpJpegDecoder::ReadJpegHeaders(
    VOID
    )
{
    if (!bCalled_jpeg_read_header)
    {
        // Read file parameters with jpeg_read_header. This function wiil fail
        // if data is not available yet, like downloading from the net, then we
        // should get E_PENDING from the stream read. If the caller abort it,
        // then we should get E_ABORT from the stream read

        __try
        {
            if (jpeg_read_header(&(CINFO), TRUE) == JPEG_SUSPENDED)
            {
                return (datasrc->GetLastError());
            }
            
            // Remember input image's color space info

            OriginalColorSpace = (CINFO).jpeg_color_space;

            if ( (CINFO).out_color_space == JCS_CMYK )
            {
                IsCMYK = TRUE;

                // Set the output color format as RGB, not CMYK.
                // By setting this, the lower level jpeg library will do the
                // color conversation before it returns to us
                // If it is under channle view case, we just let the lower level
                // return CMYK format and we return one channle back. So we
                // still leave it as CMYK. Do nothing here
                
                if ( IsChannleView == FALSE )
                {
                    (CINFO).out_color_space = JCS_RGB;
                }
            }
            else if ( ( ((CINFO).out_color_space != JCS_RGB)
                 &&((CINFO).out_color_space != JCS_GRAYSCALE) )
               ||( (CINFO).num_components > 3) ) 
            {
                WARNING(("Image is not in JCS_RGB color space"));
                return E_FAIL;
            }

            bCalled_jpeg_read_header = TRUE;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING(("Jpeg::ReadJpegHeaders-jpeg_read_header() hit exception"));
            return E_FAIL;
        }    
    }
    
    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Decodes the current frame
*
* Arguments:
*
*     decodeSink --  The sink that will support the decode operation
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpJpegDecoder::Decode()
{
    HRESULT     hresult;
    PBYTE       pBits = NULL;
    INT         index;
    UINT        uiTransform;

    // Check if the sink needs any transformation of the source image

    hresult = decodeSink->NeedTransform(&uiTransform);

    // We should do an lossless transformation if the following conditions are
    // met:
    // 1) The sink (obviously it is JPEG encoder) supports it (hresult == S_OK)
    // 2) The encoder tells us that it needs a transformation result
    //    (uiTransform equals one of the supported transformation value
    //    or This is a pure Save OP (uiTransform == JXFORM_NONE) on condition
    //    that no quality setting changed.
    //    Note: If the caller sets the quality level through EncoderParameter,
    //    then the JPEG encoder should return E_FAIL for NeedTransform() call
    //    since it knows this is not a lossless save operation

    if ( hresult == S_OK )
    {
        // When JPEG encoder returns us the transform OP parameter, it also uses
        // the highest bits in this UINT to indicate if the caller wants us to
        // trim the edge or not if the image size doesn't meet the lossless
        // transformation requirement.

        // Take off the flag bits (highest bits) for trim edge or not.
        // Note: This "CanTrimEdge" is used in DecodeForTransform() when it sets
        // jpeg_marker_processor() for passing APP1 header for lossless
        // transformation etc.

        CanTrimEdge = (BOOL)((uiTransform & 0x80000000) >> 31);
        uiTransform = uiTransform & 0x7fffffff;

        if (  ( (uiTransform >= EncoderValueTransformRotate90)
              &&(uiTransform <= EncoderValueTransformFlipVertical) )
            ||(uiTransform == JXFORM_NONE) )
        {
            // Lossless saving OP

            switch ( uiTransform )
            {
            case EncoderValueTransformRotate90:
                TransformInfo = JXFORM_ROT_90;
                break;

            case EncoderValueTransformRotate180:
                TransformInfo = JXFORM_ROT_180;
                break;

            case EncoderValueTransformRotate270:
                TransformInfo = JXFORM_ROT_270;
                break;

            case EncoderValueTransformFlipHorizontal:
                TransformInfo = JXFORM_FLIP_H;
                break;

            case EncoderValueTransformFlipVertical:
                TransformInfo = JXFORM_FLIP_V;
                break;

            default:
                TransformInfo = JXFORM_NONE;
                break;
            }

            return DecodeForTransform();
        }
    }// Sink needs a transform

    // Initiate the decode process if this is the first time we're called

    hresult = CallBeginSink();
    if ( !SUCCEEDED(hresult) ) 
    {
        return hresult;
    }
    
    // For performance reason, we put the special decode for channle into a
    // separate routine

    if ( IsChannleView == TRUE )
    {
        return DecodeForChannel();
    }
    else if ( HasSetColorKeyRange == TRUE )
    {
        hresult = DecodeForColorKeyRange();

        // If DecodeForColorKeyRange succeed, return

        if ( hresult == S_OK )
        {
            return S_OK;
        }
    }

    // Normal decode

    __try
    {
        while ((CINFO).output_scanline < imageInfo.Height) 
        {
            if (jpeg_read_scanlines(&(CINFO), scanlineBuffer, 1) == 0)
            {
                // Something is wrong with the input stream
                // Get the last error from our jpeg_datasrc

                return (datasrc->GetLastError());
            }

            RECT currentRect;
            currentRect.left = 0;
            currentRect.right = imageInfo.Width;
            currentRect.bottom = (CINFO).output_scanline; // already advanced
            currentRect.top = currentRect.bottom - 1; 

            BitmapData bitmapData;
            hresult = decodeSink->GetPixelDataBuffer(&currentRect,
                                                     imageInfo.PixelFormat,
                                                     TRUE,
                                                     &bitmapData);
            if (!SUCCEEDED(hresult)) 
            {
                return hresult;
            }

            PBYTE pSource = scanlineBuffer[0];
            PBYTE pTarget = (PBYTE) bitmapData.Scan0;

            if (imageInfo.PixelFormat == PIXFMT_8BPP_INDEXED) 
            {
                // Copy from 8BPP indexed to 8BPP indexed

                ASSERT((CINFO).out_color_space == JCS_GRAYSCALE);
                GpMemcpy(pTarget, pSource, imageInfo.Width);
            }// 8 bpp
            else if (imageInfo.PixelFormat == PIXFMT_24BPP_RGB) 
            {
                if((CINFO).out_color_space == JCS_RGB)
                {
                    // Fixup the data from the JPEG RGB to our BGR format

                    for(UINT pixel=0; pixel<imageInfo.Width; pixel++)
                    {
                        pTarget[0] = pSource[2];
                        pTarget[1] = pSource[1];
                        pTarget[2] = pSource[0];
                        pSource += 3;
                        pTarget += 3;
                    }
                }// 24 bpp RGB
                else
                {
                    // Grayscale to 24BPP

                    for(UINT pixel=0; pixel<imageInfo.Width; pixel++)
                    {
                        BYTE sourceColor = pSource[0];
                        
                        pTarget[0] = sourceColor;
                        pTarget[1] = sourceColor;
                        pTarget[2] = sourceColor;
                        pSource += 1;
                        pTarget += 3;
                    }
                }
            }// 24 bpp
            else
            {
                // Must be one of our 32BPP formats

                if( ((CINFO).out_color_space == JCS_RGB)
                  ||((CINFO).out_color_space == JCS_CMYK) )
                {
                    for(UINT pixel=0; pixel<imageInfo.Width; pixel++)
                    {
                        pTarget[0] = pSource[2];
                        pTarget[1] = pSource[1];
                        pTarget[2] = pSource[0];
                        pTarget[3] = 0xff;
                        pSource += 3;
                        pTarget += 4;
                    }
                }// 32 bpp
                else
                {
                    // Grayscale to ARGB

                    for(UINT pixel=0; pixel<imageInfo.Width; pixel++)
                    {
                        BYTE sourceColor = pSource[0];
                        pTarget[0] = sourceColor;
                        pTarget[1] = sourceColor;
                        pTarget[2] = sourceColor;
                        pTarget[3] = 0xff;
                        pSource += 1;
                        pTarget += 4;
                    }
                }// Gray scale

            }// 32 bpp case

            hresult = decodeSink->ReleasePixelDataBuffer(&bitmapData);
            if (!SUCCEEDED(hresult)) 
            {
                return hresult;
            }
        }
        jpeg_finish_decompress(&(CINFO));
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hresult = E_FAIL;
    }

    return hresult;
}// Decode()

STDMETHODIMP
GpJpegDecoder::DecodeForColorKeyRange()
{
    HRESULT hResult;
    PBYTE   pBits = NULL;
    INT     index;
    
    BYTE    cRLower = (BYTE)((TransColorKeyLow & 0x00ff0000) >> 16);
    BYTE    cGLower = (BYTE)((TransColorKeyLow & 0x0000ff00) >> 8);
    BYTE    cBLower = (BYTE)(TransColorKeyLow  & 0x000000ff);
    BYTE    cRHigher = (BYTE)((TransColorKeyHigh & 0x00ff0000) >> 16);
    BYTE    cGHigher = (BYTE)((TransColorKeyHigh & 0x0000ff00) >> 8);
    BYTE    cBHigher = (BYTE)(TransColorKeyHigh  & 0x000000ff);
    
    BYTE    cTemp;

    // The dest must be 32 bpp
    
    if ( imageInfo.PixelFormat != PIXFMT_32BPP_ARGB )
    {
        return E_FAIL;
    }

    __try
    {
        while ((CINFO).output_scanline < imageInfo.Height) 
        {
            if (jpeg_read_scanlines(&(CINFO), scanlineBuffer, 1) == 0)
            {
                // Input stream is pending

                return (datasrc->GetLastError());
            }

            RECT currentRect;
            currentRect.left = 0;
            currentRect.right = imageInfo.Width;
            currentRect.bottom = (CINFO).output_scanline; // already advanced
            currentRect.top = currentRect.bottom - 1; 

            BitmapData bitmapData;
            hResult = decodeSink->GetPixelDataBuffer(&currentRect,
                                                     imageInfo.PixelFormat,
                                                     TRUE,
                                                     &bitmapData);
            if (!SUCCEEDED(hResult))
            {
                return hResult;
            }

            PBYTE pSource = scanlineBuffer[0];
            PBYTE pTarget = (PBYTE) bitmapData.Scan0;

            if ( (CINFO).out_color_space == JCS_RGB )
            {
                for (UINT pixel=0; pixel<imageInfo.Width; pixel++)
                {
                    BYTE    cR = pSource[0];
                    BYTE    cG = pSource[1];
                    BYTE    cB = pSource[2];

                    pTarget[2] = cR;
                    pTarget[1] = cG;
                    pTarget[0] = cB;

                    if ( (cR >= cRLower) && (cR <= cRHigher)
                       &&(cG >= cGLower) && (cG <= cGHigher)
                       &&(cB >= cBLower) && (cB <= cBHigher) )
                    {
                        pTarget[3] = 0x00;
                    }
                    else
                    {
                        pTarget[3] = 0xff;
                    }

                    pSource += 3;
                    pTarget += 4;
                }
            }// 32 bpp RGB
            else if ( (CINFO).out_color_space == JCS_CMYK )
            {
                for (UINT pixel=0; pixel<imageInfo.Width; pixel++)
                {
                    BYTE sourceColor = pSource[ChannelIndex];

                    pTarget[0] = sourceColor;
                    pTarget[1] = sourceColor;
                    pTarget[2] = sourceColor;
                    pTarget[3] = 0xff;
                    pSource += 4;
                    pTarget += 4;
                }
            }// 32 bpp CMYK
            else
            {
                // Grayscale to ARGB

                for (UINT pixel=0; pixel<imageInfo.Width; pixel++)
                {
                    BYTE sourceColor = pSource[0];
                    pTarget[0] = sourceColor;
                    pTarget[1] = sourceColor;
                    pTarget[2] = sourceColor;
                    pTarget[3] = 0xff;
                    pSource += 1;
                    pTarget += 4;
                }
            }// Gray scale

            hResult = decodeSink->ReleasePixelDataBuffer(&bitmapData);
            if (!SUCCEEDED(hResult))
            {
                return hResult;
            }
        }

        jpeg_finish_decompress(&(CINFO));
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hResult = E_FAIL;
    }

    return hResult;
}// DecodeForColorKeyRange()

STDMETHODIMP
GpJpegDecoder::DecodeForChannel()
{
    // Sanity check, we can't do CHANNEL_4 for an RGB image

    if ( ((CINFO).out_color_space == JCS_RGB) && (ChannelIndex == CHANNEL_4) )
    {
        return E_FAIL;
    }

    HRESULT hresult;
    PBYTE pBits = NULL;
    INT index;

    __try
    {
        while ((CINFO).output_scanline < imageInfo.Height) 
        {
            if (jpeg_read_scanlines(&(CINFO), scanlineBuffer, 1) == 0)
            {
                return (datasrc->GetLastError());
            }

            RECT currentRect;
            currentRect.left = 0;
            currentRect.right = imageInfo.Width;
            currentRect.bottom = (CINFO).output_scanline; // already advanced
            currentRect.top = currentRect.bottom - 1; 
                                        
            BitmapData bitmapData;
            hresult = decodeSink->GetPixelDataBuffer(&currentRect,
                                                     imageInfo.PixelFormat,
                                                     TRUE,
                                                     &bitmapData);
            if (!SUCCEEDED(hresult)) 
            {
                return hresult;
            }

            PBYTE pSource = scanlineBuffer[0];
            PBYTE pTarget = (PBYTE) bitmapData.Scan0;

            if (imageInfo.PixelFormat == PIXFMT_8BPP_INDEXED) 
            {
                // Copy from 8BPP indexed to 8BPP indexed

                ASSERT((CINFO).out_color_space == JCS_GRAYSCALE);
                GpMemcpy(pTarget, pSource, imageInfo.Width);
            }// 8 bpp
            else if (imageInfo.PixelFormat == PIXFMT_24BPP_RGB) 
            {
                if((CINFO).out_color_space == JCS_RGB)
                {
                    // Fixup the data from the JPEG RGB to our BGR format

                    if ( CHANNEL_LUMINANCE == ChannelIndex )
                    {
                        //
                        // There are two ways to convert an RGB pixel to
                        // luminance:
                        // a)Giving different weights on R,G,B channels as
                        // the fomular below.
                        // b) Using the same weight.
                        // Method a) is better and standard when viewing an
                        // result image. While method b) is fast. For now we
                        // are using method b) unless there is someone asks
                        // for high quality
                        //
                        // a) luminance = 0.2125*r + 0.7154*g + 0.0721*b;

                        for (UINT pixel=0; pixel<imageInfo.Width; pixel++)
                        {
                            BYTE luminance = (BYTE)(( pSource[0]
                                                      + pSource[1]
                                                      + pSource[2]) / 3.0);

                            pTarget[0] = luminance;
                            pTarget[1] = luminance;
                            pTarget[2] = luminance;
                            pSource += 3;
                            pTarget += 3;
                        }
                    }// Extract luminance from 24 bpp RGB
                    else
                    {
                        for (UINT pixel=0; pixel<imageInfo.Width; pixel++)
                        {
                            BYTE    sourceColor = pSource[ChannelIndex];

                            pTarget[0] = sourceColor;
                            pTarget[1] = sourceColor;
                            pTarget[2] = sourceColor;
                            pSource += 3;
                            pTarget += 3;
                        }
                    }
                }// 24 bpp RGB
                else
                {
                    // Grayscale to 24BPP

                    for(UINT pixel=0; pixel<imageInfo.Width; pixel++)
                    {
                        BYTE sourceColor = pSource[0];

                        pTarget[0] = sourceColor;
                        pTarget[1] = sourceColor;
                        pTarget[2] = sourceColor;
                        pSource += 1;
                        pTarget += 3;
                    }
                }// 24 bpp gray scale
            }// 24 bpp
            else
            {
                // Must be one of our 32BPP formats

                if( (CINFO).out_color_space == JCS_RGB )
                {
                    if ( CHANNEL_LUMINANCE == ChannelIndex )
                    {
                        for (UINT pixel=0; pixel<imageInfo.Width; pixel++)
                        {
                            BYTE luminance = (BYTE)(( pSource[0]
                                                      + pSource[1]
                                                      + pSource[2]) / 3.0);

                            pTarget[0] = luminance;
                            pTarget[1] = luminance;
                            pTarget[2] = luminance;
                            pTarget[3] = 0xff;
                            pSource += 3;
                            pTarget += 4;
                        }
                    }// 32 BPP luminance output
                    else
                    {
                        for (UINT pixel=0; pixel<imageInfo.Width; pixel++)
                        {
                            BYTE sourceColor = pSource[ChannelIndex];

                            pTarget[0] = sourceColor;
                            pTarget[1] = sourceColor;
                            pTarget[2] = sourceColor;
                            pTarget[3] = 0xff;
                            pSource += 3;
                            pTarget += 4;
                        }
                    }// 32 bpp channel output
                }// 32 bpp RGB
                else if ( (CINFO).out_color_space == JCS_CMYK )
                {
                    if ( CHANNEL_LUMINANCE == ChannelIndex )
                    {
                        for (UINT pixel=0; pixel<imageInfo.Width; pixel++)
                        {
                            BYTE luminance = (BYTE)(( 765       // 3 * 255
                                                      - pSource[0]
                                                      - pSource[1]
                                                      - pSource[2]) / 3.0);

                            pTarget[0] = luminance;
                            pTarget[1] = luminance;
                            pTarget[2] = luminance;
                            pTarget[3] = 0xff;
                            pSource += 4;
                            pTarget += 4;
                        }
                    }// 32 BPP CMYK Luminance
                    else
                    {
                        for (UINT pixel=0; pixel<imageInfo.Width; pixel++)
                        {
                            BYTE sourceColor = pSource[ChannelIndex];

                            pTarget[0] = sourceColor;
                            pTarget[1] = sourceColor;
                            pTarget[2] = sourceColor;
                            pTarget[3] = 0xff;
                            pSource += 4;
                            pTarget += 4;
                        }
                    }// 32 BPP channel output
                }// 32 bpp CMYK
                else
                {
                    // Grayscale to ARGB

                    for(UINT pixel=0; pixel<imageInfo.Width; pixel++)
                    {
                        BYTE sourceColor = pSource[0];
                        pTarget[0] = sourceColor;
                        pTarget[1] = sourceColor;
                        pTarget[2] = sourceColor;
                        pTarget[3] = 0xff;
                        pSource += 1;
                        pTarget += 4;
                    }
                }// Gray scale
            }// 32 bpp case

            hresult = decodeSink->ReleasePixelDataBuffer(&bitmapData);
            if (!SUCCEEDED(hresult)) 
            {
                return hresult;
            }
        }

        jpeg_finish_decompress(&(CINFO));
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hresult = E_FAIL;
    }

    return hresult;
}// DecodeForChannle()

/**************************************************************************\
*
* Function Description:
*
*   Applying a source image transformation and save it.
*   
*   This method is called if and only if we know the sink is the JPEG encoder.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpJpegDecoder::DecodeForTransform(
    )
{
    HRESULT hResult = S_OK;

    // Check if we have called jpeg_read_header already. If yes, we would
    // reset it back

    if ( bCalled_jpeg_read_header )
    {
        bReinitializeJpeg = TRUE;
        hResult = ReinitializeJpeg();
        if ( FAILED(hResult) )
        {
            WARNING(("JpegDec::DecodeForTransform-ReinitializeJpeg failed"));
            return hResult;
        }
    }

    // We need to copy all the APP headers. So we use JCOPYOPT_ALL here

    jtransformation_markers_setup(&(CINFO), JCOPYOPT_ALL);

    // After we set the markers, it's better to reset the stream pointer to
    // the beginning. Otherwise, we might hit exception when we do
    // jpeg_read_header() below

    hResult = ReinitializeJpeg();
    if (FAILED(hResult))
    {
        WARNING(("JpegDec::DecodeForTransform-ReinitializeJpeg failed"));
        return hResult;
    }

    // Either the image property item have been changed or the image needs a
    // lossless transform, write out the APP1 header ourselves.

    if ((HasPropertyChanged == TRUE) || (TransformInfo != JXFORM_NONE))
    {
        UINT    uiNewWidth = 0;
        UINT    uiNewHeight = 0;
        UINT    uiOldWidth = 0;
        UINT    uiOldHeight = 0;

        // Check if we can trim the edge or not

        if ( CanTrimEdge == TRUE )
        {
            // Need to call a service routine to see if we need to trim the edge
            // or not. If yes, GetPropertyItem() and set it. Then restore it
            // back after PushPropertyIetm call

            GetNewDimensionValuesForTrim(&(CINFO), TransformInfo, &uiNewWidth,
                                         &uiNewHeight);

            // If no change is needed, the above function will set uiNewWidth or
            // uiNewHeight to the original width or height. So we don't need to
            // do anything if the return value is zero or equals the original
            // size

            if ( (uiNewWidth != 0) && (uiNewWidth != (CINFO).image_width) )
            {
                hResult = ChangePropertyValue(EXIF_TAG_PIX_X_DIM, uiNewWidth,
                                              &uiOldWidth);
                if ( FAILED(hResult) )
                {
                    WARNING(("Jpeg::DecodeForTrans-ChgPropertyValue() failed"));
                    return hResult;
                }
            }

            if ( (uiNewHeight != 0) && (uiNewHeight != (CINFO).image_height) )
            {
                hResult = ChangePropertyValue(EXIF_TAG_PIX_Y_DIM, uiNewHeight,
                                              &uiOldHeight);
                if ( FAILED(hResult) )
                {
                    WARNING(("Jpeg::DecodeForTrans-ChgPropertyValue() failed"));
                    return hResult;
                }
            }
        }// (CanTrimEdge == TRUE)
        
        if (PropertyNumOfItems > 0)
        {
            // Property items have been changed. So we have to save the updated info
            // into the new file. Push the raw header into the sink first

            UINT    uiTotalBufferSize = PropertyListSize +
                                        PropertyNumOfItems * sizeof(PropertyItem);
            PropertyItem*   pBuffer = NULL;
            hResult = decodeSink->GetPropertyBuffer(uiTotalBufferSize,&pBuffer);

            if ( (hResult != S_OK) && (hResult != E_NOTIMPL) )
            {
                WARNING(("GpJpeg::DecodeForTransform--GetPropertyBuffer() failed"));
                return hResult;
            }

            hResult = GetAllPropertyItems(uiTotalBufferSize,
                                          PropertyNumOfItems,
                                          pBuffer);
            if ( hResult != S_OK )
            {
                WARNING(("Jpeg::DecodeForTransform-GetAllPropertyItems() failed"));
                return hResult;
            }

            hResult = decodeSink->PushPropertyItems(PropertyNumOfItems,
                                                    uiTotalBufferSize,
                                                    pBuffer,
                                                    HasSetICCProperty);

            if ( FAILED(hResult) )
            {
                WARNING(("GpJpeg::DecodeForTransform-PushPropertyItems() failed"));
                return hResult;
            }
        }

        // We need to check if we have changed dimension values of the image due
        // to trim edge

        if ( CanTrimEdge == TRUE )
        {
            // We have to restore the image property info in current image if we
            // have changed them above

            if ( uiOldWidth != 0 )
            {
                // Note: here the 3rd parameter uiOldWidth is just a dummy. We
                // don't need it any more

                hResult = ChangePropertyValue(EXIF_TAG_PIX_X_DIM,
                                              (CINFO).image_width,
                                              &uiOldWidth);
                if ( FAILED(hResult) )
                {
                    WARNING(("Jpeg::DecodeForTrans-ChgPropertyValue() failed"));
                    return hResult;
                }
            }

            if ( uiOldHeight != 0 )
            {
                // Note: here the 3rd parameter uiOldHeight is just a dummy. We
                // don't need it any more

                hResult = ChangePropertyValue(EXIF_TAG_PIX_Y_DIM,
                                              (CINFO).image_height,
                                              &uiOldHeight);
                if ( FAILED(hResult) )
                {
                    WARNING(("Jpeg::DecodeForTrans-ChgPropertyValue() failed"));
                    return hResult;
                }
            }
        }// (CanTrimEdge == TRUE)

        if ( bCalled_jpeg_read_header )
        {
            bReinitializeJpeg = TRUE;
            hResult = ReinitializeJpeg();
            if ( FAILED(hResult) )
            {
                WARNING(("JpegDec::DecodeForTransform-ReinitializeJpeg failed"));
                return hResult;
            }
        }
    }// Property has changed
    
    // Read the jpeg header

    __try
    {
        if (jpeg_read_header(&(CINFO), TRUE) == JPEG_SUSPENDED)
        {
            WARNING(("JpgDec::DecodeForTransform-jpeg_read_header failed"));
            return (datasrc->GetLastError());
        }

        bCalled_jpeg_read_header = TRUE;
    
        UnsetMarkerProcessors();        
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING(("GpJpegDecoder::DecodeForTransform-Hit exception 1"));
        return E_FAIL;
    }
        
    // Push the source information into the sink

    hResult = decodeSink->PushRawInfo(&(CINFO));

    if ( FAILED(hResult) )
    {
        WARNING(("GpJpegDecoder::DecodeForTransform---PushRawInfo() failed"));
        return hResult;
    }

    __try
    {
        jpeg_finish_decompress(&(CINFO));    
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING(("GpJpegDecoder::DecodeForTransform-Hit exception 2"));
        return E_FAIL;
    }

    return S_OK;
}// DecodeForTransform()

/**************************************************************************\
*
* Function Description:
*
*     Get the total number of dimensions the image supports
*
* Arguments:
*
*     count -- number of dimensions this image format supports
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpJpegDecoder::GetFrameDimensionsCount(
    UINT* count
    )
{
    if ( count == NULL )
    {
        WARNING(("JpegDecoder::GetFrameDimensionsCount--Invalid input parameter"));
        return E_INVALIDARG;
    }
    
    // Tell the caller that JPEG is a one dimension image.

    *count = 1;

    return S_OK;
}// GetFrameDimensionsCount()

/**************************************************************************\
*
* Function Description:
*
*     Get an ID list of dimensions the image supports
*
* Arguments:
*
*     dimensionIDs---Memory buffer to hold the result ID list
*     count -- number of dimensions this image format supports
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpJpegDecoder::GetFrameDimensionsList(
    GUID*   dimensionIDs,
    UINT    count
    )
{
    if ( (count != 1) || (dimensionIDs == NULL) )
    {
        WARNING(("GpJpegDecoder::GetFrameDimensionsList-Invalid input param"));
        return E_INVALIDARG;
    }

    dimensionIDs[0] = FRAMEDIM_PAGE;

    return S_OK;
}// GetFrameDimensionsList()

/**************************************************************************\
*
* Function Description:
*
*     Get number of frames for the specified dimension
*     
* Arguments:
*
*     dimensionID --
*     count --     
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpJpegDecoder::GetFrameCount(
    IN const GUID* dimensionID,
    OUT UINT* count
    )
{
    if (count && (*dimensionID == FRAMEDIM_PAGE) )
    {
        *count = 1;
    }
    else
    {
        return E_INVALIDARG;
    }

    return S_OK;
}// GetFrameCount()

/**************************************************************************\
*
* Function Description:
*
*     Select currently active frame
*     
* Arguments:
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpJpegDecoder::SelectActiveFrame(
    IN const GUID* dimensionID,
    IN UINT frameIndex
    )
{
    if ( (dimensionID == NULL) || (*dimensionID != FRAMEDIM_PAGE) )
    {
        WARNING(("GpJpegDecoder::SelectActiveFrame--Invalid GUID input"));
        return E_INVALIDARG;
    }

    if ( frameIndex > 1 )
    {
        // JPEG is a single frame image format

        WARNING(("GpJpegDecoder::SelectActiveFrame--Invalid frame index"));
        return E_INVALIDARG;
    }

    return S_OK;
}// SelectActiveFrame()

/**************************************************************************\
*
* Function Description:
*
*     Reads a jpeg marker from the JPEG stream, and store it in ppBuffer.
*     The length of the marker is specified in the first two bytes of
*     the marker.
*
*     Note:  *ppBuffer will need to be freed by the caller if this function
*     succeeds (returns TRUE)!
*     
* Arguments:
*
*     cinfo - a pointer to the jpeg state
*     app_header - the code indicating which app marker we're reading
*     ppBuffer - the jpeg marker.  Note that the data returned will be
*         in the form:  app_header(two bytes), size(two bytes), data
*     pLength - will receive the length of *ppBuffer.
*
* Return Value:
*
*   TRUE upon success, FALSE otherwise
*
\**************************************************************************/

BOOL
GpJpegDecoder::read_jpeg_marker(
    IN j_decompress_ptr cinfo,
    IN SHORT app_header,
    OUT VOID **ppBuffer,
    OUT UINT16 *pLength
    )
{
    VOID *pBuffer;
    UINT16 length;

    INPUT_VARS(cinfo);
    INPUT_2BYTES(cinfo, length, return FALSE);
    INPUT_SYNC(cinfo);     
    
    *pLength = length+2;
    pBuffer = GpMalloc(length+2); // Add space for header type
    if ( pBuffer == NULL ) 
    {
        WARNING(("Out of memory in read_jpeg_marker"));
        return FALSE;
    }

    ((PSHORT) pBuffer) [0] = app_header;
    ((PSHORT) pBuffer) [1] = length;

    PBYTE p = ((PBYTE) pBuffer) + 4;
    INT   l = length - 2;
    while (l) 
    {
        if ((INT) cinfo->src->bytes_in_buffer > l)
        {
            // More than enough bytes in buffer

            GpMemcpy(p, cinfo->src->next_input_byte, l);
            cinfo->src->next_input_byte += l;
            cinfo->src->bytes_in_buffer -= l;
            p += l;
            l = 0;
        }
        else
        {
            if (cinfo->src->bytes_in_buffer) 
            {
                GpMemcpy(p, 
                    cinfo->src->next_input_byte, 
                    cinfo->src->bytes_in_buffer);
                l -= cinfo->src->bytes_in_buffer;
                p += cinfo->src->bytes_in_buffer;
                cinfo->src->next_input_byte += cinfo->src->bytes_in_buffer;
                cinfo->src->bytes_in_buffer = 0;
            }
        
            if (!cinfo->src->fill_input_buffer(cinfo))
            {
                GpFree(pBuffer);
                return FALSE;
            }
        }
    }

    *ppBuffer = pBuffer;  // will be freed by the caller!
    return TRUE;
}


// The following macro defines a c callback function for an APP header

#define JPEG_MARKER_PROCESSOR(x) \
boolean jpeg_marker_processor_APP##x (j_decompress_ptr cinfo) \
{return ((GpJpegDecoder *) (cinfo))->jpeg_marker_processor(cinfo,x + JPEG_APP0); }

// Let's emit the callback macros for all app headers except for 0 and 14 (these
// are handled by the jpeg code).  These callback functions call the
// jpeg_marker_processor method with the appropriate callback code.

JPEG_MARKER_PROCESSOR(1)
JPEG_MARKER_PROCESSOR(2)
JPEG_MARKER_PROCESSOR(3)
JPEG_MARKER_PROCESSOR(4)
JPEG_MARKER_PROCESSOR(5)
JPEG_MARKER_PROCESSOR(6)
JPEG_MARKER_PROCESSOR(7)
JPEG_MARKER_PROCESSOR(8)
JPEG_MARKER_PROCESSOR(9)
JPEG_MARKER_PROCESSOR(10)
JPEG_MARKER_PROCESSOR(11)
JPEG_MARKER_PROCESSOR(12)
JPEG_MARKER_PROCESSOR(13)
JPEG_MARKER_PROCESSOR(15)

// Now let's define a callback for the COM header

boolean jpeg_marker_processor_COM(j_decompress_ptr cinfo)
{
    return ((GpJpegDecoder *) (cinfo))->jpeg_marker_processor(cinfo, JPEG_COM);
}

// Marker reading & parsing

#include "jpegint.h"

/* Private state */

typedef struct {
  struct jpeg_marker_reader pub; /* public fields */

  /* Application-overridable marker processing methods */
  jpeg_marker_parser_method process_COM;
  jpeg_marker_parser_method process_APPn[16];

  /* Limit on marker data length to save for each marker type */
  unsigned int length_limit_COM;
  unsigned int length_limit_APPn[16];

  /* Status of COM/APPn marker saving */
  jpeg_saved_marker_ptr cur_marker; /* NULL if not processing a marker */
  unsigned int bytes_read;      /* data bytes read so far in marker */
  /* Note: cur_marker is not linked into marker_list until it's all read. */
} my_marker_reader;

typedef my_marker_reader * my_marker_ptr;

typedef enum {          /* JPEG marker codes */
  M_SOF0  = 0xc0,
  M_SOF1  = 0xc1,
  M_SOF2  = 0xc2,
  M_SOF3  = 0xc3,
  
  M_SOF5  = 0xc5,
  M_SOF6  = 0xc6,
  M_SOF7  = 0xc7,
  
  M_JPG   = 0xc8,
  M_SOF9  = 0xc9,
  M_SOF10 = 0xca,
  M_SOF11 = 0xcb,
  
  M_SOF13 = 0xcd,
  M_SOF14 = 0xce,
  M_SOF15 = 0xcf,
  
  M_DHT   = 0xc4,
  
  M_DAC   = 0xcc,
  
  M_RST0  = 0xd0,
  M_RST1  = 0xd1,
  M_RST2  = 0xd2,
  M_RST3  = 0xd3,
  M_RST4  = 0xd4,
  M_RST5  = 0xd5,
  M_RST6  = 0xd6,
  M_RST7  = 0xd7,
  
  M_SOI   = 0xd8,
  M_EOI   = 0xd9,
  M_SOS   = 0xda,
  M_DQT   = 0xdb,
  M_DNL   = 0xdc,
  M_DRI   = 0xdd,
  M_DHP   = 0xde,
  M_EXP   = 0xdf,
  
  M_APP0  = 0xe0,
  M_APP1  = 0xe1,
  M_APP2  = 0xe2,
  M_APP3  = 0xe3,
  M_APP4  = 0xe4,
  M_APP5  = 0xe5,
  M_APP6  = 0xe6,
  M_APP7  = 0xe7,
  M_APP8  = 0xe8,
  M_APP9  = 0xe9,
  M_APP10 = 0xea,
  M_APP11 = 0xeb,
  M_APP12 = 0xec,
  M_APP13 = 0xed,
  M_APP14 = 0xee,
  M_APP15 = 0xef,
  
  M_JPG0  = 0xf0,
  M_JPG13 = 0xfd,
  M_COM   = 0xfe,
  
  M_TEM   = 0x01,
  
  M_ERROR = 0x100
} JPEG_MARKER;

#define APP0_DATA_LEN   14  /* Length of interesting data in APP0 */
#define APP14_DATA_LEN  12  /* Length of interesting data in APP14 */
#define APPN_DATA_LEN   14  /* Must be the largest of the above!! */

/* Examine first few bytes from an APP0.
 * Take appropriate action if it is a JFIF marker.
 * datalen is # of bytes at data[], remaining is length of rest of marker data.
 */
LOCAL(void)
save_app0_marker(
    j_decompress_ptr    cinfo,
    JOCTET FAR*         data,
    unsigned int        datalen,
    INT32               remaining
    )
{
    INT32 totallen = (INT32) datalen + remaining;

    if ( (datalen >= APP0_DATA_LEN)
       &&(GETJOCTET(data[0]) == 0x4A)
       &&(GETJOCTET(data[1]) == 0x46)
       &&(GETJOCTET(data[2]) == 0x49)
       &&(GETJOCTET(data[3]) == 0x46)
       &&(GETJOCTET(data[4]) == 0) )
    {
        // Found JFIF APP0 marker: save info

        cinfo->saw_JFIF_marker = TRUE;
        cinfo->JFIF_major_version = GETJOCTET(data[5]);
        cinfo->JFIF_minor_version = GETJOCTET(data[6]);
        cinfo->density_unit = GETJOCTET(data[7]);
        cinfo->X_density = (GETJOCTET(data[8]) << 8) + GETJOCTET(data[9]);
        cinfo->Y_density = (GETJOCTET(data[10]) << 8) + GETJOCTET(data[11]);

        // Check version.
        // Major version must be 1, anything else signals an incompatible change.
        // (We used to treat this as an error, but now it's a nonfatal warning,
        // because some person at Hijaak couldn't read the spec.)
        // Minor version should be 0..2, but process anyway if newer.
        
        if ( cinfo->JFIF_major_version != 1 )
        {
            WARNING(("unknown JFIF revision number %d.%02d",
                     cinfo->JFIF_major_version, cinfo->JFIF_minor_version));
        }

        // Validate thumbnail dimensions and issue appropriate messages

        if ( GETJOCTET(data[12]) | GETJOCTET(data[13]) )
        {
            VERBOSE(("With %d x %d thumbnail image",
                     GETJOCTET(data[12]), GETJOCTET(data[13])));
        }

        totallen -= APP0_DATA_LEN;
        if ( totallen !=
            ((INT32)GETJOCTET(data[12]) * (INT32)GETJOCTET(data[13])*(INT32)3))
        {
            WARNING(("Bad thumbnail size %d", (int)totallen));
        }
    }
    else if ( (datalen >= 6)
            &&(GETJOCTET(data[0]) == 0x4A)
            &&(GETJOCTET(data[1]) == 0x46)
            &&(GETJOCTET(data[2]) == 0x58)
            &&(GETJOCTET(data[3]) == 0x58)
            &&(GETJOCTET(data[4]) == 0) )
    {
        // Found JFIF "JFXX" extension APP0 marker
        // The library doesn't actually do anything with these,
        // but we try to produce a helpful trace message.

        switch ( GETJOCTET(data[5]) )
        {
        case 0x10:
            VERBOSE(("JTRC_THUMB_JPEG %d", (int)totallen));
            break;

        case 0x11:
            VERBOSE(("JTRC_THUMB_PALETTE %d", (int)totallen));
            break;

        case 0x13:
            VERBOSE(("JTRC_THUMB_RGB %d", (int)totallen));
            break;

        default:
            VERBOSE(("JTRC_JFIF_EXTENSION %d",
                     GETJOCTET(data[5]), (int)totallen));
            break;
        }
    }
    else
    {
        // Start of APP0 does not match "JFIF" or "JFXX", or too short

        VERBOSE(("JTRC_APP0 %d", (int)totallen));
    }
}// save_app0_marker()

/* Examine first few bytes from an APP14.
 * Take appropriate action if it is an Adobe marker.
 * datalen is # of bytes at data[], remaining is length of rest of marker data.
 */
LOCAL(void)
save_app14_marker(
    j_decompress_ptr    cinfo,
    JOCTET FAR *        data,
    unsigned int        datalen,
    INT32               remaining
    )
{
    unsigned int version, flags0, flags1, transform;

    if ( (datalen >= APP14_DATA_LEN)
       &&(GETJOCTET(data[0]) == 0x41)
       &&(GETJOCTET(data[1]) == 0x64)
       &&(GETJOCTET(data[2]) == 0x6F)
       &&(GETJOCTET(data[3]) == 0x62)
       &&(GETJOCTET(data[4]) == 0x65) )
    {
        // Found Adobe APP14 marker

        version = (GETJOCTET(data[5]) << 8) + GETJOCTET(data[6]);
        flags0 = (GETJOCTET(data[7]) << 8) + GETJOCTET(data[8]);
        flags1 = (GETJOCTET(data[9]) << 8) + GETJOCTET(data[10]);
        transform = GETJOCTET(data[11]);
        
        cinfo->saw_Adobe_marker = TRUE;
        cinfo->Adobe_transform = (UINT8) transform;
    }
    else
    {
        // Start of APP14 does not match "Adobe", or too short
    }
}// save_app14_marker()

/**************************************************************************\
*
* Function Description:
*
*   Given an input j_decompress_structure, this function figures out if we
*   can do lossless transformation without trimming the right edge. If yes, this
*   function returns the original image width. If not, then it returns a new
*   trimmed width value so that we can do lossles rotation
*
* Arguments:
*
*     cinfo - a pointer to the jpeg state
*
* Return Value:
*
*   The width which we can do a lossless rotation
*
\**************************************************************************/

UINT
NeedTrimRightEdge(
    j_decompress_ptr cinfo
    )
{
    int     max_h_samp_factor = 1;
    int     h_samp_factor = 0;
    UINT    uiWidth = cinfo->image_width;

    int* pSrc = ((GpJpegDecoder*)(cinfo))->jpeg_get_hSampFactor();
    
    for ( int ci = 0; ci < cinfo->comps_in_scan; ++ci)
    {
        h_samp_factor = pSrc[ci];

        if ( max_h_samp_factor < h_samp_factor )
        {
            max_h_samp_factor = h_samp_factor;
        }
    }
    
    JDIMENSION  MCU_cols = cinfo->image_width / (max_h_samp_factor * DCTSIZE);
    
    if ( MCU_cols > 0 )     // Can't trim to 0 pixels
    {
        uiWidth = MCU_cols * (max_h_samp_factor * DCTSIZE);
    }

    return uiWidth;
}// NeedTrimRightEdge()

UINT
NeedTrimBottomEdge(
    j_decompress_ptr cinfo
    )
{
    int     max_v_samp_factor = 1;
    int     v_samp_factor = 0;
    UINT    uiHeight = cinfo->image_height;

    int* pSrc = ((GpJpegDecoder*)(cinfo))->jpeg_get_vSampFactor();
    
    for ( int ci = 0; ci < cinfo->comps_in_scan; ++ci )
    {
        v_samp_factor = pSrc[ci];

        if ( max_v_samp_factor < v_samp_factor )
        {
            max_v_samp_factor = v_samp_factor;
        }
    }

    JDIMENSION MCU_rows = cinfo->image_height / (max_v_samp_factor * DCTSIZE);

    if ( MCU_rows > 0 )     // Can't trim to 0 pixels
    {
        uiHeight = MCU_rows * (max_v_samp_factor * DCTSIZE);
    }
    
    return uiHeight;
}// NeedTrimBottomEdge()

void
GetNewDimensionValuesForTrim(
    j_decompress_ptr    cinfo,
    UINT                uiTransform,
    UINT*               puiNewWidth,
    UINT*               puiNewHeight
    )
{
    UINT    uiNewWidth = 0;
    UINT    uiNewHeight = 0;

    switch ( uiTransform )
    {
    case JXFORM_ROT_90:
    case JXFORM_FLIP_H:
        uiNewHeight = NeedTrimBottomEdge(cinfo);
        break;

    case JXFORM_ROT_270:
    case JXFORM_FLIP_V:
        uiNewWidth = NeedTrimRightEdge(cinfo);
        break;

    case JXFORM_ROT_180:
        uiNewHeight = NeedTrimBottomEdge(cinfo);
        uiNewWidth = NeedTrimRightEdge(cinfo);
        break;

    default:
        // Do nothing
        break;
    }

    *puiNewWidth = uiNewWidth;
    *puiNewHeight = uiNewHeight;

    return;
}// GetNewDimensionValuesForTrim()

METHODDEF(boolean)
save_marker_all(j_decompress_ptr cinfo)
{
    my_marker_ptr           marker = (my_marker_ptr)cinfo->marker;
    jpeg_saved_marker_ptr   cur_marker = marker->cur_marker;
    UINT bytes_read, data_length;
    BYTE* data;
    UINT uiTransform;
    UINT  uiNewWidth = 0;
    UINT  uiNewHeight = 0;
    INT32 length = 0;
    INPUT_VARS(cinfo);

    if (cur_marker == NULL)
    {
        /* begin reading a marker */
        
        INPUT_2BYTES(cinfo, length, return FALSE);
        length -= 2;
        if (length >= 0)
        {   
            /* watch out for bogus length word */
            /* figure out how much we want to save */
            
            UINT limit;
            if (cinfo->unread_marker == (int) M_COM)
            {
                limit = marker->length_limit_COM;
            }
            else
            {
                limit = marker->length_limit_APPn[cinfo->unread_marker
                                                  - (int) M_APP0];
            }

            if ((UINT) length < limit)
            {
                limit = (UINT) length;
            }

            /* allocate and initialize the marker item */
            
            cur_marker = (jpeg_saved_marker_ptr)
                         (*cinfo->mem->alloc_large)((j_common_ptr)cinfo,
                                                    JPOOL_IMAGE,
                                              sizeof(struct jpeg_marker_struct)
                                                    + limit);
            cur_marker->next = NULL;
            cur_marker->marker = (UINT8) cinfo->unread_marker;
            cur_marker->original_length = (UINT) length;
            cur_marker->data_length = limit;

            /* data area is just beyond the jpeg_marker_struct */
            
            data = cur_marker->data = (BYTE*)(cur_marker + 1);
            marker->cur_marker = cur_marker;
            marker->bytes_read = 0;
            bytes_read = 0;
            data_length = limit;
        }
        else
        {
            /* deal with bogus length word */
            
            bytes_read = data_length = 0;
            data = NULL;
        }
    }
    else
    {
        /* resume reading a marker */
        
        bytes_read = marker->bytes_read;
        data_length = cur_marker->data_length;
        data = cur_marker->data + bytes_read;
    }

    while (bytes_read < data_length)
    {
        INPUT_SYNC(cinfo);      /* move the restart point to here */
        marker->bytes_read = bytes_read;
        
        /* If there's not at least one byte in buffer, suspend */
        
        MAKE_BYTE_AVAIL(cinfo, return FALSE);
        
        /* Copy bytes with reasonable rapidity */
        
        while (bytes_read < data_length && bytes_in_buffer > 0)
        {
            *data++ = *next_input_byte++;
            bytes_in_buffer--;
            bytes_read++;
        }
    }

    /* Done reading what we want to read */
    
    if (cur_marker != NULL)
    {
        /* will be NULL if bogus length word */
        /* Add new marker to end of list */
        
        if (cinfo->marker_list == NULL)
        {
            cinfo->marker_list = cur_marker;
        }
        else
        {
            jpeg_saved_marker_ptr prev = cinfo->marker_list;
            while (prev->next != NULL)
                prev = prev->next;
            prev->next = cur_marker;
        }
        
        /* Reset pointer & calc remaining data length */
        
        data = cur_marker->data;
        length = cur_marker->original_length - data_length;
    }

    /* Reset to initial state for next marker */
    
    marker->cur_marker = NULL;

    /* Process the marker if interesting; else just make a generic trace msg */
    
    switch (cinfo->unread_marker)
    {
    case M_APP0:
        save_app0_marker(cinfo, data, data_length, length);
        break;
    
    case M_APP1:
        // APP1 header
        // First, get the transformation info and pass it down

        uiTransform = ((GpJpegDecoder*)(cinfo))->jpeg_get_current_xform();

        // Check if the user wants us to trim the edge or not

        if ( ((GpJpegDecoder*)(cinfo))->jpeg_get_trim_option() == TRUE )
        {
            // Get the destination's image dimensions etc if we have to trim it

            GetNewDimensionValuesForTrim(cinfo, uiTransform, &uiNewWidth,
                                         &uiNewHeight);

            // We don't need to do any size adjustment if the new size and
            // existing size is the same

            if ( uiNewWidth == cinfo->image_width )
            {
                uiNewWidth = 0;
            }
        
            if ( uiNewHeight == cinfo->image_height )
            {
                uiNewHeight = 0;
            }
        }

        TransformApp1(data, (UINT16)data_length, uiTransform, uiNewWidth,
                      uiNewHeight);

        break;

    case M_APP13:
        // APP13 header
        // Note: No need to send transformation info to APP13 since it doesn't
        // store dimension info

        TransformApp13(data, (UINT16)data_length);

        break;

    case M_APP14:
        save_app14_marker(cinfo, data, data_length, length);
        break;
    
    default:
        WARNING(("Unknown marker %d length=%d", cinfo->unread_marker,
                (int) (data_length + length)));
        break;
    }

    /* skip any remaining data -- could be lots */
    
    INPUT_SYNC(cinfo);        /* do before skip_input_data */
    if (length > 0)
        (*cinfo->src->skip_input_data) (cinfo, (long) length);

    return TRUE;
}// save_marker_all()

STDMETHODIMP
GpJpegDecoder::jtransformation_markers_setup(
    j_decompress_ptr    srcinfo,
    JCOPY_OPTION        option
    )
{
    // Save comments except under NONE option

    if ( option != JCOPYOPT_NONE)
    {
        jpeg_save_markers(srcinfo, JPEG_COM, 0xFFFF);
    }

    // Save all types of APPn markers iff ALL option

    if ( option == JCOPYOPT_ALL )
    {
        for ( int i = 0; i < 16; ++i )
        {
            jpeg_save_markers(srcinfo, JPEG_APP0 + i, 0xFFFF);
        }
    }

    return S_OK;
}// jtransformation_markers_setup()

/**************************************************************************\
*
* Function Description:
*
*     Processes a jpeg marker.  read_jpeg_marker is a helper function
*     that actually reads marker data.  The marker is then added to
*     the property set storage, and exif data in an app1 header is
*     parsed and placed in the standard imaging property set.
*     
* Arguments:
*
*     cinfo - a pointer to the jpeg state
*     app_header - the code indicating which app marker we're reading
*
* Return Value:
*
*   TRUE upon success, FALSE otherwise
*
\**************************************************************************/

BOOL
GpJpegDecoder::jpeg_marker_processor(
    j_decompress_ptr cinfo,
    SHORT app_header
    )
{
    return TRUE;
}

// jpeg_thumbnail_processor_APP1 is a callback from the JPEG code that
// calls the jpeg_thumbnail_processor method.

boolean
jpeg_thumbnail_processor_APP1(j_decompress_ptr cinfo)
{
    return ((GpJpegDecoder *) (cinfo))->jpeg_thumbnail_processor(cinfo, 
        JPEG_APP0 + 1);
}

// jpeg_thumbnail_processor_APP13 is a callback from the JPEG code that
// calls the jpeg_thumbnail_processor method.

boolean
jpeg_thumbnail_processor_APP13(
    j_decompress_ptr cinfo
    )
{
    return ((GpJpegDecoder*)(cinfo))->jpeg_thumbnail_processor(cinfo, 
                                                             JPEG_APP0 + 13);
}// jpeg_thumbnail_processor_APP13()

// jpeg_property_processor_APP1 is a callback from the JPEG code that
// calls the jpeg_property_processor method.

boolean
jpeg_property_processor_APP1(j_decompress_ptr cinfo)
{
    return ((GpJpegDecoder*)(cinfo))->jpeg_property_processor(cinfo, 
                                                              JPEG_APP0 + 1);
}// jpeg_property_processor_APP1()

// jpeg_property_processor_APP2 is a callback from the JPEG code that
// calls the jpeg_property_processor method.

boolean
jpeg_property_processor_APP2(j_decompress_ptr cinfo)
{
    return ((GpJpegDecoder*)(cinfo))->jpeg_property_processor(cinfo, 
                                                              JPEG_APP0 + 2);
}// jpeg_property_processor_APP2()

// jpeg_property_processor_APP13 is a callback from the JPEG code that
// calls the jpeg_property_processor method.

boolean
jpeg_property_processor_APP13(j_decompress_ptr cinfo)
{
    return ((GpJpegDecoder*)(cinfo))->jpeg_property_processor(cinfo, 
                                                              JPEG_APP0 + 13);
}// jpeg_property_processor_APP13()

boolean
jpeg_property_processor_COM(j_decompress_ptr cinfo)
{
    return ((GpJpegDecoder*)(cinfo))->jpeg_property_processor(cinfo, 
                                                              JPEG_COM);
}// jpeg_property_processor_APP13()

// jpeg_header_processor_APP1 is a callback from the JPEG code that
// calls the jpeg_header_processor method.

boolean
jpeg_header_processor_APP1(j_decompress_ptr cinfo)
{
    return ((GpJpegDecoder*)(cinfo))->jpeg_header_processor(cinfo, JPEG_APP0+1);
}// jpeg_property_processor_APP1()

// jpeg_header_processor_APP13 is a callback from the JPEG code that
// calls the jpeg_header_processor method.

boolean
jpeg_header_processor_APP13(j_decompress_ptr cinfo)
{
    return ((GpJpegDecoder*)(cinfo))->jpeg_header_processor(cinfo,JPEG_APP0+13);
}// jpeg_property_processor_APP13()

const double kAspectRatioTolerance = 0.05;

/**************************************************************************\
*
* Function Description:
*
*     Processes the APP1 marker of a JPEG file, and extract a thumbnail
*     from it if one is present.
*     
* Arguments:
*
*     cinfo - a pointer to the jpeg state
*     app_header - the code indicating which app marker we're reading
*
* Return Value:
*
*   TRUE upon success, FALSE otherwise
*
\**************************************************************************/

BOOL
GpJpegDecoder::jpeg_thumbnail_processor(
    j_decompress_ptr cinfo,
    SHORT app_header
    )
{
    PVOID pBuffer = NULL;
    UINT16 length;

    if (read_jpeg_marker(cinfo, app_header, &pBuffer, &length) == FALSE)
    {
        // pBuffer is guaranteed to be NULL
        
        return FALSE;
    }

    if (!pBuffer) 
    {
        return TRUE;
    }

    if (app_header == (JPEG_APP0 + 1))
    {
        if (ThumbSrcHeader != 1)
        {
            // APP1 has the highest priority among all APP headers for getting
            // thumbnail. So if we got it not from APP1 before, throw the old
            // one away, if there is one, and regenerate it from APP1

            if (thumbImage)
            {
                thumbImage->Release();
                thumbImage = NULL;
                ThumbSrcHeader = -1;
            }

            // Remember that we've seen the APP1 header
        
            bAppMarkerPresent = TRUE;

            // Look for a thumbnail in the APP1 header

            if ((GetAPP1Thumbnail(&thumbImage, (PVOID) (((PBYTE) pBuffer) + 4), 
                            length - 4) == S_OK) && thumbImage)
            {
                // Remember we got the thumbnail from APP1 header

                ThumbSrcHeader = 1;
            }
        }
    }
    else if ((app_header == (JPEG_APP0 + 13)) && (thumbImage == NULL))
    {
        // Remember that we've seen the APP13 header
        
        bAppMarkerPresent = TRUE;

        // Look for a thumbnail in the APP13 header

        if ((GetAPP13Thumbnail(&thumbImage, (PVOID) (((PBYTE)pBuffer) + 4),
                          length - 4) == S_OK) && thumbImage)
        {
            // Remember we got the thumbnail from APP13 header

            ThumbSrcHeader = 13;
        }
    }

    // Check the thumbnail aspect ratio to see if it matches the main image. If
    // not, throw it away and pretend that current image doesn't have embedded
    // thumbnail.
    // The reason we need to do this is that there are some apps that rotate the
    // JPEG image without changing the EXIF header accordingly, like
    // Photoshop 6.0, ACDSee3.1 (see Windows bug#333810, #355958)
    // There was another issue which was caused by imaging.dll on Windows ME.
    // See bug#239114. We didn't throw away thumbnail info for some big-endian
    // EXIF images. So if the image was rotated in Windows ME and the user
    // upgrade it to Windows XP, the thumbnail view will be out of sync.
    // The problem is that GetThumbnailImage() will return a
    // thumbnail that is out of sync with the real image data.

    if ( thumbImage != NULL )
    {
        ImageInfo   thumbInfo;
        if ( (thumbImage->GetImageInfo(&thumbInfo) == S_OK)
           &&(thumbInfo.Height != 0)
           &&((CINFO).image_height != 0) )
        {
            double thumbAspecRatio = (double)thumbInfo.Width / thumbInfo.Height;
            double mainAspectRatio = (double)(CINFO).image_width
                                   / (CINFO).image_height;
            double aspectRatioDelta = fabs(thumbAspecRatio - mainAspectRatio);
            double minAspectRatio = min(thumbAspecRatio, mainAspectRatio);

            // If the delta of the aspect ratio is bigger than 5% of the minimum
            // aspect ratio of the main image and the thumbnail image, we will
            // consider the thumbnail image as out of sync

            if ( aspectRatioDelta > minAspectRatio * kAspectRatioTolerance )
            {
                WARNING(("Thumbnail width x height is %d x %d ratio %f",
                         thumbInfo.Width, thumbInfo.Height, thumbAspecRatio));
                WARNING(("Main width x height is %d x %d  ratio %f",
                         (CINFO).image_width, (CINFO).image_height,
                         mainAspectRatio));
                WARNING(("Throw away embedded thumbnail"));
                thumbImage->Release();
                thumbImage = NULL;
                ThumbSrcHeader = -1;
            }
        }
    }

    GpFree(pBuffer);
    return TRUE;
}

// Sets jpeg_marker_processor_APPx to process the APPx marker

#define SET_MARKER_PROCESSOR(x) \
jpeg_set_marker_processor(&(CINFO),JPEG_APP0 + x, jpeg_marker_processor_APP##x);


/**************************************************************************\
*
* Function Description:
*
*     Sets the appropriate processor for the APP1-APP13, APP15 markers so that
*     they will eventually be processed by jpeg_marker_processor and added
*     to the property set.
*     
* Arguments:
*
* Return Value:
*
*   Status
*
\**************************************************************************/

HRESULT
GpJpegDecoder::SetMarkerProcessors(
    VOID
    )
{
    // Lets set the processor callbacks for all app headers except for 
    // APP0 and APP14 (these are read by the JPEG code)
    
    SET_MARKER_PROCESSOR(1);
    SET_MARKER_PROCESSOR(2);
    SET_MARKER_PROCESSOR(3);
    SET_MARKER_PROCESSOR(4);
    SET_MARKER_PROCESSOR(5);
    SET_MARKER_PROCESSOR(6);
    SET_MARKER_PROCESSOR(7);
    SET_MARKER_PROCESSOR(8);
    SET_MARKER_PROCESSOR(9);
    SET_MARKER_PROCESSOR(10);
    SET_MARKER_PROCESSOR(11);
    SET_MARKER_PROCESSOR(12);
    SET_MARKER_PROCESSOR(13);
    SET_MARKER_PROCESSOR(15);

    jpeg_set_marker_processor(&(CINFO), JPEG_COM, jpeg_marker_processor_COM);

    return S_OK;
}

// Sets skip_variable to process the APPx marker (i.e. skip it without
// processing).

#define UNSET_MARKER_PROCESSOR(x) \
    jpeg_set_marker_processor(&(CINFO), JPEG_APP0 + x, skip_variable);

/**************************************************************************\
*
* Function Description:
*
*     Sets the appropriate processor for the APP2-APP13, APP15 markers so that
*     they will be processed by skip_variable and skipped.  APP1 is different
*     because we want to remember if we've seen an APP1 header (can contain
*     a thumbnail), so the processor for APP1 is skip_variable_APP1.
*     
* Arguments:
*
* Return Value:
*
*   Status
*
\**************************************************************************/

HRESULT
GpJpegDecoder::UnsetMarkerProcessors(
    VOID
    )
{
    // Lets unset the processor callbacks for all app headers except for 
    // APP0, APP2, APP13 and APP14 (these are read by the JPEG code)
    
    jpeg_set_marker_processor(&(CINFO), JPEG_APP0 + 1, skip_variable_APP1);
    jpeg_set_marker_processor(&(CINFO), JPEG_APP0 + 13, skip_variable_APP1);
    
    UNSET_MARKER_PROCESSOR(3);
    UNSET_MARKER_PROCESSOR(4);
    UNSET_MARKER_PROCESSOR(5);
    UNSET_MARKER_PROCESSOR(6);
    UNSET_MARKER_PROCESSOR(7);
    UNSET_MARKER_PROCESSOR(8);
    UNSET_MARKER_PROCESSOR(9);
    UNSET_MARKER_PROCESSOR(10);
    UNSET_MARKER_PROCESSOR(11);
    UNSET_MARKER_PROCESSOR(12);
    UNSET_MARKER_PROCESSOR(15);

    jpeg_set_marker_processor(&(CINFO), JPEG_COM, skip_variable);

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*   Parse all the JPEG APP headers and call the approprite functions to get
*   correct header info, like DPI info etc.
*
* Arguments
*   [IN]cinfo--------JPEG decompressor info structure
*   [IN]app_header---APP header indicator
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   02/28/2000 minliu
*       Created it.
*
\**************************************************************************/

BOOL
GpJpegDecoder::jpeg_header_processor(
    j_decompress_ptr cinfo,
    SHORT app_header
    )
{
    PVOID pBuffer = NULL;
    UINT16 length;

    if ( read_jpeg_marker(cinfo, app_header, &pBuffer, &length) == FALSE )
    {
        // pBuffer is guaranteed to be NULL
        
        return FALSE;
    }

    if ( !pBuffer )
    {
        // Memory allocation failed. But we can still return TRUE so that other
        // process can continue

        return TRUE;
    }

    if ((app_header == (JPEG_APP0 + 1)) && (InfoSrcHeader != 1))
    {
        // Parse information from APP1 if we haven't parsed APP1 yet

        // Remember that we've seen the APP1 header
        
        bAppMarkerPresent = TRUE;

        // Read header info from APP1 header
        
        if ( ReadApp1HeaderInfo(cinfo,
                                ((PBYTE)pBuffer) + 4,
                                length - 4) != S_OK )
        {
            // Something wrong with the header. Return FALSE

            GpFree(pBuffer);
            return FALSE;
        }

        // Remember we got the header info from APP1 header

        InfoSrcHeader = 1;
    }
    else if ((app_header == (JPEG_APP0 + 13)) && (InfoSrcHeader != 1) &&
             (InfoSrcHeader != 13))
    {
        // Only parse information from APP13 if we haven't parse it from APP1
        // or APP13 yet
        
        // Remember that we've seen the APP13 header
        
        bAppMarkerPresent = TRUE;

        // Read header info from APP13 header

        if ( ReadApp13HeaderInfo(cinfo,
                                 ((PBYTE)pBuffer) + 4,
                                 length - 4) != S_OK )
        {
            GpFree(pBuffer);
            return FALSE;
        }

        InfoSrcHeader = 13;
    }

    GpFree(pBuffer);

    return TRUE;
}// jpeg_header_processor()

/**************************************************************************\
*
* Function Description:
*
*   Parse all the JPEG APP headers and call the approprite functions to build
*   up an InternalPropertyItem list
*
* Arguments
*   [IN]cinfo--------JPEG decompressor info structure
*   [IN]app_header---APP header indicator
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   02/28/2000 minliu
*       Created it.
*
\**************************************************************************/

BOOL
GpJpegDecoder::jpeg_property_processor(
    j_decompress_ptr cinfo,
    SHORT app_header
    )
{
    PVOID pBuffer = NULL;
    UINT16 length;

    if ( read_jpeg_marker(cinfo, app_header, &pBuffer, &length) == FALSE )
    {
        // pBuffer is guaranteed to be NULL
        
        WARNING(("Jpeg::jpeg_property_processor---read_jpeg_marker failed"));
        return FALSE;
    }

    // Check the reading result. pBuffer should be allocated and filled in
    // read_jpeg_marker()

    if ( !pBuffer )
    {
        return TRUE;
    }

    if ((app_header == (JPEG_APP0 + 1)) && (PropertySrcHeader != 1))
    {
        // APP1 has the highest priority for getting property information.
        // Free all the cached property items if we have allocated them from
        // other APP headers.
        // Note: this will have problem if we see APP2 first in the list. ICC
        // profile will be thrown away here. I haven't seen this kind of image
        // yet. But this logic needs to be revisited in Avalon

        if (HasProcessedPropertyItem == TRUE)
        {
            CleanUpPropertyItemList();
            PropertySrcHeader = -1;
        }

        // Remember that we've seen the APP1 header
        
        bAppMarkerPresent = TRUE;

        // Build property item list for APP1 header
        // Note: This call will add all the new items at the end of current
        // exisiting list. One scenario would be that there are more than 1 app
        // headers in a JPEG image. We will process the app header one by one.
        
        if ( BuildApp1PropertyList(&PropertyListTail,
                                   &PropertyListSize,
                                   &PropertyNumOfItems,
                                   ((PBYTE)pBuffer) + 4,
                                   length - 4) != S_OK )
        {
            WARNING(("Jpeg::property_processor-BuildApp1PropertyList failed"));
            GpFree(pBuffer);
            return FALSE;
        }

        // Remember we got property from APP1 header

        if (PropertyNumOfItems > 0)
        {
            PropertySrcHeader = 1;
        }
    }// APP1 header
    else if (app_header == (JPEG_APP0 + 2))
    {
        // Remember that we've seen the APP2 header
        
        bAppMarkerPresent = TRUE;

        // Build property item list for APP2 header
        // Note: This call will add all the new items at the end of current
        // exisiting list. One scenario would be that there are more than 1 app
        // headers in a JPEG image. We will process the app header one by one.
        
        if ( BuildApp2PropertyList(&PropertyListTail,
                                   &PropertyListSize,
                                   &PropertyNumOfItems,
                                   ((PBYTE)pBuffer) + 4,
                                   length - 4) != S_OK )
        {
            WARNING(("Jpeg::property_processor-BuildApp2PropertyList failed"));
            GpFree(pBuffer);
            return FALSE;
        }
    }// APP2 header
    else if ((app_header == (JPEG_APP0 + 13)) && (PropertySrcHeader != 1) &&
             (PropertySrcHeader != 13))
    {
        // Remember that we've seen the APP13 header
        
        bAppMarkerPresent = TRUE;

        // Build property item list for APP13 header
        // Note: This call will add all the new items at the end of current
        // exisiting list. One scenario would be that there are more than 1 app
        // headers in a JPEG image. We will process all app headers one by one.
        
        if ( BuildApp13PropertyList(&PropertyListTail,
                                    &PropertyListSize,
                                    &PropertyNumOfItems,
                                    ((PBYTE)pBuffer) + 4,
                                    length - 4) != S_OK )
        {
            WARNING(("Jpeg::property_processor-BuildApp13PropertyList failed"));
            GpFree(pBuffer);
            return FALSE;
        }
        
        // Remember we got property from APP13 header

        if (PropertyNumOfItems > 0)
        {
            PropertySrcHeader = 13;
        }
    }// APP13 header
    else if ( app_header == JPEG_COM )
    {
        // COM header for comments

        if ( length <= 4)
        {
            // If we don't have enough bytes in the header, just ignore it

            GpFree(pBuffer);
            return TRUE;
        }

        // Allocate a temp buffer which holds the length of whole comments
        // (length -4) and add one \0 at the end
        
        UINT    uiTemp = (UINT)length - 4;
        BYTE*   pTemp = (BYTE*)GpMalloc(uiTemp + 1);
        if ( pTemp == NULL )
        {
            WARNING(("Jpeg::jpeg_property_processor-out of memory"));
            GpFree(pBuffer);
            return FALSE;
        }

        GpMemcpy(pTemp, ((PBYTE)pBuffer) + 4, uiTemp);
        pTemp[uiTemp] = '\0';

        PropertyNumOfItems++;
        PropertyListSize += uiTemp + 1;

        if ( AddPropertyList(&PropertyListTail,
                             EXIF_TAG_USER_COMMENT,
                             (uiTemp + 1),
                             TAG_TYPE_ASCII,
                             (VOID*)pTemp) != S_OK )
        {
            WARNING(("Jpeg::jpeg_property_processor-AddPropertyList() failed"));
            
            GpFree(pTemp);
            GpFree(pBuffer);
            
            return FALSE;
        }
        
        GpFree(pTemp);
    }// COM header

    GpFree(pBuffer);

    return TRUE;
}// jpeg_property_processor()

/**************************************************************************\
*
* Function Description:
*
*   Parse all the JPEG APP headers and build up an InternalPropertyItem list
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   02/28/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpJpegDecoder::BuildPropertyItemList()
{
    if ( HasProcessedPropertyItem == TRUE )
    {
        return S_OK;
    }

    HRESULT hResult;    

    // In the property set storage, insert the APP headers starting
    // at FIRST_JPEG_APP_HEADER

    JpegAppHeaderCount = FIRST_JPEG_APP_HEADER;
    
    // If jpeg header has already been read, we need to reinitialize the
    // jpeg state so that it could be read again.

    if ( bCalled_jpeg_read_header == TRUE )
    {
        bReinitializeJpeg = TRUE;
        hResult = ReinitializeJpeg();
        if ( FAILED(hResult) )
        {
            WARNING(("Jpeg::BuildPropertyItemList---ReinitializeJpeg failed"));
            return hResult;
        }
    }

    // Set the property processor for the APP1, 2, 13 and COM header

    jpeg_set_marker_processor(&(CINFO), 
                              JPEG_APP0 + 1, 
                              jpeg_property_processor_APP1);

    jpeg_set_marker_processor(&(CINFO), 
                              JPEG_APP0 + 2,
                              jpeg_property_processor_APP2);
    
    jpeg_set_marker_processor(&(CINFO), 
                              JPEG_APP0 + 13, 
                              jpeg_property_processor_APP13);
    
    jpeg_set_marker_processor(&(CINFO),
                              JPEG_COM,
                              jpeg_property_processor_COM);
    
    // Read the jpeg header

    hResult = ReadJpegHeaders();

    // Restore the normal processor for the APP1, 2, 13 and COM header.

    jpeg_set_marker_processor(&(CINFO), JPEG_APP0 + 1, skip_variable);
    jpeg_set_marker_processor(&(CINFO), JPEG_APP0 + 2, skip_variable);
    jpeg_set_marker_processor(&(CINFO), JPEG_APP0 + 13, skip_variable);
    jpeg_set_marker_processor(&(CINFO), JPEG_COM, skip_variable);

    if (FAILED(hResult))
    {
        WARNING(("Jpeg::BuildPropertyItemList---ReadJpegHeaders failed"));
        return hResult;
    }

    // After this ReadJpegHeaders(), all our callbacks get called and all the
    // APP headers will be processed. We get the properties.
    // Now add some extras: luminance and chrominance quantization table
    // Note: A JPEG image can only have a luminance table and a chrominance
    // table of UINT32 with length of DCTSIZE2

    if ( (CINFO).quant_tbl_ptrs != NULL )
    {
        UINT    uiTemp = DCTSIZE2 * sizeof(UINT16);

        VOID*   pTemp = (CINFO).quant_tbl_ptrs[0];

        if ( pTemp != NULL )
        {
            PropertyNumOfItems++;
            PropertyListSize += uiTemp;

            if ( AddPropertyList(&PropertyListTail,
                                 TAG_LUMINANCE_TABLE,
                                 uiTemp,
                                 TAG_TYPE_SHORT,
                                 pTemp) != S_OK )
            {
                WARNING(("Jpeg::BuildPropertyList--AddPropertyList() failed"));
                return FALSE;
            }
        }

        pTemp = (CINFO).quant_tbl_ptrs[1];
        if ( pTemp != NULL )
        {
            PropertyNumOfItems++;
            PropertyListSize += uiTemp;

            if ( AddPropertyList(&PropertyListTail,
                                 TAG_CHROMINANCE_TABLE,
                                 uiTemp,
                                 TAG_TYPE_SHORT,
                                 (VOID*)pTemp) != S_OK )
            {
                WARNING(("Jpeg::BuildPropertyList--AddPropertyList() failed"));
                return FALSE;
            }
        }
    }

    HasProcessedPropertyItem = TRUE;

    return S_OK;
}// BuildPropertyItemList()

/**************************************************************************\
*
* Function Description:
*
*   Get the count of property items in the image
*
* Arguments:
*
*   [OUT]numOfProperty - The number of property items in the image
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   02/28/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpJpegDecoder::GetPropertyCount(
    OUT UINT*   numOfProperty
    )
{
    if ( numOfProperty == NULL )
    {
        WARNING(("GpJpegDecoder::GetPropertyCount--numOfProperty is NULL"));
        return E_INVALIDARG;
    }

    if ( HasProcessedPropertyItem == FALSE )
    {
        // If we haven't build the internal property item list, build it

        HRESULT hResult = BuildPropertyItemList();
        if ( FAILED(hResult) )
        {
            WARNING(("Jpg::GetPropertyCount-BuildPropertyItemList() failed"));
            return hResult;
        }
    }

    // After the property item list is built, "PropertyNumOfItems" will be set
    // to the correct number of property items in the image

    *numOfProperty = PropertyNumOfItems;

    return S_OK;
}// GetPropertyCount()

/**************************************************************************\
*
* Function Description:
*
*   Get a list of property IDs for all the property items in the image
*
* Arguments:
*
*   [IN]  numOfProperty - The number of property items in the image
*   [OUT] list----------- A memory buffer the caller provided for storing the
*                         ID list
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   02/28/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpJpegDecoder::GetPropertyIdList(
    IN UINT         numOfProperty,
    IN OUT PROPID*  list
    )
{
    if ( HasProcessedPropertyItem == FALSE )
    {
        // If we haven't build the internal property item list, build it

        HRESULT hResult = BuildPropertyItemList();
        if ( FAILED(hResult) )
        {
            WARNING(("Jpg::GetPropertyIdList-BuildPropertyItemList() failed"));
            return hResult;
        }
    }

    // After the property item list is built, "PropertyNumOfItems" will be set
    // to the correct number of property items in the image
    // Here we need to validate if the caller passes us the correct number of
    // IDs which we returned through GetPropertyItemCount(). Also, this is also
    // a validation for memory allocation because the caller allocates memory
    // based on the number of items we returned to it

    if ( (numOfProperty != PropertyNumOfItems) || (list == NULL) )
    {
        WARNING(("GpJpegDecoder::GetPropertyList--input wrong"));
        return E_INVALIDARG;
    }

    if ( PropertyNumOfItems == 0 )
    {
        // This is OK since there is no property in this image

        return S_OK;
    }
    
    // Coping list IDs from our internal property item list

    InternalPropertyItem*   pTemp = PropertyListHead.pNext;

    for ( int i = 0;
         (  (i < (INT)PropertyNumOfItems) && (pTemp != NULL)
         && (pTemp != &PropertyListTail));
         ++i )
    {
        list[i] = pTemp->id;
        pTemp = pTemp->pNext;
    }

    return S_OK;
}// GetPropertyIdList()

/**************************************************************************\
*
* Function Description:
*
*   Get the size, in bytes, of a specific property item, specified by the
*   property ID
*
* Arguments:
*
*   [IN]propId - The ID of a property item caller is interested
*   [OUT]size--- Size of this property, in bytes
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   02/28/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpJpegDecoder::GetPropertyItemSize(
    IN PROPID propId,
    OUT UINT* size
    )
{
    if ( size == NULL )
    {
        WARNING(("GpJpegDecoder::GetPropertyItemSize--size is NULL"));
        return E_INVALIDARG;
    }

    if ( HasProcessedPropertyItem == FALSE )
    {
        // If we haven't build the internal property item list, build it

        HRESULT hResult = BuildPropertyItemList();
        if ( FAILED(hResult) )
        {
            WARNING(("Jpg::GetPropertyItemSize-BuildPropertyItemList failed"));
            return hResult;
        }
    }

    // Loop through our cache list to see if we have this ID or not
    // Note: if pTemp->pNext == NULL, it means pTemp points to the Tail node

    InternalPropertyItem*   pTemp = PropertyListHead.pNext;

    while ( (pTemp->pNext != NULL) && (pTemp->id != propId) )
    {
        pTemp = pTemp->pNext;
    }

    if ( pTemp->pNext == NULL )
    {
        // This ID doesn't exist

        return IMGERR_PROPERTYNOTFOUND;
    }

    // The size of an property item should be "The size of the item structure
    // plus the size for the value

    *size = pTemp->length + sizeof(PropertyItem);

    return S_OK;
}// GetPropertyItemSize()

/**************************************************************************\
*
* Function Description:
*
*   Get a specific property item, specified by the prop ID.
*
* Arguments:
*
*   [IN]propId -- The ID of the property item caller is interested
*   [IN]propSize- Size of the property item. The caller has allocated these
*                 "bytes of memory" for storing the result
*   [OUT]pBuffer- A memory buffer for storing this property item
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   02/28/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpJpegDecoder::GetPropertyItem(
    IN PROPID               propId,
    IN UINT                 propSize,
    IN OUT PropertyItem*    pItemBuffer
    )
{
    if ( pItemBuffer == NULL )
    {
        WARNING(("GpJpegDecoder::GetPropertyItem--pBuffer is NULL"));
        return E_INVALIDARG;
    }

    if ( HasProcessedPropertyItem == FALSE )
    {
        // If we haven't build the internal property item list, build it

        HRESULT hResult = BuildPropertyItemList();
        if ( FAILED(hResult) )
        {
            WARNING(("Jpg::GetPropertyItem-BuildPropertyItemList() failed"));
            return hResult;
        }
    }

    // Loop through our cache list to see if we have this ID or not
    // Note: if pTemp->pNext == NULL, it means pTemp points to the Tail node

    InternalPropertyItem*   pTemp = PropertyListHead.pNext;
    BYTE*   pOffset = (BYTE*)pItemBuffer + sizeof(PropertyItem);

    while ( (pTemp->pNext != NULL) && (pTemp->id != propId) )
    {
        pTemp = pTemp->pNext;
    }

    if ( pTemp->pNext == NULL )
    {
        // This ID doesn't exist in the list

        return IMGERR_PROPERTYNOTFOUND;
    }
    else if ( (pTemp->length + sizeof(PropertyItem)) != propSize )
    {
        WARNING(("Jpg::GetPropertyItem-propsize"));
        return E_INVALIDARG;
    }

    // Found the ID in the list and return the item

    pItemBuffer->id = pTemp->id;
    pItemBuffer->length = pTemp->length;
    pItemBuffer->type = pTemp->type;

    if ( pTemp->length != 0 )
    {
        pItemBuffer->value = pOffset;

        GpMemcpy(pOffset, pTemp->value, pTemp->length);
    }
    else
    {
        pItemBuffer->value = NULL;
    }

    return S_OK;
}// GetPropertyItem()

/**************************************************************************\
*
* Function Description:
*
*   Get the size of ALL property items in the image
*
* Arguments:
*
*   [OUT]totalBufferSize-- Total buffer size needed, in bytes, for storing all
*                          property items in the image
*   [OUT]numOfProperty --- The number of property items in the image
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   02/28/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpJpegDecoder::GetPropertySize(
    OUT UINT* totalBufferSize,
    OUT UINT* numProperties
    )
{
    if ( (totalBufferSize == NULL) || (numProperties == NULL) )
    {
        WARNING(("GpJpegDecoder::GetPropertySize--invalid inputs"));
        return E_INVALIDARG;
    }

    if ( HasProcessedPropertyItem == FALSE )
    {
        // If we haven't build the internal property item list, build it

        HRESULT hResult = BuildPropertyItemList();
        if ( FAILED(hResult) )
        {
            WARNING(("Jpg::GetPropertySize-BuildPropertyItemList() failed"));
            return hResult;
        }
    }

    *numProperties = PropertyNumOfItems;

    // Total buffer size should be list value size plus the total header size

    *totalBufferSize = PropertyListSize
                     + PropertyNumOfItems * sizeof(PropertyItem);

    return S_OK;
}// GetPropertySize()

/**************************************************************************\
*
* Function Description:
*
*   Get ALL property items in the image
*
* Arguments:
*
*   [IN]totalBufferSize-- Total buffer size, in bytes, the caller has allocated
*                         memory for storing all property items in the image
*   [IN]numOfProperty --- The number of property items in the image
*   [OUT]allItems-------- A memory buffer caller has allocated for storing all
*                         the property items
*
*   Note: "allItems" is actually an array of PropertyItem
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   02/28/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpJpegDecoder::GetAllPropertyItems(
    IN UINT                 totalBufferSize,
    IN UINT                 numProperties,
    IN OUT PropertyItem*    allItems
    )
{
    // Figure out total property header size first

    UINT    uiHeaderSize = PropertyNumOfItems * sizeof(PropertyItem);

    if ( (totalBufferSize != (uiHeaderSize + PropertyListSize))
       ||(numProperties != PropertyNumOfItems)
       ||(allItems == NULL) )
    {
        WARNING(("GpJpegDecoder::GetPropertyItems--invalid inputs"));
        return E_INVALIDARG;
    }

    if ( HasProcessedPropertyItem == FALSE )
    {
        // If we haven't build the internal property item list, build it

        HRESULT hResult = BuildPropertyItemList();
        if ( FAILED(hResult) )
        {
            WARNING(("Jpg::GetAllPropertyItems-BuildPropertyItemList failed"));
            return hResult;
        }
    }

    // Loop through our cache list and assign the result out

    InternalPropertyItem*   pTempSrc = PropertyListHead.pNext;
    PropertyItem*           pTempDst = allItems;

    // For the memory buffer caller passes in, the first "uiHeaderSize" are for
    // "PropertyNumOfItems" items data structure. We store the value starts at
    // the memory buffer after that. Then assign the "Offset" value in each
    // PropertyItem's "value" field

    BYTE*                   pOffSet = (UNALIGNED BYTE*)allItems + uiHeaderSize;
        
    for ( int i = 0; i < (INT)PropertyNumOfItems; ++i )
    {
        pTempDst->id = pTempSrc->id;
        pTempDst->length = pTempSrc->length;
        pTempDst->type = pTempSrc->type;

        if ( pTempSrc->length != 0 )
        {
            pTempDst->value = (void*)pOffSet;

            GpMemcpy(pOffSet, pTempSrc->value, pTempSrc->length);
        }
        else
        {
            // For zero length property item, set the value pointer to NULL

            pTempDst->value = NULL;
        }

        // Move onto next memory offset.
        // Note: if the current item length is 0, the next line doesn't move
        // the offset

        pOffSet += pTempSrc->length;
        pTempSrc = pTempSrc->pNext;
        pTempDst++;
    }
    
    return S_OK;
}// GetAllPropertyItems()

/**************************************************************************\
*
* Function Description:
*
*   Remove a specific property item, specified by the prop ID.
*
* Arguments:
*
*   [IN]propId -- The ID of the property item to be removed
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   02/28/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpJpegDecoder::RemovePropertyItem(
    IN PROPID   propId
    )
{
    if ( HasProcessedPropertyItem == FALSE )
    {
        // If we haven't build the internal property item list, build it

        HRESULT hResult = BuildPropertyItemList();
        if ( FAILED(hResult) )
        {
            WARNING(("Jpg::RemovePropertyItem-BuildPropertyItemList() failed"));
            return hResult;
        }
    }

    // Loop through our cache list to see if we have this ID or not
    // Note: if pTemp->pNext == NULL, it means pTemp points to the Tail node

    InternalPropertyItem*   pTemp = PropertyListHead.pNext;

    while ( (pTemp->pNext != NULL) && (pTemp->id != propId) )
    {
        pTemp = pTemp->pNext;
    }

    if ( pTemp->pNext == NULL )
    {
        // Item not found

        return IMGERR_PROPERTYNOTFOUND;
    }

    // Found the item in the list. Remove it

    PropertyNumOfItems--;
    PropertyListSize -= pTemp->length;
        
    RemovePropertyItemFromList(pTemp);
       
    // Remove the item structure

    GpFree(pTemp);

    HasPropertyChanged = TRUE;

    return S_OK;
}// RemovePropertyItem()

/**************************************************************************\
*
* Function Description:
*
*   Set a property item, specified by the propertyitem structure. If the item
*   already exists, then its contents will be updated. Otherwise a new item
*   will be added
*
* Arguments:
*
*   [IN]item -- A property item the caller wants to set
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   02/28/2000 minliu
*       Created it.
*
\**************************************************************************/

HRESULT
GpJpegDecoder::SetPropertyItem(
    IN PropertyItem item
    )
{
    if ( HasProcessedPropertyItem == FALSE )
    {
        // If we haven't build the internal property item list, build it

        HRESULT hResult = BuildPropertyItemList();
        if ( FAILED(hResult) )
        {
            WARNING(("Jpg::SetPropertyItem-BuildPropertyItemList() failed"));
            return hResult;
        }
    }

    // Loop through our cache list to see if we have this ID or not
    // Note: if pTemp->pNext == NULL, it means pTemp points to the Tail node

    InternalPropertyItem*   pTemp = PropertyListHead.pNext;

    while ( (pTemp->pNext != NULL) && (pTemp->id != item.id) )
    {
        pTemp = pTemp->pNext;
    }

    if ( pTemp->pNext == NULL )
    {
        // This item doesn't exist in the list, add it into the list
        
        PropertyNumOfItems++;
        PropertyListSize += item.length;
        
        if ( AddPropertyList(&PropertyListTail,
                             item.id,
                             item.length,
                             item.type,
                             item.value) != S_OK )
        {
            WARNING(("Jpg::SetPropertyItem-AddPropertyList() failed"));
            return E_FAIL;
        }
    }
    else
    {
        // This item already exists in the link list, update the info
        // Update the size first

        PropertyListSize -= pTemp->length;
        PropertyListSize += item.length;
        
        // Free the old item

        GpFree(pTemp->value);

        pTemp->length = item.length;
        pTemp->type = item.type;

        pTemp->value = GpMalloc(item.length);
        if ( pTemp->value == NULL )
        {
            // Since we already freed the old item, we should set its length to
            // 0 before return

            pTemp->length = 0;
            WARNING(("Jpg::SetPropertyItem-Out of memory"));
            return E_OUTOFMEMORY;
        }

        GpMemcpy(pTemp->value, item.value, item.length);
    }

    HasPropertyChanged = TRUE;
    if (item.id == TAG_ICC_PROFILE)
    {
        HasSetICCProperty = TRUE;
    }
    
    return S_OK;
}// SetPropertyItem()

VOID
GpJpegDecoder::CleanUpPropertyItemList(
    )
{
    InternalPropertyItem*   pTempCurrent = PropertyListHead.pNext;
    InternalPropertyItem*   pTempNext = NULL;

    for ( int i = 0; 
          ((i < (INT)PropertyNumOfItems) && (pTempCurrent != NULL)); ++i )
    {
        pTempNext = pTempCurrent->pNext;

        GpFree(pTempCurrent->value);
        GpFree(pTempCurrent);

        pTempCurrent = pTempNext;
    }

    PropertyNumOfItems = 0;
    HasProcessedPropertyItem = FALSE;
}// CleanUpPropertyItemList()

/**************************************************************************\
*
* Function Description:
*
*   Get image thumbnail
*
* Arguments:
*
*   thumbWidth, thumbHeight - Specifies the desired thumbnail size in pixels
*   thumbImage - Returns a pointer to the thumbnail image
*
* Return Value:
*
*   Status code
*
* Note:
*
*   Even if the optional thumbnail width and height parameters are present,
*   the decoder is not required to honor it. The requested size is used
*   as a hint. If both width and height parameters are 0, then the decoder
*   is free to choose a convenient thumbnail size.
*
\**************************************************************************/

HRESULT
GpJpegDecoder::GetThumbnail(
    IN OPTIONAL UINT thumbWidth,
    IN OPTIONAL UINT thumbHeight,
    OUT IImage** thumbImageArg
    )
{
    *thumbImageArg = NULL;
    HRESULT hresult;

    // If jpeg header has already been read, we need to reinitialize the
    // jpeg state so that it could be read again.

    if (bCalled_jpeg_read_header) 
    {
        if (!bAppMarkerPresent) 
        {
            // If we read the headers, but haven't seen an APP marker
            // we might as well return now without wasting any more time.

            return E_FAIL;
        }
        
        bReinitializeJpeg = TRUE;
        hresult = ReinitializeJpeg();
        if (FAILED(hresult)) 
        {
            return hresult;
        }
    }

    // Set the thumbnail processor on the APP1 header

    jpeg_set_marker_processor(&(CINFO), 
        JPEG_APP0 + 1, 
        jpeg_thumbnail_processor_APP1);

    // Set the thumbnail processor on the APP13 header

    jpeg_set_marker_processor(&(CINFO), 
        JPEG_APP0 + 13, 
        jpeg_thumbnail_processor_APP13);

    // Read the app1 header

    hresult = ReadJpegHeaders();
    
    // Restore the normal processor for the APP1 and APP13 header.

    jpeg_set_marker_processor(&(CINFO), JPEG_APP0 + 1, skip_variable);
    jpeg_set_marker_processor(&(CINFO), JPEG_APP0 + 13, skip_variable);

    if (FAILED(hresult))
    {
        return hresult;
    }

    // Give ownership of thumbImage to the caller
    
    *thumbImageArg = thumbImage;
    thumbImage = NULL;

    if (!(*thumbImageArg)) 
    {
        // Didn't find a thumbnail
        
        return E_FAIL;
    }

    return S_OK;
}
    
/**************************************************************************\
*
* Function Description:
*
*     Get image information
*
* Arguments:
*
*     [OUT] imageInfo -- ImageInfo structure filled with all the info from the
*                        image
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpJpegDecoder::GetImageInfo(
    OUT ImageInfo* imageInfo
    )
{
    HRESULT hResult = S_OK;
    
    // Reinitialize JPEG if necessary

    hResult = ReinitializeJpeg();
    if ( FAILED(hResult) ) 
    {
        return hResult;
    }

    // Set the header info processor on the APP1 and APP13 header
    // Note: the IJG library doesn't handle a lot of APP headers. So for JPEG
    // images like Adobe and EXIF, we usually don't get the correct DPI info
    // This is the reason we have to parse it by ourselves in order to get more
    // accurate image information

    jpeg_set_marker_processor(&(CINFO), JPEG_APP0 + 1, 
                              jpeg_header_processor_APP1);
    jpeg_set_marker_processor(&(CINFO), JPEG_APP0 + 13, 
                              jpeg_header_processor_APP13);
    
    hResult = ReadJpegHeaders();
    
    // No matter ReadJpegHeaders() succeed or not, we need to restore the normal
    // processor for the APP1 and APP13 header.

    jpeg_set_marker_processor(&(CINFO), JPEG_APP0 + 1, skip_variable);
    jpeg_set_marker_processor(&(CINFO), JPEG_APP0 + 13, skip_variable);
    
    if (FAILED(hResult))
    {
        return hResult;
    }

    // Remember all the sample_factor values.
    // Note: this is used later if the caller is asking for a lossless
    // transform and we need these info to decide if we need trim the edge
    // or not

    for ( int i = 0; i < (CINFO).comps_in_scan; ++i )
    {
        SrcHSampleFactor[i] = (CINFO).cur_comp_info[i]->h_samp_factor;
        SrcVSampleFactor[i] = (CINFO).cur_comp_info[i]->v_samp_factor;
    }

    imageInfo->RawDataFormat = IMGFMT_JPEG;

    if ( HasSetColorKeyRange == TRUE )
    {
        imageInfo->PixelFormat = PIXFMT_32BPP_ARGB;
    }
    else if ( (CINFO).out_color_space == JCS_CMYK )
    {
        imageInfo->PixelFormat = PIXFMT_32BPP_ARGB;
    }
    else if ( (CINFO).out_color_space == JCS_RGB )
    {
        imageInfo->PixelFormat = PIXFMT_24BPP_RGB;
    }
    else
    {
        imageInfo->PixelFormat = PIXFMT_8BPP_INDEXED;
    }
    
    imageInfo->Width         = (CINFO).image_width;
    imageInfo->Height        = (CINFO).image_height;

    // Setup resolution unit. According to the spec:
    // density_unit may be 0 for unknown, 1 for dots/inch, or 2 for dots/cm. 

    BOOL bRealDPI = TRUE;

    switch ( (CINFO).density_unit )
    {
    case 0:
    default:

        // Start: [Bug 103296]
        // Change this code to use Globals::DesktopDpiX and Globals::DesktopDpiY
        HDC hdc;
        hdc = ::GetDC(NULL);
        if ((hdc == NULL) || 
            ((imageInfo->Xdpi = (REAL)::GetDeviceCaps(hdc, LOGPIXELSX)) <= 0) ||
            ((imageInfo->Ydpi = (REAL)::GetDeviceCaps(hdc, LOGPIXELSY)) <= 0))
        {
            WARNING(("GetDC or GetDeviceCaps failed"));
            imageInfo->Xdpi = DEFAULT_RESOLUTION;
            imageInfo->Ydpi = DEFAULT_RESOLUTION;
        }
        ::ReleaseDC(NULL, hdc);
        // End: [Bug 103296]

        bRealDPI = FALSE;

        break;

    case 1:
        // Dots per inch

        imageInfo->Xdpi = (double)(CINFO).X_density;
        imageInfo->Ydpi = (double)(CINFO).Y_density;

        break;

    case 2:
        // Convert cm to inch. 1 inch = 2.54 cm

        imageInfo->Xdpi = (double)(CINFO).X_density * 2.54;
        imageInfo->Ydpi = (double)(CINFO).Y_density * 2.54;

        break;
    }

    // For none JFIF images, these items might be left as 0. So we have to set
    // the default value here.

    if (( imageInfo->Xdpi <= 0.0 ) || ( imageInfo->Ydpi <= 0.0 ))
    {
        // Start: [Bug 103296]
        // Change this code to use Globals::DesktopDpiX and Globals::DesktopDpiY
        HDC hdc;
        hdc = ::GetDC(NULL);
        if ((hdc == NULL) || 
            ((imageInfo->Xdpi = (REAL)::GetDeviceCaps(hdc, LOGPIXELSX)) <= 0) ||
            ((imageInfo->Ydpi = (REAL)::GetDeviceCaps(hdc, LOGPIXELSY)) <= 0))
        {
            WARNING(("GetDC or GetDeviceCaps failed"));
            imageInfo->Xdpi = DEFAULT_RESOLUTION;
            imageInfo->Ydpi = DEFAULT_RESOLUTION;
        }
        ::ReleaseDC(NULL, hdc);
        // End: [Bug 103296]

        bRealDPI = FALSE;
    }
    
    // Set up misc image info flags

    imageInfo->Flags         = SINKFLAG_TOPDOWN
                             | SINKFLAG_FULLWIDTH
                             | SINKFLAG_PARTIALLY_SCALABLE
                             | IMGFLAG_HASREALPIXELSIZE;

    if ( bRealDPI == TRUE )
    {
        imageInfo->Flags     |= IMGFLAG_HASREALDPI;
    }

    // Set color space info

    switch ( OriginalColorSpace )
    {
    case JCS_RGB:
        imageInfo->Flags |= IMGFLAG_COLORSPACE_RGB;

        break;

    case JCS_CMYK:
        imageInfo->Flags |= IMGFLAG_COLORSPACE_CMYK;

        break;

    case JCS_YCCK:
        imageInfo->Flags |= IMGFLAG_COLORSPACE_YCCK;

        break;

    case JCS_GRAYSCALE:
        imageInfo->Flags |= IMGFLAG_COLORSPACE_GRAY;

        break;
    
    case JCS_YCbCr:
        imageInfo->Flags |= IMGFLAG_COLORSPACE_YCBCR;

        break;

    default:
        // Don't need to report other color space info for now

        break;
    }

    imageInfo->TileWidth     = (CINFO).image_width;
    imageInfo->TileHeight    = 1;

    return S_OK;   
}// GetImageInfo()

/**************************************************************************\
*
* Function Description:
*
*   Change the value of a particular property item and return the old value
*   as one of the output value.
*
* Arguments:
*
*   [IN]propID---------ID of the property item needs to be changed
*   [IN]uiNewValue-----New value for this property item
*   [OUT]puiOldValue---Pointer to the return buffer for the old value
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpJpegDecoder::ChangePropertyValue(
    IN PROPID  propID,
    IN UINT    uiNewValue,
    OUT UINT*  puiOldValue
    )
{
    UINT    uiItemSize = 0;

    *puiOldValue = 0;

    HRESULT hResult = GetPropertyItemSize(propID, &uiItemSize);
    if ( SUCCEEDED(hResult) )
    {
        // Allocate memory buffer for receiving it

        PropertyItem*   pItem = (PropertyItem*)GpMalloc(uiItemSize);
        if ( pItem == NULL )
        {
            WARNING(("JpegDec::ChangePropertyValue--GpMalloc() failed"));
            return E_OUTOFMEMORY;
        }

        // Get the property item

        hResult = GetPropertyItem(propID, uiItemSize, pItem);
        if ( SUCCEEDED(hResult) )
        {
            *puiOldValue = *((UINT*)pItem->value);

            // Change the value

            pItem->value = (VOID*)&uiNewValue;

            hResult = SetPropertyItem(*pItem);
        }

        // We don't need to check GetPropertyItem() failure case since
        // it is normal if the input image doesn't have
        // EXIF_TAG_PIX_X_DIM tag. Also no need to check the return
        // code of SetPropertyItem()

        GpFree(pItem);
    }

    return S_OK;
}// ChangePropertyValue()

/**************************************************************************\
*
* Function Description:
*
*   Pass property items from current image to the sink.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpJpegDecoder::PassPropertyToSink(
    )
{
    HRESULT     hResult = S_OK;
    
    // If current image has property items. Then we need to check if the sink
    // needs property stuff or not. If YES, push it
    // Note: for a memory sink, it should return E_FAIL or E_NOTIMPL

    if ((PropertyNumOfItems > 0) && (decodeSink->NeedRawProperty(NULL) == S_OK))
    {
        if ( HasProcessedPropertyItem == FALSE )
        {
            // If we haven't built the internal property item list, build it

            hResult = BuildPropertyItemList();
            if ( FAILED(hResult) )
            {
                WARNING(("Jpg::PassPropertyToSink-BldPropertyItemList() fail"));
                goto Done;
            }
        }

        UINT    uiTotalBufferSize = PropertyListSize
                                  + PropertyNumOfItems * sizeof(PropertyItem);
        PropertyItem*   pBuffer = NULL;

        hResult = decodeSink->GetPropertyBuffer(uiTotalBufferSize, &pBuffer);
        if ( FAILED(hResult) )
        {
            WARNING(("Jpg::PassPropertyToSink---GetPropertyBuffer() failed"));
            goto Done;
        }

        hResult = GetAllPropertyItems(uiTotalBufferSize,
                                      PropertyNumOfItems, pBuffer);
        if ( FAILED(hResult) )
        {
            WARNING(("Jpg::PassPropertyToSink---GetAllPropertyItems() failed"));
            goto Done;
        }

        hResult = decodeSink->PushPropertyItems(PropertyNumOfItems,
                                                uiTotalBufferSize, pBuffer,
                                                HasSetICCProperty
                                                );

        if ( FAILED(hResult) )
        {
            WARNING(("Jpg::PassPropertyToSink---PushPropertyItems() failed"));
        }
    }// If the sink needs raw property

Done:
    return hResult;
}// PassPropertyToSink()

/**************************************************************************\
*
* Function Description:
*
*   Return the jpeg_decompress structure pointer to the caller. This is for
* supporting the private app header preservation.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpJpegDecoder::GetRawInfo(
    IN OUT void** ppInfo
    )
{
    HRESULT hr = E_INVALIDARG;

    if (ppInfo)
    {
        // Check if we have called jpeg_read_header already. If yes, we would
        // reset it back

        if (bCalled_jpeg_read_header)
        {
            bReinitializeJpeg = TRUE;
            hr = ReinitializeJpeg();
            if (FAILED(hr))
            {
                WARNING(("JpegDec::GetRawInfo---ReinitializeJpeg failed"));
                return hr;
            }            
        }
        
        // Set COPYALL markers here so that all markers will be linked under
        // the decompressor info structure

        jtransformation_markers_setup(&(CINFO), JCOPYOPT_ALL);
        
        __try
        {
            if (jpeg_read_header(&(CINFO), TRUE) == JPEG_SUSPENDED)
            {
                WARNING(("JpgDec::GetRawInfo---jpeg_read_header failed"));
                return (datasrc->GetLastError());
            }

            bCalled_jpeg_read_header = TRUE;

            UnsetMarkerProcessors();        
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING(("GpJpegDecoder::GetRawInfo--Hit exception"));
            return E_FAIL;
        }
        
        *ppInfo = &(CINFO);
        hr = S_OK;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\jpeg\libjpeg\cderror.h ===
/*
 * cderror.h
 *
 * Copyright (C) 1994-1997, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file defines the error and message codes for the cjpeg/djpeg
 * applications.  These strings are not needed as part of the JPEG library
 * proper.
 * Edit this file to add new codes, or to translate the message strings to
 * some other language.
 */

/*
 * To define the enum list of message codes, include this file without
 * defining macro JMESSAGE.  To create a message string table, include it
 * again with a suitable JMESSAGE definition (see jerror.c for an example).
 */
#ifndef JMESSAGE
#ifndef CDERROR_H
#define CDERROR_H
/* First time through, define the enum list */
#define JMAKE_ENUM_LIST
#else
/* Repeated inclusions of this file are no-ops unless JMESSAGE is defined */
#define JMESSAGE(code,string)
#endif /* CDERROR_H */
#endif /* JMESSAGE */

#ifdef JMAKE_ENUM_LIST

typedef enum {

#define JMESSAGE(code,string)	code ,

#endif /* JMAKE_ENUM_LIST */

JMESSAGE(JMSG_FIRSTADDONCODE=1000, NULL) /* Must be first entry! */

#ifdef BMP_SUPPORTED
JMESSAGE(JERR_BMP_BADCMAP, "Unsupported BMP colormap format")
JMESSAGE(JERR_BMP_BADDEPTH, "Only 8- and 24-bit BMP files are supported")
JMESSAGE(JERR_BMP_BADHEADER, "Invalid BMP file: bad header length")
JMESSAGE(JERR_BMP_BADPLANES, "Invalid BMP file: biPlanes not equal to 1")
JMESSAGE(JERR_BMP_COLORSPACE, "BMP output must be grayscale or RGB")
JMESSAGE(JERR_BMP_COMPRESSED, "Sorry, compressed BMPs not yet supported")
JMESSAGE(JERR_BMP_NOT, "Not a BMP file - does not start with BM")
JMESSAGE(JTRC_BMP, "%ux%u 24-bit BMP image")
JMESSAGE(JTRC_BMP_MAPPED, "%ux%u 8-bit colormapped BMP image")
JMESSAGE(JTRC_BMP_OS2, "%ux%u 24-bit OS2 BMP image")
JMESSAGE(JTRC_BMP_OS2_MAPPED, "%ux%u 8-bit colormapped OS2 BMP image")
#endif /* BMP_SUPPORTED */

#ifdef GIF_SUPPORTED
JMESSAGE(JERR_GIF_BUG, "GIF output got confused")
JMESSAGE(JERR_GIF_CODESIZE, "Bogus GIF codesize %d")
JMESSAGE(JERR_GIF_COLORSPACE, "GIF output must be grayscale or RGB")
JMESSAGE(JERR_GIF_IMAGENOTFOUND, "Too few images in GIF file")
JMESSAGE(JERR_GIF_NOT, "Not a GIF file")
JMESSAGE(JTRC_GIF, "%ux%ux%d GIF image")
JMESSAGE(JTRC_GIF_BADVERSION,
	 "Warning: unexpected GIF version number '%c%c%c'")
JMESSAGE(JTRC_GIF_EXTENSION, "Ignoring GIF extension block of type 0x%02x")
JMESSAGE(JTRC_GIF_NONSQUARE, "Caution: nonsquare pixels in input")
JMESSAGE(JWRN_GIF_BADDATA, "Corrupt data in GIF file")
JMESSAGE(JWRN_GIF_CHAR, "Bogus char 0x%02x in GIF file, ignoring")
JMESSAGE(JWRN_GIF_ENDCODE, "Premature end of GIF image")
JMESSAGE(JWRN_GIF_NOMOREDATA, "Ran out of GIF bits")
#endif /* GIF_SUPPORTED */

#ifdef PPM_SUPPORTED
JMESSAGE(JERR_PPM_COLORSPACE, "PPM output must be grayscale or RGB")
JMESSAGE(JERR_PPM_NONNUMERIC, "Nonnumeric data in PPM file")
JMESSAGE(JERR_PPM_NOT, "Not a PPM/PGM file")
JMESSAGE(JTRC_PGM, "%ux%u PGM image")
JMESSAGE(JTRC_PGM_TEXT, "%ux%u text PGM image")
JMESSAGE(JTRC_PPM, "%ux%u PPM image")
JMESSAGE(JTRC_PPM_TEXT, "%ux%u text PPM image")
#endif /* PPM_SUPPORTED */

#ifdef RLE_SUPPORTED
JMESSAGE(JERR_RLE_BADERROR, "Bogus error code from RLE library")
JMESSAGE(JERR_RLE_COLORSPACE, "RLE output must be grayscale or RGB")
JMESSAGE(JERR_RLE_DIMENSIONS, "Image dimensions (%ux%u) too large for RLE")
JMESSAGE(JERR_RLE_EMPTY, "Empty RLE file")
JMESSAGE(JERR_RLE_EOF, "Premature EOF in RLE header")
JMESSAGE(JERR_RLE_MEM, "Insufficient memory for RLE header")
JMESSAGE(JERR_RLE_NOT, "Not an RLE file")
JMESSAGE(JERR_RLE_TOOMANYCHANNELS, "Cannot handle %d output channels for RLE")
JMESSAGE(JERR_RLE_UNSUPPORTED, "Cannot handle this RLE setup")
JMESSAGE(JTRC_RLE, "%ux%u full-color RLE file")
JMESSAGE(JTRC_RLE_FULLMAP, "%ux%u full-color RLE file with map of length %d")
JMESSAGE(JTRC_RLE_GRAY, "%ux%u grayscale RLE file")
JMESSAGE(JTRC_RLE_MAPGRAY, "%ux%u grayscale RLE file with map of length %d")
JMESSAGE(JTRC_RLE_MAPPED, "%ux%u colormapped RLE file with map of length %d")
#endif /* RLE_SUPPORTED */

#ifdef TARGA_SUPPORTED
JMESSAGE(JERR_TGA_BADCMAP, "Unsupported Targa colormap format")
JMESSAGE(JERR_TGA_BADPARMS, "Invalid or unsupported Targa file")
JMESSAGE(JERR_TGA_COLORSPACE, "Targa output must be grayscale or RGB")
JMESSAGE(JTRC_TGA, "%ux%u RGB Targa image")
JMESSAGE(JTRC_TGA_GRAY, "%ux%u grayscale Targa image")
JMESSAGE(JTRC_TGA_MAPPED, "%ux%u colormapped Targa image")
#else
JMESSAGE(JERR_TGA_NOTCOMP, "Targa support was not compiled")
#endif /* TARGA_SUPPORTED */

JMESSAGE(JERR_BAD_CMAP_FILE,
	 "Color map file is invalid or of unsupported format")
JMESSAGE(JERR_TOO_MANY_COLORS,
	 "Output file format cannot handle %d colormap entries")
JMESSAGE(JERR_UNGETC_FAILED, "ungetc failed")
#ifdef TARGA_SUPPORTED
JMESSAGE(JERR_UNKNOWN_FORMAT,
	 "Unrecognized input file format --- perhaps you need -targa")
#else
JMESSAGE(JERR_UNKNOWN_FORMAT, "Unrecognized input file format")
#endif
JMESSAGE(JERR_UNSUPPORTED_FORMAT, "Unsupported output file format")

#ifdef JMAKE_ENUM_LIST

  JMSG_LASTADDONCODE
} ADDON_MESSAGE_CODE;

#undef JMAKE_ENUM_LIST
#endif /* JMAKE_ENUM_LIST */

/* Zap JMESSAGE macro so that future re-inclusions do nothing by default */
#undef JMESSAGE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\jpeg\libjpeg\cdjpeg.c ===
/*
 * cdjpeg.c
 *
 * Copyright (C) 1991-1997, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains common support routines used by the IJG application
 * programs (cjpeg, djpeg, jpegtran).
 */

#include "cdjpeg.h"		/* Common decls for cjpeg/djpeg applications */
#include <ctype.h>		/* to declare isupper(), tolower() */
#ifdef NEED_SIGNAL_CATCHER
#include <signal.h>		/* to declare signal() */
#endif
#ifdef USE_SETMODE
#include <fcntl.h>		/* to declare setmode()'s parameter macros */
/* If you have setmode() but not <io.h>, just delete this line: */
#include <io.h>			/* to declare setmode() */
#endif


/*
 * Signal catcher to ensure that temporary files are removed before aborting.
 * NB: for Amiga Manx C this is actually a global routine named _abort();
 * we put "#define signal_catcher _abort" in jconfig.h.  Talk about bogus...
 */

#ifdef NEED_SIGNAL_CATCHER

static j_common_ptr sig_cinfo;

void				/* must be global for Manx C */
signal_catcher (int signum)
{
  if (sig_cinfo != NULL) {
    if (sig_cinfo->err != NULL) /* turn off trace output */
      sig_cinfo->err->trace_level = 0;
    jpeg_destroy(sig_cinfo);	/* clean up memory allocation & temp files */
  }
  exit(EXIT_FAILURE);
}


GLOBAL(void)
enable_signal_catcher (j_common_ptr cinfo)
{
  sig_cinfo = cinfo;
#ifdef SIGINT			/* not all systems have SIGINT */
  signal(SIGINT, signal_catcher);
#endif
#ifdef SIGTERM			/* not all systems have SIGTERM */
  signal(SIGTERM, signal_catcher);
#endif
}

#endif


/*
 * Optional progress monitor: display a percent-done figure on stderr.
 */

#ifdef PROGRESS_REPORT

METHODDEF(void)
progress_monitor (j_common_ptr cinfo)
{
  cd_progress_ptr prog = (cd_progress_ptr) cinfo->progress;
  int total_passes = prog->pub.total_passes + prog->total_extra_passes;
  int percent_done = (int) (prog->pub.pass_counter*100L/prog->pub.pass_limit);

  if (percent_done != prog->percent_done) {
    prog->percent_done = percent_done;
    if (total_passes > 1) {
      fprintf(stderr, "\rPass %d/%d: %3d%% ",
	      prog->pub.completed_passes + prog->completed_extra_passes + 1,
	      total_passes, percent_done);
    } else {
      fprintf(stderr, "\r %3d%% ", percent_done);
    }
    fflush(stderr);
  }
}


GLOBAL(void)
start_progress_monitor (j_common_ptr cinfo, cd_progress_ptr progress)
{
  /* Enable progress display, unless trace output is on */
  if (cinfo->err->trace_level == 0) {
    progress->pub.progress_monitor = progress_monitor;
    progress->completed_extra_passes = 0;
    progress->total_extra_passes = 0;
    progress->percent_done = -1;
    cinfo->progress = &progress->pub;
  }
}


GLOBAL(void)
end_progress_monitor (j_common_ptr cinfo)
{
  /* Clear away progress display */
  if (cinfo->err->trace_level == 0) {
    fprintf(stderr, "\r                \r");
    fflush(stderr);
  }
}

#endif


/*
 * Case-insensitive matching of possibly-abbreviated keyword switches.
 * keyword is the constant keyword (must be lower case already),
 * minchars is length of minimum legal abbreviation.
 */

GLOBAL(boolean)
keymatch (char * arg, const char * keyword, int minchars)
{
  register int ca, ck;
  register int nmatched = 0;

  while ((ca = *arg++) != '\0') {
    if ((ck = *keyword++) == '\0')
      return FALSE;		/* arg longer than keyword, no good */
    if (isupper(ca))		/* force arg to lcase (assume ck is already) */
      ca = tolower(ca);
    if (ca != ck)
      return FALSE;		/* no good */
    nmatched++;			/* count matched characters */
  }
  /* reached end of argument; fail if it's too short for unique abbrev */
  if (nmatched < minchars)
    return FALSE;
  return TRUE;			/* A-OK */
}


/*
 * Routines to establish binary I/O mode for stdin and stdout.
 * Non-Unix systems often require some hacking to get out of text mode.
 */

GLOBAL(FILE *)
read_stdin (void)
{
  FILE * input_file = stdin;

#ifdef USE_SETMODE		/* need to hack file mode? */
  setmode(fileno(stdin), O_BINARY);
#endif
#ifdef USE_FDOPEN		/* need to re-open in binary mode? */
  if ((input_file = fdopen(fileno(stdin), READ_BINARY)) == NULL) {
    fprintf(stderr, "Cannot reopen stdin\n");
    exit(EXIT_FAILURE);
  }
#endif
  return input_file;
}


GLOBAL(FILE *)
write_stdout (void)
{
  FILE * output_file = stdout;

#ifdef USE_SETMODE		/* need to hack file mode? */
  setmode(fileno(stdout), O_BINARY);
#endif
#ifdef USE_FDOPEN		/* need to re-open in binary mode? */
  if ((output_file = fdopen(fileno(stdout), WRITE_BINARY)) == NULL) {
    fprintf(stderr, "Cannot reopen stdout\n");
    exit(EXIT_FAILURE);
  }
#endif
  return output_file;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\jpeg\jpgmemmgr.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   shared.cpp
*
* Abstract:
*
*   Constructs shared between the decoder and the encoder.  I put them
*   in a separate file so that if one wants to link in just the encoder
*   from jpeg.lib, they won't pull in the object files for the decoder
*   and exif.
*
* Revision History:
*
*   9/24/1999 Ori Gershony (OriG)
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "jpgcodec.hpp"

VOID jpeg_error_exit(j_common_ptr cinfo)
{
    RaiseException(0, 0, 0, NULL);
}

// Memory manager functions.  Note that the JPEG MMX codes require 64-bit
// aligned memory.  On NT malloc always returns 64-bit aligned memory,
// but on Win9x the memory is only 32-bit aligned.  So our memory manager
// guarantees 64-bit alignment on top of malloc calls.

extern "C"
{
#include "jmemsys.h"

#define ALIGN_SIZE sizeof(double)  // must be a power of 2 and 
                                   // bigger than a pointer

GLOBAL(void FAR *)
jpeg_get_large (j_common_ptr cinfo, size_t sizeofobject)
{
    INT_PTR p = (INT_PTR) GpMalloc(sizeofobject + ALIGN_SIZE);
    if ( p == NULL )
    {
        return NULL;
    }

    INT_PTR *alignedPtr = (INT_PTR *) ((p + ALIGN_SIZE) & ~(ALIGN_SIZE - 1));
    alignedPtr[-1] = p;

    return (void *) alignedPtr;    
}

GLOBAL(void)
jpeg_free_large (j_common_ptr cinfo, void FAR * object, size_t sizeofobject)
{
    GpFree(((void **) object)[-1]);
}

GLOBAL(void *)
jpeg_get_small (j_common_ptr cinfo, size_t sizeofobject)
{
    return jpeg_get_large(cinfo, sizeofobject);
}

GLOBAL(void)
jpeg_free_small (j_common_ptr cinfo, void * object, size_t sizeofobject)
{
    jpeg_free_large(cinfo, object, sizeofobject);
}

GLOBAL(long)
jpeg_mem_available (j_common_ptr cinfo, long min_bytes_needed,
                    long max_bytes_needed, long already_allocated)
{
  return max_bytes_needed;
}

GLOBAL(void)
jpeg_open_backing_store (j_common_ptr cinfo, backing_store_ptr info,
			 long total_bytes_needed)
{
    jpeg_error_exit(cinfo);
}

GLOBAL(long) jpeg_mem_init (j_common_ptr cinfo) { return 0;}
GLOBAL(void) jpeg_mem_term (j_common_ptr cinfo) {}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\jpeg\jpgencoder.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   jpgencoder.cpp
*
* Abstract:
*
*   Implementation of the jpeg filter encoder.  This file contains the
*   methods for both the encoder (IImageEncoder) and the encoder's sink
*  (IImageSink).
*
* Revision History:
*
*   5/10/1999 OriG
*       Created it.
*
*   07/17/1999 Min Liu took over
*       added bunch of new features and bug fixing
*
\**************************************************************************/

#include "precomp.hpp"
#include "jpgcodec.hpp"
#include "transupp.h"
#include "appproc.hpp"

// JPEG decompression data source module

class jpeg_datadest : public jpeg_destination_mgr
{
public:

    jpeg_datadest(IStream* stream)
    {
        init_destination    = jpeg_datadest::InitDestination;
        term_destination    = jpeg_datadest::TermDestination;
        empty_output_buffer = jpeg_datadest::EmptyBuffer;
        next_output_byte = buffer;
        free_in_buffer = JPEG_OUTBUF_SIZE;
        this->stream = stream;
    }

private:

    static void
    InitDestination(j_compress_ptr cinfo)
    {
        jpeg_datadest* dest = (jpeg_datadest*) cinfo->dest;
        
        dest->next_output_byte = dest->buffer;
        dest->free_in_buffer = JPEG_OUTBUF_SIZE;
    }

    static void
    TermDestination(j_compress_ptr cinfo)
    {

        jpeg_datadest* dest = (jpeg_datadest*) cinfo->dest;
        
        if (dest->free_in_buffer < JPEG_OUTBUF_SIZE) 
        {
            UINT bytesToWrite = JPEG_OUTBUF_SIZE - dest->free_in_buffer;
            ULONG cbWritten=0;
            if ((FAILED(dest->stream->Write(dest->buffer, 
                bytesToWrite, &cbWritten))) ||
                (cbWritten != bytesToWrite))
            {
                WARNING(("jpeg_datadest::TermDestination--write failed"));
            }
        }
    }

    static BOOL
    EmptyBuffer(j_compress_ptr cinfo)
    {
        jpeg_datadest* dest = (jpeg_datadest*) cinfo->dest;

        ULONG cbWritten=0;
        if ((FAILED(dest->stream->Write(dest->buffer, 
                                        JPEG_OUTBUF_SIZE, 
                                        &cbWritten))) ||
            (cbWritten != JPEG_OUTBUF_SIZE))
        {
            WARNING(("jpeg_datadest::EmptyBuffer -- stream write failed"));
            return FALSE;
        }

        dest->next_output_byte = dest->buffer;
        dest->free_in_buffer = JPEG_OUTBUF_SIZE;
        return TRUE;        
    }
    
private:

    enum { JPEG_OUTBUF_SIZE = 4096 };

    IStream* stream;
    JOCTET buffer[JPEG_OUTBUF_SIZE];
};

VOID jpeg_error_exit(j_common_ptr cinfo);  // Implemented in jpgmemmgr.cpp

// =======================================================================
// IImageEncoder methods
// =======================================================================

/**************************************************************************\
*
* Function Description:
*
*     Initialize the image encoder
*
* Arguments:
*
*     stream - input stream to write encoded data
*
* Return Value:
*
*   Status code
*
\**************************************************************************/
    
STDMETHODIMP
GpJpegEncoder::InitEncoder(
    IN IStream* stream
    )
{
    // Make sure we haven't been initialized already

    if (pIoutStream)
    {
        WARNING(("Output stream is NULL"));
        return E_FAIL;
    }

    // Keep a reference on the input stream

    stream->AddRef();
    pIoutStream = stream;
    EP_Quality = -1;
    RequiredTransformation = JXFORM_NONE;

    scanlineBuffer[0] = NULL;
    IsCompressFinished = TRUE;
    HasAPP1Marker = FALSE;
    APP1MarkerLength = 0;
    APP1MarkerBufferPtr = NULL;
    HasAPP2Marker = FALSE;
    APP2MarkerLength = 0;
    APP2MarkerBufferPtr = NULL;
    HasICCProfileChanged = FALSE;

    HasSetLuminanceTable = FALSE;
    HasSetChrominanceTable = FALSE;

    HasSetDestColorSpace = FALSE;
    DestColorSpace = JCS_UNKNOWN;
    AllowToTrimEdge = FALSE;
    m_fSuppressAPP0 = FALSE;
    SrcInfoPtr = NULL;

    // Create a JPEG compressor
    // Note: Since we have more than one ways calling routines in this class to
    // encoder an image: BeginSink(), EndSink() pair and PushRawInfo() or
    // PushRawData(). It's better to create the compressor here

    __try
    {
        compress_info.err = jpeg_std_error(&jerr);
        jerr.error_exit = jpeg_error_exit;
        
        jpeg_create_compress(&compress_info);

        // Specify a data destination

        datadest = new jpeg_datadest(pIoutStream);
        if (datadest == NULL) 
        {
            return E_OUTOFMEMORY;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING(("GpJpegEncoder::InitEncoder----Hit exception"));
        return E_FAIL;
    }

    return S_OK;
}// InitEncoder()
        
/**************************************************************************\
*
* Function Description:
*
*     Cleans up the image encoder
*
* Arguments:
*
*     NONE
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpJpegEncoder::TerminateEncoder()
{
    HRESULT hResult = S_OK;

    // Finish and destroy the compressor

    __try
    {
        if ( IsCompressFinished == FALSE )
        {
            jpeg_finish_compress(&compress_info);
            IsCompressFinished = TRUE;
        }

        jpeg_destroy_compress(&compress_info);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING(("GpJpegEncoder::TerminateEncoder---Hit exception"));

        // jpeg_finish_compress() might hit exception when writing the remaining
        // bits to the stream, say user pulls the disk/CF card out. But we still
        // need to destroy the compressor so that we won't have memory leak here

        jpeg_destroy_compress(&compress_info);
        hResult = E_FAIL;
    }

    if (datadest) 
    {
        delete datadest;
        datadest = NULL;
    }

    // Note: GpFree can handle NULL pointer. So we don't need to check NULL here

    GpFree(APP1MarkerBufferPtr);
    APP1MarkerBufferPtr = NULL;
    
    GpFree(APP2MarkerBufferPtr);
    APP2MarkerBufferPtr = NULL;
    
    // Release the input stream

    if(pIoutStream)
    {
        pIoutStream->Release();
        pIoutStream = NULL;
    }

    if (lastBufferAllocated) 
    {
        WARNING(("JpegEnc::TermEnc-Should call ReleasePixelDataBuffer first"));
        GpFree(lastBufferAllocated);
        lastBufferAllocated = NULL;
    }
    
    if (scanlineBuffer[0] != NULL)
    {
        WARNING(("JpegEncoder::TerminateEncoder-need to call EndDecode first"));
        GpFree(scanlineBuffer[0]);
        scanlineBuffer[0] = NULL;
    }    
    
    return hResult;
}// TerminateEncoder()

/**************************************************************************\
*
* Function Description:
*
*     Returns a pointer to the vtable of the encoder sink.  The caller will
*     push the bitmap bits into the encoder sink, which will encode the
*     image.
*
* Arguments:
*
*     sink - upon exit will contain a pointer to the IImageSink vtable
*       of this object
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpJpegEncoder::GetEncodeSink(
    OUT IImageSink** sink
    )
{
    AddRef();
    *sink = static_cast<IImageSink*>(this);

    return S_OK;
}// GetEncodeSink()

/**************************************************************************\
*
* Function Description:
*
*     Set active frame dimension
*
* Arguments:
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpJpegEncoder::SetFrameDimension(
    IN const GUID* dimensionID
    )
{
    return E_NOTIMPL;
}

HRESULT
GpJpegEncoder::GetEncoderParameterListSize(
    OUT UINT* size
    )
{
    if ( size == NULL )
    {
        WARNING(("GpJpegEncoder::GetEncoderParameterListSize---Invalid input"));
        return E_INVALIDARG;
    }

    // Note: For JPEG encoder, we currently support following 4 GUIDs
    // ENCODER_QUALITY---Which has 1 return value of ValueTypeLongRange and it
    // takes 2 UINT.
    // ENCODER_TRANSFORMATION---Which has 5 return values of ValueTypeLong. So
    // we need 5 UINT for it.
    // ENCODER_LUMINANCE_TABLE--Which has 1 return value of ValueTypeUnderfined
    // and it doesn't need size
    // ENCODER_CHROMINANCE_TABLE--Which has 1 return value of
    // ValueTypeUnderfined and it doesn't need size
    //
    // This comes the formula below:

    UINT uiEncoderParamLength = sizeof(EncoderParameters)
                              + 4 * sizeof(EncoderParameter)
                              + 7 * sizeof(UINT);

    *size = uiEncoderParamLength;

    return S_OK;
}// GetEncoderParameterListSize()

HRESULT
GpJpegEncoder::GetEncoderParameterList(
    IN  UINT   size,
    OUT EncoderParameters* Params
    )
{
    // Note: For JPEG encoder, we currently support following 4 GUIDs
    // ENCODER_QUALITY---Which has 1 return value of ValueTypeRANGE and it takes
    // 2 UINT.
    // ENCODER_TRANSFORMATION---Which has 5 return values of ValueTypeLONG. So
    // we need 5 UINT for it.
    // ENCODER_LUMINANCE_TABLE--Which has 1 return value of ValueTypeUnderfined
    // and it doesn't need size
    // ENCODER_CHROMINANCE_TABLE--Which has 1 return value of
    // ValueTypeUnderfined and it doesn't need size
    // This comes the formula below:

    UINT uiEncoderParamLength = sizeof(EncoderParameters)
                              + 4 * sizeof(EncoderParameter)
                              + 7 * sizeof(UINT);


    if ( (size != uiEncoderParamLength) || (Params == NULL) )
    {
        WARNING(("GpJpegEncoder::GetEncoderParameterList---Invalid input"));
        return E_INVALIDARG;
    }

    Params->Count = 4;
    Params->Parameter[0].Guid = ENCODER_TRANSFORMATION;
    Params->Parameter[0].NumberOfValues = 5;
    Params->Parameter[0].Type = EncoderParameterValueTypeLong;

    Params->Parameter[1].Guid = ENCODER_QUALITY;
    Params->Parameter[1].NumberOfValues = 1;
    Params->Parameter[1].Type = EncoderParameterValueTypeLongRange;
    
    Params->Parameter[2].Guid = ENCODER_LUMINANCE_TABLE;
    Params->Parameter[2].NumberOfValues = 0;
    Params->Parameter[2].Type = EncoderParameterValueTypeShort;
    Params->Parameter[2].Value = NULL;
    
    Params->Parameter[3].Guid = ENCODER_CHROMINANCE_TABLE;
    Params->Parameter[3].NumberOfValues = 0;
    Params->Parameter[3].Type = EncoderParameterValueTypeShort;
    Params->Parameter[3].Value = NULL;
    
    UINT*   puiTemp = (UINT*)((BYTE*)&Params->Parameter[0]
                              + 4 * sizeof(EncoderParameter));
    
    puiTemp[0] = EncoderValueTransformRotate90;
    puiTemp[1] = EncoderValueTransformRotate180;
    puiTemp[2] = EncoderValueTransformRotate270;
    puiTemp[3] = EncoderValueTransformFlipHorizontal;
    puiTemp[4] = EncoderValueTransformFlipVertical;
    puiTemp[5] = 0;
    puiTemp[6] = 100;

    Params->Parameter[0].Value = (VOID*)puiTemp;
    Params->Parameter[1].Value = (VOID*)(puiTemp + 5);

    return S_OK;
}// GetEncoderParameterList()

/**************************************************************************\
*
* Function Description:
*
*   Set encoder parameters
*
* Arguments:
*
*   pEncoderParams - Specifies the encoder parameter to be set
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpJpegEncoder::SetEncoderParameters(
    IN const EncoderParameters* pEncoderParams
    )
{
    if ( (NULL == pEncoderParams) || (pEncoderParams->Count == 0) )
    {
        WARNING(("GpJpegEncoder::SetEncoderParameters--invalid input args"));
        return E_INVALIDARG;
    }

    for ( UINT i = 0; (i < pEncoderParams->Count); ++i )
    {
        // Figure out which parameter the caller wants to set

        if ( pEncoderParams->Parameter[i].Guid == ENCODER_TRANSFORMATION )
        {
            // For transformation, the type has to be "ValueTypeLong" and
            // "NumberOfValues" should be "1" because you can set only one
            // transformation at a time

            if ( (pEncoderParams->Parameter[i].Type
                  != EncoderParameterValueTypeLong)
               ||(pEncoderParams->Parameter[i].NumberOfValues != 1)
               ||(pEncoderParams->Parameter[i].Value == NULL) )
            {
                WARNING(("Jpeg::SetEncoderParameters--invalid input args"));
                return E_INVALIDARG;
            }

            RequiredTransformation =
                            *((UINT*)pEncoderParams->Parameter[i].Value);
        }// ENCODER_TRANSFORMATION
        else if ( pEncoderParams->Parameter[i].Guid == ENCODER_QUALITY )
        {
            // For quality setting, the type has to be "ValueTypeLong" and
            // "NumberOfValues" should be "1" because you can set only one
            // quality at a time
            
            if ( (pEncoderParams->Parameter[i].Type
                  != EncoderParameterValueTypeLong)
               ||(pEncoderParams->Parameter[i].NumberOfValues != 1)
               ||(pEncoderParams->Parameter[i].Value == NULL) )
            {
                WARNING(("Jpeg::SetEncoderParameters--invalid input args"));
                return E_INVALIDARG;
            }
            
            EP_Quality = *((UINT*)pEncoderParams->Parameter[i].Value);
        }// ENCODER_QUALITY
        else if ( pEncoderParams->Parameter[i].Guid == ENCODER_LUMINANCE_TABLE )
        {
            // Set the luminance quantization table

            if ( (pEncoderParams->Parameter[i].Type
                  != EncoderParameterValueTypeShort)
               ||(pEncoderParams->Parameter[i].NumberOfValues != DCTSIZE2)
               ||(pEncoderParams->Parameter[i].Value == NULL) )
            {
                WARNING(("Jpeg::SetEncoderParameters--invalid input args"));
                return E_INVALIDARG;
            }
            
            GpMemcpy(LuminanceTable,
                     (UINT16*)(pEncoderParams->Parameter[i].Value),
                     sizeof(UINT16)
                     * pEncoderParams->Parameter[i].NumberOfValues);

            HasSetLuminanceTable = TRUE;
        }
        else if (pEncoderParams->Parameter[i].Guid == ENCODER_CHROMINANCE_TABLE)
        {
            // Set the chrominance quantization table

            if ( (pEncoderParams->Parameter[i].Type
                  != EncoderParameterValueTypeShort)
               ||(pEncoderParams->Parameter[i].NumberOfValues != DCTSIZE2)
               ||(pEncoderParams->Parameter[i].Value == NULL) )
            {
                WARNING(("Jpeg::SetEncoderParameters--invalid input args"));
                return E_INVALIDARG;
            }
            
            GpMemcpy(ChrominanceTable,
                     (UINT16*)(pEncoderParams->Parameter[i].Value),
                     sizeof(UINT16)
                     * pEncoderParams->Parameter[i].NumberOfValues);
            
            HasSetChrominanceTable = TRUE;
        }
        else if (pEncoderParams->Parameter[i].Guid == ENCODER_TRIMEDGE)
        {
            // Let the encoder know if the caller wants us to trim the edge or
            // not if the image size doesn't meet the requirement.

            if ((pEncoderParams->Parameter[i].Type !=
                 EncoderParameterValueTypeByte) ||
                (pEncoderParams->Parameter[i].NumberOfValues != 1) ||
                (pEncoderParams->Parameter[i].Value == NULL))
            {
                WARNING(("Jpeg::SetEncoderParameters--invalid input args"));
                return E_INVALIDARG;
            }

            AllowToTrimEdge = *((BYTE*)pEncoderParams->Parameter[i].Value);
        }
        else if (pEncoderParams->Parameter[i].Guid == ENCODER_SUPPRESSAPP0)
        {
            // Let the encoder know if the caller wants us to suppress APP0 or
            // not

            if ((pEncoderParams->Parameter[i].Type !=
                 EncoderParameterValueTypeByte) ||
                (pEncoderParams->Parameter[i].NumberOfValues != 1) ||
                (pEncoderParams->Parameter[i].Value == NULL))
            {
                WARNING(("Jpeg::SetEncoderParameters--invalid input args"));
                return E_INVALIDARG;
            }

            m_fSuppressAPP0 = *((BYTE*)pEncoderParams->Parameter[i].Value);
        }
#if 0
        // !!! DON'T REMOVE THIS CODE BELO. It will be enabled in V2
        //
        // In order to make this work, I need to add:
        // New GUID: ENCODER_COLORSPACE
        // New color space value: EncoderValueColorSpaceYCCK,
        //                        EncoderValueColorSpaceGRAY
        //                        EncoderValueColorSpaceRGB
        //                        EncoderValueColorSpaceYCBCR
        //                        EncoderValueColorSpaceCMYK
        // But this is a DCR..... MinLiu 08/31/00

        else if (pEncoderParams->Parameter[i].Guid == ENCODER_COLORSPACE)
        {
            // Set the destination color space

            if ( (pEncoderParams->Parameter[i].Type != EncoderParameterValueTypeLong)
               ||(pEncoderParams->Parameter[i].NumberOfValues != 1)
               ||(pEncoderParams->Parameter[i].Value == NULL) )
            {
                WARNING(("Jpeg::SetEncoderParameters--invalid input args"));
                return E_INVALIDARG;
            }

            HasSetDestColorSpace = TRUE;
            DestColorSpace = *((UINT*)pEncoderParams->Parameter[i].Value);
        }
#endif
        else
        {
            // Ignore this encoder parameter

            continue;
        }
    }// Loop all the settings

    return S_OK;
}// SetEncoderParameters()

// =======================================================================
// IImageSink methods
// =======================================================================

/**************************************************************************\
*
* Function Description:
*
*     Caches the image info structure and initializes the sink state
*
* Arguments:
*
*     imageInfo - information about the image and format negotiations
*     subarea - the area in the image to deliver into the sink, in our
*       case the whole image.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP 
GpJpegEncoder::BeginSink(
    IN OUT ImageInfo* imageInfo,
    OUT OPTIONAL RECT* subarea
    )
{
    if (subarea) 
    {
        // Deliver the whole image to the encoder

        subarea->left = subarea->top = 0;
        subarea->right  = imageInfo->Width;
        subarea->bottom = imageInfo->Height;
    }

    if ((imageInfo->PixelFormat != PIXFMT_32BPP_RGB) && 
        (imageInfo->PixelFormat != PIXFMT_32BPP_ARGB) &&
        (imageInfo->PixelFormat != PIXFMT_32BPP_PARGB))
    {
        imageInfo->PixelFormat = PIXFMT_32BPP_ARGB;
    }

    encoderImageInfo = *imageInfo;

    // Initialize jpeg compression

    __try
    {
        // ""datadest" is created in InitEncoder() and will be freed in
        // TerminateEncoder()
        
        compress_info.dest = datadest;
   
        // Set compression state

        compress_info.image_width      = imageInfo->Width;
        compress_info.image_height     = imageInfo->Height;
        compress_info.input_components = 3;
        compress_info.in_color_space   = JCS_RGB;
        
        jpeg_set_defaults(&compress_info);

        // The rule for NOT writing JFIF header (write_JFIF_header) is:
        // 1) If the source image doesn't have JFIF header, say an EXIF image,
        // then we don't write JFIF header
        // 2) If we don't have the source and the caller wants to suppress APP0,
        // then we don't write it
        // Note: by default write_JFIF_header is TRUE

        if (SrcInfoPtr)
        {
            // We have a pointer to the source image. Then it is easy, just
            // check if it has JFIF header or not. If it doesn't have it, then
            // we don't write JFIF header.

            if (SrcInfoPtr->saw_JFIF_marker == FALSE)
            {
                compress_info.write_JFIF_header = FALSE;
            }
        }
        else if (m_fSuppressAPP0 == TRUE)
        {
            // We don't have the source image and the caller wants to suppress
            // APP0, then don't write APP0

            compress_info.write_JFIF_header = FALSE;
        }

#if 0 // Need to be turned on when the DCR is approaved

        if ( HasSetDestColorSpace == TRUE )
        {
            // Validate input and output color space to see if we can do it or
            // not. If not, return failure.
            // Note: As time goes by, we might expand this color space
            // conversion metrix. For now, we hard coded input as JCS_RGB (The
            // limitation of GDI+'s color pixel format and color conversion)
            // and force the dest with certain limited color space for each
            // source color space

            switch ( DestColorSpace )
            {
            case JCS_GRAYSCALE:
                // For destination color space as grayscale, the input can be
                // one of these {GRAYSCALE, RGB, YCBCR}

                if ( ( compress_info.in_color_space != JCS_GRAYSCALE )
                   &&( compress_info.in_color_space != JCS_RGB )
                   &&( compress_info.in_color_space != JCS_YCbCr ) )
                {
                    WARNING(("JpegEncoder::BeginSink--Wrong dest color space"));
                    return E_INVALIDARG;
                }
                
                // We can the source to dest color conversion

                compress_info.jpeg_color_space = JCS_GRAYSCALE;
                compress_info.num_components = 1;

                break;

            case JCS_RGB:
                // For destination color space as RGB, the input can be
                // one of these {RGB}

                if ( compress_info.in_color_space != JCS_RGB )
                {
                    WARNING(("JpegEncoder::BeginSink--Wrong dest color space"));
                    return E_INVALIDARG;
                }
                
                compress_info.jpeg_color_space = JCS_RGB;
                compress_info.num_components = 3;

                break;

            case JCS_YCbCr:
                // For destination color space as YCBCR, the input can be
                // one of these {RGB, YCBCR}

                if ( ( compress_info.in_color_space != JCS_RGB )
                   &&( compress_info.in_color_space != JCS_YCbCr ) )
                {
                    WARNING(("JpegEncoder::BeginSink--Wrong dest color space"));
                    return E_INVALIDARG;
                }
                
                // We can the source to dest color conversion

                compress_info.jpeg_color_space = JCS_YCbCr;
                compress_info.num_components = 3;

                break;
            
            case JCS_YCCK:
                // For destination color space as YCCK, the input can be
                // one of these {CMYK, YCCK}

                if ( ( compress_info.in_color_space != JCS_CMYK )
                   &&( compress_info.in_color_space != JCS_YCCK ) )
                {
                    WARNING(("JpegEncoder::BeginSink--Wrong dest color space"));
                    return E_INVALIDARG;
                }
                
                // We can the source to dest color conversion

                compress_info.jpeg_color_space = JCS_YCCK;
                compress_info.num_components = 4;

                break;
            
            case JCS_CMYK:
                // For destination color space as CMYK, the input can be
                // one of these {CMYK}

                if ( compress_info.in_color_space != JCS_CMYK )
                {
                    WARNING(("JpegEncoder::BeginSink--Wrong dest color space"));
                    return E_INVALIDARG;
                }
                
                // We can the source to dest color conversion

                compress_info.jpeg_color_space = JCS_CMYK;
                compress_info.num_components = 4;

                break;
            
            default:
                break;
            }// switch ( DestColorSpace )
        }// if ( HasSetDestColorSpace == TRUE )
#endif

        // Set encoding quality. If the caller set the quantization table, then
        // we set the table ourself. Otherwise, set the quality level only
        // Note: In a JFIF file, the only thing that is stored are the 2
        // (luminance and chrominance) 8 x 8 quantization tables. The scaling
        // (or quality) factor is not stored. Setting the scale (quality) factor
        // and a pair of tables is mutually exclusive. So if these two tables
        // are set, we just use the scale factor as 100, means no scale to the
        // tables.

        UINT    tempTable[DCTSIZE2];
        
        if ( HasSetLuminanceTable == TRUE )
        {
            // Set quantization table here.
            // Note: since jpeg_add_quant_table() tables an UINT table, so we
            // have to convert UINT16 table to UINT table and pass it down

            for ( int i = 0; i< DCTSIZE2; ++i )
            {
                tempTable[i] = (UINT)LuminanceTable[i];
            }

            // Here "100" means scale factor 100 (quality wise. 100 is a
            // percentage value)
            // "TRUE" means to force baseline, that is, the computed
            // quantization table entries are limited to 1..255 for JPEG
            // baseline compatibility.

            jpeg_add_quant_table(&compress_info, 0, tempTable,
                                 100, TRUE);

            if ( HasSetChrominanceTable == TRUE )
            {
                for ( int i = 0; i< DCTSIZE2; ++i )
                {
                    tempTable[i] = (UINT)ChrominanceTable[i];
                }

                jpeg_add_quant_table(&compress_info, 1, tempTable,
                                     100, TRUE);
            }
        }
        else if ( EP_Quality != -1 )
        {
            // The caller only set the quality level

            jpeg_set_quality(&compress_info, EP_Quality, TRUE);
        }

        // Set DPI info

        compress_info.density_unit   = 1;         // Unit is dot/inch
        compress_info.X_density      = (UINT16)(imageInfo->Xdpi + 0.5);
        compress_info.Y_density      = (UINT16)(imageInfo->Ydpi + 0.5);
        
        // Start the compression

        jpeg_start_compress(&compress_info, TRUE);

        IsCompressFinished = FALSE;
        
        // Write out the APP1 and APP2 marker if necessary
        
        if (HasAPP1Marker == TRUE)
        {
            jpeg_write_marker(&compress_info, 
                              (JPEG_APP0 + 1),       // Marker type
                              APP1MarkerBufferPtr,   // bits
                              APP1MarkerLength);     // Total length
            
            // Set a flag so we don't need to copy APP1 from the source to the
            // dest since we have written it out above.

            compress_info.write_APP1_marker = FALSE;
        }
        
        if (HasAPP2Marker == TRUE)
        {
            jpeg_write_marker(&compress_info, 
                              (JPEG_APP0 + 2),       // Marker type
                              APP2MarkerBufferPtr,   // bits
                              APP2MarkerLength);     // Total length
            
            // Set a flag so we don't need to copy APP2 from the source to the
            // dest since we have written it out above.

            compress_info.write_APP2_marker = FALSE;
        }
        
        // If we have a source image pointer, then copy all the private APP
        // marker

        if (SrcInfoPtr)
        {
            jcopy_markers_execute(SrcInfoPtr, &compress_info, JCOPYOPT_ALL);
        }        
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING(("GpJpegEncoder::BeginSink---Hit exception"));
        return E_FAIL;
    }

    ASSERT(scanlineBuffer[0] == NULL);
    scanlineBuffer[0] = (JSAMPROW) GpMalloc (imageInfo->Width * 3);
    if (scanlineBuffer[0] == NULL) 
    {
        WARNING(("GpJpegEncoder::BeginSink---GpMalloc failed"));
        return E_OUTOFMEMORY;
    }
       
    //Require TOPDOWN and FULLWIDTH and ask for properties

    imageInfo->Flags |= SINKFLAG_TOPDOWN
                      | SINKFLAG_FULLWIDTH;

    //Disallow SCALABLE, PARTIALLY_SCALABLE, MULTIPASS and COMPOSITE

    imageInfo->Flags &= ~SINKFLAG_SCALABLE
                      & ~SINKFLAG_PARTIALLY_SCALABLE
                      & ~SINKFLAG_MULTIPASS
                      & ~SINKFLAG_COMPOSITE;

    // If the decoder is JPEG decoder, then we ask it to push the raw property
    // header if it wants

    if ( imageInfo->RawDataFormat == IMGFMT_JPEG )
    {
        imageInfo->Flags |= SINKFLAG_WANTPROPS;
    }

    return S_OK;
}// BeginSink()

/**************************************************************************\
*
* Function Description:
*
*     Cleans up the sink state
*
* Arguments:
*
*     statusCode - the reason why the sink is terminating
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP 
GpJpegEncoder::EndSink(
    IN HRESULT statusCode
    )
{
    HRESULT hResult = S_OK;
    
    __try
    {
        if ( IsCompressFinished == FALSE )
        {
            jpeg_finish_compress(&compress_info);
            IsCompressFinished = TRUE;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING(("GpJpegEncoder::EndSink---Hit exception"));
        
        // jpeg_finish_compress() might hit exception when writing the remaining
        // bits to the stream, say user pulls the disk/CF card out. But we still
        // need to destroy the compressor so that we won't have memory leak here
        
        jpeg_destroy_compress(&compress_info);
        hResult = E_FAIL;
    }

    if (scanlineBuffer[0] != NULL)
    {
        GpFree(scanlineBuffer[0]);
        scanlineBuffer[0] = NULL;
    }

    if (FAILED(hResult)) 
    {
        return hResult;
    }

    return statusCode;
}// EndSink()
    
/**************************************************************************\
*
* Function Description:
*
*     Sets the bitmap palette
*
* Arguments:
*
*     palette - The palette to set in the sink
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP 
GpJpegEncoder::SetPalette(
    IN const ColorPalette* palette
    )
{
    // Don't care about palette

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Gives a buffer to the sink where data is to be deposited    
*
* Arguments:
*
*     rect - Specifies the interested area of the bitmap
*     pixelFormat - Specifies the desired pixel format
*     lastPass - Whether this the last pass over the specified area
*     bitmapData - Returns information about pixel data buffer
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpJpegEncoder::GetPixelDataBuffer(
    IN const RECT* rect, 
    IN PixelFormatID pixelFormat,
    IN BOOL lastPass,
    OUT BitmapData* bitmapData
    )
{
    if ((rect->left != 0) || (rect->right != (INT) encoderImageInfo.Width)) 
    {
        WARNING(("GpJpegEncoder::GetPixelDataBuffer -- must be same width as image"));
        return E_INVALIDARG;
    }

    if (rect->top != (INT) compress_info.next_scanline) 
    {
        WARNING(("GpJpegEncoder::GetPixelDataBuffer -- bad value for rect->top"));
        return E_INVALIDARG;
    }

    if (rect->bottom > (INT) encoderImageInfo.Height) 
    {
        WARNING(("GpJpegEncoder::GetPixelDataBuffer -- rect->bottom too high"));
        return E_INVALIDARG;
    }

    if ((pixelFormat != PIXFMT_32BPP_RGB) &&
        (pixelFormat != PIXFMT_32BPP_ARGB) &&
        (pixelFormat != PIXFMT_32BPP_PARGB))
    {
        WARNING(("GpJpegEncoder::GetPixelDataBuffer -- bad pixel format"));
        return E_INVALIDARG;
    }

    if (!lastPass)
    {
        WARNING(("GpJpegEncoder::GetPixelDataBuffer -- must receive last pass pixels"));
        return E_INVALIDARG;
    }

    bitmapData->Width       = encoderImageInfo.Width;
    bitmapData->Height      = rect->bottom - rect->top;
    bitmapData->Stride      = encoderImageInfo.Width * 4;
    bitmapData->PixelFormat = encoderImageInfo.PixelFormat;
    bitmapData->Reserved    = 0;

    encoderRect = *rect;
    
    if (!lastBufferAllocated) 
    {
        lastBufferAllocated = GpMalloc(bitmapData->Stride * bitmapData->Height);
        if (!lastBufferAllocated) 
        {
            return E_OUTOFMEMORY;
        }
        bitmapData->Scan0 = lastBufferAllocated;
    }
    else
    {
        WARNING(("GpJpegEncoder::GetPixelDataBuffer -- need to first free previous buffer"));
        return E_FAIL;
    }

    return S_OK;
}

/**************************************************************************\
*
* Function Description:
*
*     Write out the data from the sink's buffer into the stream
*
* Arguments:
*
*     bitmapData - Buffer filled by previous GetPixelDataBuffer call
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpJpegEncoder::ReleasePixelDataBuffer(
    IN const BitmapData* bitmapData
    )
{
    HRESULT hresult;

    hresult = PushPixelData(&encoderRect, bitmapData, TRUE);

    if (bitmapData->Scan0 == lastBufferAllocated) 
    {
        GpFree(bitmapData->Scan0);
        lastBufferAllocated = NULL;
    }

    return hresult;
}
    

/**************************************************************************\
*
* Function Description:
*
*     Push data into stream (buffer supplied by caller)
*
* Arguments:
*
*     rect - Specifies the affected area of the bitmap
*     bitmapData - Info about the pixel data being pushed
*     lastPass - Whether this is the last pass over the specified area
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpJpegEncoder::PushPixelData(
    IN const RECT* rect,
    IN const BitmapData* bitmapData,
    IN BOOL lastPass
    )
{
    if ((rect->left != 0) || (rect->right != (INT) encoderImageInfo.Width)) 
    {
        WARNING(("GpJpegEncoder::GetPixelDataBuffer -- must be same width as image"));
        return E_INVALIDARG;
    }

    if (rect->top != (INT) compress_info.next_scanline) 
    {
        WARNING(("GpJpegEncoder::GetPixelDataBuffer -- bad value for rect->top"));
        return E_INVALIDARG;
    }

    if (rect->bottom > (INT) encoderImageInfo.Height) 
    {
        WARNING(("GpJpegEncoder::GetPixelDataBuffer -- rect->bottom too high"));
        return E_INVALIDARG;
    }

    if ((bitmapData->PixelFormat != PIXFMT_32BPP_RGB) &&
        (bitmapData->PixelFormat != PIXFMT_32BPP_ARGB) &&
        (bitmapData->PixelFormat != PIXFMT_32BPP_PARGB))
    {
        WARNING(("GpJpegEncoder::GetPixelDataBuffer -- bad pixel format"));
        return E_INVALIDARG;
    }

    if (!lastPass)
    {
        WARNING(("GpJpegEncoder::GetPixelDataBuffer -- must receive last pass pixels"));
        return E_INVALIDARG;
    }

    __try
    {
        INT currentLine;
        PBYTE pBits = (PBYTE) bitmapData->Scan0;
        for (currentLine = rect->top; currentLine < rect->bottom; currentLine++) 
        {
            // Read data into scanlineBuffer
        
            PBYTE pSource = pBits;
            PBYTE pTarget = scanlineBuffer[0];
        
            for (UINT i=0; i < encoderImageInfo.Width; i++) 
            {
                // 32BPP to 24BPP
                
                pTarget[0] = pSource[2];
                pTarget[1] = pSource[1];
                pTarget[2] = pSource[0];
                pSource += 4;
                pTarget += 3;
            }
        
            jpeg_write_scanlines(&compress_info, scanlineBuffer, 1);
            pBits += bitmapData->Stride;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING(("GpJpegEncoder::PushPixelData--jpeg_write_scanline() failed"));
        return E_FAIL;
    }

    return S_OK;
}


/**************************************************************************\
*
* Function Description:
*
*     Pushes raw compressed data into the .bmp stream.  Not implemented
*     because this filter doesn't understand raw compressed data.
*
* Arguments:
*
*     buffer - Pointer to image data buffer
*     bufsize - Size of the data buffer
*     complete - Whether there is more image data left
*    
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpJpegEncoder::PushRawData(
    IN const VOID* buffer, 
    IN UINT bufsize
    )
{
    return E_NOTIMPL;
}

/**************************************************************************\
*
* Function Description:
*
*     Pushes raw source jpeg_decompress_struct info into the encoder. This
*   allows us to implement lossless transformation for JPEG image
*
* Arguments:
*
*     pInfo - Pointer to jpeg_decompress_struct*
*    
* Return Value:
*
*   Status code
*
\**************************************************************************/

STDMETHODIMP
GpJpegEncoder::PushRawInfo(
    IN OUT VOID* pInfo
    )
{
    // Setup transformation structure

    jpeg_transform_info transformOption; // image transformation options

    transformOption.trim = AllowToTrimEdge;
    transformOption.force_grayscale = FALSE;

    switch ( RequiredTransformation )
    {
    case EncoderValueTransformRotate90:
        transformOption.transform = JXFORM_ROT_90;
        break;

    case EncoderValueTransformRotate180:
        transformOption.transform = JXFORM_ROT_180;
        break;
    
    case EncoderValueTransformRotate270:
        transformOption.transform = JXFORM_ROT_270;
        break;

    case EncoderValueTransformFlipHorizontal:
        transformOption.transform = JXFORM_FLIP_H;
        break;

    case EncoderValueTransformFlipVertical:
        transformOption.transform = JXFORM_FLIP_V;
        break;
    
    default:
        transformOption.transform = JXFORM_NONE;
        break;
    }
    
    struct jpeg_decompress_struct* srcinfo = (jpeg_decompress_struct*)pInfo;
    jvirt_barray_ptr* dst_coef_arrays;

    __try
    {
        // Any space needed by a transform option must be requested before
        // jpeg_read_coefficients so that memory allocation will be done right.

        jtransform_request_workspace(srcinfo, &transformOption);

        // Read source file as DCT coefficients

        jvirt_barray_ptr* src_coef_arrays;

        src_coef_arrays = jpeg_read_coefficients(srcinfo);

        // The JPEG compression object is initialized in InitEncoder()

        IsCompressFinished = FALSE;
        
        compress_info.dest = datadest;

        // Initialize destination compression parameters from source values

        jpeg_copy_critical_parameters(srcinfo, &compress_info);

        // Adjust destination parameters if required by transform options;
        // also find out which set of coefficient arrays will hold the output.

        dst_coef_arrays = jtransform_adjust_parameters(srcinfo, &compress_info,
                                                       src_coef_arrays,
                                                       &transformOption);

        // Start compressor (note no image data is actually written here)

        jpeg_write_coefficients(&compress_info, dst_coef_arrays);

        // Write out APP1 marker if necessary

        if (HasAPP1Marker == TRUE)
        {
            jpeg_write_marker(
                &compress_info,
                (JPEG_APP0 + 1),       // Marker type
                APP1MarkerBufferPtr,   // bits
                APP1MarkerLength       // Total length
                );                  

            // Set a flag so we don't need to copy APP1 from the source to the
            // dest since we have written it out above.

            compress_info.write_APP1_marker = FALSE;
        }

        // Write out APP2 marker if the caller has changed it. Of course, first
        // of all, there should have an APP2 marker.
        // Note: if the source has an APP2 marker and the caller hasn't changed
        // it, then we don't need to write it out here since it will be copied
        // from source to dest when jcopy_markers_execute() is called.

        if ((HasAPP2Marker == TRUE) && (HasICCProfileChanged == TRUE))
        {
            jpeg_write_marker(
                &compress_info,
                (JPEG_APP0 + 2),       // Marker type
                APP2MarkerBufferPtr,   // bits
                APP2MarkerLength       // Total length
                );                  

            // Set a flag so we don't need to copy APP2 from the source to the
            // dest since we have written it out above.

            compress_info.write_APP2_marker = FALSE;
        }

        // Copy all the private APP headers.

        jcopy_markers_execute(srcinfo, &compress_info, JCOPYOPT_ALL);

        // Execute image transformation, if any

        jtransform_execute_transformation(srcinfo, &compress_info,
                                          src_coef_arrays,
                                          &transformOption);

        // Finish compression and release memory
        // Note: we have to finish the compress here first. Otherwise, we can't
        // finish the decompress. In this work flow, after we return, the
        // decoder will finish the decompress

        jpeg_finish_compress(&compress_info);
    }   
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING(("GpJpegEncoder::PushRawInfo----Hit exception"));
        
        // jpeg_finish_compress() might hit exception when writing the remaining
        // bits to the stream, say user pulls the disk/CF card out. But we still
        // need to destroy the compressor so that we won't have memory leak here
        
        jpeg_destroy_compress(&compress_info);
        
        return E_FAIL;
    }
    
    IsCompressFinished = TRUE;

    return S_OK;
}// PushRawInfo()

/**************************************************************************\
*
* Function Description:
*
*   Providing a memory buffer to the caller (source) for storing image property
*
* Arguments:
*
*   uiTotalBufferSize - [IN]Size of the buffer required.
*   ppBuffer----------- [IN/OUT] Pointer to the newly allocated buffer
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpJpegEncoder::GetPropertyBuffer(
    UINT            uiTotalBufferSize,
    PropertyItem**  ppBuffer
    )
{
    if ( (uiTotalBufferSize == 0) || ( ppBuffer == NULL) )
    {
        WARNING(("GpJpegEncoder::GetPropertyBuffer---Invalid inputs"));
        return E_INVALIDARG;
    }

    PropertyItem* pTempBuf = (PropertyItem*)GpMalloc(uiTotalBufferSize);
    if ( pTempBuf == NULL )
    {
        WARNING(("GpJpegEncoder::GetPropertyBuffer---Out of memory"));
        return E_OUTOFMEMORY;
    }

    *ppBuffer = pTempBuf;

    return S_OK;
}// GetPropertyBuffer()

/**************************************************************************\
*
* Function Description:
*
*   Method for accepting property items from the source. Then create proper JPEG
*   markers according to the property items passed in
*
* Arguments:
*
*   [IN] uiNumOfPropertyItems - Number of property items passed in
*   [IN] uiTotalBufferSize----- Size of the buffer passed in
*   [IN] pItemBuffer----------- Input buffer for holding all the property items
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

#define MARKER_OVERHEADER   2048    // Maximum size for over header bytes

HRESULT
GpJpegEncoder::PushPropertyItems(
    UINT            uiNumOfPropertyItems,
    UINT            uiTotalBufferSize,
    PropertyItem*   pItemBuffer,
    BOOL            fICCProfileChanged
    )
{
    HRESULT hResult = S_OK;
    UINT    uiMarkerBufferLength = 0;

    if ( pItemBuffer == NULL )
    {
        WARNING(("GpJpegEncoder::PushPropertyItems---Invalid arg"));
        hResult = E_INVALIDARG;
        goto Prop_CleanUp;
    }

    // Allocate a temp Marker buffer to store the markers we generated
    // Note:1) According to EXIF 2.1 spec, page 14, that an APP1 marker must not
    // be exceed the 64 Kbytes limit. Actually it is a limitation in JPEG that
    // all the markers should be smaller than 64 KBytes.
    //
    // 2) The input PropertyItem buffer should be roughly the same size as the
    // marker size we are going to create. The extras in a marker is things like
    // The heading Exif identifier, 4 bytes offset for next IFD (total of 8),
    // EXIF specific IFD header, GPS specific IFD header, Thumbnail specific
    // header etc. Should be pretty much limited items. Here I left 2K for these
    // overhaeder which should be sufficient enough.

    uiMarkerBufferLength = uiTotalBufferSize + MARKER_OVERHEADER;

    if ( uiMarkerBufferLength > 0x10000 )
    {
        WARNING(("GpJpegEncoder::PushPropertyItems---Marker size exceeds 64K"));
        hResult = E_INVALIDARG;
        goto Prop_CleanUp;
    }

    if (APP1MarkerBufferPtr)
    {
        // The caller has already pushed property items before. We should ignore
        // the old one

        GpFree(APP1MarkerBufferPtr);
        APP1MarkerBufferPtr = NULL;
    }

    APP1MarkerBufferPtr = (PBYTE)GpMalloc(uiMarkerBufferLength);
    
    if ( APP1MarkerBufferPtr == NULL )
    {
        WARNING(("GpJpegEncoder::PushPropertyItems---Out of memory"));
        
        hResult = E_OUTOFMEMORY;
        goto Prop_CleanUp;
    }

    APP1MarkerLength = 0;
    
    // Create an APP1 marker

    hResult = CreateAPP1Marker(pItemBuffer, uiNumOfPropertyItems,
                               APP1MarkerBufferPtr, &APP1MarkerLength,
                               RequiredTransformation);
    if (SUCCEEDED(hResult))
    {
        if (APP1MarkerLength > 0)
        {
            HasAPP1Marker = TRUE;
        }

        // Check if there is ICC profile in the property list

        hResult = CreateAPP2Marker(pItemBuffer, uiNumOfPropertyItems);
        if (SUCCEEDED(hResult) && (APP2MarkerLength > 0))
        {            
            HasAPP2Marker = TRUE;
            HasICCProfileChanged = fICCProfileChanged;
        }
    }

Prop_CleanUp:
    // Free the memory we allocated in GetPropertyBuffer()

    GpFree(pItemBuffer);
    
    return hResult;
}// PushPropertyItems()

const int c_nMarker2Header = 14;    // Marker 2 buffer header size

/**************************************************************************\
*
* Function Description:
*
*   This method creates an APP2 marker (for ICC profile) in memory.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

HRESULT
GpJpegEncoder::CreateAPP2Marker(
    IN PropertyItem* pPropertyList,// Input PropertyItem list
    IN UINT uiNumOfPropertyItems   // Number of Property items in the input list
    )
{
    BOOL fFoundICC = FALSE;
    HRESULT hr = S_OK;

    if (pPropertyList)
    {
        PropertyItem *pItem = pPropertyList;

        // Loop through the property item list to see if we have an ICC profile
        // or not

        for (int i = 0; i < (INT)uiNumOfPropertyItems; ++i)
        {
            if (pItem->id == TAG_ICC_PROFILE)
            {
                // Double check to see if we have a valid ICC profile or not

                if (pItem->length > 0)
                {
                    fFoundICC = TRUE;
                }

                break;
            }

            // Move onto next item

            pItem++;
        }

        if (fFoundICC == TRUE) 
        {
            APP2MarkerLength = pItem->length + c_nMarker2Header;
            APP2MarkerBufferPtr = (PBYTE)GpMalloc(APP2MarkerLength);

            if (APP2MarkerBufferPtr)
            {
                // Make an APP2 marker here

                BYTE *pbCurrent = APP2MarkerBufferPtr;

                // First write out the header

                pbCurrent[0] = 'I';
                pbCurrent[1] = 'C';
                pbCurrent[2] = 'C';
                pbCurrent[3] = '_';
                pbCurrent[4] = 'P';
                pbCurrent[5] = 'R';
                pbCurrent[6] = 'O';
                pbCurrent[7] = 'F';
                pbCurrent[8] = 'I';
                pbCurrent[9] = 'L';
                pbCurrent[10] = 'E';
                pbCurrent[11] = '\0';
                pbCurrent[12] = 1;          // Profile 1 of 1
                pbCurrent[13] = 1;

                // Copy the ICC profile in the buffer

                GpMemcpy((void*)(APP2MarkerBufferPtr + c_nMarker2Header),
                         pItem->value,
                         pItem->length
                         );

                HasAPP2Marker = TRUE;
            }
            else
            {
                APP2MarkerLength = 0;
                hr = E_OUTOFMEMORY;
            }
        }
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\jpeg\libjpeg\cdjpeg.h ===
/*
 * cdjpeg.h
 *
 * Copyright (C) 1994-1997, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains common declarations for the sample applications
 * cjpeg and djpeg.  It is NOT used by the core JPEG library.
 */

#define JPEG_CJPEG_DJPEG	/* define proper options in jconfig.h */
#define JPEG_INTERNAL_OPTIONS	/* cjpeg.c,djpeg.c need to see xxx_SUPPORTED */
#include "jinclude.h"
#include "jpeglib.h"
#include "jerror.h"		/* get library error codes too */
#include "cderror.h"		/* get application-specific error codes */


/*
 * Object interface for cjpeg's source file decoding modules
 */

typedef struct cjpeg_source_struct * cjpeg_source_ptr;

struct cjpeg_source_struct {
  JMETHOD(void, start_input, (j_compress_ptr cinfo,
			      cjpeg_source_ptr sinfo));
  JMETHOD(JDIMENSION, get_pixel_rows, (j_compress_ptr cinfo,
				       cjpeg_source_ptr sinfo));
  JMETHOD(void, finish_input, (j_compress_ptr cinfo,
			       cjpeg_source_ptr sinfo));

  FILE *input_file;

  JSAMPARRAY buffer;
  JDIMENSION buffer_height;
};


/*
 * Object interface for djpeg's output file encoding modules
 */

typedef struct djpeg_dest_struct * djpeg_dest_ptr;

struct djpeg_dest_struct {
  /* start_output is called after jpeg_start_decompress finishes.
   * The color map will be ready at this time, if one is needed.
   */
  JMETHOD(void, start_output, (j_decompress_ptr cinfo,
			       djpeg_dest_ptr dinfo));
  /* Emit the specified number of pixel rows from the buffer. */
  JMETHOD(void, put_pixel_rows, (j_decompress_ptr cinfo,
				 djpeg_dest_ptr dinfo,
				 JDIMENSION rows_supplied));
  /* Finish up at the end of the image. */
  JMETHOD(void, finish_output, (j_decompress_ptr cinfo,
				djpeg_dest_ptr dinfo));

  /* Target file spec; filled in by djpeg.c after object is created. */
  FILE * output_file;

  /* Output pixel-row buffer.  Created by module init or start_output.
   * Width is cinfo->output_width * cinfo->output_components;
   * height is buffer_height.
   */
  JSAMPARRAY buffer;
  JDIMENSION buffer_height;
};


/*
 * cjpeg/djpeg may need to perform extra passes to convert to or from
 * the source/destination file format.  The JPEG library does not know
 * about these passes, but we'd like them to be counted by the progress
 * monitor.  We use an expanded progress monitor object to hold the
 * additional pass count.
 */

struct cdjpeg_progress_mgr {
  struct jpeg_progress_mgr pub;	/* fields known to JPEG library */
  int completed_extra_passes;	/* extra passes completed */
  int total_extra_passes;	/* total extra */
  /* last printed percentage stored here to avoid multiple printouts */
  int percent_done;
};

typedef struct cdjpeg_progress_mgr * cd_progress_ptr;


/* Short forms of external names for systems with brain-damaged linkers. */

#ifdef NEED_SHORT_EXTERNAL_NAMES
#define jinit_read_bmp		jIRdBMP
#define jinit_write_bmp		jIWrBMP
#define jinit_read_gif		jIRdGIF
#define jinit_write_gif		jIWrGIF
#define jinit_read_ppm		jIRdPPM
#define jinit_write_ppm		jIWrPPM
#define jinit_read_rle		jIRdRLE
#define jinit_write_rle		jIWrRLE
#define jinit_read_targa	jIRdTarga
#define jinit_write_targa	jIWrTarga
#define read_quant_tables	RdQTables
#define read_scan_script	RdScnScript
#define set_quant_slots		SetQSlots
#define set_sample_factors	SetSFacts
#define read_color_map		RdCMap
#define enable_signal_catcher	EnSigCatcher
#define start_progress_monitor	StProgMon
#define end_progress_monitor	EnProgMon
#define read_stdin		RdStdin
#define write_stdout		WrStdout
#endif /* NEED_SHORT_EXTERNAL_NAMES */

/* Module selection routines for I/O modules. */

EXTERN(cjpeg_source_ptr) jinit_read_bmp JPP((j_compress_ptr cinfo));
EXTERN(djpeg_dest_ptr) jinit_write_bmp JPP((j_decompress_ptr cinfo,
					    boolean is_os2));
EXTERN(cjpeg_source_ptr) jinit_read_gif JPP((j_compress_ptr cinfo));
EXTERN(djpeg_dest_ptr) jinit_write_gif JPP((j_decompress_ptr cinfo));
EXTERN(cjpeg_source_ptr) jinit_read_ppm JPP((j_compress_ptr cinfo));
EXTERN(djpeg_dest_ptr) jinit_write_ppm JPP((j_decompress_ptr cinfo));
EXTERN(cjpeg_source_ptr) jinit_read_rle JPP((j_compress_ptr cinfo));
EXTERN(djpeg_dest_ptr) jinit_write_rle JPP((j_decompress_ptr cinfo));
EXTERN(cjpeg_source_ptr) jinit_read_targa JPP((j_compress_ptr cinfo));
EXTERN(djpeg_dest_ptr) jinit_write_targa JPP((j_decompress_ptr cinfo));

/* cjpeg support routines (in rdswitch.c) */

EXTERN(boolean) read_quant_tables JPP((j_compress_ptr cinfo, char * filename,
				    int scale_factor, boolean force_baseline));
EXTERN(boolean) read_scan_script JPP((j_compress_ptr cinfo, char * filename));
EXTERN(boolean) set_quant_slots JPP((j_compress_ptr cinfo, char *arg));
EXTERN(boolean) set_sample_factors JPP((j_compress_ptr cinfo, char *arg));

/* djpeg support routines (in rdcolmap.c) */

EXTERN(void) read_color_map JPP((j_decompress_ptr cinfo, FILE * infile));

/* common support routines (in cdjpeg.c) */

EXTERN(void) enable_signal_catcher JPP((j_common_ptr cinfo));
EXTERN(void) start_progress_monitor JPP((j_common_ptr cinfo,
					 cd_progress_ptr progress));
EXTERN(void) end_progress_monitor JPP((j_common_ptr cinfo));
EXTERN(boolean) keymatch JPP((char * arg, const char * keyword, int minchars));
EXTERN(FILE *) read_stdin JPP((void));
EXTERN(FILE *) write_stdout JPP((void));

/* miscellaneous useful macros */

#ifdef DONT_USE_B_MODE		/* define mode parameters for fopen() */
#define READ_BINARY	"r"
#define WRITE_BINARY	"w"
#else
#ifdef VMS			/* VMS is very nonstandard */
#define READ_BINARY	"rb", "ctx=stm"
#define WRITE_BINARY	"wb", "ctx=stm"
#else				/* standard ANSI-compliant case */
#define READ_BINARY	"rb"
#define WRITE_BINARY	"wb"
#endif
#endif

#ifndef EXIT_FAILURE		/* define exit() codes if not provided */
#define EXIT_FAILURE  1
#endif
#ifndef EXIT_SUCCESS
#ifdef VMS
#define EXIT_SUCCESS  1		/* VMS is very nonstandard */
#else
#define EXIT_SUCCESS  0
#endif
#endif
#ifndef EXIT_WARNING
#ifdef VMS
#define EXIT_WARNING  1		/* VMS is very nonstandard */
#else
#define EXIT_WARNING  2
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\jpeg\libjpeg\cjpeg.c ===
/*
 * cjpeg.c
 *
 * Copyright (C) 1991-1998, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains a command-line user interface for the JPEG compressor.
 * It should work on any system with Unix- or MS-DOS-style command lines.
 *
 * Two different command line styles are permitted, depending on the
 * compile-time switch TWO_FILE_COMMANDLINE:
 *	cjpeg [options]  inputfile outputfile
 *	cjpeg [options]  [inputfile]
 * In the second style, output is always to standard output, which you'd
 * normally redirect to a file or pipe to some other program.  Input is
 * either from a named file or from standard input (typically redirected).
 * The second style is convenient on Unix but is unhelpful on systems that
 * don't support pipes.  Also, you MUST use the first style if your system
 * doesn't do binary I/O to stdin/stdout.
 * To simplify script writing, the "-outfile" switch is provided.  The syntax
 *	cjpeg [options]  -outfile outputfile  inputfile
 * works regardless of which command line style is used.
 */

#include "cdjpeg.h"		/* Common decls for cjpeg/djpeg applications */
#include "jversion.h"		/* for version message */

#ifdef USE_CCOMMAND		/* command-line reader for Macintosh */
#ifdef __MWERKS__
#include <SIOUX.h>              /* Metrowerks needs this */
#include <console.h>		/* ... and this */
#endif
#ifdef THINK_C
#include <console.h>		/* Think declares it here */
#endif
#endif


/* Create the add-on message string table. */

#define JMESSAGE(code,string)	string ,

static const char * const cdjpeg_message_table[] = {
#include "cderror.h"
  NULL
};


/*
 * This routine determines what format the input file is,
 * and selects the appropriate input-reading module.
 *
 * To determine which family of input formats the file belongs to,
 * we may look only at the first byte of the file, since C does not
 * guarantee that more than one character can be pushed back with ungetc.
 * Looking at additional bytes would require one of these approaches:
 *     1) assume we can fseek() the input file (fails for piped input);
 *     2) assume we can push back more than one character (works in
 *        some C implementations, but unportable);
 *     3) provide our own buffering (breaks input readers that want to use
 *        stdio directly, such as the RLE library);
 * or  4) don't put back the data, and modify the input_init methods to assume
 *        they start reading after the start of file (also breaks RLE library).
 * #1 is attractive for MS-DOS but is untenable on Unix.
 *
 * The most portable solution for file types that can't be identified by their
 * first byte is to make the user tell us what they are.  This is also the
 * only approach for "raw" file types that contain only arbitrary values.
 * We presently apply this method for Targa files.  Most of the time Targa
 * files start with 0x00, so we recognize that case.  Potentially, however,
 * a Targa file could start with any byte value (byte 0 is the length of the
 * seldom-used ID field), so we provide a switch to force Targa input mode.
 */

static boolean is_targa;	/* records user -targa switch */


LOCAL(cjpeg_source_ptr)
select_file_type (j_compress_ptr cinfo, FILE * infile)
{
  int c;

  if (is_targa) {
#ifdef TARGA_SUPPORTED
    return jinit_read_targa(cinfo);
#else
    ERREXIT(cinfo, JERR_TGA_NOTCOMP);
#endif
  }

  if ((c = getc(infile)) == EOF)
    ERREXIT(cinfo, JERR_INPUT_EMPTY);
  if (ungetc(c, infile) == EOF)
    ERREXIT(cinfo, JERR_UNGETC_FAILED);

  switch (c) {
#ifdef BMP_SUPPORTED
  case 'B':
    return jinit_read_bmp(cinfo);
#endif
#ifdef GIF_SUPPORTED
  case 'G':
    return jinit_read_gif(cinfo);
#endif
#ifdef PPM_SUPPORTED
  case 'P':
    return jinit_read_ppm(cinfo);
#endif
#ifdef RLE_SUPPORTED
  case 'R':
    return jinit_read_rle(cinfo);
#endif
#ifdef TARGA_SUPPORTED
  case 0x00:
    return jinit_read_targa(cinfo);
#endif
  default:
    ERREXIT(cinfo, JERR_UNKNOWN_FORMAT);
    break;
  }

  return NULL;			/* suppress compiler warnings */
}


/*
 * Argument-parsing code.
 * The switch parser is designed to be useful with DOS-style command line
 * syntax, ie, intermixed switches and file names, where only the switches
 * to the left of a given file name affect processing of that file.
 * The main program in this file doesn't actually use this capability...
 */


static const char * progname;	/* program name for error messages */
static char * outfilename;	/* for -outfile switch */


LOCAL(void)
usage (void)
/* complain about bad command line */
{
  fprintf(stderr, "usage: %s [switches] ", progname);
#ifdef TWO_FILE_COMMANDLINE
  fprintf(stderr, "inputfile outputfile\n");
#else
  fprintf(stderr, "[inputfile]\n");
#endif

  fprintf(stderr, "Switches (names may be abbreviated):\n");
  fprintf(stderr, "  -quality N     Compression quality (0..100; 5-95 is useful range)\n");
  fprintf(stderr, "  -grayscale     Create monochrome JPEG file\n");
#ifdef ENTROPY_OPT_SUPPORTED
  fprintf(stderr, "  -optimize      Optimize Huffman table (smaller file, but slow compression)\n");
#endif
#ifdef C_PROGRESSIVE_SUPPORTED
  fprintf(stderr, "  -progressive   Create progressive JPEG file\n");
#endif
#ifdef TARGA_SUPPORTED
  fprintf(stderr, "  -targa         Input file is Targa format (usually not needed)\n");
#endif
  fprintf(stderr, "Switches for advanced users:\n");
#ifdef DCT_ISLOW_SUPPORTED
  fprintf(stderr, "  -dct int       Use integer DCT method%s\n",
	  (JDCT_DEFAULT == JDCT_ISLOW ? " (default)" : ""));
#endif
#ifdef DCT_IFAST_SUPPORTED
  fprintf(stderr, "  -dct fast      Use fast integer DCT (less accurate)%s\n",
	  (JDCT_DEFAULT == JDCT_IFAST ? " (default)" : ""));
#endif
#ifdef DCT_FLOAT_SUPPORTED
  fprintf(stderr, "  -dct float     Use floating-point DCT method%s\n",
	  (JDCT_DEFAULT == JDCT_FLOAT ? " (default)" : ""));
#endif
  fprintf(stderr, "  -restart N     Set restart interval in rows, or in blocks with B\n");
#ifdef INPUT_SMOOTHING_SUPPORTED
  fprintf(stderr, "  -smooth N      Smooth dithered input (N=1..100 is strength)\n");
#endif
  fprintf(stderr, "  -maxmemory N   Maximum memory to use (in kbytes)\n");
  fprintf(stderr, "  -outfile name  Specify name for output file\n");
  fprintf(stderr, "  -verbose  or  -debug   Emit debug output\n");
  fprintf(stderr, "Switches for wizards:\n");
#ifdef C_ARITH_CODING_SUPPORTED
  fprintf(stderr, "  -arithmetic    Use arithmetic coding\n");
#endif
  fprintf(stderr, "  -baseline      Force baseline quantization tables\n");
  fprintf(stderr, "  -qtables file  Use quantization tables given in file\n");
  fprintf(stderr, "  -qslots N[,...]    Set component quantization tables\n");
  fprintf(stderr, "  -sample HxV[,...]  Set component sampling factors\n");
#ifdef C_MULTISCAN_FILES_SUPPORTED
  fprintf(stderr, "  -scans file    Create multi-scan JPEG per script file\n");
#endif
  exit(EXIT_FAILURE);
}


LOCAL(int)
parse_switches (j_compress_ptr cinfo, int argc, char **argv,
		int last_file_arg_seen, boolean for_real)
/* Parse optional switches.
 * Returns argv[] index of first file-name argument (== argc if none).
 * Any file names with indexes <= last_file_arg_seen are ignored;
 * they have presumably been processed in a previous iteration.
 * (Pass 0 for last_file_arg_seen on the first or only iteration.)
 * for_real is FALSE on the first (dummy) pass; we may skip any expensive
 * processing.
 */
{
  int argn;
  char * arg;
  int quality;			/* -quality parameter */
  int q_scale_factor;		/* scaling percentage for -qtables */
  boolean force_baseline;
  boolean simple_progressive;
  char * qtablefile = NULL;	/* saves -qtables filename if any */
  char * qslotsarg = NULL;	/* saves -qslots parm if any */
  char * samplearg = NULL;	/* saves -sample parm if any */
  char * scansarg = NULL;	/* saves -scans parm if any */

  /* Set up default JPEG parameters. */
  /* Note that default -quality level need not, and does not,
   * match the default scaling for an explicit -qtables argument.
   */
  quality = 75;			/* default -quality value */
  q_scale_factor = 100;		/* default to no scaling for -qtables */
  force_baseline = FALSE;	/* by default, allow 16-bit quantizers */
  simple_progressive = FALSE;
  is_targa = FALSE;
  outfilename = NULL;
  cinfo->err->trace_level = 0;

  /* Scan command line options, adjust parameters */

  for (argn = 1; argn < argc; argn++) {
    arg = argv[argn];
    if (*arg != '-') {
      /* Not a switch, must be a file name argument */
      if (argn <= last_file_arg_seen) {
	outfilename = NULL;	/* -outfile applies to just one input file */
	continue;		/* ignore this name if previously processed */
      }
      break;			/* else done parsing switches */
    }
    arg++;			/* advance past switch marker character */

    if (keymatch(arg, "arithmetic", 1)) {
      /* Use arithmetic coding. */
#ifdef C_ARITH_CODING_SUPPORTED
      cinfo->arith_code = TRUE;
#else
      fprintf(stderr, "%s: sorry, arithmetic coding not supported\n",
	      progname);
      exit(EXIT_FAILURE);
#endif

    } else if (keymatch(arg, "baseline", 1)) {
      /* Force baseline-compatible output (8-bit quantizer values). */
      force_baseline = TRUE;

    } else if (keymatch(arg, "dct", 2)) {
      /* Select DCT algorithm. */
      if (++argn >= argc)	/* advance to next argument */
	usage();
      if (keymatch(argv[argn], "int", 1)) {
	cinfo->dct_method = JDCT_ISLOW;
      } else if (keymatch(argv[argn], "fast", 2)) {
	cinfo->dct_method = JDCT_IFAST;
      } else if (keymatch(argv[argn], "float", 2)) {
	cinfo->dct_method = JDCT_FLOAT;
      } else
	usage();

    } else if (keymatch(arg, "debug", 1) || keymatch(arg, "verbose", 1)) {
      /* Enable debug printouts. */
      /* On first -d, print version identification */
      static boolean printed_version = FALSE;

      if (! printed_version) {
	fprintf(stderr, "Independent JPEG Group's CJPEG, version %s\n%s\n",
		JVERSION, JCOPYRIGHT);
	printed_version = TRUE;
      }
      cinfo->err->trace_level++;

    } else if (keymatch(arg, "grayscale", 2) || keymatch(arg, "greyscale",2)) {
      /* Force a monochrome JPEG file to be generated. */
      jpeg_set_colorspace(cinfo, JCS_GRAYSCALE);

    } else if (keymatch(arg, "maxmemory", 3)) {
      /* Maximum memory in Kb (or Mb with 'm'). */
      long lval;
      char ch = 'x';

      if (++argn >= argc)	/* advance to next argument */
	usage();
      if (sscanf(argv[argn], "%ld%c", &lval, &ch) < 1)
	usage();
      if (ch == 'm' || ch == 'M')
	lval *= 1000L;
      cinfo->mem->max_memory_to_use = lval * 1000L;

    } else if (keymatch(arg, "optimize", 1) || keymatch(arg, "optimise", 1)) {
      /* Enable entropy parm optimization. */
#ifdef ENTROPY_OPT_SUPPORTED
      cinfo->optimize_coding = TRUE;
#else
      fprintf(stderr, "%s: sorry, entropy optimization was not compiled\n",
	      progname);
      exit(EXIT_FAILURE);
#endif

    } else if (keymatch(arg, "outfile", 4)) {
      /* Set output file name. */
      if (++argn >= argc)	/* advance to next argument */
	usage();
      outfilename = argv[argn];	/* save it away for later use */

    } else if (keymatch(arg, "progressive", 1)) {
      /* Select simple progressive mode. */
#ifdef C_PROGRESSIVE_SUPPORTED
      simple_progressive = TRUE;
      /* We must postpone execution until num_components is known. */
#else
      fprintf(stderr, "%s: sorry, progressive output was not compiled\n",
	      progname);
      exit(EXIT_FAILURE);
#endif

    } else if (keymatch(arg, "quality", 1)) {
      /* Quality factor (quantization table scaling factor). */
      if (++argn >= argc)	/* advance to next argument */
	usage();
      if (sscanf(argv[argn], "%d", &quality) != 1)
	usage();
      /* Change scale factor in case -qtables is present. */
      q_scale_factor = jpeg_quality_scaling(quality);

    } else if (keymatch(arg, "qslots", 2)) {
      /* Quantization table slot numbers. */
      if (++argn >= argc)	/* advance to next argument */
	usage();
      qslotsarg = argv[argn];
      /* Must delay setting qslots until after we have processed any
       * colorspace-determining switches, since jpeg_set_colorspace sets
       * default quant table numbers.
       */

    } else if (keymatch(arg, "qtables", 2)) {
      /* Quantization tables fetched from file. */
      if (++argn >= argc)	/* advance to next argument */
	usage();
      qtablefile = argv[argn];
      /* We postpone actually reading the file in case -quality comes later. */

    } else if (keymatch(arg, "restart", 1)) {
      /* Restart interval in MCU rows (or in MCUs with 'b'). */
      long lval;
      char ch = 'x';

      if (++argn >= argc)	/* advance to next argument */
	usage();
      if (sscanf(argv[argn], "%ld%c", &lval, &ch) < 1)
	usage();
      if (lval < 0 || lval > 65535L)
	usage();
      if (ch == 'b' || ch == 'B') {
	cinfo->restart_interval = (unsigned int) lval;
	cinfo->restart_in_rows = 0; /* else prior '-restart n' overrides me */
      } else {
	cinfo->restart_in_rows = (int) lval;
	/* restart_interval will be computed during startup */
      }

    } else if (keymatch(arg, "sample", 2)) {
      /* Set sampling factors. */
      if (++argn >= argc)	/* advance to next argument */
	usage();
      samplearg = argv[argn];
      /* Must delay setting sample factors until after we have processed any
       * colorspace-determining switches, since jpeg_set_colorspace sets
       * default sampling factors.
       */

    } else if (keymatch(arg, "scans", 2)) {
      /* Set scan script. */
#ifdef C_MULTISCAN_FILES_SUPPORTED
      if (++argn >= argc)	/* advance to next argument */
	usage();
      scansarg = argv[argn];
      /* We must postpone reading the file in case -progressive appears. */
#else
      fprintf(stderr, "%s: sorry, multi-scan output was not compiled\n",
	      progname);
      exit(EXIT_FAILURE);
#endif

    } else if (keymatch(arg, "smooth", 2)) {
      /* Set input smoothing factor. */
      int val;

      if (++argn >= argc)	/* advance to next argument */
	usage();
      if (sscanf(argv[argn], "%d", &val) != 1)
	usage();
      if (val < 0 || val > 100)
	usage();
      cinfo->smoothing_factor = val;

    } else if (keymatch(arg, "targa", 1)) {
      /* Input file is Targa format. */
      is_targa = TRUE;

    } else {
      usage();			/* bogus switch */
    }
  }

  /* Post-switch-scanning cleanup */

  if (for_real) {

    /* Set quantization tables for selected quality. */
    /* Some or all may be overridden if -qtables is present. */
    jpeg_set_quality(cinfo, quality, force_baseline);

    if (qtablefile != NULL)	/* process -qtables if it was present */
      if (! read_quant_tables(cinfo, qtablefile,
			      q_scale_factor, force_baseline))
	usage();

    if (qslotsarg != NULL)	/* process -qslots if it was present */
      if (! set_quant_slots(cinfo, qslotsarg))
	usage();

    if (samplearg != NULL)	/* process -sample if it was present */
      if (! set_sample_factors(cinfo, samplearg))
	usage();

#ifdef C_PROGRESSIVE_SUPPORTED
    if (simple_progressive)	/* process -progressive; -scans can override */
      jpeg_simple_progression(cinfo);
#endif

#ifdef C_MULTISCAN_FILES_SUPPORTED
    if (scansarg != NULL)	/* process -scans if it was present */
      if (! read_scan_script(cinfo, scansarg))
	usage();
#endif
  }

  return argn;			/* return index of next arg (file name) */
}


/*
 * The main program.
 */

int __cdecl
main (int argc, char **argv)
{
  struct jpeg_compress_struct cinfo;
  struct jpeg_error_mgr jerr;
#ifdef PROGRESS_REPORT
  struct cdjpeg_progress_mgr progress;
#endif
  int file_index;
  cjpeg_source_ptr src_mgr;
  FILE * input_file;
  FILE * output_file;
  JDIMENSION num_scanlines;

  /* On Mac, fetch a command line. */
#ifdef USE_CCOMMAND
  argc = ccommand(&argv);
#endif

  progname = argv[0];
  if (progname == NULL || progname[0] == 0)
    progname = "cjpeg";		/* in case C library doesn't provide it */

  /* Initialize the JPEG compression object with default error handling. */
  cinfo.err = jpeg_std_error(&jerr);
  jpeg_create_compress(&cinfo);
  /* Add some application-specific error messages (from cderror.h) */
  jerr.addon_message_table = cdjpeg_message_table;
  jerr.first_addon_message = JMSG_FIRSTADDONCODE;
  jerr.last_addon_message = JMSG_LASTADDONCODE;

  /* Now safe to enable signal catcher. */
#ifdef NEED_SIGNAL_CATCHER
  enable_signal_catcher((j_common_ptr) &cinfo);
#endif

  /* Initialize JPEG parameters.
   * Much of this may be overridden later.
   * In particular, we don't yet know the input file's color space,
   * but we need to provide some value for jpeg_set_defaults() to work.
   */

  cinfo.in_color_space = JCS_RGB; /* arbitrary guess */
  jpeg_set_defaults(&cinfo);

  /* Scan command line to find file names.
   * It is convenient to use just one switch-parsing routine, but the switch
   * values read here are ignored; we will rescan the switches after opening
   * the input file.
   */

  file_index = parse_switches(&cinfo, argc, argv, 0, FALSE);

#define TWO_FILE_COMMANDLINE 1
#ifdef TWO_FILE_COMMANDLINE
  /* Must have either -outfile switch or explicit output file name */
  if (outfilename == NULL) {
    if (file_index != argc-2) {
      fprintf(stderr, "%s: must name one input and one output file\n",
	      progname);
      usage();
    }
    outfilename = argv[file_index+1];
  } else {
    if (file_index != argc-1) {
      fprintf(stderr, "%s: must name one input and one output file\n",
	      progname);
      usage();
    }
  }
#else
  /* Unix style: expect zero or one file name */
  if (file_index < argc-1) {
    fprintf(stderr, "%s: only one input file\n", progname);
    usage();
  }
#endif /* TWO_FILE_COMMANDLINE */

  /* Open the input file. */
  if (file_index < argc) {
    if ((input_file = fopen(argv[file_index], READ_BINARY)) == NULL) {
      fprintf(stderr, "%s: can't open %s\n", progname, argv[file_index]);
      exit(EXIT_FAILURE);
    }
  } else {
    /* default input file is stdin */
    input_file = read_stdin();
  }

  /* Open the output file. */
  if (outfilename != NULL) {
    if ((output_file = fopen(outfilename, WRITE_BINARY)) == NULL) {
      fprintf(stderr, "%s: can't open %s\n", progname, outfilename);
      exit(EXIT_FAILURE);
    }
  } else {
    /* default output file is stdout */
    output_file = write_stdout();
  }

#ifdef PROGRESS_REPORT
  start_progress_monitor((j_common_ptr) &cinfo, &progress);
#endif

  /* Figure out the input file format, and set up to read it. */
  src_mgr = select_file_type(&cinfo, input_file);
  src_mgr->input_file = input_file;

  /* Read the input file header to obtain file size & colorspace. */
  (*src_mgr->start_input) (&cinfo, src_mgr);

  /* Now that we know input colorspace, fix colorspace-dependent defaults */
  jpeg_default_colorspace(&cinfo);

  /* Adjust default compression parameters by re-parsing the options */
  file_index = parse_switches(&cinfo, argc, argv, 0, TRUE);

  /* Specify data destination for compression */
  jpeg_stdio_dest(&cinfo, output_file);

  /* Start compressor */
  jpeg_start_compress(&cinfo, TRUE);

  /* Process data */
  while (cinfo.next_scanline < cinfo.image_height) {
    num_scanlines = (*src_mgr->get_pixel_rows) (&cinfo, src_mgr);
    (void) jpeg_write_scanlines(&cinfo, src_mgr->buffer, num_scanlines);
  }

  /* Finish compression and release memory */
  (*src_mgr->finish_input) (&cinfo, src_mgr);
  jpeg_finish_compress(&cinfo);
  jpeg_destroy_compress(&cinfo);

  /* Close files, if we opened them */
  if (input_file != stdin)
    fclose(input_file);
  if (output_file != stdout)
    fclose(output_file);

#ifdef PROGRESS_REPORT
  end_progress_monitor((j_common_ptr) &cinfo);
#endif

  /* All done. */
  exit(jerr.num_warnings ? EXIT_WARNING : EXIT_SUCCESS);
  return 0;			/* suppress no-return-value warnings */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\jpeg\libjpeg\ckconfig.c ===
/*
 * ckconfig.c
 *
 * Copyright (C) 1991-1994, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 */

/*
 * This program is intended to help you determine how to configure the JPEG
 * software for installation on a particular system.  The idea is to try to
 * compile and execute this program.  If your compiler fails to compile the
 * program, make changes as indicated in the comments below.  Once you can
 * compile the program, run it, and it will produce a "jconfig.h" file for
 * your system.
 *
 * As a general rule, each time you try to compile this program,
 * pay attention only to the *first* error message you get from the compiler.
 * Many C compilers will issue lots of spurious error messages once they
 * have gotten confused.  Go to the line indicated in the first error message,
 * and read the comments preceding that line to see what to change.
 *
 * Almost all of the edits you may need to make to this program consist of
 * changing a line that reads "#define SOME_SYMBOL" to "#undef SOME_SYMBOL",
 * or vice versa.  This is called defining or undefining that symbol.
 */


/* First we must see if your system has the include files we need.
 * We start out with the assumption that your system has all the ANSI-standard
 * include files.  If you get any error trying to include one of these files,
 * undefine the corresponding HAVE_xxx symbol.
 */

#define HAVE_STDDEF_H		/* replace 'define' by 'undef' if error here */
#ifdef HAVE_STDDEF_H		/* next line will be skipped if you undef... */
#include <stddef.h>
#endif

#define HAVE_STDLIB_H		/* same thing for stdlib.h */
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif

#include <stdio.h>		/* If you ain't got this, you ain't got C. */

/* We have to see if your string functions are defined by
 * strings.h (old BSD convention) or string.h (everybody else).
 * We try the non-BSD convention first; define NEED_BSD_STRINGS
 * if the compiler says it can't find string.h.
 */

#undef NEED_BSD_STRINGS

#ifdef NEED_BSD_STRINGS
#include <strings.h>
#else
#include <string.h>
#endif

/* On some systems (especially older Unix machines), type size_t is
 * defined only in the include file <sys/types.h>.  If you get a failure
 * on the size_t test below, try defining NEED_SYS_TYPES_H.
 */

#undef NEED_SYS_TYPES_H		/* start by assuming we don't need it */
#ifdef NEED_SYS_TYPES_H
#include <sys/types.h>
#endif


/* Usually type size_t is defined in one of the include files we've included
 * above.  If not, you'll get an error on the "typedef size_t my_size_t;" line.
 * In that case, first try defining NEED_SYS_TYPES_H just above.
 * If that doesn't work, you'll have to search through your system library
 * to figure out which include file defines "size_t".  Look for a line that
 * says "typedef something-or-other size_t;".  Then, change the line below
 * that says "#include <someincludefile.h>" to instead include the file
 * you found size_t in, and define NEED_SPECIAL_INCLUDE.  If you can't find
 * type size_t anywhere, try replacing "#include <someincludefile.h>" with
 * "typedef unsigned int size_t;".
 */

#undef NEED_SPECIAL_INCLUDE	/* assume we DON'T need it, for starters */

#ifdef NEED_SPECIAL_INCLUDE
#include <someincludefile.h>
#endif

typedef size_t my_size_t;	/* The payoff: do we have size_t now? */


/* The next question is whether your compiler supports ANSI-style function
 * prototypes.  You need to know this in order to choose between using
 * makefile.ansi and using makefile.unix.
 * The #define line below is set to assume you have ANSI function prototypes.
 * If you get an error in this group of lines, undefine HAVE_PROTOTYPES.
 */

#define HAVE_PROTOTYPES

#ifdef HAVE_PROTOTYPES
int testfunction (int arg1, int * arg2); /* check prototypes */

struct methods_struct {		/* check method-pointer declarations */
  int (*error_exit) (char *msgtext);
  int (*trace_message) (char *msgtext);
  int (*another_method) (void);
};

int testfunction (int arg1, int * arg2) /* check definitions */
{
  return arg2[arg1];
}

int test2function (void)	/* check void arg list */
{
  return 0;
}
#endif


/* Now we want to find out if your compiler knows what "unsigned char" means.
 * If you get an error on the "unsigned char un_char;" line,
 * then undefine HAVE_UNSIGNED_CHAR.
 */

#define HAVE_UNSIGNED_CHAR

#ifdef HAVE_UNSIGNED_CHAR
unsigned char un_char;
#endif


/* Now we want to find out if your compiler knows what "unsigned short" means.
 * If you get an error on the "unsigned short un_short;" line,
 * then undefine HAVE_UNSIGNED_SHORT.
 */

#define HAVE_UNSIGNED_SHORT

#ifdef HAVE_UNSIGNED_SHORT
unsigned short un_short;
#endif


/* Now we want to find out if your compiler understands type "void".
 * If you get an error anywhere in here, undefine HAVE_VOID.
 */

#define HAVE_VOID

#ifdef HAVE_VOID
/* Caution: a C++ compiler will insist on complete prototypes */
typedef void * void_ptr;	/* check void * */
#ifdef HAVE_PROTOTYPES		/* check ptr to function returning void */
typedef void (*void_func) (int a, int b);
#else
typedef void (*void_func) ();
#endif

#ifdef HAVE_PROTOTYPES		/* check void function result */
void test3function (void_ptr arg1, void_func arg2)
#else
void test3function (arg1, arg2)
     void_ptr arg1;
     void_func arg2;
#endif
{
  char * locptr = (char *) arg1; /* check casting to and from void * */
  arg1 = (void *) locptr;
  (*arg2) (1, 2);		/* check call of fcn returning void */
}
#endif


/* Now we want to find out if your compiler knows what "const" means.
 * If you get an error here, undefine HAVE_CONST.
 */

#define HAVE_CONST

#ifdef HAVE_CONST
static const int carray[3] = {1, 2, 3};

#ifdef HAVE_PROTOTYPES
int test4function (const int arg1)
#else
int test4function (arg1)
     const int arg1;
#endif
{
  return carray[arg1];
}
#endif


/* If you get an error or warning about this structure definition,
 * define INCOMPLETE_TYPES_BROKEN.
 */

#undef INCOMPLETE_TYPES_BROKEN

#ifndef INCOMPLETE_TYPES_BROKEN
typedef struct undefined_structure * undef_struct_ptr;
#endif


/* If you get an error about duplicate names,
 * define NEED_SHORT_EXTERNAL_NAMES.
 */

#undef NEED_SHORT_EXTERNAL_NAMES

#ifndef NEED_SHORT_EXTERNAL_NAMES

int possibly_duplicate_function ()
{
  return 0;
}

int possibly_dupli_function ()
{
  return 1;
}

#endif



/************************************************************************
 *  OK, that's it.  You should not have to change anything beyond this
 *  point in order to compile and execute this program.  (You might get
 *  some warnings, but you can ignore them.)
 *  When you run the program, it will make a couple more tests that it
 *  can do automatically, and then it will create jconfig.h and print out
 *  any additional suggestions it has.
 ************************************************************************
 */


#ifdef HAVE_PROTOTYPES
int is_char_signed (int arg)
#else
int is_char_signed (arg)
     int arg;
#endif
{
  if (arg == 189) {		/* expected result for unsigned char */
    return 0;			/* type char is unsigned */
  }
  else if (arg != -67) {	/* expected result for signed char */
    printf("Hmm, it seems 'char' is not eight bits wide on your machine.\n");
    printf("I fear the JPEG software will not work at all.\n\n");
  }
  return 1;			/* assume char is signed otherwise */
}


#ifdef HAVE_PROTOTYPES
int is_shifting_signed (long arg)
#else
int is_shifting_signed (arg)
     long arg;
#endif
/* See whether right-shift on a long is signed or not. */
{
  long res = arg >> 4;

  if (res == -0x7F7E80CL) {	/* expected result for signed shift */
    return 1;			/* right shift is signed */
  }
  /* see if unsigned-shift hack will fix it. */
  /* we can't just test exact value since it depends on width of long... */
  res |= (~0L) << (32-4);
  if (res == -0x7F7E80CL) {	/* expected result now? */
    return 0;			/* right shift is unsigned */
  }
  printf("Right shift isn't acting as I expect it to.\n");
  printf("I fear the JPEG software will not work at all.\n\n");
  return 0;			/* try it with unsigned anyway */
}


#ifdef HAVE_PROTOTYPES
int main (int argc, char ** argv)
#else
int main (argc, argv)
     int argc;
     char ** argv;
#endif
{
  char signed_char_check = (char) (-67);
  FILE *outfile;

  /* Attempt to write jconfig.h */
  if ((outfile = fopen("jconfig.h", "w")) == NULL) {
    printf("Failed to write jconfig.h\n");
    return 1;
  }

  /* Write out all the info */
  fprintf(outfile, "/* jconfig.h --- generated by ckconfig.c */\n");
  fprintf(outfile, "/* see jconfig.doc for explanations */\n\n");
#ifdef HAVE_PROTOTYPES
  fprintf(outfile, "#define HAVE_PROTOTYPES\n");
#else
  fprintf(outfile, "#undef HAVE_PROTOTYPES\n");
#endif
#ifdef HAVE_UNSIGNED_CHAR
  fprintf(outfile, "#define HAVE_UNSIGNED_CHAR\n");
#else
  fprintf(outfile, "#undef HAVE_UNSIGNED_CHAR\n");
#endif
#ifdef HAVE_UNSIGNED_SHORT
  fprintf(outfile, "#define HAVE_UNSIGNED_SHORT\n");
#else
  fprintf(outfile, "#undef HAVE_UNSIGNED_SHORT\n");
#endif
#ifdef HAVE_VOID
  fprintf(outfile, "/* #define void char */\n");
#else
  fprintf(outfile, "#define void char\n");
#endif
#ifdef HAVE_CONST
  fprintf(outfile, "/* #define const */\n");
#else
  fprintf(outfile, "#define const\n");
#endif
  if (is_char_signed((int) signed_char_check))
    fprintf(outfile, "#undef CHAR_IS_UNSIGNED\n");
  else
    fprintf(outfile, "#define CHAR_IS_UNSIGNED\n");
#ifdef HAVE_STDDEF_H
  fprintf(outfile, "#define HAVE_STDDEF_H\n");
#else
  fprintf(outfile, "#undef HAVE_STDDEF_H\n");
#endif
#ifdef HAVE_STDLIB_H
  fprintf(outfile, "#define HAVE_STDLIB_H\n");
#else
  fprintf(outfile, "#undef HAVE_STDLIB_H\n");
#endif
#ifdef NEED_BSD_STRINGS
  fprintf(outfile, "#define NEED_BSD_STRINGS\n");
#else
  fprintf(outfile, "#undef NEED_BSD_STRINGS\n");
#endif
#ifdef NEED_SYS_TYPES_H
  fprintf(outfile, "#define NEED_SYS_TYPES_H\n");
#else
  fprintf(outfile, "#undef NEED_SYS_TYPES_H\n");
#endif
  fprintf(outfile, "#undef NEED_FAR_POINTERS\n");
#ifdef NEED_SHORT_EXTERNAL_NAMES
  fprintf(outfile, "#define NEED_SHORT_EXTERNAL_NAMES\n");
#else
  fprintf(outfile, "#undef NEED_SHORT_EXTERNAL_NAMES\n");
#endif
#ifdef INCOMPLETE_TYPES_BROKEN
  fprintf(outfile, "#define INCOMPLETE_TYPES_BROKEN\n");
#else
  fprintf(outfile, "#undef INCOMPLETE_TYPES_BROKEN\n");
#endif
  fprintf(outfile, "\n#ifdef JPEG_INTERNALS\n\n");
  if (is_shifting_signed(-0x7F7E80B1L))
    fprintf(outfile, "#undef RIGHT_SHIFT_IS_UNSIGNED\n");
  else
    fprintf(outfile, "#define RIGHT_SHIFT_IS_UNSIGNED\n");
  fprintf(outfile, "\n#endif /* JPEG_INTERNALS */\n");
  fprintf(outfile, "\n#ifdef JPEG_CJPEG_DJPEG\n\n");
  fprintf(outfile, "#define BMP_SUPPORTED		/* BMP image file format */\n");
  fprintf(outfile, "#define GIF_SUPPORTED		/* GIF image file format */\n");
  fprintf(outfile, "#define PPM_SUPPORTED		/* PBMPLUS PPM/PGM image file format */\n");
  fprintf(outfile, "#undef RLE_SUPPORTED		/* Utah RLE image file format */\n");
  fprintf(outfile, "#define TARGA_SUPPORTED		/* Targa image file format */\n\n");
  fprintf(outfile, "#undef TWO_FILE_COMMANDLINE	/* You may need this on non-Unix systems */\n");
  fprintf(outfile, "#undef NEED_SIGNAL_CATCHER	/* Define this if you use jmemname.c */\n");
  fprintf(outfile, "#undef DONT_USE_B_MODE\n");
  fprintf(outfile, "/* #define PROGRESS_REPORT */	/* optional */\n");
  fprintf(outfile, "\n#endif /* JPEG_CJPEG_DJPEG */\n");

  /* Close the jconfig.h file */
  fclose(outfile);

  /* User report */
  printf("Configuration check for Independent JPEG Group's software done.\n");
  printf("\nI have written the jconfig.h file for you.\n\n");
#ifdef HAVE_PROTOTYPES
  printf("You should use makefile.ansi as the starting point for your Makefile.\n");
#else
  printf("You should use makefile.unix as the starting point for your Makefile.\n");
#endif

#ifdef NEED_SPECIAL_INCLUDE
  printf("\nYou'll need to change jconfig.h to include the system include file\n");
  printf("that you found type size_t in, or add a direct definition of type\n");
  printf("size_t if that's what you used.  Just add it to the end.\n");
#endif

  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\jpeg\libjpeg\djpeg.c ===
/*
 * djpeg.c
 *
 * Copyright (C) 1991-1997, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains a command-line user interface for the JPEG decompressor.
 * It should work on any system with Unix- or MS-DOS-style command lines.
 *
 * Two different command line styles are permitted, depending on the
 * compile-time switch TWO_FILE_COMMANDLINE:
 *	djpeg [options]  inputfile outputfile
 *	djpeg [options]  [inputfile]
 * In the second style, output is always to standard output, which you'd
 * normally redirect to a file or pipe to some other program.  Input is
 * either from a named file or from standard input (typically redirected).
 * The second style is convenient on Unix but is unhelpful on systems that
 * don't support pipes.  Also, you MUST use the first style if your system
 * doesn't do binary I/O to stdin/stdout.
 * To simplify script writing, the "-outfile" switch is provided.  The syntax
 *	djpeg [options]  -outfile outputfile  inputfile
 * works regardless of which command line style is used.
 */

#include "cdjpeg.h"		/* Common decls for cjpeg/djpeg applications */
#include "jversion.h"		/* for version message */

#include <ctype.h>		/* to declare isprint() */

#ifdef USE_CCOMMAND		/* command-line reader for Macintosh */
#ifdef __MWERKS__
#include <SIOUX.h>              /* Metrowerks needs this */
#include <console.h>		/* ... and this */
#endif
#ifdef THINK_C
#include <console.h>		/* Think declares it here */
#endif
#endif


/* Create the add-on message string table. */

#define JMESSAGE(code,string)	string ,

static const char * const cdjpeg_message_table[] = {
#include "cderror.h"
  NULL
};


/*
 * This list defines the known output image formats
 * (not all of which need be supported by a given version).
 * You can change the default output format by defining DEFAULT_FMT;
 * indeed, you had better do so if you undefine PPM_SUPPORTED.
 */

typedef enum {
	FMT_BMP,		/* BMP format (Windows flavor) */
	FMT_GIF,		/* GIF format */
	FMT_OS2,		/* BMP format (OS/2 flavor) */
	FMT_PPM,		/* PPM/PGM (PBMPLUS formats) */
	FMT_RLE,		/* RLE format */
	FMT_TARGA,		/* Targa format */
	FMT_TIFF		/* TIFF format */
} IMAGE_FORMATS;

#ifndef DEFAULT_FMT		/* so can override from CFLAGS in Makefile */
#define DEFAULT_FMT	FMT_PPM
#endif

static IMAGE_FORMATS requested_fmt;


/*
 * Argument-parsing code.
 * The switch parser is designed to be useful with DOS-style command line
 * syntax, ie, intermixed switches and file names, where only the switches
 * to the left of a given file name affect processing of that file.
 * The main program in this file doesn't actually use this capability...
 */


static const char * progname;	/* program name for error messages */
static char * outfilename;	/* for -outfile switch */


LOCAL(void)
usage (void)
/* complain about bad command line */
{
  fprintf(stderr, "usage: %s [switches] ", progname);
#ifdef TWO_FILE_COMMANDLINE
  fprintf(stderr, "inputfile outputfile\n");
#else
  fprintf(stderr, "[inputfile]\n");
#endif

  fprintf(stderr, "Switches (names may be abbreviated):\n");
  fprintf(stderr, "  -colors N      Reduce image to no more than N colors\n");
  fprintf(stderr, "  -fast          Fast, low-quality processing\n");
  fprintf(stderr, "  -grayscale     Force grayscale output\n");
#ifdef IDCT_SCALING_SUPPORTED
  fprintf(stderr, "  -scale M/N     Scale output image by fraction M/N, eg, 1/8\n");
#endif
#ifdef BMP_SUPPORTED
  fprintf(stderr, "  -bmp           Select BMP output format (Windows style)%s\n",
	  (DEFAULT_FMT == FMT_BMP ? " (default)" : ""));
#endif
#ifdef GIF_SUPPORTED
  fprintf(stderr, "  -gif           Select GIF output format%s\n",
	  (DEFAULT_FMT == FMT_GIF ? " (default)" : ""));
#endif
#ifdef BMP_SUPPORTED
  fprintf(stderr, "  -os2           Select BMP output format (OS/2 style)%s\n",
	  (DEFAULT_FMT == FMT_OS2 ? " (default)" : ""));
#endif
#ifdef PPM_SUPPORTED
  fprintf(stderr, "  -pnm           Select PBMPLUS (PPM/PGM) output format%s\n",
	  (DEFAULT_FMT == FMT_PPM ? " (default)" : ""));
#endif
#ifdef RLE_SUPPORTED
  fprintf(stderr, "  -rle           Select Utah RLE output format%s\n",
	  (DEFAULT_FMT == FMT_RLE ? " (default)" : ""));
#endif
#ifdef TARGA_SUPPORTED
  fprintf(stderr, "  -targa         Select Targa output format%s\n",
	  (DEFAULT_FMT == FMT_TARGA ? " (default)" : ""));
#endif
  fprintf(stderr, "Switches for advanced users:\n");
#ifdef DCT_ISLOW_SUPPORTED
  fprintf(stderr, "  -dct int       Use integer DCT method%s\n",
	  (JDCT_DEFAULT == JDCT_ISLOW ? " (default)" : ""));
#endif
#ifdef DCT_IFAST_SUPPORTED
  fprintf(stderr, "  -dct fast      Use fast integer DCT (less accurate)%s\n",
	  (JDCT_DEFAULT == JDCT_IFAST ? " (default)" : ""));
#endif
#ifdef DCT_FLOAT_SUPPORTED
  fprintf(stderr, "  -dct float     Use floating-point DCT method%s\n",
	  (JDCT_DEFAULT == JDCT_FLOAT ? " (default)" : ""));
#endif
  fprintf(stderr, "  -dither fs     Use F-S dithering (default)\n");
  fprintf(stderr, "  -dither none   Don't use dithering in quantization\n");
  fprintf(stderr, "  -dither ordered  Use ordered dither (medium speed, quality)\n");
#ifdef QUANT_2PASS_SUPPORTED
  fprintf(stderr, "  -map FILE      Map to colors used in named image file\n");
#endif
  fprintf(stderr, "  -nosmooth      Don't use high-quality upsampling\n");
#ifdef QUANT_1PASS_SUPPORTED
  fprintf(stderr, "  -onepass       Use 1-pass quantization (fast, low quality)\n");
#endif
  fprintf(stderr, "  -maxmemory N   Maximum memory to use (in kbytes)\n");
  fprintf(stderr, "  -outfile name  Specify name for output file\n");
  fprintf(stderr, "  -verbose  or  -debug   Emit debug output\n");
  exit(EXIT_FAILURE);
}


LOCAL(int)
parse_switches (j_decompress_ptr cinfo, int argc, char **argv,
		int last_file_arg_seen, boolean for_real)
/* Parse optional switches.
 * Returns argv[] index of first file-name argument (== argc if none).
 * Any file names with indexes <= last_file_arg_seen are ignored;
 * they have presumably been processed in a previous iteration.
 * (Pass 0 for last_file_arg_seen on the first or only iteration.)
 * for_real is FALSE on the first (dummy) pass; we may skip any expensive
 * processing.
 */
{
  int argn;
  char * arg;

  /* Set up default JPEG parameters. */
  requested_fmt = DEFAULT_FMT;	/* set default output file format */
  outfilename = NULL;
  cinfo->err->trace_level = 0;

  /* Scan command line options, adjust parameters */

  for (argn = 1; argn < argc; argn++) {
    arg = argv[argn];
    if (*arg != '-') {
      /* Not a switch, must be a file name argument */
      if (argn <= last_file_arg_seen) {
	outfilename = NULL;	/* -outfile applies to just one input file */
	continue;		/* ignore this name if previously processed */
      }
      break;			/* else done parsing switches */
    }
    arg++;			/* advance past switch marker character */

    if (keymatch(arg, "bmp", 1)) {
      /* BMP output format. */
      requested_fmt = FMT_BMP;

    } else if (keymatch(arg, "colors", 1) || keymatch(arg, "colours", 1) ||
	       keymatch(arg, "quantize", 1) || keymatch(arg, "quantise", 1)) {
      /* Do color quantization. */
      int val;

      if (++argn >= argc)	/* advance to next argument */
	usage();
      if (sscanf(argv[argn], "%d", &val) != 1)
	usage();
      cinfo->desired_number_of_colors = val;
      cinfo->quantize_colors = TRUE;

    } else if (keymatch(arg, "dct", 2)) {
      /* Select IDCT algorithm. */
      if (++argn >= argc)	/* advance to next argument */
	usage();
      if (keymatch(argv[argn], "int", 1)) {
	cinfo->dct_method = JDCT_ISLOW;
      } else if (keymatch(argv[argn], "fast", 2)) {
	cinfo->dct_method = JDCT_IFAST;
      } else if (keymatch(argv[argn], "float", 2)) {
	cinfo->dct_method = JDCT_FLOAT;
      } else
	usage();

    } else if (keymatch(arg, "dither", 2)) {
      /* Select dithering algorithm. */
      if (++argn >= argc)	/* advance to next argument */
	usage();
      if (keymatch(argv[argn], "fs", 2)) {
	cinfo->dither_mode = JDITHER_FS;
      } else if (keymatch(argv[argn], "none", 2)) {
	cinfo->dither_mode = JDITHER_NONE;
      } else if (keymatch(argv[argn], "ordered", 2)) {
	cinfo->dither_mode = JDITHER_ORDERED;
      } else
	usage();

    } else if (keymatch(arg, "debug", 1) || keymatch(arg, "verbose", 1)) {
      /* Enable debug printouts. */
      /* On first -d, print version identification */
      static boolean printed_version = FALSE;

      if (! printed_version) {
	fprintf(stderr, "Independent JPEG Group's DJPEG, version %s\n%s\n",
		JVERSION, JCOPYRIGHT);
	printed_version = TRUE;
      }
      cinfo->err->trace_level++;

    } else if (keymatch(arg, "fast", 1)) {
      /* Select recommended processing options for quick-and-dirty output. */
      cinfo->two_pass_quantize = FALSE;
      cinfo->dither_mode = JDITHER_ORDERED;
      if (! cinfo->quantize_colors) /* don't override an earlier -colors */
	cinfo->desired_number_of_colors = 216;
      cinfo->dct_method = JDCT_FASTEST;
      cinfo->do_fancy_upsampling = FALSE;

    } else if (keymatch(arg, "gif", 1)) {
      /* GIF output format. */
      requested_fmt = FMT_GIF;

    } else if (keymatch(arg, "grayscale", 2) || keymatch(arg, "greyscale",2)) {
      /* Force monochrome output. */
      cinfo->out_color_space = JCS_GRAYSCALE;

    } else if (keymatch(arg, "map", 3)) {
      /* Quantize to a color map taken from an input file. */
      if (++argn >= argc)	/* advance to next argument */
	usage();
      if (for_real) {		/* too expensive to do twice! */
#ifdef QUANT_2PASS_SUPPORTED	/* otherwise can't quantize to supplied map */
	FILE * mapfile;

	if ((mapfile = fopen(argv[argn], READ_BINARY)) == NULL) {
	  fprintf(stderr, "%s: can't open %s\n", progname, argv[argn]);
	  exit(EXIT_FAILURE);
	}
	read_color_map(cinfo, mapfile);
	fclose(mapfile);
	cinfo->quantize_colors = TRUE;
#else
	ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif
      }

    } else if (keymatch(arg, "maxmemory", 3)) {
      /* Maximum memory in Kb (or Mb with 'm'). */
      long lval;
      char ch = 'x';

      if (++argn >= argc)	/* advance to next argument */
	usage();
      if (sscanf(argv[argn], "%ld%c", &lval, &ch) < 1)
	usage();
      if (ch == 'm' || ch == 'M')
	lval *= 1000L;
      cinfo->mem->max_memory_to_use = lval * 1000L;

    } else if (keymatch(arg, "nosmooth", 3)) {
      /* Suppress fancy upsampling */
      cinfo->do_fancy_upsampling = FALSE;

    } else if (keymatch(arg, "onepass", 3)) {
      /* Use fast one-pass quantization. */
      cinfo->two_pass_quantize = FALSE;

    } else if (keymatch(arg, "os2", 3)) {
      /* BMP output format (OS/2 flavor). */
      requested_fmt = FMT_OS2;

    } else if (keymatch(arg, "outfile", 4)) {
      /* Set output file name. */
      if (++argn >= argc)	/* advance to next argument */
	usage();
      outfilename = argv[argn];	/* save it away for later use */

    } else if (keymatch(arg, "pnm", 1) || keymatch(arg, "ppm", 1)) {
      /* PPM/PGM output format. */
      requested_fmt = FMT_PPM;

    } else if (keymatch(arg, "rle", 1)) {
      /* RLE output format. */
      requested_fmt = FMT_RLE;

    } else if (keymatch(arg, "scale", 1)) {
      /* Scale the output image by a fraction M/N. */
      if (++argn >= argc)	/* advance to next argument */
	usage();
      if (sscanf(argv[argn], "%d/%d",
		 &cinfo->scale_num, &cinfo->scale_denom) != 2)
	usage();

    } else if (keymatch(arg, "targa", 1)) {
      /* Targa output format. */
      requested_fmt = FMT_TARGA;

    } else {
      usage();			/* bogus switch */
    }
  }

  return argn;			/* return index of next arg (file name) */
}


/*
 * Marker processor for COM and interesting APPn markers.
 * This replaces the library's built-in processor, which just skips the marker.
 * We want to print out the marker as text, to the extent possible.
 * Note this code relies on a non-suspending data source.
 */

LOCAL(unsigned int)
jpeg_getc (j_decompress_ptr cinfo)
/* Read next byte */
{
  struct jpeg_source_mgr * datasrc = cinfo->src;

  if (datasrc->bytes_in_buffer == 0) {
    if (! (*datasrc->fill_input_buffer) (cinfo))
      ERREXIT(cinfo, JERR_CANT_SUSPEND);
  }
  datasrc->bytes_in_buffer--;
  return GETJOCTET(*datasrc->next_input_byte++);
}


METHODDEF(boolean)
print_text_marker (j_decompress_ptr cinfo)
{
  boolean traceit = (cinfo->err->trace_level >= 1);
  INT32 length;
  unsigned int ch;
  unsigned int lastch = 0;

  length = jpeg_getc(cinfo) << 8;
  length += jpeg_getc(cinfo);
  length -= 2;			/* discount the length word itself */

  if (traceit) {
    if (cinfo->unread_marker == JPEG_COM)
      fprintf(stderr, "Comment, length %ld:\n", (long) length);
    else			/* assume it is an APPn otherwise */
      fprintf(stderr, "APP%d, length %ld:\n",
	      cinfo->unread_marker - JPEG_APP0, (long) length);
  }

  while (--length >= 0) {
    ch = jpeg_getc(cinfo);
    if (traceit) {
      /* Emit the character in a readable form.
       * Nonprintables are converted to \nnn form,
       * while \ is converted to \\.
       * Newlines in CR, CR/LF, or LF form will be printed as one newline.
       */
      if (ch == '\r') {
	fprintf(stderr, "\n");
      } else if (ch == '\n') {
	if (lastch != '\r')
	  fprintf(stderr, "\n");
      } else if (ch == '\\') {
	fprintf(stderr, "\\\\");
      } else if (isprint(ch)) {
	putc(ch, stderr);
      } else {
	fprintf(stderr, "\\%03o", ch);
      }
      lastch = ch;
    }
  }

  if (traceit)
    fprintf(stderr, "\n");

  return TRUE;
}


/*
 * The main program.
 */

int
main (int argc, char **argv)
{
  struct jpeg_decompress_struct cinfo;
  struct jpeg_error_mgr jerr;
#ifdef PROGRESS_REPORT
  struct cdjpeg_progress_mgr progress;
#endif
  int file_index;
  djpeg_dest_ptr dest_mgr = NULL;
  FILE * input_file;
  FILE * output_file;
  JDIMENSION num_scanlines;

  /* On Mac, fetch a command line. */
#ifdef USE_CCOMMAND
  argc = ccommand(&argv);
#endif

  progname = argv[0];
  if (progname == NULL || progname[0] == 0)
    progname = "djpeg";		/* in case C library doesn't provide it */

  /* Initialize the JPEG decompression object with default error handling. */
  cinfo.err = jpeg_std_error(&jerr);
  jpeg_create_decompress(&cinfo);
  /* Add some application-specific error messages (from cderror.h) */
  jerr.addon_message_table = cdjpeg_message_table;
  jerr.first_addon_message = JMSG_FIRSTADDONCODE;
  jerr.last_addon_message = JMSG_LASTADDONCODE;

  /* Insert custom marker processor for COM and APP12.
   * APP12 is used by some digital camera makers for textual info,
   * so we provide the ability to display it as text.
   * If you like, additional APPn marker types can be selected for display,
   * but don't try to override APP0 or APP14 this way (see libjpeg.doc).
   */
  jpeg_set_marker_processor(&cinfo, JPEG_COM, print_text_marker);
  jpeg_set_marker_processor(&cinfo, JPEG_APP0+12, print_text_marker);

  /* Now safe to enable signal catcher. */
#ifdef NEED_SIGNAL_CATCHER
  enable_signal_catcher((j_common_ptr) &cinfo);
#endif

  /* Scan command line to find file names. */
  /* It is convenient to use just one switch-parsing routine, but the switch
   * values read here are ignored; we will rescan the switches after opening
   * the input file.
   * (Exception: tracing level set here controls verbosity for COM markers
   * found during jpeg_read_header...)
   */

  file_index = parse_switches(&cinfo, argc, argv, 0, FALSE);

#ifdef TWO_FILE_COMMANDLINE
  /* Must have either -outfile switch or explicit output file name */
  if (outfilename == NULL) {
    if (file_index != argc-2) {
      fprintf(stderr, "%s: must name one input and one output file\n",
	      progname);
      usage();
    }
    outfilename = argv[file_index+1];
  } else {
    if (file_index != argc-1) {
      fprintf(stderr, "%s: must name one input and one output file\n",
	      progname);
      usage();
    }
  }
#else
  /* Unix style: expect zero or one file name */
  if (file_index < argc-1) {
    fprintf(stderr, "%s: only one input file\n", progname);
    usage();
  }
#endif /* TWO_FILE_COMMANDLINE */

  /* Open the input file. */
  if (file_index < argc) {
    if ((input_file = fopen(argv[file_index], READ_BINARY)) == NULL) {
      fprintf(stderr, "%s: can't open %s\n", progname, argv[file_index]);
      exit(EXIT_FAILURE);
    }
  } else {
    /* default input file is stdin */
    input_file = read_stdin();
  }

  /* Open the output file. */
  if (outfilename != NULL) {
    if ((output_file = fopen(outfilename, WRITE_BINARY)) == NULL) {
      fprintf(stderr, "%s: can't open %s\n", progname, outfilename);
      exit(EXIT_FAILURE);
    }
  } else {
    /* default output file is stdout */
    output_file = write_stdout();
  }

#ifdef PROGRESS_REPORT
  start_progress_monitor((j_common_ptr) &cinfo, &progress);
#endif

  /* Specify data source for decompression */
  jpeg_stdio_src(&cinfo, input_file);

  /* Read file header, set default decompression parameters */
  (void) jpeg_read_header(&cinfo, TRUE);

  /* Adjust default decompression parameters by re-parsing the options */
  file_index = parse_switches(&cinfo, argc, argv, 0, TRUE);

  /* Initialize the output module now to let it override any crucial
   * option settings (for instance, GIF wants to force color quantization).
   */
  switch (requested_fmt) {
#ifdef BMP_SUPPORTED
  case FMT_BMP:
    dest_mgr = jinit_write_bmp(&cinfo, FALSE);
    break;
  case FMT_OS2:
    dest_mgr = jinit_write_bmp(&cinfo, TRUE);
    break;
#endif
#ifdef GIF_SUPPORTED
  case FMT_GIF:
    dest_mgr = jinit_write_gif(&cinfo);
    break;
#endif
#ifdef PPM_SUPPORTED
  case FMT_PPM:
    dest_mgr = jinit_write_ppm(&cinfo);
    break;
#endif
#ifdef RLE_SUPPORTED
  case FMT_RLE:
    dest_mgr = jinit_write_rle(&cinfo);
    break;
#endif
#ifdef TARGA_SUPPORTED
  case FMT_TARGA:
    dest_mgr = jinit_write_targa(&cinfo);
    break;
#endif
  default:
    ERREXIT(&cinfo, JERR_UNSUPPORTED_FORMAT);
    break;
  }
  dest_mgr->output_file = output_file;

  /* Start decompressor */
  (void) jpeg_start_decompress(&cinfo);

  /* Write output file header */
  (*dest_mgr->start_output) (&cinfo, dest_mgr);

  /* Process data */
  while (cinfo.output_scanline < cinfo.output_height) {
    num_scanlines = jpeg_read_scanlines(&cinfo, dest_mgr->buffer,
					dest_mgr->buffer_height);
    (*dest_mgr->put_pixel_rows) (&cinfo, dest_mgr, num_scanlines);
  }

#ifdef PROGRESS_REPORT
  /* Hack: count final pass as done in case finish_output does an extra pass.
   * The library won't have updated completed_passes.
   */
  progress.pub.completed_passes = progress.pub.total_passes;
#endif

  /* Finish decompression and release memory.
   * I must do it in this order because output module has allocated memory
   * of lifespan JPOOL_IMAGE; it needs to finish before releasing memory.
   */
  (*dest_mgr->finish_output) (&cinfo, dest_mgr);
  (void) jpeg_finish_decompress(&cinfo);
  jpeg_destroy_decompress(&cinfo);

  /* Close files, if we opened them */
  if (input_file != stdin)
    fclose(input_file);
  if (output_file != stdout)
    fclose(output_file);

#ifdef PROGRESS_REPORT
  end_progress_monitor((j_common_ptr) &cinfo);
#endif

  /* All done. */
  exit(jerr.num_warnings ? EXIT_WARNING : EXIT_SUCCESS);
  return 0;			/* suppress no-return-value warnings */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\jpeg\libjpeg\example.c ===
/*
 * example.c
 *
 * This file illustrates how to use the IJG code as a subroutine library
 * to read or write JPEG image files.  You should look at this code in
 * conjunction with the documentation file libjpeg.doc.
 *
 * This code will not do anything useful as-is, but it may be helpful as a
 * skeleton for constructing routines that call the JPEG library.  
 *
 * We present these routines in the same coding style used in the JPEG code
 * (ANSI function definitions, etc); but you are of course free to code your
 * routines in a different style if you prefer.
 */

#include <stdio.h>

/*
 * Include file for users of JPEG library.
 * You will need to have included system headers that define at least
 * the typedefs FILE and size_t before you can include jpeglib.h.
 * (stdio.h is sufficient on ANSI-conforming systems.)
 * You may also wish to include "jerror.h".
 */

#include "jpeglib.h"

/*
 * <setjmp.h> is used for the optional error recovery mechanism shown in
 * the second part of the example.
 */

#include <setjmp.h>



/******************** JPEG COMPRESSION SAMPLE INTERFACE *******************/

/* This half of the example shows how to feed data into the JPEG compressor.
 * We present a minimal version that does not worry about refinements such
 * as error recovery (the JPEG code will just exit() if it gets an error).
 */


/*
 * IMAGE DATA FORMATS:
 *
 * The standard input image format is a rectangular array of pixels, with
 * each pixel having the same number of "component" values (color channels).
 * Each pixel row is an array of JSAMPLEs (which typically are unsigned chars).
 * If you are working with color data, then the color values for each pixel
 * must be adjacent in the row; for example, R,G,B,R,G,B,R,G,B,... for 24-bit
 * RGB color.
 *
 * For this example, we'll assume that this data structure matches the way
 * our application has stored the image in memory, so we can just pass a
 * pointer to our image buffer.  In particular, let's say that the image is
 * RGB color and is described by:
 */

extern JSAMPLE * image_buffer;	/* Points to large array of R,G,B-order data */
extern int image_height;	/* Number of rows in image */
extern int image_width;		/* Number of columns in image */


/*
 * Sample routine for JPEG compression.  We assume that the target file name
 * and a compression quality factor are passed in.
 */

GLOBAL(void)
write_JPEG_file (char * filename, int quality)
{
  /* This struct contains the JPEG compression parameters and pointers to
   * working space (which is allocated as needed by the JPEG library).
   * It is possible to have several such structures, representing multiple
   * compression/decompression processes, in existence at once.  We refer
   * to any one struct (and its associated working data) as a "JPEG object".
   */
  struct jpeg_compress_struct cinfo;
  /* This struct represents a JPEG error handler.  It is declared separately
   * because applications often want to supply a specialized error handler
   * (see the second half of this file for an example).  But here we just
   * take the easy way out and use the standard error handler, which will
   * print a message on stderr and call exit() if compression fails.
   * Note that this struct must live as long as the main JPEG parameter
   * struct, to avoid dangling-pointer problems.
   */
  struct jpeg_error_mgr jerr;
  /* More stuff */
  FILE * outfile;		/* target file */
  JSAMPROW row_pointer[1];	/* pointer to JSAMPLE row[s] */
  int row_stride;		/* physical row width in image buffer */

  /* Step 1: allocate and initialize JPEG compression object */

  /* We have to set up the error handler first, in case the initialization
   * step fails.  (Unlikely, but it could happen if you are out of memory.)
   * This routine fills in the contents of struct jerr, and returns jerr's
   * address which we place into the link field in cinfo.
   */
  cinfo.err = jpeg_std_error(&jerr);
  /* Now we can initialize the JPEG compression object. */
  jpeg_create_compress(&cinfo);

  /* Step 2: specify data destination (eg, a file) */
  /* Note: steps 2 and 3 can be done in either order. */

  /* Here we use the library-supplied code to send compressed data to a
   * stdio stream.  You can also write your own code to do something else.
   * VERY IMPORTANT: use "b" option to fopen() if you are on a machine that
   * requires it in order to write binary files.
   */
  if ((outfile = fopen(filename, "wb")) == NULL) {
    fprintf(stderr, "can't open %s\n", filename);
    exit(1);
  }
  jpeg_stdio_dest(&cinfo, outfile);

  /* Step 3: set parameters for compression */

  /* First we supply a description of the input image.
   * Four fields of the cinfo struct must be filled in:
   */
  cinfo.image_width = image_width; 	/* image width and height, in pixels */
  cinfo.image_height = image_height;
  cinfo.input_components = 3;		/* # of color components per pixel */
  cinfo.in_color_space = JCS_RGB; 	/* colorspace of input image */
  /* Now use the library's routine to set default compression parameters.
   * (You must set at least cinfo.in_color_space before calling this,
   * since the defaults depend on the source color space.)
   */
  jpeg_set_defaults(&cinfo);
  /* Now you can set any non-default parameters you wish to.
   * Here we just illustrate the use of quality (quantization table) scaling:
   */
  jpeg_set_quality(&cinfo, quality, TRUE /* limit to baseline-JPEG values */);

  /* Step 4: Start compressor */

  /* TRUE ensures that we will write a complete interchange-JPEG file.
   * Pass TRUE unless you are very sure of what you're doing.
   */
  jpeg_start_compress(&cinfo, TRUE);

  /* Step 5: while (scan lines remain to be written) */
  /*           jpeg_write_scanlines(...); */

  /* Here we use the library's state variable cinfo.next_scanline as the
   * loop counter, so that we don't have to keep track ourselves.
   * To keep things simple, we pass one scanline per call; you can pass
   * more if you wish, though.
   */
  row_stride = image_width * 3;	/* JSAMPLEs per row in image_buffer */

  while (cinfo.next_scanline < cinfo.image_height) {
    /* jpeg_write_scanlines expects an array of pointers to scanlines.
     * Here the array is only one element long, but you could pass
     * more than one scanline at a time if that's more convenient.
     */
    row_pointer[0] = & image_buffer[cinfo.next_scanline * row_stride];
    (void) jpeg_write_scanlines(&cinfo, row_pointer, 1);
  }

  /* Step 6: Finish compression */

  jpeg_finish_compress(&cinfo);
  /* After finish_compress, we can close the output file. */
  fclose(outfile);

  /* Step 7: release JPEG compression object */

  /* This is an important step since it will release a good deal of memory. */
  jpeg_destroy_compress(&cinfo);

  /* And we're done! */
}


/*
 * SOME FINE POINTS:
 *
 * In the above loop, we ignored the return value of jpeg_write_scanlines,
 * which is the number of scanlines actually written.  We could get away
 * with this because we were only relying on the value of cinfo.next_scanline,
 * which will be incremented correctly.  If you maintain additional loop
 * variables then you should be careful to increment them properly.
 * Actually, for output to a stdio stream you needn't worry, because
 * then jpeg_write_scanlines will write all the lines passed (or else exit
 * with a fatal error).  Partial writes can only occur if you use a data
 * destination module that can demand suspension of the compressor.
 * (If you don't know what that's for, you don't need it.)
 *
 * If the compressor requires full-image buffers (for entropy-coding
 * optimization or a multi-scan JPEG file), it will create temporary
 * files for anything that doesn't fit within the maximum-memory setting.
 * (Note that temp files are NOT needed if you use the default parameters.)
 * On some systems you may need to set up a signal handler to ensure that
 * temporary files are deleted if the program is interrupted.  See libjpeg.doc.
 *
 * Scanlines MUST be supplied in top-to-bottom order if you want your JPEG
 * files to be compatible with everyone else's.  If you cannot readily read
 * your data in that order, you'll need an intermediate array to hold the
 * image.  See rdtarga.c or rdbmp.c for examples of handling bottom-to-top
 * source data using the JPEG code's internal virtual-array mechanisms.
 */



/******************** JPEG DECOMPRESSION SAMPLE INTERFACE *******************/

/* This half of the example shows how to read data from the JPEG decompressor.
 * It's a bit more refined than the above, in that we show:
 *   (a) how to modify the JPEG library's standard error-reporting behavior;
 *   (b) how to allocate workspace using the library's memory manager.
 *
 * Just to make this example a little different from the first one, we'll
 * assume that we do not intend to put the whole image into an in-memory
 * buffer, but to send it line-by-line someplace else.  We need a one-
 * scanline-high JSAMPLE array as a work buffer, and we will let the JPEG
 * memory manager allocate it for us.  This approach is actually quite useful
 * because we don't need to remember to deallocate the buffer separately: it
 * will go away automatically when the JPEG object is cleaned up.
 */


/*
 * ERROR HANDLING:
 *
 * The JPEG library's standard error handler (jerror.c) is divided into
 * several "methods" which you can override individually.  This lets you
 * adjust the behavior without duplicating a lot of code, which you might
 * have to update with each future release.
 *
 * Our example here shows how to override the "error_exit" method so that
 * control is returned to the library's caller when a fatal error occurs,
 * rather than calling exit() as the standard error_exit method does.
 *
 * We use C's setjmp/longjmp facility to return control.  This means that the
 * routine which calls the JPEG library must first execute a setjmp() call to
 * establish the return point.  We want the replacement error_exit to do a
 * longjmp().  But we need to make the setjmp buffer accessible to the
 * error_exit routine.  To do this, we make a private extension of the
 * standard JPEG error handler object.  (If we were using C++, we'd say we
 * were making a subclass of the regular error handler.)
 *
 * Here's the extended error handler struct:
 */

struct my_error_mgr {
  struct jpeg_error_mgr pub;	/* "public" fields */

  jmp_buf setjmp_buffer;	/* for return to caller */
};

typedef struct my_error_mgr * my_error_ptr;

/*
 * Here's the routine that will replace the standard error_exit method:
 */

METHODDEF(void)
my_error_exit (j_common_ptr cinfo)
{
  /* cinfo->err really points to a my_error_mgr struct, so coerce pointer */
  my_error_ptr myerr = (my_error_ptr) cinfo->err;

  /* Always display the message. */
  /* We could postpone this until after returning, if we chose. */
  (*cinfo->err->output_message) (cinfo);

  /* Return control to the setjmp point */
  longjmp(myerr->setjmp_buffer, 1);
}


/*
 * Sample routine for JPEG decompression.  We assume that the source file name
 * is passed in.  We want to return 1 on success, 0 on error.
 */


GLOBAL(int)
read_JPEG_file (char * filename)
{
  /* This struct contains the JPEG decompression parameters and pointers to
   * working space (which is allocated as needed by the JPEG library).
   */
  struct jpeg_decompress_struct cinfo;
  /* We use our private extension JPEG error handler.
   * Note that this struct must live as long as the main JPEG parameter
   * struct, to avoid dangling-pointer problems.
   */
  struct my_error_mgr jerr;
  /* More stuff */
  FILE * infile;		/* source file */
  JSAMPARRAY buffer;		/* Output row buffer */
  int row_stride;		/* physical row width in output buffer */

  /* In this example we want to open the input file before doing anything else,
   * so that the setjmp() error recovery below can assume the file is open.
   * VERY IMPORTANT: use "b" option to fopen() if you are on a machine that
   * requires it in order to read binary files.
   */

  if ((infile = fopen(filename, "rb")) == NULL) {
    fprintf(stderr, "can't open %s\n", filename);
    return 0;
  }

  /* Step 1: allocate and initialize JPEG decompression object */

  /* We set up the normal JPEG error routines, then override error_exit. */
  cinfo.err = jpeg_std_error(&jerr.pub);
  jerr.pub.error_exit = my_error_exit;
  /* Establish the setjmp return context for my_error_exit to use. */
  if (setjmp(jerr.setjmp_buffer)) {
    /* If we get here, the JPEG code has signaled an error.
     * We need to clean up the JPEG object, close the input file, and return.
     */
    jpeg_destroy_decompress(&cinfo);
    fclose(infile);
    return 0;
  }
  /* Now we can initialize the JPEG decompression object. */
  jpeg_create_decompress(&cinfo);

  /* Step 2: specify data source (eg, a file) */

  jpeg_stdio_src(&cinfo, infile);

  /* Step 3: read file parameters with jpeg_read_header() */

  (void) jpeg_read_header(&cinfo, TRUE);
  /* We can ignore the return value from jpeg_read_header since
   *   (a) suspension is not possible with the stdio data source, and
   *   (b) we passed TRUE to reject a tables-only JPEG file as an error.
   * See libjpeg.doc for more info.
   */

  /* Step 4: set parameters for decompression */

  /* In this example, we don't need to change any of the defaults set by
   * jpeg_read_header(), so we do nothing here.
   */

  /* Step 5: Start decompressor */

  (void) jpeg_start_decompress(&cinfo);
  /* We can ignore the return value since suspension is not possible
   * with the stdio data source.
   */

  /* We may need to do some setup of our own at this point before reading
   * the data.  After jpeg_start_decompress() we have the correct scaled
   * output image dimensions available, as well as the output colormap
   * if we asked for color quantization.
   * In this example, we need to make an output work buffer of the right size.
   */ 
  /* JSAMPLEs per row in output buffer */
  row_stride = cinfo.output_width * cinfo.output_components;
  /* Make a one-row-high sample array that will go away when done with image */
  buffer = (*cinfo.mem->alloc_sarray)
		((j_common_ptr) &cinfo, JPOOL_IMAGE, row_stride, 1);

  /* Step 6: while (scan lines remain to be read) */
  /*           jpeg_read_scanlines(...); */

  /* Here we use the library's state variable cinfo.output_scanline as the
   * loop counter, so that we don't have to keep track ourselves.
   */
  while (cinfo.output_scanline < cinfo.output_height) {
    /* jpeg_read_scanlines expects an array of pointers to scanlines.
     * Here the array is only one element long, but you could ask for
     * more than one scanline at a time if that's more convenient.
     */
    (void) jpeg_read_scanlines(&cinfo, buffer, 1);
    /* Assume put_scanline_someplace wants a pointer and sample count. */
    put_scanline_someplace(buffer[0], row_stride);
  }

  /* Step 7: Finish decompression */

  (void) jpeg_finish_decompress(&cinfo);
  /* We can ignore the return value since suspension is not possible
   * with the stdio data source.
   */

  /* Step 8: Release JPEG decompression object */

  /* This is an important step since it will release a good deal of memory. */
  jpeg_destroy_decompress(&cinfo);

  /* After finish_decompress, we can close the input file.
   * Here we postpone it until after no more JPEG errors are possible,
   * so as to simplify the setjmp error logic above.  (Actually, I don't
   * think that jpeg_destroy can do an error exit, but why assume anything...)
   */
  fclose(infile);

  /* At this point you may want to check to see whether any corrupt-data
   * warnings occurred (test whether jerr.pub.num_warnings is nonzero).
   */

  /* And we're done! */
  return 1;
}


/*
 * SOME FINE POINTS:
 *
 * In the above code, we ignored the return value of jpeg_read_scanlines,
 * which is the number of scanlines actually read.  We could get away with
 * this because we asked for only one line at a time and we weren't using
 * a suspending data source.  See libjpeg.doc for more info.
 *
 * We cheated a bit by calling alloc_sarray() after jpeg_start_decompress();
 * we should have done it beforehand to ensure that the space would be
 * counted against the JPEG max_memory setting.  In some systems the above
 * code would risk an out-of-memory error.  However, in general we don't
 * know the output image dimensions before jpeg_start_decompress(), unless we
 * call jpeg_calc_output_dimensions().  See libjpeg.doc for more about this.
 *
 * Scanlines are returned in the same order as they appear in the JPEG file,
 * which is standardly top-to-bottom.  If you must emit data bottom-to-top,
 * you can use one of the virtual arrays provided by the JPEG memory manager
 * to invert the data.  See wrbmp.c for an example.
 *
 * As with compression, some operating modes may require temporary files.
 * On some systems you may need to set up a signal handler to ensure that
 * temporary files are deleted if the program is interrupted.  See libjpeg.doc.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\jpeg\libjpeg\jccoefct.c ===
/*
 * jccoefct.c
 *
 * Copyright (C) 1994-1997, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains the coefficient buffer controller for compression.
 * This controller is the top level of the JPEG compressor proper.
 * The coefficient buffer lies between forward-DCT and entropy encoding steps.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"


/* We use a full-image coefficient buffer when doing Huffman optimization,
 * and also for writing multiple-scan JPEG files.  In all cases, the DCT
 * step is run during the first pass, and subsequent passes need only read
 * the buffered coefficients.
 */
#ifdef ENTROPY_OPT_SUPPORTED
#define FULL_COEF_BUFFER_SUPPORTED
#else
#ifdef C_MULTISCAN_FILES_SUPPORTED
#define FULL_COEF_BUFFER_SUPPORTED
#endif
#endif


/* Private buffer controller object */

typedef struct {
  struct jpeg_c_coef_controller pub; /* public fields */

  JDIMENSION iMCU_row_num;	/* iMCU row # within image */
  JDIMENSION mcu_ctr;		/* counts MCUs processed in current row */
  int MCU_vert_offset;		/* counts MCU rows within iMCU row */
  int MCU_rows_per_iMCU_row;	/* number of such rows needed */

  /* For single-pass compression, it's sufficient to buffer just one MCU
   * (although this may prove a bit slow in practice).  We allocate a
   * workspace of C_MAX_BLOCKS_IN_MCU coefficient blocks, and reuse it for each
   * MCU constructed and sent.  (On 80x86, the workspace is FAR even though
   * it's not really very big; this is to keep the module interfaces unchanged
   * when a large coefficient buffer is necessary.)
   * In multi-pass modes, this array points to the current MCU's blocks
   * within the virtual arrays.
   */
  JBLOCKROW MCU_buffer[C_MAX_BLOCKS_IN_MCU];

  /* In multi-pass modes, we need a virtual block array for each component. */
  jvirt_barray_ptr whole_image[MAX_COMPONENTS];
} my_coef_controller;

typedef my_coef_controller * my_coef_ptr;


/* Forward declarations */
METHODDEF(boolean) compress_data
    JPP((j_compress_ptr cinfo, JSAMPIMAGE input_buf));
#ifdef FULL_COEF_BUFFER_SUPPORTED
METHODDEF(boolean) compress_first_pass
    JPP((j_compress_ptr cinfo, JSAMPIMAGE input_buf));
METHODDEF(boolean) compress_output
    JPP((j_compress_ptr cinfo, JSAMPIMAGE input_buf));
#endif


LOCAL(void)
start_iMCU_row (j_compress_ptr cinfo)
/* Reset within-iMCU-row counters for a new row */
{
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;

  /* In an interleaved scan, an MCU row is the same as an iMCU row.
   * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.
   * But at the bottom of the image, process only what's left.
   */
  if (cinfo->comps_in_scan > 1) {
    coef->MCU_rows_per_iMCU_row = 1;
  } else {
    if (coef->iMCU_row_num < (cinfo->total_iMCU_rows-1))
      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->v_samp_factor;
    else
      coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->last_row_height;
  }

  coef->mcu_ctr = 0;
  coef->MCU_vert_offset = 0;
}


/*
 * Initialize for a processing pass.
 */

METHODDEF(void)
start_pass_coef (j_compress_ptr cinfo, J_BUF_MODE pass_mode)
{
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;

  coef->iMCU_row_num = 0;
  start_iMCU_row(cinfo);

  switch (pass_mode) {
  case JBUF_PASS_THRU:
    if (coef->whole_image[0] != NULL)
      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
    coef->pub.compress_data = compress_data;
    break;
#ifdef FULL_COEF_BUFFER_SUPPORTED
  case JBUF_SAVE_AND_PASS:
    if (coef->whole_image[0] == NULL)
      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
    coef->pub.compress_data = compress_first_pass;
    break;
  case JBUF_CRANK_DEST:
    if (coef->whole_image[0] == NULL)
      ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
    coef->pub.compress_data = compress_output;
    break;
#endif
  default:
    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
    break;
  }
}


/*
 * Process some data in the single-pass case.
 * We process the equivalent of one fully interleaved MCU row ("iMCU" row)
 * per call, ie, v_samp_factor block rows for each component in the image.
 * Returns TRUE if the iMCU row is completed, FALSE if suspended.
 *
 * NB: input_buf contains a plane for each component in image,
 * which we index according to the component's SOF position.
 */

METHODDEF(boolean)
compress_data (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
{
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
  JDIMENSION MCU_col_num;	/* index of current MCU within row */
  JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;
  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
  int blkn, bi, ci, yindex, yoffset, blockcnt;
  JDIMENSION ypos, xpos;
  jpeg_component_info *compptr;

  /* Loop to write as much as one whole iMCU row */
  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
       yoffset++) {
    for (MCU_col_num = coef->mcu_ctr; MCU_col_num <= last_MCU_col;
	 MCU_col_num++) {
      /* Determine where data comes from in input_buf and do the DCT thing.
       * Each call on forward_DCT processes a horizontal row of DCT blocks
       * as wide as an MCU; we rely on having allocated the MCU_buffer[] blocks
       * sequentially.  Dummy blocks at the right or bottom edge are filled in
       * specially.  The data in them does not matter for image reconstruction,
       * so we fill them with values that will encode to the smallest amount of
       * data, viz: all zeroes in the AC entries, DC entries equal to previous
       * block's DC value.  (Thanks to Thomas Kinsman for this idea.)
       */
      blkn = 0;
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
	compptr = cinfo->cur_comp_info[ci];
	blockcnt = (MCU_col_num < last_MCU_col) ? compptr->MCU_width
						: compptr->last_col_width;
	xpos = MCU_col_num * compptr->MCU_sample_width;
	ypos = yoffset * DCTSIZE; /* ypos == (yoffset+yindex) * DCTSIZE */
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
	  if (coef->iMCU_row_num < last_iMCU_row ||
	      yoffset+yindex < compptr->last_row_height) {
	    (*cinfo->fdct->forward_DCT) (cinfo, compptr,
					 input_buf[compptr->component_index],
					 coef->MCU_buffer[blkn],
					 ypos, xpos, (JDIMENSION) blockcnt);
	    if (blockcnt < compptr->MCU_width) {
	      /* Create some dummy blocks at the right edge of the image. */
	      jzero_far((void FAR *) coef->MCU_buffer[blkn + blockcnt],
			(compptr->MCU_width - blockcnt) * SIZEOF(JBLOCK));
	      for (bi = blockcnt; bi < compptr->MCU_width; bi++) {
		coef->MCU_buffer[blkn+bi][0][0] = coef->MCU_buffer[blkn+bi-1][0][0];
	      }
	    }
	  } else {
	    /* Create a row of dummy blocks at the bottom of the image. */
	    jzero_far((void FAR *) coef->MCU_buffer[blkn],
		      compptr->MCU_width * SIZEOF(JBLOCK));
	    for (bi = 0; bi < compptr->MCU_width; bi++) {
	      coef->MCU_buffer[blkn+bi][0][0] = coef->MCU_buffer[blkn-1][0][0];
	    }
	  }
	  blkn += compptr->MCU_width;
	  ypos += DCTSIZE;
	}
      }
      /* Try to write the MCU.  In event of a suspension failure, we will
       * re-DCT the MCU on restart (a bit inefficient, could be fixed...)
       */
      if (! (*cinfo->entropy->encode_mcu) (cinfo, coef->MCU_buffer)) {
	/* Suspension forced; update state counters and exit */
	coef->MCU_vert_offset = yoffset;
	coef->mcu_ctr = MCU_col_num;
	return FALSE;
      }
    }
    /* Completed an MCU row, but perhaps not an iMCU row */
    coef->mcu_ctr = 0;
  }
  /* Completed the iMCU row, advance counters for next one */
  coef->iMCU_row_num++;
  start_iMCU_row(cinfo);
  return TRUE;
}


#ifdef FULL_COEF_BUFFER_SUPPORTED

/*
 * Process some data in the first pass of a multi-pass case.
 * We process the equivalent of one fully interleaved MCU row ("iMCU" row)
 * per call, ie, v_samp_factor block rows for each component in the image.
 * This amount of data is read from the source buffer, DCT'd and quantized,
 * and saved into the virtual arrays.  We also generate suitable dummy blocks
 * as needed at the right and lower edges.  (The dummy blocks are constructed
 * in the virtual arrays, which have been padded appropriately.)  This makes
 * it possible for subsequent passes not to worry about real vs. dummy blocks.
 *
 * We must also emit the data to the entropy encoder.  This is conveniently
 * done by calling compress_output() after we've loaded the current strip
 * of the virtual arrays.
 *
 * NB: input_buf contains a plane for each component in image.  All
 * components are DCT'd and loaded into the virtual arrays in this pass.
 * However, it may be that only a subset of the components are emitted to
 * the entropy encoder during this first pass; be careful about looking
 * at the scan-dependent variables (MCU dimensions, etc).
 */

METHODDEF(boolean)
compress_first_pass (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
{
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
  JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
  JDIMENSION blocks_across, MCUs_across, MCUindex;
  int bi, ci, h_samp_factor, block_row, block_rows, ndummy;
  JCOEF lastDC;
  jpeg_component_info *compptr;
  JBLOCKARRAY buffer;
  JBLOCKROW thisblockrow, lastblockrow;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    /* Align the virtual buffer for this component. */
    buffer = (*cinfo->mem->access_virt_barray)
      ((j_common_ptr) cinfo, coef->whole_image[ci],
       coef->iMCU_row_num * compptr->v_samp_factor,
       (JDIMENSION) compptr->v_samp_factor, TRUE);
    /* Count non-dummy DCT block rows in this iMCU row. */
    if (coef->iMCU_row_num < last_iMCU_row)
      block_rows = compptr->v_samp_factor;
    else {
      /* NB: can't use last_row_height here, since may not be set! */
      block_rows = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
      if (block_rows == 0) block_rows = compptr->v_samp_factor;
    }
    blocks_across = compptr->width_in_blocks;
    h_samp_factor = compptr->h_samp_factor;
    /* Count number of dummy blocks to be added at the right margin. */
    ndummy = (int) (blocks_across % h_samp_factor);
    if (ndummy > 0)
      ndummy = h_samp_factor - ndummy;
    /* Perform DCT for all non-dummy blocks in this iMCU row.  Each call
     * on forward_DCT processes a complete horizontal row of DCT blocks.
     */
    for (block_row = 0; block_row < block_rows; block_row++) {
      thisblockrow = buffer[block_row];
      (*cinfo->fdct->forward_DCT) (cinfo, compptr,
				   input_buf[ci], thisblockrow,
				   (JDIMENSION) (block_row * DCTSIZE),
				   (JDIMENSION) 0, blocks_across);
      if (ndummy > 0) {
	/* Create dummy blocks at the right edge of the image. */
	thisblockrow += blocks_across; /* => first dummy block */
	jzero_far((void FAR *) thisblockrow, ndummy * SIZEOF(JBLOCK));
	lastDC = thisblockrow[-1][0];
	for (bi = 0; bi < ndummy; bi++) {
	  thisblockrow[bi][0] = lastDC;
	}
      }
    }
    /* If at end of image, create dummy block rows as needed.
     * The tricky part here is that within each MCU, we want the DC values
     * of the dummy blocks to match the last real block's DC value.
     * This squeezes a few more bytes out of the resulting file...
     */
    if (coef->iMCU_row_num == last_iMCU_row) {
      blocks_across += ndummy;	/* include lower right corner */
      MCUs_across = blocks_across / h_samp_factor;
      for (block_row = block_rows; block_row < compptr->v_samp_factor;
	   block_row++) {
	thisblockrow = buffer[block_row];
	lastblockrow = buffer[block_row-1];
	jzero_far((void FAR *) thisblockrow,
		  (size_t) (blocks_across * SIZEOF(JBLOCK)));
	for (MCUindex = 0; MCUindex < MCUs_across; MCUindex++) {
	  lastDC = lastblockrow[h_samp_factor-1][0];
	  for (bi = 0; bi < h_samp_factor; bi++) {
	    thisblockrow[bi][0] = lastDC;
	  }
	  thisblockrow += h_samp_factor; /* advance to next MCU in row */
	  lastblockrow += h_samp_factor;
	}
      }
    }
  }
  /* NB: compress_output will increment iMCU_row_num if successful.
   * A suspension return will result in redoing all the work above next time.
   */

  /* Emit data to the entropy encoder, sharing code with subsequent passes */
  return compress_output(cinfo, input_buf);
}


/*
 * Process some data in subsequent passes of a multi-pass case.
 * We process the equivalent of one fully interleaved MCU row ("iMCU" row)
 * per call, ie, v_samp_factor block rows for each component in the scan.
 * The data is obtained from the virtual arrays and fed to the entropy coder.
 * Returns TRUE if the iMCU row is completed, FALSE if suspended.
 *
 * NB: input_buf is ignored; it is likely to be a NULL pointer.
 */

METHODDEF(boolean)
compress_output (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
{
  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
  JDIMENSION MCU_col_num;	/* index of current MCU within row */
  int blkn, ci, xindex, yindex, yoffset;
  JDIMENSION start_col;
  JBLOCKARRAY buffer[MAX_COMPS_IN_SCAN];
  JBLOCKROW buffer_ptr;
  jpeg_component_info *compptr;

  /* Align the virtual buffers for the components used in this scan.
   * NB: during first pass, this is safe only because the buffers will
   * already be aligned properly, so jmemmgr.c won't need to do any I/O.
   */
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
    compptr = cinfo->cur_comp_info[ci];
    buffer[ci] = (*cinfo->mem->access_virt_barray)
      ((j_common_ptr) cinfo, coef->whole_image[compptr->component_index],
       coef->iMCU_row_num * compptr->v_samp_factor,
       (JDIMENSION) compptr->v_samp_factor, FALSE);
  }

  /* Loop to process one whole iMCU row */
  for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
       yoffset++) {
    for (MCU_col_num = coef->mcu_ctr; MCU_col_num < cinfo->MCUs_per_row;
	 MCU_col_num++) {
      /* Construct list of pointers to DCT blocks belonging to this MCU */
      blkn = 0;			/* index of current DCT block within MCU */
      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
	compptr = cinfo->cur_comp_info[ci];
	start_col = MCU_col_num * compptr->MCU_width;
	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
	  buffer_ptr = buffer[ci][yindex+yoffset] + start_col;
	  for (xindex = 0; xindex < compptr->MCU_width; xindex++) {
	    coef->MCU_buffer[blkn++] = buffer_ptr++;
	  }
	}
      }
      /* Try to write the MCU. */
      if (! (*cinfo->entropy->encode_mcu) (cinfo, coef->MCU_buffer)) {
	/* Suspension forced; update state counters and exit */
	coef->MCU_vert_offset = yoffset;
	coef->mcu_ctr = MCU_col_num;
	return FALSE;
      }
    }
    /* Completed an MCU row, but perhaps not an iMCU row */
    coef->mcu_ctr = 0;
  }
  /* Completed the iMCU row, advance counters for next one */
  coef->iMCU_row_num++;
  start_iMCU_row(cinfo);
  return TRUE;
}

#endif /* FULL_COEF_BUFFER_SUPPORTED */


/*
 * Initialize coefficient buffer controller.
 */

GLOBAL(void)
jinit_c_coef_controller (j_compress_ptr cinfo, boolean need_full_buffer)
{
  my_coef_ptr coef;

  coef = (my_coef_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_coef_controller));
  cinfo->coef = (struct jpeg_c_coef_controller *) coef;
  coef->pub.start_pass = start_pass_coef;

  /* Create the coefficient buffer. */
  if (need_full_buffer) {
#ifdef FULL_COEF_BUFFER_SUPPORTED
    /* Allocate a full-image virtual array for each component, */
    /* padded to a multiple of samp_factor DCT blocks in each direction. */
    int ci;
    jpeg_component_info *compptr;

    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
	 ci++, compptr++) {
      coef->whole_image[ci] = (*cinfo->mem->request_virt_barray)
	((j_common_ptr) cinfo, JPOOL_IMAGE, FALSE,
	 (JDIMENSION) jround_up((long) compptr->width_in_blocks,
				(long) compptr->h_samp_factor),
	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
				(long) compptr->v_samp_factor),
	 (JDIMENSION) compptr->v_samp_factor);
    }
#else
    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
#endif
  } else {
    /* We only need a single-MCU buffer. */
    JBLOCKROW buffer;
    int i;

    buffer = (JBLOCKROW)
      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  C_MAX_BLOCKS_IN_MCU * SIZEOF(JBLOCK));
    for (i = 0; i < C_MAX_BLOCKS_IN_MCU; i++) {
      coef->MCU_buffer[i] = buffer + i;
    }
    coef->whole_image[0] = NULL; /* flag for no virtual arrays */
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\jpeg\libjpeg\jcapistd.c ===
/*
 * jcapistd.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains application interface code for the compression half
 * of the JPEG library.  These are the "standard" API routines that are
 * used in the normal full-compression case.  They are not used by a
 * transcoding-only application.  Note that if an application links in
 * jpeg_start_compress, it will end up linking in the entire compressor.
 * We thus must separate this file from jcapimin.c to avoid linking the
 * whole compression library into a transcoder.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"


/*
 * Compression initialization.
 * Before calling this, all parameters and a data destination must be set up.
 *
 * We require a write_all_tables parameter as a failsafe check when writing
 * multiple datastreams from the same compression object.  Since prior runs
 * will have left all the tables marked sent_table=TRUE, a subsequent run
 * would emit an abbreviated stream (no tables) by default.  This may be what
 * is wanted, but for safety's sake it should not be the default behavior:
 * programmers should have to make a deliberate choice to emit abbreviated
 * images.  Therefore the documentation and examples should encourage people
 * to pass write_all_tables=TRUE; then it will take active thought to do the
 * wrong thing.
 */

GLOBAL(void)
jpeg_start_compress (j_compress_ptr cinfo, boolean write_all_tables)
{
  if (cinfo->global_state != CSTATE_START)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);

  if (write_all_tables)
    jpeg_suppress_tables(cinfo, FALSE);	/* mark all tables to be written */

  /* (Re)initialize error mgr and destination modules */
  (*cinfo->err->reset_error_mgr) ((j_common_ptr) cinfo);
  (*cinfo->dest->init_destination) (cinfo);
  /* Perform master selection of active modules */
  jinit_compress_master(cinfo);
  /* Set up for the first pass */
  (*cinfo->master->prepare_for_pass) (cinfo);
  /* Ready for application to drive first pass through jpeg_write_scanlines
   * or jpeg_write_raw_data.
   */
  cinfo->next_scanline = 0;
  cinfo->global_state = (cinfo->raw_data_in ? CSTATE_RAW_OK : CSTATE_SCANNING);
}


/*
 * Write some scanlines of data to the JPEG compressor.
 *
 * The return value will be the number of lines actually written.
 * This should be less than the supplied num_lines only in case that
 * the data destination module has requested suspension of the compressor,
 * or if more than image_height scanlines are passed in.
 *
 * Note: we warn about excess calls to jpeg_write_scanlines() since
 * this likely signals an application programmer error.  However,
 * excess scanlines passed in the last valid call are *silently* ignored,
 * so that the application need not adjust num_lines for end-of-image
 * when using a multiple-scanline buffer.
 */

GLOBAL(JDIMENSION)
jpeg_write_scanlines (j_compress_ptr cinfo, JSAMPARRAY scanlines,
		      JDIMENSION num_lines)
{
  JDIMENSION row_ctr, rows_left;

  if (cinfo->global_state != CSTATE_SCANNING)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  if (cinfo->next_scanline >= cinfo->image_height)
    WARNMS(cinfo, JWRN_TOO_MUCH_DATA);

  /* Call progress monitor hook if present */
  if (cinfo->progress != NULL) {
    cinfo->progress->pass_counter = (long) cinfo->next_scanline;
    cinfo->progress->pass_limit = (long) cinfo->image_height;
    (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
  }

  /* Give master control module another chance if this is first call to
   * jpeg_write_scanlines.  This lets output of the frame/scan headers be
   * delayed so that application can write COM, etc, markers between
   * jpeg_start_compress and jpeg_write_scanlines.
   */
  if (cinfo->master->call_pass_startup)
    (*cinfo->master->pass_startup) (cinfo);

  /* Ignore any extra scanlines at bottom of image. */
  rows_left = cinfo->image_height - cinfo->next_scanline;
  if (num_lines > rows_left)
    num_lines = rows_left;

  row_ctr = 0;
  (*cinfo->main->process_data) (cinfo, scanlines, &row_ctr, num_lines);
  cinfo->next_scanline += row_ctr;
  return row_ctr;
}


/*
 * Alternate entry point to write raw data.
 * Processes exactly one iMCU row per call, unless suspended.
 */

GLOBAL(JDIMENSION)
jpeg_write_raw_data (j_compress_ptr cinfo, JSAMPIMAGE data,
		     JDIMENSION num_lines)
{
  JDIMENSION lines_per_iMCU_row;

  if (cinfo->global_state != CSTATE_RAW_OK)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  if (cinfo->next_scanline >= cinfo->image_height) {
    WARNMS(cinfo, JWRN_TOO_MUCH_DATA);
    return 0;
  }

  /* Call progress monitor hook if present */
  if (cinfo->progress != NULL) {
    cinfo->progress->pass_counter = (long) cinfo->next_scanline;
    cinfo->progress->pass_limit = (long) cinfo->image_height;
    (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
  }

  /* Give master control module another chance if this is first call to
   * jpeg_write_raw_data.  This lets output of the frame/scan headers be
   * delayed so that application can write COM, etc, markers between
   * jpeg_start_compress and jpeg_write_raw_data.
   */
  if (cinfo->master->call_pass_startup)
    (*cinfo->master->pass_startup) (cinfo);

  /* Verify that at least one iMCU row has been passed. */
  lines_per_iMCU_row = cinfo->max_v_samp_factor * DCTSIZE;
  if (num_lines < lines_per_iMCU_row)
    ERREXIT(cinfo, JERR_BUFFER_SIZE);

  /* Directly compress the row. */
  if (! (*cinfo->coef->compress_data) (cinfo, data)) {
    /* If compressor did not consume the whole row, suspend processing. */
    return 0;
  }

  /* OK, we processed one iMCU row. */
  cinfo->next_scanline += lines_per_iMCU_row;
  return lines_per_iMCU_row;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\jpeg\libjpeg\jcapimin.c ===
/*
 * jcapimin.c
 *
 * Copyright (C) 1994-1998, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains application interface code for the compression half
 * of the JPEG library.  These are the "minimum" API routines that may be
 * needed in either the normal full-compression case or the transcoding-only
 * case.
 *
 * Most of the routines intended to be called directly by an application
 * are in this file or in jcapistd.c.  But also see jcparam.c for
 * parameter-setup helper routines, jcomapi.c for routines shared by
 * compression and decompression, and jctrans.c for the transcoding case.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"


/*
 * Initialization of a JPEG compression object.
 * The error manager must already be set up (in case memory manager fails).
 */

GLOBAL(void)
jpeg_CreateCompress (j_compress_ptr cinfo, int version, size_t structsize)
{
  int i;

  /* Guard against version mismatches between library and caller. */
  cinfo->mem = NULL;		/* so jpeg_destroy knows mem mgr not called */
  if (version != JPEG_LIB_VERSION)
    ERREXIT2(cinfo, JERR_BAD_LIB_VERSION, JPEG_LIB_VERSION, version);
  if (structsize != SIZEOF(struct jpeg_compress_struct))
    ERREXIT2(cinfo, JERR_BAD_STRUCT_SIZE, 
	     (int) SIZEOF(struct jpeg_compress_struct), (int) structsize);

  /* For debugging purposes, we zero the whole master structure.
   * But the application has already set the err pointer, and may have set
   * client_data, so we have to save and restore those fields.
   * Note: if application hasn't set client_data, tools like Purify may
   * complain here.
   */
  {
    struct jpeg_error_mgr * err = cinfo->err;
    void * client_data = cinfo->client_data; /* ignore Purify complaint here */
    MEMZERO(cinfo, SIZEOF(struct jpeg_compress_struct));
    cinfo->err = err;
    cinfo->client_data = client_data;
  }
  cinfo->is_decompressor = FALSE;

  /* Initialize a memory manager instance for this object */
  jinit_memory_mgr((j_common_ptr) cinfo);

  /* Zero out pointers to permanent structures. */
  cinfo->progress = NULL;
  cinfo->dest = NULL;

  cinfo->comp_info = NULL;

  for (i = 0; i < NUM_QUANT_TBLS; i++)
    cinfo->quant_tbl_ptrs[i] = NULL;

  for (i = 0; i < NUM_HUFF_TBLS; i++) {
    cinfo->dc_huff_tbl_ptrs[i] = NULL;
    cinfo->ac_huff_tbl_ptrs[i] = NULL;
  }

  cinfo->script_space = NULL;

  cinfo->input_gamma = 1.0;	/* in case application forgets */

  /* OK, I'm ready */
  cinfo->global_state = CSTATE_START;
}


/*
 * Destruction of a JPEG compression object
 */

GLOBAL(void)
jpeg_destroy_compress (j_compress_ptr cinfo)
{
  jpeg_destroy((j_common_ptr) cinfo); /* use common routine */
}


/*
 * Abort processing of a JPEG compression operation,
 * but don't destroy the object itself.
 */

GLOBAL(void)
jpeg_abort_compress (j_compress_ptr cinfo)
{
  jpeg_abort((j_common_ptr) cinfo); /* use common routine */
}


/*
 * Forcibly suppress or un-suppress all quantization and Huffman tables.
 * Marks all currently defined tables as already written (if suppress)
 * or not written (if !suppress).  This will control whether they get emitted
 * by a subsequent jpeg_start_compress call.
 *
 * This routine is exported for use by applications that want to produce
 * abbreviated JPEG datastreams.  It logically belongs in jcparam.c, but
 * since it is called by jpeg_start_compress, we put it here --- otherwise
 * jcparam.o would be linked whether the application used it or not.
 */

GLOBAL(void)
jpeg_suppress_tables (j_compress_ptr cinfo, boolean suppress)
{
  int i;
  JQUANT_TBL * qtbl;
  JHUFF_TBL * htbl;

  for (i = 0; i < NUM_QUANT_TBLS; i++) {
    if ((qtbl = cinfo->quant_tbl_ptrs[i]) != NULL)
      qtbl->sent_table = suppress;
  }

  for (i = 0; i < NUM_HUFF_TBLS; i++) {
    if ((htbl = cinfo->dc_huff_tbl_ptrs[i]) != NULL)
      htbl->sent_table = suppress;
    if ((htbl = cinfo->ac_huff_tbl_ptrs[i]) != NULL)
      htbl->sent_table = suppress;
  }
}


/*
 * Finish JPEG compression.
 *
 * If a multipass operating mode was selected, this may do a great deal of
 * work including most of the actual output.
 */

GLOBAL(void)
jpeg_finish_compress (j_compress_ptr cinfo)
{
  JDIMENSION iMCU_row;

  if (cinfo->global_state == CSTATE_SCANNING ||
      cinfo->global_state == CSTATE_RAW_OK) {
    /* Terminate first pass */
    if (cinfo->next_scanline < cinfo->image_height)
      ERREXIT(cinfo, JERR_TOO_LITTLE_DATA);
    (*cinfo->master->finish_pass) (cinfo);
  } else if (cinfo->global_state != CSTATE_WRCOEFS)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
  /* Perform any remaining passes */
  while (! cinfo->master->is_last_pass) {
    (*cinfo->master->prepare_for_pass) (cinfo);
    for (iMCU_row = 0; iMCU_row < cinfo->total_iMCU_rows; iMCU_row++) {
      if (cinfo->progress != NULL) {
	cinfo->progress->pass_counter = (long) iMCU_row;
	cinfo->progress->pass_limit = (long) cinfo->total_iMCU_rows;
	(*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
      }
      /* We bypass the main controller and invoke coef controller directly;
       * all work is being done from the coefficient buffer.
       */
      if (! (*cinfo->coef->compress_data) (cinfo, (JSAMPIMAGE) NULL))
	ERREXIT(cinfo, JERR_CANT_SUSPEND);
    }
    (*cinfo->master->finish_pass) (cinfo);
  }
  /* Write EOI, do final cleanup */
  (*cinfo->marker->write_file_trailer) (cinfo);
  (*cinfo->dest->term_destination) (cinfo);
  /* We can use jpeg_abort to release memory and reset global_state */
  jpeg_abort((j_common_ptr) cinfo);
}


/*
 * Write a special marker.
 * This is only recommended for writing COM or APPn markers.
 * Must be called after jpeg_start_compress() and before
 * first call to jpeg_write_scanlines() or jpeg_write_raw_data().
 */

GLOBAL(void)
jpeg_write_marker (j_compress_ptr cinfo, int marker,
		   const JOCTET *dataptr, unsigned int datalen)
{
  JMETHOD(void, write_marker_byte, (j_compress_ptr info, int val));

  if (cinfo->next_scanline != 0 ||
      (cinfo->global_state != CSTATE_SCANNING &&
       cinfo->global_state != CSTATE_RAW_OK &&
       cinfo->global_state != CSTATE_WRCOEFS))
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);

  (*cinfo->marker->write_marker_header) (cinfo, marker, datalen);
  write_marker_byte = cinfo->marker->write_marker_byte;	/* copy for speed */
  while (datalen--) {
    (*write_marker_byte) (cinfo, *dataptr);
    dataptr++;
  }
}

/* Same, but piecemeal. */

GLOBAL(void)
jpeg_write_m_header (j_compress_ptr cinfo, int marker, unsigned int datalen)
{
  if (cinfo->next_scanline != 0 ||
      (cinfo->global_state != CSTATE_SCANNING &&
       cinfo->global_state != CSTATE_RAW_OK &&
       cinfo->global_state != CSTATE_WRCOEFS))
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);

  (*cinfo->marker->write_marker_header) (cinfo, marker, datalen);
}

GLOBAL(void)
jpeg_write_m_byte (j_compress_ptr cinfo, int val)
{
  (*cinfo->marker->write_marker_byte) (cinfo, val);
}


/*
 * Alternate compression function: just write an abbreviated table file.
 * Before calling this, all parameters and a data destination must be set up.
 *
 * To produce a pair of files containing abbreviated tables and abbreviated
 * image data, one would proceed as follows:
 *
 *		initialize JPEG object
 *		set JPEG parameters
 *		set destination to table file
 *		jpeg_write_tables(cinfo);
 *		set destination to image file
 *		jpeg_start_compress(cinfo, FALSE);
 *		write data...
 *		jpeg_finish_compress(cinfo);
 *
 * jpeg_write_tables has the side effect of marking all tables written
 * (same as jpeg_suppress_tables(..., TRUE)).  Thus a subsequent start_compress
 * will not re-emit the tables unless it is passed write_all_tables=TRUE.
 */

GLOBAL(void)
jpeg_write_tables (j_compress_ptr cinfo)
{
  if (cinfo->global_state != CSTATE_START)
    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);

  /* (Re)initialize error mgr and destination modules */
  (*cinfo->err->reset_error_mgr) ((j_common_ptr) cinfo);
  (*cinfo->dest->init_destination) (cinfo);
  /* Initialize the marker writer ... bit of a crock to do it here. */
  jinit_marker_writer(cinfo);
  /* Write them tables! */
  (*cinfo->marker->write_tables_only) (cinfo);
  /* And clean up. */
  (*cinfo->dest->term_destination) (cinfo);
  /*
   * In library releases up through v6a, we called jpeg_abort() here to free
   * any working memory allocated by the destination manager and marker
   * writer.  Some applications had a problem with that: they allocated space
   * of their own from the library memory manager, and didn't want it to go
   * away during write_tables.  So now we do nothing.  This will cause a
   * memory leak if an app calls write_tables repeatedly without doing a full
   * compression cycle or otherwise resetting the JPEG object.  However, that
   * seems less bad than unexpectedly freeing memory in the normal case.
   * An app that prefers the old behavior can call jpeg_abort for itself after
   * each call to jpeg_write_tables().
   */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\jpeg\libjpeg\jccolor.c ===
/*
 * jccolor.c
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains input colorspace conversion routines.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"


/* Private subobject */

typedef struct {
  struct jpeg_color_converter pub; /* public fields */

  /* Private state for RGB->YCC conversion */
  INT32 * rgb_ycc_tab;		/* => table for RGB to YCbCr conversion */
} my_color_converter;

typedef my_color_converter * my_cconvert_ptr;


/**************** RGB -> YCbCr conversion: most common case **************/

/*
 * YCbCr is defined per CCIR 601-1, except that Cb and Cr are
 * normalized to the range 0..MAXJSAMPLE rather than -0.5 .. 0.5.
 * The conversion equations to be implemented are therefore
 *	Y  =  0.29900 * R + 0.58700 * G + 0.11400 * B
 *	Cb = -0.16874 * R - 0.33126 * G + 0.50000 * B  + CENTERJSAMPLE
 *	Cr =  0.50000 * R - 0.41869 * G - 0.08131 * B  + CENTERJSAMPLE
 * (These numbers are derived from TIFF 6.0 section 21, dated 3-June-92.)
 * Note: older versions of the IJG code used a zero offset of MAXJSAMPLE/2,
 * rather than CENTERJSAMPLE, for Cb and Cr.  This gave equal positive and
 * negative swings for Cb/Cr, but meant that grayscale values (Cb=Cr=0)
 * were not represented exactly.  Now we sacrifice exact representation of
 * maximum red and maximum blue in order to get exact grayscales.
 *
 * To avoid floating-point arithmetic, we represent the fractional constants
 * as integers scaled up by 2^16 (about 4 digits precision); we have to divide
 * the products by 2^16, with appropriate rounding, to get the correct answer.
 *
 * For even more speed, we avoid doing any multiplications in the inner loop
 * by precalculating the constants times R,G,B for all possible values.
 * For 8-bit JSAMPLEs this is very reasonable (only 256 entries per table);
 * for 12-bit samples it is still acceptable.  It's not very reasonable for
 * 16-bit samples, but if you want lossless storage you shouldn't be changing
 * colorspace anyway.
 * The CENTERJSAMPLE offsets and the rounding fudge-factor of 0.5 are included
 * in the tables to save adding them separately in the inner loop.
 */

#define SCALEBITS	16	/* speediest right-shift on some machines */
#define CBCR_OFFSET	((INT32) CENTERJSAMPLE << SCALEBITS)
#define ONE_HALF	((INT32) 1 << (SCALEBITS-1))
#define FIX(x)		((INT32) ((x) * (1L<<SCALEBITS) + 0.5))

/* We allocate one big table and divide it up into eight parts, instead of
 * doing eight alloc_small requests.  This lets us use a single table base
 * address, which can be held in a register in the inner loops on many
 * machines (more than can hold all eight addresses, anyway).
 */

#define R_Y_OFF		0			/* offset to R => Y section */
#define G_Y_OFF		(1*(MAXJSAMPLE+1))	/* offset to G => Y section */
#define B_Y_OFF		(2*(MAXJSAMPLE+1))	/* etc. */
#define R_CB_OFF	(3*(MAXJSAMPLE+1))
#define G_CB_OFF	(4*(MAXJSAMPLE+1))
#define B_CB_OFF	(5*(MAXJSAMPLE+1))
#define R_CR_OFF	B_CB_OFF		/* B=>Cb, R=>Cr are the same */
#define G_CR_OFF	(6*(MAXJSAMPLE+1))
#define B_CR_OFF	(7*(MAXJSAMPLE+1))
#define TABLE_SIZE	(8*(MAXJSAMPLE+1))


/*
 * Initialize for RGB->YCC colorspace conversion.
 */

METHODDEF(void)
rgb_ycc_start (j_compress_ptr cinfo)
{
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
  INT32 * rgb_ycc_tab;
  INT32 i;

  /* Allocate and fill in the conversion tables. */
  cconvert->rgb_ycc_tab = rgb_ycc_tab = (INT32 *)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				(TABLE_SIZE * SIZEOF(INT32)));

  for (i = 0; i <= MAXJSAMPLE; i++) {
    rgb_ycc_tab[i+R_Y_OFF] = FIX(0.29900) * i;
    rgb_ycc_tab[i+G_Y_OFF] = FIX(0.58700) * i;
    rgb_ycc_tab[i+B_Y_OFF] = FIX(0.11400) * i     + ONE_HALF;
    rgb_ycc_tab[i+R_CB_OFF] = (-FIX(0.16874)) * i;
    rgb_ycc_tab[i+G_CB_OFF] = (-FIX(0.33126)) * i;
    /* We use a rounding fudge-factor of 0.5-epsilon for Cb and Cr.
     * This ensures that the maximum output will round to MAXJSAMPLE
     * not MAXJSAMPLE+1, and thus that we don't have to range-limit.
     */
    rgb_ycc_tab[i+B_CB_OFF] = FIX(0.50000) * i    + CBCR_OFFSET + ONE_HALF-1;
/*  B=>Cb and R=>Cr tables are the same
    rgb_ycc_tab[i+R_CR_OFF] = FIX(0.50000) * i    + CBCR_OFFSET + ONE_HALF-1;
*/
    rgb_ycc_tab[i+G_CR_OFF] = (-FIX(0.41869)) * i;
    rgb_ycc_tab[i+B_CR_OFF] = (-FIX(0.08131)) * i;
  }
}


/*
 * Convert some rows of samples to the JPEG colorspace.
 *
 * Note that we change from the application's interleaved-pixel format
 * to our internal noninterleaved, one-plane-per-component format.
 * The input buffer is therefore three times as wide as the output buffer.
 *
 * A starting row offset is provided only for the output buffer.  The caller
 * can easily adjust the passed input_buf value to accommodate any row
 * offset required on that side.
 */

METHODDEF(void)
rgb_ycc_convert (j_compress_ptr cinfo,
		 JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
		 JDIMENSION output_row, int num_rows)
{
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
  register int r, g, b;
  register INT32 * ctab = cconvert->rgb_ycc_tab;
  register JSAMPROW inptr;
  register JSAMPROW outptr0, outptr1, outptr2;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->image_width;

  while (--num_rows >= 0) {
    inptr = *input_buf++;
    outptr0 = output_buf[0][output_row];
    outptr1 = output_buf[1][output_row];
    outptr2 = output_buf[2][output_row];
    output_row++;
    for (col = 0; col < num_cols; col++) {
      r = GETJSAMPLE(inptr[RGB_RED]);
      g = GETJSAMPLE(inptr[RGB_GREEN]);
      b = GETJSAMPLE(inptr[RGB_BLUE]);
      inptr += RGB_PIXELSIZE;
      /* If the inputs are 0..MAXJSAMPLE, the outputs of these equations
       * must be too; we do not need an explicit range-limiting operation.
       * Hence the value being shifted is never negative, and we don't
       * need the general RIGHT_SHIFT macro.
       */
      /* Y */
      outptr0[col] = (JSAMPLE)
		((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])
		 >> SCALEBITS);
      /* Cb */
      outptr1[col] = (JSAMPLE)
		((ctab[r+R_CB_OFF] + ctab[g+G_CB_OFF] + ctab[b+B_CB_OFF])
		 >> SCALEBITS);
      /* Cr */
      outptr2[col] = (JSAMPLE)
		((ctab[r+R_CR_OFF] + ctab[g+G_CR_OFF] + ctab[b+B_CR_OFF])
		 >> SCALEBITS);
    }
  }
}


/*
 * The same game, but played with the colors in the opposite order.  A
 * complete copy of the above code.  The code also handles either 3 or
 * 4 bytes per pixel using the input component count as the byte count.
 */
METHODDEF(void)
bgr_ycc_convert (j_compress_ptr cinfo,
		 JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
		 JDIMENSION output_row, int num_rows)
{
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
  register int r, g, b, pixel_size = cinfo->input_components;
  register INT32 * ctab = cconvert->rgb_ycc_tab;
  register JSAMPROW inptr;
  register JSAMPROW outptr0, outptr1, outptr2;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->image_width;

  while (--num_rows >= 0) {
    inptr = *input_buf++;
    outptr0 = output_buf[0][output_row];
    outptr1 = output_buf[1][output_row];
    outptr2 = output_buf[2][output_row];
    output_row++;
    for (col = 0; col < num_cols; col++) {
      r = GETJSAMPLE(inptr[2]);
      g = GETJSAMPLE(inptr[1]);
      b = GETJSAMPLE(inptr[0]);
      inptr += pixel_size;
      /* If the inputs are 0..MAXJSAMPLE, the outputs of these equations
       * must be too; we do not need an explicit range-limiting operation.
       * Hence the value being shifted is never negative, and we don't
       * need the general RIGHT_SHIFT macro.
       */
      /* Y */
      outptr0[col] = (JSAMPLE)
		((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])
		 >> SCALEBITS);
      /* Cb */
      outptr1[col] = (JSAMPLE)
		((ctab[r+R_CB_OFF] + ctab[g+G_CB_OFF] + ctab[b+B_CB_OFF])
		 >> SCALEBITS);
      /* Cr */
      outptr2[col] = (JSAMPLE)
		((ctab[r+R_CR_OFF] + ctab[g+G_CR_OFF] + ctab[b+B_CR_OFF])
		 >> SCALEBITS);
    }
  }
}


/**************** Cases other than RGB -> YCbCr **************/


/*
 * Convert some rows of samples to the JPEG colorspace.
 * This version handles RGB->grayscale conversion, which is the same
 * as the RGB->Y portion of RGB->YCbCr.
 * We assume rgb_ycc_start has been called (we only use the Y tables).
 */

METHODDEF(void)
rgb_gray_convert (j_compress_ptr cinfo,
		  JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
		  JDIMENSION output_row, int num_rows)
{
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
  register int r, g, b;
  register INT32 * ctab = cconvert->rgb_ycc_tab;
  register JSAMPROW inptr;
  register JSAMPROW outptr;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->image_width;

  while (--num_rows >= 0) {
    inptr = *input_buf++;
    outptr = output_buf[0][output_row];
    output_row++;
    for (col = 0; col < num_cols; col++) {
      r = GETJSAMPLE(inptr[RGB_RED]);
      g = GETJSAMPLE(inptr[RGB_GREEN]);
      b = GETJSAMPLE(inptr[RGB_BLUE]);
      inptr += RGB_PIXELSIZE;
      /* Y */
      outptr[col] = (JSAMPLE)
		((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])
		 >> SCALEBITS);
    }
  }
}


/*
 * The same thing with the pixels in the opposite order, as above.
 */
METHODDEF(void)
bgr_gray_convert (j_compress_ptr cinfo,
		  JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
		  JDIMENSION output_row, int num_rows)
{
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
  register int r, g, b, pixel_size = cinfo->input_components;
  register INT32 * ctab = cconvert->rgb_ycc_tab;
  register JSAMPROW inptr;
  register JSAMPROW outptr;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->image_width;

  while (--num_rows >= 0) {
    inptr = *input_buf++;
    outptr = output_buf[0][output_row];
    output_row++;
    for (col = 0; col < num_cols; col++) {
      r = GETJSAMPLE(inptr[2]);
      g = GETJSAMPLE(inptr[1]);
      b = GETJSAMPLE(inptr[0]);
      inptr += pixel_size;
      /* Y */
      outptr[col] = (JSAMPLE)
		((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])
		 >> SCALEBITS);
    }
  }
}


/*
 * Convert some rows of samples to the JPEG colorspace.
 * This version handles Adobe-style CMYK->YCCK conversion,
 * where we convert R=1-C, G=1-M, and B=1-Y to YCbCr using the same
 * conversion as above, while passing K (black) unchanged.
 * We assume rgb_ycc_start has been called.
 */

METHODDEF(void)
cmyk_ycck_convert (j_compress_ptr cinfo,
		   JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
		   JDIMENSION output_row, int num_rows)
{
  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
  register int r, g, b;
  register INT32 * ctab = cconvert->rgb_ycc_tab;
  register JSAMPROW inptr;
  register JSAMPROW outptr0, outptr1, outptr2, outptr3;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->image_width;

  while (--num_rows >= 0) {
    inptr = *input_buf++;
    outptr0 = output_buf[0][output_row];
    outptr1 = output_buf[1][output_row];
    outptr2 = output_buf[2][output_row];
    outptr3 = output_buf[3][output_row];
    output_row++;
    for (col = 0; col < num_cols; col++) {
      r = MAXJSAMPLE - GETJSAMPLE(inptr[0]);
      g = MAXJSAMPLE - GETJSAMPLE(inptr[1]);
      b = MAXJSAMPLE - GETJSAMPLE(inptr[2]);
      /* K passes through as-is */
      outptr3[col] = inptr[3];	/* don't need GETJSAMPLE here */
      inptr += 4;
      /* If the inputs are 0..MAXJSAMPLE, the outputs of these equations
       * must be too; we do not need an explicit range-limiting operation.
       * Hence the value being shifted is never negative, and we don't
       * need the general RIGHT_SHIFT macro.
       */
      /* Y */
      outptr0[col] = (JSAMPLE)
		((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])
		 >> SCALEBITS);
      /* Cb */
      outptr1[col] = (JSAMPLE)
		((ctab[r+R_CB_OFF] + ctab[g+G_CB_OFF] + ctab[b+B_CB_OFF])
		 >> SCALEBITS);
      /* Cr */
      outptr2[col] = (JSAMPLE)
		((ctab[r+R_CR_OFF] + ctab[g+G_CR_OFF] + ctab[b+B_CR_OFF])
		 >> SCALEBITS);
    }
  }
}


/*
 * Convert some rows of samples to the JPEG colorspace.
 * This version handles grayscale output with no conversion.
 * The source can be either plain grayscale or YCbCr (since Y == gray).
 */

METHODDEF(void)
grayscale_convert (j_compress_ptr cinfo,
		   JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
		   JDIMENSION output_row, int num_rows)
{
  register JSAMPROW inptr;
  register JSAMPROW outptr;
  register JDIMENSION col;
  JDIMENSION num_cols = cinfo->image_width;
  int instride = cinfo->input_components;

  while (--num_rows >= 0) {
    inptr = *input_buf++;
    outptr = output_buf[0][output_row];
    output_row++;
    for (col = 0; col < num_cols; col++) {
      outptr[col] = inptr[0];	/* don't need GETJSAMPLE() here */
      inptr += instride;
    }
  }
}


/*
 * Convert some rows of samples to the JPEG colorspace.
 * This version handles multi-component colorspaces without conversion.
 * We assume input_components == num_components.
 */

METHODDEF(void)
null_convert (j_compress_ptr cinfo,
	      JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
	      JDIMENSION output_row, int num_rows)
{
  register JSAMPROW inptr;
  register JSAMPROW outptr;
  register JDIMENSION col;
  register int ci;
  int nc = cinfo->num_components;
  JDIMENSION num_cols = cinfo->image_width;

  while (--num_rows >= 0) {
    /* It seems fastest to make a separate pass for each component. */
    for (ci = 0; ci < nc; ci++) {
      inptr = *input_buf;
      outptr = output_buf[ci][output_row];
      for (col = 0; col < num_cols; col++) {
	outptr[col] = inptr[ci]; /* don't need GETJSAMPLE() here */
	inptr += nc;
      }
    }
    input_buf++;
    output_row++;
  }
}


/*
 * Empty method for start_pass.
 */

METHODDEF(void)
null_method (j_compress_ptr cinfo)
{
  /* no work needed */
}


/*
 * Module initialization routine for input colorspace conversion.
 */

GLOBAL(void)
jinit_color_converter (j_compress_ptr cinfo)
{
  my_cconvert_ptr cconvert;

  cconvert = (my_cconvert_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_color_converter));
  cinfo->cconvert = (struct jpeg_color_converter *) cconvert;
  /* set start_pass to null method until we find out differently */
  cconvert->pub.start_pass = null_method;

  /* Make sure input_components agrees with in_color_space */
  switch (cinfo->in_color_space) {
  case JCS_GRAYSCALE:
    if (cinfo->input_components != 1)
      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);
    break;

  case JCS_RGB:
#if RGB_PIXELSIZE != 3
    if (cinfo->input_components != RGB_PIXELSIZE)
      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);
    break;
#endif /* else share code with YCbCr */

  case JCS_YCbCr:
    if (cinfo->input_components != 3)
      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);
    break;

  case JCS_CMYK:
  case JCS_YCCK:
    if (cinfo->input_components != 4)
      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);
    break;

  default:			/* JCS_UNKNOWN can be anything */
    if (cinfo->input_components < 1)
      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);
    break;
  }

  /* Check num_components, set conversion method based on requested space */
  switch (cinfo->jpeg_color_space) {
  case JCS_GRAYSCALE:
    if (cinfo->num_components != 1)
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
    if (cinfo->in_color_space == JCS_GRAYSCALE)
      cconvert->pub.color_convert = grayscale_convert;
    else if (cinfo->in_color_space == JCS_RGB) {
      cconvert->pub.start_pass = rgb_ycc_start;
      cconvert->pub.color_convert = rgb_gray_convert;
    } else if (cinfo->in_color_space == OCS_BGR) {
      cconvert->pub.start_pass = rgb_ycc_start;
      cconvert->pub.color_convert = bgr_gray_convert;
    } else if (cinfo->in_color_space == OCS_BGRA) {
      cconvert->pub.start_pass = rgb_ycc_start;
      cconvert->pub.color_convert = bgr_gray_convert;
    } else if (cinfo->in_color_space == JCS_YCbCr)
      cconvert->pub.color_convert = grayscale_convert;
    else
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;

  case JCS_RGB:
    if (cinfo->num_components != 3)
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
    if (cinfo->in_color_space == JCS_RGB && RGB_PIXELSIZE == 3)
      cconvert->pub.color_convert = null_convert;
    else
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;

  case JCS_YCbCr:
    if (cinfo->num_components != 3)
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
    if (cinfo->in_color_space == JCS_RGB) {
      cconvert->pub.start_pass = rgb_ycc_start;
      cconvert->pub.color_convert = rgb_ycc_convert;
    } else if (cinfo->in_color_space == OCS_BGR) {
      cconvert->pub.start_pass = rgb_ycc_start;
      cconvert->pub.color_convert = bgr_ycc_convert;
    } else if (cinfo->in_color_space == OCS_BGRA) {
      cconvert->pub.start_pass = rgb_ycc_start;
      cconvert->pub.color_convert = bgr_ycc_convert;
    } else if (cinfo->in_color_space == JCS_YCbCr)
      cconvert->pub.color_convert = null_convert;
    else
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;

  case JCS_CMYK:
    if (cinfo->num_components != 4)
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
    if (cinfo->in_color_space == JCS_CMYK)
      cconvert->pub.color_convert = null_convert;
    else
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;

  case JCS_YCCK:
    if (cinfo->num_components != 4)
      ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
    if (cinfo->in_color_space == JCS_CMYK) {
      cconvert->pub.start_pass = rgb_ycc_start;
      cconvert->pub.color_convert = cmyk_ycck_convert;
    } else if (cinfo->in_color_space == JCS_YCCK)
      cconvert->pub.color_convert = null_convert;
    else
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    break;

  default:			/* allow null conversion of JCS_UNKNOWN */
    if (cinfo->jpeg_color_space != cinfo->in_color_space ||
	cinfo->num_components != cinfo->input_components)
      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
    cconvert->pub.color_convert = null_convert;
    break;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\jpeg\libjpeg\jcdctmgr.c ===
/*
 * jcdctmgr.c
 *
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains the forward-DCT management logic.
 * This code selects a particular DCT implementation to be used,
 * and it performs related housekeeping chores including coefficient
 * quantization.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"
#include "jdct.h"		/* Private declarations for DCT subsystem */


/* Private subobject for this module */

typedef struct {
  struct jpeg_forward_dct pub;	/* public fields */

  /* Pointer to the DCT routine actually in use */
  forward_DCT_method_ptr do_dct;

  /* The actual post-DCT divisors --- not identical to the quant table
   * entries, because of scaling (especially for an unnormalized DCT).
   * Each table is given in normal array order.
   */
  DCTELEM * divisors[NUM_QUANT_TBLS];

#ifdef DCT_FLOAT_SUPPORTED
  /* Same as above for the floating-point case. */
  float_DCT_method_ptr do_float_dct;
  FAST_FLOAT * float_divisors[NUM_QUANT_TBLS];
#endif
} my_fdct_controller;

typedef my_fdct_controller * my_fdct_ptr;


/*
 * Initialize for a processing pass.
 * Verify that all referenced Q-tables are present, and set up
 * the divisor table for each one.
 * In the current implementation, DCT of all components is done during
 * the first pass, even if only some components will be output in the
 * first scan.  Hence all components should be examined here.
 */

METHODDEF(void)
start_pass_fdctmgr (j_compress_ptr cinfo)
{
  my_fdct_ptr fdct = (my_fdct_ptr) cinfo->fdct;
  int ci, qtblno, i;
  jpeg_component_info *compptr;
  JQUANT_TBL * qtbl;
  DCTELEM * dtbl;

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    qtblno = compptr->quant_tbl_no;
    /* Make sure specified quantization table is present */
    if (qtblno < 0 || qtblno >= NUM_QUANT_TBLS ||
	cinfo->quant_tbl_ptrs[qtblno] == NULL)
      ERREXIT1(cinfo, JERR_NO_QUANT_TABLE, qtblno);
    qtbl = cinfo->quant_tbl_ptrs[qtblno];
    /* Compute divisors for this quant table */
    /* We may do this more than once for same table, but it's not a big deal */
    switch (cinfo->dct_method) {
#ifdef DCT_ISLOW_SUPPORTED
    case JDCT_ISLOW_X86:
    case JDCT_ISLOW_MMX:
    case JDCT_ISLOW:
      /* For LL&M IDCT method, divisors are equal to raw quantization
       * coefficients multiplied by 8 (to counteract scaling).
       */
      if (fdct->divisors[qtblno] == NULL) {
	fdct->divisors[qtblno] = (DCTELEM *)
	  (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				      DCTSIZE2 * SIZEOF(DCTELEM));
      }
      dtbl = fdct->divisors[qtblno];
      for (i = 0; i < DCTSIZE2; i++) {
	dtbl[i] = (DCTELEM)(qtbl->quantval[i] << 3);
      }
      break;
#endif
#ifdef DCT_IFAST_SUPPORTED
    case JDCT_IFAST_X86:
    case JDCT_IFAST_MMX:
    case JDCT_IFAST:
      {
	/* For AA&N IDCT method, divisors are equal to quantization
	 * coefficients scaled by scalefactor[row]*scalefactor[col], where
	 *   scalefactor[0] = 1
	 *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7
	 * We apply a further scale factor of 8.
	 */
#define CONST_BITS 14
	static const INT16 aanscales[DCTSIZE2] = {
	  /* precomputed values scaled up by 14 bits */
	  16384, 22725, 21407, 19266, 16384, 12873,  8867,  4520,
	  22725, 31521, 29692, 26722, 22725, 17855, 12299,  6270,
	  21407, 29692, 27969, 25172, 21407, 16819, 11585,  5906,
	  19266, 26722, 25172, 22654, 19266, 15137, 10426,  5315,
	  16384, 22725, 21407, 19266, 16384, 12873,  8867,  4520,
	  12873, 17855, 16819, 15137, 12873, 10114,  6967,  3552,
	   8867, 12299, 11585, 10426,  8867,  6967,  4799,  2446,
	   4520,  6270,  5906,  5315,  4520,  3552,  2446,  1247
	};
	SHIFT_TEMPS

	if (fdct->divisors[qtblno] == NULL) {
	  fdct->divisors[qtblno] = (DCTELEM *)
	    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
					DCTSIZE2 * SIZEOF(DCTELEM));
	}
	dtbl = fdct->divisors[qtblno];
	for (i = 0; i < DCTSIZE2; i++) {
	  dtbl[i] = (DCTELEM)
	    DESCALE(MULTIPLY16V16((INT32) qtbl->quantval[i],
				  (INT32) aanscales[i]),
		    CONST_BITS-3);
	}
      }
      break;
#endif
#ifdef DCT_FLOAT_SUPPORTED
    case JDCT_FLOAT:
      {
	/* For float AA&N IDCT method, divisors are equal to quantization
	 * coefficients scaled by scalefactor[row]*scalefactor[col], where
	 *   scalefactor[0] = 1
	 *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7
	 * We apply a further scale factor of 8.
	 * What's actually stored is 1/divisor so that the inner loop can
	 * use a multiplication rather than a division.
	 */
	FAST_FLOAT * fdtbl;
	int row, col;
	static const double aanscalefactor[DCTSIZE] = {
	  1.0, 1.387039845, 1.306562965, 1.175875602,
	  1.0, 0.785694958, 0.541196100, 0.275899379
	};

	if (fdct->float_divisors[qtblno] == NULL) {
	  fdct->float_divisors[qtblno] = (FAST_FLOAT *)
	    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
					DCTSIZE2 * SIZEOF(FAST_FLOAT));
	}
	fdtbl = fdct->float_divisors[qtblno];
	i = 0;
	for (row = 0; row < DCTSIZE; row++) {
	  for (col = 0; col < DCTSIZE; col++) {
	    fdtbl[i] = (FAST_FLOAT)
	      (1.0 / (((double) qtbl->quantval[i] *
		       aanscalefactor[row] * aanscalefactor[col] * 8.0)));
	    i++;
	  }
	}
      }
      break;
#endif
    default:
      ERREXIT(cinfo, JERR_NOT_COMPILED);
      break;
    }
  }
}


/*
 * Perform forward DCT on one or more blocks of a component.
 *
 * The input samples are taken from the sample_data[] array starting at
 * position start_row/start_col, and moving to the right for any additional
 * blocks. The quantized coefficients are returned in coef_blocks[].
 */

METHODDEF(void)
forward_DCT (j_compress_ptr cinfo, jpeg_component_info * compptr,
	     JSAMPARRAY sample_data, JBLOCKROW coef_blocks,
	     JDIMENSION start_row, JDIMENSION start_col,
	     JDIMENSION num_blocks)
/* This version is used for integer DCT implementations. */
{
  /* This routine is heavily used, so it's worth coding it tightly. */
  my_fdct_ptr fdct = (my_fdct_ptr) cinfo->fdct;
  forward_DCT_method_ptr do_dct = fdct->do_dct;
  DCTELEM * divisors = fdct->divisors[compptr->quant_tbl_no];
  DCTELEM workspace[DCTSIZE2];	/* work area for FDCT subroutine */
  JDIMENSION bi;

  sample_data += start_row;	/* fold in the vertical offset once */

  for (bi = 0; bi < num_blocks; bi++, start_col += DCTSIZE) {
    /* Load data into workspace, applying unsigned->signed conversion */
    { register DCTELEM *workspaceptr;
      register JSAMPROW elemptr;
      register int elemr;

      workspaceptr = workspace;
      for (elemr = 0; elemr < DCTSIZE; elemr++) {
	elemptr = sample_data[elemr] + start_col;
#if DCTSIZE == 8		/* unroll the inner loop */
	*workspaceptr++ = (DCTELEM)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
	*workspaceptr++ = (DCTELEM)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
	*workspaceptr++ = (DCTELEM)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
	*workspaceptr++ = (DCTELEM)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
	*workspaceptr++ = (DCTELEM)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
	*workspaceptr++ = (DCTELEM)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
	*workspaceptr++ = (DCTELEM)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
	*workspaceptr++ = (DCTELEM)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
#else
	{ register int elemc;
	  for (elemc = DCTSIZE; elemc > 0; elemc--) {
	    *workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE;
	  }
	}
#endif
      }
    }

    /* Perform the DCT */
    (*do_dct) (workspace);

    /* Quantize/descale the coefficients, and store into coef_blocks[] */
    { register DCTELEM temp, qval;
      register int i;
      register JCOEFPTR output_ptr = coef_blocks[bi];

      for (i = 0; i < DCTSIZE2; i++) {
	qval = divisors[i];
	temp = workspace[i];
	/* Divide the coefficient value by qval, ensuring proper rounding.
	 * Since C does not specify the direction of rounding for negative
	 * quotients, we have to force the dividend positive for portability.
	 *
	 * In most files, at least half of the output values will be zero
	 * (at default quantization settings, more like three-quarters...)
	 * so we should ensure that this case is fast.  On many machines,
	 * a comparison is enough cheaper than a divide to make a special test
	 * a win.  Since both inputs will be nonnegative, we need only test
	 * for a < b to discover whether a/b is 0.
	 * If your machine's division is fast enough, define FAST_DIVIDE.
	 */
#ifdef FAST_DIVIDE
#define DIVIDE_BY(a,b)	a = (DCTELEM)(a/b)
#else
#define DIVIDE_BY(a,b)	if (a >= b) a = (DCTELEM)(a/b); else a = 0
#endif
	if (temp < 0) {
	  temp = (DCTELEM)-temp;
	  temp = (DCTELEM)(temp + (qval>>1));	/* for rounding */
	  DIVIDE_BY(temp, qval);
	  temp = (DCTELEM)-temp;
	} else {
	  temp = (DCTELEM)(temp + (qval>>1));	/* for rounding */
	  DIVIDE_BY(temp, qval);
	}
	output_ptr[i] = (JCOEF) temp;
      }
    }
  }
}


#ifdef DCT_FLOAT_SUPPORTED

METHODDEF(void)
forward_DCT_float (j_compress_ptr cinfo, jpeg_component_info * compptr,
		   JSAMPARRAY sample_data, JBLOCKROW coef_blocks,
		   JDIMENSION start_row, JDIMENSION start_col,
		   JDIMENSION num_blocks)
/* This version is used for floating-point DCT implementations. */
{
  /* This routine is heavily used, so it's worth coding it tightly. */
  my_fdct_ptr fdct = (my_fdct_ptr) cinfo->fdct;
  float_DCT_method_ptr do_dct = fdct->do_float_dct;
  FAST_FLOAT * divisors = fdct->float_divisors[compptr->quant_tbl_no];
  FAST_FLOAT workspace[DCTSIZE2]; /* work area for FDCT subroutine */
  JDIMENSION bi;

  sample_data += start_row;	/* fold in the vertical offset once */

  for (bi = 0; bi < num_blocks; bi++, start_col += DCTSIZE) {
    /* Load data into workspace, applying unsigned->signed conversion */
    { register FAST_FLOAT *workspaceptr;
      register JSAMPROW elemptr;
      register int elemr;

      workspaceptr = workspace;
      for (elemr = 0; elemr < DCTSIZE; elemr++) {
	elemptr = sample_data[elemr] + start_col;
#if DCTSIZE == 8		/* unroll the inner loop */
	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
#else
	{ register int elemc;
	  for (elemc = DCTSIZE; elemc > 0; elemc--) {
	    *workspaceptr++ = (FAST_FLOAT)
	      (GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
	  }
	}
#endif
      }
    }

    /* Perform the DCT */
    (*do_dct) (workspace);

    /* Quantize/descale the coefficients, and store into coef_blocks[] */
    { register FAST_FLOAT temp;
      register int i;
      register JCOEFPTR output_ptr = coef_blocks[bi];

      for (i = 0; i < DCTSIZE2; i++) {
	/* Apply the quantization and scaling factor */
	temp = workspace[i] * divisors[i];
	/* Round to nearest integer.
	 * Since C does not specify the direction of rounding for negative
	 * quotients, we have to force the dividend positive for portability.
	 * The maximum coefficient size is +-16K (for 12-bit data), so this
	 * code should work for either 16-bit or 32-bit ints.
	 */
	output_ptr[i] = (JCOEF) ((int) (temp + (FAST_FLOAT) 16384.5) - 16384);
      }
    }
  }
}

#endif /* DCT_FLOAT_SUPPORTED */


/*
 * Initialize FDCT manager.
 */

GLOBAL(void)
jinit_forward_dct (j_compress_ptr cinfo)
{
  my_fdct_ptr fdct;
  int i;

  fdct = (my_fdct_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(my_fdct_controller));
  cinfo->fdct = (struct jpeg_forward_dct *) fdct;
  fdct->pub.start_pass = start_pass_fdctmgr;

  switch (cinfo->dct_method) {
#ifdef DCT_ISLOW_SUPPORTED
  case JDCT_ISLOW_MMX:
#ifdef JPEG_MMX_SUPPORTED_NOT_IN_BUILD
    fdct->pub.forward_DCT = forward_DCT;
    fdct->do_dct = jpeg_fdct_islow_mmx;
    break;
#endif
  case JDCT_ISLOW_X86:
#ifdef JPEG_X86_SUPPORTED_NOT_IN_BUILD
    fdct->pub.forward_DCT = forward_DCT;
    fdct->do_dct = jpeg_fdct_islow_x86;
    break;
#endif
  case JDCT_ISLOW:
    fdct->pub.forward_DCT = forward_DCT;
    fdct->do_dct = jpeg_fdct_islow;
    break;
#endif
#ifdef DCT_IFAST_SUPPORTED
  case JDCT_IFAST_MMX:
#ifdef JPEG_MMX_SUPPORTED_NOT_IN_BUILD
    fdct->pub.forward_DCT = forward_DCT;
    fdct->do_dct = jpeg_fdct_ifast_mmx;
    break;
#endif
  case JDCT_IFAST_X86:
#ifdef JPEG_X86_SUPPORTED_NOT_IN_BUILD
    fdct->pub.forward_DCT = forward_DCT;
    fdct->do_dct = jpeg_fdct_ifast_x86;
    break;
#endif
  case JDCT_IFAST:
    fdct->pub.forward_DCT = forward_DCT;
    fdct->do_dct = jpeg_fdct_ifast;
    break;
#endif
#ifdef DCT_FLOAT_SUPPORTED
  case JDCT_FLOAT:
    fdct->pub.forward_DCT = forward_DCT_float;
    fdct->do_float_dct = jpeg_fdct_float;
    break;
#endif
  default:
    ERREXIT(cinfo, JERR_NOT_COMPILED);
    break;
  }

  /* Mark divisor tables unallocated */
  for (i = 0; i < NUM_QUANT_TBLS; i++) {
    fdct->divisors[i] = NULL;
#ifdef DCT_FLOAT_SUPPORTED
    fdct->float_divisors[i] = NULL;
#endif
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\jpeg\libjpeg\jchuff.h ===
/*
 * jchuff.h
 *
 * Copyright (C) 1991-1997, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains declarations for Huffman entropy encoding routines
 * that are shared between the sequential encoder (jchuff.c) and the
 * progressive encoder (jcphuff.c).  No other modules need to see these.
 */

/* The legal range of a DCT coefficient is
 *  -1024 .. +1023  for 8-bit data;
 * -16384 .. +16383 for 12-bit data.
 * Hence the magnitude should always fit in 10 or 14 bits respectively.
 */

#if BITS_IN_JSAMPLE == 8
#define MAX_COEF_BITS 10
#else
#define MAX_COEF_BITS 14
#endif

/* Derived data constructed for each Huffman table */

typedef struct {
  unsigned int ehufco[256];	/* code for each symbol */
  char ehufsi[256];		/* length of code for each symbol */
  /* If no code has been allocated for a symbol S, ehufsi[S] contains 0 */
} c_derived_tbl;

/* Short forms of external names for systems with brain-damaged linkers. */

#ifdef NEED_SHORT_EXTERNAL_NAMES
#define jpeg_make_c_derived_tbl	jMkCDerived
#define jpeg_gen_optimal_table	jGenOptTbl
#endif /* NEED_SHORT_EXTERNAL_NAMES */

/* Expand a Huffman table definition into the derived format */
EXTERN(void) jpeg_make_c_derived_tbl
	JPP((j_compress_ptr cinfo, boolean isDC, int tblno,
	     c_derived_tbl ** pdtbl));

/* Generate an optimal table definition given the specified counts */
EXTERN(void) jpeg_gen_optimal_table
	JPP((j_compress_ptr cinfo, JHUFF_TBL * htbl, long freq[]));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\jpeg\libjpeg\jchuff.c ===
/*
 * jchuff.c
 *
 * Copyright (C) 1991-1997, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains Huffman entropy encoding routines.
 *
 * Much of the complexity here has to do with supporting output suspension.
 * If the data destination module demands suspension, we want to be able to
 * back up to the start of the current MCU.  To do this, we copy state
 * variables into local working storage, and update them back to the
 * permanent JPEG objects only upon successful completion of an MCU.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"
#include "jchuff.h"		/* Declarations shared with jcphuff.c */


/* Expanded entropy encoder object for Huffman encoding.
 *
 * The savable_state subrecord contains fields that change within an MCU,
 * but must not be updated permanently until we complete the MCU.
 */

typedef struct {
  INT32 put_buffer;		/* current bit-accumulation buffer */
  int put_bits;			/* # of bits now in it */
  int last_dc_val[MAX_COMPS_IN_SCAN]; /* last DC coef for each component */
} savable_state;

/* This macro is to work around compilers with missing or broken
 * structure assignment.  You'll need to fix this code if you have
 * such a compiler and you change MAX_COMPS_IN_SCAN.
 */

#ifndef NO_STRUCT_ASSIGN
#define ASSIGN_STATE(dest,src)  ((dest) = (src))
#else
#if MAX_COMPS_IN_SCAN == 4
#define ASSIGN_STATE(dest,src)  \
	((dest).put_buffer = (src).put_buffer, \
	 (dest).put_bits = (src).put_bits, \
	 (dest).last_dc_val[0] = (src).last_dc_val[0], \
	 (dest).last_dc_val[1] = (src).last_dc_val[1], \
	 (dest).last_dc_val[2] = (src).last_dc_val[2], \
	 (dest).last_dc_val[3] = (src).last_dc_val[3])
#endif
#endif


typedef struct {
  struct jpeg_entropy_encoder pub; /* public fields */

  savable_state saved;		/* Bit buffer & DC state at start of MCU */

  /* These fields are NOT loaded into local working state. */
  unsigned int restarts_to_go;	/* MCUs left in this restart interval */
  int next_restart_num;		/* next restart number to write (0-7) */

  /* Pointers to derived tables (these workspaces have image lifespan) */
  c_derived_tbl * dc_derived_tbls[NUM_HUFF_TBLS];
  c_derived_tbl * ac_derived_tbls[NUM_HUFF_TBLS];

#ifdef ENTROPY_OPT_SUPPORTED	/* Statistics tables for optimization */
  long * dc_count_ptrs[NUM_HUFF_TBLS];
  long * ac_count_ptrs[NUM_HUFF_TBLS];
#endif
} huff_entropy_encoder;

typedef huff_entropy_encoder * huff_entropy_ptr;

/* Working state while writing an MCU.
 * This struct contains all the fields that are needed by subroutines.
 */

typedef struct {
  JOCTET * next_output_byte;	/* => next byte to write in buffer */
  size_t free_in_buffer;	/* # of byte spaces remaining in buffer */
  savable_state cur;		/* Current bit buffer & DC state */
  j_compress_ptr cinfo;		/* dump_buffer needs access to this */
} working_state;


/* Forward declarations */
METHODDEF(boolean) encode_mcu_huff JPP((j_compress_ptr cinfo,
					JBLOCKROW *MCU_data));
METHODDEF(void) finish_pass_huff JPP((j_compress_ptr cinfo));
#ifdef ENTROPY_OPT_SUPPORTED
METHODDEF(boolean) encode_mcu_gather JPP((j_compress_ptr cinfo,
					  JBLOCKROW *MCU_data));
METHODDEF(void) finish_pass_gather JPP((j_compress_ptr cinfo));
#endif


/*
 * Initialize for a Huffman-compressed scan.
 * If gather_statistics is TRUE, we do not output anything during the scan,
 * just count the Huffman symbols used and generate Huffman code tables.
 */

METHODDEF(void)
start_pass_huff (j_compress_ptr cinfo, boolean gather_statistics)
{
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
  int ci, dctbl, actbl;
  jpeg_component_info * compptr;

  if (gather_statistics) {
#ifdef ENTROPY_OPT_SUPPORTED
    entropy->pub.encode_mcu = encode_mcu_gather;
    entropy->pub.finish_pass = finish_pass_gather;
#else
    ERREXIT(cinfo, JERR_NOT_COMPILED);
#endif
  } else {
    entropy->pub.encode_mcu = encode_mcu_huff;
    entropy->pub.finish_pass = finish_pass_huff;
  }

  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
    compptr = cinfo->cur_comp_info[ci];
    dctbl = compptr->dc_tbl_no;
    actbl = compptr->ac_tbl_no;
    if (gather_statistics) {
#ifdef ENTROPY_OPT_SUPPORTED
      /* Check for invalid table indexes */
      /* (make_c_derived_tbl does this in the other path) */
      if (dctbl < 0 || dctbl >= NUM_HUFF_TBLS)
	ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, dctbl);
      if (actbl < 0 || actbl >= NUM_HUFF_TBLS)
	ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, actbl);
      /* Allocate and zero the statistics tables */
      /* Note that jpeg_gen_optimal_table expects 257 entries in each table! */
      if (entropy->dc_count_ptrs[dctbl] == NULL)
	entropy->dc_count_ptrs[dctbl] = (long *)
	  (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				      257 * SIZEOF(long));
      MEMZERO(entropy->dc_count_ptrs[dctbl], 257 * SIZEOF(long));
      if (entropy->ac_count_ptrs[actbl] == NULL)
	entropy->ac_count_ptrs[actbl] = (long *)
	  (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				      257 * SIZEOF(long));
      MEMZERO(entropy->ac_count_ptrs[actbl], 257 * SIZEOF(long));
#endif
    } else {
      /* Compute derived values for Huffman tables */
      /* We may do this more than once for a table, but it's not expensive */
      jpeg_make_c_derived_tbl(cinfo, TRUE, dctbl,
			      & entropy->dc_derived_tbls[dctbl]);
      jpeg_make_c_derived_tbl(cinfo, FALSE, actbl,
			      & entropy->ac_derived_tbls[actbl]);
    }
    /* Initialize DC predictions to 0 */
    entropy->saved.last_dc_val[ci] = 0;
  }

  /* Initialize bit buffer to empty */
  entropy->saved.put_buffer = 0;
  entropy->saved.put_bits = 0;

  /* Initialize restart stuff */
  entropy->restarts_to_go = cinfo->restart_interval;
  entropy->next_restart_num = 0;
}


/*
 * Compute the derived values for a Huffman table.
 * This routine also performs some validation checks on the table.
 *
 * Note this is also used by jcphuff.c.
 */

GLOBAL(void)
jpeg_make_c_derived_tbl (j_compress_ptr cinfo, boolean isDC, int tblno,
			 c_derived_tbl ** pdtbl)
{
  JHUFF_TBL *htbl;
  c_derived_tbl *dtbl;
  int p, i, l, lastp, si, maxsymbol;
  char huffsize[257];
  unsigned int huffcode[257];
  unsigned int code;

  /* Note that huffsize[] and huffcode[] are filled in code-length order,
   * paralleling the order of the symbols themselves in htbl->huffval[].
   */

  /* Find the input Huffman table */
  if (tblno < 0 || tblno >= NUM_HUFF_TBLS)
    ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
  htbl =
    isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
  if (htbl == NULL)
    ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);

  /* Allocate a workspace if we haven't already done so. */
  if (*pdtbl == NULL)
    *pdtbl = (c_derived_tbl *)
      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				  SIZEOF(c_derived_tbl));
  dtbl = *pdtbl;
  
  /* Figure C.1: make table of Huffman code length for each symbol */

  p = 0;
  for (l = 1; l <= 16; l++) {
    i = (int) htbl->bits[l];
    if (i < 0 || p + i > 256)	/* protect against table overrun */
      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
    while (i--)
      huffsize[p++] = (char) l;
  }
  huffsize[p] = 0;
  lastp = p;
  
  /* Figure C.2: generate the codes themselves */
  /* We also validate that the counts represent a legal Huffman code tree. */

  code = 0;
  si = huffsize[0];
  p = 0;
  while (huffsize[p]) {
    while (((int) huffsize[p]) == si) {
      huffcode[p++] = code;
      code++;
    }
    /* code is now 1 more than the last code used for codelength si; but
     * it must still fit in si bits, since no code is allowed to be all ones.
     */
    if (((INT32) code) >= (((INT32) 1) << si))
      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
    code <<= 1;
    si++;
  }
  
  /* Figure C.3: generate encoding tables */
  /* These are code and size indexed by symbol value */

  /* Set all codeless symbols to have code length 0;
   * this lets us detect duplicate VAL entries here, and later
   * allows emit_bits to detect any attempt to emit such symbols.
   */
  MEMZERO(dtbl->ehufsi, SIZEOF(dtbl->ehufsi));

  /* This is also a convenient place to check for out-of-range
   * and duplicated VAL entries.  We allow 0..255 for AC symbols
   * but only 0..15 for DC.  (We could constrain them further
   * based on data depth and mode, but this seems enough.)
   */
  maxsymbol = isDC ? 15 : 255;

  for (p = 0; p < lastp; p++) {
    i = htbl->huffval[p];
    if (i < 0 || i > maxsymbol || dtbl->ehufsi[i])
      ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
    dtbl->ehufco[i] = huffcode[p];
    dtbl->ehufsi[i] = huffsize[p];
  }
}


/* Outputting bytes to the file */

/* Emit a byte, taking 'action' if must suspend. */
#define emit_byte(state,val,action)  \
	{ *(state)->next_output_byte++ = (JOCTET) (val);  \
	  if (--(state)->free_in_buffer == 0)  \
	    if (! dump_buffer(state))  \
	      { action; } }


LOCAL(boolean)
dump_buffer (working_state * state)
/* Empty the output buffer; return TRUE if successful, FALSE if must suspend */
{
  struct jpeg_destination_mgr * dest = state->cinfo->dest;

  if (! (*dest->empty_output_buffer) (state->cinfo))
    return FALSE;
  /* After a successful buffer dump, must reset buffer pointers */
  state->next_output_byte = dest->next_output_byte;
  state->free_in_buffer = dest->free_in_buffer;
  return TRUE;
}


/* Outputting bits to the file */

/* Only the right 24 bits of put_buffer are used; the valid bits are
 * left-justified in this part.  At most 16 bits can be passed to emit_bits
 * in one call, and we never retain more than 7 bits in put_buffer
 * between calls, so 24 bits are sufficient.
 */

INLINE
LOCAL(boolean)
emit_bits (working_state * state, unsigned int code, int size)
/* Emit some bits; return TRUE if successful, FALSE if must suspend */
{
  /* This routine is heavily used, so it's worth coding tightly. */
  register INT32 put_buffer = (INT32) code;
  register int put_bits = state->cur.put_bits;

  /* if size is 0, caller used an invalid Huffman table entry */
  if (size == 0)
    ERREXIT(state->cinfo, JERR_HUFF_MISSING_CODE);

  put_buffer &= (((INT32) 1)<<size) - 1; /* mask off any extra bits in code */
  
  put_bits += size;		/* new number of bits in buffer */
  
  put_buffer <<= 24 - put_bits; /* align incoming bits */

  put_buffer |= state->cur.put_buffer; /* and merge with old buffer contents */
  
  while (put_bits >= 8) {
    int c = (int) ((put_buffer >> 16) & 0xFF);
    
    emit_byte(state, c, return FALSE);
    if (c == 0xFF) {		/* need to stuff a zero byte? */
      emit_byte(state, 0, return FALSE);
    }
    put_buffer <<= 8;
    put_bits -= 8;
  }

  state->cur.put_buffer = put_buffer; /* update state variables */
  state->cur.put_bits = put_bits;

  return TRUE;
}


LOCAL(boolean)
flush_bits (working_state * state)
{
  if (! emit_bits(state, 0x7F, 7)) /* fill any partial byte with ones */
    return FALSE;
  state->cur.put_buffer = 0;	/* and reset bit-buffer to empty */
  state->cur.put_bits = 0;
  return TRUE;
}


/* Encode a single block's worth of coefficients */

LOCAL(boolean)
encode_one_block (working_state * state, JCOEFPTR block, int last_dc_val,
		  c_derived_tbl *dctbl, c_derived_tbl *actbl)
{
  register int temp, temp2;
  register int nbits;
  register int k, r, i;
  
  /* Encode the DC coefficient difference per section F.1.2.1 */
  
  temp = temp2 = block[0] - last_dc_val;

  if (temp < 0) {
    temp = -temp;		/* temp is abs value of input */
    /* For a negative input, want temp2 = bitwise complement of abs(input) */
    /* This code assumes we are on a two's complement machine */
    temp2--;
  }
  
  /* Find the number of bits needed for the magnitude of the coefficient */
  nbits = 0;
  while (temp) {
    nbits++;
    temp >>= 1;
  }
  /* Check for out-of-range coefficient values.
   * Since we're encoding a difference, the range limit is twice as much.
   */
  if (nbits > MAX_COEF_BITS+1)
    ERREXIT(state->cinfo, JERR_BAD_DCT_COEF);
  
  /* Emit the Huffman-coded symbol for the number of bits */
  if (! emit_bits(state, dctbl->ehufco[nbits], dctbl->ehufsi[nbits]))
    return FALSE;

  /* Emit that number of bits of the value, if positive, */
  /* or the complement of its magnitude, if negative. */
  if (nbits)			/* emit_bits rejects calls with size 0 */
    if (! emit_bits(state, (unsigned int) temp2, nbits))
      return FALSE;

  /* Encode the AC coefficients per section F.1.2.2 */
  
  r = 0;			/* r = run length of zeros */
  
  for (k = 1; k < DCTSIZE2; k++) {
    if ((temp = block[jpeg_natural_order[k]]) == 0) {
      r++;
    } else {
      /* if run length > 15, must emit special run-length-16 codes (0xF0) */
      while (r > 15) {
	if (! emit_bits(state, actbl->ehufco[0xF0], actbl->ehufsi[0xF0]))
	  return FALSE;
	r -= 16;
      }

      temp2 = temp;
      if (temp < 0) {
	temp = -temp;		/* temp is abs value of input */
	/* This code assumes we are on a two's complement machine */
	temp2--;
      }
      
      /* Find the number of bits needed for the magnitude of the coefficient */
      nbits = 1;		/* there must be at least one 1 bit */
      while ((temp >>= 1))
	nbits++;
      /* Check for out-of-range coefficient values */
      if (nbits > MAX_COEF_BITS)
	ERREXIT(state->cinfo, JERR_BAD_DCT_COEF);
      
      /* Emit Huffman symbol for run length / number of bits */
      i = (r << 4) + nbits;
      if (! emit_bits(state, actbl->ehufco[i], actbl->ehufsi[i]))
	return FALSE;

      /* Emit that number of bits of the value, if positive, */
      /* or the complement of its magnitude, if negative. */
      if (! emit_bits(state, (unsigned int) temp2, nbits))
	return FALSE;
      
      r = 0;
    }
  }

  /* If the last coef(s) were zero, emit an end-of-block code */
  if (r > 0)
    if (! emit_bits(state, actbl->ehufco[0], actbl->ehufsi[0]))
      return FALSE;

  return TRUE;
}


/*
 * Emit a restart marker & resynchronize predictions.
 */

LOCAL(boolean)
emit_restart (working_state * state, int restart_num)
{
  int ci;

  if (! flush_bits(state))
    return FALSE;

  emit_byte(state, 0xFF, return FALSE);
  emit_byte(state, JPEG_RST0 + restart_num, return FALSE);

  /* Re-initialize DC predictions to 0 */
  for (ci = 0; ci < state->cinfo->comps_in_scan; ci++)
    state->cur.last_dc_val[ci] = 0;

  /* The restart counter is not updated until we successfully write the MCU. */

  return TRUE;
}


/*
 * Encode and output one MCU's worth of Huffman-compressed coefficients.
 */

METHODDEF(boolean)
encode_mcu_huff (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
{
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
  working_state state;
  int blkn, ci;
  jpeg_component_info * compptr;

  /* Load up working state */
  state.next_output_byte = cinfo->dest->next_output_byte;
  state.free_in_buffer = cinfo->dest->free_in_buffer;
  ASSIGN_STATE(state.cur, entropy->saved);
  state.cinfo = cinfo;

  /* Emit restart marker if needed */
  if (cinfo->restart_interval) {
    if (entropy->restarts_to_go == 0)
      if (! emit_restart(&state, entropy->next_restart_num))
	return FALSE;
  }

  /* Encode the MCU data blocks */
  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
    ci = cinfo->MCU_membership[blkn];
    compptr = cinfo->cur_comp_info[ci];
    if (! encode_one_block(&state,
			   MCU_data[blkn][0], state.cur.last_dc_val[ci],
			   entropy->dc_derived_tbls[compptr->dc_tbl_no],
			   entropy->ac_derived_tbls[compptr->ac_tbl_no]))
      return FALSE;
    /* Update last_dc_val */
    state.cur.last_dc_val[ci] = MCU_data[blkn][0][0];
  }

  /* Completed MCU, so update state */
  cinfo->dest->next_output_byte = state.next_output_byte;
  cinfo->dest->free_in_buffer = state.free_in_buffer;
  ASSIGN_STATE(entropy->saved, state.cur);

  /* Update restart-interval state too */
  if (cinfo->restart_interval) {
    if (entropy->restarts_to_go == 0) {
      entropy->restarts_to_go = cinfo->restart_interval;
      entropy->next_restart_num++;
      entropy->next_restart_num &= 7;
    }
    entropy->restarts_to_go--;
  }

  return TRUE;
}


/*
 * Finish up at the end of a Huffman-compressed scan.
 */

METHODDEF(void)
finish_pass_huff (j_compress_ptr cinfo)
{
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
  working_state state;

  /* Load up working state ... flush_bits needs it */
  state.next_output_byte = cinfo->dest->next_output_byte;
  state.free_in_buffer = cinfo->dest->free_in_buffer;
  ASSIGN_STATE(state.cur, entropy->saved);
  state.cinfo = cinfo;

  /* Flush out the last data */
  if (! flush_bits(&state))
    ERREXIT(cinfo, JERR_CANT_SUSPEND);

  /* Update state */
  cinfo->dest->next_output_byte = state.next_output_byte;
  cinfo->dest->free_in_buffer = state.free_in_buffer;
  ASSIGN_STATE(entropy->saved, state.cur);
}


/*
 * Huffman coding optimization.
 *
 * We first scan the supplied data and count the number of uses of each symbol
 * that is to be Huffman-coded. (This process MUST agree with the code above.)
 * Then we build a Huffman coding tree for the observed counts.
 * Symbols which are not needed at all for the particular image are not
 * assigned any code, which saves space in the DHT marker as well as in
 * the compressed data.
 */

#ifdef ENTROPY_OPT_SUPPORTED


/* Process a single block's worth of coefficients */

LOCAL(void)
htest_one_block (j_compress_ptr cinfo, JCOEFPTR block, int last_dc_val,
		 long dc_counts[], long ac_counts[])
{
  register int temp;
  register int nbits;
  register int k, r;
  
  /* Encode the DC coefficient difference per section F.1.2.1 */
  
  temp = block[0] - last_dc_val;
  if (temp < 0)
    temp = -temp;
  
  /* Find the number of bits needed for the magnitude of the coefficient */
  nbits = 0;
  while (temp) {
    nbits++;
    temp >>= 1;
  }
  /* Check for out-of-range coefficient values.
   * Since we're encoding a difference, the range limit is twice as much.
   */
  if (nbits > MAX_COEF_BITS+1)
    ERREXIT(cinfo, JERR_BAD_DCT_COEF);

  /* Count the Huffman symbol for the number of bits */
  dc_counts[nbits]++;
  
  /* Encode the AC coefficients per section F.1.2.2 */
  
  r = 0;			/* r = run length of zeros */
  
  for (k = 1; k < DCTSIZE2; k++) {
    if ((temp = block[jpeg_natural_order[k]]) == 0) {
      r++;
    } else {
      /* if run length > 15, must emit special run-length-16 codes (0xF0) */
      while (r > 15) {
	ac_counts[0xF0]++;
	r -= 16;
      }
      
      /* Find the number of bits needed for the magnitude of the coefficient */
      if (temp < 0)
	temp = -temp;
      
      /* Find the number of bits needed for the magnitude of the coefficient */
      nbits = 1;		/* there must be at least one 1 bit */
      while ((temp >>= 1))
	nbits++;
      /* Check for out-of-range coefficient values */
      if (nbits > MAX_COEF_BITS)
	ERREXIT(cinfo, JERR_BAD_DCT_COEF);
      
      /* Count Huffman symbol for run length / number of bits */
      ac_counts[(r << 4) + nbits]++;
      
      r = 0;
    }
  }

  /* If the last coef(s) were zero, emit an end-of-block code */
  if (r > 0)
    ac_counts[0]++;
}


/*
 * Trial-encode one MCU's worth of Huffman-compressed coefficients.
 * No data is actually output, so no suspension return is possible.
 */

METHODDEF(boolean)
encode_mcu_gather (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
{
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
  int blkn, ci;
  jpeg_component_info * compptr;

  /* Take care of restart intervals if needed */
  if (cinfo->restart_interval) {
    if (entropy->restarts_to_go == 0) {
      /* Re-initialize DC predictions to 0 */
      for (ci = 0; ci < cinfo->comps_in_scan; ci++)
	entropy->saved.last_dc_val[ci] = 0;
      /* Update restart state */
      entropy->restarts_to_go = cinfo->restart_interval;
    }
    entropy->restarts_to_go--;
  }

  for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
    ci = cinfo->MCU_membership[blkn];
    compptr = cinfo->cur_comp_info[ci];
    htest_one_block(cinfo, MCU_data[blkn][0], entropy->saved.last_dc_val[ci],
		    entropy->dc_count_ptrs[compptr->dc_tbl_no],
		    entropy->ac_count_ptrs[compptr->ac_tbl_no]);
    entropy->saved.last_dc_val[ci] = MCU_data[blkn][0][0];
  }

  return TRUE;
}


/*
 * Generate the best Huffman code table for the given counts, fill htbl.
 * Note this is also used by jcphuff.c.
 *
 * The JPEG standard requires that no symbol be assigned a codeword of all
 * one bits (so that padding bits added at the end of a compressed segment
 * can't look like a valid code).  Because of the canonical ordering of
 * codewords, this just means that there must be an unused slot in the
 * longest codeword length category.  Section K.2 of the JPEG spec suggests
 * reserving such a slot by pretending that symbol 256 is a valid symbol
 * with count 1.  In theory that's not optimal; giving it count zero but
 * including it in the symbol set anyway should give a better Huffman code.
 * But the theoretically better code actually seems to come out worse in
 * practice, because it produces more all-ones bytes (which incur stuffed
 * zero bytes in the final file).  In any case the difference is tiny.
 *
 * The JPEG standard requires Huffman codes to be no more than 16 bits long.
 * If some symbols have a very small but nonzero probability, the Huffman tree
 * must be adjusted to meet the code length restriction.  We currently use
 * the adjustment method suggested in JPEG section K.2.  This method is *not*
 * optimal; it may not choose the best possible limited-length code.  But
 * typically only very-low-frequency symbols will be given less-than-optimal
 * lengths, so the code is almost optimal.  Experimental comparisons against
 * an optimal limited-length-code algorithm indicate that the difference is
 * microscopic --- usually less than a hundredth of a percent of total size.
 * So the extra complexity of an optimal algorithm doesn't seem worthwhile.
 */

GLOBAL(void)
jpeg_gen_optimal_table (j_compress_ptr cinfo, JHUFF_TBL * htbl, long freq[])
{
#define MAX_CLEN 32		/* assumed maximum initial code length */
  UINT8 bits[MAX_CLEN+1];	/* bits[k] = # of symbols with code length k */
  int codesize[257];		/* codesize[k] = code length of symbol k */
  int others[257];		/* next symbol in current branch of tree */
  int c1, c2;
  int p, i, j;
  long v;

  /* This algorithm is explained in section K.2 of the JPEG standard */

  MEMZERO(bits, SIZEOF(bits));
  MEMZERO(codesize, SIZEOF(codesize));
  for (i = 0; i < 257; i++)
    others[i] = -1;		/* init links to empty */
  
  freq[256] = 1;		/* make sure 256 has a nonzero count */
  /* Including the pseudo-symbol 256 in the Huffman procedure guarantees
   * that no real symbol is given code-value of all ones, because 256
   * will be placed last in the largest codeword category.
   */

  /* Huffman's basic algorithm to assign optimal code lengths to symbols */

  for (;;) {
    /* Find the smallest nonzero frequency, set c1 = its symbol */
    /* In case of ties, take the larger symbol number */
    c1 = -1;
    v = 1000000000L;
    for (i = 0; i <= 256; i++) {
      if (freq[i] && freq[i] <= v) {
	v = freq[i];
	c1 = i;
      }
    }

    /* Find the next smallest nonzero frequency, set c2 = its symbol */
    /* In case of ties, take the larger symbol number */
    c2 = -1;
    v = 1000000000L;
    for (i = 0; i <= 256; i++) {
      if (freq[i] && freq[i] <= v && i != c1) {
	v = freq[i];
	c2 = i;
      }
    }

    /* Done if we've merged everything into one frequency */
    if (c2 < 0)
      break;
    
    /* Else merge the two counts/trees */
    freq[c1] += freq[c2];
    freq[c2] = 0;

    /* Increment the codesize of everything in c1's tree branch */
    codesize[c1]++;
    while (others[c1] >= 0) {
      c1 = others[c1];
      codesize[c1]++;
    }
    
    others[c1] = c2;		/* chain c2 onto c1's tree branch */
    
    /* Increment the codesize of everything in c2's tree branch */
    codesize[c2]++;
    while (others[c2] >= 0) {
      c2 = others[c2];
      codesize[c2]++;
    }
  }

  /* Now count the number of symbols of each code length */
  for (i = 0; i <= 256; i++) {
    if (codesize[i]) {
      /* The JPEG standard seems to think that this can't happen, */
      /* but I'm paranoid... */
      if (codesize[i] > MAX_CLEN)
	ERREXIT(cinfo, JERR_HUFF_CLEN_OVERFLOW);

      bits[codesize[i]]++;
    }
  }

  /* JPEG doesn't allow symbols with code lengths over 16 bits, so if the pure
   * Huffman procedure assigned any such lengths, we must adjust the coding.
   * Here is what the JPEG spec says about how this next bit works:
   * Since symbols are paired for the longest Huffman code, the symbols are
   * removed from this length category two at a time.  The prefix for the pair
   * (which is one bit shorter) is allocated to one of the pair; then,
   * skipping the BITS entry for that prefix length, a code word from the next
   * shortest nonzero BITS entry is converted into a prefix for two code words
   * one bit longer.
   */
  
  for (i = MAX_CLEN; i > 16; i--) {
    while (bits[i] > 0) {
      j = i - 2;		/* find length of new prefix to be used */
      while (bits[j] == 0)
	j--;
      
      bits[i] -= 2;		/* remove two symbols */
      bits[i-1]++;		/* one goes in this length */
      bits[j+1] += 2;		/* two new symbols in this length */
      bits[j]--;		/* symbol of this length is now a prefix */
    }
  }

  /* Remove the count for the pseudo-symbol 256 from the largest codelength */
  while (bits[i] == 0)		/* find largest codelength still in use */
    i--;
  bits[i]--;
  
  /* Return final symbol counts (only for lengths 0..16) */
  MEMCOPY(htbl->bits, bits, SIZEOF(htbl->bits));
  
  /* Return a list of the symbols sorted by code length */
  /* It's not real clear to me why we don't need to consider the codelength
   * changes made above, but the JPEG spec seems to think this works.
   */
  p = 0;
  for (i = 1; i <= MAX_CLEN; i++) {
    for (j = 0; j <= 255; j++) {
      if (codesize[j] == i) {
	htbl->huffval[p] = (UINT8) j;
	p++;
      }
    }
  }

  /* Set sent_table FALSE so updated table will be written to JPEG file. */
  htbl->sent_table = FALSE;
}


/*
 * Finish up a statistics-gathering pass and create the new Huffman tables.
 */

METHODDEF(void)
finish_pass_gather (j_compress_ptr cinfo)
{
  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
  int ci, dctbl, actbl;
  jpeg_component_info * compptr;
  JHUFF_TBL **htblptr;
  boolean did_dc[NUM_HUFF_TBLS];
  boolean did_ac[NUM_HUFF_TBLS];

  /* It's important not to apply jpeg_gen_optimal_table more than once
   * per table, because it clobbers the input frequency counts!
   */
  MEMZERO(did_dc, SIZEOF(did_dc));
  MEMZERO(did_ac, SIZEOF(did_ac));

  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
    compptr = cinfo->cur_comp_info[ci];
    dctbl = compptr->dc_tbl_no;
    actbl = compptr->ac_tbl_no;
    if (! did_dc[dctbl]) {
      htblptr = & cinfo->dc_huff_tbl_ptrs[dctbl];
      if (*htblptr == NULL)
	*htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
      jpeg_gen_optimal_table(cinfo, *htblptr, entropy->dc_count_ptrs[dctbl]);
      did_dc[dctbl] = TRUE;
    }
    if (! did_ac[actbl]) {
      htblptr = & cinfo->ac_huff_tbl_ptrs[actbl];
      if (*htblptr == NULL)
	*htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
      jpeg_gen_optimal_table(cinfo, *htblptr, entropy->ac_count_ptrs[actbl]);
      did_ac[actbl] = TRUE;
    }
  }
}


#endif /* ENTROPY_OPT_SUPPORTED */


/*
 * Module initialization routine for Huffman entropy encoding.
 */

GLOBAL(void)
jinit_huff_encoder (j_compress_ptr cinfo)
{
  huff_entropy_ptr entropy;
  int i;

  entropy = (huff_entropy_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
				SIZEOF(huff_entropy_encoder));
  cinfo->entropy = (struct jpeg_entropy_encoder *) entropy;
  entropy->pub.start_pass = start_pass_huff;

  /* Mark tables unallocated */
  for (i = 0; i < NUM_HUFF_TBLS; i++) {
    entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = NULL;
#ifdef ENTROPY_OPT_SUPPORTED
    entropy->dc_count_ptrs[i] = entropy->ac_count_ptrs[i] = NULL;
#endif
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\imaging\jpeg\libjpeg\jcmarker.c ===
/*
 * jcmarker.c
 *
 * Copyright (C) 1991-1998, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains routines to write JPEG datastream markers.
 */

#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"


typedef enum {			/* JPEG marker codes */
  M_SOF0  = 0xc0,
  M_SOF1  = 0xc1,
  M_SOF2  = 0xc2,
  M_SOF3  = 0xc3,
  
  M_SOF5  = 0xc5,
  M_SOF6  = 0xc6,
  M_SOF7  = 0xc7,
  
  M_JPG   = 0xc8,
  M_SOF9  = 0xc9,
  M_SOF10 = 0xca,
  M_SOF11 = 0xcb,
  
  M_SOF13 = 0xcd,
  M_SOF14 = 0xce,
  M_SOF15 = 0xcf,
  
  M_DHT   = 0xc4,
  
  M_DAC   = 0xcc,
  
  M_RST0  = 0xd0,
  M_RST1  = 0xd1,
  M_RST2  = 0xd2,
  M_RST3  = 0xd3,
  M_RST4  = 0xd4,
  M_RST5  = 0xd5,
  M_RST6  = 0xd6,
  M_RST7  = 0xd7,
  
  M_SOI   = 0xd8,
  M_EOI   = 0xd9,
  M_SOS   = 0xda,
  M_DQT   = 0xdb,
  M_DNL   = 0xdc,
  M_DRI   = 0xdd,
  M_DHP   = 0xde,
  M_EXP   = 0xdf,
  
  M_APP0  = 0xe0,
  M_APP1  = 0xe1,
  M_APP2  = 0xe2,
  M_APP3  = 0xe3,
  M_APP4  = 0xe4,
  M_APP5  = 0xe5,
  M_APP6  = 0xe6,
  M_APP7  = 0xe7,
  M_APP8  = 0xe8,
  M_APP9  = 0xe9,
  M_APP10 = 0xea,
  M_APP11 = 0xeb,
  M_APP12 = 0xec,
  M_APP13 = 0xed,
  M_APP14 = 0xee,
  M_APP15 = 0xef,
  
  M_JPG0  = 0xf0,
  M_JPG13 = 0xfd,
  M_COM   = 0xfe,
  
  M_TEM   = 0x01,
  
  M_ERROR = 0x100
} JPEG_MARKER;


/* Private state */

typedef struct {
  struct jpeg_marker_writer pub; /* public fields */

  unsigned int last_restart_interval; /* last DRI value emitted; 0 after SOI */
} my_marker_writer;

typedef my_marker_writer * my_marker_ptr;


/*
 * Basic output routines.
 *
 * Note that we do not support suspension while writing a marker.
 * Therefore, an application using suspension must ensure that there is
 * enough buffer space for the initial markers (typ. 600-700 bytes) before
 * calling jpeg_start_compress, and enough space to write the trailing EOI
 * (a few bytes) before calling jpeg_finish_compress.  Multipass compression
 * modes are not supported at all with suspension, so those two are the only
 * points where markers will be written.
 */

LOCAL(void)
emit_byte (j_compress_ptr cinfo, int val)
/* Emit a byte */
{
  struct jpeg_destination_mgr * dest = cinfo->dest;

  *(dest->next_output_byte)++ = (JOCTET) val;
  if (--dest->free_in_buffer == 0) {
    if (! (*dest->empty_output_buffer) (cinfo))
      ERREXIT(cinfo, JERR_CANT_SUSPEND);
  }
}


LOCAL(void)
emit_marker (j_compress_ptr cinfo, JPEG_MARKER mark)
/* Emit a marker code */
{
  emit_byte(cinfo, 0xFF);
  emit_byte(cinfo, (int) mark);
}


LOCAL(void)
emit_2bytes (j_compress_ptr cinfo, int value)
/* Emit a 2-byte integer; these are always MSB first in JPEG files */
{
  emit_byte(cinfo, (value >> 8) & 0xFF);
  emit_byte(cinfo, value & 0xFF);
}


/*
 * Routines to write specific marker types.
 */

LOCAL(int)
emit_dqt (j_compress_ptr cinfo, int index)
/* Emit a DQT marker */
/* Returns the precision used (0 = 8bits, 1 = 16bits) for baseline checking */
{
  JQUANT_TBL * qtbl = cinfo->quant_tbl_ptrs[index];
  int prec;
  int i;

  if (qtbl == NULL)
    ERREXIT1(cinfo, JERR_NO_QUANT_TABLE, index);

  prec = 0;
  for (i = 0; i < DCTSIZE2; i++) {
    if (qtbl->quantval[i] > 255)
      prec = 1;
  }

  if (! qtbl->sent_table) {
    emit_marker(cinfo, M_DQT);

    emit_2bytes(cinfo, prec ? DCTSIZE2*2 + 1 + 2 : DCTSIZE2 + 1 + 2);

    emit_byte(cinfo, index + (prec<<4));

    for (i = 0; i < DCTSIZE2; i++) {
      /* The table entries must be emitted in zigzag order. */
      unsigned int qval = qtbl->quantval[jpeg_natural_order[i]];
      if (prec)
	emit_byte(cinfo, (int) (qval >> 8));
      emit_byte(cinfo, (int) (qval & 0xFF));
    }

    qtbl->sent_table = TRUE;
  }

  return prec;
}


LOCAL(void)
emit_dht (j_compress_ptr cinfo, int index, boolean is_ac)
/* Emit a DHT marker */
{
  JHUFF_TBL * htbl;
  int length, i;
  
  if (is_ac) {
    htbl = cinfo->ac_huff_tbl_ptrs[index];
    index += 0x10;		/* output index has AC bit set */
  } else {
    htbl = cinfo->dc_huff_tbl_ptrs[index];
  }

  if (htbl == NULL)
    ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, index);
  
  if (! htbl->sent_table) {
    emit_marker(cinfo, M_DHT);
    
    length = 0;
    for (i = 1; i <= 16; i++)
      length += htbl->bits[i];
    
    emit_2bytes(cinfo, length + 2 + 1 + 16);
    emit_byte(cinfo, index);
    
    for (i = 1; i <= 16; i++)
      emit_byte(cinfo, htbl->bits[i]);
    
    for (i = 0; i < length; i++)
      emit_byte(cinfo, htbl->huffval[i]);
    
    htbl->sent_table = TRUE;
  }
}


LOCAL(void)
emit_dac (j_compress_ptr cinfo)
/* Emit a DAC marker */
/* Since the useful info is so small, we want to emit all the tables in */
/* one DAC marker.  Therefore this routine does its own scan of the table. */
{
#ifdef C_ARITH_CODING_SUPPORTED
  char dc_in_use[NUM_ARITH_TBLS];
  char ac_in_use[NUM_ARITH_TBLS];
  int length, i;
  jpeg_component_info *compptr;
  
  for (i = 0; i < NUM_ARITH_TBLS; i++)
    dc_in_use[i] = ac_in_use[i] = 0;
  
  for (i = 0; i < cinfo->comps_in_scan; i++) {
    compptr = cinfo->cur_comp_info[i];
    dc_in_use[compptr->dc_tbl_no] = 1;
    ac_in_use[compptr->ac_tbl_no] = 1;
  }
  
  length = 0;
  for (i = 0; i < NUM_ARITH_TBLS; i++)
    length += dc_in_use[i] + ac_in_use[i];
  
  emit_marker(cinfo, M_DAC);
  
  emit_2bytes(cinfo, length*2 + 2);
  
  for (i = 0; i < NUM_ARITH_TBLS; i++) {
    if (dc_in_use[i]) {
      emit_byte(cinfo, i);
      emit_byte(cinfo, cinfo->arith_dc_L[i] + (cinfo->arith_dc_U[i]<<4));
    }
    if (ac_in_use[i]) {
      emit_byte(cinfo, i + 0x10);
      emit_byte(cinfo, cinfo->arith_ac_K[i]);
    }
  }
#endif /* C_ARITH_CODING_SUPPORTED */
}


LOCAL(void)
emit_dri (j_compress_ptr cinfo)
/* Emit a DRI marker */
{
  emit_marker(cinfo, M_DRI);
  
  emit_2bytes(cinfo, 4);	/* fixed length */

  emit_2bytes(cinfo, (int) cinfo->restart_interval);
}


LOCAL(void)
emit_sof (j_compress_ptr cinfo, JPEG_MARKER code)
/* Emit a SOF marker */
{
  int ci;
  jpeg_component_info *compptr;
  
  emit_marker(cinfo, code);
  
  emit_2bytes(cinfo, 3 * cinfo->num_components + 2 + 5 + 1); /* length */

  /* Make sure image isn't bigger than SOF field can handle */
  if ((long) cinfo->image_height > 65535L ||
      (long) cinfo->image_width > 65535L)
    ERREXIT1(cinfo, JERR_IMAGE_TOO_BIG, (unsigned int) 65535);

  emit_byte(cinfo, cinfo->data_precision);
  emit_2bytes(cinfo, (int) cinfo->image_height);
  emit_2bytes(cinfo, (int) cinfo->image_width);

  emit_byte(cinfo, cinfo->num_components);

  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
       ci++, compptr++) {
    emit_byte(cinfo, compptr->component_id);
    emit_byte(cinfo, (compptr->h_samp_factor << 4) + compptr->v_samp_factor);
    emit_byte(cinfo, compptr->quant_tbl_no);
  }
}


LOCAL(void)
emit_sos (j_compress_ptr cinfo)
/* Emit a SOS marker */
{
  int i, td, ta;
  jpeg_component_info *compptr;
  
  emit_marker(cinfo, M_SOS);
  
  emit_2bytes(cinfo, 2 * cinfo->comps_in_scan + 2 + 1 + 3); /* length */
  
  emit_byte(cinfo, cinfo->comps_in_scan);
  
  for (i = 0; i < cinfo->comps_in_scan; i++) {
    compptr = cinfo->cur_comp_info[i];
    emit_byte(cinfo, compptr->component_id);
    td = compptr->dc_tbl_no;
    ta = compptr->ac_tbl_no;
    if (cinfo->progressive_mode) {
      /* Progressive mode: only DC or only AC tables are used in one scan;
       * furthermore, Huffman coding of DC refinement uses no table at all.
       * We emit 0 for unused field(s); this is recommended by the P&M text
       * but does not seem to be specified in the standard.
       */
      if (cinfo->Ss == 0) {
	ta = 0;			/* DC scan */
	if (cinfo->Ah != 0 && !cinfo->arith_code)
	  td = 0;		/* no DC table either */
      } else {
	td = 0;			/* AC scan */
      }
    }
    emit_byte(cinfo, (td << 4) + ta);
  }

  emit_byte(cinfo, cinfo->Ss);
  emit_byte(cinfo, cinfo->Se);
  emit_byte(cinfo, (cinfo->Ah << 4) + cinfo->Al);
}


LOCAL(void)
emit_jfif_app0 (j_compress_ptr cinfo)
/* Emit a JFIF-compliant APP0 marker */
{
  /*
   * Length of APP0 block	(2 bytes)
   * Block ID			(4 bytes - ASCII "JFIF")
   * Zero byte			(1 byte to terminate the ID string)
   * Version Major, Minor	(2 bytes - major first)
   * Units			(1 byte - 0x00 = none, 0x01 = inch, 0x02 = cm)
   * Xdpu			(2 bytes - dots per unit horizontal)
   * Ydpu			(2 bytes - dots per unit vertical)
   * Thumbnail X size		(1 byte)
   * Thumbnail Y size		(1 byte)
   */
  
  emit_marker(cinfo, M_APP0);
  
  emit_2bytes(cinfo, 2 + 4 + 1 + 2 + 1 + 2 + 2 + 1 + 1); /* length */

  emit_byte(cinfo, 0x4A);	/* Identifier: ASCII "JFIF" */
  emit_byte(cinfo, 0x46);
  emit_byte(cinfo, 0x49);
  emit_byte(cinfo, 0x46);
  emit_byte(cinfo, 0);
  emit_byte(cinfo, cinfo->JFIF_major_version); /* Version fields */
  emit_byte(cinfo, cinfo->JFIF_minor_version);
  emit_byte(cinfo, cinfo->density_unit); /* Pixel size information */
  emit_2bytes(cinfo, (int) cinfo->X_density);
  emit_2bytes(cinfo, (int) cinfo->Y_density);
  emit_byte(cinfo, 0);		/* No thumbnail image */
  emit_byte(cinfo, 0);
}


LOCAL(void)
emit_adobe_app14 (j_compress_ptr cinfo)
/* Emit an Adobe APP14 marker */
{
  /*
   * Length of APP14 block	(2 bytes)
   * Block ID			(5 bytes - ASCII "Adobe")
   * Version Number		(2 bytes - currently 100)
   * Flags0			(2 bytes - currently 0)
   * Flags1			(2 bytes - currently 0)
   * Color transform		(1 byte)
   *
   * Although Adobe TN 5116 mentions Version = 101, all the Adobe files
   * now in circulation seem to use Version = 100, so that's what we write.
   *
   * We write the color transform byte as 1 if the JPEG color space is
   * YCbCr, 2 if it's YCCK, 0 otherwise.  Adobe's definition has to do with
   * whether the encoder performed a transformation, which is pretty useless.
   */
  
  emit_marker(cinfo, M_APP14);
  
  emit_2bytes(cinfo, 2 + 5 + 2 + 2 + 2 + 1); /* length */

  emit_byte(cinfo, 0x41);	/* Identifier: ASCII "Adobe" */
  emit_byte(cinfo, 0x64);
  emit_byte(cinfo, 0x6F);
  emit_byte(cinfo, 0x62);
  emit_byte(cinfo, 0x65);
  emit_2bytes(cinfo, 100);	/* Version */
  emit_2bytes(cinfo, 0);	/* Flags0 */
  emit_2bytes(cinfo, 0);	/* Flags1 */
  switch (cinfo->jpeg_color_space) {
  case JCS_YCbCr:
    emit_byte(cinfo, 1);	/* Color transform = 1 */
    break;
  case JCS_YCCK:
    emit_byte(cinfo, 2);	/* Color transform = 2 */
    break;
  default:
    emit_byte(cinfo, 0);	/* Color transform = 0 */
    break;
  }
}


/*
 * These routines allow writing an arbitrary marker with parameters.
 * The only intended use is to emit COM or APPn markers after calling
 * write_file_header and before calling write_frame_header.
 * Other uses are not guaranteed to produce desirable results.
 * Counting the parameter bytes properly is the caller's responsibility.
 */

METHODDEF(void)
write_marker_header (j_compress_ptr cinfo, int marker, unsigned int datalen)
/* Emit an arbitrary marker header */
{
  if (datalen > (unsigned int) 65533)		/* safety check */
    ERREXIT(cinfo, JERR_BAD_LENGTH);

  emit_marker(cinfo, (JPEG_MARKER) marker);

  emit_2bytes(cinfo, (int) (datalen + 2));	/* total length */
}

METHODDEF(void)
write_marker_byte (j_compress_ptr cinfo, int val)
/* Emit one byte of marker parameters following write_marker_header */
{
  emit_byte(cinfo, val);
}


/*
 * Write datastream header.
 * This consists of an SOI and optional APPn markers.
 * We recommend use of the JFIF marker, but not the Adobe marker,
 * when using YCbCr or grayscale data.  The JFIF marker should NOT
 * be used for any other JPEG colorspace.  The Adobe marker is helpful
 * to distinguish RGB, CMYK, and YCCK colorspaces.
 * Note that an application can write additional header markers after
 * jpeg_start_compress returns.
 */

METHODDEF(void)
write_file_header (j_compress_ptr cinfo)
{
  my_marker_ptr marker = (my_marker_ptr) cinfo->marker;

  emit_marker(cinfo, M_SOI);	/* first the SOI */

  /* SOI is defined to reset restart interval to 0 */
  marker->last_restart_interval = 0;

  if (cinfo->write_JFIF_header)	/* nex