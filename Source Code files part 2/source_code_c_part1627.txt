       return hr;

    hr = pSipMsg->GetSingleHeader(SIP_HEADER_FROM, &Header, &HeaderLen);
    if (hr != S_OK)
        return hr;

    hr = SetRemoteForIncomingSession(Header, HeaderLen);
    if (hr != S_OK)
        return hr;

    hr = pSipMsg->GetSingleHeader(SIP_HEADER_CALL_ID, &Header, &HeaderLen);
    if (hr != S_OK)
        return hr;

    hr = SetCallId(Header, HeaderLen);
    if (hr != S_OK)
        return hr;

    hr = pSipMsg -> GetHeader( SIP_HEADER_CONTACT, &pHeaderEntry, &NumHeaders );
    if( (hr == S_OK) && (NumHeaders != 0) )
    {
        GetWatcherContactAddress( pSipMsg );
    }
    
    if (Transport != SIP_TRANSPORT_UDP &&
        m_pRequestSocket == NULL)
    {
        hr = SetRequestSocketForIncomingSession(pResponseSocket);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR,
                 "%s SetRequestSocketForIncomingSession failed %x",
                 __fxName, hr));
            return hr;
        }
    }
    
    hr = CreateIncomingSubscribeTransaction( pSipMsg, pResponseSocket, TRUE );
    if (hr != S_OK)
        return hr;
    
    // Notify the user about the incoming call
    // and wait for Accept() to be called.
    m_WatcherState = WATCHER_STATE_OFFERING;

    return OfferWatcher();
}


HRESULT
CSIPWatcher::GetWatcherContactAddress(
    IN  SIP_MESSAGE    *pSipMsg
    )
{
    LIST_ENTRY     *pListEntry;
    CONTACT_HEADER *pContactHeader;
    LIST_ENTRY      ContactList;
    HRESULT         hr;

    LOG(( RTC_TRACE, "CSIPWatcher::GetWatcherContactAddress - Entered" ));
    
    // Extract the timeout value from contact header.
    InitializeListHead(&ContactList);

    hr = pSipMsg -> ParseContactHeaders(&ContactList);
    if( hr == S_OK )
    {
        pListEntry = ContactList.Flink;

        if(pListEntry != &ContactList)
        {
            pContactHeader = CONTAINING_RECORD(pListEntry,
                                               CONTACT_HEADER,
                                               m_ListEntry);

            if (pContactHeader->m_SipUrl.Length != 0)
            {
                hr = UTF8ToUnicode(pContactHeader->m_SipUrl.Buffer,
                                   pContactHeader->m_SipUrl.Length,
                                   &m_WatcherSipUrl);
                if (hr != S_OK)
                {
                    LOG(( RTC_ERROR, "%s - UTF8ToUnicode failed %x", hr ));
                    return hr;
                }
            }
        }

        FreeContactHeaderList(&ContactList);
    }

    return S_OK;
}


VOID
CSIPWatcher::OnTimerExpire()
{
    LOG(( RTC_ERROR, "The watcher did not refresh the SUB session in time!!:%p",
        this ));

    // The subscription has expired. Send an UNSUB and drop the watcher.
    CreateOutgoingUnsub( FALSE, NULL, 0 );
        
    WatcherDropped();
}


HRESULT
CSIPWatcher::HandleSuccessfulSubscribe(
    INT ExpireTimeout
    )
{
    LOG(( RTC_TRACE, "CSIPWatcher::HandleSuccessfulSubscribe - Entered" ));

    if( ExpireTimeout == 0 )
    {
        // UNSUB message.
        m_WatcherState = WATCHER_STATE_UNSUBSCRIBED;
    
        // Watcher is not online anymore. Remove the watcher from the list.
        WatcherOffline();
    }
    else
    {
        if( IsTimerActive() )
        {
            KillTimer();
        }

        // This is a successful SUBSCRIBE request.

        // If the watcher is in ACCEPTED mode, send a NOTIFY
        if( m_WatcherState == WATCHER_STATE_ACCEPTED )
        {
            CreateOutgoingNotify(FALSE, NULL, 0);
        }

        // Start the timer
        StartTimer( ExpireTimeout * 1000 );

        LOG(( RTC_TRACE, "This watcher session will be dropped if the next "
        "refresh is not received within %d seconds:%p", ExpireTimeout, this ));
        
        //Modify the absolute expire time
        SetAbsoluteExpireTime( time(0) + ExpireTimeout * 1000 );
    }

    return S_OK;
}

        
HRESULT
CSIPWatcher::CreateOutgoingUnsub(
    IN  BOOL                        AuthHeaderSent,
    IN  SIP_HEADER_ARRAY_ELEMENT   *pAuthHeaderElement,
    IN  ULONG                       dwNoOfHeaders
    )
{
    HRESULT hr;
    OUTGOING_NOTIFY_TRANSACTION *pOutgoingUnsubTransaction;
    SIP_HEADER_ARRAY_ELEMENT    HeaderElementArray[2];
    DWORD                       dwNoOfHeader = 0;
    SIP_HEADER_ARRAY_ELEMENT   *ExpHeaderElement;

   LOG(( RTC_TRACE, "Watcher-CreateOutgoingUnsub - Entered" ));
    
    //
    // Don't send any message if the watcher session is already 
    // dropped and this not an auth challenge response.
    //
    if( (m_WatcherState != WATCHER_STATE_ACCEPTED) && (AuthHeaderSent==FALSE) )
    {
        LOG(( RTC_TRACE, 
            "Watcher already dropped. So not creating UNSUB transaction." ));

        return E_FAIL;
    }

    m_WatcherState = WATCHER_STATE_DROPPED;

    ExpHeaderElement = &HeaderElementArray[0];

    ExpHeaderElement->HeaderId = SIP_HEADER_EXPIRES;
    ExpHeaderElement->HeaderValueLen = strlen( UNSUB_EXPIRES_HEADER_TEXT );
    ExpHeaderElement->HeaderValue =
            new CHAR[ ExpHeaderElement->HeaderValueLen + 1 ];

    if( ExpHeaderElement->HeaderValue == NULL )
    {
        return E_OUTOFMEMORY;
    }

    strcpy( ExpHeaderElement->HeaderValue, UNSUB_EXPIRES_HEADER_TEXT );
    dwNoOfHeader++;

    if (pAuthHeaderElement != NULL)
    {
        HeaderElementArray[dwNoOfHeader] = *pAuthHeaderElement;
        dwNoOfHeader++;
    }

    pOutgoingUnsubTransaction =
        new OUTGOING_NOTIFY_TRANSACTION(
                this, SIP_METHOD_NOTIFY,
                GetNewCSeqForRequest(),
                AuthHeaderSent,
                TRUE
                );
    
    if( pOutgoingUnsubTransaction == NULL )
    {
        delete ExpHeaderElement->HeaderValue;
        return E_OUTOFMEMORY;
    }

    // Set the request socket to the via field of the watcher object
    hr = pOutgoingUnsubTransaction -> CheckRequestSocketAndSendRequestMsg(
             (m_Transport == SIP_TRANSPORT_UDP) ?
             SIP_TIMER_RETRY_INTERVAL_T1 :
             SIP_TIMER_INTERVAL_AFTER_INVITE_SENT_TCP,
             HeaderElementArray, dwNoOfHeader,
             NULL, 0,
             NULL, 0     //No ContentType
             );
    
    delete ExpHeaderElement->HeaderValue;

    if( hr != S_OK )
    {
        pOutgoingUnsubTransaction->OnTransactionDone();
        return hr;
    }

    LOG(( RTC_TRACE, "CreateOutgoingUnsubTransaction() Exited - SUCCESS" ));

    return S_OK;
}


HRESULT
CSIPWatcher::StartDroppedWatcher(
    IN  SIP_MESSAGE        *pSipMsg,
    IN  SIP_SERVER_INFO    *pProxyInfo
    )
{
    HRESULT             hr;
    PSTR                Header;
    ULONG               HeaderLen;
    SIP_HEADER_ENTRY   *pHeaderEntry;
    ULONG               NumHeaders;

    LOG(( RTC_TRACE, "StartDroppedWatcher - Entered" ));
    
    m_Transport = pProxyInfo->TransportProtocol;

    hr = pSipMsg->GetSingleHeader( SIP_HEADER_TO, &Header, &HeaderLen );
    if (hr != S_OK)
        return hr;

    hr = SetRemoteForIncomingSession(Header, HeaderLen);
    if (hr != S_OK)
        return hr;

    hr = pSipMsg->GetSingleHeader(SIP_HEADER_FROM, &Header, &HeaderLen);
    if (hr != S_OK)
        return hr;

    hr = SetLocalForIncomingCall(Header, HeaderLen);
    if (hr != S_OK)
        return hr;

    hr = pSipMsg->GetSingleHeader(SIP_HEADER_CALL_ID, &Header, &HeaderLen);
    if (hr != S_OK)
        return hr;

    hr = SetCallId(Header, HeaderLen);
    if (hr != S_OK)
        return hr;

    //
    // Resolve the proxy address.
    //
    if( pProxyInfo != NULL )
    {
        hr = SetProxyInfo( pProxyInfo );
        
        if( hr != S_OK )
        {
            return hr;
        }
    }

    // Set the request URI
    hr = AllocString(   m_DecodedRemote.m_SipUrl.Buffer,
                        m_DecodedRemote.m_SipUrl.Length,
                        &m_RequestURI, &m_RequestURILen );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "Could not alloc request URI: %x", hr));
        return hr;
    }        

    // Set the request destination to the proxy.
    hr = ResolveProxyAddressAndSetRequestDestination();
    if (hr != S_OK)
    {
        LOG((RTC_ERROR,
             "ResolveProxyAddressAndSetRequestDestination failed : %x", hr));
        return hr;
    }

    //
    // Set the local CSeq to 1 less. It would be 
    // incremented when we create the transaction.
    //
    SetLocalCSeq( pSipMsg->CSeq - 1 );

	// The user has just unblocked this watcher
	m_WatcherState = WATCHER_STATE_ACCEPTED;

    //
    //Create outgoing NOTIFY:0 transaction
    //

    CreateOutgoingUnsub( FALSE, NULL, 0 );

    return S_OK;
}


STDMETHODIMP
SIP_STACK::SendUnsubToWatcher(
    IN  PSTR            NotifyBlob,
    IN  DWORD           dwBlobLength,
    IN  SIP_SERVER_INFO *pProxyInfo
    )
{
    CHAR                        tempBuf[ 20 ] = "";
    OUTGOING_NOTIFY_TRANSACTION *pOutgoingUnsubTransaction = NULL;
    INT                         ExpireTimeStringLen = 0;
    INT                         AbsoluteExpireTimeout = 0;
    PSTR                        pRequestBuffer = NULL;
    DWORD                       pRequestBufferLen = 0;
    DWORD                       BytesParsed = 0;
    SIP_MESSAGE                *pSipMsg  = NULL;
    HRESULT                     hr = S_OK;
    CSIPWatcher                *pSipWatcher = NULL;
    PSTR                        pEncodedBuffer = NULL;
    DWORD                       pEncodedBufferLen = 0;

    tempBuf[0] = NotifyBlob[0];
    tempBuf[1] = NotifyBlob[1];
    tempBuf[2] = 0;

    ExpireTimeStringLen = atoi( tempBuf );

    ASSERT( ExpireTimeStringLen <= 21 );

    CopyMemory( (PVOID)tempBuf, (PVOID)(NotifyBlob+2), ExpireTimeStringLen );
    tempBuf[ ExpireTimeStringLen ] = '\0';

    AbsoluteExpireTimeout = atoi( tempBuf );

    if( AbsoluteExpireTimeout <= time(0) )
    {
        // No need o send any UNSUB message.
        return S_OK;
    }

    //Make the blob point to the actual request buffer
    pEncodedBuffer = NotifyBlob + 2 + ExpireTimeStringLen;
    pEncodedBufferLen = dwBlobLength - 2 - ExpireTimeStringLen;

    pRequestBuffer = new CHAR[ pEncodedBufferLen ] ;
    
    if( pRequestBuffer == NULL )
    {
        return E_OUTOFMEMORY;
    }

    //base64decode the buffer
    base64decode(   pEncodedBuffer,
                    pRequestBuffer,
                    pEncodedBufferLen,
                    0,//pEncodedBufferLen,
                    &pRequestBufferLen );

    BytesParsed = 0;

    pSipMsg = new SIP_MESSAGE();
    if( pSipMsg == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    //Parse the sip message
    hr = ParseSipMessageIntoHeadersAndBody(
         pRequestBuffer,
         pRequestBufferLen,
         &BytesParsed,
         TRUE,           // IsEndOfData
         pSipMsg
         );

    //Create incoming watcher
    pSipWatcher = new CSIPWatcher( this );
    
    if( pSipWatcher == NULL )
    {
        goto cleanup;
    }

    hr = pSipWatcher -> StartDroppedWatcher( pSipMsg, pProxyInfo );

cleanup:

    if( pRequestBuffer != NULL )
    {
        delete pRequestBuffer ;
    }

    // We create the watcher with a ref count of 1
    // At this point the UNSUB transaction should have addref'ed the watcher
    // and we can release our reference.
    if( pSipWatcher != NULL )
    {
        pSipWatcher -> Release();
    }

    if( pSipMsg != NULL )
    {
        delete pSipMsg;
    }

    return hr;
}


//
// This function is called for each watcher when the core is preparing for a 
// shutdown. Pass the NOTIFY:0 blob for this watcher if this watcher is blocked
// or we are appearing offline.
//

STDMETHODIMP
CSIPWatcher::GetWatcherShutdownData(
    IN  PSTR        NotifyBlob,
    OUT IN  PDWORD  pdwBlobLength
    )
{
    HRESULT                         hr;
    OUTGOING_NOTIFY_TRANSACTION    *pOutgoingUnsubTransaction;
    SIP_HEADER_ARRAY_ELEMENT        ExpHeaderElement;
    SEND_BUFFER                    *pRequestBuffer = NULL;
    CHAR                            tempBuffer[ 20 ];
    DWORD                           tempBufLen;
    NTSTATUS                        ntStatus;

    LOG(( RTC_TRACE, "GetWatcherShutdownData - Entered:%p", this ));
    
    ASSERT( *pdwBlobLength >= 2000 );
    *pdwBlobLength = 0;
    
    //
    // Don't save any UNSUB message if this watcher is not blocked.
    //
    if( m_WatcherState != WATCHER_STATE_REJECTED )
    {
        LOG(( RTC_TRACE, "Watcher is not blocked. Dont create shutdown data" ));
        return E_FAIL;
    }

    m_WatcherState = WATCHER_STATE_DROPPED;

    ExpHeaderElement.HeaderId = SIP_HEADER_EXPIRES;
    ExpHeaderElement.HeaderValueLen = strlen( UNSUB_EXPIRES_HEADER_TEXT );

    ExpHeaderElement.HeaderValue = new CHAR[ ExpHeaderElement.HeaderValueLen + 1 ];
    
    if( ExpHeaderElement.HeaderValue == NULL )
    {
        LOG(( RTC_ERROR, "GetWatcherShutdownData- could not alloc expire header" ));
        return E_FAIL;
    }

    strcpy( ExpHeaderElement.HeaderValue, UNSUB_EXPIRES_HEADER_TEXT );

    hr = CreateRequestMsg(  SIP_METHOD_NOTIFY,
                            GetNewCSeqForRequest(),
                            NULL, 0,                // No special To header
                            &ExpHeaderElement, 1,
                            NULL, 0,                // No msgbody
                            NULL, 0,                // No content type
                            &pRequestBuffer
                            );

    delete ExpHeaderElement.HeaderValue;

    if( hr != S_OK )
    {
        LOG(( RTC_ERROR, "GetWatcherShutdownData- could not create request message" ));
        return E_FAIL;
    }

    if( pRequestBuffer != NULL )
    {
        NotifyBlob[0 ] = '0';
        NotifyBlob[1] = '0';

        _itoa( m_dwAbsoluteExpireTime, tempBuffer, 10 );

        tempBufLen = strlen( tempBuffer );

        // Copy the length of the number
        if( tempBufLen > 9 )
        {
            _itoa( tempBufLen, NotifyBlob, 10 );
        }
        else 
        {
            _itoa( tempBufLen, NotifyBlob+1, 10 );
        }

        *pdwBlobLength += 2;

        // Copy the number
        CopyMemory( &(NotifyBlob[ 2 ]), tempBuffer, tempBufLen );
        *pdwBlobLength += tempBufLen;

        // base64 encode the buffer
        ntStatus = base64encode(pRequestBuffer -> m_Buffer,
                                pRequestBuffer -> m_BufLen,
                                &(NotifyBlob[ *pdwBlobLength ]), 
                                2000 - *pdwBlobLength,
                                NULL );

        *pdwBlobLength += (pRequestBuffer->m_BufLen +2) /3 * 4;

        // Release the buffer
        pRequestBuffer -> Release();
    }

    LOG(( RTC_TRACE, "GetWatcherShutdownData - Exited:%p", this ));

    return S_OK;
}


HRESULT
CSIPWatcher::CreateOutgoingNotify(
    IN  BOOL                        AuthHeaderSent,
    IN  SIP_HEADER_ARRAY_ELEMENT   *pAuthHeaderElement,
    IN  ULONG                       dwNoOfHeaders
    )
{
    HRESULT                         hr;
    SIP_PRESENCE_INFO              *pLocalPresenceInfo;
    OUTGOING_NOTIFY_TRANSACTION    *pOutgoingNotifyTransaction;

    ENTER_FUNCTION("CSIPWatcher::CreateOutgoingNotify");
    LOG(( RTC_TRACE, "%s - Entered: %p", __fxName, this ));
    
    if( m_WatcherState != WATCHER_STATE_ACCEPTED )
    {
        LOG(( RTC_TRACE, "%s - watcher not accepted. dont send NOTIFY: %p",
            __fxName, this ));
        return S_OK;
    }

    pLocalPresenceInfo = m_pSipStack -> GetLocalPresenceInfo();

    if( pLocalPresenceInfo -> presenceStatus == BUDDY_OFFLINE )
    {
        LOG(( RTC_TRACE, "%s - user appearing offline. dont send NOTIFY: %p",
            __fxName, this ));
        
        return S_OK;
    }

    pOutgoingNotifyTransaction =
        new OUTGOING_NOTIFY_TRANSACTION(
                this, SIP_METHOD_NOTIFY,
                GetNewCSeqForRequest(),
                AuthHeaderSent,
                FALSE
                );

    if( pOutgoingNotifyTransaction == NULL )
    {
        LOG((RTC_ERROR, "%s - allocating pOutgoingNotifyTransaction failed",
             __fxName));
        return E_OUTOFMEMORY;
    }


    hr = pOutgoingNotifyTransaction->CheckRequestSocketAndSendRequestMsg(
             (m_Transport == SIP_TRANSPORT_UDP) ?
             SIP_TIMER_RETRY_INTERVAL_T1 :
             SIP_TIMER_INTERVAL_AFTER_BYE_SENT_TCP,
             pAuthHeaderElement,
             dwNoOfHeaders,
             NULL, 0,       // Msgbody created only after connection complete
             SIP_CONTENT_TYPE_MSGXPIDF_TEXT,
             sizeof(SIP_CONTENT_TYPE_MSGXPIDF_TEXT)-1
             );
    if(hr != S_OK)
    {
        LOG((RTC_ERROR, "%s CheckRequestSocketAndSendRequestMsg failed %x",
             __fxName, hr));
        pOutgoingNotifyTransaction->OnTransactionDone();
    }

    LOG(( RTC_TRACE, "%s - Exited: %p", __fxName, this ));
    return hr;
}


HRESULT
CSIPWatcher::CreateIncomingSubscribeTransaction(
    IN  SIP_MESSAGE    *pSipMsg,
    IN  ASYNC_SOCKET   *pResponseSocket,
    IN  BOOL            fIsFirstSubscribe 
    )
{
    HRESULT         hr;

    LOG(( RTC_TRACE, "CreateIncomingSubscribeTransaction-Entered" ));

    if( m_fEnforceToTag == TRUE )
    {
        hr = DropRequestIfBadToTag( pSipMsg, pResponseSocket );

        if( hr != S_OK )
        {
            // This reuest has been dropped
            
            LOG(( RTC_ERROR, "To tag in a refrsh SUB is not matching. Ignoring the refresh" ));
            return hr;
        }
    }

    INCOMING_SUBSCRIBE_TRANSACTION *pIncomingSubscribeTransaction
        = new INCOMING_SUBSCRIBE_TRANSACTION(this,
                                          pSipMsg->GetMethodId(),
                                          pSipMsg->GetCSeq(),
                                          fIsFirstSubscribe );
    
    if( pIncomingSubscribeTransaction == NULL )
    {
        LOG(( RTC_ERROR, "GetWatcherShutdownData- could not alloc sub transaction" ));
        return E_OUTOFMEMORY;
    }

    // Set the via from the message that we just received
    hr = pIncomingSubscribeTransaction->SetResponseSocketAndVia(
             pSipMsg, pResponseSocket );

    if( hr != S_OK )
    {
        LOG(( RTC_ERROR, "GetWatcherShutdownData- could not set the response socket" ));
        pIncomingSubscribeTransaction->OnTransactionDone();
        return hr;
    }
    
    hr = pIncomingSubscribeTransaction -> ProcessRequest( pSipMsg,
        pResponseSocket );

    // We shouldn't delete the transaction here even if hr is not S_OK.
    // The transaction will delete itself once it is done.
    return hr;
}


HRESULT
CSIPWatcher::OfferWatcher()
{
    SIP_PARTY_INFO  WatcherInfo;
    OFFSET_STRING   DisplayName;
    OFFSET_STRING   AddrSpec;
    OFFSET_STRING   Params;
    ULONG           BytesParsed = 0;
    HRESULT         hr;


    LOG(( RTC_TRACE, "CSIPWatcher::OfferWatcher - Entered" ));
    
    WatcherInfo.PartyContactInfo = NULL;
    
    hr = ParseNameAddrOrAddrSpec(m_Remote, m_RemoteLen, &BytesParsed,
                                 NULL_CHAR, // no header list separator
                                 &DisplayName, &AddrSpec);
    if( hr != S_OK )
        return hr;

    //skip the double qoutes if there are any
    if( (DisplayName.GetLength() > 2) &&
        (*(DisplayName.GetString(m_Remote)) == '"' )
      )
    {
        DisplayName.Length -= 2;
        DisplayName.Offset ++;
    }

    LOG((RTC_TRACE, "Incoming watcher from Display Name: %.*s  URI: %.*s",
         DisplayName.GetLength(),
         DisplayName.GetString(m_Remote),
         AddrSpec.GetLength(),
         AddrSpec.GetString(m_Remote)
         )); 
    WatcherInfo.DisplayName = NULL;
    WatcherInfo.URI         = NULL;

    if( DisplayName.GetLength() != 0 )
    {
        hr = UTF8ToUnicode(DisplayName.GetString(m_Remote),
                           DisplayName.GetLength(),
                           &m_lpwstrFriendlyName
                           );
        if( hr != S_OK )
        {
            return hr;
        }

        WatcherInfo.DisplayName = m_lpwstrFriendlyName;
    }
        
    if( AddrSpec.GetLength() != 0 )
    {
        hr = UTF8ToUnicode(AddrSpec.GetString(m_Remote),
                           AddrSpec.GetLength(),
                           &m_lpwstrPresentityURI
                           );
        if( hr != S_OK )
        {
            return hr;
        }
        
        WatcherInfo.URI = m_lpwstrPresentityURI;

        m_pstrPresentityURI = new CHAR[ AddrSpec.GetLength() + 1 ];

        if( m_pstrPresentityURI == NULL )
        {
            LOG(( RTC_ERROR, "OfferWatcher-could not alloc presentity URI" ));
            return E_OUTOFMEMORY;
        }

        CopyMemory( (PVOID)m_pstrPresentityURI, 
            AddrSpec.GetString(m_Remote), AddrSpec.GetLength() );

        m_pstrPresentityURI[ AddrSpec.GetLength() ] = '\0';
    }

    if( m_WatcherSipUrl != NULL )
    {
        WatcherInfo.PartyContactInfo = m_WatcherSipUrl;
    }

    hr = m_pSipStack -> OfferWatcher( this, &WatcherInfo );

    return hr;
}


void
CSIPWatcher::EncodeXMLBlob(
    OUT PSTR    pstrXMLBlob,
    OUT DWORD&  dwBlobLen,
    IN  SIP_PRESENCE_INFO * pPresenceInfo
    )
{
    PSTR    LocalContact;
    DWORD   LocalContactLen;
    CHAR    ch;

    //encode the XML version header.
    dwBlobLen += sprintf( &pstrXMLBlob[dwBlobLen], XMLVER_TAG1_TEXT );
    
    //encode the DOCTYPE tag.
    dwBlobLen += sprintf( &pstrXMLBlob[dwBlobLen], DOCTYPE_TAG1_TEXT );
    
    //encode the presence tag.
    dwBlobLen += sprintf( &pstrXMLBlob[dwBlobLen], PRESENCE_TAG1_TEXT );
    
    //encode the presentity tag.
    dwBlobLen += sprintf( &pstrXMLBlob[dwBlobLen], PRESENTITY_TAG1_TEXT, 
        m_pstrPresentityURI );
    
    //encode the atomid tag.
    dwBlobLen += sprintf( &pstrXMLBlob[dwBlobLen], ATOMID_TAG1_TEXT, 
        m_pSipStack -> GetPresenceAtomID() );
    

    GetContactURI( &LocalContact, &LocalContactLen );
    ch = LocalContact[LocalContactLen];
    LocalContact[LocalContactLen] = NULL_CHAR;

    //encode the addressuri tag for IP address.
    dwBlobLen += sprintf( &pstrXMLBlob[dwBlobLen], ADDRESSURI_TAG_TEXT,
        LocalContact, USER_IP, 0.8 );

    LocalContact[LocalContactLen] = ch;

    //encode the status tag for IP address.
    dwBlobLen += sprintf( &pstrXMLBlob[dwBlobLen], STATUS_TAG1_TEXT,
        GetTextFromStatus( pPresenceInfo->activeStatus) );
    
    //encode the MSN substatus tag for IP address.
    if( pPresenceInfo->activeMsnSubstatus != MSN_SUBSTATUS_UNKNOWN )
    {
        dwBlobLen += sprintf( &pstrXMLBlob[dwBlobLen], MSNSUBSTATUS_TAG1_TEXT,
            GetTextFromMsnSubstatus( pPresenceInfo->activeMsnSubstatus ) );
    }
    
    //encode the IM feature tag for IP address.
    if( pPresenceInfo->IMAcceptnce != IM_ACCEPTANCE_STATUS_UNKNOWN )
    {
        dwBlobLen += sprintf( &pstrXMLBlob[dwBlobLen], FEATURE_TAG1_TEXT,
            GetTextFromIMFeature( pPresenceInfo->IMAcceptnce ) );
    }

    //encode the appsharing feature tag for IP address.
    if( pPresenceInfo->appsharingStatus != APPSHARING_ACCEPTANCE_STATUS_UNKNOWN )
    {
        dwBlobLen += sprintf( &pstrXMLBlob[dwBlobLen], FEATURE_TAG1_TEXT,
            GetTextFromASFeature( pPresenceInfo->appsharingStatus ) );
    }
    
    //encode the sipcall feature tag for IP address.
    if( pPresenceInfo->sipCallAcceptance != SIPCALL_ACCEPTANCE_STATUS_UNKNOWN )
    {
        dwBlobLen += sprintf( &pstrXMLBlob[dwBlobLen], FEATURE_TAG1_TEXT,
            GetTextFromMMFeature( pPresenceInfo->sipCallAcceptance ) );
    }

    //encode the special note for IP address.
    if( pPresenceInfo->pstrSpecialNote[0] != NULL_CHAR )
    {
        dwBlobLen += sprintf( &pstrXMLBlob[dwBlobLen], NOTE_TAG1_TEXT, 
            pPresenceInfo->pstrSpecialNote );
    }
    
    //encode address closure.
    dwBlobLen += sprintf( &pstrXMLBlob[dwBlobLen], ADDRESS_END_TAG1_TEXT );
    
    //encode legacy phone number.

    if( pPresenceInfo->phonesAvailableStatus.fLegacyPhoneAvailable == TRUE )
    {
        //encode the addressuri tag for legacy phone.
        dwBlobLen += sprintf( &pstrXMLBlob[dwBlobLen], ADDRESSURI_TAG_TEXT,
            pPresenceInfo->phonesAvailableStatus.pstrLegacyPhoneNumber, USER_PHONE, 0.2 );
    
        //encode the status tag for legacy phone.
        dwBlobLen += sprintf( &pstrXMLBlob[dwBlobLen], STATUS_TAG1_TEXT,
             ACTIVE_STATUS_TEXT );
    
        //encode address closure.
        dwBlobLen += sprintf( &pstrXMLBlob[dwBlobLen], ADDRESS_END_TAG1_TEXT );
    }

    //encode cell phone number.

    if( pPresenceInfo->phonesAvailableStatus.fCellPhoneAvailable == TRUE )
    {
        //encode the addressuri tag for cell phone.
        dwBlobLen += sprintf( &pstrXMLBlob[dwBlobLen], ADDRESSURI_TAG_TEXT,
            pPresenceInfo->phonesAvailableStatus.pstrCellPhoneNumber, USER_PHONE, 0.1 );
    
        //encode the status tag for legacy phone.
        dwBlobLen += sprintf( &pstrXMLBlob[dwBlobLen], STATUS_TAG1_TEXT,
             ACTIVE_STATUS_TEXT );
    
        //encode address closure.
        dwBlobLen += sprintf( &pstrXMLBlob[dwBlobLen], ADDRESS_END_TAG1_TEXT );
    }
    
    //encode atom closure.
    dwBlobLen += sprintf( &pstrXMLBlob[dwBlobLen], ATOMEND_TAG1_TEXT );
    
    //encode presence closure.
    dwBlobLen += sprintf( &pstrXMLBlob[dwBlobLen], PRESENCE_END_TAG1_TEXT );
    
    return;
}


VOID
CSIPWatcher::InitiateWatcherTerminationOnError(
    IN ULONG StatusCode
    )
{
    ENTER_FUNCTION("CSIPWatcher::InitiateWatcherTerminationOnError");
    
    LOG(( RTC_TRACE, "%s - Entered: %p", __fxName, this ));
    
    HRESULT hr;
    if( m_WatcherState == WATCHER_STATE_UNSUBSCRIBED )
    {
        // do nothing
        return;
    }
    
    // Create a UNSUB transaction
    hr = CreateOutgoingUnsub( FALSE, NULL, 0 );
    if (hr != S_OK)
    {
        LOG(( RTC_ERROR, "CreateOutgoingUnsub failed %x", hr ));
    }

    WatcherDropped();
}


BOOL
CSIPWatcher::IsSessionDisconnected()
{
    return( (m_WatcherState == WATCHER_STATE_DROPPED) ||
            (m_WatcherState == WATCHER_STATE_UNSUBSCRIBED) );
}


HRESULT
CSIPWatcher::OnDeregister(
    SIP_PROVIDER_ID    *pProviderID
    )
{
    LOG(( RTC_TRACE, "CSIPWatcher::OnDeregister - Entered" ));

    //
    // If we are appearing offline then send the
    // NOTIFY:0 to all the unblocked watchers.
    //
    if( IsSessionDisconnected() == FALSE )
    {
        if( m_BlockedStatus == WATCHER_UNBLOCKED )
        {
            m_WatcherState = WATCHER_STATE_ACCEPTED;
        }
    }

    // Create a UNSUB transaction
    CreateOutgoingUnsub( FALSE, NULL, 0 );

    WatcherDropped();
    
    LOG(( RTC_TRACE, "CSIPWatcher::OnDeregister - Exited" ));
    
    return S_OK;
}


HRESULT 
CSIPWatcher::OnIpAddressChange()
{    
    HRESULT hr;

    LOG(( RTC_TRACE, "CSIPWatcher::OnIpAddressChange - Entered" ));
    
    hr = CheckListenAddrIntact();
    if( hr == S_OK )
    {
        // Nothing needs to be done.
        LOG(( RTC_TRACE, "Watcher-OnIpAddressChange-Local IP address still valid." ));
        return hr;
    }

    //
    // The IP address sent to the watcher machine is no longer valid
    // drop the session and let the core create a new session.
    //

    CreateOutgoingUnsub( FALSE, NULL, 0 );
        
    WatcherDropped();

    LOG(( RTC_TRACE, "CSIPWatcher::OnIpAddressChange - Exited" ));    
    return S_OK;
}


//
// Functions of SIP_STACK not exposed to the Applocation.
//

HRESULT
SIP_STACK::AcceptWatcher(
    IN  CSIPWatcher * pSIPWatcher
    )
{
    INT     iWatcherIndex;
    BOOL    fResult;

    iWatcherIndex = m_SipOfferingWatcherList.Find( pSIPWatcher );

    if( iWatcherIndex == -1 )
    {
        LOG(( RTC_ERROR, "AcceptWatcher - Watcher not found in the list" ));
        return E_INVALIDARG;
    }
    
    fResult = m_SipWatcherList.Add( pSIPWatcher );
    if( fResult == FALSE )
    {
        LOG(( RTC_ERROR, "AcceptWatcher - Watcher list add failed" ));
        return E_OUTOFMEMORY;
    }

    m_SipOfferingWatcherList.RemoveAt( iWatcherIndex );
    return S_OK;
}


HRESULT
SIP_STACK::RejectWatcher(
    IN  CSIPWatcher * pSIPWatcher
    )
{
    INT     iWatcherIndex;
    BOOL    fResult;

    iWatcherIndex = m_SipOfferingWatcherList.Find( pSIPWatcher );

    if( iWatcherIndex == -1 )
    {
        LOG(( RTC_ERROR, "RejectWatcher - Watcher not found in the list" ));
        return E_INVALIDARG;
    }
    
    fResult = m_SipWatcherList.Add( pSIPWatcher );
    if( fResult == FALSE )
    {
        LOG(( RTC_ERROR, "RejectWatcher - Watcher add to list failed" ));
        return E_OUTOFMEMORY;
    }

    m_SipOfferingWatcherList.RemoveAt( iWatcherIndex );

    return S_OK;
}


BOOL
SIP_STACK::IsWatcherAllowed(
    IN  SIP_MESSAGE    *pSipMessage
    )
{
    
    return TRUE; //(m_LocalPresenceInfo.presenceStatus == BUDDY_ONLINE);
}


HRESULT
SIP_STACK::OfferWatcher(
    IN  CSIPWatcher    *pSipWatcher,
    IN  SIP_PARTY_INFO *pWatcherInfo
    )
{
    HRESULT hr = S_OK;

    ENTER_FUNCTION("SIP_STACK::OfferWatcher");
    ASSERTMSG("SetNotifyInterface has to be called", m_pNotifyInterface);

    if (m_pNotifyInterface == NULL)
    {
        LOG((RTC_ERROR, "%s - m_pNotifyInterface is NULL", __fxName));
        return E_FAIL;
    }
    
    hr = m_pNotifyInterface->OfferWatcher( 
        static_cast<ISIPWatcher*> (pSipWatcher), pWatcherInfo );
    
    if( hr != S_OK )
    {
        LOG(( RTC_ERROR, "OfferWatcher returned error 0x%x", hr ));
    }

    return hr;
}


HRESULT
SIP_STACK::CreateIncomingWatcher(
    IN  SIP_TRANSPORT   Transport,
    IN  SIP_MESSAGE    *pSipMsg,
    IN  ASYNC_SOCKET   *pResponseSocket
    )
{
    HRESULT         hr;
    CSIPWatcher    *pSipWatcher;
    INT             iIndex;

    LOG(( RTC_TRACE, "SIP_STACK::CreateIncomingWatcher - Entered" ));

    pSipWatcher = new CSIPWatcher( this );
    
    if( pSipWatcher == NULL )
    {
        LOG(( RTC_ERROR, "CreateIncomingWatcher - Watcher aloc failed" ));
        return E_OUTOFMEMORY;
    }

    // Add the watcher object to the offered list.
    iIndex = m_SipOfferingWatcherList.Add( pSipWatcher );
    
    if( iIndex == -1 )
    {
        LOG(( RTC_ERROR, "CreateIncomingWatcher - Watcher add to list failed" ));
        delete pSipWatcher;
        return E_OUTOFMEMORY;
    }

    hr = pSipWatcher -> StartIncomingWatcher( Transport, pSipMsg,
        pResponseSocket );

    if( hr != S_OK )
    {
        m_SipOfferingWatcherList.Remove( pSipWatcher );

        // Release our reference.
        pSipWatcher->Release();
        return hr;
    }

    // We create the watcher with a ref count of 1
    // At this point the core should have addref'ed the watcher
    // and we can release our reference.
    pSipWatcher->Release();
    return S_OK;
}

//
//
//Incoming SUBSCRIBE Transaction
//
//


INCOMING_SUBSCRIBE_TRANSACTION::INCOMING_SUBSCRIBE_TRANSACTION(
    IN  CSIPWatcher    *pSipWatcher,
    IN  SIP_METHOD_ENUM MethodId,
    IN  ULONG           CSeq,
    IN  BOOL            fIsFirstSubscribe 
    ) :
    INCOMING_TRANSACTION( pSipWatcher, MethodId, CSeq )
{
    m_pSipWatcher           = pSipWatcher;
    m_pProvResponseBuffer   = NULL;
    m_fIsFirstSubscribe     = fIsFirstSubscribe;
}

    
INCOMING_SUBSCRIBE_TRANSACTION::~INCOMING_SUBSCRIBE_TRANSACTION()
{
    // kill the timer if its running

    if (m_pProvResponseBuffer != NULL)
    {
        m_pProvResponseBuffer->Release();
        m_pProvResponseBuffer = NULL;
    }

    LOG(( RTC_TRACE, "INCOMING_SUBSCRIBE_TRANSACTION:%p deleted", this ));
}


HRESULT
INCOMING_SUBSCRIBE_TRANSACTION::RetransmitResponse()
{
    DWORD dwError;
    
    // Send the buffer.
    dwError = m_pResponseSocket->Send( m_pResponseBuffer );
    
    if( dwError != NO_ERROR && dwError != WSAEWOULDBLOCK )
    {
        LOG(( RTC_ERROR, "INCOMING_SUBSCRIBE_TRANSACTION- retransmit failed" ));
        return HRESULT_FROM_WIN32( dwError );
    }

    return S_OK;
}

HRESULT
INCOMING_SUBSCRIBE_TRANSACTION::GetExpiresHeader(
    SIP_HEADER_ARRAY_ELEMENT   *pHeaderElement,
    DWORD                       dwExpires
    )
{
    pHeaderElement->HeaderId = SIP_HEADER_EXPIRES;

    pHeaderElement->HeaderValue = new CHAR[ 10 ];

    if( pHeaderElement->HeaderValue == NULL )
    {
        return E_OUTOFMEMORY;
    }

    _ultoa( dwExpires, pHeaderElement->HeaderValue, 10 );

    pHeaderElement->HeaderValueLen = 
        strlen( pHeaderElement->HeaderValue );
    
    return S_OK;
}


HRESULT
INCOMING_SUBSCRIBE_TRANSACTION::ProcessRequest(
    IN SIP_MESSAGE  *pSipMsg,
    IN ASYNC_SOCKET *pResponseSocket
    )
{
    HRESULT                         hr = S_OK;
    DWORD                           Error;
    INCOMING_SUBSCRIBE_TRANSACTION *pIncomingSub;
    INT                             ExpireTimeout;
    SIP_HEADER_ARRAY_ELEMENT        HeaderElement;

    ASSERT( pSipMsg->MsgType == SIP_MESSAGE_TYPE_REQUEST );
    ASSERT( pSipMsg->Request.MethodId == SIP_METHOD_SUBSCRIBE );
    ENTER_FUNCTION("INCOMING_SUBSCRIBE_TRANSACTION::ProcessRequest");
    
    LOG(( RTC_TRACE, "INCOMING_SUBSCRIBE_TRANSACTION::ProcessRequest - Entered" ));
    
    switch (m_State)
    {
    case INCOMING_TRANS_INIT:

        m_State = INCOMING_TRANS_REQUEST_RCVD;
        
        ExpireTimeout = pSipMsg -> GetExpireTimeoutFromResponse(
                    NULL, 0, SUBSCRIBE_DEFAULT_TIMER );

        if( ExpireTimeout == -1 )
        {
            ExpireTimeout = 3600;
        }
        else if( ExpireTimeout != 0 )
        {
            // We knocked off ten minutes, so add them back.
            ExpireTimeout += TEN_MINUTES;
        }

        //Get expires header
        hr = GetExpiresHeader( &HeaderElement, ExpireTimeout );
        if( hr != S_OK )
        {
            LOG(( RTC_ERROR, "INCOMING_SUBSCRIBE_TRANSACTION::ProcessRequest"
                "- alloc expire header failes" ));

            OnTransactionDone();
            return hr;
        }

        hr = ProcessRecordRouteContactAndFromHeadersInRequest( pSipMsg );
            
        if( (ExpireTimeout != 0) && m_pSipWatcher ->IsSessionDisconnected() )
        {
            LOG(( RTC_ERROR, "INCOMING_SUBSCRIBE_TRANSACTION::ProcessRequest"
                "session already dropped. sending 481" ));
            
            hr = CreateAndSendResponseMsg(481,
                         SIP_STATUS_TEXT(481),
                         SIP_STATUS_TEXT_SIZE(481),
                         NULL,
                         TRUE,
                         NULL, 0,           //No presence information.
                         NULL, 0,           // No content Type
                         &HeaderElement, 1  //Expires header
                         );
        }
        else
        {
            //Send an immediate 200 response
            hr = CreateAndSendResponseMsg(200,
                         SIP_STATUS_TEXT(200),
                         SIP_STATUS_TEXT_SIZE(200),
                         NULL,
                         TRUE,
                         NULL, 0,            //No presence information.
                         NULL, 0,            // No content Type
                         &HeaderElement, 1  //Expires header
                         );
        }

        free( HeaderElement.HeaderValue );

        if( hr != S_OK )
        {
            LOG((RTC_ERROR, "%s CreateAndSendResponseMsg failed", __fxName));
            OnTransactionDone();
            return hr;
        }
        
        m_State = INCOMING_TRANS_FINAL_RESPONSE_SENT;

        // Dont handle the request if the session is disconnected
        if( m_pSipWatcher -> IsSessionDisconnected() == FALSE )
        {
            m_pSipWatcher -> HandleSuccessfulSubscribe( ExpireTimeout );
        }

        hr = StartTimer(SIP_TIMER_MAX_INTERVAL);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s StartTimer failed", __fxName));
            OnTransactionDone();
            return hr;
        }

        break;
        
    case INCOMING_TRANS_REQUEST_RCVD:
        
        //Send an immediate 200 response
        hr = CreateAndSendResponseMsg(200,
                     SIP_STATUS_TEXT(200),
                     SIP_STATUS_TEXT_SIZE(200),
                     NULL,
                     TRUE, 
                     NULL, 0,    //No presence information.
                     NULL, 0 // No content Type
                     );
        if( hr != S_OK )
        {
            LOG((RTC_ERROR, "%s CreateAndSendResponseMsg failed", __fxName));
            OnTransactionDone();
            return hr;
        }
        m_State = INCOMING_TRANS_FINAL_RESPONSE_SENT;
        break;

    case INCOMING_TRANS_FINAL_RESPONSE_SENT:
        
        // Retransmit the response
        LOG(( RTC_TRACE, "retransmitting final response" ));
        
        hr = RetransmitResponse();
        
        if( hr != S_OK )
        {
            LOG((RTC_ERROR, "%s RetransmitResponse failed", __fxName));
            OnTransactionDone();
            return hr;
        }
        
        break;
        
    case INCOMING_TRANS_ACK_RCVD:
    default:
        
        ASSERT(FALSE);
        return E_FAIL;
    }

    return hr;
}


HRESULT
INCOMING_SUBSCRIBE_TRANSACTION::TerminateTransactionOnByeOrCancel(
    OUT BOOL *pCallDisconnected
    )
{
    // Do nothing.
    return S_OK;
}


VOID
INCOMING_SUBSCRIBE_TRANSACTION::TerminateTransactionOnError(
    IN HRESULT      hr
    )
{
    CSIPWatcher    *pSipWatcher = NULL;
    BOOL            IsFirstSubscribe;

    ENTER_FUNCTION("INCOMING_SUBSCRIBE_TRANSACTION::TerminateTransactionOnError");
    LOG((RTC_TRACE, "%s - enter", __fxName));

    pSipWatcher = m_pSipWatcher;
    // Deleting the transaction could result in the
    // buddy being deleted. So, we AddRef() it to keep it alive.
    pSipWatcher -> AddRef();
    
    IsFirstSubscribe = m_fIsFirstSubscribe;
    
    // Delete the transaction before you call
    // InitiateCallTerminationOnError as that call will notify the UI
    // and could get stuck till the dialog box returns.
    OnTransactionDone();
    
    if( IsFirstSubscribe )
    {
        // Terminate the call
        pSipWatcher -> InitiateWatcherTerminationOnError( 0 );
    }
    
    pSipWatcher -> Release();
}


VOID
INCOMING_SUBSCRIBE_TRANSACTION::OnTimerExpire()
{
    HRESULT   hr;

    ENTER_FUNCTION("INCOMING_SUBSCRIBE_TRANSACTION::OnTimerExpire");
    LOG(( RTC_TRACE, "%s- Entered", __fxName ));

    switch (m_State)
    {
    case INCOMING_TRANS_FINAL_RESPONSE_SENT:
        // Transaction done - delete the transaction
        // The timer in this state is just to keep the transaction
        // alive in order to retransmit the response when we receive a
        // retransmit of the request.
        LOG((RTC_TRACE,
             "%s deleting transaction after timeout for request retransmits",
             __fxName));
        OnTransactionDone();

        break;
        
        // No timers in these states
    case INCOMING_TRANS_INIT:
    case INCOMING_TRANS_REQUEST_RCVD:
    case INCOMING_TRANS_ACK_RCVD:
    default:
        ASSERT(FALSE);
        break;
    }

    return;
}


//
//
// OUTGOING_NOTIFY_TRANSACTION
//
//

OUTGOING_NOTIFY_TRANSACTION::OUTGOING_NOTIFY_TRANSACTION(
    IN  CSIPWatcher    *pSipWatcher,
    IN  SIP_METHOD_ENUM MethodId,
    IN  ULONG           CSeq,
    IN  BOOL            AuthHeaderSent,
    IN  BOOL            fIsUnsubNotify
    ) :
    OUTGOING_TRANSACTION(pSipWatcher, MethodId, CSeq, AuthHeaderSent )
{
    m_pSipWatcher = pSipWatcher;
    m_fIsUnsubNotify = fIsUnsubNotify;
}


// We create the XML blob only after the connection to the destination
// is complete as the XML blob contains local address information.
HRESULT
OUTGOING_NOTIFY_TRANSACTION::GetAndStoreMsgBodyForRequest()
{
    ENTER_FUNCTION("OUTGOING_NOTIFY_TRANSACTION::GetAndStoreMsgBodyForRequest");
    LOG(( RTC_TRACE, "%s- Entered", __fxName ));
    
    HRESULT             hr;
    SIP_PRESENCE_INFO  *pLocalPresenceInfo;

    if( m_fIsUnsubNotify == TRUE )
    {
        // NO message body for Unsub NOTIFY
        return S_OK;
    }

    ASSERT(m_pSipWatcher != NULL);
    
    pLocalPresenceInfo = m_pSipWatcher -> GetSipStack() -> GetLocalPresenceInfo();

    PSTR    presentityURI = m_pSipWatcher->GetPresentityURIA();
    ULONG   presentityURILen = 0;

    if( presentityURI != NULL )
    {
        presentityURILen = strlen(presentityURI);
    }

    //
    // 500 bytes for all the tags in the XML
    //
    m_szMsgBody = (PSTR) malloc(
        sizeof(SIP_PRESENCE_INFO) + 
        m_pSipMsgProc->GetLocalContactLen() +
        presentityURILen +
        500 );

    if (m_szMsgBody == NULL)
    {
        LOG((RTC_ERROR, "%s ", __fxName));
    }

    m_MsgBodyLen = 0;
    
    // Encode the presence document.
    m_pSipWatcher->EncodeXMLBlob( m_szMsgBody, m_MsgBodyLen, pLocalPresenceInfo );
    
    return S_OK;
}


HRESULT
OUTGOING_NOTIFY_TRANSACTION::ProcessProvisionalResponse(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT hr = S_OK;
    
    ENTER_FUNCTION("OUTGOING_NOTIFY_TRANSACTION::ProcessProvisionalResponse");
    LOG(( RTC_TRACE, "%s- Entered", __fxName ));
    
    if( m_State != OUTGOING_TRANS_FINAL_RESPONSE_RCVD )
    {
        m_State = OUTGOING_TRANS_PROVISIONAL_RESPONSE_RCVD;
        
        // Cancel existing timer and Start Timer
        KillTimer();
        
        hr = StartTimer(SIP_TIMER_RETRY_INTERVAL_T2);
    }

    // Ignore the Provisional response if a final response
    // has already been received.
    
    return hr;
}


HRESULT
OUTGOING_NOTIFY_TRANSACTION::ProcessFinalResponse(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT hr;
    BOOL    fDelete = TRUE;
    
    ENTER_FUNCTION("OUTGOING_NOTIFY_TRANSACTION::ProcessFinalResponse");
    LOG(( RTC_TRACE, "%s- Entered", __fxName ));
    
    if( m_State != OUTGOING_TRANS_FINAL_RESPONSE_RCVD )
    {
        // This refcount must be released before returning from this function 
        // without any exception. Only in case of kerberos we keep this refcount.
        TransactionAddRef();

        OnTransactionDone();

        m_State = OUTGOING_TRANS_FINAL_RESPONSE_RCVD;

        // If its UNSUB-NOTIFY then retry for auth failure.
        if( (m_fIsUnsubNotify == FALSE) && 
            m_pSipWatcher -> IsSessionDisconnected() )
        {
            TransactionRelease();
            return S_OK;
        }

        //
        // This means the watcher machine has seen at least one NOTIFY from 
        // this endpoint. So now the To tag should be enforced. All 
        // subsequent SUBSCRIBEs should have proper To tag.
        //

        if( IsSuccessfulResponse(pSipMsg) )
        {
            LOG((RTC_TRACE, "received successful response : %d",
                pSipMsg->GetStatusCode()));

            //m_pSipWatcher -> SetEnforceToTag( TRUE );
        }
        else if( IsFailureResponse(pSipMsg) )
        {
            // Do not drop the session. If the watcher machine does'nt like our
            // NOTIFY messages it would recreate the session itself. Sending 
            // automatic UNSUBs from the buddy machine could get us into loops
            
            hr = ProcessFailureResponse( pSipMsg );
        }
        else if( IsAuthRequiredResponse(pSipMsg) )
        {
            hr = ProcessAuthRequiredResponse( pSipMsg, fDelete );
        }
        else if( IsRedirectResponse(pSipMsg) )
        {
            LOG((RTC_TRACE, "received non-200 %d", pSipMsg->GetStatusCode() ));
        }
        
        // The OnTransactionDone kills the timer.
        // KillTimer();

        if( fDelete )
        {
            TransactionRelease();
        }
    }

    return S_OK;
}


//
// Resend the NOTIFY message if the CSeq value is lower than expected.
// This would make sure we recover from the crash scenario
//

HRESULT
OUTGOING_NOTIFY_TRANSACTION::ProcessFailureResponse(
    IN  SIP_MESSAGE *pSipMsg
    )
{
    PARSED_BADHEADERINFO    ParsedBadHeaderInfo;
    LONG                    ExpectedCSeqValue = 0;
    HRESULT                 hr = S_OK;
    SIP_HEADER_ENTRY       *pHeaderEntry = NULL;
    ULONG                   NumHeaders = 0;
    CHAR                    ExpectedValueBuf[25];
    ULONG                   HeaderLen = 0;
    PSTR                    HeaderValue = NULL;
    PLIST_ENTRY             pListEntry = NULL;
    ULONG                   i;


    if( pSipMsg->GetStatusCode() == 400 )
    {
        //Check if it has a bad-cseq header
        hr = pSipMsg -> GetHeader( SIP_HEADER_BADHEADERINFO, 
            &pHeaderEntry, &NumHeaders );

        if (hr != S_OK)
        {
            LOG(( RTC_TRACE, "Couldn't find BadHeaderInfo header in msg %x", hr ));
            return S_OK;
        }

        pListEntry = (LIST_ENTRY *)
            (pHeaderEntry + FIELD_OFFSET(SIP_HEADER_ENTRY, ListEntry) );

        for( i = 0; i < NumHeaders; i++ )
        {
            pHeaderEntry = CONTAINING_RECORD(pListEntry,
                                             SIP_HEADER_ENTRY,
                                             ListEntry);
    
            HeaderLen   = pHeaderEntry->HeaderValue.Length;
            HeaderValue = pHeaderEntry->HeaderValue.GetString( pSipMsg->BaseBuffer );

            hr = ParseBadHeaderInfo( HeaderValue, HeaderLen,
                &ParsedBadHeaderInfo );
            
            if( hr == S_OK )
            {
                if( ParsedBadHeaderInfo.HeaderId == SIP_HEADER_CSEQ )
                {
                    // CSeq value can be 10 digit long and 2 quotes
                    if( ParsedBadHeaderInfo.ExpectedValue.Length <= 12 )
                    {
                        sprintf( ExpectedValueBuf, "%.*s",
                            ParsedBadHeaderInfo.ExpectedValue.Length -2,
                            ParsedBadHeaderInfo.ExpectedValue.GetString(HeaderValue) + 1 );
                    }
                    
                    ExpectedCSeqValue = atoi( ExpectedValueBuf );
                    break;
                }
            }

            pListEntry = pListEntry -> Flink;
        }
   
        if( (ExpectedCSeqValue > 0) && 
            ((ULONG)ExpectedCSeqValue > m_pSipWatcher -> GetLocalCSeq()) )
        {
            //
            // When we create the transaction we increment the local
            // CSeq value. So set the value to 1 less than expected.
            //
            m_pSipWatcher -> SetLocalCSeq( ExpectedCSeqValue - 1 );

            if( m_fIsUnsubNotify == TRUE )
            {
                hr = m_pSipWatcher -> CreateOutgoingUnsub( FALSE, NULL, 0 );
            }
            else
            {
                hr = m_pSipWatcher -> CreateOutgoingNotify( FALSE, NULL, 0 );
            }
            
            if( hr != S_OK )
            {
                return hr;
            }
        }
    }

    return S_OK;
}


HRESULT
OUTGOING_NOTIFY_TRANSACTION::ProcessAuthRequiredResponse(
    IN  SIP_MESSAGE *pSipMsg,
    OUT BOOL        &fDelete
    )
{
    HRESULT                     hr;
    SIP_HEADER_ARRAY_ELEMENT    SipHdrElement;
    SECURITY_CHALLENGE          SecurityChallenge;
    REGISTER_CONTEXT           *pRegisterContext;

    ENTER_FUNCTION("OUTGOING_NOTIFY_TRANSACTION::ProcessAuthRequiredResponse");
    LOG(( RTC_TRACE, "%s- Entered", __fxName ));

    // We need to addref the transaction as we could show credentials UI.
    TransactionAddRef();

    hr = ProcessAuthRequired(pSipMsg,
                             TRUE,          // Show Credentials UI if necessary
                             &SipHdrElement,
                             &SecurityChallenge );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - ProcessAuthRequired failed %x",
             __fxName, hr));
        goto done;
    }

    if( m_fIsUnsubNotify == TRUE )
    {
        m_pSipWatcher -> CreateOutgoingUnsub( TRUE, &SipHdrElement, 1 );
    }
    else
    {
        m_pSipWatcher -> CreateOutgoingNotify( TRUE, &SipHdrElement, 1 );
    }

    free(SipHdrElement.HeaderValue);
    
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - CreateOutgoingNotify failed %x",
             __fxName, hr));
        goto done;
    }

    hr = S_OK;

done:

    TransactionRelease();
    return hr;

}


HRESULT
OUTGOING_NOTIFY_TRANSACTION::ProcessResponse(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT hr;
    
    ASSERT( pSipMsg->MsgType == SIP_MESSAGE_TYPE_RESPONSE );

    if( IsProvisionalResponse(pSipMsg) )
    {
        return ProcessProvisionalResponse(pSipMsg);
    }
    else if( IsFinalResponse(pSipMsg) )
    {
        return ProcessFinalResponse(pSipMsg);
    }
    else
    {
        ASSERT(FALSE);
        return E_FAIL;
    }
}


BOOL
OUTGOING_NOTIFY_TRANSACTION::MaxRetransmitsDone()
{
    return (m_pSipWatcher->GetTransport() != SIP_TRANSPORT_UDP ||
            m_NumRetries >= 11);
}


VOID
OUTGOING_NOTIFY_TRANSACTION::OnTimerExpire()
{
    HRESULT   hr;
    

    //
    // If its UNSUB-NOTIFY then keep retransmitting even if the session is dead
    //
    if( (m_fIsUnsubNotify == FALSE) && m_pSipWatcher -> IsSessionDisconnected() )
    {
        //If the session is already dead kill the transaction
        OnTransactionDone();
        return;
    }

    switch( m_State )
    {
        // we have to retransmit the request even after receiving
        // a provisional response.
    case OUTGOING_TRANS_REQUEST_SENT:
    case OUTGOING_TRANS_PROVISIONAL_RESPONSE_RCVD:
        
        // Retransmit the request
        if( MaxRetransmitsDone() )
        {
            LOG((RTC_ERROR,
                 "MaxRetransmits for request Done terminating transaction" ));
            
            goto error;
        }
        else
        {
            LOG((RTC_TRACE, "retransmitting request m_NumRetries : %d", 
                m_NumRetries));
            
            hr = RetransmitRequest();
            
            if( hr != S_OK )
            {
                goto error;
            }

            if (m_TimerValue*2 >= SIP_TIMER_RETRY_INTERVAL_T2)
            {
                m_TimerValue = SIP_TIMER_RETRY_INTERVAL_T2;
            }
            else
            {
                m_TimerValue *= 2;
            }

            hr = StartTimer(m_TimerValue);
            if( hr != S_OK )
            {
                goto error;
            }
        }
        break;

    case OUTGOING_TRANS_INIT:
    case OUTGOING_TRANS_FINAL_RESPONSE_RCVD:
    default:
        ASSERT(FALSE);
        return;
    }

    return;

error:

    // Do not drop the session even if the NOTIFY messages could not get
    // through. This could be a temeporary network condition. LEt the refresh
    // timeouts take care of recreating the sessions.

    // delete the transaction.
    OnTransactionDone();
}


//
//Global utility functions
//

BOOL
IsPresenceInfoSame( 
    IN  SIP_PRESENCE_INFO * pPresenceInfoSrc,
    IN  SIP_PRESENCE_INFO * pPresenceInfoDst
    )
{
    return
    (
        ( pPresenceInfoSrc -> presenceStatus == pPresenceInfoDst -> presenceStatus )        &&
        ( pPresenceInfoSrc -> activeStatus == pPresenceInfoDst -> activeStatus )            &&
        ( pPresenceInfoSrc -> activeMsnSubstatus == pPresenceInfoDst -> activeMsnSubstatus )&&
        ( pPresenceInfoSrc -> sipCallAcceptance == pPresenceInfoDst -> sipCallAcceptance )  &&
        ( pPresenceInfoSrc -> IMAcceptnce == pPresenceInfoDst -> IMAcceptnce )              &&
        ( pPresenceInfoSrc -> phonesAvailableStatus.fLegacyPhoneAvailable == 
            pPresenceInfoDst -> phonesAvailableStatus.fLegacyPhoneAvailable )               &&
        ( pPresenceInfoSrc -> phonesAvailableStatus.fCellPhoneAvailable == 
            pPresenceInfoDst -> phonesAvailableStatus.fCellPhoneAvailable )                 &&
        !strcmp( pPresenceInfoSrc -> phonesAvailableStatus.pstrLegacyPhoneNumber, 
            pPresenceInfoDst -> phonesAvailableStatus.pstrLegacyPhoneNumber )               &&
        !strcmp( pPresenceInfoSrc -> phonesAvailableStatus.pstrCellPhoneNumber, 
            pPresenceInfoDst -> phonesAvailableStatus.pstrCellPhoneNumber )                 &&
        !memcmp(pPresenceInfoSrc->pstrSpecialNote, 
            pPresenceInfoDst->pstrSpecialNote,  sizeof(pPresenceInfoDst->pstrSpecialNote))

    );

}


PSTR
GetTextFromStatus( 
    IN  ACTIVE_STATUS activeStatus 
    )
{
    static  PSTR    pstr[4] = { "open", 
                                "open",
                                "inactive", 
                                "inuse"
                              };
    
    return pstr[activeStatus];
}

PSTR
GetTextFromMsnSubstatus( 
    IN  ACTIVE_MSN_SUBSTATUS activeMsnSubstatus 
    )
{
    static PSTR   pstr[] = { "unknown",
                             "online",
                             "away",
                             "idle",
                             "busy",
                             "berightback",
                             "onthephone",
                             "outtolunch"
                           };

    return pstr[activeMsnSubstatus];

}


PSTR
GetTextFromASFeature( 
    IN  APPSHARING_ACCEPTANCE_STATUS appsharingStatus 
    )
{
    static  PSTR    pstr[3] = { "unknown",
                                "app-sharing",
                                "no-app-sharing"
                              };
    
    return pstr[appsharingStatus];
}


PSTR
GetTextFromIMFeature( 
    IN  IM_ACCEPTANCE_STATUS    IMAcceptnce 
    )
{
    static  PSTR    pstr[3] = { "unknown",
                                "im",
                                "no-im"
                              };
    
    return pstr[IMAcceptnce];
}


PSTR
GetTextFromMMFeature(
    IN  SIPCALL_ACCEPTANCE_STATUS sipCallAcceptance
    )
{
    static  PSTR    pstr[3] = { "unknown",
                                "multimedia-call",
                                "no-multimedia-call"
                              };
    
    return pstr[sipCallAcceptance];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\presence.h ===
#ifndef __sipcli_presence_h__
#define __sipcli_presence_h__


#define MAX_MISC_INFO_LEN   512

#include  "rtcsip.h"
#include  "sipcall.h"
#include  "pintcall.h"

class   OUTGOING_SUBSCRIBE_TRANSACTION;
class   INCOMING_NOTIFY_TRANSACTION;
class   OUTGOING_UNSUB_TRANSACTION;   
class   INCOMING_SUBSCRIBE_TRANSACTION;
class   OUTGOING_NOTIFY_TRANSACTION;
class   INCOMING_UNSUB_TRANSACTION;
class   REDIRECT_CONTEXT;

enum SIP_BUDDY_STATE
{
    BUDDY_STATE_NONE = 0,
    BUDDY_STATE_REQUEST_SENT = 1, 
    BUDDY_STATE_RESPONSE_RECVD = 2,
    BUDDY_STATE_ACCEPTED = 3,
    BUDDY_STATE_REJECTED = 4,
    BUDDY_STATE_UNSUBSCRIBED = 5,
    BUDDY_STATE_DROPPED = 6,
};


enum SIP_WATCHER_STATE
{
    WATCHER_STATE_NONE = 0,
    WATCHER_STATE_OFFERING      =1, //new session, not yet devided by the core
    WATCHER_STATE_ACCEPTED      =2, //session alive and NOTIFY messages sent
    WATCHER_STATE_REJECTED      =3, //session alive but no NOTIFY messages sent
    WATCHER_STATE_DROPPED       =4, //unsubscribed by the local user
    WATCHER_STATE_UNSUBSCRIBED  =5, //unsubscribed by the watcher himself

};



//
//This enumeration is defines the reason for removing a buddy
//






//The current status of the subscription of the local UA with the buddy is 
//conveyed through this enumeration.





// The presence rule flags defined are:
enum
{

	WATCHER_INFORM_SIPCALL_ACCEPTANCE		= 0x00000001,
    //Presence of this flag in dwPresenceInfoRules indicates that the sip calls
    //would be accepted from this watcher.

	WATCHER_INFORM_IMSESSION_ACCEPTANCE		= 0x00000002,
    //Presence of this flag in dwPresenceInfoRules indicates that the IM 
    //sessions would be accepted from this watcher. The absence of this
    //flag indicates vice versa.


	WATCHER_INFORM_ACTIVE_STATUS			= 0x00000004,
    //Presence of this flag in dwPresenceInfoRules indicates that information
    //about the local user being active at the presentity device will be 
    //conveyed to this watcher. The absence of this flag indicates vice versa.

    WATCHER_INFORM_PHONE_DEVICES			= 0x00000008,
    //Presence of this flag in dwPresenceInfoRules indicates that information
    //about the phone devices that the local user might have access to will be
    //conveyed to this watcher. The absence of this flag indicates vice versa.

};

#define ATOMID_LEN              64

enum BUDDY_RETRY_STATE
{
    BUDDY_RETRY_NONE    = 0,
    BUDDY_REFRESH       = 1,
    BUDDY_RETRY         = 2,
    BUDDY_WAIT_NOTIFY   = 3,
};


struct ADDRESS_PRESENCE_INFO
{
    LIST_ENTRY  ListEntry;
    
    CHAR        pstrAddressURI[256];
    DOUBLE      iPrioriry;
    BOOL        fPhoneNumber;
    
    //ip terminal specific information.
    ACTIVE_STATUS                   addressActiveStatus;
    ACTIVE_MSN_SUBSTATUS            addrMsnSubstatus;
    SIPCALL_ACCEPTANCE_STATUS       addrMMCallStatus;
    IM_ACCEPTANCE_STATUS            addrIMStatus;
    APPSHARING_ACCEPTANCE_STATUS    addrAppsharingStatus;
    CHAR					        pstrMiscInfo[ MAX_MISC_INFO_LEN ];
    
    ADDRESS_PRESENCE_INFO()
    {
        ZeroMemory( this, sizeof ADDRESS_PRESENCE_INFO );
		InitializeListHead( &ListEntry );
    }
};


struct PARSED_PRESENCE_INFO
{
    CHAR        pstrPresentityURI[256];
    CHAR        pstrAtomID[ ATOMID_LEN+1 ];
    LIST_ENTRY  LEAddressInfo;
    
    PARSED_PRESENCE_INFO()
    {
        pstrPresentityURI[0] = 0;
        pstrAtomID[0] = 0;
        InitializeListHead( &LEAddressInfo );
    }

    ~PARSED_PRESENCE_INFO()
    {
        ADDRESS_PRESENCE_INFO  *pAddressInfo;
        PLIST_ENTRY             pLE;

        while( !IsListEmpty(&LEAddressInfo) )
        {
            pLE = RemoveHeadList(&LEAddressInfo);

            pAddressInfo = CONTAINING_RECORD(
                pLE, 
                ADDRESS_PRESENCE_INFO, 
                ListEntry );

            delete pAddressInfo;
        }
        
        InitializeListHead( &LEAddressInfo );
    }

};



//
//  Implementation of CSIPBuddy class.
//

class CSIPBuddy
    :   public ISIPBuddy,
        public SIP_MSG_PROCESSOR,
        public TIMER
{

private:
    LPWSTR                          m_lpwstrFriendlyName;
	LPWSTR	                        m_lpwstrPresentityURI;
    SIP_PRESENCE_INFO               m_PresenceInfo;
    
    ULONG                           ulNumOfNotifyTransaction;

    CHAR                            m_BuddyContactAddress[256];
    ISipBuddyNotify                *m_pNotifyInterface;
    SIP_BUDDY_STATE                 m_BuddyState;
    DWORD                           m_dwExpires;
    BOOL                            m_NotifySeenAfterLastRefresh;
    DWORD                           m_expiresTimeout;
    BUDDY_RETRY_STATE               m_RetryState;

    HRESULT GetAtomID(
        IN  PSTR&                   pstrXMLBlob, 
        IN  DWORD&                  dwXMLBlobLen,
        IN  PSTR                    pXMLBlobTag,
        OUT PSTR                    pstrAtomID,
        IN  DWORD                   dwAtomIDLen
        );

    BOOL IsURIPhoneNumber( 
        PSTR    pXMLBlobTag
        );

public:

    CSIPBuddy(
        IN  SIP_STACK          *pSipStack,
        IN  LPWSTR              lpwstrFriendlyName,
        IN  LPWSTR              lpwstrPresentityURI,
        IN  SIP_PROVIDER_ID    *pProviderID,
        IN  REDIRECT_CONTEXT   *pRedirectContext,
        OUT BOOL*               fSuccess
        );
    
    ~CSIPBuddy();

    HRESULT SetRequestURIRemoteAndRequestDestination(
        IN  LPCOLESTR   wsDestURI,
        IN  BOOL        fPresenceProvider
        );
    
    VOID OnError();

    BOOL IsSessionDisconnected();

    HRESULT GetExpiresHeader(
        SIP_HEADER_ARRAY_ELEMENT   *pHeaderElement
        );

    HRESULT CreateOutgoingSubscribe(
        IN  BOOL                        fIsFirstSubscribe,
        IN  BOOL                        AuthHeaderSent,
        IN  SIP_HEADER_ARRAY_ELEMENT   *pAuthHeaderElement,
        IN  ULONG                       dwNoOfHeaders
        );

    HRESULT CreateOutgoingUnsub(
        IN  BOOL                        AuthHeaderSent,
        IN  SIP_HEADER_ARRAY_ELEMENT   *pAuthHeaderElement,
        IN  ULONG                       dwNoOfHeaders
        );

    HRESULT CreateIncomingTransaction(
        IN  SIP_MESSAGE *pSipMsg,
        IN ASYNC_SOCKET *pResponseSocket
        );

    HRESULT ParseBuddyNotifyMessage(
        IN  SIP_MESSAGE            *pSipMsg,
        OUT PARSED_PRESENCE_INFO   *pParsedPresenceInfo
        );
    
    HRESULT CreateIncomingNotifyTransaction(
        IN SIP_MESSAGE  *pSipMsg,
        IN ASYNC_SOCKET *pResponseSocket
        );

    HRESULT CreateIncomingUnsubTransaction(
        IN SIP_MESSAGE  *pSipMsg,
        IN ASYNC_SOCKET *pResponseSocket
        );
    
    HRESULT CreateIncomingUnsubNotifyTransaction(
        IN SIP_MESSAGE  *pSipMsg,
        IN ASYNC_SOCKET *pResponseSocket
        );

    HRESULT NotifyPresenceInfoChange( 
        PARSED_PRESENCE_INFO*   parsedPresenceInfo
        );
    
    VOID InitiateBuddyTerminationOnError(
        IN ULONG StatusCode  //= 0
        );

    VOID HandleBuddySuccessfulResponse(
        IN  SIP_MESSAGE    *pSipMsg
        );

    VOID OnTimerExpire();

    VOID SetState(
        IN  SIP_BUDDY_STATE State
        )
    {
        m_BuddyState = State;
    }

    SIP_BUDDY_STATE GetState()
    {
        return m_BuddyState;
    }
        
    VOID BuddyUnsubscribed();

    VOID BuddySubscriptionAccepted(
        IN SIP_MESSAGE *pSipMsg
        );
    
    VOID BuddySubscriptionRejected(
        IN SIP_MESSAGE *pSipMsg
        );

    HRESULT ParsePresenceInfo(
        IN SIP_MESSAGE *pSipMsg
        );

    HRESULT ParsePresenceRejectCode(
        IN SIP_MESSAGE *pSipMsg
        );
    
    HRESULT ProcessRedirect(
        IN SIP_MESSAGE *pSipMsg
        );

    HRESULT OnIpAddressChange();

    //
    //  XML parsing functions
    //

    HRESULT VerifyPresentityURI( 
        IN  PSTR    pXMLBlobTag, 
        IN  DWORD   dwTagLen, 
        OUT PSTR    pstrPresentityURI
        );

    HRESULT GetAtomPresenceInformation(
        IN  PSTR                    pstrXMLBlob,
        IN  DWORD                   dwXMLBlobLen,
        OUT PARSED_PRESENCE_INFO*   pParsedPresenceInfo,
        IN  PSTR                    pXMLBlobTag
        );
    
    HRESULT GetAddressInfo(
        IN  PSTR&                   pstrXMLBlob, 
        IN  DWORD&                  dwXMLBlobLen,
        OUT PARSED_PRESENCE_INFO*   pParsedPresenceInfo,
        IN  PSTR                    pXMLBlobTag
        );

    HRESULT GetAddressURI(
        IN  PSTR    pXMLBlobTag,
        IN  DWORD   dwTagLen,
        OUT ADDRESS_PRESENCE_INFO * pAddrPresenceInfo
        );

    HRESULT ProcessStatusTag(
        IN  PSTR    pXMLBlobTag, 
        IN  DWORD   dwTagLen,
        OUT ADDRESS_PRESENCE_INFO * pAddrPresenceInfo
        );
   
    HRESULT ProcessMsnSubstatusTag(
        IN  PSTR    pXMLBlobTag, 
        IN  DWORD   dwTagLen,
        OUT ADDRESS_PRESENCE_INFO * pAddrPresenceInfo
        );
    
    HRESULT ProcessFeatureTag(
        IN  PSTR                        pXMLBlobTag, 
        IN  DWORD                       dwTagLen,
        OUT ADDRESS_PRESENCE_INFO * pAddrPresenceInfo
        );

    HRESULT ParseNoteText( 
        PSTR&   pstrBlob,
        DWORD&  dwXMLBlobLen,
        PSTR    pstrNote,
        DWORD   dwNoteLen
        );

    //
    // ISIPBuddy interface
    //

    STDMETHODIMP GetPresenceInformation(
        IN OUT	SIP_PRESENCE_INFO * pSipBuddyPresenceInfo
        );


    STDMETHODIMP SetNotifyInterface(
        IN   ISipBuddyNotify *    NotifyInterface
        );

    //
    // IUnknown interface.
    //
    STDMETHODIMP_(ULONG) AddRef();

    STDMETHODIMP_(ULONG) Release();

    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);


};



class CSIPWatcher
    :   public ISIPWatcher,
        public SIP_MSG_PROCESSOR,
        public TIMER
{

private:

    LPWSTR                          m_lpwstrFriendlyName;
	LPWSTR	                        m_lpwstrPresentityURI;//UNICODE version of presentity URI given to core

    PSTR                            m_pstrPresentityURI;//UTF8 version copied in the messages
    DWORD                           m_dwAtomID;

    ULONG                           ulNumOfNotifyTransaction;
    ULONG                           m_WatcherState;

    ULONG                           m_WatcherMonitorState;
    WATCHER_BLOCKED_STATUS          m_BlockedStatus;
    
    // This was added to persist blocked sessions
    DWORD                           m_dwAbsoluteExpireTime;

    LPOLESTR                        m_WatcherSipUrl;

    BOOL                            m_fEnforceToTag;

    HRESULT GetWatcherContactAddress(
        IN  SIP_MESSAGE    *pSipMsg
        );

public:

    //
    // IUnknown interface.
    //
    
    STDMETHODIMP_(ULONG) AddRef();

    STDMETHODIMP_(ULONG) Release();

    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);

    
    //
    // ISIPWatcher interface funcions.
    //

    STDMETHODIMP ApproveSubscription(
        IN  DWORD	dwPresenceInfoRules 
        );

    STDMETHODIMP RejectSubscription(
        IN  WATCHER_REJECT_REASON ulReason
        );

    STDMETHODIMP ChangeBlockedStatus(    
        IN  WATCHER_BLOCKED_STATUS BlockedStatus
        );

    HRESULT HandleSuccessfulSubscribe(
        INT ExpireTimeout
        );

    VOID OnTimerExpire();

    VOID WatcherOffline()
    {
        m_pSipStack -> WatcherOffline( this );
    }
    
    VOID WatcherDropped()
    {
        m_pSipStack -> WatcherOffline( this );
    }

    VOID SetEnforceToTag(
        BOOL fEnforceToTag
        )
    {
        m_fEnforceToTag = fEnforceToTag;
    }

    HRESULT OnIpAddressChange();
    
    HRESULT OnDeregister(
        SIP_PROVIDER_ID    *pProviderID
        );
    
    STDMETHODIMP GetWatcherShutdownData(
        IN  PSTR        NotifyBlob,
        OUT IN  PDWORD  pdwBlobLength
        );

    HRESULT StartDroppedWatcher(
        IN  SIP_MESSAGE    *pSipMsg,
        IN  SIP_SERVER_INFO *pProxyInfo
        );

    //
    //
    //
    
    CSIPWatcher(
        SIP_STACK  *pSipStack
        );
    
    ~CSIPWatcher();

    HRESULT CreateIncomingTransaction(
        IN  SIP_MESSAGE *pSipMsg,
        IN  ASYNC_SOCKET *pResponseSocket
        );

    void GetContactURI( 
        OUT PSTR * pLocalContact, 
        OUT ULONG * pLocalContactLen
        );
    
    VOID OnError();
    
    HRESULT StartIncomingWatcher(
        IN  SIP_TRANSPORT   Transport,
        IN  SIP_MESSAGE    *pSipMsg,
        IN  ASYNC_SOCKET   *pResponseSocket
        );

    HRESULT CreateOutgoingUnsub(
        IN  BOOL                        AuthHeaderSent,
        IN  SIP_HEADER_ARRAY_ELEMENT   *pAuthHeaderElement,
        IN  ULONG                       dwNoOfHeaders
        );

    HRESULT CreateOutgoingNotify(
        IN  BOOL                        AuthHeaderSent,
        IN  SIP_HEADER_ARRAY_ELEMENT   *pAuthHeaderElement,
        IN  ULONG                       dwNoOfHeaders
        );

    HRESULT CreateIncomingSubscribeTransaction(
        IN  SIP_MESSAGE    *pSipMsg,
        IN  ASYNC_SOCKET   *pResponseSocket,
        IN  BOOL            fIsFirstSubscribe 
        );
    
    HRESULT
    CSIPWatcher::OfferWatcher();

    void EncodeXMLBlob(
        OUT PSTR    pstrXMLBlob,
        OUT DWORD&  pdwBlobLen,
        IN  SIP_PRESENCE_INFO * pPresenceInfo
        );

    VOID InitiateWatcherTerminationOnError(
        IN ULONG StatusCode  // = 0
        );
    
    BOOL IsSessionDisconnected();

    HRESULT PresenceParamsChanged();

    //
    // Inline functions.
    //

    WCHAR*  GetPresentityURI()
    {
        return m_lpwstrPresentityURI;
    }

    PSTR    GetPresentityURIA()
    {
        return m_pstrPresentityURI;
    }

    WCHAR*  GetContactAddress()
    {
        return m_WatcherSipUrl;
    }

    void SetAbsoluteExpireTime(
        IN  DWORD dwAbsoluteExpireTime
        )
    {
        m_dwAbsoluteExpireTime = dwAbsoluteExpireTime;
    }

};



class OUTGOING_NOTIFY_TRANSACTION : public OUTGOING_TRANSACTION
{
public:

    OUTGOING_NOTIFY_TRANSACTION(
        IN  CSIPWatcher    *pSipWatcher,
        IN  SIP_METHOD_ENUM MethodId,
        IN  ULONG           CSeq,
        IN  BOOL            AuthHeaderSent,
        IN  BOOL            fIsUnsubNotify
        );
    
    HRESULT ProcessResponse(
        IN SIP_MESSAGE  *pSipMsg
        );

    VOID OnTimerExpire();

    HRESULT ProcessAuthRequiredResponse(
        IN  SIP_MESSAGE *pSipMsg,
        OUT BOOL        &fDelete
        );

    HRESULT ProcessFailureResponse(
        IN  SIP_MESSAGE *pSipMsg
        );

    // A virtual function of OUTGOING_TRANSACTION
    HRESULT GetAndStoreMsgBodyForRequest();
    
private:    
    HRESULT ProcessProvisionalResponse(
        IN SIP_MESSAGE *pSipMsg
        );

    HRESULT ProcessFinalResponse(
        IN SIP_MESSAGE *pSipMsg
        );

    HRESULT ProcessAuthRequiredResponse(
        IN SIP_MESSAGE *pSipMsg
        );
    
    BOOL MaxRetransmitsDone();
    

    CSIPWatcher    *m_pSipWatcher;
    BOOL            m_fIsUnsubNotify;
};


class INCOMING_SUBSCRIBE_TRANSACTION : public INCOMING_TRANSACTION
{
public:

    INCOMING_SUBSCRIBE_TRANSACTION::INCOMING_SUBSCRIBE_TRANSACTION(
        IN  CSIPWatcher    *pSipWatcher,
        IN  SIP_METHOD_ENUM MethodId,
        IN  ULONG           CSeq,
        IN  BOOL            fIsFirstSubscribe 
        );
    
    ~INCOMING_SUBSCRIBE_TRANSACTION();
    
    HRESULT ProcessRequest(
        IN SIP_MESSAGE  *pSipMsg,
        IN ASYNC_SOCKET *pResponseSocket
        );

    HRESULT TerminateTransactionOnByeOrCancel(
        OUT BOOL *pCallDisconnected
        );
    
    HRESULT Accept();

    HRESULT Reject(
        IN ULONG StatusCode,
        IN PSTR  ReasonPhrase,
        IN ULONG ReasonPhraseLen
        );

    VOID OnTimerExpire();

    VOID TerminateTransactionOnError(
        IN HRESULT      hr
        );

private:
    
    HRESULT SendProvisionalResponse(
        IN ULONG StatusCode,
        IN PSTR  ReasonPhrase,
        IN ULONG ReasonPhraseLen
        );
    
    HRESULT GetExpiresHeader(
        SIP_HEADER_ARRAY_ELEMENT   *pHeaderElement,
        DWORD                       dwExpires
        );

    HRESULT RetransmitResponse();

    BOOL MaxRetransmitsDone();

    CSIPWatcher    *m_pSipWatcher;

    // Cached provisional response buffer for retransmits
    SEND_BUFFER *m_pProvResponseBuffer;

    BOOL            m_fIsFirstSubscribe;

};


enum
{
    UNKNOWN_TAG        = 0,
    NOTE_TAG           = 1,
    ADDRESS_END_TAG    = 2,
    ATOM_END_TAG       = 3,
    ADDRESS_TAG        = 4,
    DOCTYPE_TAG        = 5,
    PRESENCE_END_TAG   = 6,
    XMLVER_TAG         = 7,
    PRESENCE_TAG       = 8,
    FEATURE_TAG        = 9,
    STATUS_TAG         = 10,
    ATOMID_TAG         = 11,
    PRESENTITY_TAG     = 12,
    MSNSUBSTATUS_TAG   = 13,

};


#define MSNSUBSTATUS_TAG_TEXT   "msnsubstatus"
#define STATUS_TAG_TEXT         "status"
#define NOTE_TAG_TEXT           "note"
#define ADDRESS_END_TAG_TEXT    "/address"
#define ATOM_END_TAG_TEXT       "/atom"
#define ADDRESS_TAG_TEXT        "address"
#define DOCTYPE_TAG_TEXT        "!DOCTYPE"
#define PRESENCE_END_TAG_TEXT   "/presence"
#define XMLVER_TAG_TEXT         "?xml"
#define PRESENCE_TAG_TEXT       "presence"
#define FEATURE_TAG_TEXT        "feature"
#define ATOMID_TAG_TEXT         "atom"
#define PRESENTITY_TAG_TEXT     "presentity"


#define XMLVER_TAG1_TEXT        "<?xml version=\"1.0\"?>\n"
#define DOCTYPE_TAG1_TEXT       "<!DOCTYPE presence\nPUBLIC \"-//IETF//DTD RFCxxxx XPIDF 1.0//EN\" \"xpidf.dtd\">\n"
#define PRESENCE_TAG1_TEXT      "<presence>\n"
#define PRESENTITY_TAG1_TEXT    "<presentity uri=\"%s;method=SUBSCRIBE\" />\n"
#define ATOMID_TAG1_TEXT        "<atom id=\"%d\">\n"
#define ADDRESSURI_TAG_TEXT     "<address uri=\"%s;user=%s\" priority=\"%f\">\n"
#define STATUS_TAG1_TEXT        "<status status=\"%s\" />\n"
#define MSNSUBSTATUS_TAG1_TEXT  "<msnsubstatus substatus=\"%s\" />\n"
#define FEATURE_TAG1_TEXT       "<feature feature=\"%s\" />\n"
#define NOTE_TAG1_TEXT          "<note>%s</note>\n"
#define ADDRESS_END_TAG1_TEXT   "</address>\n"
#define ATOMEND_TAG1_TEXT       "</atom>\n"
#define PRESENCE_END_TAG1_TEXT  "</presence>\n"

#define ACTIVE_STATUS_TEXT      "active"
#define E_END_OF_ATOM           0x80000100

#define	USER_IP					"ip"
#define	USER_PHONE				"phone"

BOOL
IsPresenceInfoSame( 
    IN  SIP_PRESENCE_INFO * pPresenceInfoSrc,
    IN  SIP_PRESENCE_INFO * pPresenceInfoDst
    );
    
PSTR
GetTextFromStatus( 
    IN  ACTIVE_STATUS activeStatus 
    );

PSTR
GetTextFromMsnSubstatus( 
    IN  ACTIVE_MSN_SUBSTATUS activeMsnSubstatus 
    );

PSTR
GetTextFromASFeature( 
    IN  APPSHARING_ACCEPTANCE_STATUS appsharingStatus 
    );

PSTR
GetTextFromIMFeature( 
    IN  IM_ACCEPTANCE_STATUS    IMAcceptnce 
    );

PSTR
GetTextFromMMFeature(
    IN  SIPCALL_ACCEPTANCE_STATUS sipCallAcceptance
    );

DWORD GetPresenceTagType(
    PSTR*   ppXMLBlobTag,
    DWORD   dwTagLen
    );

#endif //__sipcli_presence_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\register.h ===
#ifndef __sipcli_register_h__
#define __sipcli_register_h__

#include "sipcall.h"


#define     MAX_USERNAME_LEN    130

enum REG_RETRY_STATE
{
    REGISTER_NONE           = 0,
    REGISTER_REFRESH        = 1,
    REGISTER_RETRY          = 2,
};


enum REGISTER_EVENT
{
    REGEVENT_DEREGISTERED   = 1,
    REGEVENT_UNSUB          = 2,
    REGEVENT_PING           = 3,
    REGEVENT_PALOGGEDOFF    = 4,
    REGEVENT_PAMOVED        = 5,

};

    
class REGISTER_CONTEXT;

class OUTGOING_REGISTER_TRANSACTION : public OUTGOING_TRANSACTION
{
public:

    OUTGOING_REGISTER_TRANSACTION(
        IN REGISTER_CONTEXT    *pRegisterContext,
        IN ULONG                CSeq,
        IN BOOL                 AuthHeaderSent,
        IN BOOL                 fIsUnregister,
        IN BOOL                 fIsFirstRegister
        );
    
    ~OUTGOING_REGISTER_TRANSACTION();

    HRESULT ProcessResponse(
        IN SIP_MESSAGE  *pSipMsg
        );

    VOID OnTimerExpire();

    VOID TerminateTransactionOnError(
        IN HRESULT      hr
        );

    HRESULT ProcessFailureResponse(
        IN SIP_MESSAGE *pSipMsg
        );

private:

    HRESULT ProcessProvisionalResponse(
        IN SIP_MESSAGE *pSipMsg
        );

    HRESULT ProcessFinalResponse(
        IN SIP_MESSAGE *pSipMsg
        );

    HRESULT ProcessRedirectResponse(
        IN SIP_MESSAGE *pSipMsg
        );

    HRESULT ProcessAuthRequiredResponse(
        IN  SIP_MESSAGE    *pSipMsg,
        IN  BOOL            fIsUnregister,
        OUT BOOL           &fDelete
        );


    HRESULT ProcessSuccessfulResponse(
        IN  SIP_MESSAGE        *pSipMsg,
        IN  REGISTER_CONTEXT   *pRegisterContext,
        IN  BOOL                fIsUnregister        
        );

    BOOL MaxRetransmitsDone();

    REGISTER_CONTEXT   *m_pRegisterContext;
    BOOL                m_fIsUnregister;
    BOOL                m_fIsFirstRegister;
};


// This class contains all the currently active registrations.
class REGISTER_CONTEXT :
    public SIP_MSG_PROCESSOR,
    public TIMER
{
public:

    REGISTER_CONTEXT(
        IN  SIP_STACK           *pSipStack,
        IN  REDIRECT_CONTEXT    *pRedirectContext,
        IN  GUID                *pProviderID
        );

    ~REGISTER_CONTEXT();

    VOID OnError();
    
    HRESULT SetRemote(
        IN  LPCOLESTR  RemoteURI
        );

    HRESULT SetRequestURI(
        IN  LPCOLESTR  wsUserURI
        );
    
    HRESULT StartRegistration(
        IN SIP_PROVIDER_PROFILE *pProviderProfile
        );
        
    HRESULT StartUnregistration();

    HRESULT GetExpiresHeader(
        SIP_HEADER_ARRAY_ELEMENT   *pHeaderElement,
        DWORD                       dwExpires
        );   

    HRESULT CreateOutgoingRegisterTransaction(
        IN  BOOL                        AuthHeaderSent,
        IN  SIP_HEADER_ARRAY_ELEMENT   *pAuthHeaderElement,
        IN  BOOL                        fIsUnregister,
        IN  BOOL                        fIsFirstRegister,
        IN  ANSI_STRING                *pstrSecAcceptBuffer = NULL
        );

    HRESULT GetAuthorizationHeader(
        SIP_HEADER_ARRAY_ELEMENT   *pAuthHeaderElement,
        IN  ANSI_STRING            *pstrSecAcceptBuffer
        );

    VOID SetAndNotifyRegState(
        REGISTER_STATE  RegState,
        HRESULT         StatusCode,
        SIP_PROVIDER_ID *pProviderID = NULL
        );

    VOID GetContactURI(
        OUT PSTR * pLocalContact,
        OUT ULONG * pLocalContactLen
        );

    VOID HandleRegistrationSuccess(
        IN  SIP_MESSAGE    *pSipMsg
        );

    VOID HandleRegistrationError(
        HRESULT StatusCode
        );

    HRESULT ProcessRedirect(
        IN SIP_MESSAGE *pSipMsg
        );

    VOID OnTimerExpire();

    BOOL IsSessionDisconnected();

    HRESULT SetMethodsParam();

    REGISTER_STATE  GetState()
    {
        return m_RegisterState;
    }

private:

    REGISTER_STATE      m_RegisterState;
    REG_RETRY_STATE     m_RegRetryState;
    ULONG               m_RegisterRetryTime;    // in milliseconds
    ULONG               m_expiresTimeout;       // in seconds

    BOOL                m_IsEndpointPA;
    PSTR                m_RemotePASipUrl;

    PSTR                m_RegistrarURI;
    ULONG               m_RegistrarURILen;
    
    HRESULT GetEventContact(
        PSTR    Buffer, 
        ULONG   BufLen, 
        ULONG  *BytesParsed 
        );
    
    HRESULT VerifyRegistrationEvent(
        SIP_MESSAGE    *pSipMsg
        );
    
    HRESULT CreateIncomingTransaction(
        IN  SIP_MESSAGE *pSipMsg,
        IN  ASYNC_SOCKET *pResponseSocket
        );
    
    HRESULT CreateIncomingUnsubNotifyTransaction(
        IN SIP_MESSAGE  *pSipMsg,
        IN ASYNC_SOCKET *pResponseSocket
        );
    
    HRESULT CreateIncomingNotifyTransaction(
        IN SIP_MESSAGE  *pSipMsg,
        IN ASYNC_SOCKET *pResponseSocket
        );

    HRESULT ParseRegisterNotifyMessage(
        SIP_MESSAGE     *pSipMsg,
        REGISTER_EVENT *RegEvent
        );
    
    HRESULT GetRegEvent( 
        PSTR            pEventStr,
        ULONG           BufLen,
        REGISTER_EVENT *RegEvent
        );

    HRESULT GetEventHeader(
        SIP_HEADER_ARRAY_ELEMENT   *pAuthHeaderElement
        );

    HRESULT GetAllowEventsHeader(
        SIP_HEADER_ARRAY_ELEMENT   *pAuthHeaderElement
        );

    HRESULT SetRegistrarURI(
        IN  LPCOLESTR  wsRegistrar
        );
};




#endif // __sipcli_register_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\register.cpp ===
#include "precomp.h"
#include "sipstack.h"
#include "register.h"
#include "sspi.h"
#include "security.h"
#include "util.h"

#define IsSecHandleValid(Handle) \
    !(((Handle) -> dwLower == -1 && (Handle) -> dwUpper == -1))

#define COUNTSTR_ENTRY(String) String, sizeof(String) - 1


//All entries in here should have corresponding ids in rtcsip.idl in same order
static const COUNTED_STRING g_SipRegisterMethodsArray [] = {
    COUNTSTR_ENTRY("INVITE"),
    COUNTSTR_ENTRY("MESSAGE"),
    COUNTSTR_ENTRY("INFO"),
    COUNTSTR_ENTRY("SUBSCRIBE"),
    COUNTSTR_ENTRY("OPTIONS"),
    COUNTSTR_ENTRY("BYE"),
    COUNTSTR_ENTRY("CANCEL"),
    COUNTSTR_ENTRY("NOTIFY"),
    COUNTSTR_ENTRY("ACK"),
};

#define NUMBEROFREGISTERMETHODS 9
///////////////////////////////////////////////////////////////////////////////
// REGISTER_CONTEXT
///////////////////////////////////////////////////////////////////////////////

REGISTER_CONTEXT::REGISTER_CONTEXT(
    IN  SIP_STACK           *pSipStack,
    IN  REDIRECT_CONTEXT    *pRedirectContext,
    IN  SIP_PROVIDER_ID     *pProviderID
    ) :
    SIP_MSG_PROCESSOR(SIP_MSG_PROC_TYPE_REGISTER, pSipStack, pRedirectContext),
    TIMER(pSipStack->GetTimerMgr())
{
    m_RegisterState = REGISTER_STATE_NONE;
    
    m_RegRetryState = REGISTER_NONE;

    //This is the time after which we try to register again if the
    //registration fails after maximum retransmits of an attempt.
    m_RegisterRetryTime = 75000;

    m_expiresTimeout = REGISTER_DEFAULT_TIMER;
    
    m_ProviderGuid = GUID_NULL;
    
    m_IsEndpointPA = FALSE;
    m_RemotePASipUrl = NULL;

    if( pProviderID != NULL )
    {
        m_ProviderGuid = *pProviderID;
    }

    m_RegistrarURI = NULL;
    m_RegistrarURILen = 0;
}


REGISTER_CONTEXT::~REGISTER_CONTEXT()
{
    LOG(( RTC_TRACE, "REGISTER_CONTEXT:%p deleted", this ));

    // Kill the timer if there is one.
    if( (m_RegRetryState == REGISTER_REFRESH) ||
        (m_RegRetryState == REGISTER_RETRY) )
    {
        KillTimer();
    }

    if( m_RemotePASipUrl != NULL )
    {
        free( m_RemotePASipUrl );
    }

    if (m_RegistrarURI != NULL)
    {
        free(m_RegistrarURI);
    }
}

VOID    
REGISTER_CONTEXT::SetAndNotifyRegState(
    REGISTER_STATE  RegState,
    HRESULT         StatusCode,
    SIP_PROVIDER_ID *pProviderID // =NULL
    )
{
    SIP_PROVIDER_STATUS ProviderStatus;
    HRESULT             hr;

    if( (m_RegisterState == REGISTER_STATE_REGISTERED) &&
        (RegState == REGISTER_STATE_REGISTERING) )
    {
        //If we are alaredy registered then, this is refresh.
        return;
    }

    if( m_RegisterState != RegState )
    {
        if( (RegState != REGISTER_STATE_DROPSUB) &&
            (RegState != REGISTER_STATE_PALOGGEDOFF) )
        {
            m_RegisterState = RegState;
        }

        if( RegState == REGISTER_STATE_DROPSUB )
        {
            //
            //remove the SUB from the methods list
            //
            m_lRegisterAccept &= (~SIP_REGISTER_ACCEPT_SUBSCRIBE);

            if( m_Methodsparam != NULL )
            {
                free(m_Methodsparam);
                m_Methodsparam = NULL;
            }
            
            m_MethodsparamLen = 0;
            SetMethodsParam();
                
            m_IsEndpointPA = FALSE;
        }

        ZeroMemory( (PVOID)&ProviderStatus, sizeof SIP_PROVIDER_STATUS );

        ProviderStatus.ProviderID = m_ProviderGuid;
        
        ProviderStatus.RegisterState = RegState;

        ProviderStatus.Status.StatusCode = StatusCode;
        ProviderStatus.Status.StatusText = NULL;

        m_pSipStack -> NotifyRegistrarStatusChange( &ProviderStatus );
    }
}

VOID
REGISTER_CONTEXT::GetContactURI( 
    OUT PSTR * pLocalContact, 
    OUT ULONG * pLocalContactLen
    )
{
    PSTR    pStr;

    if( m_LocalContact[0] == '<' )
    {
        *pLocalContact = m_LocalContact + 1;
    }
    else
    {
        *pLocalContact = m_LocalContact;
    }

    if( pStr = strchr( m_LocalContact, ';' ) )
    {
        *pLocalContactLen = (ULONG)(pStr - *pLocalContact);
    }
    else if( pStr = strchr( m_LocalContact, '>' ) )
    {
        *pLocalContactLen = (ULONG)(pStr - *pLocalContact);
    }
    else
    {
        *pLocalContactLen = m_LocalContactLen;
    }
}

HRESULT 
REGISTER_CONTEXT::SetMethodsParam()
{
    LONG   lRegisterAccept;
    ULONG  MethodId = 0;
    MESSAGE_BUILDER Builder;

    if(m_lRegisterAccept != 0)
    {
        //get the length
        
        for(lRegisterAccept = m_lRegisterAccept,MethodId = 0 ;
            lRegisterAccept !=0 && MethodId < NUMBEROFREGISTERMETHODS;
            lRegisterAccept = lRegisterAccept>>1,MethodId++)
        {
            if(lRegisterAccept & 1)
                m_MethodsparamLen += g_SipRegisterMethodsArray[MethodId].Length +2; //2 is for the comma and space
        }
        m_MethodsparamLen+=1; //+1 for \0,-2 due to extra comma and space at end , and +2 for quotes around methods
        m_Methodsparam = (PSTR) malloc(m_MethodsparamLen*sizeof(char));
        if (m_Methodsparam == NULL)
        {
            LOG((RTC_ERROR, "Allocating m_Methodsparam failed"));
            return E_OUTOFMEMORY;
        }

        Builder.PrepareBuild(m_Methodsparam, m_MethodsparamLen);
        Builder.Append("\"");
        for(lRegisterAccept = m_lRegisterAccept, MethodId = 0;
            lRegisterAccept !=0 && MethodId < NUMBEROFREGISTERMETHODS;
            lRegisterAccept = lRegisterAccept>>1,MethodId++)
        {
            if(lRegisterAccept & 1)
            {
                if(Builder.GetLength() > 1)
                    Builder.Append(", ");
                Builder.Append(g_SipRegisterMethodsArray[MethodId].Buffer);
            }
        }
        Builder.Append("\"");
        if (Builder.OverflowOccurred())
        {
            LOG((RTC_TRACE,
                "Not enough buffer space -- need %u bytes, got %u\n",
                Builder.GetLength(), m_MethodsparamLen));
            ASSERT(FALSE);
            
            free(m_Methodsparam);
            m_Methodsparam = NULL;
            return E_FAIL;
        }
        m_MethodsparamLen = Builder.GetLength();
        m_Methodsparam[m_MethodsparamLen] = '\0';
        
        LOG((RTC_TRACE, "m_Methodsparam: %s len: %d",
            m_Methodsparam, m_MethodsparamLen));
    }
    return S_OK;
}
    
HRESULT
REGISTER_CONTEXT::StartRegistration(
    IN SIP_PROVIDER_PROFILE    *pProviderProfile
    )
{
    HRESULT hr;
    DWORD   UuidStrLen;

    ENTER_FUNCTION("REGISTER_CONTEXT::StartRegistration");

    LOG((RTC_TRACE, "%s -lRegisterAccept given by core is %d",
             __fxName, pProviderProfile->lRegisterAccept));
    if(m_lRegisterAccept != pProviderProfile->lRegisterAccept)
    {
        m_lRegisterAccept = pProviderProfile->lRegisterAccept;
        if(m_Methodsparam != NULL)
        {
            free(m_Methodsparam);
            m_Methodsparam = NULL;
        }
        m_MethodsparamLen = 0;
        hr = SetMethodsParam();
        if(hr != S_OK)
             return hr;
    }

    m_Transport = pProviderProfile->Registrar.TransportProtocol;
    m_AuthProtocol = pProviderProfile->Registrar.AuthProtocol;

    if (m_Transport == SIP_TRANSPORT_SSL)
    {
        //
        // For Kerberos we have a separate provisioning entry for 
        // RemotePrincipalName. In case of SSL it must be the same as 
        // ServerAddress itself. So copy it from there.
        //
        hr = SetRemotePrincipalName(pProviderProfile->Registrar.ServerAddress);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s SetRemotePrincipalName failed %x",
                 __fxName, hr));
               
            return hr;
        }
    }

    hr = SetRequestURI(pProviderProfile->UserURI);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s  SetRequestURI failed %x", __fxName, hr));
        return hr;
    }
    
    hr = SetRegistrarURI(pProviderProfile->Registrar.ServerAddress);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s  SetRegistrarURI failed %x", __fxName, hr));
        return hr;
    }
    
    hr = SetRemoteForOutgoingCall(NULL, pProviderProfile->UserURI);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - SetRemoteForOutgoingCall failed %x",
             __fxName, hr)); 

        return hr;
    }

    // Local and Remote should be the same for register
    // hr = SetLocal(m_Remote, m_RemoteLen);
    hr = SetLocalForOutgoingCall(NULL, pProviderProfile->UserURI);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s SetLocalForOutgoingCall failed %x",
             __fxName, hr));
        
        return hr;
    }
    
    hr = ResolveSipUrlAndSetRequestDestination(
             m_RegistrarURI, m_RegistrarURILen,
             FALSE, FALSE, FALSE, TRUE);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s ResolveSipUrlAndSetRequestDestination failed %x",
             __fxName, hr));

        HandleRegistrationError( hr );
        return hr;
    }

    hr = SetCredentials(&pProviderProfile->UserCredentials,
                        pProviderProfile->Realm);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - SetCredentials failed %x",
             __fxName, hr));
        
        HandleRegistrationError( hr );
        return hr;
    }

    hr = CreateOutgoingRegisterTransaction(
             FALSE, NULL, FALSE, TRUE
             );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - CreateOutgoingRegisterTransaction failed %x",
             __fxName, hr));

        HandleRegistrationError( hr );
        return hr;
    }

    SetAndNotifyRegState( REGISTER_STATE_REGISTERING, 0, 
        &pProviderProfile->ProviderID );

    return S_OK;
}


BOOL
REGISTER_CONTEXT::IsSessionDisconnected()
{
    return ( (m_RegisterState == REGISTER_STATE_UNREGISTERED )  ||
             (m_RegisterState == REGISTER_STATE_ERROR )         ||
             (m_RegisterState == REGISTER_STATE_REJECTED ) );
}


HRESULT
REGISTER_CONTEXT::StartUnregistration()
{
    HRESULT       hr;

    LOG(( RTC_TRACE, "StartUnregistration - entered" ));
    
    // If the registration did not go through, don't send an UNREG message.
    if( ( m_RegisterState == REGISTER_STATE_REGISTERED ) ||
        ( m_RegisterState == REGISTER_STATE_REGISTERING ) )
    {
        hr = CreateOutgoingRegisterTransaction(
                 FALSE, NULL, TRUE, FALSE
                 );
        if (hr != S_OK)
        {
            return hr;
        }
    
        SetAndNotifyRegState( REGISTER_STATE_UNREGISTERING, 0 );
    }

    LOG(( RTC_TRACE, "StartUnregistration - exited" ));
    return S_OK;
}


HRESULT
REGISTER_CONTEXT::CreateOutgoingRegisterTransaction(
    IN  BOOL                        AuthHeaderSent,
    IN  SIP_HEADER_ARRAY_ELEMENT   *pAuthHeaderElement,
    IN  BOOL                        fIsUnregister,
    IN  BOOL                        fIsFirstRegister,
    IN  ANSI_STRING                *pstrSecAcceptBuffer //=NULL, NTLM buffer to be accepted, if any

    )
{
    HRESULT hr;
    OUTGOING_REGISTER_TRANSACTION  *pOutgoingRegisterTransaction;
    DWORD                           dwNoOfHeader = 0;
    SIP_HEADER_ARRAY_ELEMENT        HeaderArray[4];
    DWORD                           iIndex;
    PSTR                            ExpiresHeaderValue = NULL;
    PSTR                            AuthHeaderValue = NULL;
    PSTR                            AllowEventHeaderValue = NULL;
    PSTR                            EventHeaderValue = NULL;
    ULONG                           RegisterTimerValue;

    ENTER_FUNCTION("REGISTER_CONTEXT::CreateOutgoingRegisterTransaction()");
    LOG((RTC_TRACE, "%s - enter", __fxName));
    
    //
    // Do not create a REGISTER transaction if the session has already been disconnected.
    //
    if( (fIsUnregister==FALSE) && 
        (IsSessionDisconnected() || (m_RegisterState==REGISTER_STATE_UNREGISTERING))
      )
    {
        return S_OK;
    }

    pOutgoingRegisterTransaction =
        new OUTGOING_REGISTER_TRANSACTION(
                this, 
                GetNewCSeqForRequest(),
                AuthHeaderSent, 
                fIsUnregister, 
                fIsFirstRegister );
    
    if (pOutgoingRegisterTransaction == NULL)
    {
        LOG((RTC_ERROR, "%s - allocating pOutgoingRegisterTransaction failed",
             __fxName));
        return E_OUTOFMEMORY;
    }

    //
    // Timeout is 0 for UNREG. For refresh 180 seconds are added to the actual
    // timer value in order to take care of network delays and retransmits.
    //
    hr = GetExpiresHeader( &HeaderArray[dwNoOfHeader],
            (fIsUnregister)?0:(m_expiresTimeout+FIVE_MINUTES) );

    if( hr == S_OK )
    {
        ExpiresHeaderValue = HeaderArray[dwNoOfHeader].HeaderValue;
        //authorization required.
        dwNoOfHeader++;
    }

    if( fIsUnregister == FALSE )
    {
        hr = GetEventHeader( &HeaderArray[dwNoOfHeader] );
        if( hr == S_OK )
        {
            //Register for registration events.
            EventHeaderValue = HeaderArray[dwNoOfHeader].HeaderValue;
            dwNoOfHeader++;
        }
    }

    // If registering for SUB add the Allow-Events
    if( (m_lRegisterAccept & SIP_REGISTER_ACCEPT_SUBSCRIBE) && (fIsUnregister==FALSE) )
    {
        hr = GetAllowEventsHeader( &HeaderArray[dwNoOfHeader] );
        if( hr == S_OK )
        {
            //authorization required.
            AllowEventHeaderValue = HeaderArray[dwNoOfHeader].HeaderValue;
            dwNoOfHeader++;

            m_IsEndpointPA = TRUE;
        }
    }
    else
    {
        m_IsEndpointPA = FALSE;
    }

    if( pAuthHeaderElement != NULL )
    {
        HeaderArray[dwNoOfHeader] = *pAuthHeaderElement;
        dwNoOfHeader++;
    }
    else
    {
        hr = GetAuthorizationHeader( &HeaderArray[dwNoOfHeader], 
                                pstrSecAcceptBuffer );
        if( hr == S_OK )
        {
            //authorization required.
            AuthHeaderValue = HeaderArray[dwNoOfHeader].HeaderValue;
            dwNoOfHeader++;
        }
    }
    
    RegisterTimerValue = (m_Transport == SIP_TRANSPORT_UDP) ?
        SIP_TIMER_RETRY_INTERVAL_T1 : SIP_TIMER_INTERVAL_AFTER_REGISTER_SENT_TCP;

    hr = pOutgoingRegisterTransaction->CheckRequestSocketAndSendRequestMsg(
             RegisterTimerValue,
             HeaderArray,
             dwNoOfHeader,
             NULL, 0,
             NULL, 0  //No ContentType
             );
    
    if (AuthHeaderValue != NULL)
    {
        free(AuthHeaderValue);
    }
    
    if( ExpiresHeaderValue != NULL )
    {
        free(ExpiresHeaderValue);
    }
    
    if( AllowEventHeaderValue != NULL )
    {
        free( AllowEventHeaderValue );
    }

    if( EventHeaderValue != NULL )
    {
        free( EventHeaderValue );
    }

    if (hr != S_OK)
    {
        LOG(( RTC_ERROR, "%s failed CheckRequestSocketAndSendRequestMsg %x",
             __fxName, hr ));

        pOutgoingRegisterTransaction->OnTransactionDone();
        return hr;
    }
    return hr;
}


HRESULT
REGISTER_CONTEXT::GetEventHeader(
    SIP_HEADER_ARRAY_ELEMENT   *pHeaderElement
    )
{
    pHeaderElement->HeaderId = SIP_HEADER_EVENT;
    
    pHeaderElement->HeaderValue = (PSTR) malloc( sizeof("registration") + 10 );
    
    if( pHeaderElement->HeaderValue == NULL )
    {
        return E_OUTOFMEMORY;
    }

    pHeaderElement->HeaderValueLen =
        sprintf( pHeaderElement->HeaderValue, "registration" );

    return S_OK;
}


HRESULT 
REGISTER_CONTEXT::GetAllowEventsHeader(
    SIP_HEADER_ARRAY_ELEMENT   *pHeaderElement
    )
{
    pHeaderElement->HeaderId = SIP_HEADER_ALLOW_EVENTS;
    
    pHeaderElement->HeaderValue = (PSTR) malloc( sizeof("presence") + 10 );
    
    if( pHeaderElement->HeaderValue == NULL )
    {
        return E_OUTOFMEMORY;
    }

    pHeaderElement->HeaderValueLen = 
        sprintf( pHeaderElement->HeaderValue, "presence" );

    return S_OK;    
}


// On return with S_OK pAuthHeaderElement->HeaderValue has a string
// allocated with malloc and should be freed with free()

HRESULT 
REGISTER_CONTEXT::GetAuthorizationHeader(
    SIP_HEADER_ARRAY_ELEMENT   *pAuthHeaderElement,
    IN  ANSI_STRING            *pstrSecAcceptBuffer //buffer to be accpted if any
    )
{
    ENTER_FUNCTION("REGISTER_CONTEXT::GetAuthorizationHeader");
    
    HRESULT     hr; 
    //look at the authorization type and if its 'Basic'/'basic'
    //encode the userid:passwd using base64 and return S_OK
    //else return E_FAIL
    
    if( m_AuthProtocol != SIP_AUTH_PROTOCOL_BASIC )
    {
        return E_FAIL;
    }

    if (m_Username == NULL || m_UsernameLen == 0)
    {
        LOG((RTC_ERROR, "%s - username not present",
             __fxName));
        return E_FAIL;
    }
    
    if (m_Password == NULL || m_PasswordLen == 0)
    {
        LOG((RTC_ERROR, "%s - Password not present",
             __fxName));
        return E_FAIL;
    }
    
    SECURITY_CHALLENGE  AuthChallenge;
    SECURITY_PARAMETERS AuthParams;
    ANSI_STRING         asAuthHeader;

    ZeroMemory(&AuthChallenge, sizeof(SECURITY_CHALLENGE));
    ZeroMemory(&AuthParams, sizeof(SECURITY_PARAMETERS));

    // Build a basic authorization header
    AuthChallenge.AuthProtocol        = SIP_AUTH_PROTOCOL_BASIC;
    
    AuthParams.Username.Buffer        = m_Username;
    AuthParams.Username.Length        = (USHORT) m_UsernameLen;
    AuthParams.Username.MaximumLength = (USHORT) m_UsernameLen;

    AuthParams.Password.Buffer        = m_Password;
    AuthParams.Password.Length        = (USHORT) m_PasswordLen;
    AuthParams.Password.MaximumLength = (USHORT) m_PasswordLen;

    hr = BuildAuthResponse(&AuthChallenge,
                           &AuthParams,
                           &asAuthHeader);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s  failed %x", __fxName, hr));
        return hr;
    }
    
    pAuthHeaderElement->HeaderId = SIP_HEADER_AUTHORIZATION;
    pAuthHeaderElement->HeaderValue = asAuthHeader.Buffer;
    pAuthHeaderElement->HeaderValueLen = asAuthHeader.Length;
        
    return S_OK;
}


HRESULT
REGISTER_CONTEXT::GetExpiresHeader(
    SIP_HEADER_ARRAY_ELEMENT   *pHeaderElement,
    DWORD                       dwExpires
    )
{
    pHeaderElement->HeaderId = SIP_HEADER_EXPIRES;
    
    pHeaderElement->HeaderValue = (PSTR) malloc( 10 );
    
    if( pHeaderElement->HeaderValue == NULL )
    {
        return E_OUTOFMEMORY;
    }

    _ultoa( dwExpires, pHeaderElement->HeaderValue, 10 );

    pHeaderElement->HeaderValueLen = 
        strlen( pHeaderElement->HeaderValue );

    return S_OK;
}


VOID
REGISTER_CONTEXT::OnError()
{
    LOG((RTC_TRACE, "REGISTER_CONTEXT::OnError - enter"));
}


HRESULT
REGISTER_CONTEXT::SetRegistrarURI(
    IN  LPCOLESTR  wsRegistrar
    )
{
    HRESULT hr;

    ENTER_FUNCTION("REGISTER_CONTEXT::SetRegistrarURI");
    
    if (wcsncmp(wsRegistrar, L"sip:", 4) == 0)
    {
        hr = UnicodeToUTF8(wsRegistrar,
                           &m_RegistrarURI, &m_RegistrarURILen);
        return hr;
    }
    else
    {
        // If "sip:" is not present add it yourself

        int RegistrarURIValueLen;
        int RegistrarURIBufLen;

        RegistrarURIBufLen = 4 + wcslen(wsRegistrar) + 1;
        
        m_RegistrarURI = (PSTR) malloc(RegistrarURIBufLen);
        if (m_RegistrarURI == NULL)
        {
            LOG((RTC_TRACE, "%s allocating m_RegistrarURI failed", __fxName));
            return E_OUTOFMEMORY;
        }

        RegistrarURIValueLen = _snprintf(m_RegistrarURI, RegistrarURIBufLen,
                                         "sip:%ls", wsRegistrar);
        if (RegistrarURIValueLen < 0)
        {
            LOG((RTC_ERROR, "%s _snprintf failed", __fxName));
            return E_FAIL;
        }

        m_RegistrarURILen = RegistrarURIValueLen;
        return S_OK;
    }
    
}


// Request-URI should have the domain. The server uses this to
// check if it should forward the REGISTER request. Currently we don't
// support a scenario where a "sip:user@domain2.com" URI could be
// registered with a registrar for the "domain1.com" domain. This would
// require a registration domain in the profile.
// We always extract the domain from the User URI and use it for the Request URI.

HRESULT
REGISTER_CONTEXT::SetRequestURI(
    IN  LPCOLESTR  wsUserURI
    )
{
    HRESULT hr;
    SIP_URL DecodedSipUrl;
    ULONG   BytesParsed = 0;
    PSTR    szUserURI = NULL;
    DWORD   UserURILen = 0;

    ENTER_FUNCTION("REGISTER_CONTEXT::SetRequestURI");

    hr = UnicodeToUTF8(wsUserURI, &szUserURI, &UserURILen);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s UnicodeToUTF8 failed %x", __fxName, hr));
        return hr;
    }

    hr = ParseSipUrl(szUserURI, UserURILen, &BytesParsed,
                     &DecodedSipUrl);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s ParseSipUrl failed %x",
             __fxName, hr));
        goto done;
    }

    int RequestURIValueLen;
    int RequestURIBufLen;

    RequestURIBufLen = 4 + DecodedSipUrl.m_Host.Length + 1;
        
    m_RequestURI = (PSTR) malloc(RequestURIBufLen);
    if (m_RequestURI == NULL)
    {
        LOG((RTC_TRACE, "%s allocating m_RequestURI failed", __fxName));
        hr = E_OUTOFMEMORY;
        goto done;
    }

    RequestURIValueLen = _snprintf(m_RequestURI, RequestURIBufLen,
                                   "sip:%s", DecodedSipUrl.m_Host.Buffer);
    if (RequestURIValueLen < 0)
    {
        LOG((RTC_ERROR, "%s _snprintf failed", __fxName));
        hr = E_FAIL;
        goto done;
    }

    m_RequestURILen = RequestURIValueLen;
    hr = S_OK;

 done:
    if (szUserURI != NULL)
    {
        free(szUserURI);
    }
    return hr;
}

    
HRESULT
REGISTER_CONTEXT::CreateIncomingTransaction(
    IN  SIP_MESSAGE  *pSipMsg,
    IN  ASYNC_SOCKET *pResponseSocket
    )
{
    ENTER_FUNCTION("REGISTER_CONTEXT::CreateIncomingTransaction");

    HRESULT hr = S_OK;
    INT     ExpireTimeout;

    switch( pSipMsg->GetMethodId() )
    {
    case SIP_METHOD_NOTIFY:

        ExpireTimeout = pSipMsg -> GetExpireTimeoutFromResponse(
                NULL, 0, SUBSCRIBE_DEFAULT_TIMER );

        if( ExpireTimeout == 0 )
        {
            hr = CreateIncomingUnsubNotifyTransaction( pSipMsg, pResponseSocket );
            
            if( hr != S_OK )
            {
                LOG((RTC_ERROR, "%s  Creating reqfail transaction failed %x",
                     __fxName, hr));
                return hr;
            }
        }
        else
        {
            hr = CreateIncomingNotifyTransaction( pSipMsg, pResponseSocket );

            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s  CreateIncomingNotifyTransaction failed %x",
                     __fxName, hr));
                return hr;
            }
        }
        
        break;

    default:
        
        // send method not allowed.
        hr = CreateIncomingReqFailTransaction( pSipMsg, pResponseSocket, 405 );
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s  Creating reqfail transaction failed %x",
                 __fxName, hr));
            return hr;
        }
    }
    
    return S_OK;
}


HRESULT
REGISTER_CONTEXT::VerifyRegistrationEvent(
    SIP_MESSAGE    *pSipMsg
    )
{
    HRESULT                         hr = S_OK;
    PSTR                            Buffer = NULL;
    ULONG                           BufLen = 0;
    ULONG                           BytesParsed = 0;

    // We have Message Body. Check type.
    hr = pSipMsg -> GetSingleHeader(
                        SIP_HEADER_EVENT,
                        &Buffer,
                        &BufLen );
    if( hr != S_OK )
    {
        LOG((RTC_ERROR, "CreateIncomingNotifyTransaction-no event header %.*s",
            BufLen, Buffer ));

        return E_FAIL;
    }

    //skip white spaces
    ParseWhiteSpaceAndNewLines( Buffer, BufLen, &BytesParsed );

    //skip ;
    hr = ParseKnownString( Buffer, BufLen, &BytesParsed,
            "registration-notify", sizeof("registration-notify") - 1,
            FALSE // case-insensitive
            );
    
    if( hr != S_OK )
    {
        return hr;
    }        

    //skip white spaces
    ParseWhiteSpaceAndNewLines( Buffer, BufLen, &BytesParsed );

    if( BytesParsed != BufLen )
    {
        //skip ;
        hr = ParseKnownString( Buffer, BufLen, &BytesParsed,
                ";", sizeof(";") - 1,
                FALSE // case-insensitive
                );
    
        if( hr != S_OK )
        {
            return hr;
        }        
    }

    return S_OK;
}

    
HRESULT
REGISTER_CONTEXT::CreateIncomingUnsubNotifyTransaction(
    IN SIP_MESSAGE  *pSipMsg,
    IN ASYNC_SOCKET *pResponseSocket
    )
{
    HRESULT                         hr = S_OK;
    INCOMING_NOTIFY_TRANSACTION    *pIncomingNotifyTransaction = NULL;
    REGISTER_EVENT                  RegEvent;

    LOG(( RTC_TRACE,
        "REGISTER_CONTEXT::CreateIncomingUnsubNotifyTransaction-Entered-%p", this ));
    
    hr = VerifyRegistrationEvent( pSipMsg );
    if( hr != S_OK )
    {
        hr = m_pSipStack -> CreateIncomingReqfailCall(
                                        pResponseSocket->GetTransport(),
                                        pSipMsg,
                                        pResponseSocket,
                                        400,
                                        NULL,
                                        0 );
        return hr;
    }

    // Create a new NOTIFY transaction.
    pIncomingNotifyTransaction = new INCOMING_NOTIFY_TRANSACTION( 
                                        static_cast <SIP_MSG_PROCESSOR*>(this),
                                        pSipMsg->GetMethodId(),
                                        pSipMsg->GetCSeq(),
                                        FALSE );

    if( pIncomingNotifyTransaction == NULL )
    {
        return E_OUTOFMEMORY;
    }

    hr = pIncomingNotifyTransaction->SetResponseSocketAndVia(
             pSipMsg, pResponseSocket);
    if (hr != S_OK)
    {
        goto cleanup;
    }

    hr = pIncomingNotifyTransaction->ProcessRequest( pSipMsg, pResponseSocket );
    if( hr != S_OK )
    {
        //Should not delete the transaction. The transaction
        //should handle the error and delete itself
        return hr;
    }

    LOG(( RTC_TRACE,
        "REGISTER_CONTEXT::CreateIncomingNotifyTransaction-Exited-%p", this ));
    
    return S_OK;

cleanup:

    if( pIncomingNotifyTransaction != NULL )
    {
        pIncomingNotifyTransaction -> OnTransactionDone();
    }

    return hr;
}


HRESULT
REGISTER_CONTEXT::CreateIncomingNotifyTransaction(
    IN SIP_MESSAGE  *pSipMsg,
    IN ASYNC_SOCKET *pResponseSocket
    )
{
    HRESULT                         hr = S_OK;
    INCOMING_NOTIFY_TRANSACTION    *pIncomingNotifyTransaction = NULL;
    PSTR                            Header = NULL;
    ULONG                           HeaderLen = 0;
    REGISTER_EVENT                  RegEvent;

    LOG(( RTC_TRACE, 
        "REGISTER_CONTEXT::CreateIncomingNotifyTransaction-Entered-%p", this ));
    
    // We have Message Body. Check type.
    hr = pSipMsg -> GetSingleHeader(
                        SIP_HEADER_CONTENT_TYPE,
                        &Header,
                        &HeaderLen );

    if( hr != S_OK )
    {
        LOG((RTC_ERROR, "CreateIncomingNotifyTransaction-no Content-Type %.*s",
            HeaderLen, Header ));

        hr = m_pSipStack -> CreateIncomingReqfailCall(
                                        pResponseSocket->GetTransport(),
                                        pSipMsg,
                                        pResponseSocket,
                                        400,
                                        NULL,
                                        0 );
    
        return E_FAIL;
    }

    if( !IsOneOfContentTypeTextRegistration( Header, HeaderLen ) )
    {
        LOG((RTC_ERROR, "CreateIncomingNotifyTransaction-invalid Content-Type %.*s",
            HeaderLen, Header ));

        hr = m_pSipStack -> CreateIncomingReqfailCall(
                                        pResponseSocket->GetTransport(),
                                        pSipMsg,
                                        pResponseSocket,
                                        415,
                                        NULL,
                                        0 );
    
        return E_FAIL;
    }

    hr = VerifyRegistrationEvent( pSipMsg );
    if( hr != S_OK )
    {
        hr = m_pSipStack -> CreateIncomingReqfailCall(
                                        pResponseSocket->GetTransport(),
                                        pSipMsg,
                                        pResponseSocket,
                                        400,
                                        NULL,
                                        0 );
        return hr;
    }

    // Create a new NOTIFY transaction.
    pIncomingNotifyTransaction = new INCOMING_NOTIFY_TRANSACTION( 
                                        static_cast <SIP_MSG_PROCESSOR*>(this),
                                        pSipMsg->GetMethodId(),
                                        pSipMsg->GetCSeq(),
                                        FALSE );

    if( pIncomingNotifyTransaction == NULL )
    {
        return E_OUTOFMEMORY;
    }

    hr = pIncomingNotifyTransaction->SetResponseSocketAndVia(
             pSipMsg, pResponseSocket);
    if (hr != S_OK)
    {
        goto cleanup;
    }

    hr = ParseRegisterNotifyMessage( pSipMsg, &RegEvent );
    if( hr != S_OK )
    {
        pIncomingNotifyTransaction->CreateAndSendResponseMsg(
                 488,
                 SIP_STATUS_TEXT(488),
                 SIP_STATUS_TEXT_SIZE(488),
                 NULL,   // No Method string
                 FALSE,  // No Contact Header
                 NULL, 0, //No message body
                 NULL, 0 // No content Type
                 );

        goto cleanup;
    }

    hr = pIncomingNotifyTransaction->ProcessRequest( pSipMsg, pResponseSocket );
    if( hr != S_OK )
    {
        //Should not delete the transaction. The transaction
        //should handle the error and delete itself
        return hr;
    }

    //
    //Deregister event could release the REGISTER_CONTEXT reference so addref it
    //
    MsgProcAddRef();
    
    // Do this last as this function notifies core
    switch( RegEvent )
    {
        case REGEVENT_DEREGISTERED:
            
            m_pSipStack -> OnDeregister( &m_ProviderGuid, FALSE );

            SetAndNotifyRegState( REGISTER_STATE_DEREGISTERED, 0 );
            break;

        case REGEVENT_UNSUB:
            
            m_pSipStack -> OnDeregister( &m_ProviderGuid, TRUE );
            
            SetAndNotifyRegState( REGISTER_STATE_DROPSUB, 0 );
            break;

        case REGEVENT_PALOGGEDOFF:
            
            SetAndNotifyRegState( REGISTER_STATE_PALOGGEDOFF, 0 );
            break;
            
        case REGEVENT_PING:
        case REGEVENT_PAMOVED:

            //Nothing needs to be done.
            break;
    }

    LOG(( RTC_TRACE,
        "REGISTER_CONTEXT::CreateIncomingNotifyTransaction-Exited-%p", this ));

    MsgProcRelease();
    
    return S_OK;

cleanup:

    if( pIncomingNotifyTransaction != NULL )
    {
        pIncomingNotifyTransaction -> OnTransactionDone();
    }

    return hr;
}


HRESULT
REGISTER_CONTEXT::ParseRegisterNotifyMessage(
    SIP_MESSAGE     *pSipMsg,
    REGISTER_EVENT *RegEvent
    )
{
    HRESULT         hr = S_OK;
    PSTR            Buffer;
    ULONG           BufLen;

    LOG(( RTC_TRACE,
        "REGISTER_CONTEXT::ParseRegisterNotifyMessage-Entered-%p", this ));
    
    if( pSipMsg -> MsgBody.Length == 0 )
    {
        //no state to update
        return E_FAIL;
    }

    Buffer = pSipMsg -> MsgBody.GetString( pSipMsg->BaseBuffer );
    BufLen = pSipMsg -> MsgBody.Length;

    if (hr == S_OK)
    {
        hr = GetRegEvent(   Buffer,
                            BufLen,
                            RegEvent );
    }

    LOG(( RTC_TRACE, 
        "REGISTER_CONTEXT::ProcessRegisterNotifyMessage-Exited-%p", this ));

    return hr;
}


HRESULT
REGISTER_CONTEXT::GetEventContact(
    PSTR    Buffer,
    ULONG   BufLen,
    ULONG  *BytesParsed
    )
{
    HRESULT hr;
    CONTACT_HEADER  ContactHeader;

    ZeroMemory( (PVOID)&ContactHeader, sizeof(CONTACT_HEADER) );

    //skip white spaces
    ParseWhiteSpaceAndNewLines( Buffer, BufLen, BytesParsed );

    //skip ;
    hr = ParseKnownString( Buffer, BufLen, BytesParsed,
            ";", sizeof(";") - 1,
            FALSE // case-insensitive
            );
    
    if( hr != S_OK )
    {
        return hr;
    }        

    //skip white spaces
    ParseWhiteSpaceAndNewLines( Buffer, BufLen, BytesParsed );

    //skip Contact:
    hr = ParseKnownString( Buffer, BufLen, BytesParsed,
            "Contact:", sizeof("Contact:") - 1,
            FALSE );
    
    if( hr != S_OK )
    {
        return hr;
    }        

    //Parse contact header
    
    hr = ParseContactHeader(Buffer, BufLen, BytesParsed, &ContactHeader );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR,
             "ParseContactHeader failed: %x - skipping Contact header %.*s",
             hr, Buffer, BufLen ));
        
        return hr;
    }

    if( m_RemotePASipUrl != NULL )
    {
        free(m_RemotePASipUrl);
    }

    m_RemotePASipUrl = (PSTR)malloc( ContactHeader.m_SipUrl.Length + 1 );
    if( m_RemotePASipUrl == NULL )
    {
        return E_OUTOFMEMORY;
    }

    strncpy(m_RemotePASipUrl, ContactHeader.m_SipUrl.Buffer,
            ContactHeader.m_SipUrl.Length );

    m_RemotePASipUrl[ ContactHeader.m_SipUrl.Length ] = '\0';
        
    return hr;
}

HRESULT
REGISTER_CONTEXT::GetRegEvent(
    PSTR            Buffer,
    ULONG           BufLen,
    REGISTER_EVENT *RegEvent
    )
{
    HRESULT         hr;
    ULONG           BytesParsed = 0;
    ULONG           EventBytesParsed = 0;
    OFFSET_STRING   EventStr;
    
    ParseWhiteSpaceAndNewLines( Buffer, BufLen, &BytesParsed );

    if( BytesParsed == BufLen )
    {
        return E_FAIL;
    }

    hr = ParseToken(Buffer, BufLen, &BytesParsed,
                    IsTokenChar,
                    &EventStr );
    if (hr != S_OK)
    {
        return hr;
    }

    PSTR    EventBuf = EventStr.GetString(Buffer);
    ULONG   EventBufLen = EventStr.GetLength();

    hr = ParseKnownString(EventBuf, EventBufLen, &EventBytesParsed,
                  "deregistered", sizeof("deregistered") - 1,
                  FALSE // case-insensitive
                  );
    
    if( hr == S_OK )
    {
        *RegEvent = REGEVENT_DEREGISTERED;
        return hr;
    }

    hr = ParseKnownString(EventBuf, EventBufLen, &EventBytesParsed,
            "release-subscriptions", sizeof("release-subscription") - 1,
            FALSE );
        
    if( hr == S_OK )
    {
        *RegEvent = REGEVENT_UNSUB;

        //Get the contact of the new PA
        hr = GetEventContact( Buffer, BufLen, &BytesParsed );
        if( hr != S_OK )
        {
            LOG(( RTC_TRACE, "Could'nt get contact from the register event" ));

            return S_OK;
        }

        return S_OK;
    }

    hr = ParseKnownString(EventBuf, EventBufLen, &EventBytesParsed,
                  "Existing-PA-LoggedOff", sizeof("Existing-PA-LoggedOff") - 1,
                  FALSE // case-insensitive
                  );
        
    if( hr == S_OK )
    {
        *RegEvent = REGEVENT_PALOGGEDOFF;
        return hr;
    }

    hr = ParseKnownString(EventBuf, EventBufLen, &EventBytesParsed,
                  "PA-Moved", sizeof("PA-Moved") - 1,
                  FALSE // case-insensitive
                  );
        
    if( hr == S_OK )
    {
        *RegEvent = REGEVENT_PAMOVED;
        
        //Get the contact of the new PA
        hr = GetEventContact( Buffer, BufLen, &BytesParsed );
        if( hr != S_OK )
        {
            LOG(( RTC_TRACE, "Could'nt get contact from the register event" ));

            return S_OK;
        }
        
        return hr;
    }
    
    hr = ParseKnownString(EventBuf, EventBufLen, &BytesParsed,
                  "ping", sizeof("ping") - 1,
                  FALSE // case-insensitive
                  );
        
    if( hr == S_OK )
    {
        *RegEvent = REGEVENT_PING;
    }
    
    return hr;
}

    
VOID
REGISTER_CONTEXT::HandleRegistrationError(
    HRESULT StatusCode
    )
{
    HRESULT     hr;

    ENTER_FUNCTION("REGISTER_CONTEXT::HandleRegistrationError");
    
    //retry after 2.5/5/10/10/10/10..... minutes
    if( m_RegisterRetryTime < (10*60000) )
    {
        m_RegisterRetryTime *= 2;
    }

    LOG(( RTC_TRACE, "%s Will try to register after %d milliseconds",
        __fxName, m_RegisterRetryTime ));

    if( IsTimerActive() )
    {
        KillTimer();
    }
    hr = StartTimer( m_RegisterRetryTime );

    if( hr == S_OK )
    {
        m_RegRetryState = REGISTER_RETRY;
    }
    else
    {
        LOG(( RTC_ERROR, "%s StartTimer failed %x", __fxName, hr ));
    }

    // Do this last as this function notifies core
    SetAndNotifyRegState(REGISTER_STATE_ERROR, StatusCode );
}


VOID
REGISTER_CONTEXT::HandleRegistrationSuccess(
    IN  SIP_MESSAGE    *pSipMsg
    )
{
    ENTER_FUNCTION("REGISTER_CONTEXT::HandleRegistrationSuccess");
    
    OUT PSTR    LocalContact;
    OUT ULONG   LocalContactLen;
    HRESULT     hr = S_OK;
    INT         expireTimeout = 0;

    GetContactURI( &LocalContact, &LocalContactLen );

    expireTimeout = pSipMsg  -> GetExpireTimeoutFromResponse(
        LocalContact, LocalContactLen, REGISTER_DEFAULT_TIMER );

    if( (expireTimeout != 0) && (expireTimeout != -1) )
    {
        m_expiresTimeout = expireTimeout;
    }            

    if(m_SSLTunnel && (m_expiresTimeout >  REGISTER_SSL_TUNNEL_TIMER)) 
        m_expiresTimeout = REGISTER_SSL_TUNNEL_TIMER;

    LOG(( RTC_TRACE, "Will try to register after %d seconds",
        m_expiresTimeout ));

    hr = StartTimer( m_expiresTimeout * 1000 );

    if( hr == S_OK )
    {
        m_RegRetryState = REGISTER_REFRESH;
    }
    else
    {
        LOG((RTC_ERROR, "%s StartTimer failed %x",
             __fxName, hr));
    }

    // Do this last as this function notifies core
    SetAndNotifyRegState( REGISTER_STATE_REGISTERED, 0 );

}    


VOID
REGISTER_CONTEXT::OnTimerExpire()
{
    HRESULT                     hr = S_OK;
    SIP_HEADER_ARRAY_ELEMENT    SipHdrElement;
    
    if( (m_RegRetryState == REGISTER_REFRESH) ||
        (m_RegRetryState == REGISTER_RETRY) )
    {   
        // Send the REGISTER request again
        m_RegRetryState = REGISTER_NONE;

        if( m_RequestDestAddr.sin_addr.S_un.S_addr == 0 )
        {
            hr = ResolveSipUrlAndSetRequestDestination(
                     m_RegistrarURI, m_RegistrarURILen,
                     FALSE, FALSE, FALSE, TRUE );

            if (hr != S_OK)
            {
                LOG(( RTC_ERROR, 
                    "ResolveSipUrlAndSetRequestDestination failed %x", hr ));
        
                HandleRegistrationError( hr );
                return;
            }
        }
        
        hr = CreateOutgoingRegisterTransaction( FALSE, NULL, FALSE, FALSE );

        if( hr == S_OK )
        {
            SetAndNotifyRegState( REGISTER_STATE_REGISTERING, 0 );
        }
        else
        {
            HandleRegistrationError( hr );
        }
    }

}


HRESULT
REGISTER_CONTEXT::ProcessRedirect(
    IN SIP_MESSAGE *pSipMsg
    )
{
    SIP_CALL_STATUS RegisterStatus;
    LPWSTR          wsStatusText = NULL;
    PSTR            ReasonPhrase = NULL;
    ULONG           ReasonPhraseLen = 0;
    HRESULT         hr = S_OK;
    
    ENTER_FUNCTION("REGISTER_CONTEXT::ProcessRedirect");

    if( m_pRedirectContext == NULL )
    {
        m_pRedirectContext = new REDIRECT_CONTEXT();
        if (m_pRedirectContext == NULL)
        {
            LOG((RTC_ERROR, "%s allocating redirect context failed",
                 __fxName));
            return E_OUTOFMEMORY;
        }
    }

    hr = m_pRedirectContext->AppendContactHeaders(pSipMsg);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s AppendContactHeaders failed %x",
             __fxName, hr));
        m_pRedirectContext->Release();
        m_pRedirectContext = NULL;
        return hr;
    }

    pSipMsg->GetReasonPhrase(&ReasonPhrase, &ReasonPhraseLen);
    
    if (ReasonPhrase != NULL)
    {
        hr = UTF8ToUnicode(ReasonPhrase, ReasonPhraseLen,
                           &wsStatusText);
        if (hr != S_OK)
        {
            wsStatusText = NULL;
        }
    }
    
    RegisterStatus.State             = SIP_CALL_STATE_DISCONNECTED;
    RegisterStatus.Status.StatusCode = 
        HRESULT_FROM_SIP_STATUS_CODE( pSipMsg -> GetStatusCode() );
    
    RegisterStatus.Status.StatusText = wsStatusText;

    // Keep a reference till the notify completes to make sure
    // that the SIP_CALL object is alive when the notification
    // returns.
    MsgProcAddRef();

    hr = m_pSipStack -> NotifyRegisterRedirect( 
                            this,
                            m_pRedirectContext, 
                            &RegisterStatus );

    // If a new registration is created as a result that REGSTER_CONTEXT will
    // AddRef() the redirect context.
    m_pRedirectContext -> Release();
    m_pRedirectContext = NULL;

    if (wsStatusText != NULL)
    {
        free(wsStatusText);
    }

    MsgProcRelease();

    if (hr != S_OK)
    {
        LOG(( RTC_ERROR, "%s NotifyRedirect failed %x", __fxName, hr ));
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
// OUTGOING_REGISTER_TRANSACTION
///////////////////////////////////////////////////////////////////////////////


OUTGOING_REGISTER_TRANSACTION::OUTGOING_REGISTER_TRANSACTION(
    IN REGISTER_CONTEXT    *pRegisterContext,
    IN ULONG                CSeq,
    IN BOOL                 AuthHeaderSent,
    IN BOOL                 fIsUnregister,
    IN BOOL                 fIsFirstRegister
    ) :
    OUTGOING_TRANSACTION(pRegisterContext,
                         SIP_METHOD_REGISTER,
                         CSeq,
                         AuthHeaderSent)
{
    m_pRegisterContext = pRegisterContext;
    m_fIsUnregister = fIsUnregister;
    m_fIsFirstRegister = fIsFirstRegister;

}


OUTGOING_REGISTER_TRANSACTION::~OUTGOING_REGISTER_TRANSACTION()
{
    LOG(( RTC_TRACE, "~OUTGOING_REGISTER_TRANSACTION: %x - deleted", this ));
}


HRESULT
OUTGOING_REGISTER_TRANSACTION::ProcessProvisionalResponse(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT hr;
    ENTER_FUNCTION("OUTGOING_REGISTER_TRANSACTION::ProcessProvisionalResponse");
    
    LOG((RTC_TRACE, "%s - Enter", __fxName));
    
    if (m_State != OUTGOING_TRANS_FINAL_RESPONSE_RCVD)
    {
        m_State = OUTGOING_TRANS_PROVISIONAL_RESPONSE_RCVD;
        
        // Cancel existing timer and Start Timer
        KillTimer();
        hr = StartTimer(SIP_TIMER_RETRY_INTERVAL_T2);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s StartTimer failed %x", __fxName, hr));
            TerminateTransactionOnError(hr);
            return hr;
        }
    }

    // Ignore the Provisional response if a final response
    // has already been received.
    return S_OK;
}


HRESULT
OUTGOING_REGISTER_TRANSACTION::ProcessRedirectResponse(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT hr;
    
    ENTER_FUNCTION( "OUTGOING_INVITE_TRANSACTION::ProcessRedirectResponse" );

    // 380 is also a failure from our point of view.
    // We don't handle redirects for refreshes.
    // We don't support redirect from a TLS session.
    if( (pSipMsg->GetStatusCode() == 380) || !m_fIsFirstRegister ||
        m_pSipMsgProc->GetTransport() == SIP_TRANSPORT_SSL )
        
    {
        return ProcessFailureResponse( pSipMsg );
    }

    hr = m_pRegisterContext -> ProcessRedirect( pSipMsg );
    if( hr != S_OK )
    {
        LOG(( RTC_ERROR, "%s  ProcessRedirect failed %x", __fxName, hr ));

        if( m_fIsUnregister == FALSE )
        {
            m_pRegisterContext -> HandleRegistrationError( hr );
        }
        else
        {
            m_pRegisterContext->SetAndNotifyRegState( 
                REGISTER_STATE_UNREGISTERED, 0 );
        }

        return hr;
    }

    return S_OK;
}


//
// We need the fIsUnregister parameter to create the new transaction with the
// credentials info
//
HRESULT
OUTGOING_REGISTER_TRANSACTION::ProcessAuthRequiredResponse(
    IN SIP_MESSAGE *pSipMsg,
    IN BOOL         fIsUnregister,
    OUT BOOL       &fDelete
    )
{
    HRESULT                     hr;
    CHAR                        Buffer[1024];
    SIP_HEADER_ARRAY_ELEMENT    SipHdrElement;
    SECURITY_CHALLENGE          SecurityChallenge;

    SipHdrElement.HeaderValue = Buffer;
    SipHdrElement.HeaderValueLen = sizeof(Buffer);

    ENTER_FUNCTION("OUTGOING_REGISTER_TRANSACTION::ProcessAuthRequiredResponse");

    LOG((RTC_TRACE, "%s - enter", __fxName));

    // We need to addref the transaction as we could show credentials UI.
    TransactionAddRef();

    // Since we don't show the credentials UI there is no need to
    // AddRef the transaction here.
    hr = ProcessAuthRequired(pSipMsg,
                             TRUE,
                             &SipHdrElement,
                             &SecurityChallenge );
    if (hr != S_OK)
    {
        LOG(( RTC_ERROR, "%s - ProcessAuthRequired failed %x", __fxName, hr ));

        if( m_fIsUnregister == FALSE )
        {
            m_pRegisterContext -> HandleRegistrationError( 
                HRESULT_FROM_SIP_STATUS_CODE(pSipMsg->GetStatusCode()) );
        }
        else
        {
            m_pRegisterContext->SetAndNotifyRegState( 
                REGISTER_STATE_UNREGISTERED, 0 );
        }

        goto done;
    }


    hr = m_pRegisterContext->CreateOutgoingRegisterTransaction(
             TRUE, &SipHdrElement, fIsUnregister, m_fIsFirstRegister
             );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - CreateOutgoingRegisterTransaction failed %x",
             __fxName, hr));
        
        if( m_fIsUnregister == FALSE )
        {
            m_pRegisterContext -> HandleRegistrationError( hr );
        }
        else
        {
            m_pRegisterContext->SetAndNotifyRegState( 
                REGISTER_STATE_UNREGISTERED, 0 );
        }

        goto done;
    }

    hr = S_OK;

done:

    TransactionRelease();

    return hr;
}


HRESULT
OUTGOING_REGISTER_TRANSACTION::ProcessFailureResponse(
    IN SIP_MESSAGE *pSipMsg
    )
{
    LOG((RTC_TRACE, "received non-200 %d Registration FAILED",
        pSipMsg->Response.StatusCode));

    if( m_fIsUnregister == FALSE ) 
    {
        if( (pSipMsg->Response.StatusCode != SIP_STATUS_CLIENT_METHOD_NOT_ALLOWED) &&
            (pSipMsg->Response.StatusCode != SIP_STATUS_CLIENT_FORBIDDEN) )
        {
            m_pRegisterContext -> HandleRegistrationError(
                HRESULT_FROM_SIP_STATUS_CODE(pSipMsg->GetStatusCode()) );
        }
        else
        {
            m_pRegisterContext -> SetAndNotifyRegState( 
                REGISTER_STATE_REJECTED, 
                HRESULT_FROM_SIP_STATUS_CODE(pSipMsg->GetStatusCode()) );
        }
    }
    else
    {
        m_pRegisterContext->SetAndNotifyRegState( 
            REGISTER_STATE_UNREGISTERED, 0 );
    }

    return S_OK;
}


HRESULT
OUTGOING_REGISTER_TRANSACTION::ProcessFinalResponse(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT             hr = S_OK;
    BOOL                fDelete = TRUE;
    REGISTER_CONTEXT   *pRegisterContext = m_pRegisterContext;
    BOOL                fIsUnregister = m_fIsUnregister;

    ENTER_FUNCTION( "OUTGOING_REGISTER_TRANSACTION::ProcessFinalResponse" );
    
    if (m_State != OUTGOING_TRANS_FINAL_RESPONSE_RCVD)
    {
        // This refcount must be released before returning from this function 
        // without any exception. Only in case of kerberos we keep this refcount.
        TransactionAddRef();

        OnTransactionDone();

        m_State = OUTGOING_TRANS_FINAL_RESPONSE_RCVD;

        // Do not process the response if already in unreg state.
        if( m_fIsUnregister == FALSE )
        {
            if( (pRegisterContext -> GetState() ==  REGISTER_STATE_UNREGISTERED) ||
                (pRegisterContext -> GetState() ==  REGISTER_STATE_UNREGISTERING) )
            {
                TransactionRelease();
                return S_OK;
            }
        }

        if (IsSuccessfulResponse(pSipMsg))
        {
            hr = ProcessSuccessfulResponse( pSipMsg, pRegisterContext,
                    fIsUnregister );
        }
        else if (IsRedirectResponse(pSipMsg))
        {
            hr = ProcessRedirectResponse(pSipMsg);
        }
        else if (IsAuthRequiredResponse(pSipMsg))
        {
            hr = ProcessAuthRequiredResponse(pSipMsg, m_fIsUnregister, fDelete);
        }
        else if (IsFailureResponse(pSipMsg))
        {
            hr = ProcessFailureResponse( pSipMsg );
        }

        if( fDelete == TRUE )
        {
            TransactionRelease();
        }
    }

    return hr;
}


HRESULT
OUTGOING_REGISTER_TRANSACTION::ProcessSuccessfulResponse(
    IN  SIP_MESSAGE        *pSipMsg,
    IN  REGISTER_CONTEXT   *pRegisterContext,
    IN  BOOL                fIsUnregister        
    )
{
    if(fIsUnregister == FALSE)
    {
        pRegisterContext->HandleRegistrationSuccess(pSipMsg);

        LOG(( RTC_TRACE, "OUTGOING_REGISTER_TRANSACTION::ProcessSuccessfulResponse"
          " received 200 Registration SUCCEEDED" ));
    }
    else
    {
        pRegisterContext->SetAndNotifyRegState( 
            REGISTER_STATE_UNREGISTERED, 0 );

        LOG(( RTC_TRACE, "OUTGOING_REGISTER_TRANSACTION::ProcessSuccessfulResponse"
          " received 200 UnRegistration SUCCEEDED" ));
    }

    return S_OK;
}


HRESULT
OUTGOING_REGISTER_TRANSACTION::ProcessResponse(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT hr;
    
    ASSERT(pSipMsg->MsgType == SIP_MESSAGE_TYPE_RESPONSE);

    if (IsProvisionalResponse(pSipMsg))
    {
        return ProcessProvisionalResponse(pSipMsg);
    }
    else if (IsFinalResponse(pSipMsg))
    {
        return ProcessFinalResponse(pSipMsg);
    }
    else
    {
        ASSERT(FALSE);
        return E_FAIL;
    }
}


BOOL
OUTGOING_REGISTER_TRANSACTION::MaxRetransmitsDone()
{
    return (m_pRegisterContext->GetTransport() != SIP_TRANSPORT_UDP ||
            m_NumRetries >= 11);
}


VOID
OUTGOING_REGISTER_TRANSACTION::TerminateTransactionOnError(
    IN HRESULT      hr
    )
{
    REGISTER_CONTEXT   *pRegisterContext = NULL;
    BOOL                IsFirstRegister;
    BOOL                fIsUnregister = m_fIsUnregister;

    ENTER_FUNCTION("OUTGOING_REGISTER_TRANSACTION::TerminateTransactionOnError");
    LOG(( RTC_TRACE, "%s - enter", __fxName ));

    pRegisterContext = m_pRegisterContext;
    // Deleting the transaction could result in the
    // reg context deleted. So, we AddRef() it to keep it alive.
    pRegisterContext->MsgProcAddRef();
    
    // Delete the transaction before you call
    // HandleRegistrationError as that call will notify the UI
    // and could get stuck till the dialog box returns.
    OnTransactionDone();
    
    if( fIsUnregister == FALSE )
    {
        pRegisterContext -> HandleRegistrationError( hr );
    }
    else
    {
        pRegisterContext->SetAndNotifyRegState(
            REGISTER_STATE_UNREGISTERED, 0 );
    }
    
    pRegisterContext->MsgProcRelease();
}


VOID
OUTGOING_REGISTER_TRANSACTION::OnTimerExpire()
{
    HRESULT   hr;
    
    ENTER_FUNCTION("OUTGOING_REGISTER_TRANSACTION::OnTimerExpire");

    // If we are already in unreg state then kill this transaction.
    if( m_fIsUnregister == FALSE )
    {
        if( (m_pRegisterContext -> GetState() ==  REGISTER_STATE_UNREGISTERED) ||
            (m_pRegisterContext -> GetState() ==  REGISTER_STATE_UNREGISTERING) )
        {
            OnTransactionDone();
            return;
        }
    }

    switch (m_State)
    {
        // we have to retransmit the request even after receiving
        // a provisional response.
    case OUTGOING_TRANS_REQUEST_SENT:
    case OUTGOING_TRANS_PROVISIONAL_RESPONSE_RCVD:

        // Retransmit the request
        if (MaxRetransmitsDone())
        {
            LOG((RTC_ERROR,
                 "%s MaxRetransmits for request Done terminating transaction",
                 __fxName));

            hr = RTC_E_SIP_TIMEOUT;
            goto error;
        }
        else
        {
            LOG((RTC_TRACE, "%s retransmitting request m_NumRetries : %d",
                 __fxName, m_NumRetries));
            hr = RetransmitRequest();
            
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s resending request failed %x",
                     __fxName, hr));
                goto error;
            }

            if (m_TimerValue*2 >= SIP_TIMER_RETRY_INTERVAL_T2)
            {
                m_TimerValue = SIP_TIMER_RETRY_INTERVAL_T2;
            }
            else
            {
                m_TimerValue *= 2;
            }

            hr = StartTimer(m_TimerValue);
            
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s StartTimer failed %x",
                     __fxName, hr));                
                goto error;
            }
        }
        break;

    case OUTGOING_TRANS_FINAL_RESPONSE_RCVD:
    case OUTGOING_TRANS_INIT:
    default:

        LOG((RTC_ERROR, "%s timer expired in invalid state %d",
             __fxName, m_State));
        ASSERT(FALSE);
        break;
    }

    return;
    
error:

    TerminateTransactionOnError(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\reqfail.h ===
//reqfail.h
//Sends an error response denoted by the statusCode

#ifndef __sipcli_reqfail_h__
#define __sipcli_reqfail_h__

#include "sipcall.h"

class REQFAIL_MSGPROC;

class INCOMING_REQFAIL_TRANSACTION : public INCOMING_TRANSACTION
{
public:
    INCOMING_REQFAIL_TRANSACTION(
        IN SIP_MSG_PROCESSOR   *pSipMsgProc,
        IN SIP_METHOD_ENUM      MethodId,
        IN ULONG                CSeq,
        IN ULONG                StatusCode
        );

    ~INCOMING_REQFAIL_TRANSACTION();
    
    HRESULT SetMethodStr(
        IN PSTR   MethodStr,
        IN ULONG  MethodStrLen
        );
    
    HRESULT ProcessRequest(
        IN SIP_MESSAGE  *pSipMsg,
        IN ASYNC_SOCKET *pResponseSocket
        );
   
    HRESULT ProcessRequest(
        IN SIP_MESSAGE  *pSipMsg,
        IN ASYNC_SOCKET *pResponseSocket,
        IN SIP_HEADER_ARRAY_ELEMENT   *pAdditionalHeaderArray,
        IN ULONG AdditionalHeaderCount
        );

//      HRESULT SendResponse(
//          IN ULONG StatusCode,
//          IN PSTR  ReasonPhrase,
//          IN ULONG ReasonPhraseLen
//          );

    VOID OnTimerExpire();

    HRESULT RetransmitResponse();

private:
    ULONG    m_StatusCode;
    
    // In case the method is not known    
    PSTR     m_MethodStr;

    //virtual fn
    HRESULT TerminateTransactionOnByeOrCancel(
        OUT BOOL *pCallDisconnected
        );

};


// This class processes error messages (400 class)
class REQFAIL_MSGPROC :
    public SIP_MSG_PROCESSOR
{
public:
    REQFAIL_MSGPROC(
        IN  SIP_STACK         *pSipStack
        );

    ~REQFAIL_MSGPROC();
   
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    BOOL IsSessionDisconnected();

    HRESULT StartIncomingCall(
        IN  SIP_TRANSPORT   Transport,
        IN  SIP_MESSAGE    *pSipMsg,
        IN  ASYNC_SOCKET   *pResponseSocket,
        IN  ULONG    StatusCode,
        SIP_HEADER_ARRAY_ELEMENT   *pAdditionalHeaderArray = NULL,
        ULONG AdditionalHeaderCount = 0
        );

private:
    //Variables
    ULONG m_StatusCode;

    //Virtual fns

    HRESULT CreateIncomingTransaction(
        IN SIP_MESSAGE  *pSipMsg,
        IN ASYNC_SOCKET *pResponseSocket
        );

    VOID OnError();


};
#endif // __sipcli_reqfail_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\redirect.cpp ===
#include "precomp.h"
#include "sipcall.h"


REDIRECT_CONTEXT::REDIRECT_CONTEXT()
{
    m_RefCount = 1;
    InitializeListHead(&m_ContactList);
    m_pCurrentContact = &m_ContactList;
}


REDIRECT_CONTEXT::~REDIRECT_CONTEXT()
{
    FreeContactHeaderList(&m_ContactList);
}


///////////////////////////////////////////////////////////////////////////////
// ISipRedirectContext
///////////////////////////////////////////////////////////////////////////////


// Gets the SIP URL and Display name for creating the call.
// The caller needs to free the strings returned using SysFreeString()
STDMETHODIMP
REDIRECT_CONTEXT::GetSipUrlAndDisplayName(
    OUT  BSTR  *pbstrSipUrl,
    OUT  BSTR  *pbstrDisplayName
    )
{
    CONTACT_HEADER  *pContactHeader;
    LPWSTR           wsDisplayName;
    LPWSTR           wsSipUrl;
    HRESULT          hr;

    ENTER_FUNCTION("REDIRECT_CONTEXT::GetSipUrlAndDisplayName");
    
    if (m_pCurrentContact == &m_ContactList)
    {
        return S_FALSE;
    }
    
    pContactHeader = CONTAINING_RECORD(m_pCurrentContact,
                                       CONTACT_HEADER,
                                       m_ListEntry);

    if (pContactHeader->m_DisplayName.Length != 0)
    {
        hr = UTF8ToUnicode(pContactHeader->m_DisplayName.Buffer,
                           pContactHeader->m_DisplayName.Length,
                           &wsDisplayName);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s - UTF8ToUnicode failed %x", __fxName, hr));
            return hr;
        }

        *pbstrDisplayName = SysAllocString(wsDisplayName);
        free(wsDisplayName);
        if (*pbstrDisplayName == NULL)
        {
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        *pbstrDisplayName = NULL;
    }
    
    if (pContactHeader->m_SipUrl.Length != 0)
    {
        hr = UTF8ToUnicode(pContactHeader->m_SipUrl.Buffer,
                           pContactHeader->m_SipUrl.Length,
                           &wsSipUrl);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s - UTF8ToUnicode failed %x", __fxName, hr));
            return hr;
        }

        *pbstrSipUrl = SysAllocString(wsSipUrl);
        free(wsSipUrl);
        if (*pbstrSipUrl == NULL)
        {
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        *pbstrSipUrl = NULL;
    }
    
    return S_OK;
}


// Move to the next url in the list of contacts.
// Returns E_FAIL if we hit the end of list.
// XXX TODO Compare the new URL with the ones tried already
// and if we already tried this URL just skip it.
// Or should we remove duplicates when we add them to the
// list ?
STDMETHODIMP
REDIRECT_CONTEXT::Advance()
{
    m_pCurrentContact = m_pCurrentContact->Flink;
    if (m_pCurrentContact == &m_ContactList)
    {
        return S_FALSE;
    }

    return S_OK;
}


HRESULT
REDIRECT_CONTEXT::UpdateContactList(
    IN LIST_ENTRY *pNewContactList
    )
{
    ENTER_FUNCTION("REDIRECT_CONTEXT::UpdateContactList");
    
    HRESULT          hr;
    LIST_ENTRY      *pListEntry;
    LIST_ENTRY      *pNextEntry;
    LIST_ENTRY      *pSrchListEntry;
    CONTACT_HEADER  *pContactHeader;
    CONTACT_HEADER  *pNewContactHeader;
    BOOL            isContactHeaderPresent = FALSE;
    pListEntry = m_pCurrentContact->Flink;
    ULONG BytesParsed = 0;
    SIP_URL SipUrl1, SipUrl2;


    // Delete any elements after the current contact entry.
    while (pListEntry != &m_ContactList)
    {
        pNextEntry = pListEntry->Flink;
        RemoveEntryList(pListEntry);
        pContactHeader = CONTAINING_RECORD(pListEntry,
                                           CONTACT_HEADER,
                                           m_ListEntry);
        delete pContactHeader;
        pListEntry = pNextEntry;
    }


    // Add the new contact list to this list.
    // Remove any duplicates.

    while (!IsListEmpty(pNewContactList))
    {
        pListEntry = RemoveHeadList(pNewContactList);

        pNewContactHeader = CONTAINING_RECORD(pListEntry,
                                              CONTACT_HEADER,
                                              m_ListEntry);
        hr = ParseSipUrl(
                 pNewContactHeader->m_SipUrl.Buffer,
                 pNewContactHeader->m_SipUrl.Length,
                 &BytesParsed,
                 &SipUrl1
                 );
        BytesParsed = 0;
        if (hr != S_OK)
        {
            // If parsing a contact header fails we just skip it.
            LOG((RTC_ERROR,
                 "%s - pNewContactHeader URI parsing failed %x - skipping Contact",
                __fxName, hr));
            continue;
        }

        if (SipUrl1.m_TransportParam == SIP_TRANSPORT_SSL)
        {
            // We skip any TLS contacts.
            LOG((RTC_ERROR,
                 "%s - skipping TLS Contact header",
                __fxName, hr));
            continue;
        }
        
        // Check whether this is a duplicate SIP URL
        pSrchListEntry = m_ContactList.Flink;
        while (pSrchListEntry != &m_ContactList && !isContactHeaderPresent)
        {
            pContactHeader = CONTAINING_RECORD(pSrchListEntry,
                                               CONTACT_HEADER,
                                               m_ListEntry);
            hr = ParseSipUrl(
                     pContactHeader->m_SipUrl.Buffer,
                     pContactHeader->m_SipUrl.Length,
                     &BytesParsed,
                     &SipUrl2
                     );
            BytesParsed = 0;
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s - pContactHeader URI parsing failed %x",
                    __fxName, hr));
                // We have tested the parsing before we added it to the list.
                ASSERT(FALSE);
                continue;
            }
            
            isContactHeaderPresent = AreSipUrlsEqual(&SipUrl1, &SipUrl2);

            SipUrl2.FreeSipUrl();
            
            if (isContactHeaderPresent)
            {
                LOG((RTC_TRACE, "%s - Duplicate Sip Url found in the contact header",
                     __fxName));
            }

            pSrchListEntry = pSrchListEntry->Flink;
        }
        if(!isContactHeaderPresent)
            InsertTailList(&m_ContactList, pListEntry);

        SipUrl1.FreeSipUrl();
    }
    
    return S_OK;
}


HRESULT
REDIRECT_CONTEXT::AppendContactHeaders(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT     hr;
    LIST_ENTRY  NewContactList;

    ENTER_FUNCTION("REDIRECT_CONTEXT::AppendContactHeaders");

    InitializeListHead(&NewContactList);
    
    hr = pSipMsg->ParseContactHeaders(&NewContactList);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s ParseContactHeaders failed %x",
             __fxName, hr));
        return hr;
    }

    // The whole NewContactList is moved to the contact list
    // of the redirect context.
    hr = UpdateContactList(&NewContactList);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s UpdateContactList failed %x", __fxName, hr));
        return hr;
    }

    ASSERT(IsListEmpty(&NewContactList));
    
    return S_OK;
}



///////////////////////////////////////////////////////////////////////////////
// IUnknown
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP_(ULONG)
REDIRECT_CONTEXT::AddRef()
{
    m_RefCount++;
    LOG((RTC_TRACE, "REDIRECT_CONTEXT::AddRef this: %x m_RefCount: %d",
         this, m_RefCount));
    return m_RefCount;
}


STDMETHODIMP_(ULONG)
REDIRECT_CONTEXT::Release()
{
    m_RefCount--;
    LOG((RTC_TRACE, "REDIRECT_CONTEXT::Release this: %x m_RefCount: %d",
         this, m_RefCount));
    if (m_RefCount != 0)
    {
        return m_RefCount;
    }
    else
    {
        delete this;
        return 0;
    }
}


STDMETHODIMP
REDIRECT_CONTEXT::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (riid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown *>(this);
    }
    else if (riid == IID_ISipRedirectContext)
    {
        *ppv = static_cast<ISipRedirectContext *>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    static_cast<IUnknown *>(*ppv)->AddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\resolve.h ===
#ifndef __sipcli_resolve_h__
#define __sipcli_resolve_h__

class __declspec(novtable) DNS_RESOLUTION_COMPLETION_INTERFACE
{
public:    

    // Only called for TCP sockets
    virtual void OnDnsResolutionComplete(
        IN HRESULT      ErrorCode,
        IN SOCKADDR_IN *pSockAddr,
        IN PSTR         pszHostName,
        IN USHORT       usPort
        ) = 0;
};


// Host could be IP address or host name.
HRESULT
ResolveHost(
    IN  PSTR            Host,
    IN  ULONG           HostLen,
    IN  USHORT          Port,
    IN  SIP_TRANSPORT   Transport,
    OUT SOCKADDR_IN    *pDstAddr
    );

//  HRESULT
//  ResolveSipUrl(
//      IN  SIP_URL        *pSipUrl, 
//      OUT SOCKADDR_IN    *pDstAddr,
//      OUT SIP_TRANSPORT  *pTransport 
//      );

//  HRESULT
//  ResolveSipUrl(
//      IN  PSTR            DstUrl,
//      IN  ULONG           DstUrlLen,
//      OUT SOCKADDR_IN    *pDstAddr,
//      OUT SIP_TRANSPORT  *pTransport
//      );


HRESULT
QueryDNSSrv(
    IN       SIP_TRANSPORT  Transport, 
    IN       PSTR           pszSrvName,
    IN   OUT SOCKADDR      *pSockAddr,
    OUT      PSTR          *ppszDestHostName
    );

class DNS_RESOLUTION_WORKITEM :
    public ASYNC_WORKITEM
{
public:

    DNS_RESOLUTION_WORKITEM(
        IN ASYNC_WORKITEM_MGR *pWorkItemMgr
        );
    ~DNS_RESOLUTION_WORKITEM();
    
//      HRESULT GetWorkItemParam();

    VOID ProcessWorkItem();
    
    VOID NotifyWorkItemComplete();

    HRESULT SetHostPortTransportAndDnsCompletion(
        IN  PSTR                                    Host,
        IN  ULONG                                   HostLen,
        IN  USHORT                                  Port,
        IN  SIP_TRANSPORT                           Transport,
        IN  DNS_RESOLUTION_COMPLETION_INTERFACE    *pDnsCompletion
        );
    
private:

    DNS_RESOLUTION_COMPLETION_INTERFACE *m_pDnsCompletion;

    // Params
    PSTR                m_Host;
    ULONG               m_Port;
    SIP_TRANSPORT       m_Transport;

    // Result
    HRESULT             m_ErrorCode;
    SOCKADDR_IN         m_Sockaddr;
    
};

#endif // __sipcli_resolve_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\reqfail.cpp ===
//reqfail.cpp

#include "precomp.h"
#include "sipstack.h"
#include "reqfail.h"
//#include "resolve.h"

///////////////////////////////////////////////////////////////////////////////
// REQFAIL_MSGPROC
///////////////////////////////////////////////////////////////////////////////


REQFAIL_MSGPROC::REQFAIL_MSGPROC(
    IN  SIP_STACK         *pSipStack
    ) :
    SIP_MSG_PROCESSOR(SIP_MSG_PROC_TYPE_REQFAIL, pSipStack, NULL )
{
    m_StatusCode = 0;
}


REQFAIL_MSGPROC::~REQFAIL_MSGPROC()
{
    LOG((RTC_TRACE, "~REQFAIL_MSGPROC()"));
}

STDMETHODIMP_(ULONG) 
REQFAIL_MSGPROC::AddRef()
{
    return MsgProcAddRef();

}

STDMETHODIMP_(ULONG) 
REQFAIL_MSGPROC::Release()
{
    return MsgProcRelease();

}
/*
STDMETHODIMP 
REQFAIL_MSGPROC::QueryInterface(
        IN  REFIID riid,
        OUT LPVOID *ppv
        )
{
    if (riid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown *>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    static_cast<IUnknown *>(*ppv)->AddRef();
    return S_OK;

}
*/


HRESULT
REQFAIL_MSGPROC::StartIncomingCall(
    IN  SIP_TRANSPORT   Transport,
    IN  SIP_MESSAGE    *pSipMsg,
    IN  ASYNC_SOCKET   *pResponseSocket,
    IN  ULONG    StatusCode,
    SIP_HEADER_ARRAY_ELEMENT   *pAdditionalHeaderArray,
    ULONG AdditionalHeaderCount
    )
{
    HRESULT     hr;
    PSTR        Header = NULL;
    ULONG       HeaderLen = 0;

    ENTER_FUNCTION("REQFAIL::StartIncomingCall");
    LOG((RTC_TRACE, "%s - enter", __fxName));
    
    m_Transport = Transport;

    hr = pSipMsg->GetSingleHeader(SIP_HEADER_TO, &Header, &HeaderLen);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s getting To header failed %x",
             __fxName, hr));
        //return hr;
    }

    if(hr == S_OK)
    {
        hr = SetLocalForIncomingCall(Header, HeaderLen);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s SetLocalForIncomingCall failed %x",
                 __fxName, hr));
            return hr;
        }
    }

    //if no from in msg, drop it
    hr = pSipMsg->GetSingleHeader(SIP_HEADER_FROM, &Header, &HeaderLen);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s getting From header failed %x",
             __fxName, hr));
        return hr;
    }
    
    hr = SetRemoteForIncomingSession(Header, HeaderLen);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s SetRemoteForIncomingSession failed %x",
             __fxName, hr));
        return hr;
    }
    
    hr = pSipMsg->GetSingleHeader(SIP_HEADER_CALL_ID, &Header, &HeaderLen);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s getting Call-ID header failed %x",
             __fxName, hr));
        return hr;
    }
    hr = SetCallId(Header, HeaderLen);
    if (hr != S_OK)
    {
            LOG((RTC_ERROR, "%s SetCallId failed %x",
                 __fxName, hr));
            return hr;
    }

    if (Transport != SIP_TRANSPORT_UDP &&
        m_pRequestSocket == NULL)
    {
        hr = SetRequestSocketForIncomingSession(pResponseSocket);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR,
                 "%s SetRequestSocketForIncomingSession failed %x",
                 __fxName, hr));
            return hr;
        }
    }

    //Set Statuscode before invoking CreateIncomingTransaction
    m_StatusCode = StatusCode;
    hr = CreateIncomingReqFailTransaction(pSipMsg, pResponseSocket,
                                          StatusCode,
                                          pAdditionalHeaderArray,
                                          AdditionalHeaderCount
                                        );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s CreateIncomingReqFailTransaction failed %x",
             __fxName, hr));
        return hr;
    }
  
    return S_OK;
}


// We respond to any new transaction for this msg proc
// with the same error code.
HRESULT
REQFAIL_MSGPROC::CreateIncomingTransaction(
    IN SIP_MESSAGE  *pSipMsg,
    IN ASYNC_SOCKET *pResponseSocket
    )
{
    HRESULT         hr;

    ENTER_FUNCTION("REQFAIL_MSGPROC::CreateIncomingTransaction");
    
    LOG((RTC_TRACE, "%s - Enter", __fxName));

    hr = CreateIncomingReqFailTransaction(pSipMsg, pResponseSocket,
                                          m_StatusCode);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s CreateIncomingReqFailTransaction failed %x",
             __fxName, hr));
        return hr;
    }
    
    return S_OK;
}

BOOL
REQFAIL_MSGPROC::IsSessionDisconnected()
{
    return FALSE;
}


VOID 
REQFAIL_MSGPROC::OnError()
{
    LOG((RTC_TRACE, "REGISTER_CONTEXT::OnError - enter"));
}


///////////////////////////////////////////////////////////////////////////////
// Incoming Reqfail
///////////////////////////////////////////////////////////////////////////////


INCOMING_REQFAIL_TRANSACTION::INCOMING_REQFAIL_TRANSACTION(
    IN SIP_MSG_PROCESSOR   *pSipMsgProc,
    IN SIP_METHOD_ENUM      MethodId,
    IN ULONG                CSeq,
    IN ULONG                StatusCode
    ) :
    INCOMING_TRANSACTION(pSipMsgProc, MethodId, CSeq)
{
    m_StatusCode = StatusCode;
    m_MethodStr  = NULL;
}


INCOMING_REQFAIL_TRANSACTION::~INCOMING_REQFAIL_TRANSACTION()
{
    if (m_MethodStr != NULL)
    {
        free(m_MethodStr);
    }
    
    LOG((RTC_TRACE, "~INCOMING_REQFAIL_TRANSACTION() done"));
}

HRESULT
INCOMING_REQFAIL_TRANSACTION::SetMethodStr(
    IN PSTR   MethodStr,
    IN ULONG  MethodStrLen
    )
{
    HRESULT hr;
    
    ENTER_FUNCTION("INCOMING_REQFAIL_TRANSACTION::SetMethodStr");
    
    if (MethodStr != NULL)
    {
        hr = GetNullTerminatedString(MethodStr, MethodStrLen,
                                     &m_MethodStr);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s AllocAndCopyString failed %x",
                 __fxName, hr));
        }
    }

    return S_OK;
}

    
//virtual function
HRESULT
INCOMING_REQFAIL_TRANSACTION::ProcessRequest(
    IN SIP_MESSAGE  *pSipMsg,
    IN ASYNC_SOCKET *pResponseSocket
    )
{
    HRESULT hr = S_OK;;
    LOG((RTC_TRACE, 
        "Inside INCOMING_REQFAIL_TRANSACTION::ProcessRequest with no additional headers"));
    hr = ProcessRequest(pSipMsg, 
                   pResponseSocket,
                   NULL, 0 //No additional headers
                   );
    return hr;
}

HRESULT
INCOMING_REQFAIL_TRANSACTION::ProcessRequest(
    IN SIP_MESSAGE  *pSipMsg,
    IN ASYNC_SOCKET *pResponseSocket,
    IN SIP_HEADER_ARRAY_ELEMENT   *pAdditionalHeaderArray,
    IN ULONG AdditionalHeaderCount
    )
{
    HRESULT hr;
    ASSERT(pSipMsg->MsgType == SIP_MESSAGE_TYPE_REQUEST);
    SIP_HEADER_ARRAY_ELEMENT Additional405HeaderArray;
    ULONG Additional405HeaderCount;
    PSTR Header = NULL;
    ULONG HeaderLen = 0;
    ENTER_FUNCTION("INCOMING_REQFAIL_TRANSACTION::ProcessRequest");
    LOG((RTC_TRACE, "%s - Enter", __fxName));
    if (pSipMsg->Request.MethodId == SIP_METHOD_ACK)
        m_State = INCOMING_TRANS_ACK_RCVD;

    switch (m_State)
    {
    case INCOMING_TRANS_INIT:
        LOG((RTC_TRACE, "%s sending %d", __fxName, m_StatusCode));
        int ReasonPhraseLen;
        PCHAR ReasonPhrase;

        switch (m_StatusCode)
        {
        case 400:
            ReasonPhrase    = SIP_STATUS_TEXT(400);
            ReasonPhraseLen = SIP_STATUS_TEXT_SIZE(400);
            break;
            
        case 481:
            ReasonPhrase    = SIP_STATUS_TEXT(481);
            ReasonPhraseLen = SIP_STATUS_TEXT_SIZE(481);
            break;
        
        case 415:
            ReasonPhrase    = SIP_STATUS_TEXT(415);
            ReasonPhraseLen = SIP_STATUS_TEXT_SIZE(415);
            break;
            
        case 406:
            ReasonPhrase    = SIP_STATUS_TEXT(406);
            ReasonPhraseLen = SIP_STATUS_TEXT_SIZE(406);
            break;
            
        case 420:
            ReasonPhrase    = SIP_STATUS_TEXT(420);
            ReasonPhraseLen = SIP_STATUS_TEXT_SIZE(420);
            break;

        case 480:
            ReasonPhrase    = SIP_STATUS_TEXT(480);
            ReasonPhraseLen = SIP_STATUS_TEXT_SIZE(480);
            break;

        case 505:
            ReasonPhrase    = SIP_STATUS_TEXT(505);
            ReasonPhraseLen = SIP_STATUS_TEXT_SIZE(505);
            break;

        case 405:
            ReasonPhrase    = SIP_STATUS_TEXT(405);
            ReasonPhraseLen = SIP_STATUS_TEXT_SIZE(405);
            //We are assuming that no additional parameter other than Allow
            //should be sent with 405
            ASSERT(pAdditionalHeaderArray == NULL);
            Additional405HeaderArray.HeaderId = SIP_HEADER_ALLOW;
            Additional405HeaderArray.HeaderValueLen = strlen(SIP_ALLOW_TEXT);
            Additional405HeaderArray.HeaderValue = SIP_ALLOW_TEXT;
            Additional405HeaderCount = 1;
            break;
            
        default:
            ReasonPhrase    = NULL;
            ReasonPhraseLen = 0;
        }
        
        if(m_StatusCode != 405)
        {
            hr = CreateAndSendResponseMsg(
                     m_StatusCode,
                     ReasonPhrase,
                     ReasonPhraseLen,
                     m_MethodStr,
                     FALSE,   // No Contact header  
                     NULL, 0,  // No Message Body
                     NULL, 0, // No content Type
                     pAdditionalHeaderArray,
                     AdditionalHeaderCount
                     );
        }
        else
        {
        hr = CreateAndSendResponseMsg(
                 m_StatusCode,
                 ReasonPhrase,
                 ReasonPhraseLen,
                 m_MethodStr,
                 FALSE,   // No Contact header  
                 NULL, 0,  // No Message Body
                 NULL, 0, // No content Type
                 &Additional405HeaderArray,
                 Additional405HeaderCount
                 );
        }
        Header = NULL;
        Additional405HeaderArray.HeaderValue = NULL;
        if (hr != S_OK)
        {
            LOG((RTC_ERROR,
                 "%s  CreateAndSendResponseMsg failed %x - deleting transaction",
                 __fxName, hr));
            OnTransactionDone();
            return hr;
        }
        m_State = INCOMING_TRANS_FINAL_RESPONSE_SENT;

        // This timer will just ensure that we maintain state to
        // deal with retransmits of requests
        hr = StartTimer(SIP_TIMER_MAX_INTERVAL);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s StartTimer failed %x - deleting transaction",
                 __fxName, hr));
            OnTransactionDone();
            return hr;
        }
        break;
        
    case INCOMING_TRANS_FINAL_RESPONSE_SENT:
        // Retransmit the response
        LOG((RTC_TRACE, "%s retransmitting final response", __fxName));
        hr = RetransmitResponse();
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s  resending final response failed %x",
                 __fxName, hr));
            OnTransactionDone();
            return hr;
        }
        break;
    case INCOMING_TRANS_ACK_RCVD:
        OnTransactionDone();
        break;
    case INCOMING_TRANS_REQUEST_RCVD:
    default:
        // We should never be in these states
        LOG((RTC_TRACE, "%s Invalid state %d", __fxName, m_State));
        ASSERT(FALSE);
        OnTransactionDone();
        return E_FAIL;
    }

    return S_OK;
}


HRESULT
INCOMING_REQFAIL_TRANSACTION::RetransmitResponse()
{
    DWORD Error;

    ENTER_FUNCTION("INCOMING_REQFAIL_TRANSACTION::RetransmitResponse");
    // Send the buffer.
    Error = m_pResponseSocket->Send(m_pResponseBuffer);
    if (Error != NO_ERROR && Error != WSAEWOULDBLOCK)
    {
        LOG((RTC_ERROR, "%s Send failed %x", __fxName, Error));
        return HRESULT_FROM_WIN32(Error);
    }

    return S_OK;
}


VOID
INCOMING_REQFAIL_TRANSACTION::OnTimerExpire()
{
    HRESULT hr;

    ENTER_FUNCTION("INCOMING_REQFAIL_TRANSACTION::OnTimerExpire");
    
    switch (m_State)
    {
    case INCOMING_TRANS_FINAL_RESPONSE_SENT:
        // Transaction done - delete the transaction
        // The timer in this state is just to keep the transaction
        // alive in order to retransmit the response when we receive a
        // retransmit of the request.
        LOG((RTC_TRACE,
             "%s deleting transaction after timeout for request retransmits",
             __fxName));
        OnTransactionDone();

        break;
        
        // No timers in these states
    case INCOMING_TRANS_INIT:
    case INCOMING_TRANS_REQUEST_RCVD:
    case INCOMING_TRANS_ACK_RCVD:
    default:
        ASSERT(FALSE);
        break;
    }

    return;
}

HRESULT
INCOMING_REQFAIL_TRANSACTION::TerminateTransactionOnByeOrCancel(
    OUT BOOL *pCallDisconnected
    )
{
    // Do nothing.
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\resolve.cpp ===
#include "precomp.h"
//#include "resolve.h"

HRESULT
ResolveHostName(
    IN  PSTR   HostName,
    OUT ULONG *pIPAddr
    )
{
    struct hostent *pHostEntry = gethostbyname(HostName);
    if (pHostEntry == NULL)
    {
        DWORD WinSockErr = WSAGetLastError();
        LOG((RTC_ERROR, "gethostbyname failed for host %s, error: 0x%x",
             HostName, WinSockErr));
        return HRESULT_FROM_WIN32(WinSockErr);
    }

    // XXX
    // Currently we just look at the first one in the address list
    *pIPAddr = *((ULONG *)pHostEntry->h_addr_list[0]);
    return S_OK;
}


// Could be host or IP address
HRESULT
ResolveHost(
    IN  PSTR            Host,
    IN  ULONG           HostLen,
    IN  USHORT          Port,
    IN  SIP_TRANSPORT   Transport,
    OUT SOCKADDR_IN    *pDstAddr
    )
{
    HRESULT hr;
    
    ASSERT(pDstAddr != NULL);

    ENTER_FUNCTION("ResolveHost");

    // All APIs require a NULL terminated string.
    // So copy the string.

    PSTR szHost = (PSTR) malloc(HostLen + 1);
    if (szHost == NULL)
    {
        LOG((RTC_ERROR, "%s allocating szHost failed", __fxName));
        return E_OUTOFMEMORY;
    }

    strncpy(szHost, Host, HostLen);
    szHost[HostLen] = '\0';

    ULONG IPAddr = inet_addr(szHost);
    if (IPAddr != INADDR_NONE)
    {
        // Host is an IP address
        pDstAddr->sin_family = AF_INET;
        pDstAddr->sin_addr.s_addr = IPAddr;
        pDstAddr->sin_port =
            (Port == 0) ? htons(GetSipDefaultPort(Transport)) : htons(Port);

        free(szHost);
        return S_OK;
    }

    // Try host name resolution.
    hr = ResolveHostName(szHost, &IPAddr);

    free(szHost);
    
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s ResolveHostName failed %x",
             __fxName, hr));
        return hr;
    }

    pDstAddr->sin_family = AF_INET;
    pDstAddr->sin_addr.s_addr = IPAddr;
    pDstAddr->sin_port =
        (Port == 0) ? htons(GetSipDefaultPort(Transport)) : htons(Port);
    
    return S_OK;
}


////////////////////////////////////////////
//
// QueryDNSSrv adapted from amun\src\stack\CSipUrl.cpp
//
////////////////////////////////////////////

HRESULT 
QueryDNSSrv(
    IN       SIP_TRANSPORT  Transport,
    IN       PSTR           pszSrvName,
    IN   OUT SOCKADDR      *pAddrDest,
    OUT      PSTR          *ppszDestHostName
    )
{

    HRESULT hr = S_OK;
    HRESULT hNoARecord;
    
    HANDLE  DnsSrvContextHandle;
    ULONG   SockAddressCount;
    CHAR    szDnsName[256];
    int     intDnsNameLen = 256;
    LPSTR   DnsHostName;
    PCHAR   pStart, pEnd;
    USHORT  usSrvNameLen = 0;

    SOCKET_ADDRESS  *pSocketAddrs;
    SOCKADDR        *pSockAddr;

    LPCSTR pszPrefix = NULL;
    
    ENTER_FUNCTION("QueryDNSSrv");
    LOG((RTC_TRACE,"%s entered transport: %d SrvName %s",__fxName,Transport,pszSrvName));

    ASSERT(NULL != pszSrvName);
    //
    // check whether it is a host name or an IP address
    //
    usSrvNameLen = (USHORT)strlen(pszSrvName);
    pStart  = pszSrvName;
    pEnd    = pStart+usSrvNameLen-1;
    //
    // from the end, we scan back to find the first char in the 
    // toplabel of the host
    //
    if ('.' == *pEnd)
        pEnd--;
    //
    // Now pEnd points to the last char in the address, check
    // whether it is an Alpha or not
    //
    if (!isalpha( *pEnd))
        return E_FAIL;

    
    switch(Transport)
    {
        case SIP_TRANSPORT_UDP: // "_sip._udp." is the prefix of the query name
        {

            pszPrefix = psz_SipUdpDNSPrefix;
            break;
        }
        
        case SIP_TRANSPORT_TCP: // "_sip._tcp." is the prefix of the query name
        {
            pszPrefix = psz_SipTcpDNSPrefix;
            break;
        }
        
        case SIP_TRANSPORT_SSL: // "_sip._ssl." is the prefix of the query name
        {             
            pszPrefix = psz_SipSslDNSPrefix;            
            break;
        }

        default:
        {
            pszPrefix = psz_SipUdpDNSPrefix;
            break;
        }
    }

     
    //
    // Assemble the SRV record name
    //
    
    intDnsNameLen = _snprintf(szDnsName,intDnsNameLen-1,"%s%s",pszPrefix,pszSrvName);

//    intDnsNameLen = _snprintf(szDnsName,intDnsNameLen-1,"_ldap._tcp.microsoft.com");

    if(intDnsNameLen < 0)
    {
        LOG((RTC_ERROR, "Server name too long. Length: %d", usSrvNameLen));
        hr = E_INVALIDARG;
        goto Exit;
    }
    
    szDnsName[intDnsNameLen]='\0';
    LOG((RTC_INFO, "QueryDNSSrv - DNS Name[%s]", szDnsName));

      
    hr = DnsSrvOpen(szDnsName,                  // ASCII string
                    DNS_QUERY_STANDARD,       // Flags
                    &DnsSrvContextHandle
                   );
    
    if (hr != NO_ERROR)
    {
            LOG((RTC_ERROR, "QueryDNSSrv - failure in do the DNS query."));
            goto Exit;
    }
    
    hNoARecord = HRESULT_FROM_WIN32(DNS_ERROR_RCODE_NAME_ERROR);
    
    do {
        hr = DnsSrvNext(DnsSrvContextHandle,
                        &SockAddressCount,
                        &pSocketAddrs,
                        &DnsHostName);
    }

    // continue only if we don't get A records for the specific SRV record, proceed forward
    // if succeed or all other errors.
    while (hr == hNoARecord);
    
    if (hr != NO_ERROR)
    {
        LOG((RTC_ERROR, "QueryDNSSrv - DnsSrvNext failed status: %d (0x%x)\n",
             hr, hr));
        goto Exit;
    }
    
    //
    // DnsSrvNext() succeeded
    //

    //
    // pick up the host name
    //
    if (NULL != (*ppszDestHostName = (PSTR) malloc(strlen(DnsHostName) + 1)))
    {
        strcpy(*ppszDestHostName, DnsHostName);
    }
    else
    {
        LOG((RTC_ERROR, "QueryDNSSrv - out of memory."));
    }
    
    //
    // pick up the first entry in the first record as the query result
    // It is problemetic and should be replaced with a list of query results.
    //
    for (ULONG i = 0; 
        i < 1; // SockAddressCount
        i++)
    {
        *pAddrDest = (*(pSocketAddrs[i].lpSockaddr));            
    }
    LOG((RTC_TRACE,"%s gets sockaddr back (%d.%d.%d.%d:%d)",__fxName,PRINT_SOCKADDR((SOCKADDR_IN*)pAddrDest)));
    LocalFree(pSocketAddrs);
    

/// SHOULD WE CLOSE IT IF OPEN FAILS?!?!?!? SHOULD INVESTIGATE.
Exit:
    
    DnsSrvClose(DnsSrvContextHandle);

    return hr;
//    return HRESULT_FROM_WIN32(DNS_ERROR_RCODE_NAME_ERROR);
}

///////////////////////////////////////////////////////////////////////////////
// Async DNS resolution processing
///////////////////////////////////////////////////////////////////////////////


DNS_RESOLUTION_WORKITEM::DNS_RESOLUTION_WORKITEM(
    IN ASYNC_WORKITEM_MGR *pWorkItemMgr
    ) : ASYNC_WORKITEM(pWorkItemMgr)
{
    m_Host = NULL;
    m_Port = 0;
    m_Transport = SIP_TRANSPORT_UNKNOWN;
    m_ErrorCode = S_OK;
    ZeroMemory(&m_Sockaddr, sizeof(SOCKADDR_IN));
}


DNS_RESOLUTION_WORKITEM::~DNS_RESOLUTION_WORKITEM()
{
    ENTER_FUNCTION("DNS_RESOLUTION_WORKITEM::~DNS_RESOLUTION_WORKITEM");
    
    if (m_Host != NULL)
    {
        free(m_Host);
    }
    LOG((RTC_TRACE, "%s - done", __fxName));
}


HRESULT
DNS_RESOLUTION_WORKITEM::SetHostPortTransportAndDnsCompletion(
    IN  PSTR                                    Host,
    IN  ULONG                                   HostLen,
    IN  USHORT                                  Port,
    IN  SIP_TRANSPORT                           Transport,
    IN  DNS_RESOLUTION_COMPLETION_INTERFACE    *pDnsCompletion
    )
{
    HRESULT hr;

    ENTER_FUNCTION("DNS_RESOLUTION_WORKITEM::SetHostAndPortParam");
    
    ASSERT(m_Host == NULL);

    hr = GetNullTerminatedString(Host, HostLen, &m_Host);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s GetNullTerminatedString failed %x",
             __fxName, hr));
        return hr;
    }

    m_Port = Port;

    m_Transport = Transport;

    m_pDnsCompletion = pDnsCompletion;

    return S_OK;
}

VOID
DNS_RESOLUTION_WORKITEM::ProcessWorkItem()
{
    HRESULT hr;
    ULONG   IPAddr;
    PSTR    pszDnsQueryResultHostName = NULL;
    ULONG   dotIndex;
    ULONG   HostLen = strlen(m_Host);

    ENTER_FUNCTION("DNS_RESOLUTION_WORKITEM::ProcessWorkItem");

    LOG((RTC_TRACE,"%s host %s transport %d port %d",__fxName,m_Host, m_Transport,m_Port));
    dotIndex = strcspn(m_Host,".");
    // query DNS SRV only if host is an external, and port is unspecified
    if((dotIndex < HostLen) && ((m_Port == 0) || (m_Port == GetSipDefaultPort(m_Transport)))) 
    {
        LOG((RTC_TRACE,"%s should try query DNS SRV records for name %s",__fxName, m_Host));
        hr = QueryDNSSrv(m_Transport,m_Host,(SOCKADDR*)&m_Sockaddr,&pszDnsQueryResultHostName);
        if (hr == S_OK)
        {
            m_Port = ntohs(m_Sockaddr.sin_port);
            LOG((RTC_TRACE,"%s gets %s DNS SRV host %s port %d",
                            __fxName,
                            m_Host,
                            pszDnsQueryResultHostName,
                            m_Port));
            free(pszDnsQueryResultHostName);
            return;
        }
        LOG((RTC_ERROR,"%s query DNS SRV records failed, Error %x",__fxName, hr));
    }

    LOG((RTC_TRACE,"%s resolving host name %s",__fxName,m_Host));
    hr = ResolveHostName(m_Host, &IPAddr);

    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s ResolveHostName failed %x",
             __fxName, hr));
        m_ErrorCode = hr;
    }
    else
    {
        m_Sockaddr.sin_family = AF_INET;
        m_Sockaddr.sin_addr.s_addr = IPAddr;
        m_Sockaddr.sin_port =
            (m_Port == 0) ? htons(GetSipDefaultPort(m_Transport)) : htons((USHORT)m_Port);

        LOG((RTC_TRACE,
             "%s - Processing DNS work item succeeded:\n"
             "Host: %s - IPaddr: %d.%d.%d.%d - Port: %d - Transport: %d",
             __fxName, m_Host, PRINT_SOCKADDR(&m_Sockaddr), m_Transport));
    }
}


VOID
DNS_RESOLUTION_WORKITEM::NotifyWorkItemComplete()
{
    m_pDnsCompletion->OnDnsResolutionComplete(m_ErrorCode,
                                              &m_Sockaddr,
                                              m_Host,
                                              (USHORT)m_Port);
}


/////////////////////////////////////////
/// Stuff below is not used any more
/////////////////////////////////////////

//  HRESULT
//  ResolveSipUrl(
//      IN  SIP_URL        *pSipUrl, 
//      OUT SOCKADDR_IN    *pDstAddr,
//      OUT SIP_TRANSPORT  *pTransport 
//      )
//  {
//      ENTER_FUNCTION("ResolveSipUrl");

//      HRESULT hr;

//      // If m_addr is present we need to resolve that.
//      // Otherwise we resolve the host.

//      if (pSipUrl->m_KnownParams[SIP_URL_PARAM_MADDR].Length != 0)
//      {
//          hr = ResolveHost(pSipUrl->m_KnownParams[SIP_URL_PARAM_MADDR].Buffer,
//                           pSipUrl->m_KnownParams[SIP_URL_PARAM_MADDR].Length,
//                           (USHORT) pSipUrl->m_Port,
//                           pDstAddr,
//                           pTransport);
//          if (hr != S_OK)
//          {
//              LOG((RTC_ERROR, "%s ResolveHost(maddr) failed %x",
//                   __fxName, hr));
//              return hr;
//          }
//      }
//      else
//      {
//          hr = ResolveHost(pSipUrl->m_Host.Buffer,
//                           pSipUrl->m_Host.Length,
//                           (USHORT) pSipUrl->m_Port,
//                           pDstAddr,
//                           pTransport);
//          if (hr != S_OK)
//          {
//              LOG((RTC_ERROR, "%s ResolveHost(Host) failed %x",
//                   __fxName, hr)); 
//              return hr;
//          }
//      }

//      *pTransport = pSipUrl->m_TransportParam;

//      return S_OK;
//  }


//  HRESULT
//  ResolveSipUrl(
//      IN  PSTR            DstUrl,
//      IN  ULONG           DstUrlLen,
//      OUT SOCKADDR_IN    *pDstAddr,
//      OUT SIP_TRANSPORT  *pTransport
//      )
//  {
//      SIP_URL DecodedSipUrl;
//      HRESULT hr;
//      ULONG   BytesParsed = 0;
    
//      ENTER_FUNCTION("ResolveSipUrl");

//      hr = ParseSipUrl(DstUrl, DstUrlLen, &BytesParsed,
//                       &DecodedSipUrl);
//      if (hr != S_OK)
//      {
//          LOG((RTC_ERROR, "%s ParseSipUrl failed %x",
//               __fxName, hr));
//          return hr;
//      }

//      hr = ResolveSipUrl(&DecodedSipUrl, pDstAddr, pTransport);
//      if (hr != S_OK)
//      {
//          LOG((RTC_ERROR, "%s ResolveSipUrl(SIP_URL *) failed %x",
//               __fxName, hr));
//          return hr;
//      }

//      return S_OK;
//  }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\sipcall.cpp ===
#include "precomp.h"
#include "sipstack.h"
#include "sipcall.h"
#include "pintcall.h"
#include "register.h"

///////////////////////////////////////////////////////////////////////////////
// ISipCall functions
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
SIP_CALL::SetNotifyInterface(
    IN   ISipCallNotify *    NotifyInterface
    )
{
    if(GetSipStack()->IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "SipStack is already shutdown"));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    LOG((RTC_TRACE, "SIP_CALL::SetNotifyInterface - 0x%x",
         NotifyInterface));
    m_pNotifyInterface = NotifyInterface;

    return S_OK;
}


STDMETHODIMP
SIP_CALL::Disconnect()
{
    HRESULT hr;

    ENTER_FUNCTION("SIP_CALL::Disconnect");
    if(GetSipStack()->IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "%s - SipStack is already shutdown", __fxName));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    LOG((RTC_TRACE, "%s : state %d",
         __fxName, m_State));
    
    if (m_State == SIP_CALL_STATE_DISCONNECTED ||
        m_State == SIP_CALL_STATE_IDLE         ||
        m_State == SIP_CALL_STATE_OFFERING     ||
        m_State == SIP_CALL_STATE_REJECTED     ||
        m_State == SIP_CALL_STATE_ERROR)
    {
        // do nothing
        LOG((RTC_TRACE, "%s call in state %d Doing nothing",
             __fxName, m_State));
        return S_OK;
    }

    // Create a BYE transaction
    hr = CreateOutgoingByeTransaction(FALSE,
                                      NULL, 0 // No Additional headers
                                      );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s creating BYE transaction failed",
             __fxName));
    }

    // XXX TODO May be we should do this after we get a response to the
    // BYE.  We will not be able to show the credentials UI because
    // the notify interface will be set to NULL.
    // This will require a rewrite of the BYE transaction.
    
    // We have to notify the user even if creating the BYE transaction failed.
    // Don't wait till the BYE transaction completes
    NotifyCallStateChange(SIP_CALL_STATE_DISCONNECTED);

    // Clean up call state
    return S_OK;
}



///////////////////////////////////////////////////////////////////////////////
// IUnknown
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP_(ULONG)
SIP_CALL::AddRef()
{
    return MsgProcAddRef();
}


STDMETHODIMP_(ULONG)
SIP_CALL::Release()
{
    return MsgProcRelease();
}


STDMETHODIMP
SIP_CALL::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (riid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown *>(this);
    }
    else if (riid == IID_ISipCall)
    {
        *ppv = static_cast<ISipCall *>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    static_cast<IUnknown *>(*ppv)->AddRef();
    return S_OK;
}



///////////////////////////////////////////////////////////////////////////////
// SIP_CALL functions
///////////////////////////////////////////////////////////////////////////////


SIP_CALL::SIP_CALL(
    IN  SIP_PROVIDER_ID   *pProviderId,
    IN  SIP_CALL_TYPE      CallType,
    IN  SIP_STACK         *pSipStack,
    IN  REDIRECT_CONTEXT  *pRedirectContext    
    ) :
    SIP_MSG_PROCESSOR(
        (CallType == SIP_CALL_TYPE_RTP) ?
        SIP_MSG_PROC_TYPE_RTP_CALL : SIP_MSG_PROC_TYPE_PINT_CALL,
        pSipStack, pRedirectContext )
{
    m_Signature = 'SPCL';

    if (pProviderId != NULL)
    {
        CopyMemory(&m_ProviderGuid, pProviderId, sizeof(GUID));
    }
    else
    {
        ZeroMemory(&m_ProviderGuid, sizeof(GUID));
    }
    
    m_CallType  = CallType;

    m_State             = SIP_CALL_STATE_IDLE;

    m_pNotifyInterface  = NULL;

    m_LocalPhoneURI     = NULL;
    m_LocalPhoneURILen  = 0;

    m_fSubscribeEnabled = FALSE;

    m_pIncomingInviteTransaction = NULL;
    m_pOutgoingInviteTransaction = NULL;

    InitializeListHead( &m_PartyInfoList );
    m_PartyInfoListLen = 0;

    m_fNeedToReinitializeMediaManager = FALSE;

    LOG((RTC_TRACE, "New SIP CALL created: %x", this ));
}


SIP_CALL::~SIP_CALL()
{
    ASSERT(m_pIncomingInviteTransaction == NULL);
    //ASSERT(m_pOutgoingInviteTransaction == NULL);

    if (m_LocalPhoneURI != NULL)
    {
        free(m_LocalPhoneURI);
    }

    LOG((RTC_TRACE, "~SIP_CALL() Sip call deleted: %x", this ));
}


VOID
SIP_CALL::NotifyCallStateChange(
    IN SIP_CALL_STATE CallState,
    IN HRESULT        StatusCode,       // = 0
    IN PSTR           ReasonPhrase,     // = NULL
    IN ULONG          ReasonPhraseLen   // = 0
    )
{
    HRESULT hr;

    ENTER_FUNCTION("SIP_CALL::NotifyCallStateChange");
    
    m_State = CallState;
    
    SIP_CALL_STATUS CallStatus;
    LPWSTR          wsStatusText = NULL;

    if (ReasonPhrase != NULL)
    {
        hr = UTF8ToUnicode(ReasonPhrase, ReasonPhraseLen,
                           &wsStatusText);
        if (hr != S_OK)
        {
            wsStatusText = NULL;
        }
    }
    
    CallStatus.State             = CallState;
    CallStatus.Status.StatusCode = StatusCode;
    CallStatus.Status.StatusText = wsStatusText;

    LOG((RTC_TRACE, "%s : CallState : %d StatusCode: %x",
         __fxName, CallState, StatusCode));

    if (m_pNotifyInterface)
    {
        m_pNotifyInterface->NotifyCallChange(&CallStatus);
    }
    else
    {
        LOG((RTC_WARN, "%s : m_pNotifyInterface is NULL",
             __fxName));
    }

    if (wsStatusText != NULL)
        free(wsStatusText);
}


// A value of TRUE for IsFirstInvite should be passed
// only when creating an outgoing call.
HRESULT
SIP_CALL::CreateOutgoingInviteTransaction(
    IN  BOOL                        AuthHeaderSent,
    IN  BOOL                        IsFirstInvite,
    IN  SIP_HEADER_ARRAY_ELEMENT   *AdditionalHeaderArray,
    IN  ULONG                       AdditionalHeaderCount,
    IN  PSTR                        SDPBlob,
    IN  ULONG                       SDPBlobLen,
    IN  BOOL                        fNeedToNotifyCore,
    IN  LONG                        Cookie
    )
{
    HRESULT hr;
    OUTGOING_INVITE_TRANSACTION *pOutgoingInviteTransaction;
    ULONG  InviteTimerValue;

    ENTER_FUNCTION("SIP_CALL::CreateOutgoingInviteTransaction");

    LOG((RTC_TRACE, "%s - enter", __fxName));
    
    if (ProcessingInviteTransaction())
    {
        LOG((RTC_ERROR,
             "%s - Currently processing %s INVITE Transaction - can't create",
             __fxName, (m_pOutgoingInviteTransaction) ? "Outgoing" : "Incoming"
             ));
        return RTC_E_SIP_INVITE_TRANSACTION_PENDING;
    }
    
    pOutgoingInviteTransaction =
        new OUTGOING_INVITE_TRANSACTION(
                this, SIP_METHOD_INVITE,
                GetNewCSeqForRequest(),
                AuthHeaderSent,
                IsFirstInvite,
                fNeedToNotifyCore, Cookie
                );
    
    if (pOutgoingInviteTransaction == NULL)
    {
        LOG((RTC_ERROR, "%s - Allocating pOutgoingInviteTransaction failed",
             __fxName));
        return E_OUTOFMEMORY;
    }

    InviteTimerValue = (m_Transport == SIP_TRANSPORT_UDP) ?
        SIP_TIMER_RETRY_INTERVAL_T1 : SIP_TIMER_INTERVAL_AFTER_INVITE_SENT_TCP;

    hr = pOutgoingInviteTransaction->CheckRequestSocketAndSendRequestMsg(
             InviteTimerValue,
             AdditionalHeaderArray,
             AdditionalHeaderCount,
             SDPBlob,
             SDPBlobLen,
             SIP_CONTENT_TYPE_SDP_TEXT,
             sizeof(SIP_CONTENT_TYPE_SDP_TEXT)-1
             );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s  failed CheckRequestSocketAndSendRequestMsg %x",
             __fxName, hr));
        pOutgoingInviteTransaction->OnTransactionDone();
        return hr;
    }

    ASSERT(m_pOutgoingInviteTransaction == NULL);
    
    m_pOutgoingInviteTransaction = pOutgoingInviteTransaction;
    
    if (IsFirstInvite)
    {
        NotifyCallStateChange(SIP_CALL_STATE_CONNECTING);
    }
    
    return S_OK;
}


VOID
SIP_CALL::OnIncomingInviteTransactionDone(
    IN INCOMING_INVITE_TRANSACTION *pIncomingInviteTransaction
    )
{
    if (m_pIncomingInviteTransaction == pIncomingInviteTransaction)
    {
        m_pIncomingInviteTransaction = NULL;

        ProcessPendingInvites();
    }
}
    

HRESULT
SIP_CALL::CreateOutgoingByeTransaction(
    IN  BOOL                        AuthHeaderSent,
    IN  SIP_HEADER_ARRAY_ELEMENT   *AdditionalHeaderArray,
    IN  ULONG                       AdditionalHeaderCount
    )
{
    HRESULT     hr;
    ULONG       ByeTimerValue;
    OUTGOING_BYE_CANCEL_TRANSACTION *pOutgoingByeTransaction;

    ENTER_FUNCTION("SIP_CALL::CreateOutgoingByeTransaction");

    LOG((RTC_TRACE, "%s - Enter", __fxName));

    hr = CleanupCallTypeSpecificState();
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s CleanupCallTypeSpecificState failed %x",
             __fxName, hr));
    }
    
    hr = CancelAllTransactions();
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s CancelAllTransactions failed %x",
             __fxName, hr));
    }

    pOutgoingByeTransaction =
        new OUTGOING_BYE_CANCEL_TRANSACTION(
                this, SIP_METHOD_BYE,
                GetNewCSeqForRequest(),
                AuthHeaderSent
                );
    if (pOutgoingByeTransaction == NULL)
    {
        LOG((RTC_ERROR, "%s - Allocating pOutgoingByeTransaction failed",
             __fxName));
        return E_OUTOFMEMORY;
    }

    ByeTimerValue = (m_Transport == SIP_TRANSPORT_UDP) ?
        SIP_TIMER_RETRY_INTERVAL_T1 : SIP_TIMER_INTERVAL_AFTER_BYE_SENT_TCP;

    hr = pOutgoingByeTransaction->CheckRequestSocketAndSendRequestMsg(
             ByeTimerValue,
             AdditionalHeaderArray,
             AdditionalHeaderCount,
             NULL, 0,
             NULL, 0  //No ContentType
             );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s  failed CheckRequestSocketAndSendRequestMsg %x",
             __fxName, hr));
        pOutgoingByeTransaction->OnTransactionDone();
        return hr;
    }

    return S_OK;
}


// Default is no msg body.
HRESULT
OUTGOING_TRANSACTION::GetAndStoreMsgBodyForRequest()
{
    return S_OK;
}


HRESULT
OUTGOING_TRANSACTION::CheckRequestSocketAndRetransmitRequestMsg()
{
    ENTER_FUNCTION("OUTGOING_TRANSACTION::CheckRequestSocketAndRetransmitRequestMsg");
    
    HRESULT hr;
    
    if (m_pSipMsgProc->IsRequestSocketReleased())
    {
        LOG(( RTC_TRACE, "%s-Request socket released this: %x",
              __fxName, this ));

        hr = m_pSipMsgProc->ConnectRequestSocket();
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s - ConnectRequestSocket failed %x",
                 __fxName, hr));
            return hr;
        }
    }
    if (m_pSipMsgProc->GetRequestSocketState() == REQUEST_SOCKET_CONNECTED)
    {
        hr = m_pSipMsgProc->SendRequestMsg(m_pRequestBuffer);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s - SendRequestMsg failed %x",
                __fxName, hr));
            return hr;
        }
    }
    else
    {
        LOG((RTC_TRACE, "%s - Request Socket not connected. Message will be sent when connected ",
            __fxName));
        
        m_WaitingToSendRequest = TRUE;
    }

    return S_OK;
}

//Used only after ConnectComplete
HRESULT
OUTGOING_TRANSACTION::CheckRequestSocketAndSendRequestMsgAfterConnectComplete()
{
    ENTER_FUNCTION("OUTGOING_TRANSACTION::CheckRequestSocketAndSendRequestMsgAfterConnectComplete");
    
    HRESULT hr;
    
    if (m_pSipMsgProc->IsRequestSocketReleased())
    {
        LOG(( RTC_TRACE, "%s-Request socket released this: %x",
              __fxName, this ));

        hr = m_pSipMsgProc->ConnectRequestSocket();
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s - ConnectRequestSocket failed %x",
                 __fxName, hr));
            return hr;
        }
    }

    // Send the message if the socket is connected.
    if (m_pSipMsgProc->GetRequestSocketState() == REQUEST_SOCKET_CONNECTED)
    {
        hr = CreateAndSendRequestMsg(
                 m_TimerValue,
                 m_AdditionalHeaderArray,
                 m_AdditionalHeaderCount,
                 m_szMsgBody, m_MsgBodyLen,
                 m_ContentType, m_ContentTypeLen
                 );
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s - CreateAndSendRequestMsg failed %x",
                 __fxName, hr));
            return hr;
        }
    }
    else
    {
        LOG((RTC_TRACE, "%s - Request Socket not connected. Message will be sent when connected ",
                 __fxName));
        m_WaitingToSendRequest = TRUE;
    }
    return S_OK;
}

HRESULT
OUTGOING_TRANSACTION::CheckRequestSocketAndSendRequestMsg(
    IN  ULONG                       RequestTimerValue,
    IN  SIP_HEADER_ARRAY_ELEMENT   *AdditionalHeaderArray,
    IN  ULONG                       AdditionalHeaderCount,
    IN  PSTR                        MsgBody,
    IN  ULONG                       MsgBodyLen,
    IN  PSTR                        ContentType,
    IN  ULONG                       ContentTypeLen
    )
{
    ENTER_FUNCTION("OUTGOING_TRANSACTION::CheckRequestSocketAndSendRequestMsg");
    
    HRESULT hr;
    
    if (m_pSipMsgProc->IsRequestSocketReleased())
    {
        LOG(( RTC_TRACE, "%s-Request socket released this: %x",
              __fxName, this ));

        hr = m_pSipMsgProc->ConnectRequestSocket();
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s - ConnectRequestSocket failed %x",
                 __fxName, hr));
            return hr;
        }
    }

    // The message body is stored because we need it while handling
    // 401s, redirects (in case of IM), etc
    if (MsgBody != NULL)
    {
        hr = StoreMsgBodyAndContentType(MsgBody, MsgBodyLen, 
                                        ContentType, ContentTypeLen);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s - StoreMsgBody failed %x",
                 __fxName, hr));
            return hr;
        }
    }

    // Send the message if the socket is connected.
    // Otherwise store any additional headers / MsgBody to send later
    // when the request socket connection completes.
    if (m_pSipMsgProc->GetRequestSocketState() == REQUEST_SOCKET_CONNECTED)
    {
        if (m_szMsgBody == NULL)
        {
            hr = GetAndStoreMsgBodyForRequest();
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s - GetAndStoreMsgBodyForRequest failed %x",
                     __fxName, hr));
                return hr;
            }
        }

        //For REGISTER transaction, set the contact again,
        //since the methods list could have changed.
        if( m_MethodId == SIP_METHOD_REGISTER )
        {
	        m_pSipMsgProc -> SetLocalContact();
        }
        
        hr = CreateAndSendRequestMsg(
                 RequestTimerValue,
                 AdditionalHeaderArray,
                 AdditionalHeaderCount,
                 m_szMsgBody,
                 m_MsgBodyLen,
                 ContentType,
                 ContentTypeLen
                 );
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s - CreateAndSendRequestMsg failed %x",
                 __fxName, hr));
            return hr;
        }
    }
    else
    {
        LOG((RTC_TRACE, "%s - Request Socket not connected. Message will be sent when connected ",
                 __fxName));

        hr = StoreTimerAndAdditionalHeaders(
                 RequestTimerValue, AdditionalHeaderArray, AdditionalHeaderCount
                 );
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s StoreTimerAndAdditionalHeaders failed %x",
                 __fxName, hr));
            return hr;
        }
        m_WaitingToSendRequest = TRUE;
    }
    
    return S_OK;
}



// A value of TRUE for IsFirstInvite should be passed
// only when creating an incoming call. Otherwise, the
// argument should be omitted and it takes the default
// argument of FALSE.

HRESULT
SIP_CALL::CreateIncomingByeTransaction(
    IN SIP_MESSAGE  *pSipMsg,
    IN ASYNC_SOCKET *pResponseSocket
    )
{
    HRESULT hr = S_OK;
    BOOL    fNotifyDisconnect = FALSE;

    ENTER_FUNCTION("SIP_CALL::CreateIncomingByeTransaction");
    LOG((RTC_TRACE, "entering %s", __fxName));
    
    if (!IsCallDisconnected())
    {
        m_State = SIP_CALL_STATE_DISCONNECTED;
        fNotifyDisconnect = TRUE;
        
        // Cleanup media state
        hr = CleanupCallTypeSpecificState();
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s CleanupCallTypeSpecificState failed %x",
                 __fxName, hr));
        }

        hr = CancelAllTransactions();
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s CancelAllTransactions failed %x",
                 __fxName, hr));
        }
    }
    else
    {
        fNotifyDisconnect = FALSE;
    }

    // Make any validity checks required on the incoming Request
    
    // Cancel all existing transactions.
    INCOMING_BYE_CANCEL_TRANSACTION *pIncomingByeTransaction
        = new INCOMING_BYE_CANCEL_TRANSACTION(this,
                                              pSipMsg->GetMethodId(),
                                              pSipMsg->GetCSeq());
    if (pIncomingByeTransaction == NULL)
    {
        LOG((RTC_ERROR, "%s Allocating pIncomingByeTransaction failed",
             __fxName));
        return E_OUTOFMEMORY;
    }

    hr = pIncomingByeTransaction->SetResponseSocketAndVia(
             pSipMsg, pResponseSocket);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - SetResponseSocketAndVia failed %x",
             __fxName, hr));
        pIncomingByeTransaction->OnTransactionDone();
        goto done;
    }
    
    hr = pIncomingByeTransaction->ProcessRequest(pSipMsg, pResponseSocket);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - ProcessRequest failed %x",
             __fxName, hr));
        
        //Should not delete the transaction. The transaction should handle the error
        //and delete itself
    }

 done:
    // Notify should always be done last.
    if (fNotifyDisconnect)
    {
        NotifyCallStateChange(SIP_CALL_STATE_DISCONNECTED);
    }

    return hr;
}


HRESULT
SIP_CALL::CreateIncomingCancelTransaction(
    IN SIP_MESSAGE  *pSipMsg,
    IN ASYNC_SOCKET *pResponseSocket
    )
{
    // Make any validity checks required on the incoming Request
    HRESULT hr;
    BOOL    CallDisconnected = FALSE;

    ENTER_FUNCTION("SIP_CALL::CreateIncomingCancelTransaction");
    LOG((RTC_TRACE, "%s - enter", __fxName));
    
    INCOMING_BYE_CANCEL_TRANSACTION *pIncomingCancelTransaction
        = new INCOMING_BYE_CANCEL_TRANSACTION(this,
                                              pSipMsg->GetMethodId(),
                                              pSipMsg->GetCSeq());
    if (pIncomingCancelTransaction == NULL)
    {
        LOG((RTC_ERROR, "%s Allocating pIncomingCancelTransaction failed",
             __fxName));
        return E_OUTOFMEMORY;
    }

    hr = pIncomingCancelTransaction->SetResponseSocketAndVia(
             pSipMsg, pResponseSocket);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s SetResponseSocketAndVia failed %x",
             __fxName, hr));
        return hr;
    }
    
    hr = CancelIncomingTransaction(pSipMsg->GetCSeq(),
                                   &CallDisconnected);

    if (hr == S_OK)
    {
        hr = pIncomingCancelTransaction->ProcessRequest(pSipMsg,
                                                        pResponseSocket);
        if (CallDisconnected)
        {
            // Notify should always be the last thing you do as it could
            // end up in a modal dialog box.

            NotifyCallStateChange(SIP_CALL_STATE_DISCONNECTED);
        }
    }
    else
    {
        hr = pIncomingCancelTransaction->SendResponse(481,
                                                      SIP_STATUS_TEXT(481),
                                                      SIP_STATUS_TEXT_SIZE(481));
        
    }

    return hr;
}


// Nothing needs to be done for outgoing transactions ? XXX
// They are driven by their own state machines.
// Cancel all the incoming transactions.
// Currently this actually affects only incoming INVITE
// transactions.

HRESULT
SIP_CALL::CancelAllTransactions()
{
    LIST_ENTRY              *pListEntry;
    INCOMING_TRANSACTION    *pSipTransaction;
    BOOL                     CallDisconnected = FALSE;
    
    pListEntry = m_IncomingTransactionList.Flink;

    // Go through all the current transactions to check if CSeq
    // matches.
    while (pListEntry != &m_IncomingTransactionList)
    {
        pSipTransaction = CONTAINING_RECORD(pListEntry,
                                            INCOMING_TRANSACTION,
                                            m_ListEntry );
        pListEntry = pListEntry->Flink;
        if (!pSipTransaction->IsTransactionDone())
        {
            pSipTransaction->TerminateTransactionOnByeOrCancel(&CallDisconnected);
        }

    }

    return S_OK;
}


// Returns S_OK if the transaction is found and
// E_FAIL if the transaction is not found.

HRESULT
SIP_CALL::CancelIncomingTransaction(
    IN  ULONG  CSeq,
    OUT BOOL  *pCallDisconnected    
    )
{
    // Find the transaction that the message belongs to.
    LIST_ENTRY              *pListEntry;
    INCOMING_TRANSACTION    *pSipTransaction;
    
    pListEntry = m_IncomingTransactionList.Flink;

    // Go through all the current transactions to check if CSeq
    // matches.
    while (pListEntry != &m_IncomingTransactionList)
    {
        pSipTransaction = CONTAINING_RECORD(pListEntry,
                                            INCOMING_TRANSACTION,
                                            m_ListEntry);
        if (pSipTransaction->GetCSeq() == CSeq)
        {
            // Note that the current CANCEL transaction we are
            // processing is also in the incoming transaction list.
            if (pSipTransaction->GetMethodId() != SIP_METHOD_CANCEL)
            {
                pSipTransaction->TerminateTransactionOnByeOrCancel(
                    pCallDisconnected
                    );
                return S_OK;
            }
        }
        pListEntry = pListEntry->Flink;
    }

    return E_FAIL;
}


// XXX TODO Why doesn't this have any error code ?
VOID
SIP_CALL::OnError()
{
    InitiateCallTerminationOnError();
}



// Note that this function notifies the Core and this call could
// block and on return the transaction and call could both be deleted.
// So, we should make sure we don't touch any state after calling this
// function.
VOID
SIP_CALL::InitiateCallTerminationOnError(
    IN HRESULT StatusCode  // = 0
    )
{
    HRESULT hr;

    ENTER_FUNCTION("SIP_CALL::InitiateCallTerminationOnError");
    
    LOG((RTC_ERROR, "%s - Enter", __fxName));
    if (m_State == SIP_CALL_STATE_DISCONNECTED ||
        m_State == SIP_CALL_STATE_REJECTED)
    {
        // do nothing
        return;
    }
    
    // Create a BYE transaction
    hr = CreateOutgoingByeTransaction(FALSE,
                                      NULL, 0 // No Additional headers
                                      );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s creating BYE transaction failed",
             __fxName));
    }

    // We have to notify the user even if creating the BYE transaction failed.
    // Don't wait till the BYE transaction completes
    NotifyCallStateChange(SIP_CALL_STATE_DISCONNECTED, StatusCode);
    LOG((RTC_ERROR, "%s - Exit", __fxName));
}


HRESULT
SIP_CALL::ProcessRedirect(
    IN SIP_MESSAGE *pSipMsg
    )
{
    // For now redirects are also failures
    HRESULT hr = S_OK;
    
    ENTER_FUNCTION("SIP_CALL::ProcessRedirect");

    if (m_pRedirectContext == NULL)
    {
        m_pRedirectContext = new REDIRECT_CONTEXT();
        if (m_pRedirectContext == NULL)
        {
            LOG((RTC_ERROR, "%s allocating redirect context failed",
                 __fxName));
            return E_OUTOFMEMORY;
        }
    }

    hr = m_pRedirectContext->AppendContactHeaders(pSipMsg);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s AppendContactHeaders failed %x",
             __fxName, hr));
        // XXX Shutdown call ?
        m_pRedirectContext -> Release();
        m_pRedirectContext = NULL;
        return hr;
    }

    SIP_CALL_STATUS CallStatus;
    LPWSTR          wsStatusText = NULL;
    PSTR            ReasonPhrase = NULL;
    ULONG           ReasonPhraseLen = 0;
    

    pSipMsg->GetReasonPhrase(&ReasonPhrase, &ReasonPhraseLen);
    
    if (ReasonPhrase != NULL)
    {
        hr = UTF8ToUnicode(ReasonPhrase, ReasonPhraseLen,
                           &wsStatusText);
        if (hr != S_OK)
        {
            wsStatusText = NULL;
        }
    }
    
    CallStatus.State = SIP_CALL_STATE_DISCONNECTED;
    CallStatus.Status.StatusCode =
        HRESULT_FROM_SIP_STATUS_CODE(pSipMsg->GetStatusCode());
    CallStatus.Status.StatusText = wsStatusText;

    // Keep a reference till the notify completes to make sure
    // that the SIP_CALL object is alive when the notification
    // returns.
    AddRef();
    if(m_pNotifyInterface != NULL)
        hr = m_pNotifyInterface->NotifyRedirect(m_pRedirectContext,
                                            &CallStatus);

    // If a new call is created as a result that call will AddRef()
    // the redirect context.
    m_pRedirectContext->Release();
    m_pRedirectContext = NULL;

    if (wsStatusText != NULL)
        free(wsStatusText);

    Release();

    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s NotifyRedirect failed %x",
             __fxName, hr));
    }

    return hr;
}


HRESULT SIP_CALL::OnIpAddressChange()
{
    HRESULT hr = S_OK;
    ENTER_FUNCTION("SIP_CALL::OnIpAddressChange");
    LOG((RTC_TRACE, "%s - Enter this: %x", __fxName, this));

    //OnIpaddr change go thru the list of IP addr on IP table, check if the
    //IP is there. If not there, terminate the call.
    MsgProcAddRef();
    hr = CheckListenAddrIntact();
    if(m_pRequestSocket == NULL || hr != S_OK)
    {
        //Drop the call
        LOG((RTC_ERROR, "%s - Call dropped since local Ip not found", 
                __fxName));
        ReleaseRequestSocket();
        if (!IsCallDisconnected())
        {
            hr = CreateOutgoingByeTransaction(FALSE,
                                              NULL, 0 // No Additional headers
                                              );
            if (hr != S_OK)
            {
                LOG((RTC_ERROR,
                     "CreateOutgoingByeTransaction creating BYE transaction failed"));
            }
            m_State = SIP_CALL_STATE_DISCONNECTED;
            NotifyCallStateChange(SIP_CALL_STATE_DISCONNECTED);
        }
    }
    else
    {
        LOG((RTC_TRACE, "%s - Do Nothing",
                __fxName));
    }
    MsgProcRelease();

    LOG((RTC_TRACE, "%s - Exit this: %x", __fxName, this));
    return hr; 
}


///////////////////////////////////////////////////////////////////////////////
// SIP_TRANSACTION
///////////////////////////////////////////////////////////////////////////////

SIP_TRANSACTION::SIP_TRANSACTION(
    IN SIP_MSG_PROCESSOR    *pSipMsgProc,
    IN SIP_METHOD_ENUM       MethodId,
    IN ULONG                 CSeq,
    IN BOOL                  IsIncoming
    ) :
    TIMER(pSipMsgProc->GetSipStack()->GetTimerMgr())
{
    m_Signature         = 'SPXN';
    
    m_pSipMsgProc       = pSipMsgProc;
    m_pSipMsgProc->MsgProcAddRef();

    // The transaction is created with a ref count of 1.
    // This ref count is released by the transaction when
    // its state machine determines that the transaction is done.
    // Any other codepath that needs to keep the transaction
    // alive needs to AddRef/Release the transaction.
    m_RefCount          = 1;
    m_AsyncNotifyCount  = 0;
    m_IsTransactionDone = FALSE;
    
    m_CSeq              = CSeq;
    m_MethodId          = MethodId;
    m_IsIncoming        = IsIncoming;
}


// Note that the destructors of the derived
// classes are executed before this destructor is
// executed.
SIP_TRANSACTION::~SIP_TRANSACTION()
{
    if (m_pSipMsgProc != NULL)
    {
        m_pSipMsgProc->MsgProcRelease();
    }

    ASSERT(m_AsyncNotifyCount == 0);
    
    LOG((RTC_TRACE,
         "~SIP_TRANSACTION(this: %x) done", this));
}


// We live in a single threaded world.
STDMETHODIMP_(ULONG)
SIP_TRANSACTION::TransactionAddRef()
{
    m_RefCount++;
    LOG((RTC_TRACE,
         "SIP_TRANSACTION::TransactionAddRef this: %x m_RefCount: %d",
         this, m_RefCount));
    return m_RefCount;
}


STDMETHODIMP_(ULONG)
SIP_TRANSACTION::TransactionRelease()
{
    m_RefCount--;
    LOG((RTC_TRACE,
         "SIP_TRANSACTION::TransactionRelease this: %x m_RefCount: %d",
         this, m_RefCount));
    if (m_RefCount != 0)
    {
        return m_RefCount;
    }
    else
    {
        delete this;
        return 0;
    }
}


VOID
SIP_TRANSACTION::IncrementAsyncNotifyCount()
{
    m_AsyncNotifyCount++;
    LOG((RTC_TRACE,
         "SIP_TRANSACTION::IncrementAsyncNotifyCount this: %x m_AsyncNotifyCount: %d",
         this, m_AsyncNotifyCount));
}


VOID
SIP_TRANSACTION::DecrementAsyncNotifyCount()
{
    m_AsyncNotifyCount--;
    LOG((RTC_TRACE,
         "SIP_TRANSACTION::DecrementAsyncNotifyCount this: %x m_AsyncNotifyCount: %d",
         this, m_AsyncNotifyCount));
}


// Should we also remove the transaction from the transaction list here ?
VOID
SIP_TRANSACTION::OnTransactionDone()
{
    if( m_IsTransactionDone == FALSE )
    {
        m_IsTransactionDone = TRUE;

        if (IsTimerActive())
        {
            KillTimer();
        }

        TransactionRelease();
    }
}


// virtual
VOID
SIP_TRANSACTION::TerminateTransactionOnError(
    IN HRESULT hr
    )
{
    OnTransactionDone();
}


///////////////////////////////////////////////////////////////////////////////
// INCOMING_TRANSACTION
///////////////////////////////////////////////////////////////////////////////

INCOMING_TRANSACTION::INCOMING_TRANSACTION(
    IN SIP_MSG_PROCESSOR    *pSipMsgProc,
    IN SIP_METHOD_ENUM       MethodId,
    IN ULONG                 CSeq
    ):
    SIP_TRANSACTION(pSipMsgProc, MethodId, CSeq, TRUE)
{
    m_State             = INCOMING_TRANS_INIT;

    m_pResponseSocket   = NULL;
    ZeroMemory(&m_ResponseDestAddr, sizeof(SOCKADDR_IN));
    m_IsDestExternalToNat = FALSE;

    m_ViaHeaderArray    = NULL;
    m_NumViaHeaders     = 0;
    
    m_pResponseBuffer   = NULL;

    InitializeListHead(&m_RecordRouteHeaderList);
    
    InsertTailList(&m_pSipMsgProc->m_IncomingTransactionList,
                   &m_ListEntry);

    m_pSipMsgProc->SetHighestRemoteCSeq(CSeq);

    LOG((RTC_TRACE, "INCOMING_TRANSACTION(%x) created", this));
}


INCOMING_TRANSACTION::~INCOMING_TRANSACTION()
{
    ReleaseResponseSocket();
    
    if (m_ViaHeaderArray != NULL)
    {
        for (ULONG i = 0; i < m_NumViaHeaders; i++)
        {
            if (m_ViaHeaderArray[i].Buffer != NULL)
            {
                free(m_ViaHeaderArray[i].Buffer);
            }
        }
        free(m_ViaHeaderArray);
    }
    
    if (m_pResponseBuffer != NULL)
    {
        m_pResponseBuffer->Release();
        m_pResponseBuffer = NULL;
    }

    FreeRecordRouteHeaderList();

    RemoveEntryList(&m_ListEntry);
    
    LOG((RTC_TRACE, "~INCOMING_TRANSACTION(%x) deleted", this));
}


VOID
INCOMING_TRANSACTION::OnTransactionDone()
{
    ReleaseResponseSocket();
    
    // This should be done last as this releases
    // the transaction and this could delete the transaction.
    SIP_TRANSACTION::OnTransactionDone();
}


VOID
INCOMING_TRANSACTION::ReleaseResponseSocket()
{
    if (m_pResponseSocket != NULL)
    {
        m_pResponseSocket->RemoveFromConnectCompletionList(this);
        m_pResponseSocket->RemoveFromErrorNotificationList(this);
        m_pResponseSocket->Release();
        m_pResponseSocket = NULL;
    }
}

// XXX Should we make a special check for OnCloseReady(0)
void
INCOMING_TRANSACTION::OnSocketError(
    IN DWORD ErrorCode
    )
{
    ENTER_FUNCTION("INCOMING_TRANSACTION::OnSocketError");
    LOG((RTC_ERROR, "%s - error: %x", __fxName, ErrorCode));

    if (m_State == INCOMING_TRANS_FINAL_RESPONSE_SENT &&
        (m_pResponseSocket != NULL && 
            m_pResponseSocket->GetTransport() != SIP_TRANSPORT_UDP)
        )
    {
        ReleaseResponseSocket();
    }
    else
    {
        TerminateTransactionOnError(HRESULT_FROM_WIN32(ErrorCode));
    }
}


VOID
INCOMING_TRANSACTION::OnConnectComplete(
    IN DWORD ErrorCode
    )
{
    // TODO TODO XXX
}


VOID
INCOMING_TRANSACTION::FreeRecordRouteHeaderList()
{
    LIST_ENTRY          *pListEntry;
    RECORD_ROUTE_HEADER *pRecordRouteHeader;

    while (!IsListEmpty(&m_RecordRouteHeaderList))
    {
        pListEntry = RemoveHeadList(&m_RecordRouteHeaderList);

        pRecordRouteHeader = CONTAINING_RECORD(pListEntry,
                                               RECORD_ROUTE_HEADER,
                                               m_ListEntry);
        delete pRecordRouteHeader;
    }
}


HRESULT
INCOMING_TRANSACTION::SetResponseSocketAndVia(
    IN SIP_MESSAGE  *pSipMsg,
    IN ASYNC_SOCKET *pResponseSocket
    )
{
    // The following socket stuff should be common
    // to all incoming request processing.

    ENTER_FUNCTION("INCOMING_TRANSACTION::SetResponseSocketAndVia");
    
    // Store the Via headers
    HRESULT     hr;
    SOCKADDR_IN ResponseDestAddr;
    SOCKADDR_IN ActualResponseDestAddr;
    
    hr = pSipMsg->GetStoredMultipleHeaders(SIP_HEADER_VIA,
                                           &m_ViaHeaderArray,
                                           &m_NumViaHeaders);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s GetStoredMultipleHeaders failed %x",
             __fxName, hr));
        return hr;
    }

    if (pResponseSocket->GetTransport() != SIP_TRANSPORT_UDP)
    {
        // TCP & SSL
        
        hr = pResponseSocket->AddToErrorNotificationList(this);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s AddToErrorNotificationList failed %x",
                 __fxName, hr));
            return hr;
        }        
        
        hr = m_pSipMsgProc->GetSipStack()->MapDestAddressToNatInternalAddress(
                 pResponseSocket->m_LocalAddr.sin_addr.s_addr,
                 &pResponseSocket->m_RemoteAddr,
                 m_pSipMsgProc->GetTransport(),
                 &ActualResponseDestAddr,
                 &m_IsDestExternalToNat);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s MapDestAddressToNatInternalAddress failed %x",
                 __fxName, hr));
            return hr;
        }

        m_pResponseSocket = pResponseSocket;
        m_pResponseSocket->AddRef();
        LOG((RTC_TRACE, "%s - non-UDP setting response socket to %x",
             __fxName, m_pResponseSocket));
    }
    else
    {
        // UDP
        // Get the Via address
        ULONG BytesParsed = 0;
        // OFFSET_STRING Host;
        COUNTED_STRING  Host;
        USHORT          Port;
        
        hr = ParseFirstViaHeader(m_ViaHeaderArray[0].Buffer,
                                 m_ViaHeaderArray[0].Length,
                                 &BytesParsed, &Host, &Port);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s ParseFirstViaHeader failed %x",
                 __fxName, hr));
            return hr;
        }

        // XXX TODO - shouldn't make a synchronous call here
        
        hr = ResolveHost(Host.Buffer,
                         Host.Length,
                         Port,
                         SIP_TRANSPORT_UDP,
                         &ResponseDestAddr);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s ResolveHost failed %x",
                 __fxName, hr));
            return hr;
        }

        hr = m_pSipMsgProc->GetSipStack()->MapDestAddressToNatInternalAddress(
                 pResponseSocket->m_LocalAddr.sin_addr.s_addr,
                 &ResponseDestAddr,
                 m_pSipMsgProc->GetTransport(),
                 &ActualResponseDestAddr,
                 &m_IsDestExternalToNat);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s MapDestAddressToNatInternalAddress failed %x",
                 __fxName, hr));
            return hr;
        }

        CopyMemory(&m_ResponseDestAddr, &ActualResponseDestAddr,
                   sizeof(m_ResponseDestAddr));
        
        hr = m_pSipMsgProc->GetSipStack()->GetSocketToDestination(
                 &m_ResponseDestAddr,
                 m_pSipMsgProc->GetTransport(),
                 m_pSipMsgProc->GetRemotePrincipalName(),
                 this,
                 NULL,
                 &m_pResponseSocket);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s GetSocketToDestination failed %x",
                 __fxName, hr));
            return hr;
        }

        LOG((RTC_TRACE, "%s - UDP setting response socket to %x",
             __fxName, m_pResponseSocket));
    }

    return S_OK;
}


// Sometimes we could still be setting up the request socket and
// m_LocalContact for the SIP_MSG_PROCESSOR while we are sending the
// response.  So, we get the contact header in the response using the
// response socket.

HRESULT
INCOMING_TRANSACTION::AppendContactHeaderToResponse(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesFilled
    )
{
    int         LocalContactSize = 0;
    CHAR        LocalContact[64];
    HRESULT     hr;
    SOCKADDR_IN ListenAddr;

    ENTER_FUNCTION("INCOMING_TRANSACTION::AppendContactHeaderToResponse");

    // ASSERT(m_pResponseSocket->GetTransport() != SIP_TRANSPORT_SSL);
    ASSERT(m_pResponseSocket != NULL);

    hr = m_pSipMsgProc->GetListenAddr(
             m_pResponseSocket,
             m_IsDestExternalToNat,
             &ListenAddr);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s GetListenAddr failed %x",
             __fxName, hr));
        return hr;
    }
    
    if (m_pSipMsgProc->GetTransport() == SIP_TRANSPORT_UDP)
    {
        LocalContactSize = _snprintf(LocalContact,
                                     sizeof(LocalContact),
                                     "<sip:%d.%d.%d.%d:%d>",
                                     PRINT_SOCKADDR(&ListenAddr));
    }
    else if (m_pSipMsgProc->GetTransport() == SIP_TRANSPORT_TCP)
    {
        LocalContactSize = _snprintf(LocalContact,
                                     sizeof(LocalContact),
                                     "<sip:%d.%d.%d.%d:%d;transport=%s>",
                                     PRINT_SOCKADDR(&ListenAddr),
                                     GetTransportText(m_pSipMsgProc->GetTransport(),
                                                      FALSE)
                                     );
    }
    else if (m_pSipMsgProc->GetTransport() == SIP_TRANSPORT_SSL)
    {
        LocalContactSize = _snprintf(LocalContact,
                                     sizeof(LocalContact),
                                     "<sip:%d.%d.%d.%d:%d;transport=%s>;proxy=replace",
                                     PRINT_SOCKADDR(&ListenAddr),
                                     GetTransportText(m_pSipMsgProc->GetTransport(),
                                                      FALSE)
                                     );
    }
    
    if (LocalContactSize < 0)
    {
        LOG((RTC_ERROR, "%s _snprintf failed", __fxName));
        return E_FAIL;
    }

    LOG((RTC_TRACE, "%s - appending %s", __fxName, LocalContact));

    hr = AppendHeader(Buffer, BufLen, pBytesFilled,
                      SIP_HEADER_CONTACT,
                      LocalContact,
                      LocalContactSize);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s appending contact header failed %x",
             __fxName, hr));
        return hr;
    }
    
    return S_OK;
}


// If fAppendEndOfHeaders is TRUE CRLFCRLF is appended.
// This should be set if there is no message body. Otherwise
// the caller is expected to append a message body using the
// AppendMsgBody() function.
// Pass MethodStr if method is unknown (used for CSeq)
HRESULT
INCOMING_TRANSACTION::CreateResponseMsg(
    IN      ULONG             StatusCode,
    IN      PSTR              ReasonPhrase,
    IN      ULONG             ReasonPhraseLen,
    IN      PSTR              MethodStr,
    IN      BOOL              fAddContactHeader,
    IN      PSTR              MsgBody,
    IN      ULONG             MsgBodyLen,  
    IN      PSTR              ContentType,
    IN      ULONG             ContentTypeLen,  
    OUT     SEND_BUFFER     **ppResponseBuffer,
    IN      SIP_HEADER_ARRAY_ELEMENT   *pAdditionalHeaderArray,
    IN      ULONG             AdditionalHeaderCount
    )
{
    HRESULT hr;
    ULONG   i;
    ULONG   BufLen      = SEND_BUFFER_SIZE;
    ULONG   BytesFilled = 0;
    ULONG   tempBufLen = 0;

    ENTER_FUNCTION("INCOMING_TRANSACTION::CreateResponseMsg");
   
    PSTR Buffer = (PSTR) malloc(BufLen);
    if (Buffer == NULL)
    {
        return E_OUTOFMEMORY;
    }

    // Created with a ref count of 1.
    SEND_BUFFER *pSendBuffer = new SEND_BUFFER(Buffer, SEND_BUFFER_SIZE);
    if (pSendBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }
    
    hr = AppendStatusLine(Buffer, BufLen, &BytesFilled,
                          StatusCode, ReasonPhrase, ReasonPhraseLen);
    if (hr != S_OK)
        goto error;

    for (i = 0; i < m_NumViaHeaders; i++)
    {
        hr = AppendHeader(Buffer, BufLen, &BytesFilled,
                          SIP_HEADER_VIA,
                          m_ViaHeaderArray[i].Buffer,
                          m_ViaHeaderArray[i].Length);
        if (hr != S_OK)
            goto error;
    }

    hr = AppendHeader(Buffer, BufLen, &BytesFilled,
                      SIP_HEADER_FROM,
                      m_pSipMsgProc->GetRemote(),
                      m_pSipMsgProc->GetRemoteLen());
    if (hr != S_OK)
        goto error;

    hr = AppendHeader(Buffer, BufLen, &BytesFilled,
                      SIP_HEADER_TO,
                      m_pSipMsgProc->GetLocal(),
                      m_pSipMsgProc->GetLocalLen());
    if (hr != S_OK)
        goto error;

    hr = AppendHeader(Buffer, BufLen, &BytesFilled,
                      SIP_HEADER_CALL_ID,
                      m_pSipMsgProc->GetCallId(),
                      m_pSipMsgProc->GetCallIdLen());
    if (hr != S_OK)
        goto error;

    hr = AppendCSeqHeader(Buffer, BufLen, &BytesFilled,
                          m_CSeq, m_MethodId, MethodStr);
    if (hr != S_OK)
        goto error;

    hr = AppendRecordRouteHeaders(Buffer, BufLen, &BytesFilled,
                                  SIP_HEADER_RECORD_ROUTE,
                                  &m_RecordRouteHeaderList);
    if (hr != S_OK)
        goto error;

    // Don't send Contact header when using SSL.
    // if (m_pSipMsgProc->GetTransport() != SIP_TRANSPORT_SSL &&
    if (fAddContactHeader)
    {
        hr = AppendContactHeaderToResponse(
                 Buffer, BufLen, &BytesFilled
                 );
        if (hr != S_OK)
            goto error;
    }

    hr = AppendUserAgentHeaderToRequest(Buffer, BufLen, &BytesFilled);
    if (hr != S_OK)
        goto error;

    if (AdditionalHeaderCount != 0)
    {
        for (ULONG i = 0; i < AdditionalHeaderCount; i++)
        {
            
            hr = AppendHeader(Buffer, BufLen, &BytesFilled,
                              pAdditionalHeaderArray[i].HeaderId,
                              pAdditionalHeaderArray[i].HeaderValue,
                              pAdditionalHeaderArray[i].HeaderValueLen);
            if (hr != S_OK)
                goto error;
        }
    }

    if (MsgBody == NULL)
    {
        hr = AppendEndOfHeadersAndNoMsgBody(Buffer, BufLen,
                                            &BytesFilled);
        if (hr != S_OK)
            goto error;
    }
    else
    {

        hr = AppendMsgBody(Buffer, BufLen, &BytesFilled,
                           MsgBody, MsgBodyLen,
                           ContentType, ContentTypeLen
                           );
        if (hr != S_OK)
            goto error;
    }

    pSendBuffer->m_BufLen = BytesFilled;
    *ppResponseBuffer = pSendBuffer;
    return S_OK;
    
 error:

    LOG((RTC_ERROR, "%s Error %x", __fxName, hr));
    
    if (pSendBuffer != NULL)
    {
        // Deleting pSendBuffer will also free Buffer.
        delete pSendBuffer;
    }
    else if (Buffer != NULL)
    {
        free(Buffer);
    }
    
    *ppResponseBuffer = NULL;
    return hr;
}


// Create the response and store it in m_pResponseBuffer
// for retransmits.
HRESULT
INCOMING_TRANSACTION::CreateAndSendResponseMsg(
    IN  ULONG    StatusCode,
    IN  PSTR     ReasonPhrase,
    IN  ULONG    ReasonPhraseLen,
    IN  PSTR     MethodStr,
    IN  BOOL     fAddContactHeader,
    IN  PSTR     MsgBody,
    IN  ULONG    MsgBodyLen,
    IN  PSTR     ContentType,
    IN  ULONG    ContentTypeLen, 
    IN  SIP_HEADER_ARRAY_ELEMENT   *pAdditionalHeaderArray,
    IN  ULONG    AdditionalHeaderCount
    )
{
    HRESULT     hr;
    DWORD       Error;

    ENTER_FUNCTION("INCOMING_TRANSACTION::CreateAndSendResponseMsg");
    
    ASSERT(m_pResponseBuffer == NULL);
    
    // Create the response.
    hr = CreateResponseMsg(StatusCode, ReasonPhrase, ReasonPhraseLen,
                           MethodStr, 
                           fAddContactHeader,
                           MsgBody, MsgBodyLen,
                           ContentType, ContentTypeLen,
                           &m_pResponseBuffer,
                           pAdditionalHeaderArray,
                           AdditionalHeaderCount
                           );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s  failed CreateResponseMsg failed %x",
             __fxName, hr));
        return hr;
    }

    // Send the buffer.
    ASSERT(m_pResponseSocket);
    ASSERT(m_pResponseBuffer);
    
    Error = m_pResponseSocket->Send(m_pResponseBuffer);
    if (Error != NO_ERROR)
    {
        LOG((RTC_ERROR, "%s  m_pResponseSocket->Send() failed %x",
             __fxName, Error));
        return HRESULT_FROM_WIN32(Error);
    }

    return S_OK;
}


// Parse the Record-Route headers and store them in the
// transaction - This list will sent in the response.
// Copy the Record-Route/Contact headers into the Route header
// for future requests and set the request destination.
HRESULT
INCOMING_TRANSACTION::ProcessRecordRouteContactAndFromHeadersInRequest(
    IN SIP_MESSAGE *pSipMsg
    )
{
    ENTER_FUNCTION("INCOMING_TRANSACTION::ProcessRecordRouteContactAndFromHeadersInRequest");
    HRESULT hr;

    hr = pSipMsg->ParseRecordRouteHeaders(&m_RecordRouteHeaderList);
    if (hr != S_OK && hr != RTC_E_SIP_HEADER_NOT_PRESENT)
    {
        LOG((RTC_ERROR, "%s - ParseRecordRouteHeaders failed %x",
             __fxName, hr));
        return hr;
    }

    hr = m_pSipMsgProc->ProcessRecordRouteContactAndFromHeadersInRequest(
             &m_RecordRouteHeaderList,
             pSipMsg
             );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR,
             "%s ProcessRecordRouteContactAndFromHeadersInRequest failed %x",
             __fxName, hr));
        return hr;
    }

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
// OUTGOING_TRANSACTION
///////////////////////////////////////////////////////////////////////////////


OUTGOING_TRANSACTION::OUTGOING_TRANSACTION(
    IN SIP_MSG_PROCESSOR    *pSipMsgProc,
    IN SIP_METHOD_ENUM       MethodId,
    IN ULONG                 CSeq,
    IN BOOL                  AuthHeaderSent
    ) :
    SIP_TRANSACTION(pSipMsgProc, MethodId, CSeq, FALSE)
{
    m_State                 = OUTGOING_TRANS_INIT;
    m_NumRetries            = 0;
    m_TimerValue            = 0;

    m_WaitingToSendRequest  = FALSE;

    m_pRequestBuffer        = NULL;
    m_AuthHeaderSent        = AuthHeaderSent;

    m_AdditionalHeaderArray = NULL;
    m_AdditionalHeaderCount = 0;
    
    m_szMsgBody             = NULL;
    m_MsgBodyLen            = 0;

    m_ContentType           = NULL;
    m_ContentTypeLen        = 0;
    m_isContentTypeMemoryAllocated = FALSE;
    InsertTailList(&m_pSipMsgProc->m_OutgoingTransactionList,
                   &m_ListEntry);

    LOG((RTC_TRACE, "OUTGOING_TRANSACTION(%x) created", this));
}


OUTGOING_TRANSACTION::~OUTGOING_TRANSACTION()
{    
    if (m_pRequestBuffer != NULL)
    {
        m_pRequestBuffer->Release();
        m_pRequestBuffer = NULL;
    }

    if (m_AdditionalHeaderArray != NULL)
    {
        for( ULONG i = 0; i < m_AdditionalHeaderCount; i++ )
        {
            if( m_AdditionalHeaderArray[i].HeaderValue != NULL )
            {
                free( m_AdditionalHeaderArray[i].HeaderValue );
            }
        }
        free(m_AdditionalHeaderArray);
    }
    
    if (m_szMsgBody != NULL)
    {
        free(m_szMsgBody);
    }
    if(m_isContentTypeMemoryAllocated == TRUE && m_ContentType != NULL)
        free(m_ContentType);
    m_ContentType = NULL;
    
    // The transaction should be removed from the list only in
    // the destructor. refer to SIP_MSG_PROCESSOR::OnSocketError()
    RemoveEntryList(&m_ListEntry);
    
    LOG((RTC_TRACE, "~OUTGOING_TRANSACTION(%x) deleted", this));
}


// XXX TODO in the case of non-UDP we should actually
// try to re-establish the connection to the destination. This
// will help the scenario where the TCP connection we are using
// is reset because there was no traffic on the connection for
// some time (REGISTER/SUBSCRIBE scenario).

// Should we terminate the transaction in all cases or only in
// those cases where we are actually using the request socket.
// Should we terminate the transaction even if we are not using
// the request socket ?
void
OUTGOING_TRANSACTION::OnSocketError(
    IN DWORD ErrorCode
    )
{
    ENTER_FUNCTION("OUTGOING_TRANSACTION::OnSocketError");
    LOG((RTC_ERROR, "%s - error: %x",
         __fxName, ErrorCode));

    if (m_pSipMsgProc->GetTransport() == SIP_TRANSPORT_UDP ||
        (m_pSipMsgProc->GetTransport() != SIP_TRANSPORT_UDP &&
         m_State != OUTGOING_TRANS_ACK_SENT))
    {
        TerminateTransactionOnError(HRESULT_FROM_WIN32(ErrorCode));
    }
}


// Initialize the state machine and send the
// request message.
HRESULT
OUTGOING_TRANSACTION::CreateAndSendRequestMsg(
    IN  ULONG                       TimerValue,
    IN  SIP_HEADER_ARRAY_ELEMENT   *AdditionalHeaderArray,
    IN  ULONG                       AdditionalHeaderCount,
    IN  PSTR                        MsgBody,
    IN  ULONG                       MsgBodyLen,
    IN  PSTR                        ContentType,
    IN  ULONG                       ContentTypeLen
    )
{
    HRESULT hr;

    ENTER_FUNCTION("OUTGOING_TRANSACTION::CreateAndSendRequestMsg");

    ASSERT(m_State == OUTGOING_TRANS_INIT);
    ASSERT(m_pRequestBuffer == NULL);
    ASSERT(m_pSipMsgProc->GetRequestSocketState() == REQUEST_SOCKET_CONNECTED);

    hr = m_pSipMsgProc->CreateRequestMsg(m_MethodId, m_CSeq,
                                         NULL, 0,     // No special To header
                                         AdditionalHeaderArray,
                                         AdditionalHeaderCount,
                                         MsgBody, MsgBodyLen,
                                         ContentType, ContentTypeLen,
                                         &m_pRequestBuffer
                                         );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s CreateRequestMsg failed %x",
             __fxName, hr));
        return hr;
    }

    hr = m_pSipMsgProc->SendRequestMsg(m_pRequestBuffer);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s SendRequestMsg failed %x", __fxName, hr));
        return hr;
    }
    
    m_State = OUTGOING_TRANS_REQUEST_SENT;

    m_TimerValue = TimerValue;
    m_NumRetries = 1;

    hr = StartTimer(m_TimerValue);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s  StartTimer failed %x", __fxName, hr));
        return hr;
    }

    return S_OK;
}


HRESULT
OUTGOING_TRANSACTION::StoreTimerAndAdditionalHeaders(
    IN  ULONG                       TimerValue,
    IN  SIP_HEADER_ARRAY_ELEMENT   *AdditionalHeaderArray,
    IN  ULONG                       AdditionalHeaderCount
    )
{
    HRESULT hr;
    
    ENTER_FUNCTION("OUTGOING_TRANSACTION::StoreTimerAndAdditionalHeaders");
    
    m_TimerValue = TimerValue;

    // Store the headers.
    if (AdditionalHeaderArray != NULL &&
        AdditionalHeaderCount != 0)
    {
        m_AdditionalHeaderArray = (SIP_HEADER_ARRAY_ELEMENT *)
            malloc(AdditionalHeaderCount * sizeof(SIP_HEADER_ARRAY_ELEMENT));

        if (m_AdditionalHeaderArray == NULL)
        {
            LOG((RTC_ERROR, "%s allocating m_AdditionalHeaderArray failed",
                 __fxName));
            return E_OUTOFMEMORY;
        }

        ZeroMemory(m_AdditionalHeaderArray,
                   AdditionalHeaderCount * sizeof(SIP_HEADER_ARRAY_ELEMENT));
        
        m_AdditionalHeaderCount = AdditionalHeaderCount;

        for (ULONG i = 0; i < AdditionalHeaderCount; i++)
        {
            m_AdditionalHeaderArray[i].HeaderId =
                AdditionalHeaderArray[i].HeaderId;

            hr = AllocString(
                     AdditionalHeaderArray[i].HeaderValue,
                     AdditionalHeaderArray[i].HeaderValueLen,
                     &m_AdditionalHeaderArray[i].HeaderValue,
                     &m_AdditionalHeaderArray[i].HeaderValueLen
                     );
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s allocating additional header value failed",
                     __fxName));
                m_AdditionalHeaderCount = i;
                return E_OUTOFMEMORY;
            }
        }
    }

    return S_OK;
}


HRESULT
OUTGOING_TRANSACTION::RetransmitRequest()
{
    HRESULT hr;

    // XXX Assert that the request socket is connected.

    ENTER_FUNCTION("OUTGOING_TRANSACTION::RetransmitRequest");
    
    // Send the buffer.
    hr = CheckRequestSocketAndRetransmitRequestMsg();
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s SendRequestMsg failed %x", __fxName, hr));
        return hr;
    }
    
    m_NumRetries++;
    return S_OK;
}


// For INVITE transaction things are special as we need to take care
// of the ACK case also. So, OUTGOING_INVITE_TRANSACTION overrides this
// function.

// virtual
VOID
OUTGOING_TRANSACTION::OnRequestSocketConnectComplete(
    IN DWORD        ErrorCode
    )
{
    HRESULT hr = S_OK;
    
    ENTER_FUNCTION("OUTGOING_TRANSACTION::OnRequestSocketConnectComplete");

    // Check if we are currently waiting for the connect completion.
    // If we are waiting - grab the socket and send the request message.

    if (m_State == OUTGOING_TRANS_INIT && m_WaitingToSendRequest)
    {
        if( ErrorCode != NO_ERROR )
        {
            LOG((RTC_ERROR, "%s - connection failed error %x",
                 __fxName, ErrorCode));
            TerminateTransactionOnError(HRESULT_FROM_WIN32(ErrorCode));
            return;
        }
        
        if (m_szMsgBody == NULL)
        {
            hr = GetAndStoreMsgBodyForRequest();
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s GetAndStoreMsgBodyForRequest failed %x",
                     __fxName, hr));
                TerminateTransactionOnError(hr);
                return;
            }
        }
        // Get ContentType
        if (m_szMsgBody != NULL && m_ContentType == NULL && m_ContentTypeLen == 0)
        {
            //we do not set m_isContentTypeMemoryAllocated here since no memory is allocated
            if (m_MethodId == SIP_METHOD_MESSAGE)
            {
                m_ContentType = SIP_CONTENT_TYPE_MSGTEXT_TEXT;
                m_ContentTypeLen = sizeof(SIP_CONTENT_TYPE_MSGTEXT_TEXT)-1;
            }
            else if (m_MethodId == SIP_METHOD_INFO)
            {
                m_ContentType = SIP_CONTENT_TYPE_MSGXML_TEXT;
                m_ContentTypeLen = sizeof(SIP_CONTENT_TYPE_MSGXML_TEXT)-1;
            }
            else if ((
                (m_pSipMsgProc->GetMsgProcType() == SIP_MSG_PROC_TYPE_WATCHER) ||
                (m_pSipMsgProc->GetMsgProcType() == SIP_MSG_PROC_TYPE_BUDDY))  &&
                m_MethodId == SIP_METHOD_NOTIFY)
            {
                m_ContentType = SIP_CONTENT_TYPE_MSGXPIDF_TEXT;
                m_ContentTypeLen = sizeof(SIP_CONTENT_TYPE_MSGXPIDF_TEXT)-1;
            }
            else
            {
                m_ContentType = SIP_CONTENT_TYPE_SDP_TEXT;
                m_ContentTypeLen = sizeof(SIP_CONTENT_TYPE_SDP_TEXT);
            }
        }
       hr = CheckRequestSocketAndSendRequestMsgAfterConnectComplete();

        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s CheckRequestSocketAndSendRequestMsgAfterConnectComplete failed %x",
                 __fxName, hr));
            TerminateTransactionOnError(hr);
            return;
        }
    }
}


HRESULT
OUTGOING_TRANSACTION::GetAuthChallengeForAuthProtocol(
    IN  SIP_HEADER_ENTRY   *pAuthHeaderList,
    IN  ULONG               NumHeaders,
    IN  SIP_MESSAGE        *pSipMsg,
    IN  SIP_AUTH_PROTOCOL   AuthProtocol,
    OUT SECURITY_CHALLENGE *pAuthChallenge
    )
{
    ENTER_FUNCTION("OUTGOING_TRANSACTION::GetAuthChallengeForAuthProtocol");
    
    HRESULT             hr;
    ULONG               i = 0;
    SIP_HEADER_ENTRY   *pHeaderEntry;
    LIST_ENTRY         *pListEntry;
    PSTR                Realm;
    ULONG               RealmLen;
    ANSI_STRING         ChallengeString;

    pListEntry = &(pAuthHeaderList->ListEntry);
    
    for (i = 0; i < NumHeaders; i++)
    {
        pHeaderEntry = CONTAINING_RECORD(pListEntry,
                                         SIP_HEADER_ENTRY,
                                         ListEntry);
        
        ChallengeString.Buffer          = pHeaderEntry->HeaderValue.GetString(pSipMsg->BaseBuffer);
        ChallengeString.Length          = (USHORT)pHeaderEntry->HeaderValue.Length;
        ChallengeString.MaximumLength   = (USHORT)pHeaderEntry->HeaderValue.Length;

        hr = ::ParseAuthChallenge(&ChallengeString, pAuthChallenge);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s - digest ParseAuthChallenge failed: %x",
                 __fxName, hr));
        }
        if (hr == S_OK)
        {
            Realm       = pAuthChallenge->Realm.Buffer;
            RealmLen    = pAuthChallenge->Realm.Length;

            if (pAuthChallenge->AuthProtocol == AuthProtocol)
            {
                if (!m_pSipMsgProc->CredentialsSet())
                {
                    hr = m_pSipMsgProc->GetCredentialsForRealm(Realm, RealmLen);
                    if (hr != S_OK)
                    {
                        LOG((RTC_ERROR, "%s GetCredentialsForRealm failed %x",
                             __fxName, hr));
                    }
                    else
                    {
                        LOG((RTC_TRACE, "%s(%d) Found credentials for realm: %.*s",
                             __fxName, AuthProtocol, RealmLen, Realm));
                        return S_OK;
                    }
                }
                else
                {
                    if (AreCountedStringsEqual(m_pSipMsgProc->GetRealm(),
                                               m_pSipMsgProc->GetRealmLen(),
                                               Realm, RealmLen,
                                               FALSE // case insensitive
                                               ))
                    {
                        LOG((RTC_TRACE, "%s(%d) challenge realm %.*s matches",
                             __fxName, AuthProtocol, RealmLen, Realm));
                        return S_OK;
                    }
                    else
                    {
                        LOG((RTC_TRACE, "%s(%d) challenge realm %.*s does not match",
                             __fxName, AuthProtocol, RealmLen, Realm));
                    }
                }
            }
        }
        
        pListEntry = pListEntry->Flink;
    }

    return RTC_E_SIP_AUTH_TYPE_NOT_SUPPORTED;
}

// Go through the list of challenges and select one we support.
// XXX TODO Should we do some more selection based on the realm / auth protocol
HRESULT
OUTGOING_TRANSACTION::GetAuthChallenge(
    IN  SIP_HEADER_ENUM     SipHeaderId,
    IN  SIP_MESSAGE        *pSipMsg,
    OUT SECURITY_CHALLENGE *pAuthChallenge
    )
{
    ENTER_FUNCTION("OUTGOING_TRANSACTION::GetAuthChallenge");
    
    SIP_HEADER_ENTRY *pHeaderEntry;
    ULONG             NumHeaders;
    HRESULT           hr;

    ASSERT(SipHeaderId == SIP_HEADER_WWW_AUTHENTICATE ||
           SipHeaderId == SIP_HEADER_PROXY_AUTHENTICATE);

    hr = pSipMsg->GetHeader(SipHeaderId, &pHeaderEntry, &NumHeaders);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s Couldn't find %d header %x",
             __fxName, SipHeaderId, hr));
        return hr;
    }

    // The order we follow is digest, basic.
    hr = GetAuthChallengeForAuthProtocol(
             pHeaderEntry, NumHeaders, pSipMsg,
             SIP_AUTH_PROTOCOL_MD5DIGEST,
             pAuthChallenge);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s GetAuthChallengeForAuthProtocol(digest) failed %x",
             __fxName, hr));
    }
    else
    {
        return S_OK;
    }
    
    // Basic is permitted only over SSL.
    if (m_pSipMsgProc->GetTransport() == SIP_TRANSPORT_SSL)
    {
        hr = GetAuthChallengeForAuthProtocol(
                 pHeaderEntry, NumHeaders, pSipMsg,
                 SIP_AUTH_PROTOCOL_BASIC,
                 pAuthChallenge);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s GetAuthChallengeForAuthProtocol(basic) failed %x",
                 __fxName, hr));
        }
        else if (m_pSipMsgProc->GetAuthProtocol() != SIP_AUTH_PROTOCOL_BASIC)
        {
            LOG((RTC_ERROR, "%s - AuthProtocol is not basic: %d",
                 __fxName, m_pSipMsgProc->GetAuthProtocol()));
            hr = RTC_E_SIP_AUTH_TYPE_NOT_SUPPORTED;
        }
    }
    else
    {
        LOG((RTC_ERROR, "%s basic supported only over SSL", __fxName));
        hr = RTC_E_SIP_AUTH_TYPE_NOT_SUPPORTED;
    }
    

    LOG((RTC_TRACE, "%s  returning %x", __fxName, hr));
    return hr;
}


// Have an extra parameter saying whether we should show the Credentials
// From UI.
//
// If successful pAuthHeaderElement->HeaderValue will contain a buffer
// allocated with malloc(). The caller needs to free it with free().

// If the credentials UI is shown, the caller of this function should
// make sure that the transaction object is alive after the user
// clicks OK/Cancel on the credentials UI, even if the transaction is
// done (using TransactionAddRef()).
// Otherwise this will result in an AV as we access the transaction.

HRESULT
OUTGOING_TRANSACTION::ProcessAuthRequired(
    IN  SIP_MESSAGE                *pSipMsg,
    IN  BOOL                        fPopupCredentialsUI,  
    OUT SIP_HEADER_ARRAY_ELEMENT   *pAuthHeaderElement,
    OUT SECURITY_CHALLENGE         *pAuthChallenge
    )
{
    HRESULT hr;

    ENTER_FUNCTION("OUTGOING_TRANSACTION::ProcessAuthRequired");
    
    ASSERT(pSipMsg->GetStatusCode() == 401 ||
           pSipMsg->GetStatusCode() == 407);

    // Get the Challenge based on the response.

    if (pSipMsg->GetStatusCode() == 401)
    {
        hr = GetAuthChallenge(
                 SIP_HEADER_WWW_AUTHENTICATE, pSipMsg, pAuthChallenge
                 );

        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s - getting WWW-Authenticate challenge failed",
                 __fxName));
            return hr;
        }

        pAuthHeaderElement->HeaderId = SIP_HEADER_AUTHORIZATION;
    }
    else if (pSipMsg->GetStatusCode() == 407)
    {
        hr = GetAuthChallenge(
                 SIP_HEADER_PROXY_AUTHENTICATE, pSipMsg, pAuthChallenge
                 );

        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s - getting Proxy-Authenticate challenge failed",
                 __fxName));
            return hr;
        }

        pAuthHeaderElement->HeaderId = SIP_HEADER_PROXY_AUTHORIZATION;
    }

    SECURITY_PARAMETERS DigestParameters;
    ANSI_STRING         asAuthHeader;
    PSTR                Realm;
    ULONG               RealmLen;

    Realm       = pAuthChallenge->Realm.Buffer;
    RealmLen    = pAuthChallenge->Realm.Length;


    // Get Credentials from UI if necessary.

    // If we have sent an auth header earlier
    // or we don't have the credentials or if the
    // realms don't match - popup the credentials UI.

    if (m_AuthHeaderSent ||
        m_pSipMsgProc->GetUsername() == NULL ||
        m_pSipMsgProc->GetPassword() == NULL
        )
    {
        if (fPopupCredentialsUI)
        {
            hr = m_pSipMsgProc->GetCredentialsFromUI(Realm, RealmLen);

            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s GetCredentialsFromUI failed %x",
                     __fxName, hr));
                return RTC_E_SIP_AUTH_FAILED;
            }
        }
        else
        {
            LOG((RTC_ERROR, "%s - returning RTC_E_SIP_AUTH_FAILED AuthHeaderSent: %d",
                 __fxName, m_AuthHeaderSent));
            return RTC_E_SIP_AUTH_FAILED;
        }
    }

    // Build the response.
    
    hr = SetDigestParameters(pAuthChallenge->AuthProtocol,
                             &DigestParameters);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s SetDigestParameters failed %x",
             __fxName, hr));
        return hr;
    }
        
    hr = BuildAuthResponse(pAuthChallenge,
                           &DigestParameters,
                           &asAuthHeader);

    FreeDigestParameters(&DigestParameters);
        
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s BuildAuthResponse failed %x",
             __fxName, hr));
        return hr;
    }

    pAuthHeaderElement->HeaderValueLen = asAuthHeader.Length;
    pAuthHeaderElement->HeaderValue    = asAuthHeader.Buffer;

    return S_OK;
}


HRESULT
OUTGOING_TRANSACTION::SetDigestParameters(
    IN  SIP_AUTH_PROTOCOL    AuthProtocol,
    OUT SECURITY_PARAMETERS *pDigestParams
    )
{
    ENTER_FUNCTION("OUTGOING_TRANSACTION::SetDigestParameters");

    ASSERT(pDigestParams);
    
    ZeroMemory(pDigestParams, sizeof(SECURITY_PARAMETERS));

    pDigestParams->Username.Buffer = m_pSipMsgProc->GetUsername();
    if (pDigestParams->Username.Buffer == NULL)
    {
        LOG((RTC_ERROR, "%s - Username not set in m_pSipMsgProc",
             __fxName));
        return E_FAIL;
    }
    
    pDigestParams->Username.Length = (USHORT)strlen(pDigestParams->Username.Buffer);
    pDigestParams->Username.MaximumLength = pDigestParams->Username.Length;

    pDigestParams->Password.Buffer = m_pSipMsgProc->GetPassword();
    if (pDigestParams->Password.Buffer == NULL)
    {
        LOG((RTC_ERROR, "%s - Password not set in m_pSipMsgProc",
             __fxName));
        return E_FAIL;
    }
    
    pDigestParams->Password.Length = (USHORT)strlen(pDigestParams->Password.Buffer);
    pDigestParams->Password.MaximumLength = pDigestParams->Password.Length;

    if (AuthProtocol == SIP_AUTH_PROTOCOL_MD5DIGEST)
    {
        const COUNTED_STRING *pKnownMethod = GetSipMethodName(m_MethodId);
        if (pKnownMethod == NULL)
        {
            LOG((RTC_ERROR, "%s - Unknown MethodId: %d - this shouldn't happen",
                 __fxName, m_MethodId));
            return E_FAIL;
        }
        
        pDigestParams->RequestMethod.Buffer = pKnownMethod->Buffer;
        pDigestParams->RequestMethod.Length = (USHORT) pKnownMethod->Length;
        pDigestParams->RequestMethod.MaximumLength = pDigestParams->RequestMethod.Length;
        
        pDigestParams->RequestURI.Buffer = m_pSipMsgProc->GetRequestURI();
        pDigestParams->RequestURI.Length = (USHORT) m_pSipMsgProc->GetRequestURILen();
        pDigestParams->RequestURI.MaximumLength = pDigestParams->RequestURI.Length;
        
        PSTR    UuidStr;
        ULONG   UuidStrLen = 0;
        HRESULT hr;
        
        hr = CreateUuid(&UuidStr, &UuidStrLen);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s CreateUuid failed %x", __fxName, hr));
            return hr;
        }
        
        GetNumberStringFromUuidString(UuidStr, UuidStrLen);
        
        pDigestParams->ClientNonce.Buffer = UuidStr;
        pDigestParams->ClientNonce.Length = (USHORT)strlen(UuidStr);
        pDigestParams->ClientNonce.MaximumLength = pDigestParams->ClientNonce.Length;
    }
    
    return S_OK;
}


HRESULT
OUTGOING_TRANSACTION::FreeDigestParameters(
    IN  SECURITY_PARAMETERS *pDigestParams
    )
{
    // All the other strings are not allocated for this structure.

    if (pDigestParams->ClientNonce.Buffer != NULL)
    {
        free(pDigestParams->ClientNonce.Buffer);
    }

    return S_OK;
}


// Keep a copy of the message body for sending in requests after 401/407 and for redirects
HRESULT
OUTGOING_TRANSACTION::StoreMsgBodyAndContentType(
    IN PSTR     MsgBody,
    IN ULONG    MsgBodyLen,
    IN PSTR     ContentType,
    IN ULONG    ContentTypeLen
    )
{
    HRESULT hr;

    ENTER_FUNCTION("OUTGOING_TRANSACTION::StoreMsgBody");

    if (m_szMsgBody != NULL)
    {
        free(m_szMsgBody);
        m_szMsgBody = NULL;
        m_MsgBodyLen = 0;
    }
    
    hr = AllocString(MsgBody, MsgBodyLen,
                     &m_szMsgBody, &m_MsgBodyLen);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s GetNullTerminatedString failed %x",
             __fxName, hr));
        return hr;
    }

    if(ContentType != NULL && ContentTypeLen != 0)
    {
        if (m_isContentTypeMemoryAllocated)
        {
            free(m_ContentType);
            m_ContentType = NULL;
            m_ContentTypeLen = 0;
        }
        hr = AllocString(ContentType, ContentTypeLen,
                         &m_ContentType, &m_ContentTypeLen);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s GetNullTerminatedString for content type failed %x",
                 __fxName, hr));
            m_isContentTypeMemoryAllocated = FALSE;
            return hr;
        }
        m_isContentTypeMemoryAllocated = TRUE;
    }

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Incoming INVITE
///////////////////////////////////////////////////////////////////////////////


INCOMING_INVITE_TRANSACTION::INCOMING_INVITE_TRANSACTION(
    IN SIP_CALL        *pSipCall,
    IN SIP_METHOD_ENUM  MethodId,
    IN ULONG            CSeq,
    IN BOOL             IsFirstInvite
    ):
    INCOMING_TRANSACTION(pSipCall, MethodId, CSeq)
{
    m_pSipCall            = pSipCall;
    m_NumRetries          = 0;
    m_TimerValue          = 0;
    m_pProvResponseBuffer = NULL;
    m_IsFirstInvite       = IsFirstInvite;
    m_InviteHasSDP        = FALSE;
    m_pMediaSession       = NULL;
}

    
INCOMING_INVITE_TRANSACTION::~INCOMING_INVITE_TRANSACTION()
{
    if (m_pProvResponseBuffer != NULL)
    {
        m_pProvResponseBuffer->Release();
        m_pProvResponseBuffer = NULL;
    }

    if (m_pMediaSession != NULL)
    {
        m_pMediaSession->Release();
    }
    
    // There could be some error scenarios when we don't
    // send the final response. So we need to do this
    // here too.
    // m_pSipCall->SetIncomingInviteTransaction(NULL);
    m_pSipCall->OnIncomingInviteTransactionDone(this);
    
    LOG((RTC_TRACE,
         "~INCOMING_INVITE_TRANSACTION() done"));
}


// Need to send 180 only if the UI doesn't call Accept()/Reject()
// before OfferCall() returns i.e. only if we haven't already
// sent the final response.
HRESULT
INCOMING_INVITE_TRANSACTION::Send180IfNeeded()
{
    HRESULT hr;
    
    ENTER_FUNCTION("INCOMING_INVITE_TRANSACTION::Send180IfNeeded");
    
    ASSERT(m_State != INCOMING_TRANS_ACK_RCVD &&
           m_State != INCOMING_TRANS_INIT);
    
    if (m_State == INCOMING_TRANS_REQUEST_RCVD)
    {
        hr = SendProvisionalResponse(180, 
                                     SIP_STATUS_TEXT(180),
                                     SIP_STATUS_TEXT_SIZE(180));
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s SendProvisionalResponse failed %x",
                 __fxName, hr));
            DeleteTransactionAndTerminateCallIfFirstInvite(hr);
            return hr;
        }
    }

    return S_OK;
}


HRESULT
INCOMING_INVITE_TRANSACTION::SendProvisionalResponse(
    IN ULONG StatusCode,
    IN PSTR  ReasonPhrase,
    IN ULONG ReasonPhraseLen
    )
{
    HRESULT     hr;
    DWORD       Error;

    ENTER_FUNCTION("INCOMING_INVITE_TRANSACTION::SendProvisionalResponse");
    LOG((RTC_TRACE, "%s - enter StatusCode: %d",
         __fxName, StatusCode));
    
    if (m_pProvResponseBuffer != NULL)
    {
        m_pProvResponseBuffer->Release();
        m_pProvResponseBuffer = NULL;
    }
    
    // Create the response.
    hr = CreateResponseMsg(StatusCode, ReasonPhrase, ReasonPhraseLen,
                           NULL,    // No Method string
                           NULL, 0, // No Message Body
                           NULL, 0, //No Content Type
                           FALSE,   // No Contact header
                           &m_pProvResponseBuffer);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - CreateResponseMsg failed %x",
             __fxName, hr));
        return hr;
    }

    // Send the buffer.
    ASSERT(m_pResponseSocket);
    ASSERT(m_pProvResponseBuffer);
    
    Error = m_pResponseSocket->Send(m_pProvResponseBuffer);
    if (Error != NO_ERROR)
    {
        LOG((RTC_ERROR, "%s - Send failed %x",
             __fxName, Error));
        return HRESULT_FROM_WIN32(Error);
    }

    return S_OK;
}


HRESULT
INCOMING_INVITE_TRANSACTION::Send200()
{
    ENTER_FUNCTION("INCOMING_INVITE_TRANSACTION::Send200");
    
    HRESULT hr;
    PSTR    MediaSDPBlob = NULL;
    
    LOG((RTC_TRACE, "entering %s", __fxName));

    ASSERT(m_pSipCall->GetCallType() == SIP_CALL_TYPE_RTP);
    RTP_CALL *pRtpCall = static_cast<RTP_CALL *> (m_pSipCall);
    
    IRTCMediaManage *pMediaManager = pRtpCall->GetMediaManager();
    ASSERT(pMediaManager != NULL);
    

    LOG((RTC_TRACE, "%s before GetSDPBlob ", __fxName));

    hr = pMediaManager->GetSDPBlob(0, &MediaSDPBlob);

    LOG((RTC_TRACE, "%s after GetSDPBlob ", __fxName));

    if (hr != S_OK && hr != RTC_E_SDP_NO_MEDIA)
    {
        LOG((RTC_ERROR, "%s: GetSDPBlob failed %x",
             __fxName, hr));
        return hr;
    }
    else if (hr == RTC_E_SDP_NO_MEDIA && m_IsFirstInvite)
    {
        LOG((RTC_ERROR,
             "%s: GetSDPBlob returned RTC_E_SDP_NO_MEDIA for 1st INVITE",
             __fxName));
        if (MediaSDPBlob != NULL)
            pMediaManager->FreeSDPBlob(MediaSDPBlob);
        return hr;
    }

    // For reINVITEs RTC_E_SDP_NO_MEDIA is fine.

    LOG((RTC_TRACE, "%s Sending SDP in 200 SDP length: %d",
         __fxName, strlen(MediaSDPBlob)));
    
    hr = CreateAndSendResponseMsg(
             200,
             SIP_STATUS_TEXT(200),
             SIP_STATUS_TEXT_SIZE(200),
             NULL,              // No Method string
             m_IsFirstInvite,   // Send contact header for 1st invite
             MediaSDPBlob, strlen(MediaSDPBlob),
             SIP_CONTENT_TYPE_SDP_TEXT, //Content Type
             sizeof(SIP_CONTENT_TYPE_SDP_TEXT)-1
             );

    pMediaManager->FreeSDPBlob(MediaSDPBlob);
    
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s CreateAndSendResponseMsg failed %x",
             __fxName, hr));
        return hr;
    }

    return S_OK;
}


HRESULT
INCOMING_INVITE_TRANSACTION::RetransmitResponse()
{
    DWORD Error;

    ENTER_FUNCTION("INCOMING_INVITE_TRANSACTION::RetransmitResponse");
    
    // Send the buffer.
    if (m_pResponseSocket != NULL)
    {
        Error = m_pResponseSocket->Send(m_pResponseBuffer);
        if (Error != NO_ERROR)
        {
            LOG((RTC_ERROR, "%s  Send failed %x",
                 __fxName, Error)); 
            return HRESULT_FROM_WIN32(Error);
        }
    }
    
    m_NumRetries++;
    return S_OK;
}


// ISipCall::Accept() calls this function. So the return
// value from this function is returned to Core. So, we don't
// notify any failures to Core using NotifyCallStateChange()
// The caller of Accept() is responsible for terminating the call and
// notifying Core/UI if necessary.
HRESULT
INCOMING_INVITE_TRANSACTION::Accept()
{
    HRESULT hr;

    ENTER_FUNCTION("INCOMING_INVITE_TRANSACTION::Accept");
    LOG((RTC_TRACE, "%s - enter ", __fxName));

    ASSERT(m_State == INCOMING_TRANS_REQUEST_RCVD);
    
    hr = SetSDPSession();
    if (hr != S_OK)
    {
        LOG((RTC_WARN, "%s Processing SDP in INVITE failed - rejecting INVITE",
             __fxName));
        HRESULT hrLocal;
        hrLocal = Reject(488, SIP_STATUS_TEXT(488), SIP_STATUS_TEXT_SIZE(488));
        if (hrLocal != S_OK)
        {
            LOG((RTC_ERROR, "%s Reject failed %x", __fxName, hrLocal));
        }
        return hr;
    }
        
    hr = Send200();
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s  Send200 failed %x - deleting transaction",
             __fxName, hr));
        if (m_IsFirstInvite)
        {
            m_pSipCall->CleanupCallTypeSpecificState();
        }
        OnTransactionDone();
        return hr;
    }

    m_State = INCOMING_TRANS_FINAL_RESPONSE_SENT;

    // XXX We should do this only if the incoming INVITE had SDP
    // Otherwise the ACK will have the SDP and it will update the SDP.
    // Since we have sent the final response, we can allow other
    // INVITE transactions now.
    // m_pSipCall->SetIncomingInviteTransaction(NULL);
    m_pSipCall->OnIncomingInviteTransactionDone(this);

    LOG((RTC_TRACE, "%s : Sent 200 response", __fxName));
    // Start Timer for receiving ACK
    m_TimerValue = SIP_TIMER_RETRY_INTERVAL_T1;
    m_NumRetries = 1;
    hr = StartTimer(m_TimerValue);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s  StartTimer failed %x - deleting transaction",
             __fxName, hr));
        if (m_IsFirstInvite)
        {
            m_pSipCall->CleanupCallTypeSpecificState();
        }
        OnTransactionDone();
        return hr;
    }

    return S_OK;
}


// ISipCall::Reject() calls this function or this function
// could be called before notifying core about the call. So, we don't
// notify any failures to Core using NotifyCallStateChange()
// The caller of Reject() is responsible for terminating the call and
// notifying Core/UI if necessary.
HRESULT
INCOMING_INVITE_TRANSACTION::Reject(
    IN ULONG StatusCode,
    IN PSTR  ReasonPhrase,
    IN ULONG ReasonPhraseLen
    )
{
    HRESULT hr;
    
    ENTER_FUNCTION("INCOMING_INVITE_TRANSACTION::Reject");

    ASSERT(m_State == INCOMING_TRANS_REQUEST_RCVD);

    // Note that we should not call ReInitialize() on the
    // MediaManager here as we could currently be in another
    // call when Reject() is called. Note that before Accept()
    // is called we don't set the SDP and so there is no need
    // for calling ReInitialize().

    if (m_IsFirstInvite)
    {
        m_pSipCall->SetCallState(SIP_CALL_STATE_DISCONNECTED);
    }
    
    // Since we are rejecting this INVITE, we can allow other
    // INVITE transactions now.
    m_pSipCall->OnIncomingInviteTransactionDone(this);

    hr = CreateAndSendResponseMsg(
             StatusCode, ReasonPhrase, ReasonPhraseLen,
             NULL,    // No Method string
             FALSE,   // Don't send contact header if you are rejecting
             //m_IsFirstInvite,   // Send contact header for 1st invite
             NULL, 0,  // No Message Body
             NULL, 0 // No content Type
             );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s  CreateAndSendResponseMsg failed %x - deleting transaction",
             __fxName, hr));
        OnTransactionDone();
        return hr;
    }
    
    m_State = INCOMING_TRANS_FINAL_RESPONSE_SENT;

    LOG((RTC_TRACE, "%s : Sent %d response", __fxName, StatusCode));

    // Start Timer for receiving ACK
    m_TimerValue = SIP_TIMER_RETRY_INTERVAL_T1;
    m_NumRetries = 1;
    hr = StartTimer(m_TimerValue);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s  StartTimer failed %x - deleting transaction",
             __fxName, hr));
        OnTransactionDone();
        return hr;
    }
    
    return S_OK;
}


// Process SDP only for RTP calls.
// If SDP is not present in INVITE, we will process the
// SDP in the ACK later.
HRESULT
INCOMING_INVITE_TRANSACTION::ValidateAndStoreSDPInInvite(
    IN SIP_MESSAGE *pSipMsg
    )
{
    PSTR    MsgBody;
    ULONG   MsgBodyLen;
    HRESULT hr;

    ENTER_FUNCTION("INCOMING_INVITE_TRANSACTION::ValidateAndStoreSDPInInvite");

    if (m_pSipCall->GetCallType() != SIP_CALL_TYPE_RTP)
    {
        // Process SDP only for RTP calls
        return S_OK;
    }

    ASSERT(m_pSipCall->GetCallType() == SIP_CALL_TYPE_RTP);
    RTP_CALL *pRtpCall = static_cast<RTP_CALL *> (m_pSipCall);
    
    hr = pSipMsg->GetSDPBody(&MsgBody, &MsgBodyLen);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - GetSDPBody failed %x",
             __fxName, hr));
        return hr;
    }

    if (MsgBodyLen != 0)
    {
        m_InviteHasSDP = TRUE;
        hr = pRtpCall->ValidateSDPBlob(MsgBody, MsgBodyLen,
                                       m_IsFirstInvite,
                                       m_IsFirstInvite,
                                       &m_pMediaSession);
        return hr;
    }
    else
    {
        m_InviteHasSDP = FALSE;
    }

    return S_OK;
}


HRESULT
INCOMING_INVITE_TRANSACTION::SetSDPSession()
{
    HRESULT hr = S_OK;

    ENTER_FUNCTION("INCOMING_INVITE_TRANSACTION::SetSDPSession");
    
    if (m_pSipCall->GetCallType() != SIP_CALL_TYPE_RTP)
    {
        // Process SDP only for RTP calls
        return S_OK;
    }

    ASSERT(m_pSipCall->GetCallType() == SIP_CALL_TYPE_RTP);
    RTP_CALL *pRtpCall = static_cast<RTP_CALL *> (m_pSipCall);
    
    IRTCMediaManage *pMediaManager = pRtpCall->GetMediaManager();
    ASSERT(pMediaManager != NULL);
    
    if (m_InviteHasSDP)
    {
        // Message has SDP - process it.
        ASSERT(m_pMediaSession != NULL);
        
        pRtpCall->SetNeedToReinitializeMediaManager(TRUE);
        
        LOG((RTC_TRACE, "%s before SetSDPSession ", __fxName));
        
        hr = pMediaManager->SetSDPSession(m_pMediaSession);

        LOG((RTC_TRACE, "%s after SetSDPSession ", __fxName));

        m_pMediaSession->Release();
        m_pMediaSession = NULL;

        if (hr != S_OK && hr != RTC_E_SIP_NO_STREAM)
        {
            LOG((RTC_ERROR, "%s SetSDPSession failed %x",
                 __fxName, hr));
        
            return hr;
        }
        else if (m_IsFirstInvite && hr == RTC_E_SIP_NO_STREAM)
        {
            LOG((RTC_ERROR,
                 "%s SetSDPSession returned RTC_E_SIP_NO_STREAM for 1st INVITE",
                 __fxName, hr));
        
            return hr;
        }
        
        // for reINVITEs RTC_E_SIP_NO_STREAM is okay
    }
    else
    {
        if (m_IsFirstInvite)
        {
            hr = pRtpCall->CreateStreamsInPreference();
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s CreateStreamsInPreference failed %x",
                     __fxName, hr));
                return hr;
            }
        }

        // If not first INVITE we only send the currently active streams.
    }

    return S_OK;
}


// 
HRESULT
INCOMING_INVITE_TRANSACTION::ProcessInvite(
    IN SIP_MESSAGE  *pSipMsg,
    IN ASYNC_SOCKET *pResponseSocket
    )
{
    HRESULT hr;
    DWORD   Error;

    ENTER_FUNCTION("INCOMING_INVITE_TRANSACTION::ProcessInvite");
    LOG((RTC_TRACE, "entering %s", __fxName));
    
    switch (m_State)
    {
    case INCOMING_TRANS_INIT:

        // Copy the SDP. Process the SDP only after
        // accept is called.
        m_State = INCOMING_TRANS_REQUEST_RCVD;

        if (m_pSipCall->IsCallDisconnected())
        {
            LOG((RTC_WARN,
                 "%s Call is Disconnected "
                 "Cannot handle another incoming invite sending 481",
                 __fxName));
            return Reject(481, SIP_STATUS_TEXT(481),
                          SIP_STATUS_TEXT_SIZE(481));
        }
        
        hr = ValidateAndStoreSDPInInvite(pSipMsg);
        if (hr != S_OK)
        {
            // Reject the transaction XXX
            HRESULT hrLocal;
            hrLocal = Reject(488, SIP_STATUS_TEXT(488),
                             SIP_STATUS_TEXT_SIZE(488));
            if (hrLocal != S_OK)
            {
                LOG((RTC_ERROR, "%s Reject failed %x", __fxName, hrLocal));
            }
            return hr;
        }
        
        LOG((RTC_TRACE, "%s sending 100", __fxName));
        hr = SendProvisionalResponse(100,
                                     SIP_STATUS_TEXT(100),
                                     SIP_STATUS_TEXT_SIZE(100));
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s SendProvisionalResponse failed %x",
                 __fxName, hr));
            OnTransactionDone();
            return hr;
        }
        
        // If we already have an INVITE transaction
        // then we should create the transaction but
        // we should send an error response with a Retry-After.
        if (m_pSipCall->GetIncomingInviteTransaction() != NULL)
        {
            // Send error response.
            LOG((RTC_WARN,
                 "%s Currently processing incoming INVITE "
                 "Cannot handle another incoming invite sending 400",
                 __fxName));
            return Reject(400, SIP_STATUS_TEXT(400),
                          SIP_STATUS_TEXT_SIZE(400));
        }
        else if (m_pSipCall->GetOutgoingInviteTransaction() != NULL)
        {
            // Send error response.
            LOG((RTC_WARN,
                 "%s Currently processing outgoing INVITE "
                 "Cannot handle incoming invite sending 500",
                 __fxName));
            return Reject(500, SIP_STATUS_TEXT(500),
                          SIP_STATUS_TEXT_SIZE(500));
        }

        m_pSipCall->SetIncomingInviteTransaction(this);
        
        if (!m_IsFirstInvite)
        {
            return Accept();
        }
        else
        {
            // Need to return 400 error if there was a problem in processing
            // the headers.
            hr = ProcessRecordRouteContactAndFromHeadersInRequest(pSipMsg);
            if (hr != S_OK)
            {
                HRESULT hrLocal;
                LOG((RTC_TRACE,
                    "ProcessRecordRouteContactAndFromHeadersInRequest failed, sending 400"));
                hrLocal = Reject(400, SIP_STATUS_TEXT(400),
                                 SIP_STATUS_TEXT_SIZE(400));
                if (hrLocal != S_OK)
                {
                    LOG((RTC_ERROR, "%s Reject(400) failed %x",
                         __fxName, hrLocal));
                }
                return hr;
            }
            return hr;
        }
        
        // Wait for Accept() to be called if this is the first INVITE
        
        break;
        
    case INCOMING_TRANS_REQUEST_RCVD:
        // Send the buffer.
        LOG((RTC_TRACE, "%s retransmitting provisional response", __fxName));
        Error = m_pResponseSocket->Send(m_pProvResponseBuffer);
        if (Error != NO_ERROR)
        {
            LOG((RTC_ERROR,
                 "%s sending provisional response failed %x - deleting transaction",
                 __fxName, Error));
            DeleteTransactionAndTerminateCallIfFirstInvite(HRESULT_FROM_WIN32(Error));
            return HRESULT_FROM_WIN32(Error);
        }
        // No timer is needed in this state.
        // Wait for Accept() to be called.
        break;

    case INCOMING_TRANS_FINAL_RESPONSE_SENT:
        // Retransmit the response
        LOG((RTC_TRACE, "%s retransmitting final response", __fxName));
        hr = RetransmitResponse();
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s  sending final response failed %x",
                 __fxName, hr));
            DeleteTransactionAndTerminateCallIfFirstInvite(hr);
            return hr;
        }
        break;
        
    case INCOMING_TRANS_ACK_RCVD:
        // It is an error to receive an INVITE after the ACK.
        // Just drop it.
        LOG((RTC_WARN, "%s received INVITE in ACK_RCVD state", __fxName));
        break;

    default:
        ASSERT(FALSE);
        return E_FAIL;
    }

    return S_OK;
}


HRESULT
INCOMING_INVITE_TRANSACTION::ProcessSDPInAck(
    IN SIP_MESSAGE  *pSipMsg
    )
{
    PSTR    MsgBody;
    ULONG   MsgBodyLen;
    PSTR    szSDPBlob;
    HRESULT hr;

    ENTER_FUNCTION("ProcessSDPInAck");

    if (m_pSipCall->GetCallType() != SIP_CALL_TYPE_RTP)
    {
        // Process SDP only for RTP calls
        return S_OK;
    }
    
    if (m_pSipCall->IsCallDisconnected())
    {
        // Don't process SDP if the call is already disconnected.
        return S_OK;
    }
        
    ASSERT(m_pSipCall->GetCallType() == SIP_CALL_TYPE_RTP);
    RTP_CALL *pRtpCall = static_cast<RTP_CALL *> (m_pSipCall);
    
    IRTCMediaManage *pMediaManager = pRtpCall->GetMediaManager();
    ASSERT(pMediaManager != NULL);
    
    if (m_InviteHasSDP)
    {
        // Ignore any SDP even if it is present in the ACK.
        return S_OK;
    }
        
    // ACK should contain SDP
    hr = pSipMsg->GetSDPBody(&MsgBody, &MsgBodyLen);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s GetSDPBody failed %x", __fxName, hr));
        return hr;
    }

    if (MsgBodyLen == 0)
    {
        LOG((RTC_ERROR, "%s No SDP in both INVITE and ACK", __fxName));
        return RTC_E_SDP_NOT_PRESENT;
    }
    
    hr = pRtpCall->SetSDPBlob(MsgBody, MsgBodyLen,
                              m_IsFirstInvite);
        
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s SetSDPBlob failed %x", __fxName, hr));
        return hr;
    }

    return S_OK;
}


// We don't have to send any response to the ACK.
HRESULT
INCOMING_INVITE_TRANSACTION::ProcessAck(
    IN SIP_MESSAGE  *pSipMsg
    )
{
    HRESULT     hr;

    ENTER_FUNCTION("INCOMING_INVITE_TRANSACTION::ProcessAck()");

    LOG((RTC_TRACE, "%s - Enter", __fxName));
    
    if (m_State == INCOMING_TRANS_FINAL_RESPONSE_SENT)
    {
        // Stop the response retransmission timer
        KillTimer();
        m_State = INCOMING_TRANS_ACK_RCVD;

        // Always make sure Notify is the last thing you do.

        hr = ProcessSDPInAck(pSipMsg);
        if (hr != S_OK)
        {
            DeleteTransactionAndTerminateCallIfFirstInvite(hr);
        }
        else if (m_IsFirstInvite &&
                 m_pSipCall->GetCallState() == SIP_CALL_STATE_CONNECTING)
        {
            SIP_CALL *pSipCall = m_pSipCall;

            pSipCall->AddRef();
            
            // We are done with this transaction.
            OnTransactionDone();
            
            pSipCall->NotifyCallStateChange(SIP_CALL_STATE_CONNECTED);

            pSipCall->Release();
        }
        else
        {
            // We are done with this transaction
            OnTransactionDone();
        }
    }
    else
    {
        // Just drop the ACK.
        LOG((RTC_WARN, "Dropping ACK received in state: %d",
             m_State)); 
    }

    return S_OK;
}


VOID
INCOMING_INVITE_TRANSACTION::DeleteTransactionAndTerminateCallIfFirstInvite(
    IN HRESULT TerminateStatusCode
    )
{
    SIP_CALL   *pSipCall;
    BOOL        IsFirstInvite;

    ENTER_FUNCTION("INCOMING_INVITE_TRANSACTION::DeleteTransactionAndTerminateCallIfFirstInvite");
    LOG((RTC_TRACE, "%s - enter", __fxName));

    pSipCall = m_pSipCall;
    // Deleting the transaction could result in the
    // call being deleted. So, we AddRef() it to keep it alive.
    pSipCall->AddRef();
    
    IsFirstInvite = m_IsFirstInvite;
    
    // Delete the transaction before you call
    // InitiateCallTerminationOnError as that call will notify the UI
    // and could get stuck till the dialog box returns.
    OnTransactionDone();
    
    if (IsFirstInvite)
    {
        // Terminate the call
        pSipCall->InitiateCallTerminationOnError(TerminateStatusCode);
    }
    pSipCall->Release();
}


// virtual
VOID
INCOMING_INVITE_TRANSACTION::TerminateTransactionOnError(
    IN HRESULT      hr
    )
{
    DeleteTransactionAndTerminateCallIfFirstInvite(hr);
}


HRESULT
INCOMING_INVITE_TRANSACTION::ProcessRequest(
    IN SIP_MESSAGE  *pSipMsg,
    IN ASYNC_SOCKET *pResponseSocket
    )
{
    HRESULT hr;
    ASSERT(pSipMsg->MsgType == SIP_MESSAGE_TYPE_REQUEST);

    // Process INVITE
    if (pSipMsg->Request.MethodId == SIP_METHOD_INVITE)
    {
        return ProcessInvite(pSipMsg, pResponseSocket);
    }
    // Process ACK
    else if (pSipMsg->Request.MethodId == SIP_METHOD_ACK)
    {
        // We don't send any response to an ACK and so we
        // don't have to set the response socket / Via
        return ProcessAck(pSipMsg);
    }
    else
    {
        return E_FAIL;
    }
}


// If we are currently resolving, then we need to do
// something like the following even for non-INVITE transactions.

// We don't have to notify any failures to Core/UI.
// The function calling this function is responsible for
// cleaning up the call state and notifying core/UI
// if the call is being terminated.
HRESULT
INCOMING_INVITE_TRANSACTION::TerminateTransactionOnByeOrCancel(
    OUT BOOL *pCallDisconnected
    )
{
    HRESULT hr;

    ENTER_FUNCTION("INCOMING_INVITE_TRANSACTION::TerminateTransactionOnByeOrCancel");
    LOG((RTC_TRACE, "%s - Enter", __fxName));

    *pCallDisconnected = FALSE;
    
    // If we have already sent the response, then we can not
    // terminate the transaction.
    if (m_State == INCOMING_TRANS_REQUEST_RCVD)
    {
        if (m_IsFirstInvite)
        {
            *pCallDisconnected = TRUE;
        }
        
        hr = CreateAndSendResponseMsg(
                 487, SIP_STATUS_TEXT(487),
                 SIP_STATUS_TEXT_SIZE(487),
                 NULL,    // No Method string
                 m_IsFirstInvite,   // Send contact header for 1st invite
                 NULL, 0,  // No Message Body
                 NULL, 0 // No content Type
                 );
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s CreateAndSendResponseMsg failed %x",
                 __fxName, hr));
            if (m_IsFirstInvite)
            {
                m_pSipCall->CleanupCallTypeSpecificState();
            }
            OnTransactionDone();
            return hr;
        }
        
        m_State = INCOMING_TRANS_FINAL_RESPONSE_SENT;
        LOG((RTC_TRACE, "%s : Sent 487 response", __fxName));
        
        // Start Timer for receiving ACK
        m_TimerValue = SIP_TIMER_RETRY_INTERVAL_T1;
        m_NumRetries = 1;
        hr = StartTimer(m_TimerValue);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s StartTimer failed %x",
                 __fxName, hr));
            if (m_IsFirstInvite)
            {
                m_pSipCall->CleanupCallTypeSpecificState();
            }
            OnTransactionDone();
            return hr;
        }
    }

    return S_OK;
}


// Allow for bigger timeout when packets have to cross firewalls
// or dialup links.
BOOL
INCOMING_INVITE_TRANSACTION::MaxRetransmitsDone()
{
    //m_TimerValue >= SIP_TIMER_RETRY_INTERVAL_T2 ||
    return (m_NumRetries >= 7);
}


VOID
INCOMING_INVITE_TRANSACTION::OnTimerExpire()
{
    HRESULT     hr = S_OK;

    ENTER_FUNCTION("INCOMING_INVITE_TRANSACTION::OnTimerExpire");
    
    switch (m_State)
    {
    case INCOMING_TRANS_FINAL_RESPONSE_SENT:
        // Retransmit the response
        if (MaxRetransmitsDone())
        {
            // Terminate the transaction/call
            LOG((RTC_ERROR,
                 "%s MaxRetransmits for response Done terminating %s",
                 __fxName, (m_IsFirstInvite) ? "Call" : "transaction"));
            
            hr = RTC_E_SIP_TIMEOUT;   // Timeout
            goto error;
        }
        else
        {
            LOG((RTC_TRACE, "%s retransmitting response m_NumRetries : %d",
                 __fxName, m_NumRetries));
            hr = RetransmitResponse();
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s resending response failed %x",
                     __fxName, hr));
                goto error;
            }
            
            m_TimerValue *= 2;
            hr = StartTimer(m_TimerValue);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s StartTimer failed %x",
                     __fxName, hr));                
                goto error;
            }
        }
        
        break;

        // No timers in these states
    case INCOMING_TRANS_INIT:
    case INCOMING_TRANS_ACK_RCVD:
    case INCOMING_TRANS_REQUEST_RCVD:
    default:
        LOG((RTC_ERROR, "%s timer expired in invalid state %d",
             __fxName, m_State));
        ASSERT(FALSE);
        break;
    }

    return;

 error:

    DeleteTransactionAndTerminateCallIfFirstInvite(hr);
}


///////////////////////////////////////////////////////////////////////////////
// Incoming non-INVITE
///////////////////////////////////////////////////////////////////////////////


INCOMING_BYE_CANCEL_TRANSACTION::INCOMING_BYE_CANCEL_TRANSACTION(
    IN SIP_CALL        *pSipCall,
    IN SIP_METHOD_ENUM  MethodId,
    IN ULONG            CSeq
    ) :
    INCOMING_TRANSACTION(pSipCall, MethodId, CSeq)
{
    m_pSipCall            = pSipCall;
}


// This must be a retransmission. Just retransmit the response.
// A new request is handled in CreateIncoming***Transaction()
HRESULT
INCOMING_BYE_CANCEL_TRANSACTION::ProcessRequest(
    IN SIP_MESSAGE  *pSipMsg,
    IN ASYNC_SOCKET *pResponseSocket
    )
{
    HRESULT hr;
    ASSERT(pSipMsg->MsgType == SIP_MESSAGE_TYPE_REQUEST);

    ENTER_FUNCTION("INCOMING_BYE_CANCEL_TRANSACTION::ProcessRequest");
    LOG((RTC_TRACE, "%s - Enter", __fxName));

    switch (m_State)
    {
    case INCOMING_TRANS_INIT:
        LOG((RTC_TRACE, "%s sending 200", __fxName));
        hr = CreateAndSendResponseMsg(
                 200,
                 SIP_STATUS_TEXT(200),
                 SIP_STATUS_TEXT_SIZE(200),
                 NULL,    // No Method string
                 FALSE,   // No Contact header  
                 NULL, 0,  // No Message Body
                 NULL, 0 // No content Type
                 );
        if (hr != S_OK)
        {
            LOG((RTC_ERROR,
                 "%s  CreateAndSendResponseMsg failed %x - deleting transaction",
                 __fxName, hr));
            OnTransactionDone();
            return hr;
        }
        
        m_State = INCOMING_TRANS_FINAL_RESPONSE_SENT;

        // This timer will just ensure that we maintain state to
        // deal with retransmits of requests
        hr = StartTimer(SIP_TIMER_MAX_INTERVAL);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s StartTimer failed %x - deleting transaction",
                 __fxName, hr));
            OnTransactionDone();
            return hr;
        }
        break;
        
    case INCOMING_TRANS_FINAL_RESPONSE_SENT:
        // Retransmit the response
        LOG((RTC_TRACE, "%s retransmitting final response", __fxName));
        hr = RetransmitResponse();
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s  resending final response failed %x",
                 __fxName, hr));
            OnTransactionDone();
            return hr;
        }
        break;
        
    case INCOMING_TRANS_REQUEST_RCVD:
    case INCOMING_TRANS_ACK_RCVD:
    default:
        // We should never be in these states
        LOG((RTC_TRACE, "%s Invalid state %d", __fxName, m_State));
        ASSERT(FALSE);
        return E_FAIL;
    }

    return S_OK;
}


HRESULT
INCOMING_BYE_CANCEL_TRANSACTION::SendResponse(
    IN ULONG StatusCode,
    IN PSTR  ReasonPhrase,
    IN ULONG ReasonPhraseLen
    )
{
    HRESULT hr;
    ASSERT(m_State != INCOMING_TRANS_FINAL_RESPONSE_SENT);

    ENTER_FUNCTION("INCOMING_BYE_CANCEL_TRANSACTION::SendResponse");

    hr = CreateAndSendResponseMsg(
             StatusCode, ReasonPhrase, ReasonPhraseLen,
             NULL,    // No method string
             FALSE,   // No Contact header  
             NULL, 0,  // No Message Body
             NULL, 0 // No content Type
             );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR,
             "%s CreateAndSendResponseMsg failed %x - deleting transaction",
             __fxName, hr));
        OnTransactionDone();
        return hr;
    }

    m_State = INCOMING_TRANS_FINAL_RESPONSE_SENT;

    return S_OK;
}


HRESULT
INCOMING_BYE_CANCEL_TRANSACTION::RetransmitResponse()
{
    DWORD Error;

    ENTER_FUNCTION("INCOMING_BYE_CANCEL_TRANSACTION::RetransmitResponse");
    // Send the buffer.
    Error = m_pResponseSocket->Send(m_pResponseBuffer);
    if (Error != NO_ERROR)
    {
        LOG((RTC_ERROR, "%s Send failed %x", __fxName, Error));
        return HRESULT_FROM_WIN32(Error);
    }

    return S_OK;
}


VOID
INCOMING_BYE_CANCEL_TRANSACTION::OnTimerExpire()
{
    HRESULT hr;

    ENTER_FUNCTION("INCOMING_BYE_CANCEL_TRANSACTION::OnTimerExpire");
    
    switch (m_State)
    {
    case INCOMING_TRANS_FINAL_RESPONSE_SENT:
        // Transaction done - delete the transaction
        // The timer in this state is just to keep the transaction
        // alive in order to retransmit the response when we receive a
        // retransmit of the request.
        LOG((RTC_TRACE,
             "%s deleting transaction after timeout for request retransmits",
             __fxName));
        OnTransactionDone();

        break;
        
        // No timers in these states
    case INCOMING_TRANS_INIT:
    case INCOMING_TRANS_REQUEST_RCVD:
    case INCOMING_TRANS_ACK_RCVD:
    default:
        ASSERT(FALSE);
        break;
    }

    return;
}


HRESULT
INCOMING_BYE_CANCEL_TRANSACTION::TerminateTransactionOnByeOrCancel(
    OUT BOOL *pCallDisconnected
    )
{
    // Do nothing.
    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Outgoing INVITE
///////////////////////////////////////////////////////////////////////////////


OUTGOING_INVITE_TRANSACTION::OUTGOING_INVITE_TRANSACTION(
    IN SIP_CALL        *pSipCall,
    IN SIP_METHOD_ENUM  MethodId,
    IN ULONG            CSeq,
    IN BOOL             AuthHeaderSent,
    IN BOOL             IsFirstInvite,
    IN BOOL             fNeedToNotifyCore,
    IN LONG             Cookie
    ) :
    OUTGOING_TRANSACTION(pSipCall, MethodId, CSeq, AuthHeaderSent)
{
    m_pSipCall          = pSipCall;
    m_WaitingToSendAck  = FALSE;
    m_pAckBuffer        = NULL;
    m_AckToHeader       = NULL;
    m_AckToHeaderLen    = 0;
    m_IsFirstInvite     = IsFirstInvite;
    m_fNeedToNotifyCore = fNeedToNotifyCore;
    m_Cookie            = Cookie;
}


OUTGOING_INVITE_TRANSACTION::~OUTGOING_INVITE_TRANSACTION()
{
    if (m_pAckBuffer != NULL)
    {
        m_pAckBuffer->Release();
        m_pAckBuffer = NULL;
    }

    if (m_AckToHeader != NULL)
    {
        free(m_AckToHeader);
    }
    LOG((RTC_TRACE, "~OUTGOING_INVITE_TRANSACTION() done"));
}


// If MsgBody is currenlty NULL, then we need to get the msg body.
// Note that for RTP calls, we should create the msg body (SDP)
// only after the connection to the destination is complete.

// virtual
VOID
OUTGOING_INVITE_TRANSACTION::OnRequestSocketConnectComplete(
    IN DWORD        ErrorCode
    )
{
    HRESULT hr;
    
    ENTER_FUNCTION("OUTGOING_INVITE_TRANSACTION::OnRequestSocketConnectComplete");

    // This means we are not waiting for the connect complete notification.
    if (!((m_State == OUTGOING_TRANS_INIT && m_WaitingToSendRequest) ||
          (m_State == OUTGOING_TRANS_FINAL_RESPONSE_RCVD &&
           m_WaitingToSendAck)))
    {
        return;
    }
    
    if (ErrorCode != NO_ERROR)
    {
        LOG((RTC_ERROR, "%s - connection failed error %x",
             __fxName, ErrorCode));
        TerminateTransactionOnError(HRESULT_FROM_WIN32(ErrorCode));
        return;
    }
    
    if (m_State == OUTGOING_TRANS_INIT && m_WaitingToSendRequest)
    {
        // Send INVITE
        
        if (m_szMsgBody == NULL)
        {
            hr = GetAndStoreMsgBodyForRequest();
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s GetAndStoreMsgBodyForRequest failed %x",
                     __fxName, hr));
                TerminateTransactionOnError(hr);
                return;
            }
        }
        
        hr = CreateAndSendRequestMsg(
                 m_TimerValue,
                 m_AdditionalHeaderArray,
                 m_AdditionalHeaderCount,
                 m_szMsgBody, m_MsgBodyLen,
                 SIP_CONTENT_TYPE_SDP_TEXT, //Content Type
                 sizeof(SIP_CONTENT_TYPE_SDP_TEXT)-1
                 );

        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s CreateAndSendRequestMsg failed %x",
                 __fxName, hr));
            TerminateTransactionOnError( hr);
            return;
        }
    }
    else if (m_State == OUTGOING_TRANS_FINAL_RESPONSE_RCVD &&
             m_WaitingToSendAck)
    {
        // Send ACK
        hr = CreateAndSendACK(m_AckToHeader, m_AckToHeaderLen);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s Send request msg failed %x",
                 __fxName, hr));
            TerminateTransactionOnError(hr);
            return;
        }
    }
}


HRESULT
OUTGOING_INVITE_TRANSACTION::GetAndStoreMsgBodyForRequest()
{
    HRESULT hr;
    ENTER_FUNCTION("OUTGOING_INVITE_TRANSACTION::GetAndStoreMsgBodyForRequest");
    
    hr = m_pSipCall->GetAndStoreMsgBodyForInvite(
             m_IsFirstInvite,
             &m_szMsgBody, &m_MsgBodyLen);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s GetAndStoreMsgBodyForInvite failed %x",
             __fxName, hr));
        return hr;
    }

    return S_OK;
}


VOID
OUTGOING_INVITE_TRANSACTION::DeleteTransactionAndTerminateCallIfFirstInvite(
    IN HRESULT TerminateStatusCode
    )
{
    SIP_CALL   *pSipCall;
    BOOL        IsFirstInvite;
    LONG        Cookie;
    BOOL        fNeedToNotifyCore = m_fNeedToNotifyCore;

    ENTER_FUNCTION("OUTGOING_INVITE_TRANSACTION::DeleteTransactionAndTerminateCallIfFirstInvite");
    LOG((RTC_TRACE, "%s - enter", __fxName));

    pSipCall = m_pSipCall;
    // Deleting the transaction could result in the
    // call being deleted. So, we AddRef() it to keep it alive.
    pSipCall->AddRef();
    
    IsFirstInvite = m_IsFirstInvite;
    Cookie        = m_Cookie;
    fNeedToNotifyCore = m_fNeedToNotifyCore;
    
    // Delete the transaction before you call
    // InitiateCallTerminationOnError/NotifyStartOrStopStreamCompletion
    // as that call will notify the UI and could get stuck till the
    // dialog box returns. On an error we should mark the transaction
    // as done and delete it as it could be in some invalid state.
    
    OnTransactionDone();
    pSipCall->SetOutgoingInviteTransaction(NULL);
    if (IsFirstInvite)
    {
        // Terminate the call
        pSipCall->InitiateCallTerminationOnError(TerminateStatusCode);
    }
    else
    {
        pSipCall->ProcessPendingInvites();
        
        if (pSipCall->GetCallType() == SIP_CALL_TYPE_RTP &&
            fNeedToNotifyCore)
        {
            RTP_CALL *pRtpCall = static_cast<RTP_CALL *> (pSipCall);
            pRtpCall->NotifyStartOrStopStreamCompletion(
                Cookie, TerminateStatusCode);
        }
    }
    pSipCall->Release();
}


// virtual
VOID
OUTGOING_INVITE_TRANSACTION::TerminateTransactionOnError(
    IN HRESULT      hr
    )
{
    DeleteTransactionAndTerminateCallIfFirstInvite(hr);
}


HRESULT
OUTGOING_INVITE_TRANSACTION::ProcessProvisionalResponse(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT hr;

    ENTER_FUNCTION("OUTGOING_INVITE_TRANSACTION::ProcessProvisionalResponse");

    LOG((RTC_TRACE, "%s : %d", __fxName, pSipMsg->GetStatusCode()));
    
    if (m_State != OUTGOING_TRANS_FINAL_RESPONSE_RCVD &&
        m_State != OUTGOING_TRANS_ACK_SENT)
    {
        m_State = OUTGOING_TRANS_PROVISIONAL_RESPONSE_RCVD;

        // We have to deal with 183 responses here.
        // Cancel existing timer and Start Timer
        KillTimer();
        hr = StartTimer(SIP_TIMER_INTERVAL_AFTER_INVITE_PROV_RESPONSE_RCVD);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s  StartTimer failed %x", __fxName, hr));
            DeleteTransactionAndTerminateCallIfFirstInvite(hr);
            return hr;
        }

        if (!m_pSipCall->IsCallDisconnected())
        {
            hr = ProcessSDPInResponse(pSipMsg, FALSE);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s - ProcessSDPInResponse failed %x",
                     __fxName, hr));
                DeleteTransactionAndTerminateCallIfFirstInvite(hr);
                return hr;
            }
            
            if (m_IsFirstInvite)
            {
                PSTR  ReasonPhrase;
                ULONG ReasonPhraseLen;
                
                pSipMsg->GetReasonPhrase(&ReasonPhrase, &ReasonPhraseLen);
                m_pSipCall->NotifyCallStateChange(
                    SIP_CALL_STATE_ALERTING,
                    HRESULT_FROM_SIP_SUCCESS_STATUS_CODE(pSipMsg->GetStatusCode()),
                    ReasonPhrase,
                    ReasonPhraseLen);
            }
        }
    }

    // Ignore the Provisional response if a final response
    // has already been received.

    return S_OK; 
}


HRESULT
OUTGOING_INVITE_TRANSACTION::CreateAndSendACK(
    IN  PSTR  ToHeader,
    IN  ULONG ToHeaderLen
    )
{
    HRESULT hr;

    ENTER_FUNCTION("OUTGOING_INVITE_TRANSACTION::CreateAndSendACK");
    LOG((RTC_TRACE, "%s - enter", __fxName));
    
    hr = m_pSipCall->CreateRequestMsg(SIP_METHOD_ACK,
                                      m_CSeq,          // ACK and INVITE have same CSeq
                                      ToHeader,
                                      ToHeaderLen,
                                      NULL, 0,         // No Additional Headers 
                                      NULL, 0,         // No Message Body
                                      NULL, 0,         //ContentType
                                      &m_pAckBuffer
                                      );         
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s  CreateRequestMsg failed %x",
             __fxName, hr)); 
        return hr;
    }

    hr = m_pSipCall->SendRequestMsg(m_pAckBuffer);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s  SendRequestMsg failed %x",
             __fxName, hr)); 
        return hr;
    }

    m_State = OUTGOING_TRANS_ACK_SENT;

    // This timer will just ensure that we maintain state to
    // deal with retransmits of final responses.
    hr = StartTimer(SIP_TIMER_MAX_INTERVAL);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s  StartTimer failed %x",
             __fxName, hr));
        return hr;
    }
        
    return S_OK;
}


HRESULT
OUTGOING_INVITE_TRANSACTION::ProcessSDPInResponse(
    IN SIP_MESSAGE  *pSipMsg,
    IN BOOL          fIsFinalResponse
    )
{
    PSTR    MsgBody;
    ULONG   MsgBodyLen;
    HRESULT hr;

    ENTER_FUNCTION("OUTGOING_INVITE_TRANSACTION::ProcessSDPInResponse");

    if (m_pSipCall->GetCallType() == SIP_CALL_TYPE_RTP)
    {
        if (m_pSipCall->IsCallDisconnected())
        {
            // do nothing
            return S_OK;
        }
        
        RTP_CALL *pRtpCall = static_cast<RTP_CALL *> (m_pSipCall);
    
        IRTCMediaManage *pMediaManager = pRtpCall->GetMediaManager();
        ASSERT(pMediaManager != NULL);
    
        // 200 should contain SDP
        hr = pSipMsg->GetSDPBody(&MsgBody, &MsgBodyLen);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s  GetSDPBody() failed %x",
                 __fxName, hr));
            return hr;
        }

        if (MsgBodyLen == 0)
        {
            if (fIsFinalResponse)
            {
                LOG((RTC_ERROR, "%s No SDP in 200 for INVITE", __fxName));
                return RTC_E_SDP_NOT_PRESENT;
            }
            else
            {
                return S_OK;
            }
        }
    
        hr = pRtpCall->SetSDPBlob(MsgBody, MsgBodyLen,
                                  m_IsFirstInvite);
        
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s SetSDPBlob failed %x - IsFinalResponse: %d",
                 __fxName, hr, fIsFinalResponse));

            if (fIsFinalResponse)
            {
                return hr;
            }
            else
            {
                // We wait for the SDP blob in the final response
                return S_OK;
            }
        }
    }
    
    return S_OK;
}


HRESULT
OUTGOING_INVITE_TRANSACTION::Process200(
    IN SIP_MESSAGE *pSipMsg
    )
{
    PSTR        SDPBlob;
    HRESULT     hr;

    ENTER_FUNCTION("OUTGOING_INVITE_TRANSACTION::Process200");
    
    LOG((RTC_TRACE, "%s - Enter", __fxName));

    // The transaction completed successfully.
    // We need to deal with the SDP description
    // here.
    if (m_pSipCall->GetCallType() == SIP_CALL_TYPE_RTP)
    {
        hr = ProcessSDPInResponse(pSipMsg, TRUE);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s ProcessSDPInResponse failed %x",
                 __fxName, hr));
            m_pSipCall->SetOutgoingInviteTransaction(NULL);
            
            if (m_IsFirstInvite)
            {
                // Transaction is deleted after handling response
                // retransmits.
                m_pSipCall->InitiateCallTerminationOnError(hr);
                return hr;
            }
            else
            {
                // Transaction is deleted after handling response
                // retransmits.

                TransactionAddRef();

                // ProcessPendingInvites() could notify core.
                m_pSipCall->ProcessPendingInvites();
                
                if (m_pSipCall->GetCallType() == SIP_CALL_TYPE_RTP)
                {
                    NotifyStartOrStopStreamCompletion(hr);
                }

                TransactionRelease();
                return hr;
            }
        }
    }
    else if (m_pSipCall->GetCallType() == SIP_CALL_TYPE_PINT)
    {
        if (m_IsFirstInvite)
        {
            // Don't care about the result of this operation.
            (static_cast<PINT_CALL*>(m_pSipCall)) -> CreateOutgoingSubscribeTransaction(
                FALSE, NULL, 0
                );
        }
    }

    TransactionAddRef();
    
    m_pSipCall->SetOutgoingInviteTransaction(NULL);
    // ProcessPendingInvites() could notify core.
    m_pSipCall->ProcessPendingInvites();
                
    // Notification should be done last.
    if (m_IsFirstInvite)
    {
        m_pSipCall->NotifyCallStateChange(SIP_CALL_STATE_CONNECTED);
    }
    else
    {
        if (m_pSipCall->GetCallType() == SIP_CALL_TYPE_RTP)
        {
            NotifyStartOrStopStreamCompletion(S_OK);
        }
    }

    TransactionRelease();

    return S_OK;
}


HRESULT
OUTGOING_INVITE_TRANSACTION::ProcessRedirectResponse(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT hr;
    
    ENTER_FUNCTION("OUTGOING_INVITE_TRANSACTION::ProcessRedirectResponse");

    // 380 is also a failure from our point of view.
    // We don't handle redirects for reINVITEs.
    // We don't support redirect from a TLS session.
    if (pSipMsg->GetStatusCode() == 380 ||
        !m_IsFirstInvite ||
        m_pSipMsgProc->GetTransport() == SIP_TRANSPORT_SSL)        
    {
        return ProcessFailureResponse(pSipMsg);
    }

    // The redirection must at least reinit the 
    // streaming in order for the next call to succeed.
    m_pSipCall->CleanupCallTypeSpecificState();
    m_pSipCall->SetOutgoingInviteTransaction(NULL);
    hr = m_pSipCall->ProcessRedirect(pSipMsg);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s  ProcessRedirect failed %x",
             __fxName, hr));
        if (m_IsFirstInvite)
        {
            m_pSipCall->InitiateCallTerminationOnError(hr);
        }
        return hr;
    }

    return S_OK;
}


HRESULT
OUTGOING_INVITE_TRANSACTION::ProcessAuthRequiredResponse(
    IN SIP_MESSAGE *pSipMsg,
    OUT BOOL           &fDelete
    )
{
    HRESULT                     hr = S_OK;
    SIP_HEADER_ARRAY_ELEMENT    SipHdrElement;
    REGISTER_CONTEXT           *pRegisterContext;
    SECURITY_CHALLENGE          SecurityChallenge;

    ENTER_FUNCTION("OUTGOING_INVITE_TRANSACTION::ProcessAuthRequiredResponse");

    // We need to addref the transaction as we could show credentials UI.
    TransactionAddRef();
    
    hr = ProcessAuthRequired(pSipMsg,
                             TRUE,          // Show Credentials UI if necessary
                             &SipHdrElement,
                             &SecurityChallenge);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - ProcessAuthRequired failed %x",
             __fxName, hr));
        ProcessFailureResponse(pSipMsg);
        goto done;
    }
    m_pSipCall->SetOutgoingInviteTransaction(NULL);
    hr = m_pSipCall->CreateOutgoingInviteTransaction(
             TRUE,
             m_IsFirstInvite,
             &SipHdrElement, 1,
             m_szMsgBody, m_MsgBodyLen,
             m_fNeedToNotifyCore, m_Cookie);

    free(SipHdrElement.HeaderValue);
    
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - CreateOutgoingInviteTransaction failed %x",
             __fxName, hr));
        if (m_IsFirstInvite)
        {
            m_pSipCall->InitiateCallTerminationOnError(hr);
        }
        goto done;
    }

 done:
    
    TransactionRelease();
    return hr;
}


HRESULT
OUTGOING_INVITE_TRANSACTION::ProcessFailureResponse(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT hr;
    PSTR    ReasonPhrase;
    ULONG   ReasonPhraseLen;

    ENTER_FUNCTION("OUTGOING_INVITE_TRANSACTION::ProcessFailureResponse");
    
    LOG((RTC_TRACE, "%s: Processing non-200 StatusCode: %d",
         __fxName, pSipMsg->GetStatusCode()));
    
    // If this is PINT_CALL then all the telephone parties in
    // state SIP_PARTY_STATE_CONNECT_INITIATED should be
    // transferred to SIP_PARTY_STATE_REJECTED -XXX-
            
    m_pSipCall->HandleInviteRejected( pSipMsg );

    pSipMsg->GetReasonPhrase(&ReasonPhrase, &ReasonPhraseLen);            
    m_pSipCall->SetOutgoingInviteTransaction(NULL);
    if (m_IsFirstInvite)
    {
        hr = m_pSipCall->CleanupCallTypeSpecificState();
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s CleanupCallTypeSpecificState failed %x",
                 __fxName, hr));
        }                

        // Notify should be the last thing you do. The notification callback
        // could block till some dialog box is clicked and when it returns
        // the transaction and call could get deleted as well.
        
        m_pSipCall->NotifyCallStateChange(
            SIP_CALL_STATE_REJECTED,
            HRESULT_FROM_SIP_ERROR_STATUS_CODE(pSipMsg->GetStatusCode()),
            ReasonPhrase,
            ReasonPhraseLen);
        return S_OK;
    }
    else
    {
        TransactionAddRef();
        // ProcessPendingInvites() could notify core.
        m_pSipCall->ProcessPendingInvites();
        
        if (m_pSipCall->GetCallType() == SIP_CALL_TYPE_RTP)
        {
            NotifyStartOrStopStreamCompletion(
                HRESULT_FROM_SIP_ERROR_STATUS_CODE(pSipMsg->GetStatusCode()),
                ReasonPhrase,
                ReasonPhraseLen
                );
        }

        TransactionRelease();
    }

    return S_OK;
}


HRESULT
OUTGOING_INVITE_TRANSACTION::ProcessFinalResponse(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT hr;
    PSTR    ToHeader;
    ULONG   ToHeaderLen;
    PSTR    AckToHeader = NULL;
    ULONG   AckToHeaderLen = 0;
    BOOL    fTerminateCallAfterSendingAck = FALSE;
    HRESULT TerminateHr;
    BOOL    fDelete = TRUE;

    ENTER_FUNCTION("OUTGOING_INVITE_TRANSACTION::ProcessFinalResponse");

    LOG((RTC_TRACE, "%s - StatusCode: %d",
         __fxName, pSipMsg->GetStatusCode()));
    
    if (m_State != OUTGOING_TRANS_FINAL_RESPONSE_RCVD &&
        m_State != OUTGOING_TRANS_ACK_SENT)
    {
        // Cancel existing timer.
        KillTimer();

        m_State = OUTGOING_TRANS_FINAL_RESPONSE_RCVD;

        if (m_IsFirstInvite)
        {
            hr = pSipMsg->GetSingleHeader(SIP_HEADER_TO,
                                          &ToHeader, &ToHeaderLen);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s - To header not found", __fxName));
                fTerminateCallAfterSendingAck = TRUE;
                TerminateHr = hr;
                // Call is terminated after sending ACK.
                // Transaction is deleted after handling response retransmits.
            }

            if (IsSuccessfulResponse(pSipMsg))
            {
                hr = m_pSipCall->AddTagFromRequestOrResponseToRemote(
                                        ToHeader, ToHeaderLen );
                if (hr != S_OK)
                {
                    LOG((RTC_ERROR, "%s-AddTagFromResponseToRemote failed %x",
                         __fxName, hr));
                    fTerminateCallAfterSendingAck = TRUE;
                    TerminateHr = hr;
                    AckToHeader = ToHeader;
                    AckToHeaderLen = ToHeaderLen;
                    // Call is terminated after sending ACK.
                    // Transaction is deleted after handling response retransmits.
                }

                hr = m_pSipCall->ProcessRecordRouteAndContactHeadersInResponse(pSipMsg);
                if (hr != S_OK)
                {
                    LOG((RTC_WARN,
                         "%s - processing Record-Route/Contact in response failed %x",
                         __fxName, hr));
                }
            }
            else
            {
                AckToHeader = ToHeader;
                AckToHeaderLen = ToHeaderLen;
            }
        }

        // Send ACK
        // Note that we need to send the ACK as early as possible so as to
        // avoid any timeouts on the remote side.
        if (m_pSipCall->GetRequestSocketState() == REQUEST_SOCKET_CONNECTED)
        {
            // send the ack if the request socket is ready.
            hr = CreateAndSendACK(AckToHeader, AckToHeaderLen);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s  CreateAndSendACK() failed %x",
                     __fxName, hr));
                // m_pSipCall->InitiateCallTerminationOnError(hr);
                DeleteTransactionAndTerminateCallIfFirstInvite(hr);
                return hr;
            }
        }
        else
        {
            // Wait for connect complete to send the ACK.
            m_WaitingToSendAck = TRUE;
            hr = AllocString(AckToHeader, AckToHeaderLen,
                             &m_AckToHeader, &m_AckToHeaderLen);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s Storing AckToHeader failed %x",
                     __fxName, hr));
                // m_pSipCall->InitiateCallTerminationOnError(hr);
                DeleteTransactionAndTerminateCallIfFirstInvite(hr);
                return hr;
            }            
        }
        

        if (fTerminateCallAfterSendingAck)
        {
            m_pSipCall->InitiateCallTerminationOnError(TerminateHr);
            // Transaction is deleted after handling response
            // retransmits.
            return TerminateHr; //E_FAIL;
        }


        if (!m_pSipCall->IsCallDisconnected())
        {
            if (IsSuccessfulResponse(pSipMsg))
            {
                Process200(pSipMsg);
            }
            else if (IsRedirectResponse(pSipMsg))
            {
                ProcessRedirectResponse(pSipMsg);
            }
            else if (IsAuthRequiredResponse(pSipMsg))
            {
                ProcessAuthRequiredResponse( pSipMsg, fDelete );
            }
            else if (IsFailureResponse(pSipMsg))
            {
                ProcessFailureResponse(pSipMsg);
            }
        }
    }
    else
    {
        LOG((RTC_TRACE,
             "%s: received final response in FINAL_RESPONSE_RCVD state",
             __fxName));
        // Previously received a final response
        // This is a retransmit of the final response.
        // Send the cached ACK.
        if (m_pAckBuffer != NULL)
        {
            hr = m_pSipCall->SendRequestMsg(m_pAckBuffer);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s  resending ACK failed %x",
                     __fxName, hr));
                DeleteTransactionAndTerminateCallIfFirstInvite(hr);
                return hr;
            }
        }
        else
        {
            LOG((RTC_ERROR, "%s - m_pAckBuffer is NULL ", __fxName));
        }
    }

    return S_OK;
}


HRESULT
OUTGOING_INVITE_TRANSACTION::ProcessResponse(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT hr;

    ENTER_FUNCTION("OUTGOING_INVITE_TRANSACTION::ProcessResponse");
    
    ASSERT(pSipMsg->MsgType == SIP_MESSAGE_TYPE_RESPONSE);

    if (IsProvisionalResponse(pSipMsg))
    {
        return ProcessProvisionalResponse(pSipMsg);
    }
    else if (IsFinalResponse(pSipMsg))
    {
        return ProcessFinalResponse(pSipMsg);
    }
    else
    {
        ASSERT(FALSE);
        return E_FAIL;
    }
}


BOOL
OUTGOING_INVITE_TRANSACTION::MaxRetransmitsDone()
{
    // If the call has been disconnected, stop retransmitting INVITE
    // if we haven't received any 1xx response or if we have retransmitted
    // the INVITE 4 times. Otherwise retransmit 7 times.
    if (m_pSipCall->GetTransport() != SIP_TRANSPORT_UDP ||
        (m_pSipCall->IsCallDisconnected() &&
         m_State == OUTGOING_TRANS_REQUEST_SENT) ||
        (m_pSipCall->IsCallDisconnected() &&
         m_NumRetries >= 4) ||
        m_NumRetries >= 7)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


VOID
OUTGOING_INVITE_TRANSACTION::OnTimerExpire()
{
    HRESULT   hr = S_OK;

    ENTER_FUNCTION("OUTGOING_INVITE_TRANSACTION::OnTimerExpire");
    
    switch (m_State)
    {
    case OUTGOING_TRANS_REQUEST_SENT:
        // Retransmit the request
        if (MaxRetransmitsDone())
        {
            LOG((RTC_ERROR,
                 "%s MaxRetransmits for request Done terminating %s",
                 __fxName, (m_IsFirstInvite) ? "Call" : "transaction"));
            // Terminate the call
            hr = RTC_E_SIP_TIMEOUT;   // Timeout
            goto error;
        }
        else
        {
            LOG((RTC_TRACE, "%s retransmitting request m_NumRetries : %d",
                 __fxName, m_NumRetries));
            hr = RetransmitRequest();
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s  RetransmitRequest failed %x",
                     __fxName, hr));
                goto error;
            }
            m_TimerValue *= 2;
            hr = StartTimer(m_TimerValue);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s  StartTimer failed %x",
                     __fxName, hr));
                goto error;
            }
        }
        break;

    case OUTGOING_TRANS_PROVISIONAL_RESPONSE_RCVD:
        // We haven't received the final response within the
        // timeout. Terminate the transaction and call.
        LOG((RTC_ERROR,
             "%s Received 1xx but didn't receive final response terminating %s",
             __fxName, (m_IsFirstInvite) ? "Call" : "transaction"));
        hr = RTC_E_SIP_TIMEOUT;   // Timeout
        goto error;
        break;

    case OUTGOING_TRANS_ACK_SENT:
        // Transaction done - delete the transaction
        // The timer in this state is just to keep the transaction
        // alive in order to retransmit the ACK when we receive a
        // retransmit of the final response.
        LOG((RTC_TRACE,
             "%s deleting transaction after timeout for handling response retransmits",
             __fxName));
        OnTransactionDone();
        break;

    // No timers in the following states
    case OUTGOING_TRANS_INIT:
    case OUTGOING_TRANS_FINAL_RESPONSE_RCVD:
    default:
        ASSERT(FALSE);
        return;
    }

    return;

 error:

    DeleteTransactionAndTerminateCallIfFirstInvite(hr);
}


// Since we access member variables from this function,
// we should make sure we have a reference on the transaction
// when we call this function.
VOID
OUTGOING_INVITE_TRANSACTION::NotifyStartOrStopStreamCompletion(
    IN HRESULT        StatusCode,           // = 0
    IN PSTR           ReasonPhrase,         // = NULL
    IN ULONG          ReasonPhraseLen       // = 0
    )
{
    ENTER_FUNCTION("OUTGOING_INVITE_TRANSACTION::NotifyStartOrStopStreamCompletion");
    ASSERT(m_pSipCall->GetCallType() == SIP_CALL_TYPE_RTP);
    
    if (!m_fNeedToNotifyCore)
    {
        LOG((RTC_TRACE, "%s - m_fNeedToNotifyCore is FALSE", __fxName));
        return;
    }

    RTP_CALL *pRtpCall = static_cast<RTP_CALL *> (m_pSipCall);
    pRtpCall->NotifyStartOrStopStreamCompletion(
        m_Cookie, StatusCode, ReasonPhrase, ReasonPhraseLen);
    m_fNeedToNotifyCore = FALSE;
}


///////////////////////////////////////////////////////////////////////////////
// Outgoing non-INVITE
///////////////////////////////////////////////////////////////////////////////


OUTGOING_BYE_CANCEL_TRANSACTION::OUTGOING_BYE_CANCEL_TRANSACTION(
    IN SIP_CALL        *pSipCall,
    IN SIP_METHOD_ENUM  MethodId,
    IN ULONG            CSeq,
    IN BOOL             AuthHeaderSent
    ) :
    OUTGOING_TRANSACTION(pSipCall, MethodId, CSeq, AuthHeaderSent)
{
    m_pSipCall = pSipCall;
}


HRESULT
OUTGOING_BYE_CANCEL_TRANSACTION::ProcessProvisionalResponse(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT hr;

    ENTER_FUNCTION("OUTGOING_BYE_CANCEL_TRANSACTION::ProcessProvisionalResponse");
    
    LOG((RTC_TRACE, "%s - Enter", __fxName));
    
    if (m_State != OUTGOING_TRANS_FINAL_RESPONSE_RCVD)
    {
        m_State = OUTGOING_TRANS_PROVISIONAL_RESPONSE_RCVD;
        
        // Cancel existing timer and Start Timer
        KillTimer();
        hr = StartTimer(SIP_TIMER_RETRY_INTERVAL_T2);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s StartTimer failed %x", __fxName, hr));
            OnTransactionDone();
            return hr;
        }
    }

    // Ignore the Provisional response if a final response
    // has already been received.
    return S_OK;
}


HRESULT
OUTGOING_BYE_CANCEL_TRANSACTION::ProcessAuthRequiredResponse(
    IN SIP_MESSAGE *pSipMsg,
    OUT BOOL        &fDelete
    )
{
    HRESULT                     hr = S_OK;
    SIP_HEADER_ARRAY_ELEMENT    SipHdrElement;
    SECURITY_CHALLENGE          SecurityChallenge;
    REGISTER_CONTEXT           *pRegisterContext;

    ENTER_FUNCTION("OUTGOING_BYE_CANCEL_TRANSACTION::ProcessAuthRequiredResponse");

    // We need to addref the transaction as we could show credentials UI.
    TransactionAddRef();
    
    hr = ProcessAuthRequired(pSipMsg,
                             TRUE,          // Show Credentials UI if necessary
                             &SipHdrElement,
                             &SecurityChallenge );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - ProcessAuthRequired failed %x",
             __fxName, hr));
        goto done;
    }

    hr = m_pSipCall->CreateOutgoingByeTransaction(TRUE, &SipHdrElement, 1);

    free(SipHdrElement.HeaderValue);
    
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - CreateOutgoingByeTransaction failed %x",
             __fxName, hr));
        goto done;
    }

 done:
    
    TransactionRelease();
    return hr;
}


HRESULT
OUTGOING_BYE_CANCEL_TRANSACTION::ProcessFinalResponse(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT hr;
    BOOL    fDelete = TRUE;
    
    ENTER_FUNCTION("OUTGOING_BYE_CANCEL_TRANSACTION::ProcessFinalResponse");
    
    if (m_State != OUTGOING_TRANS_FINAL_RESPONSE_RCVD)
    {
        KillTimer();
        m_State = OUTGOING_TRANS_FINAL_RESPONSE_RCVD;
        if (IsSuccessfulResponse(pSipMsg))
        {
            LOG((RTC_TRACE, "%s received successful response : %d",
                 __fxName, pSipMsg->GetStatusCode()));

            // Create outgoing UNSUB transaction if SUB is enabled.
            if( m_pSipCall -> GetCallType() == SIP_CALL_TYPE_PINT )
            {
                //send out a UNSUBSCRIBE request
                (static_cast<PINT_CALL*>(m_pSipCall)) -> 
                    CreateOutgoingUnsubTransaction( FALSE, NULL , 0 );
            }
        }
        else if (IsAuthRequiredResponse(pSipMsg))
        {
            hr = ProcessAuthRequiredResponse( pSipMsg, fDelete );
        }
        else if (IsFailureResponse(pSipMsg) ||
                 IsRedirectResponse(pSipMsg))
        {
            LOG((RTC_TRACE, "%s received non-200 %d",
                 __fxName, pSipMsg->GetStatusCode()));
        }
        
        // We can terminate the transaction once we get a final response.
        if( fDelete == TRUE )
        {
            OnTransactionDone();
        }
    }
    return S_OK;
}


HRESULT
OUTGOING_BYE_CANCEL_TRANSACTION::ProcessResponse(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT hr;
    
    ASSERT(pSipMsg->MsgType == SIP_MESSAGE_TYPE_RESPONSE);

    if (IsProvisionalResponse(pSipMsg))
    {
        return ProcessProvisionalResponse(pSipMsg);
    }
    else if (IsFinalResponse(pSipMsg))
    {
        return ProcessFinalResponse(pSipMsg);
    }
    else
    {
        ASSERT(FALSE);
        return E_FAIL;
    }
}


BOOL
OUTGOING_BYE_CANCEL_TRANSACTION::MaxRetransmitsDone()
{
    return (m_pSipCall->GetTransport() != SIP_TRANSPORT_UDP ||
            m_NumRetries >= 11);
}


VOID
OUTGOING_BYE_CANCEL_TRANSACTION::OnTimerExpire()
{
    HRESULT   hr;
    
    ENTER_FUNCTION("OUTGOING_BYE_CANCEL_TRANSACTION::OnTimerExpire");
    
    switch (m_State)
    {
        // we have to retransmit the request even after receiving
        // a provisional response.
    case OUTGOING_TRANS_REQUEST_SENT:
    case OUTGOING_TRANS_PROVISIONAL_RESPONSE_RCVD:
        // Retransmit the request
        if (MaxRetransmitsDone())
        {
            LOG((RTC_ERROR,
                 "%s MaxRetransmits for request Done terminating transaction",
                 __fxName));
            // Terminate the call
            goto error;
        }
        else
        {
            LOG((RTC_TRACE, "%s retransmitting request m_NumRetries : %d",
                 __fxName, m_NumRetries));
            hr = RetransmitRequest();
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s RetransmitRequest failed %x",
                     __fxName, hr));
                goto error;
            }

            if (m_TimerValue*2 >= SIP_TIMER_RETRY_INTERVAL_T2)
                m_TimerValue = SIP_TIMER_RETRY_INTERVAL_T2;
            else
                m_TimerValue *= 2;

            hr = StartTimer(m_TimerValue);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s StartTimer failed %x",
                     __fxName, hr));
                goto error;
            }
        }
        break;

    case OUTGOING_TRANS_INIT:
    case OUTGOING_TRANS_FINAL_RESPONSE_RCVD:
    default:
        ASSERT(FALSE);
        return;
    }

    return;

 error:
    // We shouldn't call InitiateCallTerminationOnError()
    // as we are already doing the BYE transaction.
    OnTransactionDone();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\siphdr.h ===
#ifndef	__siphdr_h
#define	__siphdr_h


// Structure that stores a string along with length

struct COUNTED_STRING
{
    PSTR  Buffer;
    ULONG Length;
};


//
// SIP Methods
// Any method added to this enum should have an equivalent
// text in g_MethodTextArray in siphdr.cpp

enum SIP_METHOD_ENUM
{
    SIP_METHOD_INVITE = 0,
    SIP_METHOD_ACK, 
    SIP_METHOD_OPTIONS,
    SIP_METHOD_BYE,
    SIP_METHOD_CANCEL,
    SIP_METHOD_REGISTER,
    SIP_METHOD_NOTIFY,
    SIP_METHOD_SUBSCRIBE,
    SIP_METHOD_MESSAGE,
    SIP_METHOD_INFO,
    // these are not actual methods
    SIP_METHOD_MAX,
    SIP_METHOD_UNKNOWN = -1,
};

SIP_METHOD_ENUM GetSipMethodId(
    IN PSTR MethodText,
    IN ULONG MethodTextLen
    );

CONST COUNTED_STRING *GetSipMethodName(
    IN SIP_METHOD_ENUM HeaderId
    );


// SIP Headers
// This enum corresponds to the g_SipHeaderTextArray in siphdr.cpp
// and the entries should appear in exactly the same order in both
// places.

enum SIP_HEADER_ENUM
{
    SIP_HEADER_ACCEPT,
    SIP_HEADER_ACCEPT_ENCODING,
    SIP_HEADER_ACCEPT_LANGUAGE,
    SIP_HEADER_ALERT_INFO,
    SIP_HEADER_ALLOW,
    SIP_HEADER_ALLOW_EVENTS,
    SIP_HEADER_AUTHORIZATION,
    SIP_HEADER_BADHEADERINFO,
    SIP_HEADER_CALL_ID,
    SIP_HEADER_CALL_INFO,
    SIP_HEADER_CONTACT,
    SIP_HEADER_CONTENT_DISPOSITION,
    SIP_HEADER_CONTENT_ENCODING,
    SIP_HEADER_CONTENT_LANGUAGE,
    SIP_HEADER_CONTENT_LENGTH,
    SIP_HEADER_CONTENT_TYPE,
    SIP_HEADER_CSEQ,
    SIP_HEADER_DATE,
    SIP_HEADER_ENCRYPTION,
    SIP_HEADER_EVENT,
    SIP_HEADER_EXPIRES,
    SIP_HEADER_FROM,
    SIP_HEADER_HIDE,
    SIP_HEADER_IN_REPLY_TO,
    SIP_HEADER_MAX_FORWARDS,
    SIP_HEADER_MIME_VERSION,
    SIP_HEADER_ORGANIZATION,
    SIP_HEADER_PRIORITY,
    SIP_HEADER_PROXY_AUTHENTICATE,
    SIP_HEADER_PROXY_AUTHENTICATION_INFO,
    SIP_HEADER_PROXY_AUTHORIZATION,
    SIP_HEADER_PROXY_REQUIRE,
    SIP_HEADER_RECORD_ROUTE,
    SIP_HEADER_REQUIRE,
    SIP_HEADER_RESPONSE_KEY,
    SIP_HEADER_RETRY_AFTER,
    SIP_HEADER_ROUTE,
    SIP_HEADER_SERVER,
    SIP_HEADER_SUBJECT,
    SIP_HEADER_SUPPORTED,
    SIP_HEADER_TIMESTAMP,
    SIP_HEADER_TO,
    SIP_HEADER_UNSUPPORTED,
    SIP_HEADER_USER_AGENT,
    SIP_HEADER_VIA,
    SIP_HEADER_WARNING,
    SIP_HEADER_WWW_AUTHENTICATE,

    // These are not actual SIP headers
    SIP_HEADER_MAX,
    SIP_HEADER_UNKNOWN = 0xFFFFFFFF

};


// Function Declarations


SIP_HEADER_ENUM GetSipHeaderId(
    IN PSTR  HeaderName,
    IN ULONG HeaderNameLen
    );

CONST COUNTED_STRING *GetSipHeaderName(
    IN SIP_HEADER_ENUM HeaderId
    );


// SIP Header Params
// This enum corresponds to the g_SipHeaderParamTextArray in siphdr.cpp
// and the entries should appear in exactly the same order in both
// places.

enum SIP_HEADER_PARAM_ENUM
{
    SIP_HEADER_PARAM_ACTION = 0,
    SIP_HEADER_PARAM_VIA_BRANCH,
    SIP_HEADER_PARAM_CNONCE,
    SIP_HEADER_PARAM_EXPIRES,
    SIP_HEADER_PARAM_VIA_HIDDEN,
    SIP_HEADER_PARAM_VIA_MADDR,
    SIP_HEADER_PARAM_NEXTNONCE,
    SIP_HEADER_PARAM_QVALUE,
    SIP_HEADER_PARAM_VIA_RECEIVED,
    SIP_HEADER_PARAM_RSPAUTH,
    SIP_HEADER_PARAM_TAG,
    SIP_HEADER_PARAM_TTL,

    SIP_HEADER_PARAM_UNKNOWN,
};


SIP_HEADER_PARAM_ENUM GetSipHeaderParamId(
    IN PSTR  ParamName,
    IN ULONG ParamNameLen
    );

CONST COUNTED_STRING *GetSipHeaderParamName(
    IN SIP_HEADER_PARAM_ENUM ParamId
    );

// SIP URL Params
// This enum corresponds to the g_SipUrlParamTextArray in siphdr.cpp
// and the entries should appear in exactly the same order in both
// places.

enum SIP_URL_PARAM_ENUM
{
    SIP_URL_PARAM_MADDR = 0,
    SIP_URL_PARAM_METHOD,
    SIP_URL_PARAM_TRANSPORT,
    SIP_URL_PARAM_TTL,
    SIP_URL_PARAM_USER,

    SIP_URL_PARAM_UNKNOWN,
    
    SIP_URL_PARAM_MAX = SIP_URL_PARAM_UNKNOWN
};


SIP_URL_PARAM_ENUM GetSipUrlParamId(
    IN PSTR  ParamName,
    IN ULONG ParamNameLen
    );

CONST COUNTED_STRING *GetSipUrlParamName(
    IN SIP_URL_PARAM_ENUM ParamId
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\siphdr.cpp ===
#include "precomp.h"


///////////////////////////////////////////////////////////////////////////////
// SIP Method Text <-> enum value
///////////////////////////////////////////////////////////////////////////////


#define METHOD_ENTRY(String) String, sizeof(String) - 1

// All entries in SIP_METHOD_ENUM should have an entry here.
static const COUNTED_STRING g_MethodTextArray [] = {
    METHOD_ENTRY("INVITE"),
    METHOD_ENTRY("ACK"),
    METHOD_ENTRY("OPTIONS"),
    METHOD_ENTRY("BYE"),
    METHOD_ENTRY("CANCEL"),
    METHOD_ENTRY("REGISTER"),
    METHOD_ENTRY("NOTIFY"),
    METHOD_ENTRY("SUBSCRIBE"),
    METHOD_ENTRY("MESSAGE"),
    METHOD_ENTRY("INFO"),
};

#undef METHOD_ENTRY

SIP_METHOD_ENUM GetSipMethodId(PSTR MethodText, ULONG MethodTextLen)
{
    ULONG i = 0;
    for (i = 0; i < SIP_METHOD_MAX; i++)
    {
        if (MethodTextLen == g_MethodTextArray[i].Length &&
            strncmp(g_MethodTextArray[i].Buffer, MethodText, MethodTextLen) == 0)
        {
            return (SIP_METHOD_ENUM)i;
        }
    }

    return SIP_METHOD_UNKNOWN;
}

CONST COUNTED_STRING *GetSipMethodName(
    IN SIP_METHOD_ENUM MethodId
    )
{
    if (MethodId >= 0 && MethodId < SIP_METHOD_MAX)
    {
        return &g_MethodTextArray[MethodId];
    }
    else
    {
        return NULL;
    }
}



///////////////////////////////////////////////////////////////////////////////
// SIP Header Text <-> enum value
///////////////////////////////////////////////////////////////////////////////

// The following short field names are defined.
//  c Content-Type
//  e Content-Encoding
//  f From
//  i Call-ID
//  k Supported from "know"
//  m Contact from "moved"
//  l Content-Length
//  s Subject
//  t To
//  v Via

static const SIP_HEADER_ENUM g_SipShortHeaders[] = {
    SIP_HEADER_UNKNOWN, SIP_HEADER_UNKNOWN, SIP_HEADER_CONTENT_TYPE,     // abc
    SIP_HEADER_UNKNOWN, SIP_HEADER_CONTENT_ENCODING, SIP_HEADER_FROM,    // def
    SIP_HEADER_UNKNOWN, SIP_HEADER_UNKNOWN, SIP_HEADER_CALL_ID,          // ghi
    SIP_HEADER_UNKNOWN, SIP_HEADER_SUPPORTED, SIP_HEADER_CONTENT_LENGTH, // jkl
    SIP_HEADER_CONTACT, SIP_HEADER_UNKNOWN, SIP_HEADER_UNKNOWN,          // mno
    SIP_HEADER_UNKNOWN, SIP_HEADER_UNKNOWN, SIP_HEADER_UNKNOWN,          // pqr
    SIP_HEADER_SUBJECT, SIP_HEADER_TO,      SIP_HEADER_UNKNOWN,          // stu
    SIP_HEADER_VIA,     SIP_HEADER_UNKNOWN, SIP_HEADER_UNKNOWN,          // vwx
    SIP_HEADER_UNKNOWN, SIP_HEADER_UNKNOWN,                              // yz
};

#define HEADER_ENTRY(String) String, sizeof(String) - 1


// This array must be stored in sorted order, in order to allow
// using a binary search. The order should be case-insensitive.
// The index of each entry corresponds to the
// value of the SIP_HEADER enumerated type.  This array is used for
// both conversion from ID to text, and vice-versa.

static const COUNTED_STRING g_SipHeaderTextArray [] = {
    HEADER_ENTRY("Accept"),
    HEADER_ENTRY("Accept-Encoding"),
    HEADER_ENTRY("Accept-Language"),
    HEADER_ENTRY("Alert-Info"),
    HEADER_ENTRY("Allow"),
    HEADER_ENTRY("Allow-Events"),
    HEADER_ENTRY("Authorization"),
    HEADER_ENTRY("Bad-Header-Info"),
    HEADER_ENTRY("Call-ID"),
    HEADER_ENTRY("Call-Info"),
    HEADER_ENTRY("Contact"),
    HEADER_ENTRY("Content-Disposition"),
    HEADER_ENTRY("Content-Encoding"),
    HEADER_ENTRY("Content-Language"),
    HEADER_ENTRY("Content-Length"),
    HEADER_ENTRY("Content-Type"),
    HEADER_ENTRY("CSeq"),
    HEADER_ENTRY("Date"),
    HEADER_ENTRY("Encryption"),
    HEADER_ENTRY("Event"),
    HEADER_ENTRY("Expires"),
    HEADER_ENTRY("From"),
    HEADER_ENTRY("Hide"),
    HEADER_ENTRY("In-Reply-To"),
    HEADER_ENTRY("Max-Forwards"),
    HEADER_ENTRY("MIME-Version"),
    HEADER_ENTRY("Organization"),
    HEADER_ENTRY("Priority"),
    HEADER_ENTRY("Proxy-Authenticate"),
    HEADER_ENTRY("Proxy-Authentication-Info"),
    HEADER_ENTRY("Proxy-Authorization"),
    HEADER_ENTRY("Proxy-Require"),
    HEADER_ENTRY("Record-Route"),
    HEADER_ENTRY("Require"),
    HEADER_ENTRY("Response-Key"),
    HEADER_ENTRY("Retry-After"),
    HEADER_ENTRY("Route"),
    HEADER_ENTRY("Server"),
    HEADER_ENTRY("Subject"),
    HEADER_ENTRY("Supported"),
    HEADER_ENTRY("Timestamp"),
    HEADER_ENTRY("To"),
    HEADER_ENTRY("Unsupported"),
    HEADER_ENTRY("User-Agent"),
    HEADER_ENTRY("Via"),
    HEADER_ENTRY("Warning"),
    HEADER_ENTRY("WWW-Authenticate"),
};

#undef HEADER_ENTRY

SIP_HEADER_ENUM GetSipHeaderId(
    IN PSTR  HeaderName,
    IN ULONG HeaderNameLen
    )
{
    int  Start = 0;
    int  End   = SIP_HEADER_MAX - 1;
    int  Middle;
    int  CompareResult;

    // Check for short headers.
    if (HeaderNameLen == 1)
    {
        char ShortHeader = HeaderName[0];
        if (ShortHeader >= 'a' && ShortHeader <= 'z' &&
            g_SipShortHeaders[ShortHeader - 'a'] != SIP_HEADER_UNKNOWN)
            return g_SipShortHeaders[ShortHeader - 'a'];
        if (ShortHeader >= 'A' && ShortHeader <= 'Z' &&
            g_SipShortHeaders[ShortHeader - 'A'] != SIP_HEADER_UNKNOWN)
            return g_SipShortHeaders[ShortHeader - 'A'];
    }
    
    // Do a binary search of the Header name array.
    while (Start <= End)
    {
        Middle = (Start + End)/2;
        CompareResult = _strnicmp(HeaderName, g_SipHeaderTextArray[Middle].Buffer,
                                  HeaderNameLen);

        if (CompareResult == 0)
        {
            if (g_SipHeaderTextArray[Middle].Length > HeaderNameLen)
            {
                // This mean HeaderName matched a only part of the
                // known header. So we need to search in the headers
                // before this header.
                End = Middle - 1;
            }
            else
            {
                // We found the header
                return (SIP_HEADER_ENUM) Middle;
            }
        }
        else if (CompareResult < 0)
        {
            End = Middle - 1;
        }
        else
        {
            // CompareResult > 0
            Start = Middle + 1;
        }
    }

    return SIP_HEADER_UNKNOWN;
}


CONST COUNTED_STRING *GetSipHeaderName(
    IN SIP_HEADER_ENUM HeaderId
    )
{
    if (HeaderId >= 0 && HeaderId < SIP_HEADER_MAX)
    {
        return &g_SipHeaderTextArray[HeaderId];
    }
    else
    {
        return NULL;
    }
}


///////////////////////////////////////////////////////////////////////////////
// SIP Header Param Text <-> enum value
///////////////////////////////////////////////////////////////////////////////

#define HEADER_PARAM_ENTRY(String) String, sizeof(String) - 1


// This array must be stored in sorted order, in order to allow
// using a binary search. The order should be case-insensitive.
// The index of each entry corresponds to the
// value of the SIP_HEADER_PARAM_ENUM enumerated type.  This array is used for
// both conversion from ID to text, and vice-versa.

static const COUNTED_STRING g_SipHeaderParamTextArray [] = {
    HEADER_PARAM_ENTRY("action"),
    HEADER_PARAM_ENTRY("branch"),
    HEADER_PARAM_ENTRY("cnonce"),
    HEADER_PARAM_ENTRY("expires"),
    HEADER_PARAM_ENTRY("hidden"),
    HEADER_PARAM_ENTRY("maddr"),
    HEADER_PARAM_ENTRY("nextnonce"),
    HEADER_PARAM_ENTRY("q"),
    HEADER_PARAM_ENTRY("received"),
    HEADER_PARAM_ENTRY("rspauth"),
    HEADER_PARAM_ENTRY("tag"),
    HEADER_PARAM_ENTRY("ttl"),

};

#undef HEADER_PARAM_ENTRY

SIP_HEADER_PARAM_ENUM GetSipHeaderParamId(
    IN PSTR  ParamName,
    IN ULONG ParamNameLen
    )
{
    int  Start = 0;
    int  End   = SIP_HEADER_PARAM_UNKNOWN - 1;
    int  Middle;
    int  CompareResult;

    // Do a binary search of the Header name array.
    while (Start <= End)
    {
        Middle = (Start + End)/2;
        CompareResult = _strnicmp(ParamName,
                                  g_SipHeaderParamTextArray[Middle].Buffer,
                                  ParamNameLen);

        if (CompareResult == 0)
        {
            if (g_SipHeaderParamTextArray[Middle].Length > ParamNameLen)
            {
                // This mean ParamName matched a only part of the
                // known header. So we need to search in the headers
                // before this header.
                End = Middle - 1;
            }
            else
            {
                // We found the header
                return (SIP_HEADER_PARAM_ENUM) Middle;
            }
        }
        else if (CompareResult < 0)
        {
            End = Middle - 1;
        }
        else
        {
            // CompareResult > 0
            Start = Middle + 1;
        }
    }

    return SIP_HEADER_PARAM_UNKNOWN;
}


CONST COUNTED_STRING *GetSipHeaderParamName(
    IN SIP_HEADER_PARAM_ENUM ParamId
    )
{
    if (ParamId >= 0 && ParamId < SIP_HEADER_PARAM_UNKNOWN)
    {
        return &g_SipHeaderParamTextArray[ParamId];
    }
    else
    {
        return NULL;
    }
}


///////////////////////////////////////////////////////////////////////////////
// SIP URL Param Text <-> enum value
///////////////////////////////////////////////////////////////////////////////

#define SIP_URL_PARAM_ENTRY(String) String, sizeof(String) - 1


// This array must be stored in sorted order, in order to allow
// using a binary search. The order should be case-insensitive.
// The index of each entry corresponds to the
// value of the SIP_URL_PARAM_ENUM enumerated type.  This array is used for
// both conversion from ID to text, and vice-versa.

static const COUNTED_STRING g_SipUrlParamTextArray [] = {
    SIP_URL_PARAM_ENTRY("maddr"),
    SIP_URL_PARAM_ENTRY("method"),
    SIP_URL_PARAM_ENTRY("transport"),
    SIP_URL_PARAM_ENTRY("ttl"),
    SIP_URL_PARAM_ENTRY("user"),
};

#undef SIP_URL_PARAM_ENTRY


// XXX TODO Make all the binary search as common code.
SIP_URL_PARAM_ENUM GetSipUrlParamId(
    IN PSTR  ParamName,
    IN ULONG ParamNameLen
    )
{
    int  Start = 0;
    int  End   = SIP_URL_PARAM_UNKNOWN - 1;
    int  Middle;
    int  CompareResult;

    // Do a binary search of the Header name array.
    while (Start <= End)
    {
        Middle = (Start + End)/2;
        CompareResult = _strnicmp(ParamName,
                                  g_SipUrlParamTextArray[Middle].Buffer,
                                  ParamNameLen);

        if (CompareResult == 0)
        {
            if (g_SipUrlParamTextArray[Middle].Length > ParamNameLen)
            {
                // This mean ParamName matched a only part of the
                // known header. So we need to search in the headers
                // before this header.
                End = Middle - 1;
            }
            else
            {
                // We found the header
                return (SIP_URL_PARAM_ENUM) Middle;
            }
        }
        else if (CompareResult < 0)
        {
            End = Middle - 1;
        }
        else
        {
            // CompareResult > 0
            Start = Middle + 1;
        }
    }

    return SIP_URL_PARAM_UNKNOWN;
}


CONST COUNTED_STRING *GetSipUrlParamName(
    IN SIP_URL_PARAM_ENUM ParamId
    )
{
    if (ParamId >= 0 && ParamId < SIP_URL_PARAM_UNKNOWN)
    {
        return &g_SipUrlParamTextArray[ParamId];
    }
    else
    {
        return NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\rtpcall.cpp ===
#include "precomp.h"
//#include "resolve.h"
#include "sipstack.h"
#include "sipcall.h"
#include "dllres.h"

RTP_CALL::RTP_CALL(
    IN  SIP_PROVIDER_ID   *pProviderId,
    IN  SIP_STACK         *pSipStack,
    IN  REDIRECT_CONTEXT  *pRedirectContext    
    ) :
    SIP_CALL(pProviderId,
             SIP_CALL_TYPE_RTP,
             pSipStack,
             pRedirectContext)
{
    m_NumStreamQueueEntries           = 0;
}


RTP_CALL::~RTP_CALL()
{
    
}


// Methods for incoming calls

STDMETHODIMP
RTP_CALL::Accept()
{
    HRESULT hr;
    if(GetSipStack()->IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "SipStack is already shutdown"));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    ASSERT(m_State == SIP_CALL_STATE_OFFERING);
    if (m_pIncomingInviteTransaction != NULL)
    {
        m_State = SIP_CALL_STATE_CONNECTING;
        
        hr = m_pIncomingInviteTransaction->Accept();
        return hr;
    }
    
    return E_FAIL;
}


STDMETHODIMP
RTP_CALL::Reject(
    IN SIP_STATUS_CODE StatusCode
    )
{
    HRESULT hr;
    PSTR    ReasonPhrase;
    ULONG   ReasonPhraseLen;
    if(GetSipStack()->IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "SipStack is already shutdown"));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    LOG((RTC_TRACE, "RTP_CALL::Reject(%d) - enter", StatusCode));
    
    ASSERT(m_State == SIP_CALL_STATE_OFFERING);

    m_State = SIP_CALL_STATE_REJECTED;

    switch (StatusCode)
    {
    case 408:
        ReasonPhrase    = SIP_STATUS_TEXT(408);
        ReasonPhraseLen = SIP_STATUS_TEXT_SIZE(408);
        break;
        
    case 480:
        ReasonPhrase    = SIP_STATUS_TEXT(480);
        ReasonPhraseLen = SIP_STATUS_TEXT_SIZE(480);
        break;
        
    case 486:
        ReasonPhrase    = SIP_STATUS_TEXT(486);
        ReasonPhraseLen = SIP_STATUS_TEXT_SIZE(486);
        break;
    
	case 603:
    default:
        ReasonPhrase    = SIP_STATUS_TEXT(603);
        ReasonPhraseLen = SIP_STATUS_TEXT_SIZE(603);
        break;
    }
    
    if (m_pIncomingInviteTransaction != NULL)
    {
        hr = m_pIncomingInviteTransaction->Reject(StatusCode,
                                                  ReasonPhrase,
                                                  ReasonPhraseLen);
        return hr;
    }

    // No Incoming INVITE transaction.
    return E_FAIL;
}


STDMETHODIMP
RTP_CALL::Connect(
    IN   LPCOLESTR       LocalDisplayName,
    IN   LPCOLESTR       LocalUserURI,
    IN   LPCOLESTR       RemoteUserURI,
    IN   LPCOLESTR       LocalPhoneURI
    )
{
    HRESULT     hr;

    ENTER_FUNCTION("RTP_CALL::Connect");
    if(GetSipStack()->IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "%s - SipStack is already shutdown", __fxName));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    LOG((RTC_TRACE,
         "%s - enter LocalDisplayName: %ls LocalUserURI: %ls "
         "RemoteUserURI: %ls LocalPhoneURI: %ls",
         __fxName,
         PRINTABLE_STRING_W(LocalDisplayName),
         PRINTABLE_STRING_W(LocalUserURI),
         PRINTABLE_STRING_W(RemoteUserURI),
         PRINTABLE_STRING_W(LocalPhoneURI)
         ));
    ASSERTMSG("SetNotifyInterface has to be called", m_pNotifyInterface);
    ASSERT(m_State == SIP_CALL_STATE_IDLE);
    
    hr = SetLocalForOutgoingCall(LocalDisplayName, LocalUserURI);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s SetLocalForOutgoingCall failed %x",
             __fxName, hr));
        return hr;
    }
    
    hr = SetRequestURIRemoteAndRequestDestination(RemoteUserURI);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s SetRequestURIRemoteAndRequestDestination failed %x",
             __fxName, hr));
        return hr;
    }

    // SDP blob is created only after the socket is connected to
    // the destination.
    // We create the outgoing INVITE transaction even if the request socket
    // is not connected. The connect completion notification will result
    // in sending the INVITE.
    hr = CreateOutgoingInviteTransaction(
             FALSE,     // Auth Header not sent
             TRUE,      // First INVITE
             NULL, 0,   // No Additional headers
             NULL, 0,
             FALSE, 0   // No Cookie
             );

    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s: CreateOutgoingInviteTransaction failed %x",
             __fxName, hr));
        return hr;
    }
    
    return S_OK;
}


// Media streaming interfaces.

STDMETHODIMP
RTP_CALL::StartStream(
    IN RTC_MEDIA_TYPE       MediaType,
    IN RTC_MEDIA_DIRECTION  Direction,
    IN LONG                 Cookie    
    )
{
    ENTER_FUNCTION("RTP_CALL::StartStream");
    if(GetSipStack()->IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "%s - SipStack is already shutdown", __fxName));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    if (ProcessingInviteTransaction())
    {
        LOG((RTC_TRACE,
             "%s (%d, %d) INVITE transaction is pending - queuing request",
             __fxName, MediaType, Direction));

        AddToStreamStartStopQueue(MediaType, Direction, TRUE, Cookie);

        return S_OK;
    }

    return StartStreamHelperFn(MediaType, Direction, Cookie);
}


STDMETHODIMP
RTP_CALL::StopStream(
    IN RTC_MEDIA_TYPE       MediaType,
    IN RTC_MEDIA_DIRECTION  Direction,
    IN LONG                 Cookie
    )
{
    ENTER_FUNCTION("RTP_CALL::StopStream");
    if(GetSipStack()->IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "%s - SipStack is already shutdown", __fxName));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    if (ProcessingInviteTransaction())
    {
        LOG((RTC_TRACE,
             "%s (%d, %d) INVITE transaction is pending - queuing request",
             __fxName, MediaType, Direction));

        AddToStreamStartStopQueue(MediaType, Direction, FALSE, Cookie);

        return S_OK;
    }

    return StopStreamHelperFn(MediaType, Direction, Cookie);
}


// returns RTC_E_SIP_STREAM_PRESENT if the stream is
// already present.
// If this function fails the caller is responsible for
// making the callback to Core.
HRESULT
RTP_CALL::StartStreamHelperFn(
    IN RTC_MEDIA_TYPE       MediaType,
    IN RTC_MEDIA_DIRECTION  Direction,
    IN LONG                 Cookie
    )
{
    ENTER_FUNCTION("RTP_CALL::StartStreamHelperFn");

    HRESULT hr;
    PSTR    MediaSDPBlob;

    IRTCMediaManage *pMediaManager = GetMediaManager();
    ASSERT(pMediaManager != NULL);

    if (S_OK == pMediaManager->HasStream(MediaType, Direction))
    {
        // The stream is present - so a re-INVITE is not required.
        LOG((RTC_TRACE, "%s - stream %d %d present - no reINVITE required",
             __fxName, MediaType, Direction));
        return RTC_E_SIP_STREAM_PRESENT;
    }
    else
    {
        DWORD   RemoteIp = ntohl(m_RequestDestAddr.sin_addr.s_addr);
        if (RemoteIp == 0)
        {
            // This could happen if the first incoming INVITE has no
            // Record-Route/Contact header and it also doesn't have the
            // address in the From header.
            LOG((RTC_ERROR, "%s - RequestDestAddr is 0 - this shouldn't happen",
                 __fxName));
            return RTC_E_SIP_REQUEST_DESTINATION_ADDR_NOT_PRESENT;
        }

        LOG((RTC_TRACE, "%s Before pMediaManager->AddStream ", __fxName));

        hr = pMediaManager->AddStream(MediaType, Direction,
                                      RemoteIp);

        LOG((RTC_TRACE, "%s After pMediaManager->AddStream ", __fxName));

        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s: AddStream type: %d dir: %d  failed %x",
                 __fxName, MediaType, Direction, hr));
            return hr;
        }

        if (Direction == RTC_MD_RENDER)
        {
            LOG((RTC_TRACE, "%s Before pMediaManager->StartStream ", __fxName));

            hr = pMediaManager->StartStream(MediaType, Direction);

            LOG((RTC_TRACE, "%s After pMediaManager->StartStream ", __fxName));

            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s: StartStream type: %d dir: %d  failed %x",
                     __fxName, MediaType, Direction, hr));
                return hr;
            }
        }

        // SDP blob is created only after the socket is connected to
        // the destination.
        // Create outgoing INVITE transaction.
        hr = CreateOutgoingInviteTransaction(
                 FALSE,     // Auth Header not sent
                 FALSE,     // Not First INVITE
                 NULL, 0,   // No Additional headers
                 NULL, 0,   // MediaSDPBlob
                 TRUE, Cookie
                 );

        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s CreateOutgoingInviteTransaction failed %x",
                 __fxName, hr));
            return hr;
        }
    }
    
    return S_OK; 
}

                     
// returns RTC_E_SIP_STREAM_NOT_PRESENT if the stream is
// already present.
// If this function fails the caller is responsible for
// making the callback to Core.
HRESULT
RTP_CALL::StopStreamHelperFn(
    IN RTC_MEDIA_TYPE       MediaType,
    IN RTC_MEDIA_DIRECTION  Direction,
    IN LONG                 Cookie
    )
{
    ENTER_FUNCTION("RTP_CALL::StopStreamHelperFn");

    HRESULT hr;
    PSTR    MediaSDPBlob;

    IRTCMediaManage *pMediaManager = GetMediaManager();
    ASSERT(pMediaManager != NULL);
    
    if (S_FALSE == pMediaManager->HasStream(MediaType, Direction))
    {
        // The stream is not present - so a re-INVITE is not required.
        LOG((RTC_TRACE, "%s - stream %d %d not present - no reINVITE required",
             __fxName, MediaType, Direction));
        return RTC_E_SIP_STREAM_NOT_PRESENT;
    }
    

    LOG((RTC_TRACE, "%s Before pMediaManager->RemoveStream ", __fxName));

    hr = pMediaManager->RemoveStream(MediaType, Direction);

    LOG((RTC_TRACE, "%s After pMediaManager->RemoveStream ", __fxName));

    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s: RemoveStream type: %d dir: %d  failed %x",
             __fxName, MediaType, Direction, hr));
        return hr;
    }

    // SDP blob is created only after the socket is connected to
    // the destination.
    // Create outgoing INVITE transaction.
    hr = CreateOutgoingInviteTransaction(
             FALSE,     // Auth Header not sent
             FALSE,     // Not First INVITE
             NULL, 0,   // No Additional headers
             NULL, 0,   // MediaSDPBlob
             TRUE, Cookie
             );

    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s CreateOutgoingInviteTransaction failed %x",
             __fxName, hr));
        return hr;
    }

    return S_OK; 
}


VOID
RTP_CALL::NotifyStartOrStopStreamCompletion(
    IN LONG           Cookie,
    IN HRESULT        StatusCode,       // = 0
    IN PSTR           ReasonPhrase,     // = NULL
    IN ULONG          ReasonPhraseLen   // = 0
    )
{
    SIP_STATUS_BLOB StatusBlob;
    LPWSTR          wsStatusText = NULL;
    HRESULT         hr = S_OK;

    ENTER_FUNCTION("RTP_CALL::NotifyStartOrStopStreamCompletion");

    if (ReasonPhrase != NULL)
    {
        hr = UTF8ToUnicode(ReasonPhrase, ReasonPhraseLen,
                           &wsStatusText);
        if (hr != S_OK)
        {
            wsStatusText = NULL;
        }
    }
    
    StatusBlob.StatusCode = StatusCode;
    StatusBlob.StatusText = wsStatusText;
                
    // Make the callback to Core
    if (m_pNotifyInterface != NULL)
    {
        m_pNotifyInterface->NotifyStartOrStopStreamCompletion(
            Cookie, &StatusBlob);
    }
    else
    {
        LOG((RTC_WARN, "%s : m_pNotifyInterface is NULL",
             __fxName));
    }

    if (wsStatusText != NULL)
        free(wsStatusText);
}


// This function could make a callback to Core/UI if there is a failure.
// So this function should be called last.

VOID
RTP_CALL::ProcessPendingInvites()
{
    ENTER_FUNCTION("RTP_CALL::ProcessPendingInvites");

    ASSERT(!ProcessingInviteTransaction());
    
    HRESULT              hr;
    RTC_MEDIA_TYPE       MediaType;
    RTC_MEDIA_DIRECTION  Direction;
    BOOL                 fStartStream;
    LONG                 Cookie;

    if (IsCallDisconnected())
    {
        // XXX Should we notify all the pending requests here ?
        // We could rely on the fact that since the
        // call is already disconnected, we would have notified Core
        // and the application doesn't bother about these requests on
        // a disconnected call.
        if (m_NumStreamQueueEntries != 0)
        {
            LOG((RTC_TRACE,
                 "%s - Call already disconnected not processing pending requests ",
                 __fxName));
        }
        return;
    }

    // if there is something in the queue process it.
    while (PopStreamStartStopQueue(&MediaType, &Direction, &fStartStream, &Cookie))
    {
        LOG((RTC_TRACE, "%s - processing pending %s request %d %d",
             __fxName, (fStartStream)? "StartStream" : "StopStream",
             MediaType, Direction));
        
        if (fStartStream)
        {
            hr = StartStreamHelperFn(MediaType, Direction, Cookie);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s StartStreamHelperFn failed %x",
                     __fxName, hr));
            }
        }
        else
        {
            hr = StopStreamHelperFn(MediaType, Direction, Cookie);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s StopStreamHelperFn failed %x",
                     __fxName, hr));
            }
        }

        if (hr == S_OK)
        {
            // This means one of the pending INVITE transactions
            // has been started succesfully.
            ASSERT(ProcessingInviteTransaction());
            break;
        }
        else
        {
            NotifyStartOrStopStreamCompletion(Cookie, hr);
        }
    }
}


// Note that this function could make a callback to core
// with E_ABORT if we replace an existing entry in the queue.
// So, this function should be called last like any other function
// that makes a callback to core (as the callback could block, etc.)

VOID
RTP_CALL::AddToStreamStartStopQueue(
    IN  RTC_MEDIA_TYPE       MediaType,
    IN  RTC_MEDIA_DIRECTION  Direction,
    IN  BOOL                 fStartStream,
    IN LONG                  Cookie
    )
{
    ULONG i = 0;
    LONG  OldCookie;

    ASSERT(m_NumStreamQueueEntries < 6);

    for (i = 0; i < m_NumStreamQueueEntries; i++)
    {
        if (MediaType == m_StreamStartStopQueue[i].MediaType &&
            Direction == m_StreamStartStopQueue[i].Direction)
        {
            m_StreamStartStopQueue[i].fStartStream = fStartStream;
            OldCookie = m_StreamStartStopQueue[i].Cookie;
            m_StreamStartStopQueue[i].Cookie = Cookie;
            NotifyStartOrStopStreamCompletion(OldCookie, E_ABORT);
            return;
        }
    }

    m_StreamStartStopQueue[m_NumStreamQueueEntries].MediaType = MediaType;
    m_StreamStartStopQueue[m_NumStreamQueueEntries].Direction = Direction;
    m_StreamStartStopQueue[m_NumStreamQueueEntries].fStartStream = fStartStream;
    m_StreamStartStopQueue[m_NumStreamQueueEntries].Cookie = Cookie;

    m_NumStreamQueueEntries++;
}


BOOL
RTP_CALL::PopStreamStartStopQueue(
    OUT RTC_MEDIA_TYPE       *pMediaType,
    OUT RTC_MEDIA_DIRECTION  *pDirection,
    OUT BOOL                 *pfStartStream,
    OUT LONG                 *pCookie
    )
{
    ULONG i = 0;
    
    ASSERT(m_NumStreamQueueEntries < 6);

    if (m_NumStreamQueueEntries == 0)
    {
        return FALSE;
    }

    *pMediaType = m_StreamStartStopQueue[0].MediaType;
    *pDirection = m_StreamStartStopQueue[0].Direction;
    *pfStartStream = m_StreamStartStopQueue[0].fStartStream;
    *pCookie    = m_StreamStartStopQueue[0].Cookie;
    
    for (i = 1; i < m_NumStreamQueueEntries; i++)
    {
        m_StreamStartStopQueue[i-1] = m_StreamStartStopQueue[i];
    }

    m_NumStreamQueueEntries--;

    return TRUE;
}


HRESULT
RTP_CALL::StartIncomingCall(
    IN  SIP_TRANSPORT   Transport,
    IN  SIP_MESSAGE    *pSipMsg,
    IN  ASYNC_SOCKET   *pResponseSocket
    )
{
    HRESULT     hr;
    PSTR        Header;
    ULONG       HeaderLen;

    ENTER_FUNCTION("RTP_CALL::StartIncomingCall");
    LOG((RTC_TRACE, "%s - enter", __fxName));
    
    m_Transport = Transport;

    hr = pSipMsg->GetSingleHeader(SIP_HEADER_TO, &Header, &HeaderLen);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s getting To header failed %x",
             __fxName, hr));
        return hr;
    }

    //hr = SetLocalAfterAddingTag(Header, HeaderLen);
    hr = SetLocalForIncomingCall(Header, HeaderLen);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s SetLocalForIncomingCall failed %x",
             __fxName, hr));
        return hr;
    }
    
    hr = pSipMsg->GetSingleHeader(SIP_HEADER_FROM, &Header, &HeaderLen);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s getting From header failed %x",
             __fxName, hr));
        return hr;
    }
    
    //hr = SIP_MSG_PROCESSOR::SetRemote(Header, HeaderLen);
    hr = SetRemoteForIncomingSession(Header, HeaderLen);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s SetRemoteForIncomingSession failed %x",
             __fxName, hr));
        return hr;
    }
    
    hr = pSipMsg->GetSingleHeader(SIP_HEADER_CALL_ID, &Header, &HeaderLen);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s getting Call-ID header failed %x",
             __fxName, hr));
        return hr;
    }

    hr = SetCallId(Header, HeaderLen);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s SetCallId failed %x",
             __fxName, hr));
        return hr;
    }
    
//      hr = ProcessContactHeader(pSipMsg);
//      if (hr != S_OK)
//      {
//          LOG((RTC_ERROR, "%s ProcessContactHeader failed %x",
//               __fxName, hr));
//          return hr;
//      }

    hr = CreateIncomingInviteTransaction(pSipMsg, pResponseSocket, TRUE);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s CreateIncomingInviteTransaction failed %x",
             __fxName, hr));
        return hr;
    }

    // XXX Should we try to use the response socket even if we get a
    // Contact/Record-Route header in the INVITE instead of trying to
    // establish a new TCP connection ?
    if (Transport != SIP_TRANSPORT_UDP &&
        m_pRequestSocket == NULL)
    {
        hr = SetRequestSocketForIncomingSession(pResponseSocket);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR,
                 "%s SetRequestSocketForIncomingSession failed %x",
                 __fxName, hr));
            return hr;
        }
    }
    
    // Notify the user about the incoming call
    // and wait for Accept()/Reject() to be called.
    m_State = SIP_CALL_STATE_OFFERING;

    if (m_pSipStack->AllowIncomingCalls())
    {
        hr = OfferCall();
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s OfferCall failed %x",
                 __fxName, hr));
            return hr;
        }

        // Note that if we already sent the final response,
        // m_pIncomingInviteTransaction is NULL (i.e. we are done with
        // the processing of this INVITE transaction). Also it is not
        // possible that another incoming INVITE transaction has been
        // created before this call returns.
        if (m_pIncomingInviteTransaction)
        {
            hr = m_pIncomingInviteTransaction->Send180IfNeeded();
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s Send180IfNeeded failed %x",
                     __fxName, hr));
                return hr;
            }
        }
    }
    else
    {
        hr = Reject(603);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s Reject failed %x",
                 __fxName, hr));
            return hr;
        }
    }

    return S_OK;
}


HRESULT
RTP_CALL::SetRequestURIRemoteAndRequestDestination(
    IN  LPCOLESTR  wsDestURI
    )
{
    HRESULT       hr;

    ENTER_FUNCTION("RTP_CALL::SetRequestURIRemoteAndRequestDestination");
    
    if (wcsncmp(wsDestURI, L"sip:", 4) == 0)
    {
        // SIP URL
        
        PSTR    szSipUrl;
        ULONG   SipUrlLen;
        SIP_URL DecodedSipUrl;
        ULONG   BytesParsed = 0;

        hr = UnicodeToUTF8(wsDestURI, &szSipUrl, &SipUrlLen);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s UnicodeToUTF8(sipurl) failed %x",
                 __fxName, hr));
            return hr;
        }

        hr = ParseSipUrl(szSipUrl, SipUrlLen, &BytesParsed, &DecodedSipUrl);

        free(szSipUrl);
        
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s ParseSipUrl failed %x",
                 __fxName, hr));
            return hr;
        }

        hr = SIP_MSG_PROCESSOR::SetRequestURI(&DecodedSipUrl);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s SetRequestURI failed %x",
                 __fxName, hr));
            return hr;
        }

        if (DecodedSipUrl.m_TransportParam == SIP_TRANSPORT_UNKNOWN)
        {
            LOG((RTC_ERROR, "%s Unknown transport specified in SIP URL",
                 __fxName));
            return RTC_E_SIP_TRANSPORT_NOT_SUPPORTED;
        }
        
        // if maddr param is present - this should be the request destination.
        // if provider is not present - resolve the SIP URL.
        if (DecodedSipUrl.m_KnownParams[SIP_URL_PARAM_MADDR].Length != 0 ||
            IsEqualGUID(m_ProviderGuid, GUID_NULL))
        {
            hr = ResolveSipUrlAndSetRequestDestination(&DecodedSipUrl, TRUE,
                                                       FALSE, FALSE, TRUE);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s ResolveSipUrlAndSetRequestDestination failed %x",
                     __fxName, hr));
                return hr;
            }
        }
        else
        {
            // Set the request destination to the proxy.
            hr = ResolveProxyAddressAndSetRequestDestination();
            if (hr != S_OK)
            {
                LOG((RTC_ERROR,
                     "%s ResolveProxyAddressAndSetRequestDestination failed : %x",
                     __fxName, hr));
                return hr;
            }
        }
    }
    else
    {
        // Phone number.
        
        if (m_ProxyAddress != NULL)
        {
            // Set RequestURI to sip:phoneno@proxy;user=phone
            // and Remote to <sip:phoneno@proxy;user=phone>
            
            int              RequestURIValueLen;
            int              RequestURIBufLen;
            
            RequestURIBufLen = 4 + wcslen(wsDestURI) + 1
                + strlen(m_ProxyAddress) + 15;
            
            m_RequestURI = (PSTR) malloc(RequestURIBufLen);
            if (m_RequestURI == NULL)
            {
                LOG((RTC_TRACE, "%s allocating m_RequestURI failed", __fxName));
                return E_OUTOFMEMORY;
            }
            
            RequestURIValueLen = _snprintf(m_RequestURI, RequestURIBufLen,
                                           "sip:%ls@%s;user=phone",
                                           wsDestURI,
                                           //RemoveVisualSeparatorsFromPhoneNo((LPWSTR) wsDestURI),
                                           m_ProxyAddress);
            if (RequestURIValueLen < 0)
            {
                LOG((RTC_ERROR, "%s _snprintf failed", __fxName));
                return E_FAIL;
            }

            m_RequestURILen = RequestURIValueLen;

            hr = ResolveProxyAddressAndSetRequestDestination();
            if (hr != S_OK)
            {
                LOG((RTC_ERROR,
                     "%s ResolveProxyAddressAndSetRequestDestination failed : %x",
                     __fxName, hr));
                return hr;
            }
        }
        else
        {
            LOG((RTC_ERROR, "%s No proxy address specified for phone call",
                 __fxName));
            return E_FAIL;
        }
    }

    LOG((RTC_TRACE,
         "%s - call set RequestURI to : %s", __fxName, m_RequestURI));

    hr = SetRemoteForOutgoingCall(m_RequestURI, m_RequestURILen);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s SetRemoteForOutgoingCall failed %x",
             __fxName, hr));
        return hr;
    }
    
    LOG((RTC_TRACE,
         "%s - call set Remote to : %s", __fxName, m_Remote));

    return S_OK;
}

    
HRESULT
RTP_CALL::CreateIncomingTransaction(
    IN  SIP_MESSAGE  *pSipMsg,
    IN  ASYNC_SOCKET *pResponseSocket
    )
{
    HRESULT hr;

    ENTER_FUNCTION("RTP_CALL::CreateIncomingTransaction");
    
    switch(pSipMsg->GetMethodId())
    {
    case SIP_METHOD_INVITE:
        hr = CreateIncomingInviteTransaction(pSipMsg, pResponseSocket);
        if (hr != S_OK)
            return hr;
        break;
        
    case SIP_METHOD_BYE:
        hr = CreateIncomingByeTransaction(pSipMsg, pResponseSocket);
        if (hr != S_OK)
            return hr;
        break;
        
    case SIP_METHOD_CANCEL:
        hr = CreateIncomingCancelTransaction(pSipMsg, pResponseSocket);
        if (hr != S_OK)
            return hr;
        break;
        
    case SIP_METHOD_OPTIONS:
        LOG((RTC_TRACE,
            "RTPCALL:: CreateIncomingTransaction Recieved Options"));
        hr = m_pSipStack->CreateIncomingOptionsCall(pResponseSocket->GetTransport(), pSipMsg, pResponseSocket);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "CreateIncomingOptionsTansaction failed hr = 0x%x", hr));
            return hr;
        }
        break;
        
    case SIP_METHOD_ACK:
        break;
        
    default:
        hr = CreateIncomingReqFailTransaction(pSipMsg, pResponseSocket, 405);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s  Creating reqfail transaction failed %x",
                 __fxName, hr));
            return hr;
        }
        break;
    }
    
    return S_OK;
}


HRESULT
RTP_CALL::CreateIncomingInviteTransaction(
    IN SIP_MESSAGE  *pSipMsg,
    IN ASYNC_SOCKET *pResponseSocket,
    IN BOOL          IsFirstInvite   // = FALSE
    )
{
    HRESULT         hr;

    LOG((RTC_TRACE, "CreateIncomingInviteTransaction()"));

    INCOMING_INVITE_TRANSACTION *pIncomingInviteTransaction
        = new INCOMING_INVITE_TRANSACTION(this,
                                          pSipMsg->GetMethodId(),
                                          pSipMsg->GetCSeq(),
                                          IsFirstInvite);
    if (pIncomingInviteTransaction == NULL)
        return E_OUTOFMEMORY;

    hr = pIncomingInviteTransaction->SetResponseSocketAndVia(
             pSipMsg, pResponseSocket);
    if (hr != S_OK)
    {
        pIncomingInviteTransaction->OnTransactionDone();
        return hr;
    }
    
    hr = pIncomingInviteTransaction->ProcessRequest(pSipMsg, pResponseSocket);
    if (hr != S_OK)
    {
        // We shouldn't delete the transaction here.
        // If the media processing fails we send a 488 and wait for the ACK.
        // The transaction will delete itself once it is done.
        return hr;
    }
    
    return S_OK;
}


HRESULT
RTP_CALL::OfferCall()
{
    SIP_PARTY_INFO  CallerInfo;
    OFFSET_STRING   DisplayName;
    OFFSET_STRING   AddrSpec;
    OFFSET_STRING   Params;
    ULONG           BytesParsed = 0;
    HRESULT         hr;

    ENTER_FUNCTION("RTP_CALL::OfferCall");
    
    CallerInfo.PartyContactInfo = NULL;

    hr = ParseNameAddrOrAddrSpec(m_Remote, m_RemoteLen, &BytesParsed,
                                 '\0', // no header list separator
                                 &DisplayName, &AddrSpec);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - ParseNameAddrOrAddrSpec failed %x",
             __fxName, hr));
        return hr;
    }

    LOG((RTC_TRACE, "%s - Incoming Call from Display Name: %.*s  URI: %.*s",
         __fxName,
         DisplayName.GetLength(),
         DisplayName.GetString(m_Remote),
         AddrSpec.GetLength(),
         AddrSpec.GetString(m_Remote)
         )); 
    CallerInfo.DisplayName = NULL;
    CallerInfo.URI         = NULL;

    if (DisplayName.GetLength() != 0)
    {
        hr = UTF8ToUnicode(DisplayName.GetString(m_Remote),
                           DisplayName.GetLength(),
                           &CallerInfo.DisplayName
                           );
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s - UTF8ToUnicode(DisplayName) failed %x",
                 __fxName, hr));
            return hr;
        }
    }
        
    if (AddrSpec.GetLength() != 0)
    {
        hr = UTF8ToUnicode(AddrSpec.GetString(m_Remote),
                           AddrSpec.GetLength(),
                           &CallerInfo.URI
                           );
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s - UTF8ToUnicode(AddrSpec) failed %x",
                 __fxName, hr));
            free(CallerInfo.DisplayName);
            return hr;
        }
    }
        
    CallerInfo.State = SIP_PARTY_STATE_CONNECTING;
        
    m_pSipStack->OfferCall(this, &CallerInfo);

    free(CallerInfo.DisplayName);
    free(CallerInfo.URI);
    return S_OK;
}


HRESULT
RTP_CALL::CreateStreamsInPreference()
{
    ENTER_FUNCTION("SIP_CALL::CreateStreamsInPreference");

    HRESULT hr = S_OK;
    DWORD   Preference;

    DWORD   RemoteIp = ntohl(m_RequestDestAddr.sin_addr.s_addr);
    // ASSERT(RemoteIp != 0);
    if (RemoteIp == 0)
    {
        // This could happen if the first incoming INVITE has no
        // Record-Route/Contact header and it also doesn't have the
        // address in the From header.
        LOG((RTC_ERROR, "%s - RequestDestAddr is 0 - this shouldn't happen",
             __fxName));
        return RTC_E_SIP_REQUEST_DESTINATION_ADDR_NOT_PRESENT;
    }
    
    IRTCMediaManage *pMediaManager = GetMediaManager();

    ASSERT(pMediaManager != NULL);

    hr = pMediaManager->GetPreference(&Preference);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s: GetPreference failed %x", __fxName, hr));
        goto error;
    }

    // Outgoing streams
    
    if (Preference & RTC_MP_AUDIO_CAPTURE)
    {
        LOG((RTC_TRACE, "%s Before addstream audio capture ", __fxName));

        hr = pMediaManager->AddStream(RTC_MT_AUDIO, RTC_MD_CAPTURE,
                                      RemoteIp);

        LOG((RTC_TRACE, "%s After addstream audio capture ", __fxName));

        if (hr != S_OK)
        {
            LOG((RTC_WARN, "%s: AddStream Audio Capture failed %x",
                 __fxName, hr));
        }
    }
    
    if (Preference & RTC_MP_VIDEO_CAPTURE)
    {
        LOG((RTC_TRACE, "%s Before addstream video capture ", __fxName));

        hr = pMediaManager->AddStream(RTC_MT_VIDEO, RTC_MD_CAPTURE,
                                      RemoteIp);

        LOG((RTC_TRACE, "%s After addstream video capture ", __fxName));

        if (hr != S_OK)
        {
            LOG((RTC_WARN, "%s: AddStream Video Capture failed %x",
                 __fxName, hr));
        }
    }

    // Incoming streams
    
    if (Preference & RTC_MP_AUDIO_RENDER)
    {
        LOG((RTC_TRACE, "%s before addstream audio render ", __fxName));

        hr = pMediaManager->AddStream(RTC_MT_AUDIO, RTC_MD_RENDER,
                                      RemoteIp);

        LOG((RTC_TRACE, "%s after addstream audio render ", __fxName));

        if (hr != S_OK)
        {
            LOG((RTC_WARN, "%s: AddStream Audio Render failed %x",
                 __fxName, hr));
        }
        else
        {
            LOG((RTC_TRACE, "%s Before startstream audio render ", __fxName));

            hr = pMediaManager->StartStream(RTC_MT_AUDIO, RTC_MD_RENDER);

            LOG((RTC_TRACE, "%s after startstream audio render ", __fxName));

            if (hr != S_OK)
            {
                LOG((RTC_WARN, "%s: StartStream Audio Render failed %x",
                     __fxName, hr));
                hr = pMediaManager->RemoveStream(RTC_MT_AUDIO, RTC_MD_RENDER);
                if (hr != S_OK)
                {
                    LOG((RTC_ERROR, "%s: RemoveStream audio render  failed %x",
                         __fxName, hr));
                    goto error;
                }
            }
        }
    }
    
    if (Preference & RTC_MP_VIDEO_RENDER)
    {
        LOG((RTC_TRACE, "%s before addstream video render ", __fxName));

        hr = pMediaManager->AddStream(RTC_MT_VIDEO, RTC_MD_RENDER,
                                      RemoteIp);

        LOG((RTC_TRACE, "%s after addstream video render ", __fxName));

        if (hr != S_OK)
        {
            LOG((RTC_WARN, "%s: AddStream Video Render failed %x",
                 __fxName, hr));
        }
        else
        {
            LOG((RTC_TRACE, "%s before startstream video render ", __fxName));

            hr = pMediaManager->StartStream(RTC_MT_VIDEO, RTC_MD_RENDER);

            LOG((RTC_TRACE, "%s after startstream video render ", __fxName));

            if (hr != S_OK)
            {
                LOG((RTC_WARN, "%s: StartStream Video Render failed %x",
                     __fxName, hr));
                hr = pMediaManager->RemoveStream(RTC_MT_VIDEO, RTC_MD_RENDER);
                LOG((RTC_ERROR, "%s: RemoveStream Video Render failed %x",
                     __fxName, hr));
                goto error;
            }
        }
    }


    SetNeedToReinitializeMediaManager(TRUE);
    
    if (Preference & RTC_MP_DATA_SENDRECV)
    {
        LOG((RTC_TRACE, "%s before addstream Data ", __fxName));

        hr = pMediaManager->AddStream(RTC_MT_DATA, RTC_MD_CAPTURE,
                                  RemoteIp);

        LOG((RTC_TRACE, "%s after addstream Data ", __fxName));

        if (hr != S_OK)
        {
            LOG((RTC_WARN, "%s: AddStream Data failed %x",
                 __fxName, hr));
        }
    }

    LOG((RTC_TRACE, "%s succeeded", __fxName));
    return S_OK;

 error:
    pMediaManager->Reinitialize();
    return hr; 
}


// fNewSession is true only for the first INVITE
// of an incoming call (note that we validate only
// incoming SDP)
// IsFirstInvite is true if this is the first invite
// of an incoming or outgoing call.
HRESULT
RTP_CALL::ValidateSDPBlob(
    IN  PSTR        MsgBody,
    IN  ULONG       MsgBodyLen,
    IN  BOOL        fNewSession,
    IN  BOOL        IsFirstInvite,
    OUT IUnknown  **ppSession
    )
{
    HRESULT   hr;
    PSTR      szSDPBlob;
    IUnknown *pSession;
    DWORD     HasMedia;

    *ppSession = NULL;

    ENTER_FUNCTION("RTP_CALL::ValidateSDPBlob");

    hr = GetNullTerminatedString(MsgBody, MsgBodyLen, &szSDPBlob);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s GetNullTerminatedString failed",
             __fxName));
        return hr;
    }

    LOG((RTC_TRACE, "%s before ParseSDPBlob", __fxName));

    hr = GetMediaManager()->ParseSDPBlob(szSDPBlob, &pSession);

    LOG((RTC_TRACE, "%s after ParseSDPBlob", __fxName));

    free(szSDPBlob);

    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s ParseSDPBlob failed %x",
             __fxName, hr));
        return RTC_E_SDP_PARSE_FAILED;
    }

    LOG((RTC_TRACE, "%s before VerifySDPSession", __fxName));

    hr = GetMediaManager()->VerifySDPSession(pSession,
                                             fNewSession,
                                             &HasMedia);

    LOG((RTC_TRACE, "%s after VerifySDPSession", __fxName));

    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s TrySDPSession failed %x %d",
             __fxName, hr, HasMedia));
        pSession->Release();
        return hr;
    }
    else if (IsFirstInvite && HasMedia == 0)
    {
        LOG((RTC_ERROR,
             "%s TrySDPSession - no common media for 1st INVITE",
             __fxName, hr, HasMedia));
        pSession->Release();
        return RTC_E_SIP_CODECS_DO_NOT_MATCH;
    }

    *ppSession = pSession;
    return S_OK;
}


HRESULT
RTP_CALL::SetSDPBlob(
    IN PSTR   MsgBody,
    IN ULONG  MsgBodyLen,
    IN BOOL   IsFirstInvite
    )
{
    HRESULT   hr;
    IUnknown *pSession;

    ENTER_FUNCTION("RTP_CALL::SetSDPBlob");

    hr = ValidateSDPBlob(MsgBody, MsgBodyLen,
                         FALSE,
                         IsFirstInvite,
                         &pSession);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s ValidateSDPBlob failed %x",
             __fxName, hr));
        return hr;
    }

    LOG((RTC_TRACE, "%s before SetSDPSession", __fxName));

    hr = GetMediaManager()->SetSDPSession(pSession);

    LOG((RTC_TRACE, "%s after SetSDPSession", __fxName));

    pSession->Release();

    if (hr != S_OK && hr != RTC_E_SIP_NO_STREAM)
    {
        LOG((RTC_ERROR, "%s SetSDPSession failed %x",
             __fxName, hr));
        
        return hr;
    }
    else if (IsFirstInvite && hr == RTC_E_SIP_NO_STREAM)
    {
        LOG((RTC_ERROR,
             "%s SetSDPSession returned RTC_E_SIP_NO_STREAM for 1st INVITE",
             __fxName, hr));
        
        return hr;
    }

    // for reINVITEs RTC_E_SIP_NO_STREAM is okay
    
    return S_OK;
}


HRESULT
RTP_CALL::CleanupCallTypeSpecificState()
{
    HRESULT hr;

    ENTER_FUNCTION("RTP_CALL::CleanupCallTypeSpecificState");

    if (m_fNeedToReinitializeMediaManager)
    {
        LOG((RTC_TRACE, "%s calling MediaManager()->ReInitialize()", __fxName));
        
        // Cleanup media state
        hr = m_pSipStack->GetMediaManager()->Reinitialize();
        
        LOG((RTC_TRACE, "%s after Reinitialize", __fxName));
        
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s MediaManager ReInitialize failed %x",
                 __fxName, hr));
            return hr;
        }
    }
    else
    {
        LOG((RTC_TRACE, "%s - no need to reinitialize media manager",
             __fxName));
    }

    return S_OK;
}


HRESULT
RTP_CALL::GetAndStoreMsgBodyForInvite(
    IN  BOOL    IsFirstInvite,
    OUT PSTR   *pszMsgBody,
    OUT ULONG  *pMsgBodyLen
    )
{
    HRESULT hr;
    PSTR    MediaSDPBlob = NULL;

    ENTER_FUNCTION("RTP_CALL::GetAndStoreMsgBodyForInvite");
    
    // Create the streams if this is the first INVITE.
    if (IsFirstInvite)
    {
        hr = CreateStreamsInPreference();
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s: CreateStreamsInPreference failed %x",
                 __fxName, hr));
            return hr;
        }        
    }
    
    LOG((RTC_TRACE, "%s before GetSDPBlob", __fxName));

    hr = GetMediaManager()->GetSDPBlob(0, &MediaSDPBlob);

    LOG((RTC_TRACE, "%s after GetSDPBlob", __fxName));

    if (hr != S_OK && hr != RTC_E_SDP_NO_MEDIA)
    {
        LOG((RTC_ERROR, "%s: GetSDPBlob failed %x",
             __fxName, hr));
        return hr;
    }
    else if (hr == RTC_E_SDP_NO_MEDIA && IsFirstInvite)
    {
        LOG((RTC_ERROR,
             "%s: GetSDPBlob returned RTC_E_SDP_NO_MEDIA for 1st INVITE",
             __fxName));
        if (MediaSDPBlob != NULL)
            GetMediaManager()->FreeSDPBlob(MediaSDPBlob);
        return hr;
    }

    // For reINVITEs RTC_E_SDP_NO_MEDIA is fine.

    ASSERT(MediaSDPBlob != NULL);
    
    hr = AllocString(MediaSDPBlob, strlen(MediaSDPBlob),
                     pszMsgBody, pMsgBodyLen);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s GetNullTerminatedString failed %x",
             __fxName, hr));
        return hr;
    }

    GetMediaManager()->FreeSDPBlob(MediaSDPBlob);    
    return S_OK;
}


// PINT specific calls.
HRESULT 
RTP_CALL::HandleInviteRejected(
    IN SIP_MESSAGE *pSipMsg
    )
{
    // Do nothing.
    return S_OK;
}


STDMETHODIMP
RTP_CALL::AddParty(
    IN   SIP_PARTY_INFO *    PartyInfo
    )
{

    return E_NOTIMPL;
}


STDMETHODIMP
RTP_CALL::RemoveParty(
    IN   LPOLESTR            PartyURI
    )
{

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\sipcall.h ===
#ifndef __sipcli_sipcall_h__
#define __sipcli_sipcall_h__

#include "sipstack.h"
#include "asock.h"
#include "msgproc.h"

//XXX Get rid of INCOMING_TRANS_ACK_RCVD state
enum INCOMING_TRANSACTION_STATE
{
    INCOMING_TRANS_INIT = 0,
    INCOMING_TRANS_REQUEST_RCVD,
    INCOMING_TRANS_FINAL_RESPONSE_SENT,
    INCOMING_TRANS_ACK_RCVD
};


enum OUTGOING_TRANSACTION_STATE
{
    OUTGOING_TRANS_INIT = 0,
    OUTGOING_TRANS_REQUEST_SENT,
    OUTGOING_TRANS_PROVISIONAL_RESPONSE_RCVD,
    OUTGOING_TRANS_FINAL_RESPONSE_RCVD,
    OUTGOING_TRANS_ACK_SENT
};


void
RemoveEscapeChars(
    PSTR    pWordBuf,
    DWORD   dwLen
    );


class SIP_STACK;
class SIP_CALL;


///////////////////////////////////////////////////////////////////////////////
// SIP Transactions
///////////////////////////////////////////////////////////////////////////////


// INCOMING_TRANSACTION and OUTGOING_TRANSACTION
// should inherit from this class.
class __declspec(novtable) SIP_TRANSACTION :
    public TIMER,
    public ERROR_NOTIFICATION_INTERFACE
{
public:
    SIP_TRANSACTION(
        IN SIP_MSG_PROCESSOR    *pSipMsgProc,
        IN SIP_METHOD_ENUM       MethodId,
        IN ULONG                 CSeq,
        IN BOOL                  IsIncoming
        );
    virtual ~SIP_TRANSACTION();

    STDMETHODIMP_(ULONG) TransactionAddRef();
    STDMETHODIMP_(ULONG) TransactionRelease();

    VOID IncrementAsyncNotifyCount();
    VOID DecrementAsyncNotifyCount();
    inline ULONG GetAsyncNotifyCount();
    
    virtual VOID OnTransactionDone();
    
    inline BOOL IsTransactionDone();

    // The default implementation just deletes the transaction.
    // If something more needs to be done such as notifying the UI,
    // then the transaction needs to override this function.
    virtual VOID TerminateTransactionOnError(
        IN HRESULT      hr
        );

    inline ULONG GetCSeq();

    inline SIP_METHOD_ENUM GetMethodId();

    // Set to 'SPXN' in constructor
    ULONG                m_Signature;
    
    // Linked list for transactions in a Message processor
    // (m_IncomingTransactionList and m_OutgoingTransactionList)
    LIST_ENTRY           m_ListEntry;

protected:
    SIP_MSG_PROCESSOR   *m_pSipMsgProc;

    // Usually a transaction deletes itself depending on its
    // state machine.
    // This ref count is used in some special cases to keep
    // the transaction alive.
    // (currently only in ProcessAuthRequired - but could be used
    // in other cases as well)
    ULONG                m_RefCount;

    // Used to keep track of async notify operations to help with
    // shutdown.
    ULONG                m_AsyncNotifyCount;

    BOOL                 m_IsTransactionDone;
    
    ULONG                m_CSeq;
    SIP_METHOD_ENUM      m_MethodId;
    BOOL                 m_IsIncoming;
};

//////////// Incoming Transaction

class __declspec(novtable) INCOMING_TRANSACTION :
    public SIP_TRANSACTION,
    public CONNECT_COMPLETION_INTERFACE
{
public:
    INCOMING_TRANSACTION(
        IN SIP_MSG_PROCESSOR    *pSipMsgProc,
        IN SIP_METHOD_ENUM       MethodId,
        IN ULONG                 CSeq
        );

    virtual ~INCOMING_TRANSACTION();

    virtual VOID OnTransactionDone();
    
    // Callbacks
    void OnSocketError(
        IN DWORD ErrorCode
        );
    
    void OnConnectComplete(
        IN DWORD ErrorCode
        );
    
    HRESULT SetResponseSocketAndVia(
        IN SIP_MESSAGE  *pSipMsg,
        IN ASYNC_SOCKET *pResponseSocket
        );
    
    virtual HRESULT ProcessRequest(
        IN SIP_MESSAGE  *pSipMsg,
        IN ASYNC_SOCKET *pResponseSocket
        ) = 0;

    virtual HRESULT TerminateTransactionOnByeOrCancel(
        OUT BOOL *pCallDisconnected
        ) = 0;
    
    HRESULT CreateResponseMsg(
        IN  ULONG           StatusCode,
        IN  PSTR            ReasonPhrase,
        IN  ULONG           ReasonPhraseLen,
        IN  PSTR            MethodStr,
        IN  BOOL            fAddContactHeader,
        IN  PSTR            MsgBody,
        IN  ULONG           MsgBodyLen,
        IN  PSTR            ContentType,
        IN  ULONG           ContentTypeLen, 
        OUT SEND_BUFFER   **ppResponseBuffer,
        IN  SIP_HEADER_ARRAY_ELEMENT   *pAdditionalHeaderArray = NULL,
        IN  ULONG           AdditionalHeaderCount = 0
        );
    
    HRESULT CreateAndSendResponseMsg(
        IN  ULONG    StatusCode,
        IN  PSTR     ReasonPhrase,
        IN  ULONG    ReasonPhraseLen,
        IN  PSTR     MethodStr,
        IN  BOOL     fAddContactHeader,
        IN  PSTR     MsgBody,
        IN  ULONG    MsgBodyLen,
        IN  PSTR     ContentType,
        IN  ULONG    ContentTypeLen, 
        IN  SIP_HEADER_ARRAY_ELEMENT   *pAdditionalHeaderArray = NULL,
        IN  ULONG    AdditionalHeaderCount = 0
        );

protected:
    INCOMING_TRANSACTION_STATE   m_State;

    // This is where the response is to be sent.
    ASYNC_SOCKET                *m_pResponseSocket;
    SOCKADDR_IN                  m_ResponseDestAddr;
    BOOL                         m_IsDestExternalToNat;

    // Via sent in the response.
    COUNTED_STRING              *m_ViaHeaderArray;
    ULONG                        m_NumViaHeaders;

    // Cached request buffer for retransmits
    SEND_BUFFER                 *m_pResponseBuffer;

    // Record-Route headers from request.
    // This will be sent in the final response.
    // Linked list of RECORD_ROUTE_HEADER structures.
    LIST_ENTRY                   m_RecordRouteHeaderList;

    HRESULT ProcessRecordRouteContactAndFromHeadersInRequest(
        IN SIP_MESSAGE *pSipMsg
        );

    VOID ReleaseResponseSocket();
    
    VOID FreeRecordRouteHeaderList();

    HRESULT AppendContactHeaderToResponse(
        IN      PSTR            Buffer,
        IN      ULONG           BufLen,
        IN OUT  ULONG          *pBytesFilled
        );
};


//////////// Outgoing Transaction

class __declspec(novtable) OUTGOING_TRANSACTION :
    public SIP_TRANSACTION
{
public:

    OUTGOING_TRANSACTION(
        IN SIP_MSG_PROCESSOR    *pSipMsgProc,
        IN SIP_METHOD_ENUM       MethodId,
        IN ULONG                 CSeq,
        IN BOOL                  AuthHeaderSent
        );
    
    virtual ~OUTGOING_TRANSACTION();
    
    void OnSocketError(
        IN DWORD ErrorCode
        );

    HRESULT CheckRequestSocketAndSendRequestMsgAfterConnectComplete();

    HRESULT CheckRequestSocketAndSendRequestMsg(
        IN  ULONG                       RequestTimerValue,
        IN  SIP_HEADER_ARRAY_ELEMENT   *AdditionalHeaderArray,
        IN  ULONG                       AdditionalHeaderCount,
        IN  PSTR                        MsgBody,
        IN  ULONG                       MsgBodyLen,
        IN  PSTR                        ContentType,
        IN  ULONG                       ContentTypeLen
        );

    HRESULT CheckRequestSocketAndRetransmitRequestMsg();

    HRESULT CreateAndSendRequestMsg(
        IN  ULONG                       TimerValue,
        IN  SIP_HEADER_ARRAY_ELEMENT   *AdditionalHeaderArray,
        IN  ULONG                       AdditionalHeaderCount,
        IN  PSTR                        MsgBody,
        IN  ULONG                       MsgBodyLen,
        IN  PSTR                        ContentType,
        IN  ULONG                       ContentTypeLen
        );
    
    HRESULT RetransmitRequest();

//      void OnSendComplete(
//          IN  DWORD Error
//          );
    
    virtual HRESULT ProcessResponse(
        IN SIP_MESSAGE *pSipMsg
        ) = 0;

    virtual VOID OnRequestSocketConnectComplete(
        IN DWORD        ErrorCode
        );

    // override this function if the request has a msg body.
    // The default has no message body.
    virtual HRESULT GetAndStoreMsgBodyForRequest();
    
    HRESULT StoreTimerAndAdditionalHeaders(
        IN  ULONG                       TimerValue,
        IN  SIP_HEADER_ARRAY_ELEMENT   *AdditionalHeaderArray,
        IN  ULONG                       AdditionalHeaderCount
        );
    
    HRESULT StoreMsgBodyAndContentType(
        IN PSTR     MsgBody,
        IN ULONG    MsgBodyLen,
        IN PSTR     ContentType,
        IN ULONG    ContentTypeLen
        );

    inline PSTR GetMsgBody();

    inline ULONG GetMsgBodyLen();

protected:
    ULONG                        m_NumRetries;
    ULONG                        m_TimerValue;
    OUTGOING_TRANSACTION_STATE   m_State;

    BOOL                         m_WaitingToSendRequest;
    
    // Cached response buffer for retransmits
    SEND_BUFFER                 *m_pRequestBuffer;

    // Keep track of whether we already sent the auth
    // header in the request.
    BOOL                         m_AuthHeaderSent;

    // Keep a copy of the additional headers if we are waiting
    // for connect completion to send the request.
    SIP_HEADER_ARRAY_ELEMENT    *m_AdditionalHeaderArray;
    ULONG                        m_AdditionalHeaderCount;
    
    // Keep a copy of the SDP Blob for sending in requests after 401/407
    PSTR                         m_szMsgBody;
    ULONG                        m_MsgBodyLen;

    // m_ContentType is allocated freed only in the MESSSAGE transaction.
    // For other transactions it is assigned to strings defined in sipdef.h
    PSTR                         m_ContentType;
    ULONG                        m_ContentTypeLen;
    BOOL                         m_isContentTypeMemoryAllocated;
    
    HRESULT ProcessAuthRequired(
        IN  SIP_MESSAGE              *pSipMsg,
        IN  BOOL                      fPopupCredentialsUI,  
        OUT SIP_HEADER_ARRAY_ELEMENT *pAuthHeaderElement,
        OUT SECURITY_CHALLENGE       *pAuthChallenge
        );

    HRESULT GetAuthChallenge(
        IN  SIP_HEADER_ENUM     SipHeaderId,
        IN  SIP_MESSAGE        *pSipMsg,
        OUT SECURITY_CHALLENGE *pAuthChallenge
        );
    
    HRESULT GetAuthChallengeForAuthProtocol(
        IN  SIP_HEADER_ENTRY   *pAuthHeaderList,
        IN  ULONG               NumHeaders,
        IN  SIP_MESSAGE        *pSipMsg,
        IN  SIP_AUTH_PROTOCOL   AuthProtocol,
        OUT SECURITY_CHALLENGE *pAuthChallenge
        );
    
    HRESULT SetDigestParameters(
        IN  SIP_AUTH_PROTOCOL  AuthProtocol,
        OUT SECURITY_PARAMETERS *pDigestParams
        );
    
    HRESULT FreeDigestParameters(
        IN  SECURITY_PARAMETERS *pDigestParams
        );
};


//////////// Invite Transactions

class INCOMING_INVITE_TRANSACTION : public INCOMING_TRANSACTION
{
public:
    INCOMING_INVITE_TRANSACTION(
        IN SIP_CALL        *pSipCall,
        IN SIP_METHOD_ENUM  MethodId,
        IN ULONG            CSeq,
        IN BOOL             IsFirstInvite
        );
    
    ~INCOMING_INVITE_TRANSACTION();
    
    HRESULT ProcessRequest(
        IN SIP_MESSAGE  *pSipMsg,
        IN ASYNC_SOCKET *pResponseSocket
        );

    HRESULT TerminateTransactionOnByeOrCancel(
        OUT BOOL *pCallDisconnected
        );
    
    VOID TerminateTransactionOnError(
        IN HRESULT      hr
        );

    HRESULT Accept();

    HRESULT Reject(
        IN ULONG StatusCode,
        IN PSTR  ReasonPhrase,
        IN ULONG ReasonPhraseLen
        );

    HRESULT Send180IfNeeded();
    
    VOID OnTimerExpire();

private:
    
    HRESULT ProcessInvite(
        IN SIP_MESSAGE  *pSipMsg,
        IN ASYNC_SOCKET *pResponseSocket
        );

    HRESULT ValidateAndStoreSDPInInvite(
        IN SIP_MESSAGE  *pSipMsg
        );
    
    HRESULT SetSDPSession();
    
    HRESULT ProcessAck(
        IN SIP_MESSAGE  *pSipMsg
        );

    HRESULT ProcessSDPInAck(
        IN SIP_MESSAGE  *pSipMsg
        );
    
    HRESULT Send200();
    
    HRESULT SendProvisionalResponse(
        IN ULONG StatusCode,
        IN PSTR  ReasonPhrase,
        IN ULONG ReasonPhraseLen
        );
    
    HRESULT RetransmitResponse();

    BOOL MaxRetransmitsDone();

    VOID DeleteTransactionAndTerminateCallIfFirstInvite(
        IN HRESULT TerminateStatusCode
        );
    
    SIP_CALL    *m_pSipCall;
    // Number of retries for sending the response (before we get an ACK).
    ULONG        m_NumRetries;
    ULONG        m_TimerValue;
    // Cached provisional response buffer for retransmits
    SEND_BUFFER *m_pProvResponseBuffer;
    // Is this the first INVITE transaction ?
    BOOL         m_IsFirstInvite;
    BOOL         m_InviteHasSDP;
    IUnknown    *m_pMediaSession;
};


class OUTGOING_INVITE_TRANSACTION : public OUTGOING_TRANSACTION
{
public:
    OUTGOING_INVITE_TRANSACTION(
        IN SIP_CALL        *pSipCall,
        IN SIP_METHOD_ENUM  MethodId,
        IN ULONG            CSeq,
        IN BOOL             AuthHeaderSent,
        IN BOOL             IsFirstInvite,
        IN BOOL             fNeedToNotifyCore,
        IN LONG             Cookie    
        );
    
    ~OUTGOING_INVITE_TRANSACTION();
    
    HRESULT ProcessResponse(
        IN SIP_MESSAGE  *pSipMsg
        );

    VOID OnTimerExpire();

    VOID OnRequestSocketConnectComplete(
        IN DWORD        ErrorCode
        );
    
    VOID TerminateTransactionOnError(
        IN HRESULT      hr
        );

    HRESULT GetAndStoreMsgBodyForRequest();
    
private:    
    HRESULT ProcessProvisionalResponse(
        IN SIP_MESSAGE *pSipMsg
        );

    HRESULT ProcessFinalResponse(
        IN SIP_MESSAGE *pSipMsg
        );

    HRESULT Process200(
        IN SIP_MESSAGE *pSipMsg
        );

    HRESULT ProcessRedirectResponse(
        IN SIP_MESSAGE *pSipMsg
        );

    HRESULT ProcessAuthRequiredResponse(
        IN SIP_MESSAGE *pSipMsg,
        OUT BOOL        &fDelete
        );

    HRESULT ProcessFailureResponse(
        IN SIP_MESSAGE *pSipMsg
        );

    HRESULT ProcessSDPInResponse(
        IN SIP_MESSAGE  *pSipMsg,
        IN BOOL          fIsFinalResponse
        );

    HRESULT CreateAndSendACK(
        IN  PSTR  ToHeader,
        IN  ULONG ToHeaderLen
        );
    
    BOOL MaxRetransmitsDone();
    
    VOID DeleteTransactionAndTerminateCallIfFirstInvite(
        IN HRESULT TerminateStatusCode
        );
    
    VOID NotifyStartOrStopStreamCompletion(
        IN HRESULT        StatusCode = 0,
        IN PSTR           ReasonPhrase = NULL,
        IN ULONG          ReasonPhraseLen = 0
        );
    
    SIP_CALL                    *m_pSipCall;

    // This is the socket used to send the ACK
    // (including any retransmits)
//      ASYNC_SOCKET                *m_pAckSocket;

    BOOL                         m_WaitingToSendAck;
    
    // Cached ACK buffer for retransmits
    SEND_BUFFER                 *m_pAckBuffer;

    // To header to be sent in ACK in the case of non-200 final responses.
    PSTR                         m_AckToHeader;
    ULONG                        m_AckToHeaderLen;
    
    // Is this the first INVITE transaction ?
    BOOL                         m_IsFirstInvite;

    // Used for Start/StopStream completion for RTP_CALLs
    BOOL                         m_fNeedToNotifyCore;
    LONG                         m_Cookie;
};



//////////// Bye/Cancel Transactions

class INCOMING_BYE_CANCEL_TRANSACTION : public INCOMING_TRANSACTION
{
public:
    INCOMING_BYE_CANCEL_TRANSACTION(
        IN SIP_CALL        *pSipCall,
        IN SIP_METHOD_ENUM  MethodId,
        IN ULONG            CSeq
        );
    
    HRESULT ProcessRequest(
        IN SIP_MESSAGE  *pSipMsg,
        IN ASYNC_SOCKET *pResponseSocket
        );

    HRESULT TerminateTransactionOnByeOrCancel(
        OUT BOOL *pCallDisconnected
        );
    
    HRESULT SendResponse(
        IN ULONG StatusCode,
        IN PSTR  ReasonPhrase,
        IN ULONG ReasonPhraseLen
        );

    VOID OnTimerExpire();

    HRESULT RetransmitResponse();

private:
    SIP_CALL   *m_pSipCall;
};


class OUTGOING_BYE_CANCEL_TRANSACTION : public OUTGOING_TRANSACTION
{
public:
    OUTGOING_BYE_CANCEL_TRANSACTION(
        SIP_CALL        *pSipCall,
        SIP_METHOD_ENUM  MethodId,
        ULONG            CSeq,
        IN BOOL          AuthHeaderSent
        );
    
    HRESULT ProcessResponse(
        IN SIP_MESSAGE  *pSipMsg
        );

    VOID OnTimerExpire();

private:    
    HRESULT ProcessProvisionalResponse(
        IN SIP_MESSAGE *pSipMsg
        );

    HRESULT ProcessFinalResponse(
        IN SIP_MESSAGE *pSipMsg
        );

    HRESULT ProcessAuthRequiredResponse(
        IN SIP_MESSAGE *pSipMsg,
        OUT BOOL        &fDelete
        );
    
    BOOL MaxRetransmitsDone();
    

    SIP_CALL    *m_pSipCall;
};



///////////////////////////////////////////////////////////////////////////////
// REDIRECT_CONTEXT
///////////////////////////////////////////////////////////////////////////////


class REDIRECT_CONTEXT
    : public ISipRedirectContext
{
public:

    REDIRECT_CONTEXT();
    ~REDIRECT_CONTEXT();
    
    // IUnknown for ISipCall
    STDMETHODIMP_(ULONG) AddRef();

    STDMETHODIMP_(ULONG) Release();

    STDMETHODIMP QueryInterface(
        IN  REFIID riid,
        OUT LPVOID *ppv
        );

    // ISipRedirectContext
    STDMETHODIMP GetSipUrlAndDisplayName(
        OUT  BSTR  *pbstrSipUrl,
        OUT  BSTR  *pbstrDisplayName
        );

    STDMETHODIMP Advance();

    HRESULT AppendContactHeaders(
        IN SIP_MESSAGE *pSipMsg
        );

private:

    ULONG           m_RefCount;

    // List of Contact entries in the redirect response
    LIST_ENTRY      m_ContactList;

    // Current Contact in m_ContactList
    LIST_ENTRY     *m_pCurrentContact;

    HRESULT UpdateContactList(
        IN LIST_ENTRY *pNewContactList
        );    
};


///////////////////////////////////////////////////////////////////////////////
// SIP Call
///////////////////////////////////////////////////////////////////////////////


// Stores the context associated with a SIP call.
// It consists of multiple incoming and outgoing transactions.

class __declspec(novtable) SIP_CALL
    : public ISipCall,
      public SIP_MSG_PROCESSOR
{
    
public:

    SIP_CALL(
        IN  SIP_PROVIDER_ID   *pProviderId,
        IN  SIP_CALL_TYPE      CallType,
        IN  SIP_STACK         *pSipStack,
        IN  REDIRECT_CONTEXT  *pRedirectContext
        );
    
    ~SIP_CALL();
    
    // QueryInterface for ISipCall
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP QueryInterface(
        IN  REFIID riid,
        OUT LPVOID *ppv
        );
    
    // ISipCall
    STDMETHODIMP SetNotifyInterface(
        IN   ISipCallNotify *    NotifyInterface
        );

    STDMETHODIMP Disconnect();

    // methods implemented by RTP_CALL and PINT_CALL
    
    virtual HRESULT CleanupCallTypeSpecificState() = 0;

    virtual HRESULT GetAndStoreMsgBodyForInvite(
        IN  BOOL    IsFirstInvite,
        OUT PSTR   *pszMsgBody,
        OUT ULONG  *pMsgBodyLen
        ) = 0;

    inline SIP_CALL_TYPE GetCallType();

    inline SIP_CALL_STATE GetCallState();
    
    inline VOID SetCallState(
        IN SIP_CALL_STATE CallState
        );

    inline BOOL IsCallDisconnected();
    inline BOOL IsSessionDisconnected();

    inline INCOMING_INVITE_TRANSACTION *GetIncomingInviteTransaction();
    
    inline OUTGOING_INVITE_TRANSACTION *GetOutgoingInviteTransaction();
    
    inline VOID SetIncomingInviteTransaction(
        IN INCOMING_INVITE_TRANSACTION *pIncomingInviteTransaction
        );

    inline VOID SetOutgoingInviteTransaction(
        IN OUTGOING_INVITE_TRANSACTION *pOutgoingInviteTransaction
        );
    
    inline BOOL ProcessingInviteTransaction();

    inline STDMETHODIMP SetNeedToReinitializeMediaManager(
        IN BOOL BoolValue
        );

    VOID OnIncomingInviteTransactionDone(
        IN INCOMING_INVITE_TRANSACTION *pIncomingInviteTransaction
        );
    
//      VOID OnOutgoingInviteTransactionDone(
//          IN OUTGOING_INVITE_TRANSACTION *pOutgoingInviteTransaction
//          );
    
    HRESULT CreateOutgoingInviteTransaction(
        IN  BOOL                        AuthHeaderSent,
        IN  BOOL                        IsFirstInvite,
        IN  SIP_HEADER_ARRAY_ELEMENT   *AdditionalHeaderArray,
        IN  ULONG                       AdditionalHeaderCount,
        IN  PSTR                        SDPBlob,
        IN  ULONG                       SDPBlobLen,
        IN  BOOL                        fNeedToNotifyCore,
        IN  LONG                        Cookie
        );

    HRESULT CreateOutgoingByeTransaction(
        IN  BOOL                        AuthHeaderSent,
        IN  SIP_HEADER_ARRAY_ELEMENT   *AdditionalHeaderArray,
        IN  ULONG                       AdditionalHeaderCount
        );

    VOID NotifyCallStateChange(
        IN SIP_CALL_STATE CallState,
        IN HRESULT        StatusCode = 0,
        IN PSTR           ReasonPhrase = NULL,
        IN ULONG          ReasonPhraseLen = 0
        );

    VOID OnError();
    
    VOID InitiateCallTerminationOnError(
        IN HRESULT StatusCode = 0
        );

    virtual HRESULT HandleInviteRejected(
        IN SIP_MESSAGE *pSipMsg 
        ) = 0;

    virtual VOID ProcessPendingInvites() = 0;

    HRESULT ProcessRedirect(
        IN SIP_MESSAGE *pSipMsg
        );

    HRESULT OnIpAddressChange();
    
protected:

    // Set to 'SPCL' in constructor
    ULONG                   m_Signature;
    
    // RTP / PINT
    SIP_CALL_TYPE           m_CallType;
    
    SIP_CALL_STATE          m_State;

    ISipCallNotify         *m_pNotifyInterface;

    BOOL                   m_fNeedToReinitializeMediaManager;

    //local phone number for a PINT call
    PSTR                    m_LocalPhoneURI; 
    DWORD                   m_LocalPhoneURILen;

    // Invite Requests we are currently processing.
    // We could have only one INVITE transaction at any point of time.
    INCOMING_INVITE_TRANSACTION *m_pIncomingInviteTransaction;
    OUTGOING_INVITE_TRANSACTION *m_pOutgoingInviteTransaction;

    CHAR                    m_LocalHostName[ MAX_COMPUTERNAME_LENGTH + 1 ];
    DWORD                   m_LocalHostNameLen;

    BOOL                    m_fSubscribeEnabled;

    LIST_ENTRY              m_PartyInfoList;
    DWORD                   m_PartyInfoListLen;

    HRESULT CreateIncomingByeTransaction(
        IN  SIP_MESSAGE *pSipMsg,
        IN ASYNC_SOCKET *pResponseSocket
        );
    
    HRESULT CreateIncomingCancelTransaction(
        IN  SIP_MESSAGE *pSipMsg,
        IN ASYNC_SOCKET *pResponseSocket
        );
    
    HRESULT CancelAllTransactions();
    
    HRESULT CancelIncomingTransaction(
        IN  ULONG  CSeq,
        OUT BOOL  *pCallDisconnected    
        );

};


struct STREAM_QUEUE_ENTRY
{
    RTC_MEDIA_TYPE          MediaType;
    RTC_MEDIA_DIRECTION     Direction;
    BOOL                    fStartStream;
    LONG                    Cookie;
};


class RTP_CALL : public SIP_CALL
{
public:

    RTP_CALL(
        IN  SIP_PROVIDER_ID   *pProviderId,
        IN  SIP_STACK         *pSipStack,
        IN  REDIRECT_CONTEXT  *pRedirectContext
        );

    ~RTP_CALL();

    STDMETHODIMP Connect(
        IN   LPCOLESTR       LocalDisplayName,
        IN   LPCOLESTR       LocalUserURI,
        IN   LPCOLESTR       RemoteUserURI,
        IN   LPCOLESTR       LocalPhoneURI
        );

    STDMETHODIMP Accept();

    STDMETHODIMP Reject(
        IN SIP_STATUS_CODE StatusCode
        );

    STDMETHODIMP AddParty(
        IN   SIP_PARTY_INFO *pPartyInfo
        );

    STDMETHODIMP RemoveParty(
        IN   LPOLESTR  PartyURI
        );

    STDMETHODIMP StartStream(
        IN RTC_MEDIA_TYPE       MediaType,
        IN RTC_MEDIA_DIRECTION  Direction,
        IN LONG                 Cookie
        );
                     
    STDMETHODIMP StopStream(
        IN RTC_MEDIA_TYPE       MediaType,
        IN RTC_MEDIA_DIRECTION  Direction,
        IN LONG                 Cookie
        );
                     
    VOID NotifyStartOrStopStreamCompletion(
        IN LONG           Cookie,
        IN HRESULT        StatusCode = 0,
        IN PSTR           ReasonPhrase = NULL,
        IN ULONG          ReasonPhraseLen = 0
        );
    
//      HRESULT StartOutgoingCall();
    
    HRESULT StartIncomingCall(
        IN  SIP_TRANSPORT   Transport,
        IN  SIP_MESSAGE    *pSipMsg,
        IN  ASYNC_SOCKET   *pResponseSocket
        );
    
    HRESULT CreateStreamsInPreference();

    inline IRTCMediaManage *GetMediaManager();
    
    HRESULT ValidateSDPBlob(
        IN  PSTR        MsgBody,
        IN  ULONG       MsgBodyLen,
        IN  BOOL        fNewSession,
        IN  BOOL        IsFirstInvite,
        OUT IUnknown  **ppSession
        );
    
    HRESULT SetSDPBlob(
        IN PSTR   MsgBody,
        IN ULONG  MsgBodyLen,
        IN BOOL   IsFirstInvite
        );
    
    HRESULT HandleInviteRejected(
        IN SIP_MESSAGE *pSipMsg 
        );

    VOID ProcessPendingInvites();

private:

    STREAM_QUEUE_ENTRY  m_StreamStartStopQueue[6];
    ULONG               m_NumStreamQueueEntries;

    HRESULT OfferCall();
    
    HRESULT CleanupCallTypeSpecificState();
    
    HRESULT GetAndStoreMsgBodyForInvite(
        IN  BOOL    IsFirstInvite,
        OUT PSTR   *pszMsgBody,
        OUT ULONG  *pMsgBodyLen
        );

    HRESULT CreateIncomingTransaction(
        IN  SIP_MESSAGE *pSipMsg,
        IN ASYNC_SOCKET *pResponseSocket
        );

    HRESULT CreateIncomingInviteTransaction(
        IN  SIP_MESSAGE *pSipMsg,
        IN ASYNC_SOCKET *pResponseSocket,
        IN BOOL          IsFirstInvite = FALSE
        );

    HRESULT SetRequestURIRemoteAndRequestDestination(
        IN  LPCOLESTR  RemoteURI
        );
    
    HRESULT StartStreamHelperFn(
        IN RTC_MEDIA_TYPE       MediaType,
        IN RTC_MEDIA_DIRECTION  Direction,
        IN LONG                 Cookie
        );
                     
    HRESULT StopStreamHelperFn(
        IN RTC_MEDIA_TYPE       MediaType,
        IN RTC_MEDIA_DIRECTION  Direction,
        IN LONG                 Cookie
        );
                     
    VOID AddToStreamStartStopQueue(
        IN  RTC_MEDIA_TYPE       MediaType,
        IN  RTC_MEDIA_DIRECTION  Direction,
        IN  BOOL                 fStartStream,
        IN LONG                  Cookie
        );
    
    BOOL PopStreamStartStopQueue(
        OUT RTC_MEDIA_TYPE       *pMediaType,
        OUT RTC_MEDIA_DIRECTION  *pDirection,
        OUT BOOL                 *pfStartStream,
        OUT LONG                 *pCookie
        );
};




///////////////////////////////////////////////////////////////////////////////
// inline functions
///////////////////////////////////////////////////////////////////////////////


inline SIP_CALL_TYPE
SIP_CALL::GetCallType()
{
    return m_CallType;
}


inline SIP_CALL_STATE
SIP_CALL::GetCallState()
{
    return m_State;
}


inline VOID
SIP_CALL::SetCallState(
    IN SIP_CALL_STATE CallState
    )
{
    m_State = CallState;
}


inline BOOL
SIP_CALL::IsCallDisconnected()
{
    return (m_State == SIP_CALL_STATE_DISCONNECTED ||
            m_State == SIP_CALL_STATE_REJECTED);
}


inline BOOL
SIP_CALL::IsSessionDisconnected()
{
    return IsCallDisconnected();
}


inline INCOMING_INVITE_TRANSACTION *
SIP_CALL::GetIncomingInviteTransaction()
{
    return m_pIncomingInviteTransaction;
}


inline OUTGOING_INVITE_TRANSACTION *
SIP_CALL::GetOutgoingInviteTransaction()
{
    return m_pOutgoingInviteTransaction;
}

    
inline VOID
SIP_CALL::SetIncomingInviteTransaction(
    IN INCOMING_INVITE_TRANSACTION *pIncomingInviteTransaction
    )
{
    // ASSERT(m_pIncomingInviteTransaction == NULL);
    m_pIncomingInviteTransaction = pIncomingInviteTransaction;
}


inline VOID
SIP_CALL::SetOutgoingInviteTransaction(
    IN OUTGOING_INVITE_TRANSACTION *pOutgoingInviteTransaction
    )
{
    m_pOutgoingInviteTransaction = pOutgoingInviteTransaction;
}


inline BOOL
SIP_CALL::ProcessingInviteTransaction()
{
    return (m_pOutgoingInviteTransaction != NULL ||
            m_pIncomingInviteTransaction != NULL);
}


inline IRTCMediaManage *
RTP_CALL::GetMediaManager()
{
    return m_pSipStack->GetMediaManager();
}


inline STDMETHODIMP
SIP_CALL::SetNeedToReinitializeMediaManager(
    IN BOOL BoolValue
    )
{
    m_fNeedToReinitializeMediaManager = BoolValue;
    return S_OK;
}


inline ULONG
SIP_TRANSACTION::GetCSeq()
{
    return m_CSeq;
}


inline SIP_METHOD_ENUM
SIP_TRANSACTION::GetMethodId()
{
    return m_MethodId;
}


inline ULONG
SIP_TRANSACTION::GetAsyncNotifyCount()
{
    return m_AsyncNotifyCount;
}


inline BOOL
SIP_TRANSACTION::IsTransactionDone()
{
    return m_IsTransactionDone;
}


inline PSTR
OUTGOING_TRANSACTION::GetMsgBody()
{
    return m_szMsgBody;
}


inline ULONG
OUTGOING_TRANSACTION::GetMsgBodyLen()
{
    return m_MsgBodyLen;
}


#endif // __sipcli_sipcal_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\sipmsg.cpp ===
#include "precomp.h"

SIP_MESSAGE::SIP_MESSAGE()
{
    ZeroMemory( this, sizeof SIP_MESSAGE );

    InitializeListHead(&m_HeaderList);
    
    ParseState = SIP_PARSE_STATE_INIT;
}


SIP_MESSAGE::~SIP_MESSAGE()
{
    if (CSeqMethodStr != NULL)
    {
        free(CSeqMethodStr);
    }
    
    FreeHeaderList();
}


void SIP_MESSAGE::Reset()
{
    ParseState  = SIP_PARSE_STATE_INIT;
    BaseBuffer  = NULL;
    ContentLengthSpecified = FALSE;
    MsgBody.Offset = 0;
    MsgBody.Length = 0;
    FreeHeaderList();
}


// Both do essentially the same thing.
#define InsertBeforeListElement(ListElement, NewElement) \
        InsertTailList(ListElement, NewElement)
    
HRESULT SIP_MESSAGE::AddHeader(
    IN OFFSET_STRING    *pHeaderName,
    IN SIP_HEADER_ENUM   HeaderId,
    IN OFFSET_STRING    *pHeaderValue
    )
{
    HRESULT hr;

    SIP_HEADER_ENTRY *pNewHeaderEntry = new SIP_HEADER_ENTRY;

    if (pNewHeaderEntry == NULL)
    {
        return E_OUTOFMEMORY;
    }
    
    pNewHeaderEntry->HeaderName  = *pHeaderName;
    pNewHeaderEntry->HeaderId    =  HeaderId;
    pNewHeaderEntry->HeaderValue = *pHeaderValue;

    LIST_ENTRY        *pListEntry;
    SIP_HEADER_ENTRY  *pHeaderEntry;

    pListEntry = m_HeaderList.Flink;

    while (pListEntry != &m_HeaderList)
    {
        pHeaderEntry = CONTAINING_RECORD(pListEntry,
                                         SIP_HEADER_ENTRY,
                                         ListEntry);
        // Do an unsigned comparsion so that unknown headers
        // are pushed to the end.
        if ((ULONG)HeaderId < (ULONG)pHeaderEntry->HeaderId)
        {
            break;
        }

        pListEntry = pListEntry->Flink;
    }

    // Insert before the tail or the element we found with a greater HeaderId
    InsertBeforeListElement(pListEntry, &pNewHeaderEntry->ListEntry);

    return S_OK;
}


VOID SIP_MESSAGE::FreeHeaderList()
{
    LIST_ENTRY        *pListEntry;
    SIP_HEADER_ENTRY  *pHeaderEntry;

    while (!IsListEmpty(&m_HeaderList))
    {
        pListEntry = RemoveHeadList(&m_HeaderList);

        pHeaderEntry = CONTAINING_RECORD(pListEntry,
                                         SIP_HEADER_ENTRY,
                                         ListEntry);
        delete pHeaderEntry;
    }
}


HRESULT
SIP_MESSAGE::StoreCallId()
{
    SIP_HEADER_ENTRY *pHeaderEntry;
    ULONG             NumHeaders;
    HRESULT           hr;

    ENTER_FUNCTION("SIP_MESSAGE::StoreCallId");
    
    hr = GetHeader(SIP_HEADER_CALL_ID, &pHeaderEntry, &NumHeaders);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s Couldn't find Call-Id header %x",
             __fxName, hr));
        return hr;
    }
    else if (NumHeaders != 1)
    {
        LOG((RTC_ERROR, "%s More than one Call-Id header in message",
             __fxName));
        return E_FAIL;
    }
    

    CallId = pHeaderEntry->HeaderValue;
    return S_OK;
}


HRESULT
SIP_MESSAGE::StoreCSeq()
{
    HRESULT         hr;
    PSTR            CSeqHeader;
    ULONG           CSeqHeaderLen;
    ULONG           BytesParsed = 0;

    ENTER_FUNCTION("SIP_MESSAGE::StoreCSeq");
    
    hr = GetSingleHeader(SIP_HEADER_CSEQ, &CSeqHeader, &CSeqHeaderLen);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s Couldn't find CSeq header %x",
             __fxName, hr));
        return hr;
    }
    

    hr = ParseCSeq(CSeqHeader, CSeqHeaderLen, &BytesParsed,
                   &CSeq, &CSeqMethodId, &CSeqMethodStr);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s Parsing CSeq header failed %x",
             __fxName, hr));
        return hr;
    }

    // check for unknown method id also that both the strings
    // for the method are the same.
    
    if (MsgType == SIP_MESSAGE_TYPE_REQUEST &&
        Request.MethodId != CSeqMethodId)
    {
        LOG((RTC_ERROR, "%s Request Method Id doesn't match CSeq method Id",
             __fxName));
        return E_FAIL;
    }
    
    return S_OK;
}


// Also checks whether the Content-Type is "application/sdp"
HRESULT
SIP_MESSAGE::GetSDPBody(
    OUT PSTR       *pSDPBody,
    OUT ULONG      *pSDPBodyLen
    )
{
    HRESULT hr;
    PSTR    ContentTypeHdrValue;
    ULONG   ContentTypeHdrValueLen;

    ENTER_FUNCTION("SIP_MESSAGE::GetSDPBody");
    
    if (MsgBody.Length == 0)
    {
        *pSDPBody    = NULL;
        *pSDPBodyLen = 0;
        return S_OK;
    }

    // We have Message Body. Check type.

    hr = GetSingleHeader(SIP_HEADER_CONTENT_TYPE,
                         &ContentTypeHdrValue,
                         &ContentTypeHdrValueLen);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - couldn't find Content-Type header",
             __fxName));
        return E_FAIL;
    }

    if (IsContentTypeSdp(ContentTypeHdrValue, ContentTypeHdrValueLen))
    {
        *pSDPBody    = MsgBody.GetString(BaseBuffer);
        *pSDPBodyLen = MsgBody.Length;
        return S_OK;
    }
    else
    {
        LOG((RTC_ERROR, "%s - invalid Content-Type %.*s",
             __fxName, ContentTypeHdrValueLen, ContentTypeHdrValue));
        return E_FAIL;
    }
}



// Returns the number of headers if there are multiple headers.
// Should we store the headers in sorted order and do a binary
// search.
// All the headers with the same header name are stored consecutively.

HRESULT SIP_MESSAGE::GetHeader(
    IN  SIP_HEADER_ENUM     HeaderId,
    OUT SIP_HEADER_ENTRY  **ppHeaderEntry,
    OUT ULONG              *pNumHeaders
    )
{
    LIST_ENTRY        *pListEntry;
    SIP_HEADER_ENTRY  *pHeaderEntry;

    *ppHeaderEntry  = NULL;
    *pNumHeaders    = 0;

    pListEntry = m_HeaderList.Flink;

    while (pListEntry != &m_HeaderList)
    {
        pHeaderEntry = CONTAINING_RECORD(pListEntry,
                                         SIP_HEADER_ENTRY,
                                         ListEntry);
        if (HeaderId == pHeaderEntry->HeaderId)
        {
            *ppHeaderEntry = pHeaderEntry;
            while (pListEntry != &m_HeaderList &&
                   HeaderId   == pHeaderEntry->HeaderId)
            {
                (*pNumHeaders)++;
                pListEntry = pListEntry->Flink;
                pHeaderEntry = CONTAINING_RECORD(pListEntry,
                                         SIP_HEADER_ENTRY,
                                         ListEntry);
            }
            return S_OK;
        }
        pListEntry = pListEntry->Flink;
    }

    return RTC_E_SIP_HEADER_NOT_PRESENT;
}


// Can be used to get headers such as From, To, CallId,
// which are guaranteed to have just one header (unlike Via, Contact)
HRESULT
SIP_MESSAGE::GetSingleHeader(
    IN  SIP_HEADER_ENUM     HeaderId,
    OUT PSTR               *pHeaderValue,
    OUT ULONG              *pHeaderValueLen 
    )
{
    SIP_HEADER_ENTRY *pHeaderEntry;
    ULONG             NumHeaders;
    HRESULT           hr;

    ENTER_FUNCTION("SIP_MESSAGE::GetSingleHeader");
    
    hr = GetHeader(HeaderId, &pHeaderEntry, &NumHeaders);
    if (hr != S_OK)
    {
        return hr;
    }
    else if (NumHeaders != 1)
    {
        LOG((RTC_ERROR, "%s - more than one header : %d",
             __fxName, NumHeaders));
        return E_FAIL;
    }

    *pHeaderValueLen = pHeaderEntry->HeaderValue.Length;
    *pHeaderValue    = pHeaderEntry->HeaderValue.GetString(BaseBuffer);

    return S_OK;
}


// Same as GetSingleHeader() except that it could be used
// to get for headers such as Contact which could have multiple
// headers in a message. This function is called if we only care
// about processing the first header.
HRESULT
SIP_MESSAGE::GetFirstHeader(
    IN  SIP_HEADER_ENUM     HeaderId,
    OUT PSTR               *pHeaderValue,
    OUT ULONG              *pHeaderValueLen 
    )
{
    SIP_HEADER_ENTRY *pHeaderEntry;
    ULONG             NumHeaders;
    HRESULT           hr;
    
    hr = GetHeader(HeaderId, &pHeaderEntry, &NumHeaders);
    if (hr != S_OK)
    {
        return hr;
    }

    *pHeaderValueLen = pHeaderEntry->HeaderValue.Length;
    *pHeaderValue    = pHeaderEntry->HeaderValue.GetString(BaseBuffer);

    return S_OK;
}


HRESULT
SIP_MESSAGE::GetStoredMultipleHeaders(
    IN  SIP_HEADER_ENUM     HeaderId,
    OUT COUNTED_STRING     **pStringArray,
    OUT ULONG              *pNumHeaders
    )
{
    LIST_ENTRY        *pListEntry;
    SIP_HEADER_ENTRY  *pHeaderEntry;
    ULONG              NumHeaders = 0;
    COUNTED_STRING    *StringArray;
    HRESULT            hr;
    ULONG              i;

    *pStringArray = NULL;
    *pNumHeaders  = 0;

    hr = GetHeader(HeaderId, &pHeaderEntry, &NumHeaders);
    if (hr != S_OK)
    {
        return hr;
    }

    StringArray = (COUNTED_STRING *) malloc(NumHeaders * sizeof(COUNTED_STRING));
    if (StringArray == NULL)
        return E_OUTOFMEMORY;

    ZeroMemory(StringArray, NumHeaders * sizeof(COUNTED_STRING));

    pListEntry = (LIST_ENTRY *)
        (pHeaderEntry + FIELD_OFFSET(SIP_HEADER_ENTRY, ListEntry));
    
    for (i = 0; i < NumHeaders; i++)
    {
        PSTR               HeaderValue;
        ULONG              HeaderLen;

        pHeaderEntry = CONTAINING_RECORD(pListEntry,
                                         SIP_HEADER_ENTRY,
                                         ListEntry);
        
        HeaderLen   = pHeaderEntry->HeaderValue.Length;
        HeaderValue = pHeaderEntry->HeaderValue.GetString(BaseBuffer);
        StringArray[i].Buffer = (PSTR) malloc(HeaderLen + 1);
        if (StringArray[i].Buffer == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }

        strncpy(StringArray[i].Buffer, HeaderValue, HeaderLen);
        StringArray[i].Buffer[HeaderLen] = '\0';
        StringArray[i].Length = HeaderLen;

        pListEntry = pListEntry->Flink;
    }
    
    *pNumHeaders = NumHeaders;
    *pStringArray = StringArray;
    return S_OK;
    
 error:
    if (StringArray != NULL)
    {
        for (i = 0; i < NumHeaders; i++)
        {
            if (StringArray[i].Buffer != NULL)
                free(StringArray[i].Buffer);
        }
        free(StringArray);
    }
    return hr;
}


// The list should be sorted descending using QValue.
HRESULT
SIP_MESSAGE::InsertInContactHeaderList(
    IN OUT LIST_ENTRY       *pContactHeaderList,
    IN     CONTACT_HEADER   *pNewContactHeader
    )
{
    LIST_ENTRY      *pListEntry;
    CONTACT_HEADER  *pContactHeader;
    
    pListEntry = pContactHeaderList->Flink;
    
    while (pListEntry != pContactHeaderList)
    {
        pContactHeader = CONTAINING_RECORD(pListEntry,
                                           CONTACT_HEADER,
                                           m_ListEntry);

        // Do an unsigned comparsion so that unknown headers
        // are pushed to the end.
        if (pNewContactHeader->m_QValue > pContactHeader->m_QValue)
        {
            break;
        }

        pListEntry = pListEntry->Flink;
    }

    // Insert before the tail or the element we found with a greater HeaderId
    InsertBeforeListElement(pListEntry, &pNewContactHeader->m_ListEntry);

    return S_OK;
}


// pContactHeaderList is the list head.  This routine will parse all
// the contact headers into CONTACT_HEADER structures
// (allocated using new) and will add those structures to this
// list. The caller delete the structures when cleaning up the list.

// This function assumes that InitializeListHead() has been called
// earlier on pContactHeaderList.

// The list should be sorted using QValue.

HRESULT
SIP_MESSAGE::ParseContactHeaders(
    OUT LIST_ENTRY *pContactHeaderList
    )
{
    HRESULT            hr;
    LIST_ENTRY        *pListEntry;
    SIP_HEADER_ENTRY  *pHeaderEntry;
    CONTACT_HEADER    *pContactHeader;
    ULONG              NumHeaders = 0;
    ULONG              i;
    ULONG              BytesParsed;
    PSTR               HeaderValue;
    ULONG              HeaderLen;

    ASSERT(IsListEmpty(pContactHeaderList));
    
    ENTER_FUNCTION("SIP_MESSAGE::ParseContactHeaders");
    
    hr = GetHeader(SIP_HEADER_CONTACT, &pHeaderEntry, &NumHeaders);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s Couldn't find Contact header in msg %x",
             __fxName, hr));
        return hr;
    }

    pListEntry = (LIST_ENTRY *)
        (pHeaderEntry + FIELD_OFFSET(SIP_HEADER_ENTRY, ListEntry));
    
    for (i = 0; i < NumHeaders; i++)
    {
        pHeaderEntry = CONTAINING_RECORD(pListEntry,
                                         SIP_HEADER_ENTRY,
                                         ListEntry);
        
        HeaderLen   = pHeaderEntry->HeaderValue.Length;
        HeaderValue = pHeaderEntry->HeaderValue.GetString(BaseBuffer);

        BytesParsed = 0;
        
        while (BytesParsed < HeaderLen)
        {
            pContactHeader = new CONTACT_HEADER;

            if (pContactHeader == NULL)
            {
                LOG((RTC_ERROR, "%s allocating pContactHeader failed",
                     __fxName));
                FreeContactHeaderList(pContactHeaderList);
                return E_OUTOFMEMORY;
            }

            ZeroMemory( pContactHeader, sizeof(CONTACT_HEADER) );
            
            hr = ParseContactHeader(HeaderValue, HeaderLen, &BytesParsed,
                                    pContactHeader);
            if (hr != S_OK)
            {
                // If parsing a contact header fails we just skip it.
                delete pContactHeader;
                LOG((RTC_ERROR,
                     "%s ParseContactHeader failed: %x - skipping Contact header %.*s",
                     __fxName, hr, HeaderLen, HeaderValue));
                break;
            }

            InsertInContactHeaderList(pContactHeaderList, pContactHeader);
        }

        pListEntry = pListEntry->Flink;
    }

    if (IsListEmpty(pContactHeaderList))
    {
        LOG((RTC_ERROR, "%s - no valid Contact headers returning hr: %x",
             __fxName, hr));
        return hr;
    }

    return S_OK;
}


// pRecordRouteHeaderList is the list head.  This routine will parse
// all the Record-Route headers into RECORD_ROUTE_HEADER structures
// (allocated using new) and will add those structures to this
// list. The caller delete the structures when cleaning up the list.

// This function assumes that InitializeListHead() has been
// called earlier on pRecordRouteHeaderList.

// The headers are in the order they appear in the message.

HRESULT
SIP_MESSAGE::ParseRecordRouteHeaders(
    OUT LIST_ENTRY *pRecordRouteHeaderList
    )
{
    HRESULT              hr;
    LIST_ENTRY          *pListEntry;
    SIP_HEADER_ENTRY    *pHeaderEntry;
    RECORD_ROUTE_HEADER *pRecordRouteHeader;
    ULONG                NumHeaders = 0;
    ULONG                i;
    ULONG                BytesParsed;
    PSTR                 HeaderValue;
    ULONG                HeaderLen;

    ENTER_FUNCTION("SIP_MESSAGE::ParseRecordRouteHeaders");
    
    hr = GetHeader(SIP_HEADER_RECORD_ROUTE, &pHeaderEntry, &NumHeaders);
    if (hr != S_OK)
    {
        LOG((RTC_TRACE, "%s Couldn't find Record-Route header in msg %x",
             __fxName, hr));
        return hr;
    }

    pListEntry = (LIST_ENTRY *)
        (pHeaderEntry + FIELD_OFFSET(SIP_HEADER_ENTRY, ListEntry));
    
    for (i = 0; i < NumHeaders; i++)
    {
        pHeaderEntry = CONTAINING_RECORD(pListEntry,
                                         SIP_HEADER_ENTRY,
                                         ListEntry);
        
        HeaderLen   = pHeaderEntry->HeaderValue.Length;
        HeaderValue = pHeaderEntry->HeaderValue.GetString(BaseBuffer);

        BytesParsed = 0;
        
        while (BytesParsed < HeaderLen)
        {
            pRecordRouteHeader = new RECORD_ROUTE_HEADER();
            if (pRecordRouteHeader == NULL)
            {
                LOG((RTC_ERROR, "%s allocating pContactHeader failed",
                     __fxName));
                return E_OUTOFMEMORY;
            }
            
            hr = ParseRecordRouteHeader(HeaderValue, HeaderLen, &BytesParsed,
                                        pRecordRouteHeader);
            if (hr != S_OK)
            {
                delete pRecordRouteHeader;
                LOG((RTC_ERROR, "%s ParseRecordRouteHeader failed: %x",
                     __fxName, hr));
                return hr;
            }

            InsertTailList(pRecordRouteHeaderList,
                           &pRecordRouteHeader->m_ListEntry);
        }

        pListEntry = pListEntry->Flink;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\sipdef.h ===
//
// SIP Definitions
//
// This file contains SIP definitions, named constants, enumerated types, and data structures.
// See RFC 2543 for more information.
//
// This file should never contain any implementation-specific information, including
// function prototypes or C++ classes.
//


#ifndef __sipdef_h
#define __sipdef_h


//
// Versions
//

#define SIP_VERSION_2_0_TEXT                    "SIP/2.0"


// Used for User-Agent header
#define SIP_USER_AGENT_TEXT                     "Windows RTC/1.0"
// Used for Content-Type header
#define SIP_CONTENT_TYPE_SDP_TEXT               "application/sdp"
#define SIP_CONTENT_TYPE_SDP_MEDIA_TYPE         "application"
#define SIP_CONTENT_TYPE_SDP_MEDIA_SUBTYPE      "sdp"
#define SIP_CONTENT_TYPE_MSGTEXT_TEXT           "text/plain"
#define SIP_CONTENT_TYPE_MSGTEXT_MEDIA_TYPE     "text"
#define SIP_CONTENT_TYPE_MSGTEXT_MEDIA_SUBTYPE  "plain"
#define SIP_CONTENT_TYPE_TEXTREG_TEXT           "text/registration-event"
#define SIP_CONTENT_TYPE_TEXTREG_MEDIA_TYPE     "text"
#define SIP_CONTENT_TYPE_TEXTREG_MEDIA_SUBTYPE  "registration-event"
#define SIP_CONTENT_TYPE_MSGXML_TEXT            "application/xml"
#define SIP_CONTENT_TYPE_MSGXPIDF_TEXT          "application/xpidf+xml"
#define SIP_CONTENT_TYPE_MSGXML_MEDIA_TYPE      "application"
#define SIP_CONTENT_TYPE_MSGXML_MEDIA_SUBTYPE   "xml"
#define SIP_CONTENT_TYPE_XPIDF_MEDIA_TYPE       "application"
#define SIP_CONTENT_TYPE_XPIDF_MEDIA_SUBTYPE    "xpidf+xml"

//
// Status Codes
//
// Status codes are similar to HTTP.
//
//      1xx     Informational: Request received, continuing to process the request.
//      2xx     Success: The action was successfully received, understood, and accepted.
//      3xx     Redirection: Further action needs to be taken in order to complete the request.
//      4xx     Client Error: The request contains bad syntax or cannot be fulfilled at this server.
//      5xx     Server Error: The server failed to fulfill an apparently valid request.
//      6xx     Global Failure: The request cannot be fulfilled at any server.
//

#define SIP_STATUS_CLASS_INFO       1
#define SIP_STATUS_CLASS_SUCCESS    2
#define SIP_STATUS_CLASS_REDIRECT   3
#define SIP_STATUS_CLASS_CLIENT     4
#define SIP_STATUS_CLASS_SERVER     5
#define SIP_STATUS_CLASS_GLOBAL     6

#define SIP_STATUS_INFO_TRYING                              100
#define SIP_STATUS_INFO_RINGING                             180
#define SIP_STATUS_INFO_CALL_FORWARDING                     181
#define SIP_STATUS_INFO_QUEUED                              182
#define SIP_STATUS_SESSION_PROGRESS                         183

#define SIP_STATUS_SUCCESS                                  200

#define SIP_STATUS_REDIRECT_MULTIPLE_CHOICES                300
#define SIP_STATUS_REDIRECT_MOVED_PERMANENTLY               301
#define SIP_STATUS_REDIRECT_MOVED_TEMPORARILY               302
#define SIP_STATUS_REDIRECT_SEE_OTHER                       303
#define SIP_STATUS_REDIRECT_USE_PROXY                       305
#define SIP_STATUS_REDIRECT_ALTERNATIVE_SERVICE             380

#define SIP_STATUS_CLIENT_BAD_REQUEST                       400
#define SIP_STATUS_CLIENT_UNAUTHORIZED                      401
#define SIP_STATUS_CLIENT_PAYMENT_REQUIRED                  402
#define SIP_STATUS_CLIENT_FORBIDDEN                         403
#define SIP_STATUS_CLIENT_NOT_FOUND                         404
#define SIP_STATUS_CLIENT_METHOD_NOT_ALLOWED                405
#define SIP_STATUS_CLIENT_NOT_ACCEPTABLE                    406
#define SIP_STATUS_CLIENT_PROXY_AUTHENTICATION_REQUIRED     407
#define SIP_STATUS_CLIENT_REQUEST_TIMEOUT                   408
#define SIP_STATUS_CLIENT_CONFLICT                          409
#define SIP_STATUS_CLIENT_GONE                              410
#define SIP_STATUS_CLIENT_LENGTH_REQUIRED                   411
#define SIP_STATUS_CLIENT_REQUEST_ENTITY_TOO_LARGE          413
#define SIP_STATUS_CLIENT_REQUEST_URI_TOO_LARGE             414
#define SIP_STATUS_CLIENT_UNSUPPORTED_MEDIA_TYPE            415
#define SIP_STATUS_CLIENT_BAD_EXTENSION                     420
#define SIP_STATUS_CLIENT_TEMPORARILY_NOT_AVAILABLE         480
#define SIP_STATUS_CLIENT_TRANSACTION_DOES_NOT_EXIST        481
#define SIP_STATUS_CLIENT_LOOP_DETECTED                     482
#define SIP_STATUS_CLIENT_TOO_MANY_HOPS                     483
#define SIP_STATUS_CLIENT_ADDRESS_INCOMPLETE                484
#define SIP_STATUS_CLIENT_AMBIGUOUS                         485
#define SIP_STATUS_CLIENT_BUSY_HERE                         486
#define SIP_STATUS_REQUEST_TERMINATED                       487
#define SIP_STATUS_NOT_ACCEPTABLE_HERE                      488

#define SIP_STATUS_SERVER_INTERNAL_ERROR                    500
#define SIP_STATUS_SERVER_NOT_IMPLEMENTED                   501
#define SIP_STATUS_SERVER_BAD_GATEWAY                       502
#define SIP_STATUS_SERVER_SERVICE_UNAVAILABLE               503
#define SIP_STATUS_SERVER_SERVER_TIMEOUT                    504
#define SIP_STATUS_SERVER_VERSION_NOT_SUPPORTED             505

#define SIP_STATUS_GLOBAL_BUSY_EVERYWHERE                   600
#define SIP_STATUS_GLOBAL_DECLINE                           603
#define SIP_STATUS_GLOBAL_DOES_NOT_EXIST_ANYWHERE           604
#define SIP_STATUS_GLOBAL_NOT_ACCEPTABLE                    606

// Text Phrases

#define SIP_STATUS_INFO_TRYING_TEXT                             "Trying"
#define SIP_STATUS_INFO_RINGING_TEXT                            "Ringing"
#define SIP_STATUS_INFO_CALL_FORWARDING_TEXT                    "Call Is Being Forwarded"
#define SIP_STATUS_INFO_QUEUED_TEXT                             "Queued"
#define SIP_STATUS_SESSION_PROGRESS_TEXT                        "Session Progress"

#define SIP_STATUS_SUCCESS_TEXT                                 "OK"

#define SIP_STATUS_REDIRECT_MULTIPLE_CHOICES_TEXT               "Multiple Choices"
#define SIP_STATUS_REDIRECT_MOVED_PERMANENTLY_TEXT              "Moved Permanently"
#define SIP_STATUS_REDIRECT_MOVED_TEMPORARILY_TEXT              "Moved Temporarily"
#define SIP_STATUS_REDIRECT_SEE_OTHER_TEXT                      "See Other"
#define SIP_STATUS_REDIRECT_USE_PROXY_TEXT                      "Use Proxy"
#define SIP_STATUS_REDIRECT_ALTERNATIVE_SERVICE_TEXT            "Alternative Service"

#define SIP_STATUS_CLIENT_BAD_REQUEST_TEXT                      "Bad Request"
#define SIP_STATUS_CLIENT_UNAUTHORIZED_TEXT                     "Unauthorized"
#define SIP_STATUS_CLIENT_PAYMENT_REQUIRED_TEXT                 "Payment Required"
#define SIP_STATUS_CLIENT_FORBIDDEN_TEXT                        "Forbidden"
#define SIP_STATUS_CLIENT_NOT_FOUND_TEXT                        "Not Found"
#define SIP_STATUS_CLIENT_METHOD_NOT_ALLOWED_TEXT               "Method Not Allowed"
#define SIP_STATUS_CLIENT_NOT_ACCEPTABLE_TEXT                   "Not Acceptable"
#define SIP_STATUS_CLIENT_PROXY_AUTHENTICATION_REQUIRED_TEXT    "Proxy Authentication Required"
#define SIP_STATUS_CLIENT_REQUEST_TIMEOUT_TEXT                  "Request Timeout"
#define SIP_STATUS_CLIENT_CONFLICT_TEXT                         "Conflict"
#define SIP_STATUS_CLIENT_GONE_TEXT                             "Gone"
#define SIP_STATUS_CLIENT_LENGTH_REQUIRED_TEXT                  "Length Required"
#define SIP_STATUS_CLIENT_REQUEST_ENTITY_TOO_LARGE_TEXT         "Request Entity Too Large"
#define SIP_STATUS_CLIENT_REQUEST_URI_TOO_LARGE_TEXT            "Request-URI Too Long"
#define SIP_STATUS_CLIENT_UNSUPPORTED_MEDIA_TYPE_TEXT           "Unsupported Media Type"
#define SIP_STATUS_CLIENT_BAD_EXTENSION_TEXT                    "Bad Extension"
#define SIP_STATUS_CLIENT_TEMPORARILY_NOT_AVAILABLE_TEXT        "Temporarily Unavailable"
#define SIP_STATUS_CLIENT_TRANSACTION_DOES_NOT_EXIST_TEXT       "Call Leg/Transaction Does Not Exist"
#define SIP_STATUS_CLIENT_LOOP_DETECTED_TEXT                    "Loop Detected"
#define SIP_STATUS_CLIENT_TOO_MANY_HOPS_TEXT                    "Too Many Hops"
#define SIP_STATUS_CLIENT_ADDRESS_INCOMPLETE_TEXT               "Address Incomplete"
#define SIP_STATUS_CLIENT_AMBIGUOUS_TEXT                        "Ambiguous"
#define SIP_STATUS_CLIENT_BUSY_HERE_TEXT                        "Busy Here"
#define SIP_STATUS_REQUEST_TERMINATED_TEXT                      "Request Terminated"
#define SIP_STATUS_NOT_ACCEPTABLE_HERE_TEXT                     "Not Acceptable Here"

#define SIP_STATUS_SERVER_INTERNAL_ERROR_TEXT                   "Server Internal Error"
#define SIP_STATUS_SERVER_NOT_IMPLEMENTED_TEXT                  "Not Implemented"
#define SIP_STATUS_SERVER_BAD_GATEWAY_TEXT                      "Bad Gateway"
#define SIP_STATUS_SERVER_SERVICE_UNAVAILABLE_TEXT              "Service Unavailable"
#define SIP_STATUS_SERVER_SERVER_TIMEOUT_TEXT                   "Server Time-out"
#define SIP_STATUS_SERVER_VERSION_NOT_SUPPORTED_TEXT            "Version Not Supported"

#define SIP_STATUS_GLOBAL_BUSY_EVERYWHERE_TEXT                  "Busy Everywhere"
#define SIP_STATUS_GLOBAL_DECLINE_TEXT                          "Decline"
#define SIP_STATUS_GLOBAL_DOES_NOT_EXIST_ANYWHERE_TEXT          "Does Not Exist Anywhere"
#define SIP_STATUS_GLOBAL_NOT_ACCEPTABLE_TEXT                   "Not Acceptable"

// Phrases
#define SIP_STATUS_100_TEXT     "Trying"
#define SIP_STATUS_180_TEXT     "Ringing"
#define SIP_STATUS_181_TEXT     "Call Is Being Forwarded"
#define SIP_STATUS_182_TEXT     "Queued"
#define SIP_STATUS_183_TEXT     "Session Progress"

#define SIP_STATUS_200_TEXT     "OK"

#define SIP_STATUS_300_TEXT     "Multiple Choices"
#define SIP_STATUS_301_TEXT     "Moved Permanently"
#define SIP_STATUS_302_TEXT     "Moved Temporarily"
#define SIP_STATUS_303_TEXT     "See Other"
#define SIP_STATUS_305_TEXT     "Use Proxy"
#define SIP_STATUS_380_TEXT     "Alternative Service"

#define SIP_STATUS_400_TEXT     "Bad Request"
#define SIP_STATUS_401_TEXT     "Unauthorized"
#define SIP_STATUS_402_TEXT     "Payment Required"
#define SIP_STATUS_403_TEXT     "Forbidden"
#define SIP_STATUS_404_TEXT     "Not Found"
#define SIP_STATUS_405_TEXT     "Method Not Allowed"
#define SIP_STATUS_406_TEXT     "Not Acceptable"
#define SIP_STATUS_407_TEXT     "Proxy Authentication Required"
#define SIP_STATUS_408_TEXT     "Request Timeout"
#define SIP_STATUS_409_TEXT     "Conflict"
#define SIP_STATUS_410_TEXT     "Gone"
#define SIP_STATUS_411_TEXT     "Length Required"
#define SIP_STATUS_413_TEXT     "Request Entity Too Large"
#define SIP_STATUS_414_TEXT     "Request-URI Too Long"
#define SIP_STATUS_415_TEXT     "Unsupported Media Type"
#define SIP_STATUS_420_TEXT     "Bad Extension"
#define SIP_STATUS_480_TEXT     "Temporarily Unavailable"
#define SIP_STATUS_481_TEXT     "Call Leg/Transaction Does Not Exist"
#define SIP_STATUS_482_TEXT     "Loop Detected"
#define SIP_STATUS_483_TEXT     "Too Many Hops"
#define SIP_STATUS_484_TEXT     "Address Incomplete"
#define SIP_STATUS_485_TEXT     "Ambiguous"
#define SIP_STATUS_486_TEXT     "Busy Here"
#define SIP_STATUS_487_TEXT     "Request Terminated"
#define SIP_STATUS_488_TEXT     "Not Acceptable Here"

#define SIP_STATUS_500_TEXT     "Server Internal Error"
#define SIP_STATUS_501_TEXT     "Not Implemented"
#define SIP_STATUS_502_TEXT     "Bad Gateway"
#define SIP_STATUS_503_TEXT     "Service Unavailable"
#define SIP_STATUS_504_TEXT     "Server Time-out"
#define SIP_STATUS_505_TEXT     "Version Not Supported"

#define SIP_STATUS_600_TEXT     "Busy Everywhere"
#define SIP_STATUS_603_TEXT     "Decline"
#define SIP_STATUS_604_TEXT     "Does Not Exist Anywhere"
#define SIP_STATUS_606_TEXT     "Not Acceptable"

#define SIP_STATUS_TEXT(Code)      SIP_STATUS_## Code ## _TEXT
#define SIP_STATUS_TEXT_SIZE(Code) sizeof(SIP_STATUS_TEXT(Code)) - 1

//
// Timer values
//
// All values are in milliseconds
//

#ifndef SIP_TIMER_DBG
// Actual Timer values in milliseconds

#define SIP_TIMER_RETRY_INTERVAL_T1                     500
#define SIP_TIMER_RETRY_INTERVAL_T2                     4000

#define SIP_TIMER_INTERVAL_AFTER_INVITE_SENT_TCP        32000
#define SIP_TIMER_INTERVAL_AFTER_BYE_SENT_TCP           32000
#define SIP_TIMER_INTERVAL_AFTER_REGISTER_SENT_TCP      32000
#define SIP_TIMER_INTERVAL_AFTER_REQFAIL_SENT_TCP       32000
#define SIP_TIMER_INTERVAL_AFTER_PROV_RESPONSE_RCVD     32000
#define SIP_TIMER_INTERVAL_AFTER_INVITE_PROV_RESPONSE_RCVD    128000

#define SIP_TIMER_MAX_RETRY_INTERVAL                    32000
#define SIP_TIMER_MAX_INTERVAL                          32000

// Timer used for SSL negotiation
#define SSL_DEFAULT_TIMER                               30000

// Timer used for HTTPS connect
#define HTTPS_CONNECT_DEFAULT_TIMER                     60000

// in seconds
#define REGISTER_DEFAULT_TIMER                          900
#define SUBSCRIBE_DEFAULT_TIMER                         3000    //50 minutes.
#define REGISTER_SSL_TUNNEL_TIMER                       90

#else // SIP_TIMER_DBG
// Timer values to play with while debugging

#define SIP_TIMER_RETRY_INTERVAL_T1                     500
#define SIP_TIMER_RETRY_INTERVAL_T2                     4000

#define SIP_TIMER_INTERVAL_AFTER_INVITE_SENT_TCP        32000
#define SIP_TIMER_INTERVAL_AFTER_BYE_SENT_TCP           32000
#define SIP_TIMER_INTERVAL_AFTER_REGISTER_SENT_TCP      32000
#define SIP_TIMER_INTERVAL_AFTER_PROV_RESPONSE_RCVD     32000
#define SIP_TIMER_INTERVAL_AFTER_INVITE_PROV_RESPONSE_RCVD    128000

#define SIP_TIMER_MAX_RETRY_INTERVAL                    32000
#define SIP_TIMER_MAX_INTERVAL                          32000

// Timer used for HTTPS connect
#define HTTPS_CONNECT_DEFAULT_TIMER                     500 

// in seconds
#define REGISTER_DEFAULT_TIMER                          900
#define SUBSCRIBE_DEFAULT_TIMER                         3000    //50 minutes.
#define REGISTER_SSL_TUNNEL_TIMER                       90

#endif // SIP_TIMER_DBG


//
// Well-known protocol addresses
// Taken from RFC 2543
//

#define SIP_NETWORK_ADDRESS_ALL_SERVERS         0xE0000149      // 224.0.1.75
#define SIP_DEFAULT_TCP_PORT                    5060
#define SIP_DEFAULT_UDP_PORT                    5060
#define SIP_DEFAULT_SSL_PORT                    5061
//#define SIP_DEFAULT_PORT                        5060


#define SIP_ACCEPT_ENCODING_TEXT    "identity"
#define SIP_ALLOW_TEXT  "INVITE, BYE, OPTIONS, MESSAGE, ACK, CANCEL, NOTIFY, SUBSCRIBE, INFO"
#define USR_STATUS_TYPING_TEXT "Typing"
#define USR_STATUS_IDLE_TEXT "Idle"
#endif // __sipdef_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\sipenc.cpp ===
#include "precomp.h"
#include "util.h"

HRESULT
AppendData(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesFilled,
    IN      PSTR            Data,
    IN      ULONG           DataLen
    )
{
    if ((BufLen - *pBytesFilled) < DataLen)
    {
        LOG((RTC_ERROR,
             "AppendData failed BufLen: %d BytesFilled: %d DataLen: %d",
             BufLen, *pBytesFilled, DataLen));
        return E_FAIL;
    }

    CopyMemory(Buffer + *pBytesFilled, Data, DataLen);
    *pBytesFilled += DataLen;
    return S_OK;
}


// Request-Line = Method SP Request-URI SP SIP-Version return
HRESULT
AppendRequestLine(
    IN      PSTR              Buffer,
    IN      ULONG             BufLen,
    IN OUT  ULONG            *pBytesFilled,
    IN      SIP_METHOD_ENUM   MethodId,
    IN      PSTR              RequestURI,
    IN      ULONG             RequestURILen
    )
{
    int RequestLineLen = 0;
    const COUNTED_STRING *pKnownMethod;

    ENTER_FUNCTION("AppendRequestLine");
    pKnownMethod = GetSipMethodName(MethodId);


    ASSERT(pKnownMethod != NULL);
    if (pKnownMethod == NULL)
    {
        LOG((RTC_ERROR, "%s - Unknown MethodId: %d - this shouldn't happen",
             __fxName, MethodId));
        return E_FAIL;
    }
    
    // XXX Will snprintf work fine with multibyte chars (RequestURI) ?
    RequestLineLen = _snprintf(Buffer + *pBytesFilled,
                               BufLen - *pBytesFilled,
                               "%.*s %.*s %s\r\n",
                               pKnownMethod->Length,
                               pKnownMethod->Buffer,
                               RequestURILen,
                               RequestURI,
                               SIP_VERSION_2_0_TEXT
                               );
                               
    if (RequestLineLen < 0)
    {
        LOG((RTC_ERROR, "_snprintf for Request line failed"));
        return E_FAIL;
    }
    

    *pBytesFilled += RequestLineLen;
    return S_OK;
}


// Status-Line = SIP-version SP Status-Code SP Reason-Phrase return
HRESULT
AppendStatusLine(
    IN      PSTR              Buffer,
    IN      ULONG             BufLen,
    IN OUT  ULONG            *pBytesFilled,
    IN      ULONG             StatusCode,
    IN      PSTR              ReasonPhrase,
    IN      ULONG             ReasonPhraseLen
    )
{
    int ResponseLineLen = 0;

    // XXX Will snprintf work fine with multibyte chars (RequestURI) ?
    ResponseLineLen = _snprintf(Buffer + *pBytesFilled,
                                BufLen - *pBytesFilled,
                                "%s %d %.*s\r\n",
                                SIP_VERSION_2_0_TEXT,
                                StatusCode,
                                ReasonPhraseLen,
                                ReasonPhrase
                                );
                               
    if (ResponseLineLen < 0)
    {
        LOG((RTC_ERROR, "_snprintf for Response line failed"));
        return E_FAIL;
    }

    *pBytesFilled += ResponseLineLen;
    return S_OK;
}


HRESULT
AppendHeader(
    IN      PSTR                Buffer,
    IN      ULONG               BufLen,
    IN OUT  ULONG              *pBytesFilled,
    IN      SIP_HEADER_ENUM     HeaderId,
    IN      PSTR                HeaderValue,
    IN      ULONG               HeaderValueLen
    )
{
    HRESULT hr;
    const COUNTED_STRING *pKnownHeader;
    ENTER_FUNCTION("AppendHeader");
    
    ASSERT(HeaderId < SIP_HEADER_MAX);
    pKnownHeader = GetSipHeaderName(HeaderId);
    if (pKnownHeader == NULL)
    {
        LOG((RTC_ERROR, "%s Unknown header id %d - this shouldn't happen",
             __fxName, HeaderId));
        return E_FAIL;
    }
    
    hr = AppendData(Buffer, BufLen, pBytesFilled,
                    pKnownHeader->Buffer,
                    pKnownHeader->Length
                    );
    if (hr != S_OK)
        return hr;
    
    hr = AppendData(Buffer, BufLen, pBytesFilled,
                    ": ", sizeof(": ") - 1);
    if (hr != S_OK)
        return hr;

    if (HeaderValueLen == 0)
    {
        LOG((RTC_WARN, "%s - HeaderValueLen is 0 for HeaderId: %d"
             "This SHOULD NOT happen for normal headers",
             __fxName, HeaderId));
    }
    
    hr = AppendData(Buffer, BufLen, pBytesFilled,
                    HeaderValue, HeaderValueLen
                    );
    if (hr != S_OK)
        return hr;

    // Append CRLF
    hr = AppendData(Buffer, BufLen, pBytesFilled,
                    "\r\n", sizeof("\r\n") - 1);
    return hr;
}


HRESULT
AppendContentLengthAndEndOfHeaders(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesFilled,
    IN      ULONG           MsgBodyLen
    )
{
    HRESULT hr;
    CHAR ContentLengthValue[16];
    int  ContentLengthValueLen = 0;
    
    ContentLengthValueLen = _snprintf(ContentLengthValue, 16,
                                      "%d", MsgBodyLen);
    if (ContentLengthValueLen < 0)
    {
        LOG((RTC_ERROR, "_snprintf for content length value failed"));
        return E_FAIL;
    }
    
    hr = AppendHeader(Buffer, BufLen, pBytesFilled,
                      SIP_HEADER_CONTENT_LENGTH,
                      ContentLengthValue,
                      ContentLengthValueLen
                      );
    if (hr != S_OK)
        return hr;
    
    // Append CRLF to indicate end of headers.
    hr = AppendData(Buffer, BufLen, pBytesFilled,
                    "\r\n", sizeof("\r\n") - 1);
    return hr;
}

HRESULT
AppendContentTypeHeader(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesFilled,
    IN      PSTR            ContentType,
    IN      ULONG           ContentTypeLen
    )
{
    return AppendHeader(Buffer, BufLen, pBytesFilled,
                        SIP_HEADER_CONTENT_TYPE,
                        ContentType,
                        ContentTypeLen);
}

// To be called for messages that have a message body.
// This will append a "Content-Length: $$$" header followed by
// CRLFCRLF followed by the actual Message Body.
HRESULT
AppendMsgBody(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesFilled,
    IN      PSTR            MsgBody,
    IN      ULONG           MsgBodyLen,
    IN      PSTR            ContentType,
    IN      ULONG           ContentTypeLen
    )
{
    HRESULT hr;

    ASSERT(ContentTypeLen !=0);
    ASSERT(ContentType != NULL);
    ASSERT(MsgBodyLen != 0);
    ASSERT(MsgBody!= NULL);

    hr = AppendContentTypeHeader(Buffer, BufLen, pBytesFilled,
                                ContentType, ContentTypeLen);
    if (hr != S_OK)
        return hr;
    
    hr = AppendContentLengthAndEndOfHeaders(Buffer, BufLen, pBytesFilled,
                                            MsgBodyLen);
    if (hr != S_OK)
        return hr;
    
    hr = AppendData(Buffer, BufLen, pBytesFilled,
                    MsgBody, MsgBodyLen);
    return hr;
}


// To be called only for messages that don't have a message body.
// This will append a "Content-Length: 0" header followed by
// CRLFCRLF
HRESULT
AppendEndOfHeadersAndNoMsgBody(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesFilled
    )
{
    HRESULT hr;
    
    hr = AppendContentLengthAndEndOfHeaders(Buffer, BufLen, pBytesFilled, 0);
    return hr;
}


// MethodStr is used only if MethodId is UNKNOWN
HRESULT
AppendCSeqHeader(
    IN      PSTR              Buffer,
    IN      ULONG             BufLen,
    IN OUT  ULONG            *pBytesFilled,
    IN      ULONG             CSeq,
    IN      SIP_METHOD_ENUM   MethodId,
    IN      PSTR              MethodStr // = NULL
    )
{
    HRESULT                hr;
    CHAR                   CSeqBuffer[64];
    int                    CSeqBufferLen = 0;
    const COUNTED_STRING  *pKnownMethod;
    PSTR                   CSeqMethodStr;
    ULONG                  CSeqMethodStrLen;

    ENTER_FUNCTION("AppendCSeqHeader");

    if (MethodId != SIP_METHOD_UNKNOWN)
    {
        pKnownMethod = GetSipMethodName(MethodId);
        ASSERT(pKnownMethod != NULL);
        if (pKnownMethod == NULL)
        {
            LOG((RTC_ERROR, "%s - Unknown MethodId: %d - this shouldn't happen",
                 __fxName, MethodId));
            return E_FAIL;
        }
        CSeqMethodStr    = pKnownMethod->Buffer;
        CSeqMethodStrLen = pKnownMethod->Length;
    }
    else
    {
        ASSERT(MethodStr != NULL);
        
        CSeqMethodStr    = MethodStr;
        CSeqMethodStrLen = strlen(MethodStr);
    }
    
    CSeqBufferLen = _snprintf(CSeqBuffer, 64, "%u %.*s",
                              CSeq, CSeqMethodStrLen, CSeqMethodStr);
    // pKnownMethod->Length,
    //                        pKnownMethod->Buffer);
    if (CSeqBufferLen < 0)
    {
        LOG((RTC_ERROR, "_snprintf for CSeqBuffer failed"));
        return E_FAIL;
    }
    
    hr = AppendHeader(Buffer, BufLen, pBytesFilled,
                      SIP_HEADER_CSEQ, CSeqBuffer, CSeqBufferLen);
    
    return hr;
}


HRESULT
AppendUserAgentHeaderToRequest(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesFilled
    )
{
    HRESULT hr;
    hr = AppendHeader(Buffer, BufLen, pBytesFilled,
                      SIP_HEADER_USER_AGENT,
                      SIP_USER_AGENT_TEXT,
                      sizeof(SIP_USER_AGENT_TEXT) - 1);
    
    return hr;
}


HRESULT
AppendRecordRouteHeader(
    IN      PSTR                 Buffer,
    IN      ULONG                BufLen,
    IN OUT  ULONG               *pBytesFilled,
    IN      SIP_HEADER_ENUM      HeaderId,
    IN      RECORD_ROUTE_HEADER *pRecordRouteHeader
    )
{
    HRESULT hr;
    ENTER_FUNCTION("AppendRecordRouteHeader");
    ASSERT(HeaderId == SIP_HEADER_RECORD_ROUTE ||
           HeaderId == SIP_HEADER_ROUTE);

    PSTR  RecordRouteHeaderStr;
    ULONG RecordRouteHeaderStrLen;
    
    hr = pRecordRouteHeader->GetString(
             &RecordRouteHeaderStr,
             &RecordRouteHeaderStrLen
             );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s pRecordRouteHeader GetString failed %x",
             __fxName, hr));
        return hr;
    }

    hr = AppendHeader(Buffer, BufLen, pBytesFilled,
                      HeaderId,
                      RecordRouteHeaderStr,
                      RecordRouteHeaderStrLen);

    free(RecordRouteHeaderStr);

    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s AppendHeader failed %x",
             __fxName, hr));
        return hr;
    }
    
    return hr;
}


HRESULT
AppendRecordRouteHeaders(
    IN      PSTR             Buffer,
    IN      ULONG            BufLen,
    IN OUT  ULONG           *pBytesFilled,
    IN      SIP_HEADER_ENUM  HeaderId,
    IN      LIST_ENTRY      *pRecordRouteHeaderList
    )
{
    HRESULT              hr;
    LIST_ENTRY          *pListEntry;
    RECORD_ROUTE_HEADER *pRecordRouteHeader;
    
    ENTER_FUNCTION("AppendRecordRouteHeaders");

    ASSERT(HeaderId == SIP_HEADER_RECORD_ROUTE ||
           HeaderId == SIP_HEADER_ROUTE);
    
    pListEntry = pRecordRouteHeaderList->Flink;
    while (pListEntry != pRecordRouteHeaderList)
    {
        pRecordRouteHeader = CONTAINING_RECORD(pListEntry,
                                               RECORD_ROUTE_HEADER,
                                               m_ListEntry);

        hr = AppendRecordRouteHeader(Buffer, BufLen, pBytesFilled,
                                     HeaderId,
                                     pRecordRouteHeader);

        pListEntry = pListEntry->Flink;
    }

    return S_OK;
}


//
// The header syntax is:
//
// "Bad-Header-Info" ":" field-name *(;BadHeaderInfo-Param)
// BadHeaderInfo-Param = ExpectedValue | generic-param
// ExpectedValue = "ExpectedValue" "=" token | Qouted-string
//
// So an example of this header is:
// 
// Bad-Header-Info : CSeq;ExpectedValue="7"
// Bad-Header-Info : f;ExpectedValue="<sip:bob@somecompany.com>; tag=123456"
// 

HRESULT
GetBadCSeqHeader(
    IN  ULONG                       HighestRemoteCSeq,
    IN  SIP_HEADER_ARRAY_ELEMENT   *pBadCSeqHeader
    )
{
    pBadCSeqHeader->HeaderId = SIP_HEADER_BADHEADERINFO;

    pBadCSeqHeader->HeaderValue = new CHAR[ 45 ];

    if( pBadCSeqHeader->HeaderValue == NULL )
    {
        return E_OUTOFMEMORY;
    }

    //
    // The next expected value of the CSeq is 1 more than the highest we have.
    //
    pBadCSeqHeader->HeaderValueLen = sprintf( pBadCSeqHeader->HeaderValue,
        "CSeq;ExpectedValue=\"%d\"", HighestRemoteCSeq+1 );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\sipmsg.h ===
//
// SIPMSG.H
//
// The SIPMSG module contains the SIP parser and generator implementation.
// This file contains the implementation-specific data structures and definition.
//


#ifndef __sipmsg_h
#define __sipmsg_h

#include "siphdr.h"
#include "time.h"

#define     TEN_MINUTES     600
#define     TWO_MINUTES     120
#define     TWENTY_MINUTES  1200
#define     FIVE_MINUTES    300

typedef BOOL (* IS_TOKEN_CHAR_FUNCTION_TYPE) (IN UCHAR c);

// Structure to store substrings with in other strings.
// These strings only have meaning w.r.t. a base buffer.
struct OFFSET_STRING
{
    ULONG Offset;
    ULONG Length;

    //OFFSET_STRING();
    inline PSTR  GetString(PSTR Base);
    inline ULONG GetLength();
};

PSTR  OFFSET_STRING::GetString(
    IN PSTR Base
    )
{
    return (Base + Offset);
}

ULONG  OFFSET_STRING::GetLength()
{
    return Length;
}


struct SIP_VERSION
{
    ULONG MinorVersion;
    ULONG MajorVersion;
};


//
// The SIP message header consists of these components:
//
//      The request verb, such as "INVITE" or "REGISTER".
//      The request URI.  The meaning of this field depends on Method.
//      The SIP protocol version.  Typically, this is "SIP/2.0".
//      Zero or more headers, identifying fields
//

//
// SIP_HEADER - A single, individual header in a SIP
//

struct SIP_HEADER_ENTRY
{
    // sorted linked list of headers in the message (m_HeaderList).
    LIST_ENTRY       ListEntry;
    
    OFFSET_STRING    HeaderName;
    SIP_HEADER_ENUM  HeaderId;
    OFFSET_STRING    HeaderValue;
};


// Used to pass additional headers
struct SIP_HEADER_ARRAY_ELEMENT
{
    SIP_HEADER_ENUM  HeaderId;
    PSTR             HeaderValue;
    ULONG            HeaderValueLen;
};


enum SIP_MESSAGE_TYPE
{
    SIP_MESSAGE_TYPE_REQUEST = 0,
    SIP_MESSAGE_TYPE_RESPONSE,
};


enum SIP_PARSE_STATE
{
    SIP_PARSE_STATE_INIT = 0,
    SIP_PARSE_STATE_START_LINE_DONE,
    SIP_PARSE_STATE_HEADERS_DONE,
    SIP_PARSE_STATE_MESSAGE_BODY_DONE,

    // SIP_PARSE_STATE_INVALID,
};


struct SIP_HEADER_PARAM
{
    SIP_HEADER_PARAM();
    ~SIP_HEADER_PARAM();

    HRESULT SetParamNameAndValue(
        IN SIP_HEADER_PARAM_ENUM    HeaderParamId,
        IN COUNTED_STRING          *pParamName,
        IN COUNTED_STRING          *pParamValue
        );
    
    // Linked list of header params
    LIST_ENTRY              m_ListEntry;
    
    SIP_HEADER_PARAM_ENUM   m_HeaderParamId;
    COUNTED_STRING          m_ParamName;
    COUNTED_STRING          m_ParamValue;
};


// We never compare the Contact headers for equality.
// So, we don't have to keep track of other params ?
struct CONTACT_HEADER
{
    CONTACT_HEADER();
    ~CONTACT_HEADER();
    
    // Linked list of Contact headers
    LIST_ENTRY      m_ListEntry;

    COUNTED_STRING  m_DisplayName;
    COUNTED_STRING  m_SipUrl;
    double          m_QValue;
    INT             m_ExpiresValue;
};

VOID FreeContactHeaderList(
         IN LIST_ENTRY *pContactHeaderList
         );

// We need to compare the From/To headers for equality.
// So, we have to keep track of all the params.
struct FROM_TO_HEADER
{
    FROM_TO_HEADER();
    ~FROM_TO_HEADER();
    
    COUNTED_STRING  m_DisplayName;
    COUNTED_STRING  m_SipUrl;
    COUNTED_STRING  m_TagValue;

    // Linked list of other params (SIP_HEADER_PARAM structures)
    LIST_ENTRY      m_ParamList;

private:
    void FreeParamList();
};



// We have to reverse the list of RecordRoute headers
// So, we have to keep track of all the params.
struct RECORD_ROUTE_HEADER
{
    RECORD_ROUTE_HEADER();
    ~RECORD_ROUTE_HEADER();

    HRESULT GetString(
        OUT PSTR    *pRecordRouteHeaderStr,
        OUT ULONG   *pRecordRouteHeaderStrLen
        );

    // Linked list of RECORD_ROUTE_HEADERs
    LIST_ENTRY      m_ListEntry;
    
    COUNTED_STRING  m_DisplayName;
    COUNTED_STRING  m_SipUrl;

    // Linked list of params (SIP_HEADER_PARAM structures)
    LIST_ENTRY      m_ParamList;

private:
    void FreeParamList();
};


enum SIP_URL_USER_PARAM
{
    SIP_URL_USER_PARAM_PHONE = 0,
    SIP_URL_USER_PARAM_IP,
    SIP_URL_USER_PARAM_UNKNOWN
};


struct SIP_URL_PARAM
{
    SIP_URL_PARAM();
    ~SIP_URL_PARAM();

    HRESULT SetParamNameAndValue(
        IN SIP_URL_PARAM_ENUM    SipUrlParamId,
        IN COUNTED_STRING       *pParamName,
        IN COUNTED_STRING       *pParamValue
        );
    
    // Linked list of SIP_URL_PARAMs
    LIST_ENTRY              m_ListEntry;
    
    SIP_URL_PARAM_ENUM      m_SipUrlParamId;
    COUNTED_STRING          m_ParamName;
    COUNTED_STRING          m_ParamValue;
};


struct SIP_URL_HEADER
{
    SIP_URL_HEADER();
    ~SIP_URL_HEADER();

    HRESULT SetHeaderNameAndValue(
        IN SIP_HEADER_ENUM    HeaderId,
        IN COUNTED_STRING    *pHeaderName,
        IN COUNTED_STRING    *pHeaderValue
        );
    
    // Linked list of SIP_URL headers
    LIST_ENTRY              m_ListEntry;
    
    SIP_HEADER_ENUM         m_HeaderId;
    COUNTED_STRING          m_HeaderName;
    COUNTED_STRING          m_HeaderValue;
};


struct SIP_URL
{
    SIP_URL();
    ~SIP_URL();

    // Call this directly to free all the members without
    // deleting the object.
    void FreeSipUrl();

    HRESULT GetString(
        OUT PSTR    *pSipUrlString,
        OUT ULONG   *pSipUrlStringLen
        );

    HRESULT CopySipUrl(
        OUT SIP_URL  *pSipUrl
        );

    BOOL IsTransportParamPresent();
    
    COUNTED_STRING      m_User;
    COUNTED_STRING      m_Password;
    
    COUNTED_STRING      m_Host;
    // Host order. 0 is stored if the URL doesn't contain a port.
    ULONG               m_Port; 

    // SIP_TRANSPORT_NOT_SPECIFIED is stored if no transport param
    // is specified in the URL.
    SIP_TRANSPORT       m_TransportParam;

    COUNTED_STRING      m_KnownParams[SIP_URL_PARAM_MAX];

    // List of other params
    // (linked list of SIP_URL_PARAM structures)
    LIST_ENTRY          m_OtherParamList;
    
    // List of headers
    // (linked list of SIP_URL_HEADER structures)
    LIST_ENTRY          m_HeaderList;

private:
    void FreeOtherParamList();

    void FreeHeaderList();

    HRESULT CopyOtherParamList(
        OUT SIP_URL  *pSipUrl
        );

    HRESULT CopyHeaderList(
        OUT SIP_URL  *pSipUrl
        );
};


BOOL
AreSipUrlsEqual(
    IN SIP_URL *pSipUrl1,
    IN SIP_URL *pSipUrl2
    );


BOOL
AreFromToHeadersEqual(
    IN FROM_TO_HEADER *pFromToHeader1,
    IN FROM_TO_HEADER *pFromToHeader2,
    IN BOOL isResponse,
    BOOL isFromTagCheck
    );

HRESULT
ParseContactHeader(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed,
    OUT     CONTACT_HEADER *pContactHeader
    );

HRESULT
ParseFromOrToHeader(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed,
    OUT     FROM_TO_HEADER *pFromToHeader
    );

HRESULT
ParseRecordRouteHeader(
    IN      PSTR                 Buffer,
    IN      ULONG                BufLen,
    IN OUT  ULONG               *pBytesParsed,
    OUT     RECORD_ROUTE_HEADER *pRecordRouteHeader
    );

int
ParseExpiresValue(
    IN  PSTR    expiresHdr,
    IN  ULONG   BufLen
    );



///////////////////////////////////////////////////////////////////////////////
// SIP_MESSAGE
///////////////////////////////////////////////////////////////////////////////


struct  SIP_MESSAGE
{
    SIP_MESSAGE_TYPE        MsgType;
    SIP_VERSION             SipVersion;

    // State related to parsing
    SIP_PARSE_STATE         ParseState;
    BOOL                    ContentLengthSpecified;
    // State related to building


    // Stuff in the Start line
    union   {
        struct  {
            SIP_METHOD_ENUM MethodId;
            OFFSET_STRING   MethodText;
            OFFSET_STRING   RequestURI;
        }   Request;

        struct  {
            ULONG           StatusCode;
            OFFSET_STRING   ReasonPhrase;
        }   Response;
    };

    // Sorted list of headers in the SIP message
    LIST_ENTRY              m_HeaderList;

    // Message Body
    OFFSET_STRING           MsgBody;

    PSTR                    BaseBuffer;

    OFFSET_STRING           CallId;

    ULONG                   CSeq;
    SIP_METHOD_ENUM         CSeqMethodId;
    PSTR                    CSeqMethodStr;

    SIP_MESSAGE();

    ~SIP_MESSAGE();
    
    void    Reset();
    
    // Returns the number of headers if there are multiple headers.
    HRESULT GetHeader(
        IN  SIP_HEADER_ENUM     HeaderId,
        OUT SIP_HEADER_ENTRY  **ppHeaderEntry,
        OUT ULONG              *pNumHeaders
       );

    // Can be used to get headers such as From, To, CallId,
    // which are guaranteed to have just one header (unlike Via, Contact)
    HRESULT GetSingleHeader(
        IN  SIP_HEADER_ENUM     HeaderId,
        OUT PSTR               *pHeaderValue,
        OUT ULONG              *pHeaderValueLen 
       );
    
    HRESULT GetFirstHeader(
        IN  SIP_HEADER_ENUM     HeaderId,
        OUT PSTR               *pHeaderValue,
        OUT ULONG              *pHeaderValueLen 
       );
    
    HRESULT GetStoredMultipleHeaders(
        IN  SIP_HEADER_ENUM     HeaderId,
        OUT COUNTED_STRING     **pStringArray,
        OUT ULONG              *pNumHeaders
        );
    
    HRESULT ParseContactHeaders(
        OUT LIST_ENTRY *pContactHeaderList
        );
    
    HRESULT ParseRecordRouteHeaders(
        OUT LIST_ENTRY *pRecordRouteHeaderList
        );
    
    HRESULT AddHeader(
        IN OFFSET_STRING    *pHeaderName,
        IN SIP_HEADER_ENUM   HeaderId,
        IN OFFSET_STRING    *pHeaderValue
        );

    VOID    FreeHeaderList();
    
    inline ULONG GetContentLength();
    
    inline void  SetContentLength(
        IN ULONG ContentLength
        );

    inline void GetMsgBody(
        OUT PSTR       *pMsgBody,
        OUT ULONG      *pMsgBodyLen
        );

    HRESULT GetSDPBody(
        OUT PSTR       *pSDPBody,
        OUT ULONG      *pSDPBodyLen
        );
    
    inline SIP_METHOD_ENUM GetMethodId();

    inline PSTR GetMethodStr();

    inline ULONG GetMethodStrLen();

    inline ULONG GetStatusCode();

    inline void GetReasonPhrase(
        OUT PSTR       *pReasonPhrase,
        OUT ULONG      *pReasonPhraseLen
        );
    
    HRESULT StoreCallId();

    HRESULT StoreCSeq();

    inline void GetCSeq(
        OUT ULONG           *pCSeq,
        OUT SIP_METHOD_ENUM *pCSeqMethodId
        );
    
    inline ULONG GetCSeq();
    
    inline void GetCallId(
        OUT PSTR       *pCallId,
        OUT ULONG      *pCallIdLen 
        );

    inline void  SetBaseBuffer(
        IN PSTR  Buffer
        );

    inline HRESULT CheckSipVersion();
    
    INT GetExpireTimeoutFromResponse(
        IN  PSTR        LocalContact,
        IN  ULONG       LocalContactLen,
        IN  INT         ulDefaultTimer
        );

private:

    HRESULT InsertInContactHeaderList(
        IN OUT LIST_ENTRY       *pContactHeaderList,
        IN     CONTACT_HEADER   *pNewContactHeader
        );
};


ULONG
SIP_MESSAGE::GetContentLength()
{
    return MsgBody.Length;
}


void
SIP_MESSAGE::GetMsgBody(
    OUT PSTR       *pMsgBody,
    OUT ULONG      *pMsgBodyLen
    )
{
    *pMsgBody    = MsgBody.GetString(BaseBuffer);
    *pMsgBodyLen = MsgBody.Length;
}


void
SIP_MESSAGE::SetContentLength(
    IN ULONG ContentLength
    )
{
    MsgBody.Length = ContentLength;
}


SIP_METHOD_ENUM
SIP_MESSAGE::GetMethodId()
{
    ASSERT(MsgType == SIP_MESSAGE_TYPE_REQUEST);
    return Request.MethodId;
}


PSTR
SIP_MESSAGE::GetMethodStr()
{
    return Request.MethodText.GetString(BaseBuffer);
}


ULONG
SIP_MESSAGE::GetMethodStrLen()
{
    return Request.MethodText.GetLength();
}


ULONG
SIP_MESSAGE::GetStatusCode()
{
    ASSERT(MsgType == SIP_MESSAGE_TYPE_RESPONSE);
    return Response.StatusCode;
}


void
SIP_MESSAGE::GetReasonPhrase(
    OUT PSTR       *pReasonPhrase,
    OUT ULONG      *pReasonPhraseLen
    )
{
    ASSERT(MsgType == SIP_MESSAGE_TYPE_RESPONSE);
    *pReasonPhrase    = Response.ReasonPhrase.GetString(BaseBuffer);
    *pReasonPhraseLen = Response.ReasonPhrase.Length;
}


inline void
SIP_MESSAGE::GetCSeq(
    OUT ULONG           *pCSeq,
    OUT SIP_METHOD_ENUM *pCSeqMethodId
    )
{
    *pCSeq         = CSeq;
    *pCSeqMethodId = CSeqMethodId;
}

    
inline ULONG
SIP_MESSAGE::GetCSeq()
{
    return CSeq;
}

    
inline void
SIP_MESSAGE::GetCallId(
    OUT PSTR       *pCallId,
    OUT ULONG      *pCallIdLen 
    )
{
    *pCallId    = CallId.GetString(BaseBuffer);
    *pCallIdLen = CallId.GetLength();
}


// This function could get called if we reallocate the buffer
// we are parsing from.
void
SIP_MESSAGE::SetBaseBuffer(
    IN PSTR Buffer
    )
{
    BaseBuffer = Buffer;
}

HRESULT
SIP_MESSAGE::CheckSipVersion()
{
    //We accept anything greater than 2.0
    if(SipVersion.MajorVersion < 2)
        return E_FAIL;
    return S_OK;
}

//
// Parse a SIP message.
//

HRESULT ParseSipMessageIntoHeadersAndBody(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed,
    IN      BOOL            IsEndOfData,
    IN OUT  SIP_MESSAGE    *pSipMsg
    );

inline BOOL IsProvisionalStatusCode(ULONG StatusCode)
{
    return (StatusCode >= 100 && StatusCode < 200);
}

inline BOOL IsProvisionalResponse(SIP_MESSAGE *pSipMsg)
{
    ASSERT(pSipMsg->MsgType == SIP_MESSAGE_TYPE_RESPONSE);
    return (IsProvisionalStatusCode(pSipMsg->Response.StatusCode));
}


inline BOOL IsFinalResponse(SIP_MESSAGE *pSipMsg)
{
    ASSERT(pSipMsg->MsgType == SIP_MESSAGE_TYPE_RESPONSE);
    return (pSipMsg->Response.StatusCode >= 200 ||
            (pSipMsg->Response.StatusCode < 100 &&
             pSipMsg->Response.StatusCode > 0 ));
}


inline BOOL IsSuccessfulStatusCode(ULONG StatusCode)
{
    return (StatusCode >= 200 && StatusCode < 300);
}

inline BOOL IsSuccessfulResponse(SIP_MESSAGE *pSipMsg)
{
    ASSERT(pSipMsg->MsgType == SIP_MESSAGE_TYPE_RESPONSE);
    return (IsSuccessfulStatusCode(pSipMsg->Response.StatusCode));
}


inline BOOL IsRedirectResponse(SIP_MESSAGE *pSipMsg)
{
    ASSERT(pSipMsg->MsgType == SIP_MESSAGE_TYPE_RESPONSE);
    return (pSipMsg->Response.StatusCode >= 300 &&
            pSipMsg->Response.StatusCode < 400);
}


inline BOOL IsAuthRequiredResponse(SIP_MESSAGE *pSipMsg)
{
    ASSERT(pSipMsg->MsgType == SIP_MESSAGE_TYPE_RESPONSE);
    return (pSipMsg->Response.StatusCode == 401 ||
            pSipMsg->Response.StatusCode == 407);
}


inline BOOL IsFailureResponse(SIP_MESSAGE *pSipMsg)
{
    ASSERT(pSipMsg->MsgType == SIP_MESSAGE_TYPE_RESPONSE);
    return ((pSipMsg->Response.StatusCode >= 400 &&
            pSipMsg->Response.StatusCode != 401 &&
            pSipMsg->Response.StatusCode != 407) ||
            (pSipMsg->Response.StatusCode <  100 &&
             pSipMsg->Response.StatusCode > 0));
}


inline HRESULT
HRESULT_FROM_SIP_SUCCESS_STATUS_CODE(ULONG StatusCode)
{
    if ((HRESULT) StatusCode <= 0)
    {
        return (HRESULT) StatusCode;
    }
    else
    {
        return MAKE_HRESULT(SEVERITY_SUCCESS,
                            FACILITY_SIP_STATUS_CODE,
                            StatusCode);
    }
}


inline HRESULT
HRESULT_FROM_SIP_ERROR_STATUS_CODE(ULONG StatusCode)
{
    if ((HRESULT) StatusCode <= 0)
    {
        return (HRESULT) StatusCode;
    }
    else
    {
        return MAKE_HRESULT(SEVERITY_ERROR,
                            FACILITY_SIP_STATUS_CODE,
                            StatusCode);
    }
}


// Is it okay to have a severity error for redirect error codes ?
inline HRESULT
HRESULT_FROM_SIP_STATUS_CODE(ULONG StatusCode)
{
    if (IsProvisionalStatusCode(StatusCode) ||
        IsSuccessfulStatusCode(StatusCode))
    {
        return HRESULT_FROM_SIP_SUCCESS_STATUS_CODE(StatusCode);
    }
    else
    {
        return HRESULT_FROM_SIP_ERROR_STATUS_CODE(StatusCode);
    }
}


HRESULT
ParseSipUrl(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed,
    OUT     SIP_URL        *pSipUrl
    );

// pMethodStr is returned only if this is an
// unknown method.
HRESULT
ParseCSeq(
    IN      PSTR              Buffer,
    IN      ULONG             BufLen,
    IN  OUT ULONG            *pBytesParsed,
    OUT     ULONG            *pCSeq,
    OUT     SIP_METHOD_ENUM  *pCSeqMethodId,
    OUT     PSTR             *pMethodStr    
    );

HRESULT
ParseNameAddrOrAddrSpec(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed,
    IN      CHAR            HeaderListSeparator OPTIONAL,
    OUT     OFFSET_STRING  *pDisplayName,
    OUT     OFFSET_STRING  *pAddrSpec
    );


BOOL
IsTokenChar(
    IN UCHAR c
    );
    
HRESULT
ParseToken(
    IN      PSTR                         Buffer,
    IN      ULONG                        BufLen,
    IN OUT  ULONG                       *pBytesParsed,
    IN      IS_TOKEN_CHAR_FUNCTION_TYPE  IsTokenCharFunction,
    OUT     OFFSET_STRING               *pToken
    );

HRESULT
ParseFirstViaHeader(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed,
    OUT     COUNTED_STRING *pHost,
    OUT     USHORT         *pPort 
    );

BOOL
IsOneOfContentTypeXpidf(
    IN  PSTR    ContentTypeHdr,
    IN  ULONG   ContentTypeHdrLen
    );

BOOL
IsContentTypeXpidf(
    IN  PSTR    ContentTypeHdr,
    IN  ULONG   ContentTypeHdrLen
    );
    
BOOL
IsOneOfContentTypeSdp(
    IN  PSTR    ContentTypeHdr,
    IN  ULONG   ContentTypeHdrLen
    );

BOOL
IsContentTypeSdp(
    IN      PSTR            ContentTypeHdr,
    IN      ULONG           ContentTypeHdrLen
    );


BOOL
IsOneOfContentTypeTextRegistration(
    IN  PSTR    ContentTypeHdr,
    IN  ULONG   ContentTypeHdrLen
    );

BOOL
IsContentTypeTextRegistration(
    IN  PSTR    ContentTypeHdr,
    IN  ULONG   ContentTypeHdrLen
    );

BOOL
IsOneOfContentTypeTextPlain(
    IN  PSTR    ContentTypeHdr,
    IN  ULONG   ContentTypeHdrLen
    );

BOOL
IsContentTypeTextPlain(
    IN  PSTR    ContentTypeHdr,
    IN  ULONG   ContentTypeHdrLen
    );

BOOL
IsContentTypeAppXml(
    IN  PSTR    ContentTypeHdr,
    IN  ULONG   ContentTypeHdrLen
    );

// Encoding related methods
HRESULT AppendData(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesFilled,
    IN      PSTR            Data,
    IN      ULONG           DataLen
    );

HRESULT AppendRequestLine(
    IN      PSTR              Buffer,
    IN      ULONG             BufLen,
    IN OUT  ULONG            *pBytesFilled,
    IN      SIP_METHOD_ENUM   MethodId,
    IN      PSTR              RequestURI,
    IN      ULONG             RequestURILen
    );

HRESULT
AppendStatusLine(
    IN      PSTR              Buffer,
    IN      ULONG             BufLen,
    IN OUT  ULONG            *pBytesFilled,
    IN      ULONG             StatusCode,
    IN      PSTR              ReasonPhrase,
    IN      ULONG             ReasonPhraseLen
    );

HRESULT AppendHeader(
    IN      PSTR              Buffer,
    IN      ULONG             BufLen,
    IN OUT  ULONG            *pBytesFilled,
    IN      SIP_HEADER_ENUM   HeaderId,
    IN      PSTR              HeaderValue,
    IN      ULONG             HeaderValueLen
    );

HRESULT AppendContentLengthAndEndOfHeaders(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesFilled,
    IN      ULONG           MsgBodyLen
    );

HRESULT AppendMsgBody(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesFilled,
    IN      PSTR            MsgBody,
    IN      ULONG           MsgBodyLen,
    IN      PSTR            ContentType,
    IN      ULONG           ContentTypeLen
    );

HRESULT AppendEndOfHeadersAndNoMsgBody(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesFilled
    );

HRESULT AppendCSeqHeader(
    IN      PSTR              Buffer,
    IN      ULONG             BufLen,
    IN OUT  ULONG            *pBytesFilled,
    IN      ULONG             CSeq,
    IN      SIP_METHOD_ENUM   MethodId,
    IN      PSTR              MethodStr = NULL
    );

HRESULT AppendUserAgentHeaderToRequest(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesFilled
    );

HRESULT
AppendRecordRouteHeaders(
    IN      PSTR             Buffer,
    IN      ULONG            BufLen,
    IN OUT  ULONG           *pBytesFilled,
    IN      SIP_HEADER_ENUM  HeaderId,
    IN      LIST_ENTRY      *pRecordRouteHeaderList
    );

HRESULT
UpdateProxyInfo( 
    IN  SIP_SERVER_INFO    *pProxyInfo
    );

HRESULT
GetBadCSeqHeader(
    IN  ULONG                       HighestRemoteCSeq,
    IN  SIP_HEADER_ARRAY_ELEMENT   *pBadCSeqHeader
    );


struct PARSED_BADHEADERINFO
{
    SIP_HEADER_ENUM HeaderId;
    OFFSET_STRING   ExpectedValue;

    PARSED_BADHEADERINFO()
    {
        ExpectedValue.Offset = 0;
        ExpectedValue.Length = 0;
        HeaderId = SIP_HEADER_UNKNOWN;
    }
};


HRESULT
ParseBadHeaderInfo(
    PSTR                    Buffer,
    ULONG                   BufLen,
    PARSED_BADHEADERINFO   *pParsedBadHeaderInfo
    );

#endif // __sipmsg_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\sipparse.cpp ===
#include "precomp.h"


///////////////////////////////////////////////////////////////////////////////
// Utility methods
///////////////////////////////////////////////////////////////////////////////

// All parsing should take care of a lot of conditions :
// - The Buffer might be shorter than the string we are comparing against.
// - We could hit a \r or \n while parsing and the header could continue 
//   on to the next line (with a space or tab as the first char).
// - We should always allow white space between tokens.
// - Always need to take BufLen into consideration.

void
ParseWhiteSpace(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed
    )
{
    PSTR BufEnd = Buffer + BufLen;
    PSTR Buf = Buffer + *pBytesParsed;

    while (Buf < BufEnd && (*Buf == ' ' || *Buf == '\t'))
    {
        Buf++;
        (*pBytesParsed)++;
    }
}


void
ParseWhiteSpaceAndNewLines(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed
    )
{
    PSTR BufEnd = Buffer + BufLen;
    PSTR Buf = Buffer + *pBytesParsed;

    while(  (Buf < BufEnd) &&
            ( (*Buf == ' ') || (*Buf == '\t') || (*Buf == '\n') ) )
    {
        Buf++;
        (*pBytesParsed)++;
    }
}

BOOL
IsTokenChar(
    IN UCHAR c
    )
{
    // TODO: Have a global token bitmap g_TokenBitMap
    // and initialize this when you initialize the parsing module.
    CHAR *TokenChars =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-.!%*_+`'~";

    if (c >= 'A' && c <= 'Z')
        return TRUE;
    if (c >= 'a' && c <= 'z')
        return TRUE;
    if (c >= '0' && c <= '9')
        return TRUE;
    if (c == '-' || c == '.'  || c == '!' ||
        c == '%' || c == '*'  || c == '_' ||
        c == '+' || c == '\'' || c == '`' || c == '~')
        return TRUE;

    return FALSE;
}


BOOL
IsSipUrlParamChar(
    IN UCHAR c
    )
{
    // TODO: Have a global token bitmap g_TokenBitMap
    // and initialize this when you initialize the parsing module.
    // TODO: Have a global token bitmap g_TokenBitMap
    // and initialize this when you initialize the parsing module.
    CHAR *SipUrlHeaderChars =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.!~*'()%[]/:&+$";

    if (c >= 'A' && c <= 'Z')
        return TRUE;
    if (c >= 'a' && c <= 'z')
        return TRUE;
    if (c >= '0' && c <= '9')
        return TRUE;
    if (c == '-'  || c == '_' || c == '.' ||
        c == '!'  || c == '~' || c == '*' ||
        c == '\'' || c == '(' || c == ')' ||
        c == '%'  || c == '[' || c == ']' ||
        c == '/'  || c == ':' || c == '&' ||
        c == '+'  || c == '$')
        return TRUE;

    return FALSE;
}


BOOL
IsSipUrlHeaderChar(
    IN UCHAR c
    )
{
    // TODO: Have a global token bitmap g_TokenBitMap
    // and initialize this when you initialize the parsing module.
    CHAR *SipUrlHeaderChars =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.!~*'()%[]/?:+$";

    if (c >= 'A' && c <= 'Z')
        return TRUE;
    if (c >= 'a' && c <= 'z')
        return TRUE;
    if (c >= '0' && c <= '9')
        return TRUE;
    if (c == '-'  || c == '_' || c == '.' ||
        c == '!'  || c == '~' || c == '*' ||
        c == '\'' || c == '(' || c == ')' ||
        c == '%'  || c == '[' || c == ']' ||
        c == '/'  || c == '?' || c == ':' ||
        c == '+'  || c == '$')
        return TRUE;

    return FALSE;
}


BOOL
IsHostChar(
    IN UCHAR c
    )
{
    // TODO: Have a global token bitmap g_HostBitMap
    // and initialize this when you initialize the parsing module.
    CHAR *HostChars =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.";

    if (c >= 'A' && c <= 'Z')
        return TRUE;
    if (c >= 'a' && c <= 'z')
        return TRUE;
    if (c >= '0' && c <= '9')
        return TRUE;
    if (c == '-' || c == '.' || c == '_')
        return TRUE;

    return FALSE;
}


// We could probably pass a function pointer IsTokenChar
// to this function and use the same function for all
// parsing (URLs, params, etc which are defined to use a
// strict character set).

// Note that this function should be called only after
// all the whitespace before the token is parsed.

// Should we return S_FALSE if don't see a non-token
// char after the token - otherwise we don't know if the
// token ended or if the token will continue in the data
// we get in the next recv.
// NO. This will make this function unnecessarily complex.
// The function that parses complete lines will realize
// that the line has not been received completely and will
// parse the line again anyway.

HRESULT
ParseToken(
    IN      PSTR                         Buffer,
    IN      ULONG                        BufLen,
    IN OUT  ULONG                       *pBytesParsed,
    IN      IS_TOKEN_CHAR_FUNCTION_TYPE  IsTokenCharFunction,
    OUT     OFFSET_STRING               *pToken
    )
{
    if (*pBytesParsed == BufLen)
    {
        // Need to recv more data before we can parse the token.
        LOG((RTC_TRACE,
             "need to recv more data before we can parse token returning S_FALSE"));
        return S_FALSE;
    }
    
    PSTR  BufEnd      = Buffer + BufLen;
    PSTR  Buf         = Buffer + *pBytesParsed;
    
    ULONG TokenOffset = *pBytesParsed;
    ULONG TokenLength = 0;

    while (Buf < BufEnd && IsTokenCharFunction(*Buf))
    {
        Buf++;
        TokenLength++;
    }

    if (TokenLength == 0)
    {
        LOG((RTC_ERROR,
             "Found non-token char '%c' when parsing token", *Buf));
        return E_FAIL;
    }
    
    pToken->Offset = TokenOffset;
    pToken->Length = TokenLength;
    *pBytesParsed += TokenLength;

    return S_OK;
}

// Parse till you hit BufLen or one of the characters
// passed in the Delimiters parameter (NULL terminated string)
// If specified the string is stored in pString
// '\r' and '\n' are always treated as delimiters.
HRESULT
ParseTillDelimiter(
    IN           PSTR            Buffer,
    IN           ULONG           BufLen,
    IN  OUT      ULONG          *pBytesParsed,
    IN           PSTR            Delimiters,
    OUT OPTIONAL OFFSET_STRING  *pString 
    )
{
    BOOL  ParsedDelimiter    = FALSE;
    ULONG BytesParsed        = *pBytesParsed;
    ULONG StringOffset       = BytesParsed;

    UCHAR *delimit = (UCHAR *)Delimiters;

    BYTE  DelimiterMap[32];
    ULONG i = 0;

    /* Clear out bit map */
    for (i = 0; i < 32; i++)
        DelimiterMap[i] = 0;

    /* Set bits in bit map */
    while (*delimit)
    {
        DelimiterMap[*delimit >> 3] |= (1 << (*delimit & 7));
        delimit++;
    }

    // '\r' and '\n' are always treated as delimiters.
    UCHAR c = '\r';
    DelimiterMap[c >> 3] |= (1 << (c & 7));
    c = '\n';
    DelimiterMap[c >> 3] |= (1 << (c & 7));
    
    const UCHAR *Buf = (UCHAR *)Buffer + BytesParsed;

	/* 1st char in delimiter map stops search */
    while (BytesParsed < BufLen)
    {
        if (DelimiterMap[*Buf >> 3] & (1 << (*Buf & 7)))
        {
            // We hit a delimiter
            ParsedDelimiter = TRUE;
            break;
        }
        BytesParsed++;
        Buf++;
    }
    
    // If we haven't parsed a delimiter, we need to read more bytes
    // and parse the header again.
    if (!ParsedDelimiter)
    {
        LOG((RTC_TRACE,
             "need to recv more data before we can parse till delimiter"
             " returning S_FALSE"));
        return S_FALSE;
    }

    if (pString != NULL)
    {
        pString->Offset = StringOffset;
        pString->Length = BytesParsed - StringOffset;
    }
    
    *pBytesParsed = BytesParsed;
    return S_OK;
}


// Should we return S_FALSE if don't see a non-integer
// char after the integer - otherwise we don't know if the
// integer ended or if the integer will continue in the data
// we get in the next recv.
// NO. This will make this function unnecessarily complex.
// The function that parses complete lines will realize
// that the line has not been received completely and will
// parse the line again anyway.
// Currently parses Unsigned integers only.
// Do we need to parse signed integers at all ?

HRESULT
ParseUnsignedInteger(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed,
    OUT     ULONG          *pInteger
    )
{
    if (*pBytesParsed == BufLen)
    {
        LOG((RTC_TRACE,
             "need to recv more data before we can parse integer"
             " returning S_FALSE"));
        return S_FALSE;
    }

    if (Buffer[*pBytesParsed] < '0' || Buffer[*pBytesParsed] > '9')
    {
        LOG((RTC_ERROR,
             "Found non-digit char %c when trying to parse integer",
             Buffer[*pBytesParsed]));
        return E_FAIL;
    }

    ULONG Total = 0;
    ULONG PrevTotal = 0;
    while (*pBytesParsed < BufLen &&
           Buffer[*pBytesParsed] >= '0' &&
           Buffer[*pBytesParsed] <= '9')
    {
        Total = Total*10 + (Buffer[*pBytesParsed] - '0');
        (*pBytesParsed)++;
        if(PrevTotal > Total)
        {
            LOG((RTC_ERROR, "Overflow in ParseUnsignedInteger"));
            return E_FAIL;
        }
        PrevTotal = Total;
    }

    *pInteger = Total;

    return S_OK;
}


HRESULT
ParseMethod(
    IN      PSTR                Buffer,
    IN      ULONG               BufLen,
    IN OUT  ULONG              *pBytesParsed,
    OUT     OFFSET_STRING      *pMethodStr,
    OUT     SIP_METHOD_ENUM    *pMethodId
    )
{
    HRESULT hr = E_FAIL;

    hr = ParseToken(Buffer, BufLen, pBytesParsed,
                    IsTokenChar,
                    pMethodStr);
    if (hr == S_OK)
    {
        *pMethodId = GetSipMethodId(pMethodStr->GetString(Buffer),
                                    pMethodStr->GetLength());
    }

    return hr;
}


BOOL
SkipToKnownChar(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed,
    IN      INT             Char
    )
{
    *pBytesParsed = 0;
    ULONG BytesParsed = 0;

    while( BytesParsed < BufLen )
    {
        if( Buffer[ BytesParsed++ ] == Char )
        {
            *pBytesParsed = BytesParsed;
            return TRUE;
        }
    }

    return FALSE;
}


HRESULT
ParseKnownString(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed,
    IN      PSTR            String,
    IN      ULONG           StringLen,
    IN      BOOL            fIsCaseSensitive
    )
{
    ULONG BytesToParse = BufLen - *pBytesParsed;
    if (BytesToParse < StringLen)
    {
        // Need to recv more data before we can parse the string.
        if (String[0] != '\r' && String[0] != '\n')
        {
            LOG((RTC_TRACE,
                 "need to recv more data before we can parse known string"
                 " returning S_FALSE"));
        }
        return S_FALSE;
    }
    else if ((fIsCaseSensitive &&
              strncmp(Buffer + *pBytesParsed, String, StringLen) == 0) ||
             (!fIsCaseSensitive &&
              _strnicmp(Buffer + *pBytesParsed, String, StringLen) == 0))
    {
        *pBytesParsed += StringLen;
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}


// Parse SIP / 2.0
HRESULT
ParseSipVersion(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed,
    OUT     SIP_VERSION    *pSipVersion
    )
{
    DWORD BytesParsed = *pBytesParsed;
    HRESULT hr;

    hr = ParseKnownString(Buffer, BufLen, pBytesParsed,
                          "SIP", sizeof("SIP") - 1,
                          FALSE // case-insensitive
                          );
    if (hr != S_OK)
        return hr;

    ParseWhiteSpace(Buffer, BufLen, pBytesParsed);
    
    hr = ParseKnownString(Buffer, BufLen, pBytesParsed,
                          "/", sizeof("/") - 1,
                          TRUE // case-sensitive
                          );
    if (hr != S_OK)
        return hr;

    ParseWhiteSpace(Buffer, BufLen, pBytesParsed);
    
    hr = ParseUnsignedInteger(Buffer, BufLen, pBytesParsed,
                              &pSipVersion->MajorVersion);
    if (hr != S_OK)
        return hr;
    
    ParseWhiteSpace(Buffer, BufLen, pBytesParsed);
    
    hr = ParseKnownString(Buffer, BufLen, pBytesParsed,
                          ".", sizeof(".") - 1,
                          TRUE // case-sensitive
                          );
    if (hr != S_OK)
        return hr;
    
    ParseWhiteSpace(Buffer, BufLen, pBytesParsed);
    
    hr = ParseUnsignedInteger(Buffer, BufLen, pBytesParsed,
                              &pSipVersion->MinorVersion);
    if (hr != S_OK)
        return hr;
    
    return S_OK;
}


HRESULT
ParseTillReturn(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed,
    OUT     OFFSET_STRING  *pString 
    )
{
    HRESULT hr;
    BOOL    ParsedEndOfHeader  = FALSE;
    BOOL    ParsedEndOfHeaders = FALSE;
    ULONG   StringOffset       = *pBytesParsed;

    hr = ParseTillDelimiter(Buffer, BufLen, pBytesParsed,
                            "\r\n", pString);
    if (hr != S_OK)
        return hr;
    
    while (*pBytesParsed < BufLen &&
           (Buffer[*pBytesParsed] == '\r' || Buffer[*pBytesParsed] == '\n'))
    {
        (*pBytesParsed)++;
    }
    
    return S_OK;
}


// If we are not sure we parsed the line completely (i.e. we have not
// seen CR LF followed by a non-whitespace char), then we need to
// issue another recv() and reparse the line.
// Request-Line = Method SP Request-URI SP SIP-Version return
HRESULT
ParseRequestLine(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed,
    IN OUT  SIP_MESSAGE    *pSipMsg
    )
{
    HRESULT hr = E_FAIL;
    
    hr = ParseMethod(Buffer, BufLen, pBytesParsed,
                     &pSipMsg->Request.MethodText,
                     &pSipMsg->Request.MethodId
                     );
    if (hr != S_OK)
        return hr;
    
    ParseWhiteSpace(Buffer, BufLen, pBytesParsed);
    
    hr = ParseTillDelimiter(Buffer, BufLen, pBytesParsed,
                            " \r\n", &pSipMsg->Request.RequestURI);
    if (hr != S_OK)
        return hr;

    ParseWhiteSpace(Buffer, BufLen, pBytesParsed);

    hr = ParseSipVersion(Buffer, BufLen, pBytesParsed,
                         &pSipMsg->SipVersion);
    if (hr != S_OK)
        return hr;

    hr = ParseTillReturn(Buffer, BufLen, pBytesParsed, NULL);
    return hr;
}


// Status-Line = SIP-version SP Status-Code SP Reason-Phrase return
HRESULT
ParseStatusLine(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed,
    IN OUT  SIP_MESSAGE    *pSipMsg
    )
{
    HRESULT hr;

    ENTER_FUNCTION("ParseStatusLine");
    
    hr = ParseSipVersion(Buffer, BufLen, pBytesParsed,
                         &pSipMsg->SipVersion);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s ParseSipVersion failed %x",
             __fxName, hr));
        return hr;
    }

    ParseWhiteSpace(Buffer, BufLen, pBytesParsed);

    hr = ParseUnsignedInteger(Buffer, BufLen, pBytesParsed,
                              &pSipMsg->Response.StatusCode);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s Parse status code failed %x",
             __fxName, hr));
        return hr;
    }

    if (pSipMsg->Response.StatusCode < 100 ||
        pSipMsg->Response.StatusCode > 999)
    {
        LOG((RTC_ERROR, "Invalid status code in status line: %d",
             pSipMsg->Response.StatusCode));
        return E_FAIL;
    }

    ParseWhiteSpace(Buffer, BufLen, pBytesParsed);

    hr = ParseTillReturn(Buffer, BufLen, pBytesParsed,
                         &pSipMsg->Response.ReasonPhrase);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s Parse status code failed %x",
             __fxName, hr));
        return hr;
    }

    return S_OK;
}


// CRCR,  LFLF or CRLFCRLF
BOOL
IsDoubleReturn(
    IN      PSTR            String,
    IN      ULONG           StringLength
    )
{
    ULONG   i = 0;
    HRESULT hr = S_OK;
    ULONG   BytesParsed = 0;

    if (StringLength < 2)
    {
        return FALSE;
    }

    for (i = 0; i < StringLength - 1; i++)
    {
        BytesParsed = i;

        hr = ParseKnownString(String, StringLength, &BytesParsed,
                              "\r\n\r\n", sizeof("\r\n\r\n") - 1,
                              TRUE // case-sensitive
                              );
        if (hr == S_OK)
            return TRUE;
        
        hr = ParseKnownString(String, StringLength, &BytesParsed,
                              "\n\n", sizeof("\n\n") - 1,
                              TRUE // case-sensitive
                              );
        if (hr == S_OK)
            return TRUE;
        
        hr = ParseKnownString(String, StringLength, &BytesParsed,
                              "\r\r", sizeof("\r\r") - 1,
                              TRUE // case-sensitive
                              );
        if (hr == S_OK)
            return TRUE;
    }

    return FALSE;
}

// If it contains a CR or LF and is not a double
// return
BOOL
IsSingleReturn(
    IN      PSTR            String,
    IN      ULONG           StringLength
    )
{
    BOOL ContainsCRorLF = FALSE;
    ULONG i = 0;

    for (i = 0; i < StringLength; i++)
    {
        if (String[i] == '\r' || String[i] == '\n')
        {
            ContainsCRorLF = TRUE;
            break;
        }
    }

    return (ContainsCRorLF && !IsDoubleReturn(String, StringLength));
}


// When we see a \r or \n one of the following things could happen
// - it could mean a return
// - if it is \r\r or \n\n or \r\n\r\n, it could mean a double return
// - if return is followed by a space or tab it means the header is
//   continued on the next line.
// - if we hit the end of buffer before we can find out what exactly
//   it is, we need to issue a recv() and reparse the line (in case of TCP).

HRESULT
ParseCRLF(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed,
    OUT     BOOL           *pParsedEndOfHeader,
    OUT     BOOL           *pParsedEndOfHeaders
    )
{
    ULONG BytesParsed   = *pBytesParsed;
    PSTR  BufCRLFStart  = Buffer + BytesParsed;
    ULONG NumCRLF       = 0;

    ASSERT((*pBytesParsed < BufLen) &&
           (Buffer[BytesParsed] == '\r' || Buffer[BytesParsed] == '\n'));
    
    *pParsedEndOfHeader  = FALSE;
    *pParsedEndOfHeaders = FALSE;
    
    while (BytesParsed < BufLen &&
           (Buffer[BytesParsed] == '\r' || Buffer[BytesParsed] == '\n'))
    {
        NumCRLF++;
        BytesParsed++;
    }

    if (IsDoubleReturn(BufCRLFStart, NumCRLF))
    {
        *pParsedEndOfHeader = TRUE;
        *pParsedEndOfHeaders = TRUE;
    }
    else
    {
        ASSERT(IsSingleReturn(BufCRLFStart, NumCRLF));
        if (BytesParsed < BufLen)
        {
            // Check for folding header
            if (Buffer[BytesParsed] == ' ' || Buffer[BytesParsed] == '\t')
            {
                // ConvertToSpaces(BufCRLFStart, NumCRLF);
                memset(BufCRLFStart, ' ', NumCRLF);
            }
            else
            {
                *pParsedEndOfHeader = TRUE;
            }
        }
        else
        {
            // We don't know if this is the end of header till we
            // recv more bytes and reparse again.
            LOG((RTC_TRACE,
                 "need to recv more data before we know if this the "
                 "end of header returning S_FALSE"));
            return S_FALSE;
        }
    }

    *pBytesParsed = BytesParsed;
    return S_OK;
}


// We return E_FAIL if we parse the end of header
// or the end of headers.
// If we see a return at the end of buffer we return
// S_FALSE. Once we recv more data and parse the
// header again we will be able to determine if the
// return is part of LWS.
HRESULT
ParseLinearWhiteSpace(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed
    )
{
    HRESULT hr = E_FAIL;
    BOOL ParsedEndOfHeader  = FALSE;
    BOOL ParsedEndOfHeaders = FALSE;
    DWORD BytesParsed;

    while (*pBytesParsed < BufLen)
    {
        if (Buffer[*pBytesParsed] == '\r' || Buffer[*pBytesParsed] == '\n')
        {
            BytesParsed = *pBytesParsed;
            hr = ParseCRLF(Buffer, BufLen, &BytesParsed,
                           &ParsedEndOfHeader, &ParsedEndOfHeaders);
            if (hr != S_OK)
                return hr;
            // If we parse the end of a header or all headers
            // we do not update *pBytesParsed and let the caller of
            // this function deal with the CRLFs
            if (ParsedEndOfHeader || ParsedEndOfHeaders)
                return S_OK;

            *pBytesParsed = BytesParsed;
        }
        else if (Buffer[*pBytesParsed] == ' ' || Buffer[*pBytesParsed] == '\t')
        {
            (*pBytesParsed)++;
        }
        else
        {
            break;
        }
    }

    return S_OK;
}



///////////////////////////////////////////////////////////////////////////////
// SIP Header parsing
///////////////////////////////////////////////////////////////////////////////

// If we are not sure we parsed the line completely (i.e. we have not
// seen CR LF followed by a non-whitespace char), then we need to
// issue another recv() and reparse the line.

// Look for LWS / return and Parse the Headers (as strings).
// We should change a \r or \n or \r\n followed by spaces to
// identify folding headers.
// Look for double-return to identify end of headers

HRESULT
ParseHeaderLine(
    IN      PSTR             Buffer,
    IN      ULONG            BufLen,
    IN OUT  ULONG           *pBytesParsed,
    OUT     OFFSET_STRING   *pHeaderName,
    OUT     SIP_HEADER_ENUM *pHeaderId, 
    OUT     OFFSET_STRING   *pHeaderValue,
    OUT     BOOL            *pParsedEndOfHeaders
    )
{
    HRESULT hr;
    OFFSET_STRING HeaderName;
    ULONG   BytesParsed = *pBytesParsed;
    SIP_HEADER_ENUM HeaderId;

    ENTER_FUNCTION("ParseHeaderLine");
    
    // Parse the Header name
    hr = ParseToken(Buffer, BufLen, &BytesParsed,
                    IsTokenChar,
                    &HeaderName);
    if (hr != S_OK)
    {
        return hr;
    }
    
    HeaderId = GetSipHeaderId(HeaderName.GetString(Buffer),
                              HeaderName.GetLength());

    hr = ParseLinearWhiteSpace(Buffer, BufLen, &BytesParsed);
    if (hr != S_OK)
        return hr;
    
    // Parse ":"
    hr = ParseKnownString(Buffer, BufLen, &BytesParsed,
                          ":", sizeof(":") - 1,
                          TRUE // case-sensitive
                          );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s Parsing for ':' failed",
             __fxName));
        return hr;
    }
    
    hr = ParseLinearWhiteSpace(Buffer, BufLen, &BytesParsed);
    if (hr != S_OK)
        return hr;
    
    // Parse the Header value
    ULONG HeaderValueOffset     = BytesParsed;
    BOOL  ParsedEndOfHeader     = FALSE;
    BOOL  ParsedEndOfHeaders    = FALSE;
    ULONG BytesParsedBeforeCRLF = 0;
    
    while (BytesParsed < BufLen)
    {
        if (Buffer[BytesParsed] =='\r' || Buffer[BytesParsed] == '\n')
        {
            BytesParsedBeforeCRLF = BytesParsed;
            hr = ParseCRLF(Buffer, BufLen, &BytesParsed,
                           &ParsedEndOfHeader,
                           &ParsedEndOfHeaders);
            if (hr != S_OK)
                return hr;
            
            if (ParsedEndOfHeader)
            {
                break;
            }
        }
        else
        {
            BytesParsed++;
        }
    }

    // If we haven't parsed till the end of the header we
    // need to read more bytes and parse the header again.
    if (!ParsedEndOfHeader)
    {
        LOG((RTC_TRACE,
             "need to recv more data before we can parse complete header"
             " returning S_FALSE"));
        return S_FALSE;
    }

    pHeaderValue->Offset = HeaderValueOffset;

    ULONG HeaderEnd = BytesParsedBeforeCRLF;
    
    // Get rid of trailing white space.
    while (HeaderEnd > HeaderValueOffset &&
           (Buffer[HeaderEnd - 1] == ' ' ||
            Buffer[HeaderEnd - 1] == '\t'))
    {
        HeaderEnd--;
    }
    
    pHeaderValue->Length = HeaderEnd - HeaderValueOffset;

    *pBytesParsed        = BytesParsed;
    *pHeaderName         = HeaderName;
    *pHeaderId           = HeaderId;
    *pParsedEndOfHeaders = ParsedEndOfHeaders;
    
    return S_OK;
}


HRESULT
ParseStartLine(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed,
    IN OUT  SIP_MESSAGE    *pSipMsg
    )
{
    HRESULT hr          = E_FAIL;
    ULONG   BytesParsed = *pBytesParsed;

    while ((BytesParsed < BufLen) &&
           (Buffer[BytesParsed] == '\r' || Buffer[BytesParsed] == '\n'))
    {
        BytesParsed++;
    }
    
    hr = ParseRequestLine(Buffer, BufLen, &BytesParsed, pSipMsg);
    if (hr == S_OK)
    {
        pSipMsg->MsgType = SIP_MESSAGE_TYPE_REQUEST;
        *pBytesParsed    = BytesParsed;
        return S_OK;
    }
    else if (hr == S_FALSE)
    {
        // need to recv more data and parse the start line again
        *pBytesParsed    = BytesParsed;
        return S_FALSE;
    }

    BytesParsed = *pBytesParsed;
    
    hr = ParseStatusLine(Buffer, BufLen, &BytesParsed, pSipMsg);
    if (hr == S_OK)
    {
        pSipMsg->MsgType = SIP_MESSAGE_TYPE_RESPONSE;
        *pBytesParsed    = BytesParsed;
        return S_OK;
    }
    else if (hr == S_FALSE)
    {
        // need to recv more data and parse the start line again
        *pBytesParsed = BytesParsed;
        return S_FALSE;
    }

    LOG((RTC_ERROR, "ParseStartLine failed hr: %x", hr));
    return E_FAIL;
}


// Look for Content-Length to identify message body length


HRESULT
ParseHeaders(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed,
    IN OUT  SIP_MESSAGE    *pSipMsg 
    )
{
    HRESULT                 hr;
    ULONG BytesParsed =    *pBytesParsed;
    OFFSET_STRING           HeaderName;
    OFFSET_STRING           HeaderValue;
    SIP_HEADER_ENUM         HeaderId;
    BOOL                    ParsedEndOfHeaders;

    ENTER_FUNCTION("ParseHeaders");
    
    while (*pBytesParsed < BufLen)
    {
        // We could have either a parsing error or an error saying we need
        // more data.
        hr = ParseHeaderLine(Buffer, BufLen, pBytesParsed,
                             &HeaderName, &HeaderId, &HeaderValue,
                             &ParsedEndOfHeaders);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s ParseHeaderLine failed %x",
                 __fxName, hr));
            return hr;
        }
            
        if (HeaderId == SIP_HEADER_CONTENT_LENGTH)
        {
            ULONG BytesParsed = 0;
            ParseWhiteSpace(HeaderValue.GetString(Buffer),
                            HeaderValue.GetLength(), &BytesParsed);
            hr = ParseUnsignedInteger(HeaderValue.GetString(Buffer),
                                      HeaderValue.GetLength(),
                                      &BytesParsed,
                                      &pSipMsg->MsgBody.Length);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s parsing Content-Length header failed %x",
                     __fxName, hr));
                return hr;
            }
            
            pSipMsg->ContentLengthSpecified = TRUE;
        }
        else
        {
            hr = pSipMsg->AddHeader(&HeaderName, HeaderId, &HeaderValue);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s pSipMsg->AddHeader failed %x",
                     __fxName, hr));
                return hr;
            }
        }

        if (ParsedEndOfHeaders)
            break;
    }

    // Parsed the end of headers.

    // Store common headers for use later.
    hr = pSipMsg->StoreCallId();
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s StoreCallId failed %x",
             __fxName, hr));
        return hr;
    }

    hr = pSipMsg->StoreCSeq();
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s StoreCSeq failed %x",
             __fxName, hr));
        return hr;
    }

    return S_OK;
}


HRESULT
ParseMsgBody(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed,
    IN      BOOL            IsEndOfData,
    IN OUT  SIP_MESSAGE    *pSipMsg
    )
{
    // If Content-Length is not specified we parse till the end of the
    // datagram or the end of the TCP connection.
    if (pSipMsg->ContentLengthSpecified)
    {
        if (pSipMsg->GetContentLength() == 0)
        {
            // No message body to parse
            // goto done;
            return S_OK;
        }
        else if (pSipMsg->GetContentLength() <= (BufLen - *pBytesParsed))
        {
            LOG((RTC_TRACE,
                "GetContentLength = %d Remaining Length = %d", 
                pSipMsg->GetContentLength(), (BufLen - *pBytesParsed)));
            pSipMsg->MsgBody.Offset = *pBytesParsed;
            *pBytesParsed += pSipMsg->GetContentLength();
            return S_OK;
        }
        else
        {
            // We have to receive more data before we can parse
            // the message body.
            LOG((RTC_ERROR, "Need more data to parse . Content Length insufficient"));
            return S_FALSE;
        }
    }
    else // Content-Length  is not specified
    {
        // End of UDP datagram or TCP Connection is closed.
        if (IsEndOfData)
        {
            LOG((RTC_TRACE, "Inside ParseMsgBody:: IsEndOfData"));
            pSipMsg->MsgBody.Length = BufLen - *pBytesParsed;
            pSipMsg->MsgBody.Offset = *pBytesParsed;
            *pBytesParsed += pSipMsg->GetContentLength();
            return S_OK;
        }
        else
        {
            // We have to receive more data before we can parse
            // the message body.
            LOG((RTC_ERROR, "Need more data to parse . Content Length insufficient"));
            return S_FALSE;
        }            
    }
}



//
// Parse a SIP message.
//
// E_FAIL - Parsing error
// E_XXXX - Need more data. In case of UDP this means a parsing error.
//          In case of TCP this means we need to try and read more data.
//
// If the Content-Length is not specified then we need to consider the 
// end of the datagram or the TCP connection as the end of the message.
// IsEndOfData indicates this condition. Note that Buffer could contain
// more than one SIP Message.

// In the TCP case, we will have partially parsed SIP_MESSAGEs which
// we need pass in again to complete parsing after reading more data.
// On return from this function, pBytesParsed always points to the end of 
// a header. We will resume parsing from the beginning of a new  header.
// We need to differentiate a parsing error from a "need more data"
// scenario. Note that even if we see a "\r\n" we might have to wait
// for the next char to see if the header could continue on the next line.

// In case of a failure pBytesParsed is not changed.

// Different events
// - parsed start line
// - parsed end of headers
// - parsed content length
// - parsed message body

HRESULT
ParseSipMessageIntoHeadersAndBody(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed,
    IN      BOOL            IsEndOfData,
    IN OUT  SIP_MESSAGE    *pSipMsg
    )
{
    // Identify Request / Response and read the RequestLine / StatusLine.
    ULONG BytesParsed = *pBytesParsed;
    HRESULT hr = E_FAIL;

    ENTER_FUNCTION("ParseSipMessageIntoHeadersAndBody");
    
    switch (pSipMsg->ParseState)
    {
    case SIP_PARSE_STATE_INIT:
        pSipMsg->SetBaseBuffer(Buffer);
        hr = ParseStartLine(Buffer, BufLen, &BytesParsed, pSipMsg);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s ParseStartLine failed", __fxName));
            goto done;
        }
        pSipMsg->ParseState = SIP_PARSE_STATE_START_LINE_DONE;
        // Fall through is intentional.

    case SIP_PARSE_STATE_START_LINE_DONE:
        if (pSipMsg->BaseBuffer != Buffer)
        {
            LOG((RTC_ERROR,
                 "%s BaseBuffer 0x%x is different from the Buffer 0x%x passed",
                 __fxName, pSipMsg->BaseBuffer, Buffer));
            hr = E_FAIL;
            goto done;
        }
        
        // Done parsing start line. Parse the headers.
        hr = ParseHeaders(Buffer, BufLen, &BytesParsed, pSipMsg);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s ParseHeaders failed", __fxName));
            goto done;
        }
        pSipMsg->ParseState = SIP_PARSE_STATE_HEADERS_DONE;
        // Fall through is intentional.
    
    case SIP_PARSE_STATE_HEADERS_DONE:
        if (pSipMsg->BaseBuffer != Buffer)
        {
            LOG((RTC_ERROR,
                 "%s BaseBuffer 0x%x is different from the Buffer 0x%x passed",
                 __fxName, pSipMsg->BaseBuffer, Buffer));
            hr = E_FAIL;
            goto done;
        }
        
        // Done Parsing Headers. Now Parse Message Body.
        hr = ParseMsgBody(Buffer, BufLen, &BytesParsed, IsEndOfData, pSipMsg);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s ParseMsgBody failed", __fxName));
            goto done;
        }

        pSipMsg->ParseState = SIP_PARSE_STATE_MESSAGE_BODY_DONE;
        break;

    default:
        ASSERT(FALSE);
        return E_FAIL;
    }

    *pBytesParsed = BytesParsed;
    return S_OK;
done:
    *pBytesParsed = BytesParsed;
    return hr;
}



///////////////////////////////////////////////////////////////////////////////
// CSeq
///////////////////////////////////////////////////////////////////////////////


HRESULT
ParseCSeq(
    IN      PSTR              Buffer,
    IN      ULONG             BufLen,
    IN  OUT ULONG            *pBytesParsed,
    OUT     ULONG            *pCSeq,
    OUT     SIP_METHOD_ENUM  *pCSeqMethodId,
    OUT     PSTR             *pMethodStr	
    )
{
    HRESULT         hr;
    OFFSET_STRING   MethodStr;

    ENTER_FUNCTION("ParseCSeq");
    
    hr = ParseUnsignedInteger(Buffer, BufLen, pBytesParsed,
                              pCSeq);
    if (hr != S_OK)
        return hr;

    ParseWhiteSpace(Buffer, BufLen, pBytesParsed);

    hr = ParseMethod(Buffer, BufLen, pBytesParsed,
                     &MethodStr, pCSeqMethodId);

    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s ParseMethod failed %x",
             __fxName, hr));
        return hr;
    }

    if (*pCSeqMethodId == SIP_METHOD_UNKNOWN)
    {
//          hr = AllocAndCopyString(MethodStr.GetString(Buffer),
//                                  MethodStr.GetLength(),
//                                  pMethodStr);
        hr = GetNullTerminatedString(MethodStr.GetString(Buffer),
                                     MethodStr.GetLength(),
                                     pMethodStr);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s GetNullTerminatedString failed %x",
                 __fxName, hr));
            return hr;
        }
    }
    else
    {
        *pMethodStr = NULL;
    }

    return S_OK;
}



///////////////////////////////////////////////////////////////////////////////
// URL/header-specific parsing functions (From, Contact, To, Via, CSeq,
// Record-Route)
///////////////////////////////////////////////////////////////////////////////


// Returns the quoted string with the quotes.
// Do we need to take care of any leading and trailing whitespace ?
HRESULT
ParseQuotedString(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed,
    OUT     OFFSET_STRING  *pQuotedString
    )
{
    ASSERT(Buffer[*pBytesParsed] == '"');
    ULONG Offset = *pBytesParsed;
    
    ULONG Length = 1;
    PSTR  BufEnd = Buffer + BufLen;
    PSTR  Buf    = Buffer + *pBytesParsed + 1;

    while (Buf < BufEnd && *Buf != '"')
    {
        if (*Buf == '\\' && Buf < (BufEnd - 1))
        {
            Buf += 2;
            Length += 2;
        }
        else
        {
            Buf++;
            Length++;
        }
    }

    if (Buf == BufEnd)
    {
        LOG((RTC_ERROR, "Couldn't find matching quote for quote at %d",
             *pBytesParsed));
        return E_FAIL;
    }

    pQuotedString->Offset = Offset;
    pQuotedString->Length = Length + 1;
    *pBytesParsed += pQuotedString->Length;
    return S_OK;
}


// Returns the comment including the brackets.
HRESULT
ParseComments(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed,
    OUT     OFFSET_STRING  *pCommentString
    )
{
    ASSERT(Buffer[*pBytesParsed] == '(');
    ULONG Offset = *pBytesParsed;

    ULONG Length          = 1;
    ULONG NumOpenBrackets = 1;

    PSTR  BufEnd = Buffer + BufLen;
    PSTR  Buf    = Buffer + *pBytesParsed + 1;

    while (Buf < BufEnd && NumOpenBrackets != 0);
    {
        if (*Buf == '\\' && Buf < (BufEnd - 1))
        {
            Buf += 2;
            Length += 2;
        }
        else if (*Buf == '(')
        {
            NumOpenBrackets++;
            Buf++;
            Length++;
        }
        else if (*Buf == ')')
        {
            NumOpenBrackets--;
            Buf++;
            Length++;
        }
        else
        {
            Buf++;
            Length++;
        }
    }

    if (NumOpenBrackets != 0)
    {
        LOG((RTC_ERROR, "Brackets in comments do not match NumOpenBrackets: %d",
             NumOpenBrackets));
        return E_FAIL;
    }

    pCommentString->Offset = Offset;
    pCommentString->Length = Length;
    *pBytesParsed = pCommentString->Length;
    return S_OK;
}


// Parse <addr-spec>
HRESULT
ParseAddrSpecInBrackets(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed,
    OUT     OFFSET_STRING  *pAddrSpec
    )
{
    ULONG Offset;
    ULONG Length;
    PSTR  Buf, BufEnd;

    ENTER_FUNCTION("ParseAddrSpecInBrackets");
    
    ParseWhiteSpace(Buffer, BufLen, pBytesParsed);
    if (*pBytesParsed == BufLen || Buffer[*pBytesParsed] != '<')
    {
        LOG((RTC_ERROR, "%s - Didn't find '<' - returning E_FAIL",
             __fxName));
        return E_FAIL;
    }
        
    (*pBytesParsed)++;
    ParseWhiteSpace(Buffer, BufLen, pBytesParsed);
        
    // Parse past '<'
    // Parse till '>' for addr-spec
    Buf    = Buffer + *pBytesParsed;
    BufEnd = Buffer + BufLen;
    Offset = *pBytesParsed;
    Length = 0;
        
    while (Buf < BufEnd && *Buf != '>')
    {
        Buf++;
        Length++;
    }

    if (Buf == BufEnd)
    {
        LOG((RTC_ERROR, "%s Didn't find matching '>'", __fxName));
        return E_FAIL;
    }
        
    pAddrSpec->Offset = Offset;
    pAddrSpec->Length = Length;
        
    // Get past '>'
    *pBytesParsed += Length + 1;

    return S_OK;
}


// Used for Contact / From / To
// Parse ( name-addr | addr-spec )
// HeaderListSeparator could be something like ',' in Contact header
HRESULT
ParseNameAddrOrAddrSpec(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed,
    IN      CHAR            HeaderListSeparator OPTIONAL,
    OUT     OFFSET_STRING  *pDisplayName,
    OUT     OFFSET_STRING  *pAddrSpec
    )
{
    HRESULT hr;

    ENTER_FUNCTION("ParseNameAddrOrAddrSpec");
    
    ParseWhiteSpace(Buffer, BufLen, pBytesParsed);
    if (*pBytesParsed == BufLen)
    {
        LOG((RTC_ERROR, "%s : reached end of buffer BufLen: %d",
             __fxName, BufLen));
        return E_FAIL;
    }

    PSTR  BufEnd      = Buffer + BufLen;
    PSTR  Buf         = Buffer + *pBytesParsed;
    
    ULONG Offset = *pBytesParsed;
    ULONG Length = 0;

    pDisplayName->Offset = 0;
    pDisplayName->Length = 0;
    pAddrSpec->Offset    = 0;
    pAddrSpec->Length    = 0;

    if (*Buf == '"')
    {
        // Parse quoted-string <addr-spec>
        hr = ParseQuotedString(Buffer, BufLen, pBytesParsed,
                               pDisplayName);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s  ParseQuotedString failed %x",
                 __fxName, hr));
            return hr;
        }
        
        // Parse <addr-spec>
        hr = ParseAddrSpecInBrackets(Buffer, BufLen, pBytesParsed,
                                     pAddrSpec);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s  ParseAddrSpecInBrackets failed %x",
                 __fxName, hr));
            return hr;
        }
    }
    else if (*Buf == '<')
    {
        // Parse <addr-spec>
        hr = ParseAddrSpecInBrackets(Buffer, BufLen, pBytesParsed,
                                     pAddrSpec);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s  ParseAddrSpecInBrackets failed %x",
                 __fxName, hr));
            return hr;
        }
    }
    else
    {
        // We could have either *token <addr-spec> or
        // addr-spec
        while (Buf < BufEnd && *Buf != '<' && *Buf != ';' &&
               ((HeaderListSeparator != '\0') ?
                (*Buf != HeaderListSeparator) : TRUE))
        {
            // We should have a bit map of the characters we allow here.
            // It should be union of token, space, tab and characters
            // that are allowed for a URI/URL.
            //if (!IsTokenChar(*Buf) && *Buf != ' ' && *Buf != '\t')
            //return E_FAIL;
            
            Buf++;
            Length++;
        }
        
        if ((Buf == BufEnd) ||
            (*Buf == ';') ||
            (HeaderListSeparator != '\0' && *Buf == HeaderListSeparator))
        {
            // This means the stuff we parsed so far is addr-spec,
            // we have no display name,
            // and we have hit either beginning of params or the end of this
            // entry in the header list or the end of the header
            pAddrSpec->Offset = Offset;
            pAddrSpec->Length = Length;
            *pBytesParsed += Length;
        }
        else
        {
            ASSERT(*Buf == '<');
            // This means the stuff we parsed so far is display-name
            // and we have to parse <addr-spec>
            pDisplayName->Offset = Offset;
            pDisplayName->Length = Length;
            *pBytesParsed += Length;
            
            hr = ParseAddrSpecInBrackets(Buffer, BufLen, pBytesParsed,
                                         pAddrSpec);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s  ParseAddrSpecInBrackets failed %x",
                     __fxName, hr));
                return hr;
            }
        }
    }
    
    return S_OK;
}


// Used for Record-Route / Route
// Parse [ display-name ] < addr-spec >
HRESULT
ParseNameAddr(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed,
    IN      CHAR            HeaderListSeparator OPTIONAL,
    OUT     OFFSET_STRING  *pDisplayName,
    OUT     OFFSET_STRING  *pAddrSpec
    )
{
    HRESULT hr;

    ENTER_FUNCTION("ParseNameAddr");
    
    ParseWhiteSpace(Buffer, BufLen, pBytesParsed);
    if (*pBytesParsed == BufLen)
    {
        LOG((RTC_ERROR, "%s : reached end of buffer BufLen: %d",
             __fxName, BufLen));
        return E_FAIL;
    }

    PSTR  BufEnd      = Buffer + BufLen;
    PSTR  Buf         = Buffer + *pBytesParsed;
    
    ULONG Offset = *pBytesParsed;
    ULONG Length = 0;

    pDisplayName->Offset = 0;
    pDisplayName->Length = 0;
    pAddrSpec->Offset    = 0;
    pAddrSpec->Length    = 0;

    if (*Buf == '"')
    {
        // Parse quoted-string <addr-spec>
        hr = ParseQuotedString(Buffer, BufLen, pBytesParsed,
                               pDisplayName);
        if (hr != S_OK)
            return hr;

        // Parse <addr-spec>
        hr = ParseAddrSpecInBrackets(Buffer, BufLen, pBytesParsed,
                                     pAddrSpec);
        if (hr != S_OK)
            return hr;
    }
    else if (*Buf == '<')
    {
        // Parse <addr-spec>
        hr = ParseAddrSpecInBrackets(Buffer, BufLen, pBytesParsed,
                                     pAddrSpec);
        if (hr != S_OK)
            return hr;
    }
    else
    {
        // We could have *token <addr-spec>
        while (Buf < BufEnd && *Buf != '<' &&
               ((HeaderListSeparator != '\0') ?
                (*Buf != HeaderListSeparator) : TRUE))
        {
            // We should have a bit map of the characters we allow here.
            // It should be union of token, space, tab and characters
            // that are allowed for a URI/URL.
            //if (!IsTokenChar(*Buf) && *Buf != ' ' && *Buf != '\t')
            //return E_FAIL;
            
            Buf++;
            Length++;
        }
        
        if ((Buf == BufEnd) ||
            (HeaderListSeparator != '\0' && *Buf == HeaderListSeparator))
        {
            // This means we haven't seen '<' before the end of the header.
            // This is an error.

            LOG((RTC_ERROR, "%s - '<' not found", __fxName));
            return E_FAIL;
        }
        else
        {
            ASSERT(*Buf == '<');
            // This means the stuff we parsed so far is display-name
            // and we have to parse <addr-spec>
            pDisplayName->Offset = Offset;
            pDisplayName->Length = Length;
            *pBytesParsed += Length;
            
            hr = ParseAddrSpecInBrackets(Buffer, BufLen, pBytesParsed,
                                         pAddrSpec);
            if (hr != S_OK)
                return hr;
        }
    }
    
    return S_OK;
}


// Output should be a HEADER_PARAM entry
// Parse one of the following :
// ; param OR
// ; pname = token OR
// ; pname = quoted-string
// If you have some other param type then you need
// to add it to this or parse it yourself
// 
// Strings returned in pParamName and pParamValue point to locations
// in Buffer and should not be freed.

// ParamsEndChar could be ',' for the Contact params

// We could probably implement this function without the
// ParamsEndChar param. When trying to parse a param
// we could look for a token char for the paramname and
// tokenchar/'"' for the param value. But it is probably more
// robust with the current implementation.

HRESULT ParseSipHeaderParam(
    IN      PSTR                    Buffer,
    IN      ULONG                   BufLen,
    IN OUT  ULONG                  *pBytesParsed,
    IN      CHAR                    ParamsEndChar OPTIONAL,
    OUT     SIP_HEADER_PARAM_ENUM  *pSipHeaderParamId,
    OUT     COUNTED_STRING         *pParamName,
    OUT     COUNTED_STRING         *pParamValue 
    )
{
    ENTER_FUNCTION("ParseSipHeaderParam");

    OFFSET_STRING   ParamName;
    OFFSET_STRING   ParamValue;
    HRESULT         hr;

    *pSipHeaderParamId = SIP_HEADER_PARAM_UNKNOWN;
    ZeroMemory(pParamName, sizeof(COUNTED_STRING));
    ZeroMemory(pParamValue, sizeof(COUNTED_STRING));
    
    ParseWhiteSpace(Buffer, BufLen, pBytesParsed);
    
    if (*pBytesParsed == BufLen ||
        (ParamsEndChar != '\0' && Buffer[*pBytesParsed] == ParamsEndChar))
    {
        // No params - end of header
        // 
        return S_OK;
    }
    else if (Buffer[*pBytesParsed] != ';')
    {
        // No params - some other character seen
        LOG((RTC_ERROR,
             "%s Found char %c instead of ';' while parsing for params",
             __fxName, Buffer[*pBytesParsed]));
        return E_FAIL;
    }
    else
    {
        // Parse the params
        // Go past the ';'
        (*pBytesParsed)++;
        ParseWhiteSpace(Buffer, BufLen, pBytesParsed);

        // Parse param name
        hr = ParseToken(Buffer, BufLen, pBytesParsed,
                        IsTokenChar,
                        &ParamName);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s failed to parse param name", __fxName));
            return hr;
        }

        pParamName->Buffer = ParamName.GetString(Buffer);
        pParamName->Length = ParamName.GetLength();

        *pSipHeaderParamId =
            GetSipHeaderParamId(pParamName->Buffer,
                                pParamName->Length);

        ParseWhiteSpace(Buffer, BufLen, pBytesParsed);

        // Parse param value
        if (*pBytesParsed == BufLen ||
            (ParamsEndChar != '\0' && Buffer[*pBytesParsed] == ParamsEndChar) ||
            (Buffer[*pBytesParsed] == ';'))
        {
            // No param value.
            return S_OK;
        }
        else
        {
            // We have a Param value to be parsed.

            ParseWhiteSpace(Buffer, BufLen, pBytesParsed);
            if (*pBytesParsed         == BufLen ||
                Buffer[*pBytesParsed] != '=')
            {
                return E_FAIL;
            }

            (*pBytesParsed)++;
            
            ParseWhiteSpace(Buffer, BufLen, pBytesParsed);
            if (*pBytesParsed == BufLen)
            {
                return E_FAIL;
            }
            
            if (Buffer[*pBytesParsed] == '"')
            {
                hr = ParseQuotedString(Buffer, BufLen, pBytesParsed, &ParamValue);
                if (hr != S_OK)
                {
                    LOG((RTC_ERROR, "%s failed to parse param value quoted-string",
                         __fxName));
                    return hr;
                }
            }
            else
            {
                hr = ParseToken(Buffer, BufLen, pBytesParsed,
                                IsTokenChar,
                                &ParamValue);
                if (hr != S_OK)
                {
                    LOG((RTC_ERROR, "%s failed to parse param value token",
                         __fxName));
                    return hr;
                }
            }
        }

        pParamValue->Buffer = ParamValue.GetString(Buffer);
        pParamValue->Length = ParamValue.GetLength();

        // ParseWhiteSpace(Buffer, BufLen, pBytesParsed);
        return S_OK;
    }
}


int 
MonthToInt(
    IN  char *psMonth
    )
{
	static char* monthNames[12] = {"Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"};
	int			 i;

    for (i = 0; i < 12; i++)
	{
        if (_strnicmp(monthNames[i], psMonth, 3) == 0)
        {
			return i;
		}
	}

    return 0;
}


HRESULT 
parseSIPTime(
    IN  PSTR  pStr, 
    IN  time_t *pTime,
    IN  ULONG   BufLen
    )
{
	char 		  *	pEndStr;
    struct tm		tmDateTime;
	HRESULT			hr = E_FAIL;
    time_t			time = 0;

	memset(&tmDateTime, 0, sizeof(struct tm));

	// check for a  comma, to skip the day
    while ( *pStr && *pStr != ',')
    {
    	pStr++;
        BufLen--;
    }
    if (*pStr)
    {
		pStr++; 
        BufLen--;
        while( *pStr && 
               ((*pStr == ' ') || (*pStr == '\t')) 
             )	
        {
            pStr++;
            BufLen--;
        }
        if( (int)BufLen < 20 )
		{
			// date time string is too small
		}	
		else
		{
			tmDateTime.tm_mday  = strtol(pStr, &pEndStr, 10);
			tmDateTime.tm_mon   = MonthToInt(pStr + 3);
			tmDateTime.tm_year  = strtol(pStr+7, &pEndStr, 10) - 1900;
			tmDateTime.tm_hour  = strtol(pStr+12, &pEndStr, 10);
			tmDateTime.tm_min   = strtol(pStr+15, &pEndStr, 10);
			tmDateTime.tm_sec   = strtol(pStr+18, &pEndStr, 10);
			tmDateTime.tm_isdst = -1;

			time = mktime(&tmDateTime);
			if (time != -1)
			{
				hr = S_OK;
				*pTime = time;
			}
		}
    } 
  
    return hr;
}


int
ParseExpiresValue(
    IN  PSTR    expiresHdr,
    IN  ULONG   BufLen
    )
{
    HRESULT hr;
    INT     expireTimeout = 0;
    PSTR    tempPtr = expiresHdr;
    CHAR    pstrTemp[21];
    time_t  Time;


    hr = GetNextWord( &tempPtr, pstrTemp, sizeof pstrTemp );

    if( hr == S_OK )
    {
        if( pstrTemp[strlen(pstrTemp) - 1] == ',' )
        {
            hr = parseSIPTime( expiresHdr, &Time, BufLen );
            
            if( hr == S_OK )
            {
                if( Time > time(0) )
                {
                    expireTimeout = (int) (Time - time(0));
                }
            }
        }
        else
        {
            expireTimeout = atoi( pstrTemp );
        }
    }
    else
    {
        return -1;
    }

    if( expireTimeout < 0 )
    {
        return -1;
    }

    if( expireTimeout != 0 )
    {
        // Start the process of re-registration 10 minutes before expiration.
        if( expireTimeout >= TWENTY_MINUTES )
        {
            expireTimeout -= TEN_MINUTES;
        }
        else if( expireTimeout > TEN_MINUTES )
        {
            expireTimeout = TEN_MINUTES;
        }
        else if( expireTimeout >= TWO_MINUTES )
        {
            expireTimeout -= 60; //1 minute before expiration
        }
    }

    return expireTimeout;
}


HRESULT
ParseQValue(
    IN  PSTR    Buffer,
    IN  ULONG   BufLen,
    OUT double *pQValue
    )
{
    HRESULT hr;
    PSTR    szBuf;

    ENTER_FUNCTION("ParseQValue");
    
    *pQValue = 0;

    hr = GetNullTerminatedString(Buffer, BufLen, &szBuf);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s GetNullTerminatedString failed %x",
             __fxName, hr));
        return hr;
    }

    *pQValue = atof(szBuf);
    free(szBuf);
    
    return S_OK;
}


// If we hit a ',' we parse past the ','
// So, the next header can be parsed from *pBytesParsed on return

HRESULT
ParseContactHeader(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed,
    OUT     CONTACT_HEADER *pContactHeader
    )
{
    HRESULT                 hr;
    OFFSET_STRING           DisplayName;
    OFFSET_STRING           AddrSpec;

    SIP_HEADER_PARAM_ENUM   HeaderParamId;
    COUNTED_STRING          HeaderParamName;
    COUNTED_STRING          HeaderParamValue;

    ENTER_FUNCTION("ParseContactHeader");

    ZeroMemory(&pContactHeader->m_DisplayName,
               sizeof(COUNTED_STRING));
    ZeroMemory(&pContactHeader->m_SipUrl,
               sizeof(COUNTED_STRING));
    pContactHeader->m_QValue = 0;

    hr = ParseNameAddrOrAddrSpec(Buffer, BufLen, pBytesParsed,
                                 ',', // comma indicates end of contact entry
                                 &DisplayName, &AddrSpec);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s ParseNameAddrOrAddrSpec failed at %d",
             __fxName, *pBytesParsed));
        return hr;
    }

    if (DisplayName.GetLength() != 0)
    {
        hr = AllocCountedString(
                 DisplayName.GetString(Buffer),
                 DisplayName.GetLength(),
                 &pContactHeader->m_DisplayName
                 );

        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s allocating displayname failed %x",
                 __fxName, hr));
            return hr;
        }
    }
    
    if (AddrSpec.GetLength() != 0)
    {
        hr = AllocCountedString(
                 AddrSpec.GetString(Buffer),
                 AddrSpec.GetLength(),
                 &pContactHeader->m_SipUrl
                 );

        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s allocating Sip URL failed %x",
                 __fxName, hr));
            return hr;
        }
    }
    
    while (*pBytesParsed < BufLen)
    {
        ParseWhiteSpace(Buffer, BufLen, pBytesParsed);

        if (*pBytesParsed == BufLen)
        {
            return S_OK;
        }

        if (Buffer[*pBytesParsed] == ',')
        {
            // Parse past comma
            (*pBytesParsed)++;

            // We are done with this Contact header.
            break;
        }
        else if (Buffer[*pBytesParsed] == ';')
        {
            hr = ParseSipHeaderParam(Buffer, BufLen, pBytesParsed,
                                     ',', // comma indicates end of contact entry
                                     &HeaderParamId,
                                     &HeaderParamName,
                                     &HeaderParamValue
                                     );
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s ParseSipHeaderParam failed at %d",
                     __fxName, *pBytesParsed));
                return hr;
            }

            if (HeaderParamId == SIP_HEADER_PARAM_QVALUE)
            {
                hr = ParseQValue(HeaderParamValue.Buffer,
                                 HeaderParamValue.Length,
                                 &pContactHeader->m_QValue);
                if (hr != S_OK)
                {
                    LOG((RTC_ERROR, "%s ParseQValued failed", __fxName));
                    // Keep default Q value of 0
                }
            }

            if (HeaderParamId == SIP_HEADER_PARAM_EXPIRES)
            {
                pContactHeader->m_ExpiresValue = 
                    ParseExpiresValue(HeaderParamValue.Buffer,
                                      HeaderParamValue.Length);
            }
        }
        else
        {
            LOG((RTC_ERROR,
                 "%s invalid char %c found when trying to parse params",
                 __fxName, Buffer[*pBytesParsed]));
            return E_FAIL;
        }
    }

    return S_OK;    
}


HRESULT
ParseFromOrToHeader(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed,
    OUT     FROM_TO_HEADER *pFromToHeader
    )
{
    ENTER_FUNCTION("ParseFromOrToHeader");

    HRESULT                 hr;
    OFFSET_STRING           DisplayName;
    OFFSET_STRING           AddrSpec;

    SIP_HEADER_PARAM_ENUM   HeaderParamId;
    COUNTED_STRING          HeaderParamName;
    COUNTED_STRING          HeaderParamValue;

    ZeroMemory(&pFromToHeader->m_DisplayName,
               sizeof(COUNTED_STRING));
    ZeroMemory(&pFromToHeader->m_SipUrl,
               sizeof(COUNTED_STRING));
    ZeroMemory(&pFromToHeader->m_TagValue,
               sizeof(COUNTED_STRING));

    hr = ParseNameAddrOrAddrSpec(Buffer, BufLen, pBytesParsed,
                                 '\0', // no header list separator
                                 &DisplayName, &AddrSpec);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s ParseNameAddrOrAddrSpec failed at %d",
             __fxName, *pBytesParsed));
        return hr;
    }

    if (DisplayName.GetLength() != 0)
    {
        hr = AllocCountedString(
                 DisplayName.GetString(Buffer),
                 DisplayName.GetLength(),
                 &pFromToHeader->m_DisplayName
                 );

        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s allocating displayname failed %x",
                 __fxName, hr));
            return hr;
        }
    }
    
    if (AddrSpec.GetLength() != 0)
    {
        hr = AllocCountedString(
                 AddrSpec.GetString(Buffer),
                 AddrSpec.GetLength(),
                 &pFromToHeader->m_SipUrl
                 );

        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s allocating sip url failed %x",
                 __fxName, hr));
            return hr;
        }
    }
    
    while (*pBytesParsed < BufLen)
    {
        ParseWhiteSpace(Buffer, BufLen, pBytesParsed);

        if (*pBytesParsed == BufLen)
        {
            // done.
            return S_OK;
        }

        if (Buffer[*pBytesParsed] == ';')
        {
            hr = ParseSipHeaderParam(Buffer, BufLen, pBytesParsed,
                                     '\0', // no header list separator
                                     &HeaderParamId,
                                     &HeaderParamName,
                                     &HeaderParamValue
                                     );
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s ParseSipHeaderParam failed at %d",
                     __fxName, *pBytesParsed));
                return hr;
            }

            if (HeaderParamId == SIP_HEADER_PARAM_TAG)
            {
                hr = AllocCountedString(
                         HeaderParamValue.Buffer,
                         HeaderParamValue.Length,
                         &pFromToHeader->m_TagValue
                         );
                if (hr != S_OK)
                {
                    LOG((RTC_ERROR, "%s allocating tag value failed",
                         __fxName));
                    return hr;
                }
            }
            else
            {
                // Add it to the param list.
                SIP_HEADER_PARAM *pSipHeaderParam;

                pSipHeaderParam = new SIP_HEADER_PARAM();
                if (pSipHeaderParam == NULL)
                {
                    LOG((RTC_ERROR, "%s allocating sip url param failed",
                         __fxName));
                    return E_OUTOFMEMORY;
                }

                hr = pSipHeaderParam->SetParamNameAndValue(
                         SIP_HEADER_PARAM_UNKNOWN,
                         &HeaderParamName,
                         &HeaderParamValue
                         );
                if (hr != S_OK)
                {
                    LOG((RTC_ERROR, "%s SetParamNameAndValue failed %x",
                         __fxName, hr));
                    return hr;
                }

                InsertTailList(&pFromToHeader->m_ParamList,
                               &pSipHeaderParam->m_ListEntry);
            }
        }
        else
        {
            LOG((RTC_ERROR,
                 "%s invalid char %c found when trying to parse params",
                 __fxName, Buffer[*pBytesParsed]));
            return E_FAIL;
        }
    }

    return S_OK;    
}


HRESULT
ParseRecordRouteHeader(
    IN      PSTR                 Buffer,
    IN      ULONG                BufLen,
    IN OUT  ULONG               *pBytesParsed,
    OUT     RECORD_ROUTE_HEADER *pRecordRouteHeader
    )
{
    ENTER_FUNCTION("ParseRecordRouteHeader");

    HRESULT                 hr;
    OFFSET_STRING           DisplayName;
    OFFSET_STRING           AddrSpec;

    SIP_HEADER_PARAM_ENUM   HeaderParamId;
    COUNTED_STRING          HeaderParamName;
    COUNTED_STRING          HeaderParamValue;

    ZeroMemory(&pRecordRouteHeader->m_DisplayName,
               sizeof(COUNTED_STRING));
    ZeroMemory(&pRecordRouteHeader->m_SipUrl,
               sizeof(COUNTED_STRING));
    
    hr = ParseNameAddr(Buffer, BufLen, pBytesParsed,
                       ',', // ',' separates headers
                       &DisplayName, &AddrSpec);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s ParseNameAddr failed at %d",
             __fxName, *pBytesParsed));
        return hr;
    }

    if (DisplayName.GetLength() != 0)
    {
        hr = AllocCountedString(
                 DisplayName.GetString(Buffer),
                 DisplayName.GetLength(),
                 &pRecordRouteHeader->m_DisplayName
                 );

        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s allocating displayname failed %x",
                 __fxName, hr));
            return hr;
        }
    }
    
    if (AddrSpec.GetLength() != 0)
    {
        hr = AllocCountedString(
                 AddrSpec.GetString(Buffer),
                 AddrSpec.GetLength(),
                 &pRecordRouteHeader->m_SipUrl
                 );

        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s allocating sip url failed %x",
                 __fxName, hr));
            return hr;
        }
    }
    
    while (*pBytesParsed < BufLen)
    {
        ParseWhiteSpace(Buffer, BufLen, pBytesParsed);

        if (*pBytesParsed == BufLen)
        {
            // done.
            return S_OK;
        }

        if (Buffer[*pBytesParsed] == ',')
        {
            // Parse past comma
            (*pBytesParsed)++;

            // We are done with this Record-Route header.
            break;
        }
        else if (Buffer[*pBytesParsed] == ';')
        {
            hr = ParseSipHeaderParam(Buffer, BufLen, pBytesParsed,
                                     ',', // ',' separates headers
                                     &HeaderParamId,
                                     &HeaderParamName,
                                     &HeaderParamValue
                                     );
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s ParseSipHeaderParam failed at %d",
                     __fxName, *pBytesParsed));
                return hr;
            }

            // Add it to the param list.
            SIP_HEADER_PARAM *pSipHeaderParam;
            
            pSipHeaderParam = new SIP_HEADER_PARAM();
            if (pSipHeaderParam == NULL)
            {
                LOG((RTC_ERROR, "%s allocating sip header param failed",
                     __fxName));
                return E_OUTOFMEMORY;
            }
            
            hr = pSipHeaderParam->SetParamNameAndValue(
                     SIP_HEADER_PARAM_UNKNOWN,
                     &HeaderParamName,
                     &HeaderParamValue
                     );
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s SetParamNameAndValue failed %x",
                     __fxName, hr));
                return hr;
            }
            
            InsertTailList(&pRecordRouteHeader->m_ParamList,
                           &pSipHeaderParam->m_ListEntry);
        }
        else
        {
            LOG((RTC_ERROR,
                 "%s invalid char %c found when trying to parse params",
                 __fxName, Buffer[*pBytesParsed]));
            return E_FAIL;
        }
    }

    return S_OK;    
}


HRESULT
ParseSentProtocol(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed
    )
{
    HRESULT         hr;
    SIP_VERSION     SipVersion;
    OFFSET_STRING   Protocol;

    ENTER_FUNCTION("ParseSentProtocol");
    
    // Parse SIP / 2.0
    hr = ParseSipVersion(Buffer, BufLen, pBytesParsed, &SipVersion);
    if (hr != S_OK)
    {
        return E_FAIL;
    }

    ParseWhiteSpace(Buffer, BufLen, pBytesParsed);
    
    hr = ParseKnownString(Buffer, BufLen, pBytesParsed,
                          "/", sizeof("/") - 1,
                          TRUE // case-sensitive
                          );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s Parsing for '/' failed",
             __fxName));
        return E_FAIL;
    }
    

    ParseWhiteSpace(Buffer, BufLen, pBytesParsed);
    
    hr = ParseToken(Buffer, BufLen, pBytesParsed,
                    IsTokenChar,
                    &Protocol);

    return hr;
}


// Parse host[:port]
HRESULT
ParseHostPort(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed,
    OUT     OFFSET_STRING  *pHost,
    OUT     USHORT         *pPort 
    )
{
    HRESULT hr;

    pHost->Offset = 0;
    pHost->Length = 0;
    *pPort        = 0;

    ENTER_FUNCTION("ParseHostPort");

    //hr = ParseHost(Buffer, BufLen, pBytesParsed, pHost);
    // Parse Hostname | IPaddress
    hr = ParseToken(Buffer, BufLen, pBytesParsed,
                    IsHostChar,
                    pHost);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - ParseHost failed %x", __fxName, hr));
        return hr;
    }

    ParseWhiteSpace(Buffer, BufLen, pBytesParsed);

    if (*pBytesParsed < BufLen && Buffer[*pBytesParsed] == ':')
    {
        (*pBytesParsed)++;
        ParseWhiteSpace(Buffer, BufLen, pBytesParsed);
        if (*pBytesParsed < BufLen && isdigit(Buffer[*pBytesParsed]))
        {
            ULONG ulPort;
            hr = ParseUnsignedInteger(Buffer, BufLen, pBytesParsed, &ulPort);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s Parsing port (ParseUnsignedInteger) failed %x",
                     __fxName, hr));
                return hr;
            }
            // Is there some constant defined that can be used instead of 65535 ?
            if (ulPort > 65535)
            {
                LOG((RTC_ERROR, "%s - Port %d is greater than 65535",
                     __fxName, ulPort));
                return E_FAIL;
            }
            
            *pPort = (USHORT) ulPort;
            return S_OK;
        }
        else
        {
            LOG((RTC_ERROR, "%s - parsing port failed", __fxName));
            return E_FAIL;
        }
    }

    return S_OK;
}


// Parse the first via header in
// 1#( sent-protocol sent-by *( ; via-params ) [ comment ] )
// Used for From, To, Contact
// XXX TODO How do we deal with concealed-host stuff ?
// Is the usage of this field negotiated earlier ?

// pHost->Buffer points to a location in the buffer and should
// not be freed.

HRESULT
ParseFirstViaHeader(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed,
    OUT     COUNTED_STRING *pHost,
    OUT     USHORT         *pPort 
    )
{
    HRESULT hr;

    SIP_HEADER_PARAM_ENUM   HeaderParamId;
    COUNTED_STRING          HeaderParamName;
    COUNTED_STRING          HeaderParamValue;
    OFFSET_STRING           Host;

    ENTER_FUNCTION("ParseFirstViaHeader");
    
    ParseWhiteSpace(Buffer, BufLen, pBytesParsed);
    if (*pBytesParsed == BufLen)
    {
        LOG((RTC_ERROR, "%s - Empty Via header", __fxName));
        return E_FAIL;
    }

    pHost->Buffer = NULL;
    pHost->Length = 0;
    *pPort        = 0;

    hr = ParseSentProtocol(Buffer, BufLen, pBytesParsed);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s ParseSentProtocol failed %x", __fxName, hr));
        return hr;
    }
    
    ParseWhiteSpace(Buffer, BufLen, pBytesParsed);
    
    hr = ParseHostPort(Buffer, BufLen, pBytesParsed, &Host, pPort);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s ParseHostPort failed %x", __fxName, hr));
        return hr;
    }

    pHost->Buffer = Host.GetString(Buffer);
    pHost->Length = Host.GetLength();
        
    while (*pBytesParsed < BufLen)
    {
        ParseWhiteSpace(Buffer, BufLen, pBytesParsed);

        if (*pBytesParsed == BufLen)
        {
            return S_OK;
        }

        if (Buffer[*pBytesParsed] == ',')
        {
            // Parse past comma
            (*pBytesParsed)++;

            // We are done with this via header.
            break;
        }
        else if (Buffer[*pBytesParsed] == ';')
        {
            hr = ParseSipHeaderParam(Buffer, BufLen, pBytesParsed,
                                     ',', // comma indicates end of contact entry
                                     &HeaderParamId,
                                     &HeaderParamName,
                                     &HeaderParamValue
                                     );
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s ParseSipHeaderParam failed at %d",
                     __fxName, *pBytesParsed));
                return hr;
            }

            if (HeaderParamId == SIP_HEADER_PARAM_VIA_MADDR)
            {
                // maddr param overrides the host field in the via.
                pHost->Buffer = HeaderParamValue.Buffer;
                pHost->Length = HeaderParamValue.Length;
            }
        }
        else
        {
            LOG((RTC_ERROR,
                 "%s invalid char %c found when trying to parse params",
                 __fxName, Buffer[*pBytesParsed]));
            return E_FAIL;
        }
    }

    return S_OK;    
}



// Output should be a SIP_URL_PARAM entry
// Parse one of the following :
// ; 1*paramchar = 1*paramchar
// On return buffers in pSipUrlParamName and pSipUrlParamValue
// point to locations in Buffer and should not be freed.

HRESULT ParseSipUrlParam(
    IN      PSTR                Buffer,
    IN      ULONG               BufLen,
    IN OUT  ULONG              *pBytesParsed,
    OUT     SIP_URL_PARAM_ENUM *pSipUrlParamId,
    OUT     COUNTED_STRING     *pSipUrlParamName,
    OUT     COUNTED_STRING     *pSipUrlParamValue
    )
{
    ENTER_FUNCTION("ParseSipUrlParam");

    OFFSET_STRING   ParamName;
    OFFSET_STRING   ParamValue;
    HRESULT         hr;

    *pSipUrlParamId = SIP_URL_PARAM_UNKNOWN;
    ZeroMemory(pSipUrlParamName, sizeof(COUNTED_STRING));
    ZeroMemory(pSipUrlParamValue, sizeof(COUNTED_STRING));
    
    ParseWhiteSpace(Buffer, BufLen, pBytesParsed);
    if (*pBytesParsed == BufLen)
    {
        // No params - end of URL
        return S_OK;
    }
    else if (Buffer[*pBytesParsed] != ';')
    {
        // No params - some other character seen
        LOG((RTC_ERROR,
             "%s Found char %c instead of ';' while parsing for params",
             __fxName, Buffer[*pBytesParsed]));
        return E_FAIL;
    }
    else
    {
        // Parse the params
        // Go past the ';'
        (*pBytesParsed)++;
        ParseWhiteSpace(Buffer, BufLen, pBytesParsed);

        // Parse param name
        hr = ParseToken(Buffer, BufLen, pBytesParsed,
                        IsSipUrlParamChar,
                        &ParamName);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s failed to parse param name", __fxName));
            return hr;
        }

        pSipUrlParamName->Buffer = ParamName.GetString(Buffer);
        pSipUrlParamName->Length = ParamName.GetLength();

        *pSipUrlParamId = GetSipUrlParamId(pSipUrlParamName->Buffer,
                                           pSipUrlParamName->Length);

        // Parse '='
        
        ParseWhiteSpace(Buffer, BufLen, pBytesParsed);

        if (*pBytesParsed == BufLen ||
            Buffer[*pBytesParsed] != '=')
        {
            LOG((RTC_ERROR, "%s Didn't find '=' while parsing SIP URL param",
                 __fxName));
            return E_FAIL;
        }

        // Parse past '='
        (*pBytesParsed)++;
        
        // Parse param value

        ParseWhiteSpace(Buffer, BufLen, pBytesParsed);
        
        if (*pBytesParsed == BufLen)
        {
            LOG((RTC_ERROR, "%s Didn't find Param value while parsing URL param",
                 __fxName));
            return E_FAIL;
        }
        
        hr = ParseToken(Buffer, BufLen, pBytesParsed,
                        IsSipUrlParamChar,
                        &ParamValue);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s failed to parse param value token",
                 __fxName));
            return hr;
        }
        
        pSipUrlParamValue->Buffer = ParamValue.GetString(Buffer);
        pSipUrlParamValue->Length = ParamValue.GetLength();

        return S_OK;
    }
}


SIP_TRANSPORT
GetSipTransportId(
    IN  PSTR    Buffer,
    IN  ULONG   BufLen
    )
{
    if (AreCountedStringsEqual(Buffer, BufLen,
                               "udp", strlen("udp"),
                               FALSE    // case-insensitive
                               ))
    {
        return SIP_TRANSPORT_UDP;
    }
    else if (AreCountedStringsEqual(Buffer, BufLen,
                                    "tcp", strlen("tcp"),
                                    FALSE    // case-insensitive
                                    ))
    {
        return SIP_TRANSPORT_TCP;
    }
    else if (AreCountedStringsEqual(Buffer, BufLen,
                                    "ssl", strlen("ssl"),
                                    FALSE    // case-insensitive
                                    ))
    {
        return SIP_TRANSPORT_SSL;
    }
    else if (AreCountedStringsEqual(Buffer, BufLen,
                                    "tls", strlen("tls"),
                                    FALSE    // case-insensitive
                                    ))
    {
        return SIP_TRANSPORT_SSL;
    }
    else
    {
        return SIP_TRANSPORT_UNKNOWN;
    }                
}


HRESULT
ParseSipUrlParams(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed,
    OUT     SIP_URL        *pSipUrl
    )
{
    HRESULT             hr;
    SIP_URL_PARAM_ENUM  SipUrlParamId;
    COUNTED_STRING      SipUrlParamName;
    COUNTED_STRING      SipUrlParamValue;

    ENTER_FUNCTION("ParseSipUrlParams");
    
    while (*pBytesParsed < BufLen)
    {
        ParseWhiteSpace(Buffer, BufLen, pBytesParsed);

        if (*pBytesParsed == BufLen)
        {
            return S_OK;
        }

        if (Buffer[*pBytesParsed] == '?')
        {
            // Parse headers
            return S_OK;
        }
        else if (Buffer[*pBytesParsed] == ';')
        {
            hr = ParseSipUrlParam(Buffer, BufLen, pBytesParsed,
                                  &SipUrlParamId,
                                  &SipUrlParamName,
                                  &SipUrlParamValue
                                  );
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s ParseSipUrlParam failed at %d",
                     __fxName, *pBytesParsed));
                return hr;
            }

            if (SipUrlParamId != SIP_URL_PARAM_UNKNOWN)
            {
                ASSERT(SipUrlParamId < SIP_URL_PARAM_MAX);
                
                if (SipUrlParamId == SIP_URL_PARAM_TRANSPORT)
                {
                    if (SipUrlParamValue.Buffer != NULL)
                    {
                        pSipUrl->m_TransportParam =
                            GetSipTransportId(SipUrlParamValue.Buffer,
                                              SipUrlParamValue.Length
                                              );
                    }
                }
                
                hr = AllocCountedString(
                         SipUrlParamValue.Buffer,
                         SipUrlParamValue.Length,
                         &pSipUrl->m_KnownParams[SipUrlParamId]
                         );
                if (hr != S_OK)
                {
                    LOG((RTC_ERROR, "%s allocating known param (%d) failed",
                         __fxName, SipUrlParamId));
                    return hr;
                }
            }
            else
            {
                // Add it to the other params list.
                
                SIP_URL_PARAM *pSipUrlParam;

                pSipUrlParam = new SIP_URL_PARAM();
                if (pSipUrlParam == NULL)
                {
                    LOG((RTC_ERROR, "%s allocating sip url param failed",
                         __fxName));
                    return E_OUTOFMEMORY;
                }

                hr = pSipUrlParam->SetParamNameAndValue(
                         SIP_URL_PARAM_UNKNOWN,
                         &SipUrlParamName,
                         &SipUrlParamValue
                         );
                if (hr != S_OK)
                {
                    LOG((RTC_ERROR, "%s SetParamNameAndValue failed %x",
                         __fxName, hr));
                    return hr;
                }

                InsertTailList(&pSipUrl->m_OtherParamList,
                               &pSipUrlParam->m_ListEntry);
            }

        }
        else
        {
            LOG((RTC_ERROR,
                 "%s invalid char %c found when trying to parse params",
                 __fxName, Buffer[*pBytesParsed]));
            return E_FAIL;
        }
    }

    return S_OK;
}


// Output should be a SIP_URL_PARAM entry
// Parse one of the following :
// ; 1*hnvchar = *hnvchar
// On return buffers in pSipUrlHeaderName and pSipUrlHeaderValue
// point to locations in Buffer and should not be freed.

HRESULT ParseSipUrlHeader(
    IN      PSTR                Buffer,
    IN      ULONG               BufLen,
    IN OUT  ULONG              *pBytesParsed,
    OUT     SIP_HEADER_ENUM    *pSipUrlHeaderId,
    OUT     COUNTED_STRING     *pSipUrlHeaderName,
    OUT     COUNTED_STRING     *pSipUrlHeaderValue
    )
{
    ENTER_FUNCTION("ParseSipUrlHeader");

    OFFSET_STRING   HeaderName;
    OFFSET_STRING   HeaderValue;
    HRESULT         hr;

    *pSipUrlHeaderId = SIP_HEADER_UNKNOWN;
    ZeroMemory(pSipUrlHeaderName, sizeof(COUNTED_STRING));
    ZeroMemory(pSipUrlHeaderValue, sizeof(COUNTED_STRING));
    
    ParseWhiteSpace(Buffer, BufLen, pBytesParsed);
    if (*pBytesParsed == BufLen)
    {
        // No params - end of URL
        return S_OK;
    }
    else if (Buffer[*pBytesParsed] != '?' &&
             Buffer[*pBytesParsed] != '&')
    {
        // No params - some other character seen
        LOG((RTC_ERROR,
             "%s Found char %c instead of '?' or '&' while parsing for params",
             __fxName, Buffer[*pBytesParsed]));
        return E_FAIL;
    }
    else
    {
        // Parse the params
        // Go past the '?' or '&'
        (*pBytesParsed)++;
        ParseWhiteSpace(Buffer, BufLen, pBytesParsed);

        // Parse param name
        hr = ParseToken(Buffer, BufLen, pBytesParsed,
                        IsSipUrlHeaderChar,
                        &HeaderName);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s failed to parse header name token",
                 __fxName));
            return hr;
        }

        pSipUrlHeaderName->Buffer = HeaderName.GetString(Buffer);
        pSipUrlHeaderName->Length = HeaderName.GetLength();

        *pSipUrlHeaderId = GetSipHeaderId(pSipUrlHeaderName->Buffer,
                                          pSipUrlHeaderName->Length);

        // Parse '='
        
        ParseWhiteSpace(Buffer, BufLen, pBytesParsed);

        if (*pBytesParsed == BufLen ||
            Buffer[*pBytesParsed] != '=')
        {
            LOG((RTC_ERROR, "%s Didn't find '=' while parsing SIP URL header",
                 __fxName));
            return E_FAIL;
        }

        // Parse past '='
        (*pBytesParsed)++;
        
        // Parse param value

        ParseWhiteSpace(Buffer, BufLen, pBytesParsed);
        
        if (*pBytesParsed == BufLen ||
            *pBytesParsed == '&')
        {
            // No Header Value
            pSipUrlHeaderValue->Buffer = NULL;
            pSipUrlHeaderValue->Length = 0;
        }
        else 
        {
            // We have a header value to parse.
            
            hr = ParseToken(Buffer, BufLen, pBytesParsed,
                            IsSipUrlHeaderChar,
                            &HeaderValue);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s failed to parse header value token",
                     __fxName));
                return hr;
            }
        
            pSipUrlHeaderValue->Buffer = HeaderValue.GetString(Buffer);
            pSipUrlHeaderValue->Length = HeaderValue.GetLength();
        }

        return S_OK;
    }
}


HRESULT
ParseSipUrlHeaders(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed,
    OUT     SIP_URL        *pSipUrl
    )
{
    SIP_URL_HEADER   *pSipUrlHeader;
    SIP_HEADER_ENUM   SipUrlHeaderId;
    COUNTED_STRING    SipUrlHeaderName;
    COUNTED_STRING    SipUrlHeaderValue;
    HRESULT           hr;
    

    ENTER_FUNCTION("ParseSipUrlHeaders");
    
    while (*pBytesParsed < BufLen)
    {
        ParseWhiteSpace(Buffer, BufLen, pBytesParsed);

        if (*pBytesParsed == BufLen)
        {
            // done
            return S_OK;
        }

        if (Buffer[*pBytesParsed] == '?' ||
            Buffer[*pBytesParsed] == '&')
        {
            hr = ParseSipUrlHeader(Buffer, BufLen, pBytesParsed,
                                   &SipUrlHeaderId,
                                   &SipUrlHeaderName,
                                   &SipUrlHeaderValue);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s ParseSipUrlHeader failed at %d",
                     __fxName, *pBytesParsed));
                return hr;
            }
            pSipUrlHeader = new SIP_URL_HEADER();
            if (pSipUrlHeader == NULL)
            {
                LOG((RTC_ERROR, "%s allocating sip url header failed",
                     __fxName));
                return E_OUTOFMEMORY;
            }

            hr = pSipUrlHeader->SetHeaderNameAndValue(
                     SipUrlHeaderId,
                     &SipUrlHeaderName,
                     &SipUrlHeaderValue
                     );
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s SetHeaderNameAndValue failed %x",
                     __fxName, hr));
                return hr;
            }

            InsertTailList(&pSipUrl->m_HeaderList,
                           &pSipUrlHeader->m_ListEntry);
        }
        else
        {
            LOG((RTC_ERROR,
                 "%s invalid char %c found when trying to parse params",
                 __fxName, Buffer[*pBytesParsed]));
            return E_FAIL;
        }
    }

    return S_OK;
}


// pUser and pPassword contain buffers
// allocated using malloc() and they should be freed using
// free() when not required.
// XXX take care of whitespace around :
HRESULT
ParseUserinfo(
    IN  PSTR             Buffer,
    IN  ULONG            BufLen,
    OUT COUNTED_STRING  *pUser,
    OUT COUNTED_STRING  *pPassword
    )
{
    ULONG   ColonOffset = 0;
    HRESULT hr;

    ENTER_FUNCTION("ParseUserinfo");
    
    ZeroMemory(pUser, sizeof(COUNTED_STRING));
    ZeroMemory(pPassword, sizeof(COUNTED_STRING));

    while (ColonOffset < BufLen)
    {
        if (Buffer[ColonOffset] == ':')
        {
            // found colon
            break;
        }

        ColonOffset++;
    }

    if (ColonOffset < BufLen)
    {
        hr = AllocCountedString(Buffer + ColonOffset + 1,
                                BufLen - ColonOffset - 1,
                                pPassword);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s - allocating password failed %x",
                 __fxName, hr));
            return hr;
        }
    }

    hr = AllocCountedString(Buffer, ColonOffset, pUser);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - allocating user failed %x",
             __fxName, hr));
        return hr;
    }
    
    return S_OK;
}


// Parse sip: [userinfo @] host [:port] [; url-params] [?headers]
// Currently just parse host and port - in future we have
// to parse the params and headers.
HRESULT
ParseSipUrl(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed,
    OUT     SIP_URL        *pSipUrl
    )
{
    HRESULT         hr;
    OFFSET_STRING   Host;
    USHORT          Port = 0;

    ENTER_FUNCTION("ParseSipUrl");
    
    hr = ParseKnownString(Buffer, BufLen, pBytesParsed,
                          "sip:", sizeof("sip:") - 1,
                          FALSE // case-insensitive
                          );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s Parsing for \"sip:\" failed",
             __fxName));
        return RTC_E_INVALID_SIP_URL;
    }

    ParseWhiteSpace(Buffer, BufLen, pBytesParsed);
    
    if (*pBytesParsed == BufLen)
    {
        LOG((RTC_ERROR,
             "%s Didn't find host while parsing SIP URL",
             __fxName));
        return RTC_E_INVALID_SIP_URL;
    }
        
    PSTR    BufEnd = Buffer + BufLen;
    PSTR    Buf    = Buffer + *pBytesParsed;
    ULONG   Length = 0;
    
    while (Buf < BufEnd && *Buf != '@')
    {
        Buf++;
        Length++;
    }
        
    if (Buf == BufEnd)
    {
        // The URL does not have user-info
        pSipUrl->m_User.Buffer     = NULL;
        pSipUrl->m_User.Length     = 0;
        pSipUrl->m_Password.Buffer = NULL;
        pSipUrl->m_Password.Length = 0;
        
        hr = ParseHostPort(Buffer, BufLen, pBytesParsed, &Host, &Port);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s - ParseHostPort failed %x", __fxName, hr));
            return RTC_E_INVALID_SIP_URL;
        }

    }
    else
    {
        ASSERT(*Buf == '@');
        
        // The stuff we parsed so far is the user-info
        hr = ParseUserinfo(Buffer + *pBytesParsed, Length,
                           &pSipUrl->m_User,
                           &pSipUrl->m_Password);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s ParseUserinfo failed %x",
                 __fxName, hr));
            return RTC_E_INVALID_SIP_URL;
        }
        
        *pBytesParsed += Length + 1;
        hr = ParseHostPort(Buffer, BufLen, pBytesParsed, &Host, &Port);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s - ParseHostPort failed %x", __fxName, hr));
            return RTC_E_INVALID_SIP_URL;
        }
    }

    // Copy the host and port.
    
    hr = AllocCountedString(Host.GetString(Buffer),
                            Host.GetLength(),
                            &pSipUrl->m_Host);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s allocating host failed %x",
             __fxName, hr));
        return hr;
    }

    pSipUrl->m_Port = Port;
    
    // Parse Params
    hr = ParseSipUrlParams(Buffer, BufLen, pBytesParsed, pSipUrl);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s ParseSipUrlParams failed %x",
             __fxName, hr));
        return RTC_E_INVALID_SIP_URL;
    }

    // Parse Headers.
    
    hr = ParseSipUrlHeaders(Buffer, BufLen, pBytesParsed, pSipUrl);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s ParseSipUrlHeaders failed %x",
             __fxName, hr));
        return RTC_E_INVALID_SIP_URL;
    }

    return S_OK;
}


BOOL
IsOneOfContentTypeXpidf(
    IN  PSTR    ContentTypeHdr,
    IN  ULONG   ContentTypeHdrLen
    )
{
    PSTR    TempContentTypeHdr = ContentTypeHdr;
    ULONG   TempContentTypeHdrLen = ContentTypeHdrLen;
    ULONG   BytesParsed = 0;

    if( IsContentTypeXpidf( ContentTypeHdr, ContentTypeHdrLen ) == TRUE )
    {
        return TRUE;
    }

    while( SkipToKnownChar( TempContentTypeHdr, ContentTypeHdrLen, &BytesParsed, ',' ) )
    {
        TempContentTypeHdrLen -= BytesParsed;
        TempContentTypeHdr += BytesParsed;

        if( IsContentTypeXpidf( TempContentTypeHdr, TempContentTypeHdrLen ) )
        {
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
IsOneOfContentTypeSdp(
    IN  PSTR    ContentTypeHdr,
    IN  ULONG   ContentTypeHdrLen
    )
{
    PSTR    TempContentTypeHdr = ContentTypeHdr;
    ULONG   TempContentTypeHdrLen = ContentTypeHdrLen;
    ULONG   BytesParsed = 0;

    if( IsContentTypeSdp( ContentTypeHdr, ContentTypeHdrLen ) == TRUE )
    {
        return TRUE;
    }

    while( SkipToKnownChar( TempContentTypeHdr, ContentTypeHdrLen, &BytesParsed, ',' ) )
    {
        TempContentTypeHdrLen -= BytesParsed;
        TempContentTypeHdr += BytesParsed;

        if( IsContentTypeSdp( TempContentTypeHdr, TempContentTypeHdrLen ) )
        {
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
IsOneOfContentTypeTextRegistration(
    IN  PSTR    ContentTypeHdr,
    IN  ULONG   ContentTypeHdrLen
    )
{
    PSTR    TempContentTypeHdr = ContentTypeHdr;
    ULONG   TempContentTypeHdrLen = ContentTypeHdrLen;
    ULONG   BytesParsed = 0;

    if( IsContentTypeTextRegistration( ContentTypeHdr, ContentTypeHdrLen ) == TRUE )
    {
        return TRUE;
    }

    while( SkipToKnownChar( TempContentTypeHdr, ContentTypeHdrLen, &BytesParsed, ',' ) )
    {
        TempContentTypeHdrLen -= BytesParsed;
        TempContentTypeHdr += BytesParsed;

        if( IsContentTypeTextRegistration( TempContentTypeHdr, TempContentTypeHdrLen ) )
        {
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
IsOneOfContentTypeTextPlain(
    IN  PSTR    ContentTypeHdr,
    IN  ULONG   ContentTypeHdrLen
    )
{
    PSTR    TempContentTypeHdr = ContentTypeHdr;
    ULONG   TempContentTypeHdrLen = ContentTypeHdrLen;
    ULONG   BytesParsed = 0;

    if( IsContentTypeTextPlain( ContentTypeHdr, ContentTypeHdrLen ) == TRUE )
    {
        return TRUE;
    }

    while( SkipToKnownChar( TempContentTypeHdr, ContentTypeHdrLen, &BytesParsed, ',' ) )
    {
        TempContentTypeHdrLen -= BytesParsed;
        TempContentTypeHdr += BytesParsed;

        if( IsContentTypeTextPlain( TempContentTypeHdr, TempContentTypeHdrLen ) )
        {
            return TRUE;
        }
    }

    return FALSE;
}


// Use this for Content-Type header

BOOL
IsContentTypeXpidf(
    IN  PSTR    ContentTypeHdr,
    IN  ULONG   ContentTypeHdrLen
    )
{
    HRESULT hr;
    ULONG   BytesParsed = 0;

    ENTER_FUNCTION("IsContentTypeXpidf");
    
    ParseWhiteSpace(ContentTypeHdr, ContentTypeHdrLen, &BytesParsed);

    hr = ParseKnownString(ContentTypeHdr, ContentTypeHdrLen, &BytesParsed,
                          SIP_CONTENT_TYPE_XPIDF_MEDIA_TYPE,
                          sizeof(SIP_CONTENT_TYPE_XPIDF_MEDIA_TYPE) - 1,
                          FALSE // case-insensitive
                          );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s Parsing for \"%s\" failed",
             __fxName, SIP_CONTENT_TYPE_XPIDF_MEDIA_TYPE));
        return FALSE;
    }

    ParseWhiteSpace(ContentTypeHdr, ContentTypeHdrLen, &BytesParsed);
    
    hr = ParseKnownString(ContentTypeHdr, ContentTypeHdrLen, &BytesParsed,
                          "/", sizeof("/") - 1,
                          TRUE // case-sensitive
                          );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s Parsing for \"/\" failed",
             __fxName));
        return FALSE;
    }

    ParseWhiteSpace(ContentTypeHdr, ContentTypeHdrLen, &BytesParsed);
    
    hr = ParseKnownString(ContentTypeHdr, ContentTypeHdrLen, &BytesParsed,
                          SIP_CONTENT_TYPE_XPIDF_MEDIA_SUBTYPE,
                          sizeof(SIP_CONTENT_TYPE_XPIDF_MEDIA_SUBTYPE) - 1,
                          FALSE // case-insensitive
                          );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s Parsing for \"%s\" failed",
             __fxName, SIP_CONTENT_TYPE_XPIDF_MEDIA_SUBTYPE));
        return FALSE;
    }

    return TRUE;
}


BOOL
IsContentTypeSdp(
    IN  PSTR    ContentTypeHdr,
    IN  ULONG   ContentTypeHdrLen
    )
{
    HRESULT hr;
    ULONG   BytesParsed = 0;

    ENTER_FUNCTION("IsContentTypeSdp");

    ParseWhiteSpace(ContentTypeHdr, ContentTypeHdrLen, &BytesParsed);    

    hr = ParseKnownString(ContentTypeHdr, ContentTypeHdrLen, &BytesParsed,
                          SIP_CONTENT_TYPE_SDP_MEDIA_TYPE,
                          sizeof(SIP_CONTENT_TYPE_SDP_MEDIA_TYPE) - 1,
                          FALSE // case-insensitive
                          );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s Parsing for \"%s\" failed",
             __fxName, SIP_CONTENT_TYPE_SDP_MEDIA_TYPE));
        return FALSE;
    }

    ParseWhiteSpace(ContentTypeHdr, ContentTypeHdrLen, &BytesParsed);
    
    hr = ParseKnownString(ContentTypeHdr, ContentTypeHdrLen, &BytesParsed,
                          "/", sizeof("/") - 1,
                          TRUE // case-sensitive
                          );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s Parsing for \"/\" failed",
             __fxName));
        return FALSE;
    }

    ParseWhiteSpace(ContentTypeHdr, ContentTypeHdrLen, &BytesParsed);
    
    hr = ParseKnownString(ContentTypeHdr, ContentTypeHdrLen, &BytesParsed,
                          SIP_CONTENT_TYPE_SDP_MEDIA_SUBTYPE,
                          sizeof(SIP_CONTENT_TYPE_SDP_MEDIA_SUBTYPE) - 1,
                          FALSE // case-insensitive
                          );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s Parsing for \"%s\" failed",
             __fxName, SIP_CONTENT_TYPE_SDP_MEDIA_SUBTYPE));
        return FALSE;
    }

    return TRUE;
}


BOOL
IsContentTypeTextRegistration(
    IN  PSTR    ContentTypeHdr,
    IN  ULONG   ContentTypeHdrLen
    )
{
    HRESULT hr;
    ULONG   BytesParsed = 0;

    ENTER_FUNCTION("IsContentTypeTextPlain");
    
    ParseWhiteSpace(ContentTypeHdr, ContentTypeHdrLen, &BytesParsed);
    
    hr = ParseKnownString(ContentTypeHdr, ContentTypeHdrLen, &BytesParsed,
                          SIP_CONTENT_TYPE_TEXTREG_MEDIA_TYPE,
                          sizeof(SIP_CONTENT_TYPE_TEXTREG_MEDIA_TYPE) - 1,
                          FALSE // case-insensitive
                          );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s Parsing for \"%s\" failed",
             __fxName, SIP_CONTENT_TYPE_TEXTREG_MEDIA_TYPE));
        return FALSE;
    }

    ParseWhiteSpace(ContentTypeHdr, ContentTypeHdrLen, &BytesParsed);
    
    hr = ParseKnownString(ContentTypeHdr, ContentTypeHdrLen, &BytesParsed,
                          "/", sizeof("/") - 1,
                          TRUE // case-sensitive
                          );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s Parsing for \"/\" failed",
             __fxName));
        return FALSE;
    }

    ParseWhiteSpace(ContentTypeHdr, ContentTypeHdrLen, &BytesParsed);
    
    hr = ParseKnownString(ContentTypeHdr, ContentTypeHdrLen, &BytesParsed,
                          SIP_CONTENT_TYPE_TEXTREG_MEDIA_SUBTYPE,
                          sizeof(SIP_CONTENT_TYPE_TEXTREG_MEDIA_SUBTYPE) - 1,
                          FALSE // case-insensitive
                          );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s Parsing for \"%s\" failed",
             __fxName, SIP_CONTENT_TYPE_TEXTREG_MEDIA_SUBTYPE));
        return FALSE;
    }

    return TRUE;
}


BOOL
IsContentTypeTextPlain(
    IN  PSTR    ContentTypeHdr,
    IN  ULONG   ContentTypeHdrLen
    )
{
    HRESULT hr;
    ULONG   BytesParsed = 0;

    ENTER_FUNCTION("IsContentTypeTextPlain");
    
    ParseWhiteSpace(ContentTypeHdr, ContentTypeHdrLen, &BytesParsed);
    
    hr = ParseKnownString(ContentTypeHdr, ContentTypeHdrLen, &BytesParsed,
                          SIP_CONTENT_TYPE_MSGTEXT_MEDIA_TYPE,
                          sizeof(SIP_CONTENT_TYPE_MSGTEXT_MEDIA_TYPE) - 1,
                          FALSE // case-insensitive
                          );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s Parsing for \"%s\" failed",
             __fxName, SIP_CONTENT_TYPE_MSGTEXT_MEDIA_TYPE));
        return FALSE;
    }

    ParseWhiteSpace(ContentTypeHdr, ContentTypeHdrLen, &BytesParsed);
    
    hr = ParseKnownString(ContentTypeHdr, ContentTypeHdrLen, &BytesParsed,
                          "/", sizeof("/") - 1,
                          TRUE // case-sensitive
                          );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s Parsing for \"/\" failed",
             __fxName));
        return FALSE;
    }

    ParseWhiteSpace(ContentTypeHdr, ContentTypeHdrLen, &BytesParsed);
    
    hr = ParseKnownString(ContentTypeHdr, ContentTypeHdrLen, &BytesParsed,
                          SIP_CONTENT_TYPE_MSGTEXT_MEDIA_SUBTYPE,
                          sizeof(SIP_CONTENT_TYPE_MSGTEXT_MEDIA_SUBTYPE) - 1,
                          FALSE // case-insensitive
                          );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s Parsing for \"%s\" failed",
             __fxName, SIP_CONTENT_TYPE_MSGTEXT_MEDIA_SUBTYPE));
        return FALSE;
    }

    return TRUE;
}

BOOL
IsContentTypeAppXml(
    IN  PSTR    ContentTypeHdr,
    IN  ULONG   ContentTypeHdrLen
    )
{
    HRESULT hr;
    ULONG   BytesParsed = 0;

    ENTER_FUNCTION("IsContentTypeTextPlain");
    
    hr = ParseKnownString(ContentTypeHdr, ContentTypeHdrLen, &BytesParsed,
                          SIP_CONTENT_TYPE_MSGXML_MEDIA_TYPE,
                          sizeof(SIP_CONTENT_TYPE_MSGXML_MEDIA_TYPE) - 1,
                          FALSE // case-insensitive
                          );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s Parsing for \"%s\" failed",
             __fxName, SIP_CONTENT_TYPE_MSGXML_MEDIA_TYPE));
        return FALSE;
    }

    ParseWhiteSpace(ContentTypeHdr, ContentTypeHdrLen, &BytesParsed);
    
    hr = ParseKnownString(ContentTypeHdr, ContentTypeHdrLen, &BytesParsed,
                          "/", sizeof("/") - 1,
                          TRUE // case-sensitive
                          );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s Parsing for \"/\" failed",
             __fxName));
        return FALSE;
    }

    ParseWhiteSpace(ContentTypeHdr, ContentTypeHdrLen, &BytesParsed);
    
    hr = ParseKnownString(ContentTypeHdr, ContentTypeHdrLen, &BytesParsed,
                          SIP_CONTENT_TYPE_MSGXML_MEDIA_SUBTYPE,
                          sizeof(SIP_CONTENT_TYPE_MSGXML_MEDIA_SUBTYPE) - 1,
                          FALSE // case-insensitive
                          );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s Parsing for \"%s\" failed",
             __fxName, SIP_CONTENT_TYPE_MSGXML_MEDIA_SUBTYPE));
        return FALSE;
    }

    return TRUE;
}


HRESULT
UpdateProxyInfo(
    IN  SIP_SERVER_INFO    *pProxyInfo
    )
{
    HRESULT hr = S_OK;
    PSTR    DstUrl;
    ULONG   DstUrlLen;
    ULONG   BytesParsed;
    SIP_URL DecodedSipUrl;
    PSTR    ProxyAddress;
    ULONG   ProxyAddressLen;
    ULONG   StringLength;
    ULONG   AddressLength;

    ENTER_FUNCTION("UpdateProxyInfo");
    
    hr = UnicodeToUTF8( pProxyInfo->ServerAddress,
                &ProxyAddress, &ProxyAddressLen );

    if( hr != S_OK )
    {
        LOG(( RTC_ERROR, "%s UnicodeToUTF8 failed %x", __fxName, hr ));
        return hr;
    }

    hr = ParseSipUrl( ProxyAddress, ProxyAddressLen,
            &BytesParsed, &DecodedSipUrl );

    if( hr != S_OK )
    {
        LOG(( RTC_ERROR, "%s ParseSipUrl failed %x", __fxName, hr ));
            
        free( (PVOID)ProxyAddress );
        return hr;
    }

    if( pProxyInfo -> TransportProtocol == SIP_TRANSPORT_UNKNOWN )
    {
        if( DecodedSipUrl.m_TransportParam != SIP_TRANSPORT_UNKNOWN )
        {
            pProxyInfo -> TransportProtocol = DecodedSipUrl.m_TransportParam;
        }
        else
        {
            pProxyInfo -> TransportProtocol = SIP_TRANSPORT_UDP;
        }
    }

    AddressLength = DecodedSipUrl.m_Host.Length;
    strncpy( ProxyAddress, DecodedSipUrl.m_Host.Buffer, AddressLength );

    if (DecodedSipUrl.m_Port != 0)
    {
        AddressLength += sprintf(ProxyAddress + DecodedSipUrl.m_Host.Length,
                                 ":%d", DecodedSipUrl.m_Port);
    }
    
    StringLength = MultiByteToWideChar(CP_UTF8, 0,
                                       ProxyAddress, AddressLength,
                                       pProxyInfo -> ServerAddress,
                                       wcslen(pProxyInfo->ServerAddress) );
    free( (PVOID)ProxyAddress );

    if( StringLength == 0 )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    pProxyInfo->ServerAddress[ StringLength ] = L'\0';
    
    return S_OK;
}


HRESULT
ParseBadHeaderInfo(
    PSTR                    Buffer,
    ULONG                   BufLen,
    PARSED_BADHEADERINFO   *pParsedBadHeaderInfo
    )
{
    OFFSET_STRING   HeaderName;
    ULONG           BytesParsed = 0;
    HRESULT         hr = S_OK;
    
    ParseWhiteSpace(Buffer, BufLen, &BytesParsed); 

    // Parse the Header name
    hr = ParseToken(Buffer, BufLen, &BytesParsed,
                    IsTokenChar,
                    &HeaderName);
    if (hr != S_OK)
    {
        return hr;
    }
    
    pParsedBadHeaderInfo -> HeaderId = GetSipHeaderId(
        HeaderName.GetString(Buffer), HeaderName.GetLength() );

    ParseWhiteSpace( Buffer, BufLen, &BytesParsed );

    hr = ParseKnownString(Buffer, BufLen, &BytesParsed,
                      ";", sizeof(";") - 1,
                      FALSE // case-insensitive
                      );
    if( hr != S_OK )
    {
        return hr;
    }
    
    ParseWhiteSpace(Buffer, BufLen, &BytesParsed);
    
    hr = ParseKnownString(Buffer, BufLen, &BytesParsed,
                      "ExpectedValue", sizeof("ExpectedValue") - 1,
                      FALSE // case-insensitive
                      );
    if( hr != S_OK )
    {
        return hr;
    }

    ParseWhiteSpace(Buffer, BufLen, &BytesParsed);

    hr = ParseKnownString(Buffer, BufLen, &BytesParsed,
                      "=", sizeof("=") - 1,
                      FALSE // case-insensitive
                      );
    if( hr != S_OK )
    {
        return hr;
    }
    
    ParseWhiteSpace(Buffer, BufLen, &BytesParsed);

    hr = ParseQuotedString(Buffer, BufLen, &BytesParsed,
                               &pParsedBadHeaderInfo->ExpectedValue );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "ParseQuotedString failed %x", hr ));
    }


    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\sipstack.cpp ===
#include "precomp.h"
#include "sipstack.h"
#include "sipcall.h"
#include "pintcall.h"
#include "register.h"
#include "messagecall.h"
#include "reqfail.h"
#include "options.h"
#include "presence.h"
#include "register.h"

// These macros take the IP address in host order.
#define IS_MULTICAST_ADDRESS(i) (((long)(i) & 0xf0000000) == 0xe0000000)
#define IS_LOOPBACK_ADDRESS(i) (((long)(i) & 0xff000000) == 0x7f000000)

#define SIP_STACK_WINDOW_CLASS_NAME    \
    _T("SipStackWindowClassName-e0176168-7492-476f-a0c1-72c582956c3b")
// Defined in asyncwi.cpp
HRESULT RegisterWorkItemWindowClass();
HRESULT RegisterWorkItemCompletionWindowClass();


HANDLE                  g_hAddrChange;
OVERLAPPED              g_ovAddrChange;
HANDLE                  g_hEventAddrChange;
HANDLE                  g_hAddrChangeWait;
LIST_ENTRY              g_SipStackList;
CRITICAL_SECTION        g_SipStackListCriticalSection;
BOOL                    g_SipStackCSIsInitialized = FALSE;

// Global variable to keep track of when we should do
// SipStackGlobalInit and SipStackGlobalShutdown
ULONG g_NumSipStacks = 0;

HRESULT RegisterIPAddrChangeNotifications();
VOID UnregisterIPAddrChangeNotifications();

HRESULT SipStackGlobalInit();
VOID SipStackGlobalShutdown();

HRESULT SipStackList_Insert(
            SIP_STACK* sipStack
            )
{
    HRESULT hr;
    ENTER_FUNCTION("SipStackList_Insert");
    
    EnterCriticalSection(&g_SipStackListCriticalSection);
    InsertTailList(&g_SipStackList, &sipStack->m_StackListEntry);

    if (g_NumSipStacks == 0)
    {
        hr = SipStackGlobalInit();
        if (hr != S_OK)
        {
            LOG((RTC_ERROR,
                 "%s - SipStackList_Insert failed %x",
                 __fxName, hr));
            return hr;
        }
    }

    ++g_NumSipStacks;
    LeaveCriticalSection(&g_SipStackListCriticalSection);
    return S_OK;
}


void SipStackList_Delete(
         SIP_STACK *pSipStack
         )
{
    EnterCriticalSection(&g_SipStackListCriticalSection);
    //Go thru the list to find the record and remove from the list
    if (pSipStack->m_StackListEntry.Flink != NULL)
    {
        // Remove the SipStackWindow from the SipStackWindow list
        RemoveEntryList(&pSipStack->m_StackListEntry);
    }

    --g_NumSipStacks;

    if (g_NumSipStacks == 0)
    {
        SipStackGlobalShutdown();
    }
    
    LeaveCriticalSection(&g_SipStackListCriticalSection);
}


void SipStackList_PostIPAddrChangeMessageAndNotify()
{
    SIP_STACK *pSipStack;
    LIST_ENTRY* pListEntry;
    HRESULT hr;
    ENTER_FUNCTION("SipStackList_PostIPAddrChangeMessageAndNotify");
    EnterCriticalSection(&g_SipStackListCriticalSection);
    pListEntry = g_SipStackList.Flink;
    while (pListEntry != &g_SipStackList)
    {
        pSipStack = CONTAINING_RECORD( pListEntry, SIP_STACK, m_StackListEntry );
        pListEntry = pListEntry->Flink;
        // Post a message
        if (!PostMessage(pSipStack->GetSipStackWindow(),
                         WM_SIP_STACK_IPADDR_CHANGE,
                         (WPARAM) pSipStack, 0))
        {
            DWORD Error = GetLastError();
        
            LOG((RTC_ERROR, "%s PostMessage failed : %x",
                 __fxName, Error));
        }
    }
    hr = NotifyAddrChange(&g_hAddrChange, &g_ovAddrChange);
    if (hr != ERROR_SUCCESS && hr != ERROR_IO_PENDING)
    {
        LOG((RTC_ERROR, "%s  NotifyAddrChange failed %x",
             __fxName, hr));
    }
    LeaveCriticalSection(&g_SipStackListCriticalSection);
}

// Defined in asock.cpp
LRESULT WINAPI SocketWindowProc(
    IN HWND    Window, 
    IN UINT    MessageID,
    IN WPARAM  Parameter1,
    IN LPARAM  Parameter2
    );


// Defined in timer.cpp
LRESULT WINAPI TimerWindowProc(
    IN HWND    Window, 
    IN UINT    MessageID,
    IN WPARAM  Parameter1,
    IN LPARAM  Parameter2
    );


LRESULT WINAPI
SipStackWindowProc(
    IN HWND    Window, 
    IN UINT    MessageID,
    IN WPARAM  Parameter1,
    IN LPARAM  Parameter2
    )
{
    SIP_STACK *pSipStack;

    ENTER_FUNCTION("SipStackWindowProc");

    switch (MessageID)
    {
    case WM_SIP_STACK_IPADDR_CHANGE:
        pSipStack = (SIP_STACK *) Parameter1;
        pSipStack->OnIPAddrChange();
        return 0;

    case WM_SIP_STACK_NAT_ADDR_CHANGE:
        pSipStack = (SIP_STACK *) Parameter1;
        pSipStack->OnNatAddressChange();
        return 0;

    case WM_SIP_STACK_TRANSACTION_SOCKET_ERROR:

        SIP_TRANSACTION *pSipTransaction;
        pSipTransaction = (SIP_TRANSACTION *) Parameter1;

        // We decrement the AsyncNotifyCount before we make the callback
        // as the callback could call Shutdown() which will release all
        // the async notify references.
        pSipTransaction->DecrementAsyncNotifyCount();
        
        pSipTransaction->OnSocketError((DWORD) Parameter2);
        
        // Release the reference obtained in AsyncNotifyTransaction
        pSipTransaction->TransactionRelease();
        return 0;
        
    case WM_SIP_STACK_TRANSACTION_REQ_SOCK_CONNECT_COMPLETE:

        OUTGOING_TRANSACTION *pOutgoingTransaction;
        pOutgoingTransaction = (OUTGOING_TRANSACTION *) Parameter1;

        // We decrement the AsyncNotifyCount before we make the callback
        // as the callback could call Shutdown() which will release all
        // the async notify references.
        pOutgoingTransaction->DecrementAsyncNotifyCount();
        
        pOutgoingTransaction->OnRequestSocketConnectComplete((DWORD) Parameter2);
        
        // Release the reference obtained in AsyncNotifyTransaction
        pOutgoingTransaction->TransactionRelease();
        return 0;
        
    default:
        return DefWindowProc(Window, MessageID, Parameter1, Parameter2);
    }
}


HRESULT RegisterSocketWindowClass()
{
    // Register the Window class for async i/o on sockets.
    WNDCLASS    WindowClass;
    WSADATA     WsaData;
    int         err;
    
    ZeroMemory(&WindowClass, sizeof WindowClass);

    WindowClass.lpfnWndProc     = SocketWindowProc;
    WindowClass.lpszClassName   = SOCKET_WINDOW_CLASS_NAME;
    WindowClass.hInstance       = _Module.GetResourceInstance();  // may not be necessary

    if (!RegisterClass(&WindowClass))
    {
        DWORD Error = GetLastError();
        LOG((RTC_ERROR, "Socket RegisterClass failed: %x", Error));
        // return E_FAIL;
    }

    LOG((RTC_TRACE, "RegisterSocketWindowClass succeeded"));
    return S_OK;
}


HRESULT RegisterTimerWindowClass()
{
    // Register the Window class for async i/o on sockets.
    WNDCLASS    WindowClass;
    
    ZeroMemory(&WindowClass, sizeof WindowClass);

    WindowClass.lpfnWndProc     = TimerWindowProc;
    WindowClass.lpszClassName   = TIMER_WINDOW_CLASS_NAME;
    WindowClass.hInstance       = _Module.GetResourceInstance();  // may not be necessary

    if (!RegisterClass(&WindowClass))
    {
        DWORD Error = GetLastError();
        LOG((RTC_ERROR, "Timer RegisterClass failed: %x", Error));
        // return E_FAIL;
    }

    LOG((RTC_TRACE, "RegisterTimerWindowClass succeeded"));
    return S_OK;
}


HRESULT RegisterSipStackWindowClass()
{
    // Register the Window class for async i/o on sockets.
    WNDCLASS    WindowClass;
    
    ZeroMemory(&WindowClass, sizeof WindowClass);

    WindowClass.lpfnWndProc     = SipStackWindowProc;
    WindowClass.lpszClassName   = SIP_STACK_WINDOW_CLASS_NAME;
    WindowClass.hInstance       = _Module.GetResourceInstance();  // may not be necessary

    if (!RegisterClass(&WindowClass))
    {
        DWORD Error = GetLastError();
        LOG((RTC_ERROR, "SipStack RegisterClass failed: %x", Error));
        // return E_FAIL;
    }

    LOG((RTC_TRACE, "RegisterSipStackWindowClass succeeded"));
    return S_OK;
}


// This needs to be called only once (regardless of the
// number of SIP_STACKs created).
// Called with the global critical section held.

HRESULT SipStackGlobalInit()
{
    HRESULT     hr;
    WSADATA     WsaData;
    int         err;

    ENTER_FUNCTION("SipStackGlobalInit");

    // Initialize any global state
    g_hAddrChange    = NULL;
    ZeroMemory(&g_ovAddrChange, sizeof(OVERLAPPED));
    g_hEventAddrChange  = NULL;
    g_hAddrChangeWait  = NULL;

    hr = RegisterIPAddrChangeNotifications();
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s  RegisterIPAddrChangeNotifications failed %x",
             __fxName, hr));
        return hr;
    }
    
    hr = RegisterSocketWindowClass();
    if (hr != S_OK)
        return hr;
    
    hr = RegisterTimerWindowClass();
    if (hr != S_OK)
        return hr;
    
    hr = RegisterSipStackWindowClass();
    if (hr != S_OK)
        return hr;
    
    // Register the workitem window class.
    hr = RegisterWorkItemWindowClass();
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s RegisterWorkItemWindowClass failed %x",
             __fxName, hr));
        return hr;
    }
    
    // Create workitem completion window class.
    hr = RegisterWorkItemCompletionWindowClass();
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s RegisterWorkItemCompletionWindowClass failed %x",
             __fxName, hr));
        return hr;
    }
    
    // Initialize Winsock
    err = WSAStartup (MAKEWORD (1, 1), &WsaData);
    if (err != 0)
    {
        LOG((RTC_ERROR,
             "WSAStartup Failed error: %d",
             err));
        return HRESULT_FROM_WIN32(err);
    }
    
    return S_OK;
}

// Called with the global critical section held.

VOID SipStackGlobalShutdown()
{
    int err;

    ENTER_FUNCTION("SipStackGlobalShutdown");

    LOG((RTC_TRACE, "%s - Enter", __fxName));
    
    // Shutdown Winsock
    err = WSACleanup();
    if (err != 0)
    {
        LOG((RTC_ERROR, "WSACleanup Failed error: %d",
             err));
    }

    UnregisterIPAddrChangeNotifications();

    // Unregister Window classes.
    if (!UnregisterClass(SOCKET_WINDOW_CLASS_NAME,
                         _Module.GetResourceInstance()))
    {
        LOG((RTC_ERROR, "%s - unregister socket window class failed %x",
             __fxName, GetLastError()));
    }
                    
    if (!UnregisterClass(TIMER_WINDOW_CLASS_NAME,
                         _Module.GetResourceInstance()))
    {
        LOG((RTC_ERROR, "%s - unregister timer window class failed %x",
             __fxName, GetLastError()));
    }                    
    
    if (!UnregisterClass(SIP_STACK_WINDOW_CLASS_NAME,
                         _Module.GetResourceInstance()))
    {
        LOG((RTC_ERROR, "%s - unregister SipStack window class failed %x",
             __fxName, GetLastError()));
    }                    

    if (!UnregisterClass(WORKITEM_WINDOW_CLASS_NAME,
                         _Module.GetResourceInstance()))
    {
        LOG((RTC_ERROR, "%s - unregister Work item window class failed %x",
             __fxName, GetLastError()));
    }                    

    if (!UnregisterClass(WORKITEM_COMPLETION_WINDOW_CLASS_NAME,
                         _Module.GetResourceInstance()))
    {
        LOG((RTC_ERROR, "%s - unregister work item completion window class failed %x",
             __fxName, GetLastError()));
    }                    

    LOG((RTC_TRACE, "%s - done", __fxName));
}


HRESULT
SipCreateStack(
    IN  IRTCMediaManage  *pMediaManager,
    OUT ISipStack       **ppSipStack
    )
{
    SIP_STACK  *pSipStack;
    HRESULT     hr;

    ENTER_FUNCTION("SipCreateStack");

    if (!g_SipStackCSIsInitialized)
    {
        LOG((RTC_ERROR, "%s - Sipstack CS not inited",
             __fxName));
        return E_FAIL;
    }
    
    pSipStack = new SIP_STACK(pMediaManager);
    if (pSipStack == NULL)
    {
        return E_OUTOFMEMORY;
    }
    
    hr = SipStackList_Insert(pSipStack);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s SipStackList_Insert failed %x",
             __fxName, hr));
        return hr;
    }
    
    hr = pSipStack->Init();
    if (hr != S_OK)
    {
        pSipStack->Shutdown();
        delete pSipStack;
        return hr;
    }
    
    *ppSipStack = pSipStack;
    return S_OK;
}


// Called on DLL load
HRESULT
SipStackInitialize()
{
    ENTER_FUNCTION("SipStackInitialize");
    
    g_SipStackCSIsInitialized = TRUE;

    __try
    {
        InitializeCriticalSection(&g_SipStackListCriticalSection);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        g_SipStackCSIsInitialized = FALSE;
    }

    if (!g_SipStackCSIsInitialized)
    {
        LOG((RTC_ERROR, "%s  initializing sipstack critsec failed", __fxName));
        return E_OUTOFMEMORY;
    }

    InitializeListHead(&g_SipStackList);
    
    return S_OK;
}


// Called on DLL unload
HRESULT SipStackShutdown()
{
    if (g_SipStackCSIsInitialized)
    {
        DeleteCriticalSection(&g_SipStackListCriticalSection);
        g_SipStackCSIsInitialized = FALSE;
    }

    return S_OK;
}


// ISipStack implementation

SIP_STACK::SIP_STACK(
    IN IRTCMediaManage *pMediaManager
    ) :
    m_SockMgr(this)
{
    m_Signature             = 'SPSK';
    
    m_RefCount              = 1;
    m_pNotifyInterface      = NULL;

    m_SipStackWindow        = NULL;
    m_StackListEntry.Flink       = NULL;
    m_StackListEntry.Blink       = NULL;

    m_isSipStackShutDown    = FALSE;

    m_pMediaManager         = pMediaManager;
    m_pMediaManager->AddRef();

    m_AllowIncomingCalls    = FALSE;
    m_EnableStaticPort      = FALSE;

    m_NumMsgProcessors      = 0;
    m_PreparingForShutdown  = FALSE;
    
    m_NumProfiles           = 0;
    m_ProviderProfileArray  = NULL;

    InitializeListHead(&m_ListenSocketList);

    InitializeListHead(&m_MsgProcList);

    m_pMibIPAddrTable       = NULL;
    m_MibIPAddrTableSize    = 0;

    m_PresenceAtomID = 1001;
    ZeroMemory( (PVOID)&m_LocalPresenceInfo, sizeof SIP_PRESENCE_INFO );
    m_LocalPresenceInfo.presenceStatus = BUDDY_ONLINE;
    m_LocalPresenceInfo.activeMsnSubstatus = MSN_SUBSTATUS_ONLINE;
    m_bIsNestedWatcherProcessing = FALSE;

    m_NatMgrThreadHandle            = NULL;
    m_NatMgrThreadId                = 0;
    m_NatShutdownEvent              = NULL;
    m_pDirectPlayNATHelp            = NULL;
    ZeroMemory(&m_NatHelperCaps, sizeof(DPNHCAPS));
    m_NatHelperNotificationEvent    = NULL;
    m_NatMgrCSIsInitialized         = FALSE;

    srand((unsigned)time(NULL));
}


HRESULT
SIP_STACK::Init()
{
    HRESULT hr;

    ENTER_FUNCTION("SIP_STACK::Init");

    hr = RegisterHttpProxyWindowClass();
    if (hr != S_OK)
    {
        LOG((RTC_ERROR,"%s RegisterHttpProxyWindowClass failed %x",
            __fxName, hr));
        return hr;
    }

    hr = m_TimerMgr.Start();
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s starting timer manager failed %x",
             __fxName, hr));
        return hr;
    }

    hr = CreateSipStackWindow();
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s Creating SipStack window failed %x",
             __fxName, hr)); 
        return hr;
    }
    
    hr = m_WorkItemMgr.Start();
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s starting work item manager failed %x",
             __fxName, hr));
        return hr;
    }

    // Allocate Provider profile array.
    m_ProviderProfileArray = (SIP_PROVIDER_PROFILE *)
        malloc(DEFAULT_PROVIDER_PROFILE_ARRAY_SIZE * sizeof(SIP_PROVIDER_PROFILE));

    if (m_ProviderProfileArray == NULL)
    {
        LOG((RTC_ERROR, "Couldn't allocate m_ProviderProfileArray"));
        return E_OUTOFMEMORY;
    }

    m_ProviderProfileArraySize = DEFAULT_PROVIDER_PROFILE_ARRAY_SIZE;

    // Initialize the NAT helper manager.
    // Start the NAT thread only after creating the listen socket
    // list and registering the NAT mappnigs.
    hr = NatMgrInit();
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s initializing NAT manager failed %x",
             __fxName, hr));
        // ignore nat mgr error - we try to work without being
        // aware of the NAT.
        // return hr;
    }
    
    hr = GetLocalIPAddresses();
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s  GetLocalIPAddresses failed %x",
             __fxName, hr));
        return hr;
    }

    hr = CreateListenSocketList();
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s CreateListenSocketList failed %x",
             __fxName, hr));
        return hr;
    }
    
    hr = StartNatThread();
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s starting NAT manager failed %x",
             __fxName, hr));
        // ignore nat mgr error - we try to work without being
        // aware of the NAT.
        // return hr;
    }

    // XXX TODO remove
#if 1  // 0 ******* Region Commented Out Begins *******
    DWORD i = 0;
    LPOLESTR    *NetworkAddressArray;
    DWORD        NetworkAddressCount;
    
    hr = GetNetworkAddresses(FALSE, FALSE,
                             &NetworkAddressArray, &NetworkAddressCount);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - GetNetworkAddresses UDP Local failed %x",
             __fxName, hr));
    }
    else
    {
        FreeNetworkAddresses(NetworkAddressArray,
                             NetworkAddressCount);
    }
    
    hr = GetNetworkAddresses(TRUE, FALSE,
                             &NetworkAddressArray, &NetworkAddressCount);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - GetNetworkAddresses TCP Local failed %x",
             __fxName, hr));
    }
    else
    {
        FreeNetworkAddresses(NetworkAddressArray,
                             NetworkAddressCount);
    }
    
    hr = GetNetworkAddresses(FALSE, TRUE,
                             &NetworkAddressArray, &NetworkAddressCount);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - GetNetworkAddresses UDP Public failed %x",
             __fxName, hr));
    }
    else
    {
        FreeNetworkAddresses(NetworkAddressArray,
                             NetworkAddressCount);
    }
    
    hr = GetNetworkAddresses(TRUE, TRUE,
                             &NetworkAddressArray, &NetworkAddressCount);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - GetNetworkAddresses TCP Public failed %x",
             __fxName, hr));
    }
    else
    {
        FreeNetworkAddresses(NetworkAddressArray,
                             NetworkAddressCount);
    }
    
#endif // 0 ******* Region Commented Out Ends   *******
    return S_OK;
}


SIP_STACK::~SIP_STACK()
{
    LOG((RTC_TRACE, "~SIP_STACK(this - %x) Enter ", this));
    // Remove the SipStackWindow from the SipStackWindow list
    SipStackList_Delete(this);
    LOG((RTC_TRACE, "~SIP_STACK(this - %x) done ", this));
}


// Returns S_OK if Shutdown() can be called immediately.
// Otherwise it returns S_FALSE. In this case the SIP stack
// will notify Core when Shutdown() can be called using
// NotifyShutdownReady()

STDMETHODIMP
SIP_STACK::PrepareForShutdown()
{
    ENTER_FUNCTION("SIP_STACK::PrepareForShutdown");

    if(IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "%s - SipStack is already shutdown", __fxName));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    m_PreparingForShutdown = TRUE;

    if (m_NumMsgProcessors == 0)
    {
        LOG((RTC_TRACE, "%s - Ready for shutdown", __fxName));
        return S_OK;
    }
    else
    {
        LOG((RTC_TRACE, "%s - %d Msg Processors still alive",
             __fxName, m_NumMsgProcessors));
        return S_FALSE;
    }
}


VOID
SIP_STACK::OnMsgProcessorDone()
{
    ENTER_FUNCTION("SIP_STACK::OnMsgProcessorDone");
    
    m_NumMsgProcessors--;

    if (m_NumMsgProcessors == 0 && m_PreparingForShutdown)
    {
        LOG((RTC_TRACE, "%s - notify shutdown ready to Core", __fxName));
        
        if (m_pNotifyInterface != NULL)
        {
            m_pNotifyInterface->NotifyShutdownReady();
        }
        else
        {
            LOG((RTC_WARN, "%s - m_pNotifyInterface is NULL", __fxName));
        }
    }
}


STDMETHODIMP
SIP_STACK::Shutdown()
{
    ENTER_FUNCTION("SIP_STACK::Shutdown");
    if(IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "%s - SipStack is already shutdown", __fxName));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    LOG((RTC_TRACE, "%s - Enter", __fxName));

    ShutdownAllMsgProcessors();
    
    if (m_ProviderProfileArray != NULL)
    {
        free(m_ProviderProfileArray);
        m_ProviderProfileArray = NULL;
    }

    if (m_pMediaManager != NULL)
    {
        m_pMediaManager->Release();
        m_pMediaManager = NULL;
    }

    DeleteListenSocketList();
    
    m_TimerMgr.Stop();
    if (m_SipStackWindow != NULL)
    {
        if (!DestroyWindow(m_SipStackWindow))
        {
            LOG((RTC_ERROR, "%s - Destroying sip stack window failed %x this %x",
                 __fxName, GetLastError(), this));
        }
        m_SipStackWindow = NULL;
    }
    
    m_WorkItemMgr.Stop();
    
    FreeLocalIPaddrTable();

    NatMgrStop();

    UnregisterHttpProxyWindow();

    m_isSipStackShutDown = TRUE;

    return S_OK;
}


STDMETHODIMP
SIP_STACK::SetNotifyInterface(
    IN ISipStackNotify *NotifyInterface
    )
{
    if(IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "SipStack is already shutdown"));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    m_pNotifyInterface = NotifyInterface;
    return S_OK;
}


// We don't return an error code even if the address is currently
// in use and we can not bind to the static port.
STDMETHODIMP
SIP_STACK::EnableStaticPort()
{

    HRESULT hr;

    ENTER_FUNCTION("SIP_STACK::EnableStaticPort");
    if(IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "%s - SipStack is already shutdown", __fxName));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    LIST_ENTRY          *pListEntry;
    SIP_LISTEN_SOCKET   *pListenSocket;
    SOCKADDR_IN          ListenAddr;

    m_EnableStaticPort = TRUE;
    
    ZeroMemory(&ListenAddr, sizeof(ListenAddr));
    ListenAddr.sin_family = AF_INET;
    
    pListEntry = m_ListenSocketList.Flink;

    while (pListEntry != &m_ListenSocketList)
    {
        pListenSocket = CONTAINING_RECORD(pListEntry,
                                          SIP_LISTEN_SOCKET,
                                          m_ListEntry);

        ListenAddr.sin_addr.s_addr = pListenSocket->m_IpAddr;
        
        if (pListenSocket->m_pStaticPortUdpSocket == NULL)
        {
            ListenAddr.sin_port = htons(SIP_DEFAULT_UDP_PORT);
            
            hr = CreateListenSocket(FALSE,      // UDP
                                    &ListenAddr,
                                    &pListenSocket->m_pStaticPortUdpSocket);
            if (hr != S_OK && hr != HRESULT_FROM_WIN32(WSAEADDRINUSE))
            {
                LOG((RTC_ERROR, "%s CreateListenSocket UDP static failed %x",
                     __fxName, hr));
                pListenSocket->m_pStaticPortUdpSocket = NULL;
                return hr;
            }
            if (hr == HRESULT_FROM_WIN32(WSAEADDRINUSE))
            {
                LOG((RTC_WARN, "%s - Static UDP port is in use", __fxName));
            }
        }

        if (pListenSocket->m_pStaticPortTcpSocket == NULL)
        {
            ListenAddr.sin_port = htons(SIP_DEFAULT_TCP_PORT);
            
            hr = CreateListenSocket(TRUE,       // TCP
                                    &ListenAddr,
                                    &pListenSocket->m_pStaticPortTcpSocket);
            if (hr != S_OK && hr != HRESULT_FROM_WIN32(WSAEADDRINUSE))
            {
                LOG((RTC_ERROR, "%s CreateListenSocket TCP static failed %x",
                     __fxName, hr));
                pListenSocket->m_pStaticPortTcpSocket = NULL;
                return hr;
            }
            if (hr == HRESULT_FROM_WIN32(WSAEADDRINUSE))
            {
                LOG((RTC_WARN, "%s - Static TCP port is in use", __fxName));
            }
        }

        pListEntry = pListEntry->Flink;
    }
        
    return S_OK;
}


// We have a problem with disabling the static port with TCP.
// Even though we release the listening socket, there could
// be a socket which has been accepted and this will also be
// bound to the static port. In this case, someone else can not
// grab the static port. The only way to do that would be to
// terminate the call using that socket.
// Currently we are depending on Core/UI disconnecting the call.
// Once the call is disconnected, we will do the BYE on this socket
// and then it will get closed with the call object.

STDMETHODIMP
SIP_STACK::DisableStaticPort()
{
    LIST_ENTRY          *pListEntry;
    SIP_LISTEN_SOCKET   *pListenSocket;
    if(IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "SipStack is already shutdown"));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    m_EnableStaticPort = FALSE;
    
    pListEntry = m_ListenSocketList.Flink;

    while (pListEntry != &m_ListenSocketList)
    {
        pListenSocket = CONTAINING_RECORD(pListEntry,
                                          SIP_LISTEN_SOCKET,
                                          m_ListEntry);
        if (pListenSocket->m_pStaticPortUdpSocket != NULL)
        {
            pListenSocket->m_pStaticPortUdpSocket->Release();
            pListenSocket->m_pStaticPortUdpSocket = NULL;
        }

        if (pListenSocket->m_pStaticPortTcpSocket != NULL)
        {
            pListenSocket->m_pStaticPortTcpSocket->Release();
            pListenSocket->m_pStaticPortTcpSocket = NULL;
        }

        pListEntry = pListEntry->Flink;
    }

    return S_OK; 
}


STDMETHODIMP
SIP_STACK::EnableIncomingCalls()
{
    if(IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "SipStack is already shutdown"));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    m_AllowIncomingCalls = TRUE;
    return S_OK;
}


STDMETHODIMP
SIP_STACK::DisableIncomingCalls()
{
    if(IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "SipStack is already shutdown"));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    m_AllowIncomingCalls = FALSE;
    return S_OK;
}


STDMETHODIMP
SIP_STACK::GetNetworkAddresses(
    IN  BOOL        fTcp,
    IN  BOOL        fExternal,
    OUT LPOLESTR  **pNetworkAddressArray,
    OUT ULONG      *pNetworkAddressCount
    )
{
    ENTER_FUNCTION("SIP_STACK::GetNetworkAddresses");

    if(IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "%s - SipStack is already shutdown", __fxName));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    LOG((RTC_TRACE, "%s - Enter this %x", __fxName, this));
    
    if (fExternal)
    {
        return GetPublicNetworkAddresses(fTcp,
                                         pNetworkAddressArray,
                                         pNetworkAddressCount);
    }
    else
    {
        return GetLocalNetworkAddresses(fTcp,
                                        pNetworkAddressArray,
                                        pNetworkAddressCount);
    }
}


HRESULT
SIP_STACK::GetLocalNetworkAddresses(
    IN  BOOL        fTcp,
    OUT LPOLESTR  **pNetworkAddressArray,
    OUT ULONG      *pNetworkAddressCount
    )
{
    ENTER_FUNCTION("SIP_STACK::GetLocalNetworkAddresses");
    LOG((RTC_TRACE, "%s - Enter this %x", __fxName, this));
    *pNetworkAddressArray = NULL;
    *pNetworkAddressCount = 0;

    LPWSTR  *NetworkAddressArray = NULL;
    DWORD    NetworkAddressCount = 0;
    HRESULT  hr = S_OK;
    DWORD    i = 0;
    int      RetVal;

    LIST_ENTRY         *pListEntry;
    SIP_LISTEN_SOCKET  *pListenSocket;
    SOCKADDR_IN        *pListenSockAddr;

    pListEntry = m_ListenSocketList.Flink;
    NetworkAddressCount = 0;

    while (pListEntry != &m_ListenSocketList)
    {
        NetworkAddressCount++;
        pListEntry = pListEntry->Flink;
    }

    if (NetworkAddressCount == 0)
    {
        return S_FALSE;
    }
    
    NetworkAddressArray = (LPWSTR *) malloc(NetworkAddressCount*sizeof(LPWSTR));
    if (NetworkAddressArray == NULL)
    {
        LOG((RTC_ERROR, "%s - allocating NetworkAddressArray failed",
             __fxName));
        return E_OUTOFMEMORY;
    }

    ZeroMemory(NetworkAddressArray,
               NetworkAddressCount*sizeof(LPWSTR));
    
    i = 0;
    pListEntry = m_ListenSocketList.Flink;
    
    while (pListEntry != &m_ListenSocketList)
    {
        pListenSocket = CONTAINING_RECORD(pListEntry,
                                          SIP_LISTEN_SOCKET,
                                          m_ListEntry);

        // string of the form "123.123.123.123:65535"
        NetworkAddressArray[i] = (LPWSTR) malloc(24 * sizeof(WCHAR));
        if (NetworkAddressArray[i] == NULL)
        {
            LOG((RTC_ERROR, "%s allocating NetworkAddressArray[%d] failed",
                 __fxName, i));
            hr = E_OUTOFMEMORY;
            goto error;
        }

        if (fTcp)
        {
            pListenSockAddr = &pListenSocket->m_pDynamicPortTcpSocket->m_LocalAddr;
        }
        else
        {
            pListenSockAddr = &pListenSocket->m_pDynamicPortUdpSocket->m_LocalAddr;
        }
        
        RetVal = _snwprintf(NetworkAddressArray[i],
                            24,
                            L"%d.%d.%d.%d:%d",
                            PRINT_SOCKADDR(pListenSockAddr)
                            );
        if (RetVal < 0)
        {
            LOG((RTC_ERROR, "%s _snwprintf for NetworkAddressArray[%d] failed",
                 __fxName, i));
            hr = E_FAIL;
            goto error;
        }
        
        i++;
        pListEntry = pListEntry->Flink;
    }

    ASSERT(i == NetworkAddressCount);


    for (i = 0; i < NetworkAddressCount; i++)
    {
        LOG((RTC_TRACE, "%s(%s) Address: %ls",
             __fxName, (fTcp) ? "TCP" : "UDP",
             NetworkAddressArray[i]));
    }

    hr = SetLocalNetworkAddressFirst(
        NetworkAddressArray, NetworkAddressCount);
    if(hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - SetLocalNetworkAddressFirst failed %x",
            __fxName, hr));
    }
    
    *pNetworkAddressArray = NetworkAddressArray;
    *pNetworkAddressCount = NetworkAddressCount;
    return S_OK;

 error:
    for (i = 0; i < NetworkAddressCount; i++)
    {
        if (NetworkAddressArray[i] != NULL)
        {
            free(NetworkAddressArray[i]);
        }
    }

    free(NetworkAddressArray);
    
    return hr;
}


HRESULT
SIP_STACK::GetPublicNetworkAddresses(
    IN  BOOL        fTcp,
    OUT LPOLESTR  **pNetworkAddressArray,
    OUT ULONG      *pNetworkAddressCount
    )
{
    ENTER_FUNCTION("SIP_STACK::GetPublicNetworkAddresses");
    LOG((RTC_TRACE, "%s - Enter this %x", __fxName, this));
    *pNetworkAddressArray = NULL;
    *pNetworkAddressCount = 0;

    LPWSTR  *NetworkAddressArray = NULL;
    DWORD    NetworkAddressCount = 0;
    HRESULT  hr = S_OK;
    DWORD    i = 0;
    int      RetVal;

    LIST_ENTRY         *pListEntry;
    SIP_LISTEN_SOCKET  *pListenSocket;
    SOCKADDR_IN        *pListenSockAddr;
    SOCKADDR_IN         ActualListenAddr;

    pListEntry = m_ListenSocketList.Flink;
    NetworkAddressCount = 0;

    while (pListEntry != &m_ListenSocketList)
    {
        pListenSocket = CONTAINING_RECORD(pListEntry,
                                          SIP_LISTEN_SOCKET,
                                          m_ListEntry);

        if (fTcp)
        {
            pListenSockAddr = &pListenSocket->m_PublicTcpListenAddr;
        }
        else
        {
            pListenSockAddr = &pListenSocket->m_PublicUdpListenAddr;
        }
        
        if (pListenSockAddr->sin_addr.s_addr != htonl(0) &&
            pListenSockAddr->sin_port != htons(0) &&
            pListenSocket->m_fIsUpnpNatPresent &&
            !pListenSocket->m_fIsGatewayLocal)
        {
            NetworkAddressCount++;
        }
        pListEntry = pListEntry->Flink;
    }

    if (NetworkAddressCount == 0)
    {
        return S_FALSE;
    }
    
    NetworkAddressArray = (LPWSTR *) malloc(NetworkAddressCount*sizeof(LPWSTR));
    if (NetworkAddressArray == NULL)
    {
        LOG((RTC_ERROR, "%s - allocating NetworkAddressArray failed",
             __fxName));
        return E_OUTOFMEMORY;
    }

    ZeroMemory(NetworkAddressArray,
               NetworkAddressCount*sizeof(LPWSTR));
    
    i = 0;
    pListEntry = m_ListenSocketList.Flink;
    
    while (pListEntry != &m_ListenSocketList)
    {
        pListenSocket = CONTAINING_RECORD(pListEntry,
                                          SIP_LISTEN_SOCKET,
                                          m_ListEntry);
        if (fTcp)
        {
            pListenSockAddr = &pListenSocket->m_PublicTcpListenAddr;
        }
        else
        {
            pListenSockAddr = &pListenSocket->m_PublicUdpListenAddr;
        }

        if (pListenSockAddr->sin_addr.s_addr != htonl(0) &&
            pListenSockAddr->sin_port != htons(0) &&
            pListenSocket->m_fIsUpnpNatPresent &&
            !pListenSocket->m_fIsGatewayLocal)
        {
            // This is a big hack for the VPN scenario.

            ZeroMemory(&ActualListenAddr, sizeof(ActualListenAddr));
            ActualListenAddr.sin_family = AF_INET;

            hr = GetActualPublicListenAddr(pListenSocket, fTcp, &ActualListenAddr);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s GetActualPublicListenAddr failed %x",
                     __fxName, hr));
                CopyMemory(&ActualListenAddr, pListenSockAddr, sizeof(SOCKADDR_IN));
            }
            
            
            // string of the form "123.123.123.123:65535"
            NetworkAddressArray[i] = (LPWSTR) malloc(24 * sizeof(WCHAR));
            if (NetworkAddressArray[i] == NULL)
            {
                LOG((RTC_ERROR, "%s allocating NetworkAddressArray[%d] failed",
                     __fxName, i));
                hr = E_OUTOFMEMORY;
                goto error;
            }
            RetVal = _snwprintf(NetworkAddressArray[i],
                                    24,
                                    L"%d.%d.%d.%d:%d",
                                    PRINT_SOCKADDR(&ActualListenAddr)
                                    );
            if (RetVal < 0)
            {
                LOG((RTC_ERROR, "%s _snwprintf for NetworkAddressArray[%d] failed",
                     __fxName, i));
                hr = E_FAIL;
                goto error;
            }
            
            i++;
        }
        pListEntry = pListEntry->Flink;
    }
    LOG((RTC_TRACE, "i = %d NetworkAddressCount = %d", i, NetworkAddressCount));
    ASSERT(i == NetworkAddressCount);

    for (i = 0; i < NetworkAddressCount; i++)
    {
        LOG((RTC_TRACE, "%s(%s) Address: %ls",
             __fxName, (fTcp) ? "TCP" : "UDP",
             NetworkAddressArray[i]));
    }
    hr = SetLocalNetworkAddressFirst(
        NetworkAddressArray, NetworkAddressCount);
    if(hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - SetLocalNetworkAddressFirst failed %x",
            __fxName, hr));
    }

    *pNetworkAddressArray = NetworkAddressArray;
    *pNetworkAddressCount = NetworkAddressCount;
    return S_OK;

 error:
    for (i = 0; i < NetworkAddressCount; i++)
    {
        if (NetworkAddressArray[i] != NULL)
        {
            free(NetworkAddressArray[i]);
        }
    }

    free(NetworkAddressArray);
    
    return hr;

}


// This is a big hack to get the VPN scenario to work.
// When a machine behind a NAT makes a VPN connection to corpnet and
// tries to make a call, we should choose the VPN address and not the
// external address of the NAT as the listen address.

// Note that we do this only if know we are registered with a UPnP NAT.

HRESULT
SIP_STACK::GetActualPublicListenAddr(
    IN  SIP_LISTEN_SOCKET  *pListenSocket,
    IN  BOOL                fTcp,
    OUT SOCKADDR_IN        *pActualListenAddr
    )
{
    ENTER_FUNCTION("SIP_STACK::GetActualPublicListenAddr");
    LOG((RTC_TRACE, "%s - Enter this %x", __fxName, this));

    SOCKADDR_IN *pLocalListenAddr;
    SOCKADDR_IN *pNatListenAddr;

    if (fTcp)
    {
        pLocalListenAddr = &pListenSocket->m_pDynamicPortTcpSocket->m_LocalAddr;
        pNatListenAddr = &pListenSocket->m_PublicTcpListenAddr;
    }
    else
    {
        pLocalListenAddr = &pListenSocket->m_pDynamicPortUdpSocket->m_LocalAddr;
        pNatListenAddr = &pListenSocket->m_PublicUdpListenAddr;
    }

    // Check to see if the default interface to reach the external
    // address of the gateway is the mapped internal address.
    int         RetVal;
    DWORD       WinsockErr;
    SOCKADDR_IN LocalAddr;
    int         LocalAddrLen = sizeof(LocalAddr);
    SOCKET      hSocket = NULL;


    hSocket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (hSocket == INVALID_SOCKET)
    {
        WinsockErr = WSAGetLastError();
        LOG((RTC_ERROR, "%s socket failed : 0x%x", __fxName, WinsockErr));
        return HRESULT_FROM_WIN32(WinsockErr);
    }

    // The actual destination port doesn't really matter
    RetVal = connect(hSocket, (SOCKADDR *) pNatListenAddr,
                     sizeof(SOCKADDR_IN));
    if (RetVal == SOCKET_ERROR)
    {
        WinsockErr = WSAGetLastError();
        LOG((RTC_ERROR, "%s connect failed : %x", __fxName, WinsockErr));
        closesocket(hSocket);
        return HRESULT_FROM_WIN32(WinsockErr);
    }

    RetVal = getsockname(hSocket, (SOCKADDR *) &LocalAddr,
                         &LocalAddrLen);

    closesocket(hSocket);
    hSocket = NULL;
    
    if (RetVal == SOCKET_ERROR)
    {
        WinsockErr = WSAGetLastError();
        LOG((RTC_ERROR, "%s getsockname failed : %x", __fxName, WinsockErr));
        return HRESULT_FROM_WIN32(WinsockErr);
    }

    // If the default interface to reach the gateway is not the mapped
    // internal address then we think there is a VPN and so we return
    // this address always as the external address.

    if (LocalAddr.sin_addr.s_addr != pLocalListenAddr->sin_addr.s_addr)
    {
        LOG((RTC_TRACE,
             "%s NAT listen addr: %d.%d.%d.%d:%d Mapped internal addr: %d.%d.%d.%d:%d"
             "Local interface to reach NAT addr: %d.%d.%d.%d:%d",
             __fxName, PRINT_SOCKADDR(pNatListenAddr), PRINT_SOCKADDR(pLocalListenAddr),
             PRINT_SOCKADDR(&LocalAddr)));
        pActualListenAddr->sin_addr.s_addr = LocalAddr.sin_addr.s_addr;
        if (GetListenAddr(pActualListenAddr, fTcp))
        {
            LOG((RTC_TRACE, "%s - VPN scenario returning %d.%d.%d.%d:%d",
                 __fxName, PRINT_SOCKADDR(pActualListenAddr)));
            return S_OK;
        }
        else
        {
            LOG((RTC_ERROR,
                 "%s - VPN scenario couldn't find listen socket for %d.%d.%d.%d:%d",
                 __fxName, PRINT_SOCKADDR(pActualListenAddr)));
            return E_FAIL;
        }
    }
    else
    {
        CopyMemory(pActualListenAddr, pNatListenAddr, sizeof(SOCKADDR_IN));
        return S_OK;
    }   
}


STDMETHODIMP
SIP_STACK::FreeNetworkAddresses(
    IN  LPOLESTR   *NetworkAddressArray,
    IN  ULONG       NetworkAddressCount
    )
{
    DWORD i = 0;
    
    ENTER_FUNCTION("SIP_STACK::FreeNetworkAddresses");
    LOG((RTC_TRACE, "%s - Enter this %x", __fxName, this));
    if(IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "%s - SipStack is already shutdown", __fxName));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    if (NetworkAddressArray != NULL &&
        NetworkAddressCount != 0)
    {
        for (i = 0; i < NetworkAddressCount; i++)
        {
            if (NetworkAddressArray[i] != NULL)
            {
                free(NetworkAddressArray[i]);
            }
        }        
        free(NetworkAddressArray);
    }
    
    return S_OK;    
}

HRESULT
SIP_STACK::SetLocalNetworkAddressFirst(
    IN OUT LPWSTR  *ppNetworkAddressArray,
    IN DWORD        NetworkAddressCount
    )
{
    SOCKADDR_IN *       localSockAddr;
    BOOL                isIndexFound = FALSE;
    unsigned int        IpIndexcount;
    unsigned int        LocalIPIndex = 0;
    const int           colonchar = ':';
    unsigned int        ipaddrlen = 0;
    unsigned long       uipaddr = 0;
    char *              pdest;
    PSTR                NetworkAddressArrayValue;
    ULONG               NetworkAddressArrayValueLen;
    HRESULT             hr = S_OK;
    REGISTER_CONTEXT   *pRegisterContext;

    ENTER_FUNCTION("SIP_STACK::SetLocalNetworkAddressFirst");
    LOG((RTC_TRACE, "%s - Enter NetworkAddressCount: %d this %x",
            __fxName, NetworkAddressCount, this));
    if( m_NumProfiles > 0 && NetworkAddressCount > 1)
    {
        pRegisterContext = (REGISTER_CONTEXT*)
            m_ProviderProfileArray[0].pRegisterContext;
        if(pRegisterContext!= NULL)
        {
            localSockAddr = pRegisterContext->GetLocalSockAddr();
            if(localSockAddr == NULL)
            {
                LOG((RTC_ERROR, "%s - localSockAddr is NULL, exiting without change", 
                    __fxName));
                return E_FAIL;
            }
            LOG((RTC_TRACE, "%s - IP address at the begin is %d.%d.%d.%d",
                    __fxName, NETORDER_BYTES0123(localSockAddr->sin_addr.s_addr)));
            for(IpIndexcount = 0; 
              IpIndexcount < NetworkAddressCount && isIndexFound == FALSE;
              IpIndexcount++)
            {
                hr = UnicodeToUTF8(ppNetworkAddressArray[IpIndexcount],
                                   &NetworkAddressArrayValue,
                                   &NetworkAddressArrayValueLen);
                if (hr != S_OK)
                {
                    LOG((RTC_ERROR, "%s UnicodeToUTF8(ppNetworkAddressArray[%d]) failed %x",
                         __fxName, IpIndexcount, hr));
                    return hr;
                }
                pdest = strchr( NetworkAddressArrayValue, colonchar );
                if(pdest != NULL)
                {
                    ipaddrlen = pdest - NetworkAddressArrayValue;
                    NetworkAddressArrayValue[ipaddrlen] = '\0';
                }
                uipaddr = inet_addr(NetworkAddressArrayValue);
                if(uipaddr != INADDR_NONE)
                {
                    if(uipaddr == localSockAddr->sin_addr.s_addr)
                    {
                        isIndexFound = TRUE;
                        LocalIPIndex = IpIndexcount;
                        LOG((RTC_TRACE, "%s - IP address matched is %s at index %d",
                            __fxName, NetworkAddressArrayValue, LocalIPIndex));

                    }
                }
                else
                {
                    LOG((RTC_WARN, "%s - inet_addr failed", __fxName));
                }
                free(NetworkAddressArrayValue);
                NetworkAddressArrayValueLen = 0;
            }
            if(LocalIPIndex != 0)
            {
                if(isIndexFound)
                {
                    //interchange the first ipaddr and the index ipaddr
                    WCHAR *tempIpaddr;
                    LOG((RTC_TRACE, "%s - Interchanging the indexes 0 and %d", 
                        __fxName, LocalIPIndex));
                    tempIpaddr = ppNetworkAddressArray[0];
                    ppNetworkAddressArray[0] =  ppNetworkAddressArray[LocalIPIndex];
                    ppNetworkAddressArray[LocalIPIndex] = tempIpaddr;
                }
                else
                {
                    LOG((RTC_ERROR, "%s - The Local IPIndex not found. Table unchanged",
                        __fxName));
                }
            }
            else
            {
                // the local interface is already on top
                LOG((RTC_TRACE, "%s - the local interface is already on top",
                    __fxName));
            }
        }
        else
        {
           LOG((RTC_TRACE, "%s - pRegisterContext is NULL",
                __fxName));
        }
    }
    else
    {
       LOG((RTC_TRACE, "%s - No change to existing array done",
                __fxName));
    }

    return S_OK;
}


// XXX Note that we need to initiate registration
// only if m_AllowIncomingCalls is TRUE - Otherwise
// we shouldn't register ourselves.

STDMETHODIMP
SIP_STACK::SetProviderProfile(
    IN SIP_PROVIDER_PROFILE *pProviderInfo
    )
{
    ULONG ProviderIndex;

    ENTER_FUNCTION("SIP_STACK::SetProviderProfile");
    if(IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "%s - SipStack is already shutdown", __fxName));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    LOG((RTC_TRACE, "%s - enter ProviderInfo:", __fxName));

    LOG((RTC_TRACE, "\tRegistrar:  %ls lRegisterAccept: %d Transport: %d Auth: %d",
         PRINTABLE_STRING_W(pProviderInfo->Registrar.ServerAddress),
         pProviderInfo->lRegisterAccept,
         pProviderInfo->Registrar.TransportProtocol,
         pProviderInfo->Registrar.AuthProtocol
         ));

    LOG((RTC_TRACE, "\tUserCredentials  Name: %ls",
         PRINTABLE_STRING_W(pProviderInfo->UserCredentials.Username)
         ));
    
    LOG((RTC_TRACE, "\tUserURI : %ls",
         PRINTABLE_STRING_W(pProviderInfo->UserURI)
         ));

    // If this is a redirect then update the Registrar profile
    if( pProviderInfo -> lRegisterAccept != 0 )
    {
        if( pProviderInfo -> Registrar.IsServerAddressSIPURI == TRUE )
        {
            if( pProviderInfo -> pRedirectContext != NULL )
            {
                //Parse the URI and set the transport type and transport address
                UpdateProxyInfo( &pProviderInfo -> Registrar );
            }
        }
    }

    if (IsProviderIdPresent(&pProviderInfo->ProviderID, &ProviderIndex))
    {
        return UpdateProviderProfile(ProviderIndex, pProviderInfo);
    }
    else
    {
        return AddProviderProfile(pProviderInfo);
    }

    LOG((RTC_TRACE, "%s - exit", __fxName));
    return S_OK;
}


STDMETHODIMP
SIP_STACK::DeleteProviderProfile(
    IN SIP_PROVIDER_ID *pProviderId
    )
{
    // Initiate Unregistration to the provider (only if previously
    // registered).

    ENTER_FUNCTION("SIP_STACK::DeleteProviderProfile");
    if(IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "%s - SipStack is already shutdown", __fxName));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    LOG(( RTC_TRACE, "%s - entered", __fxName ));
    
    // Remove the profile
    ULONG               ProviderIndex;
    ULONG               i = 0;
    REGISTER_CONTEXT   *pRegisterContext;
    
    if (!IsProviderIdPresent(pProviderId, &ProviderIndex))
    {
        LOG((RTC_TRACE,
             "%s: Couldn't find provider profile", __fxName));
        return E_FAIL;
    }

    //free all the unicode strings
    FreeProviderProfileStrings(ProviderIndex);

    pRegisterContext = (REGISTER_CONTEXT*)
        m_ProviderProfileArray[ProviderIndex].pRegisterContext;

    if( pRegisterContext != NULL )
    {
        pRegisterContext -> StartUnregistration();
        
        //release the reference on REGISTER_CONTEXT
        pRegisterContext -> MsgProcRelease();
        m_ProviderProfileArray[ProviderIndex].pRegisterContext = NULL;
    }

    for (i = ProviderIndex; i < m_NumProfiles - 1; i++)
    {
        CopyMemory( &m_ProviderProfileArray[i], &m_ProviderProfileArray[i+1],
                   sizeof(SIP_PROVIDER_PROFILE) );
    }

    m_NumProfiles--;

    LOG((RTC_TRACE, "%s freed profile at index %d",
        __fxName, ProviderIndex));
    
    LOG((RTC_TRACE, "%s - exited -S_OK", __fxName));
    return S_OK;
}


STDMETHODIMP SIP_STACK::DeleteAllProviderProfiles()
{
    // Initiate Unregistration on all providers
    REGISTER_CONTEXT   *pRegisterContext;
    ULONG i;

    ENTER_FUNCTION("SIP_STACK::DeleteAllProviderProfiles");
    if(IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "%s - SipStack is already shutdown", __fxName));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    LOG(( RTC_TRACE, "%s - entered", __fxName ));
    
    for (i = 0; i < m_NumProfiles; i++)
    {
        //free all the unicode strings
        FreeProviderProfileStrings(i);
    
        pRegisterContext = (REGISTER_CONTEXT*)
            m_ProviderProfileArray[i].pRegisterContext;

        if( pRegisterContext != NULL )
        {
            pRegisterContext -> StartUnregistration();

            //release the reference on REGISTER_CONTEXT
            pRegisterContext -> MsgProcRelease();
            m_ProviderProfileArray[i].pRegisterContext = NULL;
        }
        LOG((RTC_TRACE, "%s freed profile at index %d",
            __fxName, i));

    }

    m_NumProfiles = 0;

    LOG((RTC_TRACE, "%s - exited -S_OK", __fxName));
    return S_OK;
}


STDMETHODIMP
SIP_STACK::CreateCall(
    IN  SIP_PROVIDER_ID        *pProviderId,
    IN  SIP_SERVER_INFO        *pProxyInfo,
    IN  SIP_CALL_TYPE           CallType,
    IN  ISipRedirectContext    *pRedirectContext, 
    OUT ISipCall              **ppCall
    )
{
    ENTER_FUNCTION("SIP_STACK::CreateCall");

    if(IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "%s - SipStack is already shutdown", __fxName));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    HRESULT hr;
    SIP_USER_CREDENTIALS *pUserCredentials = NULL;
    LPOLESTR              Realm = NULL;

    ASSERT(m_pNotifyInterface);
    *ppCall = NULL;

    LOG((RTC_TRACE, "%s - pProviderID %x  CallType: %d RedirectContext %x",
         __fxName, pProviderId, CallType, pRedirectContext));

    if (pProxyInfo != NULL)
    {
        LOG((RTC_TRACE, "%s - Proxy:  %ls Transport: %d Auth: %d",
             __fxName,
             PRINTABLE_STRING_W(pProxyInfo->ServerAddress),
             pProxyInfo->TransportProtocol,
             pProxyInfo->AuthProtocol
             ));
    }

    if (pProviderId != NULL &&
        !IsEqualGUID(*pProviderId, GUID_NULL))
    {
        hr = GetProfileUserCredentials(pProviderId, &pUserCredentials, &Realm);
        if (hr != S_OK)
        {
            LOG((RTC_WARN, "%s - GetProfileUserCredentials failed %x",
                 __fxName, hr));
            pUserCredentials = NULL;
        }
    }
        
    if (CallType == SIP_CALL_TYPE_RTP)
    {
        RTP_CALL *pRtpCall =
            new RTP_CALL(pProviderId, this,
                         (REDIRECT_CONTEXT *)pRedirectContext);
        if (pRtpCall == NULL)
        {
            return E_OUTOFMEMORY;
        }

        if (pProxyInfo != NULL)
        {
            hr = pRtpCall->SetProxyInfo(pProxyInfo);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s - SetProxyInfo failed %x",
                     __fxName, hr));
                pRtpCall->MsgProcRelease();
                return hr;
            }
        }
        
        if (pUserCredentials != NULL)
        {
            hr = pRtpCall->SetCredentials(pUserCredentials, Realm);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s - SetCredentials failed %x",
                     __fxName, hr));
                pRtpCall->MsgProcRelease();
                return hr;
            }
        }
        
        *ppCall = static_cast<ISipCall *>(pRtpCall);
    }
    else if (CallType == SIP_CALL_TYPE_PINT)
    {
        PINT_CALL *pPintCall =
            new PINT_CALL(pProviderId, this,
                          (REDIRECT_CONTEXT *)pRedirectContext,
                          &hr);
        if (pPintCall  == NULL)
        {
            return E_OUTOFMEMORY;
        }
        
        if(hr != S_OK)
        {
            pPintCall->MsgProcRelease();
            return hr;
        }

        //If its a redirect call the transport might be specified as a part of
        //the ServerAddress field in the proxy. So update the pProxyInfo struct
        if( pProxyInfo -> IsServerAddressSIPURI )
        {
            ASSERT( pRedirectContext != NULL );

            hr = UpdateProxyInfo( pProxyInfo );

            if(hr != S_OK)
            {
                pPintCall->MsgProcRelease();
                return hr;
            }
        }

        if (pProxyInfo != NULL)
        {
            hr = pPintCall->SetProxyInfo(pProxyInfo);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s - SetProxyInfo failed %x",
                     __fxName, hr));
                pPintCall->MsgProcRelease();
                return hr;
            }
        }
        
        if (pUserCredentials != NULL)
        {
            hr = pPintCall->SetCredentials(pUserCredentials, Realm);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s - SetCredentials failed %x",
                     __fxName, hr));
                pPintCall->MsgProcRelease();
                return hr;
            }
        }
        
        *ppCall = static_cast<ISipCall *>(pPintCall);
    }
    else
    {
        LOG((RTC_ERROR, "%s : Unknown call type %d", __fxName, CallType));
        ASSERT(FALSE);
        return E_FAIL;
    }

    return S_OK;
}


//This function should be used only on IPAddrChange 
//because of the CheckLocalIpPresent checks.
HRESULT
SIP_STACK::StartAllProviderUnregistration()
{
    REGISTER_CONTEXT       *pRegisterContext;
    DWORD                   i;
    SIP_PROVIDER_PROFILE   *pProviderProfile;
    HRESULT                 hr = S_OK;

    for( i = 0; i < m_NumProfiles; i++ )
    {
        pProviderProfile = &m_ProviderProfileArray[i];

        pRegisterContext = (REGISTER_CONTEXT*)
            pProviderProfile -> pRegisterContext;
        
        // if pRegisterContext is not present or if pRegisterContext
        // has not changed its local ip and nat mapping then ignore this
        // pRegisterContext
        if(pRegisterContext == NULL || 
            ((pRegisterContext != NULL) && 
             (pRegisterContext->CheckListenAddrIntact() == S_OK)))
            continue;
                
        if( pProviderProfile -> pRegisterContext != NULL )
        {
            ((REGISTER_CONTEXT*) (pProviderProfile -> pRegisterContext)) ->
                StartUnregistration();

            //release the reference on REGISTER_CONTEXT
            ((REGISTER_CONTEXT*) (pProviderProfile -> pRegisterContext)) ->
                MsgProcRelease();

            pProviderProfile -> pRegisterContext  = NULL;
        }
    }

    return S_OK;
}

//This function should be used only on IPAddrChange 
//because of the CheckLocalIpPresent checks.
HRESULT
SIP_STACK::StartAllProviderRegistration()
{
    REGISTER_CONTEXT       *pRegisterContext;
    DWORD                   i;
    SIP_PROVIDER_PROFILE   *pProviderProfile;
    HRESULT                 hr = S_OK;

    for( i = 0; i < m_NumProfiles; i++ )
    {
        pProviderProfile = &m_ProviderProfileArray[i];

        pRegisterContext = (REGISTER_CONTEXT*)
            pProviderProfile -> pRegisterContext;
        
        // if pRegisterContext has not changed local ip or nat mapping
        // then ignore this pRegisterContext
        if((pRegisterContext != NULL) && 
           (pRegisterContext->CheckListenAddrIntact() == S_OK))
                continue;

        //Even if pRegisterContext is null , we need to register.
        if( pProviderProfile -> lRegisterAccept !=0 )
        {
            hr = StartRegistration( pProviderProfile );
            if( hr != S_OK )
            {
                LOG(( RTC_ERROR, "StartRegistration failed %x", hr ));
            }
        }
    }

    return S_OK;
}


HRESULT
SIP_STACK::CreateSipStackWindow()
{
    DWORD Error;
    
    // Create the Timer Window
    m_SipStackWindow = CreateWindow(
                           SIP_STACK_WINDOW_CLASS_NAME,
                           NULL,
                           WS_DISABLED, // XXX Is this the right style ?
                           CW_USEDEFAULT,
                           CW_USEDEFAULT,
                           CW_USEDEFAULT,
                           CW_USEDEFAULT,
                           NULL,           // No Parent
                           NULL,           // No menu handle
                           _Module.GetResourceInstance(),
                           NULL
                           );
    if (!m_SipStackWindow)
    {
        Error = GetLastError();
        LOG((RTC_ERROR, "SipStack CreateWindow failed 0x%x", Error));
        return HRESULT_FROM_WIN32(Error);
    }

    return S_OK;
}


// For a Dynamic port, port 0 is passed in pListenAddr
HRESULT
SIP_STACK::CreateListenSocket(
    IN  BOOL            fTcp,
    IN  SOCKADDR_IN    *pListenAddr,
    OUT ASYNC_SOCKET  **ppAsyncSocket
    )
{
    DWORD          Error;
    ASYNC_SOCKET  *pAsyncSock;

    ASSERT(pListenAddr);
    
    ENTER_FUNCTION("SIP_STACK::CreateListenSocket");
    
    pAsyncSock = new ASYNC_SOCKET(
                         this, (fTcp) ? SIP_TRANSPORT_TCP : SIP_TRANSPORT_UDP,
                         &m_SockMgr);
    if (pAsyncSock == NULL)
    {
        LOG((RTC_ERROR, "%s allocating pAsyncSock failed", __fxName));
        return E_OUTOFMEMORY;
    }
    
    Error = pAsyncSock->Create(
                TRUE
                );
    if (Error != NO_ERROR)
    {
        LOG((RTC_ERROR, "%s(%d)  pAsyncSock->Create failed %x",
             __fxName, fTcp, Error));
        pAsyncSock->Release();
        return HRESULT_FROM_WIN32(Error);
    }

    Error = pAsyncSock->Bind(pListenAddr);
    if (Error != NO_ERROR)
    {
        LOG((RTC_ERROR, "%s  pAsyncSock->Bind(%d.%d.%d.%d:%d) failed %x",
             __fxName, PRINT_SOCKADDR(pListenAddr), Error));
        pAsyncSock->Release();
        return HRESULT_FROM_WIN32(Error);
    }

    if (fTcp)
    {
        Error = pAsyncSock->Listen();
        if (Error != NO_ERROR)
        {
            LOG((RTC_ERROR, "%s  pAsyncSock->Listen failed %x",
                 __fxName, Error));
            pAsyncSock->Release();
            return HRESULT_FROM_WIN32(Error);
        }
    }
    
    *ppAsyncSocket = pAsyncSock;
    LOG((RTC_TRACE, "%s: Listening for %s on %d.%d.%d.%d:%d",
         __fxName, (fTcp) ? "TCP" : "UDP",
         PRINT_SOCKADDR(&pAsyncSock->m_LocalAddr)));
    return S_OK;
}


// Dynamic port is really not dynamic port. This is to work
// around the bug with Messenger and WSP 2.0 client installed.
// Due to the bug in WSP 2.0 client, bind() to localaddr:0 is
// remoted to the proxy server and this results in an error
// WSAEADDRNOTAVAILABLE. This is because

HRESULT
SIP_STACK::CreateDynamicPortListenSocket(
    IN  BOOL            fTcp,
    IN  SOCKADDR_IN    *pListenAddr,
    OUT ASYNC_SOCKET  **ppAsyncSocket
    )
{
    USHORT  usBindingRetries;
    USHORT  usRandPort;
    HRESULT hr = S_OK;

    ENTER_FUNCTION("SIP_STACK::CreateDynamicPortListenSocket");
    LOG((RTC_TRACE,"%s entered",__fxName));

    for (usBindingRetries = DYNAMIC_PORT_BINDING_RETRY;
         usBindingRetries > 0;
         usBindingRetries--)
    {
        usRandPort = DYNAMIC_STARTING_PORT + rand()%DYNAMIC_PORT_RANGE;
        pListenAddr->sin_port = htons(usRandPort);
        
        hr = CreateListenSocket(fTcp, pListenAddr, ppAsyncSocket);
        if (hr == S_OK)
        {
            return S_OK;
        }
        else if (hr != HRESULT_FROM_WIN32(WSAEADDRINUSE)) 
        {
            LOG((RTC_ERROR,
                 "%s  CreateListenSocket address (%d.%d.%d.%d:%d) failed %x",
                 __fxName, PRINT_SOCKADDR(pListenAddr), hr));
            return hr;
        }
    }
    
    if (usBindingRetries == 0)
    {
        LOG((RTC_ERROR,"%s unable to bind dynamic port in %d retries, error %x",
                    __fxName,DYNAMIC_PORT_BINDING_RETRY, hr));
    }
    LOG((RTC_TRACE,"%s exits",__fxName));
    return hr;
}



HRESULT
SIP_STACK::CreateAndAddListenSocketToList(
    IN DWORD IpAddr      // in network byte order
    )
{
    ENTER_FUNCTION("SIP_STACK::CreateAndAddListenSocketToList");

    HRESULT             hr;
    ASYNC_SOCKET       *pDynamicPortUdpSocket = NULL;
    ASYNC_SOCKET       *pDynamicPortTcpSocket = NULL;
    ASYNC_SOCKET       *pStaticPortUdpSocket  = NULL;
    ASYNC_SOCKET       *pStaticPortTcpSocket  = NULL;
    SIP_LISTEN_SOCKET  *pListenSocket         = NULL;
    SOCKADDR_IN         ListenAddr;

    USHORT              usRetries;

    ZeroMemory(&ListenAddr, sizeof(ListenAddr));
    ListenAddr.sin_family = AF_INET;

    ListenAddr.sin_addr.s_addr = IpAddr;
    ListenAddr.sin_port        = htons(0);        

   
    for ( usRetries = 0; 
          usRetries < MAX_DYNAMIC_LISTEN_SOCKET_REGISTER_PORT_RETRY; 
          usRetries++)
    {
        LOG((RTC_TRACE,"%s retry %d",__fxName,usRetries));

        // UDP Dynamic port
        hr = CreateDynamicPortListenSocket(FALSE, &ListenAddr, &pDynamicPortUdpSocket);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s CreateListenSocket DynamicPort UDP failed %x",
                 __fxName, hr));
            return hr;
        }

        // TCP Dynamic port
        hr = CreateDynamicPortListenSocket(TRUE, &ListenAddr, &pDynamicPortTcpSocket);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s CreateListenSocket DynamicPort TCP failed %x",
                 __fxName, hr));
            return hr;
        }

        if (m_EnableStaticPort)
        {
            // UDP Static port

            ListenAddr.sin_port = htons(SIP_DEFAULT_UDP_PORT);

            hr = CreateListenSocket(FALSE, &ListenAddr, &pStaticPortUdpSocket);
            if (hr != S_OK && hr != HRESULT_FROM_WIN32(WSAEADDRINUSE))
            {
                LOG((RTC_ERROR, "%s CreateListenSocket StaticPort UDP failed %x",
                     __fxName, hr));
                return hr;
            }

            if (hr == HRESULT_FROM_WIN32(WSAEADDRINUSE))
            {
                LOG((RTC_WARN, "%s - Static UDP port is in use", __fxName));
            }

            // TCP Static port

            ListenAddr.sin_port = htons(SIP_DEFAULT_TCP_PORT);
        
            hr = CreateListenSocket(TRUE, &ListenAddr, &pStaticPortTcpSocket);
            if (hr != S_OK && hr != HRESULT_FROM_WIN32(WSAEADDRINUSE))
            {
                LOG((RTC_ERROR, "%s CreateListenSocket StaticPort TCP failed %x",
                    __fxName, hr));
                return hr;
            }

            if (hr == HRESULT_FROM_WIN32(WSAEADDRINUSE))
            {
                LOG((RTC_WARN, "%s - Static TCP port is in use", __fxName));
            }
        }
    
        
        // We do not bind to the static port here.
        // Core calls EnableStaticPort() if it wants the sip stack
        // to listen on the static port.    
        
        pListenSocket = new SIP_LISTEN_SOCKET(IpAddr,
                                              pDynamicPortUdpSocket,
                                              pDynamicPortTcpSocket,
                                              pStaticPortUdpSocket,
                                              pStaticPortTcpSocket,
                                              &m_ListenSocketList);
        
        // SIP_LISTEN_SOCKET() addref's the sockets.
        if (pDynamicPortUdpSocket != NULL)
        {
            pDynamicPortUdpSocket->Release();
        }
        if (pDynamicPortTcpSocket != NULL)
        {
            pDynamicPortTcpSocket->Release();
        }
        if (pStaticPortUdpSocket != NULL)
        {
            pStaticPortUdpSocket->Release();
        }
        if (pStaticPortTcpSocket != NULL)
        {
            pStaticPortTcpSocket->Release();
        }

        if (pListenSocket == NULL)
        {
            LOG((RTC_ERROR, "%s allocating SIP_LISTEN_SOCKET failed", __fxName));
            return E_OUTOFMEMORY;
        }

        // Establish the NAT mapping.
        hr = RegisterNatMapping(pListenSocket);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s registering mapping failed %x",
                 __fxName, hr));
            // ignore NAT related errors.
            return S_OK;    
        }

        hr = UpdatePublicListenAddr(pListenSocket);
        if (hr != S_OK)
        {
            // loop again only if we encounter this flag,
            // we will destroy the existing listen socket and
            // start with a fresh one.
            if(hr == DPNHERR_PORTUNAVAILABLE)
            {
                delete pListenSocket;
                pListenSocket = NULL;
                pDynamicPortUdpSocket = NULL;
                pDynamicPortTcpSocket = NULL;
                pStaticPortUdpSocket  = NULL;
                pStaticPortTcpSocket  = NULL;
                continue;
            }
            LOG((RTC_ERROR, "%s getting public listen addr failed %x",
                 __fxName, hr));
            // ignore NAT related errors.
            return hr;
        }   
    
        return S_OK;
    }

    // we exhausted the maximum NAT register port retries, returning
    return E_FAIL;
}


// Create one listen socket for each local IP
HRESULT
SIP_STACK::CreateListenSocketList()
{
    HRESULT     hr;
    DWORD       i;

    ENTER_FUNCTION("SIP_STACK::CreateListenSocketList");

    for (i = 0; i < m_pMibIPAddrTable->dwNumEntries; i++)
    {
        if (!IS_LOOPBACK_ADDRESS(ntohl(m_pMibIPAddrTable->table[i].dwAddr)) &&
            m_pMibIPAddrTable->table[i].dwAddr != htonl(INADDR_ANY))
        {
            hr = CreateAndAddListenSocketToList(m_pMibIPAddrTable->table[i].dwAddr);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s Creating listen socket failed %x",
                     __fxName, hr));
                // If we fail to bind to an interface we don't fail init.
                // we just don't have a SIP_LISTEN_SOCKET for that interface.
                // This is to avoid problems with some special interfaces
                // such as IPSink adapater that have problems when we bind
                // to them.
                // return hr;
            }
        }
    }

    return S_OK;
}


HRESULT
SIP_STACK::UpdateListenSocketList()
{
    HRESULT hr;
    ENTER_FUNCTION("SIP_STACK::UpdateListenSocketList");

    DPNHCAPS             NatHelperCaps;
    LIST_ENTRY          *pListEntry;
    SIP_LISTEN_SOCKET   *pListenSocket;
    DWORD                i = 0;


    // GetCaps()
    // We don't use m_NatHelperCaps here as this structure
    // is used at init and later by the NAT thread only.
    hr = InitNatCaps(&NatHelperCaps);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s InitNatCaps failed %x",
             __fxName, hr));
    }
    
    // Mark all sockets as not in new ipaddr list.
    pListEntry = m_ListenSocketList.Flink;

    while (pListEntry != &m_ListenSocketList)
    {
        pListenSocket = CONTAINING_RECORD(pListEntry,
                                          SIP_LISTEN_SOCKET,
                                          m_ListEntry);
        pListEntry = pListEntry->Flink;

        pListenSocket->m_IsPresentInNewIpAddrTable = FALSE;
        pListenSocket->m_NeedToUpdatePublicListenAddr = FALSE;
    }

    // Mark already existing sockets for ip addresses
    // in the new list and add new listen sockets for
    // ip addresses that we are not currently listening on.
    for (i = 0; i < m_pMibIPAddrTable->dwNumEntries; i++)
    {
        if (!IS_LOOPBACK_ADDRESS(ntohl(m_pMibIPAddrTable->table[i].dwAddr)) &&
            m_pMibIPAddrTable->table[i].dwAddr != htonl(INADDR_ANY))
        {
            pListenSocket = FindListenSocketForIpAddr(
                                m_pMibIPAddrTable->table[i].dwAddr);
            if (pListenSocket != NULL)
            {
                LOG((RTC_TRACE, "%s - already listening on %d.%d.%d.%d",
                     __fxName,
                     NETORDER_BYTES0123(m_pMibIPAddrTable->table[i].dwAddr)));
                pListenSocket->m_IsPresentInNewIpAddrTable = TRUE;
                pListenSocket->m_NeedToUpdatePublicListenAddr = TRUE;
            }
            else
            {
                LOG((RTC_TRACE, "%s adding listen socket %d.%d.%d.%d",
                     __fxName,
                     NETORDER_BYTES0123(m_pMibIPAddrTable->table[i].dwAddr)));
                hr = CreateAndAddListenSocketToList(
                         m_pMibIPAddrTable->table[i].dwAddr
                         );
                if (hr != S_OK)
                {
                    LOG((RTC_ERROR, "%s Creating listen socket failed %x",
                         __fxName, hr));
                }
            }
        }
    }

    // Remove listen sockets for addresses not in the
    // new IP address list.
    
    pListEntry = m_ListenSocketList.Flink;

    while (pListEntry != &m_ListenSocketList)
    {
        pListenSocket = CONTAINING_RECORD(pListEntry,
                                          SIP_LISTEN_SOCKET,
                                          m_ListEntry);
        pListEntry = pListEntry->Flink;

        if (!pListenSocket->m_IsPresentInNewIpAddrTable)
        {
            LOG((RTC_TRACE, "%s deleting listen socket %d.%d.%d.%d",
                 __fxName, NETORDER_BYTES0123(pListenSocket->m_IpAddr)));
            pListenSocket->DeregisterPorts(m_pDirectPlayNATHelp);
            delete pListenSocket;
        }
    }

    // Update the addresses of sockets that we need to.
    
    pListEntry = m_ListenSocketList.Flink;

    while (pListEntry != &m_ListenSocketList)
    {
        pListenSocket = CONTAINING_RECORD(pListEntry,
                                          SIP_LISTEN_SOCKET,
                                          m_ListEntry);
        pListEntry = pListEntry->Flink;

        if (pListenSocket->m_NeedToUpdatePublicListenAddr)
        {
            hr = UpdatePublicListenAddr(pListenSocket);
            if (hr != S_OK)
            {   
                if(hr == DPNHERR_PORTUNAVAILABLE)
                {
                    DWORD   dwIpAddr = pListenSocket->m_IpAddr;
                    delete pListenSocket;

                    LOG((RTC_TRACE,"%s NAT port unavailable, creating new listen sockets for IP addr 0x%x",
                                    __fxName, dwIpAddr));
                    hr = CreateAndAddListenSocketToList(dwIpAddr);
                       if (hr != S_OK) 
                       {
                           LOG((RTC_ERROR,"%s unable to CreateAndAddListenSocketToList for IPAddr 0x%x",
                               __fxName, dwIpAddr));
                       }
                }
                else 
                    LOG((RTC_ERROR, "%s getting public listen addr failed %x",
                         __fxName, hr));
            }
        }        
    }
    
    return S_OK;
}


VOID
SIP_STACK::DeleteListenSocketList()
{
    LIST_ENTRY          *pListEntry;
    SIP_LISTEN_SOCKET   *pListenSocket;

    ENTER_FUNCTION("SIP_STACK::DeleteListenSocketList");

    LOG((RTC_TRACE, "%s - Enter", __fxName));

    pListEntry = m_ListenSocketList.Flink;

    while (pListEntry != &m_ListenSocketList)
    {
        pListenSocket = CONTAINING_RECORD(pListEntry,
                                          SIP_LISTEN_SOCKET,
                                          m_ListEntry);
        pListEntry = pListEntry->Flink;

        // We don't deregister the NAT port mappings here as
        // closing the dpnat helper handle will result in deregistering the
        // port mappings as well.
        delete pListenSocket;
    }

    LOG((RTC_TRACE, "%s - Exit", __fxName));

}


SIP_LISTEN_SOCKET *
SIP_STACK::FindListenSocketForIpAddr(
    DWORD   IpAddr      // Network Byte order
    )
{
    LIST_ENTRY          *pListEntry;
    SIP_LISTEN_SOCKET   *pListenSocket;

    pListEntry = m_ListenSocketList.Flink;

    while (pListEntry != &m_ListenSocketList)
    {
        pListenSocket = CONTAINING_RECORD(pListEntry,
                                          SIP_LISTEN_SOCKET,
                                          m_ListEntry);
        if (pListenSocket->m_IpAddr == IpAddr)
        {
            return pListenSocket;
        }

        pListEntry = pListEntry->Flink;
    }

    return NULL;
}


// The local interface address is passed in pListenAddr and
// we return the port in the structure.

// Returns TRUE if we are listening on a local interface for
// the IP address passed in pListenAddr. If not, returns FALSE.
// This could happen in the ISA client installed scenario where
// getsockname() gives the external address of the proxy.
BOOL
SIP_STACK::GetListenAddr(
    IN OUT SOCKADDR_IN *pListenAddr,
    IN     BOOL         fTcp
    )
{
    ENTER_FUNCTION("SIP_STACK::GetListenAddr");
    
    SIP_LISTEN_SOCKET *pListenSocket =
        FindListenSocketForIpAddr(pListenAddr->sin_addr.s_addr);

    if (pListenSocket == NULL)
    {
        LOG((RTC_ERROR, "%s - failed to find listen socket for %d.%d.%d.%d",
             __fxName, NETORDER_BYTES0123(pListenAddr->sin_addr.s_addr)));
        return FALSE;
    }

    if (fTcp)
    {
        pListenAddr->sin_port =
            pListenSocket->m_pDynamicPortTcpSocket->m_LocalAddr.sin_port;
    }
    else
    {
        pListenAddr->sin_port =
            pListenSocket->m_pDynamicPortUdpSocket->m_LocalAddr.sin_port;
    }

    return TRUE;
}



//
// Profile processing
//

BOOL
SIP_STACK::IsProviderIdPresent(
    IN  SIP_PROVIDER_ID    *pProviderId,
    OUT ULONG              *pProviderIndex  
    )
{
    ULONG i = 0;
    for (i = 0; i < m_NumProfiles; i++)
    {
        if (IsEqualGUID(*pProviderId, m_ProviderProfileArray[i].ProviderID))
        {
            *pProviderIndex = i;
            return TRUE;
        }
    }

    return FALSE;
}


HRESULT
SIP_STACK::AddProviderProfile(
    IN SIP_PROVIDER_PROFILE    *pProviderProfile
    )
{
    HRESULT hr;

    ENTER_FUNCTION("SIP_STACK::AddProviderProfile");
    LOG(( RTC_TRACE, "%s - entered", __fxName ));
    
    
    if (m_NumProfiles == m_ProviderProfileArraySize)
    {
        hr = GrowProviderProfileArray();
        if (hr != S_OK)
            return hr;
    }

    hr = CopyProviderProfile(m_NumProfiles, pProviderProfile, TRUE);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s CopyProviderProfileStrings failed %x",
             __fxName, hr));
        return hr;
    }

    m_ProviderProfileArray[m_NumProfiles].pRegisterContext = NULL;

    LOG((RTC_TRACE, "%s added profile at index %d",
        __fxName, m_NumProfiles));
    
    // Success.
    m_NumProfiles++;

    if (pProviderProfile->lRegisterAccept !=0)
    {
        hr = StartRegistration(&m_ProviderProfileArray[m_NumProfiles-1]);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s StartRegistration failed %x",
                 __fxName, hr));
        }
    }

    LOG(( RTC_TRACE, "%s - exit OK", __fxName ));
    return S_OK;
}


HRESULT
SIP_STACK::CopyProviderProfile(
    IN ULONG                 ProviderIndex,
    IN SIP_PROVIDER_PROFILE *pProviderProfile,
    IN BOOL                  fRegistrarStatusUpdated
    )
{
	//
	//Save theexisting register context if needed
	//
	PVOID pRegisterContext = m_ProviderProfileArray[ProviderIndex].pRegisterContext;

    ZeroMemory(&m_ProviderProfileArray[ProviderIndex], sizeof(SIP_PROVIDER_PROFILE) );

    m_ProviderProfileArray[ProviderIndex].ProviderID = pProviderProfile -> ProviderID;
    m_ProviderProfileArray[ProviderIndex].lRegisterAccept = pProviderProfile -> lRegisterAccept;
    m_ProviderProfileArray[ProviderIndex].Registrar.TransportProtocol = pProviderProfile -> Registrar.TransportProtocol;
    m_ProviderProfileArray[ProviderIndex].Registrar.AuthProtocol = pProviderProfile -> Registrar.AuthProtocol;
    m_ProviderProfileArray[ProviderIndex].pRedirectContext = pProviderProfile -> pRedirectContext;

    if( fRegistrarStatusUpdated == TRUE )
    {
        m_ProviderProfileArray[ProviderIndex].pRegisterContext = pProviderProfile -> pRegisterContext;
    }
	else
	{
		//
		//Put the existing register context back
		//
        m_ProviderProfileArray[ProviderIndex].pRegisterContext = (REGISTER_CONTEXT*)pRegisterContext;
	}

    if( pProviderProfile -> UserURI != NULL )
    {
        m_ProviderProfileArray[ProviderIndex].UserURI = 
            RtcAllocString(pProviderProfile -> UserURI);
        if( m_ProviderProfileArray[ProviderIndex].UserURI == NULL )
        {
            goto error;
        }
    }
    
    if( pProviderProfile->UserCredentials.Username != NULL )
    {
        m_ProviderProfileArray[ProviderIndex].UserCredentials.Username =
            RtcAllocString( pProviderProfile->UserCredentials.Username );

        if( m_ProviderProfileArray[ProviderIndex].UserCredentials.Username == NULL )
        {
            goto error;
        }
    }
    
    if( pProviderProfile->UserCredentials.Password != NULL )
    {
        m_ProviderProfileArray[ProviderIndex].UserCredentials.Password = 
            RtcAllocString( pProviderProfile->UserCredentials.Password );

        if( m_ProviderProfileArray[ProviderIndex].UserCredentials.Password == NULL )
        {
            goto error;
        }
    }

    if( pProviderProfile->Realm != NULL )
    {
        m_ProviderProfileArray[ProviderIndex].Realm = 
            RtcAllocString( pProviderProfile->Realm );

        if( m_ProviderProfileArray[ProviderIndex].Realm == NULL )
        {
            goto error;
        }
    }

    if( pProviderProfile->Registrar.ServerAddress != NULL )
    {
        m_ProviderProfileArray[ProviderIndex].Registrar.ServerAddress =
            RtcAllocString( pProviderProfile->Registrar.ServerAddress );

        if( m_ProviderProfileArray[ProviderIndex].Registrar.ServerAddress == NULL )
        {
            goto error;
        }
    }

    return S_OK;

error:

    FreeProviderProfileStrings(ProviderIndex);
    
    return E_OUTOFMEMORY;
}


VOID
SIP_STACK::FreeProviderProfileStrings(
    IN ULONG ProviderIndex
    )
{
    if( m_ProviderProfileArray[ProviderIndex].UserURI != NULL )
    {
        RtcFree( m_ProviderProfileArray[ProviderIndex].UserURI );
        m_ProviderProfileArray[ProviderIndex].UserURI = NULL;
    }

    if( m_ProviderProfileArray[ProviderIndex].UserCredentials.Username != NULL )
    {
        RtcFree( m_ProviderProfileArray[ProviderIndex].UserCredentials.Username );
        m_ProviderProfileArray[ProviderIndex].UserCredentials.Username = NULL;
    }
    
    if( m_ProviderProfileArray[ProviderIndex].UserCredentials.Password != NULL )
    {
        RtcFree( m_ProviderProfileArray[ProviderIndex].UserCredentials.Password );
        m_ProviderProfileArray[ProviderIndex].UserCredentials.Password = NULL;
    }

    if( m_ProviderProfileArray[ProviderIndex].Realm != NULL )
    {
        RtcFree( m_ProviderProfileArray[ProviderIndex].Realm );
        m_ProviderProfileArray[ProviderIndex].Realm = NULL;
    }


    if( m_ProviderProfileArray[ProviderIndex].Registrar.ServerAddress != NULL )
    {
        RtcFree( m_ProviderProfileArray[ProviderIndex].Registrar.ServerAddress );
        m_ProviderProfileArray[ProviderIndex].Registrar.ServerAddress = NULL;
    }
}



HRESULT
SIP_STACK::GrowProviderProfileArray()
{
    HRESULT hr;
    SIP_PROVIDER_PROFILE *NewProviderProfileArray;

    NewProviderProfileArray = (SIP_PROVIDER_PROFILE *)
        malloc(m_ProviderProfileArraySize * 2 * sizeof(SIP_PROVIDER_PROFILE));
    
    if (NewProviderProfileArray == NULL)
    {
        LOG((RTC_ERROR, "GrowProviderProfileArray Couldn't allocate"));
        return E_OUTOFMEMORY;
    }

    m_ProviderProfileArraySize *= 2;
    
    CopyMemory(NewProviderProfileArray, m_ProviderProfileArray,
               m_ProviderProfileArraySize * sizeof(SIP_PROVIDER_PROFILE));

    free(m_ProviderProfileArray);
    m_ProviderProfileArray = NewProviderProfileArray;
    
    return S_OK;
}


HRESULT
SIP_STACK::UpdateProviderProfile(
    IN ULONG                 ProviderIndex, 
    IN SIP_PROVIDER_PROFILE *pProviderProfile
    )
{
    ENTER_FUNCTION("SIP_STACK::UpdateProviderProfile");
    
    BOOL    fRegistrarStatusUpdated = TRUE;

    // Initiate unregistration for the old profile.
    // Note that we need to do this only if the Registrar / SIP URL changed.
    UpdateProviderRegistration( ProviderIndex, pProviderProfile,
            &fRegistrarStatusUpdated );

    FreeProviderProfileStrings(ProviderIndex);
    
    CopyProviderProfile(ProviderIndex, pProviderProfile, fRegistrarStatusUpdated );
    
    LOG(( RTC_TRACE, "%s - exit OK", __fxName ));
    return S_OK;
}


BOOL
ChangeInRegistrarInfo(
    IN SIP_PROVIDER_PROFILE *pProviderInfo,
    IN SIP_PROVIDER_PROFILE *pProviderProfile
    )
{
    if( pProviderProfile->lRegisterAccept != pProviderInfo->lRegisterAccept )
    {
        return TRUE;
    }

    if( pProviderProfile -> Registrar.ServerAddress != NULL )
    {
        if( wcscmp( pProviderInfo -> Registrar.ServerAddress,
                    pProviderProfile -> Registrar.ServerAddress ) != 0 )
        {
            return TRUE;
        }
    }
    
    if( pProviderProfile -> UserURI != NULL )
    {
        if( wcscmp( pProviderInfo -> UserURI,
                    pProviderProfile -> UserURI ) != 0 )
        {
            return TRUE;
        }
    }

    if( pProviderProfile -> UserCredentials.Username != NULL )
    {
        if( wcscmp( pProviderInfo -> UserCredentials.Username,
                    pProviderProfile -> UserCredentials.Username ) != 0 )
        {
            return TRUE;
        }
    }
    
    if( pProviderProfile -> UserCredentials.Password != NULL )
    {
        if( wcscmp( pProviderInfo -> UserCredentials.Password,
                    pProviderProfile -> UserCredentials.Password ) != 0 )
        {
            return TRUE;
        }
    }

    return FALSE;
}


void
SIP_STACK::UpdateProviderRegistration(
    IN  ULONG                 ProviderIndex, 
    IN  SIP_PROVIDER_PROFILE *pProviderProfile,
    OUT BOOL                 *fRegistrarStatusUpdated
    )
{
    HRESULT hr;

    SIP_PROVIDER_PROFILE *pProviderInfo = &m_ProviderProfileArray[ProviderIndex];

    if( pProviderInfo->lRegisterAccept == 0 )
    {
        //No need to UNREG
        if( pProviderProfile->lRegisterAccept != 0 )
        {
            hr = StartRegistration( pProviderProfile );
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "StartRegistration failed %x", hr));
            }

            ASSERT( pProviderInfo -> pRegisterContext == NULL );
        }            
    }
    else
    {
        if( ChangeInRegistrarInfo( pProviderInfo, pProviderProfile ) == TRUE )
        {
            //start UNREG if in registered state.
            if( pProviderInfo -> pRegisterContext != NULL )
            {
                ((REGISTER_CONTEXT*) (pProviderInfo -> pRegisterContext)) -> StartUnregistration();

                //release the reference on REGISTER_CONTEXT
                ((REGISTER_CONTEXT*) (pProviderInfo -> pRegisterContext)) -> MsgProcRelease();
                pProviderInfo -> pRegisterContext = NULL;
            }
            
            //reREGISTER with new info if required.
            if( pProviderProfile->lRegisterAccept !=0 )
            {
                hr = StartRegistration( pProviderProfile );
                if( hr != S_OK )
                {
                    LOG((RTC_ERROR, "StartRegistration failed %x", hr));
                }
            }            
        }
        else
        {
            *fRegistrarStatusUpdated = FALSE;
        }
    }
}


HRESULT
SIP_STACK::StartRegistration(
    IN SIP_PROVIDER_PROFILE *pProviderProfile
    )
{
    ENTER_FUNCTION("SIP_STACK::StartRegistration");

    HRESULT           hr;
    REGISTER_CONTEXT *pRegisterContext;

    pProviderProfile -> pRegisterContext = NULL;

    pRegisterContext = new REGISTER_CONTEXT(
                        this, 
                        (REDIRECT_CONTEXT*)pProviderProfile->pRedirectContext,
                        &(pProviderProfile->ProviderID) );

    if (pRegisterContext == NULL)
    {
        return E_OUTOFMEMORY;
    }

    // REGISTER_CONTEXT is created with a refcount of 1 - we are
    // now transfering this reference to pProviderProfile->pRegisterContext
    pProviderProfile -> pRegisterContext = (PVOID) pRegisterContext;

    hr = pRegisterContext->StartRegistration(pProviderProfile);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s pRegisterContext->StartRegistration failed %x",
             __fxName, hr));
        
        pProviderProfile -> pRegisterContext = NULL;
        
        pRegisterContext->MsgProcRelease();
        return hr;
    }

    return S_OK;
}


HRESULT
SIP_STACK::GetProviderID( 
    REGISTER_CONTEXT    *pRegisterContext,
    SIP_PROVIDER_ID     *pProviderID
    )
{
    ULONG i = 0;
    for (i = 0; i < m_NumProfiles; i++)
    {
        if( m_ProviderProfileArray[i].pRegisterContext == pRegisterContext )
        {
            *pProviderID = m_ProviderProfileArray[i].ProviderID;
            return S_OK;
        }
    }

    return E_FAIL;
}


// Returns pointers to strings in table.
// The caller should not free them.
HRESULT
SIP_STACK::GetProfileUserCredentials(
    IN  SIP_PROVIDER_ID        *pProviderId,
    OUT SIP_USER_CREDENTIALS  **ppUserCredentials,
    OUT LPOLESTR               *pRealm
    )
{
    ULONG i = 0;
    for (i = 0; i < m_NumProfiles; i++)
    {
        if (IsEqualGUID(*pProviderId, m_ProviderProfileArray[i].ProviderID))
        {
            *ppUserCredentials = &m_ProviderProfileArray[i].UserCredentials;
            *pRealm = m_ProviderProfileArray[i].Realm;
            return S_OK;
        }
    }

    return E_FAIL;
}

//Checks the incoming messages for missing critical fields to send 400 class errors
HRESULT 
SIP_STACK::CheckIncomingSipMessage(IN SIP_MESSAGE  *pSipMsg,
                                IN ASYNC_SOCKET *pAsyncSock,
                                OUT BOOL * pisError,
                                OUT ULONG * pErrorCode,
                                OUT  SIP_HEADER_ARRAY_ELEMENT   *pAdditionalHeaderArray,
                                OUT  ULONG * pAdditionalHeaderCount
                                )
{
    ASSERT(pAdditionalHeaderArray != NULL);
    LOG((RTC_TRACE, "SIP_STACK::CheckIncomingSipMessage()"));
    HRESULT hr;
    *pisError = FALSE;
    PSTR        Header;
    ULONG       HeaderLen;

    hr = pSipMsg->CheckSipVersion();
    if(hr != S_OK)
    {
        LOG((RTC_ERROR, "SipVersionCheck failed Sending 505"));
        *pisError = TRUE;
        *pErrorCode = 505;
        return hr;
    }
    hr = pSipMsg->GetSingleHeader(SIP_HEADER_FROM, &Header, &HeaderLen);
    if (hr != S_OK || Header == NULL)
    {
        //Cannot send message back, drop, is Error is still False
        LOG((RTC_ERROR, "FROM corrupt cannot send 400 message back"));
        return hr;
    }
    hr = pSipMsg->GetSingleHeader(SIP_HEADER_TO, &Header, &HeaderLen);
    if (hr != S_OK || Header == NULL)
    {
        LOG((RTC_ERROR, "TO corrupt sending 400 message back"));
        *pisError = TRUE;
        *pErrorCode = 400;
        return hr;
    }
    hr = pSipMsg->GetSingleHeader(SIP_HEADER_CSEQ, &Header, &HeaderLen);
    if (hr != S_OK || Header == NULL)
    {
        LOG((RTC_ERROR, "CSEQ corrupt sending 400 message back"));
        *pisError = TRUE;
        *pErrorCode = 400;
        return hr;
    }
    hr = pSipMsg->GetSingleHeader(SIP_HEADER_CALL_ID, &Header, &HeaderLen);
    if (hr != S_OK || Header == NULL)
    {
        LOG((RTC_ERROR, "CALLID corrupt cannot send message back"));
        return hr;
    }
    hr = pSipMsg->GetFirstHeader(SIP_HEADER_VIA, &Header, &HeaderLen);
    if (hr != S_OK || Header == NULL)
    {
        //Cannot send message back
        LOG((RTC_ERROR, "VIA corrupt cannot send message back"));
        return hr;
    }
    
    hr = pSipMsg->GetSingleHeader(SIP_HEADER_ACCEPT, &Header, &HeaderLen);
    if(hr != RTC_E_SIP_HEADER_NOT_PRESENT)
    {
        BOOL isSdp = (pSipMsg->GetMethodId() == SIP_METHOD_INVITE
                      && IsOneOfContentTypeSdp(Header, HeaderLen));

        BOOL isText = (pSipMsg->GetMethodId() == SIP_METHOD_MESSAGE
                       && IsOneOfContentTypeTextPlain(Header, HeaderLen));

        BOOL isXPIDF = ((pSipMsg->GetMethodId() == SIP_METHOD_SUBSCRIBE
                         || pSipMsg->GetMethodId() == SIP_METHOD_NOTIFY)
                        && IsOneOfContentTypeXpidf(Header, HeaderLen));

        if( !isSdp && !isText && !isXPIDF )
        {
            *pisError = TRUE;
            LOG((RTC_ERROR, "Accept header found, sending 406"));
            *pErrorCode = 406;
            return hr;
        }
    }

    hr = pSipMsg->GetSingleHeader(SIP_HEADER_REQUIRE, &Header, &HeaderLen);
    if(hr != RTC_E_SIP_HEADER_NOT_PRESENT)
    {
        LOG((RTC_ERROR, "Require header found, sending 420"));
        //Send the UNSUPPORTED header
        *pisError = TRUE;
        *pErrorCode = 420;
        pAdditionalHeaderArray->HeaderId = SIP_HEADER_UNSUPPORTED;
        pAdditionalHeaderArray->HeaderValueLen = HeaderLen;
        pAdditionalHeaderArray->HeaderValue = Header;
        *pAdditionalHeaderCount = 1;
        return hr;
    }
    
    hr = pSipMsg->GetSingleHeader(SIP_HEADER_CONTENT_ENCODING, &Header, &HeaderLen);
    //We do not support this header.
    if( hr != RTC_E_SIP_HEADER_NOT_PRESENT )
    {
        if( HeaderLen != 0 )
        {
            ULONG   BytesParsed = 0;
            ParseWhiteSpace(Header, HeaderLen, &BytesParsed );

            hr = ParseKnownString( Header, HeaderLen, &BytesParsed,
                SIP_ACCEPT_ENCODING_TEXT,
                sizeof( SIP_ACCEPT_ENCODING_TEXT ) - 1,
                FALSE );
        }

        if( hr != S_OK )
        {
            LOG(( RTC_ERROR, "CONTENT-ENCODING present: send 415 message back" ));

            *pisError = TRUE;
            *pErrorCode = 415;
            //Send Accept-Encoding Header
            pAdditionalHeaderArray->HeaderId = SIP_HEADER_ACCEPT_ENCODING;
            pAdditionalHeaderArray->HeaderValueLen = strlen(SIP_ACCEPT_ENCODING_TEXT);
            pAdditionalHeaderArray->HeaderValue = SIP_ACCEPT_ENCODING_TEXT;
            *pAdditionalHeaderCount = 1;
            return hr;
        }
    }

    return S_OK;
}

void
SIP_STACK::ProcessMessage(
    IN SIP_MESSAGE  *pSipMsg,
    IN ASYNC_SOCKET *pAsyncSock
    )
{
    HRESULT hr = S_OK;
    BOOL isError;
    ULONG ErrCode = 0;
    SIP_HEADER_ARRAY_ELEMENT AdditionalHeaderArray;
    ULONG AdditionalHeaderCount = 0;

    if(pSipMsg->MsgType == SIP_MESSAGE_TYPE_REQUEST)
    {   
        hr = CheckIncomingSipMessage(pSipMsg, pAsyncSock, &isError, 
            &ErrCode, &AdditionalHeaderArray, &AdditionalHeaderCount);
        if(hr != S_OK || isError)
        {
            if(isError && pSipMsg->MsgType == SIP_MESSAGE_TYPE_REQUEST)
            {   
                //Send error
                LOG((RTC_TRACE,
                    "Dropping incoming Sip Message, sending %d", ErrCode));
                hr = CreateIncomingReqfailCall(pAsyncSock->GetTransport(),
                                                pSipMsg, 
                                                pAsyncSock,
                                                ErrCode, 
                                                &AdditionalHeaderArray,
                                                AdditionalHeaderCount);
                if (hr != S_OK)
                {
                    LOG((RTC_ERROR, "CreateIncomingReqfailCall failed 0x%x", hr));
                }
                AdditionalHeaderArray.HeaderValue = NULL;
            }
            return;
        }
    }

    SIP_MSG_PROCESSOR *pSipMsgProc = FindMsgProcForMessage(pSipMsg);
    if (pSipMsgProc != NULL)
    {
        // If message belongs to an existing call, then
        // the call processes the message.
        LOG((RTC_TRACE,
                "SIP_STACK:Incoming Message given to MsgProcessor::ProcessMessage %x", pSipMsgProc));

        //Check the From To Tags and send 481 if they do not match
        if(pSipMsg->MsgType == SIP_MESSAGE_TYPE_REQUEST)
        {
                hr = pSipMsgProc->CheckFromToInRequest(pSipMsg);
        }
        else
        {
            hr = pSipMsgProc->CheckFromToInResponse(pSipMsg);
        }
        if(hr == S_OK)
        {
            pSipMsgProc->ProcessMessage(pSipMsg, pAsyncSock);
            return;
        }
        else
        {
            if (pSipMsg->MsgType == SIP_MESSAGE_TYPE_REQUEST &&
                pSipMsg->GetMethodId() != SIP_METHOD_ACK)
            {
                //Send 481 Reqfail call
                LOG((RTC_TRACE,
                     "Dropping incoming Sip Message, sending 481"));
                hr = CreateIncomingReqfailCall(pAsyncSock->GetTransport(),
                                               pSipMsg, pAsyncSock, 481);
                if (hr != S_OK)
                {
                    LOG((RTC_ERROR, "CreateIncomingReqfailCall failed 0x%x", hr));
                }
            }
            return;
        }
    }

    // At this point we need to process only Requests.
    
    // If it does not belong to any of the calls, this could be an
    // INVITE for a new call.
    if (pSipMsg->MsgType == SIP_MESSAGE_TYPE_REQUEST)
    {
        if( !m_pNotifyInterface )
        {
            LOG((RTC_TRACE,
                 "Dropping incoming session as ISipStackNotify interface "
                 "has not been specified yet" ));
            return;
        }

        if (pSipMsg->GetMethodId() == SIP_METHOD_INVITE)
        {
            if (!m_AllowIncomingCalls)
            {
                LOG((RTC_TRACE,
                    "Dropping incoming call as incoming calls are disabled"));
                return;
            }

            hr = CreateIncomingCall(pAsyncSock->GetTransport(),
                                    pSipMsg, pAsyncSock);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "CreateIncomingCall failed 0x%x", hr));
            }
        }
        else if (pSipMsg->GetMethodId() == SIP_METHOD_OPTIONS)
        {
            LOG((RTC_TRACE,
                 "Options Recieved on a separate Call-Id. Creating Options MsgProc"));
            hr = CreateIncomingOptionsCall(pAsyncSock->GetTransport(),
                                           pSipMsg, pAsyncSock);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "CreateIncomingOptionsCall failed 0x%x", hr));
            }
        }
        else if (pSipMsg->GetMethodId() == SIP_METHOD_BYE ||
                 pSipMsg->GetMethodId() == SIP_METHOD_CANCEL ||
                 pSipMsg->GetMethodId() == SIP_METHOD_NOTIFY )
        {
            LOG((RTC_TRACE,
                 "Dropping incoming Sip Bye/Cancel/Notify Message, sending 481"));
            hr = CreateIncomingReqfailCall(pAsyncSock->GetTransport(),
                                           pSipMsg, pAsyncSock, 481);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "CreateIncomingReqfailCall failed 0x%x", hr));
            }
        }
        else if( pSipMsg->GetMethodId() == SIP_METHOD_SUBSCRIBE )
        {
            if( pSipMsg -> GetExpireTimeoutFromResponse( NULL, 0, 
                SUBSCRIBE_DEFAULT_TIMER ) == 0 )
            {
                LOG(( RTC_ERROR, "Non matching UNSUB message. Ignoring" ));
            
                hr = CreateIncomingReqfailCall(pAsyncSock->GetTransport(),
                                           pSipMsg, pAsyncSock, 481 );
                if (hr != S_OK)
                {
                    LOG((RTC_ERROR, "CreateIncomingReqfailCall failed 0x%x", hr));
                }
            
                return;
            }

            // Check the URI rules.
            if( !IsWatcherAllowed( pSipMsg ) )
            {
                LOG(( RTC_TRACE, 
                    "Dropping incoming watcher as incoming watcher disabled" ));
                return;
            }

            hr = CreateIncomingWatcher( pAsyncSock->GetTransport(),
                pSipMsg, pAsyncSock );

            if( hr != S_OK )
            {
                LOG(( RTC_ERROR, "CreateIncomingWatcher failed 0x%x", hr ));
            }
        }
        //Case IM
        else if (pSipMsg->GetMethodId() == SIP_METHOD_MESSAGE)
        {
            if (!m_AllowIncomingCalls)
            {
                LOG((RTC_TRACE,
                    "Dropping incoming call as incoming calls are disabled"));
                return;
            }

            hr = CreateIncomingMessageSession(pAsyncSock->GetTransport(), pSipMsg, pAsyncSock);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "CreateIncomingMessageSession failed 0x%x", hr));
                //TODO if the call does not succeed, we need to send error message back.
                //Many errors could occur because some fields might not be present.
            }
        }
        //This is for the cases when INFO preceeds MESSAGEs
        else if (pSipMsg->GetMethodId() == SIP_METHOD_INFO)
        {
            if (!m_AllowIncomingCalls)
            {
                LOG((RTC_TRACE,
                    "Dropping incoming call as incoming calls are disabled"));
                return;
            }

            LOG((RTC_TRACE,
                 "Dropping incoming INFO method, sending 481"));
            hr = CreateIncomingReqfailCall(pAsyncSock->GetTransport(),
                                           pSipMsg, pAsyncSock, 481);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "CreateIncomingReqfailCall failed 0x%x", hr));
            }
        }
        else if (pSipMsg->GetMethodId() != SIP_METHOD_ACK)
        {
            LOG((RTC_TRACE,
                 "Dropping incoming Request method: %d, sending 405",
                 pSipMsg->GetMethodId()));
            hr = CreateIncomingReqfailCall(pAsyncSock->GetTransport(),
                                           pSipMsg, pAsyncSock, 405);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "CreateIncomingReqfailCall failed 0x%x", hr));
            }
        }
    else
        {
            LOG((RTC_WARN, "Call-ID does not match existing calls - Dropping incoming packet"));
        }
    }
}

HRESULT
SIP_STACK::CreateIncomingCall(
    IN  SIP_TRANSPORT   Transport,
    IN  SIP_MESSAGE    *pSipMsg,
    IN  ASYNC_SOCKET   *pResponseSocket
    )
{
    //Only RTP Calls are handled here
    HRESULT       hr;
    RTP_CALL     *pRtpCall;

    ASSERT(pSipMsg->GetMethodId() == SIP_METHOD_INVITE);
    
    if (!m_pNotifyInterface)
    {
        LOG((RTC_TRACE,
             "Dropping incoming call as ISipStackNotify interface "
             "has not been specified yet"));
        return E_FAIL;
    }

    //
    // Drop the session if the To tag in not empty
    //
    
    hr = DropIncomingSessionIfNonEmptyToTag(Transport,
                                            pSipMsg,
                                            pResponseSocket );

    if( hr != S_OK )
    {
        // session has been dropped.

        return hr;
    }

    pRtpCall = new RTP_CALL(NULL, this, NULL);
    if (pRtpCall == NULL)
        return E_OUTOFMEMORY;

    hr = pRtpCall->StartIncomingCall(Transport, pSipMsg, pResponseSocket);
    if (hr != S_OK)
    {
        // Release our reference.
        pRtpCall->Release();
        return hr;
    }

    // We create the call with a ref count of 1
    // At this point the core should have addref'ed the call
    // and we can release our reference.
    pRtpCall->Release();
    return S_OK;
}


HRESULT
SIP_STACK::DropIncomingSessionIfNonEmptyToTag(
    IN  SIP_TRANSPORT   Transport,
    IN  SIP_MESSAGE    *pSipMsg,
    IN  ASYNC_SOCKET   *pResponseSocket
    )
{
    HRESULT         hr              = S_OK;
    PSTR            ToHeader        = NULL;
    ULONG           ToHeaderLen     = 0;
    FROM_TO_HEADER  DecodedToHeader;
    ULONG           BytesParsed     = 0;

    ENTER_FUNCTION( "SIP_STACK::DropIncomingSessionIfNonEmptyToTag" );

    hr = pSipMsg->GetSingleHeader(SIP_HEADER_TO, 
                                    &ToHeader, 
                                    &ToHeaderLen);
    if (hr != S_OK)
    {
        LOG(( RTC_ERROR, "%s Couldn't find To header %x", __fxName, hr ));

        hr = CreateIncomingReqfailCall( Transport,
                                        pSipMsg,
                                        pResponseSocket,
                                        400 );
        return E_FAIL;
    }
    
    hr = ParseFromOrToHeader(ToHeader, 
                             ToHeaderLen, 
                             &BytesParsed,
                             &DecodedToHeader);
    BytesParsed = 0;
    if (hr != S_OK)
    {
        LOG(( RTC_ERROR, "%s - Parse To header failed %x", __fxName, hr ));

        hr = CreateIncomingReqfailCall( Transport,
                                        pSipMsg,
                                        pResponseSocket,
                                        400 );
        return E_FAIL;
    }

   if( DecodedToHeader.m_TagValue.Length != 0 )
   {
        //
        // For us this is a new session but for the sender this is an existing
        // session. So send a 481 message back and force a session shutdown.
        //
        hr = CreateIncomingReqfailCall( Transport,
                                        pSipMsg,
                                        pResponseSocket,
                                        481 );

        LOG(( RTC_ERROR, "%s - Non empty To header dropping the session", 
            __fxName ));

        return E_FAIL;
   }

   return S_OK;
}


HRESULT
SIP_STACK::CreateIncomingReqfailCall(
    IN  SIP_TRANSPORT   Transport,
    IN  SIP_MESSAGE    *pSipMsg,
    IN  ASYNC_SOCKET   *pResponseSocket,
    IN ULONG StatusCode,
    SIP_HEADER_ARRAY_ELEMENT   *pAdditionalHeaderArray,
    ULONG AdditionalHeaderCount
    )
{
    HRESULT       hr;
    LOG((RTC_TRACE,
            "Inside SipStack::CreateIncomingReqfailCall"));
    REQFAIL_MSGPROC     *pReqfailMsgProc;
    pReqfailMsgProc = new REQFAIL_MSGPROC(this);
    if (pReqfailMsgProc == NULL)
        return E_OUTOFMEMORY;


    hr = pReqfailMsgProc->StartIncomingCall(Transport, 
                                            pSipMsg,
                                            pResponseSocket, 
                                            StatusCode,
                                            pAdditionalHeaderArray,
                                            AdditionalHeaderCount);

    if (hr != S_OK)
    {
        // Release our reference.
        pReqfailMsgProc->Release();
        return hr;
    }
    pReqfailMsgProc->Release();
    LOG((RTC_TRACE,
         "Inside SipStack::CreateIncomingReqfailCall Released REQFAIL_MSGPROC"));
    return S_OK;
}

HRESULT
SIP_STACK::CreateIncomingOptionsCall(
    IN  SIP_TRANSPORT   Transport,
    IN  SIP_MESSAGE    *pSipMsg,
    IN  ASYNC_SOCKET   *pResponseSocket
    )
{
    HRESULT       hr;
    LOG((RTC_TRACE,
            "Inside SipStack::CreateIncomingOptionsCall Creating OPTIONS_MSGPROC"));
    OPTIONS_MSGPROC     *pOptionsMsgProc;
    pOptionsMsgProc = new OPTIONS_MSGPROC(this);
    if (pOptionsMsgProc == NULL)
        return E_OUTOFMEMORY;

    hr = pOptionsMsgProc->StartIncomingCall(Transport, pSipMsg, pResponseSocket);
    if (hr != S_OK)
    {
        // Release our reference.
        pOptionsMsgProc->Release();
        return hr;
    }
    pOptionsMsgProc->Release();
    LOG((RTC_TRACE,
            "Inside SipStack::CreateIncomingOptionsCall Releasing OPTIONS_MSGPROC"));
    return S_OK;
}


HRESULT
SIP_STACK::GetSocketToDestination(
    IN  SOCKADDR_IN                     *pDestAddr,
    IN  SIP_TRANSPORT                    Transport,
    IN  LPCWSTR                          RemotePrincipalName,
    IN  CONNECT_COMPLETION_INTERFACE    *pConnectCompletion,
    IN  HttpProxyInfo                   *pHPInfo,
    OUT ASYNC_SOCKET                   **ppAsyncSocket
    )
{
    return m_SockMgr.GetSocketToDestination(
               pDestAddr, Transport,
               RemotePrincipalName,
               pConnectCompletion,
               pHPInfo,
               ppAsyncSocket);
}


HRESULT
SIP_STACK::NotifyRegisterRedirect(
    IN  REGISTER_CONTEXT   *pRegisterContext,
    IN  REDIRECT_CONTEXT   *pRedirectContext,
    IN  SIP_CALL_STATUS    *pRegisterStatus
    )
{
    HRESULT             hr;
    SIP_PROVIDER_ID     ProviderID; 
    
    hr = GetProviderID( pRegisterContext, &ProviderID );

    if( hr == S_OK )
    {
        hr = m_pNotifyInterface -> NotifyRegisterRedirect(
                                                        &ProviderID,
                                                        pRedirectContext,
                                                        pRegisterStatus );
        if( hr != S_OK )
        {
            LOG((RTC_ERROR, "NotifyRegisterRedirect returned error 0x%x", hr));
        }
    }

    return hr;
}


HRESULT
SIP_STACK::GetCredentialsFromUI(
    IN     SIP_PROVIDER_ID     *pProviderID,
    IN     BSTR                 Realm,
    IN OUT BSTR                *Username,
    OUT    BSTR                *Password        
    )
{
    if (m_pNotifyInterface != NULL)
    {
        return m_pNotifyInterface->GetCredentialsFromUI(
                   pProviderID,
                   Realm,
                   Username,
                   Password        
                   );
    }
    else
    {
        LOG((RTC_ERROR, "GetCredentialsFromUI m_pNotifyInterface is NULL"));
        return E_FAIL;
    }
}


HRESULT
SIP_STACK::GetCredentialsForRealm(
    IN  BSTR                 Realm,
    OUT BSTR                *Username,
    OUT BSTR                *Password,
    OUT SIP_AUTH_PROTOCOL   *pAuthProtocol
    )
{
    if (m_pNotifyInterface != NULL)
    {
        return m_pNotifyInterface->GetCredentialsForRealm(
                   Realm,
                   Username,
                   Password,
                   pAuthProtocol
                   );
    }
    else
    {
        LOG((RTC_ERROR, "GetCredentialsForRealm m_pNotifyInterface is NULL"));
        return E_FAIL;
    }
}


VOID
SIP_STACK::OfferCall(
    IN  SIP_CALL        *pSipCall,
    IN  SIP_PARTY_INFO  *pCallerInfo
    )
{
    HRESULT hr;
    ASSERTMSG("SetNotifyInterface has to be called", m_pNotifyInterface);
    
    hr = m_pNotifyInterface->OfferCall(pSipCall, pCallerInfo);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "OfferCall returned error 0x%x", hr));
    }
}


///////////////////////////////////////////////////////////////////////////////
// SIP Call List
///////////////////////////////////////////////////////////////////////////////


void
SIP_STACK::AddToMsgProcList(
    IN SIP_MSG_PROCESSOR *pSipMsgProc
    )
{
    InsertTailList(&m_MsgProcList, &pSipMsgProc->m_ListEntry);
}


SIP_MSG_PROCESSOR *
SIP_STACK::FindMsgProcForMessage(
    IN SIP_MESSAGE *pSipMsg
    )
{
    // Find the message processor that the message belongs to
    LIST_ENTRY          *pListEntry;
    SIP_MSG_PROCESSOR   *pSipMsgProc;
    
    pListEntry = m_MsgProcList.Flink;
    while (pListEntry != &m_MsgProcList)
    {
        pSipMsgProc = CONTAINING_RECORD(pListEntry, SIP_MSG_PROCESSOR, m_ListEntry);
        if (pSipMsgProc->DoesMessageBelongToMsgProc(pSipMsg))
        {
            return pSipMsgProc;
        }
    
        pListEntry = pListEntry->Flink;
    }

    // No Message Processor matches the SIP message.
    return NULL;
}


VOID
SIP_STACK::ShutdownAllMsgProcessors()
{
    // Find the message processor that the message belongs to
    LIST_ENTRY          *pListEntry;
    SIP_MSG_PROCESSOR   *pSipMsgProc;

    ENTER_FUNCTION("SIP_STACK::ShutdownAllMsgProcessors");

    LOG((RTC_TRACE, "%s this - %x num msgprocessors: %d",
         __fxName, this, m_NumMsgProcessors));
    
    pListEntry = m_MsgProcList.Flink;
    while (pListEntry != &m_MsgProcList)
    {
        pSipMsgProc = CONTAINING_RECORD(pListEntry,
                                        SIP_MSG_PROCESSOR,
                                        m_ListEntry);

        pListEntry = pListEntry->Flink;

        pSipMsgProc->Shutdown();        
    }
}


// IUnknown

// We live in a single threaded world.
STDMETHODIMP_(ULONG)
SIP_STACK::AddRef()
{
    m_RefCount++;
    LOG((RTC_TRACE, "SIP_STACK::AddRef(this: %x) - %d",
         this, m_RefCount));
    return m_RefCount;
}


STDMETHODIMP_(ULONG)
SIP_STACK::Release()
{
    m_RefCount--;

    LOG((RTC_TRACE, "SIP_STACK::Release(this: %x) - %d",
         this, m_RefCount));
    
    if (m_RefCount != 0)
    {
        return m_RefCount;
    }
    else
    {
        delete this;
        return 0;
    }
}


STDMETHODIMP
SIP_STACK::QueryInterface(REFIID riid, LPVOID *ppv)
{
    //Both ISipStack and IIMManager derive from IUnknown
    if (riid == IID_IUnknown)
    {
       *ppv = static_cast<IUnknown *>((ISipStack*)this);
    }
    else if (riid == IID_ISipStack)
    {
        *ppv = static_cast<ISipStack *>(this);
    }
    else if (riid == IID_ISIPBuddyManager)
    {
        *ppv = static_cast<ISIPBuddyManager *>(this);
    }
    else if (riid == IID_ISIPWatcherManager)
    {
        *ppv = static_cast<ISIPWatcherManager *>(this);
    }
    else if (riid == IID_IIMManager)
    {
        *ppv = static_cast<IIMManager *>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    static_cast<IUnknown *>(*ppv)->AddRef();
    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
// IP Address change notifications
///////////////////////////////////////////////////////////////////////////////


VOID NTAPI
OnIPAddrChange(PVOID pvContext, BOOLEAN fFlag)
{
    UNREFERENCED_PARAMETER(fFlag);
    UNREFERENCED_PARAMETER(pvContext);
    HRESULT hr;
    ENTER_FUNCTION("OnIPAddrChange");
    LOG((RTC_TRACE, "%s - Enter ", __fxName)); 

    //Go through the list of sipstacks and post message
    SipStackList_PostIPAddrChangeMessageAndNotify();
    LOG((RTC_TRACE, "%s - Exit", __fxName)); 
}


VOID
SIP_STACK::OnIPAddrChange()
{
    DWORD       Status;
    HRESULT     hr;

    ENTER_FUNCTION("SIP_STACK::OnIPAddrChange");
    LOG((RTC_TRACE, "%s - Enter ", __fxName)); 
    if(IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "%s - SipStack is already shutdown", __fxName));
        return;
    }
    
    hr = GetLocalIPAddresses();
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s  GetLocalIPAddresses failed %x",
             __fxName, hr));
    }

    hr = UpdateListenSocketList();
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s UpdateListenSocketList failed %x",
             __fxName, hr));
    }

    // Unregister with all the proxies that are registered.
    StartAllProviderUnregistration();

    LIST_ENTRY          *pListEntry;
    LIST_ENTRY          *pNextListEntry;
    SIP_MSG_PROCESSOR   *pSipMsgProc;

    //
    // This list could get modified while we are still going through the list.
    //

    pListEntry = m_MsgProcList.Flink;
    while (pListEntry != &m_MsgProcList)
    {
        pNextListEntry = pListEntry->Flink;

        pSipMsgProc = CONTAINING_RECORD( pListEntry, SIP_MSG_PROCESSOR, m_ListEntry );
        
        pListEntry = pNextListEntry;

        pSipMsgProc -> OnIpAddressChange();
    }

    // Register with all the proxies that should be registered.
    StartAllProviderRegistration();

    LOG((RTC_TRACE, "%s - Exit ", __fxName)); 
}


VOID
SIP_STACK::OnDeregister(
    SIP_PROVIDER_ID    *pProviderID,
    BOOL                fPAUnsub
    )
{
    DWORD       Status;
    HRESULT     hr;
    ULONG       ProviderIndex;

    ENTER_FUNCTION("SIP_STACK::OnDeregister");
    LOG((RTC_TRACE, "%s - Enter ", __fxName)); 

    if(IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "%s - SipStack is already shutdown", __fxName));
        return;
    }

    LIST_ENTRY          *pListEntry;
    LIST_ENTRY          *pNextListEntry;
    SIP_MSG_PROCESSOR   *pSipMsgProc;

    //
    // This list could get modified while we are still going through the list.
    //

    pListEntry = m_MsgProcList.Flink;
    while (pListEntry != &m_MsgProcList)
    {
        pNextListEntry = pListEntry->Flink;

        pSipMsgProc = CONTAINING_RECORD( pListEntry, SIP_MSG_PROCESSOR, m_ListEntry );
        
        pListEntry = pNextListEntry;

        pSipMsgProc -> OnDeregister( pProviderID );
    }

    if( (fPAUnsub==FALSE) && IsProviderIdPresent(pProviderID, &ProviderIndex) )
    {
        //release the reference on REGISTER_CONTEXT
        ((REGISTER_CONTEXT*)(m_ProviderProfileArray[ProviderIndex].pRegisterContext))
            -> MsgProcRelease();

        m_ProviderProfileArray[ProviderIndex].pRegisterContext = NULL;
        m_ProviderProfileArray[ProviderIndex].lRegisterAccept = 0;
    }

    LOG((RTC_TRACE, "%s - Exit ", __fxName)); 
}


HRESULT
RegisterIPAddrChangeNotifications()
{
    DWORD Status;

    ENTER_FUNCTION("SIP_STACK::RegisterIPAddrChangeNotifications");
    LOG((RTC_TRACE, "%s - Enter", __fxName));
    g_hEventAddrChange = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (g_hEventAddrChange == NULL)
    {
        Status = GetLastError();
        LOG((RTC_ERROR, "%s CreateEvent failed %x", __fxName, Status));
        return HRESULT_FROM_WIN32(Status);
    }

    if (!RegisterWaitForSingleObject(&g_hAddrChangeWait, g_hEventAddrChange,
                                     ::OnIPAddrChange, NULL,
                                     INFINITE, 0))
    {
        Status = GetLastError();
        LOG((RTC_ERROR, "%s RegisterWaitForSingleObject failed %x",
             __fxName, Status));
        return HRESULT_FROM_WIN32(Status);
    }

    g_ovAddrChange.hEvent = g_hEventAddrChange;

    Status = NotifyAddrChange(&g_hAddrChange, &g_ovAddrChange);

    if (Status != ERROR_SUCCESS && Status != ERROR_IO_PENDING)
    {
        LOG((RTC_ERROR, "%s  NotifyAddrChange failed %x",
             __fxName, Status));
        return HRESULT_FROM_WIN32(Status);
    }

    LOG((RTC_TRACE, "%s - returning S_OK", __fxName));
    return S_OK;
}


VOID 
UnregisterIPAddrChangeNotifications()
{
    ENTER_FUNCTION("UnregisterIPAddrChangeNotifications");
    LOG((RTC_TRACE, "%s - Enter", __fxName));

    // Make sure we don't get any more callbacks first.
    if (g_hAddrChangeWait)
    {
        UnregisterWait(g_hAddrChangeWait);
        g_hAddrChangeWait = NULL;
    }

    CancelIo(g_hAddrChange);
    ZeroMemory(&g_ovAddrChange, sizeof(OVERLAPPED));
    g_hAddrChange = NULL;
    
    if (g_hEventAddrChange)
    {
        CloseHandle(g_hEventAddrChange);
        g_hEventAddrChange = NULL;
    }
    LOG((RTC_TRACE, "%s - Done", __fxName));
}


///////////////////////////////////////////////////////////////////////////////
// DNS Stuff
///////////////////////////////////////////////////////////////////////////////



HRESULT
SIP_STACK::CreateDnsResolutionWorkItem(
    IN  PSTR                                    Host,
    IN  ULONG                                   HostLen,
    IN  USHORT                                  Port,
    IN  SIP_TRANSPORT                           Transport,
    IN  DNS_RESOLUTION_COMPLETION_INTERFACE    *pDnsCompletion,
    OUT DNS_RESOLUTION_WORKITEM               **ppDnsWorkItem 
    )
{
    ENTER_FUNCTION("SIP_STACK::CreateDnsResolutionWorkItem");

    HRESULT hr;
    DNS_RESOLUTION_WORKITEM *pDnsWorkItem;

    pDnsWorkItem = new DNS_RESOLUTION_WORKITEM(&m_WorkItemMgr);
    if (pDnsWorkItem == NULL)
    {
        LOG((RTC_ERROR, "%s - allocating dns resolution work item failed",
             __fxName));
        return E_OUTOFMEMORY;
    }

    hr = pDnsWorkItem->SetHostPortTransportAndDnsCompletion(
             Host, HostLen, Port, Transport, pDnsCompletion);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - SetHostPortTransportAndDnsCompletion failed %x",
             __fxName, hr));
        delete pDnsWorkItem;
        return hr;
    }

    hr = pDnsWorkItem->StartWorkItem();
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s StartWorkItem failed %x",
             __fxName, hr));
        delete pDnsWorkItem;
        return hr;
    }

    LOG((RTC_TRACE, "%s - created work item for %.*s",
         __fxName, HostLen, Host));

    *ppDnsWorkItem = pDnsWorkItem;
    return S_OK;
}


HRESULT
SIP_STACK::AsyncResolveHost(
    IN  PSTR                                    Host,
    IN  ULONG                                   HostLen,
    IN  USHORT                                  Port,
    IN  DNS_RESOLUTION_COMPLETION_INTERFACE    *pDnsCompletion,
    OUT SOCKADDR_IN                            *pDstAddr,
    IN  SIP_TRANSPORT                          *pTransport,
    OUT DNS_RESOLUTION_WORKITEM               **ppDnsWorkItem 
    )
{
    HRESULT hr;
    
    ENTER_FUNCTION("SIP_STACK::AsyncResolveHost");
    
    ASSERT(pDstAddr != NULL);
    ASSERT(pTransport != NULL);

    // All APIs require a NULL terminated string.
    // So copy the string.

    PSTR szHost = (PSTR) malloc(HostLen + 1);
    if (szHost == NULL)
    {
        LOG((RTC_ERROR, "%s allocating szHost failed", __fxName));
        return E_OUTOFMEMORY;
    }

    strncpy(szHost, Host, HostLen);
    szHost[HostLen] = '\0';

    ULONG IPAddr = inet_addr(szHost);

    free(szHost);
    
    if (IPAddr != INADDR_NONE)
    {
        // Host is an IP address
        pDstAddr->sin_family = AF_INET;
        pDstAddr->sin_addr.s_addr = IPAddr;
        pDstAddr->sin_port =
            (Port == 0) ? htons(GetSipDefaultPort(*pTransport)) : htons(Port);
        return S_OK;
    }

    // We have a host name - we need to resolve it asynchronously.

    // Try host name resolution.
    hr = CreateDnsResolutionWorkItem(Host, HostLen, Port,
                                     *pTransport,
                                     pDnsCompletion,
                                     ppDnsWorkItem);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s CreateDnsResolutionWorkItem failed %x",
             __fxName, hr));
        return hr;
    }

    return HRESULT_FROM_WIN32(WSAEWOULDBLOCK);
}


HRESULT
SIP_STACK::AsyncResolveSipUrl(
    IN  SIP_URL                                *pSipUrl, 
    IN  DNS_RESOLUTION_COMPLETION_INTERFACE    *pDnsCompletion,
    OUT SOCKADDR_IN                            *pDstAddr,
    IN  OUT SIP_TRANSPORT                      *pTransport,
    OUT DNS_RESOLUTION_WORKITEM               **ppDnsWorkItem,
    IN  BOOL                                    fUseTransportFromSipUrl
    )
{
    HRESULT hr;
    
    ENTER_FUNCTION("SIP_STACK::AsyncResolveSipUrl");
    LOG((RTC_TRACE,"%s entered - transport %d",__fxName, pSipUrl->m_TransportParam));
    // If m_addr is present we need to resolve that.
    // Otherwise we resolve the host.
    ASSERT(pTransport);
    if (pSipUrl->m_KnownParams[SIP_URL_PARAM_MADDR].Length != 0)
    {
        hr = AsyncResolveHost(pSipUrl->m_KnownParams[SIP_URL_PARAM_MADDR].Buffer,
                              pSipUrl->m_KnownParams[SIP_URL_PARAM_MADDR].Length,
                              (USHORT) pSipUrl->m_Port,
                              pDnsCompletion,
                              pDstAddr, 
                              fUseTransportFromSipUrl ?
                                &(pSipUrl->m_TransportParam):
                                pTransport,
                              ppDnsWorkItem);
        if (hr != S_OK && hr != HRESULT_FROM_WIN32(WSAEWOULDBLOCK))
        {
            LOG((RTC_ERROR, "%s AsyncResolveHost(maddr) failed %x",
                 __fxName, hr));
            return hr;
        }
    }
    else
    {
        hr = AsyncResolveHost(pSipUrl->m_Host.Buffer,
                              pSipUrl->m_Host.Length,
                              (USHORT) pSipUrl->m_Port,
                              pDnsCompletion,
                              pDstAddr, 
                              fUseTransportFromSipUrl ?
                                &(pSipUrl->m_TransportParam):
                                pTransport,
                              ppDnsWorkItem);
        if (hr != S_OK && hr != HRESULT_FROM_WIN32(WSAEWOULDBLOCK))
        {
            LOG((RTC_ERROR, "%s AsyncResolveHost(Host) failed %x",
                 __fxName, hr)); 
            return hr;
        }
    }
    if(fUseTransportFromSipUrl)
        *pTransport = pSipUrl->m_TransportParam;

    return hr;    
}


HRESULT
SIP_STACK::AsyncResolveSipUrl(
    IN  PSTR                                    DstUrl,
    IN  ULONG                                   DstUrlLen,
    IN  DNS_RESOLUTION_COMPLETION_INTERFACE    *pDnsCompletion, 
    OUT SOCKADDR_IN                            *pDstAddr,
    IN  OUT SIP_TRANSPORT                      *pTransport,
    OUT DNS_RESOLUTION_WORKITEM               **ppDnsWorkItem, 
    IN  BOOL                                    fUseTransportFromSipUrl
    )
{
    SIP_URL DecodedSipUrl;
    HRESULT hr;
    ULONG   BytesParsed = 0;
    
    ENTER_FUNCTION("SIP_STACK::AsyncResolveSipUrl");

    hr = ParseSipUrl(DstUrl, DstUrlLen, &BytesParsed,
                     &DecodedSipUrl);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s ParseSipUrl failed %x",
             __fxName, hr));
        return hr;
    }

    hr = AsyncResolveSipUrl(&DecodedSipUrl, pDnsCompletion,
                            pDstAddr, pTransport,
                            ppDnsWorkItem,
                            fUseTransportFromSipUrl);
    if (hr != S_OK && hr != HRESULT_FROM_WIN32(WSAEWOULDBLOCK))
    {
        LOG((RTC_ERROR, "%s AsyncResolveSipUrl(SIP_URL *) failed %x",
             __fxName, hr));
        return hr;
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
// Local IP Address table
///////////////////////////////////////////////////////////////////////////////

// Maintain a list of local IP addresses.
// Refresh the list whenever we get a notification about changes in the
// local IP addresses.


BOOL
SIP_STACK::IsIPAddrLocal(
    IN  SOCKADDR_IN    *pDestAddr,
    IN  SIP_TRANSPORT   Transport
    )
{
#if 0  // 0 ******* Region Commented Out Begins *******
    // Check whether this is the loopback address
    if (IS_LOOPBACK_ADDRESS(ntohl(pDestAddr->sin_addr.s_addr)) ||
        pDestAddr->sin_addr.s_addr == htonl(INADDR_ANY))
    {
        return TRUE;
    }
#endif // 0 ******* Region Commented Out Ends   *******
    
//      DWORD i = 0;
//      for (i = 0; i < m_pMibIPAddrTable->dwNumEntries; i++)
//      {
//          if (pDestAddr->sin_addr.s_addr == m_pMibIPAddrTable->table[i].dwAddr)
//          {
//              return TRUE;
//          }
//      }

    // Check whether we are listening on this address.
    LIST_ENTRY          *pListEntry;
    SIP_LISTEN_SOCKET   *pListenSocket;

    pListEntry = m_ListenSocketList.Flink;

    while (pListEntry != &m_ListenSocketList)
    {
        pListenSocket = CONTAINING_RECORD(pListEntry,
                                          SIP_LISTEN_SOCKET,
                                          m_ListEntry);
        if (Transport == SIP_TRANSPORT_UDP)
        {
            if ((pListenSocket->m_pDynamicPortUdpSocket != NULL &&
                 AreSockaddrEqual(&pListenSocket->m_pDynamicPortUdpSocket->m_LocalAddr,
                                 pDestAddr)) ||
                (pListenSocket->m_pStaticPortUdpSocket != NULL &&
                 AreSockaddrEqual(&pListenSocket->m_pStaticPortUdpSocket->m_LocalAddr,
                                 pDestAddr)) ||
                AreSockaddrEqual(&pListenSocket->m_PublicUdpListenAddr, pDestAddr))
            {
                return TRUE;
            }
        }
        else    // TCP and SSL
        {
            if ((pListenSocket->m_pDynamicPortTcpSocket != NULL &&
                 AreSockaddrEqual(&pListenSocket->m_pDynamicPortTcpSocket->m_LocalAddr,
                                 pDestAddr)) ||
                (pListenSocket->m_pStaticPortTcpSocket != NULL &&
                 AreSockaddrEqual(&pListenSocket->m_pStaticPortTcpSocket->m_LocalAddr,
                                 pDestAddr)) ||
                AreSockaddrEqual(&pListenSocket->m_PublicTcpListenAddr, pDestAddr))
            {
                return TRUE;
            }
        }

        pListEntry = pListEntry->Flink;
    }

    return FALSE;
}


BOOL
SIP_STACK::IsLocalIPAddrPresent(
    IN DWORD LocalIPSav
    )
{
    DWORD i = 0;
    
    for (i = 0; i < m_pMibIPAddrTable->dwNumEntries; i++)
    {
        if (LocalIPSav == m_pMibIPAddrTable->table[i].dwAddr)
        {
            LOG((RTC_TRACE, "SIP_STACK::IsLocalIPAddrPresent - IPAdress Present"));
            return TRUE;
        }
    }
    return FALSE;
}

HRESULT
SIP_STACK::CheckIPAddr(
    IN  SOCKADDR_IN    *pDestAddr,
    IN  SIP_TRANSPORT   Transport
    )
{
    ENTER_FUNCTION("SIP_STACK::CheckIPAddr");
    
    if (IS_MULTICAST_ADDRESS(ntohl(pDestAddr->sin_addr.s_addr)))
    {
        LOG((RTC_ERROR,
             "%s - The destination address %d.%d.%d.%d is multicast",
             __fxName, NETORDER_BYTES0123(pDestAddr->sin_addr.s_addr)));
        return RTC_E_DESTINATION_ADDRESS_MULTICAST;
    }
    else if (IsIPAddrLocal(pDestAddr, Transport))
    {
        LOG((RTC_ERROR,
             "%s - The destination address %d.%d.%d.%d is local",
             __fxName, NETORDER_BYTES0123(pDestAddr->sin_addr.s_addr)));
        return RTC_E_DESTINATION_ADDRESS_LOCAL;
    }
    else
    {
        return S_OK;
    }   
}


HRESULT
SIP_STACK::GetLocalIPAddresses()
{
    DWORD   Status;

    ENTER_FUNCTION("SIP_STACK::GetLocalIPAddresses");

    // Note that the loop is to take care of the case where
    // the IP address table changes betweeen two calls to
    // GetIpAddrTable().

    while (1)
    {
        Status = ::GetIpAddrTable(m_pMibIPAddrTable, &m_MibIPAddrTableSize, TRUE);
        if (Status == ERROR_SUCCESS)
        {
            LOG((RTC_TRACE, "%s GetIpAddrTable succeeded", __fxName));
            DebugPrintLocalIPAddressTable();
            return S_OK;
        }
        else if (Status == ERROR_INSUFFICIENT_BUFFER)
        {
            LOG((RTC_WARN,
                 "%s GetIpAddrTable - buf size not sufficient will allocate size : %d",
                 __fxName, m_MibIPAddrTableSize));
            
            if (m_pMibIPAddrTable != NULL)
            {
                free(m_pMibIPAddrTable);
                m_pMibIPAddrTable = NULL;
            }

            m_pMibIPAddrTable = (MIB_IPADDRTABLE *) malloc(m_MibIPAddrTableSize);

            if (m_pMibIPAddrTable == NULL)
            {
                LOG((RTC_ERROR, "%s allocating g_pMibIPAddrTable failed",
                     __fxName));
                return E_OUTOFMEMORY;
            }
        }
        else
        {
            // cannot get the list of addresses
            LOG((RTC_ERROR, "%s GetIpAddrTable failed %x",
                 __fxName, Status));
            FreeLocalIPaddrTable();
            return HRESULT_FROM_WIN32(Status);
        }
    }
    
    return S_OK;
}


VOID
SIP_STACK::DebugPrintLocalIPAddressTable()
{
    DWORD           i = 0;
    
    LOG((RTC_TRACE, "Printing Local IP address table - Num Addresses : %d",
         m_pMibIPAddrTable->dwNumEntries));
    
    for (i = 0; i < m_pMibIPAddrTable->dwNumEntries; i++)
    {
        LOG((RTC_TRACE, "\t IPaddr %d : %d.%d.%d.%d Index: %d", i,
             NETORDER_BYTES0123(m_pMibIPAddrTable->table[i].dwAddr),
             m_pMibIPAddrTable->table[i].dwIndex));
    }
}


VOID
SIP_STACK::FreeLocalIPaddrTable()
{
    if (m_pMibIPAddrTable != NULL)
    {
        free(m_pMibIPAddrTable);
        m_pMibIPAddrTable = NULL;
    }
    
    m_MibIPAddrTableSize = 0;
}


///////////////////////////////////////////////////////////////////////////////
// IMMANAGER interfaces in sipstack
///////////////////////////////////////////////////////////////////////////////

//Called from SIP_STACK::ProcessMessage() when a new incoming session arrives
//TODO if the call does not succeed, we need to send error message back.
HRESULT
SIP_STACK::CreateIncomingMessageSession(
    IN  SIP_TRANSPORT   Transport,
    IN  SIP_MESSAGE    *pSipMsg,
    IN  ASYNC_SOCKET   *pResponseSocket
    )
{
    HRESULT       hr;
    IMSESSION *pImSession;
    PSTR        Header;
    ULONG       HeaderLen;
    OFFSET_STRING   DisplayName;
    OFFSET_STRING   AddrSpec;
    ULONG           BytesParsed = 0;
    BSTR            bstrCallerURI;
    LPWSTR          wsCallerURI;
    BOOL            isAuthorized;

    LOG((RTC_TRACE, "SIP_STACK::CreateIncomingMessageSession()"));
    ENTER_FUNCTION("SIP_STACK::CreateIncomingMessageSession");
    
    //
    // Drop the session if the To tag in not empty
    //
    
    hr = DropIncomingSessionIfNonEmptyToTag(Transport,
                                            pSipMsg,
                                            pResponseSocket );

    if( hr != S_OK )
    {
        // session has been dropped.

        return hr;
    }
    
    hr = pSipMsg->GetSingleHeader(SIP_HEADER_FROM, &Header, &HeaderLen);
    if (hr != S_OK)
    {
        LOG((RTC_WARN, "SIP_STACK::Get From Header failed %x", hr));
        return hr;
    }
    
    //Check for authorization
    hr = ParseNameAddrOrAddrSpec(Header, HeaderLen, &BytesParsed,
                                        '\0', // no header list separator
                                        &DisplayName, &AddrSpec);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s -ParseNameAddrOrAddrSpec failed %x",
                __fxName, hr));
        return hr;
    }
    
    hr = UTF8ToUnicode(AddrSpec.GetString(Header),
                       AddrSpec.GetLength(),
                       &wsCallerURI);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s -UTF8ToUnicode failed %x",
        __fxName,
         hr));
        return hr;
    }

    bstrCallerURI = SysAllocString(wsCallerURI);
    free(wsCallerURI);
    if (bstrCallerURI == NULL)
    {
        LOG((RTC_WARN, "%s -bstrmsg allocation failed %x",
        __fxName, hr));
        return E_OUTOFMEMORY;
    }
    isAuthorized = TRUE;
    hr = m_pNotifyInterface->IsIMSessionAuthorized(
                            bstrCallerURI, 
                            &isAuthorized);
    SysFreeString(bstrCallerURI);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - IsIMSessionAuthorized failed %x", 
            __fxName, hr));
        return hr;
    }
    if(!isAuthorized)
    {
        LOG((RTC_ERROR, "%s - Not Authorized", 
            __fxName));
    //Send 480
        hr = CreateIncomingReqfailCall(Transport,
                                           pSipMsg, pResponseSocket, 480);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s - CreateIncomingReqfailCall failed 0x%x", 
            __fxName, hr));
        }
        return E_FAIL;
    }

    pImSession = new IMSESSION(
        NULL , //*pProviderId
        this,
        NULL,  //*pRedirectContext
        Header,
        HeaderLen
        );
    if (pImSession == NULL)
    {
        LOG((RTC_WARN, "SIP_STACK::CreateIncomingMessageSession() Failed. Out of memory"));
        return E_OUTOFMEMORY;
    }
    pImSession->SetIsFirstMessage(FALSE);
    pImSession->SetTransport(Transport);
    
    hr = pImSession->SetCreateIncomingMessageParams(
        pSipMsg, 
        pResponseSocket,
        Transport
        );
    if (hr != S_OK)
    {
        LOG((RTC_WARN, "SIP_STACK::SetCreateIncomingMessageParams failed %x", hr));
        return hr;
    }
    
    hr = pImSession->CreateIncomingMessageTransaction(pSipMsg, pResponseSocket);
    if (hr != S_OK)
    {
        LOG((RTC_WARN, "SIP_STACK::CreateIncomingMessageTransaction failed. %x", hr));  
        return hr;
    }
    
    IIMSession * pIImSession;
    hr = pImSession->QueryInterface(IID_IIMSession, (void **)&pIImSession);
    if ( FAILED (hr) )
    {
        LOG((RTC_ERROR, "QI for IIMSESSION failed"));
        return hr;
    }

    hr = NotifyIncomingSessionToCore(pIImSession, pSipMsg, Header, HeaderLen);
    if ( FAILED (hr) )
    {
        LOG((RTC_ERROR, "NotifyIncomingSessionToCore failed"));
    }
    pIImSession->Release();
    
    // We create the call with a ref count of 1
    // At this point the core should have addref'ed the call
    // and we can release our reference.
    pImSession->Release();
    return hr;
}

HRESULT
SIP_STACK::NotifyIncomingSessionToCore(
                         IN  IIMSession      *pIImSession,
                         IN  SIP_MESSAGE    *pSipMsg,
                         IN  PSTR           RemoteURI,
                         IN  ULONG          RemoteURILen
                         )
{
    SIP_PARTY_INFO  CallerInfo;
    OFFSET_STRING   DisplayName;
    OFFSET_STRING   AddrSpec;
    OFFSET_STRING   Params;
    ULONG           BytesParsed = 0;
    HRESULT         hr;
    
    CallerInfo.PartyContactInfo = NULL;

    ENTER_FUNCTION("SIPSTACK::NotifyIncomingSessionToCore");
    hr = ParseNameAddrOrAddrSpec(RemoteURI, RemoteURILen, &BytesParsed,
                                        '\0', // no header list separator
                                        &DisplayName, &AddrSpec);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s -ParseNameAddrOrAddrSpec failed %x",
                __fxName, hr));
        return hr;
    }

    LOG((RTC_TRACE, "Incoming Call from Display Name: %.*s  URI: %.*s",
         DisplayName.GetLength(),
         DisplayName.GetString(RemoteURI),
         AddrSpec.GetLength(),
         AddrSpec.GetString(RemoteURI)
         )); 

    //Get CallerInfo
    CallerInfo.DisplayName = NULL;
    CallerInfo.URI         = NULL;

    if (DisplayName.GetLength() != 0)
    {
        //Remove Quotes before passing to core
        if((DisplayName.GetString(RemoteURI))[0] == '\"')
        {
                hr = UTF8ToUnicode(DisplayName.GetString(RemoteURI+1),
                           DisplayName.GetLength()-2,
                           &CallerInfo.DisplayName
                           );
        }
        else
        {
            hr = UTF8ToUnicode(DisplayName.GetString(RemoteURI),
                           DisplayName.GetLength(),
                           &CallerInfo.DisplayName
                           );
        }
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s -UTF8ToUnicode failed %x",
                __fxName, hr));
            return hr;
        }
    }
        
    if (AddrSpec.GetLength() != 0)
    {
        hr = UTF8ToUnicode(AddrSpec.GetString(RemoteURI),
                           AddrSpec.GetLength(),
                           &CallerInfo.URI
                           );
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s -UTF8ToUnicode failed %x",
                __fxName, hr));
            free(CallerInfo.DisplayName);
            return hr;
        }
    }
        
    CallerInfo.State = SIP_PARTY_STATE_CONNECTING;
    
    //Extract Message Contents

    PSTR    ContentTypeHdrValue;
    ULONG   ContentTypeHdrValueLen;
    BSTR bstrmsg = NULL;
    BSTR bstrContentType = NULL;
    if (pSipMsg->MsgBody.Length != 0)
    {
        // We have Message Body. Check type.

        hr = pSipMsg->GetSingleHeader(SIP_HEADER_CONTENT_TYPE,
                             &ContentTypeHdrValue,
                             &ContentTypeHdrValueLen);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s - Couldn't find Content-Type header %x",
                __fxName, hr));
            free(CallerInfo.DisplayName);
            free(CallerInfo.URI);
            return E_FAIL;
        }
        LPWSTR wsContentType;
        hr = UTF8ToUnicode(ContentTypeHdrValue,
                           ContentTypeHdrValueLen,
                           &wsContentType);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s -UTF8ToUnicode failed %x",
            __fxName, hr));
            return hr;
        }

        bstrContentType = SysAllocString(wsContentType);
        free(wsContentType);
        if (bstrContentType == NULL)
        {
            LOG((RTC_WARN, "%s -bstrContentType allocation failed %x",
            __fxName, hr));
            return E_OUTOFMEMORY;
        }

        LPWSTR wsmsg;
        hr = UTF8ToUnicode(pSipMsg->MsgBody.GetString(pSipMsg->BaseBuffer),
                            pSipMsg->MsgBody.Length,
                           &wsmsg);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s -UTF8ToUnicode failed %x",
            __fxName, hr));
            return hr;
        }

        bstrmsg = SysAllocString(wsmsg);
        free(wsmsg);
        if (bstrmsg == NULL)
        {
            LOG((RTC_WARN, "%s -bstrmsg allocation failed %x",
            __fxName, hr));
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        //If the msg body is null, this should be a control message, 
        //like the one sent for Ip address change
        free(CallerInfo.DisplayName);
        free(CallerInfo.URI);
        return S_OK;
    }

    m_pNotifyInterface->NotifyIncomingSession(
        pIImSession,
        bstrmsg,
        bstrContentType,
        &CallerInfo);

    free(CallerInfo.DisplayName);
    free(CallerInfo.URI);
    if(bstrmsg)
        SysFreeString(bstrmsg);
    if(bstrContentType)
        SysFreeString(bstrContentType);
    return S_OK;
}


//This function is used for new outgoing IM sessions..
HRESULT
SIP_STACK::CreateSession(
    IN   BSTR                   bstrLocalDisplayName,
    IN   BSTR                   bstrLocalUserURI,
    IN   SIP_PROVIDER_ID       *pProviderId,
    IN   SIP_SERVER_INFO       *pProxyInfo,
    IN   ISipRedirectContext   *pRedirectContext,
    OUT  IIMSession           **pIImSession
    )
{
    HRESULT hr = S_OK;
    IMSESSION * pImSession;
    SIP_USER_CREDENTIALS *pUserCredentials = NULL;
    LPOLESTR              Realm = NULL;
    
    ENTER_FUNCTION("SIP_STACK::CreateSession");
    if(IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "%s - SipStack is already shutdown", __fxName));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    if (pProviderId != NULL &&
            !IsEqualGUID(*pProviderId, GUID_NULL))
    {
        hr = GetProfileUserCredentials(pProviderId, &pUserCredentials, &Realm);
        if (hr != S_OK)
        {
            LOG((RTC_WARN, "GetProfileUserCredentials failed %x",
                 hr));
            pUserCredentials = NULL;
        }
    }
    
    pImSession = new IMSESSION(
        pProviderId , //*pProviderId
        this,
        (REDIRECT_CONTEXT *)pRedirectContext 
        );
    if (pImSession == NULL)
    {
        LOG((RTC_WARN, "SIP_STACK::CreateSession failed %x",
             hr));
        return E_OUTOFMEMORY;
    }
    if (pProxyInfo != NULL)
    {
        hr = pImSession->SetProxyInfo(pProxyInfo);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s - SetProxyInfo failed %x",
                 __fxName, hr));
            return hr;
        }
    }

    if (pUserCredentials != NULL)
    {
        hr = pImSession->SetCredentials(pUserCredentials,
                                        Realm);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "IMSESSION::SetCredentials failed calling"
                 "from SIPSTACK::CreateCall %x", hr));
                return hr;
        }
    }
    hr = pImSession->SetLocalURI(bstrLocalDisplayName, bstrLocalUserURI);
    if (hr != S_OK)
    {
        LOG((RTC_WARN, "SIP_STACK::SetLocalURI failed %x",
           hr));
        return hr;
    }
            
    //QI for IIMSession ptr
    hr = pImSession->QueryInterface(IID_IIMSession, (void **)pIImSession);
    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "QI for IIMSESSION failed"));
        return hr;
    }
    pImSession->Release();
    return hr;
}

HRESULT 
SIP_STACK::DeleteSession(
        IN IIMSession * pSession
                    )
{
    HRESULT hr;

    ENTER_FUNCTION("SIPSTACK::DeleteSession");
    if(IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "%s - SipStack is already shutdown", __fxName));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    SIP_CALL_STATE IMState;
    pSession->GetIMSessionState(&IMState);
    
    LOG((RTC_TRACE, "%s : state %d",
         __fxName, IMState));
    if (IMState == SIP_CALL_STATE_DISCONNECTED ||
        IMState == SIP_CALL_STATE_ERROR)
    {
        // do nothing
        LOG((RTC_TRACE, "%s call in state %d Doing nothing",
             __fxName, IMState));
        return S_OK;
    }
    else if( IMState == SIP_CALL_STATE_IDLE ||
              IMState == SIP_CALL_STATE_OFFERING )
    {
        return S_OK;
    }
    // Create a BYE transaction and send notification to core
    hr = pSession->Cleanup();
    return S_OK;
}


VOID
SIP_STACK::NotifyRegistrarStatusChange( 
    SIP_PROVIDER_STATUS *ProviderStatus 
    )
{
    ENTER_FUNCTION("SIP_STACK::NotifyRegistrarStatusChange");
    
    if (m_pNotifyInterface != NULL)
    {
        m_pNotifyInterface -> NotifyProviderStatusChange(ProviderStatus);
    }
    else
    {
        LOG((RTC_WARN, "%s - m_pNotifyInterface is NULL",
             __fxName));
    }
}




///////////////////////////////////////////////////////////////////////////////
// SIP_LISTEN_SOCKET class
///////////////////////////////////////////////////////////////////////////////


SIP_LISTEN_SOCKET::SIP_LISTEN_SOCKET(
    IN DWORD         IpAddr,
    IN ASYNC_SOCKET *pDynamicPortUdpSocket,
    IN ASYNC_SOCKET *pDynamicPortTcpSocket,
    IN ASYNC_SOCKET *pStaticPortUdpSocket,
    IN ASYNC_SOCKET *pStaticPortTcpSocket,
    IN LIST_ENTRY   *pListenSocketList
    )
{
    ASSERT(pDynamicPortUdpSocket);
    ASSERT(pDynamicPortTcpSocket);
    ASSERT(pListenSocketList);

    m_IpAddr = IpAddr;
    
    m_pDynamicPortUdpSocket = pDynamicPortUdpSocket;
    if (m_pDynamicPortUdpSocket != NULL)
    {
        m_pDynamicPortUdpSocket->AddRef();
    }
    
    m_pDynamicPortTcpSocket = pDynamicPortTcpSocket;
    if (m_pDynamicPortTcpSocket != NULL)
    {
        m_pDynamicPortTcpSocket->AddRef();
    }
    
    m_pStaticPortUdpSocket  = pStaticPortUdpSocket;
    if (m_pStaticPortUdpSocket != NULL)
    {
        m_pStaticPortUdpSocket->AddRef();
    }
    
    m_pStaticPortTcpSocket  = pStaticPortTcpSocket;
    if (m_pStaticPortTcpSocket != NULL)
    {
        m_pStaticPortTcpSocket->AddRef();
    }
    
    ZeroMemory(&m_PublicUdpListenAddr, sizeof(SOCKADDR_IN));
    ZeroMemory(&m_PublicTcpListenAddr, sizeof(SOCKADDR_IN));

    ZeroMemory(&m_LocalFirewallUdpListenAddr, sizeof(SOCKADDR_IN));
    ZeroMemory(&m_LocalFirewallTcpListenAddr, sizeof(SOCKADDR_IN));

    m_NatUdpPortHandle = NULL;
    m_NatTcpPortHandle = NULL;

    m_fIsFirewallEnabled = FALSE;
    m_fIsUpnpNatPresent = FALSE;
    m_fIsGatewayLocal   = FALSE;
    
    // This should be initialized to TRUE. Otherwise new
    // sockets created in UpdateListenSocketList will be deleted.
    m_IsPresentInNewIpAddrTable = TRUE;

    // This should be initialized to FALSE. Otherwise new
    // sockets created in UpdateListenSocketList will be updated
    // one more time.
    m_NeedToUpdatePublicListenAddr = FALSE;
    
    InsertTailList(pListenSocketList, &m_ListEntry);
}


SIP_LISTEN_SOCKET::~SIP_LISTEN_SOCKET()
{
    if (m_pDynamicPortUdpSocket != NULL)
    {
        m_pDynamicPortUdpSocket->Release();
    }

    if (m_pDynamicPortTcpSocket != NULL)
    {
        m_pDynamicPortTcpSocket->Release();
    }

    if (m_pStaticPortUdpSocket != NULL)
    {
        m_pStaticPortUdpSocket->Release();
    }

    if (m_pStaticPortTcpSocket != NULL)
    {
        m_pStaticPortTcpSocket->Release();
    }

    // m_NatPortHandle should be used
    // to deregister the ports separately.
    
    RemoveEntryList(&m_ListEntry);

    LOG((RTC_TRACE, "~SIP_LISTEN_SOCKET(%x) done", this));
}


VOID
SIP_LISTEN_SOCKET::DeregisterPorts(
    IN IDirectPlayNATHelp *pDirectPlayNatHelp
    )
{
    HRESULT hr;

    ENTER_FUNCTION("SIP_LISTEN_SOCKET::DeregisterPorts");

    if (pDirectPlayNatHelp == NULL)
    {
        LOG((RTC_ERROR, "%s - pDirectPlayNatHelp is NULL",
             __fxName));
        return;
    }
    
    if (m_NatUdpPortHandle != NULL)
    {
        ASSERT(pDirectPlayNatHelp);
        hr = pDirectPlayNatHelp->DeregisterPorts(
                 m_NatUdpPortHandle, 0);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s DeregisterPorts(%x) for UDP failed %x",
                 __fxName, m_NatUdpPortHandle, hr));
        }
        m_NatUdpPortHandle = NULL;
    }
    
    if (m_NatTcpPortHandle != NULL)
    {
        hr = pDirectPlayNatHelp->DeregisterPorts(
                 m_NatTcpPortHandle, 0);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s DeregisterPorts(%x) for TCP failed %x",
                 __fxName, m_NatTcpPortHandle, hr));
        }
        m_NatTcpPortHandle = NULL;
    }
}


///////////////////////////////////////////////////////////////////////////////
// NAT port mapping code
///////////////////////////////////////////////////////////////////////////////

// XXX TODO
// - Need to be able to disable and enable natmgr dynamically.
// - (use a registry key ?)
// - Should we expose an API for enabling/disabling NAT support ?


// Exported function for Media manager.
// LocalIp is in network order.
STDMETHODIMP
SIP_STACK::IsFirewallEnabled(
    IN  DWORD       LocalIp,
    OUT BOOL       *pfIsFirewallEnabled 
    )
{
    ENTER_FUNCTION("SIP_STACK::IsFirewallEnabled");
    
    if(IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "%s - SipStack is already shutdown", __fxName));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    // Go through the list of interfaces and check if the
    // firewall is enabled for this interface.

    SIP_LISTEN_SOCKET  *pListenSocket;
    pListenSocket = FindListenSocketForIpAddr(LocalIp);
    if (pListenSocket == NULL)
    {
        LOG((RTC_ERROR, "%s - failed to find listen socket for %d.%d.%d.%d",
             __fxName, NETORDER_BYTES0123(LocalIp)));
        return E_FAIL;
    }

    *pfIsFirewallEnabled = pListenSocket->m_fIsFirewallEnabled;
    return S_OK;
}


DWORD WINAPI
NatThreadProc(
    IN LPVOID   pVoid
    )
{
    ENTER_FUNCTION("NatThreadProc");
    
    SIP_STACK *pSipStack;

    pSipStack = (SIP_STACK *) pVoid;
    ASSERT(pSipStack != NULL);

    return pSipStack->NatThreadProc();
}


DWORD
SIP_STACK::NatThreadProc()
{
    ENTER_FUNCTION("SIP_STACK::NatThreadProc");
    
    HRESULT hr;
    BOOL    fContinue = TRUE;
    HANDLE  EventHandles[2];
    DWORD   HandleCount = 2;
    DWORD   WaitStatus;
    DWORD   Error;

    EventHandles[0] = m_NatShutdownEvent;
    EventHandles[1] = m_NatHelperNotificationEvent;
    
    // Keep calling GetCaps() periodically and wait for the
    // shutdown / nat notification events.

    LOG((RTC_TRACE, "%s - NAT thread doing wait loop", __fxName));
    
    while (fContinue)
    {
        WaitStatus = WaitForMultipleObjects(
                         HandleCount,
                         EventHandles,
                         FALSE,
                         m_NatHelperCaps.dwRecommendedGetCapsInterval
                         );

        if (WaitStatus == WAIT_FAILED)
        {
            Error = GetLastError();
            LOG((RTC_ERROR, "%s WaitForMultipleObjects failed %x",
                 __fxName, hr));
            fContinue = FALSE;
        }
        else if ((WaitStatus >= WAIT_ABANDONED_0) &&
                 (WaitStatus <= (WAIT_ABANDONED_0 + HandleCount - 1)))
        {
            // Wait was abandoned.
            LOG((RTC_ERROR,
                 "%s - WaitForMultipleObjects returned abandoned event : %d",
                 __fxName, WaitStatus));
            ASSERT(FALSE);
            fContinue = FALSE;
        }
        else if ((WaitStatus <= (WAIT_OBJECT_0 + HandleCount - 1)))
        {
            DWORD EventIndex = WaitStatus - WAIT_OBJECT_0;

            switch (EventIndex)
            {
            case 0:
                // shutdown
                fContinue = FALSE;
                break;

            case 1:
                // Need to do NatHelpGetCaps()
                hr = GetCapsAndUpdateNatMappingsIfNeeded();
                if (hr != S_OK)
                {
                    LOG((RTC_ERROR,
                         "%s GetCapsAndUpdateMappingsIfNeeded failed %x",
                         __fxName, hr));
                }
                
                break;

            default:
                ASSERT(FALSE);
                fContinue = FALSE;
                break;
            }
        }
        else if (WaitStatus == WAIT_TIMEOUT)
        {
            // Need to do GetCaps()
            hr = GetCapsAndUpdateNatMappingsIfNeeded();
            if (hr != S_OK)
            {
                LOG((RTC_ERROR,
                     "%s GetCapsAndUpdateNatMappingsIfNeeded failed %x",
                     __fxName, hr));
            }                
        }
    }
    
    LOG((RTC_TRACE, "%s - NAT thread exiting ", __fxName));
    
    return 0;
}


HRESULT
SIP_STACK::NatMgrInit()
{
    ENTER_FUNCTION("SIP_STACK::NatMgrInit");

    HRESULT hr;
    DWORD   Error;

    // Initialize critsec
    
    m_NatMgrCSIsInitialized = TRUE;

    __try
    {
        InitializeCriticalSection(&m_NatMgrCritSec);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        m_NatMgrCSIsInitialized = FALSE;
    }

    if (!m_NatMgrCSIsInitialized)
    {
        LOG((RTC_ERROR, "%s  initializing critsec failed", __fxName));
        return E_OUTOFMEMORY;
    }
    
    // Initialize events

    m_NatShutdownEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (m_NatShutdownEvent == NULL)
    {
        Error = GetLastError();
        LOG((RTC_ERROR, "%s Creating NAT shutdown Event failed %x",
             __fxName, Error));
        return HRESULT_FROM_WIN32(Error);
    }
    
    m_NatHelperNotificationEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (m_NatHelperNotificationEvent == NULL)
    {
        Error = GetLastError();
        LOG((RTC_ERROR, "%s Creating nat notification Event failed %x",
             __fxName, Error));
        return HRESULT_FROM_WIN32(Error);
    }

    // Initialize nathelp

    LOG((RTC_TRACE, "%s - before NathelpInitialize",
         __fxName));
    
    hr = CoCreateInstance(CLSID_DirectPlayNATHelpUPnP,
                          NULL, CLSCTX_INPROC_SERVER,
                          IID_IDirectPlayNATHelp,
                          (void**) (&m_pDirectPlayNATHelp));
    if (hr != S_OK)
    {
        LOG((RTC_ERROR,
             "%s CoCreateInstance(dplaynathelp) failed %x - check dpnathlp.dll is regsvr'd",
             __fxName, hr));
        return S_OK;
    }

    // We use only UPnP support in dpnathlp.dll
    hr = m_pDirectPlayNATHelp->Initialize(0);
    //hr = m_pDirectPlayNATHelp->Initialize(0);
    if (hr != DPNH_OK)
    {
        LOG((RTC_ERROR, "%s m_pDirectPlayNATHelp->Initialize failed %x",
             __fxName, hr));
        return hr;
    }
    
    LOG((RTC_TRACE, "%s - after m_pDirectPlayNATHelp->Initialize(%x)",
         __fxName, m_pDirectPlayNATHelp));

    if (m_pMediaManager != NULL)
    {
        hr = m_pMediaManager->SetDirectPlayNATHelpAndSipStackInterfaces(
                 m_pDirectPlayNATHelp, static_cast<ISipStack *>(this));
        if (hr != S_OK)
        {
            LOG((RTC_ERROR,
                 "%s m_pMediaManager->SetDirectPlayNATHelpInterface failed %x",
                 __fxName, hr));
        }
    }
    
    // Call GetCaps()

    hr = InitNatCaps(&m_NatHelperCaps);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR,
             "%s InitNatCaps failed %x", __fxName, hr));
        return hr;
    }

    return S_OK;
}

HRESULT
SIP_STACK::StartNatThread()
{
    HRESULT hr;
    DWORD   Error;

    ENTER_FUNCTION("SIP_STACK::StartNatThread");

    if (m_pDirectPlayNATHelp == NULL)
    {
        LOG((RTC_ERROR, "%s - m_pDirectPlayNATHelp is NULL",
             __fxName));
        return S_OK;
    }
    
    // Start the NAT thread.

    m_NatMgrThreadHandle = CreateThread(NULL,
                                        0,
                                        ::NatThreadProc,
                                        this,
                                        0,
                                        &m_NatMgrThreadId);
    if (m_NatMgrThreadHandle == NULL)
    {
        Error = GetLastError();
        LOG((RTC_ERROR, "%s CreateThread failed %x", __fxName, Error));
        return HRESULT_FROM_WIN32(Error);
    }

    // Specify the notification event to nathelp.

    hr = m_pDirectPlayNATHelp->SetAlertEvent(
             m_NatHelperNotificationEvent, 0);
    if (hr != DPNH_OK)
    {
        LOG((RTC_ERROR, "%s m_pDirectPlayNATHelp->SetAlertEvent failed %x",
             __fxName, hr));
        return hr;
    }

    LOG((RTC_TRACE, "%s - after m_pDirectPlayNATHelp->SetAlertEvent",
         __fxName));
    
    return S_OK;
}


HRESULT
SIP_STACK::NatMgrStop()
{
    ENTER_FUNCTION("SIP_STACK::NatMgrStop");

    HRESULT hr;
    DWORD   Error;

    if (m_NatMgrThreadHandle != NULL)
    {
        ASSERT(m_NatShutdownEvent != NULL);
        if (!SetEvent(m_NatShutdownEvent))
        {
            Error = GetLastError();
            LOG((RTC_ERROR, "%s SetEvent failed %x",
                 __fxName, Error));
        }
        else
        {
            // signal Shutdown event and wait for thread to exit.
            DWORD WaitStatus = WaitForSingleObject(m_NatMgrThreadHandle,
                                                   INFINITE);
            if (WaitStatus != WAIT_OBJECT_0)
            {
                Error = GetLastError();
                LOG((RTC_ERROR,
                     "%s WaitForSingleObject failed WaitStatus: %x Error: %x",
                     __fxName, WaitStatus, Error));
            }
        }
        
        CloseHandle(m_NatMgrThreadHandle);
        m_NatMgrThreadHandle = NULL;
    }

    if (m_pMediaManager != NULL)
    {
        hr = m_pMediaManager->SetDirectPlayNATHelpAndSipStackInterfaces(
                 NULL, NULL);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR,
                 "%s m_pMediaManager->SetDirectPlayNATHelpInterface failed %x",
                 __fxName, hr));
        }
    }
    
    // close nathelp
    // This will also release the existing mappings
    if (m_pDirectPlayNATHelp != NULL)
    {
        hr = m_pDirectPlayNATHelp->Close(0);
        if (hr != DPNH_OK)
        {
            LOG((RTC_ERROR, "%s NathelpClose failed %x",
                 __fxName, hr));
        }
        
        m_pDirectPlayNATHelp->Release();
        m_pDirectPlayNATHelp = NULL;
        LOG((RTC_TRACE, "%s - shutting down dpnathlp done",
             __fxName));
    }
    
    // close handles
    if (m_NatMgrCSIsInitialized)
    {
        DeleteCriticalSection(&m_NatMgrCritSec);
        m_NatMgrCSIsInitialized = FALSE;
    }

    if (m_NatShutdownEvent != NULL)
    {
        CloseHandle(m_NatShutdownEvent);
        m_NatShutdownEvent = NULL;
    }

    if (m_NatHelperNotificationEvent != NULL)
    {
        CloseHandle(m_NatHelperNotificationEvent);
        m_NatHelperNotificationEvent = NULL;
    }

    return S_OK;
}


// We should call GetCaps() to get the current caps.
// We should also register the port mappings (even if the
// server is not present). This way we will get notified with
// a ADDRESSESCHANGED result if a NAT server becomes available later.
// This function is called in the main thread.

HRESULT
SIP_STACK::InitNatCaps(
    OUT DPNHCAPS    *pNatHelperCaps
    )
{
    HRESULT         hr;
    ENTER_FUNCTION("SIP_STACK::InitNatCaps");

    ZeroMemory(pNatHelperCaps, sizeof(DPNHCAPS));
    pNatHelperCaps->dwSize = sizeof(DPNHCAPS);

    LOG((RTC_TRACE, "%s before DirectPlayNATHelp GetCaps", __fxName));

    if (m_pDirectPlayNATHelp == NULL)
    {
        LOG((RTC_WARN, "%s - m_pDirectPlayNATHelp is NULL", __fxName));
        return S_OK;
    }
    
    hr = m_pDirectPlayNATHelp->GetCaps(
             pNatHelperCaps,
             DPNHGETCAPS_UPDATESERVERSTATUS
             );

    if (hr == DPNH_OK)
    {
        LOG((RTC_TRACE,
             "%s DirectPlayNATHelp GetCaps  Success : recommended interval : %u msec",
             __fxName, pNatHelperCaps->dwRecommendedGetCapsInterval));
    }
    else
    {
        LOG((RTC_ERROR, "%s DirectPlayNATHelp GetCaps returned Error : %x",
             __fxName, hr));
        // We shouldn't get ADDRESSCHANGED here as we haven't registered
        // any port mappings yet.
        return hr;
    }

    return S_OK;
}


// We register the mappings even if there in no NAT server.
// This is called in the main thread.
HRESULT
SIP_STACK::RegisterNatMapping(
    IN OUT SIP_LISTEN_SOCKET *pListenSocket
    )
{
    HRESULT     hr;
    DWORD       AddressTypeFlags;
    DWORD       dwAddressSize;


    ENTER_FUNCTION("SIP_STACK::RegisterNatMapping");
    LOG((RTC_TRACE, "%s before UDP RegisterPorts", __fxName));

    if (m_pDirectPlayNATHelp == NULL)
    {
        return S_OK;
    }
    
    hr = m_pDirectPlayNATHelp->RegisterPorts(
             (SOCKADDR *) &pListenSocket->m_pDynamicPortUdpSocket->m_LocalAddr,
             sizeof(SOCKADDR_IN),
             1,                     // 1 port
             3600000,               // request 1 hour
             &pListenSocket->m_NatUdpPortHandle,
             0                      // UDP
             );
    if (hr != DPNH_OK)
    {
        LOG((RTC_ERROR, "%s UDP RegisterPorts failed %x", __fxName, hr));
        return hr;
    }
    else
    {
        LOG((RTC_TRACE, "%s UDP RegisterPorts succeeded", __fxName));
    }
    
    // Register TCP Port

    LOG((RTC_TRACE, "%s before TCP RegisterPorts", __fxName));

    hr = m_pDirectPlayNATHelp->RegisterPorts(
             (SOCKADDR *) &pListenSocket->m_pDynamicPortTcpSocket->m_LocalAddr,
             sizeof(SOCKADDR_IN),
             1,                       // 1 port
             3600000,                 // request 1 hour
             &pListenSocket->m_NatTcpPortHandle,
             DPNHREGISTERPORTS_TCP    // TCP
             );
    if (hr != DPNH_OK)
    {
        LOG((RTC_ERROR, "%s TCP RegisterPorts failed %x", __fxName, hr));
        return hr;
    }
    else
    {
        LOG((RTC_TRACE, "%s TCP RegisterPorts succeeded", __fxName));
    }
    
    return S_OK;
}


// This is called in the main thread.
// Whenever this function is called, the calling function should take 
// care of DPNHERR_PORTUNAVAILABLE and other error cases.
HRESULT
SIP_STACK::UpdatePublicListenAddr(
    IN OUT SIP_LISTEN_SOCKET *pListenSocket
    )
{
    HRESULT         hr;
    DWORD           AddressTypeFlags;
    DWORD           dwAddressSize;

    ENTER_FUNCTION("SIP_STACK::UpdatePublicListenAddr");

    if (m_pDirectPlayNATHelp == NULL)
    {
        LOG((RTC_ERROR, "%s - m_pDirectPlayNATHelp is NULL",
             __fxName));
        return S_OK;
    }

    // UDP
    
    if (pListenSocket->m_NatUdpPortHandle != NULL)
    {
        ZeroMemory(&pListenSocket->m_PublicUdpListenAddr,
                   sizeof(SOCKADDR_IN));
        dwAddressSize = sizeof(SOCKADDR_IN);
        hr = m_pDirectPlayNATHelp->GetRegisteredAddresses(
                 pListenSocket->m_NatUdpPortHandle,
                 (SOCKADDR *) &pListenSocket->m_PublicUdpListenAddr,
                 &dwAddressSize,
                 &AddressTypeFlags,
                 NULL,
                 0);
        if (hr == DPNH_OK)
        {
            LOG((RTC_TRACE, "%s public UDP address : %d.%d.%d.%d:%d "
                 "for private address: %d.%d.%d.%d:%d", __fxName,
                 PRINT_SOCKADDR(&pListenSocket->m_PublicUdpListenAddr),
                 PRINT_SOCKADDR(&pListenSocket->m_pDynamicPortUdpSocket->m_LocalAddr)));

            if (AddressTypeFlags & DPNHADDRESSTYPE_GATEWAY)
            {
                pListenSocket->m_fIsUpnpNatPresent = TRUE;
            }
            else
            {
                pListenSocket->m_fIsUpnpNatPresent = FALSE;
            }
            
            if (AddressTypeFlags & DPNHADDRESSTYPE_GATEWAYISLOCAL)
            {
                pListenSocket->m_fIsGatewayLocal = TRUE;
            }
            else
            {
                pListenSocket->m_fIsGatewayLocal = FALSE;
            }
            
            // Check if Firewall is enabled for this interface.
            
            if (AddressTypeFlags & DPNHADDRESSTYPE_LOCALFIREWALL)
            {
                LOG((RTC_TRACE, "%s - Personal Firewall enabled for interface %d.%d.%d.%d",
                     __fxName, NETORDER_BYTES0123(pListenSocket->m_IpAddr)));
                pListenSocket->m_fIsFirewallEnabled = TRUE;

                ZeroMemory(&pListenSocket->m_LocalFirewallUdpListenAddr,
                           sizeof(SOCKADDR_IN));
                dwAddressSize = sizeof(SOCKADDR_IN);
                hr = m_pDirectPlayNATHelp->GetRegisteredAddresses(
                         pListenSocket->m_NatUdpPortHandle,
                         (SOCKADDR *) &pListenSocket->m_LocalFirewallUdpListenAddr,
                         &dwAddressSize,
                         &AddressTypeFlags,
                         NULL,
                         DPNHGETREGISTEREDADDRESSES_LOCALFIREWALLREMAPONLY);
                if (hr == DPNH_OK)
                {
                    LOG((RTC_TRACE, "%s Local Firewall UDP address : %d.%d.%d.%d:%d "
                         "for private address: %d.%d.%d.%d:%d", __fxName,
                         PRINT_SOCKADDR(&pListenSocket->m_LocalFirewallUdpListenAddr),
                         PRINT_SOCKADDR(&pListenSocket->m_pDynamicPortUdpSocket->m_LocalAddr)));
                }
                else
                {
                    LOG((RTC_ERROR, "%s UDP local firewall GetRegisteredAddress failed %x",
                         __fxName, hr));
                    pListenSocket->m_fIsFirewallEnabled = FALSE;
                    ZeroMemory(&pListenSocket->m_LocalFirewallUdpListenAddr,
                               sizeof(SOCKADDR_IN));
                    return hr;
                }
            }
            else
            {
                pListenSocket->m_fIsFirewallEnabled = FALSE;
            }
        }
        else
        {
            LOG((RTC_ERROR, "%s UDP GetRegisteredAddress failed %x",
                 __fxName, hr));
            pListenSocket->m_fIsUpnpNatPresent = FALSE;
            pListenSocket->m_fIsGatewayLocal = FALSE;
            pListenSocket->m_fIsFirewallEnabled = FALSE;
            ZeroMemory(&pListenSocket->m_PublicUdpListenAddr,
                       sizeof(SOCKADDR_IN));
            return hr;
        }
    }    
    
    // TCP
    
    if (pListenSocket->m_NatTcpPortHandle != NULL)
    {
        ZeroMemory(&pListenSocket->m_PublicTcpListenAddr,
                   sizeof(SOCKADDR_IN));
        dwAddressSize = sizeof(SOCKADDR_IN);
        hr = m_pDirectPlayNATHelp->GetRegisteredAddresses(
                 pListenSocket->m_NatTcpPortHandle,
                 (SOCKADDR *) &pListenSocket->m_PublicTcpListenAddr,
                 &dwAddressSize,
                 &AddressTypeFlags,
                 NULL,
                 0);
        if (hr == DPNH_OK)
        {
            LOG((RTC_TRACE, "%s public TCP address : %d.%d.%d.%d:%d "
                 "for private address: %d.%d.%d.%d:%d", __fxName,
                 PRINT_SOCKADDR(&pListenSocket->m_PublicTcpListenAddr),
                 PRINT_SOCKADDR(&pListenSocket->m_pDynamicPortTcpSocket->m_LocalAddr)));

            if (AddressTypeFlags & DPNHADDRESSTYPE_GATEWAY)
            {
                pListenSocket->m_fIsUpnpNatPresent = TRUE;
            }
            else
            {
                pListenSocket->m_fIsUpnpNatPresent = FALSE;
            }
            
            if (AddressTypeFlags & DPNHADDRESSTYPE_GATEWAYISLOCAL)
            {
                pListenSocket->m_fIsGatewayLocal = TRUE;
            }
            else
            {
                pListenSocket->m_fIsGatewayLocal = FALSE;
            }
            
            // Check if Firewall is enabled for this interface.

            if (AddressTypeFlags & DPNHADDRESSTYPE_LOCALFIREWALL)
            {
                pListenSocket->m_fIsFirewallEnabled = TRUE;

                ZeroMemory(&pListenSocket->m_LocalFirewallTcpListenAddr,
                           sizeof(SOCKADDR_IN));
                dwAddressSize = sizeof(SOCKADDR_IN);
                hr = m_pDirectPlayNATHelp->GetRegisteredAddresses(
                         pListenSocket->m_NatTcpPortHandle,
                         (SOCKADDR *) &pListenSocket->m_LocalFirewallTcpListenAddr,
                         &dwAddressSize,
                         &AddressTypeFlags,
                         NULL,
                         DPNHGETREGISTEREDADDRESSES_LOCALFIREWALLREMAPONLY);
                if (hr == DPNH_OK)
                {
                    LOG((RTC_TRACE, "%s Local Firewall TCP address : %d.%d.%d.%d:%d "
                         "for private address: %d.%d.%d.%d:%d", __fxName,
                         PRINT_SOCKADDR(&pListenSocket->m_LocalFirewallTcpListenAddr),
                         PRINT_SOCKADDR(&pListenSocket->m_pDynamicPortTcpSocket->m_LocalAddr)));
                }
                else
                {
                    LOG((RTC_ERROR, "%s TCP local firewall GetRegisteredAddress failed %x",
                         __fxName, hr));
                    pListenSocket->m_fIsFirewallEnabled = FALSE;
                    ZeroMemory(&pListenSocket->m_LocalFirewallTcpListenAddr,
                               sizeof(SOCKADDR_IN));
                    return hr;
                }
            }
            else
            {
                pListenSocket->m_fIsFirewallEnabled = FALSE;
            }
        }
        else
        {
            LOG((RTC_ERROR, "%s TCP GetRegisteredAddress failed %x",
                 __fxName, hr)); 
            pListenSocket->m_fIsUpnpNatPresent = FALSE;
            pListenSocket->m_fIsGatewayLocal = FALSE;
            pListenSocket->m_fIsFirewallEnabled = FALSE;
            ZeroMemory(&pListenSocket->m_PublicTcpListenAddr,
                       sizeof(SOCKADDR_IN));
            return hr;
        }
    }

    return S_OK;
}


// This function is called in the NAT thread.
// Keep calling GetCaps() periodically to see if the server status
// changed and to refresh the mappings.
// DPNH_OK - do nothing
// ADDRESSESCHANGED - get updated mappings (using GetRegisteredAddresses)
// ERROR - do nothing (will call GetCaps() later again.)

HRESULT
SIP_STACK::GetCapsAndUpdateNatMappingsIfNeeded()
{
    ENTER_FUNCTION("SIP_STACK::GetCapsAndUpdateNatMappingsIfNeeded");
    
    HRESULT         hr;
    
    // GetCaps

    ZeroMemory(&m_NatHelperCaps, sizeof(m_NatHelperCaps));
    m_NatHelperCaps.dwSize = sizeof(m_NatHelperCaps);

    LOG((RTC_TRACE, "%s before DirectPlayNATHelp GetCaps", __fxName));

    hr = m_pDirectPlayNATHelp->GetCaps(
             &m_NatHelperCaps,
             DPNHGETCAPS_UPDATESERVERSTATUS);

    if (hr == DPNH_OK)
    {
        LOG((RTC_TRACE,
             "%s GetCaps Success : recommended interval : %u msec",
             __fxName, m_NatHelperCaps.dwRecommendedGetCapsInterval));

        return S_OK;
    }
    else if (hr == DPNHSUCCESS_ADDRESSESCHANGED)
    {
        LOG((RTC_WARN, "%s GetCaps returned Address Changed interval: %u msec",
             __fxName, m_NatHelperCaps.dwRecommendedGetCapsInterval));

        // Post a message to the SIP stack notifying NAT address change.
        if (!PostMessage(GetSipStackWindow(),
                         WM_SIP_STACK_NAT_ADDR_CHANGE,
                         (WPARAM) this, 0))
        {
            DWORD Error = GetLastError();
            
            LOG((RTC_ERROR, "%s PostMessage failed : %x",
                 __fxName, Error));
            return (HRESULT_FROM_WIN32(Error));
        }
        return S_OK;
    }
    else
    {
        LOG((RTC_ERROR, "%s GetCaps returned Error : %x",
             __fxName, hr));
        m_NatHelperCaps.dwRecommendedGetCapsInterval = 10000;
        return hr;
    }

    return S_OK;
}

// This function is called in the NAT thread.
// XXX TODO If there is a change in server state/IP address we should
// notify the SIP_STACK to do unregister/re-register etc.

// This function is called from the nat helper thread.
// We hold the critical section just for copying the Public listen
// address as GetRegisteredAddresses could be a blocking call.

HRESULT
SIP_STACK::OnNatAddressChange()
{
    ENTER_FUNCTION("SIP_STACK::OnNatAddressChange");
    
    OnIPAddrChange();

    LOG((RTC_TRACE,"%s exits",__fxName));
    return S_OK;
}

//      if ((m_NatHelperCaps.dwFlags & PHCAPSFLAGS_SERVERPRESENT) &&
//          (m_NatHelperCaps.dwFlags & PHCAPSFLAGS_PUBLICADDRESSAVAILABLE))
//      {

//      }

// VanceO says DPNHCAPSFLAG_LOCALSERVER flag is just for
// informational purposes and that we should register the mappings
// even this flag is returned.


// This function is called from the main thread.  This function
// returns TRUE if there is a public address mapping on the NAT for
// the LocalIp passed in. It returns FALSE if we are not currently
// listening on this address or if there is no public address on the
// NAT mapped to this address.

BOOL
SIP_STACK::GetPublicListenAddr(
    IN  DWORD           LocalIp,    // in network byte order
    IN  BOOL            fTcp,
    OUT SOCKADDR_IN    *pPublicAddr
    )
{
    ENTER_FUNCTION("SIP_STACK::GetPublicListenAddr");

    ASSERT(LocalIp != 0);
    
    SIP_LISTEN_SOCKET  *pListenSocket;
    SOCKADDR_IN        *pPublicSockAddr;

    ASSERT(pPublicAddr);

    pListenSocket = FindListenSocketForIpAddr(LocalIp);
    if (pListenSocket == NULL)
    {
        LOG((RTC_ERROR, "%s - failed to find listen socket for %d.%d.%d.%d",
             __fxName, NETORDER_BYTES0123(LocalIp)));
        return FALSE;
    }

    if (fTcp)
    {
        pPublicSockAddr = &pListenSocket->m_PublicTcpListenAddr;
    }
    else
    {
        pPublicSockAddr = &pListenSocket->m_PublicUdpListenAddr;
    }

    if (pPublicSockAddr->sin_addr.s_addr != htonl(0) &&
        pPublicSockAddr->sin_port != htons(0))
    {
        CopyMemory(pPublicAddr, pPublicSockAddr, sizeof(SOCKADDR_IN));
        LOG((RTC_TRACE,
             "%s : returning use public Public addr: %d.%d.%d.%d:%d",
             __fxName, PRINT_SOCKADDR(pPublicAddr)));
        return TRUE;
    }
    else
    {
        LOG((RTC_TRACE,
             "%s : No public listen addr for LocalIp: %d.%d.%d.%d",
             __fxName, NETORDER_BYTES0123(LocalIp)));
        return FALSE;
    }
}


// If the client is behind a NAT and pDestAddr is the public address
// of a mapping (on the external edge of the NAT), then the corresponding
// NAT internal address is returned in pActualDestAddr.
// Otherwise pActualDestAddr will have pDestAddr.
// *pIsDestExternalToNat will be set to TRUE only if the client is
// behind a NAT and the actual destination address is external to the NAT.
// In all other cases, it will be set to FALSE.

// This function is called from the main thread.

// LocalIp could be 0 if we don't know the interface we are
// communicating on yet.
HRESULT
SIP_STACK::MapDestAddressToNatInternalAddress(
    IN  DWORD            LocalIp,               // in network byte order
    IN  SOCKADDR_IN     *pDestAddr,
    IN  SIP_TRANSPORT    Transport,
    OUT SOCKADDR_IN     *pActualDestAddr,
    OUT BOOL            *pIsDestExternalToNat
    )
{
    ENTER_FUNCTION("SIP_STACK::MapDestAddressToNatInternalAddress");
    
    HRESULT     hr;
    SOCKADDR_IN SourceAddr;
    DWORD       QueryFlags;

    ASSERT(pDestAddr);
    ASSERT(pActualDestAddr);
    ASSERT(pIsDestExternalToNat);

    if (m_pDirectPlayNATHelp == NULL)
    {
        LOG((RTC_ERROR, "%s m_pDirectPlayNATHelp is NULL", __fxName));
        *pIsDestExternalToNat = FALSE;
        CopyMemory(pActualDestAddr, pDestAddr, sizeof(SOCKADDR_IN));
        return S_OK;
    }
    
    ZeroMemory(&SourceAddr, sizeof(SOCKADDR_IN));
    SourceAddr.sin_family = AF_INET;
    // In some proxy scenarios we can not really pick the right local
    // address for the client on the NAT machine.
    // SourceAddr.sin_addr.s_addr = LocalIp;
    SourceAddr.sin_addr.s_addr = htonl(INADDR_ANY);

    QueryFlags = DPNHQUERYADDRESS_CHECKFORPRIVATEBUTUNMAPPED;
    if (Transport != SIP_TRANSPORT_UDP)
    {
        QueryFlags |= DPNHQUERYADDRESS_TCP;
    }
    
    LOG((RTC_TRACE, "%s before m_pDirectPlayNATHelp->QueryAddress",
         __fxName));
    
    hr = m_pDirectPlayNATHelp->QueryAddress(
             (SOCKADDR *) &SourceAddr,
             (SOCKADDR *) pDestAddr,
             (SOCKADDR *) pActualDestAddr,
             sizeof(SOCKADDR_IN),
             QueryFlags
             );
    if (hr == S_OK)
    {
        LOG((RTC_TRACE,
             "%s - found a mapped private address : %d.%d.%d.%d:%d for %d.%d.%d.%d:%d",
             __fxName, PRINT_SOCKADDR(pActualDestAddr), PRINT_SOCKADDR(pDestAddr)));
        *pIsDestExternalToNat = FALSE;
    }
    else if (hr == DPNHERR_NOMAPPINGBUTPRIVATE)
    {
        LOG((RTC_TRACE, "%s - address (%d.%d.%d.%d:%d) is private",
             __fxName, PRINT_SOCKADDR(pDestAddr)));
        *pIsDestExternalToNat = FALSE;
        // XXX TODO the server seems to think that external addresses
        // are private for some reason.
        // *pIsDestExternalToNat = TRUE;   
        CopyMemory(pActualDestAddr, pDestAddr, sizeof(SOCKADDR_IN));
    }
    else if (hr == DPNHERR_NOMAPPING)
    {
        LOG((RTC_TRACE, "%s - address (%d.%d.%d.%d:%d) is outside NAT",
             __fxName, PRINT_SOCKADDR(pDestAddr)));
        *pIsDestExternalToNat = TRUE;
        CopyMemory(pActualDestAddr, pDestAddr, sizeof(SOCKADDR_IN));
    }
    else
    {
        LOG((RTC_ERROR, "%s failed to query address(%d.%d.%d.%d:%d) %x",
             __fxName, PRINT_SOCKADDR(pDestAddr), hr));
        *pIsDestExternalToNat = FALSE;
        CopyMemory(pActualDestAddr, pDestAddr, sizeof(SOCKADDR_IN));
    }
    
    return S_OK;
}


HRESULT SIP_STACK::RegisterHttpProxyWindowClass(void)
{
    WNDCLASSEX      ClassData;
    HRESULT         Error;
    ATOM            aResult;
    
    ENTER_FUNCTION("SIP_STACK::RegisterHttpProxyProcessWindowClass");
    LOG((RTC_TRACE,"%s entered",__fxName));
    
    ZeroMemory (&ClassData, sizeof ClassData);

    ClassData.cbSize = sizeof ClassData;
    ClassData.lpfnWndProc = SIP_MSG_PROCESSOR::HttpProxyProcessWinProc;
    ClassData.hInstance = _Module.GetResourceInstance();
    ClassData.lpszClassName = SIP_MSG_PROCESSOR_WINDOW_CLASS;

    aResult = RegisterClassEx(&ClassData);
    if (!aResult) {
        Error = GetLastError();
        LOG((RTC_ERROR,"%s failed error %x",__fxName,Error));
    }

    LOG((RTC_TRACE,"%s exits",__fxName));
    return S_OK;
}


HRESULT SIP_STACK::UnregisterHttpProxyWindow(void) {

    HRESULT Error;

    ENTER_FUNCTION(("SIP_STACK::UnregisterHttpProxyProcessWindow"));
    LOG((RTC_TRACE,"%s entered",__fxName));
    if(!UnregisterClass(SIP_MSG_PROCESSOR_WINDOW_CLASS,_Module.GetResourceInstance())) 
    {
        Error = GetLastError();
        LOG((RTC_ERROR,"%s failed error %x",__fxName,Error));
        return HRESULT_FROM_WIN32(Error);
    }
    LOG((RTC_TRACE,"%s exits",__fxName));
    return S_OK;
}




//////////////////////////////////////////////////////
//// Stuff below is not used.
//////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\siputil.cpp ===
#include "precomp.h"

#define IsReserved( x )         (   ((x) == '@') || \
                                    ((x) == '$') || \
                                    ((x) == '%') || \
                                    ((x) == '&') || \
                                    ((x) == '=') || \
                                    ((x) == ',') || \
                                    ((x) == '?') || \
                                    ((x) == '/') || \
                                    ((x) == '@') || \
                                    ((x) == '^')    \
                                )

int
IntValToAscii(
    int ch
    )
{
    if( (ch >= 0) && (ch <= 9) )
       return ch + '0';
    else if( (ch >= 10) && (ch <= 16) )
       return ch + 'A' -10;
    else
        return 0;
}


HRESULT
AddEscapeSequence(
    IN  OUT PSTR   *pString,
    IN  OUT ULONG  *pStringLength,
    IN      ULONG   startIndex,
    IN      ULONG   endIndex
    )
{
    DWORD   StringLength = 0, iIndex = 0, jIndex = 0, reservedCount =0;
    PSTR    String = NULL;

    for( iIndex=startIndex; iIndex < endIndex; iIndex++)
    {
        if( IsReserved( (*pString)[iIndex] ) )
        {
            reservedCount++;
        }
    }

    if( reservedCount == 0 )
    {
        return S_OK;
    }

    //we could also use realloc here. but that won't be very effecient.
    String = (PSTR) malloc( *pStringLength + 2*reservedCount +1 );
    if( String == NULL )
    {
        return E_OUTOFMEMORY;
    }
    
    for( iIndex=startIndex; iIndex < endIndex; iIndex++ )
    {
        if( IsReserved( (*pString)[iIndex] ) )
        {
            String[jIndex++] = '%';
            String[jIndex++] = (CHAR)IntValToAscii( ((*pString)[iIndex])/16 );
            String[jIndex++] = (CHAR)IntValToAscii( ((*pString)[iIndex])%16 );
        }
        else
        {
            String[jIndex++] = (*pString)[iIndex];
        }
    }

    for( iIndex=endIndex; iIndex < *pStringLength; iIndex++ )
    {
        String[jIndex++] = (*pString)[iIndex];                
    }
    
    String[jIndex] = '\0';
    
    free( *pString );

    *pString        = String;
    *pStringLength  = jIndex;
    return S_OK;
}


HRESULT
UnicodeToUTF8(
    IN  LPCWSTR UnicodeString,
    OUT PSTR   *pString,
    OUT ULONG  *pStringLength
    )
{
    int  StringLength;
    PSTR String;
    *pString = NULL;
    *pStringLength = 0;
    if(UnicodeString ==0)
    {
        return S_OK;
    }


    StringLength = WideCharToMultiByte(CP_UTF8, 0, UnicodeString, -1,
                                       0, 0,
                                       NULL, NULL);
    if (StringLength == 0)
        return HRESULT_FROM_WIN32(GetLastError());

    // StringLength includes '\0'
    String = (PSTR) malloc(StringLength);
    if (String == NULL)
        return E_OUTOFMEMORY;

    StringLength = WideCharToMultiByte(CP_UTF8, 0, UnicodeString, -1,
                                       String, StringLength,
                                       NULL, NULL);

    if (StringLength == 0)
    {
        free(String);
        return HRESULT_FROM_WIN32(GetLastError());
    }
    
    *pString        = String;
    *pStringLength  = StringLength - 1;
    return S_OK;
}


HRESULT
UTF8ToUnicode(
    IN  LPSTR    UTF8String,
    IN  ULONG    UTF8StringLength,
    OUT LPWSTR  *pString
    )
{
    int     StringLength;
    LPWSTR  String;
    *pString = NULL;
    if(UTF8StringLength ==0)
    {
        return S_OK;
    }
    StringLength = MultiByteToWideChar(CP_UTF8, 0,
                                       UTF8String, UTF8StringLength,
                                       0, 0);
    if (StringLength == 0)
        return HRESULT_FROM_WIN32(GetLastError());

    // For '\0'
    StringLength++;
    
    String = (LPWSTR) malloc(StringLength * sizeof(WCHAR));
    if (String == NULL)
        return E_OUTOFMEMORY;

    StringLength = MultiByteToWideChar(CP_UTF8, 0,
                                       UTF8String, UTF8StringLength,
                                       String, StringLength - 1);

    if (StringLength == 0)
    {
        free(String);
        return HRESULT_FROM_WIN32(GetLastError());
    }
    
    String[StringLength] = L'\0';
    *pString             = String;
    return S_OK;
}


HRESULT
UTF8ToBstr(
    IN  LPSTR    UTF8String,
    IN  ULONG    UTF8StringLength,
    OUT BSTR    *pbstrString
    )
{
    HRESULT hr;
    LPWSTR  wsString;
    *pbstrString = NULL;

    ENTER_FUNCTION("UTF8ToBstr");
    if(UTF8StringLength ==0)
        return S_OK;
    hr = UTF8ToUnicode(UTF8String, UTF8StringLength,
                       &wsString);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - UTF8ToUnicode failed %x",
             __fxName, hr));
        return hr;
    }

    *pbstrString = SysAllocString(wsString);

    free(wsString);
    if (*pbstrString == NULL)
    {
        LOG((RTC_ERROR, "%s SysAllocString failed", __fxName));
        return E_OUTOFMEMORY;
    }

    return S_OK;
}


void
GetNumberStringFromUuidString(
	IN	OUT	PSTR	UuidStr, 
	IN		DWORD	UuidStrLen 
	)
{
	DWORD	i, j = 0;

	for( i=0; i< UuidStrLen; i++ )
	{
		if( (UuidStr[i] >= 'a') && (UuidStr[i] <= 'f') )
		{
			UuidStr[j++] = UuidStr[i] + '1' - 'a';
		}
		else if( UuidStr[i] != '-' )
		{
			UuidStr[j++] = UuidStr[i];
		}
	}

    //
    // Limiting the string to 20 digits only
    // XXX - temporary hack; should be fixed.
    UuidStr[j] = '\0';
    //if( j > 19 )
    //    UuidStr[20] = '\0';
}


HRESULT
CreateUuid(
    OUT PSTR  *pUuidStr,
    OUT ULONG *pUuidStrLen
    )
{
    UUID   Uuid;
    UCHAR *RpcUuidStr;
    PSTR   ReturnUuidStr;
    ULONG  ReturnUuidStrLen;
    
    *pUuidStr = NULL;
    
    RPC_STATUS hr = ::UuidCreate(&Uuid);
    if (hr != RPC_S_OK)
    {
        return E_FAIL;
    }

    hr = UuidToStringA(&Uuid, &RpcUuidStr);
    if (hr != RPC_S_OK)
    {
        return E_FAIL;
    }

    ReturnUuidStrLen = strlen((PSTR)RpcUuidStr);
    ReturnUuidStr = (PSTR) malloc(ReturnUuidStrLen + 1);
    if (ReturnUuidStr == NULL)
        return E_OUTOFMEMORY;
    strncpy(ReturnUuidStr, (PSTR)RpcUuidStr, ReturnUuidStrLen + 1);
    
    RpcStringFreeA(&RpcUuidStr);

    *pUuidStr    = ReturnUuidStr;
    *pUuidStrLen = ReturnUuidStrLen;
    return S_OK;
}


HRESULT
GetNullTerminatedString(
    IN  PSTR    String,
    IN  ULONG   StringLen,
    OUT PSTR   *pszString
    )
{
    *pszString = NULL;

    ASSERT(StringLen != 0);
    
    PSTR szString = (PSTR) malloc(StringLen + 1);
    if (szString == NULL)
    {
        return E_OUTOFMEMORY;
    }

    strncpy(szString, String, StringLen);
    szString[StringLen] = '\0';
    *pszString = szString;
    return S_OK;
}


HRESULT
AllocString(
    IN  PSTR    String,
    IN  ULONG   StringLen,
    OUT PSTR   *pszString,
    OUT ULONG  *pStringLen
    )
{
    ENTER_FUNCTION("AllocString");

    HRESULT hr;
    
    if (String    == NULL ||
        StringLen == 0)
    {
        *pszString  = NULL;
        *pStringLen = 0;
        return S_OK;
    }
    
    hr = GetNullTerminatedString(String, StringLen,
                                 pszString);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s GetNullTerminatedString failed %x",
             __fxName, hr));
        return hr;
    }

    *pStringLen = StringLen;
    return S_OK;
}


HRESULT
AllocCountedString(
    IN  PSTR            String,
    IN  ULONG           StringLen,
    OUT COUNTED_STRING *pCountedString
    )
{
    HRESULT hr;
    ENTER_FUNCTION("AllocCountedString");

    return AllocString(String, StringLen,
                       &pCountedString->Buffer,
                       &pCountedString->Length);
}


LPWSTR
RemoveVisualSeparatorsFromPhoneNo(
    IN LPWSTR PhoneNo
    )
{
    ULONG FromIndex = 0;
    ULONG ToIndex   = 0;
    ULONG StringLen = wcslen(PhoneNo);

    while (FromIndex < StringLen)
    {
        if (iswdigit(PhoneNo[FromIndex]))
        {
            PhoneNo[ToIndex++] = PhoneNo[FromIndex++];
        }
        else
        {
            FromIndex++;
        }
    }

    PhoneNo[ToIndex] = L'\0';
    return PhoneNo;
}


void
ReverseList(
    IN LIST_ENTRY *pListHead
    )
{
    ENTER_FUNCTION("ReverseList");
    LIST_ENTRY *pListEntry;
    LIST_ENTRY *pPrev;
    LIST_ENTRY *pNext;

    pListEntry = pListHead->Flink;
    pPrev      = pListHead;
    
    while (pListEntry != pListHead)
    {
        pNext = pListEntry->Flink;

        pListEntry->Flink = pPrev;
        pPrev->Blink = pListEntry;

        pPrev = pListEntry;
        pListEntry = pNext;
    }

    pListHead->Flink = pPrev;
    pPrev->Blink = pListHead;
}


void
MoveListToNewListHead(
    IN OUT LIST_ENTRY *pOldListHead,
    IN OUT LIST_ENTRY *pNewListHead    
    )
{
    ENTER_FUNCTION("MoveListToNewListHead");

    ASSERT(pNewListHead);
    ASSERT(pOldListHead);
    ASSERT(IsListEmpty(pNewListHead));

    if (IsListEmpty(pOldListHead))
    {
        return;
    }

    pNewListHead->Flink = pOldListHead->Flink;
    pNewListHead->Blink = pOldListHead->Blink;

    pNewListHead->Flink->Blink = pNewListHead;
    pNewListHead->Blink->Flink = pNewListHead;

    InitializeListHead(pOldListHead);
}


//
// This code has been taken from : \nt\ds\ds\src\util\base64\base64.c
//

NTSTATUS
base64encode(
    IN  VOID *  pDecodedBuffer,
    IN  DWORD   cbDecodedBufferSize,
    OUT LPSTR   pszEncodedString,
    IN  DWORD   cchEncodedStringSize,
    OUT DWORD * pcchEncoded             OPTIONAL
    )
/*++

Routine Description:

    Decode a base64-encoded string.

Arguments:

    pDecodedBuffer (IN) - buffer to encode.
    cbDecodedBufferSize (IN) - size of buffer to encode.
    cchEncodedStringSize (IN) - size of the buffer for the encoded string.
    pszEncodedString (OUT) = the encoded string.
    pcchEncoded (OUT) - size in characters of the encoded string.

Return Values:

    0 - success.
    STATUS_INVALID_PARAMETER
    STATUS_BUFFER_TOO_SMALL

--*/
{
    static char rgchEncodeTable[64] = {
        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
        'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
        'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'
    };

    DWORD   ib;
    DWORD   ich;
    DWORD   cchEncoded;
    BYTE    b0, b1, b2;
    BYTE *  pbDecodedBuffer = (BYTE *) pDecodedBuffer;

    // Calculate encoded string size.
    cchEncoded = 1 + (cbDecodedBufferSize + 2) / 3 * 4;

    if (NULL != pcchEncoded) {
        *pcchEncoded = cchEncoded;
    }

    if (cchEncodedStringSize < cchEncoded) {
        // Given buffer is too small to hold encoded string.
        return STATUS_BUFFER_TOO_SMALL;
    }

    // Encode data byte triplets into four-byte clusters.
    ib = ich = 0;
    while (ib < cbDecodedBufferSize) {
        b0 = pbDecodedBuffer[ib++];
        b1 = (ib < cbDecodedBufferSize) ? pbDecodedBuffer[ib++] : 0;
        b2 = (ib < cbDecodedBufferSize) ? pbDecodedBuffer[ib++] : 0;

        pszEncodedString[ich++] = rgchEncodeTable[b0 >> 2];
        pszEncodedString[ich++] = rgchEncodeTable[((b0 << 4) & 0x30) | ((b1 >> 4) & 0x0f)];
        pszEncodedString[ich++] = rgchEncodeTable[((b1 << 2) & 0x3c) | ((b2 >> 6) & 0x03)];
        pszEncodedString[ich++] = rgchEncodeTable[b2 & 0x3f];
    }

    // Pad the last cluster as necessary to indicate the number of data bytes
    // it represents.
    switch (cbDecodedBufferSize % 3) {
      case 0:
        break;
      case 1:
        pszEncodedString[ich - 2] = '=';
        // fall through
      case 2:
        pszEncodedString[ich - 1] = '=';
        break;
    }

    // Null-terminate the encoded string.
    pszEncodedString[ich++] = '\0';

    ASSERT(ich == cchEncoded);

    return STATUS_SUCCESS;
}


NTSTATUS
base64decode(
    IN  LPSTR   pszEncodedString,
    OUT VOID *  pDecodeBuffer,
    IN  DWORD   cbDecodeBufferSize,
    IN  DWORD   cchEncodedSize,
    OUT DWORD * pcbDecoded              OPTIONAL
    )
/*++

Routine Description:

    Decode a base64-encoded string.

Arguments:

    pszEncodedString (IN) - base64-encoded string to decode.
    cbDecodeBufferSize (IN) - size in bytes of the decode buffer.
    pbDecodeBuffer (OUT) - holds the decoded data.
    pcbDecoded (OUT) - number of data bytes in the decoded data (if success or
        STATUS_BUFFER_TOO_SMALL).

Return Values:

    0 - success.
    STATUS_INVALID_PARAMETER
    STATUS_BUFFER_TOO_SMALL

--*/
{
#define NA (255)
//#define DECODE(x) (((int)(x) < sizeof(rgbDecodeTable)) ? rgbDecodeTable[x] : NA)
#define DECODE(x) (x < sizeof(rgbDecodeTable))? rgbDecodeTable[x] : NA

    static BYTE rgbDecodeTable[128] = {
       NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,  // 0-15 
       NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,  // 16-31
       NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 62, NA, NA, NA, 63,  // 32-47
       52, 53, 54, 55, 56, 57, 58, 59, 60, 61, NA, NA, NA, NA, NA, NA,  // 48-63
       NA,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,  // 64-79
       15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, NA, NA, NA, NA, NA,  // 80-95
       NA, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,  // 96-111
       41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, NA, NA, NA, NA, NA,  // 112-127
    };

    DWORD   cbDecoded;
    DWORD   ich;
    DWORD   ib;
    BYTE    b0, b1, b2, b3;
    BYTE *  pbDecodeBuffer = (BYTE *) pDecodeBuffer;

    if( cchEncodedSize == 0 )
    {
        cchEncodedSize = lstrlenA(pszEncodedString);
    }
    if ((0 == cchEncodedSize) || (0 != (cchEncodedSize % 4))) {
        // Input string is not sized correctly to be base64.
        return STATUS_INVALID_PARAMETER;
    }

    // Calculate decoded buffer size.
    cbDecoded = (cchEncodedSize + 3) / 4 * 3;
    if (pszEncodedString[cchEncodedSize-1] == '=') {
        if (pszEncodedString[cchEncodedSize-2] == '=') {
            // Only one data byte is encoded in the last cluster.
            cbDecoded -= 2;
        }
        else {
            // Only two data bytes are encoded in the last cluster.
            cbDecoded -= 1;
        }
    }

    if (NULL != pcbDecoded) {
        *pcbDecoded = cbDecoded;
    }

    if (cbDecoded > cbDecodeBufferSize) {
        // Supplied buffer is too small.
        return STATUS_BUFFER_TOO_SMALL;
    }

    // Decode each four-byte cluster into the corresponding three data bytes.
    ich = ib = 0;
    while (ich < (cchEncodedSize-4) ) {
        b0 = DECODE(pszEncodedString[ich]);
        ich++;
        b1 = DECODE(pszEncodedString[ich]);
        ich++;
        b2 = DECODE(pszEncodedString[ich]);
        ich++;
        b3 = DECODE(pszEncodedString[ich]);
        ich++;

        if ((NA == b0) || (NA == b1) || (NA == b2) || (NA == b3)) {
            // Contents of input string are not base64.
            return STATUS_INVALID_PARAMETER;
        }

        pbDecodeBuffer[ib++] = (b0 << 2) | (b1 >> 4);

        pbDecodeBuffer[ib++] = (b1 << 4) | (b2 >> 2);
    
        pbDecodeBuffer[ib++] = (b2 << 6) | b3;
    }

    b0 = DECODE(pszEncodedString[ich]);
    ich++;
    b1 = DECODE(pszEncodedString[ich]);
    ich++;
    b2 = DECODE(pszEncodedString[ich]);
    ich++;
    b3 = DECODE(pszEncodedString[ich]);
    ich++;

    if ((NA == b0) || (NA == b1) ) {
        // Contents of input string are not base64.
        return STATUS_INVALID_PARAMETER;
    }

    pbDecodeBuffer[ib++] = (b0 << 2) | (b1 >> 4);

    if (ib < cbDecoded) {
        pbDecodeBuffer[ib++] = (b1 << 4) | (b2 >> 2);

        if (ib < cbDecoded) {
            pbDecodeBuffer[ib++] = (b2 << 6) | b3;
        }
    }

    ASSERT(ib == cbDecoded);

    return STATUS_SUCCESS;
}

//presence related xml parsing


HRESULT
GetNextTag(
    IN  PSTR&   pstrBlob, 
    OUT PSTR    pXMLBlobTag, 
    IN  DWORD   dwXMLBlobLen,
    OUT DWORD&  dwTagLen
    )
{
    dwTagLen = 0;

    LOG(( RTC_TRACE, "GetNextTag - Entered"));
    
    pXMLBlobTag[0] = NULL_CHAR;

    SkipWhiteSpacesAndNewLines( pstrBlob );

    if( *pstrBlob != '<' )
    {
        return E_FAIL;
    }

    pstrBlob++;

    while( (*pstrBlob != '>') && (*pstrBlob != NULL_CHAR) )
    {
        pXMLBlobTag[dwTagLen++] = *pstrBlob;

        //skip the qouted strings
        if( *pstrBlob == QUOTE_CHAR )
        {
            pstrBlob++;

            while( (*pstrBlob != QUOTE_CHAR) && (*pstrBlob != NULL_CHAR) )
            {
                pXMLBlobTag[dwTagLen++] = *pstrBlob++;
            }

            if( *pstrBlob == NULL_CHAR )
            {
                return E_FAIL;
            }

            pXMLBlobTag[dwTagLen++] = *pstrBlob++;
        }
        else
        {
            pstrBlob++;
        }
    }

    if( *pstrBlob == NULL_CHAR )
    {
        return E_FAIL;
    }
    
    if( pXMLBlobTag[dwTagLen-1] == '/' )
    {
        dwTagLen -= 1;
    }
    
    // Skip the '>' char
    pstrBlob++;
    //SkipWhiteSpacesAndNewLines( pstrBlob );

        
    pXMLBlobTag[dwTagLen] = NULL_CHAR;
    
    LOG(( RTC_TRACE, "GetNextTag - Exited"));
    return S_OK;
}

int
GetEscapeChar( 
    CHAR hiChar,
    CHAR loChar
    )
{
   LOG(( RTC_TRACE, "GetEscapeChar() Entered" ));
   
   if( (hiChar >= '0') && (hiChar <= '9') )
       hiChar -= '0';
   else if( (loChar >= 'A') && (loChar <= 'F') )
       hiChar = hiChar - 'A' + 10;
   else
       return 0;
       
   if( (loChar >= '0') && (loChar <= '9') )
       loChar -= '0';
   else if( (loChar >= 'A') && (loChar <= 'F') )
       loChar = loChar - 'A' + 10;
   else
       return 0;

   return (hiChar * 16) + loChar;
}


void
RemoveEscapeChars( 
    PSTR    pWordBuf,
    DWORD   dwLen
    )
{
    DWORD iIndex, jIndex=0;
    int escapeVal;

    LOG(( RTC_TRACE, "RemoveEscapeChars() Entered" ));

    if( dwLen < 2 )
        return;

    for( iIndex=0; iIndex < (dwLen-2); iIndex++ )
    {
        if( pWordBuf[iIndex] == '%' )
        {
            escapeVal = GetEscapeChar( pWordBuf[iIndex+1], pWordBuf[iIndex+2] );
            
            if( escapeVal != 0 )
            {
                escapeVal = pWordBuf[ jIndex++ ];
                iIndex += 2;
            }
        }
        else
        {
            pWordBuf[ jIndex++ ] = pWordBuf[ iIndex ];
        }
    }

    //copy the last two chars
    pWordBuf[jIndex++] = pWordBuf[iIndex++];
    pWordBuf[jIndex++] = pWordBuf[iIndex++];

    LOG(( RTC_TRACE, "RemoveEscapeChars() Exited" ));
    pWordBuf[jIndex] = NULL_CHAR;
}

// Moves the buffer pointer (ppBlock) to the next word
// and copies the current word in the array provided upto
// the length of the array.
HRESULT
GetNextWord(
    OUT PSTR * ppBlock,
    IN  PSTR   pWordBuf,
    IN  DWORD  dwWordBufSize
    )
{
    HRESULT hr = S_OK;
    DWORD iIndex = 0;
    PSTR pBlock = *ppBlock;

    LOG(( RTC_TRACE, "GetNextWord() Entered" ));
    
    *pWordBuf = NULL_CHAR;

    //skip leading white spaces
    while( (*pBlock == BLANK_CHAR) || (*pBlock == TAB_CHAR) )
    {
        pBlock++;
    }

    if( (*pBlock == NEWLINE_CHAR) || 
        (*pBlock == NULL_CHAR) || 
        IsCRLFPresent(pBlock)
      )
    {
        //no word found.
        return E_FAIL;
    }

    while( (*pBlock != NEWLINE_CHAR) && (*pBlock != NULL_CHAR) &&
           (*pBlock != TAB_CHAR) && (*pBlock != BLANK_CHAR) &&
           !IsCRLFPresent(pBlock) )
    {
        if( iIndex < (dwWordBufSize - 1) )
        {
            pWordBuf[iIndex++] = *pBlock;
        }

        pBlock++;
    }

    pWordBuf[iIndex] = NULL_CHAR;

    //remove trailing '\r' '\n' if any. Metatel sends sometimes.
    if( iIndex > 0 )
    {
        if( pWordBuf[iIndex -1] == RETURN_CHAR ||
            pWordBuf[iIndex -1] == NEWLINE_CHAR)
        {
	        pWordBuf[iIndex -1] = NULL_CHAR;
	        iIndex--;
        }

        LOG(( RTC_TRACE, "GetNextWord-%s", pWordBuf ));
    
        RemoveEscapeChars( pWordBuf, iIndex );

        LOG(( RTC_TRACE, "GetNextWord1-%s", pWordBuf ));
    }

    *ppBlock = pBlock;

    LOG(( RTC_TRACE, "GetNextWord() Exited - %lx", hr ));

    return hr;
}


VOID
SkipUnknownTags(
    IN  PSTR&   pstrXMLBlob,
    OUT PSTR    pXMLBlobTag,
    IN  DWORD   dwXMLBlobLen
    )
{
    HRESULT hr;
    DWORD   dwTagLen = 0;
    DWORD   dwTagType = UNKNOWN_TAG;
    PSTR    tempPtr = NULL;

    LOG(( RTC_TRACE, "SkipUnknownTags - Entered" ));

    while( dwTagType == UNKNOWN_TAG )
    {
        tempPtr = pstrXMLBlob;

        hr = GetNextTag( pstrXMLBlob, pXMLBlobTag, dwXMLBlobLen, dwTagLen );
        if( hr != S_OK )
        {
            pstrXMLBlob = tempPtr;
            return;
        }

        dwTagType = GetPresenceTagType( &pXMLBlobTag, dwTagLen );

        if( dwTagType != UNKNOWN_TAG )
        {
            // retract if its a known tag
            pstrXMLBlob = tempPtr;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\sipurl.cpp ===
#include "precomp.h"
#include "util.h"

#define QUOTE                  '"'

SIP_URL::SIP_URL()
{
    // Set Buffers to NULL and set default values for params.

    ZeroMemory(this, sizeof(*this));

    m_TransportParam    = SIP_TRANSPORT_UDP;
               
    InitializeListHead(&m_OtherParamList);
    InitializeListHead(&m_HeaderList);
}


SIP_URL::~SIP_URL()
{
    FreeSipUrl();
}


VOID
SIP_URL::FreeSipUrl()
{
    int i = 0;
    
    // Free all buffers
    if (m_User.Buffer != NULL)
    {
        free(m_User.Buffer);
        m_User.Buffer = NULL;
    }

    if (m_Password.Buffer != NULL)
    {
        free(m_Password.Buffer);
        m_Password.Buffer = NULL;
    }

    if (m_Host.Buffer != NULL)
    {
        free(m_Host.Buffer);
        m_Host.Buffer = NULL;
    }

    for (i = 0; i < SIP_URL_PARAM_MAX; i++)
    {
        if (m_KnownParams[i].Buffer != NULL)
        {
            free(m_KnownParams[i].Buffer);
            m_KnownParams[i].Buffer = NULL;
        }
    }

    FreeOtherParamList();

    FreeHeaderList();
}


BOOL
SIP_URL::IsTransportParamPresent()
{
    return (m_KnownParams[SIP_URL_PARAM_TRANSPORT].Buffer != NULL);
}


// *pSipUrlString is allocated using malloc and needs to be
// freed using free() when it is not required.

HRESULT
SIP_URL::GetString(
    OUT PSTR    *pSipUrlString,
    OUT ULONG   *pSipUrlStringLen
    )
{
    MESSAGE_BUILDER     Builder;
    PSTR                SipUrlString;
    ULONG               SipUrlStringLen;
    ULONG               SipUrlStringBufLen;
    LIST_ENTRY         *pListEntry;
    SIP_URL_PARAM      *pSipUrlParam;
    SIP_URL_HEADER     *pSipUrlHeader;
    ULONG               i = 0;
    
    ENTER_FUNCTION("SIP_URL::GetString");
    
    SipUrlStringBufLen = 5;   // "sip:" + '\0'
    SipUrlStringBufLen += m_User.Length;
    SipUrlStringBufLen += 1 + m_Password.Length;
    SipUrlStringBufLen += 1 + m_Host.Length;
    SipUrlStringBufLen += 10; // for port

    for (i = 0; i < SIP_URL_PARAM_MAX; i++)
    {
        if (m_KnownParams[i].Length != 0)
        {
            SipUrlStringBufLen += GetSipUrlParamName((SIP_URL_PARAM_ENUM)i)->Length;
            SipUrlStringBufLen += 2 + m_KnownParams[i].Length;
        }
    }
    
    pListEntry = m_OtherParamList.Flink;

    while (pListEntry != &m_OtherParamList)
    {
        pSipUrlParam = CONTAINING_RECORD(pListEntry,
                                         SIP_URL_PARAM,
                                         m_ListEntry);
        SipUrlStringBufLen +=
            pSipUrlParam->m_ParamName.Length +
            pSipUrlParam->m_ParamValue.Length + 2;

        pListEntry = pListEntry->Flink;
    }
    
    pListEntry = m_HeaderList.Flink;

    while (pListEntry != &m_HeaderList)
    {
        pSipUrlHeader = CONTAINING_RECORD(pListEntry,
                                          SIP_URL_HEADER,
                                          m_ListEntry);
        SipUrlStringBufLen +=
            pSipUrlHeader->m_HeaderName.Length +
            pSipUrlHeader->m_HeaderValue.Length + 2;

        pListEntry = pListEntry->Flink;
    }
    
    SipUrlString = (PSTR) malloc(SipUrlStringBufLen);
    if (SipUrlString == NULL)
    {
        LOG((RTC_ERROR, "%s Allocating SipUrlString failed",
             __fxName));
        return E_OUTOFMEMORY;
    }

    Builder.PrepareBuild(SipUrlString, SipUrlStringBufLen);

    Builder.Append("sip:");
    
    if (m_User.Length != 0)
    {
        Builder.Append(&m_User);
    }

    if (m_Password.Length != 0)
    {
        Builder.Append(":");
        Builder.Append(&m_Password);
    }
        
    if (m_User.Length != 0 ||
        m_Password.Length != 0)
    {
        Builder.Append("@");
    }

    if (m_Host.Length != 0)
    {
        Builder.Append(&m_Host);
    }

    if (m_Port != 0)
    {
        CHAR PortBuffer[10];
        Builder.Append(":");
        _itoa(m_Port, PortBuffer, 10);
        Builder.Append(PortBuffer);
    }

    for (i = 0; i < SIP_URL_PARAM_MAX; i++)
    {
        if (m_KnownParams[i].Length != 0)
        {
            Builder.Append(";");
            Builder.Append(GetSipUrlParamName((SIP_URL_PARAM_ENUM)i));
            Builder.Append("=");
            Builder.Append(&m_KnownParams[i]);
        }
    }
    
    pListEntry = m_OtherParamList.Flink;

    while (pListEntry != &m_OtherParamList)
    {
        pSipUrlParam = CONTAINING_RECORD(pListEntry,
                                         SIP_URL_PARAM,
                                         m_ListEntry);
        Builder.Append(";");
        Builder.Append(&pSipUrlParam->m_ParamName);
        if (pSipUrlParam->m_ParamValue.Length != 0)
        {
            Builder.Append("=");
            Builder.Append(&pSipUrlParam->m_ParamValue);
        }

        pListEntry = pListEntry->Flink;
    }

    if (!IsListEmpty(&m_HeaderList))
    {
        pListEntry = m_HeaderList.Flink;
        pSipUrlHeader = CONTAINING_RECORD(pListEntry,
                                          SIP_URL_HEADER,
                                          m_ListEntry);
        Builder.Append("?");
        Builder.Append(&pSipUrlHeader->m_HeaderName);
        Builder.Append("=");
        Builder.Append(&pSipUrlHeader->m_HeaderValue);

        pListEntry = pListEntry->Flink;
        
        while (pListEntry != &m_HeaderList)
        {
            pSipUrlHeader = CONTAINING_RECORD(pListEntry,
                                              SIP_URL_HEADER,
                                              m_ListEntry);
            Builder.Append("&");
            Builder.Append(&pSipUrlHeader->m_HeaderName);
            Builder.Append("=");
            Builder.Append(&pSipUrlHeader->m_HeaderValue);

            pListEntry = pListEntry->Flink;
        }
    }
        
    if (Builder.OverflowOccurred())
    {
        LOG((RTC_TRACE,
             "%s - not enough buffer space -- need %u bytes, got %u\n",
             __fxName, Builder.GetLength(), SipUrlStringBufLen));
        ASSERT(FALSE);

        free(SipUrlString);
        SipUrlString = NULL;
        return E_FAIL;
    }
    
    SipUrlStringLen = Builder.GetLength();
    SipUrlString[SipUrlStringLen] = '\0';

    LOG((RTC_TRACE, "%s SipUrlString %s len: %d BufLen: %d",
         __fxName, SipUrlString, SipUrlStringLen, SipUrlStringBufLen));

    *pSipUrlString    = SipUrlString;
    *pSipUrlStringLen = SipUrlStringLen;

    return S_OK;
}


HRESULT
SIP_URL::CopySipUrl(
    OUT SIP_URL  *pSipUrl
    )
{
    HRESULT hr;
    ULONG   i;

    ENTER_FUNCTION("SIP_URL::CopySipUrl");
    
    if (this == pSipUrl)
    {
        return S_OK;
    }

    pSipUrl->FreeSipUrl();

    hr = AllocCountedString(m_User.Buffer, m_User.Length,
                            &pSipUrl->m_User);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s AllocCountedString(m_User) failed %x",
             __fxName, hr));
        pSipUrl->FreeSipUrl();
        return S_OK;
    }
    
    hr = AllocCountedString(m_Password.Buffer, m_Password.Length,
                            &pSipUrl->m_Password);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s AllocCountedString(m_Password) failed %x",
             __fxName, hr));
        pSipUrl->FreeSipUrl();
        return S_OK;
    }
    
    hr = AllocCountedString(m_Host.Buffer, m_Host.Length,
                            &pSipUrl->m_Host);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s AllocCountedString(m_Host) failed %x",
             __fxName, hr));
        pSipUrl->FreeSipUrl();
        return S_OK;
    }

    pSipUrl->m_Port = m_Port;

    pSipUrl->m_TransportParam = m_TransportParam;

    for (i = 0; i < SIP_URL_PARAM_MAX; i++)
    {
        hr = AllocCountedString(m_KnownParams[i].Buffer,
                                m_KnownParams[i].Length,
                                &pSipUrl->m_KnownParams[i]);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR,
                 "%s AllocCountedString(m_KnownParams[%d]) failed %x",
                 __fxName, i, hr));
            pSipUrl->FreeSipUrl();
            return S_OK;
        }
    }

    hr = CopyOtherParamList(pSipUrl);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s CopyOtherParamList failed %x",
             __fxName, hr));
        pSipUrl->FreeSipUrl();
        return S_OK;
    }
    
    hr = CopyHeaderList(pSipUrl);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s CopyHeaderList failed %x",
             __fxName, hr));
        pSipUrl->FreeSipUrl();
        return S_OK;
    }
    
    return S_OK;
}


HRESULT
SIP_URL::CopyOtherParamList(
    OUT SIP_URL  *pSipUrl
    )
{
    HRESULT hr = S_OK;
    LIST_ENTRY      *pListEntry;
    SIP_URL_PARAM   *pSipUrlParam;
    SIP_URL_PARAM   *pNewSipUrlParam;

    ENTER_FUNCTION("SIP_URL::CopyOtherParamList");

    pListEntry = m_OtherParamList.Flink;

    while (pListEntry != &m_OtherParamList)
    {
        pSipUrlParam = CONTAINING_RECORD(pListEntry,
                                         SIP_URL_PARAM,
                                         m_ListEntry);
        pNewSipUrlParam = new SIP_URL_PARAM;
        if (pNewSipUrlParam == NULL)
        {
            LOG((RTC_ERROR, "%s allocating pNewSipUrlParam failed",
                 __fxName));
            return E_OUTOFMEMORY;
        }

        hr = pNewSipUrlParam->SetParamNameAndValue(
                 pSipUrlParam->m_SipUrlParamId,
                 &pSipUrlParam->m_ParamName,
                 &pSipUrlParam->m_ParamValue);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s SetParamNameAndValue failed %x",
                 __fxName, hr));
            delete pNewSipUrlParam;
            return hr;
        }

        InsertTailList(&pSipUrl->m_OtherParamList,
                       &pNewSipUrlParam->m_ListEntry);
        
        pListEntry = pListEntry->Flink;
    }

    return S_OK;
}


HRESULT
SIP_URL::CopyHeaderList(
    OUT SIP_URL  *pSipUrl
    )
{
    HRESULT hr = S_OK;
    LIST_ENTRY      *pListEntry;
    SIP_URL_HEADER  *pSipUrlHeader;
    SIP_URL_HEADER  *pNewSipUrlHeader;

    ENTER_FUNCTION("SIP_URL::CopyOtherParamList");

    pListEntry = m_HeaderList.Flink;

    while (pListEntry != &m_HeaderList)
    {
        pSipUrlHeader = CONTAINING_RECORD(pListEntry,
                                         SIP_URL_HEADER,
                                         m_ListEntry);
        pNewSipUrlHeader = new SIP_URL_HEADER;
        if (pNewSipUrlHeader == NULL)
        {
            LOG((RTC_ERROR, "%s allocating pNewSipUrlHeader failed",
                 __fxName));
            return E_OUTOFMEMORY;
        }

        hr = pNewSipUrlHeader->SetHeaderNameAndValue(
                 pSipUrlHeader->m_HeaderId,
                 &pSipUrlHeader->m_HeaderName,
                 &pSipUrlHeader->m_HeaderValue);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s SetHeaderNameAndValue failed %x",
                 __fxName, hr));
            delete pNewSipUrlHeader;
            return hr;
        }

        InsertTailList(&pSipUrl->m_HeaderList,
                       &pNewSipUrlHeader->m_ListEntry);
        
        pListEntry = pListEntry->Flink;
    }

    return S_OK;
}


void
SIP_URL::FreeOtherParamList()
{
    LIST_ENTRY      *pListEntry;
    SIP_URL_PARAM   *pSipUrlParam;

    while (!IsListEmpty(&m_OtherParamList))
    {
        pListEntry = RemoveHeadList(&m_OtherParamList);

        pSipUrlParam = CONTAINING_RECORD(pListEntry,
                                         SIP_URL_PARAM,
                                         m_ListEntry);
        delete pSipUrlParam;
    }
}


void
SIP_URL::FreeHeaderList()
{
    LIST_ENTRY        *pListEntry;
    SIP_HEADER_ENTRY  *pHeaderEntry;

    while (!IsListEmpty(&m_HeaderList))
    {
        pListEntry = RemoveHeadList(&m_HeaderList);

        pHeaderEntry = CONTAINING_RECORD(pListEntry,
                                         SIP_HEADER_ENTRY,
                                         ListEntry);
        delete pHeaderEntry;
    }
}


SIP_URL_PARAM::SIP_URL_PARAM()
{
    ZeroMemory(this, sizeof(*this));
    m_SipUrlParamId = SIP_URL_PARAM_UNKNOWN;
}


SIP_URL_PARAM::~SIP_URL_PARAM()
{
    if (m_ParamName.Buffer != NULL)
    {
        free(m_ParamName.Buffer);
    }

    if (m_ParamValue.Buffer != NULL)
    {
        free(m_ParamValue.Buffer);
    }
}


HRESULT
SIP_URL_PARAM::SetParamNameAndValue(
    IN SIP_URL_PARAM_ENUM    SipUrlParamId,
    IN COUNTED_STRING       *pParamName,
    IN COUNTED_STRING       *pParamValue
    )
{
    HRESULT hr;

    ENTER_FUNCTION("SIP_URL_PARAM::SetParamNameAndValue");
    m_SipUrlParamId = SipUrlParamId;

    hr = AllocCountedString(pParamName->Buffer,
                            pParamName->Length,
                            &m_ParamName);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s allocating m_ParamName failed",
             __fxName));
        return hr;
    }

    hr = AllocCountedString(pParamValue->Buffer,
                            pParamValue->Length,
                            &m_ParamValue);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s allocating m_ParamValue failed",
             __fxName));
        return hr;
    }
    
    return S_OK;
}


SIP_URL_HEADER::SIP_URL_HEADER()
{
    ZeroMemory(this, sizeof(*this));
    m_HeaderId = SIP_HEADER_UNKNOWN;
}


SIP_URL_HEADER::~SIP_URL_HEADER()
{
    if (m_HeaderName.Buffer != NULL)
    {
        free(m_HeaderName.Buffer);
    }

    if (m_HeaderValue.Buffer != NULL)
    {
        free(m_HeaderValue.Buffer);
    }
}


HRESULT
SIP_URL_HEADER::SetHeaderNameAndValue(
    IN SIP_HEADER_ENUM    HeaderId,
    IN COUNTED_STRING    *pHeaderName,
    IN COUNTED_STRING    *pHeaderValue
    )
{
    HRESULT hr;

    ENTER_FUNCTION("SIP_URL_HEADER::SetHeaderNameAndValue");
    m_HeaderId = HeaderId;

    hr = AllocCountedString(pHeaderName->Buffer,
                            pHeaderName->Length,
                            &m_HeaderName);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s allocating m_HeaderName failed",
             __fxName));
        return hr;
    }

    hr = AllocCountedString(pHeaderValue->Buffer,
                            pHeaderValue->Length,
                            &m_HeaderValue);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s allocating m_HeaderValue failed",
             __fxName));
        return hr;
    }
    
    return S_OK;
}


SIP_HEADER_PARAM::SIP_HEADER_PARAM()
{
    ZeroMemory(this, sizeof(*this));

    m_HeaderParamId = SIP_HEADER_PARAM_UNKNOWN;
}


SIP_HEADER_PARAM::~SIP_HEADER_PARAM()
{
    if (m_ParamName.Buffer != NULL)
    {
        free(m_ParamName.Buffer);
    }

    if (m_ParamValue.Buffer != NULL)
    {
        free(m_ParamValue.Buffer);
    }
}


HRESULT
SIP_HEADER_PARAM::SetParamNameAndValue(
    IN SIP_HEADER_PARAM_ENUM    HeaderParamId,
    IN COUNTED_STRING          *pParamName,
    IN COUNTED_STRING          *pParamValue
    )
{
    ENTER_FUNCTION("SIP_HEADER_PARAM::SetParamNameAndValue");

    HRESULT hr;
    
    m_HeaderParamId = HeaderParamId;

    hr = AllocCountedString(pParamName->Buffer,
                            pParamName->Length,
                            &m_ParamName);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s allocating m_ParamName failed",
             __fxName));
        return hr;
    }

    hr = AllocCountedString(pParamValue->Buffer,
                            pParamValue->Length,
                            &m_ParamValue);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s allocating m_ParamValue failed",
             __fxName));
        return hr;
    }
    
    return S_OK;
}
    

CONTACT_HEADER::CONTACT_HEADER()
{
    ZeroMemory(this, sizeof(*this));
}


CONTACT_HEADER::~CONTACT_HEADER()
{
    if (m_DisplayName.Buffer != NULL)
    {
        free(m_DisplayName.Buffer);
    }

    if (m_SipUrl.Buffer != NULL)
    {
        free(m_SipUrl.Buffer);
    }
}


VOID
FreeContactHeaderList(
    IN LIST_ENTRY *pContactHeaderList
    )
{
    LIST_ENTRY      *pListEntry;
    CONTACT_HEADER  *pContactHeader;

    while (!IsListEmpty(pContactHeaderList))
    {
        pListEntry = RemoveHeadList(pContactHeaderList);

        pContactHeader = CONTAINING_RECORD(pListEntry,
                                           CONTACT_HEADER,
                                           m_ListEntry);
        delete pContactHeader;
    }
}


FROM_TO_HEADER::FROM_TO_HEADER()
{
    ZeroMemory(this, sizeof(*this));

    InitializeListHead(&m_ParamList);
}


FROM_TO_HEADER::~FROM_TO_HEADER()
{
    if (m_DisplayName.Buffer != NULL)
    {
        free(m_DisplayName.Buffer);
    }

    if (m_SipUrl.Buffer != NULL)
    {
        free(m_SipUrl.Buffer);
    }

    if (m_TagValue.Buffer != NULL)
    {
        free(m_TagValue.Buffer);
    }

    FreeParamList();
}


void
FROM_TO_HEADER::FreeParamList()
{
    LIST_ENTRY         *pListEntry;
    SIP_HEADER_PARAM   *pSipHeaderParam;

    while (!IsListEmpty(&m_ParamList))
    {
        pListEntry = RemoveHeadList(&m_ParamList);

        pSipHeaderParam = CONTAINING_RECORD(pListEntry,
                                            SIP_HEADER_PARAM,
                                            m_ListEntry);
        delete pSipHeaderParam;
    }
}


RECORD_ROUTE_HEADER::RECORD_ROUTE_HEADER()
{
    ZeroMemory(this, sizeof(*this));

    InitializeListHead(&m_ParamList);
}


RECORD_ROUTE_HEADER::~RECORD_ROUTE_HEADER()
{
    if (m_DisplayName.Buffer != NULL)
    {
        free(m_DisplayName.Buffer);
    }

    if (m_SipUrl.Buffer != NULL)
    {
        free(m_SipUrl.Buffer);
    }

    FreeParamList();
}


void
RECORD_ROUTE_HEADER::FreeParamList()
{
    LIST_ENTRY         *pListEntry;
    SIP_HEADER_PARAM   *pSipHeaderParam;

    while (!IsListEmpty(&m_ParamList))
    {
        pListEntry = RemoveHeadList(&m_ParamList);

        pSipHeaderParam = CONTAINING_RECORD(pListEntry,
                                            SIP_HEADER_PARAM,
                                            m_ListEntry);
        delete pSipHeaderParam;
    }
}


// *pRecordRouteHeaderStr is allocated using malloc and needs to be
// freed using free() when it is not required.

HRESULT
RECORD_ROUTE_HEADER::GetString(
    OUT PSTR    *pRecordRouteHeaderStr,
    OUT ULONG   *pRecordRouteHeaderStrLen
    )
{
    MESSAGE_BUILDER     Builder;
    PSTR                RecordRouteHeaderStr;
    ULONG               RecordRouteHeaderStrLen;
    ULONG               RecordRouteHeaderStrBufLen;
    LIST_ENTRY         *pListEntry;
    SIP_HEADER_PARAM   *pSipHeaderParam;
    
    ENTER_FUNCTION("RECORD_ROUTE_HEADER::GetString");
    
    RecordRouteHeaderStrBufLen = 1; // '\0'
    RecordRouteHeaderStrBufLen += m_DisplayName.Length;
    RecordRouteHeaderStrBufLen += 2 + m_SipUrl.Length;

    pListEntry = m_ParamList.Flink;

    while (pListEntry != &m_ParamList)
    {
        pSipHeaderParam = CONTAINING_RECORD(pListEntry,
                                            SIP_HEADER_PARAM,
                                            m_ListEntry);
        RecordRouteHeaderStrBufLen +=
            pSipHeaderParam->m_ParamName.Length +
            pSipHeaderParam->m_ParamValue.Length + 2;

        pListEntry = pListEntry->Flink;
    }
    
    RecordRouteHeaderStr = (PSTR) malloc(RecordRouteHeaderStrBufLen);
    if (RecordRouteHeaderStr == NULL)
    {
        LOG((RTC_ERROR, "%s Allocating RecordRouteHeaderStr failed",
             __fxName));
        return E_OUTOFMEMORY;
    }

    Builder.PrepareBuild(RecordRouteHeaderStr, RecordRouteHeaderStrBufLen);

    if (m_DisplayName.Length != 0)
    {
        Builder.Append(&m_DisplayName);
    }

    if (m_SipUrl.Length != 0)
    {
        Builder.Append("<");
        Builder.Append(&m_SipUrl);
        Builder.Append(">");
    }
        
    pListEntry = m_ParamList.Flink;

    while (pListEntry != &m_ParamList)
    {
        pSipHeaderParam = CONTAINING_RECORD(pListEntry,
                                            SIP_HEADER_PARAM,
                                            m_ListEntry);
        Builder.Append(";");
        Builder.Append(&pSipHeaderParam->m_ParamName);
        if (pSipHeaderParam->m_ParamValue.Length != 0)
        {
            Builder.Append("=");
            Builder.Append(&pSipHeaderParam->m_ParamValue);
        }

        pListEntry = pListEntry->Flink;
    }

    if (Builder.OverflowOccurred())
    {
        LOG((RTC_TRACE,
             "%s - not enough buffer space -- need %u bytes, got %u\n",
             __fxName, Builder.GetLength(), RecordRouteHeaderStrBufLen));
        ASSERT(FALSE);

        free(RecordRouteHeaderStr);
        RecordRouteHeaderStr = NULL;
        return E_FAIL;
    }
    
    RecordRouteHeaderStrLen = Builder.GetLength();
    RecordRouteHeaderStr[RecordRouteHeaderStrLen] = '\0';

    LOG((RTC_TRACE, "%s RecordRouteHeaderStr %s len: %d BufLen: %d",
         __fxName, RecordRouteHeaderStr, RecordRouteHeaderStrLen,
         RecordRouteHeaderStrBufLen));

    *pRecordRouteHeaderStr    = RecordRouteHeaderStr;
    *pRecordRouteHeaderStrLen = RecordRouteHeaderStrLen;

    return S_OK;
}
#define SIP_URLPARAM_DEFAULT_TRANSPORT "udp"
#define SIP_URLPARAM_DEFAULT_USER "ip"
#define SIP_URLPARAM_DEFAULT_METHOD "INVITE"
#define SIP_URLPARAM_DEFAULT_TTL "1"

BOOL
AreKnownParamsOfSipUrlsEqual(
    IN SIP_URL *pSipUrl1,
    IN SIP_URL *pSipUrl2
    )
{
    int i;
    PSTR pUrlParam = NULL;
    int  urlParamLen = 0;
    ENTER_FUNCTION("AreKnownParamsOfSipUrlsEqual");
    for (i = 0; i < SIP_URL_PARAM_MAX; i++)
    {
        if (pSipUrl1->m_KnownParams[i].Buffer != NULL || 
            pSipUrl2->m_KnownParams[i].Buffer != NULL)
        {
            if (pSipUrl1->m_KnownParams[i].Buffer != NULL && 
                pSipUrl2->m_KnownParams[i].Buffer != NULL)
            {
                if(pSipUrl1->m_KnownParams[i].Length != 
                    pSipUrl2->m_KnownParams[i].Length ||
                    _strnicmp(pSipUrl1->m_KnownParams[i].Buffer, 
                        pSipUrl2->m_KnownParams[i].
                        Buffer,pSipUrl1->m_KnownParams[i].Length)) 
                {
                    LOG((RTC_ERROR,
                        "%s - m_KnownParams[%d] Parameter of URI does not match "
                        "Length1 = %d Length2 = %d",
                        __fxName, i,
                        pSipUrl1->m_KnownParams[i].Length,
                        pSipUrl2->m_KnownParams[i].Length));
                    return FALSE;
                }
            }
            else
            {
                //One of the url params must be NULL
                switch (i)
                {   
                    case SIP_URL_PARAM_METHOD:
                        pUrlParam = SIP_URLPARAM_DEFAULT_METHOD;
                        urlParamLen = sizeof(SIP_URLPARAM_DEFAULT_METHOD) -1;
                        break;
                    case SIP_URL_PARAM_TRANSPORT:
                        pUrlParam = SIP_URLPARAM_DEFAULT_TRANSPORT;
                        urlParamLen = sizeof(SIP_URL_PARAM_TRANSPORT)-1;
                        break;

                    case SIP_URL_PARAM_TTL:
                        pUrlParam = SIP_URLPARAM_DEFAULT_TTL;
                        urlParamLen = sizeof(SIP_URL_PARAM_TTL)-1;
                        break;
                    case SIP_URL_PARAM_USER:
                        pUrlParam = SIP_URLPARAM_DEFAULT_USER;
                        urlParamLen = sizeof(SIP_URL_PARAM_USER)-1;
                        break;
                    case SIP_URL_PARAM_MADDR:
                    case SIP_URL_PARAM_UNKNOWN:
                    default:
                        LOG((RTC_ERROR,
                            "%s - m_KnownParams[%d] Parameter of URI does not match ",
                            __fxName, i));
                        return FALSE;

                }
                if(pSipUrl1->m_KnownParams[i].Buffer != NULL &&
                   pSipUrl1->m_KnownParams[i].Length != 0 )
                {
                    if(pSipUrl1->m_KnownParams[i].Length != 
                        urlParamLen ||
                        _strnicmp(pSipUrl1->m_KnownParams[i].Buffer,
                        pUrlParam, 
                        pSipUrl1->m_KnownParams[i].Length) 
                        )
                    {
                        LOG((RTC_ERROR,
                            "%s pSipUrl1- m_KnownParams[%d] Parameter of URI does not match ",
                            __fxName, i
                            ));
                        return FALSE;
                    }
                }
                if(pSipUrl2->m_KnownParams[i].Buffer != NULL &&
                    pSipUrl2->m_KnownParams[i].Length != 0)
                {
                    if(pSipUrl2->m_KnownParams[i].Length != 
                        urlParamLen ||
                        _strnicmp(pSipUrl2->m_KnownParams[i].Buffer,
                        pUrlParam, 
                        pSipUrl2->m_KnownParams[i].Length) 
                        )
                    {
                        LOG((RTC_ERROR,
                            "%s pSipUrl2- m_KnownParams[%d] Parameter of URI does not match ",
                            __fxName, i
                            ));
                        return FALSE;
                    }
                }
                pUrlParam = NULL;
                urlParamLen = 0;
            }
        }
    }
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// Comparison functions
///////////////////////////////////////////////////////////////////////////////

// user, password, host, port and any url-parameter parameters of the
// URI must match.
// Compare with default values if a particular field is not present.
//
// XXX TODO Characters other than those in the reserved and unsafe sets (see
// RFC 2396 [12]) are equivalent to their % HEX HEX encoding.

// The ordering of parameters and headers is not significant in
// comparing SIP URLs.

// Comparisons of scheme name (sip), domain names, parameter
// names and header names are case-insensitive, all other comparisons
// are case-sensitive.

BOOL
AreSipUrlsEqual(
    IN SIP_URL *pSipUrl1,
    IN SIP_URL *pSipUrl2
    )
{
    int i;
    LIST_ENTRY *pListEntry1;
    LIST_ENTRY *pListEntry2;
    SIP_URL_PARAM      *pSipUrlParam1;
    SIP_URL_PARAM      *pSipUrlParam2;
    SIP_URL_HEADER     *pSipHeaderParam1;
    SIP_URL_HEADER     *pSipHeaderParam2;

    ENTER_FUNCTION("AreSipUrlsEqual");
    if(pSipUrl1->m_User.Length != pSipUrl2->m_User.Length ||
        strncmp(pSipUrl1->m_User.Buffer, pSipUrl2->m_User.Buffer,
                pSipUrl1->m_User.Length)) 
    {
         LOG((RTC_ERROR,
             "%s - User Parameter of URI does not match %s %s",
             __fxName, 
             pSipUrl1->m_User.Buffer,
             pSipUrl2->m_User.Buffer));
         return FALSE;
    }
    if(pSipUrl1->m_Password.Length != pSipUrl2->m_Password.Length ||
        strncmp(pSipUrl1->m_Password.Buffer, pSipUrl2->m_Password.Buffer,
                pSipUrl1->m_Password.Length)) 
    {
         LOG((RTC_ERROR,
             "%s - Password Parameter of URI does not match ",
             __fxName));
         return FALSE;
    }
    if(pSipUrl1->m_Host.Length != pSipUrl2->m_Host.Length ||
        strncmp(pSipUrl1->m_Host.Buffer, pSipUrl2->m_Host.Buffer,
                pSipUrl1->m_Host.Length)) 
    {
         LOG((RTC_ERROR,
             "%s - Host Parameter of URI does not match ",
             __fxName));
         return FALSE;
    }

    //For Transport Unknown, the actual strings are compared in AreKnownParamsOfSipUrlsEqual
    SIP_TRANSPORT sipUrl1Transport; 
    SIP_TRANSPORT sipUrl2Transport;
    if(pSipUrl1->m_TransportParam == SIP_TRANSPORT_UNKNOWN)
        sipUrl1Transport = SIP_TRANSPORT_UDP;
    else 
        sipUrl1Transport = pSipUrl1->m_TransportParam;

    if(pSipUrl2->m_TransportParam == SIP_TRANSPORT_UNKNOWN)
        sipUrl2Transport = SIP_TRANSPORT_UDP;
    else 
        sipUrl2Transport = pSipUrl2->m_TransportParam;

    if((pSipUrl1->m_Port == 0 && pSipUrl2->m_Port == 0) || 
       (pSipUrl1->m_Port == 0 && pSipUrl2->m_Port ==  GetSipDefaultPort(sipUrl2Transport)) ||
       (pSipUrl2->m_Port == 0 && pSipUrl1->m_Port ==  GetSipDefaultPort(sipUrl1Transport)))
    {
        //do nothing
        LOG((RTC_TRACE,
             "%s - Port Parameter is defaults",
             __fxName));
    }
    else if(pSipUrl1->m_Port != pSipUrl2->m_Port)
    {
         LOG((RTC_ERROR,
             "%s - Port Parameter of URI does not match ",
             __fxName));
         return FALSE;
    }
    if(sipUrl1Transport != sipUrl2Transport)
    {
         LOG((RTC_ERROR,
             "%s - Transport Parameter of URI does not match"
             "URL1 Transport %d URL2 Transport %d",
             __fxName, sipUrl1Transport, sipUrl2Transport));
         return FALSE;
    }
    if(AreKnownParamsOfSipUrlsEqual(pSipUrl1,pSipUrl2) == FALSE)
    {
        LOG((RTC_ERROR,
            "%s - m_KnownParams Parameter of URI does not match ",
            __fxName));
        return FALSE;
    }
    
    //XXXXTODO Change the Otherparam list to reflect comparison with value
    
    pListEntry1 = pSipUrl1->m_OtherParamList.Flink;
    //Ordering of parameters is not significant. So we search the 
    //pListEntry2 for corresponding ParamId and then do the comparison
    while (pListEntry1 != &pSipUrl1->m_OtherParamList)
    {
        pSipUrlParam1 = CONTAINING_RECORD(pListEntry1,
                                            SIP_URL_PARAM,
                                            m_ListEntry);
        pListEntry2 = pSipUrl2->m_OtherParamList.Flink;
        do
        {
            pSipUrlParam2 = CONTAINING_RECORD(pListEntry2,
                                                SIP_URL_PARAM,
                                                m_ListEntry);
            pListEntry2 = pListEntry2->Flink;            
        }
        while(pSipUrlParam2 != NULL &&
            pSipUrlParam1->m_SipUrlParamId != pSipUrlParam2->m_SipUrlParamId &&
            pListEntry2 != &pSipUrl2->m_OtherParamList);
        
        if(pSipUrlParam2 == NULL ||
            pSipUrlParam1->m_SipUrlParamId != pSipUrlParam2->m_SipUrlParamId)
        {
            LOG((RTC_ERROR,
                "%s - SipURLParam Parameter ID of URI does not match ",
                __fxName));
            return FALSE;
        }
        //Name comparison should be case insensitive
        if(pSipUrlParam1->m_ParamName.Length != 
            pSipUrlParam2->m_ParamName.Length ||
            _strnicmp(pSipUrlParam1->m_ParamName.Buffer, 
                    pSipUrlParam2->m_ParamName.Buffer,
                    pSipUrlParam1->m_ParamName.Length)) 
        {
            LOG((RTC_ERROR,
                "%s - m_ParamName Parameter of Param ID: %d does not match ",
                __fxName, pSipUrlParam1->m_SipUrlParamId));
            return FALSE;
        }
        if(pSipUrlParam1->m_ParamValue.Length != 
            pSipUrlParam2->m_ParamValue.Length ||
            strncmp(pSipUrlParam1->m_ParamValue.Buffer, 
                    pSipUrlParam2->m_ParamValue.Buffer,
                    pSipUrlParam1->m_ParamValue.Length)) 
        {
            LOG((RTC_ERROR,
                "%s - m_ParamValue Parameter of Param ID: %d does not match ",
                __fxName, pSipUrlParam1->m_SipUrlParamId));
            return FALSE;
        }
        pListEntry1 = pListEntry1->Flink;
    }

    pListEntry1 = pSipUrl1->m_HeaderList.Flink;
    //Ordering of parameters is not significant. So we search the 
    //pListEntry2 for corresponding ParamId and then do the comparison
    while (pListEntry1 != &pSipUrl1->m_HeaderList)
    {
        pSipHeaderParam1 = CONTAINING_RECORD(pListEntry1,
                                                SIP_URL_HEADER,
                                                m_ListEntry);
        
        pListEntry2 = pSipUrl2->m_HeaderList.Flink;
        do
        {
            pSipHeaderParam2 = CONTAINING_RECORD(pListEntry2,
                                                    SIP_URL_HEADER,
                                                    m_ListEntry);
            pListEntry2 = pListEntry2->Flink;            
        }
        while(pSipHeaderParam2 != NULL &&
            pSipHeaderParam1->m_HeaderId != pSipHeaderParam2->m_HeaderId &&
            pListEntry2 != &pSipUrl2->m_HeaderList);
        
        if(pSipHeaderParam2 == NULL ||
            pSipHeaderParam1->m_HeaderId != pSipHeaderParam2->m_HeaderId)
        {
            LOG((RTC_ERROR,
                "%s - SipHeaderParam Parameter ID of URI does not match ",
                __fxName));
            return FALSE;
        }
        //Name comparison should be case insensitive
        if(pSipHeaderParam1->m_HeaderName.Length != 
            pSipHeaderParam2->m_HeaderName.Length ||
            _strnicmp(pSipHeaderParam1->m_HeaderName.Buffer, 
                    pSipHeaderParam2->m_HeaderName.Buffer,
                    pSipHeaderParam1->m_HeaderName.Length)) 
        {
            LOG((RTC_ERROR,
                "%s - m_HeaderName Parameter of Param ID: %d does not match ",
                __fxName, pSipHeaderParam1->m_HeaderId));
            return FALSE;
        }
        if(pSipHeaderParam1->m_HeaderValue.Length != 
            pSipHeaderParam2->m_HeaderValue.Length ||
            strncmp(pSipHeaderParam1->m_HeaderValue.Buffer, 
                    pSipHeaderParam2->m_HeaderValue.Buffer,
                    pSipHeaderParam1->m_HeaderValue.Length)) 
        {
            LOG((RTC_ERROR,
                "%s - m_HeaderValue Parameter of Param ID: %d does not match ",
                __fxName, pSipHeaderParam1->m_HeaderId));
            return FALSE;
        }
        pListEntry1 = pListEntry1->Flink;
    }
   return TRUE;
}


// URIs should match and the header parameters (such as contact-param,
// from-param and to-param) match in name and parameter value, where
// parameter names and token parameter values are compared ignoring
// case and quoted-string parameter values are case-sensitive.

//For the response, It is assumed that the stored remote/local is always pFromToHeader1

BOOL
AreFromToHeadersEqual(
    IN FROM_TO_HEADER *pFromToHeader1,
    IN FROM_TO_HEADER *pFromToHeader2,
    IN BOOL isResponse,
    BOOL fCompareTag
    )
{
    ULONG BytesParsed = 0;
    HRESULT hr;
    SIP_URL        SipUrl1;
    SIP_URL        SipUrl2;
    LIST_ENTRY             *pListEntry1;
    LIST_ENTRY             *pListEntry2;
    SIP_HEADER_PARAM   *pSipHeaderParam1;
    SIP_HEADER_PARAM   *pSipHeaderParam2;

    ASSERT(pFromToHeader1 != NULL);
    ASSERT(pFromToHeader2 != NULL);

    ENTER_FUNCTION("AreFromToHeadersEqual");

    //During the first 200 OK, the stored remote need not have the tag value
    if((!isResponse || pFromToHeader1->m_TagValue.Length != 0)&& fCompareTag)
    {
        if(pFromToHeader1->m_TagValue.Length != 
            pFromToHeader2->m_TagValue.Length ||
            strncmp(pFromToHeader1->m_TagValue.Buffer, 
                    pFromToHeader2->m_TagValue.Buffer, 
                    pFromToHeader1->m_TagValue.Length))
        {
            LOG((RTC_ERROR,
                 "%s - Tag is not the same",
                 __fxName));
            return FALSE;
        }
    }

    hr = ParseSipUrl(
        pFromToHeader1->m_SipUrl.Buffer,
        pFromToHeader1->m_SipUrl.Length,
        &BytesParsed,
        &SipUrl1
        );
    BytesParsed = 0;
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s pFromToHeader1 URI parsing failed failed %x",
            __fxName, hr));
        return FALSE;
    }

    hr = ParseSipUrl(
        pFromToHeader2->m_SipUrl.Buffer,
        pFromToHeader2->m_SipUrl.Length,
        &BytesParsed,
        &SipUrl2
        );
    BytesParsed = 0;
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s pFromToHeader2 URI parsing failed failed %x",
            __fxName, hr));
        return FALSE;
    }

    if(!AreSipUrlsEqual(&SipUrl1, &SipUrl2))
    {
        LOG((RTC_ERROR,
             "%s - FromTo Header match failed in SIP URL",
             __fxName));
        return FALSE;
    }

    pListEntry1 = pFromToHeader1->m_ParamList.Flink;
    //Ordering of parameters is not significant. So we search the 
    //pListEntry2 for corresponding ParamId and then do the comparison
    while (pListEntry1 != &pFromToHeader1->m_ParamList)
    {
        pSipHeaderParam1 = CONTAINING_RECORD(pListEntry1,
                                                SIP_HEADER_PARAM,
                                                m_ListEntry);
        
        pListEntry2 = pFromToHeader2->m_ParamList.Flink;
        do
        {
            pSipHeaderParam2 = CONTAINING_RECORD(pListEntry2,
                                                SIP_HEADER_PARAM,
                                                m_ListEntry);
            pListEntry2 = pListEntry2->Flink;            
        }
        while(pSipHeaderParam2 != NULL &&
            pSipHeaderParam1->m_HeaderParamId != 
                pSipHeaderParam2->m_HeaderParamId &&
            pListEntry2 != &pFromToHeader2->m_ParamList);
                
        if(pSipHeaderParam2 == NULL ||
            pSipHeaderParam1->m_HeaderParamId != pSipHeaderParam2->m_HeaderParamId)
        {
            LOG((RTC_ERROR,
                "%s - SipHeaderParam Parameter ID of URI does not match ",
                __fxName));
            return FALSE;
        }
        //Name comparison should be case insensitive
        if(pSipHeaderParam1->m_ParamName.Length != 
            pSipHeaderParam2->m_ParamName.Length ||
            _strnicmp(pSipHeaderParam1->m_ParamName.Buffer, 
                    pSipHeaderParam2->m_ParamName.Buffer,
                    pSipHeaderParam1->m_ParamName.Length)) 
        {
            LOG((RTC_ERROR,
                "%s - m_ParamName Parameter of Param ID: %d does not match ",
                __fxName, pSipHeaderParam1->m_HeaderParamId));
            return FALSE;
        }
        if(pSipHeaderParam1->m_ParamValue.Length == 0 &&
                pSipHeaderParam2->m_ParamValue.Length ==0)
        {
            //do nothing
        }
        else if(pSipHeaderParam1->m_ParamValue.Length != 
                pSipHeaderParam2->m_ParamValue.Length)
        {
            LOG((RTC_ERROR,
                "%s - m_ParamValue Parameter of Param ID: %d does not match ",
                __fxName, pSipHeaderParam1->m_HeaderParamId));
            return FALSE;
        }
        else
        {
            if(*(pSipHeaderParam1->m_ParamValue.Buffer) != QUOTE)
            {
                if(_strnicmp(pSipHeaderParam1->m_ParamValue.Buffer, 
                        pSipHeaderParam2->m_ParamValue.Buffer,
                        pSipHeaderParam1->m_ParamValue.Length)) 
                {
                    LOG((RTC_ERROR,
                        "%s - m_ParamValue Parameter of Param ID: %d does not match ",
                        __fxName, pSipHeaderParam1->m_HeaderParamId));
                    return FALSE;
                }

            }
            else
            {
                //Do case sensitive comparison for quote
                if( strncmp(pSipHeaderParam1->m_ParamValue.Buffer, 
                        pSipHeaderParam2->m_ParamValue.Buffer,
                        pSipHeaderParam1->m_ParamValue.Length)) 
                {
                    LOG((RTC_ERROR,
                        "%s - m_ParamValue Parameter of Param ID: %d does not match ",
                        __fxName, pSipHeaderParam1->m_HeaderParamId));
                    return FALSE;
                }
            }
        }

        pListEntry1 = pListEntry1->Flink;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\siputil.h ===
#ifndef __sipcli_siputil_h__
#define __sipcli_siputil_h__

// 0,1,2,3 : count of bytes from MSB to LSB in host order
#define BYTE0(l) ((BYTE)((DWORD)(l) >> 24))
#define BYTE1(l) ((BYTE)((DWORD)(l) >> 16))
#define BYTE2(l) ((BYTE)((DWORD)(l) >> 8))
#define BYTE3(l) ((BYTE)((DWORD)(l)))

// Handy macro to use in printf statements
#define BYTES0123(l) BYTE0(l), BYTE1(l), BYTE2(l), BYTE3(l)

// 0,1,2,3 : count of bytes from MSB to LSB in network order
#define NETORDER_BYTE0(l) ((BYTE)((BYTE *) &l)[0])
#define NETORDER_BYTE1(l) ((BYTE)((BYTE *) &l)[1])
#define NETORDER_BYTE2(l) ((BYTE)((BYTE *) &l)[2])
#define NETORDER_BYTE3(l) ((BYTE)((BYTE *) &l)[3])

// Handy macro to use in printf statements
#define NETORDER_BYTES0123(l)                   \
    NETORDER_BYTE0(l), NETORDER_BYTE1(l),       \
    NETORDER_BYTE2(l), NETORDER_BYTE3(l)

#define PRINT_SOCKADDR(pSockAddr)                       \
    NETORDER_BYTES0123(((pSockAddr)->sin_addr.s_addr)), \
    ntohs((pSockAddr)->sin_port)

#define PRINTABLE_STRING_A(Str) \
    (((Str) == NULL) ? "NULL" : (Str))

#define PRINTABLE_STRING_W(WStr) \
    (((WStr) == NULL) ? L"NULL" : (WStr))

inline BOOL
AreSockaddrEqual(
    IN SOCKADDR_IN *pAddr1,
    IN SOCKADDR_IN *pAddr2
    )
{
    return (pAddr1->sin_addr.s_addr == pAddr2->sin_addr.s_addr &&
            pAddr1->sin_port == pAddr2->sin_port);
}

inline BOOL
AreCountedStringsEqual(
    IN  PSTR    String1,
    IN  ULONG   StringLen1,
    IN  PSTR    String2,
    IN  ULONG   StringLen2,
    IN  BOOL    fIsCaseSensitive
    )
{
    return (StringLen1 == StringLen2 &&
            ((fIsCaseSensitive &&
              strncmp(String1, String2, StringLen1) == 0) ||
             (!fIsCaseSensitive &&
              _strnicmp(String1, String2, StringLen1) == 0)));
}


// DefaultString is the string to compare to if either
// String1 or String2 is NULL
inline BOOL
AreCountedStringsEqualEx(
    IN  PSTR    String1,
    IN  ULONG   StringLen1,
    IN  PSTR    String2,
    IN  ULONG   StringLen2,
    IN  PSTR    DefaultString,
    IN  ULONG   DefaultStringLen,
    IN  BOOL    fIsCaseSensitive
    )
{
    // This will take care of the case when both are NULL.
    if (String1    == String2 &&
        StringLen1 == StringLen2)
    {
        return TRUE;
    }
    else if (String1 == NULL)
    {
        return AreCountedStringsEqual(
                   String2, StringLen2,
                   DefaultString, DefaultStringLen,
                   fIsCaseSensitive
                   );
    }
    else if (String2 == NULL)
    {
        return AreCountedStringsEqual(
                   String1, StringLen1,
                   DefaultString, DefaultStringLen,
                   fIsCaseSensitive
                   );
    }
    else
    {
        return AreCountedStringsEqual(
                   String1, StringLen1,
                   String2, StringLen2,
                   fIsCaseSensitive
                   );
    }
}


// Returns listen port for the protocol in host order.

inline WORD
GetSipDefaultPort(
    IN SIP_TRANSPORT Transport
    )
{
    switch(Transport)
    {
    case SIP_TRANSPORT_UDP:
        return SIP_DEFAULT_UDP_PORT;

    case SIP_TRANSPORT_TCP:
        return SIP_DEFAULT_TCP_PORT;

    case SIP_TRANSPORT_SSL:
        return SIP_DEFAULT_SSL_PORT;
        
    default:
        ASSERT(FALSE);
        return SIP_DEFAULT_UDP_PORT;
    }
}


inline PSTR
GetTransportText(
    IN SIP_TRANSPORT Transport,
    IN BOOL          fIsUpperCase
    )
{
    switch(Transport)
    {
    case SIP_TRANSPORT_UDP:
        if (fIsUpperCase)
            return "UDP";
        else
            return "udp";

    case SIP_TRANSPORT_TCP:
        if (fIsUpperCase)
            return "TCP";
        else
            return "tcp";

    case SIP_TRANSPORT_SSL:
        if (fIsUpperCase)
            return "TLS";
        else
            return "tls";
        
    default:
        ASSERT(FALSE);
        return "Unknown";
    }
}

HRESULT UnicodeToUTF8(
    IN  LPCWSTR UnicodeString,
    OUT PSTR   *pString,
    OUT ULONG  *pStringLength
    );

HRESULT UTF8ToUnicode(
    IN  LPSTR    UTF8String,
    IN  ULONG    UTF8StringLength,
    OUT LPWSTR  *pString
    );

HRESULT UTF8ToBstr(
    IN  LPSTR    UTF8String,
    IN  ULONG    UTF8StringLength,
    OUT BSTR    *pbstrString
    );

void
GetNumberStringFromUuidString( 
	IN	OUT	PSTR	UuidStr, 
	IN		DWORD	UuidStrLen 
	);

HRESULT
CreateUuid(
    OUT PSTR   *pUuidStr,
    OUT ULONG  *pUuidStrLen
    );

HRESULT
GetNullTerminatedString(
    IN  PSTR    String,
    IN  ULONG   StringLen,
    OUT PSTR   *pszString
    );

HRESULT
AllocString(
    IN  PSTR    String,
    IN  ULONG   StringLen,
    OUT PSTR   *pszString,
    OUT ULONG  *pStringLen
    );

HRESULT
AllocCountedString(
    IN  PSTR            String,
    IN  ULONG           StringLen,
    OUT COUNTED_STRING *pCountedString
    );

//  HRESULT
//  AllocAndCopyString(
//      IN  PSTR   sz,
//      IN  ULONG  szLen,
//      OUT PSTR  *pszNew
//      );

void
ReverseList(
    IN LIST_ENTRY *pListHead
    );

void
MoveListToNewListHead(
    IN OUT LIST_ENTRY *pOldListHead,
    IN OUT LIST_ENTRY *pNewListHead    
    );

DWORD
GetNextLine( 
    OUT PSTR * ppBlock,
    IN  PSTR   pLine, 
    IN  DWORD  dwBlockLen 
    );

DWORD
SkipNewLines( 
    OUT PSTR * ppBlock,
    IN  DWORD dwBlockLen
    );

HRESULT
SkipNextWord( 
    OUT PSTR * ppBlock
    );

HRESULT
GetNextWord(
    OUT PSTR * ppBlock,
    IN  PSTR   pWordBuf,
    IN  DWORD  dwWordBufSize
    );

LPWSTR
RemoveVisualSeparatorsFromPhoneNo(
    IN LPWSTR PhoneNo
    );

HRESULT
AddEscapeSequence(
    IN  OUT PSTR   *pString,
    IN  OUT ULONG  *pStringLength,
    IN      ULONG   startIndex,
    IN      ULONG   endIndex
    );

int
IntValToAscii(
    int ch
    );

NTSTATUS
base64encode(
    IN  VOID *  pDecodedBuffer,
    IN  DWORD   cbDecodedBufferSize,
    OUT LPSTR   pszEncodedString,
    IN  DWORD   cchEncodedStringSize,
    OUT DWORD * pcchEncoded             OPTIONAL
    );

//presence related xml parsing functions/ definitions
#define IsCRLFPresent( pBlock )     ( (*pBlock == RETURN_CHAR) && (*(pBlock+1) == NEWLINE_CHAR) )
#define NEWLINE_CHAR                '\n'
#define RETURN_CHAR                 '\r'
#define NULL_CHAR                   '\0'
#define BLANK_CHAR                  ' '
#define TAB_CHAR                    '\t'
#define OPEN_PARENTH_CHAR           '('
#define CLOSE_PARENTH_CHAR          ')'
#define QUOTE_CHAR                  '"'

__inline DWORD SkipWhiteSpaces(
    PSTR& pXMLBlobTag 
    )
{
    DWORD   dwCharsSkipped = 0;

    //skip white spaces
    while( (*pXMLBlobTag == BLANK_CHAR) || (*pXMLBlobTag == TAB_CHAR) )
    {
        pXMLBlobTag++;
        dwCharsSkipped++;
    }

    return dwCharsSkipped;
}


__inline DWORD SkipWhiteSpacesAndNewLines(
    PSTR& pXMLBlobTag
    )
{
    DWORD   dwCharsSkipped = 0;

    // Skip white spaces.
    while(  (*pXMLBlobTag == BLANK_CHAR) ||
            (*pXMLBlobTag == TAB_CHAR) || 
            (*pXMLBlobTag == NEWLINE_CHAR) ||
            (*pXMLBlobTag == RETURN_CHAR))
    {
        pXMLBlobTag++;
        dwCharsSkipped++;
    }

    return dwCharsSkipped;
}


HRESULT
GetNextTag(
    IN  PSTR&   pstrBlob, 
    OUT PSTR    pXMLBlobTag, 
    IN  DWORD   dwXMLBlobLen,
    OUT DWORD&  dwTagLen
    );

VOID
SkipUnknownTags(
    IN  PSTR&   pstrXMLBlob,
    OUT PSTR    pXMLBlobTag,
    IN  DWORD   dwXMLBlobLen
    );

int
GetEscapeChar( 
    CHAR hiChar,
    CHAR loChar
    );

void
RemoveEscapeChars( 
    PSTR    pWordBuf,
    DWORD   dwLen
    );

HRESULT
GetNextWord(
    OUT PSTR * ppBlock,
    IN  PSTR   pWordBuf,
    IN  DWORD  dwWordBufSize
    );


#endif // __sipcli_siputil_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\sipstack.h ===
#ifndef __sipcli_sipstack_h__
#define __sipcli_sipstack_h__

// Messages posted to the SIP stack window
#define WM_SIP_STACK_IPADDR_CHANGE                           (WM_USER + 0)
#define WM_SIP_STACK_NAT_ADDR_CHANGE                         (WM_USER + 1)
#define WM_SIP_STACK_TRANSACTION_SOCKET_ERROR                (WM_USER + 2)
#define WM_SIP_STACK_TRANSACTION_REQ_SOCK_CONNECT_COMPLETE   (WM_USER + 3)

#define DEFAULT_PROVIDER_PROFILE_ARRAY_SIZE     8
#define MAX_DYNAMIC_LISTEN_SOCKET_REGISTER_PORT_RETRY        20
#include "msgproc.h"

class SIP_MSG_PROCESSOR;
class SIP_CALL;
class REGISTER_CONTEXT;
class CSIPBuddy;
class CSIPWatcher;

template <class T, DWORD INITIAL_SIZE = 8, DWORD DELTA_SIZE = 8>
class CSIPArray
{

protected:
    T* m_aT;
    int m_nSize;
    int m_nAllocSize;

public:

    // Construction/destruction
    CSIPArray() : m_aT(NULL), m_nSize(0), m_nAllocSize(0)
    { }

    ~CSIPArray()
    {
        RemoveAll();
    }


    // Operations
    int GetSize() const
    {
        return m_nSize;
    }
    BOOL Grow()
    {
        T* aT;
        int nNewAllocSize = 
            (m_nAllocSize == 0) ? INITIAL_SIZE : (m_nSize + DELTA_SIZE);

        aT = (T*)realloc(m_aT, nNewAllocSize * sizeof(T));
        if(aT == NULL)
            return FALSE;
        m_nAllocSize = nNewAllocSize;
        m_aT = aT;
        return TRUE;
    }

    BOOL Add(T& t)
    {
        if(m_nSize == m_nAllocSize)
        {
            if (!Grow()) return FALSE;
        }
        m_nSize++;
        SetAtIndex(m_nSize - 1, t);
        return TRUE;
    }
    
    BOOL Remove(T& t)
    {
        int nIndex = Find(t);
        if(nIndex == -1)
            return FALSE;
        return RemoveAt(nIndex);
    }
    
    BOOL RemoveAt(int nIndex)
    {
        if(nIndex != (m_nSize - 1))
            memmove((void*)&m_aT[nIndex], (void*)&m_aT[nIndex + 1], 
                (m_nSize - (nIndex + 1)) * sizeof(T));
        m_nSize--;
        return TRUE;
    }
    void RemoveAll()
    {
        if(m_nAllocSize > 0)
        {
            free(m_aT);
            m_aT = NULL;
            m_nSize = 0;
            m_nAllocSize = 0;
        }
    }
    T& operator[] (int nIndex) const
    {
        ASSERT(nIndex >= 0 && nIndex < m_nSize);
        return m_aT[nIndex];
    }
    T* GetData() const
    {
        return m_aT;
    }
    
    // Implementation
    void SetAtIndex(int nIndex, T& t)
    {
        ASSERT(nIndex >= 0 && nIndex < m_nSize);
        m_aT[nIndex] = t;
    }
    int Find(T& t) const
    {
        for(int i = 0; i < m_nSize; i++)
        {
            if(m_aT[i] == t)
                return i;
        }
        return -1;  // not found
    }
};

struct SIP_LISTEN_SOCKET
{
    SIP_LISTEN_SOCKET(
        IN DWORD         IpAddr,
        IN ASYNC_SOCKET *pDynamicPortUdpSocket,
        IN ASYNC_SOCKET *pDynamicPortTcpSocket,
        IN ASYNC_SOCKET *pStaticPortUdpSocket,
        IN ASYNC_SOCKET *pStaticPortTcpSocket,
        IN LIST_ENTRY   *pListenSocketList
        );
    ~SIP_LISTEN_SOCKET();

    VOID DeregisterPorts(
         IN IDirectPlayNATHelp *pDirectPlayNatHelp
         );
    
    LIST_ENTRY          m_ListEntry;

    // In network byte order.
    DWORD               m_IpAddr;
    
    ASYNC_SOCKET       *m_pDynamicPortUdpSocket;
    ASYNC_SOCKET       *m_pDynamicPortTcpSocket;
    ASYNC_SOCKET       *m_pStaticPortUdpSocket;
    ASYNC_SOCKET       *m_pStaticPortTcpSocket;

    // This address is the public address on the NAT
    // when using PAST/UPnP.
    // Mappings on the NAT are established for the dynamic ports only.
    SOCKADDR_IN         m_PublicUdpListenAddr;
    SOCKADDR_IN         m_PublicTcpListenAddr;

    // This address is the public address mapped on the local firewall
    // when using PAST/UPnP.
    SOCKADDR_IN         m_LocalFirewallUdpListenAddr;
    SOCKADDR_IN         m_LocalFirewallTcpListenAddr;
    
    DPNHHANDLE          m_NatUdpPortHandle;
    DPNHHANDLE          m_NatTcpPortHandle;

    BOOL                m_fIsFirewallEnabled;
    BOOL                m_fIsUpnpNatPresent;
    BOOL                m_fIsGatewayLocal;

    // Used when processing IP address table changes.
    BOOL                m_IsPresentInNewIpAddrTable;
    BOOL                m_NeedToUpdatePublicListenAddr;
};


//
// SECURITY_CHALLENGE represents the contents of the challenge from the server.
// This is sent in the 401 response from an HTTP or SIP server.
//

struct  SECURITY_CHALLENGE
{
    SIP_AUTH_PROTOCOL   AuthProtocol;
    ANSI_STRING         Realm;
    ANSI_STRING         QualityOfProtection;
    ANSI_STRING         Nonce;
    ANSI_STRING         Algorithm;
    ANSI_STRING         GssapiData;
    ANSI_STRING         Opaque;
};

//
// SECURITY_PARAMETERS represents the information that is available to the client
// when the client responds to a challenge.
//
// Username and Password are the clear-text credentials of the user.
// RequestMethod and RequestURI represent the HTTP/SIP method and URI.
// ClientNonce is a nonce -- an arbitrary value chosen by the client.
//

struct  SECURITY_PARAMETERS
{
    ANSI_STRING     Username;
    ANSI_STRING     Password;
    ANSI_STRING     RequestMethod;
    ANSI_STRING     RequestURI;
    ANSI_STRING     ClientNonce;
};

typedef CSIPArray<CSIPBuddy*>           SIP_BUDDY_LIST;
typedef CSIPArray<CSIPWatcher*>         SIP_WATCHER_LIST;

#define DYNAMIC_PORT_BINDING_RETRY      10
#define DYNAMIC_STARTING_PORT           6902
#define DYNAMIC_PORT_RANGE              10000

class SIP_STACK :
    public ISipStack,
    public ISIPWatcherManager,
    public ISIPBuddyManager,
    public IIMManager
{
public:
    // IUnknown
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);

    // ISipStack
    STDMETHODIMP SetNotifyInterface(
        IN ISipStackNotify *NotifyInterface
        );
    
    STDMETHODIMP SetProviderProfile(
        IN SIP_PROVIDER_PROFILE *ProviderInfo
        );

    STDMETHODIMP DeleteProviderProfile(
        IN SIP_PROVIDER_ID *ProviderId
        );


    STDMETHODIMP DeleteAllProviderProfiles();

    STDMETHODIMP CreateCall(
        IN  SIP_PROVIDER_ID        *pProviderId,
        IN  SIP_SERVER_INFO        *pProxyInfo,
        IN  SIP_CALL_TYPE           CallType,
        IN  ISipRedirectContext    *pRedirectContext, 
        OUT ISipCall              **ppCall
        );

    STDMETHODIMP EnableIncomingCalls();
    
    STDMETHODIMP DisableIncomingCalls();
    
    STDMETHODIMP EnableStaticPort();
    
    STDMETHODIMP DisableStaticPort();

    STDMETHODIMP GetNetworkAddresses(
        IN  BOOL        fTcp,
        IN  BOOL        fExternal,
        OUT LPOLESTR  **pNetworkAddressArray,
        OUT ULONG      *pNetworkAddressCount
        );

    STDMETHODIMP FreeNetworkAddresses(
        IN  LPOLESTR   *NetworkAddressArray,
        IN  ULONG       NetworkAddressCount
        );      

    STDMETHODIMP PrepareForShutdown();
    
    STDMETHODIMP Shutdown();

    // LocalIp is in network order
    STDMETHODIMP IsFirewallEnabled(
        IN  DWORD       LocalIp,
        OUT BOOL       *pfIsFirewallEnabled 
        );

    
    SIP_STACK(
        IN IRTCMediaManage *pMediaManager
        );
    
    ~SIP_STACK();

    HRESULT Init();
    
    void AddToMsgProcList(
        IN SIP_MSG_PROCESSOR *pSipMsgProc
        );
    
    void ProcessMessage(
        IN SIP_MESSAGE  *pSipMsg,
        IN ASYNC_SOCKET *pAsyncSock
        );

    HRESULT GetSocketToDestination(
        IN  SOCKADDR_IN                     *pDestAddr,
        IN  SIP_TRANSPORT                    Transport,
        IN  LPCWSTR                          RemotePrincipalName,
        IN  CONNECT_COMPLETION_INTERFACE    *pConnectCompletion,
        IN  HttpProxyInfo                   *pHPInfo,
        OUT ASYNC_SOCKET                   **ppAsyncSocket
        );
    
    VOID OfferCall(
        IN  SIP_CALL        *pSipCall,
        IN  SIP_PARTY_INFO  *pCallerInfo
        );

    inline IRTCMediaManage *GetMediaManager();
    
    inline TIMER_MGR *GetTimerMgr();

    inline HWND GetSipStackWindow();
    
    inline BOOL AllowIncomingCalls();

    BOOL GetListenAddr(
        IN OUT SOCKADDR_IN *pListenAddr,
        IN     BOOL         fTcp
        );

    HRESULT CreateListenSocket(
        IN  BOOL            fTcp,
        IN  SOCKADDR_IN    *pListenAddr,
        OUT ASYNC_SOCKET  **ppAsyncSocket
        );
    
    HRESULT CreateDynamicPortListenSocket(
        IN BOOL             fTcp,
        IN SOCKADDR_IN     *pListenAddr,
        OUT ASYNC_SOCKET  **ppAsyncSocket
        );

    HRESULT CheckIncomingSipMessage(
        IN SIP_MESSAGE  *pSipMsg,
        IN ASYNC_SOCKET *pAsyncSock,
        OUT BOOL * pisError,  
        OUT ULONG *pErrorCode,
        OUT  SIP_HEADER_ARRAY_ELEMENT   *pAdditionalHeaderArray,
        OUT  ULONG * pAdditionalHeaderCount
        );
    
    HRESULT NotifyRegisterRedirect(
        IN  REGISTER_CONTEXT   *pRegisterContext,
        IN  REDIRECT_CONTEXT   *pRedirectContext,
        IN  SIP_CALL_STATUS    *pRegisterStatus
        );

    HRESULT GetCredentialsFromUI(
        IN     SIP_PROVIDER_ID     *pProviderID,
        IN     BSTR                 Realm,
        IN OUT BSTR                *Username,
        OUT    BSTR                *Password
        );

    HRESULT GetCredentialsForRealm(
        IN  BSTR                 Realm,
        OUT BSTR                *Username,
        OUT BSTR                *Password,
        OUT SIP_AUTH_PROTOCOL   *pAuthProtocol
        );
    
    //
    // IMPP related functions.
    //
    HRESULT RejectWatcher(
        IN  CSIPWatcher * pSIPWatcher
        );
    
    HRESULT AcceptWatcher(
        IN  CSIPWatcher * pSIPWatcher
        );
    
    HRESULT CreateIncomingWatcher(
        IN  SIP_TRANSPORT   Transport,
        IN  SIP_MESSAGE    *pSipMsg,
        IN  ASYNC_SOCKET   *pResponseSocket
        );
    
    HRESULT OfferWatcher(
        IN  CSIPWatcher    *pSipWatcher,
        IN  SIP_PARTY_INFO *pWatcherInfo
        );

    void WatcherOffline( 
        IN  CSIPWatcher    *pCSIPWatcher
        );

    STDMETHODIMP SendUnsubToWatcher(
        IN  CHAR           *NotifyBlob,
        IN  DWORD           dwBlobLength,
        IN  SIP_SERVER_INFO *pProxyInfo
        );
    
    VOID OnDeregister(
        GUID               *pProviderID,
        BOOL                fPAUnsub
        );

    //
    // ISIPBuddyManager interface functions.
    //
    
    STDMETHODIMP_(INT) GetBuddyCount(void);
    
    STDMETHODIMP_(ISIPBuddy *) GetBuddyByIndex(
        IN  INT iIndex
        );
    
    STDMETHODIMP AddBuddy(
        IN  LPWSTR                  lpwstrFriendlyName,
        IN  LPWSTR                  lpwstrPresentityURI,
        IN  LPWSTR                  lpwstrLocalUserURI,
        IN  SIP_PROVIDER_ID        *pProviderID,
        IN  SIP_SERVER_INFO        *pProxyInfo,
        IN  ISipRedirectContext    *pRedirectContext,
        OUT ISIPBuddy **            ppSipBuddy
        );

    STDMETHODIMP RemoveBuddy(
        IN  ISIPBuddy *         pSipBuddy,
        IN  BUDDY_REMOVE_REASON buddyRemoveReason
        );

    //    
    // ISIPWatcherManager interface functions
    //

    STDMETHODIMP SetPresenceInformation(
        IN SIP_PRESENCE_INFO * pSipLocalPresenceInfo
        );

    STDMETHODIMP_(INT) GetWatcherCount(void);
    
    STDMETHODIMP_(ISIPWatcher *) GetWatcherByIndex(
        IN  INT iIndex
        );

    STDMETHODIMP RemoveWatcher(
        IN  ISIPWatcher * pSipWatcher,
        IN  BUDDY_REMOVE_REASON watcherRemoveReason
        );
    
    HRESULT CreateWatcherNotify( 
        BLOCKED_WATCHER_INFO   *pBlockedWatcherInfo
        );

    HRESULT GetProfileUserCredentials(
        IN  SIP_PROVIDER_ID        *pProviderId,
        OUT SIP_USER_CREDENTIALS  **ppUserCredentials,
        OUT LPOLESTR               *pRealm
        );
    
    ISipStackNotify * GetNotifyInterface();

    //IIMManager functions defined in messagecall.cpp

    STDMETHODIMP CreateSession(
        IN BSTR         LocalDisplayName,
        IN BSTR         LocalUserURI,
        IN  SIP_PROVIDER_ID     *pProviderId,
        IN  SIP_SERVER_INFO     *pProxyInfo,
        IN  ISipRedirectContext *pRedirectContext,
        OUT IIMSession      ** pImSession
        );

    ULONG   GetPresenceAtomID()
    {
        return ++m_PresenceAtomID;
    }

    SIP_PRESENCE_INFO * GetLocalPresenceInfo()
    {
        return &m_LocalPresenceInfo;
    }

    STDMETHODIMP DeleteSession(
        IN IIMSession * pSession
        );

    HRESULT CreateIncomingMessageSession(
        IN  SIP_TRANSPORT   Transport,
        IN  SIP_MESSAGE    *pSipMsg,
        IN  ASYNC_SOCKET   *pResponseSocket
        );

    HRESULT CreateIncomingReqfailCall(
        IN  SIP_TRANSPORT               Transport,
        IN  SIP_MESSAGE                *pSipMsg,
        IN  ASYNC_SOCKET               *pResponseSocket,
        IN  ULONG                       StatusCode = 0,
        IN  SIP_HEADER_ARRAY_ELEMENT   *pAdditionalHeaderArray = NULL,
        IN  ULONG                       AdditionalHeaderCount = 0
        );
    HRESULT CreateIncomingOptionsCall(
        IN  SIP_TRANSPORT   Transport,
        IN  SIP_MESSAGE    *pSipMsg,
        IN  ASYNC_SOCKET   *pResponseSocket
        );

    HRESULT GetProviderID( 
        REGISTER_CONTEXT   *pRegisterContext,
        SIP_PROVIDER_ID    *pProviderID
        );

    VOID NotifyRegistrarStatusChange( 
        SIP_PROVIDER_STATUS *ProviderStatus 
        );
    
    HRESULT AsyncResolveHost(
        IN  PSTR                                    Host,
        IN  ULONG                                   HostLen,
        IN  USHORT                                  Port,
        IN  DNS_RESOLUTION_COMPLETION_INTERFACE    *pDnsCompletion,
        OUT SOCKADDR_IN                            *pDstAddr,
        IN  SIP_TRANSPORT                          *pTransport,
        OUT DNS_RESOLUTION_WORKITEM               **ppDnsWorkItem 
        );

    HRESULT AsyncResolveSipUrl(
        IN  SIP_URL                                *pSipUrl, 
        IN  DNS_RESOLUTION_COMPLETION_INTERFACE    *pDnsCompletion,
        OUT SOCKADDR_IN                            *pDstAddr,
        IN  OUT SIP_TRANSPORT                      *pTransport,
        OUT DNS_RESOLUTION_WORKITEM               **ppDnsWorkItem,
        IN  BOOL                                    fUseTransportFromSipUrl
        );
    
    HRESULT AsyncResolveSipUrl(
        IN  PSTR                                    DstUrl,
        IN  ULONG                                   DstUrlLen,
        IN  DNS_RESOLUTION_COMPLETION_INTERFACE    *pDnsCompletion, 
        OUT SOCKADDR_IN                            *pDstAddr,
        IN  OUT SIP_TRANSPORT                      *pTransport,
        OUT DNS_RESOLUTION_WORKITEM               **ppDnsWorkItem,
        IN  BOOL                                    fUseTransportFromSipUrl
        );

    VOID OnIPAddrChange();

    HRESULT CheckIPAddr(
        IN  SOCKADDR_IN    *pDestAddr,
        IN  SIP_TRANSPORT   Transport
        );

    HRESULT NatMgrInit();

    HRESULT StartNatThread();

    HRESULT NatMgrStop();

    DWORD NatThreadProc();

    BOOL GetPublicListenAddr(
        IN  DWORD           LocalIp,    // in network byte order
        IN  BOOL            fTcp,
        OUT SOCKADDR_IN    *pPublicAddr
        );
    
    HRESULT MapDestAddressToNatInternalAddress(
        IN  DWORD            LocalIp,               // in network byte order
        IN  SOCKADDR_IN     *pDestAddr,
        IN  SIP_TRANSPORT    Transport,
        OUT SOCKADDR_IN     *pActualDestAddr,
        OUT BOOL            *pIsDestExternalToNat
        );

    HRESULT OnNatAddressChange();

    BOOL IsLocalIPAddrPresent(IN DWORD LocalIPSav);

    inline BOOL IsSipStackShutDown();

    inline VOID IncrementNumMsgProcessors();

    VOID OnMsgProcessorDone();

    HRESULT SetLocalNetworkAddressFirst(
        IN OUT LPWSTR  *ppNetworkAddressArray,
        IN DWORD       NetworkAddressCount
        );


    LIST_ENTRY              m_StackListEntry;    

private:
    ULONG                   m_Signature;
    ULONG                   m_RefCount;

    ISipStackNotify        *m_pNotifyInterface;
    //IIMMessageNotify        *m_pIMNotifyInterface;

    IRTCMediaManage        *m_pMediaManager;
    
    SIP_PROVIDER_PROFILE   *m_ProviderProfileArray;
    ULONG                   m_NumProfiles;
    ULONG                   m_ProviderProfileArraySize;

    BOOL                    m_AllowIncomingCalls;

    BOOL                    m_EnableStaticPort;

    ULONG                   m_NumMsgProcessors;
    BOOL                    m_PreparingForShutdown;
    
    BOOL                    m_isSipStackShutDown;

    // Linked list of SIP_LISTEN_SOCKETs
    LIST_ENTRY              m_ListenSocketList;
    
    TIMER_MGR               m_TimerMgr;

    HWND                    m_SipStackWindow;    

    SOCKET_MANAGER          m_SockMgr;

    ASYNC_WORKITEM_MGR      m_WorkItemMgr;
    
    LIST_ENTRY              m_MsgProcList;

    MIB_IPADDRTABLE        *m_pMibIPAddrTable;
    DWORD                   m_MibIPAddrTableSize;
    
    //
    // IMPP related members
    //
    SIP_BUDDY_LIST          m_SipBuddyList;
    SIP_WATCHER_LIST        m_SipWatcherList;
    BOOL                    m_bIsNestedWatcherProcessing;
    SIP_WATCHER_LIST        m_SipOfferingWatcherList;
    ULONG                   m_PresenceAtomID;
    SIP_PRESENCE_INFO       m_LocalPresenceInfo;

    //
    // State for the NAT / PAST / UPnP protocol handling.
    // (with Whistler/WinMe ICS or any other NAT server that implements
    // the PAST protocol).
    // We use the dpnathlp.dll APIs. 

    HANDLE                  m_NatMgrThreadHandle;
    DWORD                   m_NatMgrThreadId;

    // This event is signaled by the main thread requesting
    // the NAT thread to shutdown. The NAT Helper thread waits
    // on this event.
    HANDLE                  m_NatShutdownEvent;

    IDirectPlayNATHelp     *m_pDirectPlayNATHelp;
    
    // Nat helper caps obtained from dpnathlp.dll
    // We don't really use this structure for anything but the
    // timer interval.
    // It's here just for debugging purposes.
    DPNHCAPS                m_NatHelperCaps;
    
    // This event is signaled by the nathelp.dll when there
    // is some notification from the NAT server about some change.
    HANDLE                  m_NatHelperNotificationEvent;

    // XXX This critical section is not used currently as
    // we modify the state only in the main thread.
    // This critical section protects the state below. Note that
    // the address mappings are set up in the NAT thread (when
    // there is a change in the server state, etc.) while they are
    // used in the main thread for setting up headers such as
    // Contact / Via.
    CRITICAL_SECTION        m_NatMgrCritSec;
    BOOL                    m_NatMgrCSIsInitialized;
    
    //      BOOL                    m_IsNatServerPresent;

    HRESULT CreateSipStackWindow();
    
    HRESULT StartAllProviderUnregistration();

    HRESULT StartAllProviderRegistration();

    HRESULT CreateAndAddListenSocketToList(
        IN DWORD IpAddr      // in network byte order
        );
    
    HRESULT CreateListenSocketList();

    HRESULT UpdateListenSocketList();
    
    VOID DeleteListenSocketList();
    
    SIP_LISTEN_SOCKET * FindListenSocketForIpAddr(
        DWORD   IpAddr      // Network Byte order
        );
    
    HRESULT CreateIncomingCall(
        IN  SIP_TRANSPORT   Transport,
        IN  SIP_MESSAGE    *pSipMsg,
        IN  ASYNC_SOCKET   *pResponseSocket
        );

    HRESULT DropIncomingSessionIfNonEmptyToTag(
        IN  SIP_TRANSPORT   Transport,
        IN  SIP_MESSAGE    *pSipMsg,
        IN  ASYNC_SOCKET   *pResponseSocket
        );

    SIP_MSG_PROCESSOR * FindMsgProcForMessage(
        IN SIP_MESSAGE *pSipMsg
        );
    
    BOOL IsProviderIdPresent(
        IN  SIP_PROVIDER_ID    *pProviderId,
        OUT ULONG              *pProviderIndex  
        );
    
    HRESULT AddProviderProfile(
        IN SIP_PROVIDER_PROFILE *pProviderProfile
        );
    
    HRESULT GrowProviderProfileArray();
    
    HRESULT UpdateProviderProfile(
        IN ULONG                 ProviderIndex, 
        IN SIP_PROVIDER_PROFILE *pProviderProfile
        );
    
    HRESULT CopyProviderProfile(
        IN ULONG                 ProviderIndex,
        IN SIP_PROVIDER_PROFILE *pProviderProfile,
        IN BOOL                  fRegistrarStatusUpdated
        );
    
    VOID FreeProviderProfileStrings(
        IN ULONG ProviderIndex
        );
    
    HRESULT StartRegistration(
        IN SIP_PROVIDER_PROFILE *pProviderProfile
        );

    void UpdateProviderRegistration(
        IN  ULONG                 ProviderIndex, 
        IN  SIP_PROVIDER_PROFILE *pProviderProfile,
        OUT BOOL                 *fRegistrarStatusUpdated
        );

    HRESULT CreateDnsResolutionWorkItem(
        IN  PSTR                                    Host,
        IN  ULONG                                   HostLen,
        IN  USHORT                                  Port,
        IN  SIP_TRANSPORT                           Transport,
        IN  DNS_RESOLUTION_COMPLETION_INTERFACE    *pDnsCompletion,
        OUT DNS_RESOLUTION_WORKITEM               **ppDnsWorkItem 
        );

    HRESULT GetLocalIPAddresses();

    BOOL IsIPAddrLocal(
        IN  SOCKADDR_IN    *pDestAddr,
        IN  SIP_TRANSPORT   Transport
        );

    VOID DebugPrintLocalIPAddressTable();
    
    VOID FreeLocalIPaddrTable();

    VOID ShutdownAllMsgProcessors();
    
    HRESULT
    NotifyIncomingSessionToCore(
        IN  IIMSession     *pImSession,
        IN  SIP_MESSAGE    *pSipMsg,
        IN  PSTR            RemoteURI,
        IN  ULONG           RemoteURILen
        );

    //IMPP related member functions
    BOOL IsWatcherAllowed(
        IN  SIP_MESSAGE    *pSipMessage
        );

    // NAT related functions
    HRESULT InitNatCaps(
        OUT DPNHCAPS    *pNatHelperCaps
        );
    
//      HRESULT RegisterNatMappings();

    HRESULT GetCapsAndUpdateNatMappingsIfNeeded();

    HRESULT RegisterNatMapping(
        IN OUT SIP_LISTEN_SOCKET *pListenSocket
        );
    
    HRESULT UpdatePublicListenAddr(
        IN OUT SIP_LISTEN_SOCKET *pListenSocket
        );

    HRESULT GetLocalNetworkAddresses(
        IN  BOOL        fTcp,
        OUT LPOLESTR  **pNetworkAddressArray,
        OUT ULONG      *pNetworkAddressCount
        );
    
    HRESULT GetPublicNetworkAddresses(
        IN  BOOL        fTcp,
        OUT LPOLESTR  **pNetworkAddressArray,
        OUT ULONG      *pNetworkAddressCount
        );
    
    HRESULT GetActualPublicListenAddr(
        IN  SIP_LISTEN_SOCKET  *pListenSocket,
        IN  BOOL                fTcp,
        OUT SOCKADDR_IN        *pActualListenAddr
        );
    
    HRESULT RegisterHttpProxyWindowClass();
    HRESULT UnregisterHttpProxyWindow();

};


inline IRTCMediaManage *
SIP_STACK::GetMediaManager()
{
    return m_pMediaManager;
}


inline TIMER_MGR *
SIP_STACK::GetTimerMgr()
{
    return &m_TimerMgr;
}


inline HWND
SIP_STACK::GetSipStackWindow()
{
    return m_SipStackWindow;
}

inline BOOL
SIP_STACK::AllowIncomingCalls()
{
    return m_AllowIncomingCalls;
}


inline ISipStackNotify *
SIP_STACK::GetNotifyInterface()
{
    return m_pNotifyInterface;
}

inline BOOL 
SIP_STACK::IsSipStackShutDown()
{
    return m_isSipStackShutDown;
}


inline VOID
SIP_STACK::IncrementNumMsgProcessors()
{
    m_NumMsgProcessors++;
}


// XXX TODO These declarations should be in sipparse.h
void
ParseWhiteSpace(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed
    );

void
ParseWhiteSpaceAndNewLines(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed
    );
    
HRESULT
ParseKnownString(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed,
    IN      PSTR            String,
    IN      ULONG           StringLen,
    IN      BOOL            fIsCaseSensitive
    );

BOOL
SkipToKnownChar(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesParsed,
    IN      INT             Char
    );

HRESULT
AppendContentTypeHeader(
    IN      PSTR            Buffer,
    IN      ULONG           BufLen,
    IN OUT  ULONG          *pBytesFilled,
    IN SIP_METHOD_ENUM      MethodId,
    IN      PSTR            ContentType,
    IN      ULONG           ContentTypeLen
    );

#endif // __sipcli_sipstack_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\sockmgr.cpp ===
#include "precomp.h"
#include "sipstack.h"

SOCKET_MANAGER::SOCKET_MANAGER(
    IN SIP_STACK *pSipStack
    )
{
    m_pSipStack = pSipStack;
    InitializeListHead(&m_SocketList);
}

SOCKET_MANAGER::~SOCKET_MANAGER()
{

}

VOID
SOCKET_MANAGER::AddSocketToList(
    IN  ASYNC_SOCKET *pAsyncSock
    )
{
    InsertTailList(&m_SocketList, &pAsyncSock->m_ListEntry);
}


// If address refers to a local interface, then it returns
// an error.

HRESULT
SOCKET_MANAGER::GetNewSocketToDestination(
    IN  SOCKADDR_IN                     *pDestAddr,
    IN  SIP_TRANSPORT                    Transport,
    IN  LPCWSTR                          RemotePrincipalName,
    IN  CONNECT_COMPLETION_INTERFACE    *pConnectCompletion,
    IN  HttpProxyInfo                   *pHPInfo,
    OUT ASYNC_SOCKET                   **ppAsyncSocket
    )
{
    ASYNC_SOCKET  *pAsyncSocket = NULL;
    DWORD          Error;
    HRESULT        hr;

    SIP_MSG_PROCESSOR *pProcessor;
    PSTR pszTunnelHost;
    USHORT usPort;

    ENTER_FUNCTION("SOCKET_MANAGER::GetNewSocketToDestination");

    hr = m_pSipStack->CheckIPAddr(pDestAddr, Transport);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s CheckIPAddr failed %x",
             __fxName, hr));
        return hr;
    }
    
    DWORD ConnectFlags = 0;
    // Enable this flag if you want to disable cert validation
    // DWORD ConnectFlags = CONNECT_FLAG_DISABLE_CERT_VALIDATION;
    
    pAsyncSocket = new ASYNC_SOCKET(m_pSipStack, Transport, NULL);
    if (pAsyncSocket == NULL)
    {
        LOG((RTC_ERROR, "%s allocating ASYNC_SOCKET ", __fxName));
        return E_OUTOFMEMORY;
    }

    AddSocketToList(pAsyncSocket);
    
    Error = pAsyncSocket->Create();
    if (Error != NO_ERROR)
    {
        LOG((RTC_ERROR, "%s  creating socket failed %x", __fxName, Error)); 
        goto error;
    }

    Error = pAsyncSocket->Connect(pDestAddr, RemotePrincipalName, ConnectFlags, pHPInfo);
    if (Error != NO_ERROR && Error != WSAEWOULDBLOCK)
    {
        LOG((RTC_ERROR, "%s connect failed %x", __fxName, Error));
        goto error;
    }

    if (Error == WSAEWOULDBLOCK)
    {
        hr = pAsyncSocket->AddToConnectCompletionList(pConnectCompletion);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s AddToConnectCompletionList failed %x",
                 __fxName, hr));
            goto error;
        }
    }

    LOG((RTC_TRACE, "%s - succeeded returning socket: %x",
         __fxName, pAsyncSocket));
    // Note that pAsyncSocket is created with a ref count of 1
    *ppAsyncSocket = pAsyncSocket;
    return HRESULT_FROM_WIN32(Error);

 error:
    if (pAsyncSocket != NULL)
    {
        LOG((RTC_ERROR,"%s deleted ASOCK %x",__fxName, pAsyncSocket));
        delete pAsyncSocket;
    }
    return HRESULT_FROM_WIN32(Error);
}


// returns WSAEWOULDBLOCK if connection is still pending.
HRESULT
SOCKET_MANAGER::GetSocketToDestination(
    IN  SOCKADDR_IN                     *pDestAddr,
    IN  SIP_TRANSPORT                    Transport,
    IN  LPCWSTR                          RemotePrincipalName,
    IN  CONNECT_COMPLETION_INTERFACE    *pConnectCompletion,
    IN  HttpProxyInfo                   *pHPInfo,
    OUT ASYNC_SOCKET                   **ppAsyncSocket
    )
{
    LIST_ENTRY    *pListEntry;
    ASYNC_SOCKET  *pAsyncSocket;
    HRESULT        hr = S_OK;

    ENTER_FUNCTION("SOCKET_MANAGER::GetSocketToDestination");
    
    pListEntry = m_SocketList.Flink;
    while (pListEntry != &m_SocketList)
    {
        pAsyncSocket = CONTAINING_RECORD(pListEntry, ASYNC_SOCKET, m_ListEntry);
        if (pAsyncSocket->IsSocketOpen() &&
            pAsyncSocket->GetTransport() == Transport &&
            (((pHPInfo) ? 
                (pAsyncSocket->m_SSLTunnelHost != NULL &&
                 !strcmp(pHPInfo->pszHostName, pAsyncSocket->m_SSLTunnelHost)):
                (AreSockaddrEqual(pDestAddr, &pAsyncSocket->m_RemoteAddr)))))
        {
            if (pAsyncSocket->GetConnectionState() != CONN_STATE_CONNECTED)
            {
                hr = pAsyncSocket->AddToConnectCompletionList(pConnectCompletion);
                if (hr != S_OK)
                {
                    LOG((RTC_ERROR, "%s AddToConnectCompletionList failed %x",
                         __fxName, hr));
                    return hr;
                }
                hr = HRESULT_FROM_WIN32(WSAEWOULDBLOCK);
            }
            
            LOG((RTC_TRACE, "%s - returning existing socket: %x",
                 __fxName, pAsyncSocket));
            pAsyncSocket->AddRef();
            *ppAsyncSocket = pAsyncSocket;
            return hr;
        }
    
        pListEntry = pListEntry->Flink;
    }

    return GetNewSocketToDestination(pDestAddr, Transport,
                                     RemotePrincipalName,
                                     pConnectCompletion,
                                     pHPInfo,
                                     ppAsyncSocket);
}


// Handle accept completion for global TCP socket
VOID
SOCKET_MANAGER::OnAcceptComplete(
    IN DWORD ErrorCode,
    IN ASYNC_SOCKET *pAcceptedSocket
    )
{
    ENTER_FUNCTION("SOCKET_MANAGER::OnAcceptComplete");
    
    if (ErrorCode != NO_ERROR)
    {
        // accept failed.
        LOG((RTC_ERROR, "%s  Error - %x", __fxName, ErrorCode));
        return;
    }

    ASSERT(pAcceptedSocket != NULL);
    // Add it to the list of sockets
    AddSocketToList(pAcceptedSocket);
}


void
SOCKET_MANAGER::DeleteUnusedSocketsOnTimer()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\timer.cpp ===
#include "precomp.h"

//
// We have one main timer that uses the Win32 SetTimer/KillTimer APIs.
// All timers in the sip stack are managed using timer queue entries in
// Timer manager.
//
// We are doing this because the Win32 KillTimer API is not very
// reliable and we could get a WM_TIMER message after the KillTimer()
// API is called.

#define WM_SIP_TIMER_CALLBACK       (WM_USER + 0)

#undef TICK_COUNT_WRAP_AROUND_DEBUG
#ifdef TICK_COUNT_WRAP_AROUND_DEBUG
ULONG
MyDebugGetTickCount()
{
    LOG((RTC_TRACE, "MyDebugGetTickCount")); 
    return 0xc1ec0d4c + ::GetTickCount();
}

#define GetTickCount() MyDebugGetTickCount()

#endif // TICK_COUNT_WRAP_AROUND_DEBUG


LRESULT WINAPI
TimerWindowProc(
    IN HWND    Window, 
    IN UINT    MessageID,
    IN WPARAM  Parameter1,
    IN LPARAM  Parameter2
    )
{
    ENTER_FUNCTION("TimerWindowProc");

    TIMER_MGR *pTimerMgr;
    TIMER_QUEUE_ENTRY *pTimerQEntry;
    TIMERQ_STATE TimerQState;
    TIMER *pTimer;
    
    switch (MessageID)
    {
    case WM_TIMER:

        LOG((RTC_TRACE, "%s : WM_TIMER msg rcvd: Window: %x pTimerMgr: %x",
             __fxName, Window, Parameter1));

        pTimerMgr = (TIMER_MGR *) Parameter1;
        ASSERT(pTimerMgr);
        pTimerMgr->OnMainTimerExpire();
        return 0;
        
    case WM_SIP_TIMER_CALLBACK:

        pTimerQEntry = (TIMER_QUEUE_ENTRY *) Parameter1;
        ASSERT(pTimerQEntry);

        RemoveEntryList(&pTimerQEntry->m_ListEntry);
        pTimer = pTimerQEntry->m_pTimer;
        TimerQState = pTimerQEntry->m_TimerQState;
        ASSERT(TimerQState == TIMERQ_STATE_EXPIRED ||
               TimerQState == TIMERQ_STATE_KILLED);
        
        pTimerMgr = (TIMER_MGR *) Parameter2;
        pTimerMgr->DecrementNumExpiredListEntries();

        delete pTimerQEntry;

        LOG((RTC_TRACE,
             "%s : WM_SIP_TIMER_CALLBACK msg rcvd: pTimerQEntry: %x pTimer: %x NumExpiredQEntries: %d",
             __fxName, Parameter1, pTimer,
             pTimerMgr->GetNumExpiredListEntries()
             ));

        // Do the callback last.
        if (TimerQState != TIMERQ_STATE_KILLED)
        {
            pTimer->OnTimerExpireCommon();
        }
        else
        {
            LOG((RTC_TRACE,
                 "%s TimerQentry %x Timer: %x already killed not making callback",
                 __fxName, pTimerQEntry, pTimer));
        }

        return 0;
        
    default:
        return DefWindowProc(Window, MessageID, Parameter1, Parameter2);
    }
}


HRESULT
TIMER::StartTimer(
    IN UINT TimeoutValue
    )
{
    ENTER_FUNCTION("TIMER::StartTimer");
    
    ASSERT(!IsTimerActive());

    HRESULT hr;

    hr = m_pTimerMgr->StartTimer(this, TimeoutValue, &m_pTimerQEntry);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s  TimerMgr->StartTimer(%x) failed %x",
             __fxName, this, hr));
        return hr;
    }
    
    m_TimeoutValue = TimeoutValue;

    LOG((RTC_TRACE, "%s done - this: %x TimeoutValue: %d",
         __fxName, this, m_TimeoutValue));
    
    return S_OK;
}


HRESULT
TIMER::KillTimer()
{
    ENTER_FUNCTION("TIMER::KillTimer");

    HRESULT hr;
    
    ASSERT(IsTimerActive());
    
    m_TimeoutValue = 0;

    hr = m_pTimerMgr->KillTimer(this);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s  TimerMgr->KillTimer(%x) failed : %x",
             __fxName, this, hr));
        m_pTimerQEntry = NULL;
        return hr;
    }
    
    m_pTimerQEntry = NULL;
    LOG((RTC_TRACE, "%s done - this: %x", __fxName, this));
    return S_OK;
}


VOID
TIMER::OnTimerExpireCommon()
{
    LOG((RTC_TRACE, "OnTimerExpireCommon this: %x m_TimeoutValue : %d",
         this, m_TimeoutValue));
    m_TimeoutValue = 0;
    m_pTimerQEntry = NULL;
    OnTimerExpire();
}


///////////////////////////////////////////////////////////////////////////////
// TIMER_MGR
///////////////////////////////////////////////////////////////////////////////

// To deal with tick count wrap around
const ULONG MAX_TIMER_TICK_COUNT_DIFF = 0x7fffffff;

// 3600000 : 1 hour to deal with any delay due to the
// timer going off a little late than the exact expire time.
// Note that there could be some blocking calls etc. 1 hour
// is just playing it safe and we don't need timers of this
// duration any way.
const ULONG MAX_TIMER_VALUE  = 0x7fffffff - 3600000;


TIMER_MGR::TIMER_MGR()
{
    InitializeListHead(&m_TimerQueue);
    InitializeListHead(&m_ExpiredList);

    m_TimerWindow           = NULL;
    
    m_NumTimerQueueEntries  = 0;
    m_NumExpiredListEntries = 0;

    m_IsMainTimerActive     = FALSE;
    m_MainTimerTickCount    = 0;
    m_isTimerStopped        = FALSE;
}


TIMER_MGR::~TIMER_MGR()
{

}


HRESULT
TIMER_MGR::Start()
{
    ENTER_FUNCTION("TIMER_MGR::Start");
    
    HRESULT hr;
    hr = CreateTimerWindow();
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s Creating timer window failed %x",
             __fxName, hr)); 
        return hr;
    }

    // Note that the main timer is started the first time
    // StartTimer() is called.
    
    return S_OK;
}


HRESULT
TIMER_MGR::CreateTimerWindow()
{
    DWORD Error;
    
    // Create the Timer Window
    m_TimerWindow = CreateWindow(
                    TIMER_WINDOW_CLASS_NAME,
                    NULL,
                    WS_DISABLED,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    NULL,           // No Parent
                    NULL,           // No menu handle
                    _Module.GetResourceInstance(),
                    NULL
                    );

    if (!m_TimerWindow)
    {
        Error = GetLastError();
        LOG((RTC_ERROR, "Timer CreateWindow failed 0x%x", Error));
        return HRESULT_FROM_WIN32(Error);
    }

    return S_OK;
}


HRESULT
TIMER_MGR::Stop()
{
    ENTER_FUNCTION("TimerMgr::Stop");
    
    DWORD Error;

    if (m_TimerWindow != NULL)
    {
        if (m_IsMainTimerActive)
        {
            if (!::KillTimer(m_TimerWindow, (UINT_PTR) this))
            {
                Error = GetLastError();
                LOG((RTC_ERROR, "%s KillTimer failed Error: %x this: %x",
                     __fxName, Error, this));
            }
        }

        if (!DestroyWindow(m_TimerWindow))
        {
            Error = GetLastError();
            LOG((RTC_ERROR, "%s - Destroying timer window failed %x",
                 __fxName, Error));
        }

        m_TimerWindow = NULL;
    }

    LIST_ENTRY          *pListEntry;
    TIMER_QUEUE_ENTRY   *pTimerQEntry;

    while (!IsListEmpty(&m_TimerQueue))
    {
        pListEntry = RemoveHeadList(&m_TimerQueue);

        pTimerQEntry = CONTAINING_RECORD(pListEntry,
                                         TIMER_QUEUE_ENTRY,
                                         m_ListEntry);

        LOG((RTC_TRACE, "%s - deleting TimerQentry: %x pTimer: %x",
             __fxName, pTimerQEntry, pTimerQEntry->m_pTimer));
        delete pTimerQEntry;
    }

    while (!IsListEmpty(&m_ExpiredList))
    {
        pListEntry = RemoveHeadList(&m_ExpiredList);

        pTimerQEntry = CONTAINING_RECORD(pListEntry,
                                         TIMER_QUEUE_ENTRY,
                                         m_ListEntry);

        LOG((RTC_TRACE, "%s - deleting ExpiredQEntry: %x pTimer: %x",
             __fxName, pTimerQEntry, pTimerQEntry->m_pTimer));
        delete pTimerQEntry;
    }
    m_isTimerStopped = TRUE;
    return S_OK;
}

// Both do essentially the same thing.
#define InsertBeforeListElement(ListElement, NewElement) \
        InsertTailList(ListElement, NewElement)

// TimeoutValue is in milliseconds
HRESULT
TIMER_MGR::StartTimer(
    IN  TIMER              *pTimer,
    IN  ULONG               TimeoutValue,
    OUT TIMER_QUEUE_ENTRY **ppTimerQEntry 
    )
{
    HRESULT hr;

    ENTER_FUNCTION("TIMER_MGR::StartTimer");

    if(m_isTimerStopped)
    {
        LOG((RTC_ERROR, "Timer Manager already stopped %x", this));
        return E_FAIL;
    }

    // This limit is required to deal with tick count wraparound
    if (TimeoutValue > MAX_TIMER_VALUE)
    {
        LOG((RTC_ERROR, "%s - Too big timeout value %d",
             __fxName, TimeoutValue));
        ASSERT(FALSE);
        return E_FAIL;
    }

    LIST_ENTRY          *pListEntry;
    TIMER_QUEUE_ENTRY   *pTimerQEntry;
    TIMER_QUEUE_ENTRY   *pNewTimerQEntry;

    // We support one-shot timers only.
    
    ASSERT(!FindTimerQueueEntryInList(pTimer, &m_TimerQueue));
    ASSERT((pTimerQEntry = FindTimerQueueEntryInList(pTimer, &m_ExpiredList)) == NULL ||
           pTimerQEntry->m_TimerQState == TIMERQ_STATE_KILLED);
    
#if 0  // 0 ******* Region Commented Out Begins *******
    pTimerQEntry = FindTimerQueueEntryInList(pTimer, &m_TimerQueue);
    if (pTimerQEntry != NULL)
    {
        LOG((RTC_ERROR, "%s - Timer Queue Entry %x already exists for Timer %x",
             __fxName, pTimerQEntry, pTimer));
        ASSERT(FALSE);
        return E_FAIL;
    }
    
    pTimerQEntry = FindTimerQueueEntryInList(pTimer, &m_ExpiredList);
    if (pTimerQEntry != NULL &&
        pTimerQEntry->m_TimerQState != TIMERQ_STATE_KILLED)
    {
        LOG((RTC_ERROR,
             "%s - Expired Q Entry %x already exists for Timer %x",
             __fxName, pTimerQEntry, pTimer));
        ASSERT(FALSE);
        return E_FAIL;
    }
#endif // 0 ******* Region Commented Out Ends   *******
    
    // Create a timer queue entry
    pNewTimerQEntry = new TIMER_QUEUE_ENTRY(pTimer, TimeoutValue);
    if (pNewTimerQEntry == NULL)
    {
        LOG((RTC_ERROR, "%s allocating pNewTimerQEntry failed",
             __fxName));
        return E_OUTOFMEMORY;
    }

    // Add it to the sorted queue
    
    pListEntry = m_TimerQueue.Flink;

    while (pListEntry != &m_TimerQueue)
    {
        pTimerQEntry = CONTAINING_RECORD(pListEntry,
                                         TIMER_QUEUE_ENTRY,
                                         m_ListEntry);

        if (!IsTimerTickCountLessThanOrEqualTo(
               pTimerQEntry->m_ExpireTickCount,
               pNewTimerQEntry->m_ExpireTickCount))
        {
            break;
        }

        pListEntry = pListEntry->Flink;
    }
    
    // Insert before the tail or the element we found with a greater
    // ExpireTickCount
    
    InsertBeforeListElement(pListEntry, &pNewTimerQEntry->m_ListEntry);
    m_NumTimerQueueEntries++;
    pNewTimerQEntry->m_TimerQState = TIMERQ_STATE_STARTED;

    AdjustMainTimer();
    
    *ppTimerQEntry = pNewTimerQEntry;

    LOG((RTC_TRACE,
         "%s - added pTimer: %x pTimerQEntry: %x ExpireTickCount: %x num Q entries: %d",
         __fxName, pTimer, pNewTimerQEntry, pNewTimerQEntry->m_ExpireTickCount,
         m_NumTimerQueueEntries));
    
    return S_OK;
}


HRESULT
TIMER_MGR::KillTimer(
    IN TIMER *pTimer
    )
{
    ENTER_FUNCTION("TIMER_MGR::KillTimer");

    if(m_isTimerStopped)
    {
        LOG((RTC_ERROR, "Timer Manager already stopped %x", this));
        return E_FAIL;
    }

    TIMER_QUEUE_ENTRY   *pTimerQEntry = pTimer->GetTimerQueueEntry();

    if (pTimerQEntry == NULL)
    {
        LOG((RTC_ERROR, "%s - m_pTimerQEntry is NULL", __fxName));
        ASSERT(FALSE);
        return E_FAIL;
    }

    if (pTimerQEntry->m_TimerQState == TIMERQ_STATE_STARTED)
    {
        m_NumTimerQueueEntries--;
        LOG((RTC_TRACE,
             "%s(%x) - deleting pTimerQEntry: %x in Timer queue num Q entries: %d",
             __fxName, this, pTimerQEntry, m_NumTimerQueueEntries));
        RemoveEntryList(&pTimerQEntry->m_ListEntry);
        delete pTimerQEntry;
        AdjustMainTimer();
        return S_OK;
    }
    else if (pTimerQEntry->m_TimerQState == TIMERQ_STATE_EXPIRED)
    {
        LOG((RTC_TRACE,
             "%s - marking timer %x killed TimerQEntry: %x",
             __fxName, pTimer, pTimerQEntry));

        // Make sure the timer callback will not be called.
        pTimerQEntry->m_TimerQState = TIMERQ_STATE_KILLED;
        return S_OK;
    }
    else
    {
        // A timer should not be killed more than once.
        LOG((RTC_WARN, "%s - pTimer: %x not in started or expired state",
             __fxName, pTimer));
        ASSERT(FALSE);
        return E_FAIL;
    }
}


VOID
TIMER_MGR::OnMainTimerExpire()
{
    LIST_ENTRY          *pListEntry;
    TIMER_QUEUE_ENTRY   *pTimerQEntry;

    ENTER_FUNCTION("TIMER_MGR::OnMainTimerExpire");

    ULONG   CurrentTickCount = GetTickCount();

    LOG((RTC_TRACE,
         "%s - CurrentTickCount: %x NumQentries: %d NumExpiredQEntries: %d",
         __fxName, CurrentTickCount, m_NumTimerQueueEntries,
         m_NumExpiredListEntries));

    DebugPrintTimerQueue();
    
    pListEntry = m_TimerQueue.Flink;

    while (pListEntry != &m_TimerQueue)
    {
        pTimerQEntry = CONTAINING_RECORD(pListEntry,
                                         TIMER_QUEUE_ENTRY,
                                         m_ListEntry);

        // Get the next pointer first as the code below could
        // remove the entry from the list.
        pListEntry = pListEntry->Flink;
        
        if (IsTimerTickCountLessThanOrEqualTo(
               pTimerQEntry->m_ExpireTickCount,
               CurrentTickCount))
        {
            ProcessTimerExpire(pTimerQEntry);
        }
        else
        {
            break;
        }
    }

    AdjustMainTimer();
}


HRESULT
TIMER_MGR::ProcessTimerExpire(
    IN TIMER_QUEUE_ENTRY *pTimerQEntry
    )
{
    ENTER_FUNCTION("TIMER_MGR::ProcessTimerExpire");

    // Remove the entry from the Timer Queue
    RemoveEntryList(&pTimerQEntry->m_ListEntry);
    m_NumTimerQueueEntries--;
            
    // Move to Expired timer list.
    // The timer queue entry will be in this list till
    // the WM_SIP_TIMER_CALLBACK message is processed.
    InsertTailList(&m_ExpiredList, &pTimerQEntry->m_ListEntry);
    m_NumExpiredListEntries++;
    pTimerQEntry->m_TimerQState = TIMERQ_STATE_EXPIRED;
    
    // We make the callback asynchronously because the timer callback
    // could block in the UI.
    if (!PostMessage(m_TimerWindow,
                     WM_SIP_TIMER_CALLBACK,
                     (WPARAM) pTimerQEntry,
                     (LPARAM) this))
    {
        DWORD Error = GetLastError();
        
        LOG((RTC_ERROR, "%s PostMessage failed : %x",
             __fxName, Error));
        return HRESULT_FROM_WIN32(Error);
    }

    LOG((RTC_TRACE, "%s(%x) - done NumQentries: %d NumExpiredQEntries: %d",
         __fxName, pTimerQEntry, m_NumTimerQueueEntries,
         m_NumExpiredListEntries));
    return S_OK;
}


VOID
TIMER_MGR::AdjustMainTimer()
{
    ENTER_FUNCTION("TIMER_MGR::AdjustMainTimer");
    DWORD Error;
    ULONG CurrentTickCount = GetTickCount();
    
    // Set the main timer to the least timeout.
    // If no timers in the queue kill the timer.
    if (!IsListEmpty(&m_TimerQueue))
    {
        LIST_ENTRY          *pListEntry;
        TIMER_QUEUE_ENTRY   *pTimerQEntry;

        pListEntry = m_TimerQueue.Flink;
        ASSERT(pListEntry != &m_TimerQueue);
        pTimerQEntry = CONTAINING_RECORD(pListEntry,
                                         TIMER_QUEUE_ENTRY,
                                         m_ListEntry);

        if (!m_IsMainTimerActive ||
            pTimerQEntry->m_ExpireTickCount != m_MainTimerTickCount)
        {
            // Let the timer expire immediately if the tickcount of the
            // first entry is before the current tick count.
            ULONG TimeoutValue = pTimerQEntry->m_ExpireTickCount - CurrentTickCount;

            if (TimeoutValue >= MAX_TIMER_TICK_COUNT_DIFF)
            {
                LOG((RTC_TRACE,
                     "%s - CurrentTickCount (%x) < pTimerQEntry->m_ExpireTickCount (%x)"
                     "Not changing existing main timer",
                     __fxName, CurrentTickCount, pTimerQEntry->m_ExpireTickCount));
            }
            else
            {
                // This replaces any existing timer if one exists or starts
                // the timer if the timer doesn't exist.
                UINT_PTR RetValue = ::SetTimer(m_TimerWindow, (UINT_PTR) this,
                                               TimeoutValue, NULL);
                if (RetValue == 0)
                {
                    Error = GetLastError();
                    LOG((RTC_ERROR, "%s - SetTimer failed Error: %x this: %x",
                         __fxName, Error, this));
                    return;
                }

                ASSERT(RetValue == (UINT_PTR) this);

                m_MainTimerTickCount = pTimerQEntry->m_ExpireTickCount;
                m_IsMainTimerActive = TRUE;

                LOG((RTC_TRACE,
                     "%s - set main timer to 0x%x(%d) milliseconds, "
                     "Main Timer TickCount: %x CurrentTickCount: %x",
                     __fxName, TimeoutValue, TimeoutValue,
                     m_MainTimerTickCount, CurrentTickCount));
            }
        }
        else
        {
            LOG((RTC_TRACE, "%s - not changing existing main timer", __fxName));
        }
    }
    else
    {
        if (m_IsMainTimerActive)
        {
            m_IsMainTimerActive = FALSE;
        
            if (!::KillTimer(m_TimerWindow, (UINT_PTR) this))
            {
                Error = GetLastError();
                LOG((RTC_ERROR, "%s KillTimer failed Error: %x this: %x",
                     __fxName, Error, this));
                return;
            }
            LOG((RTC_TRACE, "%s TimerQ empty - killed main timer",
                 __fxName));
        }
    }
}


// Finds a timer queue entry based on the timer
// in either the timer queue or the Expired list.
TIMER_QUEUE_ENTRY *
TIMER_MGR::FindTimerQueueEntryInList(
    TIMER       *pTimer,
    LIST_ENTRY  *pListHead
    )
{
    LIST_ENTRY          *pListEntry;
    TIMER_QUEUE_ENTRY   *pTimerQEntry;

    ASSERT(pListHead == &m_TimerQueue ||
           pListHead == &m_ExpiredList);

    pListEntry = pListHead->Flink;

    while (pListEntry != pListHead)
    {
        pTimerQEntry = CONTAINING_RECORD(pListEntry,
                                         TIMER_QUEUE_ENTRY,
                                         m_ListEntry);

        if (pTimerQEntry->m_pTimer == pTimer)
        {
            return pTimerQEntry;
        }

        pListEntry = pListEntry->Flink;
    }

    return NULL;
}


// For dealing with TickCount wraparound.
BOOL
TIMER_MGR::IsTimerTickCountLessThanOrEqualTo(
    IN ULONG TickCount1,
    IN ULONG TickCount2
    )
{
    ASSERT((TickCount2 - TickCount1) <= MAX_TIMER_TICK_COUNT_DIFF ||
           (TickCount1 - TickCount2) <= MAX_TIMER_TICK_COUNT_DIFF);
    
    return ((TickCount2 - TickCount1) <= MAX_TIMER_TICK_COUNT_DIFF);
}


VOID
TIMER_MGR::DebugPrintTimerQueue()
{
    LIST_ENTRY          *pListEntry;
    TIMER_QUEUE_ENTRY   *pTimerQEntry;

    ENTER_FUNCTION("DebugPrintTimerQueue");

    pListEntry = m_TimerQueue.Flink;

    while (pListEntry != &m_TimerQueue)
    {
        pTimerQEntry = CONTAINING_RECORD(pListEntry,
                                         TIMER_QUEUE_ENTRY,
                                         m_ListEntry);

        LOG((RTC_TRACE, "%s - ExpireTickCount: %x pTimer: %x",
             __fxName, pTimerQEntry->m_ExpireTickCount,
             pTimerQEntry->m_pTimer));
        pListEntry = pListEntry->Flink;
    }
}


TIMER_QUEUE_ENTRY::TIMER_QUEUE_ENTRY(
    IN TIMER *pTimer,
    IN ULONG  TimeoutValue
    )
{
    m_ExpireTickCount = GetTickCount() + TimeoutValue;
    m_pTimer          = pTimer;
    m_TimerQState     = TIMERQ_STATE_INIT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\util.h ===
#pragma	once

#define	IN_ADDR_FMT		"%u.%u.%u.%u"
#define	IN_ADDR_PRINTF(InternetAddress) \
	((PUCHAR) (InternetAddress)) [0], \
	((PUCHAR) (InternetAddress)) [1], \
	((PUCHAR) (InternetAddress)) [2], \
	((PUCHAR) (InternetAddress)) [3]

#define	SOCKADDR_IN_FMT_DECIMAL		"%u.%u.%u.%u:%u"
#define	SOCKADDR_IN_PRINTF_DECIMAL(SocketAddress) \
	IN_ADDR_PRINTF(&(SocketAddress) -> sin_addr), \
	ntohs ((SocketAddress) -> sin_port)

#define	SOCKADDR_IN_FMT_HEX			"%08X:%04X"
#define	SOCKADDR_IN_PRINTF_HEX(SocketAddress)	\
	ntohl ((SocketAddress) -> sin_addr.s_addr),	\
	ntohs ((SocketAddress) -> sin_port)

#if 0
#define	SOCKADDR_IN_FMT		SOCKADDR_IN_FMT_HEX
#define	SOCKADDR_IN_PRINTF	SOCKADDR_IN_PRINTF_HEX
#else
#define	SOCKADDR_IN_FMT		SOCKADDR_IN_FMT_DECIMAL
#define	SOCKADDR_IN_PRINTF	SOCKADDR_IN_PRINTF_DECIMAL
#endif

#define MAX_SIGBUF_LEN  500

static HRESULT GetLastResult (void)
{ return HRESULT_FROM_WIN32 (GetLastError()); }


class	MESSAGE_BUILDER
{
private:
	PSTR		m_Buffer;
	ULONG		m_Length;
	ULONG		m_MaximumLength;
	BOOL		m_Overflow;

public:

	void	PrepareBuild (
		IN	PSTR	Buffer,
		IN	ULONG	MaximumLength)
	{
		ASSERT (Buffer);

		m_Buffer = Buffer;
		m_MaximumLength = MaximumLength;
		m_Length = 0;
		m_Overflow = FALSE;
	}

	BOOL	OverflowOccurred	(void)
	{
		return m_Overflow;
	}

	//
	// GetLength is valid, even if overflow occurred
    // if the variable arg Append() is not called.
	//

	ULONG	GetLength	(void)
	{
		return m_Length;
	}

	void	Append (
		IN	PCSTR	Buffer,
		IN	ULONG	Length)
	{
		if (m_Length + Length <= m_MaximumLength)
			CopyMemory (m_Buffer + m_Length, Buffer, Length);
		else
			m_Overflow = TRUE;

		m_Length += Length;
	}

    // If this function is called and overflow occurs, then
    // the caller can not rely on GetLength() to get the
    // actual length of the buffer.
    void    AppendVaArgs (
        IN LPCSTR lpszFormat, IN ...
        )
    {
        va_list arglist;
        int     RetVal = 0;

        if (!m_Overflow && m_Length < m_MaximumLength)
        {
            va_start(arglist, lpszFormat);
            
            RetVal = _vsnprintf(m_Buffer + m_Length,
                                m_MaximumLength - m_Length, 
                                lpszFormat, 
                                arglist
                                );
            va_end(arglist);
            
            if (RetVal < 0)
                m_Overflow = TRUE;
            else
                m_Length += RetVal;
        }
        else
        {
            m_Overflow = TRUE;
        }
    }

	void	Append (
		IN	CONST ANSI_STRING *		AnsiString)
	{
		Append (AnsiString -> Buffer, AnsiString -> Length / sizeof (CHAR));
	}

	void	Append (
		IN	CONST COUNTED_STRING *		pCountedString)
	{
		Append (pCountedString -> Buffer, pCountedString -> Length / sizeof (CHAR));
	}

	void	Append (
		IN	PCSTR	Buffer)
	{
		Append (Buffer, strlen (Buffer));
	}

	void	AppendCRLF (void)
	{
		Append ("\r\n", 2);
	}

	void	AppendHeader (
		IN	PCSTR	Name,
		IN	PCSTR	Value)
	{
		Append (Name);
		Append (": ");
		Append (Value);
		AppendCRLF();
	}

};


void CvtHex(
    IN  UCHAR          *Bin,
    OUT CHAR           *Hex,
    IN  ULONG           ulHashLen
    );

VOID
ConvertHexToBinary(  
    IN  PSTR    HexBuffer,
    IN  ULONG   HexBufferLen,
    IN  PSTR    BinaryBuffer,
    OUT ULONG  &BinayBufferLen
    );

NTSTATUS
base64decode(
    IN  LPSTR   pszEncodedString,
    OUT VOID *  pDecodeBuffer,
    IN  DWORD   cbDecodeBufferSize,
    IN  DWORD   cchEncodedSize,
    OUT DWORD * pcbDecoded              OPTIONAL
    );

//
// For use in printf argument lists
//

#define	COUNTED_STRING_PRINTF(CountedString) \
	(CountedString) -> Length / sizeof (*(CountedString) -> Buffer), \
	(CountedString) -> Buffer

#define	UNICODE_STRING_PRINTF		COUNTED_STRING_PRINTF
#define	ANSI_STRING_PRINTF			COUNTED_STRING_PRINTF

#define	UNICODE_STRING_FMT		_T("%.*s")
#define	ANSI_STRING_FMT			_T("%.*S")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\msgtest\main.cpp ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
// Win32
#include <windows.h>
#include <rpc.h>
#include <winsock.h>
#include <tchar.h>

#include "rtcerr.h"
#include "rtclog.h"
#include "rtcsip.h"
#include "..\sipdef.h"
#include "..\siphdr.h"
#include "..\sipmsg.h"
#include "..\asyncwi.h"
#include "..\resolve.h"
#include "..\siputil.h"

#include "..\..\inc\obj\i386\rtcsip_i.c"

#define	COUNTED_STRING_PRINTF(pCountedString) \
	(pCountedString)->Length, (pCountedString)->Buffer

#include "atlbase.h"
CComModule  _Module;

CHAR Msg1Byte[] =
{
    '\0'
};

CHAR Msg405[] =
{
    0x53, 0x49, 0x50, 0x2F, 0x32, 0x2E, 0x30, 0x20, 0x34, 0x30, 0x35, 0x20, 0x4D, 0x65, 0x74, 0x68,
    0x6F, 0x64, 0x20, 0x4E, 0x6F, 0x74, 0x20, 0x41, 0x6C, 0x6C, 0x6F, 0x77, 0x65, 0x64, 0x0D, 0x0A,
    0x56, 0x69, 0x61, 0x3A, 0x20, 0x53, 0x49, 0x50, 0x2F, 0x32, 0x2E, 0x30, 0x2F, 0x55, 0x44, 0x50,
    0x20, 0x31, 0x37, 0x32, 0x2E, 0x33, 0x31, 0x2E, 0x38, 0x39, 0x2E, 0x31, 0x32, 0x30, 0x3A, 0x31,
    0x39, 0x36, 0x33, 0x0D, 0x0A, 0x46, 0x72, 0x6F, 0x6D, 0x3A, 0x20, 0x73, 0x69, 0x70, 0x3A, 0x61,
    0x63, 0x61, 0x70, 0x70, 0x40, 0x31, 0x37, 0x32, 0x2E, 0x33, 0x31, 0x2E, 0x39, 0x34, 0x2E, 0x38,
    0x30, 0x0D, 0x0A, 0x54, 0x6F, 0x3A, 0x20, 0x73, 0x69, 0x70, 0x3A, 0x61, 0x63, 0x61, 0x70, 0x70,
    0x40, 0x31, 0x37, 0x32, 0x2E, 0x33, 0x31, 0x2E, 0x39, 0x34, 0x2E, 0x38, 0x30, 0x0D, 0x0A, 0x43,
    0x61, 0x6C, 0x6C, 0x2D, 0x49, 0x44, 0x3A, 0x20, 0x31, 0x31, 0x33, 0x39, 0x32, 0x37, 0x36, 0x31,
    0x40, 0x31, 0x37, 0x32, 0x2E, 0x33, 0x31, 0x2E, 0x38, 0x39, 0x2E, 0x31, 0x32, 0x30, 0x0D, 0x0A,
    0x41, 0x6C, 0x6C, 0x6F, 0x77, 0x3A, 0x20, 0x49, 0x4E, 0x56, 0x49, 0x54, 0x45, 0x2C, 0x20, 0x4F,
    0x50, 0x54, 0x49, 0x4F, 0x4E, 0x53, 0x2C, 0x20, 0x42, 0x59, 0x45, 0x2C, 0x20, 0x43, 0x41, 0x4E,
    0x43, 0x45, 0x4C, 0x2C, 0x20, 0x41, 0x43, 0x4B, 0x0D, 0x0A, 0x0D, 0x0A,
};

CHAR Msg410[] =
{
    0x53, 0x49, 0x50, 0x2F, 0x32, 0x2E,
    0x30, 0x20, 0x34, 0x31, 0x30, 0x20, 0x47, 0x6F, 0x6E, 0x65, 0x0D, 0x0A, 0x56, 0x69, 0x61, 0x3A,
    0x20, 0x53, 0x49, 0x50, 0x2F, 0x32, 0x2E, 0x30, 0x2F, 0x55, 0x44, 0x50, 0x20, 0x31, 0x33, 0x31,
    0x2E, 0x31, 0x30, 0x37, 0x2E, 0x31, 0x35, 0x32, 0x2E, 0x34, 0x32, 0x3A, 0x31, 0x30, 0x39, 0x38,
    0x0D, 0x0A, 0x46, 0x72, 0x6F, 0x6D, 0x3A, 0x20, 0x73, 0x69, 0x70, 0x3A, 0x61, 0x63, 0x61, 0x70,
    0x70, 0x40, 0x31, 0x37, 0x32, 0x2E, 0x33, 0x31, 0x2E, 0x39, 0x34, 0x2E, 0x38, 0x31, 0x0D, 0x0A,
    0x54, 0x6F, 0x3A, 0x20, 0x3C, 0x73, 0x69, 0x70, 0x3A, 0x2B, 0x31, 0x2D, 0x34, 0x32, 0x35, 0x2D,
    0x37, 0x30, 0x35, 0x34, 0x30, 0x37, 0x36, 0x40, 0x36, 0x33, 0x2E, 0x32, 0x31, 0x35, 0x2E, 0x32,
    0x36, 0x2E, 0x34, 0x35, 0x3B, 0x75, 0x73, 0x65, 0x72, 0x3D, 0x70, 0x68, 0x6F, 0x6E, 0x65, 0x3E,
    0x3B, 0x20, 0x74, 0x61, 0x67, 0x3D, 0x31, 0x33, 0x35, 0x31, 0x34, 0x39, 0x38, 0x2D, 0x32, 0x35,
    0x41, 0x43, 0x0D, 0x0A, 0x44, 0x61, 0x74, 0x65, 0x3A, 0x20, 0x4D, 0x6F, 0x6E, 0x2C, 0x20, 0x32,
    0x35, 0x20, 0x53, 0x65, 0x70, 0x20, 0x32, 0x30, 0x30, 0x30, 0x20, 0x32, 0x32, 0x3A, 0x35, 0x31,
    0x3A, 0x33, 0x33, 0x20, 0x47, 0x4D, 0x54, 0x0D, 0x0A, 0x43, 0x61, 0x6C, 0x6C, 0x2D, 0x49, 0x44,
    0x3A, 0x20, 0x63, 0x36, 0x33, 0x61, 0x30, 0x33, 0x32, 0x33, 0x2D, 0x32, 0x64, 0x62, 0x61, 0x2D,
    0x34, 0x61, 0x34, 0x39, 0x2D, 0x38, 0x32, 0x38, 0x63, 0x2D, 0x35, 0x66, 0x38, 0x63, 0x33, 0x62,
    0x35, 0x33, 0x64, 0x38, 0x32, 0x38, 0x40, 0x58, 0x0D, 0x0A, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72,
    0x3A, 0x20, 0x43, 0x69, 0x73, 0x63, 0x6F, 0x20, 0x56, 0x6F, 0x49, 0x50, 0x20, 0x47, 0x61, 0x74,
    0x65, 0x77, 0x61, 0x79, 0x2F, 0x20, 0x49, 0x4F, 0x53, 0x20, 0x31, 0x32, 0x2E, 0x78, 0x2F, 0x20,
    0x53, 0x49, 0x50, 0x20, 0x65, 0x6E, 0x61, 0x62, 0x6C, 0x65, 0x64, 0x0D, 0x0A, 0x43, 0x53, 0x65,
    0x71, 0x3A, 0x20, 0x31, 0x20, 0x49, 0x4E, 0x56, 0x49, 0x54, 0x45, 0x0D, 0x0A, 0x43, 0x6F, 0x6E,
    0x74, 0x65, 0x6E, 0x74, 0x2D, 0x4C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x3A, 0x20, 0x30, 0x0D, 0x0A,
    0x0D, 0x0A,    
};
    
CHAR ByeMsg[] = 
{
    0x42, 0x59, 0x45, 0x3A, 0x20, 0x73, 0x69, 0x70, 0x3A, 0x61, 0x6A, 0x61, 0x79, 0x63, 0x68, 0x37,
    0x20, 0x53, 0x49, 0x50, 0x2F, 0x32, 0x2E, 0x30, 0x0D, 0x0A, 0x56, 0x69, 0x61, 0x3A, 0x20, 0x53,
    0x49, 0x50, 0x2F, 0x32, 0x2E, 0x30, 0x2F, 0x55, 0x44, 0x50, 0x20, 0x31, 0x35, 0x37, 0x2E, 0x35,
    0x39, 0x2E, 0x31, 0x33, 0x33, 0x2E, 0x38, 0x34, 0x3A, 0x35, 0x30, 0x36, 0x30, 0x0D, 0x0A, 0x46,
    0x72, 0x6F, 0x6D, 0x3A, 0x20, 0x6D, 0x61, 0x72, 0x79, 0x77, 0x61, 0x6E, 0x20, 0x3C, 0x73, 0x69,
    0x70, 0x3A, 0x6D, 0x61, 0x72, 0x79, 0x77, 0x61, 0x6E, 0x40, 0x4D, 0x41, 0x52, 0x59, 0x57, 0x2D,
    0x44, 0x3E, 0x0D, 0x0A, 0x54, 0x6F, 0x3A, 0x20, 0x73, 0x69, 0x70, 0x3A, 0x61, 0x6A, 0x61, 0x79,
    0x63, 0x68, 0x37, 0x0D, 0x0A, 0x43, 0x61, 0x6C, 0x6C, 0x2D, 0x49, 0x44, 0x3A, 0x20, 0x31, 0x32,
    0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x40, 0x31, 0x35, 0x37, 0x2E, 0x35, 0x39, 0x2E, 0x31,
    0x33, 0x33, 0x2E, 0x38, 0x34, 0x0D, 0x0A, 0x43, 0x53, 0x65, 0x71, 0x3A, 0x20, 0x32, 0x20, 0x42,
    0x59, 0x45, 0x0D, 0x0A, 0x55, 0x73, 0x65, 0x72, 0x2D, 0x41, 0x67, 0x65, 0x6E, 0x74, 0x3A, 0x20,
    0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66, 0x74, 0x50, 0x68, 0x6F, 0x65, 0x6E, 0x69, 0x78,
    0x2F, 0x31, 0x2E, 0x30, 0x0D, 0x0A, 0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x4C, 0x65,
    0x6E, 0x67, 0x74, 0x68, 0x3A, 0x20, 0x30, 0x0D, 0x0A, 0x0D, 0x0A,
};


CHAR SipTortureMsg[] =
"INVITE sip:vivekg@chair.dnrc.bell-labs.com SIP/2.0\r\n"
"TO :\r\n"
" sip:vivekg@chair.dnrc.bell-labs.com ;   tag    = 1a1b1f1H33n\r\n"
"From   : \"J Rosenberg \\\\\\\"\" <sip:jdrosen@lucent.com>\r\n"
"  ;\r\n"
"  tag = 98asjd8\r\n"
"CaLl-Id\r\n"
" : 0ha0isndaksdj@10.1.1.1\r\n"
"cseq: 8\r\n"
"  INVITE\r\n"
"Via  : SIP  /   2.0 \r\n"
" /UDP \r\n"
"    135.180.130.133 : 1234 \r\n"
"Subject :\r\n"
"NewFangledHeader:   newfangled value\r\n"
" more newfangled value\r\n"
"Contact: Ajay Chitturi <sip:ajaych@microsoft.com;tag=0.4>\r\n"
"Content-Type: application/sdp\r\n"
"v:  SIP  / 2.0  / TCP     12.3.4.5   ;\r\n"
"  branch  =   9ikj8  ,\r\n"
" SIP  /    2.0   / UDP  1.2.3.4   ; hidden   \r\n"
"m:\"Quoted string \\\"\\\"\" <sip:jdrosen@bell-labs.com> ; newparam = newvalue ;\r\n"
"  secondparam = secondvalue  ; q = 0.33  ,\r\n"
// "  (((nested comments) and (more)))   ,\r\n"
" tel:4443322\r\n"
"\r\n"
"v=0\r\n"
"o=mhandley 29739 7272939 IN IP4 126.5.4.3\r\n"
"c=IN IP4 135.180.130.88\r\n"
"m=audio 492170 RTP/AVP 0 12\r\n"
"m=video 3227 RTP/AVP 31\r\n"
"a=rtpmap:31 LPC\r\n"
;

void DumpViaHeader(SIP_MESSAGE *pSipMsg)
{
    COUNTED_STRING *ViaHeaderArray;
    ULONG           NumViaHeaders;
    HRESULT         hr;
    ULONG           i;
    ULONG           BytesParsed;
    COUNTED_STRING  Host;
    USHORT          Port;
    
    printf("Testing DumpViaHeader\n");
    hr = pSipMsg->GetStoredMultipleHeaders(SIP_HEADER_VIA, &ViaHeaderArray,
                                      &NumViaHeaders);
    printf("GetStoredMultipleHeaders hr: %x NumViaHeaders: %d\n",
           hr, NumViaHeaders);

    for (i = 0; i < NumViaHeaders; i++)
    {
        BytesParsed = 0;
        hr = ParseFirstViaHeader(ViaHeaderArray[i].Buffer,
                                 ViaHeaderArray[i].Length,
                                 &BytesParsed,
                                 &Host, &Port);
        printf("ParseFirstViaHeader: %d, hr %x, BytesParsed: %d\n",
               i, hr, BytesParsed);
        printf("ViaHeader : %s Length %d\n",
               ViaHeaderArray[i].Buffer, ViaHeaderArray[i].Length);
        printf("Host: %.*s Port: %d\n\n",
               Host.Length,
               Host.Buffer,
               Port);
            
    }
}


void DumpContactHeader(SIP_MESSAGE *pSipMsg)
{
    HRESULT hr;
    LIST_ENTRY ContactList;

    InitializeListHead(&ContactList);
    
    hr = pSipMsg->ParseContactHeaders(&ContactList);
    if (hr != S_OK)
    {
        printf("ParseContactHeaders failed %x\n", hr);
        return;
    }

    printf("Printing contact headers\n");
    
    LIST_ENTRY      *pListEntry;
    CONTACT_HEADER  *pContactHeader;
    
    pListEntry = ContactList.Flink;
    
    while (pListEntry != &ContactList)
    {
        pContactHeader = CONTAINING_RECORD(pListEntry,
                                           CONTACT_HEADER,
                                           m_ListEntry);

        printf("DisplayName: %.*s SIP URL: %.*s QValue: %lf\n",
               pContactHeader->m_DisplayName.Length,
               pContactHeader->m_DisplayName.Buffer,
               pContactHeader->m_SipUrl.Length,
               pContactHeader->m_SipUrl.Buffer,
               pContactHeader->m_QValue);
        
        pListEntry = pListEntry->Flink;
    }
}

void DumpHeader(SIP_MESSAGE    *pSipMsg,
                SIP_HEADER_ENUM HeaderId)
{
    HRESULT hr;
    
    SIP_HEADER_ENTRY  *pHeaderEntry;
    DWORD              HeaderCount;
    OFFSET_STRING DisplayName;
    OFFSET_STRING AddrSpec;
    OFFSET_STRING Comments;
    ULONG         BytesParsed = 0;

    PSTR               FromHeader;
    ULONG              FromHeaderLen;

    printf("Testing GetHeader() %s:\n", GetSipHeaderName(HeaderId)->Buffer);
    hr = pSipMsg->GetHeader(HeaderId, &pHeaderEntry, &HeaderCount);
    
    printf("Testing GetHeader() %s HeaderCount: %d hr: %x\n",
           GetSipHeaderName(HeaderId)->Buffer,
           HeaderCount, hr);
    FromHeaderLen = pHeaderEntry->HeaderValue.Length;
    FromHeader    = pHeaderEntry->HeaderValue.GetString(pSipMsg->BaseBuffer);
    
    printf("Testing ParseNameAddrOrAddrSpec : %.*s\n",
           FromHeaderLen, FromHeader);
    hr = ParseNameAddrOrAddrSpec(FromHeader, FromHeaderLen, &BytesParsed,
                                 '\0', //No header list end
                                 &DisplayName, &AddrSpec);
    
    printf("hr: %x BufLen: %d BytesParsed: %d\n", hr, FromHeaderLen, BytesParsed);
    printf("DisplayName : %.*s\n",
           DisplayName.GetLength(),
           DisplayName.GetString(FromHeader));
    printf("AddrSpec : %.*s\n",
           AddrSpec.GetLength(),
           AddrSpec.GetString(FromHeader));
}


void DumpSipMsg(SIP_MESSAGE *pSipMsg)
{
    printf("Dumping SIP Message :\n");
    printf("MsgType    : %d\n", pSipMsg->MsgType);
    printf("ParseState : %d\n", pSipMsg->ParseState);
    printf("ContentLengthSpecified : %d\n", pSipMsg->ContentLengthSpecified);

    if (pSipMsg->MsgType == SIP_MESSAGE_TYPE_REQUEST)
    {
        printf("MethodId : %d MethodText : %.*s\nRequest URI: %.*s\n",
               pSipMsg->Request.MethodId,
               pSipMsg->Request.MethodText.GetLength(),
               pSipMsg->Request.MethodText.GetString(pSipMsg->BaseBuffer),
               pSipMsg->Request.RequestURI.GetLength(),
               pSipMsg->Request.RequestURI.GetString(pSipMsg->BaseBuffer));
    }
    else
    {
    }
    
    LIST_ENTRY        *pListEntry;
    SIP_HEADER_ENTRY  *pHeaderEntry;
    DWORD              HeaderCount;

    pListEntry = pSipMsg->m_HeaderList.Flink;

    while(pListEntry != &pSipMsg->m_HeaderList)
    {
        pHeaderEntry = CONTAINING_RECORD(pListEntry,
                                         SIP_HEADER_ENTRY,
                                         ListEntry);
        printf("HeaderId: %d, HeaderName: %.*s, HeaderValue: %.*s HeaderValueLen: %d\n",
               pHeaderEntry->HeaderId,
               pHeaderEntry->HeaderName.GetLength(),
               pHeaderEntry->HeaderName.GetString(pSipMsg->BaseBuffer),
               pHeaderEntry->HeaderValue.GetLength(),
               pHeaderEntry->HeaderValue.GetString(pSipMsg->BaseBuffer),
               pHeaderEntry->HeaderValue.GetLength()
               );
        pListEntry = pListEntry->Flink;
    }

    if (pSipMsg->MsgBody.Length != 0)
    {
        printf("MsgBody: %.*s\n MsgBody Length: %d\n",
               pSipMsg->MsgBody.GetLength(),
               pSipMsg->MsgBody.GetString(pSipMsg->BaseBuffer),
               pSipMsg->MsgBody.GetLength()
               );
    }

    printf("Testing GetHeader() Via:\n");
    HRESULT hr = pSipMsg->GetHeader(SIP_HEADER_VIA, &pHeaderEntry, &HeaderCount);
    printf("Testing GetHeader() Via HeaderCount: %d hr: %x\n", HeaderCount, hr);
    if (hr == S_OK && HeaderCount > 0)
    {
        pListEntry = &pHeaderEntry->ListEntry;
        for (ULONG i = 0; i < HeaderCount; i++)
        {
            pHeaderEntry = CONTAINING_RECORD(pListEntry,
                                             SIP_HEADER_ENTRY,
                                             ListEntry);
            printf("HeaderId: %d, HeaderName: %.*s, HeaderValue: %.*s\n\n",
                   pHeaderEntry->HeaderId,
                   pHeaderEntry->HeaderName.GetLength(),
                   pHeaderEntry->HeaderName.GetString(pSipMsg->BaseBuffer),
                   pHeaderEntry->HeaderValue.GetLength(),
                   pHeaderEntry->HeaderValue.GetString(pSipMsg->BaseBuffer)
                   );
            pListEntry = pListEntry->Flink;
        }
    }
    
    printf("Testing GetHeader() Route:\n");
    hr = pSipMsg->GetHeader(SIP_HEADER_ROUTE, &pHeaderEntry, &HeaderCount);
    printf("Testing GetHeader() Route HeaderCount: %d hr: %x\n",
           HeaderCount, hr);

    DumpHeader(pSipMsg, SIP_HEADER_FROM);
    DumpHeader(pSipMsg, SIP_HEADER_TO);

    DumpViaHeader(pSipMsg);

    DumpContactHeader(pSipMsg);
    
    printf("Before FreeHeaderList() - IsEmpty: %d\n",
           IsListEmpty(&pSipMsg->m_HeaderList));
    pSipMsg->FreeHeaderList();
    printf("After FreeHeaderList() - IsEmpty: %d\n",
           IsListEmpty(&pSipMsg->m_HeaderList));
}


VOID
TestSipUrlParsing()
{
    HRESULT       hr;
    OFFSET_STRING Host;
    ULONG         i, j;
    USHORT        Port;
    ULONG         BytesParsed = 0;
    PSTR SipUrls[] =
    {
        "sip:ABCD;a=b@host",
        "sip:ABCD;a=b@host1;c=d@host2",
        "sip:ABCD;a=b%40host",
        "sip:ABCD;a=b%40host1;c=d@host2",
        "sip:radus:bubu@microsoft.com;maddr=172.31.94.80;user=ip?Authorization=xxxxxx&Subject=Hi"
    };
    
    for (i = 0; i < (sizeof(SipUrls)/sizeof(PSTR)); i++)
    {
        SIP_URL *pDecodedSipUrl = new SIP_URL;
        if (pDecodedSipUrl == NULL)
        {
            printf("allocating pDecodedSipUrl failed\n");
            exit(1);
        }

        BytesParsed = 0;
        hr = ParseSipUrl(SipUrls[i], strlen(SipUrls[i]), &BytesParsed,
                         pDecodedSipUrl);
        printf("ParseSipUrl(%s) : hr: %x  BytesParsed: %d\n",
               SipUrls[i], hr, BytesParsed);

        printf("\tUser : %.*s Password : %.*s\n",
               COUNTED_STRING_PRINTF(&pDecodedSipUrl->m_User),
               COUNTED_STRING_PRINTF(&pDecodedSipUrl->m_Password));
        
        printf("\tHost : %.*s Port : %d TransportParam: %d\n",
               COUNTED_STRING_PRINTF(&pDecodedSipUrl->m_Host),
               pDecodedSipUrl->m_Port, pDecodedSipUrl->m_TransportParam);

        for(j = 0; j < SIP_URL_PARAM_MAX; j++)
        {
            printf("\tKnown Param %d : %.*s\n",
                   j, COUNTED_STRING_PRINTF(&pDecodedSipUrl->m_KnownParams[j]));
        }

        LIST_ENTRY      *pListEntry;
        SIP_URL_PARAM   *pSipUrlParam;
        SIP_URL_HEADER  *pSipUrlHeader;

        pListEntry = pDecodedSipUrl->m_OtherParamList.Flink;

        while (pListEntry != &pDecodedSipUrl->m_OtherParamList)
        {
            pSipUrlParam = CONTAINING_RECORD(pListEntry,
                                             SIP_URL_PARAM,
                                             m_ListEntry);

            printf("\tOther Param name : %.*s value : %.*s\n",
                   COUNTED_STRING_PRINTF(&pSipUrlParam->m_ParamName),
                   COUNTED_STRING_PRINTF(&pSipUrlParam->m_ParamValue));
            
            pListEntry = pListEntry->Flink;
        }
        
        pListEntry = pDecodedSipUrl->m_HeaderList.Flink;
        
        while (pListEntry != &pDecodedSipUrl->m_HeaderList)
        {
            pSipUrlHeader = CONTAINING_RECORD(pListEntry,
                                              SIP_URL_HEADER,
                                              m_ListEntry);

            printf("\tHeader Id: %d name : %.*s value : %.*s\n",
                   pSipUrlHeader->m_HeaderId,
                   COUNTED_STRING_PRINTF(&pSipUrlHeader->m_HeaderName),
                   COUNTED_STRING_PRINTF(&pSipUrlHeader->m_HeaderValue));
            
            pListEntry = pListEntry->Flink;
        }

        printf("\n\n");
        
        delete pDecodedSipUrl;
        pDecodedSipUrl = NULL;
    }
}


VOID
TestSipUrlResolution()
{
    HRESULT       hr;
    OFFSET_STRING Host;
    ULONG         i;
    SIP_TRANSPORT Transport;
    SOCKADDR_IN   DstAddr;
    
    PSTR SipUrls[] =
    {
        "sip:radus@172.31.77.50",
        "sip:ABCD;a=b@radus1;c=d@host2",
    };
    
    for (i = 0; i < (sizeof(SipUrls)/sizeof(PSTR)); i++)
    {
        hr = ResolveSipUrl(SipUrls[i], strlen(SipUrls[i]),
                           &DstAddr, &Transport);
        printf("ResolveSipUrl(%s) : hr: %x ip: %d.%d.%d.%d:%d\n",
               SipUrls[i], hr,
               PRINT_SOCKADDR(&DstAddr));
    }
}


VOID
TestFromToParsing()
{
    int i = 0;
    ULONG BytesParsed = 0;
    HRESULT hr;
    
    
    PSTR FromHeaders[] =
    {
        "abcd def <sip:ABCD> ; tag = abc ; param1 = lkjlkj",
        "\"abcd def\" <sip:ABCD> ; tag = abc ; param1 = lkjlkj",
        "<sip:ABCD> ; tag = abc ; param1 = lkjlkj",
    };

    for (i = 0; i < (sizeof(FromHeaders)/sizeof(PSTR)); i++)
    {
        BytesParsed = 0;
        FROM_TO_HEADER *pFromToHeader = new FROM_TO_HEADER;
        if (pFromToHeader == NULL)
        {
            printf("allocating pFromToHeader failed\n");
            exit(1);
        }

        BytesParsed = 0;
        hr = ParseFromOrToHeader(FromHeaders[i], strlen(FromHeaders[i]), &BytesParsed,
                                 pFromToHeader);
        printf("ParseFromOrToHeader(%s) : hr: %x  BytesParsed: %d\n",
               FromHeaders[i], hr, BytesParsed);

        printf("\tDisplayName : <%.*s> SipUrl : <%.*s>\n",
               COUNTED_STRING_PRINTF(&pFromToHeader->m_DisplayName),
               COUNTED_STRING_PRINTF(&pFromToHeader->m_SipUrl));
        
        printf("\tTagValue : <%.*s>\n",
               COUNTED_STRING_PRINTF(&pFromToHeader->m_TagValue));

        LIST_ENTRY         *pListEntry;
        SIP_HEADER_PARAM   *pParam;

        pListEntry = pFromToHeader->m_ParamList.Flink;

        while (pListEntry != &pFromToHeader->m_ParamList)
        {
            pParam = CONTAINING_RECORD(pListEntry,
                                       SIP_HEADER_PARAM,
                                       m_ListEntry);

            printf("\tOther Param name : <%.*s> value : <%.*s>\n",
                   COUNTED_STRING_PRINTF(&pParam->m_ParamName),
                   COUNTED_STRING_PRINTF(&pParam->m_ParamValue));
            
            pListEntry = pListEntry->Flink;
        }

        printf("\n\n");
        
        delete pFromToHeader;
        pFromToHeader = NULL;
    }
}


struct INT_LIST_ENTRY
{
    LIST_ENTRY m_ListEntry;
    int        m_Number;
};


VOID PrintIntList(LIST_ENTRY *pListHead)
{
    LIST_ENTRY *pListEntry = pListHead->Flink;

    printf("Printing List:");
    
    while(pListEntry != pListHead)
    {
        printf("\t%d", ((INT_LIST_ENTRY *)pListEntry)->m_Number);
        pListEntry = pListEntry->Flink;
    }
    
    printf("\n\n");
}

VOID PrintIntListBackward(LIST_ENTRY *pListHead)
{
    LIST_ENTRY *pListEntry = pListHead->Blink;

    printf("Printing List:");
    
    while(pListEntry != pListHead)
    {
        printf("\t%d", ((INT_LIST_ENTRY *)pListEntry)->m_Number);
        pListEntry = pListEntry->Blink;
    }
    
    printf("\n\n");
}

VOID
TestReverseLinkedList()
{
    INT_LIST_ENTRY le1 = {{0, 0}, 1};
    INT_LIST_ENTRY le2 = {{0, 0}, 2};
    INT_LIST_ENTRY le3 = {{0, 0}, 3};

    printf("TestReverseLinkedList\n");
    
    LIST_ENTRY ListHead;
    InitializeListHead(&ListHead);

    PrintIntList(&ListHead);
    ReverseList(&ListHead);
    PrintIntList(&ListHead);

    InsertTailList(&ListHead, &le1.m_ListEntry);
    PrintIntList(&ListHead);
    ReverseList(&ListHead);
    PrintIntList(&ListHead);
    PrintIntListBackward(&ListHead);

    InsertTailList(&ListHead, &le2.m_ListEntry);
    PrintIntList(&ListHead);
    ReverseList(&ListHead);
    PrintIntList(&ListHead);
    PrintIntListBackward(&ListHead);
    ReverseList(&ListHead);
    PrintIntList(&ListHead);
    PrintIntListBackward(&ListHead);
    
    InsertTailList(&ListHead, &le3.m_ListEntry);
    PrintIntList(&ListHead);
    PrintIntListBackward(&ListHead);
    ReverseList(&ListHead);
    PrintIntList(&ListHead);
    PrintIntListBackward(&ListHead);
}


HRESULT
CreateCallId(PSTR *pCallId)
{
    UUID   Uuid;
    UCHAR *UuidStr;
    
    RPC_STATUS hr = ::UuidCreate(&Uuid);
    if (hr != RPC_S_OK)
    {
        return E_FAIL;
    }

    hr = UuidToStringA(&Uuid, &UuidStr);
    if (hr != RPC_S_OK)
    {
        return E_FAIL;
    }

    ULONG m_CallIdLen = strlen((PSTR)UuidStr) + 1;
    PSTR  m_CallId = (PSTR) malloc(m_CallIdLen);
    if (m_CallId == NULL)
        return E_OUTOFMEMORY;
    strncpy(m_CallId, (PSTR)UuidStr, m_CallIdLen);

    RpcStringFreeA(&UuidStr);
    *pCallId = m_CallId;
    return S_OK;
}


VOID
TestRandomNumberStuff()
{
   int i;

   /* Seed the random-number generator with current time so that
    * the numbers will be different every time we run.
    */
   //srand( (unsigned)time( NULL ) );
   srand( (unsigned)GetTickCount() );

   /* Display 10 numbers. */
   for( i = 0;   i < 10;i++ )
      printf( "  %6d\n", rand() );

   // printf("sleeping...");
   //Sleep(10000);
   printf("2nd");
   
   srand( (unsigned)GetTickCount() );

   /* Display 10 numbers. */
   for( i = 0;   i < 10;i++ )
      printf( "  %6d\n", rand() );
}


int
__cdecl main(int argc, char *argv[])
{
    WSADATA     WsaData;
    int         err;

    LOGREGISTERDEBUGGER(_T("SIPMSG"));
    LOGREGISTERTRACING(_T("SIPMSG"));
    
    // Initialize Winsock
    err = WSAStartup (MAKEWORD (1, 1), &WsaData);
    if (err != 0)
    {
        printf("WSAStartup failed %x", err);
        exit(1);
    }

    TestRandomNumberStuff();
    
    SIP_MESSAGE SipMsg;
    HRESULT hr;

    ULONG BytesParsed = 0;
    
    hr = ParseSipMessageIntoHeadersAndBody(
             SipTortureMsg, sizeof(SipTortureMsg) - 1,
             &BytesParsed, TRUE, &SipMsg
             );
    
    if (hr != S_OK)
    {
        printf("Parse() failed %x\n", hr);
        return 1;
    }

    DumpSipMsg(&SipMsg);
    

    printf("\n\n");
    TestSipUrlParsing();
    printf("\n\n");

    printf("\n\n");
    TestFromToParsing();
    printf("\n\n");
    
    printf("\n\n");
    TestReverseLinkedList();
    printf("\n\n");
    
    printf("\n\n");
    TestSipUrlResolution();
    printf("\n\n");
     
    PSTR pCallId;
    printf("Testing create callid\n");
    hr = CreateCallId(&pCallId);
    printf("CallId: %s\n", pCallId);

    hr = CreateCallId(&pCallId);
    printf("CallId: %s\n", pCallId);


#if 0  // 0 ******* Region Commented Out Begins *******
    // Bye SIP msg
    SIP_MESSAGE ByeSipMsg;

    BytesParsed = 0;
    
    hr = ParseSipMessageIntoHeadersAndBody(
             ByeMsg, sizeof(ByeSipMsg),
             &BytesParsed, TRUE, &ByeSipMsg
             );
    
    if (hr != S_OK)
    {
        printf("Bye Parse() failed %x\n", hr);
        return 1;
    }

    DumpSipMsg(&ByeSipMsg);

    // 410
    SIP_MESSAGE SipMsg405;

    BytesParsed = 0;
    
    hr = ParseSipMessageIntoHeadersAndBody(
             Msg405, sizeof(Msg405),
             &BytesParsed, TRUE, &SipMsg405
             );
    
    if (hr != S_OK)
    {
        printf("405 Parse() failed %x\n", hr);
        return 1;
    }

    DumpSipMsg(&SipMsg405);
#endif // 0 ******* Region Commented Out Ends   *******
    
    SIP_MESSAGE SipMsg1Byte;

    BytesParsed = 0;
    
    hr = ParseSipMessageIntoHeadersAndBody(
             Msg1Byte, sizeof(Msg1Byte),
             &BytesParsed, TRUE, &SipMsg1Byte
             );
    
    if (hr != S_OK)
    {
        printf("1byte Parse() failed %x\n", hr);
        return 1;
    }

    DumpSipMsg(&SipMsg1Byte);
    
    // Shutdown Winsock
    err = WSACleanup();
    if (err != 0)
    {
        printf("WSACleanup failed %x", err);
        return 1;
    }
    
    LOGDEREGISTERDEBUGGER();
    LOGDEREGISTERTRACING();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\sockmgr.h ===
#ifndef __sipcli_sockmgr_h__
#define __sipcli_sockmgr_h__

#include "asock.h"

class SIP_STACK;

// We need to maintain a Recv() request for each socket
// always. We need to handle the recv completions and
// buffers for the recv requests. We also need to do the
// decoding for the buffers received and map the message
// to the right SIP_CALL and call ProcessMessage() on the SIP_CALL.
// We should take care of canceling the recv() requests on
// socket shutdown.

class SOCKET_MANAGER :
    public ACCEPT_COMPLETION_INTERFACE
{
public:
    SOCKET_MANAGER(
        IN SIP_STACK *pSipStack
        );
    ~SOCKET_MANAGER();

    void AddSocketToList(
        IN  ASYNC_SOCKET *pAsyncSock
        );

    // RemoveSocket(ASYNC_SOCKET *pAsyncSock);

    HRESULT GetSocketToDestination(
        IN  SOCKADDR_IN                     *pDestAddr,
        IN  SIP_TRANSPORT                    Transport,
        IN  LPCWSTR                          RemotePrincipalName,
        IN  CONNECT_COMPLETION_INTERFACE    *pConnectCompletion,
        IN  HttpProxyInfo                   *pHPInfo,
        OUT ASYNC_SOCKET                   **ppAsyncSocket
        );

    void DeleteUnusedSocketsOnTimer();

    // accept completion
    void OnAcceptComplete(
        IN DWORD ErrorCode,
        IN ASYNC_SOCKET *pAcceptedSocket
        );

private:

    SIP_STACK   *m_pSipStack;

    // List of ASYNC_SOCKETs
    LIST_ENTRY   m_SocketList;

    HRESULT GetNewSocketToDestination(
        IN  SOCKADDR_IN                     *pDestAddr,
        IN  SIP_TRANSPORT                    Transport,
        IN  LPCWSTR                          RemotePrincipalName,
        IN  CONNECT_COMPLETION_INTERFACE    *pConnectCompletion,
        IN  HttpProxyInfo                   *pHPInfo,
    OUT ASYNC_SOCKET                   **ppAsyncSocket
        );
    
};

// extern SOCKET_MANAGER g_SockMgr;

#endif // __sipcli_sockmgr_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\timer.h ===
#ifndef __sipcli_timer_h__
#define __sipcli_timer_h__

#define TIMER_WINDOW_CLASS_NAME     \
    _T("SipTimerWindowClassName-84b7f915-2389-4204-9eb5-16f4c522816f")


class TIMER_MGR;
struct TIMER_QUEUE_ENTRY;

class __declspec(novtable) TIMER
{
public:
    inline TIMER(
        IN TIMER_MGR *pTimerMgr
        // IN HWND TimerWindow
        );
    inline ~TIMER();

    HRESULT StartTimer(
        IN UINT TimeoutValue
        );

    HRESULT KillTimer();

    void OnTimerExpireCommon();
    
    // Implemented by classes that inherit TIMER
    virtual void OnTimerExpire() = 0;
    
    inline BOOL IsTimerActive();

    inline TIMER_QUEUE_ENTRY *GetTimerQueueEntry();
    
private:
    //UINT_PTR TimerId;
    //HWND    m_TimerWindow;
    TIMER_MGR          *m_pTimerMgr;
    TIMER_QUEUE_ENTRY  *m_pTimerQEntry;
    // XXX Could probably get rid of the timeout value
    UINT                m_TimeoutValue;
};


inline
TIMER::TIMER(
    IN TIMER_MGR *pTimerMgr
    // IN HWND TimerWindow
    )
{
    // m_TimerWindow = TimerWindow;
    m_pTimerMgr = pTimerMgr;
    m_pTimerQEntry = NULL;
    m_TimeoutValue  = 0;
}


inline
TIMER::~TIMER()
{
    // ASSERT(!IsTimerActive());
    if (IsTimerActive())
    {
        KillTimer();
    }
}


inline BOOL
TIMER::IsTimerActive()
{
    return !(m_TimeoutValue == 0);
}


inline TIMER_QUEUE_ENTRY *
TIMER::GetTimerQueueEntry()
{
    return m_pTimerQEntry;
}


enum TIMERQ_STATE
{
    TIMERQ_STATE_INIT = 0,

    TIMERQ_STATE_STARTED,

    // State when the timer expired and we have posted
    // a message to the window for processing the timer
    // callback.
    TIMERQ_STATE_EXPIRED,

    // State when the timer is killed and we have posted
    // a message to the window for processing the timer
    // callback.
    TIMERQ_STATE_KILLED
};

// StartTimer() adds this entry to the queue and KillTimer() removes
// this entry from the queue.
// Note that we can not reuse the TIMER structure for the TIMER_QUEUE_ENTRY
// structure as sometimes the TIMER_QUEUE_ENTRY structure will have to
// live beyond the lifetime of the TIMER structure.

struct TIMER_QUEUE_ENTRY
{
    TIMER_QUEUE_ENTRY(
        IN TIMER *pTimer,
        IN ULONG  TimeoutValue
        );

    LIST_ENTRY      m_ListEntry;
    ULONG           m_ExpireTickCount;
    TIMER          *m_pTimer;
    // Used to deal with the scenario where a timer is killed
    // when the windows message for calling the timer callback
    // for the timer is still in the message queue.
    //BOOL        m_IsTimerKilled;
    TIMERQ_STATE    m_TimerQState;
};


class TIMER_MGR
{
public:

    TIMER_MGR();

    ~TIMER_MGR();
    
    HRESULT Start();

    HRESULT Stop();

    HRESULT StartTimer(
        IN  TIMER              *pTimer,
        IN  ULONG               TimeoutValue,
        OUT TIMER_QUEUE_ENTRY **ppTimerQEntry 
        );

    HRESULT KillTimer(
        IN TIMER *pTimer
        );
    
    VOID OnMainTimerExpire();

    inline VOID DecrementNumExpiredListEntries();

    inline ULONG GetNumExpiredListEntries();
    
private:

    // Queue of timers (List of TIMER_QUEUE_ENTRY structures)
    // Sorted by m_ExpireTickCount
    LIST_ENTRY  m_TimerQueue;
    ULONG       m_NumTimerQueueEntries;

    LIST_ENTRY  m_ExpiredList;
    ULONG       m_NumExpiredListEntries;
    
    HWND        m_TimerWindow;

    BOOL        m_IsMainTimerActive;
    ULONG       m_MainTimerTickCount;
    BOOL        m_isTimerStopped;

    HRESULT ProcessTimerExpire(
        IN TIMER_QUEUE_ENTRY *pTimerQEntry
        );

    VOID AdjustMainTimer();
    
    TIMER_QUEUE_ENTRY *FindTimerQueueEntryInList(
        TIMER       *pTimer,
        LIST_ENTRY  *pListHead
        );
    
    BOOL IsTimerTickCountLessThanOrEqualTo(
        IN ULONG TickCount1,
        IN ULONG TickCount2
        );

    HRESULT CreateTimerWindow();

    VOID DebugPrintTimerQueue();
};


inline ULONG
TIMER_MGR::GetNumExpiredListEntries()
{
    return m_NumExpiredListEntries;
}

inline VOID
TIMER_MGR::DecrementNumExpiredListEntries()
{
    m_NumExpiredListEntries--;
}

#endif // __sipcli_timer_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\siptest\main.cpp ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
// Win32
#include <windows.h>
#include <shellapi.h>
#include <rpc.h>

#include "rtcsip.h"
#include "rtclog.h"

#include "resource.h"

#include "..\..\inc\obj\i386\rtcsip_i.c"

#include "atlbase.h"
// Used by ATL
CComModule _Module;
//BEGIN_OBJECT_MAP(ObjectMap)
//END_OBJECT_MAP()
HWND                g_hDlg          = NULL;
HWND                g_hWnd          = NULL;
ISipCall           *g_pSipCall      = NULL;
SIP_CALL_STATE      g_SipCallState  = SIP_CALL_STATE_IDLE;
ISipStack          *g_pSipStack     = NULL;
IRTCMediaManage    *g_pMediaManager = NULL;

// Utility functions
WCHAR gMsgBoxTitle[] = L"Phoenix SIP stack Test Application";
void
DoMessage (
	LPWSTR pszMessage
	)
{
	MessageBox (
		g_hDlg,
		pszMessage,
		gMsgBoxTitle,
		MB_OK
		);
}


void
SetStatusMessage(
	LPWSTR pszMessage
	)
{
	SetDlgItemText(g_hDlg, IDC_STATUS, pszMessage);
}


void Usage(LPWSTR wsExeName)
{
    printf("Usage: %ls [-call SIP-URL]\n", wsExeName);
    exit(1);
}

struct SIP_STACK_NOTIFY :
    public ISipStackNotify
{
    // IUnknown
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);

    // ISipStackNotify
    STDMETHODIMP NotifyProviderStatusChange(
        IN  SIP_PROVIDER_STATUS *   ProviderStatus
        );
    STDMETHODIMP OfferCall(
        IN  ISipCall        *pSipCall,
        IN  SIP_PARTY_INFO  *pCallerInfo
        );
};

struct SIP_CALL_NOTIFY :
    public ISipCallNotify
{
    // IUnknown
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);

    // ISipCallNotify
    STDMETHODIMP NotifyCallChange(
        IN  SIP_CALL_STATUS *   CallStatus
        );
    STDMETHODIMP NotifyPartyChange(
        IN  SIP_PARTY_INFO *    PartyInfo
        );

};

SIP_STACK_NOTIFY g_SipStackNotify;
SIP_CALL_NOTIFY  g_SipCallNotify;


STDMETHODIMP
SIP_STACK_NOTIFY::NotifyProviderStatusChange(
        IN  SIP_PROVIDER_STATUS *   ProviderStatus
        )
{
    return E_NOTIMPL;
}

STDMETHODIMP
SIP_STACK_NOTIFY::OfferCall(
    IN  ISipCall        *pSipCall,
    IN  SIP_PARTY_INFO  *pCallerInfo
    )
{
    HRESULT hr;
    WCHAR   Message[300];
    
    printf("SIP_STACK_NOTIFY::OfferCall called\n");
    // immediately accept
    if (g_pSipCall != NULL)
    {
        hr = pSipCall->Reject(486);
        printf("Currently busy rejecting call hr: %x\n", hr);
        return S_OK;
    }

    swprintf(Message, L"Incoming Call from DName: %ls... URL: %ls",
             pCallerInfo->DisplayName,
             pCallerInfo->URI);
    SetStatusMessage(Message);
    
    g_pSipCall = pSipCall;
    g_pSipCall->AddRef();
    g_SipCallState = SIP_CALL_STATE_OFFERING;
    
    hr = g_pSipCall->SetNotifyInterface(&g_SipCallNotify);
    if (hr != S_OK)
    {
        printf("g_pSipCall->SetNotifyInterface failed: %x\n", hr);
        return hr;
    }

    return S_OK;
}

    
STDMETHODIMP
SIP_CALL_NOTIFY::NotifyCallChange(
    IN  SIP_CALL_STATUS *   CallStatus
    )
{
    printf("SIP_CALL_NOTIFY::NotifyCallChange called CallState: %d\n",
           CallStatus->State);
    g_SipCallState = CallStatus->State;
    
    switch (CallStatus->State)
    {
    case SIP_CALL_STATE_ALERTING:
        SetStatusMessage(L"Ringing......");
        break;
    case SIP_CALL_STATE_CONNECTED:
        SetStatusMessage(L"Call Connected!");
        break;
    case SIP_CALL_STATE_REJECTED:
        SetStatusMessage(L"Call Rejected!");
        ASSERT(g_pSipCall);
        g_pSipCall->Release();
        g_pSipCall = NULL;
        break;
    case SIP_CALL_STATE_DISCONNECTED:
        SetStatusMessage(L"Call Disconnected!");
        ASSERT(g_pSipCall);
        g_pSipCall->Release();
        g_pSipCall = NULL;
        break;
    };
    
    
    return S_OK;
}


STDMETHODIMP
SIP_CALL_NOTIFY::NotifyPartyChange(
    IN  SIP_PARTY_INFO *    PartyInfo
    )
{
    return E_NOTIMPL;
}



//IUnknown implementations.

// Do nothing for AddRef()/Release()
STDMETHODIMP_(ULONG)
SIP_STACK_NOTIFY::AddRef()
{
    return 1;
}


STDMETHODIMP_(ULONG)
SIP_STACK_NOTIFY::Release()
{
    return 1;
}


STDMETHODIMP
SIP_STACK_NOTIFY::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (riid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown *>(this);
    }
    else if (riid == IID_ISipStackNotify)
    {
        *ppv = static_cast<ISipStackNotify *>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    static_cast<IUnknown *>(*ppv)->AddRef();
    return S_OK;
}


// Do nothing for AddRef()/Release()
STDMETHODIMP_(ULONG)
SIP_CALL_NOTIFY::AddRef()
{
    return 1;
}


STDMETHODIMP_(ULONG)
SIP_CALL_NOTIFY::Release()
{
    return 1;
}


STDMETHODIMP
SIP_CALL_NOTIFY::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (riid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown *>(this);
    }
    else if (riid == IID_ISipCallNotify)
    {
        *ppv = static_cast<ISipCallNotify *>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    static_cast<IUnknown *>(*ppv)->AddRef();
    return S_OK;
}


// prototype
INT_PTR CALLBACK
MainDialogProc (
	HWND hDlg,
	UINT uMsg,
	WPARAM wParam,
	LPARAM lParam
	);

int WINAPI
WinMain(
    HINSTANCE hInstance,      // handle to current instance
    HINSTANCE hPrevInstance,  // handle to previous instance
    LPSTR lpCmdLine,          // command line
    int nCmdShow              // show state
    )
{
    _Module.Init(NULL, hInstance);
    HRESULT     hr;
    LPWSTR      CommandLine;
    int         ArgC, i;
    LPWSTR     *wsArgArray;
    LPWSTR      CallUri = NULL;

    BOOL    IsCaller = FALSE;

    LOGREGISTERDEBUGGER(_T("SIP"));
    LOGREGISTERTRACING(_T("SIP"));

    LOGREGISTERDEBUGGER(_T("SIPMEDIA"));
    LOGREGISTERTRACING(_T("SIPMEDIA"));

    CommandLine = GetCommandLine();
    printf("CommandLine: %ls\n", CommandLine);

    wsArgArray = CommandLineToArgvW(CommandLine, &ArgC);
    for (i = 0; i < ArgC; i++)
    {
        printf("Arg %d : %ls\n", i, wsArgArray[i]);
    }

    if (ArgC == 3 && wcscmp(wsArgArray[1], L"-call") == 0)
    {
        IsCaller = TRUE;
        CallUri = wsArgArray[2];
        printf("Calling %ls...\n", CallUri);
    }
    else if (ArgC == 1)
    {
        IsCaller = FALSE;
    }
    else
    {
        Usage(wsArgArray[0]);
    }

    hr = CreateMediaController(&g_pMediaManager);
    if (hr != S_OK)
    {
        printf("SipCreateStack failed: %x\n", hr);
        return hr;
    }

    hr = SipCreateStack(g_pMediaManager, &g_pSipStack);
    if (hr != S_OK)
    {
        printf("SipCreateStack failed: %x\n", hr);
        return hr;
    }

    hr = g_pSipStack->SetNotifyInterface(&g_SipStackNotify);
    if (hr != S_OK)
    {
        printf("g_pSipStack->SetNotifyInterface failed: %x\n", hr);
        return hr;
    }

    hr = g_pSipStack->EnableIncomingCalls();
    if (hr != S_OK)
    {
        printf("g_pSipStack->EnableIncomingCalls failed: %x\n", hr);
        return hr;
    }

    hr = g_pSipStack->EnableStaticPort();
    if (hr != S_OK)
    {
        printf("g_pSipStack->EnableStaticPort failed: %x\n", hr);
        return hr;
    }

    //
    // Create and show the main dialog.
    //

    g_hWnd = CreateDialog(
        hInstance,
        MAKEINTRESOURCE(IDD_MAINDLG),
        NULL,
        MainDialogProc
        );

    if ( ! g_hWnd )
    {
        MessageBox(NULL, _T("CreateDialog Failed"), NULL, MB_ICONEXCLAMATION);
        printf("CreateDialog Failed %d\n", GetLastError());
        return FALSE;
    }

    ShowWindow(g_hWnd, nCmdShow);

    if (CallUri != NULL)
    {
        SetDlgItemText(g_hWnd, IDC_DEST, CallUri);
    }

    //
    // Do a message loop.
    //

    printf("Now doing message loop\n");
    MSG msg;

    while (GetMessage(&msg, NULL, 0, 0)) 
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    LOGDEREGISTERDEBUGGER();
    LOGDEREGISTERTRACING();

    return (int) msg.wParam;
}


void
OnConnect()
{
    WCHAR   DestUrl[256];
    WCHAR   Message[300];
    HRESULT hr;
    
    if (g_pSipCall == NULL)
    {
        // Start outgoing call
        
        UINT RetVal = GetDlgItemTextW(g_hDlg, IDC_DEST, DestUrl, 2048);
        if (RetVal == 0)
        {
            DoMessage(L"GetDlgItemTextW failed");
            printf("GetDlgItemTextW failed err: %x\n", GetLastError());
            return;
        }
        swprintf(Message, L"Calling %ls...", DestUrl);
        SetStatusMessage(Message);
        
        // Make a call
        hr = g_pSipStack->CreateCall(NULL, SIP_CALL_TYPE_RTP, &g_pSipCall);
        printf("CreateCall done hr : %x\n", hr);
        
        hr = g_pSipCall->SetNotifyInterface(&g_SipCallNotify);
        if (hr != S_OK)
        {
            printf("g_pSipCall->SetNotifyInterface failed: %x\n", hr);
            return;
        }
        
        hr = g_pSipCall->Connect(L"Ajaych5", L"sip:ajaych5", DestUrl, NULL);
        printf("g_pSipCall->Connect done hr : %x\n", hr);
    }
    else if (g_SipCallState == SIP_CALL_STATE_OFFERING)
    {
        // Accept incoming call
        
        hr = g_pSipCall->Accept();
        printf("g_pSipCall->Accept hr: %x\n", hr);
        SetStatusMessage(L"Accepting Call...");
    }
}



void
OnDisconnect()
{
    HRESULT hr;
    
    if (g_pSipCall == NULL)
    {
        SetStatusMessage(L"Not in a call currently!");
        return;
    }

    if (g_SipCallState == SIP_CALL_STATE_OFFERING)
    {
        // Reject incoming call
        hr = g_pSipCall->Reject(603);
        printf("User rejected call hr: 0x%x\n", hr);
        g_pSipCall->Release();
        g_pSipCall = NULL;
        SetStatusMessage(L"Call Rejected");
    }
    else
    {
        // tear down existing call
        hr = g_pSipCall->Disconnect();
        printf("User disconnected call hr: 0x%x\n", hr);

        // g_pSipCall will be released and set to NULL once we get
        // the SIP_CALL_STATE_DISCONNECTED notification
    }
}


/*//////////////////////////////////////////////////////////////////////////////
	Callback for dialog
////*/
INT_PTR CALLBACK
MainDialogProc (
	HWND hDlg,
	UINT uMsg,
	WPARAM wParam,
	LPARAM lParam
	)
{
	LPWSTR pszMessage;
	switch (uMsg)
	{
	case WM_INITDIALOG:
		{
			g_hDlg = hDlg;
			SetStatusMessage(L"Waiting for incoming SIP call");
			return 0;
		}
	case WM_COMMAND:
		{
            printf("WM_COMMAND wParam : %x\n", wParam);
            
			switch (LOWORD(wParam))
			{
			case IDC_CONNECT:
				{
                    OnConnect();
					return 1;
				}
			case IDC_DISCONNECT:
				{
					SetStatusMessage(L"Disconnect Pressed");
                    OnDisconnect();
					return 1;
				}
			case IDC_EXIT:
            case IDCANCEL:
				{
					DestroyWindow(g_hDlg);
					return 1;
				}
			}
            return 0;
		}

    case WM_DESTROY:
        PostQuitMessage(0);
        return 1;

    case WM_QUIT:
        exit(0);
	}

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\siptest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by work.rc
//
#define IDD_MAINDLG              101
#define IDC_CONNECT              1003
#define IDC_DISCONNECT           1004
#define IDC_DEST                 1005
#define IDC_STATUS               1006
#define IDC_EXIT                 1007
#define IDC_STATIC               1008

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\ssltest\httpparse.cpp ===
#include "precomp.h"
#include "httpparse.h"





struct	HEADER_MAP_ENTRY
{
	ANSI_STRING		Name;

	//
	// Offset is the byte offset in the HTTP_KNOWN_HEADERS structure.
	// The type of the field is ANSI_STRING.
	//

	ULONG			Offset;
};

static CONST HEADER_MAP_ENTRY HttpKnownHeaderMapArray [] = {

#define	HTTP_KNOWN_HEADER_ENTRY(Field,Name) \
 	{ INITIALIZE_CONST_ANSI_STRING (Name), offsetof (HTTP_KNOWN_HEADERS, Field) },
	HTTP_KNOWN_HEADER_LIST()
#undef	HTTP_KNOWN_HEADER_ENTRY

};


//
// The known header map allows the parser to take the name of
// a header and quickly locate the data structure where it should be stored.
// Maybe this is overkill, but it's easy and efficient.
//

static CONST COUNTED_ARRAY <HEADER_MAP_ENTRY> HttpKnownHeaderMap = {
	const_cast <HEADER_MAP_ENTRY *> (HttpKnownHeaderMapArray),
	sizeof HttpKnownHeaderMapArray / sizeof HttpKnownHeaderMapArray[0]
};


static INT HttpKnownHeaderSearchFunc (
	IN	CONST ANSI_STRING *			SearchKey,
	IN	CONST HEADER_MAP_ENTRY *	Comparand)
{
	return RtlCompareString (
		const_cast <ANSI_STRING *> (SearchKey),
		const_cast <ANSI_STRING *> (&Comparand -> Name), TRUE);
}

void HTTP_KNOWN_HEADERS::SetKnownHeader (
	IN	ANSI_STRING *		HeaderName,
	IN	ANSI_STRING *		HeaderValue)
{
	HEADER_MAP_ENTRY *	MapEntry;
	ANSI_STRING *		Target;

	if (HttpKnownHeaderMap.BinarySearch (HttpKnownHeaderSearchFunc, HeaderName, &MapEntry)) {
		Target = (ANSI_STRING *) (((PUCHAR) this) + MapEntry -> Offset);
		*Target = *HeaderValue;
	}
}

//
// HttpParseHeaderLine finds the division between the name of a header and the value of the header.
// It also validates the characters in the name of the header.
//

static HRESULT HttpParseHeaderLine (
	IN	ANSI_STRING *	Line,
	OUT	ANSI_STRING *	ReturnName,
	OUT	ANSI_STRING *	ReturnValue)
{
	PCHAR	Pos;
	PCHAR	End;

	Pos = Line -> Buffer;
	End = Line -> Buffer + Line -> Length / sizeof (CHAR);


	for (; Pos < End; Pos++) {
		if (*Pos == ':') {
			if (Pos == Line -> Buffer) {
				// no name present!

				ATLTRACE ("HTTP: header line had no name (%.*s)\n", ANSI_STRING_PRINTF (Line));
				return E_FAIL;
			}

			ReturnName -> Buffer = Line -> Buffer;
			ReturnName -> Length = (Pos - Line -> Buffer) * sizeof (CHAR);
			ReturnName -> MaximumLength = 0;

			// step over the colon
			Pos++;

			while (Pos < End && isspace (*Pos))
				Pos++;

			ReturnValue -> Buffer = Pos;
			ReturnValue -> Length = Line -> Length - (Pos - Line -> Buffer) * sizeof (CHAR);
			ReturnValue -> MaximumLength = 0;

			return S_OK;
		}
		else if (isalpha (*Pos) || *Pos == '-' || *Pos == '_') {
			// normal case
		}
		else {
			ATLTRACE ("HTTP: illegal character in header name: (%.*s)\n", ANSI_STRING_PRINTF (Line));
			return E_FAIL;
		}
	}

	//
	// If we reach this point, then the header line did not contain a colon.
	//

	ATLTRACE ("HTTP: header line did not contain a separator: (%.*s)\n",
		ANSI_STRING_PRINTF (Line));

	return E_FAIL;
}



//
// ParseScanLine scans a string of ANSI text for a line terminator.
// (A line terminator can be \n, \r, \r\n, or \n\r.)
// If it finds a line terminator, it puts the first part of
// the line into ReturnLineText, and the remainder into ReturnRemainingText.
// The line terminator is not included in either of the return strings.
//
// If AllowHeaderContinuation is TRUE, then the function will check to
// see if the header is being continued.
// This is indicated by whitespace in the first character of the next line.
// If AllowHeaderContinuation is TRUE, and a continuation line is found,
// then the continuation text will be included in ReturnLineText.
// Note that this will result in the intermediate CRLF being included;
// it is the responsibility of the caller to interpret CRLF as whitespace.
//
// It is acceptable for SourceText = ReturnRemainingText.
// That is, it is safe to use the same ANSI_STRING to submit the SourceText
// as the one tha receives the remaining text.
//
// Return values:
//		S_OK - Found end of line.
//		HRESULT_FROM_WIN32 (ERROR_MORE_DATA) - Ran out of data before found the end of the line.
//

HRESULT ParseScanLine (
	IN	ANSI_STRING *	SourceText,
	IN	BOOL			AllowHeaderContinuation,
	OUT	ANSI_STRING *	ReturnLineText,
	OUT	ANSI_STRING *	ReturnRemainingText)
{
	PSTR		Pos;
	PSTR		End;
	ANSI_STRING	SourceTextCopy;

	ATLASSERT (SourceText);
	ATLASSERT (SourceText -> Buffer);
	ATLASSERT (ReturnLineText);
	ATLASSERT (ReturnLineText -> Buffer);
	ATLASSERT (ReturnRemainingText);
	ATLASSERT (ReturnRemainingText -> Buffer);

	SourceTextCopy = *SourceText;
	Pos = SourceTextCopy.Buffer;
	End = SourceTextCopy.Buffer + SourceTextCopy.Length / sizeof (CHAR);

	while (Pos < End) {

		if (*Pos == '\n' || *Pos == '\r') {

			//
			// We've found either \n, \r, \r\n, or \n\r.
			//

			ReturnLineText -> Buffer = SourceTextCopy.Buffer;
			ReturnLineText -> Length = (Pos - SourceTextCopy.Buffer) * sizeof (CHAR);
			ReturnLineText -> MaximumLength = 0;

			Pos++;

			if (Pos < End && (*Pos == '\r' || *Pos == '\n'))
				Pos++;

			if (AllowHeaderContinuation && Pos < End && (*Pos == ' ' || *Pos == '\t'))
				continue;

			ReturnRemainingText -> Buffer = Pos;
			ReturnRemainingText -> Length = SourceTextCopy.Length - (Pos - SourceTextCopy.Buffer) * sizeof (CHAR);
			ReturnRemainingText -> MaximumLength = 0;

			return S_OK;
		}

		Pos++;
	}

	//
	// Never found a line terminator (\r\n).
	// This is kind of an error condition.
	//

	ReturnLineText -> Buffer = NULL;
	ReturnLineText -> Length = 0;
	ReturnLineText -> MaximumLength = 0;

	*ReturnRemainingText = SourceTextCopy;

	ATLTRACE ("HTTP: could not find end of line:\n");
	DebugDumpAnsiString (SourceText);

	return HRESULT_FROM_WIN32 (ERROR_MORE_DATA);
}




//
// ParseScanNextToken finds the next token.
// Tokens are separated by whitespace.
//
// Return values:
//		S_OK - A token was found.  ReturnToken contains the new token,
//			and ReturnRemainingText contains the remainder of the string.
//		HRESULT_FROM_WIN32 (ERROR_MORE_DATA): The string was exhausted before any token was found.
//

HRESULT ParseScanNextToken (
	IN	ANSI_STRING *	Text,
	IN	CHARACTER_CLASS_FUNC	SeparatorTestFunc,
	OUT	ANSI_STRING *	ReturnToken,
	OUT	ANSI_STRING *	ReturnRemainingText)
{
	LPSTR	Pos;
	LPSTR	End;
	LPSTR	TokenStartPos;

	Pos = Text -> Buffer;
	End = Text -> Buffer + Text -> Length / sizeof (CHAR);

	// skip whitespace
	while (Pos < End && (*SeparatorTestFunc) (*Pos))
		Pos++;

	TokenStartPos = Pos;
	while (Pos < End && !(*SeparatorTestFunc) (*Pos))
		Pos++;

	if (TokenStartPos == Pos)
		return HRESULT_FROM_WIN32 (ERROR_MORE_DATA);		// nothing here

	ReturnToken -> Buffer = TokenStartPos;
	ReturnToken -> Length = (Pos - TokenStartPos) / sizeof (CHAR);
	ReturnToken -> MaximumLength = 0;

	// caution: Text may be the same pointer as ReturnRemainingText
	ReturnRemainingText -> Buffer = Pos;
	ReturnRemainingText -> Length = (End - Pos) / sizeof (CHAR);
	ReturnRemainingText -> MaximumLength = 0;

	return S_OK;
}

static HRESULT SplitStringAtChar (
	IN	ANSI_STRING *	SourceString,
	IN	CHAR			SearchChar,
	OUT	ANSI_STRING *	ReturnString1,
	OUT	ANSI_STRING *	ReturnString2)
{
	return E_NOTIMPL;
}

//
// This function takes a combined URI and display name, and locates the two components.
// For example, if SourceText is "Arlie Davis <arlied@microsoft.com>", then
// ReturnUri will be "HTTP:arlied@microsoft.com" and ReturnDisplayName will be "Arlie Davis".
//
// Acceptable formats:
//
//		sip:uri
//		<sip:uri>
//		Display Name <sip:uri>
//		"Display Name" <sip:uri>
//
// Return values:
//		S_OK: The URI was located.  ReturnUri -> Length is guaranteed to be greater than zero.
//			If the source text contained a display name, then ReturnDisplayName -> Length
//			will be non-zero.
//		E_INVALIDARG: The URI was malformed or was not present.
//

HRESULT HttpParseUriDisplayName (
	IN	ANSI_STRING *	SourceText,
	OUT	ANSI_STRING *	ReturnUri,
	OUT	ANSI_STRING *	ReturnDisplayName)
{
	ANSI_STRING			Remainder;
	PSTR				Pos;

	ATLASSERT (SourceText);
	ATLASSERT (ReturnUri);
	ATLASSERT (ReturnDisplayName);

	Remainder = *SourceText;
	ParseSkipSpace (&Remainder);
	if (Remainder.Length == 0)
		return E_INVALIDARG;

	ReturnDisplayName -> Buffer = NULL;
	ReturnDisplayName -> Length = 0;

	for (;;) {
		ParseSkipSpace (&Remainder);
		if (Remainder.Length == 0) {
			ATLTRACE ("HttpParseUriDisplayName: no uri found (%.*s)\n",
				ANSI_STRING_PRINTF (SourceText));
			return E_INVALIDARG;
		}


		if (Remainder.Buffer [0] == '<') {
			//
			// We've hit the beginning of the URI.
			// Find the closing brace and finish.
			//

			Remainder.Buffer++;
			Remainder.Length -= sizeof (CHAR);

			Pos = FindFirstChar (&Remainder, '>');
			if (!Pos) {
				ATLTRACE ("HttpParseUriDisplayName: unbalanced angle brackets: (%.*s)\n",
					ANSI_STRING_PRINTF (SourceText));
				return E_INVALIDARG;
			}
			if (Pos == Remainder.Buffer) {
				ATLTRACE ("HttpParseUriDisplayName: uri is empty (%.*s)\n",
					ANSI_STRING_PRINTF (SourceText));
				return E_INVALIDARG;
			}

			ReturnUri -> Buffer = Remainder.Buffer;
			ReturnUri -> Length = (Pos - Remainder.Buffer) * sizeof (CHAR);

#if	DBG
			//
			// Check for stuff after the closing bracket.
			//

			Pos++;
			Remainder.Length -= (Pos - Remainder.Buffer) * sizeof (CHAR);
			Remainder.Buffer = Pos;

			if (Remainder.Length) {
				ATLTRACE ("HttpParseUriDisplayName: extra data after closing brace: (%.*s)\n",
					ANSI_STRING_PRINTF (&Remainder));
			}
#endif

			break;
		}
		else if (Remainder.Buffer [0] == '\"') {
			//
			// We've hit a quoted section of the display name.
			// Find the next matching double-quote and skip past.
			//

			Remainder.Buffer++;
			Remainder.Length -= sizeof (CHAR);

			Pos = FindFirstChar (&Remainder, '\"');
			if (!Pos) {
				ATLTRACE ("HttpParseUriDisplayName: unbalanced double quotes: (%.*s)\n",
					ANSI_STRING_PRINTF (SourceText));
				return E_INVALIDARG;
			}

			Pos++;
			Remainder.Length -= sizeof (CHAR) * (Pos - Remainder.Buffer);
			Remainder.Buffer = Pos;

			//
			// Continue, looking for more display name data.
			//
		}
		else {
			//
			// We've hit an unquoted character in the display name.
			// Look for the next double-quote or angle-bracket.
			//

			Pos = FindFirstCharList (&Remainder, "<\"");

			if (!Pos) {
				//
				// Neither an angle bracket nor a double-quote was found.
				// The URI must be in "naked" form (without angle brackets).
				// The ONLY acceptable form is the URI itself, as one single token,
				// and without any adornment.
				//

				if (ReturnDisplayName -> Length > 0) {
					ATLTRACE ("HttpParseUriDisplayName: bogus naked uri (%.*s)\n",
						ANSI_STRING_PRINTF (SourceText));
					return E_INVALIDARG;
				}

                if (FAILED (ParseScanNextToken (&Remainder, IsSpace, ReturnUri, &Remainder))) {
					ATLTRACE ("HttpParseUriDisplayName: bogus naked uri (%.*s)\n",
						ANSI_STRING_PRINTF (SourceText));
					return E_INVALIDARG;
				}

				ParseSkipSpace (&Remainder);
				if (Remainder.Length) {
					//
					// There was extra data present after the URI.
					// This usually indicates a mal-formed URI.
					//

					ATLTRACE ("HttpParseUriDisplayName: bogus naked uri (%.*s)\n",
						ANSI_STRING_PRINTF (SourceText));

					return E_INVALIDARG;
				}

				break;
			}
			else {
				ATLASSERT (Pos != Remainder.Buffer);
				ATLASSERT (*Pos == '\"' || *Pos == '<');

				//
				// We've found the beginning of a quoted section,
				// or we've found the beginning of the real URI.
				// In either case, advance to that character.
				// 

				Remainder.Length -= sizeof (CHAR) * (Pos - Remainder.Buffer);
				Remainder.Buffer = Pos;

				//
				// Continue looking for more data
				//
			}
		}

		//
		// Anything we've skipped over becomes part of the display name.
		//

		ATLASSERT (Remainder.Buffer != SourceText -> Buffer);

		ReturnDisplayName -> Buffer = SourceText -> Buffer;
		ReturnDisplayName -> Length = (Remainder.Buffer - SourceText -> Buffer) * sizeof (CHAR);

//		ATLTRACE ("HttpParseUriDisplayName: found some display name data (%.*s)\n",
//			ANSI_STRING_PRINTF (ReturnDisplayName));
	}


#if 0
	if (ReturnDisplayName -> Length) {
		ATLTRACE ("HttpParseUriDisplayName: source (%.*s) uri (%.*s) display name (%.*s)\n",
			ANSI_STRING_PRINTF (SourceText),
			ANSI_STRING_PRINTF (ReturnUri),
			ANSI_STRING_PRINTF (ReturnDisplayName));
	}
	else {
		ATLTRACE ("HttpParseUriDisplayName: source (%.*s) uri (%.*s) no display name\n",
			ANSI_STRING_PRINTF (SourceText),
			ANSI_STRING_PRINTF (ReturnUri));
	}
#endif

	return S_OK;

}

static BOOL IsHeaderSeparator (
	IN	CHAR	Char)
{
	return Char == ':';
}

//
// This function scans the next header line from a header block,
// and returns separate pointers to the name and value.
// This function returns the remaining header block.
//
// Return values:
//		S_OK: scanned a header
//		S_FALSE: no more data
//		E_INVALIDARG: header block looks corrupt
//

HRESULT	HttpParseNextHeader (
	IN	OUT	ANSI_STRING *	HeaderBlock,
	OUT	ANSI_STRING *		ReturnHeaderName,
	OUT	ANSI_STRING *		ReturnHeaderValue)
{
	ANSI_STRING		Line;
	HRESULT			Result;

	ATLASSERT (HeaderBlock);
	ATLASSERT (ReturnHeaderName);
	ATLASSERT (ReturnHeaderValue);

	if (HeaderBlock -> Length == 0)
		return S_FALSE;

	Result = ParseScanLine (HeaderBlock, TRUE, &Line, HeaderBlock);
	if (FAILED (Result))
		return Result;

	return HttpParseHeaderLine (&Line, ReturnHeaderName, ReturnHeaderValue);
}

//
// CHttpParser -----------------------------------------------------------------------------
//

//
// Parse a message.
//

HRESULT CHttpParser::ParseMessage (
	IN	ANSI_STRING *			Message)
{
	ANSI_STRING		HeaderName;
	ANSI_STRING		HeaderValue;
	ANSI_STRING		Line;
	ANSI_STRING		Token;
	ANSI_STRING		MessageRemainder;
	ANSI_STRING		LineRemainder;
	HRESULT			Result;
	ULONG			ContentLength;

	ATLASSERT (Message);

	//
	// Determine whether the message is a response or a request.
	//
	// Requests are in the form:
	//			<method> <request-uri> <version>
	//
	// Responses are in the form:
	//			<version> <status-code> <status-text> ...
	//

	Result = ParseScanLine (Message, FALSE, &Line, &MessageRemainder);
	if (FAILED (Result)) {
		ATLTRACE (_T("UA: first line of message was invalid\n"));
		return Result;
	}

//	ATLTRACE ("UA: first line: (%.*s)\n", ANSI_STRING_PRINTF (&FirstLine));

	Result = ParseScanNextToken (&Line, IsSpace, &Token, &LineRemainder);
	if (FAILED (Result)) {
		ATLTRACE (_T("UA: first line of message was invalid\n"));
		return E_INVALIDARG;
	}

	if (FindFirstChar (&Token, '/')) {

		//
		// The first token looks like a version number (SIP/2.0).
		// The message must be a response.
		//

		m_MessageType = MESSAGE_TYPE_RESPONSE;
		m_Version = Token;

		//
		// Locate the status code and status text.
		//

		if (ParseScanNextToken (&LineRemainder, IsSpace, &m_ResponseStatusCode, &m_ResponseStatusText) != S_OK)
			return E_INVALIDARG;

		ParseSkipSpace (&m_ResponseStatusText);
	}
	else {

		//
		// Since the first token doesn't look like a version number,
		// we assume the message is a request.
		//

		m_MessageType = MESSAGE_TYPE_REQUEST;
		m_RequestMethod = Token;

		if (ParseScanNextToken (&LineRemainder, IsSpace, &m_RequestURI, &LineRemainder) != S_OK
			|| ParseScanNextToken (&LineRemainder, IsSpace, &m_Version, &LineRemainder) != S_OK)
			return E_INVALIDARG;
	}


	//
	// Common parsing section
	//
	// First pass: Scan through the header list.
	// In this pass:
	//		- Determine the number of headers
	//		- Locate the well-known headers
	//		- Determine where the content body begins
	//		- Locate the entire header block, for later scans
	//

	m_HeaderCount = 0;
	ZeroMemory (&m_KnownHeaders, sizeof (HTTP_KNOWN_HEADERS));

	m_HeaderBlock.Buffer = MessageRemainder.Buffer;

	for (;;) {
		if (MessageRemainder.Length == 0) {
			//
			// We hit the end of the message.
			// This should not happen in a well-formed message -- we should hit a blank line first.
			//

			ATLTRACE ("HTTP: message ended before end of header block -- message is invalid\n");
			return E_INVALIDARG;
		}

		//
		// Record the end of the header block.
		// Doing this here, rather than in the if statement below, removes the need to
		// use a temporary variable.
		//

		m_HeaderBlock.Length = (MessageRemainder.Buffer - m_HeaderBlock.Buffer) * sizeof (CHAR);

		Result = ParseScanLine (&MessageRemainder, TRUE, &Line, &MessageRemainder);
		if (Result != S_OK) {
			ATLTRACE ("HTTP: failed to scan next line, probably missing CRLF.\n"
				"HTTP: this probably means that the blank line between the headers and body was missing\n");
			return Result;
		}

		if (Line.Length == 0) {
			//
			// We've hit the end of the header block.
			//

			break;
		}

		//
		// This line is supposed to be a header.
		//

		Result = HttpParseHeaderLine (&Line, &HeaderName, &HeaderValue);
		if (Result != S_OK) {
			ATLTRACE ("HTTP: invalid line in header: (%.*s)\n", ANSI_STRING_PRINTF (&Line));
			return E_INVALIDARG;
		}

		m_HeaderCount++;

		m_KnownHeaders.SetKnownHeader (&HeaderName, &HeaderValue);
	}

	//
	// Now we decide what to do with the content body.
	// First, look for the Content-Length well-known header.
	//

	if (m_KnownHeaders.ContentLength.Length) {
		//
		// The message includes a Content-Length field.
		//

		Result = AnsiStringToInteger (&m_KnownHeaders.ContentLength, 10, &ContentLength);
		if (FAILED (Result)) {
			ATLTRACE ("HTTP: invalid content-length header (%.*s)\n",
				ANSI_STRING_PRINTF (&m_KnownHeaders.ContentLength));
			return E_FAIL;
		}

		if (ContentLength < MessageRemainder.Length) {
			//
			// There is more data in the packet than there is Content-Length.
			// So, there is another message after this one in the packet.
			//

			ATLTRACE ("HTTP: found more than one message in same packet -- how exciting!\n");

			m_ContentBody.Buffer = MessageRemainder.Buffer;
			m_ContentBody.Length = (USHORT) ContentLength;

			m_NextMessage.Buffer = MessageRemainder.Buffer + ContentLength / sizeof (CHAR);
			m_NextMessage.Length = MessageRemainder.Length -= (USHORT) ContentLength;
		}
		else if (ContentLength > MessageRemainder.Length) {
			//
			// The message claims to have a content length greater than the remaining data.
			// This could happen due to an insane client, or (more likely) a long message that
			// was truncated.
			//
			// Best thing to do is to fail the decode.
			//

			ATLTRACE (
				"HTTP: *** warning, received message with Content-Length (%u), but only %u bytes remaining in packet\n"
				"HTTP: *** packet may have been truncated (insufficient buffer submitted), or sender may be insane\n",
				ContentLength, MessageRemainder.Length);

			//
			// This is now a benign condition, since we have lifted the restriction of parsing
			// everything at once.
			//

			return HRESULT_FROM_WIN32 (ERROR_MORE_DATA);
		}
		else {
			//
			// Content-Length and the remaining data are the same length.
			// All is harmonious and good!
			//

			m_ContentBody = MessageRemainder;
			if (!m_ContentBody.Length)
				m_ContentBody.Buffer = NULL;

			m_NextMessage.Buffer = NULL;
			m_NextMessage.Length = 0;
		}
	}
	else {
		if (MessageRemainder.Length) {

			//
			// The message did not include a Content-Length field.
			// Assume that the rest of the message is the content.
			//

			ATLTRACE ("HTTP: message did not contain Content-Length, assuming length of %u\n",
				MessageRemainder.Length);

			m_ContentBody = MessageRemainder;
		}
		else {
			ATLTRACE ("HTTP: message did not contain Content-Length, and there is no more data\n");

			m_ContentBody.Buffer = NULL;
			m_ContentBody.Length = 0;
		}
	
		m_NextMessage.Buffer = NULL;
		m_NextMessage.Length = 0;
	}

#if 0
	if (m_ContentBody.Length) {
		ATLTRACE ("HTTP: content body:\n");
		DebugDumpAnsiString (&m_ContentBody);
	}

	if (m_NextMessage.Length) {
		ATLTRACE ("HTTP: next message:\n");
		DebugDumpAnsiString (&m_NextMessage);
	}
#endif

	return S_OK;
}



//
// Remove all of the whitespace from the beginning of a string.
//

void ParseSkipSpace (
	IN	OUT	ANSI_STRING *	String)
{
	USHORT	Index;

	ATLASSERT (String);
	ATLASSERT (String -> Buffer);

	Index = 0;
	while (Index < String -> Length / sizeof (CHAR)
		&& isspace (String -> Buffer [Index]))
		Index++;

	String -> Buffer += Index;
	String -> Length -= Index * sizeof (CHAR);
}

static inline BOOL IsValidParameterNameChar (
	IN	CHAR	Char)
{
	return isalnum (Char) || Char == '-' || Char == '_';
}

#define	HTTP_PARAMETER_SEPARATOR	','
#define	HTTP_PARAMETER_ASSIGN_CHAR	'='
#define	HTTP_PARAMETER_DOUBLEQUOTE	'\"'

//
// Given a string in this form:
//
//		parm1="foo", parm2="bar", parm3=baz
//
// this function returns parm1 in ReturnName, foo in ReturnValue,
// and parm2="bar, parm3=baz in Remainder.
//
// Parameter values may be quoted, or may not.
// All parameters are separated by commas.
// SourceText == ReturnRemainder is legal.
//
// Return values:
//		S_OK: successfully scanned a parameter
//		S_FALSE: no more data
//		E_INVALIDARG: input is invalid
//

HRESULT ParseScanNamedParameter (
	IN	ANSI_STRING *	SourceText,
	OUT	ANSI_STRING *	ReturnRemainder,
	OUT	ANSI_STRING *	ReturnName,
	OUT	ANSI_STRING *	ReturnValue)
{
	ANSI_STRING		Remainder;
	HRESULT			Result;
	

	Remainder = *SourceText;

	ParseSkipSpace (&Remainder);

	//
	// Scan through the characters of the name of the parameter.
	//

	ReturnName -> Buffer = Remainder.Buffer;

	for (;;) {
		if (Remainder.Length == 0) {
			//
			// Hit the end of the string without ever hitting an equal sign.
			// If we never accumulated anything, then return S_FALSE.
			// Otherwise, it's invalid.
			//

			if (Remainder.Buffer == ReturnName -> Buffer) {
				*ReturnRemainder = Remainder;
				return S_FALSE;
			}
			else {
				ATLTRACE ("ParseScanNamedParameter: invalid string (%.*s)\n",
					ANSI_STRING_PRINTF (SourceText));

				return E_FAIL;
			}
		}

		if (Remainder.Buffer [0] == HTTP_PARAMETER_ASSIGN_CHAR) {
			//
			// Found the end of the parameter name.
			// Update ReturnName and terminate the loop.
			//

			ReturnName -> Length = (Remainder.Buffer - ReturnName -> Buffer) * sizeof (CHAR);

			Remainder.Buffer++;
			Remainder.Length -= sizeof (CHAR);

			break;
		}

		//
		// Validate the character.
		//

		if (!IsValidParameterNameChar (Remainder.Buffer[0])) {
			ATLTRACE ("ParseScanNamedParameter: bogus character in parameter name (%.*s)\n",
				ANSI_STRING_PRINTF (SourceText));
			return E_INVALIDARG;
		}

		Remainder.Buffer++;
		Remainder.Length -= sizeof (CHAR);
	}

	//
	// Now parse the value of the parameter (portion after the equal sign)
	//

	ParseSkipSpace (&Remainder);

	if (Remainder.Length == 0) {
		//
		// The string ends before the parameter has any value at all.
		// Well, it's legal enough.
		//

		ReturnValue -> Length = 0;
		*ReturnRemainder = Remainder;
		return S_OK;
	}

	if (Remainder.Buffer [0] == HTTP_PARAMETER_DOUBLEQUOTE) {
		//
		// The parameter value is quoted.
		// Scan until we hit the next double-quote.
		//

		Remainder.Buffer++;
		Remainder.Length -= sizeof (CHAR);

		ReturnValue -> Buffer = Remainder.Buffer;

		for (;;) {
			if (Remainder.Length == 0) {
				//
				// The matching double-quote was never found.
				//

				ATLTRACE ("ParseScanNamedParameter: parameter value had no matching double-quote: (%.*s)\n",
					ANSI_STRING_PRINTF (SourceText));

				return E_INVALIDARG;
			}

			if (Remainder.Buffer [0] == HTTP_PARAMETER_DOUBLEQUOTE) {
				ReturnValue -> Length = (Remainder.Buffer - ReturnValue -> Buffer) * sizeof (CHAR);
				Remainder.Buffer++;
				Remainder.Length -= sizeof (CHAR);
				break;
			}

			Remainder.Buffer++;
			Remainder.Length -= sizeof (CHAR);
		}

		ParseSkipSpace (&Remainder);

		//
		// Make sure the next character, if any, is a comma.
		//

		if (Remainder.Length > 0) {
			if (Remainder.Buffer [0] != HTTP_PARAMETER_SEPARATOR) {
				ATLTRACE ("ParseScanNamedParameter: trailing character after quoted parameter value is NOT a comma! (%.*s)\n",
					ANSI_STRING_PRINTF (SourceText));
				return E_INVALIDARG;
			}

			Remainder.Buffer++;
			Remainder.Length -= sizeof (CHAR);
		}

		*ReturnRemainder = Remainder;
	}
	else {
		//
		// The parameter is not quoted.
		// Scan until we hit the first comma.
		//

		ReturnValue -> Buffer = Remainder.Buffer;

		for (;;) {
			if (Remainder.Length == 0) {
				ReturnValue -> Length = (Remainder.Buffer - ReturnValue -> Buffer) * sizeof (CHAR);
				ReturnRemainder -> Length = 0;
				break;
			}

			if (Remainder.Buffer [0] == HTTP_PARAMETER_SEPARATOR) {
				ReturnValue -> Length = (Remainder.Buffer - ReturnValue -> Buffer) * sizeof (CHAR);
				Remainder.Buffer++;
				Remainder.Length -= sizeof (CHAR);

				*ReturnRemainder = Remainder;
				break;
			}

			Remainder.Buffer++;
			Remainder.Length -= sizeof (CHAR);
		}
	}

#if 0
	ATLTRACE ("ParseScanNamedParameter: parameter name (%.*s) value (%.*s) remainder (%.*s)\n",
		ANSI_STRING_PRINTF (ReturnName),
		ANSI_STRING_PRINTF (ReturnValue),
		ANSI_STRING_PRINTF (ReturnRemainder));
#endif

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\ssltest\md5request.h ===
#pragma	once

#include <sipssl.h>
#include "md5digest.h"
#include "httpparse.h"



class	SECURE_REQUEST :
public	SECURE_SOCKET
{
private:
	enum	STATE
	{
		STATE_IDLE,					// waiting for StartRequest
		STATE_CONNECTING,			// waiting for NotifyConnectComplete
		STATE_WAITING_RESPONSE,		// waiting for HTTP response
	};

private:
	SOCKADDR_IN					m_DestinationAddress;
	ANSI_STRING_STATIC<0x80>	m_RequestHost;
	ANSI_STRING_STATIC<0x80>	m_RequestURI;
	ANSI_STRING_STATIC<0x80>	m_Username;
	ANSI_STRING_STATIC<0x80>	m_Password;


	STATE						m_State;


	PSTR						m_ResponseBuffer;
	ULONG						m_ResponseMaximumLength;
	ULONG						m_ResponseLength;


	ULONG						m_ResponseStatusCode;


private:

	void	CompleteRequest	(
		IN	HRESULT		Result);

	HRESULT	StartRequestInternal (void);

	HRESULT	BuildSendRequest (void);

	HRESULT	ProcessResponse (
		IN	CHttpParser *	Parser);

	void	ProcessResponse_AccessDenied (
		IN	CHttpParser *	Parser);

	void	ProcessDigestResponse (
		IN	ANSI_STRING *	AuthParameters);

	void	ProcessBasicResponse (
		IN	ANSI_STRING *	AuthParameters);


public:

	SECURE_REQUEST		(void);
	~SECURE_REQUEST		(void);


	void	SetRequestData (
		IN	SOCKADDR_IN *	DestinationAddress,
		IN	PCSTR			RequestHost,
		IN	PCSTR			RequestURI)
	{
		m_DestinationAddress = *DestinationAddress;
		m_RequestURI.Set (RequestURI);
		m_RequestHost.Set (RequestHost);
	}


	void		SetCredentials (
		IN	PCSTR			Username,
		IN	PCSTR			Password)
	{
		m_Username.Set (Username);
		m_Password.Set (Password);
	}


	HRESULT		StartRequest	(void);

	void		StopRequest		(void);


	virtual	void NotifyRequestComplete (
		IN	HRESULT		Result) = 0;


private:
	//
	// Interface to SECURE_SOCKET.
	//

	virtual	void	NotifyConnectComplete (
		IN	HRESULT		ErrorCode);

	virtual	void	NotifyDisconnect (void);

	virtual	void	NotifyReceiveReady (void);

};


#define	HTTP_STATUS_CODE_401		401
#define	HTTP_STATUS_CODE_404		404
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\ssltest\main2.cpp ===
#include "precomp.h"
#include "md5digest.h"
#include "md5request.h"
#include "rtcstring.h"

class	TEST_SECURE_REQUEST :
public	SECURE_REQUEST
{
public:

	virtual	void NotifyRequestComplete (
		IN	HRESULT		Result);
};


void TEST_SECURE_REQUEST::NotifyRequestComplete (
	IN	HRESULT		Result)
{
	PrintConsole ("TEST: finished\n");
	PostQuitMessage (Result);
}





// -----------------------------------------------------------------------------------

CComModule				_Module;
TEST_SECURE_REQUEST		AppRequest;
INT						AppWinsockStatus;

// HTTP: Undocumented Header = Authorization: Digest username="ntdev\arlied", realm="arlied1x", qop="auth", algorithm="MD5", uri="/private/", nonce="d467cd06723d436426


// HTTP: Undocumented Header = Authorization:
// Digest username="ntdev\arlied", realm="arlied1x", qop="auth", algorithm="MD5",
// uri="/private/", nonce="d467cd06723d436426


static void Test1 (void)
{
	static CONST CHAR ChallengeText [] =
		"qop=\"auth\", realm=\"arlied1x\","
		"nonce=\"d467cd06723d43642630981000008ea880ba1437902ad3d0f59bc024ac09\"";

	CHAR				ResponseBuffer	[0x200];

	DIGEST_CHALLENGE	Challenge;
	ANSI_STRING			AnsiString;
	DIGEST_PARAMETERS	Parameters;
	HRESULT				Result;


	RtlInitString (&AnsiString, ChallengeText);

	Result = DigestParseChallenge (&AnsiString, &Challenge);
	if (FAILED (Result)) {
		PrintConsoleF ("TEST: failed to parse challenge text (%s)\n", ChallengeText);
		return;
	}

	AnsiString.Buffer = ResponseBuffer;
	AnsiString.MaximumLength = sizeof ResponseBuffer;

	ZeroMemory (&Parameters, sizeof Parameters);
	RtlInitString (&Parameters.Username, "ntdev\\arlied");
	RtlInitString (&Parameters.Password, "");
	RtlInitString (&Parameters.RequestMethod, "GET");
	RtlInitString (&Parameters.RequestURI, "/private/");
	RtlInitString (&Parameters.ClientNonce,
		"961d33469a1197af6c7c53e44093d186");

	Result = DigestBuildResponse (&Challenge, &Parameters, &AnsiString);

	if (FAILED (Result)) {
		PrintConsole ("TEST: failed to build response to challenge\n");
		return;
	}

	PrintConsole ("TEST: successfully built response:\n");
	PrintConsole (AnsiString.Buffer, AnsiString.Length);

	ATLTRACE ("TEST: expected response: (6211290ec735bbecc01824d9ca7a50f5)\n");

}


static HRESULT AppStart (void)
{
	HRESULT			Result;
	SOCKADDR_IN		DestinationAddress;
	WSADATA			WinsockData;

	ATLTRACE ("TEST\n");

	Test1();
	return E_NOTIMPL;

	AppWinsockStatus = WSAStartup (MAKEWORD (1, 1), &WinsockData);
	if (AppWinsockStatus) {
		PrintConsole ("TEST: failed to initialize winsock:\n");
		PrintError (AppWinsockStatus);
		return HRESULT_FROM_WIN32 (AppWinsockStatus);
	}

	Result = SECURE_SOCKET::RegisterClass();
	if (FAILED (Result))
		return Result;

	DestinationAddress.sin_family = AF_INET;
	DestinationAddress.sin_addr.s_addr = htonl (0x7f000001);
	DestinationAddress.sin_port = htons (80);



	AppRequest.SetCredentials ("TestUser", "TestPass");
	AppRequest.SetRequestData (&DestinationAddress, "localhost", "/private/default.htm");

	Result = AppRequest.StartRequest();
	if (FAILED (Result))
		return Result;

	return S_OK;
}

static void AppStop (void)
{
	AppRequest.StopRequest();

	if (AppWinsockStatus == 0) {
		WSACleanup();
	}

	SECURE_SOCKET::UnregisterClass();
}


static void AppMainLoop (void)
{
	MSG		Message;

	while (GetMessage (&Message, NULL, 0, 0) > 0) {
		TranslateMessage (&Message);
		DispatchMessage (&Message);
	}
}

int __cdecl wmain (
	IN	INT		ArgCount,
	IN	PWSTR	ArgVector)
{
	HRESULT		Result;

	Result = AppStart();
	if (SUCCEEDED (Result)) {
		AppMainLoop();
	}

	AppStop();

	return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\ssltest\precomp.h ===
#define	STRICT
#define	UNICODE
#define	_UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <winsock2.h>
#include <stdio.h>
#include <stdlib.h>
#include <atlbase.h>
extern	CComModule	_Module;



#include "util.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\ssltest\main.cpp ===
//
// SSLTEST
//
// This program tests the SECURE_SOCKET implementation.
//
// Author: Arlie Davis, 2000
//

#include "precomp.h"
#include "sipssl.h"


class	HANDLE_CONTAINER
{
public:

	HANDLE		m_Handle;
	BOOL		m_Close;

	HANDLE_CONTAINER	(void)
	{
		m_Handle = INVALID_HANDLE_VALUE;
	}

	~HANDLE_CONTAINER	(void)
	{
		ATLASSERT (m_Handle == INVALID_HANDLE_VALUE);
	}

	void	Close	(void)
	{
		if (m_Handle != INVALID_HANDLE_VALUE) {
			if (m_Close)
				CloseHandle (m_Handle);

			m_Handle = INVALID_HANDLE_VALUE;
		}
	}

	void	Set	(
		IN	HANDLE	Handle,
		IN	BOOL	CloseFlag)
	{
		Close();
		m_Handle = Handle;
		m_Close = CloseFlag;
	}

	operator HANDLE (void) const { return m_Handle; }
};

class	TEST_SECURE_SOCKET :
public	SECURE_SOCKET
{
public:

	enum { IO_BUFFER_MAX = 0x1000 };

	HANDLE_CONTAINER	m_Input;
	HANDLE_CONTAINER	m_Output;
	UCHAR				m_IoBuffer	[IO_BUFFER_MAX];


	virtual	void	NotifyConnectComplete (
		IN	HRESULT		ErrorCode);

	virtual	void	NotifyDisconnect (void);

	virtual	void	NotifyReceiveReady (void);

	void	SendTestData (void);


	void	Close	(void);
};




//
// Global data
//

CComModule			_Module;
INT					AppWinsockStatus;
TEST_SECURE_SOCKET	AppSocket;


static void Usage (void)
{
	PrintConsole (
		"This app tests SECURE_SOCKET.\n"
		"\n"
		"Usage: <options> hostname[:port]\n"
		"\n"
		"	-name <name>	Override the principal name.\n"
		"			If this parameter is not specified, then\n"
		"			principal name is same as hostname.\n"
		"	-ssl		Run in SSL mode (default)\n"
		"	-clear		Run in clear-text mode\n"
		"	-nocertcheck	Do not validate the server certificate.\n"
		"	-in <filename>	Name of the file that contains\n"
		"			the data to send over the connection.\n"
		"			If this argument is not specified, input is stdin.\n"
		"	-out <filename>	Name of the file to write data received from\n"
		"			the network.  If this argument is not specified,\n"
		"			output is written to stdout.\n"
		"	<hostname>	The DNS name or IP address of the target.\n"
		"\n"
		"In SSL mode (the default), hostname can be a DNS name or an IP address.\n"
		"If hostname is a DNS name, then -name is optional; the SSL principal name\n"
		"is taken from the hostname.  If hostname is an IP address, then -name must\n"
		"provide the SSL remote principal name.\n"
		"\n"
		"The default port in SSL mode is 443 (HTTPS).\n"
		"The default port in clear-text mode is 80 (HTTP).\n"
		"\n"
		"The application will connect, send the data in <filename>,\n"
		"then will output data received from the socket until the\n"
		"socket closes.\n"
		"\n");

	ExitProcess (EXIT_FAILURE);
}

static HOSTENT * gethostbynameW (
	IN	PCWSTR		HostnameUnicode)
{
	CHAR	HostnameAnsi	[0x100 + 1];
	DWORD	Length;

    Length = WideCharToMultiByte (CP_ACP, 0, HostnameUnicode, wcslen(HostnameUnicode), HostnameAnsi, 0x100, NULL, NULL);
	HostnameAnsi [Length] = 0;

	return gethostbyname (HostnameAnsi);
}


#define	IF_STRING_PARAMETER(Name,Variable) \
	if (_wcsicmp (Arg, _T(Name)) == 0) { \
		if (Variable) { \
			PrintConsole ("TEST: At most one -" Name " parameter may be specified.\n\n"); \
			Usage(); \
		} \
		if (!*ArgPos) { \
			PrintConsole ("TEST: The -" Name " parameter is incomplete.\n\n"); \
			Usage(); \
		} \
		Variable = *ArgPos++; \
	}



static HRESULT AppStart (
	IN	INT			ArgCount,
	IN	PWSTR *		ArgVector)
{
	HRESULT			Result;
	HOSTENT *		HostEntry;
	SOCKADDR_IN		DestinationAddress;
	INT				Length;
	WSADATA			WinsockData;
	PWSTR *			ArgPos;
	PWSTR			Arg;
	PWSTR			ArgHostname;
	PWSTR			ArgPrincipalName;
	PWSTR			ArgInputFile;
	HANDLE			ArgInputHandle;
	PWSTR			ArgOutputFile;
	PWSTR			ArgOutputHandle;
	SECURE_SOCKET::SECURITY_MODE	SecurityMode;
	WCHAR			TextBuffer	[0x100 + 1];
	PWSTR			PortText;
	HANDLE			FileHandle;
	DWORD			ConnectFlags;

	if (ArgCount < 1)
		Usage();

	SecurityMode = SECURE_SOCKET::SECURITY_MODE_SSL;
	ArgHostname = NULL;
	ArgPrincipalName = NULL;
	ArgInputFile = NULL;
	ArgOutputFile = NULL;
	ConnectFlags = 0;

	for (ArgPos = ArgVector + 1; *ArgPos;) {
		Arg = *ArgPos++;

		if (*Arg == L'/' || *Arg == L'-') {
			Arg++;

			IF_STRING_PARAMETER ("name", ArgPrincipalName)
			else IF_STRING_PARAMETER ("in", ArgInputFile)
			else IF_STRING_PARAMETER ("out", ArgOutputFile)
			else if (_wcsicmp (Arg, L"clear") == 0) {
				SecurityMode = SECURE_SOCKET::SECURITY_MODE_CLEAR;
			}
			else if (_wcsicmp (Arg, L"ssl") == 0) {
				SecurityMode = SECURE_SOCKET::SECURITY_MODE_SSL;
			}
			else if (_wcsicmp (Arg, L"nocertcheck") == 0) {
				ConnectFlags |= SECURE_SOCKET::CONNECT_FLAG_DISABLE_CERT_VALIDATION;
			}
			else {
				PrintConsoleF ("TEST: The parameter '%S' is not valid.\n\n", Arg-1);
				Usage();
			}
		}
		else {
			if (ArgHostname) {
				PrintConsole ("TEST: Only a single <hostname> parameter may be specified.\n\n");
				Usage();
			}

			ArgHostname = Arg;
		}
	}

	if (!ArgHostname) {
		PrintConsole ("TEST: The <hostname> parameter is missing.\n\n");
		Usage();
	}



	AppWinsockStatus = WSAStartup (MAKEWORD (1, 1), &WinsockData);
	if (AppWinsockStatus) {
		PrintConsole ("TEST: failed to initialize winsock\n");
		PrintError (AppWinsockStatus);
		return E_FAIL;
	}

	Result = SECURE_SOCKET::RegisterClass();
	if (FAILED (Result)) {
		PrintConsole ("TEST: failed to register secure socket window class\n");
		return Result;
	}

	//
	// Check to see if hostname is an IP address.
	//

	Length = sizeof DestinationAddress;
	if (WSAStringToAddress (ArgHostname, AF_INET, NULL, (SOCKADDR *) &DestinationAddress, &Length)) {
		//
		// It's not an IP address.
		// Assume that it is a DNS FQDN.
		//

		wcsncpy (TextBuffer, ArgHostname, 0x100);
		TextBuffer [0x100] = 0;
		ArgHostname = wcstok (TextBuffer, L":");
		if (!ArgHostname)
			Usage();

		PortText = wcstok (NULL, L":");

		HostEntry = gethostbynameW (ArgHostname);
		if (!HostEntry) {
			Result = GetLastResult();
			PrintConsoleF ("TEST: Failed to resolve hostname '%S':\n", ArgHostname);
			PrintError (Result);
			return Result;
		}

		DestinationAddress.sin_family = AF_INET;
		DestinationAddress.sin_addr = *(IN_ADDR *) HostEntry -> h_addr;

		if (PortText)
			DestinationAddress.sin_port = htons ((USHORT) _wtoi (PortText));
		else
			DestinationAddress.sin_port = htons (0);

		if (!ArgPrincipalName) {
			ArgPrincipalName = ArgHostname;
		}

	}
	else {
		//
		// It's an IP address, and possibly a port.
		// Make sure the user specified a principal name.
		//

		ArgHostname = NULL;

		if (!ArgPrincipalName) {
			PrintConsoleF ("TEST: If <hostname> is a network address (not a DNS name),\n"
				"then you MUST provide the remote principal name, using\n"
				"the -name parameter.\n");
			Usage();
		}
	}


	if (DestinationAddress.sin_port == htons (0)) {
		switch (SecurityMode) {
		case	SECURE_SOCKET::SECURITY_MODE_SSL:
			DestinationAddress.sin_port = htons (443);		// https
			break;

		case	SECURE_SOCKET::SECURITY_MODE_CLEAR:
			DestinationAddress.sin_port = htons (80);		// http
			break;
		}

	}

	//
	// All of the parameters have been parsed,
	// and transport addresses have been resolved.
	// Open the files, then open the socket.
	//


	//
	// Handle the input.
	//

	if (ArgInputFile) {

		FileHandle = CreateFileW (ArgInputFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
			FILE_FLAG_SEQUENTIAL_SCAN, NULL);

		if (FileHandle == INVALID_HANDLE_VALUE || !FileHandle) {
			Result = GetLastResult();
			PrintConsoleF ("TEST: The file '%S' could not be opened:\n", ArgInputFile);
			PrintError (Result);
			return Result;
		}

		PrintConsoleF ("TEST: Input will be read from the file '%S'.\n", ArgInputFile);
		AppSocket.m_Input.Set (FileHandle, TRUE);
	}
	else {
		PrintConsoleF ("TEST: Input will be read from stdin.\n");
		AppSocket.m_Input.Set (GetStdHandle (STD_INPUT_HANDLE), FALSE);
	}

	//
	// Handle the output.
	// Yes, FILE_SHARE_READ is intentional.
	//

	if (ArgOutputFile) {
		FileHandle = CreateFileW (ArgOutputFile, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS,
			0, NULL);

		if (FileHandle == INVALID_HANDLE_VALUE || !FileHandle) {
			Result = GetLastResult();
			PrintConsoleF ("TEST: The file '%S' could not be opened for write access:\n", ArgOutputFile);
			PrintError (Result);
			return Result;
		}

		PrintConsoleF ("TEST: Output will be written to the file '%S'.\n", ArgOutputFile);
		AppSocket.m_Output.Set (FileHandle, TRUE);
	}
	else {
		PrintConsoleF ("TEST: Output will be written to stdout.\n");
		AppSocket.m_Output.Set (GetStdHandle (STD_OUTPUT_HANDLE), FALSE);
	}

	//
	// Start the connection.
	//

	Result = AppSocket.Connect (&DestinationAddress,
		SecurityMode, ArgPrincipalName, ConnectFlags);

	if (FAILED (Result)) {
		PrintConsoleF ("TEST: failed to issue connect:\n");
		PrintError (Result);
		return Result;
	}

	if (ArgHostname) {
		PrintConsoleF ("TEST: connecting to '%S' at address " SOCKADDR_IN_FMT_DECIMAL "\n",
			ArgHostname, SOCKADDR_IN_PRINTF (&DestinationAddress));
	}
	else {
		PrintConsoleF ("TEST: connecting to " SOCKADDR_IN_FMT_DECIMAL "...\n",
			SOCKADDR_IN_PRINTF (&DestinationAddress));
	}

	return S_OK;
}

static void AppStop (void)
{
	AppSocket.Close();

	if (!AppWinsockStatus)
		WSACleanup();
}


static void AppMainLoop (void)
{
	MSG		Message;

//	PrintConsoleF ("TEST: starting message pump\n");

	while (GetMessage (&Message, NULL, 0, 0) > 0) {
		TranslateMessage (&Message);
		DispatchMessage (&Message);
	}

//	PrintConsoleF ("TEST: ending message pump\n");
}

INT __cdecl wmain (
	IN	INT			ArgCount,
	IN	PWSTR *		ArgVector)
{
	HRESULT		Result;

	_Module.Init (NULL, (HINSTANCE) GetModuleHandleW(NULL));

	Result = AppStart (ArgCount, ArgVector);
	if (SUCCEEDED (Result)) {
		AppMainLoop();
	}
	AppStop();

	_Module.Term();

	return Result;
}



//
// TEST_SECURE_SOCKET
//

void TEST_SECURE_SOCKET::Close (void)
{
	SECURE_SOCKET::Close();

	m_Input.Close();
	m_Output.Close();
}

void TEST_SECURE_SOCKET::NotifyConnectComplete (
	IN	HRESULT		Result)
{
	if (SUCCEEDED (Result)) {
		PrintConsoleF ("TEST: connected successfully\n");

		SendTestData();
	}
	else {
		PrintConsoleF ("TEST: failed to connect or negotiate:\n");
		PrintError (Result);
		PostQuitMessage (Result);
	}
}

void TEST_SECURE_SOCKET::SendTestData (void)
{
	HRESULT		Result;
	DWORD		Status;
	DWORD		BytesTransferred;

	//
	// File I/O is "synchronous enough".
	//

	ATLASSERT (m_Input != INVALID_HANDLE_VALUE);


	for (;;) {

		if (!ReadFile (m_Input, m_IoBuffer, IO_BUFFER_MAX, &BytesTransferred, NULL)) {
			Status = GetLastError();

			if (Status != ERROR_HANDLE_EOF) {
				PrintConsoleF ("TEST: An error occurred while reading test input:\n");
				PrintError (Status);
				PostQuitMessage (HRESULT_FROM_WIN32 (Status));
				return;
			}

			break;
		}

		if (!BytesTransferred)
			break;

		Result = SendBuffer (m_IoBuffer, BytesTransferred);
		if (FAILED (Result)) {
			PrintConsoleF ("TEST: Failed to send test buffer:\n");
			PrintError (Result);
			PostQuitMessage (Result);
			return;
		}

		PrintConsoleF ("TEST: sent %u bytes\n", BytesTransferred);
	}
}


void TEST_SECURE_SOCKET::NotifyDisconnect (void)
{
	PrintConsoleF ("TEST: peer disconnected\n");
	PostQuitMessage (S_OK);
}

void TEST_SECURE_SOCKET::NotifyReceiveReady (void)
{
	ULONG		BytesTransferred;
	HRESULT		Result;

	ATLASSERT (m_Output != INVALID_HANDLE_VALUE);

	for (;;) {

		Result = RecvBuffer (m_IoBuffer, IO_BUFFER_MAX, &BytesTransferred);
		switch (Result) {
		case	HRESULT_FROM_WIN32 (WSAEWOULDBLOCK):
			return;

		case	HRESULT_FROM_WIN32 (WSAEDISCON):
			PostQuitMessage (S_OK);
			return;

		case	S_OK:
			break;

		default:
			PrintConsoleF ("TEST: An error occurred while reading data from the network:\n");
			PrintError (Result);
			PostQuitMessage (Result);
			return;
		}

		if (!BytesTransferred)
			break;

		PrintConsoleF ("TEST: received %u bytes\n", BytesTransferred);
//		PrintMemoryBlock (m_IoBuffer, BytesTransferred);

		if (!WriteFile (m_Output, m_IoBuffer, BytesTransferred, &BytesTransferred, NULL)) {
			Result = GetLastResult();
			PrintConsoleF ("TEST: An error occurred while writing output data:\n");
			PrintError (Result);
			PostQuitMessage (Result);
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\ssltest\httpparse.h ===
//
// SIPPARSE.H
//
// The SIPPARSE module contains the SIP parser and generator implementation.
// This file contains the implementation-specific data structures and definition.
//

#pragma	once

#include "siphdr.h"

//
// This must be kept in sorted order, sorted by the header name (not field name!).
// This allows us to do binary searches.
//
// Before invoking this macro, define HTTP_KNOWN_HEADER_ENTRY.
// Then immediately undefine HTTP_KNOWN_HEADER_ENTRY.
//
// Note: Do not add random headers here, even if they do occur only once in the SIP header.
// This structure allows the UAS and UAC to do their jobs.
// It should NOT be bloated with headers that have meaning only for higher-level protocols.
//

#define	HTTP_KNOWN_HEADER_LIST() \
	HTTP_KNOWN_HEADER_ENTRY (ContentLength,		"Content-Length") \
	HTTP_KNOWN_HEADER_ENTRY (ContentType,		"Content-Type") \
	HTTP_KNOWN_HEADER_ENTRY	(WWWAuthenticate,	"WWW-Authenticate")

//	HTTP_KNOWN_HEADER_ENTRY (CallID,			"Call-ID") \
//	HTTP_KNOWN_HEADER_ENTRY (SequenceNumber,	"CSeq") \
//	HTTP_KNOWN_HEADER_ENTRY (From,				"From") \
//	HTTP_KNOWN_HEADER_ENTRY (To,				"To")

//	HTTP_KNOWN_HEADER_ENTRY (Expires,		"Expires")


struct	HTTP_KNOWN_HEADERS
{
#define	HTTP_KNOWN_HEADER_ENTRY(Field,Name) ANSI_STRING Field;
	HTTP_KNOWN_HEADER_LIST()
#undef	HTTP_KNOWN_HEADER_ENTRY

	void	SetKnownHeader (
		IN	ANSI_STRING *	Name,
		IN	ANSI_STRING *	Value);
};

//
// CMessage describes a SIP message.
//

class	CHttpParser
{
public:
	enum	MESSAGE_TYPE
	{
		MESSAGE_TYPE_REQUEST,
		MESSAGE_TYPE_RESPONSE,
	};

public:
	ANSI_STRING				m_ContentBody;
	ULONG					m_HeaderCount;
	HTTP_KNOWN_HEADERS		m_KnownHeaders;
	ANSI_STRING				m_HeaderBlock;
	ANSI_STRING				m_NextMessage;

	//
	// From the first line
	//

	ANSI_STRING				m_Version;
	MESSAGE_TYPE			m_MessageType;
	union {
		struct {
			ANSI_STRING		m_RequestURI;
			ANSI_STRING		m_RequestMethod;
		};

		struct {
			ANSI_STRING		m_ResponseStatusCode;
			ANSI_STRING		m_ResponseStatusText;
		};
	};


public:

	//
	// This method parses a SIP message.
	//
	//		- Determines the type of the message (request or response) and locates
	//			type-specific fields (request URI, version, status, method, etc.)
	//		- Locates several well-known headers (Call-ID, From, To, etc.)
	//		- Locate the content body
	//		- Locate the next message in the packet, if any
	//
	// All parsed fields are stored in the CParser object.
	//

	HRESULT	ParseMessage (
		IN	ANSI_STRING *	Message);
};


typedef BOOL (*CHARACTER_CLASS_FUNC) (
	IN	CHAR	Char);

inline BOOL IsSpace (
	IN	CHAR	Char)
{
	return isspace (Char);
}

//
// ParseScanNextToken finds the next token in a string, and retuns the remainder.
//
// Tokens are separated by non-token separator characters.
// The function passed in SeparatorTestFunc determines what is a separator character,
// and what is not.  The function should return TRUE for separator characters.
//
// The source text is in this form:
//
//		<zero or more separator characters>
//		<one or more token characters>
//		[ <one or more separator characters> OR <end of line> ]
//
// On return, if there was a separator character at the end of the token,
// then ReturnRemainingText starts at that separator character and ends
// at the end of the source text.  It is acceptable for Text and
// ReturnRemainingText to point to the same storage -- the function
// handles this case correctly.
//

HRESULT ParseScanNextToken (
	IN	ANSI_STRING *	Text,
	IN	CHARACTER_CLASS_FUNC	SeparatorTestFunc,
	OUT	ANSI_STRING *	ReturnToken,
	OUT	ANSI_STRING *	ReturnRemainingText);

//
// ParseScanLine scans a string of ANSI text for a line terminator.
// (A line terminator can be \n, \r, \r\n, or \n\r.)
// If it finds a line terminator, it puts the first part of
// the line into ReturnLineText, and the remainder into ReturnRemainingText.
// The line terminator is not included in either of the return strings.
//
// If AllowHeaderContinuation is TRUE, then the function will check to
// see if the SIP header is being continued.
// This is indicated by whitespace in the first character of the next line.
// If AllowHeaderContinuation is TRUE, and a continuation line is found,
// then the continuation text will be included in ReturnLineText.
// Note that this will result in the intermediate CRLF being included;
// it is the responsibility of the caller to interpret CRLF as whitespace.
//
// It is acceptable for SourceText = ReturnRemainingText.
// That is, it is safe to use the same ANSI_STRING to submit the SourceText
// as the one tha receives the remaining text.

HRESULT ParseScanLine (
	IN	ANSI_STRING *	SourceText,
	IN	BOOL			AllowHeaderContinuation,
	OUT	ANSI_STRING *	ReturnLineText,
	OUT	ANSI_STRING *	ReturnRemainingText);
//
// Remove all of the whitespace from the beginning of a string.
//

void ParseSkipSpace (
	IN	OUT	ANSI_STRING *	String);


//
// This function takes a combined URI and display name, and locates the two components.
// For example, if SourceText is "Arlie Davis <sip:arlied@microsoft.com>", then
// ReturnUri will be "sip:arlied@microsoft.com" and ReturnDisplayName will be "Arlie Davis".
//
// Acceptable formats:
//
//		sip:uri
//		<sip:uri>
//		Display Name <sip:uri>
//		"Display Name" <sip:uri>
//
// Return values:
//		S_OK: The URI was located.  ReturnUri -> Length is guaranteed to be greater than zero.
//			If the source text contained a display name, then ReturnDisplayName -> Length
//			will be non-zero.
//		E_INVALIDARG: The URI was malformed or was not present.
//

HRESULT HttpParseUriDisplayName (
	IN	ANSI_STRING *	SourceText,
	OUT	ANSI_STRING *	ReturnUri,
	OUT	ANSI_STRING *	ReturnDisplayName);

//
// This function scans the next header line from a header block,
// and returns separate pointers to the name and value.
// This function returns the remaining header block.
//
// Do NOT call this function on the m_HeaderBlock member of a CHttpParser.
// First copy m_HeaderBlock to a local ANSI_STRING variable, then mangle that.
//

HRESULT	HttpParseNextHeader (
	IN	OUT	ANSI_STRING *	HeaderBlock,
	OUT	ANSI_STRING *		ReturnHeaderName,
	OUT	ANSI_STRING *		ReturnHeaderValue);


//
// Given a string in this form:
//
//		parm1="foo", parm2="bar", parm3=baz
//
// this function returns parm1 in ReturnName, foo in ReturnValue,
// and parm2="bar, parm3=baz in Remainder.
//
// Parameter values may be quoted, or may not.
// All parameters are separated by commas.
// SourceText == ReturnRemainder is legal.
//
// Return values:
//		S_OK: successfully scanned a parameter
//		S_FALSE: no more data
//		E_INVALIDARG: input is invalid
//

HRESULT ParseScanNamedParameter (
	IN	ANSI_STRING *	SourceText,
	OUT	ANSI_STRING *	ReturnRemainder,
	OUT	ANSI_STRING *	ReturnName,
	OUT	ANSI_STRING *	ReturnValue);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\ssltest\md5request.cpp ===
#include "precomp.h"
#include "md5request.h"
#include "httpparse.h"


SECURE_REQUEST::SECURE_REQUEST (void)
{
	m_RequestHost.Clear();
	m_RequestURI.Clear();
	m_Username.Clear();
	m_Password.Clear();

	m_ResponseBuffer = NULL;
	m_ResponseLength = 0;
	m_ResponseMaximumLength = 0;

}


SECURE_REQUEST::~SECURE_REQUEST (void)
{
	ATLASSERT (!m_ResponseBuffer);
	ATLASSERT (!m_ResponseLength);
	ATLASSERT (!m_ResponseMaximumLength);
}

HRESULT SECURE_REQUEST::StartRequest (void)
{
	HRESULT		Result;

	Result = StartRequestInternal();
	if (FAILED (Result))
		StopRequest();

	return Result;
}

HRESULT SECURE_REQUEST::StartRequestInternal (void)
{
	HRESULT		Result;

	//
	// Allocate memory for the response buffer.
	//

	if (!m_ResponseBuffer) {
		ATLASSERT (!m_ResponseLength);
		ATLASSERT (!m_ResponseMaximumLength);

		m_ResponseMaximumLength = 0x1000;
		m_ResponseBuffer = (PSTR) HeapAlloc (GetProcessHeap(), 0, m_ResponseMaximumLength);
		if (!m_ResponseBuffer) {
			m_ResponseMaximumLength = 0;
			return E_OUTOFMEMORY;
		}
	}


	Result = Connect (&m_DestinationAddress,
		SECURITY_MODE_CLEAR, NULL, 0);

	if (FAILED (Result)) {
		ATLTRACE ("SECURE_REQUEST: failed to initiate connect\n");
		DebugError (Result);
		return Result;
	}



	return S_OK;

}


//
// SECURE_SOCKET::NotifyConnectComplete
//

void SECURE_REQUEST::NotifyConnectComplete (
	IN	HRESULT		Result)
{
	if (FAILED (Result)) {
		ATLTRACE ("SECURE_REQUEST: failed to connect, request has failed\n");
		CompleteRequest (Result);
		return;
	}


	ATLTRACE ("SECURE_REQUEST: connected\n");

	Result = BuildSendRequest();
	if (FAILED (Result)) {
		CompleteRequest (Result);
		return;
	}

	ATLTRACE ("SECURE_REQUEST: waiting for response\n");
	m_State = STATE_WAITING_RESPONSE;
}


HRESULT SECURE_REQUEST::BuildSendRequest (void)
{
	HRESULT		Result;
	MESSAGE_BUILDER		Builder;

	//
	// Ok, so we cheat and use the m_ResponseBuffer.
	//

	ATLASSERT (m_ResponseBuffer);
	ATLASSERT (m_ResponseMaximumLength);

	Builder.PrepareBuild (m_ResponseBuffer, m_ResponseMaximumLength);

	Builder.Append ("GET ");
	Builder.Append (m_RequestURI);
	Builder.Append (" HTTP/1.1\r\n");
	Builder.AppendHeader ("Connection", "Keep-Alive");

	if (m_RequestHost [0])
		Builder.AppendHeader ("Host", m_RequestHost);

	Builder.AppendHeader ("Content-Length", "0");

	//
	// End of headers
	//

	Builder.AppendCRLF();


	if (Builder.OverflowOccurred()) {
		ATLTRACE ("SECURE_REQUEST: could not build request message!  buffer overflow\n");
		return E_FAIL;
	}

	Result = SendBuffer (m_ResponseBuffer, Builder.GetLength());
	if (FAILED (Result))
		return Result;

	ATLTRACE ("SECURE_REQUEST: successfully sent request:\n");
	OutputDebugStringA (m_ResponseBuffer, Builder.GetLength());

	return S_OK;
}


//
// SECURE_SOCKET::NotifyDisconnect
//

void SECURE_REQUEST::NotifyDisconnect (void)
{
	CompleteRequest (HRESULT_FROM_WIN32 (ERROR_GRACEFUL_DISCONNECT));
}

void SECURE_REQUEST::CompleteRequest (
	IN	HRESULT		Result)
{
	switch (m_State) {
	case	STATE_IDLE:
		//
		// No request is active
		//

		return;

	case	STATE_CONNECTING:
	case	STATE_WAITING_RESPONSE:

		m_State = STATE_IDLE;
		NotifyRequestComplete (Result);
		break;
	}
}

void SECURE_REQUEST::NotifyReceiveReady (void)
{
	CHttpParser		Parser;
	ANSI_STRING		Message;
	ULONG			BytesTransferred;
	ULONG			TotalBytesTransferred;		// in this run
	HRESULT			Result;

	if (m_State != STATE_WAITING_RESPONSE) {
		ATLTRACE ("SECURE_REQUEST: ready to receive data, but not in a state when we expected it\n");
		return;
	}

	TotalBytesTransferred = 0;

	//
	// Read as much data as we can from the socket.
	//

	for (;;) {

		ATLASSERT (m_ResponseMaximumLength);
		ATLASSERT (m_ResponseBuffer);
		ATLASSERT (m_ResponseLength <= m_ResponseMaximumLength);

		if (m_ResponseLength == m_ResponseMaximumLength) {
			ATLTRACE ("SECURE_REQUEST: ready to receive, but no buffer space left\n");
			return;
		}

		Result = RecvBuffer (m_ResponseBuffer + m_ResponseLength, m_ResponseMaximumLength - m_ResponseLength, &BytesTransferred);
		if (FAILED (Result)) {
			if (Result != HRESULT_FROM_WIN32 (WSAEWOULDBLOCK)) {
				ATLTRACE ("SECURE_REQUEST: ready to receive, but receive failed\n");
				DebugError (Result);
			}

			break;
		}

		if (!BytesTransferred)
			break;

		ATLASSERT (m_ResponseLength + BytesTransferred <= m_ResponseMaximumLength);

		m_ResponseLength += BytesTransferred;
		TotalBytesTransferred += BytesTransferred;
	}

	if (!TotalBytesTransferred)
		return;

	ATLTRACE ("SECURE_REQUEST: received %u bytes, buffer so far:\n", TotalBytesTransferred);

	OutputDebugStringA (m_ResponseBuffer, m_ResponseLength);

	//
	// Parse the data we have received.
	//

	ATLASSERT (m_ResponseLength <= m_ResponseMaximumLength);

	Message.Buffer = m_ResponseBuffer;
	Message.Length = (USHORT) m_ResponseLength * sizeof (CHAR);

	Result = Parser.ParseMessage (&Message);

	if (Result == HRESULT_FROM_WIN32 (ERROR_MORE_DATA)) {
		//
		// The data that we have received are not complete.
		//

		ATLTRACE ("SECURE_REQUEST: received data, but it was not complete, waiting for more...\n");
		return;
	}

	if (FAILED (Result)) {
		//
		// The message is corrupt or can never be successfully parsed.
		//

		CompleteRequest (Result);
		return;
	}

	//
	// Successfully parsed a complete response.
	//

	Result = ProcessResponse (&Parser);
	if (FAILED (Result)) {
		CompleteRequest (Result);
	}
}

HRESULT SECURE_REQUEST::ProcessResponse (
	CHttpParser *	Parser)
{
	HRESULT		Result;

	ATLTRACE ("SECURE_REQUEST: parsed response\n");

	Result = AnsiStringToInteger (&Parser -> m_ResponseStatusCode, 10, &m_ResponseStatusCode);
	if (FAILED (Result))
		return Result;


	switch (m_ResponseStatusCode) {
	case	HTTP_STATUS_CODE_401:
		ATLTRACE ("SECURE_REQUEST: got a status code 401, access denied\n");
		ProcessResponse_AccessDenied (Parser);
		break;

	case	HTTP_STATUS_CODE_404:
		ATLTRACE ("SECURE_REQUEST: got a status code 404\n");
		break;

	default:
		ATLTRACE ("SECURE_REQUEST: status code %u -- request is complete\n");
		CompleteRequest (S_OK);
		break;
	}

	return S_OK;
}

void SECURE_REQUEST::ProcessResponse_AccessDenied (
	IN	CHttpParser *	Parser)
{
	ANSI_STRING		HeaderBlock;
	ANSI_STRING		HeaderName;
	ANSI_STRING		HeaderValue;
	HRESULT			Result;
	ANSI_STRING		AuthenticationMethod;
	ANSI_STRING		Remainder;


	ANSI_STRING		AuthLine_Digest;		// contains parameters to Digest
	ANSI_STRING		AuthLine_Basic;			// contains parameters to Basic

	static CONST ANSI_STRING String_WWWAuthenticate = INITIALIZE_CONST_ANSI_STRING ("WWW-Authenticate");
	static CONST ANSI_STRING String_Negotiate	= INITIALIZE_CONST_ANSI_STRING ("Negotiate");
	static CONST ANSI_STRING String_NTLM		= INITIALIZE_CONST_ANSI_STRING ("NTLM");
	static CONST ANSI_STRING String_Digest		= INITIALIZE_CONST_ANSI_STRING ("Digest");
	static CONST ANSI_STRING String_Basic		= INITIALIZE_CONST_ANSI_STRING ("Basic");


	//
	// Scan through the headers for WWW-Authenticate headers.
	//

	HeaderBlock = Parser -> m_HeaderBlock;

	ZeroMemory (&AuthLine_Digest, sizeof (ANSI_STRING));
	ZeroMemory (&AuthLine_Basic, sizeof (ANSI_STRING));

	while (HttpParseNextHeader (&HeaderBlock, &HeaderName, &HeaderValue) == S_OK) {
		if (!RtlEqualString (&HeaderName, const_cast<ANSI_STRING *> (&String_WWWAuthenticate), TRUE))
			continue;

		Result = ParseScanNextToken (&HeaderValue, IsSpace, &AuthenticationMethod, &Remainder);
		if (FAILED (Result))
			continue;

		ATLTRACE ("SECURE_REQUEST: authentication method (%.*s) parameters (%.*s)\n",
			ANSI_STRING_PRINTF (&AuthenticationMethod),
			ANSI_STRING_PRINTF (&Remainder));

		if (RtlEqualString (&AuthenticationMethod, const_cast<ANSI_STRING *> (&String_Basic), TRUE)) {
			if (!AuthLine_Basic.Buffer)
				AuthLine_Basic = Remainder;
		}
		else if (RtlEqualString (&AuthenticationMethod, const_cast<ANSI_STRING *> (&String_Digest), TRUE)) {
			if (!AuthLine_Digest.Buffer)
				AuthLine_Digest = Remainder;
		}
#if	DBG
		else if (RtlEqualString (&AuthenticationMethod, const_cast<ANSI_STRING *> (&String_NTLM), TRUE)) {}
		else if (RtlEqualString (&AuthenticationMethod, const_cast<ANSI_STRING *> (&String_Negotiate), TRUE)) {}
#endif
		else {
			ATLTRACE ("SECURE_REQUEST: unsupported authentication method (%.*s)\n",
				ANSI_STRING_PRINTF (&AuthenticationMethod));
		}
	}

	if (AuthLine_Digest.Buffer) {
		ProcessDigestResponse (&AuthLine_Digest);
	}
	else if (AuthLine_Basic.Buffer) {
		ProcessBasicResponse (&AuthLine_Basic);
	}
	else {
		ATLTRACE ("SECURE_REQUEST: response did not contain any known authentication mechanism\n");
		CompleteRequest (S_OK);
	}
}

void SECURE_REQUEST::ProcessDigestResponse (
	IN	ANSI_STRING *	ChallengeText)
{
	DIGEST_CHALLENGE	DigestChallenge;
	DIGEST_PARAMETERS	DigestParameters;
	ANSI_STRING			AuthorizationLine;
	CHAR				Buffer	[0x1000];
	HRESULT				Result;

	//
	// First, parse the challenge.
	//

	Result = DigestParseChallenge (ChallengeText, &DigestChallenge);
	if (FAILED (Result))
		return;

	ATLTRACE ("SECURE_REQUEST: realm of challenge is (%.*s)\n",
		ANSI_STRING_PRINTF (&DigestChallenge.Realm));

	//
	// Now build the challenge response.
	//

	AuthorizationLine.Buffer = Buffer;
	AuthorizationLine.MaximumLength = sizeof Buffer;

	DigestParameters.Username = m_Username;
	DigestParameters.Password = m_Password;
	RtlInitString (&DigestParameters.RequestMethod, "GET");
	RtlInitString (&DigestParameters.RequestURI, "/test");

	Result = DigestBuildResponse (&DigestChallenge, &DigestParameters, &AuthorizationLine);
	if (FAILED (Result))
		return;

	ATLTRACE ("SECURE_REQUEST: authorization line: (%.*s)\n",
		ANSI_STRING_PRINTF (&AuthorizationLine));
}

void SECURE_REQUEST::ProcessBasicResponse (
	IN	ANSI_STRING *	AuthParameters)
{
	ATLTRACE ("SECURE_REQUEST: basic authentication, parameters (%.*s)\n",
		ANSI_STRING_PRINTF (AuthParameters));
}




void SECURE_REQUEST::StopRequest (void)
{
	Close();		// close the socket

	if (m_ResponseBuffer) {
		HeapFree (GetProcessHeap(), 0, m_ResponseBuffer);
		m_ResponseBuffer = NULL;
		m_ResponseMaximumLength = NULL;
		m_ResponseLength = 0;
	}

	m_State = STATE_IDLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\ssltest\rtcarray.h ===
#pragma	once


//
// COUNTED_ARRAY contains an array pointer and its m_Length.
// This template class implements a few things that are common
// to this kind of m_Data structure, without imposing any requirements
// on how the array is managed.
//
// Since COUNTED_ARRAY does not have any constructor, it's possible to use
// an initializer list.  This lets you declare global const instances of
// COUNTED_ARRAY and use some of the methods, such as the BinarySearch methods.
//

template <class OBJECT>
class	COUNTED_ARRAY
{
public:

	typedef OBJECT OBJECT_TYPE;

	//
	// Functions of type COMPARE_FUNC are used to compare two elements in the array.
	// This function is passed directly to the CRT quicksort algorithm.
	//
	// Return value:
	//		- negative if ObjectA < ObjectB
	//		- positive if ObjectA > ObjectB
	//		- zero if ObjectA = ObjectB
	//

	typedef int (__cdecl * COMPARE_FUNC) (
		IN	CONST OBJECT * ObjectA,
		IN	CONST OBJECT * ObjectB);


public:
	OBJECT *		m_Data;
	ULONG			m_Length;

public:

	DWORD	GetLength			(void) const { return m_Length; }
	DWORD	GetMaximumLength	(void) const { return m_MaximumLength; }

	void	QuickSort	(
		IN	COMPARE_FUNC	CompareFunc) {

		qsort (m_Data, m_Length, sizeof (OBJECT),
			(int (__cdecl *) (const void *, const void *)) CompareFunc);
	}

	//
	// This class provides several implementations of BinarySearch.
	//
	// The return value indicates whether or not the search key was found in the array.
	//
	//		- If the return value is TRUE, then the entry was found in the array,
	//			and ReturnIndex contains the index of the entry.
	//
	//		- If the return value is FALSE, then the entry was not found in the array,
	//			and ReturnIndex indicates where the entry would be inserted.
	//			(Use AllocAtIndex to insert a new entry at this position.)
	//



	//
	// This version derives the search function from the name of the search key.
	// The search function must be a static member of the search key class,
	// named BinarySearchFunc.
	//

	template <class SEARCH_KEY>
	BOOL BinarySearch (
		IN	CONST SEARCH_KEY *	SearchKey,
		OUT	ULONG *				ReturnIndex) const
	{
		return BinarySearch (SEARCH_KEY::BinarySearchFunc, SearchKey, ReturnIndex);
	}

	template <class SEARCH_KEY>
	BOOL BinarySearch (
		IN	INT (*SearchFunc) (CONST SEARCH_KEY * SearchKey, CONST OBJECT * Comparand),
		IN	CONST SEARCH_KEY *	SearchKey,
		OUT	ULONG *			ReturnIndex) const
	{
		ULONG		Start;
		ULONG		End;
		ULONG		Index;
		OBJECT *	Object;
		int			CompareResult;

		ATLASSERT (ReturnIndex);

		Start = 0;
		End = m_Length;

		for (;;) {

			Index = (Start + End) / 2;

			if (Index == End) {
				*ReturnIndex = Index;
				return FALSE;
			}

			Object = m_Data + Index;

			CompareResult = (*SearchFunc) (SearchKey, Object);

			if (CompareResult == 0) {
				*ReturnIndex = Index;
				return TRUE;
			}
			else if (CompareResult > 0) {
				Start = Index + 1;
			}
			else {
				End = Index;
			}
		}
	}

	template <class SEARCH_KEY>
	BOOL BinarySearch (
		IN	INT (*SearchFunc) (CONST SEARCH_KEY * SearchKey, CONST OBJECT * Comparand),
		IN	CONST SEARCH_KEY *	SearchKey,
		OUT	OBJECT **			ReturnEntry) const
	{
		ULONG	Index;
		BOOL	Status;

		Status = BinarySearch (SearchFunc, SearchKey, &Index);
		*ReturnEntry = m_Data + Index;
		return Status;
	}


	//
	// BinarySearchRange searches for a range of occurrences of a given key.
	// This allows duplicate keys, or allows searches on a completely ordered set,
	// but using an ambiguous (ranged) search key.
	// It finds the first and last occurrences of the key.
	//
	// ReturnIndexStart returns the index of the first matching element.
	// ReturnIndexEnd returns the BOUNDARY of the last matching element (last matching + 1).
	//

	template <class SEARCH_KEY>
	BOOL BinarySearchRange (
		IN	INT (*SearchFunc) (CONST SEARCH_KEY * SearchKey, CONST OBJECT * Comparand),
		IN	CONST SEARCH_KEY *	SearchKey,
		OUT	ULONG *			ReturnIndexStart,
		OUT	ULONG *			ReturnIndexEnd) const
	{
		ULONG		Start;
		ULONG		End;
		ULONG		Index;
		OBJECT *	Object;
		int			CompareResult;

		ATLASSERT (ReturnIndexStart);
		ATLASSERT (ReturnIndexEnd);

		Start = 0;
		End = m_Length;

		for (;;) {

			Index = (Start + End) / 2;

			if (Index == End) {
				*ReturnIndexStart = Index;
				*ReturnIndexEnd = Index;
				return FALSE;
			}

			Object = m_Data + Index;

			CompareResult = (*SearchFunc) (SearchKey, Object);

			if (CompareResult == 0) {

				//
				// Found the "middle" entry.
				// Scan backward to find the first matching element.
				// Note that we abuse / reuse Start.
				//

				Start = Index;
				while (Start > 0 && (*SearchFunc) (SearchKey, &m_Data [Start]) == 0)
					Start--;

				//
				// Scan forward to find the boundary of the last matching element.
				// The boundary is the index of the first element that does NOT match.
				// Note that we reuse / abuse End.
				//

				End = Index;
				while (End < m_Length && (*SearchFunc) (SearchKey, &m_Data [End]) == 0)
					End++;

				*ReturnIndexStart = Start;
				*ReturnIndexEnd = End;

				return TRUE;
			}
			else if (CompareResult > 0) {
				Start = Index + 1;
			}
			else {
				End = Index;
			}
		}
	
	}

	//
	// BinarySearchRange searches for a range of occurrences of a given key.
	// This allows duplicate keys, or allows searches on a completely ordered set,
	// but using an ambiguous (ranged) search key.
	// It finds the first and last occurrences of the key.
	//
	// ReturnPosStart returns the pointer to the first matching element.
	// ReturnPosEnd returns the BOUNDARY pointer of the last matching element (last matching + 1).
	//

	template <class SEARCH_KEY>
	BOOL BinarySearchRange (
		IN	INT (*SearchFunc) (CONST SEARCH_KEY * SearchKey, CONST OBJECT * Comparand),
		IN	CONST SEARCH_KEY *	SearchKey,
		OUT	OBJECT **		ReturnPosStart,
		OUT	OBJECT **		ReturnPosEnd) const
	{
		ULONG		IndexStart;
		ULONG		IndexEnd;
		BOOL		Status;

		Status = BinarySearchRange (SearchFunc, SearchKey, &IndexStart, &IndexEnd);
		*ReturnPosStart = m_Data + IndexStart;
		*ReturnPosEnd = m_Data + IndexEnd;
		return Status;
	}

	void	GetExtents	(
		OUT	OBJECT **	ReturnStart,
		OUT	OBJECT **	ReturnEnd) const
	{
		ATLASSERT (ReturnStart);
		ATLASSERT (ReturnEnd);

		*ReturnStart = m_Data;
		*ReturnEnd = m_Data + m_Length;
	}

	OBJECT &	operator[]	(
		IN	DWORD	Index) const
	{
		ATLASSERT (Index >= 0);
		ATLASSERT (Index < m_Length);

		return m_Data [Index];
	}

	operator OBJECT * (void) const {
		return m_Data;
	}

};


class	CAllocatorHeapDefault
{
public:
	PVOID	Alloc (
		IN	ULONG	RequestedBytes) const
	{
		return HeapAlloc (GetProcessHeap(), 0, RequestedBytes);
	}

	PVOID	ReAlloc (
		IN	PVOID	MemoryBlock,
		IN	ULONG	RequestedBytes) const
	{
		return HeapReAlloc (GetProcessHeap(), 0, MemoryBlock, RequestedBytes);
	}

	void	Free (
		IN	PVOID	MemoryBlock) const
	{
		HeapFree (GetProcessHeap(), 0, MemoryBlock);
	}
};

class	CAllocatorHeap
{
private:
	HANDLE		m_Heap;

public:

#if	DBG
	CAllocatorHeap (void) { m_Heap = NULL; }
#endif

	void	SetHeap	(
		IN	HANDLE	Heap)
	{
		m_Heap = Heap;
	}

	HANDLE	GetHeap (void) const
	{
		return m_Heap;
	}

	PVOID	Alloc (
		IN	ULONG	RequestedBytes) const
	{
		ATLASSERT (m_Heap);
		return HeapAlloc (m_Heap, 0, RequestedBytes);
	}

	PVOID	ReAlloc (
		IN	PVOID	MemoryBlock,
		IN	ULONG	RequestedBytes) const
	{
		ATLASSERT (m_Heap);
		return HeapReAlloc (m_Heap, 0, MemoryBlock, RequestedBytes);
	}

	void	Free (
		IN	PVOID	MemoryBlock) const
	{
		ATLASSERT (m_Heap);
		HeapFree (m_Heap, 0, MemoryBlock);
	}
};

class	CAllocatorCom
{
public:
	PVOID	Alloc (
		IN	ULONG	RequestedBytes) const
	{
		return CoTaskMemAlloc (RequestedBytes);
	}

	PVOID	ReAlloc (
		IN	PVOID	MemoryBlock,
		IN	ULONG	RequestedBytes) const
	{
		return CoTaskMemRealloc (MemoryBlock, RequestedBytes);
	}

	void	Free (
		IN	PVOID	MemoryBlock) const
	{
		CoTaskMemFree (MemoryBlock);
	}

};


//
// An implementation of a dynamic array, using contiguous allocation.
// Array growth is done via reallocation (and implicit copying).
//
// The allocator is specified as a template argument.
// You can define your own allocator, or use:
//		- CAllocatorHeapDefault: Uses the default process heap.
//		- CAllocatorHeap: Uses a specific RTL heap
//		- CAllocatorCom: Uses CoTaskMemAlloc / Free.
//

template <class OBJECT, class CAllocatorClass = CAllocatorHeapDefault>
class	DYNAMIC_ARRAY :
public	COUNTED_ARRAY <OBJECT>
{
public:

	ULONG				m_MaximumLength;
	CAllocatorClass		m_Allocator;

public:

	void	ATLASSERTIntegrity (void) const
	{
#if	DBG
		ATLASSERT (m_Length <= m_MaximumLength);
		ATLASSERT ((m_MaximumLength == 0 && !m_Data) || (m_MaximumLength > 0 && m_Data));
#endif
	}

	void	Clear	(void)
	{
		ATLASSERTIntegrity();
		m_Length = 0;
	}

	void	Free	(void)
	{
		ATLASSERTIntegrity();

		if (m_Data) {
			m_Allocator.Free (m_Data);

			m_Data = NULL;
			m_Length = 0;
			m_MaximumLength = 0;
		}
	}

	//
	// Grow requests that the maximum length be expanded to at least RequestedMaximumLength.
	//
	// If the current maximum length is already equal to or greater than the requested
	// maximum length, then this method does nothing.  Otherwise, this method allocates
	// enough space to accommodate the request.
	//
	// If RequestExtraSpace is TRUE, then the function will allocate more space than is
	// requested, based on the assumption that more space will be needed later.
	//
	// If RequestExtraSpace is FALSE, then the function will only allocate exactly as much
	// space as is requsted.
	//

	BOOL	Grow	(
		IN	ULONG	RequestedMaximumLength,
		IN	BOOL	RequestExtraSpace = TRUE)
	{
		OBJECT *	NewArray;
		DWORD		NewMaximumLength;
		ULONG		BytesRequested;

		ATLASSERTIntegrity();

		if (RequestedMaximumLength <= m_MaximumLength)
			return TRUE;

		//
		// This growth algorithm is extremely arbitrary,
		// and has never been analyzed.
		//

		NewMaximumLength = RequestedMaximumLength + (RequestedMaximumLength >> 1) + 0x20;
		BytesRequested = sizeof (OBJECT) * NewMaximumLength;

		if (m_Data) {
			NewArray = (OBJECT *) m_Allocator.ReAlloc (m_Data, BytesRequested);
		}
		else {
			NewArray = (OBJECT *) m_Allocator.Alloc (BytesRequested);
		}

		if (!NewArray)
			return FALSE;

		m_Data = NewArray;
		m_MaximumLength = NewMaximumLength;

		ATLASSERTIntegrity();

		return TRUE;
	}

	void	Trim	(void)
	{
		OBJECT *	NewArray;
		ULONG		NewMaximumLength;
		ULONG		BytesRequested;

		ATLASSERTIntegrity();

		if (m_Length < m_MaximumLength) {
			ATLASSERT (m_Data);

			if (m_Length > 0) {

				NewArray = m_Allocator.ReAlloc (m_Data, sizeof (OBJECT) * m_Length);
				if (NewArray) {
					m_Data = NewArray;
					m_MaximumLength = m_Length;
				}
			}
			else {
				Free();
			}
		}
	}

	OBJECT *	AllocAtEnd	(
		IN	BOOL	RequestExtraSpace = TRUE)
	{
		ATLASSERTIntegrity();

		if (!Grow (m_Length + 1, TRUE))
			return NULL;

		return m_Data + m_Length++;
	}

	//
	// AllocRangeAtEnd requests to allocate a range (one or more) entries at the end
	// of the array.
	//

	OBJECT *	AllocRangeAtEnd	(
		IN	ULONG	RequestedCount,
		IN	BOOL	RequestExtraSpace = TRUE)
	{
		OBJECT *	ReturnData;

		ATLASSERTIntegrity();

		if (!RequestedCount)
			return 0;

		if (!Grow (m_Length + RequestedCount, RequestExtraSpace))
			return NULL;

		ReturnData = m_Data + m_Length;
		m_Length += RequestedCount;
		return ReturnData;
	}

	OBJECT *	AllocAtIndex	(
		IN	ULONG	Index,
		IN	BOOL	RequestExtraSpace = TRUE) {

		ATLASSERT (Index >= 0);
		ATLASSERT (Index <= m_Length);

		if (!Grow (m_Length + 1, RequestExtraSpace))
			return NULL;

		if (Index < m_Length)
			MoveMemory (m_Data + Index + 1, m_Data + Index, (m_Length - Index) * sizeof (OBJECT));

		m_Length++;

		return m_Data + Index;
	}

	OBJECT *	AllocRangeAtIndex	(
		IN	ULONG	Index,
		IN	ULONG	RequestCount,
		IN	BOOL	RequestExtraSpace = TRUE)
	{
		ATLASSERTIntegrity();
		ATLASSERT (Index >= 0);
		ATLASSERT (Index <= m_Length);

		if (!Grow (m_Length + RequestCount, RequestExtraSpace))
			return NULL;

		if (Index < m_Length)
			MoveMemory (m_Data + Index + RequestCount, m_Data + Index, (m_Length - Index) * sizeof (OBJECT));

		m_Length++;

		ATLASSERTIntegrity();

		return m_Data + Index;
	}




	void	DeleteAtIndex	(
		IN	ULONG	Index)
	{

		ATLASSERTIntegrity();
		ATLASSERT (m_Data);
		ATLASSERT (m_MaximumLength);
		ATLASSERT (m_Length);
		ATLASSERT (Index >= 0);
		ATLASSERT (Index < m_Length);

		MoveMemory (m_Data + Index, m_Data + Index + 1, (m_Length - Index - 1) * sizeof (OBJECT));
		m_Length--;
	}

	void	DeleteRangeAtIndex (
		IN	ULONG	Index,
		IN	ULONG	Count)
	{
		ATLASSERTIntegrity();
		ATLASSERT (Index >= 0);
		ATLASSERT (Index + Count < m_Length);

		if (Count < 0)
			return;

		ATLASSERT (m_Data);
		ATLASSERT (m_Length <= m_MaximumLength);

		MoveMemory (m_Data + Index, m_Data + Index + Count, (m_Length - Index - Count) * sizeof (OBJECT));
		m_Length -= Count;
	}

	//
	// DeleteEntry deletes a single entry by pointer.
	// The pointer MUST point to an element within the array.
	//

	void	DeleteEntry	(OBJECT * Object)
	{
		ATLASSERTIntegrity();
		ATLASSERT (Object >= m_Data);
		ATLASSERT (Object < m_Data + m_Length);

		MoveMemory (Object, Object + 1, (m_Length - ((Object - m_Data) - 1)) * sizeof (OBJECT));
		m_Length--;
	}

	DYNAMIC_ARRAY	(void)
	{
		m_Data = NULL;
		m_Length = 0;
		m_MaximumLength = 0;
	}

	~DYNAMIC_ARRAY	(void)
	{
		ATLASSERTIntegrity();
		Free();
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\twizard\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\ssltest\util.h ===
#pragma	once

//
// Debugging stuff, ripped off from rtcutil.lib.
//


#define	IN_ADDR_FMT		"%u.%u.%u.%u"
#define	IN_ADDR_PRINTF(InternetAddress) \
	((PUCHAR) (InternetAddress)) [0], \
	((PUCHAR) (InternetAddress)) [1], \
	((PUCHAR) (InternetAddress)) [2], \
	((PUCHAR) (InternetAddress)) [3]

#define	SOCKADDR_IN_FMT_DECIMAL		"%u.%u.%u.%u:%u"
#define	SOCKADDR_IN_PRINTF_DECIMAL(SocketAddress) \
	IN_ADDR_PRINTF(&(SocketAddress) -> sin_addr), \
	ntohs ((SocketAddress) -> sin_port)

#define	SOCKADDR_IN_FMT_HEX			"%08X:%04X"
#define	SOCKADDR_IN_PRINTF_HEX(SocketAddress)	\
	ntohl ((SocketAddress) -> sin_addr.s_addr),	\
	ntohs ((SocketAddress) -> sin_port)

#if 0
#define	SOCKADDR_IN_FMT		SOCKADDR_IN_FMT_HEX
#define	SOCKADDR_IN_PRINTF	SOCKADDR_IN_PRINTF_HEX
#else
#define	SOCKADDR_IN_FMT		SOCKADDR_IN_FMT_DECIMAL
#define	SOCKADDR_IN_PRINTF	SOCKADDR_IN_PRINTF_DECIMAL
#endif



static HRESULT GetLastResult (void)
{ return HRESULT_FROM_WIN32 (GetLastError()); }


void PrintConsole (
	IN	PCSTR	Buffer,
	IN	ULONG	Length);

void PrintConsole (
	IN	PCSTR	Buffer);

void PrintConsoleF (
	IN	PCSTR	FormatString,
	IN	...);

void PrintError (
	IN	DWORD	ErrorCode);

void PrintMemoryBlock (
	const void *	Data,
	ULONG			Length);

void DebugError (
	IN	DWORD	ErrorCode);


void OutputDebugStringA (
	IN	PCSTR	Buffer,
	IN	ULONG	Length);

static inline void DebugDumpAnsiString (
	IN	ANSI_STRING *	AnsiString)
{
	OutputDebugStringA (AnsiString -> Buffer, AnsiString -> Length / sizeof (CHAR));
}





class	MESSAGE_BUILDER
{
private:
	PSTR		m_Buffer;
	ULONG		m_Length;
	ULONG		m_MaximumLength;
	BOOL		m_Overflow;

public:

	void	PrepareBuild (
		IN	PSTR	Buffer,
		IN	ULONG	MaximumLength)
	{
		ATLASSERT (Buffer);

		m_Buffer = Buffer;
		m_MaximumLength = MaximumLength;
		m_Length = 0;
		m_Overflow = FALSE;
	}

	BOOL	OverflowOccurred	(void)
	{
		return m_Overflow;
	}

	//
	// GetLength is valid, even if overflow occurred.
	//

	ULONG	GetLength	(void)
	{
		return m_Length;
	}

	void	Append (
		IN	PCSTR	Buffer,
		IN	ULONG	Length)
	{
		if (m_Length + Length <= m_MaximumLength)
			CopyMemory (m_Buffer + m_Length, Buffer, Length);
		else
			m_Overflow = TRUE;

		m_Length += Length;
	}

	void	Append (
		IN	CONST ANSI_STRING *		AnsiString)
	{
		Append (AnsiString -> Buffer, AnsiString -> Length / sizeof (CHAR));
	}

	void	Append (
		IN	PCSTR	Buffer)
	{
		Append (Buffer, strlen (Buffer));
	}

	void	AppendCRLF (void)
	{
		Append ("\r\n", 2);
	}

	void	AppendHeader (
		IN	PCSTR	Name,
		IN	PCSTR	Value)
	{
		Append (Name);
		Append (": ");
		Append (Value);
		AppendCRLF();
	}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\ssltest\util.cpp ===
#include "precomp.h"

//
// Debugging stuff, ripped off from rtcutil.lib.
//

void PrintConsole (
	IN	PCSTR	Buffer,
	IN	ULONG	Length)
{
	DWORD	BytesTransferred;

	if (!WriteFile (GetStdHandle (STD_ERROR_HANDLE), Buffer, Length, &BytesTransferred, NULL))
		DebugBreak();
}

void PrintConsole (
	IN	PCSTR	Buffer)
{
	PrintConsole (Buffer, strlen (Buffer));
}

void PrintConsoleF (
	IN	PCSTR	FormatString,
	IN	...)
{
	va_list		ArgumentList;
	CHAR		Buffer	[0x200];

	va_start (ArgumentList, FormatString);
	_vsnprintf (Buffer, 0x200, FormatString, ArgumentList);
	va_end (ArgumentList);

	PrintConsole (Buffer);
}




void PrintError (
	IN	DWORD	ErrorCode)
{
	CHAR	Text	[0x300];
	DWORD	MaxLength;
	PSTR	Pos;
	DWORD	Length;
	DWORD	CharsTransferred;

	strcpy (Text, "\tError: ");
	Pos = Text + strlen (Text);

	MaxLength = 0x300 - (DWORD)(Pos - Text) - 4;	// 4 for \r\n and nul and pad


	Length = FormatMessageA (FORMAT_MESSAGE_FROM_SYSTEM, NULL, ErrorCode, LANG_NEUTRAL, Pos, MaxLength, NULL);
	if (!Length) {
		_snprintf (Pos, MaxLength, "Unknown error %08XH %u", ErrorCode, ErrorCode);
		Length = strlen (Pos);
	}

	while (Length > 0 && Pos [Length - 1] == '\r' || Pos [Length - 1] == '\n')
		Length--;

	Pos [Length++] = '\r';
	Pos [Length++] = '\n';
//	Pos [Length++] = 0;

	PrintConsole (Text);
}

void DebugError (
	IN	DWORD	ErrorCode)
{
	CHAR	Text	[0x300];
	DWORD	MaxLength;
	PSTR	Pos;
	DWORD	Length;
	DWORD	CharsTransferred;

	strcpy (Text, "\tError: ");
	Pos = Text + strlen (Text);

	MaxLength = 0x300 - (DWORD)(Pos - Text) - 4;	// 4 for \r\n and nul and pad


	Length = FormatMessageA (FORMAT_MESSAGE_FROM_SYSTEM, NULL, ErrorCode, LANG_NEUTRAL, Pos, MaxLength, NULL);
	if (!Length) {
		_snprintf (Pos, MaxLength, "Unknown error %08XH %u", ErrorCode, ErrorCode);
		Length = strlen (Pos);
	}

	while (Length > 0 && Pos [Length - 1] == '\r' || Pos [Length - 1] == '\n')
		Length--;

	Pos [Length++] = '\r';
	Pos [Length++] = '\n';
	Pos [Length++] = 0;

	OutputDebugStringA (Text);
}

static __inline CHAR ToHexA (UCHAR x)
{
	x &= 0xF;
	if (x < 10) return x + '0';
	return (x - 10) + 'A';
}

void PrintMemoryBlock (
	const void *	Data,
	ULONG			Length)
{
	const UCHAR *	DataPos;		// position within data
	const UCHAR *	DataEnd;		// end of valid data
	const UCHAR *	RowPos;		// position within a row
	const UCHAR *	RowEnd;		// end of single row
	CHAR			Text	[0x100];
	LPSTR			TextPos;
	ULONG			RowWidth;
	ULONG			Index;

	ATLASSERT (!Length || Data);

	DataPos = (PUCHAR) Data;
	DataEnd = DataPos + Length;

	while (DataPos < DataEnd) {
		RowWidth = (DWORD)(DataEnd - DataPos);

		if (RowWidth > 16)
			RowWidth = 16;

		RowEnd = DataPos + RowWidth;

		TextPos = Text;
		*TextPos++ = '\t';

		for (RowPos = DataPos, Index = 0; Index < 0x10; Index++, RowPos++) {
			if (RowPos < RowEnd) {
				*TextPos++ = ToHexA ((*RowPos >> 4) & 0xF);
				*TextPos++ = ToHexA (*RowPos & 0xF);
			}
			else {
				*TextPos++ = ' ';
				*TextPos++ = ' ';
			}

			*TextPos++ = ' ';
		}

		*TextPos++ = ' ';
		*TextPos++ = ':';

		for (RowPos = DataPos; RowPos < RowEnd; RowPos++) {
			if (*RowPos < ' ')
				*TextPos++ = '.';
			else
				*TextPos++ = *RowPos;
		}

		*TextPos++ = '\r';
		*TextPos++ = '\n';
		*TextPos = 0;

		fputs (Text, stdout);

		ATLASSERT (RowEnd > DataPos);		// make sure we are walking forward

		DataPos = RowEnd;
	}
}


//
// This function is similar to OutputDebugStringA, except that it
// operates on a counted string, rather than a nul-terminated string.
//
// NTSTATUS.H defines DBG_PRINTEXCEPTION_C.
// The exception parameters are:
//
//		0: Length in bytes of the text to output
//		1: Pointer to ANSI string of text to output
//
// The source to OutputDebugString uses (strlen (string) + 1),
// which includes the nul terminator.  Not sure if some debuggers
// will choke on a memory block that does not have a nul terminator.
//

void OutputDebugStringA (
	IN	PCSTR		Buffer,
	IN	ULONG		Length)
{
	ULONG_PTR	ExceptionArguments	[2];

	__try {
		ExceptionArguments [0] = Length;
		ExceptionArguments [1] = (ULONG_PTR) Buffer;
		RaiseException (DBG_PRINTEXCEPTION_C, 0, 2, ExceptionArguments);
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {
		//
		// Since we caught the exception, there is no user-mode debugger attached.
		// OutputDebugStringA attempts to send the exception to a kernel-mode debugger.
		// We aren't quite that valiant.
		//
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\twizard\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__8B964C70_A342_48AD_A55A_7B98BD604F1A__INCLUDED_)
#define AFX_STDAFX_H__8B964C70_A342_48AD_A55A_7B98BD604F1A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>
#include <windows.h>
#include <winreg.h>

// Standard Windows SDK includes
#include <windowsx.h>
#include <mmsystem.h>
#include <shellapi.h>
#include <winsock.h>
#include <commdlg.h>
#include <cderr.h>
#include <winldap.h>
#include <wincrypt.h>
#include <time.h>

#include <commctrl.h>

#include "rtccore.h"
#include "twizard.h"

#include "rtclog.h"
#include "rtcmem.h"

#include "dllres.h"


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8B964C70_A342_48AD_A55A_7B98BD604F1A__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\ssltest\rtcstring.cpp ===
#include "precomp.h"
#include "rtcstring.h"

//
// Counted String (Template) Functions and Methods
//

#if 0

template <class COUNTED_STRING, class CHAR_TYPE>
HRESULT COUNTED_STRING_HEAP<COUNTED_STRING,CHAR_TYPE>::RegQueryValue (
	IN	HKEY	Key,
	IN	LPCWSTR	Name)
{
	HRESULT		Result;
	LONG		Status;
	DWORD		DataLength;
	DWORD		Type;

	DataLength = MaximumLength;
	Status = RegQueryValueExW (Key, Name, NULL, &Type, (LPBYTE) Buffer, &DataLength);

	if (Status == ERROR_MORE_DATA) {
		//
		// String buffer was not large enough to contain the registry key.
		// Length should now contain the required minimum 
		// Expand it and try again.
		//

		if (!Grow (DataLength)) {
			Length = 0;
			return E_OUTOFMEMORY;
		}

		DataLength = MaximumLength;
		Status = RegQueryValueExW (Key, Name, NULL, &Type, (LPBYTE) Buffer, &DataLength);

		if (Status != ERROR_SUCCESS) {
			Length = 0;
			return HRESULT_FROM_WIN32 (Status);
		}
	}
	else if (Status != ERROR_SUCCESS) {
		//
		// A real error has occurred.  Bail.
		//

		Length = 0;
		return HRESULT_FROM_WIN32 (Status);
	}


	if (Type == REG_SZ) {
		ATLASSERT (DataLength <= MaximumLength);
		Length = DataLength;

		//
		// Remove the trailing NUL character.
		//

		if (Length > 0 && !Buffer [Length / sizeof (CHAR_TYPE) - 1])
			Length -= sizeof (CHAR_TYPE);


		Result = S_OK;
	}
	else {
		Length = 0;
		Result = HRESULT_FROM_WIN32 (ERROR_INVALID_DATA);
	}

	return Result;
}


template <class CHAR_TYPE, class COUNTED_STRING, ULONG MAXIMUM_CHARS>
HRESULT COUNTED_STRING_STATIC<CHAR_TYPE, COUNTED_STRING, MAXIMUM_CHARS>::RegQueryValue (
	IN	HKEY	Key,
	IN	LPCWSTR	Name)
{
	LONG		Status;
	HRESULT		Result;

	Length = MaximumLength;
	Status = RegQueryValueExW (Key, Name, NULL, &Type, (LPBYTE) Buffer, &Length);
	if (Status != ERROR_SUCCESS) {
		Length = 0;
		return HRESULT_FROM_WIN32 (Status);
	}

	ATLASSERT (Length <= MaximumLength);

	if (Type != REG_SZ)
		return HRESULT_FROM_WIN32 (ERROR_INVALID_DATA);

	//
	// Remove the trailing NUL character.
	//

	if (Length > 0 && !Buffer [Length / sizeof (CHAR_TYPE) - 1])
		Length -= sizeof (CHAR_TYPE);

	return S_OK;
}

#endif




// returned memory is allocated with HeapAlloc from the given heap
// must be freed with HeapFree

EXTERN_C LPWSTR ConcatCopyStringsW (
	IN	HANDLE		Heap,
	IN	...)
{
	va_list		VaList;
	DWORD		StringCount;
	DWORD		TotalStringLength;		// in wide characters
	LPCWSTR		String;
	LPWSTR		ReturnString;
	LPWSTR		CopyPos;
	DWORD		Length;

	ATLASSERT (Heap);

	TotalStringLength = 0;

	va_start (VaList, Heap);

	for (;;) {
		String = va_arg (VaList, LPCWSTR);
		if (String)
			TotalStringLength += wcslen (String);
		else
			break;
	}

	va_end (VaList);

	ReturnString = (LPWSTR) HeapAlloc (Heap, 0, (TotalStringLength + 1) * sizeof (WCHAR));
	
	if (ReturnString) {
		// iterate the set again, copying

		va_start (VaList, Heap);

		CopyPos = ReturnString;

		for (;;) {
			String = va_arg (VaList, LPCWSTR);

			if (String) {
				Length = wcslen (String);

				// make sure we do not walk off the allocated memory
				ATLASSERT ((CopyPos - ReturnString) + Length <= TotalStringLength);

				// do not copy the terminating nul
				CopyMemory (CopyPos, String, Length * sizeof (WCHAR));

				// advance to next string
				CopyPos += Length;
			}
			else
				break;
		}

		va_end (VaList);

		// consistency check
		ATLASSERT (ReturnString + TotalStringLength == CopyPos);

		// terminate the concatenated string
		*CopyPos = 0;
	}
	else {
		ATLTRACE ("ConcatCopyStrings: Allocation failure, %d bytes\n",
			(TotalStringLength + 1) * sizeof (WCHAR));
	}

	return ReturnString;
}


HRESULT AnsiStringToInteger (
	IN	ANSI_STRING *	String,
	IN	ULONG			DefaultBase,
	OUT	ULONG *			ReturnValue)
{
	ULONG	Value;
	PSTR	Pos;
	PSTR	End;

	ATLASSERT (String);
	ATLASSERT (String -> Buffer);
	ATLASSERT (ReturnValue);

	if (DefaultBase != 10)
		return E_NOTIMPL;

	Value = 0;
	Pos = String -> Buffer;
	End = String -> Buffer + String -> Length / sizeof (CHAR);

	if (Pos == End)
		return E_INVALIDARG;

	for (; Pos < End; Pos++) {
		if (*Pos >= '0' && *Pos <= '9')
			Value = Value * 10 + (*Pos - '0');
		else
			return E_INVALIDARG;
	}

	*ReturnValue = Value;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\ssltest\rtcstring.h ===
#pragma	once


template <DWORD MaxLength>
struct	FIXED_STRING	{
public:
	enum { MAX = MaxLength };

public:
	TCHAR	Data	[MAX + 1];

public:
	void	Clear	(void) {
		Data [0] = 0;
	}

	DWORD GetMax (void) { return MAX; }

#ifdef	UNICODE

	void Store (LPCSTR ansi_string) {
		int	x;

		ATLASSERT (ansi_string);
		x = MultiByteToWideChar (CP_ACP, 0, ansi_string, -1, Data, MAX);
		Data [x] = 0;
	}

	void Store (LPCWSTR string) {

		ATLASSERT (string);
		wcsncpy (Data, string, MAX);
		Data [MAX] = 0;
	}

	void StoreCounted (LPCWSTR String, DWORD Length) {
		ATLASSERT (String);

		if (Length > MAX)
			Length = MAX;

		memcpy (Data, String, sizeof (WCHAR) * Length);
		Data [Length] = 0;
	}

#if 0
	void StoreUnicodeString (UNICODE_STRING * UnicodeString) {
		ATLASSERT (UnicodeString);
		ATLASSERT (UnicodeString -> Buffer);

		StoreCounted (UnicodeString -> Buffer, UnicodeString -> Length / sizeof (WCHAR));
	}
#endif

#else // ANSI

	void Store (LPCSTR string) {
		ATLASSERT (string);
		strncpy (Data, string, MAX);
		Data [MAX] = 0;
	}

	void Store (LPCWSTR string) {
		int	x;

		ATLASSERT (string);
		x = WideCharToMultiByte (CP_ACP, 0, string, -1, Data, MAX, NULL, FALSE);
		Data [x] = 0;
	}

#endif

	// no bounds checking
	void	StoreNumber	(DWORD value) {
		_itot (value, Data, 10);
	}

	void StoreNumber (DWORDLONG value) {
		_ui64tot (value, Data, 10);
	}

#ifdef	_WINSOCKAPI_
	void StoreIPAddress (IN_ADDR addr) {
		Store (inet_ntoa (addr));
	}
#endif

	void StoreIPAddress (DWORD addr) {
		IN_ADDR	in;

		in.s_addr = addr;
		StoreIPAddress (in);
	}

	void Append (LPCTSTR string) {
		ATLASSERT (string);

		_tcsncat (Data, string, MAX);
		Data [MAX - 1] = 0;
	}

#if 0
	BOOL RegQuery (HKEY key, LPCTSTR name) {
		LONG	status;
		DWORD	type;
		DWORD	length;

		length = sizeof (TCHAR) * MAX;
		status = RegQueryValueEx (key, name, NULL, &type, (LPBYTE) &Data, &length);
		return status == ERROR_SUCCESS && type == REG_SZ;
	}

	BOOL RegSet (HKEY key, LPCTSTR name) {
		LONG	status;

		status = RegSetValueEx (key, name, 0, REG_SZ, (LPBYTE) &Data, sizeof (TCHAR) * (_tcslen (Data) + 1));
		return status == ERROR_SUCCESS;
	}
#endif

	FIXED_STRING	(void)	{ Data [0] = 0; }
	FIXED_STRING	(LPCTSTR string) {
		Store (string);
	}

	operator LPTSTR (void) { return Data; }

	void operator= (LPCSTR string) {
		Store (string);
	}

	void operator= (LPCWSTR string) {
		Store (string);
	}

	DWORD GetLength (void) {
		return _tcslen (Data);
	}

	void	Format (LPCTSTR fmt, ...) {
		va_list	va;

		va_start (va, fmt);
		_vsntprintf (Data, MAX, fmt, va);
		Data [MAX - 1] = 0;
		va_end (va);
	}

	void	FormatAppend (LPCTSTR fmt, ...) {
		va_list	va;
		DWORD	length;
		DWORD	max;

		length = _tcslen (Data);
		max = MAX - length;
		va_start (va, fmt);
		_vsntprintf (Data + length, max, fmt, va);
		va_end (va);
	}

	void	GetWindowText	(HWND window) {
		::GetWindowText (window, Data, MAX);
	}

	BOOL	IsEmpty	(void) {
		return Data [0] == _T('\0');
	}
};










//
// Counted string classes and functions.
//

//
// Ok, these are somewhat hackish, but this is better than the explosion of permutations
// in derived classes if you don't do this.
//

static __inline int GetStringLength (IN PCSTR String) { return strlen (String); }
static __inline int GetStringLength (IN PCWSTR String) { return wcslen (String); }

//
// COUNTED_STRING_BASE is interchangeable with ANSI_STRING and UNICODE_STRING.
// It does not add any new data members (and, of course, no virtual methods).
// It does add a few simple methods.
//


template <class CHAR_TYPE, class COUNTED_STRING>
struct	COUNTED_STRING_BASE :
public	COUNTED_STRING
{
public:

	typedef CHAR_TYPE CHAR_TYPEDEF;

	void	GetRemainder	(
		OUT	COUNTED_STRING *	ReturnRemainder)
	{
		ATLASSERT (ReturnRemainder);

		ReturnRemainder -> Buffer = Buffer + Length / sizeof (CHAR_TYPE);
		ReturnRemainder -> MaximumLength = MaximumLength - Length;
		ReturnRemainder -> Length = 0;
	}

	void	Clear	(void)
	{
		Length = 0;
	}


	// explicit specialization of template method
#if 0
	void	FormatText	<UNICODE_STRING, WCHAR> (
		IN	const UNICODE_STRING *	FormatText,
		IN	...)
	{
		va_list		ArgList;

		va_start (ArgList, FormatText);
		_vswnprintf (Buffer, MaximumLength / sizeof (WCHAR), FormatText, ArgList);
		Length = wcslen (Buffer) * sizeof (WCHAR);
		va_end (ArgList);
	}
#endif

#if 0
	void	FormatText	(
		IN	const CHAR_TYPE *	FormatText,
		IN	...)
	{
		va_list		Va;

		va_start (Va, FormatText);
		_vsnprintf (Buffer, MaximumLength / sizeof (CHAR), FormatText, ArgList);
		Length = strlen (Buffer) * sizeof (CHAR);
	}
#endif

};

//
// COUNTED_STRING_HEAP manages a COUNTED_STRING (either ANSI_STRING or UNICODE_STRING),
// using the default process heap for backing store.
//
// Note: The fields Length and MaximumLength are expressed in BYTES, not CHARACTERS.
//
// The class will always maintain a NUL terminating character.
// The NUL is never counted in the Length field.
//

template <class CHAR_TYPE, class COUNTED_STRING>
struct	COUNTED_STRING_HEAP :
public	COUNTED_STRING_BASE <CHAR_TYPE, COUNTED_STRING>
{

public:

	COUNTED_STRING_HEAP	(void)
	{
		Buffer = NULL;
		Length = 0;
		MaximumLength = 0;
	}

	~COUNTED_STRING_HEAP	(void)
	{
		Free();
	}

	void	Free	(void)
	{
		if (Buffer) {
			HeapFree (GetProcessHeap(), 0, Buffer);
			Buffer = NULL;
		}

		Length = 0;
		MaximumLength = 0;
	}

	BOOL	Grow	(
		IN	ULONG	DesiredMaximumLength)		// in bytes
	{
		PSTR	NewBuffer;
		ULONG	NewMaximumLength;

		if (DesiredMaximumLength <= MaximumLength)
			return TRUE;


		//
		// This is a crude heuristic.
		//

		NewMaximumLength = DesiredMaximumLength + DesiredMaximumLength / 4 + 0x20;
		NewBuffer = HeapReAlloc (GetProcessHeap(), 0, Buffer, NewMaximumLength);

		if (NewBuffer) {
			Buffer = NewBuffer;
			MaximumLength = NewMaximumLength;

			return TRUE;
		}
		else {
			return FALSE;
		}
	}

	BOOL	Append	(
		IN	COUNTED_STRING *	SourceString)
	{
		if (Grow (Length + SourceString -> Length + sizeof (CHAR_TYPE))) {
			CopyMemory (Buffer + Length / sizeof (CHAR_TYPE), SourceString -> Buffer, SourceString -> Length);
			Length += SourceString -> Length;

			// Add a NUL terminator the string.
			Buffer [Length / sizeof (CHAR_TYPE)] = 0;

			return TRUE;
		}
		else {
			return FALSE;
		}
	}

	BOOL	Set	(
		IN	COUNTED_STRING *	SourceString)
	{
		Clear();
		return Append (SourceString);
	}

	//
	// RegQueryValue will grow the string to fit the registry value.
	//

	operator CHAR_TYPE * (void) const { return Buffer; }
};


//
// COUNTED_STRING_STATIC manages a counted string (ANSI_STRING or UNICODE_STRING),
// using a fixed-length buffer, allocated as part of the object itself.
// Some of the methods are similar to those of COUNTED_STRING_HEAP.
//

template <class CHAR_TYPE, class COUNTED_STRING, ULONG MAXIMUM_CHARS>
struct	COUNTED_STRING_STATIC :
public	COUNTED_STRING_BASE <CHAR_TYPE, COUNTED_STRING>
{
	enum { MAXIMUM_LENGTH = MAXIMUM_CHARS * sizeof (CHAR_TYPE) };

	CHAR_TYPE	BufferStore	[MAXIMUM_CHARS + 1];


	COUNTED_STRING_STATIC	(void)
	{
		Buffer = BufferStore;
		MaximumLength = MAXIMUM_LENGTH;
		Length = 0;
	}

	void	Clear	(void)
	{
		Length = 0;
		BufferStore[0] = 0;
	}

	BOOL	Set	(
		IN	const COUNTED_STRING *	SourceString)
	{
		Clear();
		return Append (SourceString);
	}

	BOOL	Set (
		IN	const CHAR_TYPE *		SourceString)
	{
		COUNTED_STRING	CountedString;

		CountedString.Buffer = const_cast<CHAR_TYPE *> (SourceString);
		CountedString.Length = GetStringLength (SourceString) * sizeof (CHAR_TYPE);

		return Set (&CountedString);
	}

	BOOL	Append	(
		IN	const COUNTED_STRING *	SourceString)
	{
		USHORT	CopyLength;
		BOOL	ReturnStatus;

		CopyLength = SourceString -> Length;
		ReturnStatus = CopyLength + Length <= MAXIMUM_LENGTH * sizeof (CHAR_TYPE);
		if (!ReturnStatus)
			CopyLength = MAXIMUM_LENGTH * sizeof (CHAR_TYPE) - Length;

		CopyMemory (Buffer + Length / sizeof (CHAR_TYPE), SourceString -> Buffer, CopyLength);
		Length += CopyLength;
		Buffer [Length / sizeof (CHAR_TYPE)] = 0;

		return ReturnStatus;
	}

	BOOL	Append	(
		IN	const CHAR_TYPE *			SourceString)
	{
		COUNTED_STRING		CountedString;

		CountedString.Buffer = const_cast <CHAR_TYPE *> (SourceString);
		CountedString.Length = GetStringLength (SourceString) * sizeof (CHAR_TYPE);

		return Append (&CountedString);
	}


	operator CHAR_TYPE * (void) const { return Buffer; }
};


typedef	COUNTED_STRING_HEAP <CHAR, ANSI_STRING>	ANSI_STRING_HEAP;
typedef	COUNTED_STRING_HEAP <WCHAR, UNICODE_STRING>	UNICODE_STRING_HEAP;


template <ULONG MAXIMUM_CHARS>
class	ANSI_STRING_STATIC :
public	COUNTED_STRING_STATIC <CHAR, ANSI_STRING, MAXIMUM_CHARS>
{
};

template <ULONG MAXIMUM_CHARS>
class	UNICODE_STRING_STATIC :
public	COUNTED_STRING_STATIC <WCHAR, UNICODE_STRING, MAXIMUM_CHARS>
{
public:


	//
	// Set the contents of this string from an ANSI string.
	// Code page can be any constant from MultiByteToWideChar.
	//

	void	ConvertAnsiString (
		IN	ANSI_STRING *	AnsiString,
		IN	UINT			CodePage)
	{
		ULONG	Length;

		Length = MultiByteToWideChar (CodePage, 0, AnsiString -> Buffer,
			AnsiString -> Length / sizeof (CHAR), Buffer, MAXIMUM_CHARS - 1);
		Buffer [Length] = 0;
	}


};

//
// GetStringRemainder is used to locate the end of a string buffer.
// This is useful for writing directly into the end of a buffer,
// rather than writing to an intermediate buffer and then append.
// Use like this:
//
//		CHAR			Buffer	[0x80];
//		ANSI_STRING		String;
//		ANSI_STRING		Remainder;
//
//		String.Buffer = Buffer;
//		String.MaximumLength = sizeof Buffer;
//		String.Length = 0;
//
//		GetStringRemainder (&String, &Remainder);
//		RtlCopyString (&Remainder, &SourceString);
//		String.Length += Remainder.Length;

template <class COUNTED_STRING>
void GetStringRemainder (
	IN	COUNTED_STRING *		String,
	OUT	COUNTED_STRING *		ReturnRemainder)
{
	ATLASSERT (String);
	ATLASSERT (ReturnRemainder);

	ReturnRemainder -> Buffer = String -> Buffer + String -> Length / sizeof (*String -> Buffer);
	ReturnRemainder -> MaximumLength = String -> MaximumLength - String -> Length;
	ReturnRemainder -> Length = 0;
}

template <class COUNTED_STRING>
HRESULT CountedStringFromGUID (
	IN	REFGUID				GuidReference,
	OUT	COUNTED_STRING *	CountedString)
{
	HRESULT		Result;

	Result = StringFromGUID2 (GuidReference, CountedString -> Buffer,
		CountedString -> MaximumLength / sizeof (*CountedString -> Buffer));

	if (Result == S_OK) {
		CountedString -> Length = GetStringLength (CountedString -> Buffer) * sizeof (*CountedString -> Buffer);
		ATLASSERT (CountedString -> Length <= CountedString -> MaximumLength);
	}

	return Result;
}

template <class COUNTED_STRING, class CHAR_TYPE>
LONG RegSetValueEx (
	IN	HKEY	Key,
	IN	const CHAR_TYPE *	ValueName,
	IN	COUNTED_STRING *	CountedString)
{
	return RegSetValueEx (Key, ValueName, NULL, REG_SZ, (PUCHAR) CountedString -> Buffer, CountedString -> Length);
}

template <class COUNTED_STRING, class CHAR_TYPE>
LONG RegQueryValueEx (
	IN	HKEY	Key,
	IN	const CHAR_TYPE *	ValueName,
	OUT	COUNTED_STRING_HEAP <COUNTED_STRING, CHAR_TYPE> *	CountedStringHeap)
{
	LONG		Status;
	DWORD		Type;
	DWORD		DataLength;

	DataLength = 0;
	Status = RegQueryValueEx (Key, ValueName, NULL, &Type, NULL, &DataLength);
	if (Status == ERROR_SUCCESS) {
		Debug (_T("RegQueryValueEx: expected to get ERROR_MORE_DATA, but got ERROR_SUCCESS??\n"));
		CountedString -> Length = 0;
		return ERROR_SUCCESS;
	}

	// silently truncate
	if (DataLength >= 0x10000) {
		DebugF (_T("RegQueryValueEx: will have to truncate value\n"));
		DataLength = 0xFFFF;
	}

	if (!CountedString -> Grow (DataLength + sizeof (CHAR_TYPE)))
		return ERROR_NOT_ENOUGH_MEMORY;


	Status = RegQueryValueEx (Key, ValueName, NULL, &Type, (PUCHAR) CountedString -> Buffer, &DataLength);
	if (Status == ERROR_SUCCESS) {
		CountedString -> Length = (USHORT) DataLength;
		CountedString -> Buffer [CountedString -> Length / sizeof (CHAR_TYPE)] = 0;
	}

	return Status;
}

template <class COUNTED_STRING, class CHAR_TYPE, ULONG MAXIMUM_LENGTH>
LONG RegQueryValueEx (
	IN	HKEY	Key,
	IN	const CHAR_TYPE *	ValueName,
	OUT	COUNTED_STRING_STATIC <CHAR_TYPE, COUNTED_STRING, MAXIMUM_LENGTH> *	CountedString)
{
	LONG		Status;
	DWORD		Type;
	DWORD		DataLength;

	DataLength = CountedString -> MaximumLength;
	Status = RegQueryValueEx (Key, ValueName, NULL, &Type, (LPBYTE) CountedString -> Buffer, &DataLength);
	CountedString -> Length = (USHORT) DataLength;

	return Status;
}

//
// FindFirstChar finds the first occurrence of a character in a string.
//

template <class COUNTED_STRING, class CHAR_TYPE>
CHAR_TYPE * FindFirstChar (
	IN	COUNTED_STRING *	CountedString,
	IN	CHAR_TYPE	SearchChar)
{
	CHAR_TYPE *		Pos;
	CHAR_TYPE *		End;

	ATLASSERT (CountedString);

	Pos = CountedString -> Buffer;
	End = CountedString -> Buffer + CountedString -> Length / sizeof (CHAR_TYPE);
	for (; Pos < End; Pos++)
		if (*Pos == SearchChar)
			return Pos;

	return NULL;
}

//
// FindFirstCharList finds the first occurrence of a list of characters in a string.
// Unfortunately, the search is very inefficient.
// Performance is proportional to the product of the length of the string 
// that must be searched and the length ofthe search list.
//

template <class COUNTED_STRING, class CHAR_TYPE>
CHAR_TYPE * FindFirstCharList (
	IN	COUNTED_STRING *	CountedString,
	IN	CONST CHAR_TYPE *	SearchList)
{
	CHAR_TYPE *		Pos;
	CHAR_TYPE *		End;
	CONST CHAR_TYPE *		SearchPos;

	ATLASSERT (CountedString);

	Pos = CountedString -> Buffer;
	End = CountedString -> Buffer + CountedString -> Length / sizeof (CHAR_TYPE);
	for (; Pos < End; Pos++) {
		SearchPos = SearchList;
		while (*SearchPos)
			if (*SearchPos++ == *Pos)
				return Pos;
	}

	return NULL;
}

#define	INITIALIZE_CONST_COUNTED_STRING(Text) \
	{ sizeof (Text) - sizeof (*Text), sizeof (Text) - sizeof (*Text), (Text) }

#define	INITIALIZE_CONST_UNICODE_STRING		INITIALIZE_CONST_COUNTED_STRING
#define	INITIALIZE_CONST_ANSI_STRING		INITIALIZE_CONST_COUNTED_STRING

//
// For use in printf argument lists
//

#define	COUNTED_STRING_PRINTF(CountedString) \
	(CountedString) -> Length / sizeof (*(CountedString) -> Buffer), \
	(CountedString) -> Buffer

#define	UNICODE_STRING_PRINTF		COUNTED_STRING_PRINTF
#define	ANSI_STRING_PRINTF			COUNTED_STRING_PRINTF

#define	UNICODE_STRING_FMT		_T("%.*s")
#define	ANSI_STRING_FMT			_T("%.*S")



#define	ConcatCopyStrings			ConcatCopyStringsW 

EXTERN_C LPWSTR ConcatCopyStringsW (
	IN	HANDLE		Heap,
	IN	...);


HRESULT AnsiStringToInteger (
	IN	ANSI_STRING *	String,
	IN	ULONG			DefaultBase,
	OUT	ULONG *			ReturnValue);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\twizard\twizard.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    twizard.cpp

Abstract:

    Implements Tuning Wizard entry function and its associates.


--*/

#include <stdafx.h>
#include "ui.h"

/* clearing bytes */
#define ClearStruct(lpv)     ZeroMemory((LPVOID) (lpv), sizeof(*(lpv)))
#define InitStruct(lpv)      {ClearStruct(lpv); (* (LPDWORD)(lpv)) = sizeof(*(lpv));}

#define OATRUE -1
#define OAFALSE 0

static HINSTANCE g_hInst;

BOOL g_bAutoSetAEC = TRUE; //whether we should auto set the AEC checkbox

//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

HRESULT CTuningWizard::GetCapabilities(
                       BOOL * pfAudioCapture,
                       BOOL * pfAudioRender,
                       BOOL * pfVideo
                       )
{
    LOG((RTC_TRACE, "CTuningWizard::GetCapabilities: Entered"));

    *pfAudioCapture = m_fCaptureAudio;
    *pfAudioRender = m_fRenderAudio;
    *pfVideo = m_fVideo;

    LOG((RTC_TRACE, "CTuningWizard::GetCapabilities: Exited"));

    return S_OK;
}

//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

HRESULT CTuningWizard::InitTerminalInfo(
                       WIZARD_TERMINAL_INFO * pwtiTerminals,
                       RTC_MEDIA_TYPE mt,
                       RTC_MEDIA_DIRECTION md
                       )
{
    LOG((RTC_TRACE, "CTuningWizard::InitTerminalInfo: Entered"));

    if (pwtiTerminals == NULL)
    {
        return E_FAIL;
    }
    
    ZeroMemory(pwtiTerminals, sizeof(WIZARD_TERMINAL_INFO));

    pwtiTerminals->dwSystemDefaultTerminal  = TW_INVALID_TERMINAL_INDEX;
    pwtiTerminals->dwTuningDefaultTerminal  = TW_INVALID_TERMINAL_INDEX;
    pwtiTerminals->mediaDirection           = md;
    pwtiTerminals->mediaType                = mt;

    LOG((RTC_TRACE, "CTuningWizard::InitTerminalInfo: Exited"));

    return S_OK;

}

//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

HRESULT CTuningWizard::Initialize(
                                  IRTCClient * pRTCClient,
                                  IRTCTerminalManage * pRTCTerminalManager, 
                                  HINSTANCE hInst
                                  )
{
    HRESULT hr;
    RTC_MEDIA_TYPE mediaType;
    RTC_MEDIA_DIRECTION mediaDirection;
    WIZARD_TERMINAL_INFO * pwtiTerminalInfo;
    TW_TERMINAL_TYPE tt;
    
    LOG((RTC_TRACE, "CTuningWizard::Initialize: Entered"));
    
    m_lCurrentPage = 0;
    m_fRenderAudio = FALSE;
    m_fCaptureAudio = FALSE;
    m_fVideo = FALSE;
    m_hInst = hInst;
    m_lLastErrorCode = 0;
    m_fTuningInitCalled = FALSE;
    m_fEnableAEC = TRUE;
    m_fSoundDetected = FALSE;
    m_pRTCClient = pRTCClient;

    hr = InitTerminalInfo(
                          &m_wtiAudioRenderTerminals,
                          RTC_MT_AUDIO,
                          RTC_MD_RENDER
                         );

    hr = InitTerminalInfo(
                          &m_wtiAudioCaptureTerminals,
                          RTC_MT_AUDIO,
                          RTC_MD_CAPTURE
                         );

    hr = InitTerminalInfo(
                          &m_wtiVideoTerminals,
                          RTC_MT_VIDEO,
                          RTC_MD_CAPTURE
                         );

    // Store the RTCTerminalManage Interface pointer

    m_pRTCTerminalManager = pRTCTerminalManager;

    hr = m_pRTCTerminalManager->QueryInterface(
                                IID_IRTCTuningManage, 
                                (void **)&m_pRTCTuningManager);
    
    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "CTuningWizard::Initialize: Faile to QI for TuningManage "
                        "interface(hr=0x%x)", hr));
        return hr;
    }


    // Get the volume and audio level ranges so that we can display
    // the values in the wizard pageg properly.

    // For Audio Render device.

    hr = m_pRTCTuningManager->GetVolumeRange(RTC_MD_RENDER, 
                        &(m_wrRenderVolume.uiMin),
                        &(m_wrRenderVolume.uiMax)
                        );

    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "CTuningWizard::Initialize: Failed to GetVolumeRange "
                        "for Audio Render(hr=0x%x)", hr));

        // We put our own default values;
        m_wrRenderVolume.uiMax = DEFAULT_MAX_VOLUME;
    }
    // Calculate the increment value for display.
    m_wrRenderVolume.uiIncrement = (m_wrRenderVolume.uiMax - 
                                     m_wrRenderVolume.uiMin ) / 
                                     MAX_VOLUME_NORMALIZED;


    LOG((RTC_INFO, "CTuningWizard::Initialize: Render Terminal - maxVol=%d, " 
                   "Increment=%d",m_wrRenderVolume.uiMax, 
                   m_wrRenderVolume.uiIncrement ));

    // For Audio Capture device
    hr = m_pRTCTuningManager->GetVolumeRange(RTC_MD_RENDER, 
                        &(m_wrCaptureVolume.uiMin),
                        &(m_wrCaptureVolume.uiMax)
                        );

    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "CTuningWizard::Initialize: Failed to GetVolumeRange "
                        "for Audio Capture(hr=0x%x)", hr));

        // We put our own default values;
        m_wrCaptureVolume.uiMax = DEFAULT_MAX_VOLUME;
    }
    // Calculate the increment value for display.
    m_wrCaptureVolume.uiIncrement = (m_wrCaptureVolume.uiMax - 
                                     m_wrCaptureVolume.uiMin ) /
                                     MAX_VOLUME_NORMALIZED;

    LOG((RTC_INFO, "CTuningWizard::Initialize: Capture Terminal - maxVol=%d, " 
                   "Increment=%d",m_wrCaptureVolume.uiMax, 
                   m_wrCaptureVolume.uiIncrement ));

    // For Audio Level Range
    hr = m_pRTCTuningManager->GetAudioLevelRange(RTC_MD_CAPTURE, 
                        &(m_wrAudioLevel.uiMin),
                        &(m_wrAudioLevel.uiMax)
                        );

    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "CTuningWizard::Initialize: Failed to GetAudioLevelRange "
                        "for Audio level(hr=0x%x)", hr));

        // We put our own default values;
        m_wrAudioLevel.uiMax = DEFAULT_MAX_VOLUME;
    }

    // Calculate the increment value for display.
    m_wrAudioLevel.uiIncrement = (m_wrAudioLevel.uiMax - 
                                     m_wrAudioLevel.uiMin ) / 
                                     MAX_VOLUME_NORMALIZED;



    // Now go through the list of terminals and categorize them. We do bulk of the 
    // work at initialization time, so that we don't have to do this enumeration
    // everytime the wizard page is activated.
    // Get all the static terminals.

    m_dwTerminalCount = MAX_TERMINAL_COUNT;
    hr = m_pRTCTerminalManager->GetStaticTerminals(&m_dwTerminalCount, 
                                              m_ppTerminalList);

    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "CTuningWizard::Initialize: Failed to get static "
                        "Terminals"));
        return hr;
    }

    hr = CategorizeTerminals();
    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "CTuningWizard::Initialize: Failed to categorize "
                        "Terminals(error=0x%x)", hr));
        ReleaseTerminals();
        return hr;
    }


    // Read the default terminal of each type from the system and save it
    // in our member variables for later use.

    for ( tt = TW_AUDIO_CAPTURE; 
          tt < TW_LAST_TERMINAL; 
          tt = (TW_TERMINAL_TYPE)(tt + 1))
    {

        hr = GetTerminalInfoFromType(tt, &pwtiTerminalInfo);
        
        if ( FAILED( hr ) )
        {
            LOG((RTC_ERROR, "CTuningWizard::Initialize: Failed in getting "
                            "terminal info from type(%d), error=0x%x", tt, hr));
            return hr;
        }


        mediaType = pwtiTerminalInfo->mediaType;
        mediaDirection = pwtiTerminalInfo->mediaDirection;

        hr = TuningSaveDefaultTerminal(
                         mediaType,
                         mediaDirection,
                         pwtiTerminalInfo
                         );

        if ( FAILED( hr ) )
        {
            // Will fail if there is some problem in setting the 
            // variables or something, not finding a default terminal
            // is not an error.

            LOG((RTC_ERROR, "CTuningWizard::Initialize: Failed to set default "
                            "Terminal(media=%d, direction=%d", mediaType,
                            mediaDirection));
            return hr;
        }
    }


    LOG((RTC_TRACE, "CTuningWizard::Initialize: Exited"));

    return S_OK;
}


//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

HRESULT CTuningWizard::SaveAECSetting()
{

    // Shutdown Tuning too
    if (m_pRTCTuningManager && m_fTuningInitCalled)
    {
        m_pRTCTuningManager->SaveAECSetting();
    }

    return S_OK;
}


//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

HRESULT CTuningWizard::Shutdown()
{

    ReleaseTerminals();

    if (m_pVideoWindow)
    {
        m_pVideoWindow->Release();
        m_pVideoWindow = NULL;
    }

    // Shutdown Tuning too
    if (m_pRTCTuningManager)
    {
        if (m_fTuningInitCalled)
        {
            m_pRTCTuningManager->ShutdownTuning();

            m_fTuningInitCalled = FALSE;
        }
        
        m_pRTCTuningManager->Release();
        m_pRTCTuningManager = NULL;
    }

    return S_OK;
}


//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

HRESULT CTuningWizard::GetTerminalInfoFromType(
                       IN TW_TERMINAL_TYPE md, 
                       OUT WIZARD_TERMINAL_INFO ** ppwtiTerminalInfo)
{
    switch (md) {
        case TW_AUDIO_CAPTURE:
            *ppwtiTerminalInfo = &m_wtiAudioCaptureTerminals;
            break;

        case TW_AUDIO_RENDER:
            *ppwtiTerminalInfo = &m_wtiAudioRenderTerminals;
            break;
        
        case TW_VIDEO:
            *ppwtiTerminalInfo = &m_wtiVideoTerminals;
            break;
        
        default:
            LOG((RTC_ERROR, "CTuningWizard::GetTerminalInfoFromType: Invalid "
                            "terminal type(%d)", md));
            return E_FAIL;
    }

    return S_OK;
}

//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

HRESULT CTuningWizard::GetRangeFromType(
                       IN TW_TERMINAL_TYPE md, 
                       OUT WIZARD_RANGE ** ppwrRange)
{
    switch (md) {
        case TW_AUDIO_CAPTURE:
            *ppwrRange = &m_wrCaptureVolume;
            break;

        case TW_AUDIO_RENDER:
            *ppwrRange = &m_wrRenderVolume;
            break;
        
        case TW_VIDEO:
            *ppwrRange = &m_wrAudioLevel;
            break;
        
        default:
            LOG((RTC_ERROR, "CTuningWizard::GetRangeFromType: Invalid "
                            "terminal type(%d)", md));
            return E_FAIL;
    }

    return S_OK;
}

//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

HRESULT CTuningWizard::CheckMicrophone(
                       HWND hDlg, 
                       HWND hwndCapture)
{
    MMRESULT                        mmresult;
    MIXERLINECONTROLS               mxlc;
    MIXERCONTROL                    mxctl;    
    HMIXER                          hMixer;
    MIXERCONTROLDETAILS             mxcd;
    MIXERCONTROLDETAILS_UNSIGNED    mxcd_u;     
    DWORD                           dwTerminalId = 0;
    UINT                            uiWaveID = 0;
    HRESULT                         hr;

    LOG((RTC_TRACE, "CTuningWizard::CheckMicrophone - enter"));

    //
    // Get the terminal
    //

    hr = GetItemFromCombo(hwndCapture, &dwTerminalId);

    if ( FAILED( hr ) ) 
    {
        LOG((RTC_ERROR, "CTuningWizard::CheckMicrophone - GetItemFromCombo failed 0x%x", hr));

        return hr;
    }

    IRTCAudioConfigure * pAudioCfg = NULL;

    hr = m_ppTerminalList[dwTerminalId]->QueryInterface(
                        IID_IRTCAudioConfigure, 
                        (void **)&pAudioCfg);
    
    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "CTuningWizard::CheckMicrophone: QueryInterface failed 0x%x", hr));

        return hr;
    }

    //
    // Get the wave id
    //

    hr = pAudioCfg->GetWaveID( &uiWaveID );

    pAudioCfg->Release();
    pAudioCfg = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CTuningWizard::CheckMicrophone: GetWaveID failed 0x%x", hr));

        return hr;
    }

    //
    // Open the mixer
    //

    mmresult = mixerOpen( &hMixer, uiWaveID, 0, 0, MIXER_OBJECTF_WAVEIN);

    if ( mmresult != MMSYSERR_NOERROR )
    {
        LOG((RTC_ERROR, "CTuningWizard::CheckMicrophone - mixerOpen failed"));
            
        return E_FAIL;
    }

    //
    // Get mixer caps
    //

    MIXERCAPS mxcaps;

    mmresult = mixerGetDevCaps( (UINT_PTR)hMixer, &mxcaps, sizeof(MIXERCAPS));

    if ( mmresult != MMSYSERR_NOERROR )
    {
        mixerClose( hMixer );

        LOG((RTC_ERROR, "CTuningWizard::CheckMicrophone - mixerGetDevCaps failed"));
            
        return E_FAIL;
    }

    LOG((RTC_INFO, "CTuningWizard::CheckMicrophone - mixer [%ws]", mxcaps.szPname));

    //
    // Search for the WAVEIN destination
    //

    DWORD dwDst;

    for (dwDst=0; dwDst < mxcaps.cDestinations; dwDst++)
    {
        //
        // Get destination info
        //

        MIXERLINE mxl_d;

        mxl_d.cbStruct = sizeof(MIXERLINE);
        mxl_d.dwDestination = dwDst;

        mmresult = mixerGetLineInfo( (HMIXEROBJ)hMixer, &mxl_d, MIXER_GETLINEINFOF_DESTINATION);

        if ( mmresult != MMSYSERR_NOERROR )
        {
            mixerClose( hMixer );

            LOG((RTC_ERROR, "CTuningWizard::CheckMicrophone - mixerGetLineInfo failed"));
            
            return E_FAIL;
        } 

        if (mxl_d.dwComponentType == MIXERLINE_COMPONENTTYPE_DST_WAVEIN)
        {
            //
            // Found the WAVEIN destination
            // 

            LOG((RTC_INFO, "CTuningWizard::CheckMicrophone - destination [%ws]", mxl_d.szName));

            //
            // Get the MUTE control on the WAVEIN destination
            //

            mxlc.cbStruct = sizeof(MIXERLINECONTROLS);
            mxlc.dwLineID = mxl_d.dwLineID;
            mxlc.dwControlType = MIXERCONTROL_CONTROLTYPE_MUTE;
            mxlc.pamxctrl = &mxctl;
            mxlc.cbmxctrl = sizeof(mxctl);

            mmresult = mixerGetLineControls( (HMIXEROBJ)hMixer, &mxlc, MIXER_GETLINECONTROLSF_ONEBYTYPE);

            if ( mmresult == MMSYSERR_NOERROR )
            {
                mxcd.cbStruct       = sizeof(mxcd);
                mxcd.dwControlID    = mxctl.dwControlID;
                mxcd.cChannels      = 1;
                mxcd.cMultipleItems = 0;
                mxcd.cbDetails      = sizeof(mxcd_u);
                mxcd.paDetails      = &mxcd_u;

                mmresult = mixerGetControlDetails( (HMIXEROBJ)hMixer, &mxcd, MIXER_GETCONTROLDETAILSF_VALUE);

                if ( mmresult == MMSYSERR_NOERROR )
                {
                    if ( mxcd_u.dwValue )
                    {
                        LOG((RTC_WARN, "CTuningWizard::CheckMicrophone - WAVEIN is MUTED"));

                        if (DisplayMessage(
                                _Module.GetResourceInstance(),
                                hDlg,
                                IDS_WAVEIN_MUTED,
                                IDS_AUDIO_WARNING,
                                MB_YESNO | MB_ICONQUESTION
                                ) == IDYES)
                        {
                            mxcd_u.dwValue = 0;

                            mmresult = mixerSetControlDetails( (HMIXEROBJ)hMixer, &mxcd, MIXER_SETCONTROLDETAILSF_VALUE);

                            if ( mmresult != MMSYSERR_NOERROR )
                            {
                                LOG((RTC_ERROR, "CTuningWizard::CheckMicrophone - mixerSetControlDetails failed"));
                            }
                        }
                    }
                }
            } 

            //
            // Search for the MICROPHONE source
            //

            DWORD dwSrc;

            for (dwSrc = 0; dwSrc < mxl_d.cConnections; dwSrc++)
            {
                //
                // Get source Info
                //

                MIXERLINE mxl_s;

                mxl_s.cbStruct = sizeof(MIXERLINE);
                mxl_s.dwDestination = dwDst;
                mxl_s.dwSource = dwSrc;

                mmresult = mixerGetLineInfo( (HMIXEROBJ)hMixer, &mxl_s, MIXER_GETLINEINFOF_SOURCE);

                if ( mmresult != MMSYSERR_NOERROR )
                {
                    mixerClose( hMixer );

                    LOG((RTC_ERROR, "CTuningWizard::CheckMicrophone - mixerGetLineInfo failed"));
            
                    return E_FAIL;
                } 

                if (mxl_s.dwComponentType == MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE)
                {
                    //
                    // Found the MICROPHONE source
                    //  
                    
                    LOG((RTC_INFO, "CTuningWizard::CheckMicrophone - source [%ws]", mxl_s.szName));
                
                    //
                    // Get the MUTE control on the MICROPHONE source
                    //

                    mxlc.cbStruct = sizeof(MIXERLINECONTROLS);
                    mxlc.dwLineID = mxl_s.dwLineID;
                    mxlc.dwControlType = MIXERCONTROL_CONTROLTYPE_MUTE;
                    mxlc.pamxctrl = &mxctl;
                    mxlc.cbmxctrl = sizeof(mxctl);

                    mmresult = mixerGetLineControls( (HMIXEROBJ)hMixer, &mxlc, MIXER_GETLINECONTROLSF_ONEBYTYPE);

                    if ( mmresult == MMSYSERR_NOERROR )
                    {
                        //
                        // Get the MUTE value
                        //

                        mxcd.cbStruct       = sizeof(mxcd);
                        mxcd.dwControlID    = mxctl.dwControlID;
                        mxcd.cChannels      = 1;
                        mxcd.cMultipleItems = 0;
                        mxcd.cbDetails      = sizeof(mxcd_u);
                        mxcd.paDetails      = &mxcd_u;

                        mmresult = mixerGetControlDetails( (HMIXEROBJ)hMixer, &mxcd, MIXER_GETCONTROLDETAILSF_VALUE);

                        if ( mmresult == MMSYSERR_NOERROR )
                        {
                            if ( mxcd_u.dwValue )
                            {
                                LOG((RTC_WARN, "CTuningWizard::CheckMicrophone - MICROPHONE is MUTED"));

                                if (DisplayMessage(
                                        _Module.GetResourceInstance(),
                                        hDlg,
                                        IDS_MICROPHONE_MUTED,
                                        IDS_AUDIO_WARNING,
                                        MB_YESNO | MB_ICONQUESTION
                                        ) == IDYES)
                                {
                                    mxcd_u.dwValue = 0;

                                    mmresult = mixerSetControlDetails( (HMIXEROBJ)hMixer, &mxcd, MIXER_SETCONTROLDETAILSF_VALUE);

                                    if ( mmresult != MMSYSERR_NOERROR )
                                    {
                                        LOG((RTC_ERROR, "CTuningWizard::CheckMicrophone - mixerSetControlDetails failed"));
                                    }
                                }
                            }
                        }
                    }

                    //
                    // Get the MUX control on the WAVEIN destination
                    //

                    BOOL bFoundMUX = FALSE;
                    BOOL bFoundMIXER = FALSE;

                    mxlc.cbStruct = sizeof(MIXERLINECONTROLS);
                    mxlc.dwLineID = mxl_d.dwLineID;
                    mxlc.dwControlType = MIXERCONTROL_CONTROLTYPE_MUX;
                    mxlc.pamxctrl = &mxctl;
                    mxlc.cbmxctrl = sizeof(mxctl);

                    mmresult = mixerGetLineControls( (HMIXEROBJ)hMixer, &mxlc, MIXER_GETLINECONTROLSF_ONEBYTYPE);

                    if ( mmresult == MMSYSERR_NOERROR )
                    {
                        //
                        // Found a MUX control on the WAVEIN destination
                        //

                        bFoundMUX = TRUE;
                    } 
                    else
                    {
                        //
                        // Get the MIXER control on the WAVEIN destination
                        //

                        mxlc.cbStruct = sizeof(MIXERLINECONTROLS);
                        mxlc.dwLineID = mxl_d.dwLineID;
                        mxlc.dwControlType = MIXERCONTROL_CONTROLTYPE_MIXER;
                        mxlc.pamxctrl = &mxctl;
                        mxlc.cbmxctrl = sizeof(mxctl);

                        mmresult = mixerGetLineControls( (HMIXEROBJ)hMixer, &mxlc, MIXER_GETLINECONTROLSF_ONEBYTYPE);

                        if ( mmresult == MMSYSERR_NOERROR )
                        {
                            //
                            // Found a MIXER control on the WAVEIN destination
                            //

                            bFoundMIXER = TRUE;
                        } 
                    }

                    if ( bFoundMUX || bFoundMIXER )
                    {
                        MIXERCONTROLDETAILS_LISTTEXT * pmxcd_lt;
                        MIXERCONTROLDETAILS_BOOLEAN * pmxcd_b;    
                
                        //
                        // Allocate memory for the control details
                        //

                        pmxcd_lt = (MIXERCONTROLDETAILS_LISTTEXT *) 
                            RtcAlloc( sizeof(MIXERCONTROLDETAILS_LISTTEXT) * mxctl.cMultipleItems * mxl_d.cChannels );

                        if ( pmxcd_lt == NULL )
                        {
                            mixerClose( hMixer );

                            LOG((RTC_ERROR, "CTuningWizard::CheckMicrophone - out of memory"));
            
                            return E_OUTOFMEMORY;
                        }

                        pmxcd_b = (MIXERCONTROLDETAILS_BOOLEAN *)
                            RtcAlloc( sizeof(MIXERCONTROLDETAILS_BOOLEAN) * mxctl.cMultipleItems * mxl_d.cChannels );

                        if ( pmxcd_b == NULL )
                        {
                            mixerClose( hMixer );

                            LOG((RTC_ERROR, "CTuningWizard::CheckMicrophone - out of memory"));
            
                            return E_OUTOFMEMORY;
                        }

                        //
                        // Get LISTTEXT details
                        //

                        mxcd.cbStruct       = sizeof(mxcd);
                        mxcd.dwControlID    = mxctl.dwControlID;
                        mxcd.cChannels      = mxl_d.cChannels;
                        mxcd.cMultipleItems = mxctl.cMultipleItems;
                        mxcd.cbDetails      = sizeof(MIXERCONTROLDETAILS_LISTTEXT);
                        mxcd.paDetails      = pmxcd_lt;

                        mmresult = mixerGetControlDetails( (HMIXEROBJ)hMixer, &mxcd, MIXER_GETCONTROLDETAILSF_LISTTEXT);  

                        if ( mmresult == MMSYSERR_NOERROR )
                        {
                            //
                            // Get BOOLEAN details
                            //

                            mxcd.cbStruct       = sizeof(mxcd);
                            mxcd.dwControlID    = mxctl.dwControlID;
                            mxcd.cChannels      = mxl_d.cChannels;
                            mxcd.cMultipleItems = mxctl.cMultipleItems;
                            mxcd.cbDetails      = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
                            mxcd.paDetails      = pmxcd_b;

                            mmresult = mixerGetControlDetails( (HMIXEROBJ)hMixer, &mxcd, MIXER_GETCONTROLDETAILSF_VALUE);

                            if ( mmresult == MMSYSERR_NOERROR )
                            {
                                DWORD dwItem;                                

                                for( dwItem = 0; dwItem < mxctl.cMultipleItems; dwItem++)
                                {
                                    if (mxl_s.dwLineID == pmxcd_lt[dwItem].dwParam1)
                                    {
                                        BOOL bNotSelected = FALSE;
                                        DWORD dwChannel = 0;

                                        //for ( dwChannel = 0; dwChannel < mxl_d.cChannels; dwChannel++ )
                                        //{
                                            if ( pmxcd_b[ (dwChannel * mxctl.cMultipleItems) + dwItem].fValue == 0 )
                                            {
                                                bNotSelected = TRUE;
                                            }
                                        //}

                                        if ( bNotSelected )
                                        {
                                            LOG((RTC_WARN, "CTuningWizard::CheckMicrophone - MICROPHONE is NOT selected"));

                                            if (DisplayMessage(
                                                    _Module.GetResourceInstance(),
                                                    hDlg,
                                                    IDS_MICROPHONE_NOT_SELECTED,
                                                    IDS_AUDIO_WARNING,
                                                    MB_YESNO | MB_ICONQUESTION
                                                    ) == IDYES)
                                            {
                                                ZeroMemory(pmxcd_b, sizeof(MIXERCONTROLDETAILS_BOOLEAN) * mxctl.cMultipleItems * mxl_d.cChannels);

                                                for ( dwChannel = 0; dwChannel < mxl_d.cChannels; dwChannel++ )
                                                {
                                                    pmxcd_b[ (dwChannel * mxctl.cMultipleItems) + dwItem].fValue = 1;
                                                }

                                                mmresult = mixerSetControlDetails( (HMIXEROBJ)hMixer, &mxcd, MIXER_SETCONTROLDETAILSF_VALUE);

                                                if ( mmresult != MMSYSERR_NOERROR )
                                                {
                                                    LOG((RTC_ERROR, "CTuningWizard::CheckMicrophone - mixerSetControlDetails failed"));
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        RtcFree( pmxcd_lt );
                        pmxcd_lt = NULL;

                        RtcFree( pmxcd_b );
                        pmxcd_b = NULL;
                    } 

                    //
                    // Done with MICROPHONE source, so break
                    //

                    break;
                }
            }

            //
            // Done with WAVEIN destination, so break
            //

            break;
        }
    }

    mixerClose( hMixer );
    hMixer = NULL;

    LOG((RTC_TRACE, "CTuningWizard::CheckMicrophone - exit"));

    return S_OK;
}

//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

HRESULT CTuningWizard::PopulateComboBox(TW_TERMINAL_TYPE md, HWND hwnd )
{
    HRESULT hr;
    RTC_MEDIA_TYPE mediaType, iMediaType;
    RTC_MEDIA_DIRECTION mediaDirection, iMediaDirection;
    WCHAR * szMediaDescription;
    DWORD dwComboCount = 0;
    DWORD i, currIndex;
    DWORD *pdwTerminalIndex;
    DWORD dwDefaultTerminalId;
    DWORD dwTerminalIndex;
    DWORD dwCurrentSelection = 0;
    WIZARD_TERMINAL_INFO * pwtiTerminalInfo;
    TCHAR szNone[64];


    LOG((RTC_TRACE, "CTuningWizard::PopulateComboBox: Entered(md=%d)",
                    md));

    hr = GetTerminalInfoFromType(md, &pwtiTerminalInfo);
    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "CTuningWizard::PopulateComboBox: Failed in getting "
                        "terminal info from type(%d), error=0x%x", md, hr));
        return hr;
    }
    
    pdwTerminalIndex = &(pwtiTerminalInfo->pdwTerminals[0]);
    dwDefaultTerminalId = pwtiTerminalInfo->dwTuningDefaultTerminal;


    // Now go thorugh the list of indices and populate the combo box

    // Clear the previous contents, if any.
    SendMessage(hwnd,
                CB_RESETCONTENT,
                0,
                0L
                );

    // Insert a none selection
    if (LoadString( _Module.GetResourceInstance(),
                IDS_NONE,
                szNone,
                64
              ))
    {
        LRESULT lrIndex;

        lrIndex = SendMessage(
            hwnd,
            CB_ADDSTRING,
            0,
            (LPARAM) szNone
            );

        SendMessage(
            hwnd,
            CB_SETITEMDATA,
            lrIndex,
            (LPARAM) TW_INVALID_TERMINAL_INDEX
            );

        dwComboCount ++;
    }

    for (i = 0; pdwTerminalIndex[i] != TW_INVALID_TERMINAL_INDEX; i ++)
    {
        dwTerminalIndex = pdwTerminalIndex[i];
        // Check if this is the default, then it has to be made current selection 
        // in combo box.
        if (dwTerminalIndex == dwDefaultTerminalId)
        {
            // Mark this as the current selection
            dwCurrentSelection = dwComboCount;
        }

        hr = m_ppTerminalList[dwTerminalIndex]->GetDescription(&szMediaDescription);
        if ( FAILED( hr ) )
        {
            LOG((RTC_ERROR, "CTuningWizard::PopulateComboBox: Can't get "
                            "media description(termId=%d)", dwTerminalIndex));
            return hr;
        }

        // We got an entry for us, put the string in the combo box.

        LRESULT lrIndex;

        lrIndex = SendMessage(
            hwnd,
            CB_ADDSTRING,
            0,
            (LPARAM) szMediaDescription
            );

        // free description
        m_ppTerminalList[dwTerminalIndex]->FreeDescription(szMediaDescription);

        //
        // Set the itemdata to the interface pointer to the index in the terminal
        // list so that we can use it later.
        //

        SendMessage(
            hwnd,
            CB_SETITEMDATA,
            lrIndex,
            (LPARAM) dwTerminalIndex
            );

        // increment the count of strings we have added.
        dwComboCount ++;
    }

    // dwDefaultTerminalId points to the current default terminal as read from
    // the system or as overwritten by user selection.

    // Set the current selection
    SendMessage(
        hwnd,
        CB_SETCURSEL,
        dwCurrentSelection,
        0L
        );


    LOG((RTC_TRACE, "CTuningWizard::PopulateComboBox: Exited(comboCount=%d)", 
                    dwComboCount));
    return S_OK;
}



//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

HRESULT CTuningWizard::UpdateAEC(HWND hwndCapture, 
                                 HWND hwndRender,
                                 HWND hwndAEC,
                                 HWND hwndAECText)
{

    DWORD dwCapture;
    DWORD dwRender;
    HRESULT hr;

    IRTCTerminal * pCapture = NULL;
    IRTCTerminal * pRender = NULL;
    BOOL fAECCapture = FALSE;
    BOOL fAECRender = FALSE;
    BOOL fAECDisabled = FALSE;

    LOG((RTC_TRACE, "CTuningWizard::UpdateAEC: Entered"));

    // See if AEC is enabled for capture

    hr = GetItemFromCombo(hwndCapture, &dwCapture);
    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "CTuningWizard::UpdateAEC: Failed in getting "
                        "selected item from Combo(capture)."));
        return hr;
    }
   
    if (dwCapture == TW_INVALID_TERMINAL_INDEX)
    {
        fAECDisabled = TRUE;
    }
    else
    {
        pCapture = m_ppTerminalList[dwCapture];
    }

    // See if AEC is enabled for render

    hr = GetItemFromCombo(hwndRender, &dwRender);
    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "CTuningWizard::UpdateAEC: Failed in getting "
                        "selected item from Combo(render)."));
        LOG((RTC_ERROR, "CTuningWizard::UpdateAEC: AEC unchanged."));
        return hr;
    }
    
    if (dwRender == TW_INVALID_TERMINAL_INDEX)
    {
        fAECDisabled = TRUE;
    }
    else
    {
        pRender = m_ppTerminalList[dwRender];
    }

    // see if AEC is enabled
    if (pCapture != NULL && pRender != NULL)
    {
        hr = m_pRTCTuningManager->IsAECEnabled(pCapture, pRender, &fAECCapture);

        if ( FAILED( hr ) )
        {
            LOG((RTC_ERROR, "CTuningWizard::UpdateAEC: Failed in method "
                            "AECEnabled for capture (0x%x) render (0x%x).",
                            pCapture, pRender));
            return hr;
        }

        fAECRender = fAECCapture;
    }


    // Try out AEC

    if (!fAECDisabled)
    {
        if (m_fTuningInitCalled)
        {
            m_pRTCTuningManager->ShutdownTuning();

            m_fTuningInitCalled = FALSE;
        }

        hr = m_pRTCTuningManager->InitializeTuning(
                                        pCapture,
                                        pRender,
                                        TRUE);

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CTuningWizard::UpdateAEC - "
                                "InitializeTuning failed 0x%lx", hr));

            fAECDisabled = TRUE;
        }
        else
        {
            m_fTuningInitCalled = TRUE;

            hr = m_pRTCTuningManager->StartTuning( RTC_MD_CAPTURE );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CTuningWizard::UpdateAEC - "
                                    "StartTuning(Capture) failed 0x%lx", hr));

                fAECDisabled = TRUE;
            }
            else
            {
                m_pRTCTuningManager->StopTuning( FALSE );
            }

            m_pRTCTuningManager->ShutdownTuning();

            m_fTuningInitCalled = FALSE;
        }
    }

    // Enable the checkbox if appropriate
    if ( fAECDisabled )
    {
        EnableWindow( hwndAEC, FALSE );

        PWSTR szAECText;

        szAECText = RtcAllocString( _Module.GetResourceInstance(), IDS_AEC_NOT_DETECT );

        if ( szAECText != NULL )
        {
            SetWindowTextW( hwndAECText, szAECText );

            RtcFree( szAECText );
        }
    }
    else
    {
        EnableWindow( hwndAEC, TRUE );

        PWSTR szAECText;

        szAECText = RtcAllocString( _Module.GetResourceInstance(), IDS_AEC_DETECT );

        if ( szAECText != NULL )
        {
            SetWindowTextW( hwndAECText, szAECText );

            RtcFree( szAECText );
        }
    }
    

    if (fAECCapture && fAECRender && !fAECDisabled)
    {
        // Uncheck the check-box.
        SendMessage(
                hwndAEC,
                BM_SETCHECK,
                (WPARAM)BST_UNCHECKED,
                0L);
        LOG((RTC_TRACE, "CTuningWizard::UpdateAEC: AEC enabled."));
        return S_OK;
    }
    else
    {
        // Check the check-box.
        SendMessage(
                hwndAEC,
                BM_SETCHECK,
                (WPARAM)BST_CHECKED,
                0L);
        LOG((RTC_TRACE, "CTuningWizard::UpdateAEC: AEC disabled."));
        return S_OK;
    }
    
    return 0;
}


//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

HRESULT CTuningWizard::SaveAEC(HWND hwnd)
{
    DWORD dwCheckStatus;

    dwCheckStatus = (DWORD)SendMessage(
                            hwnd,
                            BM_GETCHECK,
                            0,
                            0L);

    if (dwCheckStatus == BST_CHECKED)
    {
        m_fEnableAEC = FALSE;
    }
    else
    {
        m_fEnableAEC = TRUE;
    }
    return 0;
}

//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//
HRESULT CTuningWizard::GetItemFromCombo( HWND hwnd, DWORD *pdwItem )
{
    DWORD dwIndex;
    DWORD dwItemData;

    
    // We get the id that is associated with the current selection.
    
    dwIndex = (DWORD)SendMessage(
            hwnd,
            CB_GETCURSEL,
            0,
            0L
            );
    if (dwIndex == CB_ERR)
    {
        // Nothing selected currently
        LOG((RTC_TRACE, "CTuningWizard::GetItemFromCombo: No current "
                        "selection"));
        return E_FAIL;
    }

    dwItemData = (DWORD)SendMessage(
            hwnd,
            CB_GETITEMDATA,
            dwIndex,
            0L
            );

    // We got it, so return the correct value. 
    *pdwItem = dwItemData;

    return S_OK;

}

//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

HRESULT CTuningWizard::SetDefaultTerminal(TW_TERMINAL_TYPE md, HWND hwnd )
{
    DWORD dwIndex;
    DWORD dwDefaultTerminalId;
    WIZARD_TERMINAL_INFO * pwtiTerminalInfo;
    HRESULT hr;


    LOG((RTC_TRACE, "CTuningWizard::SetDefaultTerminal: Entered(md=%d)",
                    md));


    hr = GetItemFromCombo(hwnd, &dwDefaultTerminalId);
    if ( FAILED( hr ) ) 
    {
        LOG((RTC_ERROR, "CTuningWizard::SetDefaultTerminal: Failed in getting "
                        "selected item from Combo."));
        return hr;
    }

    // We got the index in the m_ppTerminalList array to point to the 
    // correct interface pointer. 

    hr = GetTerminalInfoFromType(md, &pwtiTerminalInfo);
    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "CTuningWizard::SetDefaultTerminal: Failed in getting "
                        "terminal info from type(%d), error=0x%x", md, hr));
        return hr;
    }

    pwtiTerminalInfo->dwTuningDefaultTerminal = dwDefaultTerminalId;

    // Everything OK, exit now.

    LOG((RTC_TRACE, "CTuningWizard::SetDefaultTerminal: Exited"));

    return 0;
}



//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

HRESULT CTuningWizard::InitVolume(TW_TERMINAL_TYPE md,
                                  UINT * puiIncrement,
                                  UINT * puiOldVolume,
                                  UINT * puiNewVolume,
                                  UINT * puiWaveID
                                  )
{
    HRESULT hr;
    RTC_MEDIA_DIRECTION mediaDirection;
    WIZARD_TERMINAL_INFO * pwtiTerminalInfo;
    UINT uiVolume;
    WIZARD_RANGE * pwrRange;

    LOG((RTC_TRACE, "CTuningWizard::InitVolume: Entered"));

    hr = GetTerminalInfoFromType(md, &pwtiTerminalInfo);
    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "CTuningWizard::InitVolume: Failed in getting "
                        "terminal info from type(%d), error=0x%x", md, hr));
        return hr;
    }

    mediaDirection = pwtiTerminalInfo->mediaDirection;
    
    hr = GetRangeFromType(md, &pwrRange);
    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "CTuningWizard::InitVolume: Failed in getting "
                        "Range from type(%d), error=0x%x", md, hr));
        return hr;
    }

    *puiIncrement = pwrRange->uiIncrement;

    // Get the old volume
    hr = m_pRTCTuningManager->GetVolume(
                            mediaDirection, 
                            puiOldVolume
                            );

    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "CTuningWizard::InitVolume: Failed in getting "
                        "volume(mt=%d, md=%d), error=0x%x", 
                        mediaDirection, pwtiTerminalInfo->mediaType, hr));          
        return hr;
    }

    *puiNewVolume = *puiOldVolume;

    // Get the system volume
    if ( pwtiTerminalInfo->dwTuningDefaultTerminal != TW_INVALID_TERMINAL_INDEX )
    {
        IRTCTerminal * pTerminal = NULL;

        pTerminal = m_ppTerminalList[pwtiTerminalInfo->dwTuningDefaultTerminal];

        hr = m_pRTCTuningManager->GetSystemVolume(pTerminal, puiNewVolume);

        if ( FAILED( hr ) )
        {
            LOG((RTC_ERROR, "CTuningWizard::InitVolume: Failed in getting "
                            "system volume(mt=%d, md=%d), error=0x%x", 
                            mediaDirection, pwtiTerminalInfo->mediaType, hr));          
            return hr;
        }

        hr = m_pRTCTuningManager->SetVolume(
                                mediaDirection,
                                *puiNewVolume
                                );

        if ( FAILED( hr ) )
        {
            LOG((RTC_ERROR, "CTuningWizard::InitVolume: Failed in setting "
                            "volume(mt=%d, md=%d), error=0x%x", 
                            mediaDirection, pwtiTerminalInfo->mediaType, hr));          
            return hr;
        }

        IRTCAudioConfigure * pAudConf;

        hr = pTerminal->QueryInterface( IID_IRTCAudioConfigure, (void**)&pAudConf );
        
        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CTuningWizard::InitVolume: Failed in QI "
                            "for audio configure(mt=%d, md=%d), error=0x%x", 
                            mediaDirection, pwtiTerminalInfo->mediaType, hr));          
            return hr;
        }

        hr = pAudConf->GetWaveID( puiWaveID );

        pAudConf->Release();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CTuningWizard::InitVolume: Failed in getting"
                            "wave id(mt=%d, md=%d), error=0x%x", 
                            mediaDirection, pwtiTerminalInfo->mediaType, hr));          
            return hr;
        }
    }

    LOG((RTC_TRACE, "CTuningWizard::InitVolume: Exited"));

    return S_OK;
}

//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

HRESULT CTuningWizard::GetSysVolume(TW_TERMINAL_TYPE md,                                  
                                    UINT * puiSysVolume
                                   )
{
    HRESULT hr;
    RTC_MEDIA_DIRECTION mediaDirection;
    WIZARD_TERMINAL_INFO * pwtiTerminalInfo;
    UINT uiVolume;
    WIZARD_RANGE * pwrRange;

    LOG((RTC_TRACE, "CTuningWizard::GetSysVolume: Entered"));

    hr = GetTerminalInfoFromType(md, &pwtiTerminalInfo);
    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "CTuningWizard::GetSysVolume: Failed in getting "
                        "terminal info from type(%d), error=0x%x", md, hr));
        return hr;
    }

    mediaDirection = pwtiTerminalInfo->mediaDirection;

    // Get the system volume
    if ( pwtiTerminalInfo->dwTuningDefaultTerminal != TW_INVALID_TERMINAL_INDEX )
    {
        IRTCTerminal * pTerminal = NULL;

        pTerminal = m_ppTerminalList[pwtiTerminalInfo->dwTuningDefaultTerminal];

        hr = m_pRTCTuningManager->GetSystemVolume(pTerminal, puiSysVolume);

        if ( FAILED( hr ) )
        {
            LOG((RTC_ERROR, "CTuningWizard::GetSysVolume: Failed in getting "
                            "system volume(mt=%d, md=%d), error=0x%x", 
                            mediaDirection, pwtiTerminalInfo->mediaType, hr));          
            return hr;
        }
    }

    LOG((RTC_TRACE, "CTuningWizard::GetSysVolume: Exited"));

    return S_OK;
}

//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

HRESULT CTuningWizard::SetVolume(TW_TERMINAL_TYPE md, UINT uiVolume )
{

    HRESULT hr;
    WIZARD_TERMINAL_INFO * pwtiTerminalInfo;
    RTC_MEDIA_DIRECTION mediaDirection;

    LOG((RTC_TRACE, "CTuningWizard::SetVolume: Entered"));

    hr = GetTerminalInfoFromType(md, &pwtiTerminalInfo);
    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "CTuningWizard::SetVolume: Failed in getting "
                        "terminal info from type(%d), error=0x%x", md, hr));
        return hr;
    }

    mediaDirection = pwtiTerminalInfo->mediaDirection;
    
    // Set the volume
    hr = m_pRTCTuningManager->SetVolume(
                            mediaDirection, 
                            uiVolume
                            );
    if ( FAILED( hr ) )
    {

        LOG((RTC_ERROR, "CTuningWizard::SetVolume: Failed in setting "
                        "volume(mt=%d, md=%d, volume=%d), error=0x%x", 
                        mediaDirection, pwtiTerminalInfo->mediaType, uiVolume, 
                        hr));
        return hr;
    }

    // Set the volume successfully. 

    LOG((RTC_TRACE, "CTuningWizard::SetVolume: Exited(set %d)", uiVolume));

    return S_OK;
}

//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

UINT CTuningWizard::GetAudioLevel(TW_TERMINAL_TYPE md, UINT * puiIncrement)
{
    HRESULT hr;
    RTC_MEDIA_DIRECTION mediaDirection;
    WIZARD_TERMINAL_INFO * pwtiTerminalInfo;
    UINT uiVolume;
    WIZARD_RANGE * pwrRange;
    UINT           uiAudioLevel;

    //LOG((RTC_TRACE, "CTuningWizard::GetAudioLevel: Entered"));

    hr = GetTerminalInfoFromType(md, &pwtiTerminalInfo);
    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "CTuningWizard::GetAudioLevel: Failed in getting "
                        "terminal info from type(%d), error=0x%x", md, hr));
        return hr;
    }

    mediaDirection = pwtiTerminalInfo->mediaDirection;
    
    hr = GetRangeFromType(md, &pwrRange);
    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "CTuningWizard::GetAudioLevel: Failed in getting "
                        "Range from type(%d), error=0x%x", md, hr));
        return hr;
    }

    *puiIncrement = pwrRange->uiIncrement;

    // Get the volume
    hr = m_pRTCTuningManager->GetAudioLevel(
                            mediaDirection, 
                            &uiAudioLevel
                            );
    if ( FAILED( hr ) )
    {

        LOG((RTC_ERROR, "CTuningWizard::GetAudioLevel: Failed in getting "
                        "Audio Level(mt=%d, md=%d), error=0x%x", 
                        mediaDirection, pwtiTerminalInfo->mediaType, hr));
        
     }

    // Return the current value of the volume, even if we fail. 

    //LOG((RTC_TRACE, "CTuningWizard::GetAudioLevel: Exited(get %d)", uiAudioLevel));

    return uiAudioLevel;
}

//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

HRESULT CTuningWizard::InitializeTuning()
{
    DWORD dwCaptureId;
    DWORD dwRenderId;

    HRESULT hr;


    IRTCTerminal * pCaptureTerminal = NULL;
    IRTCTerminal * pRenderTerminal = NULL;

    LOG((RTC_TRACE, "CTuningWizard::InitializeTuning: Entered."));

    dwCaptureId = m_wtiAudioCaptureTerminals.dwTuningDefaultTerminal;
    
    dwRenderId = m_wtiAudioRenderTerminals.dwTuningDefaultTerminal;

    if (dwCaptureId == TW_INVALID_TERMINAL_INDEX)
    {
        pCaptureTerminal = NULL;
    }
    else
    {
        pCaptureTerminal = m_ppTerminalList[dwCaptureId];
    }

    if (dwRenderId == TW_INVALID_TERMINAL_INDEX)
    {
        pRenderTerminal = NULL;
    }
    else
    {
        pRenderTerminal = m_ppTerminalList[dwRenderId];
    }
    
    if (
        (pCaptureTerminal == NULL) && 
        (pRenderTerminal == NULL)
       )
    {
        // if we don't have any defaults, it is not an error. 
        LOG((RTC_ERROR, "CTuningWizard::InitializeTuning: NULL default "
                        "Terminals specified(capture=0x%x, render=0x%x",
                        pCaptureTerminal, pRenderTerminal));
        return S_OK;
    }

    // If the flag fTuningInitCalled is TRUE, it means we have an outstanding
    // init call without shutdown, so let us shut it down first.


    if (m_fTuningInitCalled)
    {
        m_pRTCTuningManager->ShutdownTuning();

        m_fTuningInitCalled = FALSE;
    }

    // Now call InitializaTuning method on tuning interface.

    hr = m_pRTCTuningManager->InitializeTuning(
                                    pCaptureTerminal,
                                    pRenderTerminal,
                                    m_fEnableAEC);

    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "CTuningWizard::InitializeTuning: failed to initialize "
                        "Tuning on the streaming Interface.(hr=0x%x, capture = "
                        "0x%x, render = 0x%x", 
                        hr, pCaptureTerminal, pRenderTerminal));

    }
    else
    {
        m_fTuningInitCalled = TRUE;
    }


    // Everything done, return EXIT suyccessfully
    LOG((RTC_TRACE, "CTuningWizard::InitializeTuning: Exited."));
    return hr;
}



//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

HRESULT CTuningWizard::ShutdownTuning()
{
    LOG((RTC_TRACE, "CTuningWizard::ShutdownTuning: Entered."));

    if (m_fTuningInitCalled == FALSE)
    {
        LOG((RTC_ERROR, "CTuningWizard::ShutdownTuning: Called without "
                       "corresponding InitCall."));
        return E_FAIL;
    }

    m_pRTCTuningManager->ShutdownTuning();

    m_fTuningInitCalled = FALSE;

    LOG((RTC_TRACE, "CTuningWizard::ShutdownTuning: Exited."));

    return S_OK;
}


//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

HRESULT CTuningWizard::StartTuning(TW_TERMINAL_TYPE md )
{
    RTC_MEDIA_DIRECTION mediaDirection;
    HRESULT hr;

    LOG((RTC_TRACE, "CTuningWizard::StartTuning: Entered."));

    if (m_fTuningInitCalled == FALSE)
    {
        LOG((RTC_ERROR, "CTuningWizard::StartTuning: Called without "
                       "InitializeTuning()"));
        return E_FAIL;
    }

    if (md == TW_AUDIO_CAPTURE)
    {
        mediaDirection = RTC_MD_CAPTURE;
    }
    else if (md == TW_AUDIO_RENDER)
    {
        mediaDirection = RTC_MD_RENDER;
    }
    else
    {
        LOG((RTC_ERROR, "CTuningWizard::StartTuning: Invalid Terminal "
                       "type(%d)", md));
        return E_FAIL;
    }

    hr = m_pRTCTuningManager->StartTuning( mediaDirection );

    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "CTuningWizard::StartTuning: failed to Start "
                        "Tuning(hr=0x%x, direction = %d)", hr, mediaDirection));
        return hr;
    }

    LOG((RTC_TRACE, "CTuningWizard::StartTuning: Exited."));

    return S_OK;
}



//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

HRESULT CTuningWizard::StopTuning(TW_TERMINAL_TYPE tt, BOOL fSaveSettings )
{
    HRESULT hr;
    LOG((RTC_TRACE, "CTuningWizard::StopTuning: Entered."));

    if (m_fTuningInitCalled == FALSE)
    {
        LOG((RTC_ERROR, "CTuningWizard::StartTuning: Called without "
                       "InitializeTuning()"));
        return E_FAIL;
    }

    hr = m_pRTCTuningManager->StopTuning( fSaveSettings );

    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "CTuningWizard::StopTuning: failed to Stop "
                        "Tuning(hr=0x%x)", hr));
        return hr;
    }

    LOG((RTC_TRACE, "CTuningWizard::StopTuning: Exited."));

    return S_OK;
}

//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

HRESULT CTuningWizard::StartVideo(HWND hwndParent)
{ 
    LOG((RTC_TRACE, "CTuningWizard::StartVideo: Entered."));

    IRTCTerminal       *pVidRendTerminal = NULL;
    IRTCVideoConfigure *pVideoCfg = NULL;    
    RECT                rcVideo;
    HRESULT             hr;
    BOOL                fResult;

    if ( (m_wtiVideoTerminals.dwTuningDefaultTerminal == TW_INVALID_TERMINAL_INDEX) ||
         (m_ppTerminalList[m_wtiVideoTerminals.dwTuningDefaultTerminal] == NULL) )
    {
        LOG((RTC_ERROR, "CTuningWizard::StartVideo: "
                "no video capture terminal"));

        return E_FAIL;
    }

    //
    // Get the video render terminal
    //

    hr = m_pRTCTerminalManager->GetDefaultTerminal(
            RTC_MT_VIDEO,
            RTC_MD_RENDER,
            &pVidRendTerminal
            );

    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "CTuningWizard::StartVideo: "
                "no video render terminal (hr=0x%x)", hr));

        return hr;
    }

    //
    // Get the IRTCVideoConfigure interface on the video render terminal
    //

    hr = pVidRendTerminal->QueryInterface(
                           IID_IRTCVideoConfigure,
                           (void **)&pVideoCfg
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CTuningWizard::StartVideo: "
                            "QI(VideoConfigure) failed 0x%lx", hr));

        pVidRendTerminal->Release();
        pVidRendTerminal = NULL;

        return hr;
    }

    //
    // Get the IVideoWindow from the video render terminal
    //

    if (m_pVideoWindow != NULL)
    {
        m_pVideoWindow->Release();
        m_pVideoWindow = NULL;
    }

    hr = pVideoCfg->GetIVideoWindow( (LONG_PTR **)&m_pVideoWindow );

    pVideoCfg->Release();
    pVideoCfg = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CTuningWizard::StartVideo: "
                            "GetIVideoWindow failed 0x%lx", hr));

        pVidRendTerminal->Release();
        pVidRendTerminal = NULL;

        return hr;
    }

    if (m_fTuningInitCalled)
    {
        m_pRTCTuningManager->ShutdownTuning();

        m_fTuningInitCalled = FALSE;
    }

    hr = m_pRTCTuningManager->StartVideo(
            m_ppTerminalList[m_wtiVideoTerminals.dwTuningDefaultTerminal],
            pVidRendTerminal
            );

    pVidRendTerminal->Release();
    pVidRendTerminal = NULL;

    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "CTuningWizard::StartVideo: failed to Start "
                        "Video(hr=0x%x)", hr));
               
        m_pVideoWindow->Release();
        m_pVideoWindow = NULL;

        return hr;
    } 

    //
    // Position the IVideoWindow
    //

    hr = m_pVideoWindow->put_Owner( (OAHWND)hwndParent );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CTuningWizard::StartVideo: "
                            "put_Owner failed 0x%lx", hr));

        StopVideo();

        return hr;
    }

    hr = m_pVideoWindow->put_WindowStyle( WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CTuningWizard::StartVideo: "
                            "put_WindowStyle failed 0x%lx", hr));

        StopVideo();

        return hr;
    }
     
    fResult = GetClientRect( hwndParent, &rcVideo );

    if ( !fResult )
    {
        LOG((RTC_ERROR, "CTuningWizard::StartVideo: "
            "GetClientRect failed %d", ::GetLastError()));

        StopVideo();

        return HRESULT_FROM_WIN32(::GetLastError());
    }

    hr = m_pVideoWindow->SetWindowPosition(rcVideo.left, rcVideo.top, rcVideo.right-rcVideo.left, rcVideo.bottom-rcVideo.top);

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CTuningWizard::StartVideo: "
                            "SetWindowPosition failed 0x%lx", hr));

        StopVideo();

        return hr;
    }

    hr = m_pVideoWindow->put_Visible( OATRUE );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CTuningWizard::StartVideo: "
                            "put_Visible failed 0x%lx", hr));

        StopVideo();

        return hr;
    }

    LOG((RTC_TRACE, "CTuningWizard::StartVideo: Exited."));

    return S_OK;
}

//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

HRESULT CTuningWizard::StopVideo()
{
    HRESULT hr;
    LOG((RTC_TRACE, "CTuningWizard::StopVideo: Entered."));

    if (m_pVideoWindow != NULL)
    {
        hr = m_pVideoWindow->put_Visible( OAFALSE );

        if ( FAILED( hr ) )
        {
            LOG((RTC_ERROR, "CTuningWizard::StopVideo: "
                                "put_Visible failed 0x%lx", hr));
        } 

        hr = m_pVideoWindow->put_Owner( (OAHWND)NULL );

        if ( FAILED( hr ) )
        {
            LOG((RTC_ERROR, "CTuningWizard::StopVideo: "
                                "put_Owner failed 0x%lx", hr));
        }
    
        m_pVideoWindow->Release();
        m_pVideoWindow = NULL;
    }

    hr = m_pRTCTuningManager->StopVideo();

    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "CTuningWizard::StopVideo: failed to Stop "
                        "Video(hr=0x%x)", hr));
        return hr;
    } 

    LOG((RTC_TRACE, "CTuningWizard::StopVideo: Exited."));

    return S_OK;
}

//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

HRESULT CTuningWizard::SaveChanges()
{

    IRTCTerminal * pTerminal;
    RTC_MEDIA_TYPE mediaType;
    RTC_MEDIA_DIRECTION mediaDirection;
    HRESULT hr;
    TW_TERMINAL_TYPE tt;
    WIZARD_TERMINAL_INFO * pwtiTerminalInfo;
    LONG lMediaTypes = 0;
    
    // User clicked Finish button on wizard. So we save all the local changes
    // to the registry. This is done by calling set on streaming interfaces.


    LOG((RTC_TRACE, "CTuningWizard::SaveChanges: Entered"));

    // Get the currently configured values for media types.
    hr = m_pRTCClient->get_PreferredMediaTypes(&lMediaTypes);
    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "CTuningWizard::SaveChanges: Failed in "
                        "get_PreferredMediaTypes(error=0x%x)", hr));
    }
    else
    {
        LOG((RTC_INFO, "CTuningWizard::SaveChanges: MediaType=0x%x", 
                        lMediaTypes));
    }



    // Set default terminals of each type by iterating over the 
    // TW_TERMINAL_TYPE enum.

    for ( tt = TW_AUDIO_CAPTURE; 
          tt < TW_LAST_TERMINAL; 
          tt = (TW_TERMINAL_TYPE)(tt + 1))
    {

        hr = GetTerminalInfoFromType(tt, &pwtiTerminalInfo);
        
        if ( FAILED( hr ) )
        {
            LOG((RTC_ERROR, "CTuningWizard::SaveChanges: Failed in getting "
                            "terminal info from type(%d), error=0x%x", tt, hr));
            return hr;
        }

        // If user has some selection, save it.

        if (pwtiTerminalInfo->dwTuningDefaultTerminal != 
                TW_INVALID_TERMINAL_INDEX)
        {
            // Now set the media types
            switch (tt) {
            case TW_AUDIO_CAPTURE: 
                lMediaTypes |= RTCMT_AUDIO_SEND;
                break;
            case TW_AUDIO_RENDER:
                lMediaTypes |= RTCMT_AUDIO_RECEIVE;
                break;
            case TW_VIDEO:
                lMediaTypes |= RTCMT_VIDEO_SEND;
                break;
            }
           
            mediaType = pwtiTerminalInfo->mediaType;
            mediaDirection = pwtiTerminalInfo->mediaDirection;

            // Now call the method for setting it.

            pTerminal = m_ppTerminalList[pwtiTerminalInfo->dwTuningDefaultTerminal];

            hr = m_pRTCTerminalManager->SetDefaultStaticTerminal(
                                                mediaType,
                                                mediaDirection,
                                                pTerminal);

            if ( FAILED( hr ) )
            {
                LOG((RTC_ERROR, "CTuningWizard::SaveChanges: Failed to set 0x%x as the "
                                "default terminal for media=%d, direction=%d, hr=0x%x",
                                pTerminal, mediaType, mediaDirection, hr));
                return hr;
            }
            else
            {
                LOG((RTC_TRACE, "CTuningWizard::SaveChanges: Set 0x%x as the "
                                "default terminal for media=%d, direction=%d", 
                                pTerminal, mediaType, mediaDirection));
            }
        }
        else
        {
            // Now set the media types
            switch (tt) {
            case TW_AUDIO_CAPTURE: 
                lMediaTypes &= ~RTCMT_AUDIO_SEND;
                mediaType = RTC_MT_AUDIO;
                mediaDirection = RTC_MD_CAPTURE;
                break;

            case TW_AUDIO_RENDER:
                lMediaTypes &= ~RTCMT_AUDIO_RECEIVE;
                mediaType = RTC_MT_AUDIO;
                mediaDirection = RTC_MD_RENDER;
                break;

            case TW_VIDEO:
                lMediaTypes &= ~RTCMT_VIDEO_SEND;
                mediaType = RTC_MT_VIDEO;
                mediaDirection = RTC_MD_CAPTURE;
                break;
            }

            // Now call the method for setting it.

            hr = m_pRTCTerminalManager->SetDefaultStaticTerminal(
                                                mediaType,
                                                mediaDirection,
                                                NULL);

            if ( FAILED( hr ) )
            {
                LOG((RTC_ERROR, "CTuningWizard::SaveChanges: Failed to set NULL as the "
                                "default terminal for media=%d, direction=%d, hr=0x%x",
                                mediaType, mediaDirection, hr));
                return hr;
            }
            else
            {
                LOG((RTC_TRACE, "CTuningWizard::SaveChanges: Set NULL as the "
                                "default terminal for media=%d, direction=%d", 
                                mediaType, mediaDirection));
            }            
        }
    }


    // Now save the media types in the registry.
    hr = m_pRTCClient->SetPreferredMediaTypes(lMediaTypes, TRUE);
    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "CTuningWizard::SaveChanges: Failed in "
                        "SetPreferredMediaTypes(error=0x%x)", hr));
    }
    else
    {
        LOG((RTC_INFO, "CTuningWizard::SaveChanges: Updated MediaType=0x%x", 
                        lMediaTypes));
    }


    // All the settings have been saved.

    LOG((RTC_TRACE, "CTuningWizard::SaveChanges: Exited"));

    
    return hr;
}

//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

HINSTANCE CTuningWizard::GetInstance()
{
    return m_hInst;
}

//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

LONG CTuningWizard::GetErrorTitleId()
{
    LONG lErrorTitle;

    switch(m_lLastErrorCode) {
    case TW_AUDIO_RENDER_TUNING_ERROR:
        lErrorTitle = IDS_ERROR_WIZ_TITLE_AUDIO_RENDERTUNE;
        break;
    case TW_AUDIO_CAPTURE_TUNING_ERROR:
        lErrorTitle = IDS_ERROR_WIZ_TITLE_AUDIO_CAPTURETUNE;
        break;
    case TW_AUDIO_AEC_ERROR:
        lErrorTitle = IDS_ERROR_WIZ_TITLE_AUDIO_AEC;
        break;
    case TW_AUDIO_CAPTURE_NOSOUND:
        lErrorTitle = IDS_ERROR_WIZ_TITLE_AUDIO_CAPTURENOSOUND;
        break;
    case TW_VIDEO_CAPTURE_TUNING_ERROR:
        lErrorTitle = IDS_ERROR_WIZ_TITLE_VIDEO_CAPTURETUNE;
        break;
    case TW_INIT_ERROR:
        lErrorTitle = IDS_ERROR_WIZ_TITLE_INITERROR;
        break;
    default:
        lErrorTitle = IDS_ERROR_WIZ_TITLE_GENERIC;
        break;
    }

    return lErrorTitle;
}


//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

LONG CTuningWizard::GetErrorTextId()
{
    LONG lErrorText;

    switch(m_lLastErrorCode) {
    case TW_AUDIO_RENDER_TUNING_ERROR:
        lErrorText = IDS_ERROR_WIZ_AUDIO_RENDERTUNE;
        break;
    case TW_AUDIO_CAPTURE_TUNING_ERROR:
        lErrorText = IDS_ERROR_WIZ_AUDIO_CAPTURETUNE;
        break;      
    case TW_AUDIO_AEC_ERROR:
        lErrorText = IDS_ERROR_WIZ_AUDIO_AEC;
        break;
    case TW_AUDIO_CAPTURE_NOSOUND:
        lErrorText = IDS_ERROR_WIZ_AUDIO_CAPTURENOSOUND;
        break;
    case TW_VIDEO_CAPTURE_TUNING_ERROR:
        lErrorText = IDS_ERROR_WIZ_VIDEO_CAPTURETUNE;
        break;
    case TW_INIT_ERROR:
        lErrorText = IDS_ERROR_WIZ_INITERROR;
        break;
    default:
        lErrorText = IDS_ERROR_WIZ_GENERIC;
        break;
    }

    return lErrorText;
}

//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

HRESULT CTuningWizard::SetLastError(TW_ERROR_CODE ec)
{
    m_lLastErrorCode = ec;

    LOG((RTC_ERROR, "CTuningWizard::SetLastError: Code=%d", ec));

    return S_OK;
}

//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

HRESULT CTuningWizard::GetLastError(TW_ERROR_CODE *ec)
{
    *ec = (TW_ERROR_CODE)m_lLastErrorCode;
    
    LOG((RTC_ERROR, "CTuningWizard::GetLastError: Code=%d", *ec));
    
    return S_OK;
}

//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

LONG CTuningWizard::GetNextPage(TW_ERROR_CODE errorCode)
{
    LONG    lNextPage = 0;

    LOG((RTC_TRACE, "CTuningWizard::GetNextPage: Entered(page %d)", m_lCurrentPage));
    switch (m_lCurrentPage) {
    case IDD_INTROWIZ:
    {
        if (m_fVideo == TRUE)
        {
            lNextPage = IDD_VIDWIZ0;
        }
        else if (m_fCaptureAudio || m_fRenderAudio)
        {
            lNextPage = IDD_AUDIOCALIBWIZ0;
        }
        else
        {
            lNextPage = IDD_DETSOUNDCARDWIZ;
        }
        break;
    }

    case IDD_VIDWIZ0:
    {
        if ( m_fVideo && 
             (m_wtiVideoTerminals.dwTuningDefaultTerminal != TW_INVALID_TERMINAL_INDEX) )
        {
            lNextPage = IDD_VIDWIZ1;
        }
        else if (m_fCaptureAudio || m_fRenderAudio)
        {
            lNextPage = IDD_AUDIOCALIBWIZ0;
        }
        else
        {
            lNextPage = IDD_DETSOUNDCARDWIZ;
        }
        break;
    }

    case IDD_VIDWIZ1:
    {
        if (errorCode == TW_VIDEO_CAPTURE_TUNING_ERROR)
        {
            lNextPage = IDD_AUDIOCALIBERRWIZ;
        }
        else if (m_fCaptureAudio || m_fRenderAudio)
        {
            lNextPage = IDD_AUDIOCALIBWIZ0;
        }
        else
        {
            lNextPage = IDD_DETSOUNDCARDWIZ;
        }
        break;
    }    

    case IDD_AUDIOCALIBWIZ0:
    {
        lNextPage = IDD_AUDIOCALIBWIZ1;
        break;
    }

    case IDD_AUDIOCALIBWIZ1:
    {
        if (errorCode == TW_INIT_ERROR)
        {
            lNextPage = IDD_AUDIOCALIBERRWIZ;
        }
        else if (errorCode == TW_NO_ERROR)
        {
            if ( m_fRenderAudio && 
                 (m_wtiAudioRenderTerminals.dwTuningDefaultTerminal != TW_INVALID_TERMINAL_INDEX) )
            {
                lNextPage = IDD_AUDIOCALIBWIZ2;
            }
            else if ( m_fCaptureAudio &&
                      (m_wtiAudioCaptureTerminals.dwTuningDefaultTerminal != TW_INVALID_TERMINAL_INDEX) )
            {
                lNextPage = IDD_AUDIOCALIBWIZ3;
            }
            else
            {
                lNextPage = IDD_AUDIOCALIBWIZ4;
            }
        }
        else
        {
            // This is an unhandled error!
            LOG((RTC_ERROR, "CTuningWizard::GetNextPage: Unhandled error"
                            "(%d)", errorCode));
            lNextPage = IDD_AUDIOCALIBERRWIZ;
        }
        
        break;
    }

    case IDD_AUDIOCALIBWIZ2:
    {
        if (errorCode == TW_AUDIO_RENDER_TUNING_ERROR||
            (errorCode == TW_AUDIO_AEC_ERROR)
            )
        {
            lNextPage = IDD_AUDIOCALIBERRWIZ;
        }
        else if (errorCode == TW_NO_ERROR)
        {
            // Check if there are any capture devices or not.
            if ( m_fCaptureAudio &&
                 (m_wtiAudioCaptureTerminals.dwTuningDefaultTerminal != TW_INVALID_TERMINAL_INDEX) )
            {
                lNextPage = IDD_AUDIOCALIBWIZ3;
            }
            else
            {
                // Go directly to the last page
                lNextPage = IDD_AUDIOCALIBWIZ4;
            }

        }
        else
        {
            // This is an unhandled error!
            LOG((RTC_ERROR, "CTuningWizard::GetNextPage: Unhandled error"
                            "(%d)", errorCode));
            lNextPage = IDD_AUDIOCALIBERRWIZ;
        }
        break;
    }

    case IDD_AUDIOCALIBWIZ3:
    {
        if (
            (errorCode == TW_AUDIO_CAPTURE_TUNING_ERROR) || 
            (errorCode == TW_AUDIO_CAPTURE_NOSOUND) ||
            (errorCode == TW_AUDIO_AEC_ERROR)
            )
        {
            lNextPage = IDD_AUDIOCALIBERRWIZ;
        }
        else
        {
            lNextPage = IDD_AUDIOCALIBWIZ4;
        }
        break;
    }

    case IDD_AUDIOCALIBWIZ4:
    {
        lNextPage = 0;
        break;
    }

    case IDD_DETSOUNDCARDWIZ:
    {
        lNextPage = IDD_AUDIOCALIBWIZ4;
        break;
    }

    case IDD_AUDIOCALIBERRWIZ:
    {
        if (errorCode == TW_VIDEO_CAPTURE_TUNING_ERROR)
        {
            if (m_fCaptureAudio || m_fRenderAudio)
            {
                lNextPage = IDD_AUDIOCALIBWIZ0;
            }
            else
            {
                lNextPage = IDD_DETSOUNDCARDWIZ;
            }
        }
        else if ( errorCode == TW_AUDIO_RENDER_TUNING_ERROR )
        {
            if ( m_fCaptureAudio &&
                 (m_wtiAudioCaptureTerminals.dwTuningDefaultTerminal != TW_INVALID_TERMINAL_INDEX) )
            {
                // Next page is try tuning mic.
                lNextPage = IDD_AUDIOCALIBWIZ3;
            }
            else
            {
                // Go to the last page
                lNextPage = IDD_AUDIOCALIBWIZ4;
            }
        }
        else
        {
            lNextPage = IDD_AUDIOCALIBWIZ4;
        }
        break;
    }

    default:
        break;
    
    }


    LOG((RTC_TRACE, "CTuningWizard::GetNextPage: Exited(next=%d)", lNextPage));

    return lNextPage;
}


//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

LONG CTuningWizard::GetPrevPage(TW_ERROR_CODE errorCode)
{
    LONG    lPrevPage = 0;


    LOG((RTC_TRACE, "CTuningWizard::GetPrevPage: Entered(page %d)", m_lCurrentPage));

    switch (m_lCurrentPage) {
    case IDD_INTROWIZ:
    {
        lPrevPage = 0;
        break;
    }

    case IDD_VIDWIZ0:
    {
        lPrevPage = IDD_INTROWIZ;
        break;
    }

    case IDD_VIDWIZ1:
    {
        lPrevPage = IDD_VIDWIZ0;
        break;
    }

    case IDD_AUDIOCALIBWIZ0:
    {       
        if ( m_fVideo )
        {
            if ( (errorCode == TW_NO_ERROR) &&
                 (m_wtiVideoTerminals.dwTuningDefaultTerminal != TW_INVALID_TERMINAL_INDEX) )
            {
                lPrevPage = IDD_VIDWIZ1;
            }
            else
            {
                lPrevPage = IDD_VIDWIZ0;
            }
        }
        else
        {
            lPrevPage = IDD_INTROWIZ;
        }
        break;
    }

    case IDD_AUDIOCALIBWIZ1:
    {
        lPrevPage = IDD_AUDIOCALIBWIZ0;
        break;
    }

    case IDD_AUDIOCALIBWIZ2:
    {
        lPrevPage = IDD_AUDIOCALIBWIZ1;
        break;
    }

    case IDD_AUDIOCALIBWIZ3:
    {
        if ( m_fRenderAudio &&
             (m_wtiAudioRenderTerminals.dwTuningDefaultTerminal != TW_INVALID_TERMINAL_INDEX) )
        {
            lPrevPage = IDD_AUDIOCALIBWIZ2;
        }
        else
        {
            // No render device to go to, go to the enum page
            lPrevPage = IDD_AUDIOCALIBWIZ1;
        }

        break;
    }

    case IDD_AUDIOCALIBWIZ4:
    {
        if (errorCode == TW_NO_ERROR)
        {
            if ( m_fCaptureAudio &&
                 (m_wtiAudioCaptureTerminals.dwTuningDefaultTerminal != TW_INVALID_TERMINAL_INDEX) )
            {
                lPrevPage = IDD_AUDIOCALIBWIZ3;
            }
            else if ( m_fRenderAudio &&
                      (m_wtiAudioRenderTerminals.dwTuningDefaultTerminal != TW_INVALID_TERMINAL_INDEX) )
            {
                lPrevPage = IDD_AUDIOCALIBWIZ2;
            }
            else if ( !m_fRenderAudio && !m_fCaptureAudio )
            {
                // No Audio, show the detection page
                lPrevPage = IDD_DETSOUNDCARDWIZ;
            }
            else
            {
                lPrevPage = IDD_AUDIOCALIBWIZ1;
            }
        }
        else  
        {
            // All the error pages come from the audio devices, so
            // we should go back to device selection page from here.
            lPrevPage = IDD_AUDIOCALIBWIZ1;
        }

        break;
    }

    case IDD_DETSOUNDCARDWIZ:
    {
        if ( m_fVideo && 
             (m_wtiVideoTerminals.dwTuningDefaultTerminal != TW_INVALID_TERMINAL_INDEX) )
        {
            lPrevPage = IDD_VIDWIZ1;
        }
        else if ( m_fVideo )
        {
            lPrevPage = IDD_VIDWIZ0;
        }
        else
        {
            lPrevPage = IDD_INTROWIZ;
        }
        break;
    }

    case IDD_AUDIOCALIBERRWIZ:
    {
        if (m_lLastErrorCode == TW_VIDEO_CAPTURE_TUNING_ERROR)
        {
            lPrevPage = IDD_VIDWIZ0;
        }
        else if (m_lLastErrorCode == TW_AUDIO_CAPTURE_NOSOUND)
        {
            lPrevPage = IDD_AUDIOCALIBWIZ3;
        }
        else
        {
            lPrevPage = IDD_AUDIOCALIBWIZ1;
        }
        break;
    }

    default:
        break;
    
    }

    LOG((RTC_TRACE, "CTuningWizard::GetPrevPage: Exited(prev=%d)", lPrevPage));
    
    return lPrevPage;
}



//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

HRESULT CTuningWizard::SetCurrentPage(LONG lCurrentPage)
{
    m_lCurrentPage = lCurrentPage;
    return S_OK;
}


//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

HRESULT CTuningWizard::CategorizeTerminals()
{
    DWORD i;
    DWORD dwAudioCaptureIndex = 0;
    DWORD dwAudioRenderIndex = 0;
    DWORD dwVideoIndex = 0;
    RTC_MEDIA_TYPE iMediaType;
    RTC_MEDIA_DIRECTION iMediaDirection;
    HRESULT hr;


    LOG((RTC_TRACE, "CTuningWizard::CategorizeTerminals: Entered"));
    
    // We assume that at this point we have m_ppTerminalList populated.

    for (i = 0; i < m_dwTerminalCount; i ++)
    {
        // Get Media type
        hr = m_ppTerminalList[i]->GetMediaType(&iMediaType);
        if (FAILED( hr ) )
        {
            LOG((RTC_ERROR, "CTuningWizard::CategorizeTerminals: Failed to "
                            "get media type(i=%d)", i));
            return hr;
        }

        // Get direction

        hr = m_ppTerminalList[i]->GetDirection(&iMediaDirection);
        if (FAILED( hr ) )
        {
            LOG((RTC_ERROR, "CTuningWizard::CategorizeTerminals: Failed to "
                            "get media type(i=%d)", i));
            return hr;
        }

        // Now put the terminals in the appropriate categories. 
        if (
            (iMediaType == RTC_MT_AUDIO) && (iMediaDirection == RTC_MD_CAPTURE)
           )
        {
            m_wtiAudioCaptureTerminals.pdwTerminals[dwAudioCaptureIndex] = i; 
            dwAudioCaptureIndex ++;
        }

        else if 
        (
         (iMediaType == RTC_MT_AUDIO) && (iMediaDirection == RTC_MD_RENDER)
        )
        {
            m_wtiAudioRenderTerminals.pdwTerminals[dwAudioRenderIndex] = i; 
            dwAudioRenderIndex ++;
        }
    
        else if 
        (
         (iMediaType == RTC_MT_VIDEO) && (iMediaDirection == RTC_MD_CAPTURE)
        )
        {
            m_wtiVideoTerminals.pdwTerminals[dwVideoIndex] = i; 
            dwVideoIndex ++;
        }
        else 
        {
            // Invalid Combination!
            LOG((RTC_ERROR, "CTuningWizard::CategorizeTerminals: No such "
                            "mt/md combo supported(mt=%d, md=%d)", 
                            iMediaType, iMediaDirection));
            return E_FAIL;
        }
    }

    // Now we put endoflist marker at the end of each list.

    m_wtiAudioCaptureTerminals.pdwTerminals[dwAudioCaptureIndex] = 
                    
                    TW_INVALID_TERMINAL_INDEX; 
    

    m_wtiAudioRenderTerminals.pdwTerminals[dwAudioRenderIndex] = 
    
                    TW_INVALID_TERMINAL_INDEX; 
    

    m_wtiVideoTerminals.pdwTerminals[dwVideoIndex] = 
                    
                    TW_INVALID_TERMINAL_INDEX; 

    // See if we have video. We have if there is at least one entry in 
    // m_pdwVideoTerminals array.

    if (dwVideoIndex > 0) 
    {
        m_fVideo = TRUE;
    }
    else
    {
        m_fVideo = FALSE;
    }

    // If either capture or render terminals are there, we mark Audio as being
    // present.

    if (dwAudioCaptureIndex > 0)
    {
        m_fCaptureAudio = TRUE;
    }
    if (dwAudioRenderIndex > 0)
    {
        m_fRenderAudio = TRUE;
    }
    
    LOG((RTC_TRACE, "CTuningWizard::CategorizeTerminals: Exited"));

    return S_OK;
}


//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

HRESULT CTuningWizard::TuningSaveDefaultTerminal(
                        RTC_MEDIA_TYPE mediaType, 
                        RTC_MEDIA_DIRECTION mediaDirection,
                        WIZARD_TERMINAL_INFO * pwtiTerminalInfo
                        )

{
    DWORD dwTerminalId = TW_INVALID_TERMINAL_INDEX;
    DWORD i;
    IRTCTerminal * pTerminal = NULL;
    HRESULT hr;

    LOG((RTC_TRACE, "CTuningWizard::TuningSaveDefaultTerminal: Entered"));

    if (pwtiTerminalInfo == NULL)
    {
        LOG((RTC_ERROR, "CTuningWizard::TuningSaveDefaultTerminal: Called with"
                        "NULL terminalInfo."));
        return E_FAIL;
    }

    // Get the default terminal.
    hr = m_pRTCTerminalManager->GetDefaultTerminal(
                                        mediaType,
                                        mediaDirection,
                                        &pTerminal);

    if ( FAILED( hr ) || (pTerminal == NULL))
    {
        LOG((RTC_WARN, "CTuningWizard::TuningSaveDefaultTerminal: No "
                        "default Terminal configured(media=%d, direction=%d", 
                        mediaType, mediaDirection));
        
        // This is not an error, so we return OK here.
        return S_OK;
    }

    // So we have a default terminal. 


    // Search for the terminal in our list.
    for (i = 0; i < m_dwTerminalCount; i ++)
    {
        if (pTerminal == m_ppTerminalList[i])
        {
            dwTerminalId = i;
        }
    }
    if (dwTerminalId == TW_INVALID_TERMINAL_INDEX)
    {
        LOG((RTC_WARN, "CTuningWizard::TuningSaveDefaultTerminal: No such "
                        "Terminal in the terminal list!"));

        // This is not an error, so continue
    }

    // Set the system default field here. 
    pwtiTerminalInfo->dwSystemDefaultTerminal = dwTerminalId;

    // We also set the Tuning.. variables, since these variable
    // are used during the time wizard is active to show the 
    // current selection and first time it should show the default
    // as read from system.

    pwtiTerminalInfo->dwTuningDefaultTerminal = dwTerminalId;


    LOG((RTC_TRACE, "CTuningWizard::TuningSaveDefaultTerminal: Exited"
                    "(terminal=0x%x, id=%d)", pTerminal, 
                    dwTerminalId ));

    // release interface
    pTerminal->Release();

    return S_OK;
}


//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

HRESULT CTuningWizard::ReleaseTerminals()
{
    DWORD i;

    LOG((RTC_TRACE, "CTuningWizard::ReleaseTerminals: Entered"));
    for (i = 0; i < m_dwTerminalCount; i ++)
    {
        if (m_ppTerminalList[i])
        {
            m_ppTerminalList[i]->Release();
            
            // NULL it so that it is not released again accidentally.
            
            m_ppTerminalList[i] = NULL;
        }
    }

    LOG((RTC_TRACE, "CTuningWizard::ReleaseTerminals: Exited"));
    
    return S_OK;
}


//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

HRESULT RTCTuningWizard(
                        IRTCClient * pRTCClient,
                        HINSTANCE hInst, 
                        HWND hwndParent,
                        IRTCTerminalManage * pRTCTerminalManager,
                        BOOL * pfAudioCapture,
                        BOOL * pfAudioRender,
                        BOOL * pfVideo
                        )
{
    LPPROPSHEETPAGE pAudioPages = NULL;
    UINT            nNumAudioPages = 0;
    UINT            nNumPages = 0;
    LPARAM          lParam = 0;
    CTuningWizard * ptwTuningWizard;
    BOOL            fNeedAudioWizard = TRUE;
    HRESULT         hr = S_OK;
    
    
    LOG((RTC_TRACE, "RTCTuningWizard: Entered"));
    
    // initialize the global variable to hold the instance.
    g_hInst = hInst;

    //We are first time into Tuning wizard, so the AEC will be auto setted
    g_bAutoSetAEC = TRUE;

    // Create the CTuningWizard object to keep track of tuning parameters.
    ptwTuningWizard = (CTuningWizard *) RtcAlloc( sizeof( CTuningWizard ) );

    if (ptwTuningWizard == NULL)
    {
        LOG((RTC_ERROR, "RTCTuningWizard: Failed to allocate CTuningWizard!"));

        return E_OUTOFMEMORY;
    }

    // Initialize the tuning wizard
    hr = ptwTuningWizard->Initialize(pRTCClient, pRTCTerminalManager, hInst);
    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "RTCTuningWizard: Failed to initialize CTuningWizard(0x%x)", hr));

        RtcFree(ptwTuningWizard);

        return hr;
    }

    // Get capabilities
    hr = ptwTuningWizard->GetCapabilities(pfAudioCapture, pfAudioRender, pfVideo);
    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "RTCTuningWizard: Failed to GetCapabilities(0x%x)", hr));

        ptwTuningWizard->Shutdown();
        RtcFree(ptwTuningWizard);

        return hr;
    }

    // Now prepare the pointer to pass to the app-specific data for the
    // property sheets
    lParam = (LPARAM) ptwTuningWizard;

    if (fNeedAudioWizard)
    {
        hr = GetAudioWizardPages(&pAudioPages,
                                 &nNumAudioPages, 
                                 lParam);
        if ( FAILED( hr ) )
        {
            LOG((RTC_ERROR, "RTCTuningWizard: Could not get AudioWiz pages"));
        }
    }

    // Now fill in remaining PROPSHEETHEADER structures:
    PROPSHEETHEADER    psh;
    InitStruct(&psh);
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_WIZARD | PSH_NOAPPLYNOW;
    psh.hInstance = g_hInst;
    psh.hwndParent = hwndParent;
    _ASSERTE(0 == psh.nStartPage);

    // alocate enough space for all pages, we have two video pages and an intro 
    // page, allocate for them too.

    LPPROPSHEETPAGE ppsp = new PROPSHEETPAGE[ nNumAudioPages + 3 ];

    if (NULL != ppsp)
    {
        BOOL fContinue = TRUE;

        // Video Page
        FillInPropertyPage(&ppsp[nNumPages], IDD_INTROWIZ,
               IntroWizDlg, lParam);
        nNumPages++;

        FillInPropertyPage(&ppsp[nNumPages], IDD_VIDWIZ0,
               VidWizDlg0, lParam);
        nNumPages++;
    
        FillInPropertyPage(&ppsp[nNumPages], IDD_VIDWIZ1,
               VidWizDlg1, lParam);
        nNumPages++;

        // Copy Audio pages here
        ::CopyMemory( &(ppsp[nNumPages]),
                      pAudioPages,
                      nNumAudioPages * sizeof(PROPSHEETPAGE) );

        nNumPages += nNumAudioPages;
        
        // release the audio pages
        ReleaseAudioWizardPages(pAudioPages);

// Create the property pages first by using CreatePropertySheetPage,
//        otherwise Fusion/Theming are confused
#if 0
        psh.ppsp = ppsp;

        INT_PTR iRes = PropertySheet(&psh);
#else
        psh.dwFlags &= ~PSH_PROPSHEETPAGE;

        HPROPSHEETPAGE  *phpage = new HPROPSHEETPAGE[ nNumAudioPages + 3 ];
        if(phpage != NULL)
        {
            HPROPSHEETPAGE *phCrt = phpage;
            HPROPSHEETPAGE *phEnd = phCrt + nNumAudioPages + 3;

            LPPROPSHEETPAGE pPage = ppsp;
            
            hr = S_OK;

            for(; phCrt < phEnd; phCrt++, pPage++)
            {
                *phCrt = CreatePropertySheetPage(pPage);
                if(!*phCrt)
                {
                    // destroy everything and exit
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    LOG((RTC_ERROR, "CreatePropertySheetPage error %x", hr));
    
                    for(;phCrt>=phpage; phCrt--)
                    {
                        DestroyPropertySheetPage(*phCrt);
                    }

                    ptwTuningWizard->Shutdown();
                    RtcFree(ptwTuningWizard);
                    delete ppsp;

                    return hr;
                }
            }
        }

        psh.phpage = phpage;
        psh.nPages = nNumPages;

        INT_PTR iRes = PropertySheet(&psh);

        delete phpage;
#endif

        if( iRes <= 0 )
        {        // User hit CANCEL or there was an error

            if(iRes==0)
            {
                hr = S_FALSE;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                LOG((RTC_ERROR, "PropertySheet error %d", hr));
            }

            delete ppsp;
    
            ptwTuningWizard->Shutdown();
            RtcFree(ptwTuningWizard);            

            return hr;
        }
    
        delete ppsp;
    }

    ptwTuningWizard->Shutdown();

    RtcFree(ptwTuningWizard);

    return S_OK;
}



//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

VOID FillInPropertyPage(PROPSHEETPAGE* psp, int idDlg,
    DLGPROC pfnDlgProc, LPARAM lParam, LPCTSTR pszProc)
{
    // Clear and set the size of the PROPSHEETPAGE
    InitStruct(psp);

    _ASSERTE(0 == psp->dwFlags);       // No special flags.
    _ASSERTE(NULL == psp->pszIcon);    // Don't use a special icon in the caption bar.

    psp->hInstance = g_hInst;
    psp->pszTemplate = MAKEINTRESOURCE(idDlg); // The dialog box template to use.
    psp->pfnDlgProc = pfnDlgProc;    // The dialog procedure that handles this page.
    psp->lParam = lParam;            // Special application-specific data.
    psp->pszTitle = pszProc;         // The title for this page.
}



//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

HRESULT GetAudioWizardPages(
                         LPPROPSHEETPAGE *plpPropSheetPages, 
                         LPUINT lpuNumPages, LPARAM lParam)
{
    LPPROPSHEETPAGE psp;
    UINT            uNumPages = 0;

    *plpPropSheetPages = NULL;

    psp = (LPPROPSHEETPAGE) RtcAlloc(MAXNUMPAGES_INAUDIOWIZ * sizeof(PROPSHEETPAGE));
    if (NULL == psp)
      {
        return FALSE;
      }

    FillInPropertyPage(&psp[uNumPages++], IDD_DETSOUNDCARDWIZ,
                        DetSoundCardWiz,lParam);
    FillInPropertyPage(&psp[uNumPages++], IDD_AUDIOCALIBWIZ0,
                        AudioCalibWiz0, lParam);
        FillInPropertyPage(&psp[uNumPages++], IDD_AUDIOCALIBWIZ1,
                            AudioCalibWiz1,lParam);
    
    // For each of the pages that I need, fill in a PROPSHEETPAGE structure.
    FillInPropertyPage(&psp[uNumPages++], IDD_AUDIOCALIBWIZ2,
                        AudioCalibWiz2, lParam);

    FillInPropertyPage(&psp[uNumPages++], IDD_AUDIOCALIBWIZ3,
                        AudioCalibWiz3, lParam);
    
    FillInPropertyPage(&psp[uNumPages++], IDD_AUDIOCALIBWIZ4,
                        AudioCalibWiz4, lParam);
    
    FillInPropertyPage(&psp[uNumPages++], IDD_AUDIOCALIBERRWIZ,
                        AudioCalibErrWiz, lParam);
    
    // The number of pages in this wizard.
    *lpuNumPages = uNumPages;
    *plpPropSheetPages = (LPPROPSHEETPAGE) psp;
    return TRUE;
}



//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
//////////////////////////////////////////////////////////////////////////////////////////////
//

void ReleaseAudioWizardPages(LPPROPSHEETPAGE lpPropSheetPages)
{
    RtcFree(lpPropSheetPages);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\twizard\twizard.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    twizard.h

Abstract:

    Implements tuning wizard class to be used by the prop sheets
    to maintain state. Also holds global constants.


--*/

#ifndef _TWIZARD_H
#define _TWIZARD_H

#include "rtcmedia.h"

#define TID_INTENSITY  100

// Number of prperty sheets in AUDIO wizard.
const DWORD MAXNUMPAGES_INAUDIOWIZ  = 7;

const DWORD MAXSTRINGSIZE           = 300;

const UINT DEFAULT_MAX_VOLUME       = 32768;

const INT MAX_VOLUME_NORMALIZED     = 256;

const DWORD RECTANGLE_WIDTH	        = 10;

const DWORD MODERATE_MAX	        = 1;

const DWORD RECTANGLE_LEADING       = 1;

// this is the percentage of the max audio level
const DWORD CLIPPING_THRESHOLD      = 75;

// this is the percentage of the max audio level

const DWORD SILENCE_THRESHOLD       = 2;

const DWORD DECREMENT_VOLUME        = 0x800;

const DWORD INTENSITY_POLL_INTERVAL = 100;


// Maximum number of terminals that we support since we have to 
// pass a pre-allocated array of terminals.

const MAX_TERMINAL_COUNT            = 20;

// MArks the end of terminal index list.
const TW_INVALID_TERMINAL_INDEX     = -1;
typedef enum TW_TERMINAL_TYPE {
    TW_AUDIO_CAPTURE,
    TW_AUDIO_RENDER,
    TW_VIDEO,
    TW_LAST_TERMINAL
} TW_TERMINAL_TYPE;

typedef enum TW_ERROR_CODE {
    TW_NO_ERROR,
    TW_AUDIO_ERROR,
    TW_AUDIO_RENDER_TUNING_ERROR,
    TW_AUDIO_CAPTURE_TUNING_ERROR,
    TW_AUDIO_CAPTURE_NOSOUND,
    TW_AUDIO_AEC_ERROR,
    TW_VIDEO_CAPTURE_TUNING_ERROR,
    TW_INIT_ERROR,
    TW_LAST_ERROR
} TW_ERROR_CODE;

typedef struct _WIZARD_RANGE {
    UINT uiMin;
    UINT uiMax;
    UINT uiIncrement; // This is the number equivalent to one unit on the display.
} WIZARD_RANGE;


// Some global function declarations

VOID FillInPropertyPage(PROPSHEETPAGE* psp, int idDlg,
    DLGPROC pfnDlgProc, LPARAM lParam=0, LPCTSTR pszProc=NULL);

INT_PTR APIENTRY VidWizDlg0(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

INT_PTR APIENTRY VidWizDlg1(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

HRESULT GetAudioWizardPages(LPPROPSHEETPAGE *plpPropSheetPages, 
                            LPUINT lpuNumPages, 
                            LPARAM lParam);
void ReleaseAudioWizardPages(LPPROPSHEETPAGE lpPropSheetPages);

INT_PTR APIENTRY DetSoundCardWiz( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

INT_PTR APIENTRY AudioCalibWiz0( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

INT_PTR APIENTRY AudioCalibWiz1( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

INT_PTR APIENTRY AudioCalibWiz2( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

INT_PTR APIENTRY AudioCalibWiz3( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

INT_PTR APIENTRY AudioCalibWiz4( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

INT_PTR APIENTRY AudioCalibErrWiz( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

INT_PTR APIENTRY IntroWizDlg(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

typedef struct _WIZARD_TERMINAL_INFO {

    RTC_MEDIA_TYPE          mediaType;

    RTC_MEDIA_DIRECTION     mediaDirection;

    // This is the system default which we read from the system.
    DWORD                   dwSystemDefaultTerminal;
    
    // This is the default as selected by the user. 
    DWORD                   dwTuningDefaultTerminal;

    // List of terminals of this category in the system
    DWORD                   pdwTerminals[MAX_TERMINAL_COUNT];

} WIZARD_TERMINAL_INFO;

// Define the class for holding all the tuning wizard information and methods

class CTuningWizard {
private:
    
    // Handle to the terminal manager so that we can talk to streaming
    IRTCTerminalManage * m_pRTCTerminalManager;


    // Special interface for tuning that will have all the methods we 
    // need for tuning. We keep a pointer handy.

    IRTCTuningManage   * m_pRTCTuningManager;

    
    // List of terminal interfaces, corresponding to the terminals available
    // in the system. We support a fixed number of devices only.
    IRTCTerminal * m_ppTerminalList[MAX_TERMINAL_COUNT]; 

    // Total Number of terminals stored in the m_ppTerminalList.

    DWORD           m_dwTerminalCount;

    // One terminal info structure for each type of terminal.

    // Audo Render Terminals
    WIZARD_TERMINAL_INFO m_wtiAudioRenderTerminals;

    // Audio Capture Terminals
    WIZARD_TERMINAL_INFO m_wtiAudioCaptureTerminals;

    // Video Terminals
    WIZARD_TERMINAL_INFO m_wtiVideoTerminals;

    // Keep track of whether Init has been called. This flag is checked 
    // whenever InitializaTuning is Called. If it is set, Init will first
    // call ShutdownTuning, and then initialize. 
    // Flag is also checked when Tuning wizard is destroyed, if it is set,
    // Shutdown will be called.

    BOOL m_fTuningInitCalled;

    BOOL m_fEnableAEC;

    WIZARD_RANGE m_wrCaptureVolume;

    WIZARD_RANGE m_wrRenderVolume;
    
    WIZARD_RANGE m_wrAudioLevel;
   
    IVideoWindow * m_pVideoWindow;

public:

    CTuningWizard() : m_pRTCTerminalManager(NULL),
                      m_pRTCTuningManager(NULL),
                      m_pVideoWindow(NULL),
                      m_fTuningInitCalled(FALSE)
    {}
    
    // Initialize the class. It will get the terminals and the default 
    // terminals from the streaming module and populate the relevant 
    // member fields. 
    HRESULT Initialize(
                    IRTCClient * pRTCCLient, 
                    IRTCTerminalManage * pRTCTerminalManager, 
                    HINSTANCE hInst);


    HRESULT Shutdown();

    HRESULT InitializeTuning();

    HRESULT SaveAECSetting();

    HRESULT ShutdownTuning();
    
    HRESULT PopulateComboBox(TW_TERMINAL_TYPE md, HWND hwnd );

    HRESULT UpdateAEC(HWND hwndCapture, HWND hwndRender, HWND hwndAEC, HWND hwndAECText  );

    HRESULT SetDefaultTerminal(TW_TERMINAL_TYPE md, HWND hwnd );

    HRESULT SaveAEC(HWND hwnd );

    HRESULT InitVolume(TW_TERMINAL_TYPE md,
                       UINT * puiIncrement,
                       UINT * puiOldVolume,
                       UINT * puiNewVolume,
                       UINT * puiWaveID);

    HRESULT GetSysVolume(TW_TERMINAL_TYPE md, UINT * puiSysVolume );

    HRESULT SetVolume(TW_TERMINAL_TYPE md, UINT uiVolume );

    UINT GetAudioLevel(TW_TERMINAL_TYPE md, UINT * uiIncrement );

    HRESULT StartTuning(TW_TERMINAL_TYPE md );

    HRESULT StopTuning(TW_TERMINAL_TYPE md, BOOL fSaveSettings );

    HRESULT StartVideo(HWND hwndParent);

    HRESULT StopVideo();

    HRESULT SaveChanges();

    HINSTANCE GetInstance();

    LONG GetErrorTitleId();

    LONG GetErrorTextId();

    LONG GetNextPage(TW_ERROR_CODE errorCode = TW_NO_ERROR);

    LONG GetPrevPage(TW_ERROR_CODE errorCode = TW_NO_ERROR);

    HRESULT SetCurrentPage(LONG lPageId);

    HRESULT CategorizeTerminals();

    HRESULT TuningSaveDefaultTerminal(
                        RTC_MEDIA_TYPE mt, 
                        RTC_MEDIA_DIRECTION md, 
                        WIZARD_TERMINAL_INFO * pwtiTerminalInfo);

    HRESULT ReleaseTerminals();
    
    HRESULT InitTerminalInfo(
                       WIZARD_TERMINAL_INFO * pwtiTerminals,
                       RTC_MEDIA_TYPE mt,
                       RTC_MEDIA_DIRECTION md
                       );

    
    HRESULT GetTerminalInfoFromType(
                        TW_TERMINAL_TYPE tt,
                        WIZARD_TERMINAL_INFO ** ppwtiTerminalInfo);


    HRESULT GetRangeFromType(
                        TW_TERMINAL_TYPE tt,
                        WIZARD_RANGE ** ppwrRange);

    HRESULT GetItemFromCombo(
                        HWND hwnd,
                        DWORD *pdwItem);

    HRESULT SetLastError(TW_ERROR_CODE ec);

    HRESULT GetLastError(TW_ERROR_CODE * ec);

    HRESULT CheckMicrophone(HWND hDlg, HWND hwndCapture);

    HRESULT GetCapabilities(BOOL * pfAudioCapture, BOOL * pfAudioRender, BOOL * pfVideo);

private:
    
    // Currently visible page. 
    LONG m_lCurrentPage;


    BOOL m_fCaptureAudio;

    BOOL m_fRenderAudio;

    BOOL m_fVideo;

    HINSTANCE m_hInst;

    LONG m_lLastErrorCode;

    // For capture device
    BOOL m_fSoundDetected;

    IRTCClient * m_pRTCClient;


};
#endif    //#ifndef _TWIZARD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\util\button.cpp ===
#include "stdafx.h"
#include "button.h"
#include "rtcdib.h"



CButton *   CButton::s_pButtonFocus = NULL;
CButton *   CButton::s_pButtonMouse = NULL;
BOOL        CButton::s_bAllowFocus = TRUE;


/////////////////////////////////////////////////////////////////////////////
//
//
CButton::CButton()
{
    // LOG((RTC_TRACE, "CButton::CButton"));

    m_hNormalBitmap = NULL;
    m_hPressedBitmap = NULL;
    m_hDisabledBitmap = NULL;
    m_hHotBitmap = NULL;
    m_hActiveNormalBitmap = NULL;
    m_hActivePressedBitmap = NULL;
    m_hActiveDisabledBitmap = NULL;
    m_hActiveHotBitmap = NULL;
    m_hMaskBitmap = NULL;

    m_bIsCheckbox = FALSE;
    m_bMouseInButton = FALSE;
    m_bChecked = FALSE;

    m_nID = 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//
CButton::~CButton()
{
    // LOG((RTC_TRACE, "CButton::~CButton"));

    if (m_hNormalBitmap != NULL)
    {
        GlobalFree(m_hNormalBitmap);
    }

    if (m_hPressedBitmap != NULL)
    {
        GlobalFree(m_hPressedBitmap);
    }

    if (m_hDisabledBitmap != NULL)
    {
        GlobalFree(m_hDisabledBitmap);
    }

    if (m_hHotBitmap != NULL)
    {
        GlobalFree(m_hHotBitmap);
    }
    
    if (m_hActiveNormalBitmap != NULL)
    {
        GlobalFree(m_hActiveNormalBitmap);
    }

    if (m_hActivePressedBitmap != NULL)
    {
        GlobalFree(m_hActivePressedBitmap);
    }

    if (m_hActiveDisabledBitmap != NULL)
    {
        GlobalFree(m_hActiveDisabledBitmap);
    }

    if (m_hActiveHotBitmap != NULL)
    {
        GlobalFree(m_hActiveHotBitmap);
    }

    if (m_hMaskBitmap != NULL)
    {
        DeleteObject(m_hMaskBitmap);
    }
}

/////////////////////////////////////////////////////////////////////////////
//
//
HWND CButton::Create(
    HWND hWndParent,
    RECT &rc,
    LPCTSTR szText,
    DWORD dwStyle,
    LPCTSTR szNormalBitmap,
    LPCTSTR szPressedBitmap,
    LPCTSTR szDisabledBitmap,
    LPCTSTR szHotBitmap,
    LPCTSTR szMaskBitmap,
    UINT nID
    )
{
    return Create(
        hWndParent,
        rc,
        szText,
        dwStyle,
        szNormalBitmap,
        szPressedBitmap,
        szDisabledBitmap,
        szHotBitmap,
        NULL,
        NULL,
        NULL,
        NULL,
        szMaskBitmap,
        nID
        );
}

HWND CButton::Create(
    HWND hWndParent,
    RECT &rc,
    LPCTSTR szText,
    DWORD dwStyle,
    LPCTSTR szNormalBitmap,
    LPCTSTR szPressedBitmap,
    LPCTSTR szDisabledBitmap,
    LPCTSTR szHotBitmap,
    LPCTSTR szActiveNormalBitmap,
    LPCTSTR szActivePressedBitmap,
    LPCTSTR szActiveDisabledBitmap,
    LPCTSTR szActiveHotBitmap,
    LPCTSTR szMaskBitmap,
    UINT nID
    )
{
    // LOG((RTC_TRACE, "CButton::Create"));

    //
    if(szActiveNormalBitmap ||
       szActivePressedBitmap ||
       szActiveDisabledBitmap ||
       szActiveHotBitmap)
    {
        m_bIsCheckbox = TRUE;
    }

    //
    // Load the bitmaps
    //

    HBITMAP hbmpTemp;

    if (szNormalBitmap != NULL)
    {
        hbmpTemp = (HBITMAP)LoadImage( _Module.GetResourceInstance(), szNormalBitmap,
            IMAGE_BITMAP, rc.right-rc.left, rc.bottom-rc.top, LR_CREATEDIBSECTION );

        if(hbmpTemp)
        {
            m_hNormalBitmap = DibFromBitmap((HBITMAP)hbmpTemp,0,0,NULL,0);

            DeleteObject(hbmpTemp);
        }
    }

    if (szPressedBitmap != NULL)
    {
        hbmpTemp = (HBITMAP)LoadImage( _Module.GetResourceInstance(), szPressedBitmap,
            IMAGE_BITMAP, rc.right-rc.left, rc.bottom-rc.top, LR_CREATEDIBSECTION );

        if(hbmpTemp)
        {
            m_hPressedBitmap = DibFromBitmap((HBITMAP)hbmpTemp,0,0,NULL,0);

            DeleteObject(hbmpTemp);
        }
    }

    if (szDisabledBitmap != NULL)
    {
        hbmpTemp = (HBITMAP)LoadImage( _Module.GetResourceInstance(), szDisabledBitmap,
            IMAGE_BITMAP, rc.right-rc.left, rc.bottom-rc.top, LR_CREATEDIBSECTION );

        if(hbmpTemp)
        {
            m_hDisabledBitmap = DibFromBitmap((HBITMAP)hbmpTemp,0,0,NULL,0);

            DeleteObject(hbmpTemp);
        }
    }

    if (szHotBitmap != NULL)
    {
        hbmpTemp = (HBITMAP)LoadImage( _Module.GetResourceInstance(), szHotBitmap,
            IMAGE_BITMAP, rc.right-rc.left, rc.bottom-rc.top, LR_CREATEDIBSECTION );

        if(hbmpTemp)
        {
            m_hHotBitmap = DibFromBitmap((HBITMAP)hbmpTemp,0,0,NULL,0);

            DeleteObject(hbmpTemp);
        }
    }
    
    if (szActiveNormalBitmap != NULL)
    {
        hbmpTemp = (HBITMAP)LoadImage( _Module.GetResourceInstance(), szActiveNormalBitmap,
            IMAGE_BITMAP, rc.right-rc.left, rc.bottom-rc.top, LR_CREATEDIBSECTION );

        if(hbmpTemp)
        {
            m_hActiveNormalBitmap = DibFromBitmap((HBITMAP)hbmpTemp,0,0,NULL,0);

            DeleteObject(hbmpTemp);
        }
    }

    if (szActivePressedBitmap != NULL)
    {
        hbmpTemp = (HBITMAP)LoadImage( _Module.GetResourceInstance(), szActivePressedBitmap,
            IMAGE_BITMAP, rc.right-rc.left, rc.bottom-rc.top, LR_CREATEDIBSECTION );

        if(hbmpTemp)
        {
            m_hActivePressedBitmap = DibFromBitmap((HBITMAP)hbmpTemp,0,0,NULL,0);

            DeleteObject(hbmpTemp);
        }
    }

    if (szActiveDisabledBitmap != NULL)
    {
        hbmpTemp = (HBITMAP)LoadImage( _Module.GetResourceInstance(), szActiveDisabledBitmap,
            IMAGE_BITMAP, rc.right-rc.left, rc.bottom-rc.top, LR_CREATEDIBSECTION );

        if(hbmpTemp)
        {
            m_hActiveDisabledBitmap = DibFromBitmap((HBITMAP)hbmpTemp,0,0,NULL,0);

            DeleteObject(hbmpTemp);
        }
    }

    if (szActiveHotBitmap != NULL)
    {
        hbmpTemp = (HBITMAP)LoadImage( _Module.GetResourceInstance(), szActiveHotBitmap,
            IMAGE_BITMAP, rc.right-rc.left, rc.bottom-rc.top, LR_CREATEDIBSECTION );

        if(hbmpTemp)
        {
            m_hActiveHotBitmap = DibFromBitmap((HBITMAP)hbmpTemp,0,0,NULL,0);

            DeleteObject(hbmpTemp);
        }
    }


    if (szMaskBitmap != NULL)
    {
        m_hMaskBitmap = (HBITMAP)LoadImage( _Module.GetResourceInstance(), szMaskBitmap,
            IMAGE_BITMAP, rc.right-rc.left, rc.bottom-rc.top, LR_MONOCHROME );
    }

    m_nID = nID;

    //
    // Create the window
    //

    CWindow::Create(_T("BUTTON"), hWndParent, rc, szText,
        dwStyle | WS_CHILD | WS_VISIBLE | BS_OWNERDRAW, WS_EX_TRANSPARENT, nID);

    //
    // Store a pointer to this instance of CButton in the window 
    //  (m_hWnd should be valid now)

    if(m_hWnd)
    {
        ::SetWindowLongPtr(m_hWnd, GWLP_USERDATA, (LONG_PTR)this);

        // subclass the window
        SubclassWindow(m_hWnd);
    }

    return m_hWnd;
}

/////////////////////////////////////////////////////////////////////////////
//
//
void CButton::BMaskBlt(HDC hdcDest, int x, int y, int width, int height, 
                        HDC hdcSource, int xs, int ys, 
                        HBITMAP hMask, int xm, int ym)
{
    HDC hdcMask = CreateCompatibleDC(hdcDest);
    if(hdcMask)
    {
        HBITMAP holdbmp = (HBITMAP)SelectObject(hdcMask,hMask);

        BitBlt(hdcDest, x, y, width, height, hdcSource, xs, ys, SRCINVERT);
        BitBlt(hdcDest, x, y, width, height, hdcMask, xm, ym, SRCAND);
        BitBlt(hdcDest, x, y, width, height, hdcSource, xs, ys, SRCINVERT);

        SelectObject(hdcMask,holdbmp);
        DeleteDC(hdcMask);
    }
}

/////////////////////////////////////////////////////////////////////////////
//
//
void CButton::OnDrawItem(
    LPDRAWITEMSTRUCT lpDIS,
    HPALETTE hPalette,
    BOOL bBackgroundPalette
    )
{
    CButton * me;

    me = (CButton *)::GetWindowLongPtr(lpDIS->hwndItem, GWLP_USERDATA);

    // LOG((RTC_TRACE, "CButton::OnDrawItem [%p], item state <%x>", me, lpDIS->itemState));

    HANDLE hSelectBitmap = NULL;   

    //
    // Choose the right bitmap
    //    

    if (lpDIS->itemState & ODS_DISABLED)
    {
        hSelectBitmap = me->m_hDisabledBitmap;
    }
    else
    {
        if(me->m_bMouseInButton)
        {
            s_pButtonMouse = me;

            hSelectBitmap = me->m_bChecked ? me->m_hActiveHotBitmap : me->m_hHotBitmap;

            if(s_pButtonFocus != NULL)
            {
                s_bAllowFocus = FALSE;

                if (me != s_pButtonFocus)
                {
                    s_pButtonFocus ->InvalidateRect(NULL,FALSE);
                    s_pButtonFocus-> UpdateWindow();
                }            
            }
        }
        else if (lpDIS->itemState & ODS_FOCUS)
        {
            if (me == s_pButtonFocus)
            {
                if (s_bAllowFocus && me->GetWindowLong(GWL_STYLE) & WS_TABSTOP)
                {
                    hSelectBitmap = me->m_bChecked ? me->m_hActiveHotBitmap : me->m_hHotBitmap;        
                }
            }
            else
            {
                s_pButtonFocus = me;
                
                if (me->GetWindowLong(GWL_STYLE) & WS_TABSTOP)
                {
                    hSelectBitmap = me->m_bChecked ? me->m_hActiveHotBitmap : me->m_hHotBitmap;
                }
               
                s_bAllowFocus = TRUE;
                if ((s_pButtonMouse!=NULL) && (s_pButtonMouse!=me))
                {
                    s_pButtonMouse->m_bMouseInButton = FALSE;

                    s_pButtonFocus ->InvalidateRect(NULL,FALSE);
                    s_pButtonFocus-> UpdateWindow();
                    s_pButtonMouse = NULL;
                } //end if removing mouse highlight
            }            
        }
        else
        {
            if (me == s_pButtonFocus)
            {
                // Button lost keyboard focus
                
                s_pButtonFocus = NULL;
                s_bAllowFocus = TRUE;
            }
        }

        // overrides the above
        if (lpDIS->itemState & ODS_SELECTED)
        {
            hSelectBitmap = me->m_bChecked ? me->m_hActivePressedBitmap : me->m_hPressedBitmap;
        }
    }

    if (hSelectBitmap == NULL)
    {
        //
        // if none of the above (or one of the above has no bitmap)
        // select the normal bitmap 
        //
        if(me->m_bChecked && me->m_hActiveNormalBitmap)
        {
            hSelectBitmap = me->m_hActiveNormalBitmap;
        }
        else
        {
            hSelectBitmap = me->m_hNormalBitmap;
        }
    }

    // LOG((RTC_INFO, "CButton::OnDrawItem bitmap [%p]", hSelectBitmap));

    //
    // Draw the bitmap
    //

    if (hPalette)
    {
        SelectPalette(lpDIS->hDC, hPalette, bBackgroundPalette);
        RealizePalette(lpDIS->hDC);
    }

    if (hSelectBitmap != NULL)
    {
        HDC hdcMem = CreateCompatibleDC( lpDIS->hDC );

        if(hdcMem)
        {

            if (hPalette)
            {
                SelectPalette(hdcMem, hPalette, bBackgroundPalette);
                RealizePalette(hdcMem);
            }

            HBITMAP hBitmap = CreateCompatibleBitmap( lpDIS->hDC,
                                lpDIS->rcItem.right - lpDIS->rcItem.left,
                                lpDIS->rcItem.bottom - lpDIS->rcItem.top);

            if(hBitmap)
            {

                HBITMAP hOldBitmap = (HBITMAP)SelectObject( hdcMem, hBitmap );

                DibBlt(hdcMem, 0, 0, -1, -1, hSelectBitmap, 0, 0, SRCCOPY, 0);

                if (me->m_hMaskBitmap == NULL)
                {
                    BitBlt(lpDIS->hDC, lpDIS->rcItem.left, lpDIS->rcItem.top,
                        lpDIS->rcItem.right - lpDIS->rcItem.left,
                        lpDIS->rcItem.bottom - lpDIS->rcItem.top,
                        hdcMem, 0, 0, SRCCOPY);
                }
                else
                {
                    BMaskBlt(lpDIS->hDC, lpDIS->rcItem.left, lpDIS->rcItem.top,
                        lpDIS->rcItem.right - lpDIS->rcItem.left,
                        lpDIS->rcItem.bottom - lpDIS->rcItem.top,
                        hdcMem, 0, 0,
                        me->m_hMaskBitmap, 0, 0);
                }

                SelectObject( hdcMem, hOldBitmap );
                DeleteObject( hBitmap );
            }

            DeleteDC(hdcMem);
        }
    } 

    //
    // Draw the text
    //

    TCHAR s[MAX_PATH];
    me->GetWindowText(s,MAX_PATH-1);

    SetBkMode(lpDIS->hDC,TRANSPARENT);

    if (lpDIS->itemState & ODS_DISABLED)
    {
        SetTextColor(lpDIS->hDC, RGB(128,128,128));
    }
    else
    {
        SetTextColor(lpDIS->hDC, RGB(0,0,0));
    }

    // create message font
    NONCLIENTMETRICS metrics;
    metrics.cbSize = sizeof(metrics);
    SystemParametersInfo(SPI_GETNONCLIENTMETRICS,sizeof(metrics),&metrics,0);

    HFONT hMessageFont = CreateFontIndirect(&metrics.lfMessageFont);
    HFONT hOrgFont = (HFONT)SelectObject(lpDIS->hDC, hMessageFont);

    // center text
    SIZE size;
    GetTextExtentPoint32(lpDIS->hDC, s, _tcslen(s), &size);

    int iOffY = ((lpDIS->rcItem.bottom - lpDIS->rcItem.top) - size.cy) / 2;
    int iOffX = ((lpDIS->rcItem.right - lpDIS->rcItem.left) - size.cx) / 2;

    if (lpDIS->itemState & ODS_SELECTED)
    {
        iOffY++;
        iOffX++;
    }

    ExtTextOut(lpDIS->hDC, lpDIS->rcItem.left + iOffX, lpDIS->rcItem.top + iOffY, 0, NULL, s, _tcslen(s), NULL );

    SelectObject(lpDIS->hDC,hOrgFont);
    DeleteObject(hMessageFont);
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CButton::OnMouseMove(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (!m_bMouseInButton)
    {
        m_bMouseInButton = TRUE;
         
        TRACKMOUSEEVENT tme;
        
        tme.cbSize = sizeof(tme);
        tme.dwFlags = TME_LEAVE;
        tme.dwHoverTime = HOVER_DEFAULT;
        tme.hwndTrack = m_hWnd;
                    
        TrackMouseEvent(&tme);
        InvalidateRect(NULL,FALSE);
    }

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CButton::OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // Set the button as a default button
    ::SendMessage(GetParent(), DM_SETDEFID, m_nID, 0);
    //
    // this is a must..
    bHandled = FALSE;
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CButton::OnMouseLeave(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    m_bMouseInButton = FALSE;
    InvalidateRect(NULL,FALSE);

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CButton::OnSetCheck(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if(m_bIsCheckbox)
    {
        m_bChecked = (wParam == BST_CHECKED);

        InvalidateRect(NULL,FALSE);
        UpdateWindow();
    }

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CButton::OnGetCheck(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    return m_bIsCheckbox ? 
        ( m_bChecked ? BST_CHECKED : BST_UNCHECKED) : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\twizard\twizhelper.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    twizhelper.cpp

Abstract:

    Implements the dialog procedures for various property sheets.


--*/

#include "stdafx.h"
#include "rtcerr.h"//To get definition of RTC_E_MEDIA_AEC

#define QCIF_CX_SIZE                   176
#define QCIF_CY_SIZE                   144

typedef struct _STATS_INFO {
    UINT dwMin;
    UINT dwMax;
    UINT dwCount;
    float flAverage;
} STATS_INFO;

STATS_INFO g_StatsArray[4];

DWORD g_FrequencyArray[256];

static int g_nCurrentSelection = 0;
// set to true only if the user hit's back or next
static BOOL g_bCurrentValid = FALSE;

// was the user prompted to select a video device
static BOOL g_bPrompted = FALSE;

//whehter we should auto set the AEC checkbox
extern BOOL g_bAutoSetAEC;

void InitStats();
void UpdateStats(UINT uiAudioLevel, DWORD silence, DWORD clipping);
void DisplayStats();
void PaintVUMeter (HWND hwnd, DWORD dwVolume, WIZARD_RANGE * pRange);

//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
// Introductory Page
//////////////////////////////////////////////////////////////////////////////////////////////
//

INT_PTR APIENTRY IntroWizDlg(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    static PROPSHEETPAGE        * ps;
    static CTuningWizard        * ptwTuningWizard;
    LONG                          lNextPage;

    switch (message) 
    {
        case WM_INITDIALOG:
        {

            // Save the PROPSHEETPAGE information.
            ps = (PROPSHEETPAGE *)lParam;

            // Get the tuningwizard pointer for later use
            ptwTuningWizard = (CTuningWizard *)(ps->lParam);
            
            return (TRUE);
        }            

        case(WM_NOTIFY) :
        {
            switch (((NMHDR *)lParam)->code)
            {

                case PSN_WIZNEXT:
                {
                    lNextPage = ptwTuningWizard->GetNextPage();
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, lNextPage);
                    return TRUE;
                }

                case PSN_SETACTIVE:
                {
                    // Initialize the controls.
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
                    ptwTuningWizard->SetCurrentPage(IDD_INTROWIZ);
                    break;
                }

                default:
                    return FALSE;
            }
         
            break;
        }
        default: 
            return FALSE;
    }

    return TRUE;
}

//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
// Video Page
//////////////////////////////////////////////////////////////////////////////////////////////
//

INT_PTR APIENTRY VidWizDlg0(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    static PROPSHEETPAGE        * ps;
    static CTuningWizard        * ptwTuningWizard;

    HWND                          hwndCB;  // handle to the dialog box
    int                           index;
    LONG                          lNextPage;
    LONG                          lPrevPage;
    
    hwndCB = GetDlgItem(hDlg, IDC_VWCOMBO);

    switch (message) 
    {
        case WM_INITDIALOG:
        {

            // Save the PROPSHEETPAGE information.
            ps = (PROPSHEETPAGE *)lParam;

            // Get the tuningwizard pointer for later use
            ptwTuningWizard = (CTuningWizard *)(ps->lParam);

            return TRUE;
        }            

        case WM_NOTIFY:
            switch (((NMHDR *)lParam)->code)
            {
                case PSN_WIZBACK:
                {
                    lPrevPage = ptwTuningWizard->GetPrevPage();
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, lPrevPage);
                    return TRUE;
                }

                case PSN_WIZNEXT:
                {
                    // Set the default video verminal
                    ptwTuningWizard->SetDefaultTerminal(TW_VIDEO, hwndCB);

                    lNextPage = ptwTuningWizard->GetNextPage();
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, lNextPage);
                    
                    return TRUE;
                }

               case PSN_SETACTIVE:
                {
                    // Populate the combo box

                    ptwTuningWizard->SetCurrentPage(IDD_VIDWIZ0);
                    ptwTuningWizard->PopulateComboBox(TW_VIDEO, hwndCB);

                    // Initialize the controls.
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    
                    break;
                }

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
// Video Test Page
//////////////////////////////////////////////////////////////////////////////////////////////
//

INT_PTR APIENTRY VidWizDlg1(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    static PROPSHEETPAGE        * ps;
    static CTuningWizard        * ptwTuningWizard;
    LONG                          lNextPage;
    LONG                          lPrevPage;
    HRESULT                       hr;
    
    switch (message)
    {
        case WM_INITDIALOG:
        {

            // Save the PROPSHEETPAGE information.
            ps = (PROPSHEETPAGE *)lParam;

            // Get the tuningwizard pointer for later use
            ptwTuningWizard = (CTuningWizard *)(ps->lParam);


            return (TRUE);
        }            

        case WM_NOTIFY:
            switch (((NMHDR *)lParam)->code)
            {
                case PSN_WIZBACK:
                {
                    ptwTuningWizard->StopVideo();

                    lPrevPage = ptwTuningWizard->GetPrevPage();
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, lPrevPage);
                    return TRUE;
                }

                case PSN_WIZNEXT:
                {
                    ptwTuningWizard->StopVideo();

                    lNextPage = ptwTuningWizard->GetNextPage();
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, lNextPage);
                    return TRUE;
                }

               case PSN_SETACTIVE:
                {
                    // Populate the combo box
                    ptwTuningWizard->SetCurrentPage(IDD_VIDWIZ1);

                    // get video window handle
                    HWND hwndVideoWindow;
                    hwndVideoWindow = GetDlgItem(hDlg, IDC_VIDEOTUNE);

                    // get video window info
                    WINDOWINFO  wi;    
                    wi.cbSize = sizeof(WINDOWINFO);

                    GetWindowInfo(hwndVideoWindow, &wi);

                    // the window rect is in screen coords, convert in client
                    ::MapWindowPoints( NULL, hDlg, (LPPOINT)&wi.rcWindow, 2 );

                    // compute the bottom/right
                    // use diff between client area and window area
                    wi.rcWindow.bottom += QCIF_CY_SIZE - (wi.rcClient.bottom - wi.rcClient.top);
                    wi.rcWindow.right += QCIF_CX_SIZE - (wi.rcClient.right - wi.rcClient.left);

                    // adjust the size
                    MoveWindow(hwndVideoWindow,
                               wi.rcWindow.left,
                               wi.rcWindow.top,
                               wi.rcWindow.right - wi.rcWindow.left,
                               wi.rcWindow.bottom - wi.rcWindow.top,
                               TRUE);

                    // Start tuning
                    hr = ptwTuningWizard->StartVideo( hwndVideoWindow );

                    if ( FAILED( hr ) )
                    {
                        LOG((RTC_ERROR,"VidWizDlg1: StartVideo "
                            "failed(0x%x), Show Error Page",
                            hr));

                        ptwTuningWizard->SetLastError(
                                    TW_VIDEO_CAPTURE_TUNING_ERROR
                                    );

                        lNextPage = ptwTuningWizard->GetNextPage(TW_VIDEO_CAPTURE_TUNING_ERROR);

                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, lNextPage);

                        return TRUE;
                    }

                    ptwTuningWizard->SetLastError(
                                TW_NO_ERROR
                                );

                    // Initialize the controls.
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    
                    break;
                }

                case PSN_RESET:
                    ptwTuningWizard->StopVideo();
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
// No sound card detected page
//////////////////////////////////////////////////////////////////////////////////////////////
//

INT_PTR APIENTRY DetSoundCardWiz( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    static PROPSHEETPAGE        * ps;
    static CTuningWizard        * ptwTuningWizard;
    LONG                          lNextPage;
    LONG                          lPrevPage;
    
    switch (message)
    {
        case WM_INITDIALOG:
        {

            // Save the PROPSHEETPAGE information.
            ps = (PROPSHEETPAGE *)lParam;

            // Get the tuningwizard pointer for later use
            ptwTuningWizard = (CTuningWizard *)(ps->lParam);

            
            return (TRUE);
        }            

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_WIZBACK:
                {
                    lPrevPage = ptwTuningWizard->GetPrevPage();
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, lPrevPage);
                    return TRUE;
                }

                case PSN_WIZNEXT:
                {
                    lNextPage = ptwTuningWizard->GetNextPage();
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, lNextPage);
                    return TRUE;

                }
                case PSN_SETACTIVE:
                {
                    // Initialize the controls.
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    
                    ptwTuningWizard->SetCurrentPage(IDD_DETSOUNDCARDWIZ);
                    break;
                }
            }
            break;
    }

    return FALSE;
}


//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
// Intro Audio Page
//////////////////////////////////////////////////////////////////////////////////////////////
//

INT_PTR APIENTRY AudioCalibWiz0( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    static PROPSHEETPAGE        * ps;
    static CTuningWizard        * ptwTuningWizard;
    LONG                          lNextPage;
    LONG                          lPrevPage;
    
    switch (message)
    {
        case WM_INITDIALOG:
        {
            // Save the PROPSHEETPAGE information.
            ps = (PROPSHEETPAGE *)lParam;

            // Get the tuningwizard pointer for later use
            ptwTuningWizard = (CTuningWizard *)(ps->lParam);
            
            return (TRUE);
        }            

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code) 
            {
                case PSN_WIZBACK:
                {
                    TW_ERROR_CODE ec;

                    // Prev will be different if we came here through an error.                    
                    ptwTuningWizard->GetLastError(&ec);

                    lPrevPage = ptwTuningWizard->GetPrevPage(ec);

                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, lPrevPage);
                    return TRUE;
                }

                case PSN_WIZNEXT:
                {
                    lNextPage = ptwTuningWizard->GetNextPage();
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, lNextPage);
                    return TRUE;

                }
                case PSN_SETACTIVE:
                {
                    ptwTuningWizard->SetCurrentPage(IDD_AUDIOCALIBWIZ0);

                    // Initialize the controls.
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    
                    break;
                }
            }
            break;
    }

    return FALSE;
}

//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
// Enumerate the devices
//////////////////////////////////////////////////////////////////////////////////////////////
//

INT_PTR APIENTRY AudioCalibWiz1( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    static PROPSHEETPAGE        * ps;
    static CTuningWizard        * ptwTuningWizard;
    HWND                          hwndCB;
    LONG                          lNextPage;
    LONG                          lPrevPage;
    HRESULT                       hr;
    static HWND                   hwndCapture, hwndRender, hwndAEC, hwndAECText; 
    
    switch (message) 
    {
        case WM_INITDIALOG:
        {
            // Save the PROPSHEETPAGE information.
            ps = (PROPSHEETPAGE *)lParam;

            // Get the tuningwizard pointer for later use
            ptwTuningWizard = (CTuningWizard *)(ps->lParam);
          
            return TRUE;
        }            

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_SETACTIVE:
                {
                    ptwTuningWizard->SetCurrentPage(IDD_AUDIOCALIBWIZ1);
                    // Populate the combo box
                    
                    // Mic devices.
                    hwndCapture = GetDlgItem(hDlg, IDC_WAVEIN);
                    ptwTuningWizard->PopulateComboBox(TW_AUDIO_CAPTURE, hwndCapture);

                    // Speaker devices
                    hwndRender = GetDlgItem(hDlg, IDC_WAVEOUT);
                    ptwTuningWizard->PopulateComboBox(TW_AUDIO_RENDER, hwndRender);


                    // Put the value in the AEC checkbox

                    hwndAEC = GetDlgItem(hDlg, IDC_AEC);
                    hwndAECText = GetDlgItem(hDlg, IDC_AEC_TEXT);

                    //Unless when users first come to this page, or they failed in AEC setting,
                    //  we will not update AEC settings
                    if ( g_bAutoSetAEC )
                    {
                        ptwTuningWizard->UpdateAEC(hwndCapture, hwndRender, hwndAEC, hwndAECText);

                        g_bAutoSetAEC = FALSE;
                    }

                    // Initialize the controls.
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    
                    break;
                }

                case PSN_WIZBACK:
                {
                    lPrevPage = ptwTuningWizard->GetPrevPage();
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, lPrevPage);

                    g_bAutoSetAEC = TRUE;

                    return TRUE;
                }

                case PSN_WIZNEXT:
                    // Post the current selection in the combo box as the defaults

                    // Mic devices.
                    ptwTuningWizard->SetDefaultTerminal(TW_AUDIO_CAPTURE, hwndCapture);

                    // Speaker devices
                    ptwTuningWizard->SetDefaultTerminal(TW_AUDIO_RENDER, hwndRender);
                   
                    // Read the AEC checkbox and save it with us.
                    ptwTuningWizard->SaveAEC(hwndAEC);

                    // Check the microphone
                    ptwTuningWizard->CheckMicrophone(hDlg, hwndCapture);

                    // Initialize Tuning now, so that we can call Start and Stop tuning
                    // methods later
                    hr = ptwTuningWizard->InitializeTuning();

                    if ( FAILED( hr ) )
                    {
                        LOG((RTC_ERROR, "AudioCalibWiz1: Failed to Initialize "
                                        "Tuning (hr=0x%x)", hr));

                        ptwTuningWizard->SetLastError(
                                    TW_INIT_ERROR
                                    );

                        lNextPage = ptwTuningWizard->GetNextPage(TW_INIT_ERROR);
                        SetWindowLongPtr(hDlg, 
                                         DWLP_MSGRESULT, 
                                         lNextPage);
                        return TRUE;
                    }

                    ptwTuningWizard->SetLastError(
                                TW_NO_ERROR
                                );

                    lNextPage = ptwTuningWizard->GetNextPage();
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, lNextPage);

                    return TRUE;
            }
            break;

            case WM_COMMAND:
            {
                switch( HIWORD( wParam ) )
                {
                    case CBN_SELCHANGE:
                    {
                        // Read the entries from both the combobox, then 
                        // see if AEC is enabled on them.
                        ptwTuningWizard->UpdateAEC(hwndCapture, hwndRender, hwndAEC, hwndAECText);
                        break;
                    }
                }
            }
            break;
    }

    return FALSE;
}

//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
// Speaker test page..
//////////////////////////////////////////////////////////////////////////////////////////////
//

INT_PTR APIENTRY AudioCalibWiz2( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    static PROPSHEETPAGE        * ps;
    static CTuningWizard        * ptwTuningWizard;
    static HWND                   hTrackBar;
    DWORD                         dwTBPos;
    static BOOL                   fTuning;
    static HINSTANCE              hInst;
    LONG                          lNextPage;
    LONG                          lPrevPage;
    WCHAR                         szTemp[MAXSTRINGSIZE];
    static UINT                   uiIncrement, uiWaveID;
    static UINT                   uiMinVolume, uiMaxVolume;  
    static UINT                   uiOldVolume, uiNewVolume;
    WIZARD_RANGE                * pRange;
    HRESULT                       hr;
    static HMIXER                 hMixer = NULL;

    switch (message)
    {
        case WM_INITDIALOG:
        {
            // Save the PROPSHEETPAGE information.
            ps = (PROPSHEETPAGE *)lParam;

            // Get the tuningwizard pointer for later use
            ptwTuningWizard = (CTuningWizard *)(ps->lParam);
            

            hInst = ptwTuningWizard->GetInstance();

            // Get the volume bar.
            hTrackBar = GetDlgItem(hDlg, IDC_ATW_SLIDER1);

            fTuning = FALSE;

            return TRUE;
        }            

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_SETACTIVE:
                {
                    ptwTuningWizard->SetCurrentPage(IDD_AUDIOCALIBWIZ2);
        
                    ptwTuningWizard->GetRangeFromType(TW_AUDIO_RENDER, &pRange);


                    // Initialize the trackbar control
                    SendMessage(hTrackBar, TBM_SETRANGE, TRUE, 
                                (LPARAM)MAKELONG(0, MAX_VOLUME_NORMALIZED));
                    SendMessage(hTrackBar, TBM_SETTICFREQ, 32, 0);
                    SendMessage(hTrackBar, TBM_SETPAGESIZE, 0, 32);
                    SendMessage(hTrackBar, TBM_SETLINESIZE, 0, 8);
                    
                    // Get the current volume and show it on the bar.
                    hr = ptwTuningWizard->InitVolume( TW_AUDIO_RENDER,  
                                                 &uiIncrement,
                                                 &uiOldVolume,
                                                 &uiNewVolume,
                                                 &uiWaveID
                                               );

                    if ( FAILED(hr) )
                    {
                        return -1;
                    }

                    mixerOpen( &hMixer, uiWaveID, (DWORD)hDlg, 0, MIXER_OBJECTF_WAVEOUT | CALLBACK_WINDOW );

                    SendMessage(hTrackBar, TBM_SETPOS, TRUE, uiNewVolume/uiIncrement);

                    // Change the button label to the correct name, "Test".
                    LoadString(hInst,IDS_TESTBUTTON_TEXT, szTemp, MAXSTRINGSIZE);
                    SetDlgItemText(hDlg, IDC_BUTTON_ATW_TEST, szTemp);

                    fTuning = FALSE;
        
                    // Initialize the controls.
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    
                    break;
                }

                case PSN_RESET:
                    // Stop Tuning
                    if (fTuning)
                    {
                        ptwTuningWizard->StopTuning(TW_AUDIO_RENDER, TRUE);
                        fTuning = FALSE;
                    }

                    if (hMixer != NULL)
                    {
                        mixerClose(hMixer);
                        hMixer = NULL;
                    }

                    // Restore the volume to the old value.
                    ptwTuningWizard->SetVolume(TW_AUDIO_RENDER, uiOldVolume);

                    break;


                case PSN_WIZBACK:
                {
                    if (fTuning)
                    {
                        ptwTuningWizard->StopTuning(TW_AUDIO_RENDER, FALSE);
                        fTuning = FALSE;
                    }

                    if (hMixer != NULL)
                    {
                        mixerClose(hMixer);
                        hMixer = NULL;
                    }

                    lPrevPage = ptwTuningWizard->GetPrevPage();
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, lPrevPage);

                    return TRUE;
                }

                case PSN_WIZNEXT:
                {
                    if (fTuning)
                    {
                        ptwTuningWizard->StopTuning(TW_AUDIO_RENDER, TRUE);
                        fTuning = FALSE;
                    }

                    if (hMixer != NULL)
                    {
                        mixerClose(hMixer);
                        hMixer = NULL;
                    }

                    lNextPage = ptwTuningWizard->GetNextPage();
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, lNextPage);

                    return TRUE;

                }
            }
            break;

        case MM_MIXM_CONTROL_CHANGE: // mixer volume change
        {
            UINT uiSysVolume;
            ptwTuningWizard->GetSysVolume(TW_AUDIO_RENDER, &uiSysVolume );

            if ( uiNewVolume != uiSysVolume )
            {
                uiNewVolume = uiSysVolume;
                SendMessage(hTrackBar, TBM_SETPOS, TRUE, uiNewVolume/uiIncrement);
            }
            break;
        }

        case WM_HSCROLL:  // trackbar notification
        {
            dwTBPos = (DWORD)SendMessage(hTrackBar, TBM_GETPOS, 0, 0);
            uiNewVolume = dwTBPos * uiIncrement;
            ptwTuningWizard->SetVolume(TW_AUDIO_RENDER, uiNewVolume);
            break;
        }

        case WM_COMMAND:
        {
            if (LOWORD(wParam) == IDC_BUTTON_ATW_TEST)
            {
                if (fTuning == FALSE)
                {
                    // User wants to start tuning.. do it now.

                    hr = ptwTuningWizard->StartTuning(TW_AUDIO_RENDER);

                    if ( FAILED( hr ) )
                    {
                        LOG((RTC_ERROR,"AudioCalibWiz2: StartTuning "
                            "failed(0x%x), Show Error Page",
                            hr));

                        TW_ERROR_CODE errCode = TW_AUDIO_RENDER_TUNING_ERROR;

                        if( RTC_E_MEDIA_AEC == hr )
                        {
                            errCode = TW_AUDIO_AEC_ERROR;

                            g_bAutoSetAEC = TRUE;
                        }

                        ptwTuningWizard->SetLastError(errCode);

                        lNextPage = ptwTuningWizard->GetNextPage(errCode);

                        PropSheet_SetCurSelByID(GetParent(hDlg), lNextPage);

                        return TRUE;
                    }

                    ptwTuningWizard->SetLastError(
                                TW_NO_ERROR
                                );

                    LoadString(hInst,IDS_STOPBUTTON_TEXT, szTemp, MAXSTRINGSIZE);
                    SetDlgItemText(hDlg, IDC_BUTTON_ATW_TEST, szTemp);
                    fTuning = TRUE;

                    // Get the current volume as shown on the slider. We will
                    // set this volume on the device. This allows the user to 
                    // change the volume even when we wre not in tuning.

                    dwTBPos = (DWORD)SendMessage(hTrackBar, TBM_GETPOS, 0, 0);
                    uiNewVolume = dwTBPos * uiIncrement;
                                        
                    ptwTuningWizard->SetVolume(TW_AUDIO_RENDER, uiNewVolume);
                }
                else
                {
                    // User want to stop tuning..
                    ptwTuningWizard->StopTuning(TW_AUDIO_RENDER, TRUE);
                    LoadString(hInst,IDS_TESTBUTTON_TEXT, szTemp, MAXSTRINGSIZE);
                    SetDlgItemText(hDlg, IDC_BUTTON_ATW_TEST, szTemp);
                    fTuning = FALSE;
                }

            }
            break;
        }
    }

    return FALSE;
}


//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
// Microphone test page..
//////////////////////////////////////////////////////////////////////////////////////////////
//

INT_PTR APIENTRY AudioCalibWiz3( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    static PROPSHEETPAGE        * ps;
    static HWND                   hTrackBar;
    static HWND                   hProgressBar;
    static CTuningWizard        * ptwTuningWizard;
    DWORD                         dwTBPos;
    LONG                          lNextPage;
    LONG                          lPrevPage;
    static UINT                   uiIncrement, uiWaveID;
    WCHAR                       * szEventName = L"Tuning Wizard Progress Bar Event";
    static UINT                   uiMinVolume, uiMaxVolume;
    static UINT                   uiOldVolume, uiNewVolume;
    static WIZARD_RANGE         * pRange = NULL;
    HRESULT                       hr;
    static BOOL                   fSoundDetected = FALSE;
    static DWORD                  dwClippingThreshold;
    static DWORD                  dwSilenceThreshold;
    static DWORD                  dwSampleCount;
    static HMIXER                 hMixer = NULL;

    switch (message)
    {
        case WM_INITDIALOG:
        {
            // Save the PROPSHEETPAGE information.
            ps = (PROPSHEETPAGE *)lParam;

            // Get the tuningwizard pointer for later use
            ptwTuningWizard = (CTuningWizard *)(ps->lParam);

            hTrackBar = GetDlgItem(hDlg, IDC_ATW_SLIDER2);

            hProgressBar = GetDlgItem(hDlg, IDC_VUMETER);

            return TRUE;
        }            

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_SETACTIVE:
                {
                    // Reset the sound detected flag
                    fSoundDetected = FALSE;

                    ptwTuningWizard->SetCurrentPage(IDD_AUDIOCALIBWIZ3);
                    
                    ptwTuningWizard->GetRangeFromType(TW_AUDIO_CAPTURE, &pRange);

                    dwClippingThreshold = (pRange->uiMax * CLIPPING_THRESHOLD)/100;
                    dwSilenceThreshold = (pRange->uiMax * SILENCE_THRESHOLD)/100;
                    dwSampleCount = 0;

                    LOG((RTC_INFO, "AudioCalibWiz3: AudioLevel Max - %d, AudioLevel "
                                   "Increment - %d, Silence Threshold - %d, Clipping Threshold "
                                   "- %d", pRange->uiMax, pRange->uiIncrement, 
                                   dwSilenceThreshold, dwClippingThreshold));

                    PaintVUMeter(hProgressBar, 0, pRange);

                    InitStats();

                    // Initialize the trackbar control
                    
                    SendMessage(hTrackBar, TBM_SETRANGE, TRUE, 
                                (LPARAM)MAKELONG(0, MAX_VOLUME_NORMALIZED));
                    SendMessage(hTrackBar, TBM_SETTICFREQ, 32, 0);
                    SendMessage(hTrackBar, TBM_SETPAGESIZE, 0, 32);
                    SendMessage(hTrackBar, TBM_SETLINESIZE, 0, 8);
                    
                    // Get the current volume and show it on the bar.
                    hr = ptwTuningWizard->InitVolume( TW_AUDIO_CAPTURE, 
                                                 &uiIncrement,
                                                 &uiOldVolume,
                                                 &uiNewVolume,
                                                 &uiWaveID
                                               );

                    if ( FAILED(hr) )
                    {
                        return -1;
                    }

                    mixerOpen( &hMixer, uiWaveID, (DWORD)hDlg, 0, MIXER_OBJECTF_WAVEIN | CALLBACK_WINDOW );

                    SendMessage(hTrackBar, TBM_SETPOS, TRUE, uiNewVolume/uiIncrement);

                    // Start tuning
                    hr = ptwTuningWizard->StartTuning( TW_AUDIO_CAPTURE );
                    if ( FAILED( hr ) )
                    {
                        LOG((RTC_ERROR,"AudioCalibWiz3: StartTuning "
                            "failed(0x%x), Show Error Page",
                            hr));

                        TW_ERROR_CODE errCode = TW_AUDIO_CAPTURE_TUNING_ERROR;

                        if( RTC_E_MEDIA_AEC == hr )
                        {
                            errCode = TW_AUDIO_AEC_ERROR;

                            g_bAutoSetAEC = TRUE;
                        }

                        ptwTuningWizard->SetLastError(errCode);

                        lNextPage = ptwTuningWizard->GetNextPage(errCode);

                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, lNextPage);

                        return TRUE;
                    }

                    ptwTuningWizard->SetLastError(
                                TW_NO_ERROR
                                );
                    
                    // Set the progres bar timer
                    SetTimer( hDlg, TID_INTENSITY, INTENSITY_POLL_INTERVAL, NULL );
                    
                    // Initialize the controls.
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    
                    break;
                }

                case PSN_WIZBACK:
                {
                    ptwTuningWizard->StopTuning(TW_AUDIO_CAPTURE, FALSE);
                    lPrevPage = ptwTuningWizard->GetPrevPage();
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, lPrevPage);

                    if (hMixer != NULL)
                    {
                        mixerClose(hMixer);
                        hMixer = NULL;
                    }

                    // Kill the progres bar timer
                    KillTimer( hDlg, TID_INTENSITY );

                    DisplayStats();

                    return TRUE;
                }

                case PSN_WIZNEXT:
                {
                    // Kill the progres bar timer
                    KillTimer( hDlg, TID_INTENSITY );

                    DisplayStats();
                    
                    ptwTuningWizard->StopTuning(TW_AUDIO_CAPTURE, TRUE);
                    // Check if sound was detected. 
                    if (!fSoundDetected)
                    {
                        // No sound, show the error page.
                        
                        ptwTuningWizard->SetLastError(
                                        TW_AUDIO_CAPTURE_NOSOUND
                                        );

                        lNextPage = ptwTuningWizard->GetNextPage(TW_AUDIO_CAPTURE_NOSOUND);
                    }
                    else
                    {
                        ptwTuningWizard->SetLastError(
                                    TW_NO_ERROR
                                    );

                        lNextPage = ptwTuningWizard->GetNextPage();
                    }

                    if (hMixer != NULL)
                    {
                        mixerClose(hMixer);
                        hMixer = NULL;
                    }

                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, lNextPage);

                    return TRUE;

                }

                case PSN_RESET:                    
                    // Stop tuning
                    ptwTuningWizard->StopTuning( TW_AUDIO_CAPTURE, FALSE );

                    if (hMixer != NULL)
                    {
                        mixerClose(hMixer);
                        hMixer = NULL;
                    }
                    
                    // Restore the volume to the old value.
                    ptwTuningWizard->SetVolume(TW_AUDIO_CAPTURE, uiOldVolume);
                    
                    // Kill the progres bar timer
                    KillTimer( hDlg, TID_INTENSITY );

                    DisplayStats();

                    break;
            }
            break;

        case WM_HSCROLL:  // trackbar notification
        {
            dwTBPos = (DWORD)SendMessage(hTrackBar, TBM_GETPOS, 0, 0);
            uiNewVolume = dwTBPos * uiIncrement;
            ptwTuningWizard->SetVolume(TW_AUDIO_CAPTURE, uiNewVolume);
            break;
        }

        case MM_MIXM_CONTROL_CHANGE: // mixer volume change
        {
            UINT uiSysVolume;
            ptwTuningWizard->GetSysVolume(TW_AUDIO_CAPTURE, &uiSysVolume );

            if ( uiNewVolume != uiSysVolume )
            {
                uiNewVolume = uiSysVolume;
                SendMessage(hTrackBar, TBM_SETPOS, TRUE, uiNewVolume/uiIncrement);
            }
            break;
        }

        case WM_TIMER:
        {
            if ( wParam == TID_INTENSITY )
            {
                // Get the audio level.

                // If the audio level crosses the silence threshold, we send this message to 
                // the wizard.

                UINT uiAudioLevel;

                uiAudioLevel = ptwTuningWizard->GetAudioLevel(TW_AUDIO_CAPTURE, &uiIncrement);
        
                // We skip the info from sound level for first 200 ms, so that
                // initial noise from sampling doesn't corrupt the sampling.
                if (dwSampleCount++ > 2)
                {
                    // We collect some stats about the audio level here. 
                    UpdateStats(uiAudioLevel, dwSilenceThreshold, dwClippingThreshold);

                    if ((uiAudioLevel > dwSilenceThreshold) && (!fSoundDetected))
                    {
                        LOG((RTC_TRACE, "AudioCalibWiz3: sound was detected"));
                        fSoundDetected = TRUE;
                    }

                    // If audio level is too high, we send this message to the wizard so that it 
                    // can decrease the volume.

#if 0
                    // audio filter has its AGC algorithm
                    // we don't need anti-clipping here

                    if (uiAudioLevel > dwClippingThreshold)
                    {
                        LOG((RTC_TRACE, "AudioCalibWiz3: clipping"));

                        dwTBPos = (DWORD)SendMessage(hTrackBar, TBM_GETPOS, 0, 0);
                        uiNewVolume = dwTBPos * uiIncrement;

                        if (uiNewVolume > DECREMENT_VOLUME)
                        {

                            // decrement volume
                            uiNewVolume -= DECREMENT_VOLUME;
                            if (SUCCEEDED( 
                                    ptwTuningWizard->SetVolume(TW_AUDIO_CAPTURE, uiNewVolume) 
                                    ))
                            {
                                // update the track bar.
                                SendMessage(hTrackBar, TBM_SETPOS, TRUE, uiNewVolume/uiIncrement);
                            }
                        }                        
                    }
#endif

                    PaintVUMeter(hProgressBar, uiAudioLevel, pRange);
                }
            }

            break;
        }
    }

    return FALSE;
}


//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
// Final Audio Page
//////////////////////////////////////////////////////////////////////////////////////////////
//

INT_PTR APIENTRY AudioCalibWiz4( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    static PROPSHEETPAGE        * ps;
    static CTuningWizard        * ptwTuningWizard;
    LONG                          lPrevPage;

    switch (message) 
    {
        case WM_INITDIALOG:
        {
            // Save the PROPSHEETPAGE information.
            ps = (PROPSHEETPAGE *)lParam;

            // Get the tuningwizard pointer for later use
            ptwTuningWizard = (CTuningWizard *)(ps->lParam);

            return TRUE;
        }            

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code) 
            {
                case PSN_SETACTIVE:
                {
                    ptwTuningWizard->SetCurrentPage(IDD_AUDIOCALIBWIZ4);

                    // Initialize the controls.
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_FINISH);
                    break;
                }

                case PSN_WIZBACK:
                {
                    TW_ERROR_CODE ec;

                    // Prev will be different if we came here through an error.                     
                    ptwTuningWizard->GetLastError(&ec);

                    lPrevPage = ptwTuningWizard->GetPrevPage(ec);

                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, lPrevPage);
                    
                    return TRUE;
                }

                case PSN_WIZFINISH:
                    // This method will write the current config to the 
                    // registry.
                    ptwTuningWizard->SaveAECSetting();
                    ptwTuningWizard->SaveChanges();
                    
                    break;
            }
            break;

    }

    return FALSE;
}


//
//////////////////////////////////////////////////////////////////////////////////////////////
// Function Name: 
// Description:
// Audio Caliberation Error Page
//////////////////////////////////////////////////////////////////////////////////////////////
//

INT_PTR APIENTRY AudioCalibErrWiz( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    PROPSHEETPAGE               * ps;
    static CTuningWizard        * ptwTuningWizard;
    WCHAR                         szTemp[MAXSTRINGSIZE];
    LONG                          lErrorType;
    LONG                          lErrorTitleId;
    LONG                          lErrorTextId;
    static HINSTANCE              hInst;
    LONG                          lNextPage;
    LONG                          lPrevPage;

    switch (message) 
    {
        case WM_INITDIALOG:
        {

            // Save the PROPSHEETPAGE information.
            ps = (PROPSHEETPAGE *)lParam;

            // Get the tuningwizard pointer for later use
            ptwTuningWizard = (CTuningWizard *)(ps->lParam);
            hInst = ptwTuningWizard->GetInstance();

            return TRUE;
        }            
        
        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_SETACTIVE:
                {
                    ptwTuningWizard->SetCurrentPage(IDD_AUDIOCALIBERRWIZ);
                    // initialize the controls.

                    // Set the wizard bitmap to the static control
                    ::SendDlgItemMessage(    hDlg,
                                    IDC_ERRWIZICON,
                                    STM_SETIMAGE,
                                    IMAGE_ICON,
                                    (LPARAM) ::LoadIcon(NULL, IDI_EXCLAMATION));

                    szTemp[0] = L'\0';

                    //set the error title
                    lErrorTitleId = ptwTuningWizard->GetErrorTitleId();
                    if (lErrorTitleId)
                    {
                        LoadString(hInst,lErrorTitleId, szTemp, MAXSTRINGSIZE);
                        SetDlgItemText(hDlg, IDC_ERRTITLE, szTemp);
                    }

                    szTemp[0] = L'\0';

                    lErrorTextId = ptwTuningWizard->GetErrorTextId();

                    if (lErrorTextId)
                    {
                        // Show the error text
                        LoadString(hInst,lErrorTextId, szTemp, MAXSTRINGSIZE);
                        SetDlgItemText(hDlg, IDC_ERRTEXT, szTemp);
                    }


                    // Initialize the controls.
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    
                    break;
                }

                case PSN_WIZBACK:
                {
                    lPrevPage = ptwTuningWizard->GetPrevPage();
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, lPrevPage);
                    return TRUE;
                }

                case PSN_WIZNEXT:
                {
                    TW_ERROR_CODE ec;

                    // Next will depend on the error which got us here.
                    
                    ptwTuningWizard->GetLastError(&ec);

                    lNextPage = ptwTuningWizard->GetNextPage(ec);
                                    
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, lNextPage);
                    return TRUE;

                }
            }
            break;
    }

    return FALSE;
}

static const BYTE g_VUTable[] = {
     0,     1,     2,     3,     4,     5,     6,     7,
     8,    23,    30,    35,    39,    43,    46,    49,
    52,    55,    57,    60,    62,    64,    66,    68,
    70,    72,    74,    76,    78,    80,    81,    83,
    85,    86,    88,    89,    91,    92,    94,    95,
    97,    98,    99,   101,   102,   103,   105,   106,
   107,   108,   110,   111,   112,   113,   114,   115,
   117,   118,   119,   120,   121,   122,   123,   124,
   125,   126,   127,   128,   129,   130,   132,   132,
   133,   134,   135,   136,   137,   138,   139,   140,
   141,   142,   143,   144,   145,   146,   147,   147,
   148,   149,   150,   151,   152,   153,   154,   154,
   155,   156,   157,   158,   159,   159,   160,   161,
   162,   163,   163,   164,   165,   166,   167,   167,
   168,   169,   170,   170,   171,   172,   173,   173,
   174,   175,   176,   176,   177,   178,   179,   179,
   180,   181,   181,   182,   183,   184,   184,   185,
   186,   186,   187,   188,   188,   189,   190,   190,
   191,   192,   192,   193,   194,   194,   195,   196,
   196,   197,   198,   198,   199,   200,   200,   201,
   202,   202,   203,   204,   204,   205,   205,   206,
   207,   207,   208,   209,   209,   210,   210,   211,
   212,   212,   213,   213,   214,   215,   215,   216,
   216,   217,   218,   218,   219,   219,   220,   221,
   221,   222,   222,   223,   223,   224,   225,   225,
   226,   226,   227,   227,   228,   229,   229,   230,
   230,   231,   231,   232,   232,   233,   234,   234,
   235,   235,   236,   236,   237,   237,   238,   238,
   239,   239,   240,   241,   241,   242,   242,   243,
   243,   244,   244,   245,   245,   246,   246,   247,
   247,   248,   248,   249,   249,   250,   250,   251,
   251,   252,   252,   253,   253,   254,   254,   255
};


void PaintVUMeter (HWND hwnd, DWORD dwVolume, WIZARD_RANGE * pRange)
{
    COLORREF     RedColor = RGB(255,0,0);
    COLORREF     YellowColor = RGB(255,255,0);
    COLORREF     GreenColor = RGB(0,255,0);
    static DWORD dwPrevVolume=0;
    HBRUSH       hRedBrush, hOldBrush, hYellowBrush, hGreenBrush;
    HBRUSH       hBlackBrush, hCurrentBrush;
    HDC          hdc;
    RECT         rect, rectDraw, invalidRect;
    DWORD        width, boxwidth, startPos=0;
    DWORD        nRect=0, yellowPos, redPos;
    LONG         lDiff, lDiffTrunc = (MAX_VOLUME_NORMALIZED/2);
    UINT         uiMinVolume;
    UINT         uiMaxVolume;
    UINT         uiIncrement;

    if (pRange == NULL)
    {
        LOG((RTC_ERROR, "PaintVUMeter: Received NULL Range pointer."));
        return;
    }

    uiMinVolume = pRange->uiMin;
    uiMaxVolume = pRange->uiMax;
    uiIncrement = pRange->uiIncrement;

    // rect gets filled with the dimensions we are drawing into
    if (FALSE == GetClientRect (hwnd, &rect))
    {
        return;
    }

    if (dwVolume > uiMaxVolume)
        dwVolume = uiMaxVolume;

    // reduce from 15 bits to 8    // 0 <= dwVolume <= 256
    dwVolume = dwVolume / uiIncrement;

    // run it through the "normalizing" table.  Special case: F(256)==256
    if (dwVolume < MAX_VOLUME_NORMALIZED)
        dwVolume = g_VUTable[dwVolume];
    
    // visual aesthetic #1 - get rid of VU jerkiness
    // if the volume changed by more than 1/2 since the last update
    // only move the meter up half way
   // exception: if volume is explicitly 0, then skip
    lDiff = (LONG)dwVolume - (LONG)dwPrevVolume;
    if ((dwVolume != 0) && ( (lDiff > (MAX_VOLUME_NORMALIZED/2))
                       ||   (lDiff < -(MAX_VOLUME_NORMALIZED/2)) ))
        dwVolume = dwVolume - (lDiff/2);
    
    // minus 2 for the ending borders
    // if Framed rectangles are used, drop the -2
    boxwidth = rect.right - rect.left - 2;
    width = (boxwidth * dwVolume)/ MAX_VOLUME_NORMALIZED;

    // visual aesthetic #2 - to get rid of flicker
    // if volume has increased since last time
    // then there is no need to invalidate/update anything
    // otherwise only clear everything to the right of the
    // calculated "width".  +/- 1 so the border doesn't get erased
    if ((dwVolume < dwPrevVolume) || (dwVolume == 0))
    {
        invalidRect.left = rect.left + width - RECTANGLE_WIDTH;
        if (invalidRect.left < rect.left)
            invalidRect.left = rect.left;
        invalidRect.right = rect.right - 1;
        invalidRect.top = rect.top + 1;
        invalidRect.bottom = rect.bottom - 1;

        // these calls together erase the invalid region
        InvalidateRect (hwnd, &invalidRect, TRUE);
        UpdateWindow (hwnd);
    }

    hdc = GetDC (hwnd) ;

    hRedBrush = CreateSolidBrush (RedColor) ;
    hGreenBrush = CreateSolidBrush(GreenColor);
    hYellowBrush = CreateSolidBrush(YellowColor);

    hBlackBrush = (HBRUSH)GetStockObject(BLACK_BRUSH);

    if(hRedBrush && hGreenBrush && hYellowBrush && hBlackBrush)
    {

        hOldBrush = (HBRUSH) SelectObject (hdc, hBlackBrush);

        // draw the main
        FrameRect(hdc, &rect, hBlackBrush);

        yellowPos = boxwidth/2;
        redPos = (boxwidth*3)/4;

        SelectObject(hdc, hGreenBrush);

        hCurrentBrush = hGreenBrush;

        rectDraw.top = rect.top +1;
        rectDraw.bottom = rect.bottom -1;
        while ((startPos+RECTANGLE_WIDTH) < width)
        {
            rectDraw.left = rect.left + (RECTANGLE_WIDTH+RECTANGLE_LEADING)*nRect + 1;
            rectDraw.right = rectDraw.left + RECTANGLE_WIDTH;
            nRect++;

            FillRect(hdc, &rectDraw, hCurrentBrush);
            startPos += RECTANGLE_WIDTH+RECTANGLE_LEADING;

            if (startPos > redPos)
                hCurrentBrush = hRedBrush;
            else if (startPos > yellowPos)
                hCurrentBrush = hYellowBrush;
        }

        SelectObject (hdc, hOldBrush);
    }

    if(hRedBrush)
        DeleteObject(hRedBrush);

    if(hYellowBrush)
        DeleteObject(hYellowBrush);

    if(hGreenBrush)
        DeleteObject(hGreenBrush);

    ReleaseDC (hwnd, hdc) ;

    dwPrevVolume = dwVolume;

    return;
}

void InitStats()
{
    int i;
    for (i=1; i < 4; i ++)
    {
        g_StatsArray[i].dwMin = 0xffffffff;
        g_StatsArray[i].dwMax = 0;
        g_StatsArray[i].flAverage = 0.0;
        g_StatsArray[i].dwCount = 0;
    }

    for (i = 0; i < 256; i ++)
    {
        g_FrequencyArray[i] = 0;
    }
}

void UpdateCategoryStats(int i, UINT uiAudioLevel)
{
    STATS_INFO * pStats = &g_StatsArray[i];

    pStats->dwCount ++;

    if (pStats->dwMin > uiAudioLevel) 
    {
        pStats->dwMin = uiAudioLevel;
    }

    if (pStats->dwMax < uiAudioLevel) 
    {
        pStats->dwMax = uiAudioLevel;
    }

    pStats->flAverage = (pStats->flAverage *(pStats->dwCount-1) + 
                        uiAudioLevel)/
                        pStats->dwCount;
}

void UpdateStats(UINT uiAudioLevel, DWORD silence, DWORD clipping)
{
    int i;
    // I will partition the sample in three parts:
    // 1. Below silence threshold
    // 2. Above clipping threshold
    // 3. Between the two

    // Update the frequency stats first..
    
    i = uiAudioLevel / 256;
    if (i >= 256)
    {
        i = 256;
    }
    g_FrequencyArray[i] ++;

    if (uiAudioLevel < silence)
    {
        UpdateCategoryStats(1, uiAudioLevel);
    }
    else if (uiAudioLevel > clipping)
    {
        UpdateCategoryStats(3, uiAudioLevel);
    }
    else
    {
        UpdateCategoryStats(2, uiAudioLevel);
    }
}

void DisplayStats()
{
    int i;

    for (i=1; i <= 3; i ++)
    {

        LOG((RTC_INFO, "[%d] min: 0x%x, max: 0x%x, count: %d, average: %f", i, 
            g_StatsArray[i].dwMin, g_StatsArray[i].dwMax,
            g_StatsArray[i].dwCount, g_StatsArray[i].flAverage));
        
    }

    for (i = 0; i < 256; i ++)
    {
        LOG((RTC_INFO, "[0x%x-0x%x] - 0x%x", i*256, (i+1)*256, g_FrequencyArray[i]));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\util\rtcdib.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    rtcdib.cpp

Abstract:

    DIB helpers, copied from NT source tree

--*/

#include <windows.h>
#include "rtcdib.h"


//
//  Dib helpers
//

/*  How big is the palette? if bits per pel not 24
 *  no of bytes to read is 6 for 1 bit, 48 for 4 bits
 *  256*3 for 8 bits and 0 for 24 bits
 */
UINT PaletteSize(VOID FAR * pv)
{
    #define lpbi ((LPBITMAPINFOHEADER)pv)
    #define lpbc ((LPBITMAPCOREHEADER)pv)

    UINT    NumColors;

    NumColors = DibNumColors(lpbi);

    if (lpbi->biSize == sizeof(BITMAPCOREHEADER))
    {
        return NumColors * sizeof(RGBTRIPLE);
    }
    else
    {
        return NumColors * sizeof(RGBQUAD);
    }

    #undef lpbi
    #undef lpbc
}



/*  How Many colors does this DIB have?
 *  this will work on both PM and Windows bitmap info structures.
 */
WORD DibNumColors(VOID FAR * pv)
{
    #define lpbi ((LPBITMAPINFOHEADER)pv)
    #define lpbc ((LPBITMAPCOREHEADER)pv)

    int bits;

    /*
     *  with the new format headers, the size of the palette is in biClrUsed
     *  else is dependent on bits per pixel
     */
    if (lpbi->biSize != sizeof(BITMAPCOREHEADER))
    {
        if (lpbi->biClrUsed != 0)
        {
	        return (UINT)lpbi->biClrUsed;
        }

        bits = lpbi->biBitCount;
    }
    else
    {
        bits = lpbc->bcBitCount;
    }

    switch (bits)
    {
    case 1:
        return 2;
    case 4:
        return 16;
    case 8:
        return 256;
    default:
        return 0;
    }

    #undef lpbi
    #undef lpbc
}

/*
 *  DibFromBitmap()
 *
 *  Will create a global memory block in DIB format that represents the DDB
 *  passed in
 *
 */
HANDLE DibFromBitmap(HBITMAP hbm, DWORD biStyle, WORD biBits, HPALETTE hpal, UINT wUsage)
{
    BITMAP               bm;
    BITMAPINFOHEADER     bi;
    BITMAPINFOHEADER FAR *lpbi;
    DWORD                dwLen;
    int                  nColors;
    HANDLE               hdib;
    HANDLE               h;
    HDC                  hdc;

    if (wUsage == 0)
    {
	    wUsage = DIB_RGB_COLORS;
    }

    if (!hbm)
    {
        return NULL;
    }
#if 0
    if (biStyle == BI_RGB && wUsage == DIB_RGB_COLORS)
        return CreateLogicalDib(hbm,biBits,hpal);
#endif

    if (hpal == NULL)
    {
        hpal = (HPALETTE)GetStockObject(DEFAULT_PALETTE);
    }

    GetObject(hbm,sizeof(bm),(LPBYTE)&bm);
#ifdef WIN32
    nColors = 0;  // GetObject only stores two bytes
#endif
    GetObject(hpal,sizeof(nColors),(LPBYTE)&nColors);

    if (biBits == 0)
    {
	    biBits = bm.bmPlanes * bm.bmBitsPixel;
    }

    bi.biSize               = sizeof(BITMAPINFOHEADER);
    bi.biWidth              = bm.bmWidth;
    bi.biHeight             = bm.bmHeight;
    bi.biPlanes             = 1;
    bi.biBitCount           = biBits;
    bi.biCompression        = biStyle;
    bi.biSizeImage          = 0;
    bi.biXPelsPerMeter      = 0;
    bi.biYPelsPerMeter      = 0;
    bi.biClrUsed            = 0;
    bi.biClrImportant       = 0;

    dwLen  = bi.biSize + PaletteSize(&bi);

    hdc = CreateCompatibleDC(NULL);
    if(!hdc)
    {
        return NULL;
    }
    
    hpal = SelectPalette(hdc,hpal,TRUE);
    RealizePalette(hdc);

    hdib = GlobalAlloc(GMEM_MOVEABLE,dwLen);

    if (!hdib)
    {
	    goto exit;
    }

    lpbi = (BITMAPINFOHEADER*)GlobalLock(hdib);

    *lpbi = bi;

    /*
     *  call GetDIBits with a NULL lpBits param, so it will calculate the
     *  biSizeImage field for us
     */
    GetDIBits(hdc, hbm, 0, (UINT)bi.biHeight,
        NULL, (LPBITMAPINFO)lpbi, wUsage);

    bi = *lpbi;
    GlobalUnlock(hdib);

    /*
     * HACK! if the driver did not fill in the biSizeImage field, make one up
     */
    if (bi.biSizeImage == 0)
    {
        bi.biSizeImage = (DWORD)WIDTHBYTES(bm.bmWidth * biBits) * bm.bmHeight;

        if (biStyle != BI_RGB)
        {
            bi.biSizeImage = (bi.biSizeImage * 3) / 2;
        }
    }

    /*
     *  realloc the buffer big enough to hold all the bits
     */
    dwLen = bi.biSize + PaletteSize(&bi) + bi.biSizeImage;
    if (h = GlobalReAlloc(hdib,dwLen,GMEM_MOVEABLE))
    {
        hdib = h;
    }
    else
    {
        GlobalFree(hdib);
        hdib = NULL;
        goto exit;
    }

    /*
     *  call GetDIBits with a NON-NULL lpBits param, and actualy get the
     *  bits this time
     */
    lpbi = (BITMAPINFOHEADER*)GlobalLock(hdib);

    GetDIBits(hdc, hbm, 0, (UINT)bi.biHeight,
    (LPBYTE)lpbi + (UINT)lpbi->biSize + PaletteSize(lpbi),
    (LPBITMAPINFO)lpbi, wUsage);

    bi = *lpbi;
    lpbi->biClrUsed = DibNumColors(lpbi) ;
    GlobalUnlock(hdib);

exit:
    SelectPalette(hdc,hpal,TRUE);
    DeleteDC(hdc);
    return hdib;
}


/*
 *  DibBlt()
 *
 *  draws a bitmap in CF_DIB format, using SetDIBits to device.
 *
 *  takes the same parameters as BitBlt()
 */
BOOL DibBlt(HDC hdc, int x0, int y0, int dx, int dy, HANDLE hdib, int x1, int y1, LONG rop, UINT wUsage)
{
    LPBITMAPINFOHEADER lpbi;
    LPBYTE       pBuf;
    BOOL        f;

    if (!hdib)
    {
        return PatBlt(hdc,x0,y0,dx,dy,rop);
    }

    if (wUsage == 0)
    {
        wUsage = DIB_RGB_COLORS;
    }

    lpbi = (BITMAPINFOHEADER*)GlobalLock(hdib);

    if (!lpbi)
    {
        return FALSE;
    }

    if (dx == -1 && dy == -1)
    {
        if (lpbi->biSize == sizeof(BITMAPCOREHEADER))
        {
            dx = ((LPBITMAPCOREHEADER)lpbi)->bcWidth;
            dy = ((LPBITMAPCOREHEADER)lpbi)->bcHeight;
        }
        else
        {
            dx = (int)lpbi->biWidth;
            dy = (int)lpbi->biHeight;
        }
    }

    pBuf = (LPBYTE)lpbi + (UINT)lpbi->biSize + PaletteSize(lpbi);

#if 0
    f = SetDIBitsToDevice(
        hdc, x0, y0, dx, dy,
        x1,y1, x1, dy,
        pBuf, (LPBITMAPINFO)lpbi,
        wUsage );
#else
    f = StretchDIBits (
        hdc,
    x0,y0,
    dx,dy,
    x1,y1,
    dx,dy,
    pBuf, (LPBITMAPINFO)lpbi,
    wUsage,
    rop);
#endif

    GlobalUnlock(hdib);
    return f;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\util\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\util\rtcmem.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCMem.cpp

Abstract:

    Implementation for memory allocation.

--*/

#include <windows.h>
#include <objbase.h>
#include "RTCMem.h"
#include "RTCLog.h"

PRTC_MEMINFO            g_pMemFirst = NULL;
PRTC_MEMINFO            g_pMemLast = NULL;
HANDLE                  g_hHeap = NULL;

/////////////////////////////////////////////////////////////////////////////
//
// RtcHeapCreate
//
/////////////////////////////////////////////////////////////////////////////

BOOL
WINAPI
RtcHeapCreate()
{
    if (!(g_hHeap = HeapCreate(
                               0,    // NULL on failure,serialize access
                               0x1000, // initial heap size
                               0       // max heap size (0 == growable)
                              )))
    {
        LOG((RTC_ERROR, "RtcHeapCreate - HeapCreate failed 0x%lx", GetLastError()));

        g_hHeap = GetProcessHeap();

        if (g_hHeap == NULL)
        {
            LOG((RTC_ERROR, "RtcHeapCreate - GetProcessHeap failed 0x%lx", GetLastError()));
            return FALSE;
        }
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//
// RtcHeapDestroy
//
/////////////////////////////////////////////////////////////////////////////

VOID
WINAPI
RtcHeapDestroy()
{
    //
    // if ghHeap is NULL, then there is no heap to destroy
    //
    
    if ( ( g_hHeap != NULL) && ( g_hHeap != GetProcessHeap() ) )
    {   
        HeapDestroy (g_hHeap);
    }
}

/////////////////////////////////////////////////////////////////////////////
//
// RtcAllocReal
//
/////////////////////////////////////////////////////////////////////////////

#if DBG

LPVOID
WINAPI
RtcAllocReal(
    DWORD   dwSize,
    DWORD   dwLine,
    PSTR    pszFile
    )
{
    //
    // Alloc 16 extra bytes so we can make sure the pointer we pass back
    // is 64-bit aligned & have space to store the original pointer
    //
    PRTC_MEMINFO     pHold;
    PDWORD_PTR       pAligned;
    PBYTE            p;

    p = (LPBYTE)HeapAlloc(g_hHeap, HEAP_ZERO_MEMORY, dwSize + sizeof(RTC_MEMINFO) + 16);

    if (p == NULL)
    {
        return NULL;
    }

    // note note note - this only works because rtcmeminfo is
    // a 16 bit multiple in size.  if it wasn't, this
    // align would cause problems.
    pAligned = (PDWORD_PTR) (p + 8 - (((DWORD_PTR) p) & (DWORD_PTR)0x7));   
    *pAligned = (DWORD_PTR) p;
    pHold = (PRTC_MEMINFO)((DWORD_PTR)pAligned + 8); 
    
    pHold->dwSize = dwSize;
    pHold->dwLine = dwLine;
    pHold->pszFile = pszFile;

    //EnterCriticalSection(&csMemoryList);

    if (g_pMemLast != NULL)
    {
        g_pMemLast->pNext = pHold;
        pHold->pPrev = g_pMemLast;
        g_pMemLast = pHold;
    }
    else
    {
        g_pMemFirst = g_pMemLast = pHold;
    }

    //LeaveCriticalSection(&csMemoryList);
    
    return (LPVOID)(pHold + 1);
}

#else

LPVOID
WINAPI
RtcAllocReal(
    DWORD   dwSize
    )
{
    LPBYTE  p;
    PDWORD_PTR pAligned;

    if ((p = (LPBYTE) HeapAlloc(g_hHeap, HEAP_ZERO_MEMORY, dwSize + 16)))
    {
        pAligned = (PDWORD_PTR) (p + 8 - (((DWORD_PTR) p) & (DWORD_PTR)0x7));
        *pAligned = (DWORD_PTR) p;
        pAligned = (PDWORD_PTR)((DWORD_PTR)pAligned + 8);
    }
    else
    {
        pAligned = NULL;
    }

    return ((LPVOID) pAligned);
}

#endif

/////////////////////////////////////////////////////////////////////////////
//
// RtcFree
//
/////////////////////////////////////////////////////////////////////////////

VOID
WINAPI
RtcFree(
    LPVOID  p
    )
{
    if (p == NULL)
    {
        return;
    }

#if DBG

    PRTC_MEMINFO       pHold;

    pHold = (PRTC_MEMINFO)(((LPBYTE)p) - sizeof(RTC_MEMINFO));

    //EnterCriticalSection(&csMemoryList);

    if (pHold->pPrev)
    {
        pHold->pPrev->pNext = pHold->pNext;
    }
    else
    {
        g_pMemFirst = pHold->pNext;
    }

    if (pHold->pNext)
    {
        pHold->pNext->pPrev = pHold->pPrev;
    }
    else
    {
        g_pMemLast = pHold->pPrev;
    }

    //LeaveCriticalSection(&csMemoryList);

    LPVOID  pOrig = (LPVOID) *((PDWORD_PTR)((DWORD_PTR)pHold - 8));

#else

    LPVOID  pOrig = (LPVOID) *((PDWORD_PTR)((DWORD_PTR)p - 8));

#endif

    HeapFree(g_hHeap,0, pOrig);

    return;
}

#if DBG

/////////////////////////////////////////////////////////////////////////////
//
// DumpMemoryList
//
/////////////////////////////////////////////////////////////////////////////

void
RtcDumpMemoryList()
{
    PRTC_MEMINFO       pHold;

    if (g_pMemFirst == NULL)
    {
        LOG((RTC_TRACE, "RtcDumpMemoryList - All memory deallocated"));
        return;
    }

    pHold = g_pMemFirst;

    while (pHold)
    {
       LOG((RTC_ERROR, "RtcDumpMemoryList - 0x%lx not freed - LINE %d FILE %s!", pHold+1, pHold->dwLine, pHold->pszFile));
       pHold = pHold->pNext;
    }

    DebugBreak();
}

#endif

/////////////////////////////////////////////////////////////////////////////
//
// RtcAllocString
//
/////////////////////////////////////////////////////////////////////////////

PWSTR
RtcAllocString(
    PCWSTR sz
    )
{
    PWSTR szNew;

    if ( sz == NULL )
    {
        LOG((RTC_WARN, "RtcAllocString - "
                            "NULL string"));

        return NULL;
    }

    szNew = (PWSTR)RtcAlloc( sizeof(WCHAR) * (lstrlenW(sz) + 1) );

    if ( szNew == NULL )
    {
        LOG((RTC_ERROR, "RtcAllocString - "
                            "out of memory"));
                            
        return NULL;
    }

    lstrcpyW( szNew, sz );

    return szNew;
}

/////////////////////////////////////////////////////////////////////////////
//
// RtcAllocString
//
/////////////////////////////////////////////////////////////////////////////

// Load string for this resource. Safe with respect to string size. 
// the caller is responsible for freeing returned memory by calling 
// RtcFree
//  (copied from termmgr\tmutils.cpp)

PWSTR
RtcAllocString(
    HINSTANCE   hInst,
    UINT        uResID
    )
{
    TCHAR *pszTempString = NULL;

    int nCurrentSizeInChars = 128;
    
    int nCharsCopied = 0;

    do
    {
        if ( NULL != pszTempString )
        {
            delete pszTempString;
            pszTempString = NULL;
        }

        nCurrentSizeInChars *= 2;

        pszTempString = new TCHAR[nCurrentSizeInChars];

        if (NULL == pszTempString)
        {
            return NULL;
        }

        nCharsCopied = ::LoadString( hInst,
                                     uResID,
                                     pszTempString,
                                     nCurrentSizeInChars
                                    );

        if ( 0 == nCharsCopied )
        {
            delete pszTempString;
            return NULL;
        }

        //
        // nCharsCopied does not include the null terminator
        // so compare it to the size of the buffer - 1
        // if the buffer was filled completely, retry with a bigger buffer
        //

    } while ( (nCharsCopied >= (nCurrentSizeInChars - 1) ) );


    //
    // allocate bstr and initialize it with the string we have
    //
    
    PWSTR szNew = RtcAllocString(pszTempString);


    //
    // no longer need this
    //

    delete pszTempString;
    pszTempString = NULL;

    return szNew;
}



/////////////////////////////////////////////////////////////////////////////
//
// CoTaskAllocString
//
/////////////////////////////////////////////////////////////////////////////

PWSTR
CoTaskAllocString(
    PCWSTR sz
    )
{
    PWSTR szNew;

    if ( sz == NULL )
    {
        LOG((RTC_WARN, "CoTaskAllocString - "
                            "NULL string"));

        return NULL;
    }

    szNew = (PWSTR)CoTaskMemAlloc( sizeof(WCHAR) * (lstrlenW(sz) + 1) );

    if ( szNew == NULL )
    {
        LOG((RTC_ERROR, "CoTaskAllocString - "
                            "out of memory"));
                            
        return NULL;
    }

    lstrcpyW( szNew, sz );

    return szNew;
}

/////////////////////////////////////////////////////////////////////////////
//
// RtcAllocStringFromANSI
//
/////////////////////////////////////////////////////////////////////////////

PWSTR
RtcAllocStringFromANSI(
    PCSTR sz
    )
{
    PWSTR szWide;
    int cchNeeded;

    if ( sz == NULL )
    {
        LOG((RTC_WARN, "RtcAllocStringFromANSI - "
                            "NULL string"));

        return NULL;
    }

    cchNeeded = MultiByteToWideChar(CP_ACP, 0, sz, -1, NULL, 0);

    if ( cchNeeded == 0 )
    {
        LOG((RTC_ERROR, "RtcAllocStringFromANSI - "
                            "MultiByteToWideChar(NULL) failed"));
                            
        return NULL;
    }

    szWide = (PWSTR)RtcAlloc( sizeof(WCHAR) * (cchNeeded + 1) );

    if ( szWide == NULL )
    {
        LOG((RTC_ERROR, "RtcAllocStringFromANSI - "
                            "out of memory"));
                            
        return NULL;
    }

    ZeroMemory( szWide, sizeof(WCHAR) * (cchNeeded + 1) );

    if ( MultiByteToWideChar(CP_ACP, 0, sz, -1, szWide, cchNeeded) == 0 )
    {
        LOG((RTC_ERROR, "RtcAllocStringFromANSI - "
                            "MultiByteToWideChar failed"));
                       
        RtcFree( szWide );
        return NULL;
    }

    return szWide;
}

/////////////////////////////////////////////////////////////////////////////
//
// SysAllocStringFromANSI
//
/////////////////////////////////////////////////////////////////////////////

BSTR
SysAllocStringFromANSI(
    PCSTR sz
    )
{
    BSTR bstrNew;
    PWSTR szWide;

    szWide = RtcAllocStringFromANSI( sz );

    if ( szWide == NULL )
    {
        LOG((RTC_WARN, "SysAllocStringFromANSI - "
                            "RtcAllocStringFromANSI failed"));

        return NULL;
    }

    bstrNew = SysAllocString( szWide );

    RtcFree( szWide );

    if ( bstrNew == NULL )
    {
        LOG((RTC_ERROR, "SysAllocStringFromANSI - "
                            "out of memory"));
                            
        return NULL;
    }

    return bstrNew;
}

/////////////////////////////////////////////////////////////////////////////
//
// RtcRegQueryString
//
/////////////////////////////////////////////////////////////////////////////

PWSTR
RtcRegQueryString(
    HKEY hKey,
    PCWSTR szValueName
    )
{
    PWSTR szNew = NULL;
    DWORD cbSize = 0;
    DWORD dwType;
    LONG lResult;

    while (TRUE)
    {
        lResult = RegQueryValueExW(
                                   hKey,
                                   szValueName,
                                   0,
                                   &dwType,
                                   (LPBYTE)szNew,
                                   &cbSize
                                  );

        if ( lResult == ERROR_MORE_DATA || szNew == NULL) // this is correct !!!
        {
           if (szNew != NULL)
           {
               RtcFree(szNew);
           }

           //LOG((RTC_INFO, "RtcRegQueryString - "
           //                     "RtcAlloc[%d]", cbSize));

           szNew = (PWSTR)RtcAlloc(cbSize);
        }                  
        else if (lResult != ERROR_SUCCESS )
        {
            //LOG((RTC_ERROR, "RtcRegQueryString - "
            //                   "RegQueryValueExW failed %d", lResult));
            
            if (szNew != NULL)
            {
                RtcFree(szNew);
            }

            return NULL;
        }
        else if ( dwType != REG_SZ )
        {
            LOG((RTC_ERROR, "RtcRegQueryString - "
                                "not a string"));
            
            if (szNew != NULL)
            {
                RtcFree(szNew);
            }

            return NULL;
        }
        else
        {
            //LOG((RTC_INFO, "RtcRegQueryString - "
            //                    "[%ws] = '%ws'", szValueName, szNew));
            break;
        }
    }

    return szNew;
}

/////////////////////////////////////////////////////////////////////////////
//
// RtcGetUserName
//
/////////////////////////////////////////////////////////////////////////////
PWSTR 
RtcGetUserName()
{
    PWSTR    szString = NULL;
    ULONG    cOldSize = 32;
    ULONG    cSize = 32;
    BOOL     fResult;
    
    while (TRUE)
    {
        LOG((RTC_TRACE, "CRTCClient::RtcGetUserName - alloc[%d]", cSize * sizeof(WCHAR)));

        szString = (PWSTR)RtcAlloc( cSize * sizeof(WCHAR) );

        if ( szString == NULL )
        {
            return NULL;
        }

        fResult = GetUserNameW( szString, &cSize );

        if ( fResult != 0 )
        {
            return szString;
        }
        else
        {            
            RtcFree( szString );

            if ( cSize == cOldSize )
            {
                return NULL;
            }

            cOldSize = cSize;
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
//
// RtcGetComputerName
//
/////////////////////////////////////////////////////////////////////////////
PWSTR 
RtcGetComputerName()
{
    PWSTR    szString = NULL;
    ULONG    cOldSize = 32;
    ULONG    cSize = 32;
    BOOL     fResult;
    
    while (TRUE)
    {
        LOG((RTC_TRACE, "CRTCClient::RtcGetComputerName - alloc[%d]", cSize * sizeof(WCHAR)));

        szString = (PWSTR)RtcAlloc( cSize * sizeof(WCHAR) );

        if ( szString == NULL )
        {
            return NULL;
        }

        fResult = GetComputerNameW( szString, &cSize );

        if ( fResult != 0 )
        {
            return szString;
        }
        else
        {            
            RtcFree( szString );

            if ( cSize == cOldSize )
            {
                return NULL;
            }

            cOldSize = cSize;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\util\rtcphonenumber.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCPhoneNumber.cpp

Abstract:

    Implementation of the CRTCPhoneNumber class

--*/

#include "stdafx.h"
#include "rtcphonenumber.h"
#include <initguid.h>
#include "rtcutil_i.c"


/////////////////////////////////////////////////////////////////////////////
//
// CRTCPhoneNumber::FinalConstruct
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCPhoneNumber::FinalConstruct()
{
    // LOG((RTC_TRACE, "CRTCPhoneNumber::FinalConstruct - enter"));

#if DBG
    m_pDebug = (PWSTR) RtcAlloc( 1 );
#endif

    // LOG((RTC_TRACE, "CRTCPhoneNumber::FinalConstruct - exit S_OK"));

    return S_OK;
}  

/////////////////////////////////////////////////////////////////////////////
//
// CRTCPhoneNumber::FinalRelease
//
/////////////////////////////////////////////////////////////////////////////

void 
CRTCPhoneNumber::FinalRelease()
{
    // LOG((RTC_TRACE, "CRTCPhoneNumber::FinalRelease - enter"));

    if ( m_szAreaCode != NULL )
    {
        RtcFree(m_szAreaCode);
        m_szAreaCode = NULL;
    }

    if ( m_szNumber != NULL )
    {
        RtcFree(m_szNumber);
        m_szNumber = NULL;
    }

    if ( m_szLabel != NULL )
    {
        RtcFree(m_szLabel);
        m_szLabel = NULL;
    }

#if DBG
    RtcFree( m_pDebug );
    m_pDebug = NULL;
#endif

    // LOG((RTC_TRACE, "CRTCPhoneNumber::FinalRelease - exit"));
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCPhoneNumber::put_CountryCode
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCPhoneNumber::put_CountryCode(
        DWORD dwCountryCode
        )
{
    // LOG((RTC_TRACE, "CRTCPhoneNumber::put_CountryCode - enter"));

    m_dwCountryCode = dwCountryCode;

    // LOG((RTC_TRACE, "CRTCPhoneNumber::put_CountryCode - exit S_OK"));

    return S_OK;
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCPhoneNumber::get_CountryCode
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCPhoneNumber::get_CountryCode(
        DWORD * pdwCountryCode
        ) 
{
    // LOG((RTC_TRACE, "CRTCPhoneNumber::get_CountryCode - enter"));

    if ( IsBadWritePtr( pdwCountryCode, sizeof(DWORD) ) )
    {
        LOG((RTC_ERROR, "CRTCPhoneNumber::get_CountryCode - "
                            "bad DWORD pointer"));

        return E_POINTER;
    }

    *pdwCountryCode = m_dwCountryCode;

    // LOG((RTC_TRACE, "CRTCPhoneNumber::get_CountryCode - exit S_OK"));

    return S_OK;
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCPhoneNumber::put_AreaCode
//
/////////////////////////////////////////////////////////////////////////////        

STDMETHODIMP
CRTCPhoneNumber::put_AreaCode(
        BSTR bstrAreaCode
        )
{
    // LOG((RTC_TRACE, "CRTCPhoneNumber::put_AreaCode - enter"));

    if ( IsBadStringPtrW( bstrAreaCode, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCPhoneNumber::put_AreaCode - "
                            "bad string pointer"));

        return E_POINTER;
    }

    if ( m_szAreaCode != NULL )
    {
        RtcFree(m_szAreaCode);
        m_szAreaCode = NULL;
    }

    m_szAreaCode = RtcAllocString( bstrAreaCode );

    if ( m_szAreaCode == NULL )
    {
        LOG((RTC_ERROR, "CRTCPhoneNumber::put_AreaCode - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    // LOG((RTC_TRACE, "CRTCPhoneNumber::put_AreaCode - exit S_OK"));

    return S_OK;
} 
        
/////////////////////////////////////////////////////////////////////////////
//
// CRTCPhoneNumber::get_AreaCode
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCPhoneNumber::get_AreaCode(
        BSTR * pbstrAreaCode
        )
{
    // LOG((RTC_TRACE, "CRTCPhoneNumber::get_AreaCode - enter"));

    if ( IsBadWritePtr( pbstrAreaCode, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCPhoneNumber::get_AreaCode - "
                            "bad string pointer"));

        return E_POINTER;
    }

    if ( m_szAreaCode == NULL )
    {
        LOG((RTC_ERROR, "CRTCPhoneNumber::get_AreaCode - "
                            "no string"));

        return E_FAIL;
    }

    *pbstrAreaCode = SysAllocString( m_szAreaCode );

    if ( *pbstrAreaCode == NULL )
    {
        LOG((RTC_ERROR, "CRTCPhoneNumber::get_AreaCode - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    // LOG((RTC_TRACE, "CRTCPhoneNumber::get_AreaCode - exit S_OK"));

    return S_OK;
} 
        
/////////////////////////////////////////////////////////////////////////////
//
// CRTCPhoneNumber::put_Number
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCPhoneNumber::put_Number(
        BSTR bstrNumber
        )
{
    // LOG((RTC_TRACE, "CRTCPhoneNumber::put_Number - enter"));

    if ( IsBadStringPtrW( bstrNumber, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCPhoneNumber::put_Number - "
                            "bad string pointer"));

        return E_POINTER;
    }

    if ( m_szNumber != NULL )
    {
        RtcFree(m_szNumber);
        m_szNumber = NULL;
    }

    m_szNumber = RtcAllocString( bstrNumber );

    if ( m_szNumber == NULL )
    {
        LOG((RTC_ERROR, "CRTCPhoneNumber::put_Number - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    // LOG((RTC_TRACE, "CRTCPhoneNumber::put_Number - exit S_OK"));

    return S_OK;
} 
        
/////////////////////////////////////////////////////////////////////////////
//
// CRTCPhoneNumber::get_Number
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCPhoneNumber::get_Number(
        BSTR * pbstrNumber
        )
{
    // LOG((RTC_TRACE, "CRTCPhoneNumber::get_Number - enter"));

    if ( IsBadWritePtr( pbstrNumber, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCPhoneNumber::get_Number - "
                            "bad string pointer"));

        return E_POINTER;
    }

    if ( m_szNumber == NULL )
    {
        LOG((RTC_ERROR, "CRTCPhoneNumber::get_Number - "
                            "no string"));

        return E_FAIL;
    }

    *pbstrNumber = SysAllocString( m_szNumber );

    if ( *pbstrNumber == NULL )
    {
        LOG((RTC_ERROR, "CRTCPhoneNumber::get_Number - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    // LOG((RTC_TRACE, "CRTCPhoneNumber::get_Number - exit S_OK"));

    return S_OK;
} 
        
/////////////////////////////////////////////////////////////////////////////
//
// CRTCPhoneNumber::put_Canonical
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCPhoneNumber::put_Canonical(
        BSTR bstrCanonical
        )
{
    // LOG((RTC_TRACE, "CRTCPhoneNumber::put_Canonical - enter"));

    if ( IsBadStringPtrW( bstrCanonical, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCPhoneNumber::put_Canonical - "
                            "bad string pointer"));

        return E_POINTER;
    }

    //
    // A canonical number is of the form +1 (425) 555-1212.
    //
    // For now we "parse" very simply!
    //

    int     iResult;
    WCHAR   szAreaCode[ 256 ];
    WCHAR   szNumber  [ 256 ];
    DWORD   dwCountryCode;
    WCHAR * szAreaCodeWithoutParens = szAreaCode;

    iResult = swscanf(
        bstrCanonical,
        L"+%d %s %s",
        & dwCountryCode,
        & szAreaCode,
        & szNumber
        );
        
    if ( iResult == 3 )
    {
        //
        // Make sure first and last characters in szAreaCode
        // are the parens. If not, clobber iResult to trigger
        // areacodeless parsing. If they are, remove the parens.
        //

        DWORD dwLen = lstrlenW(szAreaCodeWithoutParens);

        if ( ( szAreaCodeWithoutParens[ 0 ] == L'(' ) &&
             ( szAreaCodeWithoutParens[dwLen - 1 ] == L')' ) )
        {
            // remove the parens
            szAreaCodeWithoutParens[ dwLen - 1 ] = L'\0';
            szAreaCodeWithoutParens++;
        }
        else
        {
            iResult = 2; // no valid area code
        }
    }

    if ( iResult != 3 )
    {
        LOG((RTC_WARN, "CRTCPhoneNumber::put_Canonical - "
                            "not in canonical format with area code; trying "
                            "without area code"));

        szAreaCode[0] = L'\0';

        iResult = swscanf(
            bstrCanonical,
            L"+%d %s",
            & dwCountryCode,
            & szNumber
            );

        if ( iResult != 2 )
        {
        
            LOG((RTC_ERROR, "CRTCPhoneNumber::put_Canonical - "
                                "not in canonical format"));

            return E_FAIL;
        }
    }

    //
    // Allocate dynamic space for the strings.
    // In all cases, szAreaCodeWithoutParens points to the first
    // character of the area code string that we really want.
    //

    WCHAR * szAreaCodeDynamic;
    WCHAR * szNumberDynamic;

    szAreaCodeDynamic = RtcAllocString( szAreaCodeWithoutParens );

    if ( szAreaCodeDynamic == NULL )
    {
        LOG((RTC_ERROR, "CRTCPhoneNumber::put_Canonical - "
                            "E_OUTOFMEMORY on area code"));

        return E_OUTOFMEMORY;
    }
    
    szNumberDynamic = RtcAllocString( szNumber );

    if ( szNumberDynamic == NULL )
    {
        LOG((RTC_ERROR, "CRTCPhoneNumber::put_Canonical - "
                            "E_OUTOFMEMORY on local number"));

        RtcFree( szAreaCodeDynamic );

        return E_OUTOFMEMORY;
    }

    //
    // Now set the member variables to store this number.
    //

    if ( m_szNumber != NULL )
    {
        RtcFree( m_szNumber );
    }

    m_szNumber = szNumberDynamic;

    if ( m_szAreaCode != NULL )
    {
        RtcFree( m_szAreaCode );
    }

    m_szAreaCode = szAreaCodeDynamic;

    m_dwCountryCode = dwCountryCode;

    // LOG((RTC_TRACE, "CRTCPhoneNumber::put_Canonical - exit S_OK"));

    return S_OK;
} 
        
/////////////////////////////////////////////////////////////////////////////
//
// CRTCPhoneNumber::get_Canonical
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCPhoneNumber::get_Canonical(
        BSTR * pbstrCanonical
        )
{
    // LOG((RTC_TRACE, "CRTCPhoneNumber::get_Canonical - enter"));

    if ( IsBadWritePtr( pbstrCanonical, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCPhoneNumber::get_Canonical - "
                            "bad string pointer"));

        return E_POINTER;
    }
  
    if ( m_szNumber == NULL )
    {
        LOG((RTC_ERROR, "CRTCPhoneNumber::get_Canonical - "
                            "no string"));

        return E_FAIL;
    }

    //
    // Construct the canonical string. If the area code is NULL or empty, then
    // don't include parentheses.
    //

    WCHAR szScratch[256];

    if ( ( m_szAreaCode == NULL ) || ( m_szAreaCode[0] == L'\0') )
    {
        if (_snwprintf(szScratch, 256, L"+%hd %s", LOWORD(m_dwCountryCode), m_szNumber) < 0)
        {
            LOG((RTC_ERROR, "CRTCPhoneNumber::get_Canonical - "
                            "overflow"));

            return E_FAIL;
        }
    }
    else
    {
        if (_snwprintf(szScratch, 256, L"+%hd (%s) %s", LOWORD(m_dwCountryCode), m_szAreaCode, m_szNumber) < 0)
        {
            LOG((RTC_ERROR, "CRTCPhoneNumber::get_Canonical - "
                            "overflow"));

            return E_FAIL;
        }
    }

    // LOG((RTC_INFO, "CRTCPhoneNumber::get_Canonical - "
    //                        "[%ws]", szScratch));

    *pbstrCanonical = SysAllocString( szScratch );

    if ( *pbstrCanonical == NULL )
    {
        LOG((RTC_ERROR, "CRTCPhoneNumber::get_Canonical - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    // LOG((RTC_TRACE, "CRTCPhoneNumber::get_Canonical - exit S_OK"));

    return S_OK;
} 
        
/////////////////////////////////////////////////////////////////////////////
//
// CRTCPhoneNumber::put_Label
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCPhoneNumber::put_Label(
        BSTR bstrLabel
        )
{
    // LOG((RTC_TRACE, "CRTCPhoneNumber::put_Label - enter"));

    if ( IsBadStringPtrW( bstrLabel, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCPhoneNumber::get_Label - "
                            "bad string pointer"));

        return E_POINTER;
    }

    if ( m_szLabel != NULL )
    {
        RtcFree(m_szLabel);
        m_szLabel = NULL;
    }

    m_szLabel = RtcAllocString( bstrLabel );

    if ( m_szLabel == NULL )
    {
        LOG((RTC_ERROR, "CRTCPhoneNumber::put_Label - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    // LOG((RTC_TRACE, "CRTCPhoneNumber::put_Label - exit S_OK"));

    return S_OK;
} 
        
/////////////////////////////////////////////////////////////////////////////
//
// CRTCPhoneNumber::get_Label
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCPhoneNumber::get_Label(
        BSTR * pbstrLabel
        )
{
    // LOG((RTC_TRACE, "CRTCPhoneNumber::get_Label - enter"));

    if ( IsBadWritePtr( pbstrLabel, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCPhoneNumber::get_Label - "
                            "bad string pointer"));

        return E_POINTER;
    }

    if ( m_szLabel == NULL )
    {
        LOG((RTC_ERROR, "CRTCPhoneNumber::get_Label - "
                            "no string"));

        return E_FAIL;
    }

    *pbstrLabel = SysAllocString( m_szLabel );

    if ( *pbstrLabel == NULL )
    {
        LOG((RTC_ERROR, "CRTCPhoneNumber::get_Label - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    // LOG((RTC_TRACE, "CRTCPhoneNumber::get_Label - exit S_OK"));

    return S_OK;
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCPhoneNumber::RegStore
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCPhoneNumber::RegStore(
        HKEY hkeyParent,
        BOOL fOverwrite
        )
{
    // LOG((RTC_TRACE, "CRTCPhoneNumber::RegStore - enter"));

    if ( m_szLabel == NULL )
    {
        LOG((RTC_ERROR, "CRTCPhoneNumber::RegStore - "
                            "no label"));

        return E_FAIL;
    }

    //
    // Open the Child key
    //

    LONG lResult;
    HKEY hkeyChild;
    DWORD dwDisposition;

    lResult = RegCreateKeyExW(
                              hkeyParent,
                              m_szLabel,
                              0,
                              NULL,
                              0,
                              KEY_WRITE,
                              NULL,
                              &hkeyChild,
                              &dwDisposition
                             );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "CRTCPhoneNumber::RegStore - "
                            "RegCreateKeyExW failed %d", lResult));
        
        return HRESULT_FROM_WIN32(lResult);
    }

    if ( (fOverwrite == FALSE) &&
         (dwDisposition == REG_OPENED_EXISTING_KEY) )
    {
        LOG((RTC_ERROR, "CRTCPhoneNumber::RegStore - "
                            "key already exists"));

        RegCloseKey( hkeyChild );

        return E_FAIL;
    }

    //
    // Store the CountryCode
    //

    lResult = RegSetValueExW(
                             hkeyChild,
                             L"CountryCode",
                             0,
                             REG_DWORD,
                             (LPBYTE)&m_dwCountryCode,
                             sizeof(DWORD)
                            );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "CRTCPhoneNumber::RegStore - "
                            "RegSetValueEx failed %d", lResult));
        
        RegCloseKey( hkeyChild );

        return HRESULT_FROM_WIN32(lResult);
    }

    //
    // Store the AreaCode
    //

    if ( m_szAreaCode != NULL )
    {
        lResult = RegSetValueExW(
                                 hkeyChild,
                                 L"AreaCode",
                                 0,
                                 REG_SZ,
                                 (LPBYTE)m_szAreaCode,
                                 sizeof(WCHAR) * (lstrlenW(m_szAreaCode) + 1)
                                );

        if ( lResult != ERROR_SUCCESS )
        {
            LOG((RTC_ERROR, "CRTCPhoneNumber::RegStore - "
                                "RegSetValueEx failed %d", lResult));
        
            RegCloseKey( hkeyChild );

            return HRESULT_FROM_WIN32(lResult);
        }
    }
    else
    {
        lResult = RegDeleteValue(
                             hkeyChild,
                             _T("AreaCode")
                            );
    }

    //
    // Store the Number
    //

    if ( m_szNumber != NULL )
    {
        lResult = RegSetValueExW(
                                 hkeyChild,
                                 L"Number",
                                 0,
                                 REG_SZ,
                                 (LPBYTE)m_szNumber,
                                 sizeof(WCHAR) * (lstrlenW(m_szNumber) + 1)
                                );

        if ( lResult != ERROR_SUCCESS )
        {
            LOG((RTC_ERROR, "CRTCPhoneNumber::RegStore - "
                                "RegSetValueEx failed %d", lResult));
        
            RegCloseKey( hkeyChild );

            return HRESULT_FROM_WIN32(lResult);
        }
    }
    else
    {
        lResult = RegDeleteValue(
                             hkeyChild,
                             _T("Number")
                            );
    }

    //
    // Close the key
    //

    RegCloseKey( hkeyChild );

    // LOG((RTC_TRACE, "CRTCPhoneNumber::RegStore - exit S_OK"));

    return S_OK;
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCPhoneNumber::RegRead
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCPhoneNumber::RegRead(
        HKEY hkeyParent
        )
{
    // LOG((RTC_TRACE, "CRTCPhoneNumber::RegRead - enter"));

    if ( m_szLabel == NULL )
    {
        LOG((RTC_ERROR, "CRTCPhoneNumber::RegRead - "
                            "no label"));

        return E_FAIL;
    }

    //
    // Open the Child key
    //

    LONG lResult;
    HKEY hkeyChild;

    lResult = RegOpenKeyExW(
                            hkeyParent,
                            m_szLabel,
                            0,
                            KEY_READ,                         
                            &hkeyChild
                           );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "CRTCPhoneNumber::RegRead - "
                            "RegOpenKeyExW failed %d", lResult));
        
        return HRESULT_FROM_WIN32(lResult);
    }

    //
    // Read the CountryCode
    //

    DWORD cbSize = sizeof(DWORD);

    lResult = RegQueryValueExW(
                               hkeyChild,
                               L"CountryCode",
                               0,
                               NULL,
                               (LPBYTE)&m_dwCountryCode,
                               &cbSize
                              );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "CRTCPhoneNumber::RegRead - "
                            "RegQueryValueExW(CountryCode) failed %d", lResult));
    }

    //
    // Read the AreaCode
    //

    m_szAreaCode = RtcRegQueryString( hkeyChild, L"AreaCode" );

    if ( m_szAreaCode == NULL )
    {
        LOG((RTC_ERROR, "CRTCPhoneNumber::RegRead - "
                            "RtcRegQueryString(AreaCode) failed"));
    }

    //
    // Read the Number
    //

    m_szNumber = RtcRegQueryString( hkeyChild, L"Number" );

    if ( m_szNumber == NULL )
    {
        LOG((RTC_ERROR, "CRTCPhoneNumber::RegRead - "
                            "RtcRegQueryString(Number) failed"));
    }

    //
    // Close the key
    //

    RegCloseKey( hkeyChild );

    // LOG((RTC_TRACE, "CRTCPhoneNumber::RegRead - exit S_OK"));

    return S_OK;
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCPhoneNumber::RegDelete
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCPhoneNumber::RegDelete(
        HKEY hkeyParent
        )
{
    // LOG((RTC_TRACE, "CRTCPhoneNumber::RegDelete - enter"));

    if ( m_szLabel == NULL )
    {
        LOG((RTC_ERROR, "CRTCPhoneNumber::RegDelete - "
                            "no label"));

        return E_FAIL;
    }

    //
    // Delete the Child key
    //

    LONG lResult;
    HKEY hkeyChild;

    lResult = RegDeleteKeyW(
                            hkeyParent,
                            m_szLabel
                           );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "CRTCPhoneNumber::RegDelete - "
                            "RegDeleteKeyW failed %d", lResult));
        
        return HRESULT_FROM_WIN32(lResult);
    }

    // LOG((RTC_TRACE, "CRTCPhoneNumber::RegDelete - exit S_OK"));

    return S_OK;
}





/////////////////////////////////////////////////////////////////////////////
// 
// Phone number helpers
//
/////////////////////////////////////////////////////////////////////////////

HRESULT StoreLocalPhoneNumber(
            IRTCPhoneNumber * pPhoneNumber,
            VARIANT_BOOL fOverwrite
            )
{
    LOG((RTC_TRACE, "StoreLocalPhoneNumber - enter"));

    LONG lResult;
    HKEY hkeyContact;

    //
    // Open the Contact key
    //

    lResult = RegCreateKeyEx(
                             HKEY_CURRENT_USER,
                             _T("Software\\Microsoft\\Phoenix\\Contact"),
                             0,
                             NULL,
                             0,
                             KEY_WRITE,
                             NULL,
                             &hkeyContact,
                             NULL
                            );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "StoreLocalPhoneNumber - "
                            "RegCreateKeyEx(Contact) failed %d", lResult));
        
        return HRESULT_FROM_WIN32(lResult);
    }

    //
    // Store the phone number
    //

    CRTCPhoneNumber * pCPhoneNumber = NULL;

    pCPhoneNumber = static_cast<CRTCPhoneNumber *>(pPhoneNumber);

    HRESULT hr;

    hr = pCPhoneNumber->RegStore( hkeyContact, fOverwrite ? TRUE : FALSE );

    //
    // Close the Contact key
    //

    RegCloseKey(hkeyContact);    

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "StoreLocalPhoneNumber - "
                            "RegStore failed 0x%lx", hr));
        
        return hr;
    }

    LOG((RTC_TRACE, "StoreLocalPhoneNumber - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT  DeleteLocalPhoneNumber(
            IRTCPhoneNumber * pPhoneNumber
            )
{
    LOG((RTC_TRACE, "DeleteLocalPhoneNumber - enter"));

    LONG lResult;
    HKEY hkeyContact;

    //
    // Open the Contact key
    //

    lResult = RegCreateKeyEx(
                             HKEY_CURRENT_USER,
                             _T("Software\\Microsoft\\Phoenix\\Contact"),
                             0,
                             NULL,
                             0,
                             KEY_WRITE,
                             NULL,
                             &hkeyContact,
                             NULL
                            );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "DeleteLocalPhoneNumber - "
                            "RegCreateKeyEx(Contact) failed %d", lResult));
        
        return HRESULT_FROM_WIN32(lResult);
    }

    //
    // Delete the phone number
    //

    CRTCPhoneNumber * pCPhoneNumber = NULL;

    pCPhoneNumber = static_cast<CRTCPhoneNumber *>(pPhoneNumber);

    HRESULT hr;

    hr = pCPhoneNumber->RegDelete( hkeyContact );

    //
    // Close the Contact key
    //

    RegCloseKey(hkeyContact);

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "DeleteLocalPhoneNumber - "
                            "RegDelete failed 0x%lx", hr));
        
        return hr;
    }

    LOG((RTC_TRACE, "DeleteLocalPhoneNumber - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//
HRESULT EnumerateLocalPhoneNumbers(
            IRTCEnumPhoneNumbers ** ppEnum
            )
{
    HRESULT                 hr;

    LOG((RTC_TRACE, "EnumerateLocalPhoneNumbers enter"));

    //
    // Create the enumeration
    //
 
    CComObject< CRTCEnum< IRTCEnumPhoneNumbers,
                          IRTCPhoneNumber,
                          &IID_IRTCEnumPhoneNumbers > > * p;
                          
    hr = CComObject< CRTCEnum< IRTCEnumPhoneNumbers,
                               IRTCPhoneNumber,
                               &IID_IRTCEnumPhoneNumbers > >::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "EnumerateLocalPhoneNumbers - "
                            "CreateInstance failed 0x%lx", hr));

        if ( hr == S_FALSE )
        {
            hr = E_FAIL;
        }
        
        return hr;
    }

    //
    // Initialize the enumeration (adds a reference)
    //
    
    hr = p->Initialize();

    if ( S_OK != hr )
    {
        LOG((RTC_ERROR, "EnumerateLocalPhoneNumbers - "
                            "could not initialize enumeration" ));
    
        delete p;
        return hr;
    }

    LONG lResult;
    HKEY hkeyContact;

    //
    // Open the Contact key
    //

    lResult = RegCreateKeyEx(
                             HKEY_CURRENT_USER,
                             _T("Software\\Microsoft\\Phoenix\\Contact"),
                             0,
                             NULL,
                             0,
                             KEY_READ,
                             NULL,
                             &hkeyContact,
                             NULL
                            );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "EnumerateLocalPhoneNumbers - "
                            "RegCreateKeyEx(Contact) failed %d", lResult));
        
        return HRESULT_FROM_WIN32(lResult);
    }

    //
    // Enumerate phone numbers
    //

    WCHAR szSubkey[256];
    DWORD cSize;

    for ( int n=0; TRUE; n++ )
    {
        cSize = 256;

        lResult = RegEnumKeyExW(
                                   hkeyContact,
                                   n,
                                   szSubkey,
                                   &cSize,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL
                                  );

        if ( lResult == ERROR_NO_MORE_ITEMS )
        {
            break;
        }
        else if ( lResult != ERROR_SUCCESS )
        {
            LOG((RTC_ERROR, "EnumerateLocalPhoneNumbers - "
                            "RegKeyEnumKeyExW failed %d", lResult));
        
            p->Release();
            RegCloseKey( hkeyContact );

            return HRESULT_FROM_WIN32(lResult);
        }
        
        //
        // Create the phone number
        //

        IRTCPhoneNumber * pPhoneNumber = NULL;
        
        hr = CreatePhoneNumber( 
                               &pPhoneNumber
                              );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "EnumerateLocalPhoneNumbers - "
                                "CreatePhoneNumber failed 0x%lx", hr));
            
            p->Release();
            RegCloseKey( hkeyContact );

            return hr;
        } 

        //
        // Set the label
        //

        hr = pPhoneNumber->put_Label(szSubkey);

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "EnumerateLocalPhoneNumbers - "
                                "put_Label failed 0x%lx", hr));
        
            p->Release();
            RegCloseKey( hkeyContact );

            return hr;
        }

        //
        // Read the phone number
        //

        CRTCPhoneNumber * pCPhoneNumber = NULL;

        pCPhoneNumber = static_cast<CRTCPhoneNumber *>(pPhoneNumber);
        
        hr = pCPhoneNumber->RegRead( hkeyContact );

        if ( FAILED(hr) )
        {
            LOG((RTC_WARN, "EnumerateLocalPhoneNumbers - "
                                "RegRead failed 0x%lx", hr));

            pPhoneNumber->Release();

            //
            // Just skip this entry...
            //
            continue;
        } 

        //
        // Add the phone number to the enumeration
        //

        hr = p->Add( pPhoneNumber );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "EnumerateLocalPhoneNumbers - "
                                "Add failed 0x%lx", hr));

            p->Release();
            pPhoneNumber->Release();
            RegCloseKey( hkeyContact );
            
            return hr;
        } 

        //
        // Release our reference
        //
        
        pPhoneNumber->Release();
    }

    RegCloseKey( hkeyContact );

    *ppEnum = p;

    LOG((RTC_TRACE, "EnumerateLocalPhoneNumbers - exit S_OK"));

    return S_OK;
} 

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CreatePhoneNumber(
            IRTCPhoneNumber ** ppPhoneNumber
            )
{
    HRESULT hr;
    
    LOG((RTC_TRACE, "CreatePhoneNumber - enter"));
    
    //
    // Create the phone number
    //

    CComObject<CRTCPhoneNumber> * pCPhoneNumber;
    hr = CComObject<CRTCPhoneNumber>::CreateInstance( &pCPhoneNumber );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CreatePhoneNumber - "
                            "CreateInstance failed 0x%lx", hr));

        if ( hr == S_FALSE )
        {
            hr = E_FAIL;
        }
            
        return hr;
    }

    //
    // Get the IRTCPhoneNumber interface
    //

    IRTCPhoneNumber * pPhoneNumber = NULL;

    hr = pCPhoneNumber->QueryInterface(
                           IID_IRTCPhoneNumber,
                           (void **)&pPhoneNumber
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CreatePhoneNumber - "
                            "QI failed 0x%lx", hr));
        
        delete pCPhoneNumber;
        
        return hr;
    }
   
    *ppPhoneNumber = pPhoneNumber;

    LOG((RTC_TRACE, "CreatePhoneNumber - exit S_OK"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\util\rtcphonenumber.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCPhoneNumber.h

Abstract:

    Definition of the CRTCPhoneNumber class

--*/

#ifndef __RTCPHONENUMBER__
#define __RTCPHONENUMBER__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


/////////////////////////////////////////////////////////////////////////////
// CRTCPhoneNumber

class ATL_NO_VTABLE CRTCPhoneNumber : 
    public IRTCPhoneNumber, 
	public CComObjectRoot
{
public:
    CRTCPhoneNumber() : m_dwCountryCode(1),
                        m_szAreaCode(NULL),
                        m_szNumber(NULL),
                        m_szLabel(NULL)
    {}
    
BEGIN_COM_MAP(CRTCPhoneNumber)
    COM_INTERFACE_ENTRY(IRTCPhoneNumber)
END_COM_MAP()

    HRESULT FinalConstruct();

    void FinalRelease();   

    HRESULT RegStore(
        HKEY hkeyParent,
        BOOL fOverwrite
        );

    HRESULT RegRead(
        HKEY hkeyParent
        );

    HRESULT RegDelete(
        HKEY hkeyParent
        );

private:

    DWORD               m_dwCountryCode;
    PWSTR               m_szAreaCode;
    PWSTR               m_szNumber;
    PWSTR               m_szLabel;

#if DBG
    PWSTR               m_pDebug;
#endif
    
// IRTCPhoneNumber
public:

    STDMETHOD(put_CountryCode)(
            DWORD dwCountryCode
            );  
            
    STDMETHOD(get_CountryCode)(
            DWORD * pdwCountryCode
            );   
         
    STDMETHOD(put_AreaCode)(
            BSTR bstrAreaCode
            );  
            
    STDMETHOD(get_AreaCode)(
            BSTR * pbstrAreaCode
            ); 
            
    STDMETHOD(put_Number)(
            BSTR bstrNumber
            );  
            
    STDMETHOD(get_Number)(
            BSTR * pbstrNumber
            ); 
            
    STDMETHOD(put_Canonical)(
            BSTR bstrCanonical
            );  
            
    STDMETHOD(get_Canonical)(
            BSTR * pbstrCanonical
            );   
            
    STDMETHOD(put_Label)(
            BSTR bstrLabel
            );  
            
    STDMETHOD(get_Label)(
            BSTR * pbstrLabel
            );  

};

#endif //__RTCPHONENUMBER__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\util\rtclog.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCLog.cpp

Abstract:

    This module contains the debugging support.

--*/
#ifdef RTCLOG
#include <windows.h>
#include <stdio.h>
#include "RTCLog.h"


#define MAXDEBUGSTRINGLENGTH 512

static DWORD   sg_dwTraceID = INVALID_TRACEID;

static char    sg_szTraceName[100];   // saves name of dll
static DWORD   sg_dwTracingToDebugger = 0;
static DWORD   sg_dwTracingToConsole  = 0;
static DWORD   sg_dwTracingToFile     = 0;
static DWORD   sg_dwDebuggerMask      = 0;

/*++

Routine Description:

    Registers for tracing on a debugger if it is enabled in the registry.
    This may be called from DllMain().

Arguments:

    szName   - Component name for use in the tracing

Return Value:

    BOOL

--*/
BOOL NTAPI LogRegisterDebugger(LPCTSTR szName)
{
    HKEY       hTracingKey;

    char       szTracingKey[100];
    const char szDebuggerTracingEnableValue[] = "EnableDebuggerTracing";
    const char szTracingMaskValue[]   = "ConsoleTracingMask";

    sg_dwTracingToDebugger = 0;

#ifdef UNICODE
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%ls", szName);
#else
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%s", szName);
#endif

    if ( ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                        szTracingKey,
                                        0,
                                        KEY_READ,
                                        &hTracingKey) )
    {
        DWORD      dwDataSize = sizeof (DWORD);
        DWORD      dwDataType;

        RegQueryValueExA(hTracingKey,
                         szDebuggerTracingEnableValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwTracingToDebugger,
                         &dwDataSize);

        RegQueryValueExA(hTracingKey,
                         szTracingMaskValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwDebuggerMask,
                         &dwDataSize);

        RegCloseKey (hTracingKey);
    }

#ifdef UNICODE
    wsprintfA(sg_szTraceName, "%ls", szName);
#else
    wsprintfA(sg_szTraceName, "%s", szName);
#endif

    return TRUE;
}

/*++

Routine Description:

    Registers for tracing using the Tracing API.
    This is NOT safe to be called from DllMain().

Arguments:

    szName   - Component name for use in the tracing

Return Value:

    BOOL

--*/
BOOL NTAPI LogRegisterTracing(LPCTSTR szName)
{
    HKEY       hTracingKey;

    char       szTracingKey[100];
    const char szConsoleTracingEnableValue[] = "EnableConsoleTracing";
    const char szFileTracingEnableValue[] = "EnableFileTracing";

    sg_dwTracingToConsole = 0;
    sg_dwTracingToFile = 0; 

#ifdef UNICODE
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%ls", szName);
#else
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%s", szName);
#endif

    if ( ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                        szTracingKey,
                                        0,
                                        KEY_READ,
                                        &hTracingKey) )
    {
        DWORD      dwDataSize = sizeof (DWORD);
        DWORD      dwDataType;

        RegQueryValueExA(hTracingKey,
                         szConsoleTracingEnableValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwTracingToConsole,
                         &dwDataSize);

        RegQueryValueExA(hTracingKey,
                         szFileTracingEnableValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwTracingToFile,
                         &dwDataSize);

        RegCloseKey (hTracingKey);
    }

    sg_dwTraceID = TraceRegister(szName);

    return (sg_dwTraceID != INVALID_TRACEID);
}

/*++

Routine Description:

    DeRegisters for tracing on a debugger.
    This may be called from DllMain().

--*/
void NTAPI LogDeRegisterDebugger()
{
    sg_dwTracingToDebugger = 0;
}

/*++

Routine Description:

    DeRegisters for tracing using the Tracing API.
    This is NOT safe to be called from DllMain().

--*/
void NTAPI LogDeRegisterTracing()
{
    sg_dwTracingToConsole = 0;
    sg_dwTracingToFile = 0; 

    if (sg_dwTraceID != INVALID_TRACEID)
    {
        TraceDeregister(sg_dwTraceID);
        sg_dwTraceID = INVALID_TRACEID;
    }
}

/*++

Routine Description:

    Formats the incoming debug message & calls TraceVprintfEx to print it.

Arguments:

    dwDbgLevel   - The type of the message.

    lpszFormat - printf-style format string, followed by appropriate
                 list of arguments

Return Value:

--*/
void NTAPI LogPrint(IN DWORD dwDbgLevel, IN LPCSTR lpszFormat, IN ...)
{

    static char * message[24] = 
    {
        "ERROR", 
        "WARNING", 
        "INFO", 
        "TRACE", 
        "INVALID TRACE LEVEL"
    };

    char  szTraceBuf[MAXDEBUGSTRINGLENGTH + 1];
    
    DWORD dwIndex;

    SYSTEMTIME SystemTime;
    va_list ap;
    va_list arglist;

    if ( ( sg_dwTracingToDebugger > 0 ) &&
         ( 0 != ( dwDbgLevel & sg_dwDebuggerMask ) ) )
    {
        switch(dwDbgLevel)
        {
        case RTC_ERROR: dwIndex = 0; break;
        case RTC_WARN:  dwIndex = 1; break;
        case RTC_INFO:  dwIndex = 2; break;
        case RTC_TRACE: dwIndex = 3; break;
        default:        dwIndex = 4; break;
        }

        // retrieve local time
     
        GetLocalTime(&SystemTime);

        wsprintfA(szTraceBuf,
                  "%s:[%02u:%02u:%02u.%03u,tid=%x:]%s: ",
                  sg_szTraceName,
                  SystemTime.wHour,
                  SystemTime.wMinute,
                  SystemTime.wSecond,
                  SystemTime.wMilliseconds,
                  GetCurrentThreadId(), 
                  message[dwIndex]);

       
        va_start(ap, lpszFormat);

        _vsnprintf(&szTraceBuf[lstrlenA(szTraceBuf)], 
            MAXDEBUGSTRINGLENGTH - lstrlenA(szTraceBuf), 
            lpszFormat, 
            ap
            );

        lstrcatA (szTraceBuf, "\n");

        OutputDebugStringA (szTraceBuf);

        va_end(ap);
    }

    if (sg_dwTraceID != INVALID_TRACEID)
    {
        if ( ( sg_dwTracingToConsole > 0 ) || ( sg_dwTracingToFile > 0 ) )
        {
            switch(dwDbgLevel)
            {
            case RTC_ERROR: dwIndex = 0; break;
            case RTC_WARN:  dwIndex = 1; break;
            case RTC_INFO:  dwIndex = 2; break;
            case RTC_TRACE: dwIndex = 3; break;
            default:        dwIndex = 4; break;
            }

            wsprintfA(szTraceBuf, "%s: ", message[dwIndex]);
            
            va_start(arglist, lpszFormat);
            
            _vsnprintf(&szTraceBuf[lstrlenA(szTraceBuf)], 
                       MAXDEBUGSTRINGLENGTH - lstrlenA(szTraceBuf), 
                       lpszFormat, 
                       arglist
                       );
            
            TracePutsExA(sg_dwTraceID, dwDbgLevel, szTraceBuf);

            va_end(arglist);
#if 0  // 0 ******* Region Commented Out Begins *******
            wsprintfA(szTraceBuf, "[%s] %s", message[dwIndex], lpszFormat);

        
            va_start(arglist, lpszFormat);
            TraceVprintfExA(sg_dwTraceID, dwDbgLevel, szTraceBuf, arglist);
            va_end(arglist);
#endif // 0 ******* Region Commented Out Ends   *******
        }
    }
}
#endif //RTCLOG
// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\util\rtcuri.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    rtcuri.cpp

Abstract:

    URI helpers

--*/

#include "stdafx.h"

#define     SIP_NAMESPACE_PREFIX    L"sip:"
#define     TEL_NAMESPACE_PREFIX    L"tel:"

#define     PREFIX_LENGTH           4

/////////////////////////////////////////////////////////////////////////////
//
// AllocCleanSipString
//
/////////////////////////////////////////////////////////////////////////////

//
//      For empty string, do nothing
//      For strings that begin with "sip:", do nothing
//      For strings that begin with "tel:", replace it with "sip:"
//      For other strings, append "sip:"             
//  

HRESULT AllocCleanSipString(PCWSTR szIn, PWSTR *pszOut)
{
    HRESULT     hr;
    
    LOG((RTC_TRACE, "AllocCleanSipString - "
            "enter <%S>", szIn ? szIn : _T("(null)")));

    // If non NULL
    if( szIn != NULL )
    {
        //
        // Prealocate the new string, plus some space
        // 
        *pszOut = (PWSTR)RtcAlloc(sizeof(WCHAR) * (lstrlenW(szIn) + PREFIX_LENGTH + 1));

        if( *pszOut == NULL )
        {
            LOG((RTC_ERROR, "AllocCleanSipString - "
                    "out of memory"));

            return E_OUTOFMEMORY;
        }

        // Now copy the source
        // One NULL at the end should suffice (we don't support embedded NULLs)
        wcscpy( *pszOut, szIn );

        // empty ?
        if( *szIn == L'\0')
        {
            // do nothing
        }
        // is there a "tel:" prefix ?
        else if(_wcsnicmp(szIn, TEL_NAMESPACE_PREFIX, PREFIX_LENGTH) == 0)
        {
            // replace with SIP
            wcsncpy(*pszOut, SIP_NAMESPACE_PREFIX, PREFIX_LENGTH);
        }
        else if (_wcsnicmp(szIn, SIP_NAMESPACE_PREFIX, PREFIX_LENGTH) != 0)
        {
            // prepend SIP
            wcscpy(*pszOut, SIP_NAMESPACE_PREFIX);

            // our prefix has no embedded '\0', so concatenating works
            wcscat(*pszOut, szIn);
        }
        else
        {
            // this is a sip url, but overwrite the namespace to make sure it's lowercase
            wcsncpy(*pszOut, SIP_NAMESPACE_PREFIX, PREFIX_LENGTH);
        }
    }
    else
    {
        *pszOut = NULL;
    }

    LOG((RTC_TRACE, "AllocCleanSipString - "
            "exit <%S>", *pszOut ? *pszOut : _T("(null)")));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// AllocCleanTelString
//
/////////////////////////////////////////////////////////////////////////////

//      
//      For empty string, do nothing
//      For strings that begin with "sip:", remove it
//      For strings that begin with "tel:", remove it
//      Remove spaces and unrecognized symbols
//      Replace '(' and ')' with '-'
//      Stops if it detects a '@' or ';'             
//  

HRESULT 
AllocCleanTelString(PCWSTR szIn, PWSTR *pszOut)
{
    HRESULT     hr;
    
    LOG((RTC_TRACE, "AllocCleanTelString - "
            "enter <%S>", szIn ? szIn : _T("(null)")));

    // If non NULL
    if(szIn != NULL)
    {
        //
        // Prealocate the new string (the new length will always be less
        // than or equalt to the current length)
        // 
        *pszOut = (PWSTR)RtcAlloc(sizeof(WCHAR) * (lstrlenW(szIn) + 1));

        if( *pszOut == NULL )
        {
            LOG((RTC_ERROR, "AllocCleanTelString - "
                    "out of memory"));

            return E_OUTOFMEMORY;
        }

        WCHAR * pSrc = (WCHAR *)szIn;
        WCHAR * pDest = *pszOut;

        // is there a "tel:" prefix ?
        if (_wcsnicmp(pSrc, TEL_NAMESPACE_PREFIX, PREFIX_LENGTH) == 0)
        {
            // don't copy it
            pSrc += PREFIX_LENGTH;           
        }
        // is there a "sip:" prefix ?
        else if (_wcsnicmp(pSrc, SIP_NAMESPACE_PREFIX, PREFIX_LENGTH) == 0)
        {
            // don't copy it
            pSrc += PREFIX_LENGTH;        
        }
        
        // copy the string
        while ( *pSrc != L'\0' )
        {
            // if it is a number
            if ( ( *pSrc >= L'0' ) && ( *pSrc <= L'9' ) )
            {
                *pDest = *pSrc;
                pDest++;
            }
            // if it is a valid symbol
            else if ( ( *pSrc == L'+' ) || ( *pSrc == L'-' ) )
            {
                *pDest = *pSrc;
                pDest++;
            }
            // if it is a symbol to be converted
            else if ( ( *pSrc == L'(' ) || ( *pSrc == L')' ) )
            {
                *pDest = L'-';
                pDest++;
            }
            else if(*pSrc == L'@'  || *pSrc == L';' )
            {
                break;
            }

            pSrc++;
        }

        // adds a \0
        *pDest = L'\0';

    }
    else
    {
        *pszOut = NULL;
    }

    LOG((RTC_TRACE, "AllocCleanTelString - "
            "exit <%S>", *pszOut ? *pszOut : _T("(null)")));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// IsEqualURI
//
/////////////////////////////////////////////////////////////////////////////

BOOL
IsEqualURI(PCWSTR szA, PCWSTR szB)
{
    //
    // Skip any leading "sip:"
    //

    if( _wcsnicmp(szA, SIP_NAMESPACE_PREFIX, PREFIX_LENGTH) == 0 )
    {
        szA += PREFIX_LENGTH;
    }

    if( _wcsnicmp(szB, SIP_NAMESPACE_PREFIX, PREFIX_LENGTH) == 0 )
    {
        szB += PREFIX_LENGTH;
    }

    //
    // Skip any extra leading whitespace
    //

    while (*szA == L' ')
    {
        szA++;
    }

    while (*szB == L' ')
    {
        szB++;
    }

    //
    // Everything after a semi-colon will be thrown away as we do not want
    // to include parameters, such as "transport", in our comparision
    //

    if ((*szA == L'+') && (*szB == L'+'))
    {
        //
        // These are phone numbers. Use a comparison that ignores dashes.
        //

        while (*szA == *szB)
        {
            szA++;
            szB++;

            while (*szA == L'-')
            {
                szA++;
            }

            while (*szB == L'-')
            {
                szB++;
            }

            if ( ((*szA == L'\0') || (*szA == L';')) &&
                 ((*szB == L'\0') || (*szB == L';')) )
            {
                return TRUE;               
            }
        }

        return FALSE;
    }
    else
    {
        //
        // Do a standard string comparison.
        //

        while (tolower(*szA) == tolower(*szB))
        {
            szA++;
            szB++;

            if ( ((*szA == L'\0') || (*szA == L';')) &&
                 ((*szB == L'\0') || (*szB == L';')) )
            {
                return TRUE;               
            }
        }

        return FALSE;
    }
}

// It's just a skeleton right now, it will be enhanced with time
//
HRESULT    GetAddressType(
    LPCOLESTR pszAddress, 
    BOOL *pbIsPhoneAddress, 
    BOOL *pbIsSipURL,
    BOOL *pbIsTelURL,
    BOOL *pbIsEmailLike,
    BOOL *pbHasMaddrOrTsp)
{
    
    // NULL pointer
    if(!pszAddress)
    {
        return E_INVALIDARG;
    }

    // Empty string
    if(!*pszAddress)
    {
        return E_FAIL;
    }

    LPOLESTR pszAddressCopy = ::RtcAllocString(pszAddress);
    if (pszAddressCopy == NULL)
    {
        return E_OUTOFMEMORY;
    }

    _wcslwr(pszAddressCopy);

    *pbIsPhoneAddress = FALSE;
    *pbHasMaddrOrTsp = FALSE;
    *pbIsEmailLike = FALSE;
    
    *pbIsSipURL = FALSE;
    *pbIsTelURL = FALSE;
    
    if(wcsncmp(pszAddressCopy, L"tel:", 4) == 0)
    {
        // this is a tel: url
        *pbIsTelURL = TRUE;
        *pbIsPhoneAddress = TRUE;

        // search for a tsp param
        if(NULL!=wcsstr(pszAddressCopy, L"tsp="))
        {
            *pbHasMaddrOrTsp = TRUE;
        }
    }
    else if (wcsncmp(pszAddressCopy, L"sip:", 4) == 0)
    {
        // this is a sip url
        *pbIsSipURL = TRUE;

        // search for "user=phone"
        if(NULL != wcsstr(pszAddressCopy, L"user=phone"))
        {
            *pbIsPhoneAddress = TRUE;
        }

        // search for "maddr="
        //// or a tsp param (a R2C sip url may have this parameter)
        if(NULL != wcsstr(pszAddressCopy, L"maddr=")
        //|| NULL!=wcsstr(pszAddressCopy, L"tsp=")   
        )
        {
            *pbHasMaddrOrTsp = TRUE;
        }
    }
    else
    {
        if(*pszAddressCopy == L'+')
        {
            *pbIsPhoneAddress = TRUE;
        }
    }

    // is it email like ?
    if(NULL != wcschr(pszAddressCopy, L'@'))
    {
        *pbIsEmailLike = TRUE;
    }

    RtcFree(pszAddressCopy);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\util\statictext.cpp ===
#include "stdafx.h"
#include "statictext.h"

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CStaticText::OnEraseBkgnd(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{   
    //
    // Don't do anything here, we want a transparent background
    //

    return 1;
}

/////////////////////////////////////////////////////////////////////////////
//
//
LRESULT CStaticText::OnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // LOG((RTC_TRACE, "CStaticText::OnPaint"));
   
    PAINTSTRUCT ps;
    HDC hdc;
    RECT rc;
    
    hdc = BeginPaint(&ps);

    GetClientRect(&rc);

    TCHAR s[MAX_PATH];
    GetWindowText(s,MAX_PATH-1);

    SetBkMode(hdc,TRANSPARENT);

    if ( IsWindowEnabled() )
    {
        SetTextColor(hdc, RGB(0,0,0));
    }
    else
    {
        SetTextColor(hdc, RGB(128,128,128));
    }

    //create status bar font
    NONCLIENTMETRICS metrics;
    metrics.cbSize = sizeof(metrics);
    SystemParametersInfo(SPI_GETNONCLIENTMETRICS,sizeof(metrics),&metrics,0);

    HFONT hStatusFont = CreateFontIndirect(&metrics.lfStatusFont);
    HFONT hOrgFont = (HFONT)SelectObject(hdc, hStatusFont);

    DrawTextEx(hdc, s, _tcslen(s), &rc, m_dwFlags, NULL);

    SelectObject(hdc,hOrgFont);
    DeleteObject(hStatusFont);

    EndPaint(&ps);
    
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CStaticText::OnRefresh(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{ 
    // LOG((RTC_TRACE, "CStaticText::OnRefresh"));

    //
    // Invalidate our client rectangle in our parent's window, so the background
    // will be redrawn
    //

    RECT rc;
    HWND hwndParent;

    hwndParent = GetParent();

    GetWindowRect(&rc);

    ::MapWindowPoints( NULL, hwndParent, (LPPOINT)&rc, 2 );

    ::InvalidateRect(GetParent(), &rc, TRUE);

    //
    // Invalidate our own client rectange, so our text will get redrawn
    //

    InvalidateRect(NULL, FALSE);

    //
    // Say that we didn't handle this message, so that it will fall thru
    // to the default handler
    //

    bHandled = FALSE;

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CStaticText::OnUpdateUIState(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{ 
    // LOG((RTC_TRACE, "CStaticText::OnUpdateUIState"));

    if ((LOWORD(wParam) & UIS_CLEAR) && (HIWORD(wParam) & UISF_HIDEACCEL))
    {
        if (m_dwFlags & DT_HIDEPREFIX)
        {
            m_dwFlags &= ~DT_HIDEPREFIX;

            OnRefresh(uMsg, wParam, lParam, bHandled);
        }
    }

    bHandled = FALSE;

    return 0;
}


/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CStaticText::put_CenterHorizontal(BOOL bCenter)
{
    if (bCenter)
    {
        m_dwFlags |= DT_CENTER;
    }
    else
    {
        m_dwFlags &= ~DT_CENTER;
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CStaticText::put_CenterVertical(BOOL bCenter)
{
    if (bCenter)
    {
        m_dwFlags |= DT_VCENTER;
    }
    else
    {
        m_dwFlags &= ~DT_VCENTER;
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//
  
HRESULT CStaticText::put_WordWrap(BOOL bWrap)
{
    if (bWrap)
    {
        m_dwFlags |= DT_WORDBREAK;
    }
    else
    {
        m_dwFlags &= ~DT_WORDBREAK;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\util\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__F335F437_0358_431D_9900_DF1268BBD8EF__INCLUDED_)
#define AFX_STDAFX_H__F335F437_0358_431D_9900_DF1268BBD8EF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#define _ATL_APARTMENT_THREADED
#include <atlbase.h>

#include <commctrl.h>
#include <exdisp.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>
#include <atlwin.h>
#include <atlhost.h>

#include "rtclog.h"
#include "rtcmem.h"

#include <rtcutil.h>
#include <rtcutils.h>
#include <rtcenum.h>
#include <rtccore.h>
#include <ui.h>
#include <rtcuri.h>


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__F335F437_0358_431D_9900_DF1268BBD8EF__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\util\ui.cpp ===
#include "stdafx.h"
#include "rtcphonenumber.h"

#define ASSERT _ASSERTE
#define LABEL_SEPARATOR      L": "


//////////////////////////////////////////////////////////////////////////////
//
// Release all interface pointers stored in a combo box or list box itemdata
//

void CleanupListOrComboBoxInterfaceReferences(
    IN  HWND        hwndDlg,
    IN  int         nIDDlgItem,
    IN  BOOL        fUseComboBox
    )
{
    LOG((RTC_TRACE, "CleanupListOrComboBoxInterfaceReferences - enter"));

    ASSERT( IsWindow( hwndDlg ) );

    //
    // Retrieve a handle to the combo box.
    //

    HWND hwndControl;

    hwndControl = GetDlgItem(
        hwndDlg,
        nIDDlgItem
        );

    if ( hwndControl == NULL )
    {
        LOG((RTC_ERROR, "CleanupListOrComboBoxInterfaceReferences - failed to "
                        "get combo box handle - exit"));

        return;
    }

    //
    // Determine the number of items in the combo box.
    //

    DWORD dwNumItems;

    dwNumItems = (DWORD) SendMessage(
        hwndControl,
        fUseComboBox ? CB_GETCOUNT : LB_GETCOUNT,
        0,
        0
        );

    //
    // For each item, get the interface pointer stored in the itemdata
    // and release our reference to the interface pointer.
    //

    DWORD dwIndex;

    for ( dwIndex = 0; dwIndex < dwNumItems ; dwIndex++ )
    {
        IUnknown * pUnknown;

        pUnknown = (IUnknown *) SendMessage(
            hwndControl,
            fUseComboBox ? CB_GETITEMDATA : LB_GETITEMDATA,
            dwIndex,
            0
            );

        if (pUnknown != NULL)
        {
            ASSERT( ! IsBadReadPtr( pUnknown, sizeof(IUnknown) ) );

            pUnknown->Release();
        }
    }

    //
    // Clear the list.
    //

    SendMessage(
        hwndControl,
        fUseComboBox ? CB_RESETCONTENT : LB_RESETCONTENT,
        0,
        0
        );

    LOG((RTC_TRACE, "CleanupListOrComboBoxInterfaceReferences - exit S_OK"));

    return;
} 

//////////////////////////////////////////////////////////////////////////////
//
//

HRESULT PopulateCallFromList(
    IN   HWND          hwndDlg,
    IN   int           nIDDlgItem,
    IN   BOOL          fUseComboBox,
    IN   BSTR          bstrDefaultCallFrom
    )
{
    LOG((RTC_TRACE, "PopulateCallFromList - enter"));

    ASSERT( IsWindow( hwndDlg ) );

    ASSERT( ! IsBadReadPtr( pClient, sizeof( IRTCClient ) ) );

    //
    // Release references to existing list items.
    //

    CleanupListOrComboBoxInterfaceReferences(
        hwndDlg,
        nIDDlgItem,
        fUseComboBox
        );

    //
    // Retrieve a handle to the combo box.
    //

    HWND hwndControl;

    hwndControl = GetDlgItem(
        hwndDlg,
        nIDDlgItem
        );

    if ( hwndControl == NULL )
    {
        LOG((RTC_ERROR, "PopulateCallFromList - failed to "
                        "get combo box handle - exit E_FAIL"));

        return E_FAIL;
    }

    //
    // Loop through the available source phone numbers.
    //

    HRESULT hr;

    IRTCEnumPhoneNumbers * pEnumPhoneNumbers;

    hr = EnumerateLocalPhoneNumbers(
        & pEnumPhoneNumbers
        );

    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "PopulateCallFromList - failed to "
                        "enumerate phone numbers - exit 0x%08x", hr));
    
        return hr;
    }

    //
    // For each phone number, add the label concatenated with the canonical
    // string to the combo box.
    //
    // Also add as itemdata the interface pointer for each phone number.
    // This allows us to retrieve the selected phone number without having
    // to parse the displayed string (and without having to change that
    // code if the displayed string's format changes).
    //

    IRTCPhoneNumber * pPhoneNumber;

    WCHAR * wszDefault = NULL;

    while ( S_OK == pEnumPhoneNumbers->Next( 1, & pPhoneNumber, NULL ) )
    {
        //
        // Get the label.
        //

        BSTR bstrLabel;

        hr = pPhoneNumber->get_Label( & bstrLabel );

        if ( FAILED( hr ) )
        {
            LOG((RTC_ERROR, "PopulateCallFromList - failed to "
                            "get phone number label - 0x%08x - skipping", hr));

            pPhoneNumber->Release();

            continue;
        }

        //
        // Get the canonical phone number.
        //

        BSTR bstrCanonicalNumber;

        hr = pPhoneNumber->get_Canonical( &bstrCanonicalNumber );

        if ( FAILED( hr ) )
        {
            LOG((RTC_ERROR, "PopulateCallFromList - failed to "
                            "get canonical number - 0x%08x - skipping", hr));

            SysFreeString( bstrLabel );
            bstrLabel = NULL;

            pPhoneNumber->Release();

            continue;
        }

        //
        // Allocate memory for the display string.
        //

        DWORD dwDisplayLen =
            lstrlenW( bstrLabel ) +
            lstrlenW( bstrCanonicalNumber ) +
            lstrlenW( LABEL_SEPARATOR );

        WCHAR * wszDisplay =
            (WCHAR *) RtcAlloc( ( dwDisplayLen + 1 ) * sizeof( WCHAR ) );

        if ( wszDisplay == NULL )
        {
            SysFreeString( bstrLabel );

            SysFreeString( bstrCanonicalNumber );

            pPhoneNumber->Release();

            pEnumPhoneNumbers->Release();

            return E_OUTOFMEMORY;
        }

        //
        // Construct the display string.
        //

        wsprintf(
            wszDisplay,
            L"%s%s%s",
            bstrLabel,
            LABEL_SEPARATOR,
            bstrCanonicalNumber
            );
       
        //
        // Set the display string in the combo box.
        //

        LRESULT lrIndex;
    
        lrIndex = SendMessage(
            hwndControl,
            fUseComboBox ? CB_ADDSTRING : LB_ADDSTRING,
            0,
            (LPARAM) wszDisplay
            );

        //
        // Is this the default entry?
        //

        if ( (bstrDefaultCallFrom != NULL) &&
             (wcscmp( bstrCanonicalNumber, bstrDefaultCallFrom ) == 0 ) )
        {
            if ( wszDefault != NULL )
            {
                RtcFree( wszDefault );             
            }

            wszDefault = wszDisplay;
        }
        else
        {
            RtcFree( wszDisplay );
            wszDisplay = NULL;
        }

        SysFreeString( bstrLabel );
        bstrLabel = NULL;

        SysFreeString( bstrCanonicalNumber );
        bstrCanonicalNumber = NULL;

        //
        // Set the interface pointer as item data in the combo box.
        // Do not release, so that we retain a reference to the phone number object.
        //

        SendMessage(
            hwndControl,
            fUseComboBox ? CB_SETITEMDATA : LB_SETITEMDATA,
            lrIndex,
            (LPARAM) pPhoneNumber
            );
    }

    pEnumPhoneNumbers->Release();

    if ( fUseComboBox )
    {
        LRESULT lrDefaultIndex;

        lrDefaultIndex = SendMessage(
                    hwndControl,
                    CB_FINDSTRINGEXACT,
                    -1, // search from the top
                    (LPARAM) wszDefault
                    );

        if (lrDefaultIndex == CB_ERR)
        {
            lrDefaultIndex = 0;
        }

        //
        // Set the default selection.
        //

        SendMessage(
            hwndControl,
            CB_SETCURSEL,
            lrDefaultIndex, // index of item
            0
            );
    }  
    
    if ( wszDefault != NULL )
    {
        RtcFree( wszDefault );
        wszDefault = NULL;
    }

    LOG((RTC_TRACE, "PopulateCallFromList - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT GetCallFromListSelection(
    IN   HWND               hwndDlg,
    IN   int                nIDDlgItem,
    IN   BOOL               fUseComboBox,
    OUT  IRTCPhoneNumber ** ppNumber
    )
{
    HWND hwndControl;
    
    hwndControl = GetDlgItem(
        hwndDlg,
        nIDDlgItem
        );

    LRESULT lrIndex;
    
    lrIndex = SendMessage(
        hwndControl,
        fUseComboBox ? CB_GETCURSEL : LB_GETCURSEL,
        0,
        0
        );

    if ( lrIndex == ( fUseComboBox ? CB_ERR : LB_ERR ) )
    {
        return E_FAIL;
    }

    (*ppNumber) = (IRTCPhoneNumber *) SendMessage(
        hwndControl,
        fUseComboBox ? CB_GETITEMDATA : LB_GETITEMDATA,
        (WPARAM) lrIndex,
        0
        );

    ASSERT( (*ppNumber) != NULL );

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
//

HRESULT PopulateServiceProviderList(
    IN   HWND          hwndDlg,
    IN   IRTCClient  * pClient,
    IN   int           nIDDlgItem,
    IN   BOOL          fUseComboBox,
    IN   IRTCProfile * pOneShotProfile,
    IN   BSTR          bstrDefaultProfileKey, 
    IN   long          lSessionMask,
    IN   int           nIDNone
    )
{
    LOG((RTC_TRACE, "PopulateServiceProviderList - enter"));

    ASSERT( IsWindow( hwndDlg ) );

    ASSERT( ! IsBadReadPtr( pClient, sizeof( IRTCClient ) ) );
    
    //
    // Release references to existing list items.
    //

    CleanupListOrComboBoxInterfaceReferences(
        hwndDlg,
        nIDDlgItem,
        fUseComboBox
        );

    //
    // Retrieve a handle to the combo box.
    //

    HWND hwndControl;

    hwndControl = GetDlgItem(
        hwndDlg,
        nIDDlgItem
        );

    if ( hwndControl == NULL )
    {
        LOG((RTC_ERROR, "PopulateServiceProviderList - failed to "
                        "get combo box handle - exit E_FAIL"));

        return E_FAIL;
    }

    HRESULT hr;
   
    LRESULT lrIndex;

    WCHAR * wszDefault = NULL;
    
    if ( pOneShotProfile != NULL )
    {       
        //
        // Add it to the combo box. Don't query for the name, the ITSP 
        // paragraph is not valid in a one shot provisioning profile
        //

        lrIndex = SendMessage(
            hwndControl,
            fUseComboBox ? CB_ADDSTRING : LB_ADDSTRING,
            0,
            (LPARAM) _T("")
            );

        //
        // Set the interface pointer as item data in the combo box.
        //

        SendMessage(
            hwndControl,
            fUseComboBox ? CB_SETITEMDATA : LB_SETITEMDATA,
            lrIndex,
            (LPARAM) pOneShotProfile
            );

        //
        // Addref the profile so that we retain a reference
        //

        pOneShotProfile->AddRef();
    }

    //
    // Add the "None" provider, if requested
    //

    if (nIDNone)
    {
        TCHAR szString[256];

        if (LoadString(_Module.GetResourceInstance(), nIDNone, szString, 256))
        {
            lrIndex = SendMessage(
                hwndControl,
                fUseComboBox ? CB_ADDSTRING : LB_ADDSTRING,
                0,
                (LPARAM)szString
                );   
            
            if ( bstrDefaultProfileKey == NULL )
            {
                //
                // This is the default profile
                //

                if ( wszDefault != NULL )
                {
                    RtcFree( wszDefault );
                }

                wszDefault = RtcAllocString( szString );
            }
        }
    }

    if(lSessionMask != 0)
    {
        //
        // Loop through the provisioned service provider profiles if we are
        // letting the user choose a service provider.
        //

        IRTCEnumProfiles * pEnumProfiles;
        IRTCClientProvisioning * pProv;

        hr = pClient->QueryInterface(
                           IID_IRTCClientProvisioning,
                           (void **)&pProv
                          );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "PopulateServiceProviderList - "
                                "QI failed 0x%lx", hr));
        
            return hr;
        }

        hr = pProv->EnumerateProfiles(
            & pEnumProfiles
            );

        pProv->Release();

        if ( FAILED( hr ) )
        {
            LOG((RTC_ERROR, "PopulateServiceProviderList - failed to "
                            "enumerate profiles - exit 0x%08x", hr));

            return hr;
        }

        //
        // For each provider, add the provider name string to the combo box.
        //
        // This list must not be sorted
        //
        // Also add as itemdata the interface pointer for each profile.
        //

        IRTCProfile * pProfile;   

        while ( S_OK == pEnumProfiles->Next( 1, &pProfile, NULL ) )
        {
            //
            // Get the supported session types of the provider
            //
        
            long lSupportedSessions;

            hr = pProfile->get_SessionCapabilities( &lSupportedSessions );

            if ( FAILED( hr ) )
            {
                LOG((RTC_ERROR, "PopulateServiceProviderList - failed to "
                                "get session info - 0x%08x - skipping", hr));

                pProfile->Release();

                continue;
            }

            if ( !(lSupportedSessions & lSessionMask) )
            {
                LOG((RTC_WARN, "PopulateServiceProviderList - profile does"
                                "not support XXX_TO_PHONE - skipping", hr));

                pProfile->Release();

                continue;
            }

            //
            // Get the key of the provider
            //

            BSTR bstrKey; 

            hr = pProfile->get_Key( &bstrKey );

            if ( FAILED( hr ) )
            {
                LOG((RTC_ERROR, "PopulateServiceProviderList - failed to "
                                "get profile key - 0x%08x - skipping", hr));

                pProfile->Release();

                continue;
            }
    
            //
            // Get the name of the provider.
            //

            BSTR bstrName;

            hr = pProfile->get_Name( & bstrName );

            if ( FAILED( hr ) )
            {
                LOG((RTC_ERROR, "PopulateServiceProviderList - failed to "
                                "get name - 0x%08x - skipping", hr));

                SysFreeString(bstrKey);
                pProfile->Release();

                continue;
            }

            //
            // Set the provider name in the combo box.
            //

            lrIndex = SendMessage(
                hwndControl,
                fUseComboBox ? CB_ADDSTRING : LB_ADDSTRING,
                0,
                (LPARAM) bstrName
                );
           
            //
            // Set the interface pointer as item data in the combo box.
            // Do not release, so that we retain a reference to the profile.
            //

            SendMessage(
                hwndControl,
                fUseComboBox ? CB_SETITEMDATA : LB_SETITEMDATA,
                lrIndex,
                (LPARAM) pProfile
                );
    
            if ( (bstrDefaultProfileKey != NULL) &&
                 (wcscmp( bstrKey, bstrDefaultProfileKey ) == 0) )
            {
                //
                // This is the default profile
                //

                if ( wszDefault != NULL )
                {
                    RtcFree( wszDefault );
                }

                wszDefault = RtcAllocString( bstrName );
            }

            SysFreeString( bstrName );
            SysFreeString( bstrKey );
        }

        pEnumProfiles->Release();
    }

    if ( fUseComboBox )
    {       
        LRESULT lrDefaultIndex;

        lrDefaultIndex = SendMessage(
                    hwndControl,
                    CB_FINDSTRINGEXACT,
                    -1, // search from the top
                    (LPARAM) wszDefault
                    );

        if (lrDefaultIndex == CB_ERR)
        {
            lrDefaultIndex = 0;
        }

        //
        // Set the default selection.
        //

        SendMessage(
                hwndControl,
                fUseComboBox ? CB_SETCURSEL : LB_SETCURSEL,
                lrDefaultIndex, // index of item
                0
                );

    }

    if ( wszDefault != NULL )
    {
        RtcFree( wszDefault );
        wszDefault = NULL;
    }
    
    LOG((RTC_TRACE, "PopulateServiceProviderList - exit S_OK"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT GetServiceProviderListSelection(
    IN   HWND               hwndDlg,
    IN   int                nIDDlgItem,
    IN   BOOL               fUseComboBox,
    OUT  IRTCProfile     ** ppProfile
    )
{
    HWND hwndControl;
    
    hwndControl = GetDlgItem(
        hwndDlg,
        nIDDlgItem
        );

    LRESULT lrIndex;
    
    lrIndex = SendMessage(
        hwndControl,
        fUseComboBox ? CB_GETCURSEL : LB_GETCURSEL,
        0,
        0
        );

    if ( lrIndex == ( fUseComboBox ? CB_ERR : LB_ERR ) )
    {
        return E_FAIL;
    }

    (*ppProfile) = (IRTCProfile *) SendMessage(
        hwndControl,
        fUseComboBox ? CB_GETITEMDATA : LB_GETITEMDATA,
        (WPARAM) lrIndex,
        0
        );

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
//

void EnableDisableCallGroupElements(
    IN   HWND          hwndDlg,
    IN   IRTCClient  * pClient,
    IN   long          lSessionMask,
    IN   int           nIDRbComputer,
    IN   int           nIDRbPhone,
    IN   int           nIDComboCallFrom,
    IN   int           nIDComboProvider,
    OUT  BOOL        * pfCallFromComputer,
    OUT  BOOL        * pfCallFromPhone,
    OUT  BOOL        * pfCallToComputer,
    OUT  BOOL        * pfCallToPhone
    )
{
    DWORD   dwNumItems = 0;
    long    lSupportedSessions = 0;
    HRESULT hr;

    BOOL    bRbPhoneEnabled = FALSE;
    BOOL    bRbComputerEnabled = FALSE;
    BOOL    bComboCallFromEnabled = FALSE;
    
    //
    //  Cache some handles to the controls
    //

    HWND    hwndRbComputer = GetDlgItem(hwndDlg, nIDRbComputer);
    HWND    hwndRbPhone = GetDlgItem(hwndDlg, nIDRbPhone);
    HWND    hwndComboCallFrom = GetDlgItem(hwndDlg, nIDComboCallFrom);

#ifdef MULTI_PROVIDER

    HWND    hwndComboProvider = GetDlgItem(hwndDlg, nIDComboProvider);

    //
    //  Query the currently selected service provider
    //
  
    LRESULT lrIndex;

    lrIndex = SendMessage( hwndComboProvider, CB_GETCURSEL, 0, 0 );

    if ( lrIndex >= 0 )
    {
    
        IRTCProfile * pProfile;

        pProfile = (IRTCProfile *)SendMessage( hwndComboProvider, CB_GETITEMDATA, lrIndex, 0 );

        if ( (LRESULT)pProfile == CB_ERR )
        {
            LOG((RTC_ERROR, "EnableDisableCallFromGroupElements - failed to "
                            "get profile pointer"));

            return;
        }

        if ( pProfile != NULL )
        {
            hr = pProfile->get_SessionInfo( &lSupportedSessions );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "EnableDisableCallFromGroupElements - failed to "
                                "get supported sessions 0x%lx", hr));

                return;
            }
        }
        else
        {
            // The "none" provider supports PC to PC only
            lSupportedSessions = RTCSI_PC_TO_PC;
        }
    }
    else
    {
        // there's no entry in the list. Assume we support everything
        lSupportedSessions = 0xf;
    }

#else

    //
    // find supported sessions for all profiles
    //

    IRTCEnumProfiles * pEnumProfiles = NULL; 
    IRTCProfile * pProfile = NULL;

    lSupportedSessions = RTCSI_PC_TO_PC;

    if (pClient != NULL)
    {
        IRTCClientProvisioning * pProv;

        hr = pClient->QueryInterface(
                           IID_IRTCClientProvisioning,
                           (void **)&pProv
                          );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "EnableDisableCallFromGroupElements - "
                                "QI failed 0x%lx", hr));
        
            return;
        }

        hr = pProv->EnumerateProfiles( &pEnumProfiles );

        pProv->Release();

        if ( SUCCEEDED(hr) )
        {
            while ( S_OK == pEnumProfiles->Next( 1, &pProfile, NULL ) )
            {
                //
                // Get the supported session types of the provider
                //

                long lSupportedSessionsForThisProfile;

                hr = pProfile->get_SessionCapabilities( &lSupportedSessionsForThisProfile );

                if ( FAILED( hr ) )
                {
                    LOG((RTC_ERROR, "CMainFrm::OnCallFromSelect - failed to "
                                    "get session capabilities - 0x%08x - skipping", hr));

                    pProfile->Release();
                    pProfile = NULL;

                    continue;
                }

                lSupportedSessions |= lSupportedSessionsForThisProfile;  
            
                pProfile->Release();
                pProfile = NULL;
            }

            pEnumProfiles->Release();
            pEnumProfiles = NULL;
        }
    }

#endif MULTI_PROVIDER

    lSupportedSessions &= lSessionMask;

    //
    // Figure out what should be enabled based on the session types
    // supported by the provider
    //

    bRbPhoneEnabled = (lSupportedSessions & RTCSI_PHONE_TO_PHONE);
    bComboCallFromEnabled = (lSupportedSessions & RTCSI_PHONE_TO_PHONE);
    bRbComputerEnabled = (lSupportedSessions & (RTCSI_PC_TO_PHONE | RTCSI_PC_TO_PC));

    if (bRbPhoneEnabled)
    {
        //
        //  Query the number of items in the combo box
        //

        dwNumItems = (DWORD) SendMessage(
            hwndComboCallFrom,
            CB_GETCOUNT,
            0,
            0
            );

        if( dwNumItems == 0 )
        {
            //
            // If no items, disable combo
            //
            //  The radio is kept enabled

            bComboCallFromEnabled = FALSE;

        }
    }

    if (!bComboCallFromEnabled && bRbComputerEnabled)
    {
        //
        // If phone is disabled, move to computer
        //

        SendMessage(
                hwndRbComputer,
                BM_SETCHECK,
                BST_CHECKED,
                0);

        SendMessage(
                hwndRbPhone,
                BM_SETCHECK,
                BST_UNCHECKED,
                0);
    }
    else if (!bRbComputerEnabled && bRbPhoneEnabled)
    {
        //
        // If computer is disabled, move to phone
        //

        SendMessage(
                hwndRbPhone,
                BM_SETCHECK,
                BST_CHECKED,
                0);

        SendMessage(
                hwndRbComputer,
                BM_SETCHECK,
                BST_UNCHECKED,
                0);
    }
    else if (!bRbComputerEnabled && !bRbPhoneEnabled)
    {
        //
        // If both are disabled
        //

        SendMessage(
                hwndRbPhone,
                BM_SETCHECK,
                BST_UNCHECKED,
                0);

        SendMessage(
                hwndRbComputer,
                BM_SETCHECK,
                BST_UNCHECKED,
                0);
    }

    if (bComboCallFromEnabled)
    {
        //
        // Disable call from combo if radio is not selected to phone
        //

        bComboCallFromEnabled = 
                SendMessage(
                    hwndRbPhone,
                    BM_GETCHECK,
                    0,
                    0) == BST_CHECKED;
    }

    //
    // Enable / Disable
    //

    EnableWindow(hwndRbPhone, bRbPhoneEnabled);
    EnableWindow(hwndRbComputer, bRbComputerEnabled);
    EnableWindow(hwndComboCallFrom, bComboCallFromEnabled);

    if ( pfCallFromPhone )
    {
        *pfCallFromPhone = bRbPhoneEnabled;
    }

    if ( pfCallFromComputer )
    {
        *pfCallFromComputer = bRbComputerEnabled;
    }

    if ( pfCallToPhone && pfCallToComputer )
    {
#ifdef MULTI_PROVIDER
        if ( SendMessage(
                    hwndRbPhone,
                    BM_GETCHECK,
                    0, 0) == BST_CHECKED)
        {
            *pfCallToPhone = (lSupportedSessions & RTCSI_PHONE_TO_PHONE);
            *pfCallToComputer = FALSE;
        }
        else if ( SendMessage(
                    hwndRbComputer,
                    BM_GETCHECK,
                    0, 0) == BST_CHECKED)
        {
            *pfCallToPhone = (lSupportedSessions & RTCSI_PC_TO_PHONE);
            *pfCallToComputer = (lSupportedSessions & RTCSI_PC_TO_PC);
        }
        else
        {
            *pfCallToPhone = FALSE;
            *pfCallToComputer = FALSE;
        }
#else
        *pfCallToPhone = (lSupportedSessions & (RTCSI_PC_TO_PHONE | RTCSI_PHONE_TO_PHONE));
        *pfCallToComputer = (lSupportedSessions & RTCSI_PC_TO_PC);
#endif MULTI_PROVIDER  
        
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// DisplayMessage
//
// Displays a message box. The message string and caption are loaded from the
// string table based on the IDs passed in. The message box has only a
// single "OK" button.
//
// Parameters
//    hResourceInstance - handle to resource instance used to load strings
//    hwndParent        - parent window. Can be NULL.
//    nTextId           - IDS for the message string
//    nCaptionId        - IDS for the caption
//
// Return value
//    void
//

int DisplayMessage(
    IN   HINSTANCE hResourceInstance,
    IN   HWND      hwndParent,
    IN   int       nTextId,
    IN   int       nCaptionId,
    IN   UINT      uiStyle
    )
{
    const int MAXLEN = 1000;
    int retVal = 0;

    WCHAR wszText[ MAXLEN ];

    LoadString(
        hResourceInstance,
        nTextId,
        wszText,
        MAXLEN
        );

    WCHAR wszCaption[ MAXLEN ];

    LoadString(
        hResourceInstance,
        nCaptionId,
        wszCaption,
        MAXLEN
        );

    retVal = MessageBox(
        hwndParent,
        wszText,
        wszCaption,
        uiStyle
        );

    return retVal;
}

/////////////////////////////////////////////////////////////////////////////
//
//

const TCHAR * g_szPhoenixKeyName = _T("Software\\Microsoft\\Phoenix");

WCHAR *g_szSettingsStringNames[] =
{
    L"UserDisplayName",
    L"UserURI",
    L"LastAreaCode",
    L"LastNumber",
    L"LastProfile",
    L"LastAddress",
    L"LastCallFrom",
    L"WindowPosition"
};

WCHAR *g_szSettingsDwordNames[] =
{
    L"LastCountryCode",
    L"UrlRegDontAskMe",
    L"AutoAnswer",
    L"RunAtStartup",
    L"MinimizeOnClose",
    L"VideoPreview"
};

/////////////////////////////////////////////////////////////////////////////
//
// put_SettingsString
//
// This is a method that stores a settings string in
// the registry.
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
put_SettingsString(
        SETTINGS_STRING enSetting,
        BSTR bstrValue            
        )
{
    // LOG((RTC_TRACE, "put_SettingsString - enter"));

    if ( IsBadStringPtrW( bstrValue, -1 ) )
    {
        LOG((RTC_ERROR, "put_SettingsString - "
                            "bad string pointer"));

        return E_POINTER;
    }  

    //
    // Open the Phoenix key
    //

    LONG lResult;
    HKEY hkeyPhoenix;

    lResult = RegCreateKeyEx(
                             HKEY_CURRENT_USER,
                             g_szPhoenixKeyName,
                             0,
                             NULL,
                             0,
                             KEY_WRITE,
                             NULL,
                             &hkeyPhoenix,
                             NULL
                            );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "put_SettingsString - "
                            "RegCreateKeyEx(Phoenix) failed %d", lResult));
        
        return HRESULT_FROM_WIN32(lResult);
    }

    lResult = RegSetValueExW(
                             hkeyPhoenix,
                             g_szSettingsStringNames[enSetting],
                             0,
                             REG_SZ,
                             (LPBYTE)bstrValue,
                             sizeof(WCHAR) * (lstrlenW(bstrValue) + 1)
                            );

    RegCloseKey( hkeyPhoenix );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "put_SettingsString - "
                            "RegSetValueEx failed %d", lResult));

        return HRESULT_FROM_WIN32(lResult);
    }    
      
    // LOG((RTC_TRACE, "put_SettingsString - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// get_SettingsString
//
// This is a method that gets a settings string from
// the registry.
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
get_SettingsString(
        SETTINGS_STRING enSetting,
        BSTR * pbstrValue            
        )
{
    // LOG((RTC_TRACE, "get_SettingsString - enter"));

    if ( IsBadWritePtr( pbstrValue, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "get_SettingsString - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }  

    //
    // Open the Phoenix key
    //

    LONG lResult;
    HKEY hkeyPhoenix;

    lResult = RegCreateKeyEx(
                             HKEY_CURRENT_USER,
                             g_szPhoenixKeyName,
                             0,
                             NULL,
                             0,
                             KEY_READ,
                             NULL,
                             &hkeyPhoenix,
                             NULL
                            );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_WARN, "get_SettingsString - "
                            "RegCreateKeyEx(Phoenix) failed %d", lResult));
        
        return HRESULT_FROM_WIN32(lResult);
    }

    PWSTR szString = NULL;

    szString = RtcRegQueryString( hkeyPhoenix, g_szSettingsStringNames[enSetting] );        

    RegCloseKey( hkeyPhoenix );

    if ( szString == NULL )
    {
        LOG((RTC_ERROR, "get_SettingsString - "
                            "RtcRegQueryString failed"));

        return E_FAIL;
    }
    
    *pbstrValue = SysAllocString( szString );

    RtcFree( szString );

    if ( *pbstrValue == NULL )
    {
        LOG((RTC_ERROR, "get_SettingsString - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }
      
    // LOG((RTC_TRACE, "get_SettingsString - exit S_OK"));

    return S_OK;
}  

/////////////////////////////////////////////////////////////////////////////
//
// DeleteSettingsString
//
// This is a method that deletes a settings string in
// the registry.
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
DeleteSettingsString(
        SETTINGS_STRING enSetting         
        )
{
    // LOG((RTC_TRACE, "DeleteSettingsString - enter")); 

    //
    // Open the Phoenix key
    //

    LONG lResult;
    HKEY hkeyPhoenix;

    lResult = RegCreateKeyEx(
                             HKEY_CURRENT_USER,
                             g_szPhoenixKeyName,
                             0,
                             NULL,
                             0,
                             KEY_WRITE,
                             NULL,
                             &hkeyPhoenix,
                             NULL
                            );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "DeleteSettingsString - "
                            "RegCreateKeyEx(Phoenix) failed %d", lResult));
        
        return HRESULT_FROM_WIN32(lResult);
    }

    lResult = RegDeleteValueW(
                             hkeyPhoenix,
                             g_szSettingsStringNames[enSetting]
                            );

    RegCloseKey( hkeyPhoenix );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_WARN, "DeleteSettingsString - "
                            "RegDeleteValueW failed %d", lResult));

        return HRESULT_FROM_WIN32(lResult);
    }    
      
    // LOG((RTC_TRACE, "DeleteSettingsString - exit S_OK"));

    return S_OK;
}          

/////////////////////////////////////////////////////////////////////////////
//
// put_SettingsDword
//
// This is a method that stores a settings dword in
// the registry.
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
put_SettingsDword(
        SETTINGS_DWORD enSetting,
        DWORD dwValue            
        )
{
    // LOG((RTC_TRACE, "put_SettingsDword - enter"));

    //
    // Open the Phoenix key
    //

    LONG lResult;
    HKEY hkeyPhoenix;

    lResult = RegCreateKeyEx(
                             HKEY_CURRENT_USER,
                             g_szPhoenixKeyName,
                             0,
                             NULL,
                             0,
                             KEY_WRITE,
                             NULL,
                             &hkeyPhoenix,
                             NULL
                            );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "put_SettingsDword - "
                            "RegCreateKeyEx(Phoenix) failed %d", lResult));
        
        return HRESULT_FROM_WIN32(lResult);
    }

    lResult = RegSetValueExW(
                     hkeyPhoenix,
                     g_szSettingsDwordNames[enSetting],
                     0,
                     REG_DWORD,
                     (LPBYTE)&dwValue,
                     sizeof(DWORD)
                    );

    RegCloseKey( hkeyPhoenix );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "put_SettingsDword - "
                            "RegSetValueEx failed %d", lResult));

        return HRESULT_FROM_WIN32(lResult);
    }    
      
    // LOG((RTC_TRACE, "put_SettingsDword - exit S_OK"));

    return S_OK;
}            

/////////////////////////////////////////////////////////////////////////////
//
// get_SettingsDword
//
// This is a method that gets a settings dword from
// the registry.
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
get_SettingsDword(
        SETTINGS_DWORD enSetting,
        DWORD * pdwValue            
        )
{
    // LOG((RTC_TRACE, "get_SettingsDword - enter"));

    if ( IsBadWritePtr( pdwValue, sizeof(DWORD) ) )
    {
        LOG((RTC_ERROR, "get_SettingsDword - "
                            "bad DWORD pointer"));

        return E_POINTER;
    }

    //
    // Open the Phoenix key
    //

    LONG lResult;
    HKEY hkeyPhoenix;

    lResult = RegCreateKeyEx(
                             HKEY_CURRENT_USER,
                             g_szPhoenixKeyName,
                             0,
                             NULL,
                             0,
                             KEY_READ,
                             NULL,
                             &hkeyPhoenix,
                             NULL
                            );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "get_SettingsDword - "
                            "RegCreateKeyEx(Phoenix) failed %d", lResult));
        
        return HRESULT_FROM_WIN32(lResult);
    }

    DWORD cbSize = sizeof(DWORD);

    lResult = RegQueryValueExW(
                               hkeyPhoenix,
                               g_szSettingsDwordNames[enSetting],
                               0,
                               NULL,
                               (LPBYTE)pdwValue,
                               &cbSize
                              );

    RegCloseKey( hkeyPhoenix );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_WARN, "get_SettingsDword - "
                            "RegQueryValueExW failed %d", lResult));

        return HRESULT_FROM_WIN32(lResult);
    }    
      
    // LOG((RTC_TRACE, "get_SettingsDword - exit S_OK"));

    return S_OK;
}                    

/////////////////////////////////////////////////////////////////////////////
//
// DeleteSettingsDword
//
// This is a method that deletes a settings dword in
// the registry.
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
DeleteSettingsDword(
        SETTINGS_DWORD enSetting
        )
{
    // LOG((RTC_TRACE, "DeleteSettingsDword - enter"));

    //
    // Open the Phoenix key
    //

    LONG lResult;
    HKEY hkeyPhoenix;

    lResult = RegCreateKeyEx(
                             HKEY_CURRENT_USER,
                             g_szPhoenixKeyName,
                             0,
                             NULL,
                             0,
                             KEY_WRITE,
                             NULL,
                             &hkeyPhoenix,
                             NULL
                            );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "DeleteSettingsDword - "
                            "RegCreateKeyEx(Phoenix) failed %d", lResult));
        
        return HRESULT_FROM_WIN32(lResult);
    }

    lResult = RegDeleteValueW(
                     hkeyPhoenix,
                     g_szSettingsDwordNames[enSetting]
                    );

    RegCloseKey( hkeyPhoenix );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_WARN, "DeleteSettingsDword - "
                            "RegDeleteValueW failed %d", lResult));

        return HRESULT_FROM_WIN32(lResult);
    }    
      
    // LOG((RTC_TRACE, "DeleteSettingsDword - exit S_OK"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\server\buffer.h ===
typedef struct _bufferinfo
{
    DWORD           dwTotalSize;
    DWORD           dwUsedSize;
    LPBYTE          pBuffer;
    LPBYTE          pDataIn;
    LPBYTE          pDataOut;
    
} BUFFERINFO, *PBUFFERINFO;

BOOL PeekAsyncEventMsgFromQueue(
                                PBUFFERINFO         pBufferInfo,
                                PBYTE *             ppCurrent,
                                PASYNCEVENTMSG *    ppMsg,
                                DWORD *             pdwMsgSize
                               );
void RemoveAsyncEventMsgFromQueue(
                                  PBUFFERINFO       pBufferInfo,
                                  PASYNCEVENTMSG    pMsg,
                                  PBYTE *           ppCurrent
                                 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\server\buffer.c ===
////////////////////////////////////////////////////////////
//
// buffer.c
//
// this modularizes some of the circular buffer functionality
//
/////////////////////////////////////////////////////////////


#include "windows.h"
#include "assert.h"
#include "tapi.h"
#include "tspi.h"
#include "utils.h"
#include "..\client\client.h"
#include "buffer.h"

#define INVAL_KEY ((DWORD) 'LVNI')

#if DBG

extern BOOL gbBreakOnLeak;

#define ServerAlloc( __size__ ) ServerAllocReal( __size__, __LINE__, __FILE__ )

LPVOID
WINAPI
ServerAllocReal(
    DWORD dwSize,
    DWORD dwLine,
    PSTR  pszFile
    );

void
MyRealAssert(
             DWORD dwLine,
             PSTR pszFile
            );

#define MyAssert( __exp__ ) { if ( !(__exp__) ) MyRealAssert (__LINE__, __FILE__); }

#else

#define ServerAlloc( __size__ ) ServerAllocReal( __size__ )

LPVOID
WINAPI
ServerAllocReal(
    DWORD dwSize
    );

#define MyAssert( __exp__ )

#endif
    

VOID
WINAPI
ServerFree(
    LPVOID  lp
    );


///////////////////////////////////////////////////////////////////////////////
//
// PeekAsyncEventMsgFromQueue - peeks an ASYNCEVENTMSG from a circular buffer.
//      Places the next messge in the queue into the *ppMsg passed in.  pdwID
//      is used for multiple calls to this function, to save the place in the
//      buffer.  On the first call to this function, *pdwID must be 0.
//
//      If the buffer needs to be critical sectioned, it is up to the calling
//      procedure to do that.
//
//  PARAMETERS
//      pBufferInfo
//          [in] pointer to bufferinfo structure.  this does not get modified
//               since we are just doing a peek message here.
//      ppCurrent
//          [in, out] pointer to the location in the buffer
//                    where the last message was retrieved.  When this function
//                    is first called, *ppCurrent MUST be 0.  *ppCurrent is filled in
//                    if this function is successful.  *ppCurrent can be passed to
//                    subsequent calls to this function to retreive subsequent
//                    messages.  ppCurrent may not be NULL.
//      ppMsg
//          [in, out] pointer to pointer to ASYNCEVENTMSG.  Preallocated - size
//                    is in *pdwMsgSize.  May be realloced if message is too big.
//                    Uses ServerAlloc and ServerFree.
//      pdwMsgSize
//          [in, out] pointer to size of ppMsg.  Can be modified if ppMsg is realloced.
//
//
//  RETURNS

//      TRUE if a message is copied to the buffer
//
//      FALSE if a message is not copied to the buffer.  
//
////////////////////////////////////////////////////////////////////////////////////
BOOL
PeekAsyncEventMsgFromQueue(
    PBUFFERINFO         pBufferInfo,
    PBYTE              *ppCurrent,
    PASYNCEVENTMSG     *ppMsg,
    DWORD              *pdwMsgSize
    )
{
    DWORD           dwBytesToEnd;
    DWORD           dwMoveSize, dwMoveSizeWrapped;
    PBYTE           pBufferEnd, pStart;
    PASYNCEVENTMSG  pMsg;
    
    
    LOG((TL_TRACE, "Entering PeekAsyncEventMsgFromQueue"));

    MyAssert (ppCurrent);

do_it:

    if (*ppCurrent)
    {
        pStart = *ppCurrent;
    }
    else
    {
        pStart = pBufferInfo->pDataOut;
    }
    
    pMsg = *ppMsg;

    pBufferEnd = pBufferInfo->pBuffer + pBufferInfo->dwTotalSize;
    
    MyAssert(pStart < pBufferEnd);
    MyAssert(pStart >= pBufferInfo->pBuffer);
    MyAssert(*pdwMsgSize >= sizeof(ASYNCEVENTMSG));
    MyAssert(*ppMsg != NULL);

    if (pBufferInfo->dwUsedSize == 0)
    {
        LOG((TL_INFO, "GetAsyncEventMsg: dwUsedSize == 0"));
        
        return FALSE;
    }

    if ((pStart == pBufferInfo->pDataIn) ||
        ((pStart == pBufferInfo->pBuffer) &&
            (pBufferInfo->pDataIn == pBufferEnd)))
    {
        // gone through the whole buffer
        LOG((TL_TRACE, "PeekAsyncEventMsg: Gone through whole buffer"));
        
        return FALSE;
    }
    
    // Copy the fixed portion of the msg to the local buf

    // dwBytesToEnd is the number of bytes between the start
    // of copying and the end of the buffer

    dwBytesToEnd = pBufferEnd - pStart;


    // if dwBytesToEnd is greater than the fixed portion of
    // ASYNCEVENTMSG, just copy it
    // otherwise, the message wraps, so figure out where
    // it wraps.

    if (dwBytesToEnd >= sizeof (ASYNCEVENTMSG))
    {
        dwMoveSize        = sizeof (ASYNCEVENTMSG);
        dwMoveSizeWrapped = 0;
    }
    else
    {
        dwMoveSize        = dwBytesToEnd;
        dwMoveSizeWrapped = sizeof (ASYNCEVENTMSG) - dwBytesToEnd;
    }

    CopyMemory (pMsg, pStart, dwMoveSize);

    pStart += dwMoveSize;

    if (dwMoveSizeWrapped)
    {
        CopyMemory(
            ((LPBYTE) pMsg) + dwMoveSize,
            pBufferInfo->pBuffer,
            dwMoveSizeWrapped
            );

        pStart = pBufferInfo->pBuffer + dwMoveSizeWrapped;
    }

    // See if there's any extra data in this msg

    if (pMsg->dwTotalSize > sizeof (ASYNCEVENTMSG))
    {
        BOOL    bCopy = TRUE;

        LOG((TL_INFO, "GetAsyncEventMessage: Message > ASYNCEVENTMSG"));

        // See if we need to grow the msg buffer

        if (pMsg->dwTotalSize > *pdwMsgSize)
        {
            DWORD   dwNewMsgSize = pMsg->dwTotalSize + 256;

            if ((pMsg = ServerAlloc (dwNewMsgSize)))
            {
                CopyMemory(
                           pMsg,
                           *ppMsg,
                           sizeof(ASYNCEVENTMSG)
                          );

                ServerFree (*ppMsg);

                *ppMsg = pMsg;
                *pdwMsgSize = dwNewMsgSize;
            }
            else
            {
                return FALSE;
            }
        }

        // pStart has been moved to the end of the fixed portion
        // of the message.
        // dwBytesToEnd is the number of bytes between pStart and
        // the end of the buffer.

        dwBytesToEnd = pBufferEnd - pStart;


        // if dwBytesToEnd is greater than the size that we need
        // to copy...
        // otherwise, the copying wraps.

        if (dwBytesToEnd >= (pMsg->dwTotalSize - sizeof (ASYNCEVENTMSG)))
        {
            dwMoveSize        = pMsg->dwTotalSize - sizeof (ASYNCEVENTMSG);
            dwMoveSizeWrapped = 0;
        }
        else
        {
            dwMoveSize        = dwBytesToEnd;
            dwMoveSizeWrapped = (pMsg->dwTotalSize - sizeof (ASYNCEVENTMSG)) -
                                dwBytesToEnd;
        }

        CopyMemory (pMsg + 1, pStart, dwMoveSize);

        pStart += dwMoveSize;
                  
        if (dwMoveSizeWrapped)
        {
            CopyMemory(
                ((LPBYTE) (pMsg + 1)) + dwMoveSize,
                pBufferInfo->pBuffer,
                dwMoveSizeWrapped
                );

            pStart = pBufferInfo->pBuffer + dwMoveSizeWrapped;
        }
    }

    *ppCurrent = pStart;

    // check to see if it is wrapping

    if (*ppCurrent >= pBufferEnd)
    {
        *ppCurrent = pBufferInfo->pBuffer;
    }


    if (pMsg->dwMsg == INVAL_KEY)
    {
        goto do_it;
    }

    return TRUE;
}


void
RemoveAsyncEventMsgFromQueue(
    PBUFFERINFO     pBufferInfo,
    PASYNCEVENTMSG  pMsg,
    PBYTE          *ppCurrent
    )
/*++

    Removes a message retrieved by PeekAsyncEventMsgFromQueue.
    Basically, this function simply fixes up the pointers in the
    pBufferInfo structure to remove the message.

--*/
{
    DWORD           dwMsgSize;
    LPBYTE          pBuffer    = pBufferInfo->pBuffer;
    LPBYTE          pBufferEnd = pBuffer + pBufferInfo->dwTotalSize;
    PASYNCEVENTMSG  pMsgInBuf, pMsgXxx;


    dwMsgSize = pMsg->dwTotalSize;

    pMsgInBuf = (PASYNCEVENTMSG) ((*ppCurrent - dwMsgSize) >= pBuffer ?
        *ppCurrent - dwMsgSize :
        *ppCurrent + pBufferInfo->dwTotalSize - dwMsgSize
        );

    if ((LPBYTE) pMsgInBuf == pBufferInfo->pDataOut)
    {
        //
        // This is the oldest msg in the ring buffer so we can easily
        // remove it.  Then we'll loop checking each next message in the
        // queue & deleting those which have been invalidated, only
        // breaking out of the loop when there's no more msgs or we find
        // a msg that's not been invalidated.
        //

        do
        {
            if ((((LPBYTE) pMsgInBuf) + dwMsgSize) < pBufferEnd)
            {
                pBufferInfo->pDataOut = ((LPBYTE) pMsgInBuf) + dwMsgSize;
            }
            else
            {
                pBufferInfo->pDataOut = pBuffer +
                    ((((LPBYTE) pMsgInBuf) + dwMsgSize) - pBufferEnd);
            }

            if ((pBufferInfo->dwUsedSize -= dwMsgSize) == 0)
            {
                break;
            }

            pMsgInBuf = (PASYNCEVENTMSG) pBufferInfo->pDataOut;

            if ((LPBYTE) &pMsgInBuf->dwMsg <=
                    (pBufferEnd - sizeof (pMsgInBuf->dwMsg)))
            {
                if (pMsgInBuf->dwMsg != INVAL_KEY)
                {
                    break;
                }
            }
            else
            {
                pMsgXxx = (PASYNCEVENTMSG)
                    (pBuffer - (pBufferEnd - ((LPBYTE) pMsgInBuf)));

                if (pMsgXxx->dwMsg != INVAL_KEY)
                {
                    break;
                }
            }

            dwMsgSize = pMsgInBuf->dwTotalSize;

        } while (1);
    }
    else
    {
        //
        // Msg is not the oldest in the ring buffer, so mark it as invalid
        // and it'll get cleaned up later
        //

        if ((LPBYTE) &pMsgInBuf->dwMsg <=
                (pBufferEnd - sizeof (pMsgInBuf->dwMsg)))
        {
            pMsgInBuf->dwMsg = INVAL_KEY;
        }
        else
        {
            pMsgXxx = (PASYNCEVENTMSG)
                (pBuffer - (pBufferEnd - ((LPBYTE) pMsgInBuf)));

            pMsgXxx->dwMsg = INVAL_KEY;
        }
    }
}

#if DBG
void
MyRealAssert(
    DWORD   dwLine,
    PSTR    pszFile
    )
{
    LOG((TL_ERROR, "Assert in %s at line # %d", pszFile, dwLine));
    
    if (gbBreakOnLeak)
    {
        DebugBreak();
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\server\event.c ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    event.c

Abstract:

    Src module for tapi event filtering funcs

Author:

    Xiaohai Zhang (xzhang)    24-Nov-1999

Revision History:

--*/

#include "windows.h"
#include "tapi.h"
#include "tspi.h"
#include "client.h"
#include "loc_comn.h"
#include "server.h"
#include "private.h"
#include "tapihndl.h"
#include "utils.h"

extern BOOL    gbNTServer;

//
//  GetSubMaskIndex
//  Description:
//      Get the index into the submask array in vairous TAPI server object
//      from the event mask, there should be one and only one bit set in
//      ulEventMask
//  Parameters:
//      ulEventMask : the mask whose submask index to be returned
//  Return Value:
//      The index of the message mask in ulEventMask
//

DWORD
GetSubMaskIndex (ULONG64   ulEventMask)
{
    DWORD dwSubMaskIndex;

    //  Assert that there is one and only one bit set in ulEventMask
    ASSERT (ulEventMask !=0 && (ulEventMask & (ulEventMask - 1)) == 0);

    dwSubMaskIndex = 0;
    while (ulEventMask > 1)
    {
    	ulEventMask >>= 1;
    	++dwSubMaskIndex;
    }

    return dwSubMaskIndex;
}

//
//  GetMsgMask
//  Description:
//      Utility function to get corresponding msg mask and its submask index
//  Parameters:
//      Msg     : whose mask and submask index to be returned
//      pulMask : address to hold the returned mask
//      pdwSubMaskIndex : address to hold the returned submask index
//  Return Value:
//      TRUE if there exists a mask defined for the Msg, otherwise FALSE
//

BOOL
GetMsgMask (DWORD Msg, ULONG64 * pulMask, DWORD *pdwSubMaskIndex)
{
    ULONG64     ulMask;
    DWORD       dwSubMaskIndex;

    if (NULL == pulMask ||
        NULL == pdwSubMaskIndex)
    {
        ASSERT (0);
        return FALSE;
    }

    switch (Msg)
    {
    case LINE_ADDRESSSTATE:
        ulMask = EM_LINE_ADDRESSSTATE;
        break;
    case LINE_LINEDEVSTATE:
        ulMask = EM_LINE_LINEDEVSTATE;
        break;
    case LINE_CALLINFO:
        ulMask = EM_LINE_CALLINFO;
        break;
    case LINE_CALLSTATE:
        ulMask = EM_LINE_CALLSTATE;
        break;
    case LINE_APPNEWCALL:
        ulMask = EM_LINE_APPNEWCALL;
        break;
    case LINE_CREATE:
        ulMask = EM_LINE_CREATE;
        break;
    case LINE_REMOVE:
        ulMask = EM_LINE_REMOVE;
        break;
    case LINE_CLOSE:
        ulMask = EM_LINE_CLOSE;
        break;
//    case LINE_PROXYREQUEST:
//        ulMask = EM_LINE_PROXYREQUEST;
//        break;
    case LINE_DEVSPECIFIC:
        ulMask = EM_LINE_DEVSPECIFIC;
        break;
    case LINE_DEVSPECIFICFEATURE:
        ulMask = EM_LINE_DEVSPECIFICFEATURE;
        break;
    case LINE_AGENTSTATUS:
        ulMask = EM_LINE_AGENTSTATUS;
        break;
    case LINE_AGENTSTATUSEX:
        ulMask = EM_LINE_AGENTSTATUSEX;
        break;
    case LINE_AGENTSPECIFIC:
        ulMask = EM_LINE_AGENTSPECIFIC;
        break;
    case LINE_AGENTSESSIONSTATUS:
        ulMask = EM_LINE_AGENTSESSIONSTATUS;
        break;
    case LINE_QUEUESTATUS:
        ulMask = EM_LINE_QUEUESTATUS;
        break;
    case LINE_GROUPSTATUS:
        ulMask = EM_LINE_GROUPSTATUS;
        break;
//    case LINE_PROXYSTATUS:
//        ulMask = EM_LINE_PROXYSTATUS;
//        break;
    case LINE_APPNEWCALLHUB:
        ulMask = EM_LINE_APPNEWCALLHUB;
        break;
    case LINE_CALLHUBCLOSE:
        ulMask = EM_LINE_CALLHUBCLOSE;
        break;
    case LINE_DEVSPECIFICEX:
        ulMask = EM_LINE_DEVSPECIFICEX;
        break;
    case LINE_QOSINFO:
        ulMask = EM_LINE_QOSINFO;
        break;
    case PHONE_CREATE:
        ulMask =  EM_PHONE_CREATE;
        break;
    case PHONE_REMOVE:
        ulMask = EM_PHONE_REMOVE;
        break;
    case PHONE_CLOSE:
        ulMask = EM_PHONE_CLOSE;
        break;
    case PHONE_STATE:
        ulMask = EM_PHONE_STATE;
        break;
    case PHONE_DEVSPECIFIC:
        ulMask = EM_PHONE_DEVSPECIFIC;
        break;
    case PHONE_BUTTON:
        ulMask = EM_PHONE_BUTTONMODE;
        break;
    default:
        ulMask = 0;
    }

    if (ulMask != 0)
    {
	    *pulMask = ulMask;
    	*pdwSubMaskIndex = GetSubMaskIndex(ulMask);
    }
    
    return (ulMask ? TRUE : FALSE);
}

//
//  FMsgDisabled
//  Description:
//      Utility function used throughout tapisrv to check if a message
//      is allowed to be sent or not.
//  Parameters:
//      dwAPIVersion    : the object API version
//      adwEventSubMasks: the object submasks array
//      Msg             : the message to be checked
//      dwParam1        : the sub message of Msg to be checked
//  Return Value:
//      TRUE if the message should NOT be sent, otherwise FALSE
//

BOOL
FMsgDisabled (
    DWORD       dwAPIVersion,
    DWORD       *adwEventSubMasks,
    DWORD       Msg,
    DWORD       dwParam1
    )
{
    BOOL        fRet;
    ULONG64     ulMsgMask;
    DWORD       dwSubMaskIndex;

    if (dwAPIVersion <= TAPI_VERSION3_0)
    {
        LOG((TL_INFO, "FMsgDisbled: dwAPIVersion<= TAPI_VERSION3_0, msg will be enabled"));
        fRet = FALSE;
        goto ExitHere;
    }

    //
    //  The message is allowed to be sent if
    //      (1). No event mask defined for Msg, i.e LINE_REPLY
    //      (2). Msg is enabled for all submasks adwEventSubMasks[index] = (-1)
    //      (3). SubMask enabled: adwEventSubMask[index] & dwParam1 != 0
    //
    
    if (!GetMsgMask(Msg, &ulMsgMask, &dwSubMaskIndex) ||
        adwEventSubMasks[dwSubMaskIndex] == (-1) ||
        ((adwEventSubMasks[dwSubMaskIndex] & dwParam1) != 0))
    {
        fRet = FALSE;
    }
    else
    {
        fRet = TRUE;
    }

ExitHere:
    LOG((TL_TRACE, "FMsgDisabled return %x", fRet));
    return (fRet);
}

//
//  SetEventMasksOrSubMasks
//  Description:
//      Utility function used to apply masks or submasks to a certain objects
//      submasks array. 
//  Parameters:
//      fSubMask        : this function is called for submasks
//      ulEventMasks    : the masks to be set if fSubMask is true or the mask
//                        whose submasks is to be set
//      dwEventSubMasks : the submasks to be set, ignored if fSubMask is FALSE
//      adwEventSubMasks: the submasks array from the object
//  Return Value:
//      Always succeed.
//

LONG
SetEventMasksOrSubMasks (
    BOOL            fSubMask,
    ULONG64         ulEventMasks,
    DWORD           dwEventSubMasks,
    DWORD          *adwTargetSubMasks
    )
{
    ULONG64         ulMask = 1;
    LONG            lResult = S_OK;
    DWORD           dwIndex = 0;

    if (NULL == adwTargetSubMasks)
    {
        ASSERT (0);
        return LINEERR_INVALPOINTER;
    }

    if (fSubMask)
    {
        dwIndex = GetSubMaskIndex(ulEventMasks);
        adwTargetSubMasks[dwIndex] = dwEventSubMasks;
    }
    else
    {
        for (dwIndex = 0; dwIndex < EM_NUM_MASKS; ++dwIndex)
        {
            adwTargetSubMasks[dwIndex] = ((ulMask & ulEventMasks) ? (-1) : 0);
            ulMask <<= 1;
        }
    }

    return lResult;
}

//
//  SettCallClientEventMasks
//  Description:
//      Apply the masks or submasks on a call object. 
//  Parameters:
//      ptCallClient    : the call object to apply the masking
//      fSubMask        : this function is called for submasks
//      ulEventMasks    : the masks to be set if fSubMask is true or the mask
//                        whose submasks is to be set
//      dwEventSubMasks : the submasks to be set, ignored if fSubMask is FALSE
//  Return Value:
//

LONG
SettCallClientEventMasks (
    PTCALLCLIENT    ptCallClient,
    BOOL            fSubMask,
    ULONG64         ulEventMasks,
    DWORD           dwEventSubMasks
    )
{
    LONG        lResult = S_OK;
    BOOL        bLocked = TRUE;

    if (!WaitForExclusivetCallAccess (ptCallClient->ptCall, TCALL_KEY))
    {
        bLocked = FALSE;
        lResult = LINEERR_OPERATIONFAILED;
        goto ExitHere;
    }

    if (ptCallClient->ptLineClient->ptLineApp->dwAPIVersion <= TAPI_VERSION3_0)
    {
        goto ExitHere;
    }

    lResult = SetEventMasksOrSubMasks (
        fSubMask,
        ulEventMasks,
        dwEventSubMasks,
        ptCallClient->adwEventSubMasks
        );


ExitHere:
    if (bLocked)
    {
        UNLOCKTCALL (ptCallClient->ptCall);
    }
    return lResult;
}

//
//  SettLineClientEventMasks
//  Description:
//      Apply the masks or submasks on a tLineClient object. 
//  Parameters:
//      ptLineClient    : the line object to apply the masking
//      fSubMask        : this function is called for submasks
//      ulEventMasks    : the masks to be set if fSubMask is true or the mask
//                        whose submasks is to be set
//      dwEventSubMasks : the submasks to be set, ignored if fSubMask is FALSE
//  Return Value:
//

LONG
SettLineClientEventMasks (
    PTLINECLIENT    ptLineClient,
    BOOL            fSubMask,
    ULONG64         ulEventMasks,
    DWORD           dwEventSubMasks
    )
{
    LONG            lResult = S_OK;
    PTCALLCLIENT    ptCallClient;

    LOCKTLINECLIENT (ptLineClient);
    if (ptLineClient->dwKey != TLINECLIENT_KEY)
    {
        lResult = LINEERR_OPERATIONFAILED;
        goto ExitHere;
    }

    if (ptLineClient->ptLineApp->dwAPIVersion <= \
        TAPI_VERSION3_0)
    {
        goto ExitHere;
    }

    lResult = SetEventMasksOrSubMasks (
        fSubMask,
        ulEventMasks,
        dwEventSubMasks,
        ptLineClient->adwEventSubMasks
        );
    if (lResult)
    {
        goto ExitHere;
    }

    ptCallClient = ptLineClient->ptCallClients;
    while (ptCallClient)
    {
        lResult = SettCallClientEventMasks (
            ptCallClient,
            fSubMask,
            ulEventMasks,
            dwEventSubMasks
            );
        if (lResult)
        {
            goto ExitHere;
        }
        ptCallClient = ptCallClient->pNextSametLineClient;
    }
    
ExitHere:
    UNLOCKTLINECLIENT (ptLineClient);
    return lResult;
}

//
//  SettLineAppEventMasks
//  Description:
//      Apply the masks or submasks on a tLineApp object. 
//  Parameters:
//      ptLineApp       : the tLineApp object to apply the masking
//      fSubMask        : this function is called for submasks
//      ulEventMasks    : the masks to be set if fSubMask is true or the mask
//                        whose submasks is to be set
//      dwEventSubMasks : the submasks to be set, ignored if fSubMask is FALSE
//  Return Value:
//

LONG
SettLineAppEventMasks (
    PTLINEAPP       ptLineApp,
    BOOL            fSubMask,
    ULONG64         ulEventMasks,
    DWORD           dwEventSubMasks
    )
{
    PTLINECLIENT        ptLineClient;
    LONG                lResult = S_OK;

    LOCKTLINEAPP (ptLineApp);
    if (ptLineApp->dwKey != TLINEAPP_KEY)
    {
        lResult = LINEERR_OPERATIONFAILED;
        goto ExitHere;
    }
    
    if (ptLineApp->dwAPIVersion <= TAPI_VERSION3_0)
    {
        lResult = LINEERR_OPERATIONUNAVAIL;
        goto ExitHere;
    }

    lResult = SetEventMasksOrSubMasks (
        fSubMask,
        ulEventMasks,
        dwEventSubMasks,
        ptLineApp->adwEventSubMasks
        );
    if (lResult)
    {
        goto ExitHere;
    }

    ptLineClient = ptLineApp->ptLineClients;
    while (ptLineClient)
    {
        lResult = SettLineClientEventMasks (
            ptLineClient,
            fSubMask,
            ulEventMasks,
            dwEventSubMasks
            );
        if (lResult)
        {
            goto ExitHere;
        }
        ptLineClient = ptLineClient->pNextSametLineApp;
    }

ExitHere:
    UNLOCKTLINEAPP (ptLineApp);
    return lResult;
}

//
//  SettPhoneClientEventMasks
//  Description:
//      Apply the masks or submasks on a tPhoneClient object. 
//  Parameters:
//      ptPhoneClient   : the tPhoneClient object to apply the masking
//      fSubMask        : this function is called for submasks
//      ulEventMasks    : the masks to be set if fSubMask is true or the mask
//                        whose submasks is to be set
//      dwEventSubMasks : the submasks to be set, ignored if fSubMask is FALSE
//  Return Value:
//

LONG
SettPhoneClientEventMasks (
    PTPHONECLIENT       ptPhoneClient,
    BOOL                fSubMask,
    ULONG64             ulEventMasks,
    DWORD               dwEventSubMasks
    )
{
    LONG                lResult = S_OK;

    LOCKTPHONECLIENT (ptPhoneClient);
    if (ptPhoneClient->dwKey != TPHONECLIENT_KEY)
    {
        lResult = PHONEERR_OPERATIONFAILED;
        goto ExitHere;
    }

    if (ptPhoneClient->ptPhoneApp->dwAPIVersion <= TAPI_VERSION3_0)
    {
        goto ExitHere;
    }

    lResult = SetEventMasksOrSubMasks (
        fSubMask,
        ulEventMasks,
        dwEventSubMasks,
        ptPhoneClient->adwEventSubMasks
        );


ExitHere:
    UNLOCKTPHONECLIENT (ptPhoneClient);
    return lResult;
}

//
//  SettPhoneAppEventMasks
//  Description:
//      Apply the masks or submasks on a tPhoneApp object. 
//  Parameters:
//      ptPhoneApp      : the tPhoneApp object to apply the masking
//      fSubMask        : this function is called for submasks
//      ulEventMasks    : the masks to be set if fSubMask is true or the mask
//                        whose submasks is to be set
//      dwEventSubMasks : the submasks to be set, ignored if fSubMask is FALSE
//  Return Value:
//

LONG
SettPhoneAppEventMasks (
    PTPHONEAPP          ptPhoneApp,
    BOOL                fSubMask,
    ULONG64             ulEventMasks,
    DWORD               dwEventSubMasks
    )
{
    LONG                lResult = S_OK;
    PTPHONECLIENT       ptPhoneClient;

    LOCKTPHONEAPP (ptPhoneApp);
    if (ptPhoneApp->dwKey != TPHONEAPP_KEY)
    {
        lResult = PHONEERR_OPERATIONFAILED;
        goto ExitHere;
    }

    if (ptPhoneApp->dwAPIVersion <= TAPI_VERSION3_0)
    {
        lResult = PHONEERR_OPERATIONUNAVAIL;
        goto ExitHere;
    }

    lResult = SetEventMasksOrSubMasks (
        fSubMask,
        ulEventMasks,
        dwEventSubMasks,
        ptPhoneApp->adwEventSubMasks
        );
    if (lResult)
    {
        goto ExitHere;
    }
    
    ptPhoneClient = ptPhoneApp->ptPhoneClients;
    while (ptPhoneClient)
    {
        lResult = SettPhoneClientEventMasks (
            ptPhoneClient,
            fSubMask,
            ulEventMasks,
            dwEventSubMasks
            );
        if (lResult)
        {
            goto ExitHere;
        }
        ptPhoneClient = ptPhoneClient->pNextSametPhoneApp;
    }

ExitHere:
    UNLOCKTPHONEAPP (ptPhoneApp);
    return lResult;

}

//
//  SettClientEventMasks
//  Description:
//      Apply the masks or submasks client wide. 
//  Parameters:
//      ptClient        : the client object to apply the masking
//      fSubMask        : this function is called for submasks
//      ulEventMasks    : the masks to be set if fSubMask is true or the mask
//                        whose submasks is to be set
//      dwEventSubMasks : the submasks to be set, ignored if fSubMask is FALSE
//  Return Value:
//

LONG
SettClientEventMasks (
    PTCLIENT        ptClient,
    BOOL            fSubMask,
    ULONG64         ulEventMasks,
    DWORD           dwEventSubMasks
    )
{
    LONG            lResult = S_OK;
    PTLINEAPP       ptLineApp;
    PTPHONEAPP      ptPhoneApp;
    BOOL            fLocked = TRUE;

    if (!WaitForExclusiveClientAccess (ptClient))
    {
        lResult = LINEERR_OPERATIONFAILED;
        fLocked = FALSE;
        goto ExitHere;
    }

    lResult = SetEventMasksOrSubMasks (
        fSubMask,
        ulEventMasks,
        dwEventSubMasks,
        ptClient->adwEventSubMasks
        );
    if (lResult)
    {
        goto ExitHere;
    }
    
    ptLineApp = ptClient->ptLineApps;
    while (ptLineApp)
    {
        lResult = SettLineAppEventMasks (
            ptLineApp,
            fSubMask,
            ulEventMasks,
            dwEventSubMasks
            );
        if (lResult)
        {
            goto ExitHere;
        }
        ptLineApp = ptLineApp->pNext;
    }

    ptPhoneApp = ptClient->ptPhoneApps;
    while (ptPhoneApp)
    {
        lResult = SettPhoneAppEventMasks (
            ptPhoneApp,
            fSubMask,
            ulEventMasks,
            dwEventSubMasks
            );
        if (lResult)
        {
            goto ExitHere;
        }
        ptPhoneApp = ptPhoneApp->pNext;
    }

ExitHere:
    if (fLocked)
    {
        UNLOCKTCLIENT (ptClient);
    }
    return lResult;
}

//
//  SettClientEventMasks
//  Description:
//      Apply the masks or submasks server wide.
//  Parameters:
//      fSubMask        : this function is called for submasks
//      ulEventMasks    : the masks to be set if fSubMask is true or the mask
//                        whose submasks is to be set
//      dwEventSubMasks : the submasks to be set, ignored if fSubMask is FALSE
//  Return Value:
//

LONG
SetGlobalEventMasks (
    BOOL        fSubMask,
    ULONG64     ulEventMasks,
    DWORD       dwEventSubMasks
    )
{
    LONG        lResult = S_OK;
    PTCLIENT    ptClient;

    TapiEnterCriticalSection (&TapiGlobals.CritSec);

    ptClient = TapiGlobals.ptClients;
    while (ptClient)
    {
        lResult = SettClientEventMasks (
            ptClient,
            fSubMask,
            ulEventMasks,
            dwEventSubMasks
            );
        if (lResult)
        {
            goto ExitHere;
        }
        ptClient = ptClient->pNext;
    }

ExitHere:
    TapiLeaveCriticalSection (&TapiGlobals.CritSec);
    return lResult;
}

//
//  TSetEventMasksOrSubMasks
//  Description:
//      The RPC function used for seting Masks/SubMasks on various different
//      types of objects
//  Parameters:
//  Return Value:
//

void
WINAPI
TSetEventMasksOrSubMasks (
    PTCLIENT                ptClient,
    PTSETEVENTMASK_PARAMS   pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    ULONG64     ulEventMasks;

    //  Assemble the two DWORD into 64 bit masks
    ulEventMasks = pParams->dwHiMasks;
    ulEventMasks <<= 32;
    ulEventMasks |= pParams->dwLowMasks;

    //  Mask sure we do not violate the permissible mask setting
    TapiEnterCriticalSection (&TapiGlobals.CritSec);
    if (ulEventMasks & (~TapiGlobals.ulPermMasks))
    {
        pParams->lResult = LINEERR_INVALPARAM;
        TapiLeaveCriticalSection (&TapiGlobals.CritSec);
        goto ExitHere;
    }

    //  Call the corresponding function to apply masking on different
    //  type of objects
    switch (pParams->dwObjType)
    {
    case TAPIOBJ_NULL:
        {
            pParams->lResult = (LONG) SettClientEventMasks (
                ptClient,
                pParams->fSubMask,
                ulEventMasks,
                pParams->dwEventSubMasks
                );
        }
        break;
    case TAPIOBJ_HLINEAPP:
        {
            PTLINEAPP       ptLineApp;

            ptLineApp = ReferenceObject (
                ghHandleTable, 
                pParams->hLineApp, 
                TLINEAPP_KEY
                );
            if (ptLineApp)
            {
                pParams->lResult = (LONG) SettLineAppEventMasks (
                    ptLineApp,
                    pParams->fSubMask,
                    ulEventMasks,
                    pParams->dwEventSubMasks
                    );
                DereferenceObject (
                    ghHandleTable,
                    pParams->hLineApp,
                    1
                    );
            }
            else
            {
                pParams->lResult = LINEERR_INVALAPPHANDLE;
            }
        }
        break;
    case TAPIOBJ_HPHONEAPP:
        {
            PTPHONEAPP      ptPhoneApp;

            ptPhoneApp = ReferenceObject (
                ghHandleTable,
                pParams->hPhoneApp,
                TPHONEAPP_KEY
                );
            if (ptPhoneApp)
            {
                pParams->lResult = (LONG) SettPhoneAppEventMasks (
                    ptPhoneApp,
                    pParams->fSubMask,
                    ulEventMasks,
                    pParams->dwEventSubMasks
                    );
                DereferenceObject (
                    ghHandleTable,
                    pParams->hPhoneApp,
                    1
                    );
            }
            else
            {
                pParams->lResult = PHONEERR_INVALAPPHANDLE;
            }
        }
        break;
    case TAPIOBJ_HLINE:
        {
            PTLINECLIENT        ptLineClient;

            ptLineClient = ReferenceObject (
                ghHandleTable,
                pParams->hLine,
                TLINECLIENT_KEY
                );
            if (ptLineClient)
            {
                pParams->lResult = (LONG) SettLineClientEventMasks (
                    ptLineClient,
                    pParams->fSubMask,
                    ulEventMasks,
                    pParams->dwEventSubMasks
                    );
                DereferenceObject (
                    ghHandleTable,
                    pParams->hLine,
                    1
                    );
            }
            else
            {
                pParams->lResult = LINEERR_INVALLINEHANDLE;
            }
        }
        break;
    case TAPIOBJ_HCALL:
        {
            PTCALLCLIENT        ptCallClient;

            ptCallClient = ReferenceObject (
                ghHandleTable,
                pParams->hCall,
                TCALLCLIENT_KEY
                );
            if (ptCallClient)
            {
                pParams->lResult = (LONG) SettCallClientEventMasks (
                    ptCallClient,
                    pParams->fSubMask,
                    ulEventMasks,
                    pParams->dwEventSubMasks
                    );
                DereferenceObject (
                    ghHandleTable,
                    pParams->hCall,
                    1
                    );
            }
            else
            {
                pParams->lResult = LINEERR_INVALCALLHANDLE;
            }
        }
        break;
    case TAPIOBJ_HPHONE:
        {
            PTPHONECLIENT       ptPhoneClient;

            ptPhoneClient = ReferenceObject (
                ghHandleTable,
                pParams->hPhone,
                TPHONECLIENT_KEY
                );
            if (ptPhoneClient)
            {
                pParams->lResult = (LONG) SettPhoneClientEventMasks (
                    ptPhoneClient,
                    pParams->fSubMask,
                    ulEventMasks,
                    pParams->dwEventSubMasks
                    );
                DereferenceObject (
                    ghHandleTable,
                    pParams->hPhone,
                    1
                    );
            }
            else
            {
                pParams->lResult = PHONEERR_INVALPHONEHANDLE;
            }
        }
        break;
    default:
        pParams->lResult = LINEERR_OPERATIONFAILED;
        break;
    }

    TapiLeaveCriticalSection (&TapiGlobals.CritSec);

ExitHere:
    *pdwNumBytesReturned = sizeof (TSETEVENTMASK_PARAMS);
}

//
//  GetEventsMasksOrSubMasks
//  Description:
//      Utility function used by TGetEventMasksOrSubMasks to retrieve
//      Masks/SubMasks from various Tapisrv objects
//  Parameters:
//      fSubMask            Masks or SubMasks are to be retrieved
//      ulEventMasksIn      Indicates which submask to get if fSubMask
//      pulEventMasksOut    Hold the returned masks if(!fSubMask), 
//                          corresponding bit is set as long as at least
//                          one submask bit is set
//      pdwEventSubMasksOut Hold the returned submask if(fSubMask)
//      adwEventSubMasks    the submasks array to work on
//  Return Value:
//

LONG
GetEventMasksOrSubMasks (
    BOOL            fSubMask,
    ULONG64         ulEventMasksIn, // Needs to be set if fSubMask
    ULONG64        *pulEventMasksOut,
    DWORD          *pdwEventSubMasksOut,
    DWORD          *adwEventSubMasks
    )
{
    DWORD       dwIndex;
    ULONG64     ulMask;

    if (NULL == adwEventSubMasks ||
        NULL == pulEventMasksOut ||
        NULL == pdwEventSubMasksOut)
    {
        ASSERT (0);
        return LINEERR_INVALPOINTER;
    }

    if (fSubMask)
    {
        ASSERT (pdwEventSubMasksOut != NULL);
        ASSERT (ulEventMasksIn != 0 &&
            (ulEventMasksIn & (ulEventMasksIn - 1)) == 0);
        *pdwEventSubMasksOut = 
            adwEventSubMasks[GetSubMaskIndex(ulEventMasksIn)];
    }
    else
    {
        ASSERT (pulEventMasksOut);
        ulMask = 1;
        *pulEventMasksOut = 0;
        for (dwIndex = 0; dwIndex < EM_NUM_MASKS; ++dwIndex)
        {
            if (adwEventSubMasks[dwIndex])
            {
                *pulEventMasksOut |= ulMask;
            }
            ulMask <<= 1;
        }
    }
    
    return S_OK;
}

//
//  TGetEventMasksOrSubMasks
//  Description:
//      The RPC function used for geting Masks/SubMasks on various different
//      types of objects
//  Parameters:
//  Return Value:
//

void
WINAPI
TGetEventMasksOrSubMasks (
    PTCLIENT                ptClient,
    PTGETEVENTMASK_PARAMS   pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    ULONG64     ulEventMasksIn;
    ULONG64     ulEventMasksOut;

    //  Assember the 64 bit mask from the two DWORD
    if (pParams->fSubMask)
    {
        ulEventMasksIn = pParams->dwHiMasksIn;
        ulEventMasksIn <<= 32;
        ulEventMasksIn += pParams->dwLowMasksIn;
    }

    TapiEnterCriticalSection (&TapiGlobals.CritSec);
    
    //  Retrieve the masking from various objects by calling
    //  the corresponding functions
    switch (pParams->dwObjType)
    {
    case TAPIOBJ_NULL:
        {

            if (WaitForExclusiveClientAccess (ptClient))
            {
                pParams->lResult = (LONG) GetEventMasksOrSubMasks (
                    pParams->fSubMask,
                    ulEventMasksIn,
                    &ulEventMasksOut,
                    &pParams->dwEventSubMasks,
                    ptClient->adwEventSubMasks
                    );
                UNLOCKTCLIENT (ptClient);
            }
            else
            {
                pParams->lResult = LINEERR_INVALPARAM;
            }

        }
        break;
    case TAPIOBJ_HLINEAPP:
        {
            PTLINEAPP       ptLineApp;

            ptLineApp = ReferenceObject (
                ghHandleTable, 
                pParams->hLineApp, 
                TLINEAPP_KEY
                );
            if (ptLineApp && ptLineApp->dwKey == TLINEAPP_KEY)
            {
                LOCKTLINEAPP (ptLineApp);

                pParams->lResult = GetEventMasksOrSubMasks (
                    pParams->fSubMask,
                    ulEventMasksIn,
                    &ulEventMasksOut,
                    &pParams->dwEventSubMasks,
                    ptLineApp->adwEventSubMasks
                    );

                UNLOCKTLINEAPP (ptLineApp);
            
                DereferenceObject (
                    ghHandleTable,
                    pParams->hLineApp,
                    1
                    );
            }
            else
            {
                pParams->lResult = LINEERR_INVALAPPHANDLE;
            }
        }
        break;
    case TAPIOBJ_HPHONEAPP:
        {
            PTPHONEAPP      ptPhoneApp;

            ptPhoneApp = ReferenceObject (
                ghHandleTable,
                pParams->hPhoneApp,
                TPHONEAPP_KEY
                );
            if (ptPhoneApp && ptPhoneApp->dwKey == TPHONEAPP_KEY)
            {
                LOCKTPHONEAPP (ptPhoneApp);

                pParams->lResult = GetEventMasksOrSubMasks (
                    pParams->fSubMask,
                    ulEventMasksIn,
                    &ulEventMasksOut,
                    &pParams->dwEventSubMasks,
                    ptPhoneApp->adwEventSubMasks
                    );

                UNLOCKTPHONEAPP (ptPhoneApp);
                
                DereferenceObject (
                    ghHandleTable,
                    pParams->hPhoneApp,
                    1
                    );
            }
            else
            {
                pParams->lResult = PHONEERR_INVALAPPHANDLE;
            }
        }
        break;
    case TAPIOBJ_HLINE:
        {
            PTLINECLIENT        ptLineClient;

            ptLineClient = ReferenceObject (
                ghHandleTable,
                pParams->hLine,
                TLINECLIENT_KEY
                );
            if (ptLineClient && ptLineClient->dwKey == TLINECLIENT_KEY)
            {
                LOCKTLINECLIENT (ptLineClient);

                pParams->lResult = GetEventMasksOrSubMasks (
                    pParams->fSubMask,
                    ulEventMasksIn,
                    &ulEventMasksOut,
                    &pParams->dwEventSubMasks,
                    ptLineClient->adwEventSubMasks
                    );

                UNLOCKTLINECLIENT (ptLineClient);
                
                DereferenceObject (
                    ghHandleTable,
                    pParams->hLine,
                    1
                    );
            }
            else
            {
                pParams->lResult = LINEERR_INVALLINEHANDLE;
            }
        }
        break;
    case TAPIOBJ_HCALL:
        {
            PTCALLCLIENT        ptCallClient;

            ptCallClient = ReferenceObject (
                ghHandleTable,
                pParams->hCall,
                TCALLCLIENT_KEY
                );
            if (ptCallClient && ptCallClient->dwKey == TCALLCLIENT_KEY)
            {
                LOCKTLINECLIENT (ptCallClient);

                pParams->lResult = GetEventMasksOrSubMasks (
                    pParams->fSubMask,
                    ulEventMasksIn,
                    &ulEventMasksOut,
                    &pParams->dwEventSubMasks,
                    ptCallClient->adwEventSubMasks
                    );

                UNLOCKTLINECLIENT (ptCallClient);
                
                DereferenceObject (
                    ghHandleTable,
                    pParams->hCall,
                    1
                    );
            }
            else
            {
                pParams->lResult = LINEERR_INVALCALLHANDLE;
            }
        }
        break;
    case TAPIOBJ_HPHONE:
        {
            PTPHONECLIENT       ptPhoneClient;

            ptPhoneClient = ReferenceObject (
                ghHandleTable,
                pParams->hPhone,
                TPHONECLIENT_KEY
                );
            if (ptPhoneClient && ptPhoneClient->dwKey == TPHONECLIENT_KEY)
            {
                LOCKTPHONECLIENT (ptPhoneClient);

                pParams->lResult = GetEventMasksOrSubMasks (
                    pParams->fSubMask,
                    ulEventMasksIn,
                    &ulEventMasksOut,
                    &pParams->dwEventSubMasks,
                    ptPhoneClient->adwEventSubMasks
                    );

                UNLOCKTPHONECLIENT (ptPhoneClient);
                
                DereferenceObject (
                    ghHandleTable,
                    pParams->hPhone,
                    1
                    );
            }
            else
            {
                pParams->lResult = PHONEERR_INVALPHONEHANDLE;
            }
        }
        break;
    default:
        pParams->lResult = LINEERR_OPERATIONFAILED;
        break;
    }

    TapiLeaveCriticalSection (&TapiGlobals.CritSec);
    
    //  Seperating the returned 64 bit masks into two DWORD for RPC purpose
    if (pParams->lResult == 0 && !pParams->fSubMask)
    {
        pParams->dwLowMasksOut = (DWORD)(ulEventMasksOut & 0xffffffff);
        pParams->dwHiMasksOut = (DWORD)(ulEventMasksOut >> 32);
    }
    *pdwNumBytesReturned = sizeof (TGETEVENTMASK_PARAMS);
}


//
//  TSetPermissibleMasks
//  Description:
//      Set the global PermissibleMasks, this operation is only 
//      allowed for admins
//  Parameters:
//  Return Value:
//

void
WINAPI
TSetPermissibleMasks (
    PTCLIENT                ptClient,
    PTSETPERMMASKS_PARAMS   pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL            bAdmin;
    ULONG64         ulPermMasks;

    //  Check the Admin status
    LOCKTCLIENT (ptClient);
    bAdmin = IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR);
    UNLOCKTCLIENT (ptClient);

    //  Allow the operation to go ahead if the caller is an Admin or
    //  this machine is not configured to function as a server
    if (!(TapiGlobals.dwFlags & TAPIGLOBALS_SERVER) || bAdmin)
    {
        ulPermMasks = pParams->dwHiMasks;
        ulPermMasks <<= 32;
        ulPermMasks += pParams->dwLowMasks;
    
        TapiEnterCriticalSection (&TapiGlobals.CritSec);
        TapiGlobals.ulPermMasks = ulPermMasks & EM_ALL;
        TapiLeaveCriticalSection (&TapiGlobals.CritSec);
        
        pParams->lResult = (LONG) SetGlobalEventMasks (
            FALSE,
            ulPermMasks,
            0
            );
    }
    else
    {
        pParams->lResult = TAPIERR_NOTADMIN;
    }

    *pdwNumBytesReturned = sizeof (TSETPERMMASKS_PARAMS);
    return;
}

//
//  TGetPermissibleMasks
//  Description:
//      Get the global PermissibleMasks
//  Parameters:
//  Return Value:
//

void
WINAPI
TGetPermissibleMasks (
    PTCLIENT                ptClient,
    PTGETPERMMASKS_PARAMS   pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    TapiEnterCriticalSection (&TapiGlobals.CritSec);
    pParams->dwLowMasks = (DWORD)(TapiGlobals.ulPermMasks & 0xffffffff);
    pParams->dwHiMasks = (DWORD)(TapiGlobals.ulPermMasks >> 32);
    TapiLeaveCriticalSection (&TapiGlobals.CritSec);
    *pdwNumBytesReturned = sizeof (TGETPERMMASKS_PARAMS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\server\makefile.inc ===
$(O)\rmotsprpc.c: ..\idl\$(O)\rmotsp_c.c
    -copy /v $? $@

$(O)\tapsrvrpc.c: ..\idl\$(O)\tapsrv_s.c
    -copy /v $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\server\dspub.cpp ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 2000 - 2002  Microsoft Corporation

Module Name:

    dspub.cpp

Abstract:

    Src module for tapi server DS publishing

Author:

    Xiaohai Zhang (xzhang)    10-March-2000

Revision History:

--*/
#include "windows.h"
#include "objbase.h"
#include "winbase.h"
#include "sddl.h"
#include "iads.h"
#include "activeds.h"
#include "tapi.h"
#include "tspi.h"
#include "utils.h"
#include "client.h"
#include "server.h"
#include "private.h"
#include "tchar.h"

#define SECURITY_WIN32
#include "sspi.h"
#include "secext.h"
#include "psapi.h"

extern "C" {

extern const TCHAR gszRegKeyTelephony[];
extern DWORD gdwTapiSCPTTL;
extern const TCHAR gszRegTapisrvSCPGuid[];

}

const TCHAR gszTapisrvBindingInfo[] = TEXT("E{\\pipe\\tapsrv}P{ncacn_np}C{%s}A{%s}S{%s}TTL{%s}");

const TCHAR gszVenderMS[] = TEXT("Microsoft");
const TCHAR gszMSGuid[] = TEXT("937924B8-AA44-11d2-81F1-00C04FB9624E");

const WCHAR gwszTapisrvRDN[] = L"CN=Telephony Service";
const TCHAR gszTapisrvProdName[] = TEXT("Telephony Service");
//  gszTapisrvGuid needs to be consistant with remotesp\dslookup.cpp
const TCHAR gszTapisrvGuid[] = TEXT("B1A37774-E3F7-488E-ADBFD4DB8A4AB2E5");
const TCHAR gwszProxyRDN[] = L"cn=TAPI Proxy Server";
const TCHAR gszProxyProdName[] = TEXT("TAPI Proxy Server");
const TCHAR gszProxyGuid[] = TEXT("A2657445-3E27-400B-851A-456C41666E37");
const TCHAR gszRegProxySCPGuid[] = TEXT("PROXYSCPGUID");


typedef struct _PROXY_SCP_ENTRY {
    //  A valid CLSID requires 38 chars
    TCHAR   szClsid[40];

    //  A binding GUID is of format 
    //      LDAP://<GUID={B1A37774-E3F7-488E-ADBFD4DB8A4AB2E5}>
    //  required size is 38+14=52 chars
    TCHAR   szObjGuid[56];

    //  Ref count for this entry
    DWORD   dwRefCount;
} PROXY_SCP_ENTRY, *PPROXY_SCP_ENTRY;

typedef struct _PROXY_SCPS {
    DWORD                   dwTotalEntries;
    DWORD                   dwUsedEntries;
    PROXY_SCP_ENTRY *       aEntries;
} PROXY_SCPS, *PPROXY_SCPS;

PROXY_SCPS  gProxyScps;

#define MAX_SD              2048

//
//  GetTokenUser
//
//  Based on hAccessToken, call GetTokenInformation
//  to retrieve TokenUser info
//
HRESULT
GetTokenUser (HANDLE hAccessToken, PTOKEN_USER * ppUser)
{
    HRESULT                     hr = S_OK;
    DWORD                       dwInfoSize = 0;
    PTOKEN_USER                 ptuUser = NULL;
    DWORD                       ntsResult;

    if (!GetTokenInformation(
        hAccessToken,
        TokenUser,
        NULL,
        0,
        &dwInfoSize
        ))
    {
        ntsResult = GetLastError();
        if (ntsResult != ERROR_INSUFFICIENT_BUFFER)
        {
            hr = HRESULT_FROM_WIN32 (ntsResult);
            goto ExitHere;
        }
    }
    ptuUser = (PTOKEN_USER) ServerAlloc (dwInfoSize);
    if (ptuUser == NULL)
    {
        hr = LINEERR_NOMEM;
        goto ExitHere;
    }
    if (!GetTokenInformation(
        hAccessToken,
        TokenUser,
        ptuUser,
        dwInfoSize,
        &dwInfoSize
        ))
    {
        ServerFree (ptuUser);
        hr = HRESULT_FROM_WIN32 (GetLastError());
        goto ExitHere;
    }

    *ppUser = ptuUser;

ExitHere:
    return hr;
}

//
//  IsLocalSystem
//
//      This function makes the determination if the given process token
//  is running as LocalSystem or LocalService or NetworkService
//      Returns S_OK if it is, S_FALSE if it is not LocalSystem.
//

HRESULT
IsLocalSystem(HANDLE hAccessToken) 
{
    HRESULT                     hr = S_OK;
    SID_IDENTIFIER_AUTHORITY    NtAuthority = SECURITY_NT_AUTHORITY;
    PSID                        pLocalSid = NULL;
    PSID                        pLocalServiceSid = NULL;
    PSID                        pNetworkServiceSid = NULL;
    PTOKEN_USER                 ptuUser = NULL;

    hr = GetTokenUser (hAccessToken, &ptuUser);
    if (FAILED(hr))
    {
        goto ExitHere;
    }

    if (!AllocateAndInitializeSid (
        &NtAuthority, 
        1, 
        SECURITY_LOCAL_SYSTEM_RID, 
        0, 0, 0, 0, 0, 0, 0, 
        &pLocalSid) ||
        !AllocateAndInitializeSid (
        &NtAuthority, 
        1, 
        SECURITY_LOCAL_SERVICE_RID, 
        0, 0, 0, 0, 0, 0, 0, 
        &pLocalServiceSid) ||
        !AllocateAndInitializeSid (
        &NtAuthority, 
        1, 
        SECURITY_NETWORK_SERVICE_RID, 
        0, 0, 0, 0, 0, 0, 0, 
        &pNetworkServiceSid)
        )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ExitHere;
    }

    if (!EqualSid(pLocalSid, ptuUser->User.Sid) &&
        !EqualSid(pLocalServiceSid, ptuUser->User.Sid) &&
        !EqualSid(pNetworkServiceSid, ptuUser->User.Sid)) 
    {
        hr = S_FALSE;
    } 

ExitHere:

    if (NULL != ptuUser) 
    {
        ServerFree (ptuUser);
    }

    if (NULL != pLocalSid) 
    {
        FreeSid(pLocalSid);
    }
    if (NULL != pLocalServiceSid)
    {
        FreeSid (pLocalServiceSid);
    }
    if (NULL != pNetworkServiceSid)
    {
        FreeSid (pNetworkServiceSid);
    }

    return hr;
}

//
//  IsCurrentLocalSystem
//
//  IsCurrentLocalSystem checks to see if current thread/process
//  runs in LocalSystem account
//
HRESULT
IsCurrentLocalSystem ()
{
    HRESULT             hr = S_OK;
    HANDLE              hToken = NULL;

    if (!OpenThreadToken(
        GetCurrentThread(), 
        TOKEN_QUERY,
        FALSE,
        &hToken))
    {       
        if(!OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_QUERY,
            &hToken
            )) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto ExitHere;
        }
    }

    hr = IsLocalSystem (hToken);
    CloseHandle (hToken);

ExitHere:
    return hr;
}

HRESULT
SetPrivilege(
    HANDLE hToken,          // token handle
    LPCTSTR Privilege,      // Privilege to enable/disable
    BOOL bEnablePrivilege   // to enable or disable privilege
    )
{
    HRESULT                 hr = S_OK;
    TOKEN_PRIVILEGES        tp;
    LUID                    luid;
    TOKEN_PRIVILEGES        tpPrevious;
    DWORD                   cbPrevious=sizeof(TOKEN_PRIVILEGES);
    DWORD                   dwErr;

    if(!LookupPrivilegeValue( NULL, Privilege, &luid ))
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }

    //
    // first pass.  get current privilege setting
    //
    tp.PrivilegeCount           = 1;
    tp.Privileges[0].Luid       = luid;
    tp.Privileges[0].Attributes = 0;

    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tp,
            sizeof(TOKEN_PRIVILEGES),
            &tpPrevious,
            &cbPrevious
            );
    dwErr = GetLastError ();
    if (dwErr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32 (dwErr);
        goto ExitHere;
    }

    //
    // second pass.  set privilege based on previous setting
    //
    tpPrevious.PrivilegeCount       = 1;
    tpPrevious.Privileges[0].Luid   = luid;

    if(bEnablePrivilege) 
    {
        tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
    }
    else 
    {
        tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED &
            tpPrevious.Privileges[0].Attributes);
    }

    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tpPrevious,
            cbPrevious,
            NULL,
            NULL
            );
    dwErr = GetLastError ();
    if (dwErr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32 (dwErr);
        goto ExitHere;
    }

ExitHere:
    return hr;
}

HRESULT
SetCurrentPrivilege (
    LPCTSTR Privilege,      // Privilege to enable/disable
    BOOL bEnablePrivilege   // to enable or disable privilege
    )
{
    HRESULT             hr = S_OK;
    HANDLE              hToken = NULL;

    if (!OpenThreadToken(
        GetCurrentThread(), 
        TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
        FALSE,
        &hToken))
    {       
        if(!OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
            &hToken
            )) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto ExitHere;
        }
    }

    hr = SetPrivilege(hToken, Privilege, bEnablePrivilege);

ExitHere:
    if (hToken)
    {
        CloseHandle(hToken);
    }
    return hr;
}

//
//  SetSidOnAcl
//
BOOL
SetSidOnAcl(
    PSID pSid,
    PACL pAclSource,
    PACL *pAclDestination,
    DWORD AccessMask,
	BYTE AceFlags,
    BOOL bAddSid
    )
{
    HRESULT                 hr = S_OK;
    ACL_SIZE_INFORMATION    AclInfo;
    DWORD                   dwNewAclSize, dwErr;
    LPVOID                  pAce;
    DWORD                   AceCounter;

    //
    // If we were given a NULL Acl, just provide a NULL Acl
    //
    *pAclDestination = NULL;
    if(pAclSource == NULL || !IsValidSid(pSid)) 
    {
        hr = E_INVALIDARG;
        goto ExitHere;
    }

    if(!GetAclInformation(
        pAclSource,
        &AclInfo,
        sizeof(ACL_SIZE_INFORMATION),
        AclSizeInformation
        ))
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }

    //
    // compute size for new Acl, based on addition or subtraction of Ace
    //
    if(bAddSid) 
    {
        dwNewAclSize=AclInfo.AclBytesInUse  +
            sizeof(ACCESS_ALLOWED_ACE)  +
            GetLengthSid(pSid)          -
            sizeof(DWORD)               ;
    }
    else
    {
        dwNewAclSize=AclInfo.AclBytesInUse  -
            sizeof(ACCESS_ALLOWED_ACE)  -
            GetLengthSid(pSid)          +
            sizeof(DWORD)               ;
    }

    *pAclDestination = (PACL)ServerAlloc(dwNewAclSize);

    if(*pAclDestination == NULL) {
        hr = LINEERR_NOMEM;
        goto ExitHere;
    }
    
    //
    // initialize new Acl
    //
    if(!InitializeAcl(
            *pAclDestination, 
            dwNewAclSize, 
            ACL_REVISION
            ))
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }

    //
    // if appropriate, add ace representing pSid
    //
    if(bAddSid) 
    {
		PACCESS_ALLOWED_ACE pNewAce;

        if(!AddAccessAllowedAce(
            *pAclDestination,
            ACL_REVISION,
            AccessMask,
            pSid
            )) 
        {
            hr = HRESULT_FROM_WIN32 (GetLastError ());
            goto ExitHere;
        }

        //
        // get pointer to ace we just added, so we can change the AceFlags
        //
        if(!GetAce(
            *pAclDestination,
            0, // this is the first ace in the Acl
            (void**) &pNewAce
            ))
        {
            hr = HRESULT_FROM_WIN32 (GetLastError ());
            goto ExitHere;
        }

		pNewAce->Header.AceFlags = AceFlags;	
    }

    //
    // copy existing aces to new Acl
    //
    for(AceCounter = 0 ; AceCounter < AclInfo.AceCount ; AceCounter++) {
        //
        // fetch existing ace
        //
        if(!GetAce(pAclSource, AceCounter, &pAce))
        {
            hr = HRESULT_FROM_WIN32 (GetLastError ());
            goto ExitHere;
        }
        //
        // check to see if we are removing the Ace
        //
        if(!bAddSid) {
            //
            // we only care about ACCESS_ALLOWED aces
            //
            if((((PACE_HEADER)pAce)->AceType) == ACCESS_ALLOWED_ACE_TYPE) 
            {
                PSID pTempSid=(PSID)&((PACCESS_ALLOWED_ACE)pAce)->SidStart;
                //
                // if the Sid matches, skip adding this Sid
                //
                if(EqualSid(pSid, pTempSid)) 
                {
                    continue;
                }
            }
        }

        //
        // append ace to Acl
        //
        if(!AddAce(
            *pAclDestination,
            ACL_REVISION,
            MAXDWORD,  // maintain Ace order
            pAce,
            ((PACE_HEADER)pAce)->AceSize
            )) 
        {
            hr = HRESULT_FROM_WIN32 (GetLastError ());
            goto ExitHere;
        }
    }

ExitHere:

    //
    // free memory if an error occurred
    //
    if(hr) {
        if(*pAclDestination != NULL)
        {
            ServerFree(*pAclDestination);
        }
    }

    return hr;
}

//
//  AddSIDToKernelObject()
//
//  This function takes a given SID and dwAccess and adds it to a given token.
//
//  **  Be sure to restore old kernel object
//  **  using call to GetKernelObjectSecurity()
//
HRESULT
AddSIDToKernelObjectDacl(
    PSID                   pSid,
    DWORD                  dwAccess,
    HANDLE                 OriginalToken,
    PSECURITY_DESCRIPTOR*  ppSDOld)
{
    HRESULT                 hr = S_OK;
    PSECURITY_DESCRIPTOR    pSD = NULL;
    SECURITY_DESCRIPTOR     sdNew;
    DWORD                   cbByte = MAX_SD, cbNeeded = 0, dwErr = 0; 
    PACL                    pOldDacl = NULL, pNewDacl = NULL;
    BOOL                    fDaclPresent, fDaclDefaulted, fRet = FALSE;                    
   
    pSD = (PSECURITY_DESCRIPTOR) ServerAlloc(cbByte);
    if (NULL == pSD) 
    {
        hr = LINEERR_NOMEM;
        goto ExitHere;
    }

    if (!InitializeSecurityDescriptor(
        &sdNew, 
        SECURITY_DESCRIPTOR_REVISION
        )) 
    {
        hr = HRESULT_FROM_WIN32 (GetLastError());
        goto ExitHere;
    }

    if (!GetKernelObjectSecurity(
        OriginalToken,
        DACL_SECURITY_INFORMATION,
        pSD,
        cbByte,
        &cbNeeded
        )) 
    {
        dwErr = GetLastError();
        if (cbNeeded > MAX_SD && dwErr == ERROR_MORE_DATA) 
        { 
            ServerFree(pSD);
            pSD = (PSECURITY_DESCRIPTOR) ServerAlloc(cbNeeded);
            if (NULL == pSD) 
            {
                hr = LINEERR_NOMEM;
                goto ExitHere;
            }
            if (!GetKernelObjectSecurity(
                OriginalToken,
                DACL_SECURITY_INFORMATION,
                pSD,
                cbNeeded,
                &cbNeeded
                )) 
            {
                hr = HRESULT_FROM_WIN32 (GetLastError());
                goto ExitHere;
            }
            dwErr = 0;
        }
        
        if (dwErr != 0) 
        {
            hr = HRESULT_FROM_WIN32 (dwErr);
            goto ExitHere;
        }
    }
    
    if (!GetSecurityDescriptorDacl(
        pSD,
        &fDaclPresent,
        &pOldDacl,
        &fDaclDefaulted
        )) 
    {
        hr = HRESULT_FROM_WIN32 (GetLastError());
        goto ExitHere;
    }
    
    hr = SetSidOnAcl(
        pSid,
        pOldDacl,
        &pNewDacl,
        dwAccess,
        0,
        TRUE
        );
    if (hr)
    {
        goto ExitHere;
    }
    
    if (!SetSecurityDescriptorDacl(
        &sdNew,
        TRUE,
        pNewDacl,
        FALSE
        )) 
    {
        hr = HRESULT_FROM_WIN32 (GetLastError());
        goto ExitHere;
    } 
    
    if (!SetKernelObjectSecurity(
        OriginalToken,
        DACL_SECURITY_INFORMATION,
        &sdNew
        )) 
    {
        hr = HRESULT_FROM_WIN32 (GetLastError());
        goto ExitHere;
    }
    
    *ppSDOld = pSD;

ExitHere:

    if (NULL != pNewDacl) 
    {
        ServerFree(pNewDacl);
    }

    if (hr) 
    {
        if (NULL != pSD) 
        {
            ServerFree(pSD);
            *ppSDOld = NULL;
        }
    }
       
    return hr;
}

//
//  SetTokenDefaultDacl
//
//      This function makes pSidUser and LocalSystem account
//  have full access in the default DACL of the access token
//  this is necessary for CreateThread to succeed without
//  an assert in checked build
//

HRESULT
SetTokenDefaultDacl(HANDLE hAccessToken, PSID pSidUser) 
{
    HRESULT                     hr = S_OK;
    SID_IDENTIFIER_AUTHORITY    IDAuthorityNT = SECURITY_NT_AUTHORITY;
    PSID                        pLocalSid = NULL;
    TOKEN_DEFAULT_DACL          defDACL = {0};
    DWORD                       cbDACL;

    if (!AllocateAndInitializeSid(
        &IDAuthorityNT,
        1,
        SECURITY_LOCAL_SYSTEM_RID,
        0,0,0,0,0,0,0,
        &pLocalSid
        ))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ExitHere;
    }

    cbDACL = sizeof(ACL) + 
        sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid (pLocalSid) +
        sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid (pSidUser);
    defDACL.DefaultDacl = (PACL) ServerAlloc (cbDACL);
    if (defDACL.DefaultDacl == NULL)
    {
        hr = LINEERR_NOMEM;
        goto ExitHere;
    }
    if (!InitializeAcl (
        defDACL.DefaultDacl,
        cbDACL,
        ACL_REVISION
        ))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ExitHere;
    }
    if (!AddAccessAllowedAce (
        defDACL.DefaultDacl,
        ACL_REVISION,
        GENERIC_ALL,
        pLocalSid
        ) ||
        !AddAccessAllowedAce (
        defDACL.DefaultDacl,
        ACL_REVISION,
        GENERIC_ALL,
        pSidUser
        ))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ExitHere;
    }
    if (!SetTokenInformation (
        hAccessToken,
        TokenDefaultDacl,
        &defDACL,
        sizeof(TOKEN_DEFAULT_DACL)
        ))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ExitHere;
    }

ExitHere:

    if (NULL != pLocalSid) 
    {
        FreeSid(pLocalSid);
    }

    if (defDACL.DefaultDacl != NULL)
    {
        ServerFree (defDACL.DefaultDacl);
    }

    return hr;
}

//
//  GetLocalSystemToken
//
//  This function grabs a process token from a LocalSystem process and uses it
//  to impersonate when ncessary
//

HRESULT
GetLocalSystemToken(HANDLE* phRet)
{
    HRESULT                 hr = S_OK;

    DWORD                   rgDefPIDs[128];
    DWORD                   * rgPIDs = rgDefPIDs;
    DWORD                   cbPIDs = sizeof(rgDefPIDs), cbNeeded;

    DWORD                   i;
    HANDLE                  hProcess = NULL;
    HANDLE                  hPToken = NULL, hPDupToken = NULL, hPTokenNew = NULL;
    HANDLE                  hToken;

    PTOKEN_USER             ptuUser = NULL;
    BOOL                    fSet = FALSE;
    PSECURITY_DESCRIPTOR    pSD = NULL;

    //
    //  Set up necessary privilege for follow-on security operation
    //
    if(hr = SetCurrentPrivilege(SE_DEBUG_NAME, TRUE))
    {
        goto ExitHere;
    }
    if(hr = SetCurrentPrivilege(SE_TAKE_OWNERSHIP_NAME, TRUE))
    {
        goto ExitHere;
    }

    //
    //  Get the current thread/process token user info
    //
    if (!OpenThreadToken(
        GetCurrentThread(), 
        TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
        FALSE,
        &hToken))
    {       
        if(!OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
            &hToken
            )) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto ExitHere;
        }
    }
    hr = GetTokenUser (hToken, &ptuUser);
    CloseHandle (hToken);
    if (hr)
    {
        goto ExitHere;
    }

    //
    //  Get the list of process IDs in the system
    //
    while (1)
    {
        if (!EnumProcesses (
            rgPIDs,
            cbPIDs,
            &cbNeeded
            ))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto ExitHere;
        }
        //  Break out if we have large enough buf
        if (cbNeeded < cbPIDs)
        {
            break;
        }
        // Otherwise, alloc larger buffer
        if (rgPIDs != rgDefPIDs)
        {
            ServerFree (rgPIDs);
        }
        cbPIDs += 256;
        rgPIDs = (DWORD *)ServerAlloc (cbPIDs);
        if (rgPIDs == NULL)
        {
            hr = LINEERR_NOMEM;
            goto ExitHere;
        }
    }

    //
    //  Walk processes until we find one that's running as
    //  local system
    //
    for (i = 1; i < (cbNeeded / sizeof(DWORD)); i++) 
    {
        hProcess = OpenProcess(
            PROCESS_ALL_ACCESS,
            FALSE,
            rgPIDs[i]
            );
        if (NULL == hProcess) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto ExitHere;
        }
        if (!OpenProcessToken(
            hProcess,
            READ_CONTROL | WRITE_DAC,
            &hPToken
            )) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto ExitHere;
        }

        //
        //  We have got the process token, but in general
        //  we do not have TOKEN_DUPLICATE access. So we
        //  go ahead and whack the DACL of the object to
        //  grant us the access right.
        //  IMPORTANT: need to restore the original SD
        //
        if (hr = AddSIDToKernelObjectDacl(
            ptuUser->User.Sid,
            TOKEN_DUPLICATE,
            hPToken,
            &pSD
            )) 
        {
            goto ExitHere;
        }
                       
        fSet = TRUE;
        
        if (!OpenProcessToken(
            hProcess,
            TOKEN_DUPLICATE,
            &hPTokenNew
            )) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto ExitHere;
        }
        
        //
        //  Duplicate the token
        //
        if (!DuplicateTokenEx(
            hPTokenNew,
            TOKEN_ALL_ACCESS,
            NULL,
            SecurityImpersonation,
            TokenPrimary,
            &hPDupToken
            )) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto ExitHere;
        }

        if (IsLocalSystem (hPDupToken) == S_OK &&
            SetTokenDefaultDacl (
                hPDupToken,
                ptuUser->User.Sid) == S_OK)
        {
            break;
        }

        //
        //  Loop cleanup
        //
        if (!SetKernelObjectSecurity(
            hPToken,
            DACL_SECURITY_INFORMATION,
            pSD
            )) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto ExitHere;
        }
        fSet = FALSE;

        if (hPDupToken)
        {
            CloseHandle (hPDupToken);
            hPDupToken = NULL;
        }
        if (hPTokenNew)
        {
            CloseHandle (hPTokenNew);
            hPTokenNew = NULL;
        }
        if (pSD != NULL)
        {
            ServerFree (pSD);
            pSD = NULL;
        }
        if (hPToken)
        {
            CloseHandle (hPToken);
            hPToken = NULL;
        }
        if (hProcess)
        {
            CloseHandle (hProcess);
            hProcess = NULL;
        }
    }
    
    if (i >= cbNeeded / sizeof(DWORD))
    {
        hr = S_FALSE;
    }

ExitHere:
    if (fSet)
    {
        if (!SetKernelObjectSecurity(
            hPToken,
            DACL_SECURITY_INFORMATION,
            pSD
            )) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    if (hPTokenNew)
    {
        CloseHandle (hPTokenNew);
    }
    if (hPToken)
    {
        CloseHandle (hPToken);
    }
    if (pSD != NULL)
    {
        ServerFree (pSD);
    }
    if (hProcess)
    {
        CloseHandle (hProcess);
    }
    if (rgPIDs != rgDefPIDs)
    {
        ServerFree (rgPIDs);
    }
    if (ptuUser)
    {
        ServerFree (ptuUser);
    }

    if (hr)
    {
        *phRet = NULL;
        if (hPDupToken)
        {
            CloseHandle (hPDupToken);
        }
    }
    else
    {
        *phRet = hPDupToken;
    }
    return hr;
}

//
//  ImpersonateLocalSystem
//
HRESULT ImpersonateLocalSystem ()
{
    HRESULT         hr = S_OK;
    HANDLE          hTokenLocalSys;

    hr = GetLocalSystemToken (&hTokenLocalSys);
    if (FAILED (hr))
    {
        goto ExitHere;
    }

    if (!ImpersonateLoggedOnUser(
        hTokenLocalSys
        ))
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }

ExitHere:
    if (hTokenLocalSys)
    {
        CloseHandle (hTokenLocalSys);
    }
    return hr;
}

//
//  RevertLocalSystemImp
//
//  Revert the LocalSystem account impersonation
//
HRESULT RevertLocalSystemImp ()
{
    HRESULT         hr;

    if (!RevertToSelf())
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
    }
    else
    {
        hr = S_OK;
    }

    return hr;
}

//
//  AllowAccessToScpProperties
//
//      The ACEs grant read/write access to the computer account 
//  under which the TAPI service instance will be running
//

HRESULT AllowAccessToScpProperties(
    IADs *pSCPObject       // IADs pointer to the SCP object.
    )
{
    HRESULT         hr = S_OK;

    VARIANT         varSD;
    LPOLESTR        szAttribute = L"nTSecurityDescriptor";
    
    DWORD dwLen;
    IADsSecurityDescriptor *pSD = NULL;
    IADsAccessControlList *pACL = NULL;
    IDispatch *pDisp = NULL;
    IADsAccessControlEntry *pACE1 = NULL;
    IADsAccessControlEntry *pACE2 = NULL;
    IDispatch *pDispACE = NULL;
    long lFlags = 0L;

    SID_IDENTIFIER_AUTHORITY    sia = SECURITY_NT_AUTHORITY;
    PSID                        pSid = NULL;
    LPOLESTR                    szTrustee = NULL;
    SID_IDENTIFIER_AUTHORITY    siaAll = SECURITY_WORLD_SID_AUTHORITY;
    PSID                        pSidAll = NULL;
    LPOLESTR                    szTrusteeAll = NULL;

    //
    //  Give tapi server service logon account full control
    //
    
    if(!AllocateAndInitializeSid(
        &sia,
        1,
        SECURITY_SERVICE_RID,
        0, 0, 0, 0, 0, 0, 0,
        &pSid
        ) ||
        !ConvertSidToStringSidW (pSid, &szTrustee))
    {
        hr = HRESULT_FROM_NT(GetLastError());
        goto ExitHere;
    }

    //
    //  Give everyone read access
    //
    
    if(!AllocateAndInitializeSid(
        &siaAll,
        1,
        SECURITY_WORLD_RID,
        0, 0, 0, 0, 0, 0, 0,
        &pSidAll
        ) ||
        !ConvertSidToStringSidW (pSidAll, &szTrusteeAll))
    {
        hr = HRESULT_FROM_NT(GetLastError());
        goto ExitHere;
    }

    //
    //  Now get the nTSecurityDescriptor
    //
    VariantClear(&varSD);
    hr = pSCPObject->Get(szAttribute, &varSD);
    if (FAILED(hr) || (varSD.vt!=VT_DISPATCH)) {
        LOG((TL_ERROR, "Get nTSecurityDescriptor failed: 0x%x\n", hr));
        goto ExitHere;
    } 

    //
    // Use the V_DISPATCH macro to get the IDispatch pointer from VARIANT 
    // structure and QueryInterface for an IADsSecurityDescriptor pointer.
    //
    hr = V_DISPATCH( &varSD )->QueryInterface(
        IID_IADsSecurityDescriptor,
        (void**)&pSD
        );
    if (FAILED(hr)) {
        LOG((TL_ERROR, "Couldn't get IADsSecurityDescriptor: 0x%x\n", hr));
        goto ExitHere;
    } 
 
    // Get an IADsAccessControlList pointer to the security descriptor's DACL.
    hr = pSD->get_DiscretionaryAcl(&pDisp);
    if (SUCCEEDED(hr))
        hr = pDisp->QueryInterface(IID_IADsAccessControlList,(void**)&pACL);
    if (FAILED(hr)) {
        LOG((TL_ERROR, "Couldn't get DACL: 0x%x\n", hr));
        goto ExitHere;
    } 
 
    // Create the COM object for the first ACE.
    hr = CoCreateInstance(
        CLSID_AccessControlEntry,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IADsAccessControlEntry,
        (void **)&pACE1
        );
    // Create the COM object for the second ACE.
    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(
            CLSID_AccessControlEntry,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IADsAccessControlEntry,
            (void **)&pACE2
            );
    }
    if (FAILED(hr)) {
        LOG((TL_ERROR, "Couldn't create ACEs: 0x%x\n", hr));
        goto ExitHere;
    } 

    //
    // Set the properties of the two ACEs.
    //

    // Set the trustee    
    hr = pACE1->put_Trustee( szTrustee );
    hr = pACE2->put_Trustee( szTrusteeAll );

    //
    // Set the access rights
    //

    //  Full access for service logon account
    hr = pACE1->put_AccessMask(
        ADS_RIGHT_DELETE | ADS_RIGHT_READ_CONTROL |
        ADS_RIGHT_WRITE_DAC | ADS_RIGHT_WRITE_OWNER |
        ADS_RIGHT_SYNCHRONIZE | ADS_RIGHT_ACCESS_SYSTEM_SECURITY |
        ADS_RIGHT_GENERIC_READ | ADS_RIGHT_GENERIC_WRITE |
        ADS_RIGHT_GENERIC_EXECUTE | ADS_RIGHT_GENERIC_ALL |
        ADS_RIGHT_DS_CREATE_CHILD | ADS_RIGHT_DS_DELETE_CHILD |
        ADS_RIGHT_ACTRL_DS_LIST | ADS_RIGHT_DS_SELF |
        ADS_RIGHT_DS_READ_PROP | ADS_RIGHT_DS_WRITE_PROP |
        ADS_RIGHT_DS_DELETE_TREE | ADS_RIGHT_DS_LIST_OBJECT |
        ADS_RIGHT_DS_CONTROL_ACCESS
        );
    //  Read access for everyone
    hr = pACE2->put_AccessMask(
        ADS_RIGHT_DS_READ_PROP | ADS_RIGHT_READ_CONTROL |
        ADS_RIGHT_GENERIC_READ | ADS_RIGHT_ACTRL_DS_LIST |
        ADS_RIGHT_DS_LIST_OBJECT
        );
                            
    // Set the ACE type.
    hr = pACE1->put_AceType( ADS_ACETYPE_ACCESS_ALLOWED_OBJECT );
    hr = pACE2->put_AceType( ADS_ACETYPE_ACCESS_ALLOWED_OBJECT );

    // Set AceFlags to zero because ACE is not inheritable.
    hr = pACE1->put_AceFlags( 0 );
    hr = pACE2->put_AceFlags( 0 );
 
    // Set Flags to indicate an ACE that protects a specified object.
    hr = pACE1->put_Flags( 0 );
    hr = pACE2->put_Flags( 0 );
 
    // Set ObjectType to the schemaIDGUID of the attribute.
    hr = pACE1->put_ObjectType( NULL );
    hr = pACE2->put_ObjectType( NULL ); 

    // Add the ACEs to the DACL. Need an IDispatch pointer for each ACE 
    // to pass to the AddAce method.
    hr = pACE1->QueryInterface(IID_IDispatch,(void**)&pDispACE);
    if (SUCCEEDED(hr))
    {
        hr = pACL->AddAce(pDispACE);
    }
    if (FAILED(hr)) {
        LOG((TL_ERROR, "Couldn't add first ACE: 0x%x\n", hr));
        goto ExitHere;
    }
    else 
    {
        if (pDispACE)
            pDispACE->Release();
        pDispACE = NULL;
    }
 
    // Do it again for the second ACE.
    hr = pACE2->QueryInterface(IID_IDispatch, (void**)&pDispACE);
    if (SUCCEEDED(hr))
    {
        hr = pACL->AddAce(pDispACE);
    }
    if (FAILED(hr)) {
        LOG((TL_ERROR, "Couldn't add second ACE: 0x%x\n", hr));
        goto ExitHere;
    }
 
    // Write the modified DACL back to the security descriptor.
    hr = pSD->put_DiscretionaryAcl(pDisp);
    if (SUCCEEDED(hr))
    {
        // Write the ntSecurityDescriptor property to the property cache.
        hr = pSCPObject->Put(szAttribute, varSD);
        if (SUCCEEDED(hr))
        {
            // SetInfo updates the SCP object in the directory.
            hr = pSCPObject->SetInfo();
        }
    }
                                
ExitHere:
    if (pDispACE)
        pDispACE->Release();
                        
    if (pACE1)
        pACE1->Release();
                    
    if (pACE2)
        pACE2->Release();
                    
    if (pACL)
        pACL->Release();
               
    if (pDisp)
        pDisp->Release();
            
    if (pSD)
        pSD->Release();

    if (szTrustee)
        LocalFree (szTrustee);

    if (pSid)
        FreeSid (pSid);
 
    if (szTrusteeAll)
        LocalFree (szTrusteeAll);

    if (pSidAll)
        FreeSid (pSidAll);
 
    VariantClear(&varSD);
 
    return hr;
}

/**********************************************************
 *  SCP Creation
 *********************************************************/
 
//
//  CreateSCP
//
//      Creates a server Service Connection Point object
//  under the local host computer object
//  
//  Parameters:
//      wszRDN          - RDN
//      szProductName   - A member of "keywords" property
//      szProductGuid   - A member of "keywords" property
//      szExtraKey      - An extra member of "keywords" property
//      szBindingInfo   - value of property "serviceBindingInformation"
//      szObjGuidVlueName
//                      - The value name to store the SCP object GUID
//                        under HKLM\Software\Microsoft\Windows\
//                        CurrentVersion\Telephony\
//                        if this value is NULL, we don't cache it in registry
//      ppBindByGuidStr - For returning the SCP object GUID in the
//                        format of LPTSTR, if this is NULL, the GUID is 
//                        not returned
//

HRESULT CreateSCP (
    LPWSTR      wszRDN,
    LPTSTR      szProductName,
    LPTSTR      szProductGuid,
    LPTSTR      szExtraKey,
    LPTSTR      szBindingInfo,
    LPTSTR      szObjGuidValueName,
    LPTSTR *    ppBindByGuidStr
    )
{
    DWORD               dwStat, dwAttr, dwLen;
    HRESULT             hr = S_OK;
    IDispatch           *pDisp = NULL; // returned dispinterface of new object
    IDirectoryObject    *pComp = NULL; // Computer object; parent of SCP
    IADs                *pIADsSCP = NULL; // IADs interface on new object
    BOOL                bCoInited = FALSE;
    BOOL                bRevert = FALSE;

    //
    // Values for SCPs keywords attribute. Tapisrv product GUID is defined
    // in server.h, vendor GUID is from MSDN
    //
    DWORD               dwNumKeywords = 4;
    TCHAR               *KwVal[5]={
        (LPTSTR) gszMSGuid,                                 // Vendor GUID
        (LPTSTR) szProductGuid,                             // Product GUID
        (LPTSTR) gszVenderMS,                               // Vendor Name
        (LPTSTR) szProductName,                             // Product Name
        NULL
    };

    if (szExtraKey != NULL && szExtraKey[0] != 0)
    {
        KwVal[4] = szExtraKey;
        ++dwNumKeywords;
    }

    TCHAR               szServer[MAX_PATH];
    TCHAR               szBinding[128];
    TCHAR               szDn[MAX_PATH];
    TCHAR               szAdsPath[MAX_PATH];

    HKEY                hReg = NULL;
    DWORD               dwDisp;

    ADSVALUE            cn,objclass,keywords[4],binding,
                        classname,dnsname,nametype;

    //
    // SCP attributes to set during creation of SCP.
    //
    ADS_ATTR_INFO   ScpAttribs[] = {
        {TEXT("cn"), ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING, &cn, 1},
        {TEXT("objectClass"), ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
            &objclass, 1},
        {TEXT("keywords"), ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
            keywords, dwNumKeywords},
        {TEXT("serviceDNSName"), ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
            &dnsname, 1},
        {TEXT("serviceDNSNameType"), ADS_ATTR_UPDATE,ADSTYPE_CASE_IGNORE_STRING,
            &nametype, 1},
        {TEXT("serviceClassName"), ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
            &classname, 1},
        {TEXT("serviceBindingInformation"), ADS_ATTR_UPDATE, 
            ADSTYPE_CASE_IGNORE_STRING,
            &binding, 1},
        };

    //  A binding GUID is of format 
    //      LDAP:<GUID=B1A37774-E3F7-488E-ADBFD4DB8A4AB2E5>
    BSTR bstrGuid = NULL;
    TCHAR szBindByGuidStr[64]; 

    //
    //  Do CoInitializeEx
    //
    hr = CoInitializeEx (NULL, COINIT_MULTITHREADED);
    if (FAILED (hr))
    {
        goto ExitHere;
    }
    bCoInited = TRUE;

    //
    //  Do all the operation in LocalSystem account
    //
    if (IsCurrentLocalSystem () != S_OK)
    {
        hr = ImpersonateLocalSystem ();
        if (hr)
        {
            goto ExitHere;
        }
        bRevert = TRUE;
    }

    //
    // Get the DNS name of the local computer
    //
    dwLen = sizeof(szServer);
    if (!GetComputerNameEx(
        ComputerNameDnsFullyQualified,
        szServer,
        &dwLen
        ))
    {
        hr = HRESULT_FROM_NT(GetLastError());
        LOG((TL_ERROR, "GetComputerNameEx: %s\n", szServer));
        goto ExitHere;
    }

    //
    // Fill in the attribute values to be stored in the SCP.
    //

    cn.dwType                   = ADSTYPE_CASE_IGNORE_STRING;
    cn.CaseIgnoreString         = wszRDN + 3; // 3 is the size of "CN="
    objclass.dwType             = ADSTYPE_CASE_IGNORE_STRING;
    objclass.CaseIgnoreString   = TEXT("serviceConnectionPoint");

    keywords[0].dwType = ADSTYPE_CASE_IGNORE_STRING;
    keywords[1].dwType = ADSTYPE_CASE_IGNORE_STRING;
    keywords[2].dwType = ADSTYPE_CASE_IGNORE_STRING;
    keywords[3].dwType = ADSTYPE_CASE_IGNORE_STRING;
    keywords[4].dwType = ADSTYPE_CASE_IGNORE_STRING;

    keywords[0].CaseIgnoreString=KwVal[0];
    keywords[1].CaseIgnoreString=KwVal[1];
    keywords[2].CaseIgnoreString=KwVal[2];
    keywords[3].CaseIgnoreString=KwVal[3];
    keywords[4].CaseIgnoreString=KwVal[4];

    dnsname.dwType              = ADSTYPE_CASE_IGNORE_STRING;
    dnsname.CaseIgnoreString    = szServer;
    nametype.dwType             = ADSTYPE_CASE_IGNORE_STRING;
    nametype.CaseIgnoreString   = TEXT("A");
    
    classname.dwType            = ADSTYPE_CASE_IGNORE_STRING;
    classname.CaseIgnoreString  = szProductName;

    binding.dwType              = ADSTYPE_CASE_IGNORE_STRING;
    binding.CaseIgnoreString    = szBindingInfo;

    //
    // Get the distinguished name of the computer object for the local computer
    //
    dwLen = sizeof(szDn);
    if (!GetComputerObjectName(NameFullyQualifiedDN, szDn, &dwLen))
    {
        hr = HRESULT_FROM_NT(GetLastError());
        LOG((TL_ERROR, "GetComputerObjectName: %s\n", szDn));
        goto ExitHere;
    }

    //
    // Compose the ADSpath and bind to the computer object for the local computer
    //
    _tcscpy(szAdsPath,TEXT("LDAP://"));
    _tcscat(szAdsPath,szDn);
    hr = ADsGetObject(szAdsPath, IID_IDirectoryObject, (void **)&pComp);
    if (FAILED(hr)) {
        LOG((TL_ERROR, "Failed to bind Computer Object.",hr));
        goto ExitHere;
    }

    //*******************************************************************
    // Publish the SCP as a child of the computer object
    //*******************************************************************

    // Figure out attribute count.
    dwAttr = sizeof(ScpAttribs)/sizeof(ADS_ATTR_INFO);  

    // Do the Deed!
    hr = pComp->CreateDSObject(
        wszRDN,
        ScpAttribs, 
        dwAttr, 
        &pDisp
        );
    if (FAILED(hr)) {
        LOG((TL_ERROR, "Failed to create SCP: 0x%x\n", hr));
        if (HRESULT_CODE(hr) == ERROR_OBJECT_ALREADY_EXISTS)
        {
            hr = HRESULT_FROM_NT (TAPIERR_SCP_ALREADY_EXISTS);
        }
        goto ExitHere;
    }

    // Query for an IADs pointer on the SCP object.
    hr = pDisp->QueryInterface(IID_IADs,(void **)&pIADsSCP);
    if (FAILED(hr)) {
        LOG((TL_ERROR, "Failed to QI for IADs: 0x%x\n",hr));
        goto ExitHere;
    }

    // Set ACEs on SCP so service can modify it.
    hr = AllowAccessToScpProperties(
        pIADsSCP       // IADs pointer to the SCP object.
        );
    if (FAILED(hr)) {
        LOG((TL_ERROR, "Failed to set ACEs on SCP DACL: 0x%x\n", hr));
        goto ExitHere;
    }

    // Retrieve the SCP's objectGUID in format suitable for binding. 
    hr = pIADsSCP->get_GUID(&bstrGuid); 
    if (FAILED(hr)) {
        LOG((TL_ERROR, "Failed to get GUID: 0x%x\n", hr));
        goto ExitHere;
    }

    // Build a string for binding to the object by GUID
    _tcscpy(szBindByGuidStr, TEXT("LDAP://<GUID="));
    _tcscat(szBindByGuidStr, bstrGuid);
    _tcscat(szBindByGuidStr, TEXT(">"));
    LOG((TL_INFO, "GUID binding string: %s\n", szBindByGuidStr));

    //  Set the returning BindByGuidStr if any
    if (ppBindByGuidStr)
    {
        *ppBindByGuidStr = (LPTSTR) ServerAlloc (
            (_tcslen (szBindByGuidStr) + 1) * sizeof(TCHAR)
            );
        if (*ppBindByGuidStr == NULL)
        {
            hr = LINEERR_NOMEM;
            goto ExitHere;
        }
        _tcscpy (*ppBindByGuidStr, szBindByGuidStr);
    }

    // Create a registry key under 
    //     HKEY_LOCAL_MACHINE\SOFTWARE\Vendor\Product.
    if (szObjGuidValueName)
    {
        dwStat = RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            gszRegKeyTelephony,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_SET_VALUE,
            NULL,
            &hReg,
            &dwDisp);
        if (dwStat != NO_ERROR) {
            hr = HRESULT_FROM_NT(GetLastError());
            LOG((TL_ERROR, "RegCreateKeyEx failed: 0x%x\n", hr));
            return hr;
        }

        // Cache the GUID binding string under the registry key.
        dwStat = RegSetValueEx(
            hReg, 
            szObjGuidValueName,
            0, 
            REG_SZ,
            (const BYTE *)szBindByGuidStr, 
            sizeof(TCHAR)*(_tcslen(szBindByGuidStr))
            );
        if (dwStat != NO_ERROR) {
            hr = HRESULT_FROM_NT(GetLastError());
            LOG((TL_ERROR, "RegSetValueEx failed: 0x%x\n", hr));
    //      goto ExitHere;
        }
    }

ExitHere:
    if (pDisp)
    {
        pDisp->Release();
    }
    if (pIADsSCP)
    {
        pIADsSCP->Release();
    }
    if (hReg)
    {
        RegCloseKey(hReg);
    }
    if (bstrGuid)
    {
        SysFreeString (bstrGuid);
    }
    if (pComp)
    {
        if (FAILED(hr))
        {
            pComp->DeleteDSObject (wszRDN);
        }
        pComp->Release();
    }

    if (bRevert)
    {
        RevertLocalSystemImp ();
    }

    if (bCoInited)
    {
        CoUninitialize ();
    }

    return hr;
}

//
//  CreateTapiSCP
//
//      Creates the TAPI server Service Connection Point object
//  under the local host computer object
//  
//  Parameters:
//      pGuidAssoc      - GUID of the line/user association objecct GUID
//                        currently NULL
//      pGuidCluster    - The cluster object GUID this server belonging to
//

HRESULT CreateTapiSCP (
    GUID        * pGuidAssoc,
    GUID        * pGuidCluster
    )
{
    DWORD               dwStat, dwAttr, dwLen;
    HRESULT             hr = S_OK;

    TCHAR               szGUIDCluster[40];
    TCHAR               szGUIDAssoc[40];
    TCHAR               szBinding[128];

    //  Construct the binding information
    if (pGuidCluster != NULL)
    {
        StringFromGUID2 (
            *pGuidCluster,
            szGUIDCluster,
            sizeof(szGUIDCluster) / sizeof(TCHAR)
            );
    }
    else
    {
        szGUIDCluster[0] = 0;
    }
    if (pGuidAssoc != NULL)
    {
        StringFromGUID2 (
            *pGuidAssoc,
            szGUIDAssoc,
            sizeof(szGUIDAssoc) / sizeof(TCHAR)
            );
    }
    else
    {
        szGUIDAssoc[0] = 0;
    }

    wsprintf(
        szBinding,
        gszTapisrvBindingInfo,
        szGUIDCluster,
        szGUIDAssoc,
        TEXT("Inactive"),
        TEXT("")
        );

    hr = CreateSCP (
        (LPWSTR) gwszTapisrvRDN,
        (LPTSTR) gszTapisrvProdName,
        (LPTSTR) gszTapisrvGuid,
        (pGuidCluster == NULL) ? NULL : ((LPTSTR)szGUIDCluster),
        (LPTSTR) szBinding,
        (LPTSTR) gszRegTapisrvSCPGuid,
        NULL
        );

    return hr;
}

//
//  CreateProxySCP
//
//      Creates the TAPI proxy server Service Connection Point object
//  under the local host computer object
//  
//  Parameters:
//      szClsid - class ID of the proxy server object for DCOM invokation
//      ppBindByGuidStr
//              - where to return the BindByGuid string pointer
//

HRESULT CreateProxySCP (
    LPTSTR          szClsid,
    LPTSTR *        ppBindByGuidStr
    )
{
    HRESULT         hr = S_OK;
    
    //  RDN size include "cn=TAPI Proxy Server" + szClsid(38ch)
    WCHAR wszRDN[128];
    WCHAR *psz;

    wcscpy (wszRDN, gwszProxyRDN);
    wcscat (wszRDN, L"{");
    psz = wszRDN + wcslen(wszRDN);
#ifndef UNICODE
    if (MultiByteToWideChar (
        CP_ACP,
        MB_PRECOMPOSED,
        szClsid,
        -1,
        psz,
        (sizeof(wszRDN) - sizeof(gwszProxyRDN)) / sizeof(WCHAR) - 3
                            // 3 is to compensate for the two brace
        ) == 0)
    {
        hr = HRESULT_FROM_NT(GetLastError());
        goto ExitHere;
    }
#else
    wcscat (wszRDN, szClsid);
#endif
    wcscat (wszRDN, L"}");
    
    hr = CreateSCP (
        (LPWSTR) wszRDN,
        (LPTSTR) gszProxyProdName,
        (LPTSTR) gszProxyGuid,
        NULL,
        (LPTSTR) szClsid,
        NULL,
        ppBindByGuidStr
        );

    return hr;
}

/**********************************************************
 *  SCP Update
 *********************************************************/
 
//
//  UpdateSCP
//
//      Update a general SCP properties when necessary to keep every
//  piece ofthe information up to date. The following will be checked:
//      1. Check the serviceDNSName property against current computer
//         DNS name to ensure consistancy
//      2. Check the binding information with the information given
//
//  Parameters:
//      szAdsPath   - The ADs path of the SCP object
//      szBinding   - The binding information to compare with
//

HRESULT UpdateSCP (
    LPTSTR              szAdsPath,
    LPTSTR              szBinding
    )
{
    HRESULT             hr = S_OK;
    DWORD               dwAttrs;
    int                 i;
    ADSVALUE            dnsname,binding;

    DWORD               dwLen;
    BOOL                bUpdate=FALSE;
    BOOL                bCoInited = FALSE;
    BOOL                bRevert = FALSE;

    IDirectoryObject    *pObj = NULL;
    PADS_ATTR_INFO      pAttribs = NULL;

    TCHAR               szServer[MAX_PATH];

    TCHAR   *pszAttrs[]={
        TEXT("serviceDNSName"),
        TEXT("serviceBindingInformation")
    };

    ADS_ATTR_INFO   Attribs[]={
        {TEXT("serviceDNSName"),ADS_ATTR_UPDATE,ADSTYPE_CASE_IGNORE_STRING,&
            dnsname,1},
        {TEXT("serviceBindingInformation"),ADS_ATTR_UPDATE,
            ADSTYPE_CASE_IGNORE_STRING,&binding,1},
    };

    //
    //  Do CoInitializeEx
    //
    hr = CoInitializeEx (NULL, COINIT_MULTITHREADED);
    if (FAILED (hr))
    {
        goto ExitHere;
    }
    bCoInited = TRUE;

    //
    //  Do all the operation in LocalSystem account
    //
    if (IsCurrentLocalSystem() != S_OK)
    {
        hr = ImpersonateLocalSystem ();
        if (hr)
        {
            goto ExitHere;
        }
        bRevert = TRUE;
    }
    
    // Get the DNS name of the host server.
    dwLen = sizeof(szServer)/sizeof(TCHAR);
    if (!GetComputerNameEx(ComputerNameDnsFullyQualified, szServer, &dwLen))
    {
        hr = HRESULT_FROM_NT(GetLastError());
        goto ExitHere;
    }

    // Bind to the SCP.
    hr = ADsGetObject(szAdsPath, IID_IDirectoryObject, (void **)&pObj);
    if (FAILED(hr)) 
    {
        LOG((TL_ERROR,
            "ADsGetObject failed to bind to GUID (bind string: %S): ", 
            szAdsPath
            ));
        goto ExitHere;
    }

    // Retrieve attributes from the SCP.
    hr = pObj->GetObjectAttributes(pszAttrs, 2, &pAttribs, &dwAttrs);
    if (FAILED(hr)) {
        LOG((TL_ERROR, "GetObjectAttributes failed"));
        goto ExitHere;
    }

    // Check if we got the correct attribute type
    if (pAttribs->dwADsType != ADSTYPE_CASE_IGNORE_STRING ||
        (pAttribs+1)->dwADsType != ADSTYPE_CASE_IGNORE_STRING)
    {
        LOG((TL_ERROR, 
            "GetObjectAttributes returned dwADsType (%d,%d) instead of CASE_IGNORE_STRING",
            pAttribs->dwADsType, 
            (pAttribs+1)->dwADsType
        ));
        goto ExitHere;
    }

    // Compare the current DNS name and port to the values retrieved from
    // the SCP. Update the SCP only if something has changed.
    for (i=0; i<(LONG)dwAttrs; i++) 
    {
        if (_tcsicmp(TEXT("serviceDNSName"), pAttribs[i].pszAttrName)==0)
        {
            if (_tcsicmp(szServer, pAttribs[i].pADsValues->CaseIgnoreString) != 0)
            {
                LOG((TL_ERROR, "serviceDNSName being updated", 0));
                bUpdate = TRUE;
            }
            else
            {
                LOG((TL_ERROR, "serviceDNSName okay", 0));
            }
        }
        else if (_tcsicmp(
            TEXT("serviceBindingInformation"),
            pAttribs[i].pszAttrName
            )==0)
        {
            if (_tcsicmp(szBinding, pAttribs[i].pADsValues->CaseIgnoreString) != 0)
            {
                LOG((TL_ERROR, "serviceBindingInformation being updated", 0));
                bUpdate = TRUE;
            }
            else
            {
                LOG((TL_ERROR, "serviceBindingInformation okay"));
            }
        }
    }

    // The binding information or server name have changed, 
    // so update the SCP values.
    if (bUpdate)
    {
        dnsname.dwType              = ADSTYPE_CASE_IGNORE_STRING;
        dnsname.CaseIgnoreString    = szServer;
        binding.dwType              = ADSTYPE_CASE_IGNORE_STRING;
        binding.CaseIgnoreString    = szBinding;
        hr = pObj->SetObjectAttributes(Attribs, 2, &dwAttrs);
        if (FAILED(hr)) 
        {
            LOG((TL_ERROR, "ScpUpdate: Failed to set SCP values.", hr));
            goto ExitHere;
        }
    }

ExitHere:
    if (pAttribs)
    {
        FreeADsMem(pAttribs);
    }
    if (pObj)
    {
        pObj->Release();
    }

    if (bRevert)
    {
        RevertLocalSystemImp ();
    }

    if (bCoInited)
    {
        CoUninitialize ();
    }

    return hr;
}

//
//  UpdateTapiSCP
//
//      Update TAPI server SCP properties when necessary to keep every
//  piece ofthe information up to date. The following will be checked:
//
//  Parameters:
//      pGuidAssoc   - The line/user association guid
//      pGuidCluster - The cluster GUID
//

HRESULT UpdateTapiSCP (
    BOOL        bActive,
    GUID        * pGuidAssoc,
    GUID        * pGuidCluster
    )
{
    HRESULT             hr = S_OK;
    TCHAR               szGUIDCluster[40];
    TCHAR               szGUIDAssoc[40];
    TCHAR               szBinding[128];

    DWORD               dwStat, dwType, dwLen;
    HKEY                hReg = NULL;
    TCHAR               szAdsPath[MAX_PATH];

    // Open the service's registry key.
    dwStat = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        gszRegKeyTelephony,
        0,
        KEY_QUERY_VALUE,
        &hReg
        );
    if (dwStat != NO_ERROR) 
    {
        //  Probably because the SCP never published, CreateTapiSCP
        LOG((TL_ERROR, "RegOpenKeyEx failed", dwStat));
        hr = HRESULT_FROM_NT(dwStat);
        goto ExitHere;
    }

    // Get the GUID binding string used to bind to the service's SCP.
    dwLen = sizeof(szAdsPath);
    dwStat = RegQueryValueEx(
        hReg,
        gszRegTapisrvSCPGuid,
        0,
        &dwType,
        (LPBYTE)szAdsPath,
        &dwLen
        );
    if (dwStat != NO_ERROR) 
    {
        LOG((TL_ERROR, "RegQueryValueEx failed", dwStat));
        if (TapiGlobals.dwFlags & TAPIGLOBALS_SERVER)
        {
            if (FAILED(hr = CreateTapiSCP (pGuidAssoc, pGuidCluster)))
            {
                LOG((TL_ERROR, "UpdateTapiSCP: CreateTapiSCP failed"));
                goto ExitHere;
            }

            // CreateTapiSCP succeeded, need to read the guid
            dwLen = sizeof(szAdsPath);
            dwStat = RegQueryValueEx(
                hReg,
                gszRegTapisrvSCPGuid,
                0,
                &dwType,
                (LPBYTE)szAdsPath,
                &dwLen
                );
            if (dwStat != NO_ERROR) 
            {
                LOG((TL_ERROR, "UpdateTapiSCP: CreateTapiSCP succeeded but cannot read the guid"));
                hr = HRESULT_FROM_NT(dwStat);
                goto ExitHere;
            }
        }
        else
        {
            hr = HRESULT_FROM_NT(dwStat);
            goto ExitHere;
        }
    }

    //  Format to generate desired binding information
    if (pGuidCluster != NULL)
    {
        StringFromGUID2 (
            *pGuidCluster,
            szGUIDCluster,
            sizeof(szGUIDCluster) / sizeof(TCHAR)
            );
    }
    else
    {
        szGUIDCluster[0] = 0;
    }
    if (pGuidAssoc != NULL)
    {
        StringFromGUID2 (
            *pGuidAssoc,
            szGUIDAssoc,
            sizeof(szGUIDAssoc) / sizeof(TCHAR)
            );
    }
    else
    {
        szGUIDAssoc[0] = 0;
    }

    //
    //  Now construct the serviceBindingInformation based on the 
    //  service status
    //
    if (bActive)
    {
        TCHAR       szTTL[64];
        FILETIME    ftCur;
        ULONGLONG   ullInc, ullTime;
        SYSTEMTIME  stExp;

        //  Get current time
        GetSystemTimeAsFileTime (&ftCur);
        CopyMemory (&ullTime, &ftCur, sizeof(ULONGLONG));

        //  Get the time increment for gdwTapiSCPTTL minutes
        //  FILETIME is in the unit of 100 nanoseconds
        ullInc = ((ULONGLONG)gdwTapiSCPTTL) * 60 * 10000000;

        //  Get the record expiration time
        ullTime += ullInc;
        CopyMemory (&ftCur, &ullTime, sizeof(FILETIME));

        //
        //  Convert the expiration time to system time and
        //  format the string
        //
        //  The current TTL string is the concatenation of
        //      Year, Month, Date, Hour, Minute, Second, Milliseconds
        //  There are 5 digits allocated for year, 3 digits for
        //  milliseconds, and 2 digits fro the remaining fields
        //  all the numbers are zero padded to fill the extra space
        //
        //  Format here needs to be consistant with \
        //      sp\remotesp\dslookup.cpp
        //
        
        FileTimeToSystemTime (&ftCur, &stExp);
        wsprintf (
            szTTL,
            TEXT("%05d%02d%02d%02d%02d%02d%03d"),
            stExp.wYear,
            stExp.wMonth,
            stExp.wDay,
            stExp.wHour,
            stExp.wMinute,
            stExp.wSecond,
            stExp.wMilliseconds
            );
        
        wsprintf(
            szBinding,
            gszTapisrvBindingInfo,
            szGUIDCluster,
            szGUIDAssoc,
            TEXT("Active"),
            szTTL
            );
    }
    else
    {
        wsprintf(
            szBinding,
            gszTapisrvBindingInfo,
            szGUIDCluster,
            szGUIDAssoc,
            TEXT("Inactive"),
            TEXT("")
            );
    }
    
    hr = UpdateSCP (
        szAdsPath,
        szBinding
        );

ExitHere:
    if (hReg)
    {
        RegCloseKey (hReg);
    }
    return hr;
}

//
//  Proxy server exists only if TAPI server are alive
//  the DS information not likely to change when TAPI server is
//  alive, so no SCP updating routine for Proxy server
//

/**********************************************************
 *  SCP Removal
 *********************************************************/
 
//
//  RemoveSCP
//
//      Removes a Service Connection Point object from the
//  local host computer object. 
//
//  Parameters:
//      wszRDN      - the RDN of the SCP to delete
//      szRegNameToDel
//                  - The registery value name to be deleted
//                    If this value is NULL, no registry del
//

HRESULT RemoveSCP (
    LPWSTR          wszRDN,
    LPTSTR          szRegNameToDel
    )
{
    HRESULT             hr = S_OK;
    TCHAR               szServer[MAX_PATH];
    TCHAR               szAdsPath[MAX_PATH];
    DWORD               dwLen, dwStat;
    HKEY                hReg;
    IDirectoryObject    * pComp = NULL;
    BOOL                bCoInited = FALSE;
    BOOL                bRevert = FALSE;

    //
    //  Do CoInitializeEx
    //
    hr = CoInitializeEx (NULL, COINIT_MULTITHREADED);
    if (FAILED (hr))
    {
        goto ExitHere;
    }
    bCoInited = TRUE;

    //
    //  Do all the operation in LocalSystem account
    //
    if (IsCurrentLocalSystem() != S_OK)
    {
        hr = ImpersonateLocalSystem ();
        if (hr)
        {
            goto ExitHere;
        }
        bRevert = TRUE;
    }
    
    // Get the DNS name of the host server.
    dwLen = sizeof(szServer);
    if (!GetComputerObjectName(NameFullyQualifiedDN, szServer, &dwLen))
    {
        hr = HRESULT_FROM_NT(GetLastError());
        goto ExitHere;
    }
    
    //
    // Compose the ADSpath and bind to the computer object for the local computer
    //
    _tcscpy(szAdsPath,TEXT("LDAP://"));
    _tcscat(szAdsPath,szServer);
    hr = ADsGetObject(szAdsPath, IID_IDirectoryObject, (void **)&pComp);
    if (FAILED(hr)) {
        LOG((TL_ERROR, "Failed (%x) to bind Computer Object.",hr));
        goto ExitHere;
    }

    hr = pComp->DeleteDSObject (wszRDN);
    if (FAILED (hr))
    {
        LOG((TL_ERROR, "Failed (%x) to Delete Tapisrv Object.",hr));
        if (HRESULT_CODE(hr) == ERROR_DS_NO_SUCH_OBJECT)
        {
            hr = HRESULT_FROM_NT (TAPIERR_SCP_DOES_NOT_EXIST);
        }
        goto ExitHere;
    }
    
    // Open the service's registry key.
    if (szRegNameToDel)
    {
        dwStat = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            gszRegKeyTelephony,
            0,
            KEY_QUERY_VALUE | KEY_WRITE,
            &hReg);
        if (dwStat == NO_ERROR) 
        {
            RegDeleteValue (
                hReg,
                szRegNameToDel
                );
            RegCloseKey (hReg);
        }
        else
        {
            LOG((TL_ERROR, "RegOpenKeyEx failed", dwStat));
            hr = HRESULT_FROM_NT(GetLastError());
//          goto ExitHere;
        }
    }

ExitHere:
    if (pComp)
        pComp->Release();
    if (bRevert)
    {
        RevertLocalSystemImp ();
    }
    if (bCoInited)
    {
        CoUninitialize ();
    }
    return  hr;
}

//
//  RemoveTapiSCP
//
//      Removes the TAPI server Service Connection Point object from the
//  local host computer object. This happens if a TAPI server machine
//  retires from service.
//

HRESULT RemoveTapiSCP (
    )
{
    return RemoveSCP (
        (LPWSTR) gwszTapisrvRDN,
        (LPTSTR) gszRegTapisrvSCPGuid
        );
}

//
//  RemoveProxySCP
//
//      Removes the proxy server Service Connection Point object from the
//  local host computer object. This happens if the last line is closed
//  from a certain proxy server (CLSID)
//

HRESULT RemoveProxySCP (
    LPTSTR          szClsid
    )
{
    HRESULT         hr = S_OK;

    //  Construct the RDN
    //  RDN size include "cn=TAPI Proxy Server" + szClsid(38ch)
    WCHAR wszRDN[128];
    WCHAR *psz;

    wcscpy (wszRDN, gwszProxyRDN);
    wcscat (wszRDN, L"{");
    psz = wszRDN + wcslen(wszRDN);
#ifndef UNICODE
    if (MultiByteToWideChar (
        CP_ACP,
        MB_PRECOMPOSED,
        szClsid,
        -1,
        psz,
        (sizeof(wszRDN) - sizeof(gwszProxyRDN)) / sizeof(WCHAR) - 3
                            // 3 is to compensate for the two brace
        ) == 0)
    {
        hr = HRESULT_FROM_NT(GetLastError());
        goto ExitHere;
    }
#else
    wcscat (wszRDN, szClsid);
#endif
    wcscat (wszRDN, L"}");

    //  Call RemoveSCP
    hr = RemoveSCP (
        wszRDN,
        NULL
        );

//ExitHere:
    return hr;
}

/**********************************************************
 *  Proxy Server SCP management
 *********************************************************/

//
//  The Rules:
//      1. An array of created SCP objects and their corresponding CLSID
//         is maintained in a global data structure PROXY_SCPS
//      2. ServerInit calls OnProxySCPInit & ServerShutdown calls 
//          OnProxySCPShutdown
//      3. Every LOpen with proxy privilege will call OnProxyLineOpen with
//         the proxy server CLSID as the input parameter.
//         An SCP object will be created for a new CLSID, subsequent LOpen
//         with the same CLSID will only increment the ref count
//      4. Every LClose with on a line (opened with proxy privilege) will call
//         OnProxyLineClose with the proxy server CLSID as the input parameter
//         The ref count is decemented every time for the SCP with the CLSID,
//         if the ref count goes to zero, the SCP object will be deleted.
//

HRESULT OnProxySCPInit (
    )
{
    TapiEnterCriticalSection (&TapiGlobals.CritSec);
    ZeroMemory (&gProxyScps, sizeof(gProxyScps));
    TapiLeaveCriticalSection (&TapiGlobals.CritSec);
    
    return S_OK;
}

HRESULT OnProxySCPShutdown (
    )
{
    DWORD           i;

    TapiEnterCriticalSection (&TapiGlobals.CritSec);
    for (i = 0; i < gProxyScps.dwUsedEntries; ++i)
    {
        RemoveProxySCP (gProxyScps.aEntries[i].szClsid);
    }
    if (gProxyScps.aEntries != NULL)
    {
        ServerFree (gProxyScps.aEntries);
    }
    ZeroMemory (&gProxyScps, sizeof(gProxyScps));
    TapiLeaveCriticalSection (&TapiGlobals.CritSec);
    
    return S_OK;
}

HRESULT OnProxyLineOpen (
    LPTSTR      szClsid
    )
{
    HRESULT         hr = S_OK;
    BOOL            fExists = FALSE;
    DWORD           i;

    //  Skip beginning/trailing white space
    while (*szClsid == TEXT(' ') || *szClsid == TEXT('\t'))
        ++ szClsid;
    // A valid CLSID string should only contain 38 chars
    if (_tcslen (szClsid) > 40) 
    {
        hr = E_INVALIDARG;
        goto ExitHere;
    }

    TapiEnterCriticalSection (&TapiGlobals.CritSec);
    //  Is SCP for this szClsid already created (in array)?
    for (i = 0; i < gProxyScps.dwUsedEntries; ++i)
    {
        if (_tcsicmp (
            gProxyScps.aEntries[i].szClsid,
            szClsid
            ) == 0)
        {
            fExists = TRUE;
            break;
        }
    }

    //  If already exists, inc the ref count
    if (fExists)
    {
        gProxyScps.aEntries[i].dwRefCount++;
    }
    //  If not exists, create the new SCP and cache it
    else 
    {
        LPTSTR      pBindByGuidStr;
    
        hr = CreateProxySCP (szClsid, &pBindByGuidStr);
        if (FAILED (hr))
        {
            TapiLeaveCriticalSection (&TapiGlobals.CritSec);
            goto ExitHere;
        }

        if (gProxyScps.dwUsedEntries >= gProxyScps.dwTotalEntries)
        {
            //  Increase the size
            PROXY_SCP_ENTRY      * pNew;

            pNew = (PPROXY_SCP_ENTRY) ServerAlloc (
                sizeof(PROXY_SCP_ENTRY) * (gProxyScps.dwTotalEntries + 16)
                );
            if (pNew == NULL)
            {
                hr = LINEERR_NOMEM;
                ServerFree (pBindByGuidStr);
                TapiLeaveCriticalSection (&TapiGlobals.CritSec);
                goto ExitHere;
            }
            CopyMemory (
                pNew, 
                gProxyScps.aEntries, 
                sizeof(PROXY_SCP_ENTRY) * gProxyScps.dwTotalEntries
                );
            ServerFree (gProxyScps.aEntries);
            gProxyScps.aEntries = pNew;
            gProxyScps.dwTotalEntries += 16;
        }
        i = gProxyScps.dwUsedEntries++;
        _tcscpy (gProxyScps.aEntries[i].szClsid, szClsid);
        _tcscpy (gProxyScps.aEntries[i].szObjGuid, pBindByGuidStr);
        gProxyScps.aEntries[i].dwRefCount = 1;
        ServerFree (pBindByGuidStr);
    }
    TapiLeaveCriticalSection (&TapiGlobals.CritSec);

ExitHere:
    return hr;
}

HRESULT OnProxyLineClose (
    LPTSTR      szClsid
    )
{
    HRESULT         hr = S_OK;
    BOOL            fExists = FALSE;
    DWORD           i;

    //  Skip beginning/trailing white space
    while (*szClsid == TEXT(' ') || *szClsid == TEXT('\t'))
        ++ szClsid;
    // A valid CLSID string should only contain 38 chars
    if (_tcslen (szClsid) > 40) 
    {
        hr = E_INVALIDARG;
        goto ExitHere;
    }

    TapiEnterCriticalSection (&TapiGlobals.CritSec);
    
    //  Is SCP for this szClsid already created (in array)?
    for (i = 0; i < gProxyScps.dwUsedEntries; ++i)
    {
        if (_tcsicmp (
            gProxyScps.aEntries[i].szClsid,
            szClsid
            ) == 0)
        {
            fExists = TRUE;
            break;
        }
    }

    if (fExists)
    {
        --gProxyScps.aEntries[i].dwRefCount;
        //  If ref count goes to zero, remove the SCP
        if (gProxyScps.aEntries[i].dwRefCount == 0)
        {
            hr = RemoveProxySCP (gProxyScps.aEntries[i].szClsid);
            if (i < gProxyScps.dwUsedEntries - 1)
            {
                MoveMemory (
                    gProxyScps.aEntries + i,
                    gProxyScps.aEntries + i + 1,
                    sizeof(PROXY_SCP_ENTRY) * (gProxyScps.dwUsedEntries - 1 - i)
                    );
            }
            --gProxyScps.dwUsedEntries;
        }
    }
    
    TapiLeaveCriticalSection (&TapiGlobals.CritSec);

ExitHere:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\server\private.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1995-1998  Microsoft Corporation

Module Name:

    private.h

Abstract:

    Header file for tapi server

Author:

    Dan Knudson (DanKn)    01-Apr-1995

Revision History:

--*/

#ifdef __cplusplus
extern "C" {
#endif

//
// Func protos from line.c, phone.c, tapi.c (needed for gaFuncs def)
//

void WINAPI GetAsyncEvents              (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI GetUIDllName                (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI TUISPIDLLCallback           (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI FreeDialogInstance          (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);

void WINAPI LAccept                     (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LAddToConference            (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LAgentSpecific              (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LAnswer                     (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LBlindTransfer              (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LClose                      (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LCompleteCall               (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LCompleteTransfer           (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LConditionalMediaDetection  (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LDeallocateCall             (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LDevSpecific                (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LDevSpecificFeature         (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LDial                       (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LDrop                       (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LForward                    (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGatherDigits               (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGenerateDigits             (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGenerateTone               (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGetAddressCaps             (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGetAddressID               (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGetAddressStatus           (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGetAgentActivityList       (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGetAgentCaps               (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGetAgentGroupList          (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGetAgentStatus             (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGetAppPriority             (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGetCallAddressID           (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGetCallHubTracking         (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGetCallIDs                 (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGetCallInfo                (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGetCallStatus              (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGetConfRelatedCalls        (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGetCountry                 (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGetCountryGroups           (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGetDevCaps                 (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGetDevConfig               (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGetHubRelatedCalls         (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGetIcon                    (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGetID                      (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGetIDEx                    (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGetLineDevStatus           (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGetNewCalls                (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGetNumAddressIDs           (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGetNumRings                (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGetProviderList            (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGetRequest                 (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGetStatusMessages          (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LHandoff                    (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LHold                       (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LInitialize                 (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LMakeCall                   (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LMonitorDigits              (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LMonitorMedia               (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LMonitorTones               (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LNegotiateAPIVersion        (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LNegotiateExtVersion        (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LOpen                       (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LPark                       (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LPickup                     (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LPrepareAddToConference     (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LProxyMessage               (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LProxyResponse              (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LRedirect                   (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LRegisterRequestRecipient   (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LReleaseUserUserInfo        (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LRemoveFromConference       (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LSecureCall                 (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LSelectExtVersion           (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LSendUserUserInfo           (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LSetAgentActivity           (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LSetAgentGroup              (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LSetAgentState              (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LSetAppPriority             (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LSetAppSpecific             (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LSetCallData                (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LSetCallHubTracking         (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LSetCallParams              (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LSetCallPrivilege           (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LSetCallQualityOfService    (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LSetCallTreatment           (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LSetDefaultMediaDetection   (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LSetDevConfig               (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LSetLineDevStatus           (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LSetMediaControl            (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LSetMediaMode               (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LSetNumRings                (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LSetStatusMessages          (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LSetTerminal                (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LSetupConference            (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LSetupTransfer              (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LShutdown                   (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LSwapHold                   (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LUncompleteCall             (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LUnhold                     (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LUnpark                     (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);

void WINAPI PClose                      (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI PDevSpecific                (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI PGetButtonInfo              (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI PGetData                    (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI PGetDevCaps                 (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI PGetDisplay                 (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI PGetGain                    (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI PGetHookSwitch              (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI PGetID                      (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI PGetIDEx                    (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI PGetIcon                    (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI PGetLamp                    (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI PGetRing                    (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI PGetStatus                  (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI PGetStatusMessages          (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI PGetVolume                  (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI PInitialize                 (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI POpen                       (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI PNegotiateAPIVersion        (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI PNegotiateExtVersion        (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI PSelectExtVersion           (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI PSetButtonInfo              (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI PSetData                    (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI PSetDisplay                 (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI PSetGain                    (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI PSetHookSwitch              (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI PSetLamp                    (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI PSetRing                    (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI PSetStatusMessages          (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI PSetVolume                  (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI PShutdown                   (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);

void WINAPI TRequestDrop                (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI TRequestMakeCall            (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI TRequestMediaCall           (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI TReadLocations              (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI TWriteLocations             (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI TAllocNewID                 (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI TPerformance                (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI MGetAvailableProviders      (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI MGetLineInfo                (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI MGetPhoneInfo               (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI MGetServerConfig            (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI MSetLineInfo                (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI MSetPhoneInfo               (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI MSetServerConfig            (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LMSPIdentify                (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LReceiveMSPData             (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LCreateAgent                (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LCreateAgentSession         (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGetAgentInfo               (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGetAgentSessionInfo        (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGetAgentSessionList        (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGetQueueInfo               (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGetGroupList               (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGetQueueList               (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LSetAgentMeasurementPeriod  (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LSetAgentSessionState       (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LSetQueueMeasurementPeriod  (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI PrivateFactoryIdentify      (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LDevSpecificEx              (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LSetAgentStateEx            (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LGetProxyStatus             (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LCreateMSPInstance          (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI LCloseMSPInstance           (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
   
void WINAPI NegotiateAPIVersionForAllDevices    (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);


void WINAPI TSetEventMasksOrSubMasks    (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI TGetEventMasksOrSubMasks    (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI TSetPermissibleMasks        (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI TGetPermissibleMasks        (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);
void WINAPI MGetDeviceFlags             (PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);

typedef void (WINAPI *TAPISRVPROC)(PTCLIENT, LPVOID, DWORD, LPBYTE, LPDWORD);

#ifdef INIT_FUNCTABLE
TAPISRVPROC gaFuncs[] =
{
    GetAsyncEvents,
    GetUIDllName,
    TUISPIDLLCallback,
    FreeDialogInstance,

    LAccept,
    LAddToConference,
    LAgentSpecific,
    LAnswer,
    LBlindTransfer,
    LClose,
    LCompleteCall,
    LCompleteTransfer,
//    LConditionalMediaDetection,
    LDeallocateCall,
    LDevSpecific,
    LDevSpecificFeature,
    LDial,
    LDrop,
    LForward,
    LGatherDigits,
    LGenerateDigits,
    LGenerateTone,
    LGetAddressCaps,
    LGetAddressID,
    LGetAddressStatus,
    LGetAgentActivityList,
    LGetAgentCaps,
    LGetAgentGroupList,
    LGetAgentStatus,
    LGetAppPriority,
    LGetCallAddressID,
    LGetCallInfo,
    LGetCallStatus,
    LGetConfRelatedCalls,
    LGetCountry,
    LGetDevCaps,
    LGetDevConfig,
    LGetIcon,
    LGetID,
    LGetLineDevStatus,
    LGetNewCalls,
    LGetNumAddressIDs,
    LGetNumRings,
    LGetProviderList,
    LGetRequest,
    LGetStatusMessages,
//IN TAPI32.DLL now:     LGetTranslateCaps,
    LHandoff,
    LHold,
    LInitialize,
    LMakeCall,
    LMonitorDigits,
    LMonitorMedia,
    LMonitorTones,
    LNegotiateAPIVersion,
    LNegotiateExtVersion,
    LOpen,
    LPark,
    LPickup,
    LPrepareAddToConference,
    LProxyMessage,
    LProxyResponse,
    LRedirect,
    LRegisterRequestRecipient,
    LReleaseUserUserInfo,
    LRemoveFromConference,
    LSecureCall,
//    LSelectExtVersion,
    LSendUserUserInfo,
    LSetAgentActivity,
    LSetAgentGroup,
    LSetAgentState,
    LSetAppPriority,
    LSetAppSpecific,
    LSetCallData,
    LSetCallParams,
    LSetCallPrivilege,
    LSetCallQualityOfService,
    LSetCallTreatment,
    LSetDefaultMediaDetection,
    LSetDevConfig,
    LSetLineDevStatus,
    LSetMediaControl,
    LSetMediaMode,
    LSetNumRings,
    LSetStatusMessages,
    LSetTerminal,
    LSetupConference,
    LSetupTransfer,
    LShutdown,
    LSwapHold,
//IN TAPI32.DLL now:     LTranslateAddress,
    LUncompleteCall,
    LUnhold,
    LUnpark,

    PClose,
    PDevSpecific,
    PGetButtonInfo,
    PGetData,
    PGetDevCaps,
    PGetDisplay,
    PGetGain,
    PGetHookSwitch,
    PGetID,
    PGetIcon,
    PGetLamp,
    PGetRing,
    PGetStatus,
    PGetStatusMessages,
    PGetVolume,
    PInitialize,
    POpen,
    PNegotiateAPIVersion,
    PNegotiateExtVersion,
//    PSelectExtVersion,
    PSetButtonInfo,
    PSetData,
    PSetDisplay,
    PSetGain,
    PSetHookSwitch,
    PSetLamp,
    PSetRing,
    PSetStatusMessages,
    PSetVolume,
    PShutdown,

//IN TAPI32.DLL now:     TGetLocationInfo,
    TRequestDrop,
    TRequestMakeCall,
    TRequestMediaCall,
//    TMarkLineEvent,
    TReadLocations,
    TWriteLocations,
    TAllocNewID,
    TPerformance,
    LConditionalMediaDetection,
    LSelectExtVersion,
    PSelectExtVersion,

    //
    // Funcs for tapi 2.1 ended here.  the lOpenInt & lShutdownInt
    // were Win95 local-machine-only hacks which have since been removed
    //

    NegotiateAPIVersionForAllDevices,

    MGetAvailableProviders,
    MGetLineInfo,
    MGetPhoneInfo,
    MGetServerConfig,
    MSetLineInfo,
    MSetPhoneInfo,
    MSetServerConfig,

    //
    // Funcs for 2.1 update (nt4 sp4) ended here
    //

    LMSPIdentify,
    LReceiveMSPData,

    LGetCallHubTracking,
    LGetCallIDs,
    LGetHubRelatedCalls,
    LSetCallHubTracking,
    PrivateFactoryIdentify,
    LDevSpecificEx,
    LCreateAgent,
    LCreateAgentSession,
    LGetAgentInfo,
    LGetAgentSessionInfo,
    LGetAgentSessionList,
    LGetQueueInfo,
    LGetGroupList,
    LGetQueueList,
    LSetAgentMeasurementPeriod,
    LSetAgentSessionState,
    LSetQueueMeasurementPeriod,
    LSetAgentStateEx,
    LGetProxyStatus,
    LCreateMSPInstance,
    LCloseMSPInstance,

    //
    //  Funcs for 3.1
    //

    TSetEventMasksOrSubMasks,
    TGetEventMasksOrSubMasks,
    TSetPermissibleMasks,
    TGetPermissibleMasks,

    MGetDeviceFlags,

    LGetCountryGroups,

    LGetIDEx,

    PGetIDEx

};
#else
extern TAPISRVPROC gaFuncs[];
#endif

//
//  Private Error codes
//

#define TAPIERR_NOSERVICECONTROL    0xF100
#define TAPIERR_INVALRPCCONTEXT     0xF101

DWORD
PASCAL
ChangeDeviceUserAssociation(
    LPWSTR  pDomainUserName,
    LPWSTR  pFriendlyUserName,
    DWORD   dwProviderID,
    DWORD   dwPermanentDeviceID,
    BOOL    bLine
    );

DWORD
PASCAL
MyGetPrivateProfileString(
    LPCWSTR     pszSection,
    LPCWSTR     pszKey,
    LPCWSTR     pszDefault,
    LPWSTR     *ppBuf,
    LPDWORD     pdwBufSize
    );

void
PASCAL
SendAMsgToAllLineApps(
    DWORD       dwWantVersion,
    DWORD       Msg,
    DWORD       Param1,
    DWORD       Param2,
    DWORD       Param3
    );
void
PASCAL
SendAMsgToAllPhoneApps(
    DWORD       dwWantVersion,
    DWORD       dwMsg,
    DWORD       Param1,
    DWORD       Param2,
    DWORD       Param3
    );

LPWSTR 
WaveDeviceIdToStringId(
    DWORD dwDeviceId, 
    LPWSTR pwszDeviceType
    );

typedef struct _TGETEVENTMASK_PARAMS
{
        OUT LONG        lResult;

        DWORD           dwUnused;

        IN  DWORD       dwObjType;

    union
    {
        IN  HLINEAPP    hLineApp;
        IN  HPHONEAPP   hPhoneApp;
        IN  HLINE       hLine;
        IN  HPHONE      hPhone;
        IN  HCALL       hCall;
    };

        BOOL            fSubMask;

        OUT DWORD       dwEventSubMasks;

        IN  DWORD       dwLowMasksIn;
    
        IN  DWORD       dwHiMasksIn;

        OUT DWORD       dwLowMasksOut;
    
        OUT DWORD       dwHiMasksOut;
} TGETEVENTMASK_PARAMS, *PTGETEVENTMASK_PARAMS;

typedef struct _TSETEVENTMASK_PARAMS
{
        OUT LONG        lResult;

        DWORD           dwUnused;

        IN  DWORD       dwObjType;

    union
    {
        IN  HLINEAPP    hLineApp;
        IN  HPHONEAPP   hPhoneApp;
        IN  HLINE       hLine;
        IN  HPHONE      hPhone;
        IN  HCALL       hCall;
    };

        IN  BOOL        fSubMask;

        IN  DWORD       dwEventSubMasks;
    
        IN  DWORD       dwLowMasks;
    
        IN  DWORD       dwHiMasks;
} TSETEVENTMASK_PARAMS, *PTSETEVENTMASK_PARAMS;

typedef struct _PTSETPERMMASKS_PARAMS
{
        OUT LONG        lResult;

        DWORD           dwUnused;

        IN  DWORD       dwLowMasks;
    
        IN  DWORD       dwHiMasks;

} TSETPERMMASKS_PARAMS, *PTSETPERMMASKS_PARAMS;

typedef struct _PTGETPERMMASKS_PARAMS
{
    union
    {
        OUT LONG        lResult;
            LONG_PTR    unused;
    };

    DWORD           dwUnused;

    union
    {
        IN  DWORD       dwLowMasks;
            LONG_PTR    unused1;
    };
    
    union
    {
        IN  DWORD       dwHiMasks;
            LONG_PTR    unused2;
    };

} TGETPERMMASKS_PARAMS, *PTGETPERMMASKS_PARAMS;

BOOL
GetMsgMask (
    DWORD Msg, 
    ULONG64 * pulMask, 
    DWORD *pdwSubMaskIndex
    );

BOOL
FMsgDisabled (
    DWORD       dwAPIVersion,
    DWORD      *adwEventSubMasks,
    DWORD       Msg,
    DWORD       dwParam1
    );

LONG
SetEventMasksOrSubMasks (
    BOOL            fSubMask,
    ULONG64         ulEventMasks,
    DWORD           dwEventSubMasks,
    DWORD          *adwTargetSubMasks
    );

extern DWORD            gdwPointerToLockTableIndexBits;
extern CRITICAL_SECTION *gLockTable;

PTCLIENT
PASCAL
WaitForExclusiveClientAccess(
    PTCLIENT    ptClient
    );

BOOL
PASCAL
WaitForExclusivetCallAccess(
    PTCALL  ptCall,
    DWORD   dwKey
    );

#define POINTERTOTABLEINDEX(pObject) \
            ((((ULONG_PTR) pObject) >> 4) & gdwPointerToLockTableIndexBits)

#define LOCKTCALL(p) \
            EnterCriticalSection(&gLockTable[POINTERTOTABLEINDEX(p)])

#define UNLOCKTCALL(p) \
            LeaveCriticalSection(&gLockTable[POINTERTOTABLEINDEX(p)])

#define LOCKTLINECLIENT(p) \
            EnterCriticalSection(&gLockTable[POINTERTOTABLEINDEX(p)])

#define UNLOCKTLINECLIENT(p) \
            LeaveCriticalSection(&gLockTable[POINTERTOTABLEINDEX(p)])

#define LOCKTLINEAPP(p) \
            EnterCriticalSection(&gLockTable[POINTERTOTABLEINDEX(p)])

#define UNLOCKTLINEAPP(p) \
            LeaveCriticalSection(&gLockTable[POINTERTOTABLEINDEX(p)])

#define LOCKTCLIENT(p) \
            EnterCriticalSection(&gLockTable[POINTERTOTABLEINDEX(p)])

#define UNLOCKTCLIENT(p) \
            LeaveCriticalSection(&gLockTable[POINTERTOTABLEINDEX(p)])

#define POINTERTOTABLEINDEX(p) \
            ((((ULONG_PTR) p) >> 4) & gdwPointerToLockTableIndexBits)

#define LOCKTPHONECLIENT(p) \
            EnterCriticalSection(&gLockTable[POINTERTOTABLEINDEX(p)])

#define UNLOCKTPHONECLIENT(p) \
            LeaveCriticalSection(&gLockTable[POINTERTOTABLEINDEX(p)])

#define LOCKTPHONEAPP(p) \
            EnterCriticalSection(&gLockTable[POINTERTOTABLEINDEX(p)])

#define UNLOCKTPHONEAPP(p) \
            LeaveCriticalSection(&gLockTable[POINTERTOTABLEINDEX(p)])

extern TAPIGLOBALS TapiGlobals;
extern HANDLE ghTapisrvHeap;
extern HANDLE ghHandleTable;


/**********************************************************
 *  Server Connection Point Routines
 *********************************************************/

HRESULT CreateTapiSCP (
    GUID        * pGuidAssoc,
    GUID        * pGuidCluster
    );

HRESULT UpdateTapiSCP (
    BOOL        bActive,
    GUID        * pGuidAssoc,
    GUID        * pGuidCluster
    );

HRESULT RemoveTapiSCP (
    );

HRESULT OnProxySCPInit (
    );

HRESULT OnProxySCPShutdown (
    );

HRESULT OnProxyLineOpen (
    LPTSTR      szClsid
    );

HRESULT OnProxyLineClose (
    LPTSTR      szClsid
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\server\phone.c ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1995-1998  Microsoft Corporation

Module Name:

    phone.c

Abstract:

    Src module for tapi server phone funcs

Author:

    Dan Knudson (DanKn)    01-Apr-1995

Revision History:

--*/


#include "windows.h"
#include "assert.h"
#include "tapi.h"
#include "tspi.h"
#include "utils.h"
#include "client.h"
#include "server.h"
#include "phone.h"
#include "tapihndl.h"
#include "private.h"

#include "string.h"

extern TAPIGLOBALS TapiGlobals;

extern PTPROVIDER pRemoteSP;

extern CRITICAL_SECTION gSafeMutexCritSec;

extern HANDLE ghHandleTable;

extern BOOL gbQueueSPEvents;
extern BOOL             gbNTServer;
extern BOOL             gbServerInited;



#if DBG
char *
PASCAL
MapResultCodeToText(
    LONG    lResult,
    char   *pszResult
    );
#endif

void
DestroytPhoneClient(
    HPHONE  hPhone
    );

BOOL
IsAPIVersionInRange(
    DWORD   dwAPIVersion,
    DWORD   dwSPIVersion
    );

LONG
InitTapiStruct(
    LPVOID  pTapiStruct,
    DWORD   dwTotalSize,
    DWORD   dwFixedSize,
    BOOL    bZeroInit
    );

void
PASCAL
SendMsgToPhoneClients(
    PTPHONE         ptPhone,
    PTPHONECLIENT   ptPhoneClienttoExclude,
    DWORD           Msg,
    DWORD           Param1,
    DWORD           Param2,
    DWORD           Param3
    );

BOOL
PASCAL
WaitForExclusivetPhoneAccess(
    PTPHONE     ptPhone,
    HANDLE     *phMutex,
    BOOL       *pbDupedMutex,
    DWORD       dwTimeout
    );

void
PASCAL
SendReinitMsgToAllXxxApps(
    void
    );

PTCLIENT
PASCAL
WaitForExclusiveClientAccess(
    PTCLIENT    ptClient
    );

void
CALLBACK
CompletionProcSP(
    DWORD   dwRequestID,
    LONG    lResult
    );

void
PASCAL
SendAMsgToAllPhoneApps(
    DWORD       dwWantVersion,
    DWORD       dwMsg,
    DWORD       Param1,
    DWORD       Param2,
    DWORD       Param3
    );
    
BOOL
GetPhonePermanentIdFromDeviceID(
    PTCLIENT            ptClient,
    DWORD               dwDeviceID,
    LPTAPIPERMANENTID   pID
    );

LONG
InitializeClient(
    PTCLIENT ptClient
    );

LONG
PASCAL
GetPhoneClientListFromPhone(
    PTPHONE         ptPhone,
    PTPOINTERLIST  *ppList
    );

BOOL
IsBadStructParam(
    DWORD   dwParamsBufferSize,
    LPBYTE  pDataBuf,
    DWORD   dwXxxOffset
    );

void
CALLBACK
PhoneEventProcSP(
    HTAPIPHONE  htPhone,
    DWORD       dwMsg,
    ULONG_PTR   Param1,
    ULONG_PTR   Param2,
    ULONG_PTR   Param3
    );

LONG
GetPermPhoneIDAndInsertInTable(
    PTPROVIDER  ptProvider,
    DWORD       dwDeviceID,
    DWORD       dwSPIVersion
    );

LONG
AppendNewDeviceInfo (
    BOOL                        bLine,
    DWORD                       dwDeviceID
    );

LONG
RemoveDeviceInfoEntry (
    BOOL                        bLine,
    DWORD                       dwDeviceID
    );

LONG
PASCAL
GetClientList(
    BOOL            bAdminOnly,
    PTPOINTERLIST   *ppList
    );

PTPHONELOOKUPENTRY
GetPhoneLookupEntry(
    DWORD   dwDeviceID
    )
{
    DWORD               dwDeviceIDBase = 0;
    PTPHONELOOKUPTABLE  pLookupTable = TapiGlobals.pPhoneLookup;


    if (dwDeviceID >= TapiGlobals.dwNumPhones)
    {
        return ((PTPHONELOOKUPENTRY) NULL);
    }

    while (pLookupTable)
    {
        if (dwDeviceID < pLookupTable->dwNumTotalEntries)
        {
            return (pLookupTable->aEntries + dwDeviceID);
        }

        dwDeviceID -= pLookupTable->dwNumTotalEntries;

        pLookupTable = pLookupTable->pNext;
    }

    return ((PTPHONELOOKUPENTRY) NULL);
}


LONG
GetPhoneVersions(
    HPHONE  hPhone,
    LPDWORD lpdwAPIVersion,
    LPDWORD lpdwSPIVersion
    )
{
    LONG            lResult;
    PTPHONECLIENT   ptPhoneClient;


    if ((ptPhoneClient = ReferenceObject(
            ghHandleTable,
            hPhone,
            TPHONECLIENT_KEY
            )))
    {
        *lpdwAPIVersion = ptPhoneClient->dwAPIVersion;

        try
        {
            *lpdwSPIVersion = ptPhoneClient->ptPhone->dwSPIVersion;

            lResult = (ptPhoneClient->dwKey == TPHONECLIENT_KEY ?
                0 : PHONEERR_INVALPHONEHANDLE);
        }
        myexcept
        {
            lResult = PHONEERR_INVALPHONEHANDLE;
        }

        DereferenceObject (ghHandleTable, hPhone, 1);
    }
    else
    {
        lResult = PHONEERR_INVALPHONEHANDLE;
    }

    return lResult;
}


BOOL
PASCAL
IsValidPhoneExtVersion(
    DWORD   dwDeviceID,
    DWORD   dwExtVersion
    )
{
    BOOL                bResult;
    PTPHONE             ptPhone;
    PTPROVIDER          ptProvider;
    PTPHONELOOKUPENTRY  pLookupEntry;


    if (dwExtVersion == 0)
    {
        return TRUE;
    }

    if (!(pLookupEntry = GetPhoneLookupEntry (dwDeviceID)))
    {
        return FALSE;
    }

    ptPhone = pLookupEntry->ptPhone;

    if (ptPhone)
    {
        try
        {
            if (ptPhone->dwExtVersionCount)
            {
                bResult = (dwExtVersion == ptPhone->dwExtVersion ?
                    TRUE : FALSE);

                if (ptPhone->dwKey == TPHONE_KEY)
                {
                    goto IsValidPhoneExtVersion_return;
                }
            }

        }
        myexcept
        {
            //
            // if here the phone was closed, just drop thru to the code below
            //
        }
    }

    ptProvider = pLookupEntry->ptProvider;

    if (ptProvider->apfn[SP_PHONENEGOTIATEEXTVERSION])
    {
        LONG    lResult;
        DWORD   dwNegotiatedExtVersion;


        lResult = CallSP5(
            ptProvider->apfn[SP_PHONENEGOTIATEEXTVERSION],
            "phoneNegotiateExtVersion",
            SP_FUNC_SYNC,
            (DWORD) dwDeviceID,
            (DWORD) pLookupEntry->dwSPIVersion,
            (DWORD) dwExtVersion,
            (DWORD) dwExtVersion,
            (ULONG_PTR) &dwNegotiatedExtVersion
            );

        bResult = ((lResult || !dwNegotiatedExtVersion) ? FALSE : TRUE);
    }
    else
    {
        bResult = FALSE;
    }

IsValidPhoneExtVersion_return:

    return bResult;
}


PTPHONEAPP
PASCAL
IsValidPhoneApp(
    HPHONEAPP   hPhoneApp,
    PTCLIENT    ptClient
    )
{
    PTPHONEAPP  ptPhoneApp;


    if ((ptPhoneApp = ReferenceObject(
            ghHandleTable,
            hPhoneApp,
            TPHONEAPP_KEY
            )))
    {
        if (ptPhoneApp->ptClient != ptClient)
        {
            ptPhoneApp = NULL;
        }

        DereferenceObject (ghHandleTable, hPhoneApp, 1);
    }

    return ptPhoneApp;
}


LONG
PASCAL
ValidateButtonInfo(
    LPPHONEBUTTONINFO   pButtonInfoApp,
    LPPHONEBUTTONINFO  *ppButtonInfoSP,
    DWORD               dwAPIVersion,
    DWORD               dwSPIVersion
    )
{
    //
    // This routine checks the fields in a PHONEBUTTONINFO struct,
    // looking for invalid bit flags and making sure that the
    // various size/offset pairs only reference data within the
    // variable-data portion of the structure. Also, if the
    // specified SPI version is greater than the API version and
    // the fixed structure size differs between the two versions,
    // a larger buffer is allocated, the var data is relocated,
    // and the sizeof/offset pairs are patched.
    //

    char    szFunc[] = "ValidateButtonInfo";

    DWORD   dwTotalSize = pButtonInfoApp->dwTotalSize, dwFixedSizeApp,
            dwFixedSizeSP;


    switch (dwAPIVersion)
    {
    case TAPI_VERSION1_0:

        dwFixedSizeApp = 36;    // 9 * sizeof (DWORD)
        break;

    case TAPI_VERSION1_4:
    case TAPI_VERSION2_0:
    case TAPI_VERSION2_1:
    case TAPI_VERSION2_2:
    case TAPI_VERSION3_0:
    case TAPI_VERSION_CURRENT:

        dwFixedSizeApp = sizeof (PHONEBUTTONINFO);
        break;

    default:

        return PHONEERR_INVALPHONEHANDLE;
    }

    switch (dwSPIVersion)
    {
    case TAPI_VERSION1_0:

        dwFixedSizeSP = 36;     // 9 * sizeof (DWORD)
        break;

    case TAPI_VERSION1_4:
    case TAPI_VERSION2_0:
    case TAPI_VERSION2_1:
    case TAPI_VERSION2_2:
    case TAPI_VERSION3_0:
    case TAPI_VERSION_CURRENT:

        dwFixedSizeSP = sizeof (PHONEBUTTONINFO);
        break;

    default:

        return PHONEERR_INVALPHONEHANDLE;
    }

    if (dwTotalSize < dwFixedSizeApp)
    {
        LOG((TL_TRACE, 
            "%sbad dwTotalSize, x%x (minimum valid size=x%x)",
            szFunc,
            dwTotalSize,
            dwFixedSizeApp
            ));

        return PHONEERR_STRUCTURETOOSMALL;
    }

    if (ISBADSIZEOFFSET(
            dwTotalSize,
            dwFixedSizeApp,
            pButtonInfoApp->dwButtonTextSize,
            pButtonInfoApp->dwButtonTextOffset,
            0,
            szFunc,
            "ButtonText"
            ) ||

        ISBADSIZEOFFSET(
            dwTotalSize,
            dwFixedSizeApp,
            pButtonInfoApp->dwDevSpecificSize,
            pButtonInfoApp->dwDevSpecificOffset,
            0,
            szFunc,
            "DevSpecific"
            ))
    {
        return PHONEERR_OPERATIONFAILED;
    }

    if (dwAPIVersion < TAPI_VERSION1_4)
    {
        goto ValidateButtonInfo_checkFixedSizes;
    }

ValidateButtonInfo_checkFixedSizes:

    if (dwFixedSizeApp < dwFixedSizeSP)
    {
        DWORD               dwFixedSizeDiff = dwFixedSizeSP - dwFixedSizeApp;
        LPPHONEBUTTONINFO   pButtonInfoSP;


        if (!(pButtonInfoSP = ServerAlloc (dwTotalSize + dwFixedSizeDiff)))
        {
            return PHONEERR_NOMEM;
        }

        CopyMemory (pButtonInfoSP, pButtonInfoApp, dwFixedSizeApp);

        pButtonInfoSP->dwTotalSize = dwTotalSize + dwFixedSizeDiff;

        CopyMemory(
            ((LPBYTE) pButtonInfoSP) + dwFixedSizeSP,
            ((LPBYTE) pButtonInfoApp) + dwFixedSizeApp,
            dwTotalSize - dwFixedSizeApp
            );

        pButtonInfoSP->dwButtonTextOffset  += dwFixedSizeDiff;
        pButtonInfoSP->dwDevSpecificOffset += dwFixedSizeDiff;

        *ppButtonInfoSP = pButtonInfoSP;
    }
    else
    {
        *ppButtonInfoSP = pButtonInfoApp;
    }

//bjm 03/19 - not used - ValidateButtonInfo_return:

    return 0; // success

}


BOOL
PASCAL
WaitForExclusivePhoneClientAccess(
    PTPHONECLIENT   ptPhoneClient
    )
{
    //
    // Assumes ptXxxClient->hXxx has already been referenced,
    // so we can safely access ptXxxClient
    //

    LOCKTPHONECLIENT (ptPhoneClient);

    if (ptPhoneClient->dwKey == TPHONECLIENT_KEY)
    {
        return TRUE;
    }

    UNLOCKTPHONECLIENT (ptPhoneClient);

    return FALSE;
}


void
DestroytPhone(
    PTPHONE ptPhone,
    BOOL    bUnconditional
    )
{
    BOOL    bCloseMutex;
    HANDLE  hMutex;


    LOG((TL_ERROR, "DestroytPhone: enter, ptPhone=x%p", ptPhone));

    if (WaitForExclusivetPhoneAccess(
            ptPhone,
            &hMutex,
            &bCloseMutex,
            INFINITE
            ))
    {
        //
        // If the key is bad another thread is in the process of
        // destroying this widget, so just release the mutex &
        // return. Otherwise, if this is a conditional destroy
        // & there are existing clients (which can happen when
        // one app is closing the last client just as another app
        // is creating one) just release the mutex & return.
        // Otherwise, mark the widget as bad and proceed with
        // the destroy; also, send CLOSE msgs to all the clients
        // (note that we have to do this manually rather than via
        // SendMsgToPhoneClients since 1) we don't want to hold the
        // mutex when sending msgs [deadlock], and 2) we mark the
        // dwKey as invalid)
        //

        {
            BOOL            bExit;
            TPOINTERLIST    fastClientList, *pClientList = &fastClientList;


            if (ptPhone->dwKey == TPHONE_KEY &&
                (bUnconditional == TRUE  ||  ptPhone->ptPhoneClients == NULL))
            {
                if (GetPhoneClientListFromPhone (ptPhone, &pClientList) != 0)
                {
                    //
                    // If here we know there's at least a few entries
                    // in the fastClientList (DEF_NUM_PTR_LIST_ENTRIES
                    // to be exact), so we'll just work with that list
                    // and at least get msgs out to a few clients
                    //

                    pClientList = &fastClientList;

                    fastClientList.dwNumUsedEntries =
                        DEF_NUM_PTR_LIST_ENTRIES;
                }

                ptPhone->dwKey = INVAL_KEY;
                bExit = FALSE;
            }
            else
            {
                bExit = TRUE;
            }

            MyReleaseMutex (hMutex, bCloseMutex);

            if (bExit)
            {
                return;
            }

            if (pClientList->dwNumUsedEntries)
            {
                DWORD           i;
                PTCLIENT        ptClient;
                PTPHONECLIENT   ptPhoneClient;
                ASYNCEVENTMSG   msg;


                ZeroMemory (&msg, sizeof (msg));

                msg.TotalSize = sizeof (ASYNCEVENTMSG);
                msg.Msg       = PHONE_CLOSE;

                for (i = 0; i < pClientList->dwNumUsedEntries; i++)
                {
                    ptPhoneClient = (PTPHONECLIENT) pClientList->aEntries[i];

                    try
                    {
                        msg.InitContext =
                            ptPhoneClient->ptPhoneApp->InitContext;
                        msg.hDevice     = ptPhoneClient->hRemotePhone;
                        msg.OpenContext = ptPhoneClient->OpenContext;

                        ptClient = ptPhoneClient->ptClient;

                        if (ptPhoneClient->dwKey == TPHONECLIENT_KEY &&
                            !FMsgDisabled(
                                ptPhoneClient->ptPhoneApp->dwAPIVersion,
                                ptPhoneClient->adwEventSubMasks,
                                PHONE_CLOSE,
                                0
                                ))
                        {
                            WriteEventBuffer (ptClient, &msg);
                        }
                    }
                    myexcept
                    {
                        // do nothing
                    }
                }
            }

            if (pClientList != &fastClientList)
            {
                ServerFree (pClientList);
            }
        }


        //
        // Destroy all the widget's clients.  Note that we want to
        // grab the mutex (and we don't have to dup it, since this
        // thread will be the one to close it) each time we reference
        // the list of clients, since another thread might be
        // destroying a client too.
        //

        {
            HPHONE  hPhone;


            hMutex = ptPhone->hMutex;

destroy_tPhoneClients:

            WaitForSingleObject (hMutex, INFINITE);

            hPhone = (ptPhone->ptPhoneClients ?
                ptPhone->ptPhoneClients->hPhone : (HPHONE) 0);

            ReleaseMutex (hMutex);

            if (hPhone)
            {
                DestroytPhoneClient (hPhone);
                goto destroy_tPhoneClients;
            }
        }


        //
        // Tell the provider to close the widget
        //

        {
            PTPROVIDER  ptProvider = ptPhone->ptProvider;
            PTPHONELOOKUPENTRY   pEntry;

            pEntry = GetPhoneLookupEntry (ptPhone->dwDeviceID);

            if (ptProvider->dwTSPIOptions & LINETSPIOPTION_NONREENTRANT)
            {
                WaitForSingleObject (ptProvider->hMutex, INFINITE);
            }

            if (ptProvider->apfn[SP_PHONECLOSE] &&
                pEntry &&
                !pEntry->bRemoved
               )
            {
                CallSP1(
                    ptProvider->apfn[SP_PHONECLOSE],
                    "phoneClose",
                    SP_FUNC_SYNC,
                    (ULONG_PTR) ptPhone->hdPhone
                    );
            }

            if (ptProvider->dwTSPIOptions & LINETSPIOPTION_NONREENTRANT)
            {
                ReleaseMutex (ptProvider->hMutex);
            }
        }


        //
        // NULLify the ptPhone field in the lookup entry, so POpen will
        // know it has to open the SP's phone on the next open request
        //

        {
            PTPHONELOOKUPENTRY   pEntry;


            pEntry = GetPhoneLookupEntry (ptPhone->dwDeviceID);
            if (NULL != pEntry)
            {
                pEntry->ptPhone = NULL;
            }
        }

        DereferenceObject (ghHandleTable, ptPhone->hPhone, 1);
    }
}


void
DestroytPhoneClient(
    HPHONE  hPhone
    )
{
    BOOL            bExit = TRUE, bUnlock = FALSE;
    HANDLE          hMutex;
    PTPHONE         ptPhone;
    PTPHONECLIENT   ptPhoneClient;


    LOG((TL_TRACE,  "DestroytPhoneClient: enter, hPhone=x%x", hPhone));

    if (!(ptPhoneClient = ReferenceObject(
            ghHandleTable,
            hPhone,
            TPHONECLIENT_KEY
            )))
    {
        return;
    }


    //
    // If we can get exclusive access to this tPhoneClient then mark
    // it (the dwKey) as bad & continue with teardown.  Else, another
    // thread is already in the process of destroying this tPhoneClient
    //
    //

    if (WaitForExclusivePhoneClientAccess (ptPhoneClient))
    {
        BOOL    bSendDevStateMsg = FALSE;
        DWORD   dwParam1, dwParam2;


        ptPhoneClient->dwKey = INVAL_KEY;

        UNLOCKTPHONECLIENT (ptPhoneClient);


        //
        // Remove tPhoneClient from tPhoneApp's list.  Note that we don't
        // have to worry validating the tPhoneApp here, since we know
        // it's valid (another thread trying to destroy the tPhoneApp
        // will be spinning until the tPhoneClient we're destroying here
        // is removed from the tPhoneApp's list)
        //

        {
            PTPHONEAPP  ptPhoneApp = (PTPHONEAPP) ptPhoneClient->ptPhoneApp;


            LOCKTPHONEAPP (ptPhoneApp);

            if (ptPhoneClient->pNextSametPhoneApp)
            {
                ptPhoneClient->pNextSametPhoneApp->pPrevSametPhoneApp =
                    ptPhoneClient->pPrevSametPhoneApp;
            }

            if (ptPhoneClient->pPrevSametPhoneApp)
            {
                ptPhoneClient->pPrevSametPhoneApp->pNextSametPhoneApp =
                    ptPhoneClient->pNextSametPhoneApp;
            }
            else
            {
                ptPhoneApp->ptPhoneClients = ptPhoneClient->pNextSametPhoneApp;
            }

            UNLOCKTPHONEAPP (ptPhoneApp);
        }


        //
        // Remove tPhoneClient from tPhone's list.  Note that we don't
        // have to worry about dup-ing the mutex here because we know
        // it's valid & won't get closed before we release it.
        //

        ptPhone = ptPhoneClient->ptPhone;

        hMutex = ptPhone->hMutex;

        WaitForSingleObject (hMutex, INFINITE);

        {
            //
            // Also check for ext ver stuff
            //

            if (ptPhoneClient->dwExtVersion)
            {
                if ((--ptPhone->dwExtVersionCount) == 0 &&
                    ptPhone->ptProvider->apfn[SP_PHONESELECTEXTVERSION])
                {
                    CallSP2(
                        ptPhone->ptProvider->apfn[SP_PHONESELECTEXTVERSION],
                        "phoneSelectExtVersion",
                        SP_FUNC_SYNC,
                        (ULONG_PTR) ptPhone->hdPhone,
                        (DWORD) 0
                        );

                    ptPhone->dwExtVersion = 0;
                }
            }
        }

        if (ptPhoneClient->pNextSametPhone)
        {
            ptPhoneClient->pNextSametPhone->pPrevSametPhone =
                ptPhoneClient->pPrevSametPhone;
        }

        if (ptPhoneClient->pPrevSametPhone)
        {
            ptPhoneClient->pPrevSametPhone->pNextSametPhone =
                ptPhoneClient->pNextSametPhone;
        }
        else
        {
            ptPhone->ptPhoneClients = ptPhoneClient->pNextSametPhone;
        }


        //
        // Decrement tPhone's NumOwners/Monitors as appropriate
        //

        if (ptPhoneClient->dwPrivilege == PHONEPRIVILEGE_OWNER)
        {
            ptPhone->dwNumOwners--;
        }
        else
        {
            ptPhone->dwNumMonitors--;
        }


        //
        //
        //

        if (ptPhone->dwKey == TPHONE_KEY)
        {
            if (ptPhone->ptPhoneClients)
            {
                bSendDevStateMsg = TRUE;

                dwParam1 =
                    (ptPhoneClient->dwPrivilege == PHONEPRIVILEGE_OWNER ?
                    PHONESTATE_OWNER : PHONESTATE_MONITORS);

                dwParam2 =
                    (ptPhoneClient->dwPrivilege == PHONEPRIVILEGE_OWNER ?
                    0 : ptPhone->dwNumMonitors);


                //
                // See if we need to reset the status msgs (if so, make
                // sure to check/set the busy flag & not to hold the
                // mutex while calling down to provider - see comments
                // in LSetStatusMessages)
                //

                if ((ptPhoneClient->dwPhoneStates & ~PHONESTATE_REINIT) ||
                    ptPhoneClient->dwButtonModes ||
                    ptPhoneClient->dwButtonStates)
                {
                    DWORD           dwUnionPhoneStates = 0,
                                    dwUnionButtonModes = 0,
                                    dwUnionButtonStates = 0;
                    PTPHONECLIENT   ptPC;


                    while (ptPhone->dwBusy)
                    {
                        BOOL    bClosed = TRUE;


                        ReleaseMutex (hMutex);
                        Sleep (50);
                        WaitForSingleObject (hMutex, INFINITE);

                        try
                        {
                            if (ptPhone->dwKey == TPHONE_KEY)
                            {
                                bClosed = FALSE;
                            }
                        }
                        myexcept
                        {
                            // do nothing
                        }

                        if (bClosed)
                        {
                            goto releasMutex;
                        }
                    }

                    for(
                        ptPC = ptPhone->ptPhoneClients;
                        ptPC;
                        ptPC = ptPC->pNextSametPhone
                        )
                    {
                        if (ptPC != ptPhoneClient)
                        {
                            dwUnionPhoneStates  |= ptPC->dwPhoneStates;
                            dwUnionButtonModes  |= ptPC->dwButtonModes;
                            dwUnionButtonStates |= ptPC->dwButtonStates;
                        }
                    }

                    if ((dwUnionPhoneStates != ptPhone->dwUnionPhoneStates)  ||
                        (dwUnionButtonModes != ptPhone->dwUnionButtonModes)  ||
                        (dwUnionButtonStates != ptPhone->dwUnionButtonStates))
                    {
                        if (ptPhone->ptProvider->apfn
                                [SP_PHONESETSTATUSMESSAGES])
                        {
                            LONG        lResult;
                            TSPIPROC    pfn;
                            HDRVPHONE   hdPhone = ptPhone->hdPhone;


                            pfn = ptPhone->ptProvider->
                                apfn[SP_PHONESETSTATUSMESSAGES];

                            ptPhone->dwBusy = 1;

                            ReleaseMutex (hMutex);

                            lResult = CallSP4(
                                pfn,
                                "phoneSetStatusMessages",
                                SP_FUNC_SYNC,
                                (ULONG_PTR) hdPhone,
                                (DWORD) dwUnionPhoneStates,
                                (DWORD) dwUnionButtonModes,
                                (DWORD) dwUnionButtonStates
                                );

                            WaitForSingleObject (hMutex, INFINITE);

                            try
                            {
                                if (ptPhone->dwKey == TPHONE_KEY)
                                {
                                    ptPhone->dwBusy = 0;

                                    if (lResult == 0)
                                    {
                                        ptPhone->dwUnionPhoneStates  =
                                            dwUnionPhoneStates;
                                        ptPhone->dwUnionButtonModes  =
                                            dwUnionButtonModes;
                                        ptPhone->dwUnionButtonStates =
                                            dwUnionButtonStates;
                                    }
                                }
                            }
                            myexcept
                            {
                                // do nothing
                            }
                        }
                    }
                }
            }
            else
            {
                //
                // This was the last client so destroy the tPhone too
                //

                ReleaseMutex (hMutex);
                hMutex = NULL;
                DestroytPhone (ptPhone, FALSE); // conditional destroy
            }
        }

releasMutex:

        if (hMutex)
        {
            ReleaseMutex (hMutex);
        }


        //
        // Now that the mutex is released send any necessary msgs
        //

        if (bSendDevStateMsg)
        {
            SendMsgToPhoneClients(
                ptPhone,
                NULL,
                PHONE_STATE,
                dwParam1,
                dwParam2,
                0
                );
        }


        //
        // Decrement reference count by two to remove the initial
        // reference & the reference above
        //

        DereferenceObject (ghHandleTable, hPhone, 2);
    }
    else
    {
        DereferenceObject (ghHandleTable, hPhone, 1);
    }
}


LONG
DestroytPhoneApp(
    HPHONEAPP   hPhoneApp
    )
{
    BOOL        bExit = TRUE, bUnlock = FALSE;
    PTPHONEAPP  ptPhoneApp;


    LOG((TL_TRACE,  "DestroytPhoneApp: enter, hPhoneApp=x%x", hPhoneApp));


    if (!(ptPhoneApp = ReferenceObject (ghHandleTable, hPhoneApp, 0)))
    {
        return (TapiGlobals.dwNumPhoneInits ?
                    PHONEERR_INVALAPPHANDLE : PHONEERR_UNINITIALIZED);
    }

    //
    // Check to make sure that this is a valid tPhoneClient object,
    // then grab the lock and (recheck and) mark object as invalid.
    //

    LOCKTPHONEAPP (ptPhoneApp);

    if (ptPhoneApp->dwKey != TPHONEAPP_KEY)
    {
        UNLOCKTPHONEAPP (ptPhoneApp);
        DereferenceObject (ghHandleTable, hPhoneApp, 1);
        return (TapiGlobals.dwNumPhoneInits ?
                    PHONEERR_INVALAPPHANDLE : PHONEERR_UNINITIALIZED);
    }

    ptPhoneApp->dwKey = INVAL_KEY;


    //
    // Destroy all the tPhoneClients.  Note that we want to grab the
    // lock each time we reference the list of tPhoneClient's, since
    // another thread might be destroying a tPhoneClient too.
    //

    {
        HPHONE  hPhone;


destroy_tPhoneClients:

        hPhone = (ptPhoneApp->ptPhoneClients ?
            ptPhoneApp->ptPhoneClients->hPhone : (HPHONE) 0);

        UNLOCKTPHONEAPP (ptPhoneApp);

        if (hPhone)
        {
            DestroytPhoneClient (hPhone);
            LOCKTPHONEAPP (ptPhoneApp);
            goto destroy_tPhoneClients;
        }
    }


    //
    // Remove ptPhoneApp from tClient's list. Note that we don't
    // have to worry about dup-ing the mutex here because we know
    // it's valid & won't get closed before we release it.
    //

    {
        PTCLIENT    ptClient = (PTCLIENT) ptPhoneApp->ptClient;


        LOCKTCLIENT (ptClient);

        if (ptPhoneApp->pNext)
        {
            ptPhoneApp->pNext->pPrev = ptPhoneApp->pPrev;
        }

        if (ptPhoneApp->pPrev)
        {
            ptPhoneApp->pPrev->pNext = ptPhoneApp->pNext;
        }
        else
        {
            ptClient->ptPhoneApps = ptPhoneApp->pNext;
        }

        UNLOCKTCLIENT (ptClient);
    }


    //
    // Decrement total num inits & see if we need to go thru shutdown
    //

    TapiEnterCriticalSection (&TapiGlobals.CritSec);

    //assert(TapiGlobals.dwNumLineInits != 0);

    TapiGlobals.dwNumPhoneInits--;

    if ((TapiGlobals.dwNumLineInits == 0) &&
        (TapiGlobals.dwNumPhoneInits == 0) &&
        !(TapiGlobals.dwFlags & TAPIGLOBALS_SERVER))
    {
        ServerShutdown();
        gbServerInited = FALSE;
    }

    TapiLeaveCriticalSection (&TapiGlobals.CritSec);


    //
    // Decrement reference count by two to remove the initial
    // reference & the reference above
    //

    DereferenceObject (ghHandleTable, hPhoneApp, 2);

    return 0;
}


LONG
PASCAL
PhoneProlog(
    PTCLIENT    ptClient,
    DWORD       dwArgType,
    DWORD       dwArg,
    LPVOID      phdXxx,
    LPDWORD     pdwPrivilege,
    HANDLE     *phMutex,
    BOOL       *pbDupedMutex,
    DWORD       dwTSPIFuncIndex,
    TSPIPROC   *ppfnTSPI_phoneXxx,
    PASYNCREQUESTINFO  *ppAsyncRequestInfo,
    DWORD       dwRemoteRequestID
#if DBG
    ,char      *pszFuncName
#endif
    )
{
    LONG        lResult = 0;
    DWORD       initContext;
    DWORD       openContext;
    ULONG_PTR   htXxx;
    PTPROVIDER  ptProvider;

#if DBG
    LOG((TL_TRACE,  "PhoneProlog: (phone%s) enter", pszFuncName));
#else
    LOG((TL_TRACE,  "PhoneProlog:  -- enter"));
#endif

    *phMutex = NULL;
    *pbDupedMutex = FALSE;

    if (ppAsyncRequestInfo)
    {
        *ppAsyncRequestInfo = (PASYNCREQUESTINFO) NULL;
    }

    if (TapiGlobals.dwNumPhoneInits == 0)
    {
        lResult = PHONEERR_UNINITIALIZED;
        goto PhoneProlog_return;
    }

    if (ptClient->phContext == (HANDLE) -1)
    {
        lResult = PHONEERR_REINIT;
        goto PhoneProlog_return;
    }

    switch (dwArgType)
    {
    case ANY_RT_HPHONE:
    {
        PTPHONECLIENT   ptPhoneClient;


        if ((ptPhoneClient = ReferenceObject(
                ghHandleTable,
                dwArg,
                TPHONECLIENT_KEY
                )))
        {
            if (ptPhoneClient->ptClient != ptClient)
            {
                lResult = PHONEERR_INVALPHONEHANDLE;
            }
            else if (ptPhoneClient->dwPrivilege < *pdwPrivilege)
            {
                lResult = PHONEERR_NOTOWNER;
            }
            else
            {
                try
                {
                    ptProvider = ptPhoneClient->ptPhone->ptProvider;
                    *((HDRVPHONE *) phdXxx) = ptPhoneClient->ptPhone->hdPhone;

                     if (ppAsyncRequestInfo)
                     {
                         initContext = ptPhoneClient->ptPhoneApp->InitContext;
                         openContext = ptPhoneClient->OpenContext;
                         htXxx       = (ULONG_PTR)ptPhoneClient->ptPhone;
                     }
                }
                myexcept
                {
                    lResult = PHONEERR_INVALPHONEHANDLE;
                }

                if (lResult  ||  ptPhoneClient->dwKey != TPHONECLIENT_KEY)
                {
                    lResult = PHONEERR_INVALPHONEHANDLE;
                }
                else if (ptProvider->dwTSPIOptions &
                            LINETSPIOPTION_NONREENTRANT)
                {
                    if (!WaitForMutex(
                            ptProvider->hMutex,
                            phMutex,
                            pbDupedMutex,
                            ptProvider,
                            TPROVIDER_KEY,
                            INFINITE
                            ))
                    {
                        lResult = PHONEERR_OPERATIONFAILED;
                    }
                }
            }

            DereferenceObject (ghHandleTable, dwArg, 1);
        }
        else
        {
            lResult = PHONEERR_INVALPHONEHANDLE;
        }

        break;
    }
    case DEVICE_ID:
    {
        PTPHONELOOKUPENTRY  pPhoneLookupEntry;


#if TELE_SERVER

        //
        // Ff it's a server, map the device id
        //

        if ((TapiGlobals.dwFlags & TAPIGLOBALS_SERVER) &&
               !IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR))
        {
            try
            {
                if (*pdwPrivilege >= ptClient->dwPhoneDevices)
                {
                    lResult = PHONEERR_BADDEVICEID;
                    goto PhoneProlog_return;
                }

                *pdwPrivilege = (ptClient->pPhoneDevices)[*pdwPrivilege];
            }
            myexcept
            {
                lResult = PHONEERR_INVALPHONEHANDLE;
                goto PhoneProlog_return;
            }
        }
#endif

        if (dwArg  &&  !IsValidPhoneApp ((HPHONEAPP) dwArg, ptClient))
        {
            lResult = PHONEERR_INVALAPPHANDLE;
        }
        else if (!(pPhoneLookupEntry = GetPhoneLookupEntry (*pdwPrivilege)))
        {
            lResult = PHONEERR_BADDEVICEID;
        }
        else if (pPhoneLookupEntry->bRemoved)
        {
            lResult = PHONEERR_NODEVICE;
        }
        else if (!(ptProvider = pPhoneLookupEntry->ptProvider))
        {
            lResult = PHONEERR_NODRIVER;
        }
        else if (ptProvider->dwTSPIOptions & LINETSPIOPTION_NONREENTRANT)
        {
            if (!WaitForMutex(
                    ptProvider->hMutex,
                    phMutex,
                    pbDupedMutex,
                    ptProvider,
                    TPROVIDER_KEY,
                    INFINITE
                    ))
            {
                lResult = PHONEERR_OPERATIONFAILED;
            }
        }

        break;
    }
    } // switch

    if (lResult)
    {
        goto PhoneProlog_return;
    }


    //
    // Make sure that if caller wants a pointer to a TSPI proc that the
    // func is exported by the provider
    //

    if (ppfnTSPI_phoneXxx &&
        !(*ppfnTSPI_phoneXxx = ptProvider->apfn[dwTSPIFuncIndex]))
    {
        lResult = PHONEERR_OPERATIONUNAVAIL;
        goto PhoneProlog_return;
    }


    //
    // See if we need to alloc & init an ASYNCREQUESTINFO struct
    //

    if (ppAsyncRequestInfo)
    {
        PASYNCREQUESTINFO   pAsyncRequestInfo;


        if (!(pAsyncRequestInfo = ServerAlloc (sizeof(ASYNCREQUESTINFO))))
        {
            lResult = PHONEERR_NOMEM;
            goto PhoneProlog_return;
        }

        pAsyncRequestInfo->dwLocalRequestID = (DWORD)
            NewObject (ghHandleTable, pAsyncRequestInfo, NULL);

        if (pAsyncRequestInfo->dwLocalRequestID == 0)
        {
            ServerFree (pAsyncRequestInfo);
            lResult = LINEERR_NOMEM;
            goto PhoneProlog_return;
        }

        pAsyncRequestInfo->dwKey       = TASYNC_KEY;
        pAsyncRequestInfo->ptClient    = ptClient;
        pAsyncRequestInfo->InitContext = initContext;
        pAsyncRequestInfo->OpenContext = openContext;
        pAsyncRequestInfo->htXxx       = htXxx;
        pAsyncRequestInfo->dwLineFlags = 0;

        if (dwRemoteRequestID)
        {
            lResult = pAsyncRequestInfo->dwRemoteRequestID = dwRemoteRequestID;
        }
        else
        {
            lResult = pAsyncRequestInfo->dwRemoteRequestID =
                pAsyncRequestInfo->dwLocalRequestID;
        }

        *ppAsyncRequestInfo = pAsyncRequestInfo;
    }

PhoneProlog_return:

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "PhoneProlog: (phone%s) exit, result=%s",
            pszFuncName,
            MapResultCodeToText (lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE, 
            "PhoneProlog: exit, result=x%x",
            lResult
            ));
#endif

    return lResult;
}


void
PASCAL
PhoneEpilogSync(
    LONG   *plResult,
    HANDLE  hMutex,
    BOOL    bCloseMutex
#if DBG
    ,char *pszFuncName
#endif
    )
{
    MyReleaseMutex (hMutex, bCloseMutex);

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "PhoneEpilogSync: (phone%s) exit, result=%s",
            pszFuncName,
            MapResultCodeToText (*plResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE, 
            "PhoneEpilogSync: -- exit, result=x%x",
            *plResult
            ));
#endif
}


void
PASCAL
PhoneEpilogAsync(
    LONG   *plResult,
    LONG    lRequestID,
    HANDLE  hMutex,
    BOOL    bCloseMutex,
    PASYNCREQUESTINFO pAsyncRequestInfo
#if DBG
    ,char *pszFuncName
#endif
    )
{
    MyReleaseMutex (hMutex, bCloseMutex);


    if (lRequestID > 0)
    {
        if (*plResult <= 0)
        {
            if (*plResult == 0)
            {
                LOG((TL_ERROR, "Error: SP returned 0, not request ID"));
            }

            //
            // If here the service provider returned an error (or 0,
            // which it never should for async requests), so call
            // CompletionProcSP like the service provider normally
            // would, & the worker thread will take care of sending
            // the client a REPLY msg with the request result (we'll
            // return an async request id)
            //

            CompletionProcSP(
                pAsyncRequestInfo->dwLocalRequestID,
                *plResult
                );
        }
    }
    else if (pAsyncRequestInfo != NULL)
    {
        //
        // If here an error occured before we even called the service
        // provider, so just free the async request (the error will
        // be returned to the client synchronously)
        //

        DereferenceObject(
            ghHandleTable,
            pAsyncRequestInfo->dwLocalRequestID,
            1
            );
    }

    *plResult = lRequestID;

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "PhoneEpilogSync: (phone%s) exit, result=%s",
            pszFuncName,
            MapResultCodeToText (lRequestID, szResult)
            ));
    }
#else
        LOG((TL_TRACE, 
            "PhoneEpilogSync: -- exit, result=x%x",
            lRequestID
            ));
#endif
}


BOOL
PASCAL
WaitForExclusivetPhoneAccess(
    PTPHONE     ptPhone,
    HANDLE     *phMutex,
    BOOL       *pbDupedMutex,
    DWORD       dwTimeout
    )
{
    try
    {
        if (ptPhone->dwKey == TPHONE_KEY  &&

            WaitForMutex(
                ptPhone->hMutex,
                phMutex,
                pbDupedMutex,
                (LPVOID) ptPhone,
                TPHONE_KEY,
                INFINITE
                ))
        {
            if (ptPhone->dwKey == TPHONE_KEY)
            {
                return TRUE;
            }

            MyReleaseMutex (*phMutex, *pbDupedMutex);
        }

    }
    myexcept
    {
        // do nothing
    }

    return FALSE;
}


PTPHONEAPP
PASCAL
WaitForExclusivePhoneAppAccess(
    HPHONEAPP   hPhoneApp,
    PTCLIENT    ptClient
    )
{
    PTPHONEAPP  ptPhoneApp;


    if (!(ptPhoneApp = ReferenceObject(
            ghHandleTable,
            hPhoneApp,
            TPHONEAPP_KEY
            )))
    {
        return NULL;
    }

    LOCKTPHONEAPP (ptPhoneApp);

    if ((ptPhoneApp->dwKey != TPHONEAPP_KEY)  ||
        (ptPhoneApp->ptClient != ptClient))
    {
        UNLOCKTPHONEAPP (ptPhoneApp);

        ptPhoneApp = NULL;
    }

    DereferenceObject (ghHandleTable, hPhoneApp, 1);

    return ptPhoneApp;
}


LONG
PASCAL
GetPhoneAppListFromClient(
    PTCLIENT        ptClient,
    PTPOINTERLIST  *ppList
    )
{
    if (WaitForExclusiveClientAccess (ptClient))
    {
        DWORD           dwNumTotalEntries = DEF_NUM_PTR_LIST_ENTRIES,
                        dwNumUsedEntries = 0;
        PTPHONEAPP      ptPhoneApp = ptClient->ptPhoneApps;
        PTPOINTERLIST   pList = *ppList;


        while (ptPhoneApp)
        {
            if (dwNumUsedEntries == dwNumTotalEntries)
            {
                //
                // We need a larger list, so alloc a new one, copy the
                // contents of the current one, and the free the current
                // one iff we previously alloc'd it
                //

                PTPOINTERLIST   pNewList;


                dwNumTotalEntries <<= 1;

                if (!(pNewList = ServerAlloc(
                        sizeof (TPOINTERLIST) + sizeof (LPVOID) *
                            (dwNumTotalEntries - DEF_NUM_PTR_LIST_ENTRIES)
                        )))
                {
                    UNLOCKTCLIENT (ptClient);
                    return PHONEERR_NOMEM;
                }

                CopyMemory(
                    pNewList->aEntries,
                    pList->aEntries,
                    dwNumUsedEntries * sizeof (LPVOID)
                    );

                if (pList != *ppList)
                {
                    ServerFree (pList);
                }

                pList = pNewList;
            }

            pList->aEntries[dwNumUsedEntries++] = ptPhoneApp;

            ptPhoneApp = ptPhoneApp->pNext;
        }

        UNLOCKTCLIENT (ptClient);

        pList->dwNumUsedEntries = dwNumUsedEntries;

        *ppList = pList;
    }
    else
    {
        return PHONEERR_OPERATIONFAILED;
    }

    return 0;
}


LONG
PASCAL
GetPhoneClientListFromPhone(
    PTPHONE         ptPhone,
    PTPOINTERLIST  *ppList
    )
{
    BOOL    bDupedMutex;
    HANDLE  hMutex;


    if (WaitForExclusivetPhoneAccess(
            ptPhone,
            &hMutex,
            &bDupedMutex,
            INFINITE
            ))
    {
        DWORD           dwNumTotalEntries = DEF_NUM_PTR_LIST_ENTRIES,
                        dwNumUsedEntries = 0;
        PTPOINTERLIST   pList = *ppList;
        PTPHONECLIENT   ptPhoneClient = ptPhone->ptPhoneClients;


        while (ptPhoneClient)
        {
            if (dwNumUsedEntries == dwNumTotalEntries)
            {
                //
                // We need a larger list, so alloc a new one, copy the
                // contents of the current one, and the free the current
                // one iff we previously alloc'd it
                //

                PTPOINTERLIST   pNewList;


                dwNumTotalEntries <<= 1;

                if (!(pNewList = ServerAlloc(
                        sizeof (TPOINTERLIST) + sizeof (LPVOID) *
                            (dwNumTotalEntries - DEF_NUM_PTR_LIST_ENTRIES)
                        )))
                {
                    MyReleaseMutex (hMutex, bDupedMutex);
                    return PHONEERR_NOMEM;
                }

                CopyMemory(
                    pNewList->aEntries,
                    pList->aEntries,
                    dwNumUsedEntries * sizeof (LPVOID)
                    );

                if (pList != *ppList)
                {
                    ServerFree (pList);
                }

                pList = pNewList;
            }

            pList->aEntries[dwNumUsedEntries++] = ptPhoneClient;

            ptPhoneClient = ptPhoneClient->pNextSametPhone;
        }

        MyReleaseMutex (hMutex, bDupedMutex);

        pList->dwNumUsedEntries = dwNumUsedEntries;

        *ppList = pList;
    }
    else
    {
        return PHONEERR_INVALPHONEHANDLE;
    }

    return 0;
}


void
PASCAL
SendMsgToPhoneClients(
    PTPHONE         ptPhone,
    PTPHONECLIENT   ptPhoneClientToExclude,
    DWORD           Msg,
    DWORD           Param1,
    DWORD           Param2,
    DWORD           Param3
    )
{
    DWORD           i;
    TPOINTERLIST    clientList, *pClientList = &clientList;
    ASYNCEVENTMSG   msg;


    if (Msg == PHONE_STATE  &&  Param1 & PHONESTATE_REINIT)
    {
        SendReinitMsgToAllXxxApps();

        if (Param1 == PHONESTATE_REINIT)
        {
            return;
        }
        else
        {
            Param1 &= ~PHONESTATE_REINIT;
        }
    }

    if (GetPhoneClientListFromPhone (ptPhone, &pClientList) != 0)
    {
        return;
    }

    msg.TotalSize          = sizeof (ASYNCEVENTMSG);
    msg.fnPostProcessProcHandle = 0;
    msg.Msg                = Msg;
    msg.Param1             = Param1;
    msg.Param2             = Param2;
    msg.Param3             = Param3;

    for (i = 0; i < pClientList->dwNumUsedEntries; i++)
    {
        try
        {
            PTCLIENT        ptClient;
            PTPHONECLIENT   ptPhoneClient = pClientList->aEntries[i];


            if (ptPhoneClient == ptPhoneClientToExclude)
            {
                continue;
            }

            if (FMsgDisabled (
                ptPhoneClient->ptPhoneApp->dwAPIVersion,
                ptPhoneClient->adwEventSubMasks,
                (DWORD) Msg,
                (DWORD) Param1
                ))
            {
                continue;
            }

            if (Msg == PHONE_STATE)
            {
                DWORD   phoneStates = Param1;


                //
                // Munge the state flags so we don't pass
                // unexpected flags to old apps
                //

                switch (ptPhoneClient->dwAPIVersion)
                {
                case TAPI_VERSION1_0:

                    phoneStates &= AllPhoneStates1_0;
                    break;

                default: // case TAPI_VERSION1_4:
                         // case TAPI_VERSION_CURRENT:

                    phoneStates &= AllPhoneStates1_4;
                    break;
                }

                if (Param1 & PHONESTATE_CAPSCHANGE)
                {
                }

                if (ptPhoneClient->dwPhoneStates & (DWORD) phoneStates)
                {
                    msg.Param1 = phoneStates;
                }
                else
                {
                    continue;
                }
            }
            else if (Msg == PHONE_BUTTON)
            {
                DWORD       buttonModes = Param2,
                            buttonStates = Param3;


                //
                // Munge the state flags so we don't pass
                // unexpected flags to old apps
                //

                switch (ptPhoneClient->dwAPIVersion)
                {
                case TAPI_VERSION1_0:

                    buttonStates &= AllButtonStates1_0;
                    break;

                default:    // case TAPI_VERSION1_4:
                            // case TAPI_VERSION_CURRENT:

                    buttonStates &= AllButtonStates1_4;
                    break;
                }

                if (((DWORD) buttonModes & ptPhoneClient->dwButtonModes) &&
                    ((DWORD) buttonStates & ptPhoneClient->dwButtonStates))
                {
                    msg.Param2 = buttonModes;
                    msg.Param3 = buttonStates;
                }
                else
                {
                    continue;
                }
            }

            msg.InitContext =
                ((PTPHONEAPP) ptPhoneClient->ptPhoneApp)->InitContext;
            msg.hDevice     = ptPhoneClient->hRemotePhone;
            msg.OpenContext = ptPhoneClient->OpenContext;

            ptClient = ptPhoneClient->ptClient;

            if (ptPhoneClient->dwKey == TPHONECLIENT_KEY)
            {
                WriteEventBuffer (ptClient, &msg);
            }
        }
        myexcept
        {
            // just continue
        }
    }

    if (pClientList != &clientList)
    {
        ServerFree (pClientList);
    }
}


void
PASCAL
PhoneEventProc(
    HTAPIPHONE  htPhone,
    DWORD       dwMsg,
    ULONG_PTR   Param1,
    ULONG_PTR   Param2,
    ULONG_PTR   Param3
    )
{
 PTPHONE ptPhone = (PTPHONE)htPhone;

    switch (dwMsg)
    {
        case PHONE_CLOSE:
        {
            if (NULL == ptPhone)
            {
                break;
            }

            if (ptPhone->dwKey == TINCOMPLETEPHONE_KEY)
            {
                //
                // The device is in the process of getting opened but
                // the key has not been set & the Open() func still owns
                // the mutex and has stuff to do, so repost the msg
                // and try again later. (Set Param3 to special value
                // to indicate this repost, so EventProcSP doesn't recurse)
                //

                PhoneEventProcSP (htPhone, PHONE_CLOSE, 0, 0, 0xdeadbeef);
            }
            else if (ptPhone->dwKey == TPHONE_KEY)
            {
                DestroytPhone (ptPhone, TRUE); // unconditional destroy
            }

            break;
        }
        case PHONE_DEVSPECIFIC:
        case PHONE_STATE:
        case PHONE_BUTTON:
        {
            if (dwMsg == PHONE_STATE  &&
                ptPhone == NULL  &&
                Param1 & PHONESTATE_REINIT)
            {
                SendReinitMsgToAllXxxApps();
            }
            else
            {
                SendMsgToPhoneClients(
                    ptPhone,
                    NULL,
                    dwMsg,
                    DWORD_CAST(Param1,__FILE__,__LINE__),
                    DWORD_CAST(Param2,__FILE__,__LINE__),
                    DWORD_CAST(Param3,__FILE__,__LINE__)
                    );
            }

            break;
        }
        case PHONE_CREATE:
        {
            LONG                lResult;
            DWORD               dwDeviceID;
            TSPIPROC            pfnTSPI_providerCreatePhoneDevice;
            PTPROVIDER          ptProvider = (PTPROVIDER) Param1;
            PTPHONELOOKUPTABLE  pTable, pPrevTable;
            PTPHONELOOKUPENTRY  pEntry;
            PTPROVIDER          ptProvider2;


            pfnTSPI_providerCreatePhoneDevice =
                    ptProvider->apfn[SP_PROVIDERCREATEPHONEDEVICE];

            assert (pfnTSPI_providerCreatePhoneDevice != NULL);


            //
            // Search for a table entry (create a new table if we can't find
            // a free entry in an existing table)
            //

            TapiEnterCriticalSection (&TapiGlobals.CritSec);

            //  Check to make sure provider is still loaded
            ptProvider2 = TapiGlobals.ptProviders;
            while (ptProvider2 && ptProvider2 != ptProvider)
            {
                ptProvider2 = ptProvider2->pNext;
            }

            if (ptProvider2 != ptProvider)
            {
                TapiLeaveCriticalSection (&TapiGlobals.CritSec);
                return;
            }
        
            if (!gbQueueSPEvents)
            {
                //
                // We're shutting down, so bail out
                //

                TapiLeaveCriticalSection (&TapiGlobals.CritSec);

                return;
            }

            pTable = pPrevTable = TapiGlobals.pPhoneLookup;

            while (pTable &&
                   !(pTable->dwNumUsedEntries < pTable->dwNumTotalEntries))
            {
                pPrevTable = pTable;

                pTable = pTable->pNext;
            }

            if (!pTable)
            {
                if (!(pTable = ServerAlloc(
                        sizeof (TPHONELOOKUPTABLE) +
                            (2 * pPrevTable->dwNumTotalEntries - 1) *
                            sizeof (TPHONELOOKUPENTRY)
                        )))
                {
                    TapiLeaveCriticalSection (&TapiGlobals.CritSec);
                    break;
                }

                pPrevTable->pNext = pTable;

                pTable->dwNumTotalEntries = 2 * pPrevTable->dwNumTotalEntries;
            }


            //
            // Initialize the table entry
            //

            pEntry = pTable->aEntries + pTable->dwNumUsedEntries;

            dwDeviceID = TapiGlobals.dwNumPhones;

            if ((pEntry->hMutex = MyCreateMutex()))
            {
                pEntry->ptProvider = (PTPROVIDER) Param1;


                //
                // Now call the creation & negotiation entrypoints, and if all
                // goes well increment the counts & send msgs to the clients
                //

                if ((lResult = CallSP2(
                        pfnTSPI_providerCreatePhoneDevice,
                        "providerCreatePhoneDevice",
                        SP_FUNC_SYNC,
                        (ULONG_PTR) Param2,
                        (DWORD) dwDeviceID

                        )) == 0)
                {
                    TSPIPROC    pfnTSPI_phoneNegotiateTSPIVersion =
                                    ptProvider->apfn[SP_PHONENEGOTIATETSPIVERSION];
                    TPOINTERLIST    clientList, *pClientList = &clientList;


                    if (pfnTSPI_phoneNegotiateTSPIVersion &&
                        (lResult = CallSP4(
                            pfnTSPI_phoneNegotiateTSPIVersion,
                            "",
                            SP_FUNC_SYNC,
                            (DWORD) dwDeviceID,
                            (DWORD) TAPI_VERSION1_0,
                            (DWORD) TAPI_VERSION_CURRENT,
                            (ULONG_PTR) &pEntry->dwSPIVersion

                            )) == 0)
                    {
                        PTCLIENT        ptClient;
                        ASYNCEVENTMSG   msg;


                        GetPermPhoneIDAndInsertInTable(
                            ptProvider,
                            dwDeviceID,
                            pEntry->dwSPIVersion
                            );

                        pTable->dwNumUsedEntries++;

                        TapiGlobals.dwNumPhones++;

                        TapiLeaveCriticalSection (&TapiGlobals.CritSec);
                        AppendNewDeviceInfo (FALSE, dwDeviceID);
                        TapiEnterCriticalSection (&TapiGlobals.CritSec);
                        
                        msg.TotalSize          = sizeof (ASYNCEVENTMSG);
                        msg.fnPostProcessProcHandle = 0;
                        msg.hDevice            = 0;
                        msg.OpenContext        = 0;
                        msg.Param2             = 0;
                        msg.Param3             = 0;

                        // only send the message if the client is an
                        // admin or we're not a telephony server
                        // we don't want to send the message to non-admin
                        // clients, because their phones have not changed.
                        if (TapiGlobals.dwFlags & TAPIGLOBALS_SERVER)
                        {
                            lResult = GetClientList (TRUE, &pClientList);
                        }
                        else
                        {
                            lResult = GetClientList (FALSE, &pClientList);
                        }
                        if (lResult == S_OK)
                        {
                            DWORD           i;
                            PTPHONEAPP      ptPhoneApp;
                    
                            for (i = 0; i < pClientList->dwNumUsedEntries; ++i)
                            {
                                ptClient = (PTCLIENT) pClientList->aEntries[i];
                                if (!WaitForExclusiveClientAccess (ptClient))
                                {
                                    continue;
                                }
                                ptPhoneApp = ptClient->ptPhoneApps;

                                while (ptPhoneApp)
                                {
                                    if (ptPhoneApp->dwAPIVersion == TAPI_VERSION1_0)
                                    {
                                        msg.Msg    = PHONE_STATE;
                                        msg.Param1 = PHONESTATE_REINIT;
                                    }
                                    else
                                    {
                                        msg.Msg    = PHONE_CREATE;
                                        msg.Param1 = dwDeviceID;
                                    }

                                    if (!FMsgDisabled(
                                        ptPhoneApp->dwAPIVersion,
                                        ptPhoneApp->adwEventSubMasks,
                                        (DWORD) msg.Msg,
                                        (DWORD) msg.Param1
                                        ))
                                    {
                                        msg.InitContext = ptPhoneApp->InitContext;

                                        WriteEventBuffer (ptClient, &msg);
                                    }

                                    ptPhoneApp = ptPhoneApp->pNext;
                                }

                                UNLOCKTCLIENT (ptClient);
                            }
                        }
                    }
                    
                    if (pClientList != &clientList)
                    {
                        ServerFree (pClientList);
                    }
                }

                if (lResult)
                {
                    MyCloseMutex (pEntry->hMutex);
                }
            }

            TapiLeaveCriticalSection (&TapiGlobals.CritSec);
            break;
        }
        case PHONE_REMOVE:
        {
            PTPHONELOOKUPENTRY  pLookupEntry;
            HANDLE              hLookupEntryMutex = NULL;
            BOOL                bOK = FALSE;

            TapiEnterCriticalSection (&TapiGlobals.CritSec);
            if (!(pLookupEntry = GetPhoneLookupEntry ((DWORD) Param1)) ||
                pLookupEntry->bRemoved)
            {
                TapiLeaveCriticalSection (&TapiGlobals.CritSec);
                return;
            }

            if ( pLookupEntry->hMutex )
            {
                bOK = DuplicateHandle(
                            TapiGlobals.hProcess,
                            pLookupEntry->hMutex,
                            TapiGlobals.hProcess,
                            &hLookupEntryMutex,
                            0,
                            FALSE,
                            DUPLICATE_SAME_ACCESS
                            );
            }

            TapiLeaveCriticalSection(&TapiGlobals.CritSec); 

            if ( !bOK )
            {
                return;
            }

            //
            // Wait for the LookupEntry's mutex on the duplicate handle
            //
            if (WaitForSingleObject (hLookupEntryMutex, INFINITE)
                        != WAIT_OBJECT_0)
            {
                return;
            }

            //
            // Mark the lookup table entry as removed
            //

            pLookupEntry->bRemoved = 1;

            //
            // Release the mutex and close the duplicate handle
            //
            ReleaseMutex (hLookupEntryMutex);
            CloseHandle (hLookupEntryMutex);
            hLookupEntryMutex = NULL;

            if (pLookupEntry->ptPhone)
            {
                DestroytPhone (pLookupEntry->ptPhone, TRUE); // unconditional destroy
            }

            TapiEnterCriticalSection (&TapiGlobals.CritSec);

            //
            // Close the mutex to reduce overall handle count
            //

            MyCloseMutex (pLookupEntry->hMutex);
            pLookupEntry->hMutex = NULL;

            RemoveDeviceInfoEntry (FALSE, DWORD_CAST(Param1,__FILE__,__LINE__));
            TapiLeaveCriticalSection(&TapiGlobals.CritSec); 

            SendAMsgToAllPhoneApps(
                TAPI_VERSION2_0 | 0x80000000,
                PHONE_REMOVE,
                DWORD_CAST(Param1,__FILE__,__LINE__),
                0,
                0
                );

            break;
        }
        default:

            LOG((TL_ERROR, "PhoneEventProc: unknown msg, dwMsg=%ld", dwMsg));
            break;
    }
}


void
CALLBACK
PhoneEventProcSP(
    HTAPIPHONE  htPhone,
    DWORD       dwMsg,
    ULONG_PTR   Param1,
    ULONG_PTR   Param2,
    ULONG_PTR   Param3
    )
{
    PSPEVENT    pSPEvent;

    LOG((TL_TRACE, 
        "PhoneEventProc: enter\n\thtPhone=x%lx, Msg=x%lx\n" \
            "\tP1=x%lx, P2=x%lx, P3=x%lx",
        htPhone,
        dwMsg,
        Param1,
        Param2,
        Param3
        ));

    if ((pSPEvent = (PSPEVENT) ServerAlloc (sizeof (SPEVENT))))
    {
        pSPEvent->dwType   = SP_PHONE_EVENT;
        pSPEvent->htPhone  = htPhone;
        pSPEvent->dwMsg    = dwMsg;
        pSPEvent->dwParam1 = Param1;
        pSPEvent->dwParam2 = Param2;
        pSPEvent->dwParam3 = Param3;

        if (!QueueSPEvent (pSPEvent))
        {
            ServerFree (pSPEvent);
        }
    }
    else if (dwMsg != PHONE_CLOSE  ||  Param3 != 0xdeadbeef)
    {
        //
        // Alloc failed, so call the event proc within the SP's context
        // (but not if it's  CLOSE msg and Param3 == 0xdeadbeef,
        // which means the real EventProc() is calling us directly &
        // we don't want to recurse)
        //

        PhoneEventProc (htPhone, dwMsg, Param1, Param2, Param3);
    }
}

void
WINAPI
PClose(
    PTCLIENT            ptClient,
    PPHONECLOSE_PARAMS  pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    BOOL        bCloseMutex;
    HANDLE      hMutex;
    HDRVPHONE   hdPhone;
    DWORD       dwPrivilege = PHONEPRIVILEGE_MONITOR;


    if ((pParams->lResult = PHONEPROLOG(
            ptClient,                   // tClient
            ANY_RT_HPHONE,              // widget type
            (DWORD) pParams->hPhone,    // client widget handle
            (LPVOID) &hdPhone,          // provider widget handle
            &dwPrivilege,               // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            0,                          // provider func index
            NULL,                       // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            "Close"                     // func name

            )) == 0)
    {
     PTPHONECLIENT   ptPhoneClient;
        if ((ptPhoneClient = ReferenceObject(
                ghHandleTable,
                pParams->hPhone,
                TPHONECLIENT_KEY
                )))
        {
            pParams->dwCallbackInstance = ptPhoneClient->OpenContext;
            DereferenceObject (ghHandleTable, pParams->hPhone, 1);
        }
        DestroytPhoneClient ((HPHONE) pParams->hPhone);
    }

    PHONEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        "Close"
        );
}


void
PDevSpecific_PostProcess(
    PASYNCREQUESTINFO   pAsyncRequestInfo,
    PASYNCEVENTMSG      pAsyncEventMsg,
    LPVOID             *ppBuf
    )
{
    PASYNCEVENTMSG  pNewAsyncEventMsg = (PASYNCEVENTMSG)
                        pAsyncRequestInfo->dwParam3;


    CopyMemory (pNewAsyncEventMsg, pAsyncEventMsg, sizeof (ASYNCEVENTMSG));

    *ppBuf = pNewAsyncEventMsg;

    if (pAsyncEventMsg->Param2 == 0)  // success
    {
        //
        // Make sure to keep the total size 64-bit aligned
        //

        pNewAsyncEventMsg->TotalSize +=
            (DWORD_CAST(pAsyncRequestInfo->dwParam2,__FILE__,__LINE__) + 7) & 0xfffffff8;


        pNewAsyncEventMsg->Param3 = DWORD_CAST(pAsyncRequestInfo->dwParam1,__FILE__,__LINE__); // lpParams
        pNewAsyncEventMsg->Param4 = DWORD_CAST(pAsyncRequestInfo->dwParam2,__FILE__,__LINE__); // dwSize
    }
}


void
WINAPI
PDevSpecific(
    PTCLIENT                    ptClient,
    PPHONEDEVSPECIFIC_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVPHONE           hdPhone;
    PASYNCREQUESTINFO   pAsyncRequestInfo;
    TSPIPROC            pfnTSPI_phoneDevSpecific;
    DWORD               dwPrivilege = PHONEPRIVILEGE_MONITOR;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwParamsSize,
            pParams->dwParamsOffset,
            sizeof(DWORD),
            "PDevSpecific",
            "pParams->Params"
            ))
    {
        pParams->lResult = PHONEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = PHONEPROLOG(
            ptClient,          // tClient
            ANY_RT_HPHONE,              // widget type
            (DWORD) pParams->hPhone,    // client widget handle
            (LPVOID) &hdPhone,          // provider widget handle
            &dwPrivilege,               // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_PHONEDEVSPECIFIC,        // provider func index
            &pfnTSPI_phoneDevSpecific,  // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            "DevSpecific"               // func name

            )) > 0)
    {
        LPBYTE  pBuf;


        //
        // Alloc a shadow buf that the SP can use until it completes this
        // request.  Make sure there's enough extra space in the buf for
        // an ASYNCEVENTMSG header so we don't have to alloc yet another
        // buf in the post processing proc when preparing the completion
        // msg to send to the client, and that the msg is 64-bit aligned.
        //

        if (!(pBuf = ServerAlloc(
                ((pParams->dwParamsSize + 7) & 0xfffffff8) +
                    sizeof (ASYNCEVENTMSG)
                )))
        {
            lRequestID = PHONEERR_NOMEM;
            goto PDevSpecific_epilog;
        }

        CopyMemory(
            pBuf + sizeof (ASYNCEVENTMSG),
            pDataBuf + pParams->dwParamsOffset,
            pParams->dwParamsSize
            );

        pAsyncRequestInfo->pfnPostProcess = PDevSpecific_PostProcess;
        pAsyncRequestInfo->dwParam1       = pParams->hpParams;
        pAsyncRequestInfo->dwParam2       = pParams->dwParamsSize;
        pAsyncRequestInfo->dwParam3       = (ULONG_PTR) pBuf;

        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;

        pParams->lResult = CallSP4(
            pfnTSPI_phoneDevSpecific,
            "phoneDevSpecific",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR)  hdPhone,
            (ULONG_PTR) (pParams->dwParamsSize ?
                pBuf + sizeof (ASYNCEVENTMSG) : NULL),
            (DWORD) pParams->dwParamsSize
            );
    }

PDevSpecific_epilog:

    PHONEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        "DevSpecific"
        );
}


void
WINAPI
PGetButtonInfo(
    PTCLIENT                    ptClient,
    PPHONEGETBUTTONINFO_PARAMS  pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL        bCloseMutex;
    HANDLE      hMutex;
    HDRVPHONE   hdPhone;
    TSPIPROC    pfnTSPI_phoneGetButtonInfo;
    DWORD       dwPrivilege = PHONEPRIVILEGE_MONITOR;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (pParams->dwButtonInfoTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = PHONEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = PHONEPROLOG(
            ptClient,          // tClient
            ANY_RT_HPHONE,              // widget type
            (DWORD) pParams->hPhone,    // client widget handle
            (LPVOID) &hdPhone,          // provider widget handle
            &dwPrivilege,     // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_PHONEGETBUTTONINFO,      // provider func index
            &pfnTSPI_phoneGetButtonInfo,// provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            "GetButtonInfo"             // func name

            )) == 0)
    {
        DWORD               dwAPIVersion, dwSPIVersion, dwTotalSize,
                            dwFixedSizeClient, dwFixedSizeSP;
        LPPHONEBUTTONINFO   pButtonInfo = (LPPHONEBUTTONINFO) pDataBuf,
                            pButtonInfo2 = (LPPHONEBUTTONINFO) NULL;


        //
        // Safely retrieve the API & SPI versions
        //

        if (GetPhoneVersions(
                pParams->hPhone,
                &dwAPIVersion,
                &dwSPIVersion

                ) != 0)
        {
            pParams->lResult = PHONEERR_INVALPHONEHANDLE;
            goto PGetButtonInfo_epilog;
        }


        //
        // Determine the fixed size of the structure for the specified API
        // version, verify client's buffer is big enough
        //

        dwTotalSize = pParams->dwButtonInfoTotalSize;

        switch (dwAPIVersion)
        {
        case TAPI_VERSION1_0:

            dwFixedSizeClient = 0x24;
            break;

        default: // case TAPI_VERSION_CURRENT:

            dwFixedSizeClient = sizeof (PHONEBUTTONINFO);
            break;
        }

        if (dwTotalSize < dwFixedSizeClient)
        {
            pParams->lResult = PHONEERR_STRUCTURETOOSMALL;
            goto PGetButtonInfo_epilog;
        }


        //
        // Determine the fixed size of the structure expected by the SP
        //

        switch (dwSPIVersion)
        {
        case TAPI_VERSION1_0:

            dwFixedSizeSP = 0x24;
            break;

        default: // case TAPI_VERSION_CURRENT:

            dwFixedSizeSP = sizeof (PHONEBUTTONINFO);
            break;
        }


        //
        // If the client's buffer is < the fixed size of that expected by
        // the SP (client is lower version than SP) then allocate an
        // intermediate buffer
        //

        if (dwTotalSize < dwFixedSizeSP)
        {
            if (!(pButtonInfo2 = ServerAlloc (dwFixedSizeSP)))
            {
                pParams->lResult = PHONEERR_NOMEM;
                goto PGetButtonInfo_epilog;
            }

            pButtonInfo = pButtonInfo2;
            dwTotalSize = dwFixedSizeSP;
        }


        InitTapiStruct(
            pButtonInfo,
            dwTotalSize,
            dwFixedSizeSP,
            (pButtonInfo2 == NULL ? TRUE : FALSE)
            );

        if ((pParams->lResult = CallSP3(
                pfnTSPI_phoneGetButtonInfo,
                "phoneGetButtonInfo",
                SP_FUNC_SYNC,
                (ULONG_PTR) hdPhone,
                (DWORD) pParams->dwButtonLampID,
                (ULONG_PTR) pButtonInfo

                )) == 0)
        {
#if DBG
            //
            // Verify the info returned by the provider
            //

#endif

            //
            // Add the fields we're responsible for
            //


            //
            // Munge fields where appropriate for old apps (don't want to
            // pass back flags that they won't understand)
            //


            //
            // If an intermediate buffer was used then copy the bits back
            // to the the original buffer, & free the intermediate buffer.
            // Also reset the dwUsedSize field to the fixed size of the
            // structure for the specifed version, since any data in the
            // variable portion is garbage as far as the client is concerned.
            //

            if (pButtonInfo == pButtonInfo2)
            {
                pButtonInfo = (LPPHONEBUTTONINFO) pDataBuf;

                CopyMemory (pButtonInfo, pButtonInfo2, dwFixedSizeClient);

                ServerFree (pButtonInfo2);

                pButtonInfo->dwTotalSize = pParams->dwButtonInfoTotalSize;
                pButtonInfo->dwUsedSize  = dwFixedSizeClient;
            }


            //
            // Indicate the offset & how many bytes of data we're passing back
            //

            pParams->dwButtonInfoOffset = 0;

            *pdwNumBytesReturned = sizeof (TAPI32_MSG) +
                pButtonInfo->dwUsedSize;
        }
    }

PGetButtonInfo_epilog:

    PHONEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        "GetButtonInfo"
        );
}


void
WINAPI
PGetData(
    PTCLIENT                ptClient,
    PPHONEGETDATA_PARAMS    pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL        bCloseMutex;
    HANDLE      hMutex;
    HDRVPHONE   hdPhone;
    TSPIPROC    pfnTSPI_phoneGetData;
    DWORD       dwPrivilege = PHONEPRIVILEGE_MONITOR;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (pParams->dwSize > dwParamsBufferSize)
    {
        pParams->lResult = PHONEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = PHONEPROLOG(
            ptClient,          // tClient
            ANY_RT_HPHONE,              // widget type
            (DWORD) pParams->hPhone,    // client widget handle
            (LPVOID) &hdPhone,          // provider widget handle
            &dwPrivilege,     // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_PHONEGETDATA,            // provider func index
            &pfnTSPI_phoneGetData,      // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            "GetData"                   // func name

            )) == 0)
    {
        if ((pParams->lResult = CallSP4(
                pfnTSPI_phoneGetData,
                "phoneGetData",
                SP_FUNC_SYNC,
                (ULONG_PTR) hdPhone,
                (DWORD) pParams->dwDataID,
                (ULONG_PTR) pDataBuf,
                (DWORD) pParams->dwSize

                )) == 0)
        {
            //
            // Indicate offset & how many bytes of data we're passing back
            //

            pParams->dwDataOffset = 0;

            *pdwNumBytesReturned = sizeof (TAPI32_MSG) + pParams->dwSize;
        }
    }

    PHONEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        "GetData"
        );
}


void
WINAPI
PGetDevCaps(
    PTCLIENT                ptClient,
    PPHONEGETDEVCAPS_PARAMS pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL        bCloseMutex;
    DWORD       dwDeviceID = pParams->dwDeviceID;
    HANDLE      hMutex;
    TSPIPROC    pfnTSPI_phoneGetDevCaps;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (pParams->dwPhoneCapsTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = PHONEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = PHONEPROLOG(
            ptClient,          // tClient
            DEVICE_ID,                  // widget type
            (DWORD) pParams->hPhoneApp, // client widget handle
            NULL,                       // provider widget handle
            &dwDeviceID,                 // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_PHONEGETDEVCAPS,         // provider func index
            &pfnTSPI_phoneGetDevCaps,   // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            "GetDevCaps"                // func name

            )) == 0)
    {
        DWORD       dwAPIVersion, dwSPIVersion, dwTotalSize,
                    dwFixedSizeClient, dwFixedSizeSP;
        LPPHONECAPS pCaps = (LPPHONECAPS) pDataBuf,
                    pCaps2 = (LPPHONECAPS) NULL;


        //
        // Verify API & SPI version compatibility
        //

        dwAPIVersion = pParams->dwAPIVersion;

        dwSPIVersion =
            (GetPhoneLookupEntry (dwDeviceID))->dwSPIVersion;

        if (!IsAPIVersionInRange (dwAPIVersion, dwSPIVersion))
        {
            pParams->lResult = PHONEERR_INCOMPATIBLEAPIVERSION;
            goto PGetDevCaps_epilog;
        }


        //
        // Verify Ext version compatibility
        //

        if (!IsValidPhoneExtVersion (dwDeviceID, pParams->dwExtVersion))
        {
            pParams->lResult = PHONEERR_INCOMPATIBLEEXTVERSION;
            goto PGetDevCaps_epilog;
        }


        //
        // Determine the fixed size of the structure for the specified API
        // version, verify client's buffer is big enough
        //

        dwTotalSize = pParams->dwPhoneCapsTotalSize;

        switch (dwAPIVersion)
        {
        case TAPI_VERSION1_0:
        case TAPI_VERSION1_4:

            dwFixedSizeClient = 144;    // 36 * sizeof (DWORD)
            break;

        case TAPI_VERSION2_0:
        case TAPI_VERSION2_1:

            dwFixedSizeClient = 180;    // 45 * sizeof (DWORD)
            break;

        // case TAPI_VERSION2_2:
        default: // (fix ppc build wrn) case TAPI_VERSION_CURRENT:

            dwFixedSizeClient = sizeof (PHONECAPS);
            break;
        }

        if (dwTotalSize < dwFixedSizeClient)
        {
            pParams->lResult = PHONEERR_STRUCTURETOOSMALL;
            goto PGetDevCaps_epilog;
        }


        //
        // Determine the fixed size of the structure expected by the SP
        //

        switch (dwSPIVersion)
        {
        case TAPI_VERSION1_0:
        case TAPI_VERSION1_4:

            dwFixedSizeSP =  144;       // 36 * sizeof (DWORD)
            break;

        case TAPI_VERSION2_0:
        case TAPI_VERSION2_1:

            dwFixedSizeSP =  180;       // 45 * sizeof (DWORD)
            break;

        // case TAPI_VERSION2_2:
        default: // (fix ppc build wrn) case TAPI_VERSION_CURRENT:

            dwFixedSizeSP = sizeof (PHONECAPS);
            break;
        }


        //
        // If the client's buffer is < the fixed size of that expected by
        // the SP (client is lower version than SP) then allocate an
        // intermediate buffer
        //

        if (dwTotalSize < dwFixedSizeSP)
        {
            if (!(pCaps2 = ServerAlloc (dwFixedSizeSP)))
            {
                pParams->lResult = PHONEERR_NOMEM;
                goto PGetDevCaps_epilog;
            }

            pCaps       = pCaps2;
            dwTotalSize = dwFixedSizeSP;
        }


        InitTapiStruct(
            pCaps,
            dwTotalSize,
            dwFixedSizeSP,
            (pCaps2 == NULL ? TRUE : FALSE)
            );

        if ((pParams->lResult = CallSP4(
                pfnTSPI_phoneGetDevCaps,
                "phoneGetDevCaps",
                SP_FUNC_SYNC,
                (DWORD) dwDeviceID,
                (DWORD) dwSPIVersion,
                (DWORD) pParams->dwExtVersion,
                (ULONG_PTR) pCaps

                )) == 0)
        {
#if DBG
            //
            // Verify the info returned by the provider
            //

#endif


            //
            // Add the fields we're responsible for
            //

            pCaps->dwPhoneStates |= PHONESTATE_OWNER |
                                    PHONESTATE_MONITORS |
                                    PHONESTATE_REINIT;


            //
            // Munge fields where appropriate for old apps (don't want to
            // pass back flags that they won't understand)
            //


            //
            // If an intermediate buffer was used then copy the bits back
            // to the the original buffer, & free the intermediate buffer.
            // Also reset the dwUsedSize field to the fixed size of the
            // structure for the specifed version, since any data in the
            // variable portion is garbage as far as the client is concerned.
            //

            if (pCaps == pCaps2)
            {
                pCaps = (LPPHONECAPS) pDataBuf;

                CopyMemory (pCaps, pCaps2, dwFixedSizeClient);

                ServerFree (pCaps2);

                pCaps->dwTotalSize = pParams->dwPhoneCapsTotalSize;
                pCaps->dwUsedSize  = dwFixedSizeClient;
            }


            //
            // Indicate the offset & how many bytes of data we're passing back
            //

            pParams->dwPhoneCapsOffset = 0;

            *pdwNumBytesReturned = sizeof (TAPI32_MSG) + pCaps->dwUsedSize;
        }
    }

PGetDevCaps_epilog:

    PHONEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        "GetDevCaps"
        );
}


void
WINAPI
PGetDisplay(
    PTCLIENT                ptClient,
    PPHONEGETDISPLAY_PARAMS pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL        bCloseMutex;
    HANDLE      hMutex;
    HDRVPHONE   hdPhone;
    TSPIPROC    pfnTSPI_phoneGetDisplay;
    DWORD       dwPrivilege = PHONEPRIVILEGE_MONITOR;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (pParams->dwDisplayTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = PHONEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = PHONEPROLOG(
            ptClient,          // tClient
            ANY_RT_HPHONE,              // widget type
            (DWORD) pParams->hPhone,    // client widget handle
            (LPVOID) &hdPhone,          // provider widget handle
            &dwPrivilege,     // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_PHONEGETDISPLAY,         // provider func index
            &pfnTSPI_phoneGetDisplay,   // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            "GetDisplay"                // func name

            )) == 0)
    {
        LPVARSTRING pDisplay = (LPVARSTRING) pDataBuf;


        if (!InitTapiStruct(
                pDisplay,
                pParams->dwDisplayTotalSize,
                sizeof (VARSTRING),
                TRUE
                ))
        {
            pParams->lResult = PHONEERR_STRUCTURETOOSMALL;
            goto PGetDisplay_epilog;
        }

        if ((pParams->lResult = CallSP2(
                pfnTSPI_phoneGetDisplay,
                "phoneGetDisplay",
                SP_FUNC_SYNC,
                (ULONG_PTR) hdPhone,
                (ULONG_PTR) pDisplay

                )) == 0)
        {
#if DBG
            //
            // Verify the info returned by the provider
            //

#endif

            //
            // Indicate how many bytes of data we're passing back
            //

            pParams->dwDisplayOffset = 0;

            *pdwNumBytesReturned = sizeof (TAPI32_MSG) + pDisplay->dwUsedSize;
        }
    }

PGetDisplay_epilog:

    PHONEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        "GetDisplay"
        );
}


void
WINAPI
PGetGain(
    PTCLIENT                ptClient,
    PPHONEGETGAIN_PARAMS    pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL        bCloseMutex;
    HANDLE      hMutex;
    HDRVPHONE   hdPhone;
    TSPIPROC    pfnTSPI_phoneGetGain;
    DWORD       dwPrivilege = PHONEPRIVILEGE_MONITOR;

    if ((pParams->lResult = PHONEPROLOG(
            ptClient,          // tClient
            ANY_RT_HPHONE,              // widget type
            (DWORD) pParams->hPhone,    // client widget handle
            (LPVOID) &hdPhone,          // provider widget handle
            &dwPrivilege,     // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_PHONEGETGAIN,            // provider func index
            &pfnTSPI_phoneGetGain,      // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            "GetGain"                   // func name

            )) == 0)
    {
        if (!IsOnlyOneBitSetInDWORD (pParams->dwHookSwitchDev) ||
            (pParams->dwHookSwitchDev & ~AllHookSwitchDevs))
        {
            pParams->lResult = PHONEERR_INVALHOOKSWITCHDEV;
        }
        else
        {
            if ((pParams->lResult = CallSP3(
                    pfnTSPI_phoneGetGain,
                    "phoneGetGain",
                    SP_FUNC_SYNC,
                    (ULONG_PTR) hdPhone,
                    (DWORD) pParams->dwHookSwitchDev,
                    (ULONG_PTR) &pParams->dwGain

                    )) == 0)
            {
                *pdwNumBytesReturned = sizeof (PHONEGETGAIN_PARAMS);
            }
        }
    }

    PHONEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        "GetGain"
        );
}


void
WINAPI
PGetHookSwitch(
    PTCLIENT                    ptClient,
    PPHONEGETHOOKSWITCH_PARAMS  pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL        bCloseMutex;
    HANDLE      hMutex;
    HDRVPHONE   hdPhone;
    TSPIPROC    pfnTSPI_phoneGetHookSwitch;
    DWORD       dwPrivilege = PHONEPRIVILEGE_MONITOR;


    if ((pParams->lResult = PHONEPROLOG(
            ptClient,          // tClient
            ANY_RT_HPHONE,              // widget type
            (DWORD) pParams->hPhone,    // client widget handle
            (LPVOID) &hdPhone,          // provider widget handle
            &dwPrivilege,     // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_PHONEGETHOOKSWITCH,      // provider func index
            &pfnTSPI_phoneGetHookSwitch,// provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            "GetHookSwitch"             // func name

            )) == 0)
    {
        if ((pParams->lResult = CallSP2(
                pfnTSPI_phoneGetHookSwitch,
                "phoneGetHookSwitch",
                SP_FUNC_SYNC,
                (ULONG_PTR) hdPhone,
                (ULONG_PTR) &pParams->dwHookSwitchDevs

                )) == 0)
        {
            *pdwNumBytesReturned = sizeof (PHONEGETHOOKSWITCH_PARAMS);
        }
    }

    PHONEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        "GetHookSwitch"
        );
}


void
WINAPI
PGetIcon(
    PTCLIENT                ptClient,
    PPHONEGETICON_PARAMS    pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    WCHAR      *pszDeviceClass;
    BOOL        bCloseMutex;
    HANDLE      hMutex;
    TSPIPROC    pfnTSPI_phoneGetIcon;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if ((pParams->dwDeviceClassOffset != TAPI_NO_DATA)  &&

        IsBadStringParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwDeviceClassOffset
            ))
    {
        pParams->lResult = PHONEERR_OPERATIONFAILED;
        return;
    }


    pszDeviceClass = (WCHAR *) (pParams->dwDeviceClassOffset == TAPI_NO_DATA ?
        NULL : pDataBuf + pParams->dwDeviceClassOffset);

    if ((pParams->lResult = PHONEPROLOG(
            ptClient,          // tClient
            DEVICE_ID,                  // widget type
            0,                          // client widget handle
            NULL,                       // provider widget handle
            &(pParams->dwDeviceID), // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_PHONEGETICON,            // provider func index
            &pfnTSPI_phoneGetIcon,      // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            "GetIcon"                   // func name

            )) == 0)
    {

        if ((pParams->lResult = CallSP3(
                pfnTSPI_phoneGetIcon,
                "phoneGetIcon",
                SP_FUNC_SYNC,
                (DWORD) pParams->dwDeviceID,
                (ULONG_PTR) pszDeviceClass,
                (ULONG_PTR) &pParams->hIcon

                )) == 0)
        {
            *pdwNumBytesReturned = sizeof (PHONEGETICON_PARAMS);
        }
    }
    else if (pParams->lResult == PHONEERR_OPERATIONUNAVAIL)
    {
        if ((pszDeviceClass == NULL) ||
            (_wcsicmp(pszDeviceClass, L"tapi/phone") == 0))
        {
            pParams->hIcon = TapiGlobals.hPhoneIcon;
            pParams->lResult = 0;
            *pdwNumBytesReturned = sizeof (PHONEGETICON_PARAMS);
        }
        else
        {
            pParams->lResult = PHONEERR_INVALDEVICECLASS;
        }
    }

    PHONEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        "GetIcon"
        );
}

void
WINAPI
PGetIDEx(
    PTCLIENT            ptClient,
    PPHONEGETID_PARAMS  pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{

    LPBYTE pDeviceClass = pDataBuf + pParams->dwDeviceClassOffset;
    LPWSTR pDeviceClassCopy = NULL;
    LPWSTR szStringId1 = NULL;
    LPWSTR szStringId2 = NULL;
    LPVARSTRING pID = (LPVARSTRING) pDataBuf;
    DWORD  dwAvailSize;

    //
    // Make a copy of the device class
    //
    pDeviceClassCopy = (LPWSTR) ServerAlloc( (1 + wcslen( (LPWSTR)pDeviceClass )) * sizeof(WCHAR));
    if (!pDeviceClassCopy)
    {
        LOG((TL_ERROR, "PGetIDEx: failed to allocate DeviceClassCopy"));
        pParams->lResult = PHONEERR_NOMEM;
    }

    wcscpy(pDeviceClassCopy, (LPWSTR)pDeviceClass);

    //
    // First call PGetID
    //
    PGetID( ptClient,
            pParams,
            dwParamsBufferSize,
            pDataBuf,
            pdwNumBytesReturned);

    //
    // if PGetID was successful and the request was for a wave device, 
    // translate the device ID into a string ID 
    //
    if (    (pParams->lResult == 0) &&
            !(pID->dwNeededSize > pID->dwTotalSize)
       ) 
    {
        if (!_wcsicmp((LPWSTR)pDeviceClassCopy, L"wave/in")  ||
            !_wcsicmp((LPWSTR)pDeviceClassCopy, L"wave/out") ||
            !_wcsicmp((LPWSTR)pDeviceClassCopy, L"midi/in")  ||
            !_wcsicmp((LPWSTR)pDeviceClassCopy, L"midi/out") 
           )
        {
            szStringId1 = WaveDeviceIdToStringId (
                            *(DWORD*)((LPBYTE)pID + pID->dwStringOffset), 
                            (LPWSTR)pDeviceClassCopy);
            if ( szStringId1 )
            {
                dwAvailSize = pID->dwTotalSize - pID->dwUsedSize + sizeof(DWORD);
                if ( dwAvailSize >= (wcslen(szStringId1) + 1) * sizeof(WCHAR) )
                {
                    wcscpy( (LPWSTR)((LPBYTE)pID + pID->dwStringOffset), szStringId1 );
                    pID->dwStringSize = (wcslen(szStringId1) + 1) * sizeof(WCHAR);
                    pID->dwUsedSize = pID->dwNeededSize = pID->dwUsedSize + pID->dwStringSize - sizeof(DWORD);
                    *pdwNumBytesReturned = sizeof (TAPI32_MSG) + pID->dwUsedSize;
                }
                else
                {
                    pID->dwNeededSize = (wcslen(szStringId1) + 1) * sizeof(WCHAR);
                }

                ServerFree(szStringId1);
            }
            else
            {
                LOG((TL_ERROR, "PGetIDEx:  WaveDeviceIdToStringId failed"));
                pParams->lResult = PHONEERR_OPERATIONFAILED;
            }
        } else if (!_wcsicmp((LPWSTR)pDeviceClassCopy, L"wave/in/out"))
        {
            szStringId1 = WaveDeviceIdToStringId (
                            *(DWORD*)((LPBYTE)pID + pID->dwStringOffset), 
                            L"wave/in");
            szStringId2 = WaveDeviceIdToStringId (
                            *( (DWORD*)((LPBYTE)pID + pID->dwStringOffset) + 1 ), 
                            L"wave/out");
            if ( szStringId1 && szStringId2 )
            {
                dwAvailSize = pID->dwTotalSize - pID->dwUsedSize + 2 * sizeof(DWORD);
                if ( dwAvailSize >= (wcslen(szStringId1) + wcslen(szStringId2) + 2) * sizeof(WCHAR) )
                {
                    wcscpy( (LPWSTR)((LPBYTE)pID + pID->dwStringOffset), szStringId1 );
                    wcscpy( (LPWSTR)
                        ((LPBYTE)pID + pID->dwStringOffset + 
                                      (wcslen(szStringId1) + 1) * sizeof(WCHAR)),
                        szStringId2
                        );
                    pID->dwStringSize = (wcslen(szStringId1) + wcslen(szStringId2) + 2) * sizeof(WCHAR);
                    pID->dwUsedSize = pID->dwNeededSize = pID->dwUsedSize + pID->dwStringSize - 2 * sizeof(DWORD);
                    *pdwNumBytesReturned = sizeof (TAPI32_MSG) + pID->dwUsedSize;
                }
                else
                {
                    pID->dwNeededSize = (wcslen(szStringId1) + wcslen(szStringId2) + 2) * sizeof(WCHAR);
                }

            }
            else
            {
                LOG((TL_ERROR, "PGetIDEx:  WaveDeviceIdToStringId failed"));
                pParams->lResult = PHONEERR_OPERATIONFAILED;
            }
            
            ServerFree(szStringId1);
            ServerFree(szStringId2);
        }
    }

    ServerFree(pDeviceClassCopy);
}


void
WINAPI
PGetID(
    PTCLIENT            ptClient,
    PPHONEGETID_PARAMS  pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    BOOL        bCloseMutex;
    HANDLE      hMutex;
    HDRVPHONE   hdPhone;
    TSPIPROC    pfnTSPI_phoneGetID;
    DWORD       dwPrivilege = PHONEPRIVILEGE_MONITOR;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if ((pParams->dwDeviceIDTotalSize > dwParamsBufferSize)  ||

        IsBadStringParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwDeviceClassOffset
            ))
    {
        pParams->lResult = PHONEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = PHONEPROLOG(
            ptClient,          // tClient
            ANY_RT_HPHONE,              // widget type
            (DWORD) pParams->hPhone,    // client widget handle
            (LPVOID) &hdPhone,          // provider widget handle
            &dwPrivilege,     // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_PHONEGETID,              // provider func index
            &pfnTSPI_phoneGetID,        // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            "GetID"                     // func name

            )) == 0  ||  pParams->lResult == PHONEERR_OPERATIONUNAVAIL)
    {
        WCHAR      *pszDeviceClass;
        LPVARSTRING pID = (LPVARSTRING) pDataBuf;


        //
        // We'll handle the "tapi/phone" class right here rather than
        // burden every single driver with having to support it
        //

        if (_wcsicmp(
                (PWSTR)(pDataBuf + pParams->dwDeviceClassOffset),
                L"tapi/phone"

                ) == 0)
        {
            if (!InitTapiStruct(
                    pID,
                    pParams->dwDeviceIDTotalSize,
                    sizeof (VARSTRING),
                    TRUE
                    ))
            {
                pParams->lResult = PHONEERR_STRUCTURETOOSMALL;
                goto PGetID_epilog;
            }

            pID->dwNeededSize += sizeof (DWORD);

            if (pID->dwTotalSize >= pID->dwNeededSize)
            {
                PTPHONECLIENT   ptPhoneClient;


                if (!(ptPhoneClient = ReferenceObject(
                        ghHandleTable,
                        pParams->hPhone,
                        0
                        )))
                {
                    pParams->lResult = PHONEERR_INVALPHONEHANDLE;
                    goto PGetID_epilog;
                }

                try
                {
                    *((LPDWORD)(pID + 1)) = ptPhoneClient->ptPhone->dwDeviceID;
                }
                myexcept
                {
                    pParams->lResult = PHONEERR_INVALPHONEHANDLE;
                }

                DereferenceObject (ghHandleTable, pParams->hPhone, 1);

                if (pParams->lResult == PHONEERR_INVALPHONEHANDLE)
                {
                    goto PGetID_epilog;
                }

                pID->dwUsedSize     += sizeof (DWORD);
                pID->dwStringFormat = STRINGFORMAT_BINARY;
                pID->dwStringSize   = sizeof (DWORD);
                pID->dwStringOffset = sizeof (VARSTRING);
            }


            //
            // Indicate offset & how many bytes of data we're passing back
            //

            pParams->lResult = 0;
            pParams->dwDeviceIDOffset = 0;
            *pdwNumBytesReturned = sizeof (TAPI32_MSG) + pID->dwUsedSize;
            goto PGetID_epilog;
        }
        else if (pParams->lResult ==  PHONEERR_OPERATIONUNAVAIL)
        {
            goto PGetID_epilog;
        }


        //
        // Alloc a temporary buf for the dev class, since we'll be using
        // the existing buffer for output
        //

        {
            UINT nStringSize;

            nStringSize = sizeof(WCHAR) * (1 + wcslen((PWSTR)(pDataBuf +
                                  pParams->dwDeviceClassOffset)));

            if (0 == nStringSize)
            {
                pParams->lResult = PHONEERR_INVALPARAM;
                goto PGetID_epilog;
            }


            if (!(pszDeviceClass = (WCHAR *) ServerAlloc(nStringSize) ))
            {
                pParams->lResult = PHONEERR_NOMEM;
                goto PGetID_epilog;
            }

        }

        wcscpy(
            pszDeviceClass,
            (PWSTR)(pDataBuf + pParams->dwDeviceClassOffset)
            );


        if (!InitTapiStruct(
                pID,
                pParams->dwDeviceIDTotalSize,
                sizeof (VARSTRING),
                TRUE
                ))
        {
            ServerFree (pszDeviceClass);
            pParams->lResult = PHONEERR_STRUCTURETOOSMALL;
            goto PGetID_epilog;
        }

        if ((pParams->lResult = CallSP4(
                pfnTSPI_phoneGetID,
                "phoneGetID",
                SP_FUNC_SYNC,
                (ULONG_PTR) hdPhone,
                (ULONG_PTR) pID,
                (ULONG_PTR) pszDeviceClass,
                (ULONG_PTR) (IS_REMOTE_CLIENT (ptClient) ?
                     (HANDLE) -1 : ptClient->hProcess)

                )) == 0)
        {

#if TELE_SERVER
                //
                // If
                //     this is a server &
                //     client doesn't have admin privileges &
                //     the specified device class == "tapi/line" &
                //     the dwUsedSize indicates that a line id was
                //         (likely) copied to the buffer
                // then
                //     try to map the retrieved line device id back
                //     to one that makes sense to the client (and
                //     fail the request if there's no mapping)
                //

                if (IS_REMOTE_CLIENT(ptClient)  &&
                    (_wcsicmp (pszDeviceClass, L"tapi/line") == 0) &&
                    !IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR) &&
                    (pID->dwUsedSize >= (sizeof (*pID) + sizeof (DWORD))))
                {
                    DWORD   i;
                    LPDWORD pdwLineID = (LPDWORD)
                                (((LPBYTE) pID) + pID->dwStringOffset);


                    for (i = 0; i < ptClient->dwLineDevices; i++)
                    {
                        if (*pdwLineID == ptClient->pLineDevices[i])
                        {
                            *pdwLineID = i;
                            break;
                        }
                    }

                    if (i >= ptClient->dwLineDevices)
                    {
                        pParams->lResult = PHONEERR_OPERATIONFAILED;
                    }
                }
#endif
            //
            // Indicate offset & how many bytes of data we're passing back
            //

            pParams->dwDeviceIDOffset = 0;

            *pdwNumBytesReturned = sizeof (TAPI32_MSG) + pID->dwUsedSize;
        }

        ServerFree (pszDeviceClass);
    }

PGetID_epilog:

    PHONEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        "GetID"
        );
}


void
WINAPI
PGetLamp(
    PTCLIENT                ptClient,
    PPHONEGETLAMP_PARAMS    pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL        bCloseMutex;
    HANDLE      hMutex;
    HDRVPHONE   hdPhone;
    TSPIPROC    pfnTSPI_phoneGetLamp;
    DWORD       dwPrivilege = PHONEPRIVILEGE_MONITOR;


    if ((pParams->lResult = PHONEPROLOG(
            ptClient,          // tClient
            ANY_RT_HPHONE,              // widget type
            (DWORD) pParams->hPhone,    // client widget handle
            (LPVOID) &hdPhone,          // provider widget handle
            &dwPrivilege,     // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_PHONEGETLAMP,            // provider func index
            &pfnTSPI_phoneGetLamp,      // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            "GetLamp"                   // func name

            )) == 0)
    {
        if ((pParams->lResult = CallSP3(
                pfnTSPI_phoneGetLamp,
                "phoneGetLamp",
                SP_FUNC_SYNC,
                (ULONG_PTR) hdPhone,
                (DWORD) pParams->dwButtonLampID,
                (ULONG_PTR) &pParams->dwLampMode

                )) == 0)
        {
            *pdwNumBytesReturned = sizeof (PHONEGETLAMP_PARAMS);
        }
    }

    PHONEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        "GetLamp"
        );
}


void
WINAPI
PGetRing(
    PTCLIENT                ptClient,
    PPHONEGETRING_PARAMS    pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL        bCloseMutex;
    HANDLE      hMutex;
    HDRVPHONE   hdPhone;
    TSPIPROC    pfnTSPI_phoneGetRing;
    DWORD       dwPrivilege = PHONEPRIVILEGE_MONITOR;


    if ((pParams->lResult = PHONEPROLOG(
            ptClient,          // tClient
            ANY_RT_HPHONE,              // widget type
            (DWORD) pParams->hPhone,    // client widget handle
            (LPVOID) &hdPhone,          // provider widget handle
            &dwPrivilege,     // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_PHONEGETRING,            // provider func index
            &pfnTSPI_phoneGetRing,      // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            "GetRing"                   // func name

            )) == 0)
    {
        if ((pParams->lResult = CallSP3(
                pfnTSPI_phoneGetRing,
                "phoneGetRing",
                SP_FUNC_SYNC,
                (ULONG_PTR) hdPhone,
                (ULONG_PTR) &pParams->dwRingMode,
                (ULONG_PTR) &pParams->dwVolume

                )) == 0)
        {
            *pdwNumBytesReturned = sizeof (PHONEGETRING_PARAMS);
        }
    }

    PHONEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        "GetRing"
        );
}


void
WINAPI
PGetStatus(
    PTCLIENT                ptClient,
    PPHONEGETSTATUS_PARAMS  pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL        bCloseMutex;
    HANDLE      hMutex;
    HDRVPHONE   hdPhone;
    TSPIPROC    pfnTSPI_phoneGetStatus;
    DWORD       dwPrivilege = PHONEPRIVILEGE_MONITOR;
    PTPHONECLIENT   ptPhoneClient;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (pParams->dwPhoneStatusTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = PHONEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = PHONEPROLOG(
            ptClient,          // tClient
            ANY_RT_HPHONE,              // widget type
            (DWORD) pParams->hPhone,    // client widget handle
            (LPVOID) &hdPhone,          // provider widget handle
            &dwPrivilege,     // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_PHONEGETSTATUS,          // provider func index
            &pfnTSPI_phoneGetStatus,    // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            "GetStatus"                 // func name

            )) == 0)
    {
        DWORD           dwAPIVersion, dwSPIVersion, dwTotalSize,
                        dwFixedSizeClient, dwFixedSizeSP;
        LPPHONESTATUS   pStatus = (LPPHONESTATUS) pDataBuf,
                        pStatus2 = (LPPHONESTATUS) NULL;


        if (!(ptPhoneClient = ReferenceObject(
                ghHandleTable,
                pParams->hPhone,
                0
                )))
        {
            pParams->lResult = (TapiGlobals.dwNumPhoneInits ?
                PHONEERR_INVALPHONEHANDLE : PHONEERR_UNINITIALIZED);
            // since ReferenceObject failed, no point
            // in dereferencing.
            goto PGetStatus_epilog;
        }

        //
        // Safely retrieve the API & SPI versions
        //

        if (GetPhoneVersions(
                pParams->hPhone,
                &dwAPIVersion,
                &dwSPIVersion

                ) != 0)
        {
            pParams->lResult = PHONEERR_INVALPHONEHANDLE;
            goto PGetStatus_dereference;
        }


        //
        // Determine the fixed size of the structure for the specified API
        // version, verify client's buffer is big enough
        //

        dwTotalSize = pParams->dwPhoneStatusTotalSize;

        switch (dwAPIVersion)
        {
        case TAPI_VERSION1_0:
        case TAPI_VERSION1_4:

            dwFixedSizeClient = 100;    // 25 * sizeof (DWORD)
            break;

        default: // (fix ppc build wrn) case TAPI_VERSION_CURRENT:

            dwFixedSizeClient = sizeof (PHONESTATUS);
            break;
        }

        if (dwTotalSize < dwFixedSizeClient)
        {
            pParams->lResult = PHONEERR_STRUCTURETOOSMALL;
            goto PGetStatus_dereference;
        }


        //
        // Determine the fixed size of the structure expected by the SP
        //

        switch (dwSPIVersion)
        {
        case TAPI_VERSION1_0:
        case TAPI_VERSION1_4:

            dwFixedSizeSP = 100;        // 25 * sizeof (DWORD)
            break;

        default: // (fix ppc build wrn) case TAPI_VERSION_CURRENT:

            dwFixedSizeSP = sizeof (PHONESTATUS);
            break;
        }


        //
        // If the client's buffer is < the fixed size of that expected by
        // the SP (client is lower version than SP) then allocate an
        // intermediate buffer
        //

        if (dwTotalSize < dwFixedSizeSP)
        {
            if (!(pStatus2 = ServerAlloc (dwFixedSizeSP)))
            {
                pParams->lResult = PHONEERR_NOMEM;
                goto PGetStatus_dereference;
            }

            pStatus     = pStatus2;
            dwTotalSize = dwFixedSizeSP;
        }


        InitTapiStruct(
            pStatus,
            dwTotalSize,
            dwFixedSizeSP,
            (pStatus2 == NULL ? TRUE : FALSE)
            );

        if ((pParams->lResult = CallSP2(
                pfnTSPI_phoneGetStatus,
                "phoneGetStatus",
                SP_FUNC_SYNC,
                (ULONG_PTR) hdPhone,
                (ULONG_PTR) pStatus

                )) == 0)
        {
            DWORD           dwNeededSize = 0, dwAlign = 0;
            PTPHONEAPP      ptPhoneApp;
            PTPHONE         ptPhone;
            PTPHONECLIENT   ptPhClnt;
            WCHAR           *pAppName;

#if DBG
            //
            // Verify the info returned by the provider
            //

#endif

            //
            // Add the fields we're responsible for
            //

            try
            {
                ptPhone = ptPhoneClient->ptPhone;

                pStatus->dwNumOwners   = ptPhone->dwNumOwners;
                pStatus->dwNumMonitors = ptPhone->dwNumMonitors;

                if (0 != pStatus->dwUsedSize % 2)   // 2 is sizeof(WCHAR)
                {
                    // make sure that the owner name will always be aligned
                    // on a WCHAR boundary.
                    dwAlign = 1;
                }

                // Initialize fields.
                pStatus->dwOwnerNameSize   = 0;
                pStatus->dwOwnerNameOffset = 0;

                if (0 != ptPhone->dwNumOwners)
                {
                    for (ptPhClnt = ptPhone->ptPhoneClients; NULL != ptPhClnt; ptPhClnt = ptPhClnt->pNextSametPhone)
                    {
                        if (PHONEPRIVILEGE_OWNER == ptPhClnt->dwPrivilege)
                        {
                            ptPhoneApp = ptPhClnt->ptPhoneApp;
                            if (0 < ptPhoneApp->dwFriendlyNameSize &&
                                NULL != ptPhoneApp->pszFriendlyName)
                            {
                                dwNeededSize = ptPhoneApp->dwFriendlyNameSize + dwAlign;
                                pAppName = ptPhoneApp->pszFriendlyName;
                            }
                            else if (0 < ptPhoneApp->dwModuleNameSize &&
                                     NULL != ptPhoneApp->pszModuleName)
                            {
                                dwNeededSize = ptPhoneApp->dwFriendlyNameSize + dwAlign;
                                pAppName = ptPhoneApp->pszFriendlyName;
                            }
                            else
                            {
                                break;
                            }

                            pStatus->dwNeededSize += dwNeededSize;

                            if (dwNeededSize <= pStatus->dwTotalSize - pStatus->dwUsedSize)
                            {
                                pStatus->dwOwnerNameSize   = dwNeededSize - dwAlign;
                                pStatus->dwOwnerNameOffset = pStatus->dwUsedSize + dwAlign;
                                
                                CopyMemory(
                                    ((LPBYTE) pStatus) + pStatus->dwOwnerNameOffset,
                                    pAppName,
                                    dwNeededSize-dwAlign
                                    );

                                if (ptPhoneApp->dwKey == TPHONEAPP_KEY)
                                {
                                    pStatus->dwUsedSize += dwNeededSize;
                                }
                                else
                                {
                                    pStatus->dwOwnerNameSize   = 0;
                                    pStatus->dwOwnerNameOffset = 0;
                                }
                            }

                            break;
                        }
                    }
                }
            }
            myexcept
            {
                pParams->lResult = PHONEERR_INVALPHONEHANDLE;
                goto PGetStatus_dereference;
            }


            //
            // Munge fields where appropriate for old apps (don't want to
            // pass back flags that they won't understand)
            //


            //
            // If an intermediate buffer was used then copy the bits back
            // to the the original buffer, & free the intermediate buffer.
            // Also reset the dwUsedSize field to the fixed size of the
            // structure for the specifed version, since any data in the
            // variable portion is garbage as far as the client is concerned.
            //

            if (pStatus == pStatus2)
            {
                pStatus = (LPPHONESTATUS) pDataBuf;

                CopyMemory (pStatus, pStatus2, dwFixedSizeClient);

                ServerFree (pStatus2);

                pStatus->dwTotalSize = pParams->dwPhoneStatusTotalSize;
                pStatus->dwUsedSize  = dwFixedSizeClient;
            }


            //
            // Indicate the offset & how many bytes of data we're passing back
            //

            pParams->dwPhoneStatusOffset = 0;

            *pdwNumBytesReturned = sizeof (TAPI32_MSG) + pStatus->dwUsedSize;
        }

PGetStatus_dereference:

        DereferenceObject (ghHandleTable, pParams->hPhone, 1);
    }

PGetStatus_epilog:

    PHONEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        "GetStatus"
        );
}


void
WINAPI
PGetStatusMessages(
    PTCLIENT                        ptClient,
    PPHONEGETSTATUSMESSAGES_PARAMS  pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    PTPHONECLIENT   ptPhoneClient;


    if ((ptPhoneClient = ReferenceObject(
            ghHandleTable,
            pParams->hPhone,
            0
            )))
    {
        if (ptPhoneClient->ptClient == ptClient)
        {
            pParams->dwPhoneStates  = ptPhoneClient->dwPhoneStates;
            pParams->dwButtonModes  = ptPhoneClient->dwButtonModes;
            pParams->dwButtonStates = ptPhoneClient->dwButtonStates;

            *pdwNumBytesReturned = sizeof (PHONEGETSTATUSMESSAGES_PARAMS);
        }
        else
        {
            pParams->lResult = (TapiGlobals.dwNumPhoneInits ?
                PHONEERR_INVALPHONEHANDLE : PHONEERR_UNINITIALIZED);
        }

        DereferenceObject (ghHandleTable, pParams->hPhone, 1);
    }
    else
    {
        pParams->lResult = (TapiGlobals.dwNumPhoneInits ?
            PHONEERR_INVALPHONEHANDLE : PHONEERR_UNINITIALIZED);
    }

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "phoneGetStatusMessages: exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE, 
            "phoneGetStatusMessages: exit, result=x%x",
            pParams->lResult
            ));
#endif
}


void
WINAPI
PGetVolume(
    PTCLIENT                ptClient,
    PPHONEGETVOLUME_PARAMS  pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL        bCloseMutex;
    HANDLE      hMutex;
    HDRVPHONE   hdPhone;
    TSPIPROC    pfnTSPI_phoneGetVolume;
    DWORD       dwPrivilege = PHONEPRIVILEGE_MONITOR;


    if ((pParams->lResult = PHONEPROLOG(
            ptClient,          // tClient
            ANY_RT_HPHONE,              // widget type
            (DWORD) pParams->hPhone,    // client widget handle
            (LPVOID) &hdPhone,          // provider widget handle
            &dwPrivilege,     // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_PHONEGETVOLUME,          // provider func index
            &pfnTSPI_phoneGetVolume,    // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            "GetVolume"                 // func name

            )) == 0)
    {
        if (!IsOnlyOneBitSetInDWORD (pParams->dwHookSwitchDev) ||
            (pParams->dwHookSwitchDev & ~AllHookSwitchDevs))
        {
            pParams->lResult = PHONEERR_INVALHOOKSWITCHDEV;
        }
        else
        {
            if ((pParams->lResult = CallSP3(
                    pfnTSPI_phoneGetVolume,
                    "phoneGetVolume",
                    SP_FUNC_SYNC,
                    (ULONG_PTR) hdPhone,
                    (DWORD) pParams->dwHookSwitchDev,
                    (ULONG_PTR) &pParams->dwVolume

                    )) == 0)
            {
                *pdwNumBytesReturned = sizeof (PHONEGETVOLUME_PARAMS);
            }
        }
    }

    PHONEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        "GetVolume"
        );
}


void
WINAPI
PInitialize(
    PTCLIENT                ptClient,
    PPHONEINITIALIZE_PARAMS pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    DWORD       dwFriendlyNameSize, dwModuleNameSize;
    PTPHONEAPP  ptPhoneApp;
    BOOL        bInitClient = FALSE;

    LOG((TL_TRACE,  "PInitialize - enter. dwParamsBufferSize %lx, ptClient %p", dwParamsBufferSize, ptClient));


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (IsBadStringParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwFriendlyNameOffset
            ) ||

        IsBadStringParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwModuleNameOffset
            ))
    {
        LOG((TL_ERROR, "PInitialize - error1."));
        pParams->lResult = PHONEERR_OPERATIONFAILED;
        return;
    }


    //
    // Alloc & init a new tPhoneApp
    //

    dwFriendlyNameSize = sizeof(WCHAR) * (1 + lstrlenW(
        (PWSTR)(pDataBuf + pParams->dwFriendlyNameOffset))
        );

    dwModuleNameSize = sizeof(WCHAR) * (1 + lstrlenW(
        (PWSTR)(pDataBuf + pParams->dwModuleNameOffset))
        );

    if (!(ptPhoneApp = ServerAlloc(
            sizeof (TPHONEAPP) +
            dwFriendlyNameSize +
            dwModuleNameSize
            )))
    {
        pParams->lResult = PHONEERR_NOMEM;
        goto PInitialize_return;
    }

    if (!(ptPhoneApp->hPhoneApp = (HPHONEAPP) NewObject(
            ghHandleTable,
            ptPhoneApp,
            NULL
            )))
    {
        pParams->lResult = PHONEERR_NOMEM;
        ServerFree (ptPhoneApp);
        goto PInitialize_return;
    }

    ptPhoneApp->dwKey        = TPHONEAPP_KEY;
    ptPhoneApp->ptClient     = ptClient;
    ptPhoneApp->InitContext  = pParams->InitContext;
    ptPhoneApp->dwAPIVersion = pParams->dwAPIVersion;

    ptPhoneApp->pszFriendlyName = (WCHAR *) (ptPhoneApp + 1);
    ptPhoneApp->dwFriendlyNameSize = dwFriendlyNameSize;

    wcscpy(
        ptPhoneApp->pszFriendlyName,
        (PWSTR)(pDataBuf + pParams->dwFriendlyNameOffset)
        );

    ptPhoneApp->pszModuleName = (PWSTR)((BYTE *) (ptPhoneApp + 1) + dwFriendlyNameSize);
    ptPhoneApp->dwModuleNameSize = dwModuleNameSize;

    wcscpy(
        ptPhoneApp->pszModuleName,
        (PWSTR)(pDataBuf + pParams->dwModuleNameOffset)
        );


    //
    // Safely insert new tPhoneApp at front of tClient's tPhoneApp list
    //

    if (ptClient->ptLineApps == NULL)
    {
        bInitClient = TRUE;
    }


    if (WaitForExclusiveClientAccess (ptClient))
    {
        if (ptPhoneApp->dwAPIVersion <= TAPI_VERSION3_0)
        {
            FillMemory (
                ptPhoneApp->adwEventSubMasks, 
                sizeof(DWORD) * EM_NUM_MASKS,
                (BYTE) 0xff
                );
        }
        else
        {
            CopyMemory (
                ptPhoneApp->adwEventSubMasks, 
                ptClient->adwEventSubMasks,
                sizeof(DWORD) * EM_NUM_MASKS
                );
        }
        
        if ((ptPhoneApp->pNext = ptClient->ptPhoneApps))
        {
            ptPhoneApp->pNext->pPrev = ptPhoneApp;
        }

        ptClient->ptPhoneApps = ptPhoneApp;

        UNLOCKTCLIENT (ptClient);
    }
    else
    {
        LOG((TL_ERROR, "PInitialize - error2."));
        
        pParams->lResult = PHONEERR_OPERATIONFAILED;
        goto PInitialize_error1;
    }


    //
    // Check if global reinit flag set
    //

    if (TapiGlobals.dwFlags & TAPIGLOBALS_REINIT)
    {
        pParams->lResult = PHONEERR_REINIT;
        goto PInitialize_error2;
    }


    //
    // See if we need to go thru init
    //

    TapiEnterCriticalSection (&TapiGlobals.CritSec);

    if ((TapiGlobals.dwNumLineInits == 0) &&
        (TapiGlobals.dwNumPhoneInits == 0) &&
        !gbServerInited)
    {
        if ((pParams->lResult = ServerInit(FALSE)) != 0)
        {
            TapiLeaveCriticalSection (&TapiGlobals.CritSec);
            goto PInitialize_error2;
        }
        gbServerInited = TRUE;
    }



#if TELE_SERVER
    if (bInitClient)
    {
        if (pParams->lResult = InitializeClient (ptClient))
        {
            TapiLeaveCriticalSection (&TapiGlobals.CritSec);
            goto PInitialize_error2;
        }
    }
#else
    pParams->lResult = 0;  //  That's what happens if it's not a server...
#endif


    //
    // Fill in the return values
    //

    pParams->hPhoneApp = ptPhoneApp->hPhoneApp;
    pParams->dwNumDevs = TapiGlobals.dwNumPhones;


#if TELE_SERVER
    if ((TapiGlobals.dwFlags & TAPIGLOBALS_SERVER) &&
        !IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR))
    {
        pParams->dwNumDevs = ptClient->dwPhoneDevices;
    }
#endif


    //
    // Increment total num phone inits
    //

    TapiGlobals.dwNumPhoneInits++;

    *pdwNumBytesReturned = sizeof (PHONEINITIALIZE_PARAMS);

    TapiLeaveCriticalSection (&TapiGlobals.CritSec);

    goto PInitialize_return;

PInitialize_error2:

    if (WaitForExclusiveClientAccess (ptClient))
    {
        if (ptPhoneApp->pNext)
        {
            ptPhoneApp->pNext->pPrev = ptPhoneApp->pPrev;
        }

        if (ptPhoneApp->pPrev)
        {
            ptPhoneApp->pPrev->pNext = ptPhoneApp->pNext;
        }
        else
        {
            ptClient->ptPhoneApps = ptPhoneApp->pNext;
        }

        UNLOCKTCLIENT (ptClient);
    }

PInitialize_error1:

    DereferenceObject (ghHandleTable, ptPhoneApp->hPhoneApp, 1);

PInitialize_return:

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "phoneInitialize: exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE, 
            "phoneInitialize: exit, result=x%x",
            pParams->lResult
            ));
#endif

    return;
}


void
WINAPI
PNegotiateAPIVersion(
    PTCLIENT                            ptClient,
    PPHONENEGOTIATEAPIVERSION_PARAMS    pParams,
    DWORD                               dwParamsBufferSize,
    LPBYTE                              pDataBuf,
    LPDWORD                             pdwNumBytesReturned
    )
{
    //
    // Note: TAPI_VERSION1_0 <= dwNegotiatedAPIVersion <= dwSPIVersion
    //

    DWORD   dwDeviceID = pParams->dwDeviceID;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (dwParamsBufferSize < sizeof (PHONEEXTENSIONID))
    {
        pParams->lResult = PHONEERR_OPERATIONFAILED;
        return;
    }


    if (TapiGlobals.dwNumPhoneInits == 0)
    {
        pParams->lResult = PHONEERR_UNINITIALIZED;
        goto PNegotiateAPIVersion_exit;
    }


#if TELE_SERVER

    if ((TapiGlobals.dwFlags & TAPIGLOBALS_SERVER) &&
        !IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR))
    {
        try
        {
            if (dwDeviceID >= ptClient->dwPhoneDevices)
            {
                pParams->lResult = PHONEERR_BADDEVICEID;
                goto PNegotiateAPIVersion_exit;
            }
            dwDeviceID = ptClient->pPhoneDevices[dwDeviceID];
        }
        myexcept
        {
            LOG((TL_ERROR, "ptClient excepted in PhoneNegotiateAPIVersion"));
            pParams->lResult = PHONEERR_INVALPHONEHANDLE;
            goto PNegotiateAPIVersion_exit;
        }
    }

#endif


    if (dwDeviceID < TapiGlobals.dwNumPhones)
    {
        DWORD       dwAPIHighVersion = pParams->dwAPIHighVersion,
                    dwAPILowVersion  = pParams->dwAPILowVersion,
                    dwHighestValidAPIVersion;
        PTPHONEAPP  ptPhoneApp;


        if (!(ptPhoneApp = ReferenceObject(
                ghHandleTable,
                pParams->hPhoneApp,
                TPHONEAPP_KEY
                )))
        {
            pParams->lResult = (TapiGlobals.dwNumPhoneInits ?
                PHONEERR_INVALAPPHANDLE : PHONEERR_UNINITIALIZED);

            goto PNegotiateAPIVersion_exit;
        }


        //
        // Do a minimax test on the specified lo/hi values
        //

        if ((dwAPILowVersion > dwAPIHighVersion) ||
            (dwAPILowVersion > TAPI_VERSION_CURRENT) ||
            (dwAPIHighVersion < TAPI_VERSION1_0))
        {
            pParams->lResult = PHONEERR_INCOMPATIBLEAPIVERSION;
            goto PNegotiateAPIVersion_dereference;
        }


        //
        // Find the highest valid API version given the lo/hi values.
        // Since valid vers aren't consecutive we need to check for
        // errors that our minimax test missed.
        //

        if (dwAPIHighVersion < TAPI_VERSION_CURRENT)
        {
            if ((dwAPIHighVersion >= TAPI_VERSION3_0) &&
                (dwAPILowVersion <= TAPI_VERSION3_0))
            {
                dwHighestValidAPIVersion = TAPI_VERSION3_0;
            }
            else if ((dwAPIHighVersion >= TAPI_VERSION2_2) &&
                (dwAPILowVersion <= TAPI_VERSION2_2))
            {
                dwHighestValidAPIVersion = TAPI_VERSION2_2;
            }
            else if ((dwAPIHighVersion >= TAPI_VERSION2_1) &&
                (dwAPILowVersion <= TAPI_VERSION2_1))
            {
                dwHighestValidAPIVersion = TAPI_VERSION2_1;
            }
            else if ((dwAPIHighVersion >= TAPI_VERSION2_0) &&
                (dwAPILowVersion <= TAPI_VERSION2_0))
            {
                dwHighestValidAPIVersion = TAPI_VERSION2_0;
            }
            else if ((dwAPIHighVersion >= TAPI_VERSION1_4) &&
                (dwAPILowVersion <= TAPI_VERSION1_4))
            {
                dwHighestValidAPIVersion = TAPI_VERSION1_4;
            }
            else if ((dwAPIHighVersion >= TAPI_VERSION1_0) &&
                (dwAPILowVersion <= TAPI_VERSION1_0))
            {
                dwHighestValidAPIVersion = TAPI_VERSION1_0;
            }
            else
            {
                LOG((TL_ERROR, "   Incompatible version"));
                pParams->lResult = PHONEERR_INCOMPATIBLEAPIVERSION;
                goto PNegotiateAPIVersion_dereference;
            }
        }
        else
        {
            dwHighestValidAPIVersion = TAPI_VERSION_CURRENT;
        }


        //
        // WARNING!!! WARNING!!! WARNING!!! WARNING!!!
        // This code overwrites ptPhoneApp and later invalidates it.
        // Do NOT use ptPhoneApp after the UNLOCKTPHONEAPP call.
        //

        if (WaitForExclusivePhoneAppAccess(
                pParams->hPhoneApp,
                ptClient
                ))
        {

            //
            // Is this app trying to negotiate something valid?
            //
            // If an app has called phoneInitalize (as opposed to
            // phoneInitializeEx), we'll clamp the max APIVersion they can
            // negotiate to 1.4.
            //
            if ( ptPhoneApp->dwAPIVersion < TAPI_VERSION2_0 )
            {
                dwHighestValidAPIVersion =
                    (dwHighestValidAPIVersion >= TAPI_VERSION1_4) ?
                    TAPI_VERSION1_4 : TAPI_VERSION1_0;
            }


            //
            // Save the highest valid API version the client says it supports
            // (we need this for determining which msgs to send to it)
            //

            if (dwHighestValidAPIVersion > ptPhoneApp->dwAPIVersion)
            {
                ptPhoneApp->dwAPIVersion = dwHighestValidAPIVersion;
            }

            UNLOCKTPHONEAPP(ptPhoneApp);
        }
        else
        {
            pParams->lResult = PHONEERR_INVALAPPHANDLE;
            goto PNegotiateAPIVersion_dereference;
        }


        //
        // See if there's a valid match with the SPI ver
        //

        {
            DWORD               dwSPIVersion;
            PTPHONELOOKUPENTRY  pLookupEntry;


            pLookupEntry = GetPhoneLookupEntry (dwDeviceID);
            dwSPIVersion = pLookupEntry->dwSPIVersion;

            if (pLookupEntry->bRemoved)
            {
                LOG((TL_ERROR, "  phone removed..."));
                pParams->lResult = PHONEERR_NODEVICE;
                goto PNegotiateAPIVersion_dereference;
            }

            if (pLookupEntry->ptProvider == NULL)
            {
                LOG((TL_ERROR, "  Provider == NULL"));
                pParams->lResult = PHONEERR_NODRIVER;
                goto PNegotiateAPIVersion_dereference;
            }

            if (dwAPILowVersion <= dwSPIVersion)
            {
                pParams->dwAPIVersion =
                    (dwHighestValidAPIVersion > dwSPIVersion ?
                    dwSPIVersion : dwHighestValidAPIVersion);


                //
                // Retrieve ext id (indicate no exts if GetExtID not exported)
                //

                if (pLookupEntry->ptProvider->apfn[SP_PHONEGETEXTENSIONID])
                {
                    if ((pParams->lResult = CallSP3(
                            pLookupEntry->ptProvider->
                                apfn[SP_PHONEGETEXTENSIONID],
                            "phoneGetExtensionID",
                            SP_FUNC_SYNC,
                            (DWORD) dwDeviceID,
                            (DWORD) dwSPIVersion,
                            (ULONG_PTR) pDataBuf

                            )) != 0)
                    {
                        goto PNegotiateAPIVersion_dereference;
                    }
                }
                else
                {
                    FillMemory (pDataBuf, sizeof (PHONEEXTENSIONID), 0);
                }
            }
            else
            {
                LOG((TL_ERROR, "  API version too high"));
                pParams->lResult = PHONEERR_INCOMPATIBLEAPIVERSION;
                goto PNegotiateAPIVersion_dereference;
            }
        }

        pParams->dwExtensionIDOffset = 0;
        pParams->dwSize              = sizeof (PHONEEXTENSIONID);

        LOG((TL_INFO, "  ExtensionID0=x%08lx", *(LPDWORD)(pDataBuf+0) ));
        LOG((TL_INFO, "  ExtensionID1=x%08lx", *(LPDWORD)(pDataBuf+4) ));
        LOG((TL_INFO, "  ExtensionID2=x%08lx", *(LPDWORD)(pDataBuf+8) ));
        LOG((TL_INFO, "  ExtensionID3=x%08lx", *(LPDWORD)(pDataBuf+12) ));

        *pdwNumBytesReturned = sizeof (PHONEEXTENSIONID) + sizeof (TAPI32_MSG);

PNegotiateAPIVersion_dereference:

        DereferenceObject (ghHandleTable, pParams->hPhoneApp, 1);
    }
    else
    {
        pParams->lResult = PHONEERR_BADDEVICEID;
    }

PNegotiateAPIVersion_exit:

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "phoneNegotiateAPIVersion: exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE, 
            "phoneNegotiateAPIVersion: exit, result=x%x",
            pParams->lResult
            ));
#endif

    return;
}


void
WINAPI
PNegotiateExtVersion(
    PTCLIENT                            ptClient,
    PPHONENEGOTIATEEXTVERSION_PARAMS    pParams,
    DWORD                               dwParamsBufferSize,
    LPBYTE                              pDataBuf,
    LPDWORD                             pdwNumBytesReturned
    )
{
    BOOL        bCloseMutex;
    DWORD       dwDeviceID = pParams->dwDeviceID;
    HANDLE      hMutex;
    TSPIPROC    pfnTSPI_phoneNegotiateExtVersion;


    if ((pParams->lResult = PHONEPROLOG(
            ptClient,          // tClient
            DEVICE_ID,                  // widget type
            (DWORD) pParams->hPhoneApp, // client widget handle
            NULL,                       // provider widget handle
            &dwDeviceID,                 // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_PHONENEGOTIATEEXTVERSION,// provider func index
            &pfnTSPI_phoneNegotiateExtVersion,  // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            "NegotiateExtVersion"       // func name

            )) == 0)
    {
        DWORD   dwSPIVersion = (GetPhoneLookupEntry(dwDeviceID))->dwSPIVersion;


        if (!IsAPIVersionInRange(
                pParams->dwAPIVersion,
                dwSPIVersion
                ))
        {
            pParams->lResult = PHONEERR_INCOMPATIBLEAPIVERSION;
            goto PNegotiateExtVersion_epilog;
        }

        if ((pParams->lResult = CallSP5(
                pfnTSPI_phoneNegotiateExtVersion,
                "phoneNegotiateExtVersion",
                SP_FUNC_SYNC,
                (DWORD) dwDeviceID,
                (DWORD) dwSPIVersion,
                (DWORD) pParams->dwExtLowVersion,
                (DWORD) pParams->dwExtHighVersion,
                (ULONG_PTR) &pParams->dwExtVersion

                )) == 0)
        {
            if (pParams->dwExtVersion == 0)
            {
                pParams->lResult = PHONEERR_INCOMPATIBLEEXTVERSION;
            }
            else
            {
                *pdwNumBytesReturned = sizeof(PHONENEGOTIATEEXTVERSION_PARAMS);
            }
        }
    }

PNegotiateExtVersion_epilog:

    PHONEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        "NegotiateExtVersion"
        );
}


void
WINAPI
POpen(
    PTCLIENT            ptClient,
    PPHONEOPEN_PARAMS   pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex,
                        bOpenedtPhone = FALSE,
                        bReleasetPhoneMutex = FALSE;
    LONG                lResult;
    DWORD               dwDeviceID = pParams->dwDeviceID, dwNumMonitors;
    HANDLE              hMutex;
    PTPHONE             ptPhone = NULL;
    PTPHONECLIENT       ptPhoneClient = NULL;
    PTPHONELOOKUPENTRY  pLookupEntry;
    HANDLE              hLookupEntryMutex = NULL;


    if ((lResult = PHONEPROLOG(
            ptClient,          // tClient
            DEVICE_ID,                  // widget type
            (DWORD) pParams->hPhoneApp, // client widget handle
            NULL,                       // provider widget handle
            &dwDeviceID,                // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            0,                          // provider func index
            NULL,                       // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            "Open"                      // func name

            )) == 0)
    {
        DWORD       dwPrivilege = pParams->dwPrivilege,
                    dwExtVersion = pParams->dwExtVersion;
        PTPROVIDER  ptProvider;
        BOOL        bDuplicateOK = FALSE;


        //
        // Check if the global reinit flag is set
        //

        if (TapiGlobals.dwFlags & TAPIGLOBALS_REINIT)
        {
            lResult = PHONEERR_REINIT;
            goto POpen_cleanup;
        }


        //
        // Validate params
        //

        if ((dwPrivilege != PHONEPRIVILEGE_MONITOR) &&
            (dwPrivilege != PHONEPRIVILEGE_OWNER))
        {
            lResult = PHONEERR_INVALPRIVILEGE;
            goto POpen_cleanup;
        }

        pLookupEntry = GetPhoneLookupEntry (dwDeviceID);

        TapiEnterCriticalSection (&TapiGlobals.CritSec);

        if ( pLookupEntry->hMutex )
        {
            bDuplicateOK = DuplicateHandle(
                TapiGlobals.hProcess,
                pLookupEntry->hMutex,
                TapiGlobals.hProcess,
                &hLookupEntryMutex,
                0,
                FALSE,
                DUPLICATE_SAME_ACCESS
                );
        }

        TapiLeaveCriticalSection(&TapiGlobals.CritSec);

        if ( !bDuplicateOK )
        {
            LOG((TL_ERROR, "DuplicateHandle failed!"));

            lResult = PHONEERR_OPERATIONFAILED;
            goto POpen_cleanup;
        }

        if (!IsAPIVersionInRange(
                pParams->dwAPIVersion,
                pLookupEntry->dwSPIVersion
                ))
        {
            lResult = PHONEERR_INCOMPATIBLEAPIVERSION;
            goto POpen_cleanup;
        }

        ptProvider = pLookupEntry->ptProvider;


        //
        // Create & init a tPhoneClient & associated resources
        //

        if (!(ptPhoneClient = ServerAlloc (sizeof(TPHONECLIENT))))
        {
            lResult = PHONEERR_NOMEM;
            goto POpen_cleanup;
        }

        if (!(ptPhoneClient->hPhone = (HPHONE) NewObject(
                ghHandleTable,
                ptPhoneClient,
                0
                )))
        {
            ptPhoneClient = NULL;
            ServerFree (ptPhoneClient);
            lResult = PHONEERR_NOMEM;
            goto POpen_cleanup;
        }

        ptPhoneClient->ptClient     = ptClient;
        ptPhoneClient->hRemotePhone = (pParams->hRemotePhone ?
            (DWORD) pParams->hRemotePhone : ptPhoneClient->hPhone);
        ptPhoneClient->dwAPIVersion = pParams->dwAPIVersion;
        ptPhoneClient->dwPrivilege  = pParams->dwPrivilege;
        ptPhoneClient->OpenContext  = pParams->OpenContext;

        //
        // Grab the tPhone's mutex, then start doing the open
        //

POpen_waitForMutex:

        if (WaitForSingleObject (hLookupEntryMutex, INFINITE)
                != WAIT_OBJECT_0)
        {
            LOG((TL_ERROR, "WaitForSingleObject failed!"));

            lResult = PHONEERR_OPERATIONFAILED;
            goto POpen_cleanup;
        }

        bReleasetPhoneMutex = TRUE;


        //
        // If the tPhone is in the process of being destroyed then spin
        // until it's been completely destroyed (DestroytPhone() will
        // NULLify pLookupEntry->ptPhone when it's finished). Make sure
        // to release the mutex while sleeping so we don't block
        // DestroytPhone.
        //

        try
        {
            while (pLookupEntry->ptPhone &&
                   pLookupEntry->ptPhone->dwKey != TPHONE_KEY)
            {
                ReleaseMutex (hLookupEntryMutex);
                Sleep (0);
                goto POpen_waitForMutex;
            }
        }
        myexcept
        {
            // If here pLookupEntry->ptPhone was NULLified, safe to continue
        }


        //
        // Validate ext ver as appropriate
        //

        if (dwExtVersion != 0 &&
            (!IsValidPhoneExtVersion (dwDeviceID, dwExtVersion) ||
            ptProvider->apfn[SP_PHONESELECTEXTVERSION] == NULL))
        {
            lResult = PHONEERR_INCOMPATIBLEEXTVERSION;
            goto POpen_cleanup;
        }


        //
        // Check for exclusive ownership as appropriate
        //

        ptPhone = pLookupEntry->ptPhone;

        if (dwPrivilege == PHONEPRIVILEGE_OWNER &&
            ptPhone &&
            (ptPhone->dwNumOwners != 0)
            )
        {
            lResult = PHONEERR_INUSE;
            goto POpen_cleanup;
        }

        if (ptPhone == NULL)
        {
            if (!(ptPhone = ServerAlloc (sizeof(TPHONE))))
            {
                lResult = PHONEERR_NOMEM;
                goto POpen_cleanup;
            }

            if (!(ptPhone->hPhone = (HPHONE) NewObject(
                    ghHandleTable,
                    (LPVOID) ptPhone,
                    NULL
                    )))
            {
                ServerFree (ptPhone);
                lResult = PHONEERR_NOMEM;
                goto POpen_cleanup;
            }

            ptPhone->dwKey        = TINCOMPLETEPHONE_KEY;
            ptPhone->hMutex       = pLookupEntry->hMutex;
            ptPhone->ptProvider   = ptProvider;
            ptPhone->dwDeviceID   = dwDeviceID;
            ptPhone->dwSPIVersion = pLookupEntry->dwSPIVersion;

            bOpenedtPhone = TRUE;

            {
                //
                // Hack Alert!
                //
                // We need to pass the ext version through to
                // remote sp, so we make this a special case
                //

                ULONG_PTR   aParams[2];
                ULONG_PTR   param;


                if (ptProvider == pRemoteSP)
                {
                    aParams[0] = (ULONG_PTR) ptPhone;
                    aParams[1] = dwExtVersion;

                    param = (ULONG_PTR) aParams;
                }
                else
                {
                    param = (ULONG_PTR) ptPhone;
                }

                if (ptProvider->apfn[SP_PHONEOPEN] == NULL)
                {
                    lResult = PHONEERR_OPERATIONUNAVAIL;
                    goto POpen_cleanup;
                }

                if ((lResult = CallSP5(
                        ptProvider->apfn[SP_PHONEOPEN],
                        "phoneOpen",
                        SP_FUNC_SYNC,
                        (DWORD) dwDeviceID,
                        (ULONG_PTR) param,
                        (ULONG_PTR) &ptPhone->hdPhone,
                        (DWORD) pLookupEntry->dwSPIVersion,
                        (ULONG_PTR) PhoneEventProcSP

                        )) != 0)
                {
                    goto POpen_cleanup;
                }
            }
        }

        ptPhoneClient->ptPhone = ptPhone;


        //
        // If the client has specified a non-zero ext version then
        // ask the driver to enable it and/or increment the ext
        // version count.
        //

        if (dwExtVersion)
        {
            if (ptPhone->dwExtVersionCount == 0)
            {
                if (ptProvider != pRemoteSP  &&
                    ((ptProvider->apfn[SP_PHONESELECTEXTVERSION] == NULL) ||
                    (lResult = CallSP2(
                        ptProvider->apfn[SP_PHONESELECTEXTVERSION],
                        "phoneSelectExtVersion",
                        SP_FUNC_SYNC,
                        (ULONG_PTR) ptPhone->hdPhone,
                        (DWORD) dwExtVersion

                        )) != 0))
                {
                    if (bOpenedtPhone && ptProvider->apfn[SP_PHONECLOSE])
                    {
                        CallSP1(
                            ptProvider->apfn[SP_PHONECLOSE],
                            "phoneClose",
                            SP_FUNC_SYNC,
                            (ULONG_PTR) ptPhone->hdPhone
                            );
                    }

                    goto POpen_cleanup;
                }

                ptPhone->dwExtVersion = dwExtVersion;
            }

            ptPhoneClient->dwExtVersion = dwExtVersion;
            ptPhone->dwExtVersionCount++;
        }


        //
        //
        //

        if (dwPrivilege == PHONEPRIVILEGE_OWNER)
        {
            ptPhone->dwNumOwners++;
        }
        else
        {
            ptPhone->dwNumMonitors++;
            dwNumMonitors = ptPhone->dwNumMonitors;
        }


        //
        // Add the tPhoneClient to the tPhone's list
        //

        if ((ptPhoneClient->pNextSametPhone = ptPhone->ptPhoneClients))
        {
            ptPhoneClient->pNextSametPhone->pPrevSametPhone = ptPhoneClient;
        }

        ptPhone->ptPhoneClients = ptPhoneClient;

        if (bOpenedtPhone)
        {
            pLookupEntry->ptPhone = ptPhone;
            ptPhone->dwKey = TPHONE_KEY;
        }

        ReleaseMutex (hLookupEntryMutex);

        bReleasetPhoneMutex = FALSE;


        //
        // Safely add the new tPhoneClient to the tPhoneApp's list
        //

        {
            HANDLE      hMutex;
            PTPHONEAPP  ptPhoneApp;


            if ((ptPhoneApp = WaitForExclusivePhoneAppAccess(
                    pParams->hPhoneApp,
                    ptClient
                    )))
            {

                if (ptPhoneApp->dwAPIVersion <= TAPI_VERSION3_0)
                {
                    FillMemory (
                        ptPhoneClient->adwEventSubMasks, 
                        sizeof(DWORD) * EM_NUM_MASKS,
                        (BYTE) 0xff
                        );
                }
                else
                {
                    CopyMemory (
                        ptPhoneClient->adwEventSubMasks, 
                        ptPhoneApp->adwEventSubMasks,
                        sizeof(DWORD) * EM_NUM_MASKS
                        );
                }

                if ((ptPhoneClient->pNextSametPhoneApp =
                        ptPhoneApp->ptPhoneClients))
                {
                    ptPhoneClient->pNextSametPhoneApp->pPrevSametPhoneApp =
                        ptPhoneClient;
                }

                ptPhoneApp->ptPhoneClients = ptPhoneClient;

                ptPhoneClient->ptPhoneApp = ptPhoneApp;
                ptPhoneClient->dwKey      = TPHONECLIENT_KEY;


                //
                // Fill in the return values
                //

                pParams->hPhone = ptPhoneClient->hPhone;

                UNLOCKTPHONEAPP(ptPhoneApp);


                //
                // Alert other clients that another open has occured
                //

                SendMsgToPhoneClients(
                    ptPhone,
                    ptPhoneClient,
                    PHONE_STATE,
                    (pParams->dwPrivilege == PHONEPRIVILEGE_OWNER ?
                        PHONESTATE_OWNER : PHONESTATE_MONITORS),
                    (pParams->dwPrivilege == PHONEPRIVILEGE_OWNER ?
                        1 : dwNumMonitors),
                    0
                    );

                *pdwNumBytesReturned = sizeof (PHONEOPEN_PARAMS);
            }
            else
            {
                //
                // If here the app handle is bad, & we've some special
                // case cleanup to do.  Since the tPhoneClient is not
                // in the tPhoneApp's list, we can't simply call
                // DestroytPhone(Client) to clean things up, since the
                // pointer-resetting code will blow up.  So we'll
                // grab the tPhone's mutex and explicitly remove the
                // new tPhoneClient from it's list, then do a conditional
                // shutdown on the tPhone (in case any other clients
                // have come along & opened it).
                //
                // Note: keep in mind that a PHONE_CLOSE might be being
                //       processed by another thread (if so, it will be
                //       spinning on trying to destroy the tPhoneClient
                //       which isn't valid at this point)
                //

                lResult = PHONEERR_INVALAPPHANDLE;

                WaitForSingleObject (hLookupEntryMutex, INFINITE);

                //
                // Remove the tpHOneClient from the tLine's list & decrement
                // the number of opens
                //

                if (ptPhoneClient->pNextSametPhone)
                {
                    ptPhoneClient->pNextSametPhone->pPrevSametPhone =
                        ptPhoneClient->pPrevSametPhone;
                }

                if (ptPhoneClient->pPrevSametPhone)
                {
                    ptPhoneClient->pPrevSametPhone->pNextSametPhone =
                        ptPhoneClient->pNextSametPhone;
                }
                else
                {
                    ptPhone->ptPhoneClients = ptPhoneClient->pNextSametPhone;
                }

                if (dwPrivilege == PHONEPRIVILEGE_OWNER)
                {
                    ptPhone->dwNumOwners--;
                }
                else
                {
                    ptPhone->dwNumMonitors--;
                }

                if (dwExtVersion != 0)
                {
                    ptPhone->dwExtVersionCount--;

                    if (ptPhone->dwExtVersionCount == 0 && 
                        ptProvider->apfn[SP_PHONESELECTEXTVERSION])
                    {
                        ptPhone->dwExtVersion = 0;

                        CallSP2(
                            ptProvider->apfn[SP_PHONESELECTEXTVERSION],
                            "phoneSelectExtVersion",
                            SP_FUNC_SYNC,
                            (ULONG_PTR) ptPhone->hdPhone,
                            (DWORD) 0
                            );
                    }
                }

                ReleaseMutex (hLookupEntryMutex);

                DestroytPhone (ptPhone, FALSE); // conditional destroy

                bOpenedtPhone = FALSE; // so we don't do err handling below
            }
        }

        CloseHandle (hLookupEntryMutex);
    }

POpen_cleanup:

    if (bReleasetPhoneMutex)
    {
        ReleaseMutex (hLookupEntryMutex);
        CloseHandle  (hLookupEntryMutex);
    }

    if (lResult != 0)
    {
        if (ptPhoneClient)
        {
            DereferenceObject (ghHandleTable, ptPhoneClient->hPhone, 1);
        }

        if (bOpenedtPhone)
        {
            DereferenceObject (ghHandleTable, ptPhone->hPhone, 1);
        }
    }

    pParams->lResult = lResult;

    PHONEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        "Open"
        );
}


void
WINAPI
PSelectExtVersion(
    PTCLIENT                            ptClient,
    PPHONESELECTEXTVERSION_PARAMS       pParams,
    DWORD                               dwParamsBufferSize,
    LPBYTE                              pDataBuf,
    LPDWORD                             pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex, bCloseMutex2;
    HANDLE              hMutex, hMutex2;
    HDRVPHONE           hdPhone;
    TSPIPROC            pfnTSPI_phoneSelectExtVersion;
    DWORD               dwPrivilege = 0;
    PTPHONECLIENT       ptPhoneClient;


    if ((pParams->lResult = PHONEPROLOG(
            ptClient,          // tClient
            ANY_RT_HPHONE,              // widget type
            (DWORD) pParams->hPhone,    // client widget handle
            (LPVOID) &hdPhone,          // provider widget handle
            &dwPrivilege,               // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_PHONESELECTEXTVERSION,   // provider func index
            &pfnTSPI_phoneSelectExtVersion, // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            "SelectExtVersion"          // func name

            )) == 0)
    {
        if ((ptPhoneClient = ReferenceObject(
                ghHandleTable,
                pParams->hPhone,
                TPHONECLIENT_KEY
                )))
        {
            if (WaitForExclusivetPhoneAccess(
                    ptPhoneClient->ptPhone,
                    &hMutex2,
                    &bCloseMutex2,
                    INFINITE
                    ))
            {
                if (IsValidPhoneExtVersion(
                        ptPhoneClient->ptPhone->dwDeviceID,
                        pParams->dwExtVersion
                        ))
                {
                    if (pParams->dwExtVersion)
                    {
                        if (ptPhoneClient->ptPhone->dwExtVersionCount  ||

                            (pParams->lResult = CallSP2(
                                pfnTSPI_phoneSelectExtVersion,
                                "phoneSelectExtVersion",
                                SP_FUNC_SYNC,
                                (ULONG_PTR) hdPhone,
                                (DWORD) pParams->dwExtVersion

                                )) == 0)
                        {
                            ptPhoneClient->dwExtVersion =
                            ptPhoneClient->ptPhone->dwExtVersion =
                                pParams->dwExtVersion;
                            ptPhoneClient->ptPhone->dwExtVersionCount++;
                        }
                    }
                    else if (ptPhoneClient->ptPhone->dwExtVersionCount)
                    {
                        if (--ptPhoneClient->ptPhone->dwExtVersionCount == 0)
                        {
                            CallSP2(
                                pfnTSPI_phoneSelectExtVersion,
                                "phoneSelectExtVersion",
                                SP_FUNC_SYNC,
                                (ULONG_PTR) hdPhone,
                                (DWORD) 0
                                );

                            ptPhoneClient->ptPhone->dwExtVersion = 0;
                        }

                        ptPhoneClient->dwExtVersion = 0;
                    }
                }
                else
                {
                    pParams->lResult = PHONEERR_INCOMPATIBLEEXTVERSION;
                }

                MyReleaseMutex (hMutex2, bCloseMutex2);
            }
            else
            {
                pParams->lResult = PHONEERR_INVALPHONEHANDLE;
            }

            DereferenceObject (ghHandleTable, pParams->hPhone, 1);
        }
        else
        {
            pParams->lResult = PHONEERR_INVALPHONEHANDLE;
        }
    }

    PHONEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        "SelectExtVersion"
        );

}


void
WINAPI
PSetButtonInfo(
    PTCLIENT                    ptClient,
    PPHONESETBUTTONINFO_PARAMS  pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVPHONE           hdPhone;
    PASYNCREQUESTINFO   pAsyncRequestInfo;
    TSPIPROC            pfnTSPI_phoneSetButtonInfo;
    DWORD               dwPrivilege = PHONEPRIVILEGE_OWNER;


    if ((lRequestID = PHONEPROLOG(
            ptClient,          // tClient
            ANY_RT_HPHONE,              // widget type
            (DWORD) pParams->hPhone,    // client widget handle
            (LPVOID) &hdPhone,          // provider widget handle
            &dwPrivilege,       // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_PHONESETBUTTONINFO,      // provider func index
            &pfnTSPI_phoneSetButtonInfo,// provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            "SetButtonInfo"             // func name

            )) > 0)
    {
        LONG                lResult;
        DWORD               dwAPIVersion, dwSPIVersion;
        LPPHONEBUTTONINFO   pButtonInfoApp = (LPPHONEBUTTONINFO)
                                (pDataBuf + pParams->dwButtonInfoOffset),
                            pButtonInfoSP;


        //
        // Verify size/offset/string params given our input buffer/size
        //

        if (IsBadStructParam(
                dwParamsBufferSize,
                pDataBuf,
                pParams->dwButtonInfoOffset
                ))
        {
            lRequestID = PHONEERR_STRUCTURETOOSMALL;
            goto PSetButtonInfo_epilog;
        }


        //
        // Safely get API & SPI version
        //

        if (GetPhoneVersions(
                pParams->hPhone,
                &dwAPIVersion,
                &dwSPIVersion

                ) != 0)
        {
            lRequestID = PHONEERR_INVALPHONEHANDLE;
            goto PSetButtonInfo_epilog;
        }

        if ((lResult = ValidateButtonInfo(
                pButtonInfoApp,
                &pButtonInfoSP,
                dwAPIVersion,
                dwSPIVersion
                )))
        {
            lRequestID = lResult;
            goto PSetButtonInfo_epilog;
        }

        pParams->lResult = CallSP4(
            pfnTSPI_phoneSetButtonInfo,
            "phoneSetButtonInfo",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdPhone,
            (DWORD) pParams->dwButtonLampID,
            (ULONG_PTR) pButtonInfoSP
            );

        if (pButtonInfoSP != pButtonInfoApp)
        {
            ServerFree (pButtonInfoSP);
        }
    }

PSetButtonInfo_epilog:

    PHONEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        "SetButtonInfo"
        );
}


void
WINAPI
PSetData(
    PTCLIENT                ptClient,
    PPHONESETDATA_PARAMS    pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVPHONE           hdPhone;
    PASYNCREQUESTINFO   pAsyncRequestInfo;
    TSPIPROC            pfnTSPI_phoneSetData;
    DWORD               dwPrivilege = PHONEPRIVILEGE_OWNER;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwSize,
            pParams->dwDataOffset,
            sizeof(DWORD),
            "PSetData",
            "pParams->Data"
            ))
    {
        pParams->lResult = PHONEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = PHONEPROLOG(
            ptClient,          // tClient
            ANY_RT_HPHONE,              // widget type
            (DWORD) pParams->hPhone,    // client widget handle
            (LPVOID) &hdPhone,          // provider widget handle
            &dwPrivilege,       // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_PHONESETDATA,            // provider func index
            &pfnTSPI_phoneSetData,      // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            "SetData"                   // func name

            )) > 0)
    {
        pParams->lResult = CallSP5(
            pfnTSPI_phoneSetData,
            "phoneSetData",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdPhone,
            (DWORD) pParams->dwDataID,
            (ULONG_PTR) (pParams->dwSize ?
                pDataBuf + pParams->dwDataOffset : NULL),
            (DWORD) pParams->dwSize
            );
    }

    PHONEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        "SetData"
        );
}


void
WINAPI
PSetDisplay(
    PTCLIENT                ptClient,
    PPHONESETDISPLAY_PARAMS pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVPHONE           hdPhone;
    PASYNCREQUESTINFO   pAsyncRequestInfo;
    TSPIPROC            pfnTSPI_phoneSetDisplay;
    DWORD               dwPrivilege = PHONEPRIVILEGE_OWNER;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwSize,
            pParams->dwDisplayOffset,
            sizeof(DWORD),
            "PSetDisplay",
            "pParams->Display"
            ))
    {
        pParams->lResult = PHONEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = PHONEPROLOG(
            ptClient,          // tClient
            ANY_RT_HPHONE,              // widget type
            (DWORD) pParams->hPhone,    // client widget handle
            (LPVOID) &hdPhone,          // provider widget handle
            &dwPrivilege,       // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_PHONESETDISPLAY,         // provider func index
            &pfnTSPI_phoneSetDisplay,   // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            "SetDisplay"                // func name

            )) > 0)
    {
        pParams->lResult = CallSP6(
            pfnTSPI_phoneSetDisplay,
            "phoneSetDisplay",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdPhone,
            (DWORD) pParams->dwRow,
            (DWORD) pParams->dwColumn,
            (ULONG_PTR) (pParams->dwSize ?
                pDataBuf + pParams->dwDisplayOffset : NULL),
            (DWORD) pParams->dwSize
            );
    }

    PHONEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        "SetDisplay"
        );
}


void
WINAPI
PSetGain(
    PTCLIENT                ptClient,
    PPHONESETGAIN_PARAMS    pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVPHONE           hdPhone;
    PASYNCREQUESTINFO   pAsyncRequestInfo;
    TSPIPROC            pfnTSPI_phoneSetGain;
    DWORD               dwPrivilege = PHONEPRIVILEGE_OWNER;


    if ((lRequestID = PHONEPROLOG(
            ptClient,          // tClient
            ANY_RT_HPHONE,              // widget type
            (DWORD) pParams->hPhone,    // client widget handle
            (LPVOID) &hdPhone,          // provider widget handle
            &dwPrivilege,       // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_PHONESETGAIN,            // provider func index
            &pfnTSPI_phoneSetGain,      // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            "SetGain"                   // func name

            )) > 0)
    {
        if (!IsOnlyOneBitSetInDWORD (pParams->dwHookSwitchDev) ||
            (pParams->dwHookSwitchDev & ~AllHookSwitchDevs))
        {
            lRequestID = PHONEERR_INVALHOOKSWITCHDEV;
        }
        else
        {
            pParams->lResult = CallSP4(
                pfnTSPI_phoneSetGain,
                "phoneSetGain",
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdPhone,
                (DWORD) pParams->dwHookSwitchDev,
                (DWORD) (pParams->dwGain > 0x0000ffff ?
                    0x0000ffff : pParams->dwGain)
                );
        }
    }

    PHONEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        "SetGain"
        );
}


void
WINAPI
PSetHookSwitch(
    PTCLIENT                    ptClient,
    PPHONESETHOOKSWITCH_PARAMS  pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVPHONE           hdPhone;
    PASYNCREQUESTINFO   pAsyncRequestInfo;
    TSPIPROC            pfnTSPI_phoneSetHookSwitch;
    DWORD               dwPrivilege = PHONEPRIVILEGE_OWNER;


    if ((lRequestID = PHONEPROLOG(
            ptClient,          // tClient
            ANY_RT_HPHONE,              // widget type
            (DWORD) pParams->hPhone,    // client widget handle
            (LPVOID) &hdPhone,          // provider widget handle
            &dwPrivilege,       // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_PHONESETHOOKSWITCH,      // provider func index
            &pfnTSPI_phoneSetHookSwitch,// provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            "SetHookSwitch"             // func name

            )) > 0)
    {
        if (!(pParams->dwHookSwitchDevs & AllHookSwitchDevs) ||
            (pParams->dwHookSwitchDevs & (~AllHookSwitchDevs)))
        {
            lRequestID = PHONEERR_INVALHOOKSWITCHDEV;
        }
        else if (!IsOnlyOneBitSetInDWORD (pParams->dwHookSwitchMode) ||
            (pParams->dwHookSwitchMode & ~AllHookSwitchModes))
        {
            lRequestID = PHONEERR_INVALHOOKSWITCHMODE;
        }
        else
        {
            pParams->lResult = CallSP4(
                pfnTSPI_phoneSetHookSwitch,
                "phoneSetHookSwitch",
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdPhone,
                (DWORD) pParams->dwHookSwitchDevs,
                (DWORD) pParams->dwHookSwitchMode
                );
        }
    }

    PHONEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        "SetHookSwitch"
        );
}


void
WINAPI
PSetLamp(
    PTCLIENT                ptClient,
    PPHONESETLAMP_PARAMS    pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVPHONE           hdPhone;
    PASYNCREQUESTINFO   pAsyncRequestInfo;
    TSPIPROC            pfnTSPI_phoneSetLamp;
    DWORD               dwPrivilege = PHONEPRIVILEGE_OWNER;


    if ((lRequestID = PHONEPROLOG(
            ptClient,          // tClient
            ANY_RT_HPHONE,              // widget type
            (DWORD) pParams->hPhone,    // client widget handle
            (LPVOID) &hdPhone,          // provider widget handle
            &dwPrivilege,       // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_PHONESETLAMP,            // provider func index
            &pfnTSPI_phoneSetLamp,      // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            "SetLamp"                   // func name

            )) > 0)
    {
        if (!IsOnlyOneBitSetInDWORD (pParams->dwLampMode) ||
            (pParams->dwLampMode & ~AllLampModes))
        {
            lRequestID = PHONEERR_INVALLAMPMODE;
        }
        else
        {
            pParams->lResult = CallSP4(
                pfnTSPI_phoneSetLamp,
                "phoneSetLamp",
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdPhone,
                (DWORD) pParams->dwButtonLampID,
                (DWORD) pParams->dwLampMode
                );
        }
    }

    PHONEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        "SetLamp"
        );
}


void
WINAPI
PSetRing(
    PTCLIENT                ptClient,
    PPHONESETRING_PARAMS    pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVPHONE           hdPhone;
    PASYNCREQUESTINFO   pAsyncRequestInfo;
    TSPIPROC            pfnTSPI_phoneSetRing;
    DWORD               dwPrivilege = PHONEPRIVILEGE_OWNER;


    if ((lRequestID = PHONEPROLOG(
            ptClient,          // tClient
            ANY_RT_HPHONE,              // widget type
            (DWORD) pParams->hPhone,    // client widget handle
            (LPVOID) &hdPhone,          // provider widget handle
            &dwPrivilege,       // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_PHONESETRING,            // provider func index
            &pfnTSPI_phoneSetRing,      // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            "SetRing"                   // func name

            )) > 0)
    {
        pParams->lResult = CallSP4(
            pfnTSPI_phoneSetRing,
            "phoneSetRing",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdPhone,
            (DWORD) pParams->dwRingMode,
            (DWORD) (pParams->dwVolume > 0x0000ffff ?
                0x0000ffff : pParams->dwVolume)
            );
    }

    PHONEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        "SetRing"
        );
}


void
WINAPI
PSetStatusMessages(
    PTCLIENT                        ptClient,
    PPHONESETSTATUSMESSAGES_PARAMS  pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex, bCloseMutex2;
    HANDLE              hMutex, hMutex2;
    HDRVPHONE           hdPhone;
    TSPIPROC            pfnTSPI_phoneSetStatusMessages;
    DWORD               dwPrivilege = PHONEPRIVILEGE_MONITOR;


    if ((pParams->lResult = PHONEPROLOG(
            ptClient,          // tClient
            ANY_RT_HPHONE,              // widget type
            pParams->hPhone,            // client widget handle
            (LPVOID) &hdPhone,          // provider widget handle
            &dwPrivilege,               // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_PHONESETSTATUSMESSAGES,  // provider func index
            &pfnTSPI_phoneSetStatusMessages,    // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
             "SetStatusMessages"        // func name

            )) == 0)
    {
        DWORD           dwAPIVersion, dwUnionPhoneStates, dwUnionButtonModes,
                        dwUnionButtonStates;
        PTPHONECLIENT   ptPhoneClient, ptPhoneClient2;
        PTPHONE         ptPhone;


        //
        // Safely get the ptPhone & api version
        //

        if (!(ptPhoneClient = ReferenceObject(
                ghHandleTable,
                pParams->hPhone,
                0
                )))
        {
            pParams->lResult = PHONEERR_INVALPHONEHANDLE;
            goto PSetStatusMessages_epilog;
        }

        try
        {
            ptPhone = ptPhoneClient->ptPhone;

            dwAPIVersion = ptPhoneClient->dwAPIVersion;

            if (ptPhoneClient->dwKey != TPHONECLIENT_KEY)
            {
                pParams->lResult = PHONEERR_INVALPHONEHANDLE;
                goto PSetStatusMessages_Dereference;
            }
        }
        myexcept
        {
            pParams->lResult = PHONEERR_INVALPHONEHANDLE;
            goto PSetStatusMessages_Dereference;
        }


        //
        // Validate the params
        //

        {
            DWORD   dwValidPhoneStates, dwValidButtonStates;


            switch (dwAPIVersion)
            {
            case TAPI_VERSION1_0:

                dwValidPhoneStates  = AllPhoneStates1_0;
                dwValidButtonStates = AllButtonStates1_0;
                break;

            default: // case TAPI_VERSION1_4:

                dwValidPhoneStates  = AllPhoneStates1_4;
                dwValidButtonStates = AllButtonStates1_4;
                break;

            }

            if ((pParams->dwPhoneStates & ~dwValidPhoneStates))
            {
                pParams->lResult = PHONEERR_INVALPHONESTATE;
                goto PSetStatusMessages_Dereference;
            }

            if ((pParams->dwButtonStates & ~dwValidButtonStates))
            {
                pParams->lResult = PHONEERR_INVALBUTTONSTATE;
                goto PSetStatusMessages_Dereference;
            }

            if ((pParams->dwButtonModes & ~AllButtonModes))
            {
                pParams->lResult = PHONEERR_INVALBUTTONMODE;
                goto PSetStatusMessages_Dereference;
            }

            if (pParams->dwButtonModes && !pParams->dwButtonStates)
            {
                pParams->lResult = PHONEERR_INVALBUTTONSTATE;
                goto PSetStatusMessages_Dereference;
            }
        }


        //
        // Make sure the REINIT bit is always set
        //

        pParams->dwPhoneStates |= PHONESTATE_REINIT;


        //
        // Get exclusive access to the device, determine the
        // new union of all the client's status message settings
        // and call down to the SP as appropriate
        //

        dwUnionPhoneStates  = pParams->dwPhoneStates;
        dwUnionButtonModes  = pParams->dwButtonModes;
        dwUnionButtonStates = pParams->dwButtonStates;

waitForExclAccess:

        if (WaitForExclusivetPhoneAccess(
                ptPhone,
                &hMutex2,
                &bCloseMutex2,
                INFINITE
                ))
        {
            if (ptPhone->dwBusy)
            {
                MyReleaseMutex (hMutex2, bCloseMutex2);
                Sleep (50);
                goto waitForExclAccess;
            }

            for(
                ptPhoneClient2 = ptPhone->ptPhoneClients;
                ptPhoneClient2;
                ptPhoneClient2 = ptPhoneClient2->pNextSametPhone
                )
            {
                if (ptPhoneClient2 != ptPhoneClient)
                {
                    dwUnionPhoneStates  |= ptPhoneClient2->dwPhoneStates;
                    dwUnionButtonModes  |= ptPhoneClient2->dwButtonModes;
                    dwUnionButtonStates |= ptPhoneClient2->dwButtonStates;
                }
            }

            if ((dwUnionPhoneStates != ptPhone->dwUnionPhoneStates)  ||
                (dwUnionButtonModes != ptPhone->dwUnionButtonModes)  ||
                (dwUnionButtonStates != ptPhone->dwUnionButtonStates))
            {
                ptPhone->dwBusy = 1;

                MyReleaseMutex (hMutex2, bCloseMutex2);

                pParams->lResult = CallSP4(
                        pfnTSPI_phoneSetStatusMessages,
                        "phoneSetStatusMessages",
                        SP_FUNC_SYNC,
                        (ULONG_PTR) hdPhone,
                        (DWORD) dwUnionPhoneStates,
                        (DWORD) dwUnionButtonModes,
                        (DWORD) dwUnionButtonStates
                        );

                if (WaitForExclusivetPhoneAccess(
                        ptPhone,
                        &hMutex2,
                        &bCloseMutex2,
                        INFINITE
                        ))
                {
                    ptPhone->dwBusy = 0;

                    if (pParams->lResult == 0)
                    {
                        ptPhone->dwUnionPhoneStates  = dwUnionPhoneStates;
                        ptPhone->dwUnionButtonModes  = dwUnionButtonModes;
                        ptPhone->dwUnionButtonStates = dwUnionButtonStates;
                    }

                    MyReleaseMutex (hMutex2, bCloseMutex2);
                }
                else
                {
                    pParams->lResult = PHONEERR_INVALPHONEHANDLE;
                }
            }
            else
            {
                MyReleaseMutex (hMutex2, bCloseMutex2);
            }

            if (pParams->lResult == 0)
            {
                if (WaitForExclusivePhoneClientAccess (ptPhoneClient))
                {
                    ptPhoneClient->dwPhoneStates  = pParams->dwPhoneStates;
                    ptPhoneClient->dwButtonModes  = pParams->dwButtonModes;
                    ptPhoneClient->dwButtonStates = pParams->dwButtonStates;

                    UNLOCKTPHONECLIENT (ptPhoneClient);
                }
                else
                {
                    //
                    // The client is invalid now, but don't bother
                    // restoring the status msg states (will eventually
                    // get reset correctly & worse case is that SP just
                    // sends some extra msgs that get discarded)
                    //

                    pParams->lResult = PHONEERR_INVALPHONEHANDLE;
                }
            }
        }
        else
        {
            pParams->lResult = PHONEERR_INVALPHONEHANDLE;
        }

PSetStatusMessages_Dereference:

        DereferenceObject (ghHandleTable, pParams->hPhone, 1);
    }

PSetStatusMessages_epilog:

    PHONEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        "SetStatusMessages"
        );
}


void
WINAPI
PSetVolume(
    PTCLIENT                ptClient,
    PPHONESETVOLUME_PARAMS  pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVPHONE           hdPhone;
    PASYNCREQUESTINFO   pAsyncRequestInfo;
    TSPIPROC            pfnTSPI_phoneSetVolume;
    DWORD               dwPrivilege = PHONEPRIVILEGE_OWNER;


    if ((lRequestID = PHONEPROLOG(
            ptClient,          // tClient
            ANY_RT_HPHONE,              // widget type
            (DWORD) pParams->hPhone,    // client widget handle
            (LPVOID) &hdPhone,          // provider widget handle
            &dwPrivilege,       // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_PHONESETVOLUME,          // provider func index
            &pfnTSPI_phoneSetVolume,    // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            "SetVolume"                 // func name

            )) > 0)
    {
        if (!IsOnlyOneBitSetInDWORD (pParams->dwHookSwitchDev) ||
            (pParams->dwHookSwitchDev & ~AllHookSwitchDevs))
        {
            lRequestID = PHONEERR_INVALHOOKSWITCHDEV;
        }
        else
        {
            pParams->lResult = CallSP4(
                pfnTSPI_phoneSetVolume,
                "phoneSetVolume",
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdPhone,
                (DWORD) pParams->dwHookSwitchDev,
                (DWORD) (pParams->dwVolume > 0x0000ffff ?
                    0x0000ffff : pParams->dwVolume)
                );
        }
    }

    PHONEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        "SetVolume"
        );
}


void
WINAPI
PShutdown(
    PTCLIENT                ptClient,
    PPHONESHUTDOWN_PARAMS   pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    pParams->lResult = DestroytPhoneApp (pParams->hPhoneApp);

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "phoneShutdown: exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE, 
            "phoneShutdown: exit, result=x%x",
            pParams->lResult
            ));
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\server\resource.h ===
//
// (c) 1995 Microsoft Corporation.  Portions Copyright Intel/Microsoft 1992-93.  All Rights Reserved."
//
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by TELEPHON.RC
//
#define IDS_DC_GL_DRIVER_SETUP          1
#define IDS_DT_GL_DRIVER_LIST           2
#define IDCL_CR_HELP                    3
#define IDS_DC_GL_LOCATION              4
#define ID_CURRENT                      4
#define IDS_DT_GL_LOC_LIST              5
#define IDS_DC_GL_CALL_CARD             6
#define ID_NEW                          6
#define IDS_DT_GL_CARD_LIST             7
#define IDS_TITLE                       8
#define IDS_STATUS_LINE                 9
#define IDHELP                          9
#define IDS_HELP_FILE                   10
#define IDS_CLOSE                       11
#define IDS_CUSTOMIZE                   12
#define IDS_ADD_LOCATION                13
#define IDS_EDIT_LOCATION               14
#define IDS_WRN_REMOVE_CARD             15
#define IDS_ERR_APPLICATION             16
#define IDS_ERR_MEMORY                  17
#define IDS_ERR_ALREADY_IN_LIST         18
#define IDS_ERR_READ_PRIV_INI           19
#define IDS_ERR_WRITE_INI               20
#define IDS_ERR_INVALID_INI             21
#define IDS_ERR_WRITE_WIN_INI           22
#define IDS_WRN_INVALID_STR             23
#define IDS_WRN_INVALID_EX_NUM_STR      24
#define IDS_WRN_INVALID_NUM             25
#define IDS_ERR_INVALID_TAPIADDR        26
#define IDS_WRN_INI_READ_ONLY           27
#define IDS_DT_DS_NO_DRIVER             28
#define IDS_ERR_NO_DRIVER               29
#define IDS_ERR_BAD_DRIVER              30
#define IDS_NONE                        31
#define IDS_ADD_CALLING_CARD            32
#define IDS_EDIT_CALLING_CARD           33
#define IDS_CARD_REMOVE                 34
#define IDS_LOCATION_REMOVE             35
#define IDS_DRIVER_REMOVE               36
#define IDS_ERR_INVALID_INI_LOCATIONS   37
#define IDS_ERR_INVALID_INI_CARDS       38
#define IDD_BROWSE_TEMPLATE             38
#define IDS_ERR_INVALID_INI_DRIVERS     39

#ifndef CHICAGO
#define IDS_ERR_INVALID_INI_COUNTRIES   40
#endif

#define IDS_WRN_AREA_CODE_REQUIRED      41
#define IDS_WRN_INVALID_NUM_STR         42
#define IDS_WRN_INVALID_LOCATION_CARD   43
#define IDS_WRN_DRIVER_IN_USE           44
#define IDS_ERR_DRIVER_FAILED           45
#define IDS_ERR_MULTIPLE_INST           46

#define IDS_DIAL_ASST                   47
#define IDS_ERR_UPDATE_LOCATION          48
#define IDS_ERR_UPDATE_CARD              49
#define IDS_WRN_LOCATION_NAME_REQUIRED  50
#define IDS_WRN_CANNOT_CHANGE_DEF_LOC   51
#define IDS_WRN_LOCATION_NAME_REQUIRED  50

#define IDS_PROVIDERERROR_NOT_AN_SP     52
#define IDS_PROVIDERERROR_TOO_OLD       53
#define IDS_PROVIDERERROR_FAILED_INIT   54
#define IDS_WRN_CARD_NAME_REQUIRED  	 55
#define IDS_WRN_QUITING_WIZ            56

#define IDS_WRN_CANT_REMOVE_LAST_CARD   57

#define IDS_WRN_CARD_NUMBER_REQUIRED    58
#define IDS_MSG_SIMPLEMSG_MDMINSTALLED  59


#define IDD_TELEPHONY                   101
#define IDD_GENERIC_LIST                102
#define IDD_TOLL_LIST                   104
#define IDD_CREDIT_CARD                 105
#define IDD_DIALING_RULES               106
#define IDI_TELEPHONY                   108
#define IDD_COPY_DIAL_RULES             109
#define IDD_ADD_DRIVER                  111
#define IDD_DEFINE_LOCATION             112
#define IDD_DEFINE_LOCATION_SIMPLE      113
#define IDD_DRIVER_SETUP                116
#define IDD_INSTALL_DRIVER              117
#define IDB_BITMAP1                     120
#define IDD_DEBUG_OUT                   121
#define ID_LIST                         303
#define LB_UNLISTED                     306

#define IDS_WRN_TITLE_WARNING           350
#define IDS_WRN_TITLE_NAMEINUSE         351
#define IDS_WRN_TITLE_INVALCHAR         352
#define IDS_WRN_TITLE_SURE              353
#define IDS_WRN_TITLE_REQUIRED          354

#define IDCC_TM_CURR_LOCATION           1000
#define IDD_INSERT_DISK                 1000
#define IDD_BROWSE                      1001
#define IDD_UNLISTED_DRIVERS            1002
#define IDD_UPDATE                      1003
#define IDD_RESTART                     1004
#define IDD_EXISTS                      1005
#define IDCB_TM_MULT_LOCATIONS          1007
#define IDCB_TM_DRIVER_SETUP            1008
#define IDCB_TM_HELP                    1009
#define IDCB_GL_REMOVE                  1011
#define IDCB_TL_REMOVE                  1012
#define IDCB_TL_ADD                     1013
#define IDCB_TL_HELP                    1014
#define IDCK_TL_USE_AREA_CODE           1015
#define IDCT_GL_LIST_TEXT               1017
#define IDCB_CC_CUSTOMIZE               1018
#define IDCB_CC_HELP                    1019
#define IDCE_CC_CARD_NAME               1020
#define IDCE_CC_CARD_NUM                1021
#define IDCB_DR_COPY_FROM               1022
#define IDCE_CC_PASSWORD_CARD_NUM       1022
#define IDCB_DR_HELP                    1023
#define IDCE_DR_LOCAL_NUM               1024
#define IDCE_DR_LONG_NUM                1025
#define IDCE_DR_INTERNATIONAL_NUM       1026
#define IDCL_CR_RULE_LIST               1031
#define IDCB_AD_ADD                     1032
#define IDCB_AD_BROWSE                  1033
#define IDCH_AD_HELP                    1034
#define IDCE_DL_CURR_LOCATION           1035
#define IDCE_DL_LOCAL_CALLS             1036
#define IDCE_DL_LONG_DIST_CALLS         1037
#define IDCE_DL_AREA_CODE               1038
#define psh15                           0x040e
#define IDCC_DL_COUNTRY_CODE            1039
#define IDCC_DL_CALLING_CARD            1040
#define chx1                            0x0410
#define IDCB_DL_TOLL_LIST               1041
#define IDCL_AD_DRIVER_LIST             1042
#define IDCB_DL_CALLCARD_SETUP          1052
#define IDCB_DL_HELP                    1053
#define IDCC_TL_TOLL_LIST               1055
#define IDCB_DS_EDIT                    1056
#define IDCL_DS_LIST                    1057
#define IDCB_DS_ADD                     1058
#define IDCB_DS_REMOVE                  1059
#define IDCB_DS_HELP                    1060
#define IDCK_DR_HIDE_CARD               1061
#define IDCS_TM_LOCAL_CALLS             1062
#define IDCS_TM_LONG_DIST_CALLS         1063
#define IDCS_TM_AREA_CODE               1064
#define IDCS_TM_COUNTRY_CODE            1065
#define IDCS_TM_CALLING_CARD            1066
#define IDCB_INSTALL_BROWSE             1067
#define IDC_BUTTON2                     1068
#define IDCB_ID_HELP                    1068
#define IDC_EDIT1                       1069
#define IDCE_PATHNAME                   1069
#define IDT_DEBUG                       1070
#define IDCB_TM_CALLCARD_SETUP          1081
#define IDCB_GL_EDIT                    1083
#define stc1                            0x0440
#define stc2                            0x0441
#define IDCB_GL_ADD                     1109
#define IDCB_GL_HELP                    1112
#define lst1                            0x0460
#define IDCL_GL_LIST                    1121
#define lst2                            0x0461
#define cmb1                            0x0470
#define cmb2                            0x0471
#define edt1                            0x0480
#define ctlLast                         0x04ff
#define IDS_NAME                        2001
#define IDS_NAME2                       2002
#define IDS_NOINF                       2003
#define IDS_NOINF2                      2004
#define IDS_OUTOFDISK                   2005
#define IDS_NOINF3                      2006
#define IDS_NAME3                       2007
#define IDS_RESTARTTEXT                 2015
#define IDS_UPDATED                     2031
#define IDS_UNLISTED                    2034
#define IDS_UNABLE_TOINSTALL            2049
#define IDS_FILEINUSEADD                2053
#define IDS_FILEINUSEREM                2055
#define IDS_FILEINUSEREM2               2056
#define IDS_DRIVER_EXISTS               2058
#define IDS_DIAL_ASST_NOT_SET                2059
#define IDS_WRN_DIAL_ASST_NOT_SET        2060
#define ID_STATUS2                      4002
#define IDS_FILENOTINDIR                0x2001
#define IDS_DISKMSG                     0x2002
#define IDS_FILEMSG                     0x2003
#define IDS_DISKFILEMSG                 0x2004
#define IDH_DLG_ADD_UNKNOWN             8803
#define IDD_PATH                        0x3002
#define IDD_TEXT                        0x3003
#define IDD_ICON                        0x3004
#define IDC_STATIC                      -1

#define IDCC_DL_CURR_LOCATION                5000
#define IDCB_DL_NEW_LOCATION                 5001
#define IDCK_DL_IN_LOCAL                     5002
#define IDCB_DL_REMOVE_LOCATION          5003
#define IDCB_DL_CHANGE_CARD              5004
#define IDCK_DL_CALLING_CARD                 5005
#define IDCK_DL_CALL_WAITING                 5006
#define IDCK_DL_PULSE_DIAL                   5007
#define IDCC_DL_CALL_WAITING                 5008
#define IDCE_DL_CALLING_CARD                 5009
#define IDCS_DL_CURR_LOCATION            5010
#define IDCS_DL_AREA_CODE                5011
#define IDCS_DL_COUNTRY_CODE             5012
#define IDCS_DL_OUTSIDE                  5013
#define IDCS_DL_LOCAL_CALLS              5014
#define IDCS_DL_LONG_DIST_CALLS          5015

#define IDCS_DL_SILENTTEXT               5016



#define IDCC_DR_CARD_NAME               6000
#define IDCE_DR_CARD_NUM                6001
#define IDCK_DR_IN_LOCAL                     6002
#define IDCB_DR_NEW_CARD                     6003
#define IDCB_DR_REMOVE_CARD              6004
#define IDCB_DR_ADVANCED                     6005
#define IDCS_DR_CARD_NAME                   6006
#define IDCS_DR_CARD_NUM                    6007
#define IDCS_DR_LOCAL_NUM                   6008
#define IDCS_DR_LONG_NUM                    6009
#define IDCS_DR_INTERNATIONAL_NUM           6010
#define IDCB_DR_DUMMY                       6011

#define IDCR_PULSE                          6050
#define IDCR_TONE                               6051
#define IDCS_PULSE                       6052
#define IDCS_TONE                        6053

#define IDD_NEW_LOCATION                    7000
#define IDCE_NL_NEW_LOCATION                7001
#define IDCS_NL_NEW_LOCATION                7002

#define IDD_NEW_CARD                            8000
#define IDCE_NC_NEW_CARD                    8001
#define IDCS_NC_NEW_CARD                    8002
#define IDCS_CR_RULE_LIST                   8003

#define IDCS_DIAL_NUMBER_TEXT               9000
#define IDCS_DL_DIAL_NUMBER             9001
#define IDCS_DR_DIAL_NUMBER             9002
#define IDCS_LOC_BMP                            9100
#define IDCL_LOC_BMP                            9101
#define IDCL_LOC_SIMPLE_BMP             9102

#define IDD_CALLING_CARD_CHANGE         9150

#define IDI_LINE_ICON                   9200
#define IDI_PHONE_ICON                  9201

/* ALERT! Do NOT change this value. It is used by the RNA guys
 * to identify the Dialing info dialog for their Modems Wizard.
 */
#define IDD_WIZ_DIALINFO                400


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        122
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1071
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif


#define RC_COUNTRY_ID_BASE      16000
#define RC_COUNTRY_GROUP_BASE   17000
#define RC_COUNTRY_NAME_BASE    27000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\server\tapimmc.c ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    tapimmc.c

Abstract:

    Src module for tapi server mmc-support funcs

Author:

    Dan Knudson (DanKn)    10-Dec-1997

Revision History:

--*/


#include "windows.h"
#include "stdio.h"
#include "stdlib.h"
#include "assert.h"
#include "tapi.h"
#include "utils.h"
#include "tapiclnt.h"
#include "tspi.h"
#include "client.h"
#include "server.h"
#include "tapimmc.h"
#include "private.h"
#include "Sddl.h"

typedef struct _USERNAME_TUPLE
{
    LPWSTR  pDomainUserNames;

    LPWSTR  pFriendlyUserNames;

} USERNAME_TUPLE, *LPUSERNAME_TUPLE;


typedef struct _MMCGETAVAILABLEPROVIDERS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;


    union
    {
        IN  HLINEAPP    hLineApp;
    };

    union
    {
        IN  DWORD       dwProviderListTotalSize;    // size of client buffer
        OUT DWORD       dwProviderListOffset;       // valid offset on success
    };

} MMCGETAVAILABLEPROVIDERS_PARAMS, *PMMCGETAVAILABLEPROVIDERS_PARAMS;


typedef struct _MMCGETDEVICEINFO_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;


    union
    {
        IN  HLINEAPP    hLineApp;
    };

    union
    {
        IN  DWORD       dwDeviceInfoListTotalSize;  // size of client buffer
        OUT DWORD       dwDeviceInfoListOffset;     // valid offset on success
    };

} MMCGETDEVICEINFO_PARAMS, *PMMCGETDEVICEINFO_PARAMS;


typedef struct _MMCGETSERVERCONFIG_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;


    union
    {
        IN  HLINEAPP    hLineApp;
    };

    union
    {
        IN  DWORD       dwServerConfigTotalSize;    // size of client buffer
        OUT DWORD       dwServerConfigOffset;       // valid offset on success
    } ;

} MMCGETSERVERCONFIG_PARAMS, *PMMCGETSERVERCONFIG_PARAMS;


typedef struct _MMCSETDEVICEINFO_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;


    union
    {
        IN  HLINEAPP    hLineApp;
    };

    union
    {
        IN  DWORD       dwDeviceInfoListOffset;     // valid offset
    };

} MMCSETDEVICEINFO_PARAMS, *PMMCSETDEVICEINFO_PARAMS;


typedef struct _MMCSETSERVERCONFIG_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;


    union
    {
        IN  HLINEAPP    hLineApp;
    };

    union
    {
        IN  DWORD       dwServerConfigOffset;       // valid offset
    };

} MMCSETSERVERCONFIG_PARAMS, *PMMCSETSERVERCONFIG_PARAMS;

typedef struct _MMCGETDEVICEFLAGS_PARAMS
{

    OUT LONG            lResult;
    
    DWORD               dwUnused;

    IN HLINEAPP         hLineApp;

    IN DWORD            fLine;

    IN DWORD            dwProviderID;
    
    IN DWORD            dwPermanentDeviceID;

    OUT DWORD           dwFlags;

    OUT DWORD           dwDeviceID;
    
} MMCGETDEVICEFLAGS_PARAM, *PMMCGETDEVICEFLAGS_PARAMS;

LPDEVICEINFOLIST gpLineInfoList = NULL;
LPDEVICEINFOLIST gpPhoneInfoList = NULL;
LPDWORD          gpLineDevFlags = NULL;
DWORD            gdwNumFlags = 0;
BOOL             gbLockMMCWrite = FALSE;

//
//  the last ftLastWriteTime of tsec.ini when we build the
//  gpLineInfoList or gpPhoneInfoList, we will rebuild the
//  *InfList if tsec.ini has been updated since then
//
FILETIME         gftLineLastWrite = {0};
FILETIME         gftPhoneLastWrite = {0};
CRITICAL_SECTION gMgmtCritSec;

WCHAR gszLines[] = L"Lines";
WCHAR gszPhones[] = L"Phones";
WCHAR gszFileName[] = L"..\\TAPI\\tsec.ini";
WCHAR gszEmptyString[] = L"";
WCHAR gszFriendlyUserName[] = L"FriendlyUserName";
WCHAR gszTapiAdministrators[] = L"TapiAdministrators";

//
//  The following are the length of the constant strings
//  defined above (excluding the terminating zero). The above
//  string should not be changed normally. If for some
//  reason the above strings need to be changed, the following
//  CCH_constants need to be changed accordingly.
//

#define CCH_LINES 5
#define CCH_PHONES 6
#define CCH_FRIENDLYUSERNAME 16
#define CCH_TAPIADMINISTRATORS 18

extern TAPIGLOBALS TapiGlobals;

extern TCHAR gszProductType[];
extern TCHAR gszProductTypeServer[];
extern TCHAR gszProductTypeLanmanNt[];
extern TCHAR gszRegKeyNTServer[];

extern HANDLE ghEventService;

PTLINELOOKUPENTRY
GetLineLookupEntry(
    DWORD   dwDeviceID
    );

PTPHONELOOKUPENTRY
GetPhoneLookupEntry(
    DWORD   dwDeviceID
    );

BOOL
InitTapiStruct(
    LPVOID  pTapiStruct,
    DWORD   dwTotalSize,
    DWORD   dwFixedSize,
    BOOL    bZeroInit
    );

DWORD
GetDeviceIDFromPermanentID(
    TAPIPERMANENTID ID,
    BOOL            bLine
    );

DWORD
GetProviderFriendlyName(
    WCHAR  *pFileNameBuf,
    WCHAR **ppFriendlyNameBuf
    );

BOOL
IsBadStructParam(
    DWORD   dwParamsBufferSize,
    LPBYTE  pDataBuf,
    DWORD   dwXxxOffset
    );

LONG
PASCAL
GetClientList(
    BOOL            bAdminOnly,
    PTPOINTERLIST   *ppList
    );

extern CRITICAL_SECTION *gLockTable;
extern DWORD            gdwPointerToLockTableIndexBits;

#define POINTERTOTABLEINDEX(p) \
            ((((ULONG_PTR) p) >> 4) & gdwPointerToLockTableIndexBits)

PTCLIENT
PASCAL
WaitForExclusiveClientAccess(
    PTCLIENT    ptClient
    );
    
#define UNLOCKTCLIENT(p) \
            LeaveCriticalSection(&gLockTable[POINTERTOTABLEINDEX(p)])
            
#define UNLOCKTLINECLIENT(p) \
            LeaveCriticalSection(&gLockTable[POINTERTOTABLEINDEX(p)])
            
#define UNLOCKTPHONECLIENT(p) \
            LeaveCriticalSection(&gLockTable[POINTERTOTABLEINDEX(p)])

BOOL
PASCAL
WaitForExclusivetLineAccess(
    PTLINE      ptLine,
    HANDLE     *phMutex,
    BOOL       *pbDupedMutex,
    DWORD       dwTimeout
    );

BOOL
PASCAL
WaitForExclusiveLineClientAccess(
    PTLINECLIENT    ptLineClient
    );

    
BOOL
PASCAL
WaitForExclusivetPhoneAccess(
    PTPHONE     ptPhone,
    HANDLE     *phMutex,
    BOOL       *pbDupedMutex,
    DWORD       dwTimeout
    );

BOOL
PASCAL
WaitForExclusivePhoneClientAccess(
    PTPHONECLIENT   ptPhoneClient
    );

void
DestroytPhoneClient(
    HPHONE  hPhone
    );

void
PASCAL
DestroytLineClient(
    HLINE   hLine
    );

LONG
PASCAL
GetLineAppListFromClient(
    PTCLIENT        ptClient,
    PTPOINTERLIST  *ppList
    );

LONG
PASCAL
GetPhoneAppListFromClient(
    PTCLIENT        ptClient,
    PTPOINTERLIST  *ppList
    );
    
void
WINAPI
MGetAvailableProviders(
    PTCLIENT                            ptClient,
    PMMCGETAVAILABLEPROVIDERS_PARAMS    pParams,
    DWORD                               dwParamsBufferSize,
    LPBYTE                              pDataBuf,
    LPDWORD                             pdwNumBytesReturned
    )
{
    WCHAR                   szPath[MAX_PATH+8], *pFileNameBuf,
                            *pFriendlyNameBuf, *p, *p2;
    DWORD                   dwFileNameBufTotalSize, dwFileNameBufUsedSize,
                            dwFriendlyNameBufTotalSize,
                            dwFriendlyNameBufUsedSize,
                            dwNumProviders, dwSize, i;
    HANDLE                  hFind;
    WIN32_FIND_DATAW        findData;
    LPAVAILABLEPROVIDERLIST pList = (LPAVAILABLEPROVIDERLIST) pDataBuf;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (pParams->dwProviderListTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if (pParams->dwProviderListTotalSize < sizeof (AVAILABLEPROVIDERLIST))
    {
        pParams->lResult = LINEERR_STRUCTURETOOSMALL;
        return;
    }

    pList->dwTotalSize              = pParams->dwProviderListTotalSize;
    pList->dwNeededSize             =
    pList->dwUsedSize               = sizeof (*pList);
    pList->dwNumProviderListEntries =
    pList->dwProviderListSize       =
    pList->dwProviderListOffset     = 0;

    pParams->dwProviderListOffset = 0;


    //
    // Find all the files in the system directory with the extenion .TSP
    //

    GetSystemDirectoryW (szPath, MAX_PATH);

    wcscat (szPath, L"\\*.TSP");

    if ((hFind = FindFirstFileW (szPath, &findData)) == INVALID_HANDLE_VALUE)
    {
        LOG((TL_ERROR,
            "MGetAvailableProviders: FindFirstFile err=%d",
            GetLastError()
            ));

        goto done;
    }

    dwNumProviders         =
    dwFileNameBufTotalSize =
    dwFileNameBufUsedSize  = 0;

    do
    {
        LOG((TL_INFO,
            "MGetAvailableProviders: found '%ws'",
            findData.cFileName
            ));

        dwSize = (wcslen (findData.cFileName) + 1) * sizeof (WCHAR);

        if ((dwSize + dwFileNameBufUsedSize) > dwFileNameBufTotalSize)
        {
            if (!(p = ServerAlloc (dwFileNameBufTotalSize += 512)))
            {
                FindClose (hFind);
                pParams->lResult = LINEERR_NOMEM;
                return;
            }

            if (dwFileNameBufUsedSize)
            {
                CopyMemory (p, pFileNameBuf, dwFileNameBufUsedSize);

                ServerFree (pFileNameBuf);
            }

            pFileNameBuf = p;
        }

        CopyMemory(
            ((LPBYTE) pFileNameBuf) + dwFileNameBufUsedSize,
            findData.cFileName,
            dwSize
            );

        dwFileNameBufUsedSize += dwSize;

        dwNumProviders++;

    } while (FindNextFileW (hFind, &findData));

    FindClose (hFind);


    //
    // For each of the files we found above get their "friendly" name
    // (use the module name if there's no friendly name)
    //
    RpcImpersonateClient (0);
    dwFriendlyNameBufUsedSize = GetProviderFriendlyName (pFileNameBuf, &pFriendlyNameBuf);
    RpcRevertToSelf();

    if (0 == dwFriendlyNameBufUsedSize)
    {
        pFriendlyNameBuf = pFileNameBuf;

        dwFriendlyNameBufUsedSize = dwFileNameBufUsedSize;
    }

    pList->dwNeededSize +=
        (dwNumProviders * sizeof (AVAILABLEPROVIDERENTRY)) +
        dwFileNameBufUsedSize +
        dwFriendlyNameBufUsedSize;


    //
    // Now if there's enough room in the buffer for everything then
    // pack it all in there
    //

    if (pList->dwNeededSize <= pList->dwTotalSize)
    {
        DWORD                       dwNumAvailProviders;
        LPAVAILABLEPROVIDERENTRY    pEntry = (LPAVAILABLEPROVIDERENTRY)
                                        (pList + 1);


        pList->dwUsedSize += dwNumProviders * sizeof (AVAILABLEPROVIDERENTRY);

        p  = pFileNameBuf;
        p2 = pFriendlyNameBuf;

        for (i = dwNumAvailProviders = 0; i < dwNumProviders; i++)
        {
            HANDLE  hTsp;


            if (!(hTsp = LoadLibraryW (p)))
            {
                //
                // If we can't even load the tsp then ignore it
                //

                p += wcslen (p) + 1;
                p2 += wcslen (p2) + 1;
                continue;
            }
            
            if (GetProcAddress (hTsp, "TSPI_providerInstall"))
            {
                pEntry->dwOptions = AVAILABLEPROVIDER_INSTALLABLE;
            }
            else
            {
                pEntry->dwOptions = 0;
            }

            if (GetProcAddress (hTsp, "TSPI_providerConfig") ||
                GetProcAddress (hTsp, "TUISPI_providerConfig"))
            {
                pEntry->dwOptions |= AVAILABLEPROVIDER_CONFIGURABLE;
            }

            if (GetProcAddress (hTsp, "TSPI_providerRemove"))
            {
                pEntry->dwOptions |= AVAILABLEPROVIDER_REMOVABLE;
            }

            FreeLibrary (hTsp);


            pEntry->dwFileNameSize   = (wcslen (p) + 1) * sizeof (WCHAR);
            pEntry->dwFileNameOffset = pList->dwUsedSize;

            CopyMemory(
                ((LPBYTE) pList) + pEntry->dwFileNameOffset,
                p,
                pEntry->dwFileNameSize
                );

            pList->dwUsedSize += pEntry->dwFileNameSize;

            p += pEntry->dwFileNameSize / sizeof (WCHAR);


            pEntry->dwFriendlyNameSize   = (wcslen (p2) + 1) * sizeof (WCHAR);
            pEntry->dwFriendlyNameOffset = pList->dwUsedSize;

            CopyMemory(
                ((LPBYTE) pList) + pEntry->dwFriendlyNameOffset,
                p2,
                pEntry->dwFriendlyNameSize
                );

            pList->dwUsedSize += pEntry->dwFriendlyNameSize;

            p2 += pEntry->dwFriendlyNameSize / sizeof (WCHAR);


            dwNumAvailProviders++; pEntry++;
        }

        pList->dwNumProviderListEntries = dwNumAvailProviders;
        pList->dwProviderListSize       =
            dwNumProviders * sizeof (AVAILABLEPROVIDERENTRY);
        pList->dwProviderListOffset     = sizeof (*pList);
    }

    ServerFree (pFileNameBuf);

    if (pFriendlyNameBuf != pFileNameBuf)
    {
        ServerFree (pFriendlyNameBuf);
    }

done:

    *pdwNumBytesReturned = sizeof (TAPI32_MSG) + pList->dwUsedSize;

    pParams->lResult = 0;
}


DWORD
PASCAL
MyGetPrivateProfileString(
    LPCWSTR     pszSection,
    LPCWSTR     pszKey,
    LPCWSTR     pszDefault,
    LPWSTR     *ppBuf,
    LPDWORD     pdwBufSize
    )
{
    DWORD dwResult;


    while (1)
    {
        dwResult = GetPrivateProfileStringW(
            pszSection,
            pszKey,
            pszDefault,
            *ppBuf,
            *pdwBufSize / sizeof (WCHAR),
            gszFileName
            );

        if (dwResult < ((*pdwBufSize) / sizeof(WCHAR) - 2))
        {
            return 0;
        }

        ServerFree (*ppBuf);

        *pdwBufSize *= 2;

        if (!(*ppBuf = ServerAlloc (*pdwBufSize)))
        {
            break;
        }
    }

    return LINEERR_NOMEM;
}


DWORD
PASCAL
InsertInfoListString(
    LPDEVICEINFOLIST    *ppInfoList,
    DWORD               dwInfoIndex,
    DWORD               dwXxxSizeFieldOffset,
    LPWSTR              psz,
    DWORD               dwLength,
    BOOL                bAppendNull
    )
{
    LPDWORD             pdwXxxSize;
    LPDEVICEINFO        pInfo;
    LPDEVICEINFOLIST    pInfoList = *ppInfoList;


    if (!dwLength)
    {
        return 0;
    }


    //
    // If the existing buffer is too small the alloc a larger one
    //

    if ((pInfoList->dwUsedSize + dwLength + sizeof (WCHAR)) >
            pInfoList->dwTotalSize)
    {
        DWORD   dwTotalSize = (*ppInfoList)->dwTotalSize + dwLength + 4096;


        if (!(pInfoList = ServerAlloc (dwTotalSize)))
        {
            return LINEERR_NOMEM;
        }

        CopyMemory (pInfoList, *ppInfoList, (*ppInfoList)->dwUsedSize);

        pInfoList->dwTotalSize = dwTotalSize;;

        ServerFree (*ppInfoList);

        *ppInfoList = pInfoList;
    }

    CopyMemory (((LPBYTE) pInfoList) + pInfoList->dwUsedSize, psz, dwLength);

    pInfo = ((LPDEVICEINFO)(pInfoList + 1)) + dwInfoIndex;

    pdwXxxSize = (LPDWORD) (((LPBYTE) pInfo) + dwXxxSizeFieldOffset);

    if ((*pdwXxxSize += dwLength) == dwLength)
    {
        *(pdwXxxSize + 1) = pInfoList->dwUsedSize;
    }

    pInfoList->dwUsedSize += dwLength;

    if (bAppendNull)
    {
        *((WCHAR *)(((LPBYTE) pInfoList) + pInfoList->dwUsedSize)) = L'\0';

        pInfoList->dwUsedSize += sizeof (WCHAR);

        *pdwXxxSize += sizeof (WCHAR);
    }

    return 0;
}


DWORD
PASCAL
GrowCapsBuf(
    LPDWORD    *ppXxxCaps,
    LPDWORD     pdwBufSize
    )
{
    DWORD   dwTotalSize = **ppXxxCaps + 256, *pXxxCapsTmp;


    if (!(pXxxCapsTmp = ServerAlloc (dwTotalSize)))
    {
        return LINEERR_NOMEM;
    }

    *pdwBufSize = *pXxxCapsTmp = dwTotalSize;

    ServerFree (*ppXxxCaps);

    *ppXxxCaps = pXxxCapsTmp;

    return 0;
}


DWORD
PASCAL
ChangeDeviceUserAssociation(
    LPWSTR  pDomainUserName,
    LPWSTR  pFriendlyUserName,
    DWORD   dwProviderID,
    DWORD   dwPermanentDeviceID,
    BOOL    bLine
    )
{
    DWORD   dwSize = 64 * sizeof (WCHAR), dwLength, dwNeededSize;
    WCHAR  *p, *p2, *p3, buf[32];
    BOOL    bAlreadyIn;
    WCHAR  *pSub;


    if (!(p = ServerAlloc (dwSize)))
    {
        return LINEERR_NOMEM;
    }

    if (MyGetPrivateProfileString(
            pDomainUserName,
            (bLine ? gszLines : gszPhones),
            gszEmptyString,
            &p,
            &dwSize
            ))
    {
        ServerFree (p);
        return LINEERR_NOMEM;
    }

    dwLength = wsprintfW (buf, L"%d,%d", dwProviderID, dwPermanentDeviceID);

    //
    //  Check if the specified Device/User assocation is already there
    //  if so bAlreadyIn is set to be true and pSub points to the
    //  (dwProviderID, dwPermanentDeviceID) pair
    //
    bAlreadyIn = FALSE;
    pSub = p;
    while (*pSub)
    {
        if ((wcsncmp(pSub, buf, dwLength) == 0) && 
            (*(pSub + dwLength) == L',' || *(pSub + dwLength) == L'\0'))
        {
            bAlreadyIn = TRUE;
            break;
        }

        //
        //  Skip the next two delimiting ','
        //
        if (!(pSub = wcschr (pSub, L',')))
        {
            break;
        }
        pSub++;
        if (!(pSub = wcschr (pSub, L',')))
        {
            break;
        }
        pSub++;
    }

    if (pFriendlyUserName) // Add device/user association
    {
        //  Always write the friendly name which could be different
        WritePrivateProfileStringW(
            pDomainUserName,
            gszFriendlyUserName,
            pFriendlyUserName,
            gszFileName
            );

        if ( !bAlreadyIn)
        {
            dwNeededSize = (dwLength + wcslen (p) + 2) * sizeof (WCHAR);

            if (dwNeededSize > dwSize)
            {
                if (!(p2 = ServerAlloc (dwNeededSize)))
                {
                    return LINEERR_NOMEM;
                }

                wcscpy (p2, p);
                ServerFree (p);
                p = p2;
            }

            if (*p == L'\0')
            {
                wcscpy (p, buf);
            }
            else
            {
                wcscat (p, L",");
                wcscat (p, buf);
            }
        }
    }
    else // Remove device/user association
    {
        p2 = pSub;

        if (bAlreadyIn)
        {
            if (*(p2 + dwLength) == L',') // not last item in list, so copy
            {
                for(
                    p3 = p2 + dwLength + 1;
                    (*p2 = *p3) != L'\0';
                    p2++, p3++
                    );
            }
            else if (*(p2 + dwLength) == L'\0')
            {
                if (p2 == p) // only item in list, so list == ""
                {
                    *p2 = L'\0';
                }
                else // last item in list, so nuke preceding ','
                {
                    *(p2 - 1) = L'\0';
                }
            }
        }

        if (*p == L'\0')
        {
        }
    }

    if (bLine && *p == 0)
    {
        WritePrivateProfileStringW(
            pDomainUserName,
            NULL,
            NULL,
            gszFileName
            );
    }
    else
    {
        WritePrivateProfileStringW(
            pDomainUserName,
            (bLine ? gszLines : gszPhones),
            p,
            gszFileName
            );
    }

    ServerFree (p);

    return 0;
}

//
//  UpdateLastWriteTime
//      It reads the ftLastWriteTime of the tsec.ini into gftLineLastWrite or
//  gftPhoneLastWrite, it also returns S_FALSE, if the timestamp is newer
//
LONG
UpdateLastWriteTime (
    BOOL                        bLine
    )
{
    LONG     lResult = S_OK;
    WCHAR       szFilePath[MAX_PATH + 16];    // include space for "tsec.ini"
    WIN32_FILE_ATTRIBUTE_DATA fad;
    FILETIME *  pft;
    DWORD       dwError;
        
    if (GetSystemWindowsDirectoryW(szFilePath, MAX_PATH) == 0)
    {
        lResult = LINEERR_OPERATIONFAILED;
        goto ExitHere;
    }

    wcscat (szFilePath, L"\\");
    wcscat (szFilePath, gszFileName);
    pft = bLine ? &gftLineLastWrite : &gftPhoneLastWrite;

    if (GetFileAttributesExW (
        szFilePath,
        GetFileExInfoStandard,
        &fad) == 0
        )
    {
        dwError = GetLastError();
        if (dwError == ERROR_FILE_NOT_FOUND || dwError == ERROR_PATH_NOT_FOUND)
        {
            ZeroMemory (pft, sizeof(FILETIME));
            lResult = S_FALSE;
        }
        else
        {
            lResult = LINEERR_OPERATIONFAILED;
        }
        goto ExitHere;
    }

    if (fad.ftLastWriteTime.dwHighDateTime > pft->dwHighDateTime ||
        fad.ftLastWriteTime.dwLowDateTime > pft->dwLowDateTime)
    {
        pft->dwHighDateTime = fad.ftLastWriteTime.dwHighDateTime;
        pft->dwLowDateTime = fad.ftLastWriteTime.dwLowDateTime;
        lResult = S_FALSE;
    }

ExitHere:
    return lResult;
}

//
//  InsertDevNameAddrInfo
//      Utlity to fill
//          DEVICEINFO.dwDeviceNameSize
//          DEVICEINFO.dwDeviceNameOffset
//          DEVICEINFO.dwAddressSize
//          DEVICEINFO.dwAddressOffset
//      dwDeviceID is the device ID to retrieve information while
//      dwEntry is the DEVICEINFO entry index in the deviceinfo list
//
//

LONG
InsertDevNameAddrInfo (
    BOOL                        bLine,
    LPDEVICEINFOLIST            *ppList,
    LPDWORD                     pdwDevFlags,
    DWORD                       dwDeviceID,
    DWORD                       dwEntry
    )
{
    LPDEVICEINFO                pInfo = ((LPDEVICEINFO)((*ppList) + 1)) + dwEntry;
    PTLINELOOKUPENTRY           pLLE;
    PTPHONELOOKUPENTRY          pPLE;
    LONG                        lResult = S_OK;
    DWORD                       k;
    
    LINEDEVCAPS                 devCaps[3];
    LPLINEDEVCAPS               pDevCaps = devCaps;
    DWORD                       dwDevCapsTotalSize = sizeof(devCaps);
    
    LINEADDRESSCAPS             addrCaps[3];
    LPLINEADDRESSCAPS           pAddrCaps = addrCaps;
    DWORD                       dwAddrCapsTotalSize = sizeof(addrCaps);

    TapiEnterCriticalSection(&TapiGlobals.CritSec);
    
    if (bLine)
    {
        pLLE = GetLineLookupEntry (dwDeviceID);

        if (!pLLE ||
            pLLE->bRemoved)
        {
             lResult = S_FALSE;
             goto ExitHere;
        }

        pInfo->dwProviderID = pLLE->ptProvider->dwPermanentProviderID;
    }
    else
    {
        pPLE = GetPhoneLookupEntry (dwDeviceID);

        if (!pPLE ||
            pPLE->bRemoved)
        {
             lResult = S_FALSE;
             goto ExitHere;
        }
        pInfo->dwProviderID = pPLE->ptProvider->dwPermanentProviderID;
    }

    //
    // Retrieve device name from TSPI_xxGetCaps
    //

get_dev_caps:

    InitTapiStruct(
        pDevCaps,
        dwDevCapsTotalSize,
        sizeof (LINEDEVCAPS),
        TRUE
        );

    if (bLine)
    {
        lResult = CallSP4(
            pLLE->ptProvider->apfn[SP_LINEGETDEVCAPS],
            "lineGetDevCaps",
            SP_FUNC_SYNC,
            (DWORD) dwDeviceID,
            (DWORD) pLLE->dwSPIVersion,
            (DWORD) 0,
            (ULONG_PTR) pDevCaps
            );
    }
    else
    {
        lResult = CallSP4(
            pPLE->ptProvider->apfn[SP_PHONEGETDEVCAPS],
            "phoneGetDevCaps",
            SP_FUNC_SYNC,
            (DWORD) dwDeviceID,
            (DWORD) pPLE->dwSPIVersion,
            (DWORD) 0,
            (ULONG_PTR) pDevCaps
            );
    }
    if (lResult != 0)
    {
        //
        // We can't get the name or the PermDevID, so ignore this device
        //

        goto ExitHere;
    }
    else if (pDevCaps->dwNeededSize <= pDevCaps->dwTotalSize)
    {
        DWORD   dwXxxSize;
        LPWSTR  pwszXxxName;
        const WCHAR szUnknown[] = L"Unknown";

        if (bLine)
        {
            pInfo->dwPermanentDeviceID = pDevCaps->dwPermanentLineID;

            if (pdwDevFlags)
            {
                *pdwDevFlags = pDevCaps->dwDevCapFlags;
            }

            dwXxxSize = pDevCaps->dwLineNameSize;

            pwszXxxName = (WCHAR *) (((LPBYTE) pDevCaps) +
                pDevCaps->dwLineNameOffset);

        }
        else
        {
            LPPHONECAPS pPhoneCaps = (LPPHONECAPS) pDevCaps;


            pInfo->dwPermanentDeviceID = pPhoneCaps->dwPermanentPhoneID;

            dwXxxSize = pPhoneCaps->dwPhoneNameSize;

            pwszXxxName = (WCHAR *) (((LPBYTE) pPhoneCaps) +
                pPhoneCaps->dwPhoneNameOffset);
        }

        if (dwXxxSize == 0  ||  *pwszXxxName == L'\0')
        {
            dwXxxSize = 8 * sizeof (WCHAR);

            pwszXxxName = (LPWSTR) szUnknown;
        }

        if (InsertInfoListString(
                ppList,
                dwEntry,
                (DWORD) (((LPBYTE) &pInfo->dwDeviceNameSize) -
                    ((LPBYTE) pInfo)),
                pwszXxxName,
                dwXxxSize,
                FALSE
                ))
        {
            lResult = LINEERR_NOMEM;
            goto ExitHere;
        }
    }
    //
    //  if the pDevCaps is not large enough, increase the size
    //  by 256 and try again.
    //
    else
    {
        LPLINEDEVCAPS       pNewDevCaps;
        
        dwDevCapsTotalSize += 256;
        pNewDevCaps = ServerAlloc (dwDevCapsTotalSize);
        if (pNewDevCaps == NULL)
        {
            lResult = LINEERR_NOMEM;
            goto ExitHere;
        }
        if (pDevCaps != devCaps)
        {
            ServerFree (pDevCaps);
        }
        pDevCaps = pNewDevCaps;
        goto get_dev_caps;
    }


    if (bLine)
    {
        //
        // for each address on this line retrieve the address "name"
        // by calling TSPI_lineGetAddressCaps.  Terminate the last
        // address name in the list with an extra Null character.
        //

        for (k = 0; k < pDevCaps->dwNumAddresses; k++)
        {

get_addr_caps:
            InitTapiStruct(
                pAddrCaps,
                dwAddrCapsTotalSize,
                sizeof (LINEADDRESSCAPS),
                TRUE
                );

            if ((lResult = CallSP5(
                pLLE->ptProvider->apfn[SP_LINEGETADDRESSCAPS],
                "lineGetAddressCaps",
                SP_FUNC_SYNC,
                (DWORD) dwDeviceID,
                (DWORD) k,
                (DWORD) pLLE->dwSPIVersion,
                (DWORD) 0,
                (ULONG_PTR) pAddrCaps
                )) == 0)
            {
                if (pAddrCaps->dwNeededSize <= pAddrCaps->dwTotalSize)
                {
                    if (InsertInfoListString(
                        ppList,
                        dwEntry,
                        (DWORD) (((LPBYTE) &pInfo->dwAddressesSize) -
                            ((LPBYTE) pInfo)),
                        (LPWSTR) (((LPBYTE) pAddrCaps) +
                            pAddrCaps->dwAddressOffset),
                        pAddrCaps->dwAddressSize,
                        (k < (pDevCaps->dwNumAddresses - 1) ?
                            FALSE : TRUE)
                        ))
                    {
                        lResult = LINEERR_NOMEM;
                        goto ExitHere;
                    }
                }
                //
                //  if the pAddrCaps is not large enough, increase the size
                //  by 256 and try again.
                //
                else
                {
                    LPLINEADDRESSCAPS          pNewAddrCaps;
                    dwAddrCapsTotalSize += 256;
                    pNewAddrCaps = ServerAlloc (dwAddrCapsTotalSize);
                    if (pNewAddrCaps == NULL)
                    {
                        goto ExitHere;
                    }
                    if (pAddrCaps != addrCaps)
                    {
                        ServerFree (pAddrCaps);
                    }
                    pAddrCaps = pNewAddrCaps;
                    goto get_addr_caps;
                }
            }
            else
            {
                // no addr name (will default to blank, not bad)
            }
        }
    }

ExitHere:
    if (pDevCaps != devCaps)
    {
        ServerFree (pDevCaps);
    }
    if (pAddrCaps != addrCaps)
    {
        ServerFree (pAddrCaps);
    }
    TapiLeaveCriticalSection(&TapiGlobals.CritSec);
    return lResult;
}

//
//  AppendNewDeviceInfo
//      This function insert a newly created device identified by 
//  dwDeviceID into the cached gpLineInfoList or gpPhoneInfoList in
//  response to LINE/PHONE_CREATE message
//

LONG
AppendNewDeviceInfo (
    BOOL                        bLine,
    DWORD                       dwDeviceID
    )
{
    LONG             lResult = S_OK;
    LPDEVICEINFOLIST    pXxxList;
    DWORD               dwXxxDevices;
    DWORD               dwTotalSize;
    DWORD               dwSize, dw;

    EnterCriticalSection (&gMgmtCritSec);

    pXxxList = bLine? gpLineInfoList : gpPhoneInfoList;
    dwXxxDevices = bLine ? TapiGlobals.dwNumLines : TapiGlobals.dwNumPhones;

    if (pXxxList == NULL)
    {
        goto ExitHere;
    }

    //
    //  make sure we have enough space to accomodate the new device flags
    if (bLine && gpLineDevFlags && gdwNumFlags < dwXxxDevices)
    {
        LPDWORD         pNewLineDevFlags;

        pNewLineDevFlags = ServerAlloc (dwXxxDevices * sizeof(DWORD));
        if (pNewLineDevFlags == NULL)
        {
            goto ExitHere;
        }
        CopyMemory (
            pNewLineDevFlags, 
            gpLineDevFlags, 
            gdwNumFlags * sizeof(DWORD)
            );
        ServerFree (gpLineDevFlags);
        gpLineDevFlags = pNewLineDevFlags;
        gdwNumFlags = dwXxxDevices;
    }

    //
    //  make sure we have enough space for the new DEVICEINFO entry
    //  An estimate is done for the new DEVICEINFO entry
    //  the estimation includes:
    //      1. Fixed size of DEVICEINFO structure
    //      2. 20 bytes each for DeviceName, Addresses, DomainUserName
    //         and FriendlyUserName
    //
    dwTotalSize = pXxxList->dwUsedSize + 
        sizeof(DEVICEINFO) + (20 + 20 + 20 + 20) * sizeof(WCHAR);
    if (dwTotalSize > pXxxList->dwTotalSize)
    {
        LPDEVICEINFOLIST        pNewList;

        pNewList = ServerAlloc (dwTotalSize);
        if (pNewList == NULL)
        {
            lResult = (bLine ? LINEERR_NOMEM : PHONEERR_NOMEM);
            goto ExitHere;
        }
        CopyMemory (pNewList, pXxxList, pXxxList->dwUsedSize);
        pNewList->dwTotalSize = dwTotalSize;
        pXxxList = pNewList;
        if (bLine)
        {
            ServerFree (gpLineInfoList);
            gpLineInfoList = pXxxList;
        }
        else
        {
            ServerFree (gpPhoneInfoList);
            gpPhoneInfoList = pXxxList;
        }
    }

    //  Now make space for the new DEVICEINFO entry
    if (pXxxList->dwUsedSize > 
        pXxxList->dwDeviceInfoSize + sizeof(*pXxxList))
    {
        LPBYTE      pbVar = (LPBYTE) pXxxList + 
            pXxxList->dwDeviceInfoSize + sizeof(*pXxxList);
        LPDEVICEINFO    pInfo = (LPDEVICEINFO)(((LPBYTE)pXxxList) + 
            sizeof(*pXxxList));
        dwSize = pXxxList->dwUsedSize - 
            pXxxList->dwDeviceInfoSize - sizeof(*pXxxList);
        MoveMemory (
            pbVar + sizeof(DEVICEINFO),
            pbVar,
            dwSize);
        ZeroMemory (pbVar, sizeof(DEVICEINFO));
        for (dw = 0; 
            dw < pXxxList->dwNumDeviceInfoEntries; 
            ++dw
            )
        {
            if (pInfo->dwDeviceNameOffset != 0)
            {
                pInfo->dwDeviceNameOffset += sizeof(DEVICEINFO);
            }
            if (pInfo->dwAddressesOffset != 0)
            {
                pInfo->dwAddressesOffset += sizeof(DEVICEINFO);
            }
            if (pInfo->dwDomainUserNamesOffset != 0)
            {
                pInfo->dwDomainUserNamesOffset += sizeof(DEVICEINFO);
            }
            if (pInfo->dwFriendlyUserNamesOffset != 0)
            {
                pInfo->dwFriendlyUserNamesOffset += sizeof(DEVICEINFO);
            }
            ++pInfo;
        }
    }
    pXxxList->dwUsedSize += sizeof(DEVICEINFO);
    pXxxList->dwNeededSize = pXxxList->dwUsedSize;

    //  Now add the new entry
    lResult = InsertDevNameAddrInfo (
        bLine,
        (bLine ? (&gpLineInfoList) : (&gpPhoneInfoList)),
        (bLine && dwDeviceID < gdwNumFlags) ? (gpLineDevFlags + dwDeviceID) : NULL,
        dwDeviceID,
        pXxxList->dwNumDeviceInfoEntries
        );
    if (lResult == 0)
    {
        pXxxList = bLine? gpLineInfoList : gpPhoneInfoList;
        pXxxList->dwDeviceInfoSize += sizeof(DEVICEINFO);
        ++pXxxList->dwNumDeviceInfoEntries;
        pXxxList->dwNeededSize = pXxxList->dwUsedSize;
    }

ExitHere:
    LeaveCriticalSection (&gMgmtCritSec);

    return lResult;
}

//
//  RemoveDeviceInfoEntry
//      // This function removes a device info entry from the gpLineInfoList
//  or gpPhoneInfoList identified by dwDevice in response to LINE/PHONE_REMOVE
//  message
//

LONG
RemoveDeviceInfoEntry (
    BOOL                        bLine,
    DWORD                       dwDeviceID
    )
{
    LPDEVICEINFOLIST            pXxxList;
    LPDEVICEINFO                pInfo;
    int                         iIndex, cItems;
    LPBYTE                      pb;

    EnterCriticalSection (&gMgmtCritSec);

    pXxxList = bLine ? gpLineInfoList : gpPhoneInfoList;
    if (pXxxList == NULL)
    {
        goto ExitHere;
    }
    
    pInfo = (LPDEVICEINFO)(pXxxList + 1);

    cItems = (int)pXxxList->dwNumDeviceInfoEntries;
    iIndex = dwDeviceID;
    if ((int)dwDeviceID >= cItems)
    {
        iIndex = cItems - 1;
    }
    pInfo += iIndex;
    while (iIndex >= 0)
    {
        TAPIPERMANENTID     tpid;

        tpid.dwDeviceID = pInfo->dwPermanentDeviceID;
        tpid.dwProviderID = pInfo->dwProviderID;

        if (dwDeviceID == GetDeviceIDFromPermanentID(tpid, bLine))
        {
            break;
        }
        --pInfo;
        --iIndex;
    }
    if (iIndex < 0)
    {
        goto ExitHere;
    }

    //  With the entry pointed to by iIndex found, move down
    //  all the DEVICEINFO entry above it
    if (iIndex < cItems - 1)
    {
        pb = (LPBYTE)((LPDEVICEINFO)(pXxxList + 1) + iIndex);
        MoveMemory (
            pb, 
            pb + sizeof(DEVICEINFO), 
            (cItems - 1 - iIndex) * sizeof(DEVICEINFO)
            );
    }
    pXxxList->dwDeviceInfoSize -= sizeof(DEVICEINFO);
    --pXxxList->dwNumDeviceInfoEntries;

ExitHere:
    LeaveCriticalSection (&gMgmtCritSec);
    return 0;
}

//
//  BuildDeviceInfoList
//      Private function called by GetDeviceInfo to build the DEVICEINFOLIST
//  if not already created, the list is saved in gpLineInfoList or 
//  gpPhoneInfoList
//

LONG
BuildDeviceInfoList(
    BOOL                        bLine
    )
{
    LONG                lResult = S_OK;
    DWORD               dwNumDevices, dwListTotalSize, dwFriendlyNameSize,
                        dwDomainUserNameSize, dwFriendlyUserNameSize;
    DWORD               i, j;
    LPDEVICEINFOLIST    pList = NULL;
    LPUSERNAME_TUPLE    pUserNames= NULL;
    LPWSTR              lpszFriendlyName = NULL;
    LPDEVICEINFO        pInfo;
    
    HANDLE              hIniFile = 0;
    HANDLE              hFileMap = NULL;
    char *              lpszFileBuf = NULL;
    char*               lpszLineAnsiBuf = NULL;
    LPWSTR              lpszLineWcharBuf = NULL;
    DWORD               dwAnsiLineBufSize, dwWcharLineBufSize;
    DWORD               dwTotalFileSize;
    DWORD               dwFilePtr;
    LPWSTR              lpszDomainUser = NULL;
    DWORD               cbDomainUser;
    LPDWORD             lpdwDevFlags = NULL;
    WCHAR               *p;

    //
    // Alloc a buffer to use for the device info list.  Size includes
    // the list header, list entries for each existing device,
    // and space wide unicode strings for device name, (address,)
    // domain\user name(s), and friendly user name(s) (each est to 20 char).
    //
    // Also alloc buffers to use for retrieving device & address caps,
    // and a buffer to temporarily store pointers to user name
    // strings (which are associated with each line)
    //

    TapiEnterCriticalSection(&TapiGlobals.CritSec);
    dwNumDevices = (bLine ? TapiGlobals.dwNumLines : TapiGlobals.dwNumPhones);
    TapiLeaveCriticalSection(&TapiGlobals.CritSec);

    dwAnsiLineBufSize = 256 * sizeof(WCHAR);
    dwWcharLineBufSize = 256 * sizeof(WCHAR);
    dwFriendlyNameSize = 64 * sizeof (WCHAR);
    cbDomainUser = 128;
    dwListTotalSize =
        sizeof (DEVICEINFOLIST) +
        (dwNumDevices * sizeof (DEVICEINFO)) +
        (dwNumDevices * (20 + 20 + 20 + 20) * sizeof (WCHAR));

    if (!(pList      = ServerAlloc (dwListTotalSize)) ||
        !(pUserNames = ServerAlloc (dwNumDevices * sizeof (USERNAME_TUPLE))) ||
        !(lpszFriendlyName = ServerAlloc (dwFriendlyNameSize)) ||
        !(lpszLineAnsiBuf = ServerAlloc (dwAnsiLineBufSize)) ||
        !(lpszLineWcharBuf = ServerAlloc (dwWcharLineBufSize)) ||
        !(lpszDomainUser = ServerAlloc (cbDomainUser)))
    {
        lResult = LINEERR_NOMEM;
        goto ExitHere;
    }

    if (bLine && !(lpdwDevFlags = ServerAlloc (dwNumDevices * sizeof (DWORD))))
    {
        lResult = LINEERR_NOMEM;
        goto ExitHere;
    }

    pList->dwTotalSize            = dwListTotalSize;
    pList->dwUsedSize             = sizeof (*pList) +
                                      dwNumDevices * sizeof (DEVICEINFO);
    pList->dwDeviceInfoSize       = dwNumDevices * sizeof (DEVICEINFO);
    pList->dwDeviceInfoOffset     = sizeof (*pList);

    //
    // Get info for all the lines, including:
    //
    //      Provider ID
    //      Permanent Device ID
    //      Device Name
    //      (Addresses)
    //
    // ... and pack this info in the list sequentially
    //

    LOG((TL_INFO,
        "GetDeviceInfo: getting names (addrs) for %ld %ws",
        dwNumDevices,
        (bLine ? gszLines : gszPhones)
        ));

    for (i = j = 0; i < dwNumDevices; i++)
    {
        if (WaitForSingleObject (
            ghEventService,
            0
            ) == WAIT_OBJECT_0)
        {
            lResult = LINEERR_OPERATIONFAILED;
            goto ExitHere;
        }
    
        lResult = InsertDevNameAddrInfo (
            bLine, 
            &pList, 
            bLine ? lpdwDevFlags + i : NULL, 
            i, 
            j
            );
        if (lResult)
        {
            lResult = 0;
            continue;
        }
        ++j;
    }

    dwNumDevices =
    pList->dwNumDeviceInfoEntries = j;  // the number of devices in the list


    //
    // Now enumerate all the known users & figure out what devices they
    // have access to.  Since each device can be seen by zero, one, or
    // many users, we allocate separate user name buffers in this loop
    // rather than try to pack them into the existing device info list.
    //

    //
    //  Open %windir%\tsec.ini file and map it into memory
    //

    {
        TCHAR       szFilePath[MAX_PATH + 16];    // include space for "tsec.ini"
        OFSTRUCT    ofs;
        
        if (GetCurrentDirectory(MAX_PATH, szFilePath) == 0)
        {
            lResult = LINEERR_OPERATIONFAILED;
            goto ExitHere;
        }

        wcscat (szFilePath, L"\\");
        wcscat (szFilePath, gszFileName);

        hIniFile = CreateFile (
            szFilePath, 
            GENERIC_READ, 
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (hIniFile == INVALID_HANDLE_VALUE) 
        {
            DWORD           dwError;
            
            dwError = GetLastError();
            if (dwError != ERROR_FILE_NOT_FOUND 
                && dwError != ERROR_PATH_NOT_FOUND)
            {
                lResult = LINEERR_OPERATIONFAILED;
                goto ExitHere;
            }
        }
        if (hIniFile != INVALID_HANDLE_VALUE)
        {
            dwTotalFileSize = GetFileSize(hIniFile, NULL);
        }
        else
        {
            dwTotalFileSize = 0;
        }
        if (dwTotalFileSize > 0)
        {
            hFileMap = CreateFileMapping (
                hIniFile,
                NULL,
                PAGE_READONLY,
                0,
                0,
                NULL
                );
            if (hFileMap == NULL)
            {
                lResult = LINEERR_OPERATIONFAILED;
                goto ExitHere;
            }
            lpszFileBuf = MapViewOfFile (
                hFileMap,
                FILE_MAP_READ,
                0,
                0,
                0
                );
            if (lpszFileBuf == NULL)
            {
                lResult = LINEERR_OPERATIONFAILED;
                goto ExitHere;
            }
        }
        
    }

    pInfo = (LPDEVICEINFO)(pList + 1);

    dwFilePtr = 0;
    while (dwFilePtr < dwTotalFileSize)
    {
        WCHAR               wch;
        DWORD               cch, cb;
        WCHAR *             lpwsz;
        
        if (WaitForSingleObject (
            ghEventService,
            0
            ) == WAIT_OBJECT_0)
        {
            lResult = LINEERR_OPERATIONFAILED;
            goto ExitHere;
        }
        
        ASSERT (lpszFileBuf != NULL);

        //  Read one line from the file
        cch = 0;
        wch = 0;
        cb = 0;
        while (wch != L'\n' && wch != L'\r' && dwFilePtr < dwTotalFileSize)
        {
            //  Not enough line buffer? if so enlarge
            if (cb >= dwAnsiLineBufSize)
            {
                char        * lpszNewAnsi;
            
                if (!(lpszNewAnsi = ServerAlloc (dwAnsiLineBufSize + 256)))
                {
                    lResult = LINEERR_NOMEM;
                    goto ExitHere;
                }
                CopyMemory (lpszNewAnsi, lpszLineAnsiBuf, cb);
                ServerFree (lpszLineAnsiBuf);
                lpszLineAnsiBuf = lpszNewAnsi;
                dwAnsiLineBufSize += 256;
            }
            
            wch = lpszLineAnsiBuf[cb++] = lpszFileBuf[dwFilePtr++];
            if (IsDBCSLeadByte((BYTE)wch))
            {
                lpszLineAnsiBuf[cb] = lpszFileBuf[dwFilePtr++];
                wch = (wch << 8) + lpszLineAnsiBuf[cb];
                ++cb;
            }
            ++cch;
        }

        //  skip the \r & \n
        if (wch == L'\r' || wch == L'\n')
        {
            lpszLineAnsiBuf[cb - 1] = 0;
            if (dwFilePtr < dwTotalFileSize &&
                ((lpszFileBuf[dwFilePtr] == L'\n') ||
                (lpszFileBuf[dwFilePtr] == L'\r')))
            {
                ++dwFilePtr;
            }
        }

        //  Now convert the ANSI string to Wide char

        //  enough wchar line buffer size?
        if (dwWcharLineBufSize <= (cch + 1) * sizeof(WCHAR))
        {
            ServerFree (lpszLineWcharBuf);
            dwWcharLineBufSize = (cch + 256) * sizeof(WCHAR);
            if (!(lpszLineWcharBuf = ServerAlloc (dwWcharLineBufSize)))
            {
                lResult = LINEERR_NOMEM;
                goto ExitHere;
            }
        }

        if ((cch = MultiByteToWideChar (
            CP_ACP,
            MB_PRECOMPOSED,
            lpszLineAnsiBuf,
            cb,
            lpszLineWcharBuf,
            dwWcharLineBufSize / sizeof(WCHAR)
            )) == 0)
        {
            lResult = LINEERR_OPERATIONFAILED;
            goto ExitHere;
        }
        ASSERT (cch < dwWcharLineBufSize / sizeof(WCHAR));
        lpszLineWcharBuf[cch] = 0;

        lpwsz = lpszLineWcharBuf;
        //  Skip white space
        while (*lpwsz && ((*lpwsz == L' ') || (*lpwsz == L'\t')))
        {
            ++lpwsz;
        }

        //  Got a bracket, this might be the starting of a new NT
        //  domain user or the section of [TapiAdministators]
        if (*lpwsz == L'[')
        {
            *lpszFriendlyName = 0;  // reset friendly name
            ++lpwsz;
            if (_wcsnicmp (
                lpwsz, 
                gszTapiAdministrators, 
                CCH_TAPIADMINISTRATORS
                ) == 0 &&
                lpwsz[CCH_TAPIADMINISTRATORS] == L']')
            {
                //  Got [TapiAdministrators], not any domain user
                // to process, reset the lpszDomainUser to empty
                *lpszDomainUser = 0;
                continue;
            }
            else
            {
                // might be a valid NT domain user like [ndev\jonsmith]
                // copy the domain user string over
                cch = 0;
                while (*lpwsz && *lpwsz != L']')
                {
                    if (((cch + 1) * sizeof(WCHAR)) >= cbDomainUser)
                    {
                        LPTSTR      lpszNew;

                        if (!(lpszNew = ServerAlloc (cbDomainUser + 128)))
                        {
                            lResult = LINEERR_NOMEM;
                            goto ExitHere;
                        }
                        CopyMemory (lpszNew, lpszDomainUser, cb);
                        ServerFree (lpszDomainUser);
                        lpszDomainUser = lpszNew;
                        cbDomainUser += 128;
                    }
                    lpszDomainUser[cch++] = *lpwsz++;
                }
                lpszDomainUser[cch] = 0;
                if (*lpwsz == 0)
                {
                    //  did not find a closing ']', ignore this section
                    *lpszDomainUser = 0;
                    continue;
                }
            }
        }
        //
        //  Now it might be some ntdev\jonsmith=1 in [TapiAdministrators] or
        //  Lines=1,1000 under section of [ntdev\jonsmith].
        //  for the first case, we just ignore this line, for the second case
        //  we need to have *lpszDomainUser != 0
        //
        else if (*lpszDomainUser)
        {
            if (_wcsnicmp (
                lpwsz, 
                gszFriendlyUserName, 
                CCH_FRIENDLYUSERNAME
                ) == 0)
            {
                // The tsec.ini friendly name is the following format
                // FriendlyName=Jon Smith
                // skip over the '='
                while (*lpwsz && *lpwsz != L'=')
                {
                    ++lpwsz;
                }
                if (*lpwsz == 0)
                {
                    continue;
                }
                else
                {
                    ++lpwsz;
                }
                if (dwFriendlyNameSize < (1 + wcslen (lpwsz)) * sizeof(WCHAR))
                {
                    ServerFree (lpszFriendlyName);
                    dwFriendlyNameSize = (64 + wcslen (lpwsz)) * sizeof(WCHAR);
                    if (!(lpszFriendlyName = ServerAlloc (dwFriendlyNameSize)))
                    {
                        lResult = LINEERR_NOMEM;
                        goto ExitHere;
                    }
                }
                wcscpy (lpszFriendlyName, lpwsz);
                continue;
            }
            else if (_wcsnicmp (
                lpwsz,
                gszLines,
                CCH_LINES
                ) == 0 && bLine ||
                _wcsnicmp (
                lpwsz,
                gszPhones,
                CCH_PHONES
                ) == 0 && (!bLine))
            {
                //  Here it is either Lines=1,100 or Phones=1,100
                DWORD           dwXxxSize, dwDeviceID;
                WCHAR          *pXxxNames, *pNewXxxNames, * p;
                TAPIPERMANENTID tpid;

                //  first skip over the '=' sign
                while (*lpwsz && *lpwsz != L'=')
                {
                    ++lpwsz;
                }
                if (*lpwsz == 0)
                {
                    continue;
                }
                ++lpwsz;

                p = lpwsz;
                while (*p)
                {
                    if ((tpid.dwProviderID = _wtol (p)) == 0)
                    {
                        //
                        // ProviderID's are never 0, so list must be corrupt.
                        //
                        break;
                    }
    
                    for (; ((*p != L'\0')  &&  (*p != L',')); p++);
    
                    if (*p == L'\0')
                    {
                        //
                        // Couldn't find a trailing ',' so list must be corrupt.
                        //
                        break;
                    }

                    p++; // skip the ','

                    tpid.dwDeviceID = _wtol (p);

                    while (*p != L','  &&  *p != L'\0')
                    {
                        p++;
                    }

                    if (*p == L',')
                    {
                        if (*(p + 1) == L'\0')
                        {
                            //
                            // The ',' is followed by a NULL, so nuke the ','
                            //
                            *p = L'\0';
                        }
                        else
                        {
                            p++;
                        }
                    }
    
                    dwDeviceID = GetDeviceIDFromPermanentID (tpid, bLine);

                    if (dwDeviceID == 0xffffffff)
                    {
                        //
                        // This <ppid>,<plid> pair is bad.  Skip it.
                        //
                        continue;
                    }


                    //
                    // At this point dwDeviceID is the zero-based index
                    // of a fully populated info list (no missing entries).
                    //
                    // If the list is not fully-populated (due to failed
                    // dev caps, or removed devices, etc) we need to
                    // recompute the index by walking the list & comparing
                    // permanent XXX id's.
                    //

                    if (dwNumDevices <
                        (bLine ? TapiGlobals.dwNumLines : TapiGlobals.dwNumPhones))
                    {
                        BOOL  bContinue = FALSE;

        
                        for (i = dwDeviceID;; i--)
                        {
                            LPDEVICEINFO    pInfoTmp = ((LPDEVICEINFO) (pList + 1)) +i;


                            if (pInfoTmp->dwPermanentDeviceID == tpid.dwDeviceID  &&
                                pInfoTmp->dwProviderID == tpid.dwProviderID)
                            {
                                dwDeviceID = i;
                                break;
                            }

                            if (i == 0)
                            {
                                bContinue = TRUE;
                                break;
                            }
                        }

                        if (bContinue)
                        {
                            continue;
                        }
                    }


                    //
                    //
                    //
                    dwDomainUserNameSize = (wcslen(lpszDomainUser) + 1) * sizeof(WCHAR);
                    dwXxxSize = pInfo[dwDeviceID].dwDomainUserNamesOffset;
                    pXxxNames = pUserNames[dwDeviceID].pDomainUserNames;

                    if (!(pNewXxxNames = ServerAlloc(
                            dwXxxSize + dwDomainUserNameSize
                            )))
                    {
                        lResult = LINEERR_NOMEM;
                        goto ExitHere;
                    }

                    CopyMemory (pNewXxxNames, lpszDomainUser, dwDomainUserNameSize);

                    if (dwXxxSize)
                    {
                        CopyMemory(
                            ((LPBYTE) pNewXxxNames) + dwDomainUserNameSize,
                            pXxxNames,
                            dwXxxSize
                            );

                        ServerFree (pXxxNames);
                    }

                    pInfo[dwDeviceID].dwDomainUserNamesOffset +=
                        dwDomainUserNameSize;
                    pUserNames[dwDeviceID].pDomainUserNames = pNewXxxNames;


                    //
                    //
                    //

                    //  If there is no friendly name specified in tsec.ini 
                    //  which happens in NT/SP4 upgrade case, we use the 
                    //  DomainUserName for display
                    //
                    if (*lpszFriendlyName == 0)
                    {
                        wcsncpy(lpszFriendlyName, lpszDomainUser, 
                                dwFriendlyNameSize / sizeof(WCHAR));
                        lpszFriendlyName[(dwFriendlyNameSize / sizeof(WCHAR)) - 1] = 0;
                    }
                    dwFriendlyUserNameSize = (wcslen(lpszFriendlyName) + 1) * sizeof(WCHAR);
                    dwXxxSize = pInfo[dwDeviceID].dwFriendlyUserNamesOffset;
                    pXxxNames = pUserNames[dwDeviceID].pFriendlyUserNames;

                    if (!(pNewXxxNames = ServerAlloc(
                            dwXxxSize + dwFriendlyUserNameSize
                            )))
                    {
                        lResult = LINEERR_NOMEM;
                        goto ExitHere;
                    }

                    CopyMemory(
                        pNewXxxNames,
                        lpszFriendlyName,
                        dwFriendlyUserNameSize
                        );

                    if (dwXxxSize)
                    {
                        CopyMemory(
                            ((LPBYTE) pNewXxxNames) + dwFriendlyUserNameSize,
                            pXxxNames,
                            dwXxxSize
                            );

                        ServerFree (pXxxNames);
                    }

                    pInfo[dwDeviceID].dwFriendlyUserNamesOffset +=
                        dwFriendlyUserNameSize;
                    pUserNames[dwDeviceID].pFriendlyUserNames = pNewXxxNames;
                }
            }
        }
    }

    //
    //
    //

    LOG((TL_INFO,
        "GetDeviceInfo: matching users to %ws",
        (bLine ? gszLines : gszPhones)
        ));

    for (i = 0; i < dwNumDevices; i++)
    {
        pInfo = ((LPDEVICEINFO)(pList + 1)) + i;

        if (InsertInfoListString(
                &pList,
                i,
                (DWORD) (((LPBYTE) &pInfo->dwDomainUserNamesSize) -
                    ((LPBYTE) pInfo)),
                pUserNames[i].pDomainUserNames,
                pInfo->dwDomainUserNamesOffset,
                TRUE
                ))
        {
            lResult = LINEERR_NOMEM;
            goto ExitHere;
        }

        pInfo = ((LPDEVICEINFO)(pList + 1)) + i;

        if (InsertInfoListString(
                &pList,
                i,
                (DWORD) (((LPBYTE) &pInfo->dwFriendlyUserNamesSize) -
                    ((LPBYTE) pInfo)),
                pUserNames[i].pFriendlyUserNames,
                pInfo->dwFriendlyUserNamesOffset,
                TRUE
                ))
        {
            lResult = LINEERR_NOMEM;
            goto ExitHere;
        }
    }


    //
    // If here we successfully built the list
    //

    pList->dwNeededSize = pList->dwUsedSize;

    if (bLine)
    {
        gpLineInfoList = pList;
        gpLineDevFlags = lpdwDevFlags;
        gdwNumFlags = dwNumDevices;
    }
    else
    {
        gpPhoneInfoList = pList;
    }

ExitHere:


    if (pUserNames != NULL)
    {
        for (i = 0; i < dwNumDevices; i++)
        {
            ServerFree (pUserNames[i].pDomainUserNames);
            ServerFree (pUserNames[i].pFriendlyUserNames);
        }
    }

    ServerFree (lpszDomainUser);
    ServerFree (lpszLineAnsiBuf);
    ServerFree (lpszLineWcharBuf);
    ServerFree (lpszFriendlyName);
    ServerFree (pUserNames);
    if (lResult)
    {
        ServerFree (pList);
        if (bLine)
        {
            ServerFree (lpdwDevFlags);
            gdwNumFlags = 0;
        }
    }

    if (hFileMap)
    {
        UnmapViewOfFile(lpszFileBuf);
        CloseHandle (hFileMap);
    }
    if (hIniFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle (hIniFile);
    }

    return lResult;
}

void
GetDeviceInfo(
    PMMCGETDEVICEINFO_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned,
    BOOL                        bLine
    )
{
    LONG                lResult = LINEERR_NOMEM;
    LPDEVICEINFOLIST    pXxxList,
                        pInfoListApp;

    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (pParams->dwDeviceInfoListTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        goto ExitHere;
    }


    if (pParams->dwDeviceInfoListTotalSize < sizeof (*pXxxList))
    {
        pParams->lResult = LINEERR_STRUCTURETOOSMALL;
        goto ExitHere;
    }

    //
    // If there's not an existing device info list then & build a
    // new one or
    // if tsec.ini has been updated outsize, rebuild the DeviceInfoList
    //

    pInfoListApp = (LPDEVICEINFOLIST) pDataBuf;

    EnterCriticalSection(&gMgmtCritSec);

    pXxxList = (bLine ? gpLineInfoList : gpPhoneInfoList);

    if (UpdateLastWriteTime(bLine) == S_FALSE || pXxxList == NULL)
    {

        //  First free old infoList if any (if updated outside)
        if (bLine)
        {
            if (gpLineInfoList)
            {
                ServerFree (gpLineInfoList);
                gpLineInfoList = NULL;
                ServerFree (gpLineDevFlags);
                gpLineDevFlags = NULL;
                gdwNumFlags = 0;
            }
        }
        else
        {
            if (gpPhoneInfoList)
            {
                ServerFree (gpPhoneInfoList);
                gpPhoneInfoList = NULL;
            }
        }

        //  Create new info list, BuildDeviceInfoList is a long process
        pParams->lResult = BuildDeviceInfoList(bLine);
        if (pParams->lResult != S_OK)
        {
            LeaveCriticalSection(&gMgmtCritSec);
            goto ExitHere;
        }
    }

    //
    //  Return the device info list we have in memory
    //

    pXxxList = (bLine ? gpLineInfoList : gpPhoneInfoList);
    ASSERT (pXxxList != NULL);
    if (pParams->dwDeviceInfoListTotalSize < pXxxList->dwNeededSize)
    {
        pInfoListApp->dwNeededSize           = pXxxList->dwNeededSize;
        pInfoListApp->dwUsedSize             = sizeof (*pInfoListApp);
        pInfoListApp->dwNumDeviceInfoEntries =
        pInfoListApp->dwDeviceInfoSize       =
        pInfoListApp->dwDeviceInfoOffset     = 0;
    }
    else
    {
        CopyMemory(
            pInfoListApp,
            pXxxList,
            pXxxList->dwNeededSize
            );
    }

    pInfoListApp->dwTotalSize = pParams->dwDeviceInfoListTotalSize;

    pParams->dwDeviceInfoListOffset = 0;

    *pdwNumBytesReturned = sizeof (TAPI32_MSG) + pInfoListApp->dwUsedSize;

    pParams->lResult = 0;

    LeaveCriticalSection(&gMgmtCritSec);

ExitHere:
    return;
}


void
WINAPI
MGetLineInfo(
    PTCLIENT                    ptClient,
    PMMCGETDEVICEINFO_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    GetDeviceInfo(
        pParams,
        dwParamsBufferSize,
        pDataBuf,
        pdwNumBytesReturned,
        TRUE
        );
}


void
WINAPI
MGetPhoneInfo(
    PTCLIENT                    ptClient,
    PMMCGETDEVICEINFO_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    GetDeviceInfo(
        pParams,
        dwParamsBufferSize,
        pDataBuf,
        pdwNumBytesReturned,
        FALSE
        );
}


void
SetDeviceInfo(
    PMMCSETDEVICEINFO_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned,
    BOOL                        bLine
    )
{
    DWORD              i;
    WCHAR              *pDomainUserName, *pDomainUserNames,
                       *pFriendlyUserName, *pFriendlyUserNames;
    LPDEVICEINFO       pOldInfo, pNewInfo;
    LPDEVICEINFOLIST   pNewInfoList = (LPDEVICEINFOLIST) (pDataBuf +
                           pParams->dwDeviceInfoListOffset),
                       *ppXxxList = (bLine ?
                           &gpLineInfoList : &gpPhoneInfoList);


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (IsBadStructParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwDeviceInfoListOffset
            ))
    {
        pParams->lResult = PHONEERR_OPERATIONFAILED;
        return;
    }


    //
    // Serialize access to global line info list
    //

    if (!(*ppXxxList))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        goto exit;
    }


    //
    // Update the global list & ini file by diff'ing old & new settings
    //

    pNewInfo = (LPDEVICEINFO)
        (((LPBYTE) pNewInfoList) + pNewInfoList->dwDeviceInfoOffset);

    for (i = 0; i < pNewInfoList->dwNumDeviceInfoEntries; i++, pNewInfo++)
    {
        DWORD           dwDeviceID;
        DWORD           dwIndex;
        TAPIPERMANENTID tpid;


        tpid.dwProviderID = pNewInfo->dwProviderID;
        tpid.dwDeviceID   = pNewInfo->dwPermanentDeviceID;

        dwDeviceID = GetDeviceIDFromPermanentID (tpid, bLine);

        if (dwDeviceID == 0xffffffff)
        {
            LOG((TL_ERROR,
                "SetDeviceInfo: bad provider/device IDs (x%x/x%x)",
                pNewInfo->dwProviderID,
                pNewInfo->dwPermanentDeviceID
                ));

            continue;
        }

        pOldInfo = dwDeviceID + ((LPDEVICEINFO) (*ppXxxList + 1));

        //
        //  Due to device removal, it is possible pOldInfo is not the entry
        //  desired, we need to search back to find the one we want
        //
        dwIndex = dwDeviceID;
        if ((dwDeviceID >= (*ppXxxList)->dwNumDeviceInfoEntries) ||
            (pOldInfo->dwProviderID != tpid.dwProviderID) ||
            (pOldInfo->dwPermanentDeviceID != tpid.dwDeviceID))
        {
            LPDEVICEINFO    pInfoFirst = (LPDEVICEINFO)(*ppXxxList + 1);
            DWORD dwLastSchDevice = 
                    ((*ppXxxList)->dwNumDeviceInfoEntries <= dwDeviceID)?
                        ((*ppXxxList)->dwNumDeviceInfoEntries - 1) : 
                        (dwDeviceID - 1);
            LPDEVICEINFO    pInfo = pInfoFirst + dwLastSchDevice;
            
            while (pInfo >= pInfoFirst && 
                    ((pInfo->dwProviderID != tpid.dwProviderID) ||
                     (pInfo->dwPermanentDeviceID != tpid.dwDeviceID)))
            {
                --pInfo;
            }
            if (pInfo < pInfoFirst)
            {
                LOG((TL_ERROR,
                    "SetDeviceInfo: bad provider/device IDs (x%x/x%x)",
                    pNewInfo->dwProviderID,
                    pNewInfo->dwPermanentDeviceID
                    ));

                continue;
            }
            pOldInfo = pInfo;
            dwIndex = (DWORD)(ULONG_PTR)(pInfo - pInfoFirst);
        }


        //
        // Remove all the old users from this device
        //

        if (pOldInfo->dwDomainUserNamesSize)
        {
            pDomainUserName = (WCHAR *) (((LPBYTE) *ppXxxList) +
                pOldInfo->dwDomainUserNamesOffset);

            while (*pDomainUserName != L'\0')
            {
                ChangeDeviceUserAssociation(
                    pDomainUserName,
                    NULL,
                    pOldInfo->dwProviderID,
                    pOldInfo->dwPermanentDeviceID,
                    bLine
                    );

                pDomainUserName += wcslen (pDomainUserName) + 1;
            }

            pOldInfo->dwDomainUserNamesSize = 0;
            pOldInfo->dwFriendlyUserNamesSize = 0;
        }


        //
        // Add all the new users to this device
        //

        if (pNewInfo->dwDomainUserNamesSize)
        {
            pDomainUserName =
            pDomainUserNames = (WCHAR *) (((LPBYTE) pNewInfoList) +
                pNewInfo->dwDomainUserNamesOffset);

            pFriendlyUserName =
            pFriendlyUserNames = (WCHAR *) (((LPBYTE) pNewInfoList) +
                pNewInfo->dwFriendlyUserNamesOffset);

            while (*pDomainUserName != L'\0')
            {
                ChangeDeviceUserAssociation(
                    pDomainUserName,
                    pFriendlyUserName,
                    pOldInfo->dwProviderID,
                    pOldInfo->dwPermanentDeviceID,
                    bLine
                    );

                pDomainUserName += wcslen (pDomainUserName) + 1;
                pFriendlyUserName += wcslen (pFriendlyUserName) + 1;
            }

            if (InsertInfoListString(
                    ppXxxList,
                    dwIndex,
                    (DWORD) (((LPBYTE) &pNewInfo->dwDomainUserNamesSize) -
                        ((LPBYTE) pNewInfo)),
                    pDomainUserNames,
                    pNewInfo->dwDomainUserNamesSize,
                    FALSE
                    ))
            {
            }

            if (InsertInfoListString(
                    ppXxxList,
                    dwIndex,
                    (DWORD) (((LPBYTE) &pNewInfo->dwFriendlyUserNamesSize) -
                        ((LPBYTE) pNewInfo)),
                    pFriendlyUserNames,
                    pNewInfo->dwFriendlyUserNamesSize,
                    FALSE
                    ))
            {
            }
        }

        //
        //  Update the device access(phone/line mapping) for the client users
        //  send LINE/PHONE_REMOVE if the domain/user lose the access
        //  send LINE/PHONE_CREATE if the domain/user gained the access
        //
        {
            TPOINTERLIST    clientList = {0}, *pClientList = &clientList;
            DWORD           i, j;

            //
            //  Walk throught the client list
            //
            GetClientList (FALSE, &pClientList);
            for (i = 0; i < pClientList->dwNumUsedEntries; i++)
            {
                PTCLIENT        ptClient;
                BOOL            bHaveAccess = FALSE;
                BOOL            bGainAccess = FALSE;
                BOOL            bLoseAccess = FALSE;
                BOOL            bSendMessage = FALSE;
                WCHAR *         pwsz = NULL;
                WCHAR           wszBuf[255];
                DWORD           dw, dwNewDeviceID;

                ptClient = (PTCLIENT) pClientList->aEntries[i];

                //
                //  Should this client have access to this device?
                //
                if (WaitForExclusiveClientAccess(ptClient))
                {
                    if (IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR) ||
                        ptClient->pszDomainName == NULL ||
                        ptClient->pszUserName == NULL)
                    {
                        UNLOCKTCLIENT (ptClient);
                        continue;
                    }
                    
                    dw = wcslen (ptClient->pszDomainName) +
                        wcslen (ptClient->pszUserName) + 2;
                    dw *= sizeof(WCHAR);
                    if (dw > sizeof (wszBuf))
                    {
                        pwsz = ServerAlloc (dw);
                        if (pwsz == NULL)
                        {
                            UNLOCKTCLIENT (ptClient);
                            continue;
                        }
                    }
                    else
                    {
                        pwsz = wszBuf;
                    }
                    wcscpy (pwsz, ptClient->pszDomainName);
                    wcscat (pwsz, L"\\");
                    wcscat (pwsz, ptClient->pszUserName);
                    UNLOCKTCLIENT (ptClient);
                }
                else
                {
                    continue;
                }
                
                pDomainUserName = (WCHAR *) (((LPBYTE) pNewInfoList) +
                    pNewInfo->dwDomainUserNamesOffset);
                while (*pDomainUserName != L'\0')
                {
                    if (lstrcmpiW (pwsz, pDomainUserName) == 0)
                    {
                        bHaveAccess = TRUE;
                        break;
                    }
                    pDomainUserName += wcslen (pDomainUserName) + 1;
                }
                if (pwsz != wszBuf)
                {
                    ServerFree (pwsz);
                }

                //
                //  Does the client lose/gain the access to this device
                //  if any changes happen, modify the mapping
                //
                if (WaitForExclusiveClientAccess(ptClient))
                {
                    LPDWORD             lpXxxDevices;
                    LPTAPIPERMANENTID   lpXxxMap;
                    DWORD               dwNumDev;

                    if (bLine)
                    {
                        dwNumDev = ptClient->dwLineDevices;
                        lpXxxMap = ptClient->pLineMap;
                        lpXxxDevices = ptClient->pLineDevices;
                    }
                    else
                    {
                        dwNumDev = ptClient->dwPhoneDevices;
                        lpXxxMap = ptClient->pPhoneMap;
                        lpXxxDevices = ptClient->pPhoneDevices;
                    }

                    for (j = 0; j < dwNumDev; ++ j)
                    {
                        if (lpXxxDevices[j] == dwDeviceID)
                        {
                            bLoseAccess = (!bHaveAccess);
                            break;
                        }
                    }
                    if (j == dwNumDev)
                    {
                        bGainAccess = bHaveAccess;
                    }

                    if (bLoseAccess)
                    {
                        lpXxxDevices[j] = 0xffffffff;
                        lpXxxMap[j].dwDeviceID = 0xffffff;
                        dwNewDeviceID = j;
                    }

                    if (bGainAccess)
                    {
                        LPTAPIPERMANENTID   lpNewXxxMap;
                        LPDWORD             lpNewDevices = NULL;

                        if (lpNewXxxMap = ServerAlloc (
                            sizeof(TAPIPERMANENTID) * (dwNumDev + 1)))
                        {
                            if (lpNewDevices = ServerAlloc (
                                sizeof(DWORD) * (dwNumDev + 1)))
                            {
                                if (dwNumDev != 0)
                                {
                                    memcpy (
                                        lpNewXxxMap,
                                        lpXxxMap,
                                        sizeof (TAPIPERMANENTID) * dwNumDev
                                        );
                                    memcpy (
                                        lpNewDevices,
                                        lpXxxDevices,
                                        sizeof (DWORD) * dwNumDev
                                        );
                                }
                                lpNewDevices[dwNumDev] = dwDeviceID;
                                lpNewXxxMap[dwNumDev] = tpid;
                                ++ dwNumDev;
                            }
                            else
                            {
                                ServerFree (lpNewXxxMap);
                                UNLOCKTCLIENT (ptClient);
                                continue;
                            }
                        }
                        else
                        {
                            UNLOCKTCLIENT(ptClient);
                            continue;
                        }
                        if (bLine)
                        {
                            ptClient->dwLineDevices = dwNumDev;
                            ServerFree (ptClient->pLineDevices);
                            ptClient->pLineDevices = lpNewDevices;
                            ServerFree (ptClient->pLineMap);
                            ptClient->pLineMap = lpNewXxxMap;
                        }
                        else
                        {
                            ptClient->dwPhoneDevices = dwNumDev;
                            ServerFree (ptClient->pPhoneDevices);
                            ptClient->pPhoneDevices = lpNewDevices;
                            ServerFree (ptClient->pPhoneMap);
                            ptClient->pPhoneMap = lpNewXxxMap;
                        }

                        dwNewDeviceID = dwNumDev - 1;
                    }
                    
                    //
                    //  Need to send messsage if there is 
                    //  any line/phoneInitialize(Ex)
                    //
                    if ((ptClient->ptLineApps && bLine) || 
                        (ptClient->ptPhoneApps && (!bLine)))
                    {
                        if (bLoseAccess || bGainAccess)
                        {
                            bSendMessage = TRUE;
                        }
                    }
                    
                    UNLOCKTCLIENT (ptClient);
                }
                else
                {
                    continue;
                }
                
                if (bSendMessage)
                {
                    ASYNCEVENTMSG   msg;
                    TPOINTERLIST    xxxAppList = {0}, 
                        *pXxxAppList = &xxxAppList;

                    msg.TotalSize          = sizeof (ASYNCEVENTMSG);
                    msg.fnPostProcessProcHandle = 0;
                    msg.Msg                = (bLine ? 
                        (bLoseAccess? LINE_REMOVE : LINE_CREATE) :
                        (bLoseAccess? PHONE_REMOVE: PHONE_CREATE));
                    msg.Param1             = dwNewDeviceID;

                    if (bLine)
                    {
                        GetLineAppListFromClient (ptClient, &pXxxAppList);
                    }
                    else
                    {
                        GetPhoneAppListFromClient (ptClient, &pXxxAppList);
                    }

                    for (i = 0; i < pXxxAppList->dwNumUsedEntries; ++i)
                    {
                        BOOL    b;

                        try
                        {
                            if (bLine)
                            {
                                PTLINEAPP ptLineApp = 
                                    (PTLINEAPP) pXxxAppList->aEntries[i];

                                b = FMsgDisabled (
                                    ptLineApp->dwAPIVersion,
                                    ptLineApp->adwEventSubMasks,
                                    (DWORD) msg.Msg,
                                    (DWORD) msg.Param1
                                    );
                                msg.InitContext = ptLineApp->InitContext;
                            }
                            else
                            {
                                PTPHONEAPP ptPhoneApp = 
                                    (PTPHONEAPP) pXxxAppList->aEntries[i];

                                b = FMsgDisabled (
                                    ptPhoneApp->dwAPIVersion,
                                    ptPhoneApp->adwEventSubMasks,
                                    (DWORD) msg.Msg,
                                    (DWORD) msg.Param1
                                    );
                                msg.InitContext = ptPhoneApp->InitContext;
                            }
                        }
                        myexcept
                        {
                            continue;
                        }
                        if (b)
                        {
                            continue;
                        }
                        
                        WriteEventBuffer (ptClient, &msg);
                    }

                    if (pXxxAppList != &xxxAppList)
                    {
                        ServerFree (pXxxAppList);
                    }
                }
                
                //
                //  If the user loses the device access, anything
                //  opened about the device needs to be closed
                //
                if (bLoseAccess)
                {
                    //
                    //  Walk throught all its TLINEAPP
                    //
                    if (bLine)
                    {
                        PTLINELOOKUPENTRY   ptLineLookup;
                        PTLINE              ptLine;
                        PTLINECLIENT        ptLineClient, pNextLineClient;
                        HANDLE              hMutex;
                        BOOL                bDupedMutex;
                        
                        ptLineLookup = GetLineLookupEntry(dwDeviceID);
                        if (!ptLineLookup || !(ptLine = ptLineLookup->ptLine));
                        {
                            continue;
                        }
                        if (!WaitForExclusivetLineAccess(
                            ptLine, 
                            &hMutex, 
                            &bDupedMutex,
                            INFINITE
                            ))
                        {
                            continue;
                        }
                        ptLineClient = ptLine->ptLineClients;
                        while (ptLineClient)
                        {
                            if (WaitForExclusiveLineClientAccess(ptLineClient))
                            {
                                pNextLineClient = ptLineClient->pNextSametLine;
                                
                                if (ptLineClient->ptClient == ptClient)
                                {
                                    HLINE       hLine = ptLineClient->hLine;
                                    UNLOCKTLINECLIENT (ptLineClient);
                                    DestroytLineClient(ptLineClient->hLine);
                                }
                                else
                                {
                                    UNLOCKTLINECLIENT (ptLineClient);
                                }

                                ptLineClient = pNextLineClient;
                            }
                            else
                            {
                                break;
                            }
                        }
                        MyReleaseMutex(hMutex, bDupedMutex);
                    }

                    //
                    //  Walk throught all its TPHONEAPP
                    //
                    else
                    {
                        PTPHONELOOKUPENTRY   ptPhoneLookup;
                        PTPHONE              ptPhone;
                        PTPHONECLIENT        ptPhoneClient, pNextPhoneClient;
                        HANDLE               hMutex;
                        BOOL                 bDupedMutex;
                        
                        ptPhoneLookup = GetPhoneLookupEntry(dwDeviceID);
                        if (!ptPhoneLookup || !(ptPhone = ptPhoneLookup->ptPhone));
                        {
                            continue;
                        }
                        if (!WaitForExclusivetPhoneAccess(
                            ptPhone,
                            &hMutex,
                            &bDupedMutex,
                            INFINITE
                            ))
                        {
                            continue;
                        }
                        ptPhoneClient = ptPhone->ptPhoneClients;
                        while (ptPhoneClient)
                        {
                            if (WaitForExclusivePhoneClientAccess(ptPhoneClient))
                            {
                                pNextPhoneClient = ptPhoneClient->pNextSametPhone;
                                
                                if (ptPhoneClient->ptClient == ptClient)
                                {
                                    HPHONE       hPhone = ptPhoneClient->hPhone;
                                    UNLOCKTPHONECLIENT (ptPhoneClient);
                                    DestroytPhoneClient(ptPhoneClient->hPhone);
                                }
                                else
                                {
                                    UNLOCKTPHONECLIENT (ptPhoneClient);
                                }

                                ptPhoneClient = pNextPhoneClient;
                            }
                            else
                            {
                                break;
                            }
                        }
                        MyReleaseMutex (hMutex, bDupedMutex);
                    }
                }
            }
            
            if (pClientList != &clientList)
            {
                ServerFree (pClientList);
            }
        }
    }


    //
    // Reset the dwNeededSize field since it might have grown adding
    // users to devices
    //

    (*ppXxxList)->dwNeededSize = (*ppXxxList)->dwUsedSize;


exit:

    return;
}


void
WINAPI
MSetLineInfo(
    PTCLIENT                    ptClient,
    PMMCSETDEVICEINFO_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL            bDidLock;

    if (WaitForExclusiveClientAccess(ptClient))
    {
        bDidLock = 
            IS_FLAG_SET (ptClient->dwFlags, PTCLIENT_FLAG_LOCKEDMMCWRITE);
        UNLOCKTCLIENT (ptClient);
    }
    else
    {
        bDidLock = FALSE;
    }

    EnterCriticalSection (&gMgmtCritSec);

    if (gbLockMMCWrite && !bDidLock)
    {
        pParams->lResult = TAPIERR_MMCWRITELOCKED;
    }
    else
    {
        SetDeviceInfo(
            pParams,
            dwParamsBufferSize,
            pDataBuf,
            pdwNumBytesReturned,
            TRUE
            );
        UpdateLastWriteTime(TRUE);
    }

    LeaveCriticalSection (&gMgmtCritSec);

}


void
WINAPI
MSetPhoneInfo(
    PTCLIENT                    ptClient,
    PMMCSETDEVICEINFO_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL            bDidLock;

    if (WaitForExclusiveClientAccess(ptClient))
    {
        bDidLock = 
            IS_FLAG_SET (ptClient->dwFlags, PTCLIENT_FLAG_LOCKEDMMCWRITE);
        UNLOCKTCLIENT (ptClient);
    }
    else
    {
        bDidLock = FALSE;
    }

    EnterCriticalSection (&gMgmtCritSec);

    if (gbLockMMCWrite && !bDidLock)
    {
        pParams->lResult = TAPIERR_MMCWRITELOCKED;
    }
    else
    {
        SetDeviceInfo(
            pParams,
            dwParamsBufferSize,
            pDataBuf,
            pdwNumBytesReturned,
            FALSE
            );
        UpdateLastWriteTime(FALSE);
    }

    LeaveCriticalSection (&gMgmtCritSec);
}


VOID
PASCAL
InsertString(
    LPVOID      pStruct,
    LPDWORD     pdwXxxSize,
    LPWSTR      pString
    )
{
    DWORD   dwSize = (wcslen (pString) + 1) * sizeof (WCHAR);


    CopyMemory(
        ((LPBYTE) pStruct) + ((LPVARSTRING) pStruct)->dwUsedSize,
        pString,
        dwSize
        );

    if (*pdwXxxSize == 0) // if dwXxxSize == 0 set dwXxxOffset
    {
        *(pdwXxxSize + 1) = ((LPVARSTRING) pStruct)->dwUsedSize;
    }

    ((LPVARSTRING) pStruct)->dwUsedSize += dwSize;

    *pdwXxxSize += dwSize;
}


LONG
PASCAL
GetDomainAndUserNames(
    WCHAR **ppDomainName,
    WCHAR **ppUserName
    )
{
    LONG            lResult = LINEERR_OPERATIONFAILED;
    DWORD           dwInfoBufferSize, dwSize, dwAccountNameSize,
                        dwDomainNameSize;
    HANDLE          hAccessToken;
    LPWSTR          InfoBuffer, lpszAccountName, lpszDomainName;
    PTOKEN_USER     ptuUser;
    SID_NAME_USE    use;


    if (!OpenProcessToken (GetCurrentProcess(), TOKEN_READ, &hAccessToken))
    {
        LOG((TL_ERROR,
            "GetAccountInfo: OpenThreadToken failed, error=%d",
            GetLastError()
            ));

        goto GetDomainAndUserNames_return;
    }

    dwSize = 1000;
    dwInfoBufferSize = 0;
    InfoBuffer = (LPWSTR) ServerAlloc (dwSize);
    if (!InfoBuffer)
    {
        CloseHandle (hAccessToken);
        return LINEERR_NOMEM;
    }

    ptuUser = (PTOKEN_USER) InfoBuffer;

    if (!GetTokenInformation(
            hAccessToken,
            TokenUser,
            InfoBuffer,
            dwSize,
            &dwInfoBufferSize
            ))
    {
        LOG((TL_ERROR,
            "GetAccountInfo: GetTokenInformation failed, error=%d",
            GetLastError()
            ));

        goto close_AccessToken;
    }

    if (!(lpszAccountName = ServerAlloc (200)))
    {
        lResult = LINEERR_NOMEM;
        goto free_InfoBuffer;
    }

    if (!(lpszDomainName = ServerAlloc (200)))
    {
        lResult = LINEERR_NOMEM;
        goto free_AccountName;
    }

    dwAccountNameSize = dwDomainNameSize = 200;

    if (!LookupAccountSidW(
            NULL,
            ptuUser->User.Sid,
            lpszAccountName,
            &dwAccountNameSize,
            lpszDomainName,
            &dwDomainNameSize,
            &use
            ))
    {
        LOG((TL_ERROR,
            "GetAccountInfo: LookupAccountSidW failed, error=%d",
            GetLastError()
            ));
    }
    else
    {
        LOG((TL_INFO,
            "GetAccountInfo: User name %ls Domain name %ls",
            lpszAccountName,
            lpszDomainName
            ));

        lResult = 0;

        *ppDomainName = lpszDomainName;
        *ppUserName = lpszAccountName;

        goto free_InfoBuffer;
    }

    ServerFree (lpszDomainName);

free_AccountName:

    ServerFree (lpszAccountName);

free_InfoBuffer:

    ServerFree (InfoBuffer);

close_AccessToken:

    CloseHandle (hAccessToken);

GetDomainAndUserNames_return:

    return lResult;
}


BOOL
IsNTServer(
    void
    )
{
    BOOL    bResult = FALSE;
    TCHAR   szProductType[64];
    HKEY    hKey;
    DWORD   dwDataSize;
    DWORD   dwDataType;


    if (RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            gszRegKeyNTServer,
            0,
            KEY_QUERY_VALUE,
            &hKey

            ) == ERROR_SUCCESS)
    {
        dwDataSize = 64*sizeof(TCHAR);

        if (RegQueryValueEx(
                hKey,
                gszProductType,
                0,
                &dwDataType,
                (LPBYTE) szProductType,
                &dwDataSize

                )  == ERROR_SUCCESS)


        if ((!lstrcmpi (szProductType, gszProductTypeServer))  ||
            (!lstrcmpi (szProductType, gszProductTypeLanmanNt)))
        {
            bResult = TRUE;
        }

        RegCloseKey (hKey);
    }

    return bResult;
}


BOOL
IsSharingEnabled(
    void
    )
{
    HKEY    hKey;
    BOOL    bResult = FALSE;
    DWORD   dwType, dwDisableSharing;


    if (RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Server"),
            0,
            KEY_ALL_ACCESS,
            &hKey

            ) == ERROR_SUCCESS)
    {
        DWORD   dwSize = sizeof (dwDisableSharing);


        dwDisableSharing = 1;   // default is sharing == disabled

        if (RegQueryValueEx(
                hKey,
                TEXT("DisableSharing"),
                0,
                &dwType,
                (LPBYTE) &dwDisableSharing,
                &dwSize

                ) == ERROR_SUCCESS)
        {
            bResult = (dwDisableSharing ? FALSE : TRUE);
        }

        RegCloseKey (hKey);
    }

    return bResult;
}


void
WINAPI
MGetServerConfig(
    PTCLIENT                    ptClient,
    PMMCGETSERVERCONFIG_PARAMS  pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    LONG                lResult;
    DWORD               dwDomainNameSize, dwUserNameSize, dwValuesSize,
                        dwResult, dwNeededSize;
    WCHAR              *pValues = NULL, *pValue;
    LPWSTR              pDomainName, pUserName;
    LPTAPISERVERCONFIG  pServerConfig = (LPTAPISERVERCONFIG) pDataBuf;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (pParams->dwServerConfigTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    //
    // Make sure the buffer is >= fixed size of the structure
    //

    if (pParams->dwServerConfigTotalSize < sizeof (*pServerConfig))
    {
        pParams->lResult = LINEERR_STRUCTURETOOSMALL;
        return;
    }

    pServerConfig->dwTotalSize = pParams->dwServerConfigTotalSize;


    //
    // If this is not an NT server then just set the needed/used size
    // fields & jump to done
    //

    if (!IsNTServer())
    {
        pServerConfig->dwNeededSize =
        pServerConfig->dwUsedSize   = sizeof (*pServerConfig);

        goto MGetServerConfig_done;
    }


    //
    // Retrieve domain & user name strings, & calc their length in bytes
    //

    if ((lResult = GetDomainAndUserNames (&pDomainName, &pUserName)))
    {
        pParams->lResult = lResult;
        return;
    }

    dwDomainNameSize = (wcslen (pDomainName) + 1) * sizeof (WCHAR);
    dwUserNameSize = (wcslen (pUserName) + 1) * sizeof (WCHAR);


    //
    // Retrieve the list of tapi administrators
    //

    do
    {
        if  (pValues)
        {
            ServerFree (pValues);

            dwValuesSize *= 2;
        }
        else
        {
            dwValuesSize = 256;
        }

        if (!(pValues = ServerAlloc (dwValuesSize * sizeof (WCHAR))))
        {
            pParams->lResult = LINEERR_NOMEM;
            goto MGetServerConfig_freeNames;
        }

        pValues[0] = L'\0';

        dwResult = GetPrivateProfileSectionW(
            gszTapiAdministrators,
            pValues,
            dwValuesSize,
            gszFileName
            );

    } while (dwResult >= (dwValuesSize - 2));

    dwNeededSize = dwDomainNameSize + dwUserNameSize + dwValuesSize;


    //
    // Fill in the server config structure
    //

    ZeroMemory(
        &pServerConfig->dwFlags,
        sizeof (*pServerConfig) - (3 * sizeof (DWORD))
        );

    pServerConfig->dwFlags |= TAPISERVERCONFIGFLAGS_ISSERVER;

    if (IsSharingEnabled())
    {
        pServerConfig->dwFlags |= TAPISERVERCONFIGFLAGS_ENABLESERVER;
    }

    if (pServerConfig->dwTotalSize < dwNeededSize)
    {
        pServerConfig->dwNeededSize = dwNeededSize;
        pServerConfig->dwUsedSize   = sizeof (*pServerConfig);
    }
    else
    {
        pServerConfig->dwUsedSize = sizeof (*pServerConfig);

        InsertString(
            pServerConfig,
            &pServerConfig->dwDomainNameSize,
            pDomainName
            );

        InsertString(
            pServerConfig,
            &pServerConfig->dwUserNameSize,
            pUserName
            );

        pValue = pValues;

        while (*pValue != L'\0')
        {
            //
            // The string looks like "Domain\User=1", and we want
            // the "Domain\User" part.
            //

            //
            // Walk the string until we find a '=' char, or ' ' space
            // (which might result from user editing ini file manually),
            // or a NULL char (implying corruption).
            //

            WCHAR *p;


            for (p = pValue; *p != L'\0' &&  *p != L'='  &&  *p != L' '; p++);


            //
            // If we found a '=' or ' ' char then we're good to go.
            //
            // A more robust check would be to see that the following
            // string looks like "=1" or "1" (possibly with some spaces
            // thrown in) to make sure.
            //

            if (*p != L'\0')
            {
                *p = L'\0';

                InsertString(
                    pServerConfig,
                    &pServerConfig->dwAdministratorsSize,
                    pValue
                    );

                //
                // Skip the NULL we set above & look for the next NULL
                //

                for (++p; *p != L'\0'; p++);
            }


            //
            // Skip the NULL
            //

            pValue = p + 1;
        }

        if (pServerConfig->dwAdministratorsSize)
        {
            InsertString(
                pServerConfig,
                &pServerConfig->dwAdministratorsSize,
                gszEmptyString
                );
        }

        pServerConfig->dwNeededSize = pServerConfig->dwUsedSize;
    }

    ServerFree (pValues);

MGetServerConfig_freeNames:

    ServerFree (pDomainName);
    ServerFree (pUserName);

MGetServerConfig_done:

    if (pParams->lResult == 0)
    {
        pParams->dwServerConfigOffset = 0;

        *pdwNumBytesReturned = sizeof (TAPI32_MSG) +
            pServerConfig->dwUsedSize;
    }
}


LONG
PASCAL
WriteRegistryKeys(
    LPTSTR  lpszMapper,
    LPTSTR  lpszDlls,
    DWORD   dwDisableSharing
    )
{
    LONG    lResult = LINEERR_OPERATIONFAILED;
    HKEY    hKeyTelephony, hKey;
    DWORD   dw;


    if (RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Telephony"),
            0,
            KEY_ALL_ACCESS,
            &hKeyTelephony

            ) == ERROR_SUCCESS)
    {
        if (RegCreateKeyEx(
                hKeyTelephony,
                TEXT("Server"),
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS,
                NULL,
                &hKey,
                &dw

                ) == ERROR_SUCCESS)
        {
            if (RegSetValueEx(
                    hKey,
                    TEXT("DisableSharing"),
                    0,
                    REG_DWORD,
                    (LPBYTE) &dwDisableSharing,
                    sizeof (dwDisableSharing)

                    ) == ERROR_SUCCESS  &&

                RegSetValueEx(
                    hKey,
                    TEXT("MapperDll"),
                    0,
                    REG_SZ,
                    (LPBYTE) TEXT ("TSEC.DLL"),
                    (lstrlen (TEXT ("TSEC.DLL")) + 1) * sizeof (TCHAR)

                    ) == ERROR_SUCCESS)
            {
                lResult = 0;
            }

            RegCloseKey (hKeyTelephony);
        }

        RegCloseKey (hKey);
    }

    return lResult;
}


LONG
PASCAL
WriteServiceConfig(
    LPWSTR  pDomainName,
    LPWSTR  pUserName,
    LPWSTR  pPassword,
    BOOL    bServer
    )
{
    LONG       lResult = LINEERR_OPERATIONFAILED;
    SC_HANDLE  sch, sc_tapisrv;


    if ((sch = OpenSCManager (NULL, NULL, SC_MANAGER_ENUMERATE_SERVICE)))
    {
        if ((sc_tapisrv = OpenService(
                sch,
                TEXT("TAPISRV"),
                SERVICE_CHANGE_CONFIG
                )))
        {
            DWORD   dwSize;
            WCHAR  *pDomainUserName;


            dwSize = (wcslen (pDomainName) + wcslen (pUserName) + 2) *\
                sizeof (WCHAR);

            if ((pDomainUserName = ServerAlloc (dwSize)))
            {
                wcscpy (pDomainUserName, pDomainName);
                wcscat (pDomainUserName, L"\\");
                wcscat (pDomainUserName, pUserName);

                if ((ChangeServiceConfigW(
                        sc_tapisrv,
                        SERVICE_WIN32_OWN_PROCESS,
                        bServer ? SERVICE_AUTO_START : SERVICE_DEMAND_START,
                        SERVICE_NO_CHANGE,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        pDomainUserName,
                        pPassword,
                        NULL
                        )))
                {
                    lResult = 0;
                }
                else
                {
                    LOG((TL_ERROR,
                        "WriteServiceConfig: ChangeServiceConfig " \
                            "failed, err=%ld",
                        GetLastError()
                        ));
                }

                ServerFree (pDomainUserName);
            }
            else
            {
                lResult = LINEERR_NOMEM;
            }

            CloseServiceHandle(sc_tapisrv);
        }

        CloseServiceHandle(sch);
    }

    return lResult;
}


void
WINAPI
MSetServerConfig(
    PTCLIENT                    ptClient,
    PMMCSETSERVERCONFIG_PARAMS  pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    LONG                lResult;
    BOOL                bIsSharingEnabled;
    LPTAPISERVERCONFIG  pServerConfig = (LPTAPISERVERCONFIG)
                            (pDataBuf + pParams->dwServerConfigOffset);

    pParams->lResult = 0;

    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (IsBadStructParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwServerConfigOffset
            ))
    {
        pParams->lResult = PHONEERR_OPERATIONFAILED;
        return;
    }


    if (!IsNTServer())
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }

    bIsSharingEnabled = IsSharingEnabled();

    if (pServerConfig->dwFlags & TAPISERVERCONFIGFLAGS_LOCKMMCWRITE)
    {
        EnterCriticalSection (&gMgmtCritSec);
        if (gbLockMMCWrite)
        {
            pParams->lResult = TAPIERR_MMCWRITELOCKED;
        }
        else
        {
            gbLockMMCWrite = TRUE;
        }
        LeaveCriticalSection (&gMgmtCritSec);
        if (pParams->lResult)
        {
            return;
        }
        else if (WaitForExclusiveClientAccess (ptClient))
        {
            SET_FLAG (ptClient->dwFlags, PTCLIENT_FLAG_LOCKEDMMCWRITE);
            UNLOCKTCLIENT (ptClient);
        }
    }

    if (pServerConfig->dwFlags & TAPISERVERCONFIGFLAGS_UNLOCKMMCWRITE &&
        WaitForExclusiveClientAccess (ptClient))
    {   
        BOOL        bToUnlock;

        bToUnlock = 
            IS_FLAG_SET (ptClient->dwFlags, PTCLIENT_FLAG_LOCKEDMMCWRITE);
        RESET_FLAG (ptClient->dwFlags, PTCLIENT_FLAG_LOCKEDMMCWRITE);
        UNLOCKTCLIENT (ptClient);

        if (bToUnlock)
        {
            EnterCriticalSection (&gMgmtCritSec);
            gbLockMMCWrite = FALSE;
            LeaveCriticalSection (&gMgmtCritSec);
        }
    }

    if (pServerConfig->dwFlags & TAPISERVERCONFIGFLAGS_SETACCOUNT)
    {
        HANDLE  hToken;
        LPWSTR  pUserName, pDomainName, pPassword;


        pUserName = (LPWSTR)
            (((LPBYTE) pServerConfig) + pServerConfig->dwUserNameOffset);

        pDomainName = (LPWSTR)
            (((LPBYTE) pServerConfig) + pServerConfig->dwDomainNameOffset);

        pPassword = (LPWSTR)
            (((LPBYTE) pServerConfig) + pServerConfig->dwPasswordOffset);


        //
        // Make sure the new name/domain/password are valid
        //

        if (!LogonUserW(
                pUserName,
                pDomainName,
                pPassword,
                LOGON32_LOGON_NETWORK,
                LOGON32_PROVIDER_DEFAULT,
                &hToken
                ))
        {
            LOG((TL_ERROR,
                "MSetServerConfig: LogonUser failed, err=%ld",
                GetLastError()
                ));

            pParams->lResult = ERROR_LOGON_FAILURE;
            return;
        }

        CloseHandle (hToken);


        //
        //
        //

        if ((lResult = WriteServiceConfig(
                pDomainName,
                pUserName,
                pPassword,
                (pServerConfig->dwFlags & TAPISERVERCONFIGFLAGS_ENABLESERVER)
                )))
        {
            LOG((TL_ERROR,
                "MSetServerConfig: WriteServiceConfig failed, err=%ld",
                lResult
                ));

            pParams->lResult = lResult;
            return;
        }
    }

    if (pServerConfig->dwFlags & TAPISERVERCONFIGFLAGS_ENABLESERVER &&
        !bIsSharingEnabled)
    {
        if ((pParams->lResult = CreateTapiSCP (NULL, NULL)) != 0)
        {
            LOG((TL_ERROR,
                "MSetServerConfig: CreateTapiSCP failed, err=%ld",
                pParams->lResult
                ));
            return;
        }
    }
    else if (!(pServerConfig->dwFlags & TAPISERVERCONFIGFLAGS_ENABLESERVER) &&
        bIsSharingEnabled)
    {
        if ((pParams->lResult = RemoveTapiSCP ()) != 0)
        {
            LOG((TL_ERROR,
                "MSetServerConfig: RemoveTapiSCP failed, err=%ld",
                pParams->lResult
                ));
            return;
        }
        else
        {
            // This is not a Telephony server anymore, so reset the flag
            TapiGlobals.dwFlags = TapiGlobals.dwFlags & ~TAPIGLOBALS_SERVER;
        }
    }
    if ((lResult = WriteRegistryKeys(
            NULL,
            NULL,
            (DWORD) ((pServerConfig->dwFlags &
                TAPISERVERCONFIGFLAGS_ENABLESERVER) ? 0 : 1)
            )))
    {
       LOG((TL_ERROR,
                "MSetServerConfig: WriteRegistryKeys failed, err=%ld",
                lResult
                ));
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if (pServerConfig->dwFlags & TAPISERVERCONFIGFLAGS_SETTAPIADMINISTRATORS)
    {
        WCHAR  *pAdmin, buf[16];
        DWORD   i;


        //
        // Reset the TapiAdministrators section
        //

        if (WritePrivateProfileSectionW(
            gszTapiAdministrators,
            L"\0",
            gszFileName) == 0)
        {
            pParams->lResult = LINEERR_OPERATIONFAILED;
            return;
        }

        pAdmin = (WCHAR *)
            (((LPBYTE) pServerConfig) + pServerConfig->dwAdministratorsOffset);


        //
        // For each admin in the list write out a "Domain\User=1"
        // value to the TapiAdministrators section
        //

        for (i = 0; *pAdmin != L'\0'; i++)
        {
            if (WritePrivateProfileStringW(
                gszTapiAdministrators,
                pAdmin,
                L"1",
                gszFileName
                ) == 0)
            {
                pParams->lResult = LINEERR_OPERATIONFAILED;
                return;
            }

            pAdmin += (wcslen (pAdmin) + 1);
        }
    }
}


typedef BOOL ( APIENTRY GETFILEVERSIONINFO(
    LPWSTR  lptstrFilename,     // pointer to filename string
    DWORD  dwHandle,    // ignored
    DWORD  dwLen,       // size of buffer
    LPVOID  lpData      // pointer to buffer to receive file-version info.
   ));
typedef DWORD ( APIENTRY GETFILEVERSIONINFOSIZE(
    LPWSTR  lptstrFilename,     // pointer to filename string
    LPDWORD  lpdwHandle         // pointer to variable to receive zero
   ));
typedef BOOL ( APIENTRY VERQUERYVALUE(
   const LPVOID  pBlock,        // address of buffer for version resource
   LPWSTR  lpSubBlock,  // address of value to retrieve
   LPVOID  *lplpBuffer, // address of buffer for version pointer
   PUINT  puLen         // address of version-value length buffer
  ));


static WCHAR gszVarFileInfo[]    = L"\\VarFileInfo\\Translation";
static WCHAR gszStringFileInfo[] = L"\\StringFileInfo\\%04x%04x\\FileDescription";

//
// EmanP
//   Given a multisz of file names,
//   allocates a multisz of friendly names.
//   Returns the number of bytes in the frienly name multisz
//
//

DWORD
GetProviderFriendlyName(
    /*IN */ WCHAR  *pFileNameBuf,
    /*OUT*/ WCHAR **ppFriendlyNameBuf
    )
{
    DWORD                   dwBufTotalSize = 0,
                            dwBufUsedSize  = 0,
                            dwVerSize      = 0,
                            dwSize,
                            dwVerHandle;
    UINT                    uItemSize;
    HINSTANCE               hVerDll;
    GETFILEVERSIONINFO     *pGetFileVersionInfo;
    GETFILEVERSIONINFOSIZE *pGetFileVersionInfoSize;
    VERQUERYVALUE          *pVerQueryValue;
    WCHAR                  *pFileName = pFileNameBuf,
                           *pszBuffer,
                           *pFriendlyNameBuf = NULL,
                           *p;
    BYTE                   *pbVerData = NULL;
    WCHAR                   szItem[1024];
    WORD                    wLangID;
    WORD                    wUserLangID;
    WORD                    wCodePage;
    DWORD                   dwIdx;

    if (NULL == pFileName ||
        NULL == ppFriendlyNameBuf)
    {
        return 0;
    }


    //
    // First, load VERSION.DLL
    //

    hVerDll = LoadLibrary( TEXT("Version.dll") );

    if ( NULL == hVerDll )
    {
        LOG((TL_ERROR,
            "LoadLibrary('VERSION.DLL') failed! err=0x%08lx",
            GetLastError()
            ));

        return 0;
    }


    //
    // Now, get the needed entry points into VERSION.DLL.
    // Use only UNICODE versions.
    //

    pGetFileVersionInfo = (GETFILEVERSIONINFO*) GetProcAddress(
        hVerDll,
        "GetFileVersionInfoW"
        );

    if ( NULL == pGetFileVersionInfo )
    {
        LOG((TL_ERROR,
            "GetProcAddress('VERSION.DLL', 'GetFileVersionInfoW') " \
                "failed! err=0x%08lx",
            GetLastError()
            ));

        goto _Return;
    }

    pGetFileVersionInfoSize = (GETFILEVERSIONINFOSIZE *) GetProcAddress(
        hVerDll,
        "GetFileVersionInfoSizeW"
        );

    if ( NULL == pGetFileVersionInfoSize )
    {
        LOG((TL_ERROR,
            "GetProcAddress('VERSION.DLL', 'GetFileVersionInfoSizeW') " \
                "failed! err=0x%08lx",
            GetLastError()
            ));

        goto _Return;
    }

    pVerQueryValue = (VERQUERYVALUE *) GetProcAddress(
        hVerDll,
        "VerQueryValueW"
        );

    if ( NULL == pVerQueryValue )
    {
        LOG((TL_ERROR,
            "GetProcAddress('VERSION.DLL', 'VerQueryValueW') " \
            "failed! err=0x%08lx",
            GetLastError()
            ));

        goto _Return;
    }

    //
    // Get the current UI language ( this is needed if MUI is enabled )
    // 
    wUserLangID = GetUserDefaultUILanguage ();

    //
    // For each filename in the input multisz,
    // try to get it's friendly name. If anything fails,
    // make the friendly name the same as the file name.
    //

    for (; 0 != *pFileName; pFileName += lstrlenW(pFileName)+1)
    {
        pszBuffer = NULL;

        //
        // 1. Get the size needed for the verion resource
        //

        if ((dwSize = pGetFileVersionInfoSize( pFileName, &dwVerHandle )) == 0)
        {
            LOG((TL_ERROR, "GetFileVersionInfoSize failure for %S", pFileName ));
            goto  _UseFileName;
        }

        //
        // 2. If our current buffer is smaller than needed, reallocate it.
        //

        if (dwSize > dwVerSize)
        {
            if (NULL != pbVerData)
            {
                ServerFree (pbVerData);
            }

            dwVerSize = dwSize + 16; 
            pbVerData = ServerAlloc( dwVerSize );
            if ( pbVerData == NULL )
            {
                dwVerSize = 0;
                goto  _UseFileName;
            }
        }


        //
        // 3. Now, get the version information for the file.
        //

        if (pGetFileVersionInfo(
                pFileName,
                dwVerHandle,
                dwVerSize,
                pbVerData

                ) == FALSE )
        {
            LOG((TL_ERROR, "GetFileVersionInfo failure for %S", pFileName ));
            goto  _UseFileName;
        }


        //
        // 4. Get the Language/Code page translation
        //
        // NOTE: bug in VerQueryValue, can't handle static CS based str
        //

        lstrcpyW ( szItem, gszVarFileInfo );

        if ((pVerQueryValue(
                pbVerData,
                szItem,
                &pszBuffer,
                (LPUINT) &uItemSize

                ) == FALSE) ||

            (uItemSize == 0))
        {
            LOG((TL_ERROR,
                "ERROR:  VerQueryValue failure for %S on file %S",
                szItem,
                pFileName
                ));

            pszBuffer = NULL;
            goto  _UseFileName;
        }


        wCodePage = 0;
        wLangID = wUserLangID;

        //
        // lookup the current user UI language ID in the file version info
        //
        if (0 != wLangID)
        {   
            for( dwIdx=0; dwIdx < uItemSize/sizeof(DWORD); dwIdx++ )
            {
                if ( *(WORD*)((DWORD*)pszBuffer + dwIdx) == wLangID )
                {
                    wCodePage = *( (WORD*)((DWORD*)pszBuffer + dwIdx) + 1);
                    break;
                }
            }
            if( dwIdx == uItemSize/sizeof(DWORD) )
            {
                wLangID = 0;
            }
        }

        //
        // if GetUserDefaultUILanguage() failed, 
        // or the current user UI language doesn't show up in the file version info
        // just use the first language in the file version
        //
        if (0 == wLangID)
        {
            wLangID = *(LPWORD)pszBuffer;
            wCodePage = *(((LPWORD)pszBuffer)+1);
        }

        //
        // 5. Get the FileDescription in the language obtained above.
        //    (We use the FileDescription as friendly name).
        //

        wsprintfW(
            szItem,
            gszStringFileInfo,
            wLangID,
            wCodePage
            );

        if ((pVerQueryValue(
                pbVerData,
                szItem,
                &pszBuffer,
                (LPUINT) &uItemSize

                ) == FALSE) ||

            (uItemSize == 0))
        {
            LOG((TL_ERROR,
                "ERROR:  VerQueryValue failure for %S on file %S",
                szItem,
                pFileName
                ));

            pszBuffer = NULL;
            goto  _UseFileName;
        }

_UseFileName:

        if (NULL == pszBuffer)
        {
            //
            // Something went wrong and we couldn't get
            // the file description. Use the file name
            // instead.
            //

            pszBuffer = pFileName;
        }


        //
        // At this point, pszBuffer points to a (UNICODE) string
        // containing what we deem to be the friendly name.
        // Let's append it to the OUT multisz.
        //

        dwSize = (lstrlenW (pszBuffer) + 1) * sizeof (WCHAR);

        if ((dwSize + dwBufUsedSize) > dwBufTotalSize)
        {
            if (!(p = ServerAlloc (dwBufTotalSize += 512)))
            {
                //
                // We don't have enough memory.
                // Release what we allocated until now, and return 0.
                //

                if (NULL != pFriendlyNameBuf)
                {
                    ServerFree (pFriendlyNameBuf);
                }

                dwBufUsedSize = 0;
                break;
            }

            if (dwBufUsedSize)
            {
                CopyMemory (p, pFriendlyNameBuf, dwBufUsedSize);

                ServerFree (pFriendlyNameBuf);
            }

            pFriendlyNameBuf = p;
        }

        CopyMemory(
            ((LPBYTE) pFriendlyNameBuf) + dwBufUsedSize,
            pszBuffer,
            dwSize
            );

        dwBufUsedSize += dwSize;
    }

_Return:

    //
    // We don't need the library anymore.
    // We don't need the version buffer either.
    //

    FreeLibrary (hVerDll);

    if (NULL != pbVerData)
    {
        ServerFree (pbVerData);
    }

    if (0 != dwBufUsedSize)
    {
        *ppFriendlyNameBuf = pFriendlyNameBuf;
    }

    return dwBufUsedSize;
}

void WINAPI MGetDeviceFlags (
    PTCLIENT                    ptClient,
    PMMCGETDEVICEFLAGS_PARAMS   pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    DWORD                   dwDeviceID;
    TAPIPERMANENTID         ID;

    *pdwNumBytesReturned = sizeof (TAPI32_MSG);
    
    //  Support calls on line device only for now
    if (!pParams->fLine)
    {
        pParams->lResult = LINEERR_OPERATIONUNAVAIL;
        return;
    }

    ID.dwDeviceID = pParams->dwPermanentDeviceID;
    ID.dwProviderID = pParams->dwProviderID;

    EnterCriticalSection(&gMgmtCritSec);

    if (gpLineDevFlags == NULL)
    {
        pParams->lResult = LINEERR_OPERATIONUNAVAIL;
        goto ExitHere;
    }

    dwDeviceID = GetDeviceIDFromPermanentID (ID, pParams->fLine);

    if (dwDeviceID == 0xffffffff || dwDeviceID >= gdwNumFlags)
    {
        pParams->lResult = LINEERR_OPERATIONUNAVAIL;
        goto ExitHere;
    }

    pParams->dwDeviceID = dwDeviceID;
    pParams->dwFlags = gpLineDevFlags[dwDeviceID];

ExitHere:
    LeaveCriticalSection (&gMgmtCritSec);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\server\line.c ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1995-1998  Microsoft Corporation

Module Name:

    line.c

Abstract:

    Src module for tapi server line funcs

Author:

    Dan Knudson (DanKn)    01-Apr-1995

Revision History:

--*/


#include "windows.h"
#include "assert.h"
#include "prsht.h"
#include "stdlib.h"
#include "tapip.h" // private\inc\tapip.h
#include "tspi.h"
#include "utils.h"
#include "client.h"
#include "loc_comn.h"
#include "server.h"
#include "line.h"
#include "resource.h"
#include "tapihndl.h"
#include "tregupr2.h"
#include <tchar.h>
#include "private.h"
#include <MMSYSTEM.H>
#include <mmddk.h>

// PERF
#include "tapiperf.h"

#define ARRAYSIZE(x)    (sizeof(x)/sizeof(x[0]))

// PERF
extern PERFBLOCK           PerfBlock;

LONG
RtlOpenCurrentUser(
    IN ULONG DesiredAccess,
    OUT PHANDLE CurrentUserKey
    );

//NTSYSAPI
//NTSTATUS
//NTAPI
LONG
NtClose(
    IN HANDLE Handle
    );



LPLINECOUNTRYLIST   gpCountryList = NULL;
LPDWORD             gpCountryGroups = NULL;

extern TAPIGLOBALS TapiGlobals;
extern CRITICAL_SECTION gSafeMutexCritSec,
                        gPriorityListCritSec;


extern HANDLE ghHandleTable;

extern TCHAR gszProviderID[];
extern TCHAR gszNumProviders[];
extern TCHAR gszNextProviderID[];
extern TCHAR gszProviderFilename[];
extern TCHAR gszRegKeyTelephony[];

const TCHAR gszLocation[]  = TEXT("Location");
const TCHAR gszLocations[] = TEXT("Locations");
const TCHAR gszAreaCodeRules[]  = TEXT("AreaCodeRules");

extern TCHAR gszRegKeyProviders[];

extern PTPROVIDER pRemoteSP;

extern DWORD gdwNumSPEventHandlerThreads;

extern HINSTANCE ghInstance;

extern BOOL gbQueueSPEvents;

const TCHAR gszID[]                 = TEXT("ID");
const TCHAR gszCountry[]            = TEXT("Country");
const TCHAR gszFlags[]              = TEXT("Flags");
const TCHAR gszNoPrefixAreaCodes[]  = TEXT("NoPrefAC");

const TCHAR gszNumEntries[]         = TEXT("NumEntries");
const TCHAR gszCurrentID[]          = TEXT("CurrentID");
const TCHAR gszNextID[]             = TEXT("NextID");
const TCHAR gszLocationListVersion[]= TEXT("LocationListVersion");

const TCHAR gszCallingCard[]        = TEXT("CallingCard");

const TCHAR gszSameAreaRuleW[]       = TEXT("SameAreaRule");
const TCHAR gszLongDistanceRuleW[]   = TEXT("LongDistanceRule");
const TCHAR gszInternationalRuleW[]  = TEXT("InternationalRule");
const TCHAR gszCountryGroupW[]       = TEXT("CountryGroup");
const TCHAR gszNameW[]               = TEXT("Name");
const TCHAR gszNameResW[]            = TEXT("NameResourceId");
const TCHAR gszAreaCodeW[]           = TEXT("AreaCode");
const TCHAR gszLongDistanceCarrierCodeW[] = TEXT("LongDistanceCarrierCode");
const TCHAR gszInternationalCarrierCodeW[] = TEXT("InternationalCarrierCode");
const TCHAR gszOutsideAccessW[]      = TEXT("OutsideAccess");
const TCHAR gszLongDistanceAccessW[] = TEXT("LongDistanceAccess");
const TCHAR gszDisableCallWaitingW[] = TEXT("DisableCallWaiting");
const TCHAR gszTollListW[]           = TEXT("TollList");
const TCHAR gszCountryListVersionW[] = TEXT("CountryListVersion");

const TCHAR gszAreaCodeToCallW[]     = TEXT("AreaCodeToCall");
const TCHAR gszNumberToDialW[]       = TEXT("NumberToDial"); 
const TCHAR gszPrefixesW[]           = TEXT("Prefixes"); 

//
// IMPORTANT NOTE: this value should be incremented any time there is a
//                 change to country.rc
//

#define TAPI_CURRENT_COUNTRY_LIST_VERSION  0x00000110

#define IS_LRESULT_NOTERROR( foo )                            \
            ( ! ( 0x80000000 & foo )  &&                                        \
            (  (foo <= LINEERR_LASTERRORVALUE)  ||                                     \
                (foo > 0x90000000 && foo <= PHONEERR_LASTERRORVALUE) ) )

extern UINT             guiAlignmentFaultEnabled;
extern BOOL             gbWinNT;
extern BOOL             gbNTServer;
extern BOOL             gbServerInited;
extern HANDLE           ghTapisrvHeap;



//
// The following are used for the call hub implementation.
//
// One call hub hash table is used for each service provider.
// When a outgoing call or is successfully made or an incoming
// call shows up, TAPI will retrieve the call ID for that
// call and stick it in the hash table using the algorithim :
//
//   hashEntryIndex = callID % numHashTableEntries
//
// In the case of collision (hashEntry already in use by a
// different callID) then the DoCallHubHashing() function will
// try to create a dynamic entry to hang off the "static" entry.
//
// We will allow a total number (per table) of dynamic entries
// specified by the GetMaxDynamicHashTableEntries() macro below.
//
// We will allow a total number (per table entry) of dynamic
// entries specified by the symbolic MAX_DYNAMIC_HASH_ENTRIES_PER_SLOT
// constant below.
//
// TapiPrimes is an array of increasing prime numbers used
// for hash table sizes. We will not grow a hash table to more
// the 261983 (static) entries, this being a seemingly
// reasonable limitation at this point.  If we try to hash
// a call and are unable to (out of memory, max table size, etc)
// then we will reset our internal copy of the call ID for
// the call to 0, meaning it's not hashed at all.
//

const DWORD TapiPrimes[] =
{
    31, 61, 127, 257, 521, 1031, 2053, 4099, 8191,
    16381, 32749, 65537, 131071, 261983, 0
};

#define GetMaxDynamicHashTableEntries(TotalNumEntries) \
            (TotalNumEntries/10)

#define MAX_DYNAMIC_HASH_ENTRIES_PER_SLOT 3


#if DBG
extern DWORD   gdwDebugLevel;
extern BOOL    gfBreakOnSeriousProblems;

char *
PASCAL
MapResultCodeToText(
    LONG    lResult,
    char   *pszResult
    );
#endif

void
PASCAL
DestroytCall(
    PTCALL  ptCall
    );

void
PASCAL
DestroytCallClient(
    PTCALLCLIENT    ptCallClient
    );

void
PASCAL
DestroytLineClient(
    HLINE   hLine
    );

void
LDevSpecific_PostProcess(
    PASYNCREQUESTINFO   pAsyncRequestInfo,
    PASYNCEVENTMSG      pAsyncEventMsg,
    LPVOID             *ppBuf
    );

void
LMakeCall_PostProcess(
    PASYNCREQUESTINFO   pAsyncRequestInfo,
    PASYNCEVENTMSG      pAsyncEventMsg,
    LPVOID             *ppBuf
    );

void
CALLBACK
CompletionProcSP(
    DWORD   dwRequestID,
    LONG    lResult
    );

LONG
PASCAL
GetPhoneAppListFromClient(
    PTCLIENT        ptClient,
    PTPOINTERLIST  *ppList
    );

LONG
InitializeClient(
    PTCLIENT    ptClient
    );

BOOL
GetLinePermanentIdFromDeviceID(
    PTCLIENT            ptClient,
    DWORD               dwDeviceID,
    LPTAPIPERMANENTID   pID
    );

void
CALLBACK
LineEventProcSP(
    HTAPILINE   htLine,
    HTAPICALL   htCall,
    DWORD       dwMsg,
    ULONG_PTR   dwParam1,
    ULONG_PTR   dwParam2,
    ULONG_PTR   dwParam3
    );

PTPHONELOOKUPENTRY
GetPhoneLookupEntry(
    DWORD   dwDeviceID
    );

LONG
GetPermLineIDAndInsertInTable(
    PTPROVIDER  ptProvider,
    DWORD       dwDeviceID,
    DWORD       dwSPIVersion
    );

LONG
AppendNewDeviceInfo (
    BOOL                        bLine,
    DWORD                       dwDeviceID
    );

LONG
RemoveDeviceInfoEntry (
    BOOL                        bLine,
    DWORD                       dwDeviceID
    );

BOOL
IsAPIVersionInRange(
    DWORD   dwAPIVersion,
    DWORD   dwSPIVersion
    )
{
    if (dwAPIVersion <= dwSPIVersion)
    {
        switch (dwAPIVersion)
        {
        case TAPI_VERSION_CURRENT:
        case TAPI_VERSION3_0:
        case TAPI_VERSION2_2:
        case TAPI_VERSION2_1:
        case TAPI_VERSION2_0:
        case TAPI_VERSION1_4:
        case TAPI_VERSION1_0:

            return TRUE;

        default:

            break;
        }
    }

    return FALSE;
}


LONG
GetLineVersions(
    PTLINECLIENT    ptLineClient,
    LPDWORD         lpdwAPIVersion,
    LPDWORD         lpdwSPIVersion
    )
{
    *lpdwAPIVersion = ptLineClient->dwAPIVersion;
    *lpdwSPIVersion = ptLineClient->ptLine->dwSPIVersion;

    if (ptLineClient->dwKey != TLINECLIENT_KEY)
    {
        return LINEERR_INVALLINEHANDLE;
    }

    return 0;
}


BOOL
InitTapiStruct(
    LPVOID  pTapiStruct,
    DWORD   dwTotalSize,
    DWORD   dwFixedSize,
    BOOL    bZeroInit
    )
{
    //
    // Verify there's space enough for fixed data
    //

    if (dwTotalSize < dwFixedSize)
    {
        return FALSE;
    }


    //
    // Init the dwTotalSize as specified, then init the dwUsedSize and
    // dwNeededSize fields as the fixed size of the structure (saves the
    // SP some work if it's not planning on adding any of it's own
    // varible-length data to the structure)
    //

    *((LPDWORD) pTapiStruct)       = dwTotalSize;

    *(((LPDWORD) pTapiStruct) + 1) =
    *(((LPDWORD) pTapiStruct) + 2) = dwFixedSize;


    //
    // Now zero out the rest of the buffer if the caller wants us to
    //

    if (bZeroInit)
    {
        ZeroMemory(
            ((LPDWORD) pTapiStruct) + 3,
            dwTotalSize - 3 * sizeof (DWORD)
            );
    }

    return TRUE;
}


#if DBG
BOOL
IsBadSizeOffset(
    DWORD dwTotalSize,
    DWORD dwFixedSize,
    DWORD dwXxxSize,
    DWORD dwXxxOffset,
    DWORD dwAlignMask,
    char *pszCallingFunc,
    char *pszFieldName
    )

#else
BOOL
IsBadSizeOffset(
    DWORD dwTotalSize,
    DWORD dwFixedSize,
    DWORD dwXxxSize,
    DWORD dwXxxOffset,
    DWORD dwAlignMask
    )

#endif
{
    if (dwXxxSize != 0)
    {
        DWORD   dwSum = dwXxxSize + dwXxxOffset;

        if ((dwAlignMask == 2) || (dwAlignMask == 4) || (dwAlignMask == 8))
        {
            dwAlignMask--;
            if (dwAlignMask & dwXxxOffset)
            {
                return TRUE;
            }
        }

        if (dwXxxOffset < dwFixedSize)
        {
#if DBG
            LOG((TL_INFO,
                "%s: dw%sOffset (=x%x) points at fixed portion (=x%x)" \
                    " of structure",
                pszCallingFunc,
                pszFieldName,
                dwXxxSize,
                dwFixedSize
                ));
#else
            LOG((TL_INFO,
                "Offset (=x%x) points at fixed portion (=x%x)" \
                    " of structure",
                dwXxxSize,
                dwFixedSize
                ));
#endif
            return TRUE;
        }
        else if ((dwSum > dwTotalSize) || (dwSum < dwXxxSize))
        {
#if DBG
            LOG((TL_INFO,
                "%s: sum of dw%sSize/Offset (=x%x/x%x) > dwTotalSize (=x%x)",
                pszCallingFunc,
                pszFieldName,
                dwXxxSize,
                dwXxxOffset,
                dwFixedSize,
                dwTotalSize
                ));
#endif
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
IsBadStringParam(
    DWORD   dwParamsBufferSize,
    LPBYTE  pDataBuf,
    DWORD   dwStringOffset
    )
{
    WCHAR  *p;
    DWORD   dwCharsLeft;


    //
    // Check if offset is not WCHAR-aligned or if offset lies outside buffer
    //

    if ((dwStringOffset & 1)  ||  (dwStringOffset >= dwParamsBufferSize))
    {
        return TRUE;
    }


    //
    // Walk the string & make sure it's NULL-terminated within the buffer
    //

    dwCharsLeft = (dwParamsBufferSize - dwStringOffset) / sizeof (WCHAR);

    for(
        p = (WCHAR *) (pDataBuf + dwStringOffset);
        dwCharsLeft  &&  *p;
        dwCharsLeft--, p++
        );

    return (dwCharsLeft ? FALSE : TRUE);
}


BOOL
IsBadStructParam(
    DWORD   dwParamsBufferSize,
    LPBYTE  pDataBuf,
    DWORD   dwXxxOffset
    )
{
    DWORD   dwTotalSize;


    if ((dwXxxOffset & 0x3) ||
        (dwParamsBufferSize < sizeof (DWORD)) ||
        (dwXxxOffset >= (dwParamsBufferSize - sizeof (DWORD))))
    {
        return TRUE;
    }

    dwTotalSize = *((LPDWORD) (pDataBuf + dwXxxOffset));

    if (dwTotalSize > (dwParamsBufferSize - dwXxxOffset))
    {
        return TRUE;
    }

    return FALSE;
}


LONG
PASCAL
ValidateCallParams(
    LPLINECALLPARAMS    pCallParamsApp,
    LPLINECALLPARAMS   *ppCallParamsSP,
    DWORD               dwAPIVersion,
    DWORD               dwSPIVersion,
    DWORD               dwAsciiCallParamsCodePage
    )
{
    //
    // This routine checks the fields in a LINECALLPARAMS struct,
    // looking for invalid bit flags and making sure that the
    // various size/offset pairs only reference data within the
    // variable-data portion of the structure. Also, if the
    // specified SPI version is greater than the API version and
    // the fixed structure size differs between the two versions,
    // a larger buffer is allocated, the var data is relocated,
    // and the sizeof/offset pairs are patched.
    //

    char    szFunc[] = "ValidateCallParams";
    DWORD   dwTotalSize = pCallParamsApp->dwTotalSize, dwFixedSizeApp,
            dwFixedSizeSP, dwAllBearerModes, dwAllMediaModes,
            dwAllCallParamFlags;


    switch (dwAPIVersion)
    {
    case TAPI_VERSION1_0:

        dwFixedSizeApp   = 112; // 24 * sizeof (DWORD) + sizeof(LINEDIALPARAMS)
        dwAllMediaModes  = AllMediaModes1_0;

        //
        // HotFax v1.0 may be hot, but it's not real smart.  It's
        // negotating an API ver == 0x10003, and subsequently tries
        // to sneak in a v1.4 bearer mode (PASSTHROUGH).  We'll
        // allow for it this time...
        //
        //dwAllBearerModes = AllBearerModes1_0;

        dwAllBearerModes = AllBearerModes1_4; // HACK - see above

        dwAllCallParamFlags = AllCallParamFlags1_0;

        break;

    case TAPI_VERSION1_4:

        dwFixedSizeApp   = 112; // 24 * sizeof (DWORD) + sizeof(LINEDIALPARAMS)
        dwAllMediaModes  = AllMediaModes1_4;
        dwAllBearerModes = AllBearerModes1_4;
        dwAllCallParamFlags = AllCallParamFlags1_0;
        break;

    case TAPI_VERSION2_0:
    case TAPI_VERSION2_1:
    case TAPI_VERSION2_2:

        dwFixedSizeApp   = 176; // 40 * sizeof (DWORD) + sizeof(LINEDIALPARAMS)
        dwAllMediaModes  = AllMediaModes2_1;
        dwAllBearerModes = AllBearerModes2_0;
        dwAllCallParamFlags = AllCallParamFlags2_0;
        break;

    case TAPI_VERSION3_0:
    case TAPI_VERSION_CURRENT:

        dwFixedSizeApp   = sizeof (LINECALLPARAMS);
        dwAllMediaModes  = AllMediaModes2_1;
        dwAllBearerModes = AllBearerModes2_0;
        dwAllCallParamFlags = AllCallParamFlags2_0;
        break;

    default:

        return LINEERR_OPERATIONFAILED;
    }


    switch (dwSPIVersion)
    {
    case TAPI_VERSION1_0:
    case TAPI_VERSION1_4:

        dwFixedSizeSP = 112;    // 24 * sizeof (DWORD) + sizeof(LINEDIALPARAMS)
        break;

    case TAPI_VERSION2_0:
    case TAPI_VERSION2_1:
    case TAPI_VERSION2_2:

        dwFixedSizeSP = 176;    // 40 * sizeof (DWORD) + sizeof(LINEDIALPARAMS)
        break;

    case TAPI_VERSION3_0:
    case TAPI_VERSION_CURRENT:

        dwFixedSizeSP = sizeof (LINECALLPARAMS);
        break;

    default:

        return LINEERR_OPERATIONFAILED;
    }


    if (dwTotalSize < dwFixedSizeApp)
    {
        LOG((TL_ERROR,
            "%sbad dwTotalSize, x%x (minimum valid size=x%x)",
            szFunc,
            dwTotalSize,
            dwFixedSizeApp
            ));
        return LINEERR_STRUCTURETOOSMALL;
    }

    if (pCallParamsApp->dwBearerMode)
    {
        //
        // Allow 1.x apps to pass >=1 valid bearer modes to 1.x service
        // providers for backwards compatiblity, but enforce a single
        // valid bearer mode for newer apps and/or service providers
        //

        if ((dwAPIVersion >= TAPI_VERSION2_0) ||
            (dwSPIVersion >= TAPI_VERSION2_0))
        {
            if (!IsOnlyOneBitSetInDWORD (pCallParamsApp->dwBearerMode) ||
                (pCallParamsApp->dwBearerMode & ~dwAllBearerModes))
            {
bad_bearer_mode:

                LOG((TL_ERROR,
                    "%sbad dwBearerMode, x%x",
                    szFunc,
                    pCallParamsApp->dwBearerMode
                    ));

                return LINEERR_INVALBEARERMODE;
            }
        }
        else
        {
            if (pCallParamsApp->dwBearerMode & ~dwAllBearerModes)
            {
                goto bad_bearer_mode;
            }
            else if (!IsOnlyOneBitSetInDWORD (pCallParamsApp->dwBearerMode))
            {
                LOG((TL_ERROR,
                    "%sbad dwBearerMode, x%x, allowed for 1.x apps/SPs",
                    szFunc,
                    pCallParamsApp->dwBearerMode
                    ));
            }
        }
    }
    else
    {
        //
        // For clarity's sake reset 0 bearer mode to VOICE
        //

        pCallParamsApp->dwBearerMode = LINEBEARERMODE_VOICE;
    }



    {
        DWORD dwMediaModeApp = pCallParamsApp->dwMediaMode;


        if ((dwMediaModeApp & (0x00ffffff ^ dwAllMediaModes)) ||

             // single media mode is version is less <= 2.1
             ( (dwAPIVersion <= TAPI_VERSION2_1) &&
               !IsOnlyOneBitSetInDWORD (dwMediaModeApp) &&
               !(dwMediaModeApp & LINEMEDIAMODE_UNKNOWN) ) )
        {
            //
            // For clarity's sake reset 0 media mode to INTERACTIVEVOICE
            //

            if (dwMediaModeApp == 0)
            {
                pCallParamsApp->dwMediaMode = LINEMEDIAMODE_INTERACTIVEVOICE;
            }
            else
            {
                LOG((TL_ERROR, "%sbad dwMediaMode, x%x", szFunc, dwMediaModeApp));
                return LINEERR_INVALMEDIAMODE;
            }
        }
    }

    if (pCallParamsApp->dwCallParamFlags & ~dwAllCallParamFlags)
    {
        LOG((TL_ERROR,
            "%sbad dwCallParamFlags, x%x",
            szFunc,
            pCallParamsApp->dwCallParamFlags
            ));
        return LINEERR_INVALCALLPARAMS;
    }

    //
    // Note: an address mode of 0 means "default to any address,
    //       don't select a specific address" (says TNixon)
    //

    if (pCallParamsApp->dwAddressMode == LINEADDRESSMODE_ADDRESSID ||
        pCallParamsApp->dwAddressMode == LINEADDRESSMODE_DIALABLEADDR)
    {
        // do nothing (it's a valid addr mode)
    }
    else if (pCallParamsApp->dwAddressMode == 0)
    {
        //
        // For clarity's sake reset 0 addr mode to ADDRESSID
        //

        pCallParamsApp->dwAddressMode = LINEADDRESSMODE_ADDRESSID;
    }
    else
    {
        LOG((TL_ERROR,
            "%sbad dwAddressMode, x%x",
            szFunc,
            pCallParamsApp->dwAddressMode
            ));

        return LINEERR_INVALADDRESSMODE;
    }

    if (ISBADSIZEOFFSET(
            dwTotalSize,
            dwFixedSizeApp,
            pCallParamsApp->dwOrigAddressSize,
            pCallParamsApp->dwOrigAddressOffset,
            (!guiAlignmentFaultEnabled) ? 0 : 
                ((pCallParamsApp->dwAddressMode & LINEADDRESSMODE_DIALABLEADDR) ?
                    sizeof(TCHAR) : sizeof(DWORD)),
            szFunc,
            "OrigAddress"
            ) ||

        ISBADSIZEOFFSET(
            dwTotalSize,
            dwFixedSizeApp,
            pCallParamsApp->dwUserUserInfoSize,
            pCallParamsApp->dwUserUserInfoOffset,
            guiAlignmentFaultEnabled? sizeof(TCHAR) : 0,
            szFunc,
            "UserUserInfo"
            ) ||

        ISBADSIZEOFFSET(
            dwTotalSize,
            dwFixedSizeApp,
            pCallParamsApp->dwHighLevelCompSize,
            pCallParamsApp->dwHighLevelCompOffset,
            0,
            szFunc,
            "HighLevelComp"
            ) ||

        ISBADSIZEOFFSET(
            dwTotalSize,
            dwFixedSizeApp,
            pCallParamsApp->dwLowLevelCompSize,
            pCallParamsApp->dwLowLevelCompOffset,
            0,
            szFunc,
            "LowLevelComp"
            ) ||

        ISBADSIZEOFFSET(
            dwTotalSize,
            dwFixedSizeApp,
            pCallParamsApp->dwDevSpecificSize,
            pCallParamsApp->dwDevSpecificOffset,
            0,
            szFunc,
            "DevSpecificSize"
            ))
    {
        return LINEERR_INVALCALLPARAMS;
    }


    //
    // The following is an attempt to compensate for 1.x tapi apps
    // that borrowed dialer.exe's source code and package their
    // call params incorrectly.  The fix is to zero the offending
    // dwXxxSize/Offset pair of the various information-only fields,
    // so at worst some logging info will be lost, but the app will
    // still be able to make calls.  (Failure to correctly package
    // any of the above var-length fields is considered "fatal" in
    // any case.)
    //

    if (ISBADSIZEOFFSET(
            dwTotalSize,
            dwFixedSizeApp,
            pCallParamsApp->dwDisplayableAddressSize,
            pCallParamsApp->dwDisplayableAddressOffset,
            guiAlignmentFaultEnabled? sizeof(TCHAR) : 0,
            szFunc,
            "DisplayableAddress"
            ))
    {
        if (dwAPIVersion < TAPI_VERSION2_0)
        {
            pCallParamsApp->dwDisplayableAddressSize   =
            pCallParamsApp->dwDisplayableAddressOffset = 0;
        }
        else
        {
            return LINEERR_INVALCALLPARAMS;
        }
    }

    if (ISBADSIZEOFFSET(
            dwTotalSize,
            dwFixedSizeApp,
            pCallParamsApp->dwCalledPartySize,
            pCallParamsApp->dwCalledPartyOffset,
            guiAlignmentFaultEnabled? sizeof(TCHAR) : 0,
            szFunc,
            "CalledParty"
            ))
    {
        if (dwAPIVersion < TAPI_VERSION2_0)
        {
            pCallParamsApp->dwCalledPartySize   =
            pCallParamsApp->dwCalledPartyOffset = 0;
        }
        else
        {
            return LINEERR_INVALCALLPARAMS;
        }
    }

    if (ISBADSIZEOFFSET(
            dwTotalSize,
            dwFixedSizeApp,
            pCallParamsApp->dwCommentSize,
            pCallParamsApp->dwCommentOffset,
            guiAlignmentFaultEnabled? sizeof(TCHAR) : 0,
            szFunc,
            "Comment"
            ))
    {
        if (dwAPIVersion < TAPI_VERSION2_0)
        {
            pCallParamsApp->dwCommentSize   =
            pCallParamsApp->dwCommentOffset = 0;
        }
        else
        {
            return LINEERR_INVALCALLPARAMS;
        }
    }


    if (dwAPIVersion <= TAPI_VERSION1_4)
    {
        goto ValidateCallParams_checkFixedSizes;
    }

    #define AllCallStates                     \
        (LINECALLSTATE_IDLE                 | \
        LINECALLSTATE_OFFERING              | \
        LINECALLSTATE_ACCEPTED              | \
        LINECALLSTATE_DIALTONE              | \
        LINECALLSTATE_DIALING               | \
        LINECALLSTATE_RINGBACK              | \
        LINECALLSTATE_BUSY                  | \
        LINECALLSTATE_SPECIALINFO           | \
        LINECALLSTATE_CONNECTED             | \
        LINECALLSTATE_PROCEEDING            | \
        LINECALLSTATE_ONHOLD                | \
        LINECALLSTATE_CONFERENCED           | \
        LINECALLSTATE_ONHOLDPENDCONF        | \
        LINECALLSTATE_ONHOLDPENDTRANSFER    | \
        LINECALLSTATE_DISCONNECTED          | \
        LINECALLSTATE_UNKNOWN)

    if (pCallParamsApp->dwPredictiveAutoTransferStates & ~AllCallStates)
    {
        LOG((TL_ERROR,
            "%sbad dwPredictiveAutoTransferStates, x%x",
            szFunc,
            pCallParamsApp->dwPredictiveAutoTransferStates
            ));

        return LINEERR_INVALCALLPARAMS;
    }

    if (ISBADSIZEOFFSET(
            dwTotalSize,
            dwFixedSizeApp,
            pCallParamsApp->dwTargetAddressSize,
            pCallParamsApp->dwTargetAddressOffset,
            guiAlignmentFaultEnabled? sizeof(TCHAR) : 0,
            szFunc,
            "TargetAddress"
            ) ||

        ISBADSIZEOFFSET(
            dwTotalSize,
            dwFixedSizeApp,
            pCallParamsApp->dwSendingFlowspecSize,
            pCallParamsApp->dwSendingFlowspecOffset,
            guiAlignmentFaultEnabled? sizeof(DWORD) : 0,
            szFunc,
            "SendingFlowspec"
            ) ||

        ISBADSIZEOFFSET(
            dwTotalSize,
            dwFixedSizeApp,
            pCallParamsApp->dwReceivingFlowspecSize,
            pCallParamsApp->dwReceivingFlowspecOffset,
            guiAlignmentFaultEnabled? sizeof(DWORD) : 0,
            szFunc,
            "ReceivingFlowspec"
            ) ||

        ISBADSIZEOFFSET(
            dwTotalSize,
            dwFixedSizeApp,
            pCallParamsApp->dwDeviceClassSize,
            pCallParamsApp->dwDeviceClassOffset,
            0,
            szFunc,
            "DeviceClass"
            ) ||

        ISBADSIZEOFFSET(
            dwTotalSize,
            dwFixedSizeApp,
            pCallParamsApp->dwDeviceConfigSize,
            pCallParamsApp->dwDeviceConfigOffset,
            0,
            szFunc,
            "DeviceConfig"
            ) ||

        ISBADSIZEOFFSET(
            dwTotalSize,
            dwFixedSizeApp,
            pCallParamsApp->dwCallDataSize,
            pCallParamsApp->dwCallDataOffset,
            0,
            szFunc,
            "CallData"
            ) ||

        ISBADSIZEOFFSET(
            dwTotalSize,
            dwFixedSizeApp,
            pCallParamsApp->dwCallingPartyIDSize,
            pCallParamsApp->dwCallingPartyIDOffset,
            0,
            szFunc,
            "CallingPartyID"
            ))
    {
        return LINEERR_INVALCALLPARAMS;
    }

    if (dwAPIVersion < TAPI_VERSION3_0)
    {
        goto ValidateCallParams_checkFixedSizes;
    }

    if (pCallParamsApp->dwAddressType == 0)
    {
        // pCallParamsApp->dwAddressType = LINEADDRESSTYPE_PHONENUMBER;
    }
    else if ((pCallParamsApp->dwAddressType & ~AllAddressTypes) ||
             !IsOnlyOneBitSetInDWORD (pCallParamsApp->dwAddressType))
    {
        LOG((TL_ERROR,
            "%sbad dwAddressType, x%x",
            szFunc,
            pCallParamsApp->dwAddressType
            ));

        return LINEERR_INVALCALLPARAMS;
    }

ValidateCallParams_checkFixedSizes:

    if (dwAsciiCallParamsCodePage == TAPI_NO_DATA)
    {
        //
        // If here we're getting unicode call params from the app
        //
        // Check to see if the fixed size of the app's call params
        // are smaller than the fixed size of the call params
        // required by the service provider (due to it's negotiated
        // SPI version), and if so alloc a larger buffer to account
        // for this different fixed size & set it up correctly
        //

        if (dwFixedSizeApp < dwFixedSizeSP)
        {
            DWORD               dwFixedSizeDiff =
                                    dwFixedSizeSP - dwFixedSizeApp;
            LPLINECALLPARAMS    pCallParamsSP;


            if (!(pCallParamsSP = ServerAlloc (dwTotalSize + dwFixedSizeDiff)))
            {
                return LINEERR_NOMEM;
            }

            CopyMemory (pCallParamsSP, pCallParamsApp, dwFixedSizeApp);

            pCallParamsSP->dwTotalSize = dwTotalSize + dwFixedSizeDiff;

            CopyMemory(
                ((LPBYTE) pCallParamsSP) + dwFixedSizeSP,
                ((LPBYTE) pCallParamsApp) + dwFixedSizeApp,
                dwTotalSize - dwFixedSizeApp
                );

            if (pCallParamsSP->dwOrigAddressOffset)
            {
                pCallParamsSP->dwOrigAddressOffset += dwFixedSizeDiff;
            }

            if (pCallParamsSP->dwDisplayableAddressOffset)
            {
                pCallParamsSP->dwDisplayableAddressOffset += dwFixedSizeDiff;
            }

            if (pCallParamsSP->dwCalledPartyOffset)
            {
                pCallParamsSP->dwCalledPartyOffset += dwFixedSizeDiff;
            }

            if (pCallParamsSP->dwCommentOffset)
            {
                pCallParamsSP->dwCommentOffset += dwFixedSizeDiff;
            }

            if (pCallParamsSP->dwUserUserInfoOffset)
            {
                pCallParamsSP->dwUserUserInfoOffset += dwFixedSizeDiff;
            }

            if (pCallParamsSP->dwHighLevelCompOffset)
            {
                pCallParamsSP->dwHighLevelCompOffset += dwFixedSizeDiff;
            }

            if (pCallParamsSP->dwLowLevelCompOffset)
            {
                pCallParamsSP->dwLowLevelCompOffset += dwFixedSizeDiff;
            }

            if (pCallParamsSP->dwDevSpecificOffset)
            {
                pCallParamsSP->dwDevSpecificOffset += dwFixedSizeDiff;
            }

            if (dwAPIVersion >= TAPI_VERSION2_0)
            {
                if (pCallParamsSP->dwTargetAddressOffset)
                {
                    pCallParamsSP->dwTargetAddressOffset += dwFixedSizeDiff;
                }

                if (pCallParamsSP->dwSendingFlowspecOffset)
                {
                    pCallParamsSP->dwSendingFlowspecOffset += dwFixedSizeDiff;
                }

                if (pCallParamsSP->dwReceivingFlowspecOffset)
                {
                    pCallParamsSP->dwReceivingFlowspecOffset +=dwFixedSizeDiff;
                }

                if (pCallParamsSP->dwDeviceClassOffset)
                {
                    pCallParamsSP->dwDeviceClassOffset += dwFixedSizeDiff;
                }

                if (pCallParamsSP->dwDeviceConfigOffset)
                {
                    pCallParamsSP->dwDeviceConfigOffset += dwFixedSizeDiff;
                }

                if (pCallParamsSP->dwCallDataOffset)
                {
                    pCallParamsSP->dwCallDataOffset += dwFixedSizeDiff;
                }

                if (pCallParamsSP->dwCallingPartyIDOffset)
                {
                    pCallParamsSP->dwCallingPartyIDOffset += dwFixedSizeDiff;
                }
            }

            *ppCallParamsSP = pCallParamsSP;
        }
        else
        {
            *ppCallParamsSP = pCallParamsApp;
        }
    }
    else // see if there's ascii var data fields to translate
    {
        //
        // If here we're getting ascii call params form the app
        //
        // We may need to due ascii -> unicode conversions on some
        // of the var fields, as well as account for differences
        // in the fixed sizes of the call params structs as described
        // above
        //

        DWORD   dwAsciiVarDataSize,
                dwFixedSizeDiff = dwFixedSizeSP - dwFixedSizeApp;


        dwAsciiVarDataSize =
            pCallParamsApp->dwOrigAddressSize +
            pCallParamsApp->dwDisplayableAddressSize +
            pCallParamsApp->dwCalledPartySize +
            pCallParamsApp->dwCommentSize;

        if (dwAPIVersion > TAPI_VERSION1_4)
        {
            dwAsciiVarDataSize +=
                pCallParamsApp->dwTargetAddressSize +
                pCallParamsApp->dwDeviceClassSize +
                pCallParamsApp->dwCallingPartyIDSize;
        }

        if (dwFixedSizeDiff != 0  ||  dwAsciiVarDataSize != 0)
        {
            LPLINECALLPARAMS    pCallParamsSP;


            // alloc 3 extra for alignment
            if (!(pCallParamsSP = ServerAlloc(
                    dwTotalSize + dwFixedSizeDiff + 2 * dwAsciiVarDataSize + 3
                    )))
            {
                return LINEERR_NOMEM;
            }

            if (dwFixedSizeDiff)
            {
                CopyMemory (pCallParamsSP, pCallParamsApp, dwFixedSizeApp);

                CopyMemory(
                    ((LPBYTE) pCallParamsSP) + dwFixedSizeSP,
                    ((LPBYTE) pCallParamsApp) + dwFixedSizeApp,
                    dwTotalSize - dwFixedSizeApp
                    );

                if (pCallParamsSP->dwUserUserInfoOffset)
                {
                    pCallParamsSP->dwUserUserInfoOffset += dwFixedSizeDiff;
                }

                if (pCallParamsSP->dwHighLevelCompOffset)
                {
                    pCallParamsSP->dwHighLevelCompOffset += dwFixedSizeDiff;
                }

                if (pCallParamsSP->dwLowLevelCompOffset)
                {
                    pCallParamsSP->dwLowLevelCompOffset += dwFixedSizeDiff;
                }

                if (pCallParamsSP->dwDevSpecificOffset)
                {
                    pCallParamsSP->dwDevSpecificOffset += dwFixedSizeDiff;
                }

                if (dwAPIVersion >= TAPI_VERSION2_0)
                {
                    if (pCallParamsSP->dwSendingFlowspecOffset)
                    {
                        pCallParamsSP->dwSendingFlowspecOffset +=
                            dwFixedSizeDiff;
                    }

                    if (pCallParamsSP->dwReceivingFlowspecOffset)
                    {
                        pCallParamsSP->dwReceivingFlowspecOffset +=
                            dwFixedSizeDiff;
                    }

                    if (pCallParamsSP->dwDeviceConfigOffset)
                    {
                        pCallParamsSP->dwDeviceConfigOffset +=
                            dwFixedSizeDiff;
                    }

                    if (pCallParamsSP->dwCallDataOffset)
                    {
                        pCallParamsSP->dwCallDataOffset +=
                            dwFixedSizeDiff;
                    }
                }
            }
            else
            {
                CopyMemory (pCallParamsSP, pCallParamsApp, dwTotalSize);
            }

            pCallParamsSP->dwTotalSize = dwTotalSize + dwFixedSizeDiff +
                2*dwAsciiVarDataSize + 3;

            if (dwAsciiVarDataSize)
            {
                LPDWORD alpdwXxxSize[] =
                {
                    &pCallParamsSP->dwOrigAddressSize,
                    &pCallParamsSP->dwDisplayableAddressSize,
                    &pCallParamsSP->dwCalledPartySize,
                    &pCallParamsSP->dwCommentSize,
                    (dwAPIVersion > TAPI_VERSION1_4 ?
                        &pCallParamsSP->dwTargetAddressSize : NULL),
                    (dwAPIVersion > TAPI_VERSION1_4 ?
                        &pCallParamsSP->dwDeviceClassSize : NULL),
                    (dwAPIVersion > TAPI_VERSION1_4 ?
                        &pCallParamsSP->dwCallingPartyIDSize : NULL),
                    NULL
                };

                // align dwXxxOffset
                DWORD   i, dwXxxOffset = (dwTotalSize + dwFixedSizeDiff + 3) &
                                         0xFFFFFFFC;


                for (i = 0; alpdwXxxSize[i]; i++)
                {
                    if (*alpdwXxxSize[i] != 0)
                    {
                        MultiByteToWideChar(
                            (UINT) dwAsciiCallParamsCodePage,
                            MB_PRECOMPOSED,
                            (LPCSTR) (((LPBYTE) pCallParamsApp) +
                                *(alpdwXxxSize[i] + 1)), // dwXxxOffset
                            *alpdwXxxSize[i],
                            (LPWSTR) (((LPBYTE) pCallParamsSP) + dwXxxOffset),
                            *alpdwXxxSize[i] * 2
                            );

                        *(alpdwXxxSize[i] + 1) = dwXxxOffset;
                        *alpdwXxxSize[i] *= 2;
                        dwXxxOffset += *alpdwXxxSize[i];
                    }
                }
            }

            *ppCallParamsSP = pCallParamsSP;
        }
        else
        {
            *ppCallParamsSP = pCallParamsApp;
        }
    }

    return 0; // success
}


void
PASCAL
InsertVarData(
    LPVOID      lpXxx,
    LPDWORD     pdwXxxSize,
    LPVOID     *pData,
    DWORD       dwDataSize
    )
{
    DWORD       dwAlignedSize, dwUsedSize;
    LPVARSTRING lpVarString = (LPVARSTRING) lpXxx;


    if (dwDataSize != 0)
    {
        //
        // Align var data on 64-bit boundaries
        //

        if ((dwAlignedSize = dwDataSize) & 7)
        {
            dwAlignedSize += 8;
            dwAlignedSize &= 0xfffffff8;

        }


        //
        // The following if statement should only be TRUE the first time
        // we're inserting data into a given structure that does not have
        // an even number of DWORD fields
        //

        if ((dwUsedSize = lpVarString->dwUsedSize) & 7)
        {
            dwUsedSize += 8;
            dwUsedSize &= 0xfffffff8;

            lpVarString->dwNeededSize += dwUsedSize - lpVarString->dwUsedSize;
        }

        lpVarString->dwNeededSize += dwAlignedSize;

        if ((dwUsedSize + dwAlignedSize) <= lpVarString->dwTotalSize)
        {
            CopyMemory(
                ((LPBYTE) lpVarString) + dwUsedSize,
                pData,
                dwDataSize
                );

            *pdwXxxSize = dwDataSize;
            pdwXxxSize++;             // pdwXxxSize = pdwXxxOffset
            *pdwXxxSize = dwUsedSize;

            lpVarString->dwUsedSize = dwUsedSize + dwAlignedSize;
        }
    }
}


PTLINELOOKUPENTRY
GetLineLookupEntry(
    DWORD   dwDeviceID
    )
{
    DWORD               dwDeviceIDBase = 0;
    PTLINELOOKUPTABLE   pLookupTable = TapiGlobals.pLineLookup;


    if (dwDeviceID >= TapiGlobals.dwNumLines)
    {
        return ((PTLINELOOKUPENTRY) NULL);
    }

    while (pLookupTable)
    {
        if (dwDeviceID < pLookupTable->dwNumTotalEntries)
        {
            return (pLookupTable->aEntries + dwDeviceID);
        }

        dwDeviceID -= pLookupTable->dwNumTotalEntries;

        pLookupTable = pLookupTable->pNext;
    }

    return ((PTLINELOOKUPENTRY) NULL);
}


BOOL
PASCAL
IsValidLineExtVersion(
    DWORD   dwDeviceID,
    DWORD   dwExtVersion
    )
{
    BOOL                bResult;
    PTLINE              ptLine;
    PTPROVIDER          ptProvider;
    PTLINELOOKUPENTRY   pLookupEntry;


    if (dwExtVersion == 0)
    {
        return TRUE;
    }

    if (!(pLookupEntry = GetLineLookupEntry (dwDeviceID)))
    {
        return FALSE;
    }

    ptLine = pLookupEntry->ptLine;

    if (ptLine)
    {
        try
        {
            if (ptLine->dwExtVersionCount)
            {
                bResult = (dwExtVersion == ptLine->dwExtVersion ?
                    TRUE : FALSE);

                if (ptLine->dwKey == TLINE_KEY)
                {
                    goto IsValidLineExtVersion_return;
                }
            }
        }
        myexcept
        {
            //
            // if here the line was closed, just drop thru to the code below
            //
        }
    }

    ptProvider = pLookupEntry->ptProvider;

    if (ptProvider->apfn[SP_LINENEGOTIATEEXTVERSION])
    {
        LONG    lResult;
        DWORD   dwNegotiatedExtVersion;


        lResult = CallSP5(
            ptProvider->apfn[SP_LINENEGOTIATEEXTVERSION],
            "lineNegotiateExtVersion",
            SP_FUNC_SYNC,
            (DWORD) dwDeviceID,
            (DWORD) pLookupEntry->dwSPIVersion,
            (DWORD) dwExtVersion,
            (DWORD) dwExtVersion,
            (ULONG_PTR) &dwNegotiatedExtVersion
            );

        bResult = ((lResult || !dwNegotiatedExtVersion) ? FALSE : TRUE);
    }
    else
    {
        bResult = FALSE;
    }

IsValidLineExtVersion_return:

    return bResult;
}


PTCALLCLIENT
PASCAL
ReferenceCall(
    HCALL       hCall,
    PTCLIENT    ptClient
    )
{
    PTCALLCLIENT    ptCallClient;


    if ((ptCallClient = ReferenceObject(
            ghHandleTable,
            hCall,
            TCALLCLIENT_KEY
            )))
    {
        if (ptCallClient->ptClient != ptClient)
        {
            DereferenceObject (ghHandleTable, hCall, 1);
            ptCallClient = NULL;
        }
    }

    return ptCallClient;
}


PTCALLHUBCLIENT
PASCAL
IsValidCallHub(
    HCALLHUB    hCallHub,
    PTCLIENT    ptClient
    )
{
    PTCALLHUBCLIENT     ptCallHubClient = NULL;
    if (hCallHub == 0)
    {
        goto ExitHere;
    }

    try
    {
        ptCallHubClient = ReferenceObject (
                            ghHandleTable, 
                            hCallHub, 
                            TCALLHUBCLIENT_KEY);
        if (ptCallHubClient)
        {
            if ((ptCallHubClient->ptClient != ptClient) ||
                 (ptCallHubClient->hCallHub != hCallHub))
            {
                ptCallHubClient = NULL;
            }
            DereferenceObject(ghHandleTable, hCallHub, 1);
        }
    }
    myexcept
    {
    }

ExitHere:
    return ptCallHubClient;
}


PTLINEAPP
PASCAL
IsValidLineApp(
    HLINEAPP    hLineApp,
    PTCLIENT    ptClient
    )
{
    PTLINEAPP   ptLineApp;


    if ((ptLineApp = ReferenceObject (ghHandleTable, hLineApp, TLINEAPP_KEY)))
    {
        if (ptLineApp->ptClient != ptClient)
        {
            ptLineApp = NULL;
        }

        DereferenceObject (ghHandleTable, hLineApp, 1);
    }

    return ptLineApp;
}


BOOL
PASCAL
WaitForExclusivetCallAccess(
    PTCALL  ptCall,
    DWORD   dwKey
    )
{
    //
    // Retrieve the call instance & check the key to make sure it's
    // really a tCall object, then wait for exclusive access, then
    // reverify the key and the call instance (it's possible the tCall
    // object might have been freed & reallocated while we were waiting,
    // in which case it will have come back to life with a different
    // dwCallInstance value)
    //

    BOOL bUnlock = FALSE;


    try
    {
        HCALL   hCall = ptCall->hCall;


        if (ptCall->dwKey == dwKey)
        {
            LOCKTCALL (ptCall);

            bUnlock = TRUE;

            if (ptCall->dwKey == dwKey  &&
                ptCall->hCall == hCall)
            {
                return TRUE;
            }
        }
    }
    myexcept
    {
        // just fall thru
    }

    if (bUnlock)
    {
        UNLOCKTCALL (ptCall);
    }

    return FALSE;
}


BOOL
PASCAL
WaitForExclusivetLineAccess(
    PTLINE      ptLine,
    HANDLE     *phMutex,
    BOOL       *pbDupedMutex,
    DWORD       dwTimeout
    )
{
    BOOL    bResult = FALSE;


    try
    {
        if (ptLine->dwKey == TLINE_KEY  &&

            WaitForMutex(
                ptLine->hMutex,
                phMutex,
                pbDupedMutex,
                (LPVOID) ptLine,
                TLINE_KEY,
                dwTimeout
                ))
        {
            if (ptLine->dwKey == TLINE_KEY)
            {
                bResult = TRUE;
            }
            else
            {
                MyReleaseMutex (*phMutex, *pbDupedMutex);
            }
        }
    }
    myexcept
    {
        // do nothing
    }

    return bResult;
}


BOOL
PASCAL
WaitForExclusiveLineClientAccess(
    PTLINECLIENT    ptLineClient
    )
{
    //
    // Assumes ptXxxClient->hXxx has already been referenced,
    // so we can safely access ptXxxClient
    //

    LOCKTLINECLIENT (ptLineClient);

    if (ptLineClient->dwKey == TLINECLIENT_KEY)
    {
        return TRUE;
    }

    UNLOCKTLINECLIENT (ptLineClient);

    return FALSE;
}


PTLINEAPP
PASCAL
WaitForExclusiveLineAppAccess(
    HLINEAPP    hLineApp,
    PTCLIENT    ptClient
    )
{
    PTLINEAPP   ptLineApp;


    if (!(ptLineApp = ReferenceObject(
            ghHandleTable,
            hLineApp,
            TLINEAPP_KEY
            )))
    {
        return NULL;
    }

    LOCKTLINEAPP (ptLineApp);

    if ((ptLineApp->dwKey != TLINEAPP_KEY)  ||
        (ptLineApp->ptClient != ptClient))
    {

        UNLOCKTLINEAPP (ptLineApp);

        ptLineApp = NULL;
    }

    DereferenceObject (ghHandleTable, hLineApp, 1);

    return ptLineApp;
}


PTCLIENT
PASCAL
WaitForExclusiveClientAccess(
    PTCLIENT    ptClient
    )
{
    LOCKTCLIENT (ptClient);

    try
    {
        if (ptClient->dwKey == TCLIENT_KEY)
        {
            return (ptClient);
        }
    }
    myexcept
    {
    }

    UNLOCKTCLIENT (ptClient);

    return NULL;
}


LONG
PASCAL
FindProxy(
    PTLINECLIENT    ptLineClient,
    DWORD           dwAddressID,
    DWORD           dwRequestType,
    PTLINECLIENT   *ppProxy,
    LPDWORD         lpdwDeviceID,
    DWORD           dwMinAPIVersion
    )
{
    LONG    lResult;
    PTLINE  ptLine;

    try
    {
        if (ptLineClient->ptLineApp->dwAPIVersion >= dwMinAPIVersion)
        {
            ptLine = ptLineClient->ptLine;
            *ppProxy = ptLine->apProxys[dwRequestType];
            *lpdwDeviceID = ptLine->dwDeviceID;

            if (dwAddressID >= ptLine->dwNumAddresses)
            {
                lResult = LINEERR_INVALADDRESSID;
            }
            else if (ptLine->dwKey != TLINE_KEY)
            {
                lResult = LINEERR_INVALLINEHANDLE;
            }
            else
            {
                lResult = 0;
            }
        }
        else
        {
            lResult = LINEERR_INCOMPATIBLEAPIVERSION;
        }
    }
    myexcept
    {
        lResult = LINEERR_OPERATIONUNAVAIL;
    }

    return lResult;
}


LONG
PASCAL
CreateProxyRequest(
    PTLINECLIENT            pProxy,
    DWORD                   dwRequestType,
    DWORD                   dwExtraBytes,
    PASYNCREQUESTINFO       pAsyncReqInfo,
    PPROXYREQUESTWRAPPER   *ppWrapper
    )
{
    HLINE                   hLine;
    DWORD                   dwSize, dwComputerNameSize, dwUserNameSize;
    PTCLIENT                ptClient = pAsyncReqInfo->ptClient;
    DWORD                   initContext, openContext;
    PPROXYREQUESTWRAPPER    pWrapper;


    LOG((TL_TRACE,  "CreateProxyRequest: enter..."));
    
    //
    // Safely get info from the proxy, then make sure it's still valid
    // if the proxy is refusing LINE_PROXYREQUEST msg, return failure
    //

    try
    {
        hLine       = pProxy->hLine;
        initContext = pProxy->ptLineApp->InitContext;
        openContext = pProxy->OpenContext;

        if (pProxy->dwKey != TLINECLIENT_KEY ||
            (FMsgDisabled(
                pProxy->ptLineApp->dwAPIVersion,
                pProxy->adwEventSubMasks,
                LINE_PROXYREQUEST,
                0)))
        {
            return LINEERR_OPERATIONUNAVAIL;
        }
    }
    myexcept
    {
        return LINEERR_OPERATIONUNAVAIL;
    }

    dwComputerNameSize = (ptClient->dwComputerNameSize + TALIGN_COUNT) & TALIGN_MASK;
    dwUserNameSize     = (ptClient->dwUserNameSize + TALIGN_COUNT) & TALIGN_MASK;


    //
    // Calculate, alloc, & initalize a PROXYREQUESTWRAPPER struct.  At the
    // head of this struct is the msg info for the LINE_PROXYREQUEST,
    // followed by the actual request data.
    //

    dwSize =
        (sizeof (ASYNCEVENTMSG) +   // LINE_PROXYREQUEST msg info
        7 * sizeof (DWORD) +        // Non-union fields in LINEPROXYREQUEST
        dwExtraBytes +              // Request-specific size
        dwUserNameSize +            // User name size
        dwComputerNameSize +        // Computer name size
        TALIGN_COUNT) & TALIGN_MASK;// make sure size is a ULONG_PTR multiple
                                    //   so our lstrcpyW's below don't fault
                                    //   and so that when this msg eventually
                                    //   gets copied to some client's async
                                    //   event buf we don't start running into
                                    //   alignment problems (the msgs's
                                    //   TotalSize field must be ULONG_PTR-
                                    //   aligned)

    if (!(pWrapper = ServerAlloc (dwSize)))
    {
        return LINEERR_NOMEM;
    }

    pWrapper->AsyncEventMsg.TotalSize            = dwSize;
    pWrapper->AsyncEventMsg.InitContext          = initContext;
    //pWrapper->AsyncEventMsg.hfnPostProcessProc =
    pWrapper->AsyncEventMsg.hDevice              = pProxy->hLine;
    pWrapper->AsyncEventMsg.Msg                  = LINE_PROXYREQUEST;
    pWrapper->AsyncEventMsg.OpenContext          = openContext;
    pWrapper->AsyncEventMsg.Param1               =
        pAsyncReqInfo->dwLocalRequestID;
    //pWrapper->AsyncEventMsg.Param2           =
    //pWrapper->AsyncEventMsg.Param3           =
    //pWrapper->AsyncEventMsg.Param4           =

    dwSize -= sizeof (ASYNCEVENTMSG);

    pWrapper->ProxyRequest.dwSize = dwSize;

    pWrapper->ProxyRequest.dwClientMachineNameSize   = ptClient->dwComputerNameSize;
    pWrapper->ProxyRequest.dwClientMachineNameOffset =
        dwSize - dwComputerNameSize;

    if (NULL != ptClient->pszComputerName)
    {
        wcscpy(
            (PWSTR)((LPBYTE) &pWrapper->ProxyRequest +
                pWrapper->ProxyRequest.dwClientMachineNameOffset),
            ptClient->pszComputerName
            );
    }

    pWrapper->ProxyRequest.dwClientUserNameSize   = ptClient->dwUserNameSize;
    pWrapper->ProxyRequest.dwClientUserNameOffset =
        (dwSize - dwComputerNameSize) - dwUserNameSize;

    if (NULL != ptClient->pszUserName)
    {
        wcscpy(
            (PWSTR)((LPBYTE) &pWrapper->ProxyRequest +
                pWrapper->ProxyRequest.dwClientUserNameOffset),
            ptClient->pszUserName
            );
    }

    pWrapper->ProxyRequest.dwClientAppAPIVersion = 0;
    pWrapper->ProxyRequest.dwRequestType = dwRequestType;

    *ppWrapper = pWrapper;


    //
    // Change the AsyncRequestInfo struct's key value to be ==
    // the proxy's hLine, so we can verify when app calls
    // lineProxyResponse
    //

    pAsyncReqInfo->dwKey = hLine;

    return 0;
}


LONG
PASCAL
SendProxyRequest(
    PTLINECLIENT            pProxy,
    PPROXYREQUESTWRAPPER    pWrapper,
    PASYNCREQUESTINFO       pAsyncRequestInfo
    )
{
    LONG    lResult;
    BOOL    bUnlock = FALSE;


    //
    // Add the request to the proxy's list, then send it the request.
    // Since the proxy (tLineClient) could get closed at any time we
    // wrap the following in a try/except.
    //
    // Note: the AsyncReqInfo.dwParam4 & dwParam5 fields are used as
    // the prev & next pointers for maintaining the list of proxy
    // requests pending on tLineClient.
    //

    try
    {
        if (WaitForExclusiveLineClientAccess (pProxy))
        {
            bUnlock = TRUE;

            if ((pAsyncRequestInfo->dwParam5 = (ULONG_PTR)
                    pProxy->pPendingProxyRequests))
            {
                ((PASYNCREQUESTINFO) pAsyncRequestInfo->dwParam5)->dwParam4 =
                     (ULONG_PTR) pAsyncRequestInfo;
            }

            pProxy->pPendingProxyRequests = pAsyncRequestInfo;

            UNLOCKTLINECLIENT (pProxy);

            bUnlock = FALSE;

            WriteEventBuffer (pProxy->ptClient, (PASYNCEVENTMSG) pWrapper);

            lResult = 0;
        }
        else
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
        }
    }
    myexcept
    {
        lResult = LINEERR_OPERATIONUNAVAIL;
    }

    if (bUnlock)
    {
        UNLOCKTLINECLIENT (pProxy);
    }

    ServerFree (pWrapper);

    return lResult;
}


BOOL
PASCAL
NotifyHighestPriorityRequestRecipient(
    void
    )
{
    //
    // Send a LINE_REQUEST msg to the highest priority request recipient
    // to inform it that there are requests available for processing
    //

    PTLINEAPP       ptLineApp;
    ASYNCEVENTMSG   msg;

    LOG((TL_TRACE,  "NotifyHighestPriorityRequestRecipient: enter..."));

    EnterCriticalSection (&gPriorityListCritSec);

        ptLineApp = TapiGlobals.pHighestPriorityRequestRecipient->ptLineApp;

        msg.TotalSize          = sizeof (ASYNCEVENTMSG);
        msg.InitContext        = ptLineApp->InitContext;
    
        msg.fnPostProcessProcHandle = 0;
    
        msg.hDevice            = 0;
        msg.Msg                = LINE_REQUEST;
        msg.OpenContext        =
            (TapiGlobals.pHighestPriorityRequestRecipient->dwRegistrationInstance);
        msg.Param1             = LINEREQUESTMODE_MAKECALL;
        msg.Param2             =
        msg.Param3             = 0;

        WriteEventBuffer (ptLineApp->ptClient, &msg);

    LeaveCriticalSection (&gPriorityListCritSec);

    LOG((TL_TRACE,  "NotifyHighestPriorityRequestRecipient: finished."));

    return TRUE;
}


void
SetDrvCallFlags(
    PTCALL      ptCall,
    DWORD       dwDrvCallFlags
    )
{
    //
    // This func is called on return from TSPI_lineMakeCall (and other
    // TSPI_lineXxx funcs where calls are created) and sets the
    // dwDrvCallFlags field in the tCall as specified.  This keeps
    // another thread which is currently doing a DestroytCall on this
    // call from passing an invalid hdCall to the provider when
    // doing a TSPI_lineCloseCall.
    //
    //

    LOCKTCALL (ptCall);

    try
    {
        if ((ptCall->dwKey == TINCOMPLETECALL_KEY) ||
            (ptCall->dwKey == TCALL_KEY) ||
            (ptCall->dwKey == TZOMBIECALL_KEY))
        {
            // only set the loword

            ptCall->dwDrvCallFlags = MAKELONG(LOWORD(dwDrvCallFlags),
                HIWORD(ptCall->dwDrvCallFlags));
        }
    }
    myexcept
    {
    }

    UNLOCKTCALL (ptCall);
}


LONG
PASCAL
SetCallConfList(
    PTCALL              ptCall,
    PTCONFERENCELIST    pConfList,
    BOOL                bAddToConfPostProcess
    )
{
    LONG    lResult;
    BOOL    bAddToConfList = FALSE;


    if (WaitForExclusivetCallAccess (ptCall, TCALL_KEY))
    {
        if (pConfList)
        {
            if (ptCall->pConfList && !bAddToConfPostProcess)
            {
                lResult = LINEERR_INVALCALLHANDLE;
            }
            else
            {
                ptCall->pConfList = pConfList;
                lResult = 0;
                bAddToConfList = TRUE;
            }
        }
        else
        {
            if (ptCall->pConfList)
            {
                pConfList = ptCall->pConfList;
                ptCall->pConfList = NULL;
                lResult = 0;
            }
            else
            {
                lResult = LINEERR_INVALCALLHANDLE;
            }
        }

        UNLOCKTCALL (ptCall);
    }
    else
    {
        lResult = LINEERR_INVALCALLHANDLE;
    }

    if (pConfList &&
        (pConfList != (PTCONFERENCELIST) LongToPtr(0xffffffff) ) &&
        (lResult == 0))
    {
        if (bAddToConfList)
        {
             while (pConfList->dwNumUsedEntries >=
                     pConfList->dwNumTotalEntries)
             {
                 if (pConfList->pNext)
                 {
                     pConfList = pConfList->pNext;
                 }
                 else
                 {
                    DWORD               dwSize;
                    PTCONFERENCELIST    pNewConfList;


                    dwSize = sizeof (TCONFERENCELIST) +  sizeof (PTCALL) *
                         (2 * pConfList->dwNumTotalEntries - 1);

                    if (!(pNewConfList = ServerAlloc (dwSize)))
                    {
                         ptCall->pConfList = NULL;
                         return LINEERR_NOMEM;
                    }

                    pNewConfList->dwNumTotalEntries =
                        2 * pConfList->dwNumTotalEntries;

                    pConfList->pNext = pNewConfList;

                    pConfList = pNewConfList;
                }
            }

            pConfList->aptCalls[pConfList->dwNumUsedEntries++] = ptCall;
        }
        else
        {
            while (pConfList)
            {
                DWORD   i, dwNumUsedEntries = pConfList->dwNumUsedEntries;
                PTCALL *pptCall = pConfList->aptCalls;


                for (i = 0; i < dwNumUsedEntries; i++)
                {
                    if (pConfList->aptCalls[i] == ptCall)
                    {
                        //
                        // Found the call in the list, shuffle all the
                        // following calls in list down by 1 to maintain
                        // continuity
                        //

                        for (; i < (dwNumUsedEntries - 1); i++)
                        {
                            pConfList->aptCalls[i] = pConfList->aptCalls[i+1];
                        }

                        pConfList->dwNumUsedEntries--;

                        pConfList = NULL;

                        break;
                    }

                    pptCall++;
                }

                if (pConfList)
                {
                    pConfList = pConfList->pNext;
                }
            }
        }
    }

    return lResult;
}


LONG
PASCAL
RemoveCallFromLineList(
    PTCALL  ptCall
    )
{
    PTLINE ptLine = (PTLINE) ptCall->ptLine;


    WaitForSingleObject (ptLine->hMutex, INFINITE);

    if (ptCall->pNext)
    {
        ptCall->pNext->pPrev = ptCall->pPrev;
    }

    if (ptCall->pPrev)
    {
        ptCall->pPrev->pNext = ptCall->pNext;
    }
    else
    {
        ptLine->ptCalls = ptCall->pNext;
    }

    ReleaseMutex (ptLine->hMutex);

    return 0;
}


LONG
PASCAL
RemoveCallClientFromLineClientList(
    PTCALLCLIENT    ptCallClient
    )
{
    PTLINECLIENT    ptLineClient = ptCallClient->ptLineClient;


    LOCKTLINECLIENT (ptLineClient);

    if (ptCallClient->pNextSametLineClient)
    {
        ptCallClient->pNextSametLineClient->pPrevSametLineClient =
            ptCallClient->pPrevSametLineClient;
    }

    if (ptCallClient->pPrevSametLineClient)
    {
        ptCallClient->pPrevSametLineClient->pNextSametLineClient =
            ptCallClient->pNextSametLineClient;
    }
    else
    {
        ptLineClient->ptCallClients = ptCallClient->pNextSametLineClient;
    }

    UNLOCKTLINECLIENT (ptLineClient);

    return 0;
}


LONG
PASCAL
GetConfCallListFromConf(
    PTCONFERENCELIST    pConfList,
    PTPOINTERLIST      *ppList
    )
{
    DWORD           dwNumTotalEntries = DEF_NUM_PTR_LIST_ENTRIES,
                    dwNumUsedEntries = 0, i;
    PTPOINTERLIST   pList = *ppList;

    while (pConfList)
    {
        if ((dwNumUsedEntries + pConfList->dwNumUsedEntries) >
                dwNumTotalEntries)
        {
            //
            // We need a larger list, so alloc a new one, copy the
            // contents of the current one, and the free the current
            // one iff we previously alloc'd it
            //

            PTPOINTERLIST   pNewList;


            do
            {
                dwNumTotalEntries <<= 1;

            } while ((dwNumUsedEntries + pConfList->dwNumUsedEntries) >
                        dwNumTotalEntries);

            if (!(pNewList = ServerAlloc(
                    sizeof (TPOINTERLIST) + sizeof (LPVOID) *
                        (dwNumTotalEntries - DEF_NUM_PTR_LIST_ENTRIES)
                    )))
            {
                return LINEERR_NOMEM;
            }

            CopyMemory(
                pNewList->aEntries,
                pList->aEntries,
                dwNumUsedEntries * sizeof (LPVOID)
                );

            if (pList != *ppList)
            {
                ServerFree (pList);
            }

            pList = pNewList;
        }

        for (i = 0; i < pConfList->dwNumUsedEntries; i++)
        {
            pList->aEntries[dwNumUsedEntries++] = pConfList->aptCalls[i];
        }

        pConfList = pConfList->pNext;
    }

    pList->dwNumUsedEntries = dwNumUsedEntries;

    *ppList = pList;

    return 0;
}


LONG
PASCAL
GetList(
    LIST_ENTRY     *pListHead,
    PTPOINTERLIST  *ppList
    )
{
    DWORD           dwNumTotalEntries = DEF_NUM_PTR_LIST_ENTRIES,
                    dwNumUsedEntries = 0;
    PTPOINTERLIST   pList = *ppList;
    LIST_ENTRY     *pEntry;


    pEntry = pListHead->Flink;

    while (pEntry != pListHead)
    {
        if (dwNumUsedEntries == dwNumTotalEntries)
        {
            //
            // We need a larger list, so alloc a new one, copy the
            // contents of the current one, and the free the current
            // one iff we previously alloc'd it
            //

            PTPOINTERLIST   pNewList;


            dwNumTotalEntries <<= 1;

            if (!(pNewList = ServerAlloc(
                    sizeof (TPOINTERLIST) + sizeof (LPVOID) *
                        (dwNumTotalEntries - DEF_NUM_PTR_LIST_ENTRIES)
                    )))
            {
                return LINEERR_NOMEM;
            }

            CopyMemory(
                pNewList->aEntries,
                pList->aEntries,
                dwNumUsedEntries * sizeof (LPVOID)
                );

            if (pList != *ppList)
            {
                ServerFree (pList);
            }

            pList = pNewList;
        }

        pList->aEntries[dwNumUsedEntries++] = pEntry;

        pEntry = pEntry->Flink;
    }

    pList->dwNumUsedEntries = dwNumUsedEntries;

    *ppList = pList;

    return 0;
}


LONG
PASCAL
GetCallClientListFromCall(
    PTCALL          ptCall,
    PTPOINTERLIST  *ppList
    )
{
    if (WaitForExclusivetCallAccess (ptCall, TCALL_KEY))
    {
        DWORD           dwNumTotalEntries = DEF_NUM_PTR_LIST_ENTRIES,
                        dwNumUsedEntries = 0;
        PTPOINTERLIST   pList = *ppList;
        PTCALLCLIENT    ptCallClient = ptCall->ptCallClients;


        while (ptCallClient)
        {
            if (dwNumUsedEntries == dwNumTotalEntries)
            {
                //
                // We need a larger list, so alloc a new one, copy the
                // contents of the current one, and the free the current
                // one iff we previously alloc'd it
                //

                PTPOINTERLIST   pNewList;


                dwNumTotalEntries <<= 1;

                if (!(pNewList = ServerAlloc(
                        sizeof (TPOINTERLIST) + sizeof (LPVOID) *
                            (dwNumTotalEntries - DEF_NUM_PTR_LIST_ENTRIES)
                        )))
                {
                    UNLOCKTCALL (ptCall);
                    return LINEERR_NOMEM;
                }

                CopyMemory(
                    pNewList->aEntries,
                    pList->aEntries,
                    dwNumUsedEntries * sizeof (LPVOID)
                    );

                if (pList != *ppList)
                {
                    ServerFree (pList);
                }

                pList = pNewList;
            }

            pList->aEntries[dwNumUsedEntries++] = ptCallClient;

            ptCallClient = ptCallClient->pNextSametCall;
        }

        UNLOCKTCALL (ptCall);

        pList->dwNumUsedEntries = dwNumUsedEntries;

        *ppList = pList;
    }
    else
    {
        return LINEERR_INVALCALLHANDLE;
    }

    return 0;
}


LONG
PASCAL
GetCallListFromLine(
    PTLINE          ptLine,
    PTPOINTERLIST  *ppList
    )
{
    BOOL    bDupedMutex;
    HANDLE  hMutex;


    if (WaitForExclusivetLineAccess(
            ptLine,
            &hMutex,
            &bDupedMutex,
            INFINITE
            ))
    {
        DWORD           dwNumTotalEntries = DEF_NUM_PTR_LIST_ENTRIES,
                        dwNumUsedEntries = 0;
        PTCALL          ptCall = ptLine->ptCalls;
        PTPOINTERLIST   pList = *ppList;


        while (ptCall)
        {
            if (dwNumUsedEntries == dwNumTotalEntries)
            {
                //
                // We need a larger list, so alloc a new one, copy the
                // contents of the current one, and the free the current
                // one iff we previously alloc'd it
                //

                PTPOINTERLIST   pNewList;


                dwNumTotalEntries <<= 1;

                if (!(pNewList = ServerAlloc(
                        sizeof (TPOINTERLIST) + sizeof (LPVOID) *
                            (dwNumTotalEntries - DEF_NUM_PTR_LIST_ENTRIES)
                        )))
                {
                    MyReleaseMutex (hMutex, bDupedMutex);
                    return LINEERR_NOMEM;
                }

                CopyMemory(
                    pNewList->aEntries,
                    pList->aEntries,
                    dwNumUsedEntries * sizeof (LPVOID)
                    );

                if (pList != *ppList)
                {
                    ServerFree (pList);
                }

                pList = pNewList;
            }

            pList->aEntries[dwNumUsedEntries++] = ptCall;

            ptCall = ptCall->pNext;
        }

        MyReleaseMutex (hMutex, bDupedMutex);

        pList->dwNumUsedEntries = dwNumUsedEntries;

        *ppList = pList;
    }
    else
    {
        LOG((TL_TRACE,  "GetCallListFromLine: inval ptLine=x%p", ptLine));
        return LINEERR_INVALLINEHANDLE;
    }

    return 0;
}


LONG
PASCAL
GetLineClientListFromLine(
    PTLINE          ptLine,
    PTPOINTERLIST  *ppList
    )
{
    BOOL    bDupedMutex;
    HANDLE  hMutex;


    if (WaitForExclusivetLineAccess(
            ptLine,
            &hMutex,
            &bDupedMutex,
            INFINITE
            ))
    {
        DWORD           dwNumTotalEntries = DEF_NUM_PTR_LIST_ENTRIES,
                        dwNumUsedEntries = 0;
        PTPOINTERLIST   pList = *ppList;
        PTLINECLIENT    ptLineClient = ptLine->ptLineClients;


        while (ptLineClient)
        {
            if (dwNumUsedEntries == dwNumTotalEntries)
            {
                //
                // We need a larger list, so alloc a new one, copy the
                // contents of the current one, and the free the current
                // one iff we previously alloc'd it
                //

                PTPOINTERLIST   pNewList;


                dwNumTotalEntries <<= 1;

                if (!(pNewList = ServerAlloc(
                        sizeof (TPOINTERLIST) + sizeof (LPVOID) *
                            (dwNumTotalEntries - DEF_NUM_PTR_LIST_ENTRIES)
                        )))
                {
                    MyReleaseMutex (hMutex, bDupedMutex);
                    return LINEERR_NOMEM;
                }

                CopyMemory(
                    pNewList->aEntries,
                    pList->aEntries,
                    dwNumUsedEntries * sizeof (LPVOID)
                    );

                if (pList != *ppList)
                {
                    ServerFree (pList);
                }

                pList = pNewList;
            }

            pList->aEntries[dwNumUsedEntries++] = ptLineClient;

            ptLineClient = ptLineClient->pNextSametLine;
        }

        MyReleaseMutex (hMutex, bDupedMutex);

        pList->dwNumUsedEntries = dwNumUsedEntries;

        *ppList = pList;
    }
    else
    {
        LOG((TL_ERROR, "GetLineClientListFromLine: inval ptLine=x%p", ptLine));
        return LINEERR_INVALLINEHANDLE;
    }

    return 0;
}


LONG
PASCAL
GetLineAppListFromClient(
    PTCLIENT        ptClient,
    PTPOINTERLIST  *ppList
    )
{
    if (WaitForExclusiveClientAccess (ptClient))
    {
        DWORD           dwNumTotalEntries = DEF_NUM_PTR_LIST_ENTRIES,
                        dwNumUsedEntries = 0;
        PTLINEAPP       ptLineApp = ptClient->ptLineApps;
        PTPOINTERLIST   pList = *ppList;


        while (ptLineApp)
        {
            if (dwNumUsedEntries == dwNumTotalEntries)
            {
                //
                // We need a larger list, so alloc a new one, copy the
                // contents of the current one, and the free the current
                // one iff we previously alloc'd it
                //

                PTPOINTERLIST   pNewList;


                dwNumTotalEntries <<= 1;

                if (!(pNewList = ServerAlloc(
                        sizeof (TPOINTERLIST) + sizeof (LPVOID) *
                            (dwNumTotalEntries - DEF_NUM_PTR_LIST_ENTRIES)
                        )))
                {
                    UNLOCKTCLIENT (ptClient);
                    return LINEERR_NOMEM;
                }

                CopyMemory(
                    pNewList->aEntries,
                    pList->aEntries,
                    dwNumUsedEntries * sizeof (LPVOID)
                    );

                if (pList != *ppList)
                {
                    ServerFree (pList);
                }

                pList = pNewList;
            }

            pList->aEntries[dwNumUsedEntries++] = ptLineApp;

            ptLineApp = ptLineApp->pNext;
        }

        UNLOCKTCLIENT (ptClient);

        pList->dwNumUsedEntries = dwNumUsedEntries;

        *ppList = pList;
    }
    else
    {
        return LINEERR_OPERATIONFAILED;
    }

    return 0;
}


LONG
PASCAL
GetClientList(
    BOOL            bAdminOnly,
    PTPOINTERLIST   *ppList
    )
{
    DWORD           dwNumTotalEntries = DEF_NUM_PTR_LIST_ENTRIES,
                    dwNumUsedEntries = 0;
    PTPOINTERLIST   pList = *ppList;
    PTCLIENT        ptClient;


    TapiEnterCriticalSection (&TapiGlobals.CritSec);

    ptClient = TapiGlobals.ptClients;
    while (ptClient)
    {
        if (!bAdminOnly || IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR))
        {
            if (dwNumUsedEntries == dwNumTotalEntries)
            {
                //
                // We need a larger list, so alloc a new one, copy the
                // contents of the current one, and the free the current
                // one iff we previously alloc'd it
                //
                PTPOINTERLIST   pNewList;

                dwNumTotalEntries <<= 1;

                if (!(pNewList = ServerAlloc(
                        sizeof (TPOINTERLIST) + sizeof (LPVOID) *
                        (dwNumTotalEntries - DEF_NUM_PTR_LIST_ENTRIES)
                    )))
                {
                    TapiLeaveCriticalSection (&TapiGlobals.CritSec);
                    return LINEERR_NOMEM;
                }

                CopyMemory(
                    pNewList->aEntries,
                    pList->aEntries,
                    dwNumUsedEntries * sizeof (LPVOID)
                    );

                if (pList != *ppList)
                {
                    ServerFree (pList);
                }

                pList = pNewList;
            }

            pList->aEntries[dwNumUsedEntries++] = ptClient;
        }
        ptClient = ptClient->pNext;
    }

    TapiLeaveCriticalSection (&TapiGlobals.CritSec);
    pList->dwNumUsedEntries = dwNumUsedEntries;
    *ppList = pList;
    return 0;
}

void
PASCAL
SendMsgToCallClients(
    PTCALL          ptCall,
    PTCALLCLIENT    ptCallClientToExclude,
    DWORD           Msg,
/*
    ULONG_PTR       Param1,
    ULONG_PTR       Param2,
    ULONG_PTR       Param3 */
    DWORD           Param1,
    DWORD           Param2,
    DWORD           Param3

    )
{
    DWORD           i;
    TPOINTERLIST    clientList, *pClientList = &clientList;
    ASYNCEVENTMSG   msg[2];


    if (GetCallClientListFromCall (ptCall, &pClientList) != 0)
    {
        return;
    }

    msg->TotalSize          = sizeof (ASYNCEVENTMSG) + sizeof (HCALLHUB);
    msg->fnPostProcessProcHandle = 0;
    msg->Msg                = Msg;
    msg->Param1             = Param1;
    msg->Param2             = Param2;
    msg->Param3             = Param3;

    for (i = 0; i < pClientList->dwNumUsedEntries; i++)
    {
        try
        {
            PTCLIENT        ptClient;
            PTCALLCLIENT    ptCallClient = pClientList->aEntries[i];
            PTLINECLIENT    ptLineClient = ptCallClient->ptLineClient;


            if (ptCallClient == ptCallClientToExclude)
            {
                continue;
            }

            if (Msg == LINE_MONITORDIGITS)
            {
                if ((ptCallClient->dwMonitorDigitModes & Param2) == 0)
                {
                    continue;
                }
            }
            else if (Msg == LINE_MONITORMEDIA)
            {
                // ULONG_PTR   mediaModes = Param1;
                DWORD   mediaModes = Param1;


                //
                // Munge the media modes so we don't pass unexpected flags
                // to old apps
                //

                if (ptLineClient->dwAPIVersion == TAPI_VERSION1_0)
                {
                    if ((mediaModes & ~AllMediaModes1_0))
                    {
                        mediaModes = (mediaModes & AllMediaModes1_0) |
                            LINEMEDIAMODE_UNKNOWN;
                    }
                }

                if (ptCallClient->dwMonitorMediaModes & mediaModes)
                {
                    msg->Param1 = mediaModes;
                }
                else
                {
                    continue;
                }
            }
            else if (Msg == LINE_MONITORTONE)
            {
                if (!ptCallClient->bMonitoringTones)
                {
                    continue;
                }
            }
            else if (FMsgDisabled(
                ptCallClient->ptLineClient->ptLineApp->dwAPIVersion,
                ptCallClient->adwEventSubMasks,
                (DWORD) Msg,
                (DWORD) Param1
                ))
            {
                continue;
            }

            msg->InitContext = ptLineClient->ptLineApp->InitContext;
            msg->hDevice     = ptCallClient->hCall;
            msg->OpenContext = ptLineClient->OpenContext;

            //
            // Indicate the hRemoteLine in p4 to make life easier for remotesp
            //

            msg->Param4 = ptLineClient->hRemoteLine;

            *((LPHCALLHUB)(&msg->Param4 + 1)) = 
                        (ptCallClient->ptCallHubClient)?
                            ptCallClient->ptCallHubClient->hCallHub : 
                            (HCALLHUB)0;

            ptClient = ptLineClient->ptClient;

            if (ptCallClient->dwKey == TCALLCLIENT_KEY)
            {
                WriteEventBuffer (ptClient, msg);
            }
        }
        myexcept
        {
            // just continue
        }
    }

    if (pClientList != &clientList)
    {
        ServerFree (pClientList);
    }
}


void
PASCAL
SendBufferMsgToCallClients(
    PTCALL          ptCall,
    PTCALLCLIENT    ptCallClientToExclude,
    DWORD           Msg,
    DWORD           Param1,
    DWORD           Size,
    LPBYTE          pBuffer
    )
{
    DWORD           i;
    TPOINTERLIST    clientList, *pClientList = &clientList;
    PASYNCEVENTMSG  pmsg;


    DWORD           dwTotalSize =
                        (sizeof (ASYNCEVENTMSG) + (DWORD) Size +
                            TALIGN_COUNT) & TALIGN_MASK;

    if (!(pmsg = (ASYNCEVENTMSG *) ServerAlloc (dwTotalSize)))
    {
        return;
    }

    if (GetCallClientListFromCall (ptCall, &pClientList) != 0)
    {
        ServerFree( pmsg );
        return;
    }

    pmsg->TotalSize        = dwTotalSize;
    pmsg->fnPostProcessProcHandle = 0;
    pmsg->Msg              = Msg;
    pmsg->Param2           = Size;
    pmsg->Param3           = 0;

    CopyMemory ((PBYTE)(pmsg+1), pBuffer, Size);

    for (i = 0; i < pClientList->dwNumUsedEntries; i++)
    {
        try
        {
            PTCLIENT        ptClient;
            PTCALLCLIENT    ptCallClient = pClientList->aEntries[i];
            PTLINECLIENT    ptLineClient = ptCallClient->ptLineClient;


            if (ptCallClient == ptCallClientToExclude)
            {
                continue;
            }

            if (FMsgDisabled (
                ptCallClient->ptLineClient->ptLineApp->dwAPIVersion,
                ptCallClient->adwEventSubMasks,
                (DWORD) Msg,
                (DWORD) Param1
                ))
            {
                continue;
            }

            pmsg->Param1       = (DWORD) ptCallClient->hCall;
            pmsg->InitContext  = ptLineClient->ptLineApp->InitContext;
            pmsg->hDevice        = (DWORD) ptLineClient->hLine;
            pmsg->OpenContext = ptLineClient->OpenContext;


            //
            // Indicate the hRemoteLine in p4 to make life easier for remotesp
            //

            pmsg->Param4 = ptLineClient->hRemoteLine;

            ptClient = ptCallClient->ptClient;

            if (ptCallClient->dwKey == TCALLCLIENT_KEY)
            {
                WriteEventBuffer (ptClient, pmsg);
            }
        }
        myexcept
        {
            // just continue
        }
    }

    if (pClientList != &clientList)
    {
        ServerFree (pClientList);
    }

    ServerFree( pmsg );
}


void
PASCAL
SendAMsgToAllLineApps(
    DWORD       dwWantVersion,
    DWORD       Msg,
    DWORD       Param1, // ULONG_PTR   Param1,
    DWORD       Param2, // ULONG_PTR   Param2
    DWORD       Param3  // ULONG_PTR   Param3
    )
{
    DWORD           i, j;
    TPOINTERLIST    clientList, *pClientList = &clientList;
    ASYNCEVENTMSG   lineMsg;


    if (GetClientList (FALSE, &pClientList) != 0)
    {
        return;
    }

    ZeroMemory (&lineMsg, sizeof (ASYNCEVENTMSG));

    lineMsg.TotalSize = sizeof (ASYNCEVENTMSG);
    lineMsg.Msg       = Msg;
    lineMsg.Param2    = Param2;
    lineMsg.Param3    = Param3;


    for (i = 0; i < pClientList->dwNumUsedEntries; i++)
    {
        PTCLIENT        ptClient = (PTCLIENT) pClientList->aEntries[i];
        TPOINTERLIST    xxxAppList, *pXxxAppList = &xxxAppList;

        if (NULL == ptClient)
        {
            break;
        }

        lineMsg.Param1    = Param1;

        //
        //  For LINE_REMOVE, need to remap the dwDeviceID(Param1)
        //
        if (Msg == LINE_REMOVE)
        {
            DWORD           dwNumDevices;
            LPDWORD         lpdwDevices;
            
            if ((TapiGlobals.dwFlags & TAPIGLOBALS_SERVER) &&
                WaitForExclusiveClientAccess (ptClient))
            {
                if (!IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR))
                {
                    dwNumDevices = ptClient->dwLineDevices;
                    lpdwDevices = ptClient->pLineDevices;
                    for (j = 0; j < dwNumDevices; ++j, ++lpdwDevices)
                    {
                        if (*lpdwDevices == Param1)
                        {
                            break;
                        }
                    }
                    if (j >= dwNumDevices)
                    {
                        //  Not found in the device map, ignore
                        UNLOCKTCLIENT (ptClient);
                        continue;
                    }
                    else
                    {
                        lineMsg.Param1 = j;
                    }
                }
                UNLOCKTCLIENT (ptClient);
            }
        }
        else if (Msg == LINE_CREATE)
        {
            if ((TapiGlobals.dwFlags & TAPIGLOBALS_SERVER) &&
                WaitForExclusiveClientAccess (ptClient))
            {
                BOOL bAdmin = IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR);
                UNLOCKTCLIENT (ptClient);
                if (!bAdmin)
                {
                    continue;
                }
            }
        }


        if (GetLineAppListFromClient (ptClient, &pXxxAppList) == 0)
        {
            for (j = 0; j < pXxxAppList->dwNumUsedEntries; j++)
            {
                PTLINEAPP ptLineApp = (PTLINEAPP) pXxxAppList->aEntries[j];

                try
                {
                    lineMsg.InitContext = ptLineApp->InitContext;

                    if ((ptLineApp->dwKey == TLINEAPP_KEY)  &&
                          ((dwWantVersion == 0) ||
                             (ptLineApp->dwAPIVersion == dwWantVersion)  ||
                             ((dwWantVersion & 0x80000000)   &&
                                 (ptLineApp->dwAPIVersion >=
                                     (dwWantVersion & 0x7fffffff)))))
                    {
                        if (!FMsgDisabled (
                            ptLineApp->dwAPIVersion,
                            ptLineApp->adwEventSubMasks,
                            (DWORD) Msg,
                            (DWORD) Param1
                            ))
                        {
                            WriteEventBuffer (ptClient, &lineMsg);
                        }
                    }
                }
                myexcept
                {
                    // just continue
                }
            }

            if (pXxxAppList != &xxxAppList)
            {
                ServerFree (pXxxAppList);
            }
        }
    }

    if (pClientList != &clientList)
    {
        ServerFree (pClientList);
    }
}


void
PASCAL
SendAMsgToAllPhoneApps(
    DWORD       dwWantVersion,
    DWORD       Msg,
    DWORD       Param1,     // ULONG_PTR   Param1,
    DWORD       Param2,     // ULONG_PTR   Param2,
    DWORD       Param3      // ULONG_PTR   Param3
    )
{
    DWORD           i, j;
    TPOINTERLIST    clientList, *pClientList = &clientList;
    ASYNCEVENTMSG   phoneMsg;


    if (GetClientList (FALSE, &pClientList) != 0)
    {
        return;
    }

    ZeroMemory (&phoneMsg, sizeof (ASYNCEVENTMSG));

    phoneMsg.TotalSize = sizeof (ASYNCEVENTMSG);
    phoneMsg.Msg       = Msg;
    phoneMsg.Param2    = Param2;
    phoneMsg.Param3    = Param3;

    for (i = 0; i < pClientList->dwNumUsedEntries; i++)
    {
        PTCLIENT        ptClient = (PTCLIENT) pClientList->aEntries[i];
        TPOINTERLIST    xxxAppList, *pXxxAppList = &xxxAppList;

        if (NULL == ptClient)
        {
            break;
        }

        phoneMsg.Param1    = Param1;

        //
        //  For PHONE_REMOVE, need to remap the dwDeviceID(Param1)
        //
        if (Msg == PHONE_REMOVE)
        {
            DWORD           dwNumDevices;
            LPDWORD         lpdwDevices;
            
            if ((TapiGlobals.dwFlags & TAPIGLOBALS_SERVER) &&
                WaitForExclusiveClientAccess (ptClient))
            {
                if (!IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR))
                {
                    dwNumDevices = ptClient->dwPhoneDevices;
                    lpdwDevices = ptClient->pPhoneDevices;
                    for (j = 0; j < dwNumDevices; ++j, ++lpdwDevices)
                    {
                        if (*lpdwDevices == Param1)
                        {
                            break;
                        }
                    }
                    if (j >= dwNumDevices)
                    {
                        //  Not found in the device map, ignore
                        UNLOCKTCLIENT (ptClient);
                        continue;
                    }
                    else
                    {
                        phoneMsg.Param1 = j;
                    }
                }
                UNLOCKTCLIENT (ptClient);
            }
        }
        else if (Msg == PHONE_CREATE)
        {
            if ((TapiGlobals.dwFlags & TAPIGLOBALS_SERVER) &&
                WaitForExclusiveClientAccess (ptClient))
            {
                BOOL bAdmin = IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR);
                UNLOCKTCLIENT (ptClient);
                if (!bAdmin)
                {
                    continue;
                }
            }
        }

        if (GetPhoneAppListFromClient (ptClient, &pXxxAppList) == 0)
        {
            for (j = 0; j < pXxxAppList->dwNumUsedEntries; j++)
            {
                PTPHONEAPP  ptPhoneApp = (PTPHONEAPP) pXxxAppList->aEntries[j];

                try
                {
                    phoneMsg.InitContext = ptPhoneApp->InitContext;

                    if ((ptPhoneApp->dwKey == TPHONEAPP_KEY)  &&
                        ((dwWantVersion == 0) ||
                            (ptPhoneApp->dwAPIVersion == dwWantVersion) ||
                            ((dwWantVersion & 0x80000000)  &&
                                (ptPhoneApp->dwAPIVersion >=
                                   (dwWantVersion & 0x7fffffff)))))
                    {
                        if (!FMsgDisabled (
                            ptPhoneApp->dwAPIVersion,
                            ptPhoneApp->adwEventSubMasks,
                            (DWORD) Msg,
                            (DWORD) Param1
                            ))
                        {
                            WriteEventBuffer (ptClient, &phoneMsg);
                        }
                    }
                }
                myexcept
                {
                    // just continue
                }
            }

            if (pXxxAppList != &xxxAppList)
            {
                ServerFree (pXxxAppList);
            }
        }
    }

    if (pClientList != &clientList)
    {
        ServerFree (pClientList);
    }
}


void
PASCAL
SendReinitMsgToAllXxxApps(
    void
    )
{
    TapiGlobals.dwFlags |= TAPIGLOBALS_REINIT;

    SendAMsgToAllLineApps (0, LINE_LINEDEVSTATE, LINEDEVSTATE_REINIT, 0, 0);

    SendAMsgToAllPhoneApps (0, PHONE_STATE, PHONESTATE_REINIT, 0, 0);
}


void
PASCAL
SendBufferMsgToLineClients(
    PTLINE          ptLine,
    PTLINECLIENT    ptLineClientToExclude,
    DWORD           dwMsg,
    DWORD           dwParam1,   // ULONG_PTR       dwParam1,
    DWORD           dwSize,     // ULONG_PTR       dwSize,
    LPBYTE          pBuffer
    )
{
    DWORD           i;
    TPOINTERLIST    clientList, *pClientList = &clientList;
    ASYNCEVENTMSG * pmsg;
    DWORD           dwTotalSize = (sizeof (ASYNCEVENTMSG) +
                        (DWORD) dwSize + TALIGN_COUNT) & TALIGN_MASK;


    if (!(pmsg = (ASYNCEVENTMSG *) ServerAlloc (dwTotalSize)))
    {
        LOG((TL_ERROR, "SendBufferMsgToLineClients - Cannot allocate memory for message"));
        return;
    }

    if (GetLineClientListFromLine (ptLine, &pClientList) != 0)
    {
        ServerFree (pmsg);
        return;
    }

    pmsg->TotalSize          = dwTotalSize;
    pmsg->fnPostProcessProcHandle = 0;
    pmsg->Msg                = dwMsg;
    pmsg->Param1             = dwParam1;
    pmsg->Param2             = dwSize;
    pmsg->Param3             = 0;
    pmsg->Param4             = 0; // remotesp chks this on LINE_DEVSPEC(FEATURE)

    CopyMemory ((PBYTE)(pmsg+1), pBuffer, dwSize);

    for (i = 0; i < pClientList->dwNumUsedEntries; i++)
    {
        try
        {
            PTCLIENT     ptClient;
            PTLINECLIENT ptLineClient = pClientList->aEntries[i];


            if (ptLineClient == ptLineClientToExclude)
            {
                continue;
            }

            if (FMsgDisabled (
                ptLineClient->ptLineApp->dwAPIVersion,
                ptLineClient->adwEventSubMasks,
                dwMsg,
                (DWORD) dwParam1
                ))
            {
                continue;
            }

            pmsg->InitContext = ptLineClient->ptLineApp->InitContext;
            pmsg->hDevice     = ptLineClient->hRemoteLine;
            pmsg->OpenContext = ptLineClient->OpenContext;

            ptClient = ptLineClient->ptClient;

            if (ptLineClient->dwKey == TLINECLIENT_KEY)
            {
                WriteEventBuffer (ptClient, pmsg);
            }
        }
        myexcept
        {
            // just continue
        }
    }

    if (pClientList != &clientList)
    {
        ServerFree (pClientList);
    }

    ServerFree (pmsg);
}


void
PASCAL
SendMsgToLineClients(
    PTLINE          ptLine,
    PTLINECLIENT    ptLineClientToExclude,
    DWORD           Msg,
    DWORD           Param1, // ULONG_PTR       Param1,
    DWORD           Param2, // ULONG_PTR       Param2,
    DWORD           Param3  // ULONG_PTR       Param3
    )
{
    DWORD           i;
    TPOINTERLIST    clientList, *pClientList = &clientList;
    ASYNCEVENTMSG   msg;


    LOG((TL_TRACE, "SendMsgToLineClients - enter"));
    if (Msg == LINE_LINEDEVSTATE  &&  Param1 & LINEDEVSTATE_REINIT)
    {
        SendReinitMsgToAllXxxApps();

        if (Param1 == LINEDEVSTATE_REINIT)
        {
            return;
        }
        else
        {
            Param1 &= ~LINEDEVSTATE_REINIT;
        }
    }


    if (GetLineClientListFromLine (ptLine, &pClientList) != 0)
    {
        return;
    }

    msg.TotalSize          = sizeof (ASYNCEVENTMSG);
    msg.fnPostProcessProcHandle = 0;
    msg.Msg                = Msg;
    msg.Param1             = Param1;
    msg.Param2             = Param2;
    msg.Param3             = Param3;
    msg.Param4             = 0; // remotesp chks this on LINE_DEVSPEC(FEATURE)

    LOG((TL_INFO, "SendMsgToLineClients - number of Clients:%u", pClientList->dwNumUsedEntries));
    for (i = 0; i < pClientList->dwNumUsedEntries; i++)
    {
        try
        {
            PTCLIENT     ptClient;
            PTLINECLIENT ptLineClient = pClientList->aEntries[i];

            if (ptLineClient == ptLineClientToExclude)
            {
                continue;
            }
            LOG((TL_INFO, "SendMsgToLineClients: Msg:%x -- Param1:%x", Msg, Param1));
            if (FMsgDisabled (
                ptLineClient->ptLineApp->dwAPIVersion,
                ptLineClient->adwEventSubMasks,
                (DWORD) Msg,
                (DWORD) Param1
                ))
            {
                continue;
            }

            if (Msg == LINE_ADDRESSSTATE)
            {
                DWORD   addressStates = Param2;     // ULONG_PTR   addressStates = Param2;


                //
                // Munge the state flags so we don't pass
                // unexpected flags to old apps
                //

                switch (ptLineClient->dwAPIVersion)
                {
                case TAPI_VERSION1_0:

                    addressStates &= AllAddressStates1_0;
                    break;

                //case TAPI_VERSION1_4:
                //case TAPI_VERSION2_0:
                //case TAPI_VERSION2_1:
                //case TAPI_VERSION2_2:
                //case TAPI_VERSION_CURRENT:
                default:

                    addressStates &= AllAddressStates1_4;
                    break;
                }

                if ((addressStates &= ptLineClient->dwAddressStates))
                {
                    msg.Param2 = addressStates;
                }
                else
                {
                    continue;
                }

                if ((Param2 & LINEADDRESSSTATE_CAPSCHANGE))
                {
                }
            }
            else if (Msg == LINE_LINEDEVSTATE)
            {
                DWORD   lineStates = Param1;    // ULONG_PTR   lineStates = Param1;


                //
                // Munge the state flags so we don't pass unexpected flags
                // to old apps
                //

                switch (ptLineClient->dwAPIVersion)
                {
                case TAPI_VERSION1_0:

                    lineStates &= AllLineStates1_0;
                    break;

                default:    // case TAPI_VERSION1_4:
                            // case TAPI_VERSION_CURRENT:

                    lineStates &= AllLineStates1_4;
                    break;
                }

                if ((lineStates &= ptLineClient->dwLineStates))
                {
                    msg.Param1 = lineStates;
                }
                else
                {
                    continue;
                }

                if ((Param1 & (LINEDEVSTATE_CAPSCHANGE |
                        LINEDEVSTATE_TRANSLATECHANGE)))
                {
                }

            }
            else if (Msg == LINE_PROXYSTATUS)
            {
                //
                // Don't pass this message to older apps
                //

                if (ptLineClient->dwAPIVersion < TAPI_VERSION2_2)
                {
                    continue;
                }
            }

            msg.InitContext = ptLineClient->ptLineApp->InitContext;
            msg.hDevice     = ptLineClient->hRemoteLine;
            msg.OpenContext = ptLineClient->OpenContext;

            ptClient = ptLineClient->ptClient;

            if (ptLineClient->dwKey == TLINECLIENT_KEY)
            {
                WriteEventBuffer (ptClient, &msg);
            }
        }
        myexcept
        {
            // just continue
        }
    }

    if (pClientList != &clientList)
    {
        ServerFree (pClientList);
    }
}


LONG
PASCAL
GetCallIDs(
    PTCALL  ptCall
    )
{
    //
    // NOTE: Caller must already have exclusive access to the
    //       tCall when invoking this function.  On return they
    //       will still have exclusive access to the tCall.
    //
    //       Also, it is assumed that only the LINE_CALLSTATE
    //       msg handler & MakeCallPostProcess-style functions
    //       will call this function.  Otherwise, the code that
    //       resets the tCall's dwKey down below will need to
    //       be changed.
    //

    //
    // We don't want to hold the lock while we call the provider,
    // since this request might take a while (possible ring
    // transitions, etc). But we also don't want another thread
    // to destroy this tCall in the meantime (because we didn't
    // allow for that in NT 4.0, and because it makes life more
    // difficult for the calling function).  So, we'll reset the
    // tCall's dwKey value to ZOMBIE, thereby causing any other
    // thread(s) that is waiting to destroy this call to effectively
    // wait/spin, and we'll then restore the dwKey value down below
    // after we reacquire the lock. (Since this func is only called
    // by MakeCallPostProcess-style functions & the LINE_CALLSTATE
    // handler [on the first callstate msg received on an incoming
    // call], the only way another thread would be destroying this
    // call is if the line is being closed, either by an app or as
    // the result of a LINE_CLOSE, and DestroytLine spins until
    // it has destroyed all tCall's in the tLine's list.)

    DWORD       dwNumAddresses = ptCall->ptLine->dwNumAddresses, dwSavedKey;
    PTPROVIDER  ptProvider = ptCall->ptProvider;

    if (ptProvider->apfn[SP_LINEGETCALLINFO] == NULL)
    {
        return LINEERR_OPERATIONUNAVAIL;
    }

    dwSavedKey = ptCall->dwKey;
    ptCall->dwKey = TZOMBIECALL_KEY;

    UNLOCKTCALL (ptCall);

    if (ptProvider->apfn[SP_LINEGETCALLIDS])
    {
        CallSP4(
            ptProvider->apfn[SP_LINEGETCALLIDS],
            "lineGetCalIDs",
            SP_FUNC_SYNC,
            (ULONG_PTR) ptCall->hdCall,
            (ULONG_PTR) &ptCall->dwAddressID,
            (ULONG_PTR) &ptCall->dwCallID,
            (ULONG_PTR) &ptCall->dwRelatedCallID
            );
    }
    else
    {
        DWORD           dwSPIVersion, dwFixedSizeSP;
        LINECALLINFO    callInfo;


        //
        // Determine the fixed size of the structure expected by the SP
        //

        dwSPIVersion = ((PTLINE) ptCall->ptLine)->dwSPIVersion;

        switch (dwSPIVersion)
        {
        case TAPI_VERSION1_0:
        case TAPI_VERSION1_4:

            dwFixedSizeSP = 296;    // 69 * sizeof(DWORD) + sizeof (HLINE)
                                    //     + sizeof (LINEDIALPARAMS)
            break;

        case TAPI_VERSION2_0:
        case TAPI_VERSION2_1:
        case TAPI_VERSION2_2:

            dwFixedSizeSP = 324;    // 76 * sizeof(DWORD) + sizeof (HLINE)
                                    //     + sizeof (LINEDIALPARAMS)
            break;

        default: // (fix ppc build wrn) case TAPI_VERSION_CURRENT:

            dwFixedSizeSP = sizeof (LINECALLINFO);
            break;
        }

        InitTapiStruct (&callInfo, dwFixedSizeSP, dwFixedSizeSP, TRUE);

        CallSP2(
            ptProvider->apfn[SP_LINEGETCALLINFO],
            "lineGetCallInfo",
            SP_FUNC_SYNC,
            (ULONG_PTR) ptCall->hdCall,
            (ULONG_PTR) &callInfo
            );

        ptCall->dwAddressID     = callInfo.dwAddressID;
        ptCall->dwCallID        = callInfo.dwCallID;
        ptCall->dwRelatedCallID = callInfo.dwRelatedCallID;
    }


    //
    // Reacquire the call lock, restore the dwKey value, & fill
    // in the address id
    //

    LOCKTCALL (ptCall);
    ptCall->dwKey = dwSavedKey;

    return 0;
}


VOID
PASCAL
AcquireHashTableReaderLock(
    PTPROVIDER  ptProvider
    )
{
    EnterCriticalSection (&ptProvider->HashTableCritSec);
    InterlockedIncrement (&ptProvider->lHashTableReaderCount);
    LeaveCriticalSection (&ptProvider->HashTableCritSec);
}


VOID
PASCAL
AcquireHashTableWriterLock(
    PTPROVIDER  ptProvider
    )
{
    EnterCriticalSection (&ptProvider->HashTableCritSec);

    if (InterlockedDecrement (&ptProvider->lHashTableReaderCount) >= 0)
    {
        WaitForSingleObject (ptProvider->hHashTableReaderEvent, INFINITE);
    }
}


VOID
PASCAL
ReleaseHashTableReaderLock(
    PTPROVIDER  ptProvider
    )
{
    if (InterlockedDecrement (&ptProvider->lHashTableReaderCount) < 0)
    {
        SetEvent (ptProvider->hHashTableReaderEvent);
    }
}


VOID
PASCAL
ReleaseHashTableWriterLock(
    PTPROVIDER  ptProvider
    )
{
    InterlockedIncrement (&ptProvider->lHashTableReaderCount);
    LeaveCriticalSection (&ptProvider->HashTableCritSec);
}


PTHASHTABLEENTRY
PASCAL
AcquireHashTableEntryLock(
    PTPROVIDER  ptProvider,
    DWORD       dwCallHubID
    )
{
    LONG                lPreviousCookie;
    PTHASHTABLEENTRY    pEntry;


    AcquireHashTableReaderLock (ptProvider);

    pEntry = ptProvider->pHashTable +
        (dwCallHubID % ptProvider->dwNumHashTableEntries);

    do
    {
        lPreviousCookie = InterlockedExchange (&pEntry->lCookie, 1);

    } while (lPreviousCookie != 0);

    return pEntry;
}


VOID
PASCAL
ReleaseHashTableEntryLock(
    PTPROVIDER          ptProvider,
    PTHASHTABLEENTRY    pEntry
    )
{
    InterlockedExchange (&pEntry->lCookie, 0);

    ReleaseHashTableReaderLock (ptProvider);
}


VOID
PASCAL
FreeHashTable(
    PTHASHTABLEENTRY    pHashTable,
    DWORD               dwNumHashTableEntries,
    DWORD               dwNumDynamicHashTableEntries
    )
{
    //
    // Walk thru hash table to find any dynamic entries that need to
    // be freed.  We compare against both dwNumDynamicHashTableEntries
    // and dwNumHashTableEntries in case something went wrong somewhere.
    //
    // Then free the table itself & return
    //

    DWORD               i;
    PTHASHTABLEENTRY    pEntry, pEntry2;


    for(
        i = 0, pEntry = pHashTable;
        dwNumDynamicHashTableEntries  &&  i < dwNumHashTableEntries;
        i++, pEntry++
        )
    {
        while (pEntry->pNext)
        {
            dwNumDynamicHashTableEntries--;

            pEntry2 = pEntry->pNext->pNext;

            ServerFree (pEntry->pNext);

            pEntry->pNext = pEntry2;
        }
    }

    ServerFree (pHashTable);
}


PTHASHTABLEENTRY
PASCAL
FindDynamicHashTableEntry(
    PTHASHTABLEENTRY    pEntry,
    DWORD               dwCallHubID
    )
{
    //
    // Note that the pEntry passed to us is static, so no need to check that
    //

    while (pEntry->pNext)
    {
        if (pEntry->pNext->dwCallHubID == dwCallHubID)
        {
            break;
        }

        pEntry = pEntry->pNext;
    }

    return pEntry->pNext;
}


VOID
PASCAL
RemoveDynamicHashTableEntry(
    PTPROVIDER          ptProvider,
    PTHASHTABLEENTRY    pStaticEntry,
    PTHASHTABLEENTRY    pDynamicEntry
    )
{
    while (pStaticEntry->pNext != pDynamicEntry)
    {
        pStaticEntry = pStaticEntry->pNext;
    }

    pStaticEntry->pNext = pDynamicEntry->pNext;

    ServerFree (pDynamicEntry);

    InterlockedDecrement ((LPLONG) &ptProvider->dwNumDynamicHashTableEntries);
}


DWORD
PASCAL
GetNumDynamicHashTableEntries(
    PTHASHTABLEENTRY    pEntry
    )
{
    //
    // Note that the pEntry passed to us is static, so no need to count that
    //

    DWORD  i;


    for (i = 0; (pEntry = pEntry->pNext); i++);

    return i;
}


//
//  SendNewCallHubEvent
//
//  Utility function used by DoCallHubHashing & UpdateCallHubHashing
//  to send LINE_NEWCALLHUB event if not sent yet
//

LONG
PASCAL
SendNewCallHubEvent (
    PTCALL                  ptCall,
    PTHASHTABLEENTRY        pTargetEntry
    )
{
    //
    // For each tCallClient see if tLineClient has tracking
    // enabled, and if so then see if there is already an
    // associated (via common tLineApp) tCallHubClient - if
    // not then create one & notify the app
    //

    DWORD   i;
    BOOL    bExistingCallHubClients = 
        (pTargetEntry->ptCallHubClients != NULL);
    TPOINTERLIST        fastCallClientList, *ptCallClientList;

    if (ptCall->ptLine->dwNumCallHubTrackers != 0)
    {
        ptCallClientList = &fastCallClientList;
        if (GetCallClientListFromCall (ptCall, &ptCallClientList) != 0)
        {
            ptCallClientList = NULL;
        }
    }
    else
    {
        ptCallClientList = NULL;
    }

    if (ptCallClientList == NULL || pTargetEntry == NULL)
    {
        return 0;
    }

    for (i = 0; i < ptCallClientList->dwNumUsedEntries; i++)
    {
        PTLINEAPP       ptLineApp;
        PTCALLCLIENT    ptCallClient = ptCallClientList->aEntries[i];
        ASYNCEVENTMSG   msg;
        PTCALLHUBCLIENT ptCallHubClient;


        if (ptCallClient->ptLineClient->dwCurrentTracking ||
            bExistingCallHubClients)
        {
            ptLineApp = ptCallClient->ptLineClient->ptLineApp;
            ptCallHubClient = pTargetEntry->ptCallHubClients;

            while (ptCallHubClient)
            {
                if (ptCallHubClient->ptLineApp == ptLineApp)
                {
                    break;
                }

                ptCallHubClient = ptCallHubClient->pNext;
            }

            if (ptCallClient->ptLineClient->dwCurrentTracking  &&
                !ptCallHubClient &&
                (!FMsgDisabled (
                    ptCallClient->ptLineClient->ptLineApp->dwAPIVersion,
                    ptCallClient->adwEventSubMasks,
                    LINE_APPNEWCALLHUB,
                    0)))
            {
                DWORD hptClientHandle = 0;


                ptCallHubClient = ServerAlloc (sizeof(TCALLHUBCLIENT));

                if (!ptCallHubClient)
                {
                    i = ptCallClientList->dwNumUsedEntries;
                    continue;
                }

                ptCallHubClient->hCallHub = (DWORD) NewObject(
                    ghHandleTable,
                    ptCallHubClient,
                    NULL
                    );

                if (!ptCallHubClient->hCallHub)
                {
                    ServerFree(ptCallHubClient);
                    i = ptCallClientList->dwNumUsedEntries;
                    continue;
                }

                ptCallHubClient->dwKey = TCALLHUBCLIENT_KEY;
                ptCallHubClient->ptClient = ptCallClient->ptClient;
                ptCallHubClient->ptProvider = ptCall->ptProvider;
                ptCallHubClient->dwCallHubID = ptCall->dwCallID;
                ptCallHubClient->ptLineApp = ptLineApp;
                ptCallHubClient->pNext = pTargetEntry->ptCallHubClients;
                pTargetEntry->ptCallHubClients = ptCallHubClient;


                //
                // Queue a msg to alert the app of the new call
                // hub.  We do this rather than sending a msg
                // directly from here to make sure the app gets
                // the LINE_REPLY and/or APPNEWCALL msgs first
                // (i.e. before calling lineGetHubRelatedCalls
                // in response to LINE_APPNEWCALLHUB)
                //

                LineEventProcSP(
                    (HTAPILINE) 0,
                    (HTAPICALL) 0,
                    LINE_APPNEWCALLHUB,
                    ptCallHubClient->hCallHub,
                    ptLineApp->InitContext,
                    (ULONG_PTR)ptLineApp->ptClient
                    );
            }

            ptCallClient->ptCallHubClient = ptCallHubClient;
        }
    }

    return 0;
}

//
//  Per Bug 7591
//      There might be a owner ship transferring of a call after
//  it has been created. The new owner will not get the new call
//  hub event since such event is only generated while the call
//  is created. UpdateCallHubHashing goes through the call client
//  if any of the client did not receive the LINE_NEWCALLHUB event
//  it will send it one.
//

LONG
PASCAL
UpdateCallHubHashing (
    PTCALL      ptCall
    )
{
    if (WaitForExclusivetCallAccess (ptCall, TCALL_KEY))
    {
        PTHASHTABLEENTRY    pStaticEntry, pTargetEntry;
        
        pStaticEntry = AcquireHashTableEntryLock(
            ptCall->ptProvider,
            ptCall->dwCallID
            );
        if (pStaticEntry->dwCallHubID == ptCall->dwCallID)
        {
            pTargetEntry = pStaticEntry;
        }
        else
        {
            pTargetEntry = FindDynamicHashTableEntry(
                pStaticEntry,
                ptCall->dwCallID
                );
        }
        if (pTargetEntry)
        {
            SendNewCallHubEvent (ptCall, pTargetEntry);
        }
        ReleaseHashTableEntryLock (ptCall->ptProvider, pStaticEntry);
        UNLOCKTCALL (ptCall);
    }

    return 0;
}

LONG
PASCAL
DoCallHubHashing(
    PTCALL  ptCall,
    DWORD   dwPreviousCallID
    )
{
    //
    // Assumes caller has exclusive access to the tCall
    //

    DWORD               i;
    PTPROVIDER          ptProvider = ptCall->ptProvider;
    PTHASHTABLEENTRY    pStaticEntry, pDynamicEntry;


    if (ptCall->dwCallID == dwPreviousCallID)
    {
        return 0;
    }

    if (dwPreviousCallID != 0)
    {
        //
        // Remove tCall from call hub hash table (based on
        // previous call id).  If this is the last tCall in
        // that hash table entry then destroy any associated
        // tCallHubClients and alert apps.
        //
        // Note that (when freeing tCallHubClients) we call
        // LineEventProcSP() to queue the CALLHUBCLOSE msgs
        // rather than sending them directly via
        // WriteEventBuffer() because we already own the
        // tCall lock and we don't want to entertain the
        // possibility of deadlock by grabbing other locks.
        //

        PTCALLHUBCLIENT ptCallHubClient = NULL,  pNext;


        pStaticEntry = AcquireHashTableEntryLock(
            ptProvider,
            dwPreviousCallID
            );

        if (pStaticEntry->dwCallHubID == dwPreviousCallID)
        {
            RemoveEntryList (&ptCall->CallHubList);

            ptCall->CallHubList.Flink = NULL;
            ptCall->CallHubList.Blink = NULL;

            if (IsListEmpty (&pStaticEntry->CallHubList))
            {
                ptCallHubClient = pStaticEntry->ptCallHubClients;
                pStaticEntry->ptCallHubClients = NULL;
                pStaticEntry->dwCallHubID = 0;
            }
        }
        else if ((pDynamicEntry = FindDynamicHashTableEntry(
                        pStaticEntry,
                        dwPreviousCallID
                        )))
        {
            RemoveEntryList (&ptCall->CallHubList);

            ptCall->CallHubList.Flink = NULL;
            ptCall->CallHubList.Blink = NULL;

            if (IsListEmpty (&pDynamicEntry->CallHubList))
            {
                ptCallHubClient = pDynamicEntry->ptCallHubClients;

                RemoveDynamicHashTableEntry(
                    ptProvider,
                    pStaticEntry,
                    pDynamicEntry
                    );
            }
        }
        else
        {
            // TODO assert
        }

        ReleaseHashTableEntryLock (ptProvider, pStaticEntry);

        if (ptCallHubClient)
        {
            while (ptCallHubClient)
            {
                BOOL        bSendMsg = FALSE;
                DWORD       param2 = 0;
                DWORD       param3 = 0; // ULONG_PTR   param2, param3;
                PTLINEAPP   ptLineApp;


                try
                {
                    ptLineApp = ptCallHubClient->ptLineApp;

                    param2 = ptLineApp->InitContext;
                    
                    if (ptLineApp->dwKey == TLINEAPP_KEY &&
                        (!FMsgDisabled(
                            ptLineApp->dwAPIVersion,
                            ptLineApp->adwEventSubMasks,
                            LINE_CALLHUBCLOSE,
                            0
                            )))
                    {
                        bSendMsg = TRUE;
                    }
                }
                except (EXCEPTION_EXECUTE_HANDLER)
                {
                    // tLineApp is gone, just fall through
                }

                if (bSendMsg)
                {
                    LineEventProcSP(
                        (HTAPILINE) UIntToPtr(ptCallHubClient->hCallHub), // "random" seed for MP
                        (HTAPICALL) 0,
                        LINE_CALLHUBCLOSE,
                        ptCallHubClient->hCallHub,
                        param2,
                        (ULONG_PTR)ptLineApp->ptClient
                        );
                }

                pNext = ptCallHubClient->pNext;
                ptCallHubClient->dwKey = INVAL_KEY;

                DereferenceObject(
                    ghHandleTable,
                    ptCallHubClient->hCallHub,
                    1
                    );

                ptCallHubClient = pNext;
            }
        }
    }

    if (ptCall->dwCallID != 0 &&
        ptCall->CallHubList.Flink == NULL &&
        ptCall->CallHubList.Blink == NULL)
    {
        //
        // If at least one tLineClient has call hub tracking enabled
        // then retrieve the list of tCallClients before we acquire
        // exclusive access to the hash table
        //

        DWORD               dwOldNumHashTableEntries,
                            dwOldNumDynamicHashTableEntries;
        PTHASHTABLEENTRY    pOldHashTable = NULL, pTargetEntry;


        //
        // Insert tCall in call hub hash table (based on current call ID).
        //
        // In the event of collision, first check to see if there's an
        // existing dynamic entry with corresponding to the call ID.
        // If so, party on the dynamic entry.  Otherwise, try to create
        // a dynamic entry if we're still within the dynamic entry
        // threshholds.
        //
        // Finally, failing all the above, attempt to grow the hash table.
        //

acquireTableEntryLock:

        pStaticEntry = AcquireHashTableEntryLock(
            ptProvider,
            ptCall->dwCallID
            );

        if (pStaticEntry->dwCallHubID == ptCall->dwCallID)
        {
            //
            // Add tCall to list (static entry)
            //

            InsertTailList (&pStaticEntry->CallHubList, &ptCall->CallHubList);

            pTargetEntry = pStaticEntry;
        }
        else if(pStaticEntry->dwCallHubID == 0)
        {
            //
            //  Check to see if there is already a dynamic entry for this dwCallID,
            //  if so, use it
            //
        
            pTargetEntry = pStaticEntry->pNext;
            
            while (pTargetEntry && pTargetEntry->dwCallHubID != ptCall->dwCallID)
            {
                pTargetEntry = pTargetEntry->pNext;
            }
            if (pTargetEntry == NULL)
            {
                pTargetEntry = pStaticEntry;
                pTargetEntry->dwCallHubID = ptCall->dwCallID;
            }
            
            InsertTailList (&pTargetEntry->CallHubList, &ptCall->CallHubList);
        }
        else if ((pTargetEntry = FindDynamicHashTableEntry(
                        pStaticEntry,
                        ptCall->dwCallID
                        )))
        {
            //
            // Add tCall to list (existing dynamic entry)
            //

            InsertTailList (&pTargetEntry->CallHubList, &ptCall->CallHubList);
        }
        else if (InterlockedIncrement(
                    (LPLONG) &ptProvider->dwNumDynamicHashTableEntries
                    )

                    <  (LONG) GetMaxDynamicHashTableEntries(
                                   ptProvider->dwNumHashTableEntries
                                   )                                   &&

                 GetNumDynamicHashTableEntries (pStaticEntry)

                    < MAX_DYNAMIC_HASH_ENTRIES_PER_SLOT)
        {
            //
            // Add tCall to list (new dynamic entry)
            //

            if (!(pTargetEntry = ServerAlloc (sizeof (*pTargetEntry))))
            {
                //
                // Failed to allocate memory, so we'll reset the call
                // hub id for this call to zero so as not to confuse
                // things later
                //

                InterlockedDecrement(
                    (LPLONG) &ptProvider->dwNumDynamicHashTableEntries
                    );

                ReleaseHashTableEntryLock (ptProvider, pStaticEntry);
                ptCall->dwCallID = 0;

                return 0;
            }

            pTargetEntry->dwCallHubID = ptCall->dwCallID;

            InitializeListHead (&pTargetEntry->CallHubList);

            InsertTailList (&pTargetEntry->CallHubList, &ptCall->CallHubList);

            pTargetEntry->pNext = pStaticEntry->pNext;

            pStaticEntry->pNext = pTargetEntry;
        }
        else
        {
            //
            // Grow table
            //

            DWORD               dwNewNumHashTableEntries, dwMaxDynamicEntries,
                                dwNewNumDynamicHashTableEntries;
            PTHASHTABLEENTRY    pNewHashTable, pNewEntry, pEntry2, pEndOfTable;


            //
            // Decrement to compensate for the failed check above
            //

            InterlockedDecrement(
                &ptProvider->dwNumDynamicHashTableEntries
                );


            //
            // Grab the current number of hash table entries before
            // we release the entry lock, so we can compare with
            // that after the table writer lock is acquired.  (Another
            // thread might have grown table in time it took to acquire
            // table writer lock, in which case we want to jump up
            // top again.)
            //
            // The chances of another thread having released the
            // entry we collided with (or freed up a related dynamic
            // entry, etc) are fairly slim, so we won't bother checking
            // for that
            //

            {
                DWORD   dwNumHashTableEntries =
                            ptProvider->dwNumHashTableEntries;


                ReleaseHashTableEntryLock (ptProvider, pStaticEntry);

                AcquireHashTableWriterLock (ptProvider);

                if (dwNumHashTableEntries < ptProvider->dwNumHashTableEntries)
                {
                    ReleaseHashTableWriterLock (ptProvider);

                    goto acquireTableEntryLock;
                }

                //
                //  Because we released the lock & reaquired a lock, if
                //  another call with the same dwCallID got hashed in, we
                //  would got two hash table entries with the same dwCallHubID
                //  that eventually leads to memory corruption when grow
                //  the table again. So check for it
                //
                pTargetEntry = ptProvider->pHashTable +
                    (ptCall->dwCallID % ptProvider->dwNumHashTableEntries);
                while (pTargetEntry && pTargetEntry->dwCallHubID != ptCall->dwCallID)
                {
                    pTargetEntry = pTargetEntry->pNext;
                }
                if (pTargetEntry)
                {
                    //
                    //  Found such entry, go back & retry
                    //
                    ReleaseHashTableWriterLock (ptProvider);

                    goto acquireTableEntryLock;
                }
            }


            //
            // Ok, we really do need to grow the table.  Find the next
            // larger number of entries.
            //

            for(
                i = 0;
                ptProvider->dwNumHashTableEntries >= TapiPrimes[i] &&
                    TapiPrimes[i];
                i++
                );

alloc_new_hash_table:

            if (!(dwNewNumHashTableEntries = TapiPrimes[i]))
            {
                //
                // We won't attempt to grow the hash table any further,
                // so we'll reset the call hub id for this call to zero
                // so as not to confuse things later
                //

                ptCall->dwCallID = 0;
                ReleaseHashTableWriterLock (ptProvider);
                return 0;
            }

            pNewHashTable = ServerAlloc(
                dwNewNumHashTableEntries * sizeof (THASHTABLEENTRY)
                );

            if (!pNewHashTable)
            {
                //
                // Failed to allocate a new hash table, so we'll reset the
                // call hub id for this call to zero so as not to confuse
                // things later
                //

                ptCall->dwCallID = 0;
                ReleaseHashTableWriterLock (ptProvider);
                return 0;
            }


            //
            // Move all existing hash table entries to new table
            //

            pEndOfTable = ptProvider->pHashTable +
                ptProvider->dwNumHashTableEntries;

            dwNewNumDynamicHashTableEntries = 0;

            dwMaxDynamicEntries = GetMaxDynamicHashTableEntries(
                dwNewNumHashTableEntries
                );

            for(
                pStaticEntry = ptProvider->pHashTable;
                pStaticEntry != pEndOfTable;
                pStaticEntry++
                )
            {
                //
                // If this entry is in use somehow, check to see
                // if we need to start walking at the static entry
                // or the dynamic entry.  Else, simply continue.
                //

                if (pStaticEntry->dwCallHubID == 0)
                {
                    if (!pStaticEntry->pNext)
                    {
                        continue;
                    }

                    pEntry2 = pStaticEntry->pNext;
                }
                else
                {
                    pEntry2 = pStaticEntry;
                }

                while (pEntry2)
                {
                    pNewEntry = pNewHashTable +
                        (pEntry2->dwCallHubID % dwNewNumHashTableEntries);

                    if (pNewEntry->dwCallHubID != 0)
                    {
                        //
                        // Collision, try to add a dynamic entry
                        //

                        if (dwNewNumDynamicHashTableEntries  <
                                dwMaxDynamicEntries  &&

                            GetNumDynamicHashTableEntries (pNewEntry)
                                < MAX_DYNAMIC_HASH_ENTRIES_PER_SLOT)
                        {
                            if (!(pDynamicEntry = ServerAlloc(
                                    sizeof (*pDynamicEntry)
                                    )))
                            {
                                //
                                // Failed to allocate a new dynamic entry,
                                // so we'll reset the call hub id for this
                                // call to zero so as not to confuse things
                                // later
                                //

                                ptCall->dwCallID = 0;
                                ReleaseHashTableWriterLock (ptProvider);

                                FreeHashTable(
                                    pNewHashTable,
                                    dwNewNumHashTableEntries,
                                    dwNewNumDynamicHashTableEntries
                                    );

                                return 0;
                            }

                            pDynamicEntry->pNext = pNewEntry->pNext;
                            pNewEntry->pNext = pDynamicEntry;

                            pNewEntry = pDynamicEntry;

                            dwNewNumDynamicHashTableEntries++;
                        }
                        else
                        {
                            //
                            // Free new table and try for a larger one
                            //

                            FreeHashTable(
                                pNewHashTable,
                                dwNewNumHashTableEntries,
                                dwNewNumDynamicHashTableEntries
                                );

                            i++;

                            goto alloc_new_hash_table;
                        }
                    }

                    pNewEntry->dwCallHubID       = pEntry2->dwCallHubID;
                    pNewEntry->CallHubList.Flink = pEntry2->CallHubList.Flink;
                    pNewEntry->CallHubList.Blink = pEntry2->CallHubList.Blink;
                    pNewEntry->ptCallHubClients  = pEntry2->ptCallHubClients;

                    pEntry2 = pEntry2->pNext;
                }
            }


            //
            // Now init the new entry
            //

            pNewEntry = pNewHashTable +
                (ptCall->dwCallID % dwNewNumHashTableEntries);

            if (pNewEntry->dwCallHubID != 0)
            {
                //
                // Collision, try to add a dynamic entry.
                //
                // We intentionally ignore the dyna entry threshhold
                // checks, as they'd be overkill here.
                //

                if ((pDynamicEntry = ServerAlloc (sizeof(*pDynamicEntry))))
                {
                    pDynamicEntry->pNext = pNewEntry->pNext;
                    pNewEntry->pNext = pDynamicEntry;

                    pNewEntry = pDynamicEntry;

                    dwNewNumDynamicHashTableEntries++;
                }
                else
                {
                    FreeHashTable(
                        pNewHashTable,
                        dwNewNumHashTableEntries,
                        dwNewNumDynamicHashTableEntries
                        );

                    i++;

                    goto alloc_new_hash_table;
                }
            }

            pNewEntry->dwCallHubID       = ptCall->dwCallID;
            pNewEntry->CallHubList.Flink =
            pNewEntry->CallHubList.Blink = &ptCall->CallHubList;


            //
            // Save the old table info (so we can free it & dyna
            // entries later when the lock is released), then save
            // the new table info
            //

            pOldHashTable = ptProvider->pHashTable;
            dwOldNumHashTableEntries = ptProvider->dwNumHashTableEntries;
            dwOldNumDynamicHashTableEntries =
                ptProvider->dwNumDynamicHashTableEntries;


            ptProvider->pHashTable = pNewHashTable;
            ptProvider->dwNumHashTableEntries = dwNewNumHashTableEntries;
            ptProvider->dwNumDynamicHashTableEntries =
                dwNewNumDynamicHashTableEntries;


            //
            // Init the unused table entries and the head & tail
            // list items in the used entries
            //

            pEndOfTable = ptProvider->pHashTable +
                ptProvider->dwNumHashTableEntries;

            for(
                pStaticEntry = ptProvider->pHashTable;
                pStaticEntry != pEndOfTable;
                pStaticEntry++
                )
            {
                if (pStaticEntry->dwCallHubID == 0)
                {
                    InitializeListHead (&pStaticEntry->CallHubList);
                }
                else
                {
                    pEntry2 = pStaticEntry;

                    while (pEntry2)
                    {
                        pEntry2->CallHubList.Flink->Blink =
                        pEntry2->CallHubList.Blink->Flink =
                            &pEntry2->CallHubList;

                        pEntry2 = pEntry2->pNext;
                    }
                }
            }


            //
            // Set pTargetEntry to point to the "new" entry (as expected below)
            //

            pTargetEntry = pNewEntry;
        }


        //
        // Check to see if we need to create any tCallHubClient objects
        //

        SendNewCallHubEvent (ptCall, pTargetEntry);

        //
        // Release the appropriate hash table lock, then if we grew
        // the table free the old table & dynamic table entries
        //

        if (!pOldHashTable)
        {
            ReleaseHashTableEntryLock (ptProvider, pStaticEntry);
        }
        else
        {
            ReleaseHashTableWriterLock (ptProvider);

            FreeHashTable(
                pOldHashTable,
                dwOldNumHashTableEntries,
                dwOldNumDynamicHashTableEntries
                );
        }
    }

    return 0;
}


LONG
PASCAL
CreatetCall(
    PTLINE              ptLine,
    BOOL                bIncoming,
    HDRVCALL            hdCall,
    PTCALL             *pptCall,
    LPLINECALLPARAMS    pCallParams,
    PTCALL              ptCallAssociate
    )
{
    BOOL    bDupedMutex;
    DWORD   dwExtraBytes;
    HANDLE  hMutex;
    PTCALL  ptCall;


    LOG((TL_TRACE,  "CreatetCall: enter, ptLine=%p", ptLine));


    //
    // If there's call params specified check to see if we need to alloc
    // any extra space for the CalledParty, DisplayableAddr, or Comment
    // fields.  Also, if any of these fields are non-NULL make sure to
    // get extra space to keep these fields 64-bit aligned.
    //

    dwExtraBytes = (pCallParams == NULL ? 0 : pCallParams->dwCalledPartySize +
        pCallParams->dwDisplayableAddressSize + pCallParams->dwCommentSize);

    if (dwExtraBytes != 0)
    {
        dwExtraBytes += (sizeof (TCALL) & 4) + 16;
    }


    //
    // Alloc necessary resources
    //

    if (!(ptCall = ServerAlloc (sizeof (TCALL) + dwExtraBytes)))
    {
        return LINEERR_NOMEM;
    }


    //
    // Init tCall & add to tLine's tCall list
    //

    if (bIncoming)
    {
        //
        // This is an incoming call (we're being called by the
        // LINE_NEWCALL handler)
        //

        ptCall->dwKey          = INVAL_KEY;
        ptCall->dwDrvCallFlags = DCF_SPIRETURNED | DCF_DRVCALLVALID;
        ptCall->bAlertApps     = TRUE;
        ptCall->dwCallState    = LINECALLSTATE_UNKNOWN;
        ptCall->hdCall         = hdCall;
    }
    else
    {
        //
        // This is an outgoing call (we're not being called by
        // the LINE_NEWCALL handler)
        //

        ptCall->dwKey = TINCOMPLETECALL_KEY;
    }

    if (pCallParams)
    {
        DWORD dwOffset = sizeof (TCALL) + (sizeof (TCALL) & 4);


        if (pCallParams->dwDisplayableAddressSize != 0)
        {
            CopyMemory(
                (ptCall->pszDisplayableAddress = (WCHAR *)
                    (((LPBYTE) ptCall) + dwOffset)),
                ((LPBYTE) pCallParams) +
                    pCallParams->dwDisplayableAddressOffset,
                (ptCall->dwDisplayableAddressSize =
                    pCallParams->dwDisplayableAddressSize)
                );

            dwOffset += ((ptCall->dwDisplayableAddressSize + 8) & 0xfffffff8);
        }

        if (pCallParams->dwCalledPartySize)
        {
            CopyMemory(
                (ptCall->pszCalledParty = (WCHAR *)
                    (((LPBYTE)ptCall) + dwOffset)),
                ((LPBYTE) pCallParams) + pCallParams->dwCalledPartyOffset,
                (ptCall->dwCalledPartySize = pCallParams->dwCalledPartySize)
                );

            dwOffset += ((ptCall->dwCalledPartySize + 8) & 0xfffffff8);
        }

        if (pCallParams->dwCommentSize)
        {
            CopyMemory(
                (ptCall->pszComment = (WCHAR *)
                    (((LPBYTE) ptCall) + dwOffset)),
                ((LPBYTE) pCallParams) + pCallParams->dwCommentOffset,
                (ptCall->dwCommentSize = pCallParams->dwCommentSize)
                );
        }
    }


    //
    // If this call has an associated call (i.e. this func is being
    // called during the processing of a lineSetupConference request)
    // then we want to make sure we get an htCall which maps to the
    // same SPEventHandlerThread as that of the associated call.
    // This is necessary on MP boxes (or any time we create > 1
    // SPEventHandlerThread) to prevent call state, etc msgs for
    // a call being processed (by thread A) prior to the call-creation
    // completion msg being processed (by thread B).
    //

    if (ptCallAssociate  &&  (gdwNumSPEventHandlerThreads > 1))
    {
        ptCall->hCall = (HCALL) NewObjectEx(
            ghHandleTable,
            ptCall,
            NULL,
            gdwNumSPEventHandlerThreads,
            (DWORD) MAP_HANDLE_TO_SP_EVENT_QUEUE_ID(
                (ULONG_PTR) ptLine->hLine
                )
            );
    }
    else
    {
        LOG((TL_INFO, "CreatetCall: calling NewObject ptCall %p", ptCall));

        ptCall->hCall = (HCALL) NewObject(
            ghHandleTable,
            ptCall,
            NULL
            );
    }

    LOG((TL_TRACE, "CreatetCall: NewObject returned 0x%lx", ptCall->hCall));
    

    if (!ptCall->hCall)
    {
        ServerFree (ptCall);
        return LINEERR_NOMEM;
    }


    //
    // Add the new tCall to the tLine's list
    //

    if (WaitForExclusivetLineAccess(
            ptLine,
            &hMutex,
            &bDupedMutex,
            INFINITE
            ))
    {
        ptCall->ptLine     = ptLine;
        ptCall->ptProvider = ptLine->ptProvider;

        if ((ptCall->pNext = ptLine->ptCalls))
        {
           ptCall->pNext->pPrev = ptCall;
        }

        ptLine->ptCalls = ptCall;

        MyReleaseMutex (hMutex, bDupedMutex);
    }
    else
    {
        //
        // tLine was destroyed, so clean up. Note that we return
        // a generic OPFAILED error, since some calling routines
        // might no be spec'd to return INVALLINEHANDLE, etc.
        //

        DereferenceObject (ghHandleTable, ptCall->hCall, 1);
        return LINEERR_OPERATIONFAILED;
    }


    //
    // Fill in caller's pointer & return success
    //

    *pptCall = ptCall;

    PerfBlock.dwTotalOutgoingCalls++;
    PerfBlock.dwCurrentOutgoingCalls++;

    //
    //  For incoming call, the call is ready to be used
    //
    if (bIncoming)
    {
        ptCall->dwKey = TCALL_KEY;
    }

    LOG((TL_TRACE,  "CreatetCall: exit, new ptCall=%p", *pptCall));

    return 0;
}


LONG
PASCAL
CreatetCallClient(
    PTCALL          ptCall,
    PTLINECLIENT    ptLineClient,
    DWORD           dwPrivilege,
    BOOL            bValidate,
    BOOL            bSendCallInfoMsg,
    PTCALLCLIENT   *pptCallClient,
    BOOL            bIndicatePrivilege
    )
{
    BOOL            bFastCallClient, bValidLineClient;
    PTCALLCLIENT    ptCallClient;
    PTLINECLIENT    ptLineClient2 = NULL;


    LOG((TL_TRACE,  "CreatetCallClient: enter, ptCall=%p,", ptCall));

    if (WaitForExclusivetCallAccess(
            ptCall,
            (bValidate ? TCALL_KEY : TINCOMPLETECALL_KEY)
            ))
    {
        if (ptCall->lUsedFastCallClients < DEF_NUM_FAST_CALLCLIENTS)
        {
            ptCallClient = ptCall->aFastCallClients +
                ptCall->lUsedFastCallClients++;
            ptCall->lActiveFastCallClients++;
            bFastCallClient = TRUE;
        }
        else if ((ptCallClient = ServerAlloc (sizeof(TCALLCLIENT))))
        {
            bFastCallClient = FALSE;
        }
        else
        {
            UNLOCKTCALL(ptCall);
            return LINEERR_NOMEM;
        }

        LOG((TL_INFO, "CreatetCallClient: calling NewObject, ptCallClient = [%p]", ptCallClient));

        if (!(ptCallClient->hCall = (HCALL) NewObject(
                ghHandleTable,
                ptCallClient,
                (LPVOID) UIntToPtr(bFastCallClient)
                )))
        {
            if (bFastCallClient)
            {
                ptCall->lActiveFastCallClients--;
                ptCall->lUsedFastCallClients--;
            }
            else
            {
                ServerFree (ptCallClient);
            }

            UNLOCKTCALL(ptCall);
            return LINEERR_NOMEM;
        }

        if (dwPrivilege == LINECALLPRIVILEGE_OWNER)
        {
            ptCall->dwNumOwners++;
        }
        else
        {
            ptCall->dwNumMonitors++;
        }

        if ((ptCallClient->pNextSametCall = ptCall->ptCallClients))
        {
            ptCallClient->pNextSametCall->pPrevSametCall =
                ptCallClient;
        }

        ptCall->ptCallClients = ptCallClient;

        UNLOCKTCALL (ptCall);

        ptCallClient->ptLineClient = ptLineClient;
        ptCallClient->ptCall       = ptCall;
        ptCallClient->dwPrivilege  = dwPrivilege;
        ptCallClient->bIndicatePrivilege = (bIndicatePrivilege ? 1 : 0);
    }
    else
    {
        //
        // tCall was destroyed, so return error. Note that we return
        // a generic OPFAILED error, since some calling routines
        // might not be spec'd to return INVALCALLHANDLE, etc.
        //

        return LINEERR_OPERATIONFAILED;
    }


    //
    // Add to tLineClient's tCallClient list
    //

    LOCKTLINECLIENT (ptLineClient);

    try
    {
        bValidLineClient =
            (ptLineClient->dwKey == TLINECLIENT_KEY ? TRUE : FALSE);
        if (bValidLineClient)
        {
            ptLineClient2 = (PTLINECLIENT) ReferenceObject (
                ghHandleTable,
                ptLineClient->hLine,
                TLINECLIENT_KEY
                );
            if (ptLineClient2 == NULL || ptLineClient != ptLineClient2)
            {
                bValidLineClient = FALSE;
            }
        }
    }
    myexcept
    {
        bValidLineClient = FALSE;
    }

    if (bValidLineClient)
    {
        ptCallClient->ptClient = ptLineClient->ptClient;

        if ((ptCallClient->pNextSametLineClient = ptLineClient->ptCallClients))
        {
            ptCallClient->pNextSametLineClient->pPrevSametLineClient =
                ptCallClient;
        }

        ptLineClient->ptCallClients = ptCallClient;

        if (ptLineClient2)
        {
            DereferenceObject (
                ghHandleTable,
                ptLineClient2->hLine,
                1
                );
        }

        if (ptLineClient->ptLineApp->dwAPIVersion <= TAPI_VERSION3_0)
        {
            FillMemory (
                ptCallClient->adwEventSubMasks, 
                sizeof(DWORD) * EM_NUM_MASKS,
                (BYTE) 0xff
                );
        }
        else
        {
            CopyMemory (
                ptCallClient->adwEventSubMasks, 
                ptLineClient->adwEventSubMasks,
                sizeof(DWORD) * EM_NUM_MASKS
                );
        }

        UNLOCKTLINECLIENT (ptLineClient);
    }
    else
    {
        if (ptLineClient2)
        {
            DereferenceObject (
                ghHandleTable,
                ptLineClient2->hLine,
                1
                );
        }

        UNLOCKTLINECLIENT (ptLineClient);


        //
        // Couldn't add tCallClient to tLineClient's list, so safely
        // remove it from tCall's list, dec the owner or monitor count,
        // free the tCallClient, and return an appropriate error
        //
        // Note that no validation of tCall is necessary - it has to be
        // valid since we previously added a tCallClient to it's list,
        // and that tCallClient's key was not yet validated (so any
        // threads attempting to destroy the tCall would be spinning)
        //

        LOCKTCALL (ptCall);

        if (dwPrivilege == LINECALLPRIVILEGE_OWNER)
        {
            ptCall->dwNumOwners--;
        }
        else
        {
            ptCall->dwNumMonitors--;
        }

        if (ptCallClient->pNextSametCall)
        {
            ptCallClient->pNextSametCall->pPrevSametCall =
                ptCallClient->pPrevSametCall;
        }

        if (ptCallClient->pPrevSametCall)
        {
            ptCallClient->pPrevSametCall->pNextSametCall =
                ptCallClient->pNextSametCall;
        }
        else
        {
            ptCall->ptCallClients = ptCallClient->pNextSametCall;
        }

        if (bFastCallClient)
        {
            ptCall->lActiveFastCallClients--;
        }

        UNLOCKTCALL (ptCall);

        DereferenceObject (ghHandleTable, ptCallClient->hCall, 1);

        return LINEERR_INVALLINEHANDLE;
    }


    //
    // If here success, so mark tCallClient as valid (if another thread
    // was tearing down the corresponding tCall or tLineClient it will
    // have been spinning waiting for us to validate this tCallClient)
    //

    ptCallClient->dwKey = (bValidate ? TCALLCLIENT_KEY :
        TINCOMPLETECALLCLIENT_KEY);


    //
    // Send a call info msg other call clients if appropriate
    //

    if (bSendCallInfoMsg)
    {
        SendMsgToCallClients(
            ptCall,
            ptCallClient,
            LINE_CALLINFO,
            (dwPrivilege == LINECALLPRIVILEGE_OWNER ?
                LINECALLINFOSTATE_NUMOWNERINCR :
                LINECALLINFOSTATE_NUMMONITORS),
            0,
            0
            );
    }


    //
    // Fill in caller's pointer & return success
    //

    *pptCallClient = ptCallClient;

    LOG((TL_TRACE, 
        "CreatetCallClient: exit, new ptCallClient=%p",
        *pptCallClient
        ));

    return 0;
}


LONG
PASCAL
CreatetCallAndClient(
    PTLINECLIENT        ptLineClient,
    PTCALL             *pptCall,
    PTCALLCLIENT       *pptCallClient,
    LPLINECALLPARAMS    pCallParams,
    PTCALL              ptCallAssociate
    )
{
    LONG            lResult = 0;
    DWORD           dwAppNameSize;
    WCHAR          *pszAppName = NULL;
    PTCALL          ptCall = NULL;
    PTLINE          ptLine;

    LOG((TL_TRACE,  "CreatetCallAndClient: enter, ptLineClient=%p", ptLineClient));

    try
    {
        ptLine = ptLineClient->ptLine;

        dwAppNameSize = ptLineClient->ptLineApp->dwFriendlyNameSize;

        if (ptLineClient->dwKey != TLINECLIENT_KEY)
        {
            lResult = LINEERR_INVALLINEHANDLE;
        }
        else if ((pszAppName = ServerAlloc (dwAppNameSize)))
        {
            CopyMemory(
                pszAppName,
                ptLineClient->ptLineApp->pszFriendlyName,
                dwAppNameSize
                );
        }
        else
        {
            lResult = LINEERR_NOMEM;
        }
    }
    myexcept
    {
        ServerFree (pszAppName);
        lResult = LINEERR_INVALLINEHANDLE;
    }

    if (lResult != 0)
    {
        return lResult;
    }

    if ((lResult = CreatetCall(
            ptLine,
            FALSE,
            (HDRVCALL) 0,
            &ptCall,
            pCallParams,
            ptCallAssociate

            )) != 0)
    {
        ServerFree (pszAppName);

        return lResult;
    }

    if ((lResult = CreatetCallClient(
            ptCall,
            ptLineClient,
            LINECALLPRIVILEGE_OWNER,
            FALSE,
            FALSE,
            pptCallClient,
            FALSE

            )) != 0)
    {
        ServerFree (pszAppName);

        ptCall->dwDrvCallFlags = DCF_SPIRETURNED;

        DestroytCall (ptCall);

        *pptCall = (PTCALL) NULL;
        return lResult;
    }

    ptCall->dwAppNameSize = dwAppNameSize;
    ptCall->pszAppName    = pszAppName;

    *pptCall = ptCall;

    return lResult;
}


LONG
PASCAL
CreateCallMonitors(
    PTCALL  ptCall,
    BOOL    bIncoming
    )
{
    //
    // This func is called by post processing routines when
    // a call was successfully created, or on receiving the
    // first call state message for an incoming call, at
    // which times we want to create call handles for any
    // monitoring apps.
    //
    // Assumes tCall only has has either no clients at all
    // or a single (owner) client
    //
    // Returns the # of monitor call clients created (>=0) or
    // an error value (<0)
    //

    LONG            lResult;
    BOOL            bInitializedMsgs, bRemote, bConfParent = FALSE;
    DWORD           i, dwAddressID, dwCallID, dwRelatedCallID;
    TPOINTERLIST    lineClients, *pLineClients = &lineClients;
    PTLINE          ptLine;
    PTLINECLIENT    ptLineClientOwner;
    ASYNCEVENTMSG   newCallMsg[2], callStateUnkMsg[2];


    //
    // Determine if this call is conf parent and get a list of line clients
    //

    try
    {
        PTCONFERENCELIST    pConfList;

        if ((pConfList = ptCall->pConfList) &&
            (pConfList != (PTCONFERENCELIST) LongToPtr(0xffffffff)) &&
            (pConfList->aptCalls[0] == ptCall))
        {
            bConfParent = TRUE;
        }
        dwAddressID     = ptCall->dwAddressID;
        dwCallID        = ptCall->dwCallID;
        dwRelatedCallID = ptCall->dwRelatedCallID;

        ptLine = (PTLINE) ptCall->ptLine;

        ptLineClientOwner = (ptCall->ptCallClients ?
            ptCall->ptCallClients->ptLineClient : NULL);
    }
    myexcept
    {
        return LINEERR_OPERATIONFAILED;
    }

    if ((lResult = GetLineClientListFromLine (ptLine, &pLineClients)))
    {
        return lResult;
    }


    //
    // Look at each line client in the list, and if it has
    // monitor privileges and is not the one associated with
    // the existing owner call client then create a monitor
    // call client
    //
    //

    bInitializedMsgs = FALSE;

    for (i = 0; i < pLineClients->dwNumUsedEntries; i++)
    {
        PTCALLCLIENT    ptCallClientMonitor;
        PTLINECLIENT    ptLineClient = pLineClients->aEntries[i];
        BOOL            fContinue;


        try
        {
            if (!(ptLineClient->dwPrivileges & LINECALLPRIVILEGE_MONITOR) ||
                (ptLineClient == ptLineClientOwner))
            {
                fContinue = TRUE;
            }
            else
            {
                fContinue = FALSE;

                bRemote = IS_REMOTE_CLIENT (ptLineClient->ptClient);
            }
        }
        myexcept
        {
            //
            // If here the tLineClient or tCallClient was destroyed,
            // just continue
            //

            fContinue = TRUE;
        }


        if (fContinue)
        {
            continue;
        }


        //
        // NOTE: If client is remote(sp) then create the call client
        //       with OWNER privileges so client can still do everything.
        //       The remote tapisrv will deal with all the remote
        //       privilege issues.  We'll still send the appropriate
        //       MONITOR privilege flag so the remote tapisrv will know
        //       not to look for an owner app.
        //
        //       This scheme might end up confusing other apps since
        //       a LINE_CALLINFO\NUMOWNERINCR (not NUMMONITORS) msgs
        //       get sent, but it certainly beats what we had in tapi 2.1 -
        //       that is, if a remote client did not initially have owner
        //       privilege then it could *never* get owner privilege.
        //

        if (CreatetCallClient(
                ptCall,
                ptLineClient,
                (bRemote ? LINECALLPRIVILEGE_OWNER :LINECALLPRIVILEGE_MONITOR),
                TRUE,
                FALSE,
                &ptCallClientMonitor,
                bIncoming

                ) == 0)
        {
            //
            // If this is an incoming call simply increment the number of
            // monitor call clients created and continue.
            //
            // Else this is an outgoing call, so send the monitor app
            // LINE_APPNEWCALL & LINE_CALLSTATE\UNKNOWN messages to alert
            // it of new outgoing call
            //

            if (bIncoming)
            {
                lResult++;
                continue;
            }

            if (!bInitializedMsgs)
            {
                
                
                newCallMsg->TotalSize          = sizeof (ASYNCEVENTMSG) +
                                                    3 * sizeof (DWORD);
                newCallMsg->fnPostProcessProcHandle = 0;
                newCallMsg->Msg                = LINE_APPNEWCALL;
                newCallMsg->Param1             = dwAddressID;
                newCallMsg->Param3             = LINECALLPRIVILEGE_MONITOR;

                *(&newCallMsg->Param4 + 1)     = dwCallID;
                *(&newCallMsg->Param4 + 2)     = dwRelatedCallID;
                *(&newCallMsg->Param4 + 3)     = (DWORD)bConfParent;

                callStateUnkMsg->TotalSize     = sizeof(ASYNCEVENTMSG)
                                                    + sizeof (HCALLHUB);

                callStateUnkMsg->fnPostProcessProcHandle = 0;
                callStateUnkMsg->Msg                = LINE_CALLSTATE;
                callStateUnkMsg->Param1             = LINECALLSTATE_UNKNOWN;

                *((LPHCALLHUB)(callStateUnkMsg + 1)) = (HCALLHUB)0;

                bInitializedMsgs = TRUE;
            }

            try
            {
                //
                // We're presenting the app with a new call handle; for
                // 2.0 & newer apps we indicate this with an APPNEWCALL
                // msg, while older apps just get the privilege field
                // set in the call state msg.
                //

                if (ptLineClient->ptLineApp->dwAPIVersion >= TAPI_VERSION2_0)
                {
                    if (!FMsgDisabled(
                        ptLineClient->ptLineApp->dwAPIVersion,
                        ptLineClient->adwEventSubMasks,
                        LINE_APPNEWCALL,
                        0
                        ))
                    {
                        newCallMsg->InitContext =
                            ptLineClient->ptLineApp->InitContext;
                        newCallMsg->hDevice     = ptLineClient->hRemoteLine;
                        newCallMsg->OpenContext = ptLineClient->OpenContext;
                        newCallMsg->Param2      = ptCallClientMonitor->hCall;

                        WriteEventBuffer (ptLineClient->ptClient, newCallMsg);
                    }

                    callStateUnkMsg->Param3 = 0;
                }
                else
                {
                    callStateUnkMsg->Param3 = LINECALLPRIVILEGE_MONITOR;
                }

                if (FMsgDisabled (
                    ptLineClient->ptLineApp->dwAPIVersion,
                    ptLineClient->adwEventSubMasks,
                    LINE_CALLSTATE,
                    LINECALLSTATE_UNKNOWN
                    ))
                {
                    continue;
                }
                    

                callStateUnkMsg->InitContext =
                    ptLineClient->ptLineApp->InitContext;

                callStateUnkMsg->hDevice     = ptCallClientMonitor->hCall;
                callStateUnkMsg->OpenContext = ptLineClient->OpenContext;
                 
                //
                // Indicate hRemoteLine in p4 to make life easier for remotesp
                //

                callStateUnkMsg->Param4 = ptLineClient->hRemoteLine;


                //
                // REMOTESP HACK: See note in LINE_CALLSTATE msg handler
                //

                if (IS_REMOTE_CLIENT (ptLineClient->ptClient))
                {
                    callStateUnkMsg->Param2 = LINECALLPRIVILEGE_MONITOR;
                    callStateUnkMsg->Param3 = LINEMEDIAMODE_UNKNOWN;
                }
                else
                {
                    callStateUnkMsg->Param2 = 0;
                }

                WriteEventBuffer (ptLineClient->ptClient, callStateUnkMsg);

                lResult++;
            }
            myexcept
            {
                // just continue
            }
        }
    }

    if (pLineClients != &lineClients)
    {
        ServerFree (pLineClients);
    }


    //
    // Now safely set the flag that says it's ok for other routines like
    // lineGetNewCalls to create new call handles for apps for this call
    //

    {
        if (WaitForExclusivetCallAccess (ptCall, TCALL_KEY))
        {
            //
            // Only do call hub hashing if there's >0 call clients,
            // since the (incoming) call will get destroyed otherwise
            //
            //  $$ Per bug 87355
            //  It is necessary to do DoCallHubHashing even if we do 
            //  not have a client now. So we removed the check for 
            //  ptCall->ptCallClients. For incoming call who has got
            //  an owner, we behave the same; for incoming call without
            //  an owner, we would hash the call for now and remove the
            //  call from hash table when destroying the call, so we 
            //  are safe either way.
            //

            DoCallHubHashing (ptCall, 0);

            ptCall->bCreatedInitialMonitors = TRUE;
            UNLOCKTCALL (ptCall);
        }
        else
        {
            lResult = LINEERR_OPERATIONFAILED;
        }
    }

    return lResult;

}


PTREQUESTRECIPIENT
PASCAL
GetHighestPriorityRequestRecipient(
    void
    )
{
    BOOL               bFoundRecipientInPriorityList = FALSE;
    WCHAR             *pszAppInPriorityList,
                      *pszAppInPriorityListPrev = (WCHAR *) LongToPtr(0xffffffff);
    PTREQUESTRECIPIENT pRequestRecipient,
                       pHighestPriorityRequestRecipient = NULL;


    EnterCriticalSection (&gPriorityListCritSec);

    pRequestRecipient = TapiGlobals.pRequestRecipients;

    while (pRequestRecipient)
    {
        if (TapiGlobals.pszReqMakeCallPriList &&

            (pszAppInPriorityList = wcsstr(
                TapiGlobals.pszReqMakeCallPriList,
                pRequestRecipient->ptLineApp->pszModuleName
                )))
        {
            if (pszAppInPriorityList <= pszAppInPriorityListPrev)
            {
                pHighestPriorityRequestRecipient = pRequestRecipient;
                pszAppInPriorityListPrev = pszAppInPriorityList;

                bFoundRecipientInPriorityList = TRUE;
            }
        }
        else if (!bFoundRecipientInPriorityList)
        {
            pHighestPriorityRequestRecipient = pRequestRecipient;
        }

        pRequestRecipient = pRequestRecipient->pNext;
    }

    LeaveCriticalSection (&gPriorityListCritSec);

    return pHighestPriorityRequestRecipient;
}


void
PASCAL
FreetCall(
    PTCALL  ptCall
    )
{
    if (ptCall->pszAppName)
    {
        ServerFree (ptCall->pszAppName);
    }

    if (ptCall->dwDrvCallFlags & DCF_INCOMINGCALL)
    {
        PerfBlock.dwCurrentIncomingCalls--;
    }
    else
    {
        PerfBlock.dwCurrentOutgoingCalls--;
    }

    DereferenceObject (ghHandleTable, ptCall->hCall, 1);
}


void
PASCAL
DestroytCall(
    PTCALL  ptCall
    )
{
    DWORD   dwKey;


    LOG((TL_TRACE, "DestroytCall: enter, ptCall=x%p", ptCall));


    //
    // Safely get the call's current key, then grab the call's lock.
    // The two waits allow us to deal with the case where the tCall's
    // key is either TINCOMPLETECALL_KEY or TCALL_KEY, or changing
    // from the former to the latter (the completion proc was called)
    //

    try
    {
        dwKey = (ptCall->dwKey == TCALL_KEY ? TCALL_KEY : TINCOMPLETECALL_KEY);
    }
    myexcept
    {
        LOG((TL_ERROR, "DestroytCall: excepted looking at key"));
        return;
    }

    if (WaitForExclusivetCallAccess (ptCall, dwKey) ||
        WaitForExclusivetCallAccess (ptCall, TCALL_KEY))

    {
        PTPROVIDER  ptProvider;
        PTCALL      ptCall2;

        ptCall2 = ReferenceObject (
            ghHandleTable,
            ptCall->hCall,
            dwKey
            );
        if (ptCall2)
        {
            DereferenceObject (
                ghHandleTable,
                ptCall2->hCall,
                1
                );
        }
        if (ptCall2 == NULL || ptCall != ptCall2)
        {
            UNLOCKTCALL (ptCall);
            return;
        }


        //
        // Invalidate the tCall
        //

        ptCall->dwKey = TZOMBIECALL_KEY;
        UNLOCKTCALL (ptCall);


        //
        // If the provider has not returned from it's call-creation
        // routine yet (i.e. TSPI_lineMakeCall) wait for it to do so
        //

        while (!(ptCall->dwDrvCallFlags & DCF_SPIRETURNED))
        {
            Sleep (0);
        }

        ptProvider = ptCall->ptProvider;


        //
        // Remove tCall from call hub list if appropriate
        //
        // Note that there's a window of time between which the call IDs
        // are retrieved and the call is inserted in a hash time, and so
        // we need to check for that case as well (CallHubList.Flink == 0)
        //

        if (ptCall->dwCallID != 0)
        {
            PTHASHTABLEENTRY    pStaticEntry, pEntry;


            pStaticEntry = AcquireHashTableEntryLock(
                ptCall->ptProvider,
                ptCall->dwCallID
                );

            if (ptCall->CallHubList.Flink == 0 ||
                ptCall->CallHubList.Blink == 0)
            {
                ReleaseHashTableEntryLock (ptCall->ptProvider, pStaticEntry);
                goto finished_callhubID;
            }

            RemoveEntryList (&ptCall->CallHubList);
            ptCall->CallHubList.Flink = NULL;
            ptCall->CallHubList.Blink = NULL;

            pEntry = (pStaticEntry->dwCallHubID == ptCall->dwCallID ?
                pStaticEntry :
                FindDynamicHashTableEntry (pStaticEntry, ptCall->dwCallID)
                );

            if (IsListEmpty (&pEntry->CallHubList))
            {
                PTCALLHUBCLIENT  ptCallHubClient, pNext;


                ptCallHubClient = pEntry->ptCallHubClients;

                if (pEntry == pStaticEntry)
                {
                    pStaticEntry->dwCallHubID = 0;
                    pStaticEntry->ptCallHubClients = NULL;
                }
                else
                {
                    RemoveDynamicHashTableEntry(
                        ptProvider,
                        pStaticEntry,
                        pEntry
                        );
                }

                ReleaseHashTableEntryLock (ptCall->ptProvider, pStaticEntry);

                if (ptCallHubClient)
                {
                    ASYNCEVENTMSG   msg;


                    pEntry->ptCallHubClients = NULL;

                    msg.TotalSize          = sizeof (ASYNCEVENTMSG);
                    msg.Msg                = LINE_CALLHUBCLOSE;
                    msg.fnPostProcessProcHandle = 0;
                    msg.hDevice            = 0;
                    msg.OpenContext        = 0;
                    msg.Param2             = 0;
                    msg.Param3             = 0;

                    while (ptCallHubClient)
                    {
                        msg.Param1 = ptCallHubClient->hCallHub;

                        try
                        {
                            msg.InitContext =
                                ptCallHubClient->ptLineApp->InitContext;

                            if (ptCallHubClient->ptLineApp->dwKey ==
                                    TLINEAPP_KEY &&
                                (!FMsgDisabled(
                                    ptCallHubClient->ptLineApp->dwAPIVersion,
                                    ptCallHubClient->ptLineApp->adwEventSubMasks,
                                    LINE_CALLHUBCLOSE,
                                    0
                                    )))
                            {
                                WriteEventBuffer(
                                    ptCallHubClient->ptClient,
                                    &msg
                                    );
                            }
                        }
                        except (EXCEPTION_EXECUTE_HANDLER)
                        {
                            // tLineApp is gone, just fall through
                        }

                        pNext = ptCallHubClient->pNext;
                        ptCallHubClient->dwKey = INVAL_KEY;

                        DereferenceObject(
                            ghHandleTable, 
                            ptCallHubClient->hCallHub,
                            1
                            );

                        ptCallHubClient = pNext;
                    }
                }
            }
            else
            {
                ReleaseHashTableEntryLock (ptCall->ptProvider, pStaticEntry);
            }
        }
        
finished_callhubID:

        //
        // Destroy all the tCallClient's
        //

        if (ptCall->ptCallClients)
        {
            while (ptCall->ptCallClients)
            {
                DestroytCallClient (ptCall->ptCallClients);
            }
        }


        //
        // Tell the provider to close the call, but only if the hdCall
        // is valid (we might be destroying a call that
        // LMakeCall_PostProcess would normally destroy in the event
        // of a failed make-call request, and we wouldn't want to pass
        // an invalid hdCall to the driver)
        //

        if (ptCall->dwDrvCallFlags & DCF_DRVCALLVALID)
        {
            if (ptProvider->dwTSPIOptions & LINETSPIOPTION_NONREENTRANT)
            {
                WaitForSingleObject (ptProvider->hMutex, INFINITE);
            }

            if (ptProvider->apfn[SP_LINECLOSECALL])
            {
                CallSP1(
                    ptProvider->apfn[SP_LINECLOSECALL],
                    "lineCloseCall",
                    SP_FUNC_SYNC,
                    (ULONG_PTR) ptCall->hdCall
                    );
            }

            if (ptProvider->dwTSPIOptions & LINETSPIOPTION_NONREENTRANT)
            {
                ReleaseMutex (ptProvider->hMutex);
            }
        }


        //
        // Remove tCall from the tLine's tCall list
        //

        RemoveCallFromLineList (ptCall);


        //
        // Free the resources
        //

        {
            PTCONFERENCELIST    pConfList;


            if ((pConfList = ptCall->pConfList) &&
                (pConfList != (PTCONFERENCELIST) LongToPtr(0xffffffff)))
            {
                DWORD   i;

                if (pConfList->aptCalls[0] == ptCall)
                {
                    //
                    // We're destroying a conf parent so we want to zero
                    // out the pConfList field of all the conf children,
                    // essentially removing them from the conference.
                    //

                    TPOINTERLIST    confCallList,
                                    *pConfCallList = &confCallList;


                    if (GetConfCallListFromConf(
                            pConfList,
                            &pConfCallList

                            ) == 0)
                    {
                        for(
                            i = 1;
                            i < pConfCallList->dwNumUsedEntries;
                            i++
                            )
                        {
                            SetCallConfList(
                                pConfCallList->aEntries[i],
                                NULL,
                                FALSE
                                );
                        }

                        if (pConfCallList != &confCallList)
                        {
                            ServerFree (pConfCallList);
                        }
                    }

                    while (pConfList)
                    {
                        PTCONFERENCELIST    pNextConfList =
                                                pConfList->pNext;


                        ServerFree (pConfList);
                        pConfList = pNextConfList;
                    }
                }
                else
                {
                }
            }
        }

        while (ptCall->lActiveFastCallClients != 0)
        {
            Sleep (5);
        }

        FreetCall (ptCall);
    }
    else
    {
        LOG((TL_ERROR, "DestroytCall: two waits failed!"));
    }

}


void
PASCAL
DestroytCallClient(
    PTCALLCLIENT    ptCallClient
    )
{
    BOOL            bUnlock = FALSE,
                    bExit = TRUE,
                    bDestroytCall,
                    bSendCallInfoMsgs,
                    bFastCallClient;
    HCALL           hCall;
    PTCALL          ptCall;
    PTCALLCLIENT    ptCallClient2;


    LOG((TL_TRACE, "DestroytCallClient: enter, ptCallCli=x%p", ptCallClient));

    //
    // Check that this is a valid tCallClient, & if so lock the
    // corresponding tCall (and recheck)
    //

    try
    {
        if (ptCallClient->dwKey == TINCOMPLETECALLCLIENT_KEY ||
            ptCallClient->dwKey == TCALLCLIENT_KEY)
        {
            ptCall = ptCallClient->ptCall;

            LOCKTCALL (ptCall);

            bUnlock = TRUE;

            //
            //  Check to be sure we are working on a valid memory
            //
            
            ptCallClient2 = ReferenceObject (
                ghHandleTable,
                ptCallClient->hCall,
                ptCallClient->dwKey
                );
            if (ptCallClient2 != NULL)
            {
                DereferenceObject (
                    ghHandleTable,
                    ptCallClient2->hCall,
                    1
                    );
            }

            if ((ptCallClient->dwKey == TINCOMPLETECALLCLIENT_KEY ||
                ptCallClient->dwKey == TCALLCLIENT_KEY) &&
                ptCall == ptCallClient->ptCall &&
                ptCallClient2 == ptCallClient)

            {
                //
                // We can continue detroying this tCallClient
                //
                bExit = FALSE;
            }
        }
    }
    myexcept
    {
        LOG((TL_ERROR, "DestroytCallClient: %lx faulted looking at key",
                     ptCallClient ));
    }

    if (bExit)
    {
        if (bUnlock)
        {
            UNLOCKTCALL (ptCall);
        }

        return;
    }


    //
    // Mark tCallClient as bad
    //

    ptCallClient->dwKey = INVAL_KEY;


    //
    // Munge tCall's num owners/monitors fields
    //

    if (ptCallClient->dwPrivilege == LINECALLPRIVILEGE_OWNER)
    {
        ptCall->dwNumOwners--;

        //
        // NOTE: per bug #20545 we're no longer auto-dropping
        //       non-IDLE calls; figured this would be the
        //       wrong thing to do in a distributed system
        //
        //       dankn 02/15/96
        //
    }
    else
    {
        ptCall->dwNumMonitors--;

        //
        // NOTE: per bug #20545 we're no longer auto-dropping
        //       non-IDLE calls; figured this would be the
        //       wrong thing to do in a distributed system
        //
        //       dankn 02/15/96
        //
    }


    //
    // Remove it from the tCall's tCallClient list
    //

    bDestroytCall = FALSE;
    bSendCallInfoMsgs = (ptCall->dwKey == TCALL_KEY ? TRUE : FALSE);

    if (ptCallClient->pNextSametCall)
    {
        ptCallClient->pNextSametCall->pPrevSametCall =
            ptCallClient->pPrevSametCall;
    }

    if (ptCallClient->pPrevSametCall)
    {
        ptCallClient->pPrevSametCall->pNextSametCall =
            ptCallClient->pNextSametCall;
    }
    else if (ptCallClient->pNextSametCall)
    {
        ptCall->ptCallClients = ptCallClient->pNextSametCall;
    }
    else // last call client so destroy the tCall too
    {
        ptCall->ptCallClients = NULL;
        bDestroytCall = TRUE;
    }

    UNLOCKTCALL (ptCall);


    //
    // Remove tCallClient from the tLineClient's tCallClient list
    //

    RemoveCallClientFromLineClientList (ptCallClient);


    //
    // Save the hCall in a local because it won't be safe to access
    // ptCallClient->hCall once we've decremented
    // ptCall->lActiveFastCallClients below
    //

    hCall = ptCallClient->hCall;


    //
    // If this is a fast call client decrement the number of active
    // fast call clients prior to calling DestroytCall
    //

    bFastCallClient = (ptCallClient >= ptCall->aFastCallClients &&
        ptCallClient < (ptCall->aFastCallClients + DEF_NUM_FAST_CALLCLIENTS));

    if (bFastCallClient)
    {
        InterlockedDecrement (&ptCall->lActiveFastCallClients);
    }

    if (bDestroytCall)
    {
        DestroytCall (ptCall);
        bSendCallInfoMsgs = FALSE;
    }


    //
    // Send call info msgs as appropriate
    //

    if (bSendCallInfoMsgs)
    {
        SendMsgToCallClients(
            ptCall,
            NULL,
            LINE_CALLINFO,
            (ptCallClient->dwPrivilege ==
                LINECALLPRIVILEGE_OWNER ?
                LINECALLINFOSTATE_NUMOWNERDECR :
                LINECALLINFOSTATE_NUMMONITORS),
            0,
            0
            );
    }


    //
    // Decrement reference count remove the initial (creation) reference
    //

    DereferenceObject (ghHandleTable, hCall, 1);
}


void
PASCAL
DestroytLine(
    PTLINE  ptLine,
    BOOL    bUnconditional
    )
{
    BOOL    bCloseMutex;
    HANDLE  hMutex;


    LOG((TL_TRACE, 
        "DestroytLine: enter, ptLine=x%p, bUnconditional=%d",
        ptLine,
        bUnconditional
        ));

    if (WaitForExclusivetLineAccess(
            ptLine,
            &hMutex,
            &bCloseMutex,
            INFINITE
            ))
    {
        //
        // If the key is bad another thread is in the process of
        // destroying this widget, so just release the mutex &
        // return. Otherwise, if this is a conditional destroy
        // & there are existing clients (which can happen when
        // one app is closing the last client just as another app
        // is creating one) just release the mutex & return.
        // Otherwise, mark the widget as bad and proceed with
        // the destroy; also, send CLOSE msgs to all the clients
        // (note that we have to do this manually rather than via
        // SendMsgToLineClients since 1) we don't want to hold the
        // mutex when sending msgs [deadlock], and 2) we mark the
        // dwKey as invalid)
        //

        {
            BOOL            bExit;
            TPOINTERLIST    fastClientList, *pClientList = &fastClientList;


            if (ptLine->dwKey == TLINE_KEY &&
                (bUnconditional == TRUE  ||  ptLine->ptLineClients == NULL))
            {
                if (GetLineClientListFromLine (ptLine, &pClientList) != 0)
                {
                    //
                    // If here we know there's at least a few entries
                    // in the fastClientList (DEF_NUM_PTR_LIST_ENTRIES
                    // to be exact), so we'll just work with that list
                    // and at least get msgs out to a few clients
                    //

                    pClientList = &fastClientList;

                    fastClientList.dwNumUsedEntries =
                        DEF_NUM_PTR_LIST_ENTRIES;
                }

                ptLine->dwKey = INVAL_KEY;
                bExit = FALSE;
            }
            else
            {
                bExit = TRUE;
            }

            MyReleaseMutex (hMutex, bCloseMutex);

            if (bExit)
            {
                LOG((TL_TRACE, 
                    "DestroytLine: exit, didn't destroy tLine=x%p",
                    ptLine
                    ));

                return;
            }

            if (pClientList->dwNumUsedEntries)
            {
                DWORD           i;
                PTCLIENT        ptClient;
                PTLINECLIENT    ptLineClient;
                ASYNCEVENTMSG   msg;


                ZeroMemory (&msg, sizeof (msg));

                msg.TotalSize = sizeof (ASYNCEVENTMSG);
                msg.Msg       = LINE_CLOSE;

                for (i = 0; i < pClientList->dwNumUsedEntries; i++)
                {
                    ptLineClient = (PTLINECLIENT) pClientList->aEntries[i];

                    try
                    {
                        msg.InitContext = ptLineClient->ptLineApp->InitContext;
                        msg.hDevice     = ptLineClient->hRemoteLine;
                        msg.OpenContext = ptLineClient->OpenContext;

                        ptClient = ptLineClient->ptClient;

                        if (ptLineClient->dwKey == TLINECLIENT_KEY &&
                            (!FMsgDisabled(
                                ptLineClient->ptLineApp->dwAPIVersion,
                                ptLineClient->adwEventSubMasks,
                                LINE_CLOSE,
                                0
                                )))
                        {
                            WriteEventBuffer (ptClient, &msg);
                        }
                    }
                    myexcept
                    {
                        // do nothing
                    }
                }
            }

            if (pClientList != &fastClientList)
            {
                ServerFree (pClientList);
            }
        }


        //
        // Destroy all the widget's clients.  Note that we want to
        // grab the mutex (and we don't have to dup it, since this
        // thread will be the one to close it) each time we reference
        // the list of clients, since another thread might be
        // destroying a client too.
        //

        {
            HLINE   hLine;


            hMutex = ptLine->hMutex;

destroy_tLineClients:

            WaitForSingleObject (hMutex, INFINITE);

            hLine = (ptLine->ptLineClients ?
                ptLine->ptLineClients->hLine : (HLINE) 0);

            ReleaseMutex (hMutex);

            if (hLine)
            {
                DestroytLineClient (hLine);
                goto destroy_tLineClients;
            }
        }


        //
        // There may yet be some tCall's hanging around, i.e. incoming
        // calls that we have not processed the 1st call state msg for
        // and hence have no associated owner/monitor that would have
        // been destroyed in the loop above, so destroy any of these
        // before proceeding
        //
        //

        {
            PTCALL  ptCall;


destroy_UnownedtCalls:

            WaitForSingleObject (hMutex, INFINITE);

            ptCall = ptLine->ptCalls;

            ReleaseMutex (hMutex);

            if (ptCall)
            {
                DestroytCall (ptCall);
                goto destroy_UnownedtCalls;
            }
        }


        //
        // Tell the provider to close the widget
        //

        {
            PTPROVIDER          ptProvider = ptLine->ptProvider;
            PTLINELOOKUPENTRY   pEntry;
            
            pEntry = GetLineLookupEntry (ptLine->dwDeviceID);

            if (ptProvider->dwTSPIOptions & LINETSPIOPTION_NONREENTRANT)
            {
                WaitForSingleObject (ptProvider->hMutex, INFINITE);
            }

            if ( ptProvider->apfn[SP_LINECLOSE] && 
                 pEntry &&
                 !pEntry->bRemoved
               )
            {
                CallSP1(
                    ptProvider->apfn[SP_LINECLOSE],
                    "lineClose",
                    SP_FUNC_SYNC,
                    (ULONG_PTR) ptLine->hdLine
                    );
            }

            if (ptProvider->dwTSPIOptions & LINETSPIOPTION_NONREENTRANT)
            {
                ReleaseMutex (ptProvider->hMutex);
            }
        }


        //
        // NULLify the ptLine field in the lookup entry, so LOpen will
        // know it has to open the SP's line on the next open request
        //

        {
            PTLINELOOKUPENTRY   pEntry;


            pEntry = GetLineLookupEntry (ptLine->dwDeviceID);
            if (NULL != pEntry)
            {
                pEntry->ptLine = NULL;
            }
        }

        DereferenceObject (ghHandleTable, ptLine->hLine, 1);
    }
    else
    {
        LOG((TL_ERROR, 
        "DestroytLine: WaitForExclusivetLineAccess failed"
        ));
    }

    // PERF

    if (PerfBlock.dwLinesInUse)
    {
        PerfBlock.dwLinesInUse--;
    }
    else
    {
        LOG((TL_INFO, "PERF: dwNumLinesInUse below 0"));
    }

    LOG((TL_TRACE,  "DestroytLine: exit, destroyed line=x%p", ptLine));
}


void
PASCAL
DestroytLineClient(
    HLINE   hLine
    )
{
    BOOL            bDupedMutex;
    HANDLE          hMutex;
    PTLINECLIENT    ptLineClient;


    LOG((TL_TRACE,  "DestroytLineClient: enter, hLine=x%x", hLine));

    if (!(ptLineClient = ReferenceObject (ghHandleTable, hLine, 0)))
    {
        return;
    }


    //
    // If we can get exclusive access to this tLineClient then mark
    // it (the dwKey) as bad & continue with teardown.  Else, another
    // thread is already in the process of destrying this tLineClient
    //
    //

    if (WaitForExclusiveLineClientAccess (ptLineClient))
    {
        BOOL    bSendDevStateCloseMsg = FALSE;
        DWORD   dwProxyCloseMsgs = 0;
        PTLINE  ptLine;
        PTPROVIDER ptProvider = ptLineClient->ptLine->ptProvider;
        HANDLE  hProviderMutex = NULL;


        if (ptProvider->dwTSPIOptions & LINETSPIOPTION_NONREENTRANT)
        {
            hProviderMutex = ptProvider->hMutex;
        }

        ptLineClient->dwKey = INVAL_KEY;

        //
        //  Remove the proxy server publishing if any
        //
        if (ptLineClient->szProxyClsid)
        {
            OnProxyLineClose (ptLineClient->szProxyClsid);
            ServerFree (ptLineClient->szProxyClsid);
        }

        //
        // Destroy all the tCallClients.  Note that we want to grab the
        // lock each time we reference the list of tCallClient's, since
        // another thread might be destroying a tCallClient too.
        //

        {
            PTCALLCLIENT    ptCallClient;


destroy_tCallClients:

            ptCallClient = ptLineClient->ptCallClients;

            UNLOCKTLINECLIENT (ptLineClient);

            if (ptCallClient)
            {
                DestroytCallClient (ptCallClient);
                LOCKTLINECLIENT (ptLineClient);
                goto destroy_tCallClients;
            }
        }


        //
        // Remove tLineClient from tLineApp's list.  Note that we don't
        // have to worry validating the tLineApp here, since we know
        // it's valid (another thread trying to destroy the tLineApp
        // will be spinning until the tLineClient we're destroying here
        // is removed from the tLineApp's list)
        //

        {
            PTLINEAPP   ptLineApp = (PTLINEAPP) ptLineClient->ptLineApp;


            LOCKTLINEAPP (ptLineApp);

            if (ptLineClient->pNextSametLineApp)
            {
                ptLineClient->pNextSametLineApp->pPrevSametLineApp =
                    ptLineClient->pPrevSametLineApp;
            }

            if (ptLineClient->pPrevSametLineApp)
            {
                ptLineClient->pPrevSametLineApp->pNextSametLineApp =
                    ptLineClient->pNextSametLineApp;
            }
            else
            {
                ptLineApp->ptLineClients = ptLineClient->pNextSametLineApp;
            }

            UNLOCKTLINEAPP (ptLineApp);
        }


        //
        // Grab the tLine's mutex & start munging.  Note that we don't
        // have to worry about dup-ing the mutex here because we know
        // it's valid & won't get closed before we release it.
        //

        ptLine = ptLineClient->ptLine;
        hMutex = ptLine->hMutex;
        WaitForSingleObject (hMutex, INFINITE);


        //
        // If client had call hub tracking enabled then adjust tLine
        //

        if (ptLineClient->dwCurrentTracking)
        {
            --ptLine->dwNumCallHubTrackers;

            if ((ptLineClient->dwCurrentTracking &
                    LINECALLHUBTRACKING_PROVIDERLEVEL) &&
                (--ptLine->dwNumCallHubTrackersSPLevel == 0))
            {
                const LINECALLHUBTRACKINGINFO trackingInfo =
                {
                    sizeof (LINECALLHUBTRACKINGINFO),
                    sizeof (LINECALLHUBTRACKINGINFO),
                    sizeof (LINECALLHUBTRACKINGINFO),
                    0,
                    LINECALLHUBTRACKING_NONE
                };


                if (hProviderMutex)
                {
                    WaitForSingleObject (hProviderMutex, INFINITE);
                }
                if (ptLine->ptProvider->apfn[SP_LINESETCALLHUBTRACKING])
                {
                    CallSP2(
                        ptLine->ptProvider->apfn[SP_LINESETCALLHUBTRACKING],
                        "lineSetCallHubTracking",
                        SP_FUNC_SYNC,
                        (ULONG_PTR) ptLine->hdLine,
                        (ULONG_PTR) &trackingInfo
                        );
                }
                if (hProviderMutex)
                {
                    ReleaseMutex (hProviderMutex);
                }
            }
        }


        //
        // If client registered as a proxy then unregister it
        //

        if (ptLineClient->dwPrivileges & LINEOPENOPTION_PROXY)
        {
            DWORD i;

            for(
                i = LINEPROXYREQUEST_SETAGENTGROUP;
                i <= LINEPROXYREQUEST_LASTVALUE;
                i++
                )
            {
                if (ptLine->apProxys[i] == ptLineClient)
                {
                    //
                    // Alert other clients that a proxy close has occured
                    //

                    LOG((TL_INFO, "tell clients proxy %02X closed", i));

                    dwProxyCloseMsgs |= (1 << (i - 1));

                    ptLine->apProxys[i] = NULL;
                }
            }
        }


        //
        //
        //

        if (ptLineClient->dwExtVersion)
        {
            if ((--ptLine->dwExtVersionCount) == 0)
            {
                if (hProviderMutex)
                {
                    WaitForSingleObject (hProviderMutex, INFINITE);
                }
                if (ptLine->ptProvider->apfn[SP_LINESELECTEXTVERSION])
                {
                    CallSP2(
                        ptLine->ptProvider->apfn[SP_LINESELECTEXTVERSION],
                        "lineSelectExtVersion",
                        SP_FUNC_SYNC,
                        (ULONG_PTR) ptLine->hdLine,
                        (DWORD) 0
                        );
                }
                if (hProviderMutex)
                {
                    ReleaseMutex (hProviderMutex);
                }

                ptLine->dwExtVersion = 0;
            }
        }


        //
        // Remove the tLineClient from the tLine's list & decrement
        // the number of opens
        //

        if (ptLineClient->pNextSametLine)
        {
            ptLineClient->pNextSametLine->pPrevSametLine =
                ptLineClient->pPrevSametLine;
        }

        if (ptLineClient->pPrevSametLine)
        {
            ptLineClient->pPrevSametLine->pNextSametLine =
                ptLineClient->pNextSametLine;
        }
        else
        {
            ptLine->ptLineClients = ptLineClient->pNextSametLine;
        }

        ptLine->dwNumOpens--;


        //
        // See if we need to reset the monitored media modes or close
        // the tLine (still hanging on the the mutex)
        //

        if (ptLine->dwKey == TLINE_KEY)
        {
            LOG((TL_INFO, "It's a line_key"));
            if (ptLine->ptLineClients)
            {
                LOG((TL_INFO, "...and there are still clients"));
                if (ptLine->dwOpenMediaModes && ptLineClient->dwMediaModes)
                {
                    DWORD           dwUnionMediaModes = 0;
                    PTLINECLIENT    ptLineClientTmp =
                                        ptLine->ptLineClients;


                    while (ptLineClientTmp)
                    {
                        if (ptLineClientTmp->dwPrivileges &
                                LINECALLPRIVILEGE_OWNER)
                        {
                            dwUnionMediaModes |=
                                ptLineClientTmp->dwMediaModes;
                        }

                        ptLineClientTmp = ptLineClientTmp->pNextSametLine;
                    }

                    if (dwUnionMediaModes != ptLine->dwOpenMediaModes)
                    {
                        LONG        lResult;

                        if (hProviderMutex)
                        {
                            WaitForSingleObject (hProviderMutex, INFINITE);
                        }
                        if (ptLine->ptProvider->apfn
                                [SP_LINESETDEFAULTMEDIADETECTION])
                        {
                            lResult = CallSP2(
                                ptLine->ptProvider->apfn
                                    [SP_LINESETDEFAULTMEDIADETECTION],
                                "lineSetDefaultMediaDetection",
                                SP_FUNC_SYNC,
                                (ULONG_PTR) ptLine->hdLine,
                                (DWORD) dwUnionMediaModes
                                );
                        }
                        else
                        {
                            lResult = LINEERR_OPERATIONUNAVAIL;
                        }
                        if (hProviderMutex)
                        {
                            ReleaseMutex (hProviderMutex);
                        }

                        ptLine->dwOpenMediaModes = dwUnionMediaModes;
                    }
                }

                bSendDevStateCloseMsg = TRUE;


                //
                // See if we need to reset the status msgs (if so, make
                // sure to check/set the busy flag & not to hold the
                // mutex while calling down to provider - see comments
                // in LSetStatusMessages)
                //

                if ((ptLineClient->dwLineStates & ~LINEDEVSTATE_REINIT) ||
                    ptLineClient->dwAddressStates)
                {
                    DWORD           dwUnionLineStates = 0,
                                    dwUnionAddressStates = 0;
                    PTLINECLIENT    ptLC;


                    while (ptLine->dwBusy)
                    {
                        BOOL    bClosed = TRUE;


                        ReleaseMutex (hMutex);
                        Sleep (50);
                        WaitForSingleObject (hMutex, INFINITE);

                        try
                        {
                            if (ptLine->dwKey == TLINE_KEY)
                            {
                                bClosed = FALSE;
                            }
                        }
                        myexcept
                        {
                            // do nothing
                        }

                        if (bClosed)
                        {
                            goto releasMutex;
                        }
                    }

                    for(
                        ptLC = ptLine->ptLineClients;
                        ptLC;
                        ptLC = ptLC->pNextSametLine
                        )
                    {
                        dwUnionLineStates    |= ptLC->dwLineStates;
                        dwUnionAddressStates |= ptLC->dwAddressStates;
                    }

                    if ((dwUnionLineStates != ptLine->dwUnionLineStates)  ||
                        (dwUnionAddressStates != ptLine->dwUnionAddressStates))
                    {
                        if (ptLine->ptProvider->apfn[SP_LINESETSTATUSMESSAGES])
                        {
                            LONG        lResult;
                            TSPIPROC    pfn;
                            HDRVLINE    hdLine = ptLine->hdLine;


                            pfn = ptLine->ptProvider->
                                apfn[SP_LINESETSTATUSMESSAGES];

                            ptLine->dwBusy = 1;

                            ReleaseMutex (hMutex);

                            if (hProviderMutex)
                            {
                                WaitForSingleObject (hProviderMutex, INFINITE);
                            }
                            lResult = CallSP3(
                                pfn,
                                "lineSetStatusMessages",
                                SP_FUNC_SYNC,
                                (ULONG_PTR) hdLine,
                                (DWORD) dwUnionLineStates,
                                (DWORD) dwUnionAddressStates
                                );
                                if (hProviderMutex)
                                {
                                    ReleaseMutex (hProviderMutex);
                                }

                            WaitForSingleObject (hMutex, INFINITE);

                            try
                            {
                                if (ptLine->dwKey == TLINE_KEY)
                                {
                                    ptLine->dwBusy = 0;

                                    if (lResult == 0)
                                    {
                                        ptLine->dwUnionLineStates =
                                            dwUnionLineStates;
                                        ptLine->dwUnionAddressStates =
                                            dwUnionAddressStates;
                                    }
                                }
                            }
                            myexcept
                            {
                                // do nothing
                            }
                        }
                    }
                }
            }
            else
            {
                //
                // This was the last client so destroy the tLine too
                //

                LOG((TL_INFO, "...and it's the last one out"));

                ReleaseMutex (hMutex);
                hMutex = NULL;
                DestroytLine (ptLine, FALSE); // conditional destroy
            }
        }

releasMutex:

        if (hMutex)
        {
            ReleaseMutex (hMutex);
        }


        //
        // Now that the mutex is released send any necessary msgs
        //

        if (bSendDevStateCloseMsg)
        {
            DWORD   dwOrdinal, dwBitFlag;


            SendMsgToLineClients(
                ptLine,
                NULL,
                LINE_LINEDEVSTATE,
                LINEDEVSTATE_CLOSE,
                0,
                0
                );

            for(
                dwOrdinal = LINEPROXYREQUEST_SETAGENTGROUP, dwBitFlag = 1;
                dwProxyCloseMsgs != 0;
                dwOrdinal++, dwBitFlag <<= 1)
            {
                if (dwProxyCloseMsgs & dwBitFlag)
                {
                    SendMsgToLineClients(
                        ptLine,
                        NULL,
                        LINE_PROXYSTATUS,
                        LINEPROXYSTATUS_CLOSE,
                        dwOrdinal,              // LINEPROXYREQUEST_xx
                        0
                        );

                    dwProxyCloseMsgs ^= dwBitFlag;
                }
            }
        }


        //
        // Complete any remaining
        // proxy requests
        //

        if (ptLineClient->dwPrivileges & LINEOPENOPTION_PROXY)
        {
            PASYNCREQUESTINFO   pAsyncRequestInfo =
                                    ptLineClient->pPendingProxyRequests,
                                pNextAsyncRequestInfo;


            while (pAsyncRequestInfo)
            {
                pNextAsyncRequestInfo = (PASYNCREQUESTINFO)
                    pAsyncRequestInfo->dwParam5;

                pAsyncRequestInfo->dwKey = TASYNC_KEY;

                CompletionProc (pAsyncRequestInfo, LINEERR_OPERATIONUNAVAIL);

                DereferenceObject(
                    ghHandleTable,
                    pAsyncRequestInfo->dwLocalRequestID,
                    1
                    );

                pAsyncRequestInfo = pNextAsyncRequestInfo;
            }
        }


        //
        // Free resources
        //

        if (ptLineClient->aNumRings)
        {
            ServerFree (ptLineClient->aNumRings);
        }


        //
        // Decrement reference count by two to remove the initial
        // reference & the reference above
        //

        DereferenceObject (ghHandleTable, hLine, 2);
    }
    else
    {
        DereferenceObject (ghHandleTable, hLine, 1);

        LOG((TL_ERROR, "DestroytLineClient: WaitForExclLineClientAccess failed!"));
    }

}


LONG
PASCAL
DestroytLineApp(
    HLINEAPP    hLineApp
    )
{
    PTCLIENT    ptClient;
    PTLINEAPP   ptLineApp;


    LOG((TL_TRACE,  "DestroytLineApp: enter, hLineApp=x%x", hLineApp));


    if (!(ptLineApp = ReferenceObject (ghHandleTable, hLineApp, TLINEAPP_KEY)))
    {
        return (TapiGlobals.dwNumLineInits ?
                    LINEERR_INVALAPPHANDLE : LINEERR_UNINITIALIZED);
    }


    //
    // See if this this is a valid tLineApp, & if so grab the lock
    // and mark it as bad, then continue teardown.  Else, another
    // thread is in the processing of tearing down this tLineApp,
    // so return.
    //

    LOCKTLINEAPP (ptLineApp);

    if (ptLineApp->dwKey != TLINEAPP_KEY)
    {
        UNLOCKTLINEAPP (ptLineApp);
        DereferenceObject (ghHandleTable, hLineApp, 1);
        return (TapiGlobals.dwNumPhoneInits ?
                    LINEERR_INVALAPPHANDLE : LINEERR_UNINITIALIZED);
    }

    ptLineApp->dwKey = INVAL_KEY;
    ptClient = (PTCLIENT) ptLineApp->ptClient;


    //
    // Destroy all the tLineClients.  Note that we want to grab the
    // lock each time we reference the list of tLineClient's, since
    // another thread might be destroying a tLineClient too.
    //

    {
        HLINE   hLine;


destroy_tLineClients:

        hLine = (ptLineApp->ptLineClients ?
            ptLineApp->ptLineClients->hLine : (HLINE) 0);

        UNLOCKTLINEAPP (ptLineApp);

        if (hLine)
        {
            DestroytLineClient (hLine);
            LOCKTLINEAPP (ptLineApp);
            goto destroy_tLineClients;
        }
    }


    //
    // Remove tLineApp from tClient's list. Note that we don't
    // have to worry about dup-ing the mutex here because we know
    // it's valid & won't get closed before we release it.
    //

    LOCKTCLIENT (ptClient);

    if (ptLineApp->pNext)
    {
        ptLineApp->pNext->pPrev = ptLineApp->pPrev;
    }

    if (ptLineApp->pPrev)
    {
        ptLineApp->pPrev->pNext = ptLineApp->pNext;
    }
    else
    {
        ptClient->ptLineApps = ptLineApp->pNext;
    }


    //
    // Clean up any existing generic dialog instances if this is the
    // last tLineApp on this tClient
    //

    if (ptClient->pGenericDlgInsts && ptClient->ptLineApps == NULL)
    {
        PTAPIDIALOGINSTANCE         pGenericDlgInst =
                                        ptClient->pGenericDlgInsts,
                                    pNextGenericDlgInst;

        TAPI32_MSG                  params;

        while (pGenericDlgInst)
        {
            pNextGenericDlgInst = pGenericDlgInst->pNext;
            params.u.Req_Func = 0;
            params.Params[0] = pGenericDlgInst->htDlgInst;
            params.Params[1] = LINEERR_OPERATIONFAILED;

            FreeDialogInstance(
                ptClient,
                (PFREEDIALOGINSTANCE_PARAMS) &params,
                sizeof (params),
                NULL,
                NULL
                );

            pGenericDlgInst = pNextGenericDlgInst;
        }
    }

    UNLOCKTCLIENT (ptClient);


    //
    // Decrement total num inits & see if we need to go thru shutdown
    //

    TapiEnterCriticalSection (&TapiGlobals.CritSec);

    //assert(TapiGlobals.dwNumLineInits != 0);

    TapiGlobals.dwNumLineInits--;


    if ((TapiGlobals.dwNumLineInits == 0) &&
        (TapiGlobals.dwNumPhoneInits == 0) &&
        !(TapiGlobals.dwFlags & TAPIGLOBALS_SERVER))
    {
        ServerShutdown();
        gbServerInited = FALSE;
    }

    TapiLeaveCriticalSection (&TapiGlobals.CritSec);


    //
    // Check to see if this tLineApp is a registered request
    // recipient, and if so do the appropriate munging
    //

    {
        BOOL               bResetHighestPriorityRequestRecipient;
        PTREQUESTRECIPIENT pRequestRecipient;


        if ((pRequestRecipient = ptLineApp->pRequestRecipient))
        {
            EnterCriticalSection (&gPriorityListCritSec);

            bResetHighestPriorityRequestRecipient =
                (TapiGlobals.pHighestPriorityRequestRecipient ==
                    pRequestRecipient ? TRUE : FALSE);

            if (pRequestRecipient->pNext)
            {
                pRequestRecipient->pNext->pPrev = pRequestRecipient->pPrev;
            }

            if (pRequestRecipient->pPrev)
            {
                pRequestRecipient->pPrev->pNext = pRequestRecipient->pNext;
            }
            else
            {
                TapiGlobals.pRequestRecipients = pRequestRecipient->pNext;
            }

            if (bResetHighestPriorityRequestRecipient)
            {
                TapiGlobals.pHighestPriorityRequestRecipient =
                    GetHighestPriorityRequestRecipient();

                if (TapiGlobals.pRequestMakeCallList)
                {
                    if (TapiGlobals.pHighestPriorityRequestRecipient)
                    {
                        NotifyHighestPriorityRequestRecipient();
                    }

                     else
                    {
                        //
                        // We couldn't start a request recipient so
                        // nuke all pending request make calls
                        //

                        PTREQUESTMAKECALL   pRequestMakeCall,
                                            pNextRequestMakeCall;


                        pRequestMakeCall =
                            TapiGlobals.pRequestMakeCallList;

                        TapiGlobals.pRequestMakeCallList    =
                        TapiGlobals.pRequestMakeCallListEnd = NULL;

                        while (pRequestMakeCall)
                        {
                            pNextRequestMakeCall =
                                pRequestMakeCall->pNext;
                            ServerFree (pRequestMakeCall);
                            pRequestMakeCall =  pNextRequestMakeCall;
                        }

                        LOG((TL_INFO,
                            "DestroytLineApp: deleting pending " \
                                "MakeCall requests"
                            ));
                    }
                }
            }

            LeaveCriticalSection (&gPriorityListCritSec);
            ServerFree (pRequestRecipient);
        }
    }


    //
    // Decrement reference count by two to remove the initial
    // reference & the reference above
    //

    DereferenceObject (ghHandleTable, hLineApp, 2);

    return 0;
}


BOOL
FillupACountryEntry(
    HKEY                hKey,
    PBYTE               pcl,
    LPLINECOUNTRYENTRY  pce,
    PBYTE               *ppVarOffset
    )
{
    PBYTE  pVarOffset = *ppVarOffset;
    DWORD  dwSize;
    DWORD  dwType;
    LONG   lTemp;


    dwSize = sizeof(pce->dwCountryCode);

    lTemp = RegQueryValueEx(
                          hKey,
                          TEXT("CountryCode"),
                          NULL,
                          &dwType,
                          (LPBYTE)&(pce->dwCountryCode),
                          &dwSize
                        );

    //
    // If we failed to get the country code, the rest of this work
    // is meaningless...
    //
    if ( ERROR_SUCCESS == lTemp )
    {
        //
        // Read the country name string resource ID
        //
        dwSize = sizeof(DWORD);
        lTemp = RegQueryValueEx(
                          hKey,
                          gszNameResW,
                          NULL,
                          &dwType,
                          pVarOffset,
                          &dwSize
                        );


        if ( ERROR_SUCCESS == lTemp )
        {
            pce->dwCountryNameOffset = (DWORD) (pVarOffset - pcl);
            pce->dwCountryNameSize = dwSize;

            pVarOffset += dwSize;
        }

        dwSize = MAXLEN_RULE * sizeof(WCHAR);
        // Here we need to read a wide string because this is our packed structure
        // that will eventually get returned to the client and these are WCHAR always.
        lTemp = TAPIRegQueryValueExW(
                          hKey,
                          gszSameAreaRuleW,
                          NULL,
                          &dwType,
                          pVarOffset,
                          &dwSize
                        );

        if ( ERROR_SUCCESS == lTemp )
        {
            pce->dwSameAreaRuleOffset = (DWORD) (pVarOffset - pcl);
            pce->dwSameAreaRuleSize = dwSize;

            pVarOffset += dwSize;
        }


        dwSize = MAXLEN_RULE * sizeof(WCHAR);
        // Here we need to read a wide string because this is our packed structure
        // that will eventually get returned to the client and these are WCHAR always.
        lTemp = TAPIRegQueryValueExW(
                          hKey,
                          gszLongDistanceRuleW,
                          NULL,
                          &dwType,
                          pVarOffset,
                          &dwSize
                        );

        if ( ERROR_SUCCESS == lTemp )
        {
            pce->dwLongDistanceRuleOffset = (DWORD) (pVarOffset - pcl);
            pce->dwLongDistanceRuleSize = dwSize;

            pVarOffset += dwSize;
        }


        dwSize = MAXLEN_RULE * sizeof(WCHAR);
        // Here we need to read a wide string because this is our packed structure
        // that will eventually get returned to the client and these are WCHAR always.
        lTemp = TAPIRegQueryValueExW(
                          hKey,
                          gszInternationalRuleW,
                          NULL,
                          &dwType,
                          pVarOffset,
                          &dwSize
                        );

        if ( ERROR_SUCCESS == lTemp )
        {
            pce->dwInternationalRuleOffset =  (DWORD) (pVarOffset - pcl);
            pce->dwInternationalRuleSize = dwSize;

            pVarOffset += dwSize;
        }


        *ppVarOffset = pVarOffset;
    }

    return TRUE;
}


BOOL
BuildCountryRegistryListFromRCW(
    void
    )
{
    HKEY        hKey = NULL, hKey2;
    DWORD       dwDisposition, dwNextCountryID, dw, dwNextCountryGroup, dwCountryGroupID;
    TCHAR       sz[256];
    TCHAR       sz1[256];
    LONG        err;


    if (RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        gszRegKeyTelephony,
        0,
        KEY_READ,
        &hKey2
        ) != ERROR_SUCCESS)
    {
        goto ExitHere;
    }

    err = RegCreateKeyEx(
        hKey2,
        TEXT("Country List"),
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        NULL,
        &hKey,
        &dwDisposition
        );


    RegCloseKey (hKey2);

    if (err != ERROR_SUCCESS)
    {
        goto ExitHere;
    }

    dwNextCountryID = 1;

    while (dwNextCountryID)
    {
        if (LoadString(
                ghInstance,
                RC_COUNTRY_ID_BASE + dwNextCountryID,
                sz,
                ARRAYSIZE(sz)
                )  > 0 &&

            LoadString(
                ghInstance,
                RC_COUNTRY_NAME_BASE + dwNextCountryID,
                sz1,
                ARRAYSIZE(sz1) 
                ) > 0
             )
        {
            TCHAR szCountryKey[20];
            PTSTR p;
            PTSTR p2;


            wsprintf( szCountryKey, TEXT("%ld"), dwNextCountryID );

            if (RegCreateKeyEx(
                hKey,
                szCountryKey,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS,
                NULL,
                &hKey2,
                &dwDisposition
                ) != ERROR_SUCCESS)
            {
                goto ExitHere;
            }

            //
            // Set the country name and resource ID in registry
            //
            RegSetValueEx(
                hKey2,
                gszNameW,
                0,
                REG_SZ,
                (LPBYTE) sz1,
                (DWORD) ( (_tcslen(sz1) + 1) * sizeof(TCHAR) )
                );


            dw = RC_COUNTRY_NAME_BASE + dwNextCountryID;
            RegSetValueEx(
                hKey2,
                gszNameResW,
                0,
                REG_DWORD,
                (LPBYTE) &dw,
                sizeof(DWORD)
                );

//RC_COUNTRY_ID_BASE + 1 "1,101,""G"","" 1FG"",""011EFG"""


            p = sz;

            //
            // Get the countryID
            //

            dw = _ttol (p);

            RegSetValueEx(
                hKey2,
                TEXT("CountryCode"),
                0,
                REG_DWORD,
                (LPBYTE)&dw,
                sizeof(DWORD)
                );


            p = _tcschr( p, TEXT(',') ) + 1;
            dwNextCountryID = _ttol( p );

            p  = _tcschr( p, TEXT('"') ) + 1;  // Point to start of rule
            p2 = _tcschr( p, TEXT('"') );           // Point to end of rule
            *p2 = TEXT('\0');

            RegSetValueEx(
                hKey2,
                gszSameAreaRuleW,
                0,
                REG_SZ,
                (LPBYTE) p,
                (DWORD) ((PBYTE) p2 - (PBYTE) p) + sizeof(TCHAR)
                );

            p  = _tcschr( p2 + 1, TEXT('"') ) + 1;  // Point to start of rule
            p2 = _tcschr( p, TEXT('"') );           // Point to end of rule
            *p2 = TEXT('\0');

            RegSetValueEx(
                hKey2,
                gszLongDistanceRuleW,
                0,
                REG_SZ,
                (LPBYTE) p,
                (DWORD) ((PBYTE) p2 - (PBYTE) p) + sizeof(TCHAR)
                );

            p  = _tcschr( p2 + 1, TEXT('"') ) + 1;  // Point to start of rule
            p2 = _tcschr( p, TEXT('"') );           // Point to end of rule
            *p2 = TEXT('\0');

            RegSetValueEx(
                hKey2,
                gszInternationalRuleW,
                0,
                REG_SZ,
                (LPBYTE) p,
                (DWORD) ((PBYTE) p2 - (PBYTE) p) + sizeof(TCHAR)
                );


            RegCloseKey(hKey2);
        }
        else
        {
            dwNextCountryID = 0;
        }

    }

    //
    // Get the Country Groups
    // 

//RC_COUNTRY_GROUP_BASE + 1 "1,0,""594,590,596,262,33"""

    dwNextCountryGroup = 1;
    while (dwNextCountryGroup)
    {
        if (LoadString(
                ghInstance,
                RC_COUNTRY_GROUP_BASE + dwNextCountryGroup,
                sz,
                ARRAYSIZE(sz)

                )  > 0)
        {
            TCHAR szCountryKey[20];
            PTSTR p;
            PTSTR p2;

            p = sz;

            //
            // Get the country group ID
            //

            dwCountryGroupID = _ttol (p);

            p = _tcschr( p, TEXT(',') ) + 1;
            dwNextCountryGroup = _ttol( p );


            p = _tcschr( p, TEXT('"') );
            p2 = _tcschr( p+1, TEXT('"') );
            *p2 = TEXT('\0');

            while( NULL != p && p+1 < p2)
            {
                wsprintf( szCountryKey, TEXT("%ld"), _ttol (p+1) );

                if (RegOpenKeyEx(
                    hKey,
                    szCountryKey,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey2
                    ) != ERROR_SUCCESS)
                {
                    goto ExitHere;
                }


                RegSetValueEx(
                    hKey2,
                    gszCountryGroupW,
                    0,
                    REG_DWORD,
                    (LPBYTE)&dwCountryGroupID,
                    sizeof(DWORD)
                    );

                RegCloseKey(hKey2);
                
                p = _tcschr( p+1, TEXT(',') );
            }
        }
        else
        {
            dwNextCountryGroup = 0;
        }
    }

    //
    // Write the country list version to the registry
    //

    {
        DWORD dwCountryListVersion = TAPI_CURRENT_COUNTRY_LIST_VERSION;

        RegSetValueEx(
            hKey,
            gszCountryListVersionW,
            0,
            REG_DWORD,
            (LPBYTE) &dwCountryListVersion,
            (DWORD) sizeof (dwCountryListVersion)
            );
    }

ExitHere:
    if (hKey)
    {
        RegCloseKey (hKey);
    }

    return TRUE;
}


BOOL
DeleteAllSubkeys(
    HKEY    hKey,
    DWORD   dwRecursionCount
    )
{
    //
    // Build a MULTISZ-style list of all the subkey names,
    // then delete them all.  This is because NT won't
    // let us (do it the easy way and) delete the parent key
    // while subkeys still exist.  Note also that we're not
    // allowed to delete subkeys while enumerating them.
    //

    HKEY    hSubkey;
    DWORD   i, dwTotalChars = 2048, dwUsedChars = 0;
    TCHAR   *p, *p2;


    //
    // If we're nested more than a few levels deep then someone
    // is probably doing some malicious registry munging to
    // see if we blow up - don't recurse any further.
    //

    if (dwRecursionCount > 5)
    {
        return TRUE;
    }


    //
    // Alloc a buffer to store subkey names
    //

    if (!(p = ServerAlloc (dwTotalChars * sizeof (TCHAR))))
    {
        return FALSE;
    }


    //
    // Build the list
    //

    for (i = 0;; i++)
    {
        DWORD       dwNumChars = dwTotalChars - dwUsedChars;
        FILETIME    fileTime;


        //
        // See if we need to grow the buffer first
        //

        if (dwNumChars < 256)
        {
            dwTotalChars *= 2;

            if (!(p2 = LocalAlloc (LPTR, dwTotalChars * sizeof (TCHAR))))
            {
                ServerFree (p);
                return FALSE;
            }

            CopyMemory (p2, p, dwUsedChars * sizeof (TCHAR));

            ServerFree (p);

            p = p2;
        }

        if (RegEnumKeyEx(
                hKey,
                i,
                p + dwUsedChars,
                &dwNumChars,
                NULL,
                NULL,
                NULL,
                &fileTime

                ) != ERROR_SUCCESS)
        {
            p[dwUsedChars] = TEXT('\0');    // the final (double) NULL
            break;
        }


        //
        // Append a terminating NULL if there wasn't one
        //

        if (p[dwUsedChars + dwNumChars - 1] != TEXT('\0'))
        {
            p[dwUsedChars + dwNumChars] = TEXT('\0');
            dwNumChars++;
        }

        dwUsedChars += dwNumChars;
    }


    //
    // Now nuke all the subkeys in the list (make sure to nuke
    // any sub-subkeys first)
    //

    for (p2 = p; *p2 != TEXT('\0'); p2 += lstrlen (p2) + 1)
    {
        if (RegOpenKeyEx(
                hKey,
                p2,
                0,
                KEY_ALL_ACCESS,
                &hSubkey

                ) == ERROR_SUCCESS)
        {
            DeleteAllSubkeys (hSubkey, dwRecursionCount + 1);

            RegCloseKey (hSubkey);
        }

        RegDeleteKey (hKey, p2);
    }

    ServerFree (p);

    return TRUE;
}


BOOL
BuildCountryListCache(
    void
    )
{
    //
    // The following is our "last resort" country list, i.e. the one we
    // use of we get errors trying to build the country list below
    //

    static LINECOUNTRYLIST defCountryList =
    {
        sizeof(LINECOUNTRYLIST),    // dwTotalSize
        sizeof(LINECOUNTRYLIST),    // dwNeededSize
        sizeof(LINECOUNTRYLIST),    // dwUsedSize
        0,                          // dwNumCountries
        0,                          // dwCountryListSize
        0                           // dwCountryListOffset
    };
    BOOL bResult = TRUE;
    UINT i;


    if (!gpCountryList)
    {
        TCHAR sz[256];
        DWORD dwSize;
        DWORD dwListSize;
        DWORD dwCountryId, dwCountryListVersion, dwType;
        PBYTE pTempCountryList;
        LPLINECOUNTRYENTRY pce;
        LPLINECOUNTRYENTRY pcePrev = NULL;
        HKEY hKey;
        HKEY hKeyTemp;
        UINT uNumCountries;
        PBYTE pVarOffset;


        #define INITIAL_COUNTRY_COUNT 256

        dwListSize = sizeof(LINECOUNTRYLIST) +
               INITIAL_COUNTRY_COUNT * (sizeof(LINECOUNTRYENTRY) + 64);

        if ( NULL == (pTempCountryList = ServerAlloc(dwListSize)) )
        {
            bResult = FALSE;
            LOG((TL_ERROR, "Mem alloc failed for country list!1 (0x%lx", dwListSize));
            goto BuildCountryListCache_return;
        }


        //
        // Make sure the list is more-or-less there first
        //

        if (RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                gszRegKeyTelephony,
                0,
                KEY_READ,
                &hKey

                ) != ERROR_SUCCESS)
        {
            bResult = FALSE;
            ServerFree (pTempCountryList);
            goto BuildCountryListCache_return;
        }

        dwCountryListVersion = 0;

        if (RegOpenKeyEx(
                hKey,
                TEXT("Country List"),
                0,
                KEY_READ,
                &hKeyTemp

                ) == ERROR_SUCCESS)
        {
            dwSize = sizeof(DWORD);
            TAPIRegQueryValueExW(
                hKeyTemp,
                gszCountryListVersionW,
                NULL,
                &dwType,
                (LPBYTE) &dwCountryListVersion,
                &dwSize
                );

             RegCloseKey (hKeyTemp);
        }


        //
        // If the country list version is < the version in our resource
        // file  OR
        // if a read on the key for country code 1 (these united states)
        // fails, we'll assume the country list in the registry is toasted
        //

        if ((dwCountryListVersion < TAPI_CURRENT_COUNTRY_LIST_VERSION) ||

             RegOpenKeyEx(
                 hKey,
                 TEXT("Country List\\1"),
                 0,
                 KEY_READ,
                 &hKeyTemp
                 ))
        {
            //
            // Nuke any existing subkeys & (re)create it
            //

            if (RegOpenKeyEx(
                    hKey,
                    TEXT("Country List"),
                    0,
                    KEY_ALL_ACCESS,
                    &hKeyTemp

                    ) == ERROR_SUCCESS)
            {
                 DeleteAllSubkeys (hKeyTemp, 0);

                 RegCloseKey (hKeyTemp);
            }

            BuildCountryRegistryListFromRCW();
        }
        else
        {
            RegCloseKey( hKeyTemp );
        }

        RegCloseKey( hKey );


        //
        // In any case, the list is now good
        //

        if (RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                gszRegKeyTelephony,
                0,
                KEY_READ,
                &hKeyTemp

                ) != ERROR_SUCCESS)
        {
            bResult = FALSE;
            ServerFree (pTempCountryList);
            goto BuildCountryListCache_return;
        }

        if (RegOpenKeyEx(
                hKeyTemp,
                TEXT("Country List"),
                0,
                KEY_READ,
                &hKey

                ) != ERROR_SUCCESS)
        {
            RegCloseKey( hKeyTemp );
            bResult = FALSE;
            ServerFree (pTempCountryList);
            goto BuildCountryListCache_return;
        }

        RegCloseKey( hKeyTemp );


        //
        // Enum through the country keys and make sure there's enough room
        // for all of the LINECOUNTRYENTRYs
        //

        pce = (LPLINECOUNTRYENTRY)(pTempCountryList +
                                     sizeof(LINECOUNTRYLIST));

        //
        // Make pretend we already have a previous linecountryentry so we
        // don't have to do an 'if' in the loop every time just for the
        // special case of the first time.  (The correct number gets put
        // into the field the second time through the loop.)
        //

        pcePrev = pce;

        dwSize = ARRAYSIZE(sz);

        uNumCountries = 0;

        while (RegEnumKeyEx(
                    hKey,
                    uNumCountries,
                    sz,
                    &dwSize,
                    NULL,
                    NULL,
                    NULL,
                    NULL

                    ) == 0)
        {
           if ((sizeof(LINECOUNTRYLIST) +
                   (sizeof(LINECOUNTRYENTRY) * uNumCountries))  >  dwListSize)
           {
               PBYTE p;
               UINT uOldSize;


               uOldSize = dwListSize;

               //
               // alloc a new space
               //

               dwListSize = sizeof(LINECOUNTRYLIST) +
                                (
                                   (sizeof(LINECOUNTRYENTRY) + 64)
                                     * (uNumCountries + 25)
                                );

               p = ServerAlloc( dwListSize );

               if ( NULL == p )
               {
                   bResult = FALSE;
                   LOG((TL_ERROR, "Mem alloc failed for country list!2 (0x%lx", dwListSize));
                   ServerFree( pTempCountryList );
                   RegCloseKey (hKey);
                   goto BuildCountryListCache_return;
               }

               CopyMemory(
                   p,
                   pTempCountryList,
                   (LPBYTE)pce - pTempCountryList
                   );

               ServerFree( pTempCountryList );

               pTempCountryList = p;

               pce = (LPLINECOUNTRYENTRY)((LPBYTE)p + uOldSize);
           }

           dwCountryId = _ttol( sz );

           pce->dwCountryID = dwCountryId;

           pcePrev->dwNextCountryID = dwCountryId;


           // Prepare for next trip through the loop

           pcePrev = pce;

           pce++;

           uNumCountries++;

           dwSize = ARRAYSIZE(sz);  // need to set every time :-(
        }

        // Allocate the country groups global
        gpCountryGroups = (LPDWORD) ServerAlloc( uNumCountries * sizeof (DWORD) );
        if (gpCountryGroups)
            memset(gpCountryGroups, 0, uNumCountries * sizeof (DWORD));

        pcePrev->dwNextCountryID = 0;

        
        //
        // Now go through and get all of the associated strings
        //

        pce = (LPLINECOUNTRYENTRY)
                (pTempCountryList + sizeof(LINECOUNTRYLIST));

        pVarOffset = pTempCountryList +
                                 sizeof(LINECOUNTRYLIST) +
                                 (sizeof(LINECOUNTRYENTRY) * uNumCountries);

        i = 0;

        while ( i < uNumCountries )
        {
            HKEY hKey2;


//-->      if it can't fix MAX_SPACE, realloc it
            if ( ((DWORD)(pVarOffset - pTempCountryList) +
                         ((MAXLEN_NAME +
                         MAXLEN_RULE +
                         MAXLEN_RULE +
                         MAXLEN_RULE +
                         100) * sizeof(WCHAR)))    // mmmm... fudge...
                    > dwListSize )
            {
               PBYTE p;

               //
               // alloc a new space
               //

               dwListSize += 1024;

               p = ServerAlloc( dwListSize );

               if ( NULL == p )
               {
                   bResult = FALSE;
                   LOG((TL_ERROR, "Mem alloc failed for country list!3 (0x%lx", dwListSize));
                   ServerFree( pTempCountryList );
                   RegCloseKey (hKey);
                   goto BuildCountryListCache_return;
               }

               CopyMemory(
                   p,
                   pTempCountryList,
                   (LPBYTE)pce - pTempCountryList
                   );

               pVarOffset = (LPVOID)(p +
                               (UINT)( pVarOffset - pTempCountryList));

               ServerFree( pTempCountryList );

               pTempCountryList = p;

               pce = (LPLINECOUNTRYENTRY)
                     (pTempCountryList + sizeof(LINECOUNTRYLIST) +
                                 ( sizeof(LINECOUNTRYENTRY) * i ));
            }

            wsprintf( sz, TEXT("%ld"), pce->dwCountryID);

            if (RegOpenKeyEx (hKey, sz, 0, KEY_READ, &hKey2) == ERROR_SUCCESS)
            {
                FillupACountryEntry(
                    hKey2,
                    pTempCountryList,
                    pce,
                    &pVarOffset
                    );

                // fill the country group

                if (gpCountryGroups)
                {
                    DWORD dwType;
                    DWORD dwSize = sizeof (DWORD);

                    if (ERROR_SUCCESS != RegQueryValueEx(
                            hKey2,
                            gszCountryGroupW,
                            NULL,
                            &dwType,
                            (LPBYTE)(gpCountryGroups + i),
                            &dwSize
                            )                           ||
                         dwType != REG_DWORD
                        )
                    {
                        gpCountryGroups[ i ] = 0;
                    }
                }


                RegCloseKey (hKey2);
            }
            
            pce++;
            i++;
        }

        RegCloseKey( hKey );

        ((LPLINECOUNTRYLIST)pTempCountryList)->dwTotalSize =
                      (DWORD)(pVarOffset - pTempCountryList);

        ((LPLINECOUNTRYLIST)pTempCountryList)->dwNeededSize =
                      (DWORD)(pVarOffset - pTempCountryList);

        ((LPLINECOUNTRYLIST)pTempCountryList)->dwUsedSize =
                      (DWORD)(pVarOffset - pTempCountryList);

        ((LPLINECOUNTRYLIST)pTempCountryList)->dwNumCountries = uNumCountries;

        ((LPLINECOUNTRYLIST)pTempCountryList)->dwCountryListSize =
                                 uNumCountries * sizeof(LINECOUNTRYENTRY);

        ((LPLINECOUNTRYLIST)pTempCountryList)->dwCountryListOffset =
                                          sizeof(LINECOUNTRYLIST);

        gpCountryList = (LPLINECOUNTRYLIST)pTempCountryList;
    }

BuildCountryListCache_return:

    if (bResult == FALSE)
    {
        gpCountryList = &defCountryList;
        ServerFree( gpCountryGroups );
        gpCountryGroups = NULL;
    }

    return bResult;
}


LPLINECOUNTRYLIST
BuildCountryList(
    void
    )
{
    LPLINECOUNTRYENTRY  pCtryEntry, pCtryEntryGlobal;
    LPLINECOUNTRYLIST   pCtryList;
    DWORD               dwListSize;
    DWORD               dwIdx;
    DWORD               dwResourceId;
    DWORD               dwNameSize;
    DWORD               dwNeededSize;
    DWORD               dwTotalSize;
    LPBYTE              pVarOffset;
    BOOL                bResult = TRUE;
    WCHAR               sz[MAXLEN_NAME];

    if (!gpCountryList)
    {
        return NULL;
    }

    //
    // Allocate memory, make room for country names
    //
    dwTotalSize = gpCountryList->dwUsedSize + 
                  gpCountryList->dwNumCountries * 
                           ( MAXLEN_NAME * sizeof(WCHAR) - sizeof(DWORD) );
    pCtryList = ServerAlloc (dwTotalSize);

    if (!pCtryList)
    {
        return NULL;
    }

    //
    // Fill the buffer
    // 
    pCtryEntry = (LPLINECOUNTRYENTRY)((LPBYTE) pCtryList + sizeof(LINECOUNTRYLIST));
    pCtryEntryGlobal = (LPLINECOUNTRYENTRY)((LPBYTE) gpCountryList + sizeof(LINECOUNTRYLIST));
    pVarOffset = (LPBYTE)pCtryList + sizeof(LINECOUNTRYLIST) + 
                    sizeof(LINECOUNTRYENTRY) * gpCountryList->dwNumCountries;
    dwNeededSize = sizeof(LINECOUNTRYLIST) + 
                    sizeof(LINECOUNTRYENTRY) * gpCountryList->dwNumCountries;

    for( dwIdx = 0; dwIdx < gpCountryList->dwNumCountries; 
            dwIdx++, pCtryEntry++, pCtryEntryGlobal++ )
    {
        pCtryEntry->dwCountryCode = pCtryEntryGlobal->dwCountryCode;
        pCtryEntry->dwCountryID = pCtryEntryGlobal->dwCountryID;
        pCtryEntry->dwNextCountryID = pCtryEntryGlobal->dwNextCountryID;


        //
        // The name field has the resource string ID
        // Need to load the actual string 
        //
            
        CopyMemory(
            &dwResourceId,
            (LPBYTE)gpCountryList + pCtryEntryGlobal->dwCountryNameOffset,
            sizeof(DWORD)
            );

        if (0 == LoadStringW(
                            ghInstance,
                            dwResourceId,
                            sz,
                            ARRAYSIZE(sz)
                            )  
           )
        {
            bResult = FALSE;
            break;
        }
                        
        dwNameSize = (wcslen(sz) + 1) * sizeof(WCHAR);
        CopyMemory(
            pVarOffset,
            (LPBYTE)sz,
            dwNameSize
            );

        pCtryEntry->dwCountryNameSize = dwNameSize;

        pCtryEntry->dwCountryNameOffset = (DWORD)(pVarOffset - (LPBYTE)pCtryList);
        pVarOffset += dwNameSize;
        dwNeededSize += dwNameSize;


        CopyMemory(
            pVarOffset,
            (LPBYTE)gpCountryList + pCtryEntryGlobal->dwSameAreaRuleOffset,
            pCtryEntryGlobal->dwSameAreaRuleSize
            );

        pCtryEntry->dwSameAreaRuleSize = pCtryEntryGlobal->dwSameAreaRuleSize;
        pCtryEntry->dwSameAreaRuleOffset = (DWORD)(pVarOffset - (LPBYTE)pCtryList);
        pVarOffset += pCtryEntryGlobal->dwSameAreaRuleSize;
        dwNeededSize += pCtryEntryGlobal->dwSameAreaRuleSize;


        CopyMemory(
            pVarOffset,
            (LPBYTE)gpCountryList + pCtryEntryGlobal->dwLongDistanceRuleOffset,
            pCtryEntryGlobal->dwLongDistanceRuleSize
            );

        pCtryEntry->dwLongDistanceRuleSize = pCtryEntryGlobal->dwLongDistanceRuleSize;
        pCtryEntry->dwLongDistanceRuleOffset = (DWORD)(pVarOffset - (LPBYTE)pCtryList);
        pVarOffset += pCtryEntryGlobal->dwLongDistanceRuleSize;
        dwNeededSize += pCtryEntryGlobal->dwLongDistanceRuleSize;


        CopyMemory(
            pVarOffset,
            (LPBYTE)gpCountryList + pCtryEntryGlobal->dwInternationalRuleOffset,
            pCtryEntryGlobal->dwInternationalRuleSize
            );

        pCtryEntry->dwInternationalRuleSize = pCtryEntryGlobal->dwInternationalRuleSize;
        pCtryEntry->dwInternationalRuleOffset = (DWORD)(pVarOffset - (LPBYTE)pCtryList);
        pVarOffset += pCtryEntryGlobal->dwInternationalRuleSize;
        dwNeededSize += pCtryEntryGlobal->dwInternationalRuleSize;
        
    }
    
    if (!bResult)
    {
        ServerFree(pCtryList);
        pCtryList = NULL;
    }
    else
    {
        pCtryList->dwNeededSize = dwNeededSize;
        pCtryList->dwTotalSize = dwTotalSize;
        pCtryList->dwUsedSize = dwNeededSize;
        pCtryList->dwNumCountries = gpCountryList->dwNumCountries;
        pCtryList->dwCountryListSize = sizeof(LINECOUNTRYENTRY) * gpCountryList->dwNumCountries;
        pCtryList->dwCountryListOffset = sizeof(LINECOUNTRYLIST);
    }

    return pCtryList;
}

PTLINECLIENT
PASCAL
xxxGetHighestPriorityLineClient(
    TPOINTERLIST    *pLineClientList,
    DWORD           dwMediaModes,
    DWORD           dwAddressID,
    WCHAR          *pszPriorityList
    )
{
    BOOL            bFoundOwnerInPriorityList = FALSE;
    DWORD           i;
    WCHAR           *pszAppInPriorityList = NULL;
    WCHAR           *pszAppInPriorityListPrev = (WCHAR *) LongToPtr(0xffffffff);
    PTLINECLIENT    ptHiPriLineClient = (PTLINECLIENT) NULL;


    for (i = 0; i < pLineClientList->dwNumUsedEntries; i++)
    {
        PTLINECLIENT    ptLineClient = (PTLINECLIENT)
                            pLineClientList->aEntries[i];

        try
        {
            if (ptLineClient->dwPrivileges & LINECALLPRIVILEGE_OWNER)
            {
                BOOL            bMatch;


                bMatch = ((ptLineClient->dwMediaModes & dwMediaModes)
                    == dwMediaModes);

                if ( bMatch &&

                    // most common case, line opened for all addrs

                    ((ptLineClient->dwAddressID == 0xffffffff) ||


                    // line opened for single addr, check if match

                    (ptLineClient->dwAddressID == dwAddressID) ||


                    // called from lineHandoff, addr ID irrelevent

                    (dwAddressID == 0xffffffff)))
                {
                    if (pszPriorityList &&

                        (pszAppInPriorityList = wcsstr(
                            pszPriorityList,
                            ptLineClient->ptLineApp->pszModuleName
                            )))
                    {
                        //
                        // See if this app has higher pri
                        // than the previous app we found,
                        // and if so save the info
                        //

                        if (pszAppInPriorityList <= pszAppInPriorityListPrev)
                        {
                            ptHiPriLineClient = ptLineClient;

                            pszAppInPriorityListPrev  =
                                pszAppInPriorityList;

                            bFoundOwnerInPriorityList = TRUE;
                        }
                    }
                    else if (!bFoundOwnerInPriorityList)
                    {
                        ptHiPriLineClient = ptLineClient;
                    }
                }
            }
        }
        myexcept
        {
            // just continue
        }
    }

    return ptHiPriLineClient;
}


WCHAR *
GetPriorityListForMediaModes(
    DWORD   dwMediaModes
    )
{
    DWORD   dwCount;
    WCHAR   *pszPriorityList = NULL;


    if (TapiGlobals.dwUsedPriorityLists != 0)
    {
        //
        // Safely get a copy of the priority list (if any)
        // for this media mode
        //

        EnterCriticalSection (&gPriorityListCritSec);

        for(
            dwCount = 0;
            dwCount < TapiGlobals.dwUsedPriorityLists;
            dwCount++
            )
        {
            PRILISTSTRUCT PriList = TapiGlobals.pPriLists[dwCount];


            if ((dwMediaModes & PriList.dwMediaModes) == dwMediaModes)
            {
                if (PriList.pszPriList)
                {
                    if ((pszPriorityList = ServerAlloc( sizeof(WCHAR) *
                            (1 + lstrlenW(PriList.pszPriList))
                            )))
                    {
                        wcscpy (pszPriorityList, PriList.pszPriList);
                    }
                }

                break;
            }
        }

        LeaveCriticalSection (&gPriorityListCritSec);
    }

    return pszPriorityList;
}


PTLINECLIENT
PASCAL
GetHighestPriorityLineClient(
    PTLINE  ptLine,
    DWORD   dwMediaModes,
    DWORD   dwAddressID
    )
{
    WCHAR          *pszPriorityList = NULL;
    TPOINTERLIST    lineClientList, *pLineClientList = &lineClientList;
    PTLINECLIENT    ptHiPriLineClient = (PTLINECLIENT) NULL;
    DWORD           dwCount = 0, dwMask;


    if (GetLineClientListFromLine (ptLine, &pLineClientList) != 0)
    {
        return NULL;
    }


    //
    // If >1 media mode is specifed without the UNKNOWN bit being set
    // then we first want to see if there's any exact matches available,
    // that is, if there's an app which has opened the line with OWNER
    // privileges for all the specfied media modes. If so, then we'll
    // give privilege to that app immediately, rather than walking
    // through the media mode bits one-by-one as done below (the original
    // TAPI 1.x priority determination scheme).
    //

    if (!IsOnlyOneBitSetInDWORD (dwMediaModes) &&
        !(dwMediaModes & LINEMEDIAMODE_UNKNOWN))
    {
        pszPriorityList = GetPriorityListForMediaModes (dwMediaModes);

        ptHiPriLineClient = xxxGetHighestPriorityLineClient(
            pLineClientList,
            dwMediaModes,
            dwAddressID,
            pszPriorityList
            );

        if (pszPriorityList)
        {
            ServerFree (pszPriorityList);
        }
    }


    //
    // Step thru the list of line clients (youngest client at head
    // of list, oldest at tail) and look for the oldest & highest
    // priority owner.  Position in pri list takes precedence
    // over "age" of line client.
    //
    // To be considered for ownership a line client must have owner
    // privileges and be registered for (one of) the call's media
    // mode(s).  In addition, if the line client was opened with
    // the SINGLEADDRESS option and the calling function specified
    // a valid address ID (not 0xffffffff), the line client's single
    // address ID must match that which was passed in.
    //

    dwMask = LINEMEDIAMODE_UNKNOWN; // 0x00000002, smallest valid bit

    while (!ptHiPriLineClient  &&  dwMediaModes)
    {
        if (dwMask & dwMediaModes)
        {
            pszPriorityList = GetPriorityListForMediaModes (dwMask);

            ptHiPriLineClient = xxxGetHighestPriorityLineClient(
                pLineClientList,
                dwMask,
                dwAddressID,
                pszPriorityList
                );

            if (pszPriorityList)
            {
                ServerFree (pszPriorityList);
            }
        }

        dwMediaModes &= ~dwMask;
        dwMask <<= 1;
    }


    //
    // Free line client list iff appropriate
    //

    if (pLineClientList != &lineClientList)
    {
        ServerFree (pLineClientList);
    }

    return ptHiPriLineClient;
}


LONG
PASCAL
LineProlog(
    PTCLIENT    ptClient,
    DWORD       dwArgType,
    DWORD       dwArg,
    LPVOID      phdXxx,
    DWORD       dwPrivilege, // can be privilege or device id
    HANDLE     *phMutex,
    BOOL       *pbDupedMutex,
    DWORD       dwTSPIFuncIndex,
    TSPIPROC   *ppfnTSPI_lineXxx,
    PASYNCREQUESTINFO  *ppAsyncRequestInfo,
    DWORD       dwRemoteRequestID,
    DWORD      *pObjectToDereference,
    LPVOID     *pContext
#if DBG
    ,char      *pszFuncName
#endif
    )
{
    LONG        lResult = 0;
    DWORD       initContext;
    DWORD       openContext;
    ULONG_PTR   htXxx;
    PTPROVIDER  ptProvider;

#if DBG
    LOG((TL_TRACE,  "LineProlog: (line%s) enter", pszFuncName));
#else
    LOG((TL_TRACE, "LineProlog:  -- enter"));
#endif

    LOG((TL_INFO, "LineProlog: dwArg %lx", dwArg));

    if (phMutex)
    {
        *phMutex = NULL;
        *pbDupedMutex = FALSE;
    }

    *pObjectToDereference = 0;

    if (ppAsyncRequestInfo)
    {
        *ppAsyncRequestInfo = (PASYNCREQUESTINFO) NULL;
    }

    if (TapiGlobals.dwNumLineInits == 0)
    {
        lResult = LINEERR_UNINITIALIZED;
        goto LineProlog_exit;
    }

    if (ptClient->phContext == (HANDLE) -1)
    {
        lResult = LINEERR_REINIT;
        goto LineProlog_exit;
    }

    switch (dwArgType)
    {
    case ANY_RT_HCALL:
    {
        PTCALLCLIENT    ptCallClient;

        LOG((TL_INFO, "LineProlog: ANY_RT_HCALL "));

        if ((ptCallClient = ReferenceObject(
                ghHandleTable,
                dwArg,
                TCALLCLIENT_KEY
                )))
        {
            LOG((TL_INFO, "LineProlog: ReferenceObject returned ptCallClient %p", ptCallClient));

            if (ptCallClient->ptClient != ptClient)
            {
                lResult = LINEERR_INVALCALLHANDLE;
            }
            else if (ptCallClient->dwPrivilege < dwPrivilege)
            {
                lResult = LINEERR_NOTOWNER;
            }
            else
            {
                *pObjectToDereference = dwArg;
                *pContext = ptCallClient;

                try
                {
                    ptProvider = ptCallClient->ptCall->ptProvider;
                    *((HDRVCALL *) phdXxx) = ptCallClient->ptCall->hdCall;

                    if (ppAsyncRequestInfo)
                    {
                        PTLINECLIENT    ptLineClient =
                                            ptCallClient->ptLineClient;


                        initContext = ptLineClient->ptLineApp->InitContext;
                        openContext = ptLineClient->OpenContext;
                        htXxx       = (ULONG_PTR)ptLineClient->ptLine;
                    }
                }
                myexcept
                {
                    
                    LOG((TL_ERROR, "LineProlog: exception"));
                    lResult = LINEERR_INVALCALLHANDLE;
                }

                if (lResult  ||  ptCallClient->dwKey != TCALLCLIENT_KEY)
                {
                    lResult = LINEERR_INVALCALLHANDLE;
                }
                else if (phMutex &&
                         (ptProvider->dwTSPIOptions &
                            LINETSPIOPTION_NONREENTRANT))
                {
                    if (!WaitForMutex(
                            ptProvider->hMutex,
                            phMutex,
                            pbDupedMutex,
                            ptProvider,
                            TPROVIDER_KEY,
                            INFINITE
                            ))
                    {
                        lResult = LINEERR_OPERATIONFAILED;
                    }
                }
            }
        }
        else
        {
            lResult = LINEERR_INVALCALLHANDLE;
        }

        break;
    }
    case ANY_RT_HLINE:
    {
        PTLINECLIENT    ptLineClient;

        LOG((TL_INFO, "LineProlog: ANY_RT_HLINE"));

        if ((ptLineClient = ReferenceObject(
                ghHandleTable,
                dwArg,
                TLINECLIENT_KEY
                )))
        {
            LOG((TL_INFO, "LineProlog: ReferenceObject returned ptLineClient %p", ptLineClient));

            if (ptLineClient->ptClient != ptClient)
            {

                lResult = LINEERR_INVALLINEHANDLE;
            }
            else
            {
                *pObjectToDereference = dwArg;
                *pContext = ptLineClient;

                try
                {
                    ptProvider = ptLineClient->ptLine->ptProvider;
                    *((HDRVLINE *) phdXxx) = ptLineClient->ptLine->hdLine;

                    if (ppAsyncRequestInfo)
                    {
                        initContext = ptLineClient->ptLineApp->InitContext;
                        openContext = ptLineClient->OpenContext;
                        htXxx       = (ULONG_PTR)ptLineClient->ptLine;
                    }
                }
                myexcept
                {
                    LOG((TL_ERROR, "LineProlog: exception"));

                    lResult = LINEERR_INVALLINEHANDLE;
                }

                if (lResult  ||  ptLineClient->dwKey != TLINECLIENT_KEY)
                {
                    lResult = LINEERR_INVALLINEHANDLE;
                }
                else if (phMutex &&
                         (ptProvider->dwTSPIOptions &
                            LINETSPIOPTION_NONREENTRANT))
                {
                    if (!WaitForMutex(
                            ptProvider->hMutex,
                            phMutex,
                            pbDupedMutex,
                            ptProvider,
                            TPROVIDER_KEY,
                            INFINITE
                            ))
                    {
                        LOG((TL_ERROR, "LineProlog: waitformutex failed"));

                        lResult = LINEERR_OPERATIONFAILED;
                    }
                }
            }
        }
        else
        {
            LOG((TL_ERROR, "LineProlog: ReferenceObject returned NULL"));

            lResult = LINEERR_INVALLINEHANDLE;
        }

        break;
    }
    case DEVICE_ID:
    {
        PTLINEAPP           ptLineApp = NULL;
        PTLINELOOKUPENTRY   pLineLookupEntry;


#if TELE_SERVER

        //
        // If it's a server, map the device id
        //

        if ((TapiGlobals.dwFlags & TAPIGLOBALS_SERVER) &&
            !IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR))
        {
            try
            {
                if ((dwPrivilege >= ptClient->dwLineDevices) ||
                    (ptClient->pLineDevices[dwPrivilege] == 0xffffffff))
                {
                    lResult = LINEERR_BADDEVICEID;
                    goto LineProlog_exit;
                }

                *((LPDWORD) phdXxx) = ptClient->pLineDevices[dwPrivilege];
            }
            myexcept
            {
                lResult = LINEERR_INVALLINEHANDLE;
                goto LineProlog_exit;
            }
        }
        else
#endif
        {
            *((LPDWORD)phdXxx) = dwPrivilege;
        }


        if (dwArg  &&
            !(ptLineApp = IsValidLineApp ((HLINEAPP) dwArg, ptClient)))
        {
            lResult = LINEERR_INVALAPPHANDLE;
        }

        if (ppAsyncRequestInfo)
        {
            try
            {
                initContext = ptLineApp->InitContext;
                openContext = 0;

                if (ptLineApp->dwKey != TLINEAPP_KEY)
                {
                    lResult = LINEERR_INVALAPPHANDLE;
                }
            }
            myexcept
            {
                lResult = LINEERR_INVALAPPHANDLE;
            }
        }

        if (lResult != 0)
        {
            // do nothing
        }
        else if (!(pLineLookupEntry = GetLineLookupEntry (*(LPDWORD)phdXxx)))
        {
            lResult = LINEERR_BADDEVICEID;
        }
        else if (pLineLookupEntry->bRemoved)
        {
            lResult = LINEERR_NODEVICE;
        }
        else if (!(ptProvider = pLineLookupEntry->ptProvider))
        {
            lResult = LINEERR_NODRIVER;
        }
        else
        {
            *pContext = pLineLookupEntry;

            if (phMutex &&
                (ptProvider->dwTSPIOptions &
                    LINETSPIOPTION_NONREENTRANT))
            {
                if (!WaitForMutex(
                        ptProvider->hMutex,
                        phMutex,
                        pbDupedMutex,
                        ptProvider,
                        TPROVIDER_KEY,
                        INFINITE
                        ))
                {
                    lResult = LINEERR_OPERATIONFAILED;
                }
            }
        }

        break;
    }
    } // switch

    if (lResult)
    {
        goto LineProlog_exit;
    }


    //
    // Make sure that if caller wants a pointer to a TSPI proc that the
    // func is exported by the provider
    //

    if (ppfnTSPI_lineXxx &&
        !(*ppfnTSPI_lineXxx = ptProvider->apfn[dwTSPIFuncIndex]))
    {
        lResult = LINEERR_OPERATIONUNAVAIL;
        goto LineProlog_exit;
    }


    //
    // See if we need to alloc & init an ASYNCREQUESTINFO struct
    //

    if (ppAsyncRequestInfo)
    {
        PASYNCREQUESTINFO   pAsyncRequestInfo;


        if (!(pAsyncRequestInfo = ServerAlloc (sizeof(ASYNCREQUESTINFO))))
        {
            lResult = LINEERR_NOMEM;
            goto LineProlog_exit;
        }

        pAsyncRequestInfo->dwLocalRequestID = (DWORD) NewObject(
            ghHandleTable,
            pAsyncRequestInfo,
            NULL
            );

        if (pAsyncRequestInfo->dwLocalRequestID == 0)
        {
            ServerFree (pAsyncRequestInfo);
            lResult = LINEERR_NOMEM;
            goto LineProlog_exit;
        }

        pAsyncRequestInfo->dwKey    = TASYNC_KEY;
        pAsyncRequestInfo->ptClient = ptClient;

        pAsyncRequestInfo->InitContext = initContext;
        pAsyncRequestInfo->OpenContext = openContext;
        pAsyncRequestInfo->htXxx       = (dwArgType != DEVICE_ID ? htXxx :
            pAsyncRequestInfo->dwLocalRequestID);       // a +/- random #

        LOG((TL_INFO, "LineProlog: OpenContext %p", openContext));

        pAsyncRequestInfo->dwLineFlags = 1;

        if (dwRemoteRequestID)
        {
            lResult = pAsyncRequestInfo->dwRemoteRequestID = dwRemoteRequestID;
        }
        else
        {
            lResult = pAsyncRequestInfo->dwRemoteRequestID =
                pAsyncRequestInfo->dwLocalRequestID;
        }

        *ppAsyncRequestInfo = pAsyncRequestInfo;
    }

LineProlog_exit:

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "LineProlog: (line%s) exit, result=%s",
            pszFuncName,
            MapResultCodeToText (lResult, szResult)
            ));
    }
#else
    LOG((TL_TRACE,
        "LienProlog: exit, result = x%lx",
        lResult
        ));
#endif

    return lResult;
}


void
PASCAL
LineEpilogSync(
    LONG       *plResult,
    HANDLE      hMutex,
    BOOL        bCloseMutex,
    DWORD       ObjectToDereference
#if DBG
    ,char *pszFuncName
#endif
    )
{
    DereferenceObject (ghHandleTable, ObjectToDereference, 1);

    if (hMutex)
    {
        MyReleaseMutex (hMutex, bCloseMutex);
    }

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "LineEpilogSync: (line%s) exit, result=%s",
            pszFuncName,
            MapResultCodeToText (*plResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE, 
            "LineEpilogSync: exit, result=x%x",
            *plResult
            ));
#endif
}


void
PASCAL
LineEpilogAsync(
    LONG               *plResult,
    LONG                lRequestID,
    HANDLE              hMutex,
    BOOL                bCloseMutex,
    PASYNCREQUESTINFO   pAsyncRequestInfo,
    DWORD               ObjectToDereference
#if DBG
    ,char *pszFuncName
#endif
    )
{
    DereferenceObject (ghHandleTable, ObjectToDereference, 1);

    MyReleaseMutex (hMutex, bCloseMutex);

    if (lRequestID > 0)
    {
        if (*plResult <= 0)
        {
            if (*plResult == 0)
            {
                LOG((TL_ERROR, "Error: SP returned 0, not request ID"));
            }

            //
            // If here the service provider returned an error (or 0,
            // which it never should for async requests), so call
            // CompletionProcSP like the service provider normally
            // would, & the worker thread will take care of sending
            // the client a REPLY msg with the request result (we'll
            // return an async request id)
            //

            CompletionProcSP(
                pAsyncRequestInfo->dwLocalRequestID,
                *plResult
                );
        }
    }
    else if (pAsyncRequestInfo != NULL)
    {
        //
        // If here an error occured before we even called the service
        // provider, so just free the async request (the error will
        // be returned to the client synchronously)
        //

        DereferenceObject(
            ghHandleTable,
            pAsyncRequestInfo->dwLocalRequestID,
            1
            );
    }

    *plResult = lRequestID;

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "LineEpilogAsync: (line%s) exit, result=%s",
            pszFuncName,
            MapResultCodeToText (lRequestID, szResult)
            ));
    }
#else
        LOG((TL_TRACE,
            "LineEpilogAsyc: exit, result=x%lx",
            lRequestID
            ));
#endif
}


void
PASCAL
LineEventProc(
    HTAPILINE   htLine,
    HTAPICALL   htCall,
    DWORD       dwMsg,
    ULONG_PTR   Param1,
    ULONG_PTR   Param2,
    ULONG_PTR   Param3
    )
{
    LOG((TL_TRACE,  "LineEventProc"));

    switch (dwMsg)
    {
    case LINE_ADDRESSSTATE:
    case LINE_LINEDEVSTATE:
    case LINE_DEVSPECIFIC:
    case LINE_DEVSPECIFICFEATURE:
    case LINE_PROXYSTATUS:
    case LINE_AGENTSTATUS:
    {
        PTLINE  ptLine = (PTLINE)htLine;

        if (NULL == ptLine)
        {
            return;
        }

        if (dwMsg == LINE_LINEDEVSTATE  &&
                 htLine == 0  &&
                 Param1 & LINEDEVSTATE_REINIT)
        {
            SendReinitMsgToAllXxxApps();
        }
        else
        {
            SendMsgToLineClients(
                ptLine,
                NULL,
                dwMsg,
                DWORD_CAST(Param1,__FILE__,__LINE__),
                DWORD_CAST(Param2,__FILE__,__LINE__),
                DWORD_CAST(Param3,__FILE__,__LINE__)
                );
        }

        break;
    }
    case LINE_AGENTSPECIFIC:

        if (htCall)
        {
            SendMsgToCallClients(
                (PTCALL)htCall,
                NULL,
                LINE_AGENTSPECIFIC,
                DWORD_CAST(Param1,__FILE__,__LINE__),
                DWORD_CAST(Param2,__FILE__,__LINE__),
                DWORD_CAST(Param3,__FILE__,__LINE__)
                );

        }
        else
        {
            PTLINE  ptLine = (PTLINE)htLine;


            SendMsgToLineClients(
                ptLine,
                NULL,
                LINE_AGENTSPECIFIC,
                DWORD_CAST(Param1,__FILE__,__LINE__),
                DWORD_CAST(Param2,__FILE__,__LINE__),
                DWORD_CAST(Param3,__FILE__,__LINE__)
                );
        }

        break;

    case LINE_CLOSE:
    {
        PTLINE  ptLine = (PTLINE)htLine;
        DWORD   dwKey;

        try 
        {
            dwKey = ptLine->dwKey;
        }
        myexcept
        {
            dwKey = 0;
        }

        if (dwKey == TINCOMPLETELINE_KEY)
        {
            //
            // The device is in the process of getting opened but
            // the key has not been set & the Open() func still owns
            // the mutex and has stuff to do, so repost the msg
            // and try again later. (Set Param3 to special value
            // to indicate this repost, so EventProcSP doesn't recurse)
            //

            LineEventProcSP (htLine, 0, LINE_CLOSE, 0, 0, 0xdeadbeef);
        }
        else if (dwKey == TLINE_KEY)
        {
            DestroytLine (ptLine, TRUE); // unconditional destroy
        }

        break;
    }
    case LINE_CALLDEVSPECIFIC:
    case LINE_CALLDEVSPECIFICFEATURE:
    case LINE_CALLINFO:
    {
        PTCALL  ptCall = (PTCALL)htCall;

        if (NULL == htCall)
        {
            return;
        }

        switch (dwMsg)
        {
            case LINE_CALLDEVSPECIFIC:

                dwMsg = LINE_DEVSPECIFIC;
                break;

            case LINE_CALLDEVSPECIFICFEATURE:

                dwMsg = LINE_DEVSPECIFICFEATURE;
                break;

            case LINE_CALLINFO:
            {
                Param2 =
                Param3 = 0;

                if ((Param1 == LINECALLINFOSTATE_CALLID)  ||
                    (Param1 == LINECALLINFOSTATE_RELATEDCALLID))
                {
                    if ((WaitForExclusivetCallAccess (ptCall, TCALL_KEY)))
                    {
                        DWORD dwPreviousCallID = ptCall->dwCallID;


                        GetCallIDs (ptCall);

                        DoCallHubHashing (ptCall, dwPreviousCallID);

                        UNLOCKTCALL(ptCall);
                    }
                }
                break;
            }
        }

        SendMsgToCallClients(
            ptCall,
            NULL,
            dwMsg,
            DWORD_CAST(Param1,__FILE__,__LINE__),
            DWORD_CAST(Param2,__FILE__,__LINE__),
            DWORD_CAST(Param3,__FILE__,__LINE__)
            );

        break;
    }
    case LINE_MONITORDIGITS:
    case LINE_MONITORMEDIA:
    {
        PTCALL  ptCall = (PTCALL)htCall;

        if (NULL == htCall)
        {
            return;
        }

        SendMsgToCallClients(
            ptCall,
            NULL,
            dwMsg,
            DWORD_CAST(Param1,__FILE__,__LINE__),
            DWORD_CAST(Param2,__FILE__,__LINE__),
            (Param3 ? DWORD_CAST(Param3,__FILE__,__LINE__) : GetTickCount())
            );

        break;
    }
    case LINE_CALLSTATE:
    {
        BOOL            fastPrivilegeList[DEF_NUM_PTR_LIST_ENTRIES],
                        *pPrivilegeList = fastPrivilegeList;
        DWORD           i, j, dwNumUsedEntries = 0,
                        dwNumTotalEntries= DEF_NUM_PTR_LIST_ENTRIES;
        PTCALL          ptCall = (PTCALL)htCall;
        TPOINTERLIST    fastCallClientList,
                        *pCallClientList = &fastCallClientList;
        TPOINTERLIST    fastConfCallClientList,
                        *pConfCallClientList = NULL;

        LOG((TL_EVENT,  "LineEventProc: LINE_CALLSTATE event x%lx", Param1));


        if (WaitForExclusivetCallAccess (ptCall, TCALL_KEY))
        {
            PTCALLCLIENT    ptCallClient = ptCall->ptCallClients;
            ASYNCEVENTMSG   msg[2];


            if (Param1 == LINECALLSTATE_OFFERING)
            {
                ptCall->dwDrvCallFlags |= DCF_INCOMINGCALL;
                PerfBlock.dwCurrentIncomingCalls++;
                PerfBlock.dwTotalIncomingCalls++;
                PerfBlock.dwCurrentOutgoingCalls--;
                PerfBlock.dwTotalOutgoingCalls--;
            }

            if (ptCall->bAlertApps)
            {
                //
                // This is the first state msg we've received for an incoming
                // call.  We need to determine who owns & who monitors it,
                // and create the appropriate tCallClients
                //

                BOOL            bFindOwner;
                DWORD           dwMediaModes = (DWORD) Param3,
                                dwSPIVersion = ptCall->ptLine->dwSPIVersion,
                                dwAddressID;
                PTLINECLIENT    ptLineClientOwner;


                ptCall->bAlertApps = FALSE;


                //
                // If this is a remotesp call then Param2 points at a
                // DWORD array, the 1st entry of which is the "real"
                // Param2 for this message (i.e. the call state mode),
                // the 2nd entry of which is the original privilege for
                // this call, and the 3rd entry of which is htCall
                // (which we use for call verification purposes)
                //

                if (ptCall->ptProvider != pRemoteSP)
                {
                    bFindOwner = TRUE;
                }
                else
                {
                    BOOL        bBreak = FALSE;
                    PULONG_PTR  pdwRealParam2 = (PULONG_PTR) Param2,
                                pdwPrivilege = (((PULONG_PTR) Param2) + 1);
                    LPHTAPICALL phtCall = (LPHTAPICALL)
                                    (((LPDWORD) Param2) + 2);


                    try
                    {
                        Param2 = *pdwRealParam2;

                        bFindOwner = (*pdwPrivilege & LINECALLPRIVILEGE_OWNER ?
                            TRUE : FALSE);

                        bBreak = (*phtCall != htCall ? TRUE : FALSE);
                    }
                    myexcept
                    {
                        bBreak = TRUE;
                    }

                    if (bBreak)
                    {
                        UNLOCKTCALL(ptCall);
                        goto LINE_CALLSTATE_break;
                    }
                }


                //
                // Retrieve call's address id, etc
                //

                GetCallIDs (ptCall);

                dwAddressID = ptCall->dwAddressID;

                UNLOCKTCALL(ptCall);


                //
                // Add the UNKNOWN bit if >1 bit set
                // if version is <= 2.1

                if ( ( (dwSPIVersion <= TAPI_VERSION2_1) &&
                    !IsOnlyOneBitSetInDWORD (dwMediaModes) ) ||
                    dwMediaModes == 0)
                {
                    dwMediaModes |= LINEMEDIAMODE_UNKNOWN;
                }


                //
                // Try to find an owner.  If no owner found then destroy
                // the tCall.
                //

                if (bFindOwner)
                {
                    PTLINE  ptLine = (PTLINE)htLine;


                    if (!ptLine)
                    {
                        //
                        // Line closed
                        //

                        DestroytCall (ptCall);
                        goto LINE_CALLSTATE_break;
                    }

LINE_CALLSTATE_findOwner:

                    if ((ptLineClientOwner = GetHighestPriorityLineClient(
                            ptLine,
                            dwMediaModes,
                            dwAddressID
                            )))
                    {
                        LONG         lResult;
                        PTCALLCLIENT ptCallClientOwner;


                        if ((lResult = CreatetCallClient(
                                ptCall,
                                ptLineClientOwner,
                                LINECALLPRIVILEGE_OWNER,
                                TRUE,
                                FALSE,
                                &ptCallClientOwner,
                                TRUE

                            )) != 0)
                        {
                            if (lResult == LINEERR_INVALLINEHANDLE)
                            {
                                //
                                // The tLineClient was just closed, so jump
                                // up top & try to find another owner
                                //

                                goto LINE_CALLSTATE_findOwner;
                            }
                            else
                            {
                                //
                                // No mem, line closed, etc
                                //

                                DestroytCall (ptCall);
                                goto LINE_CALLSTATE_break;
                            }
                        }
                    }
                }
                else if (Param1 == LINECALLSTATE_UNKNOWN  &&
                         Param2 == 0xa5a5a5a5)
                {
                    //
                    // If here we're being called directly from
                    // remotesp!TSPI_lineGetID, who's being called
                    // by LGetNewCalls.  We're not going to look
                    // for an owner of this call, but if we don't
                    // find any monitors we still don't want to
                    // tear the call down, because we want to give
                    // a handle to the app doing the lineGetNewCalls
                    // (which may not have MONITOR privileges).
                    //
                    // So we do the following to prevent the call
                    // from getting destroyed.
                    //

                    ptLineClientOwner = (PTLINECLIENT) 1;
                    Param2 = 0;
                }
                else
                {
                    //
                    // Set ptLineClientOwner == NULL, becaue if there
                    // aren't any monitors we'll want to destroy this
                    // calls.
                    //

                    ptLineClientOwner = (PTLINECLIENT) NULL;
                }

                if (CreateCallMonitors (ptCall, TRUE) <= 0 &&
                    !ptLineClientOwner)
                {
                    DestroytCall (ptCall);
                    goto LINE_CALLSTATE_break;
                }

                if (!WaitForExclusivetCallAccess (ptCall, TCALL_KEY))
                {
                    goto LINE_CALLSTATE_break;
                }
            }


            //
            // NOTE: per bug #20545 we're no longer auto-dropping
            //       non-IDLE calls; figured this would be the wrong
            //       thing to do in a distributed system
            //
            //       dankn 02/15/96
            //


            //
            // SP-initiated conference
            //

            if (Param1 == LINECALLSTATE_CONFERENCED)
            {
                if (!ptCall->pConfList)
                {
                    PTCALL              ptConfCall = (PTCALL)Param2;
                    PTCONFERENCELIST    pConfList;


                    ptCall->pConfList = (LPVOID) LongToPtr(0xffffffff);

                    UNLOCKTCALL(ptCall);

                    if (WaitForExclusivetCallAccess(
                            ptConfCall,
                            TCALL_KEY
                            ))
                    {
                        if (!ptConfCall->pConfList)
                        {
                            if ((pConfList = ServerAlloc(
                                    sizeof (TCONFERENCELIST) +
                                        sizeof(PTCALL) *
                                        (DEF_NUM_CONF_LIST_ENTRIES - 1)
                                    )))
                            {
                                pConfList->dwKey = TCONFLIST_KEY;
                                pConfList->dwNumTotalEntries =
                                    DEF_NUM_CONF_LIST_ENTRIES;
                                pConfList->dwNumUsedEntries  = 1;

                                pConfList->aptCalls[0] = ptConfCall;

                                ptConfCall->pConfList = pConfList;
                            }
                        }

                        pConfList = ptConfCall->pConfList;

                        pConfCallClientList = &fastConfCallClientList;

                        if (GetCallClientListFromCall(
                                ptConfCall,
                                &pConfCallClientList

                                ) != 0)
                        {
                            pConfCallClientList = NULL;
                        }

                        UNLOCKTCALL(ptConfCall);
                    }
                    else
                    {
                        pConfList = NULL;
                    }

                    SetCallConfList (ptCall, pConfList, TRUE);

                    if (!WaitForExclusivetCallAccess (ptCall, TCALL_KEY))
                    {
                        if (pConfCallClientList  &&
                            pConfCallClientList != &fastConfCallClientList)
                        {
                            ServerFree (pConfCallClientList);
                        }

                        goto LINE_CALLSTATE_break;
                    }
                }
            }


            //
            // If call is a conference child and the call state has
            // changed then remove it from the conference
            //

            else if (ptCall->pConfList  &&
                     ptCall->pConfList != (PTCONFERENCELIST) LongToPtr(0xffffffff))
            {
                try
                {
                    if ( ptCall->pConfList->aptCalls[0] != ptCall)
                    {
                        SetCallConfList (ptCall, NULL, FALSE);
                    }
                }
                myexcept
                {
                }
            }


            //
            // Record the call state & mode
            //

            ptCall->dwCallState     = DWORD_CAST(Param1,__FILE__,__LINE__);
            ptCall->dwCallStateMode = (LINECALLSTATE_CONFERENCED==Param1?0:DWORD_CAST(Param2,__FILE__,__LINE__));


            //
            // Build a list of call clients & their bIndicatePrivilege
            // settings
            //

            if (GetCallClientListFromCall (ptCall, &pCallClientList) != 0)
            {
                //
                // If here we know there's at least a few entries
                // in the fastCallClientList (DEF_NUM_PTR_LIST_ENTRIES
                // to be exact), so we'll just work with that list
                // and at least get msgs out to a few clients
                //

                pCallClientList = &fastCallClientList;

                fastCallClientList.dwNumUsedEntries = DEF_NUM_PTR_LIST_ENTRIES;
            }

            dwNumUsedEntries = pCallClientList->dwNumUsedEntries;

            pPrivilegeList = (dwNumUsedEntries <= DEF_NUM_PTR_LIST_ENTRIES ?
                fastPrivilegeList :
                ServerAlloc (pCallClientList->dwNumUsedEntries * sizeof (BOOL))
                );

            if (!pPrivilegeList)
            {
                //
                // Same as above - make due with the stack bufs
                //

                pPrivilegeList = fastPrivilegeList;

                dwNumUsedEntries = DEF_NUM_PTR_LIST_ENTRIES;
            }

            for (i = 0; i < dwNumUsedEntries; i++)
            {
                ptCallClient = (PTCALLCLIENT) pCallClientList->aEntries[i];

                if ((pPrivilegeList[i] =
                        (BOOL) ptCallClient->bIndicatePrivilege))
                {
                    ptCallClient->bIndicatePrivilege = 0;
                }
            }


            //
            // It's now ok to unlock the tCall
            //

            UNLOCKTCALL(ptCall);


            //
            // Send the CALLSTATE msg to all the clients
            //

            msg->TotalSize = sizeof (ASYNCEVENTMSG) + sizeof(HCALLHUB);
            msg->Msg       = dwMsg;
            msg->Param1    = DWORD_CAST(Param1,__FILE__,__LINE__);

            for (i = 0; i < dwNumUsedEntries; i++)
            {
                ptCallClient = (PTCALLCLIENT) pCallClientList->aEntries[i];

                LOG((TL_INFO, "LineEventProc: i = [%d] corresponding ptCallClient [%p]", i, ptCallClient));

                try
                {
                    PTLINECLIENT    ptLineClient;
                    PTLINEAPP       ptLineApp;


                    LOG((TL_INFO, "LineEventProc: ptCallClient->ptLineClient[%p]", ptCallClient->ptLineClient));
                    ptLineClient = ptCallClient->ptLineClient;

                    LOG((TL_INFO, "LineEventProc: ptLineClient->ptLineApp[%p]", ptLineClient->ptLineApp));
                    ptLineApp    = ptLineClient->ptLineApp;

                    LOG((TL_INFO, "LineEventProc: setting msg->InitContext to ptLineApp[%p]->InitContext of [%p]", ptLineApp, ptLineApp->InitContext));
                    msg->InitContext = ptLineApp->InitContext;

                    msg->hDevice     = ptCallClient->hCall;

                    LOG((TL_INFO, "LineEventProc: setting msg->OpenContext to [%p]", ptLineClient->OpenContext));

                    msg->OpenContext = ptLineClient->OpenContext;

                    //
                    // REMOTESP HACK: indicate the hRemoteLine in p4
                    //

                    msg->Param4 = ptLineClient->hRemoteLine;

                    *((LPHCALLHUB)(&msg->Param4 + 1)) = 
                        (ptCallClient->ptCallHubClient)?
                            ptCallClient->ptCallHubClient->hCallHub : 
                            (HCALLHUB)0;

                    if (pPrivilegeList[i])
                    {
                        //
                        // We're presenting the app with a new call handle;
                        // for 2.0 & newer apps we indicate this with an
                        // APPNEWCALL msg, while older apps just get the
                        // privilege field set in the call state msg.
                        //

                        if (ptLineApp->dwAPIVersion >= TAPI_VERSION2_0)
                        {
                            ASYNCEVENTMSG   newCallMsg[2],
                                            *pNewCallMsg = newCallMsg;
                            PTCONFERENCELIST    pConfList;
                            BOOL                bConfParent = FALSE;

                            if (!FMsgDisabled(
                                ptCallClient->ptLineClient->ptLineApp->dwAPIVersion,
                                ptCallClient->adwEventSubMasks,
                                LINE_APPNEWCALL,
                                0
                                ))
                            {
                                pNewCallMsg->TotalSize   =
                                    sizeof (ASYNCEVENTMSG) + 3 * sizeof (DWORD);
                                pNewCallMsg->InitContext = msg->InitContext;
                                pNewCallMsg->hDevice     =
                                    ptLineClient->hRemoteLine;
                                pNewCallMsg->OpenContext = msg->OpenContext;
                                pNewCallMsg->fnPostProcessProcHandle = 0;
                                pNewCallMsg->Msg    = LINE_APPNEWCALL;
                                pNewCallMsg->Param1 = ptCall->dwAddressID;
                                pNewCallMsg->Param2 = ptCallClient->hCall;
                                pNewCallMsg->Param3 = ptCallClient->dwPrivilege;
                                *(&pNewCallMsg->Param4 + 1) = ptCall->dwCallID;
                                *(&pNewCallMsg->Param4 + 2) =
                                    ptCall->dwRelatedCallID;
                                if ((pConfList = ptCall->pConfList) &&
                                    (pConfList != (PTCONFERENCELIST) LongToPtr(0xffffffff)) &&
                                    (pConfList->aptCalls[0] == ptCall))
                                {
                                    bConfParent = TRUE;
                                }
                                *(&pNewCallMsg->Param4 + 3) = (DWORD) bConfParent;

                                if (ptCallClient->dwKey == TCALLCLIENT_KEY)
                                {
                                    LOG((TL_INFO, "LineEventProc: sending LINE_APPNEWCALL, ptClient[%p]", ptCallClient->ptClient));
                                    WriteEventBuffer(
                                        ptCallClient->ptClient,
                                        pNewCallMsg
                                        );
                                }
                            }

                            msg->Param3 = 0;
                        }
                        else
                        {
                            msg->Param3 = ptCallClient->dwPrivilege;
                        }
                    }
                    else
                    {
                        msg->Param3 = 0;
                    }

                    if (FMsgDisabled (
                        ptCallClient->ptLineClient->ptLineApp->dwAPIVersion,
                        ptCallClient->adwEventSubMasks,
                        (DWORD) msg->Msg,
                        (DWORD) msg->Param1
                        ))
                    {
                        continue;
                    }

                    //
                    // Another special case for LINECALLSTATE_CONFERENCED -
                    // try to find the corresponding hConfCall (on same
                    // tLineClient) so we can set Param2 per spec
                    //

                    if (Param1 == LINECALLSTATE_CONFERENCED)
                    {
                        BOOL    bDone = (pConfCallClientList ? FALSE : TRUE);


                        Param2 = 0;

                        while (!bDone)
                        {
                            try
                            {
                                for(
                                    j = 0;
                                    j < pConfCallClientList->dwNumUsedEntries;
                                    j++
                                    )
                                {
                                    PTCALLCLIENT    pConfCallClient;


                                    pConfCallClient = (PTCALLCLIENT)
                                        pConfCallClientList->aEntries[j];

                                    if (pConfCallClient  &&
                                        pConfCall